<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    Fortran95程序设计基础学习笔记 |  VincereZhou&#39;s blog
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/images/mojie.jpg" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

<link rel="alternate" href="/atom.xml" title="VincereZhou's blog" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Fortran95程序设计基础学习笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Fortran95程序设计基础学习笔记
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/posts/f06ad5f5/" class="article-date">
  <time datetime="2021-05-14T07:30:55.000Z" itemprop="datePublished">2021-05-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/Fortran/">Fortran</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">77.4k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">326 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>很多人都说，彭国伦老师的这本书是很经典的Fortran基础书籍。我看完了，感觉确实深入浅出，除了让我对Fortran语言有一定的了解，而且让我对一些计算机方面的基础概念更加清晰了。</p>
<p>但是如果仅仅针对 Fortran 而言，我可能以后不会考虑用Fortran写代码。我的理由很肤浅，Fortran 代码的可读性太差了，更别提之前版本的 goto 语法。如果让我看一个别人写的很长的 Fortran 代码，我觉得这是一种谋杀。</p>
<span id="more"></span>
<h1>准备工作</h1>
<p>运行fortran 需要编译器。我这里用的gfortran，在 linux 系统下运行，而且免费。</p>
<h2 id="安装gfortran">安装gfortran</h2>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yangle4695/article/details/51533770">https://blog.csdn.net/yangle4695/article/details/51533770</a></p>
<p>显示下面这条信息就说明安装好了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(base) [zhouziwen@ny ~]$ which gfortran</span><br><span class="line">/usr/bin/gfortran</span><br><span class="line">(base) [zhouziwen@ny ~]$ gfortran -v</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gfortran</span><br><span class="line">COLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/lto-wrapper</span><br><span class="line">Target: x86_64-redhat-linux</span><br><span class="line">Configured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzil                                                                                                                                la.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-                                                                                                                                zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-link                                                                                                                                er-hash-style=gnu --enable-languages=c,c++,objc,obj-c++,java,fortran,ada,go,lto --enable-plugin --enable-initfini-array -                                                                                                                                -disable-libgcj --with-isl=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/isl-install --with-cloog=/bui                                                                                                                                lddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/cloog-install --enable-gnu-indirect-function --with-tune=gen                                                                                                                                eric --with-arch_32=x86-64 --build=x86_64-redhat-linux</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>redhat 安装命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install gcc-gfortran</span><br></pre></td></tr></table></figure>
<h2 id="编译和链接">编译和链接</h2>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1tx411u7o4?p=2">https://www.bilibili.com/video/BV1tx411u7o4?p=2</a></p>
<p>编译文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gfortran -c hello.f90 -o fcode</span><br></pre></td></tr></table></figure>
<ul>
<li>-c 需要编译的文件</li>
<li>-o 结果文件（不提供，则生成 hello.o）</li>
</ul>
<p>链接（生成一个可执行文件）：拼接各代码的过程，是编译器检查代码完整性的过程。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gfortran 1.o 2.o 3.o -o 3body</span><br></pre></td></tr></table></figure>
<p>貌似这个命令能把三个绑在一起。</p>
<p><strong>编译和链接可以放在一起</strong></p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gfortran main.f90 sub.f90 func.f90 -o <span class="number">3</span>body</span><br></pre></td></tr></table></figure>
<h1>Fortran95 程序设计基础</h1>
<h1>3 Fortran 程序设计基础</h1>
<h2 id="3-1-字符集">3-1 字符集</h2>
<p>编写Fortran 程序时所能使用的所有字符和符号</p>
<ul>
<li>英文 26个字母：不分大小写</li>
<li>数字：0-9</li>
<li>特殊符号：22个<code>:=+-*/(),.'!&quot;%&amp;;&lt;&gt;?$_&quot;</code>  ，还有一个空格</li>
</ul>
<p>注意，<strong>Fortran 大小写不分</strong>，INTEGER 和 integer 是一样的</p>
<h2 id="3-2-书面格式">3-2 书面格式</h2>
<p>Fortran 有两种编写格式：Fixed Format 是旧的，不建议使用；建议全部使用 Free Format 格式。</p>
<h3 id="3-2-1-Fixed-Format">3-2-1 Fixed Format</h3>
<p>规定了程序代码每一行中每个字段的意义。第 7 - 72 个字符是可以编写程序的字段。每一行的前5个字符只能是空格或数字，数字用来作为”行代码“。每一行的第6个字符只能是空格或”0“以外的字符。</p>
<h3 id="3-2-2-Free-Format">3-2-2 Free Format</h3>
<p>不需要在每一行的开头预留空格。</p>
<p>注意事项</p>
<ol>
<li>叹号 ！后面都是注释</li>
<li>每一行可以编写 132 个字符</li>
<li>行号放在每行程序的最前面（这个我感觉不是必须的）</li>
<li>一行程序代码的最后符合如果是 &amp; ，代表下一行程序会和这一行连接。如果一行代码开头是 &amp; ，表示它会和上一行连接。</li>
</ol>
<h2 id="3-3-数据类型">3-3 数据类型</h2>
<h3 id="整数（integeral）">整数（integeral）</h3>
<p>又分为长整型（4个字节）和短整型（2个字节）</p>
<h3 id="浮点数（real）">浮点数（real）</h3>
<p>单精度（4个字节），双精度（8个字节）</p>
<h3 id="复数（complex）">复数（complex）</h3>
<h3 id="字符（character）">字符（character）</h3>
<h3 id="逻辑判断（logical）">逻辑判断（logical）</h3>
<p>true 和 false</p>
<h2 id="3-4-数学表达式">3-4 数学表达式</h2>
<blockquote>
<p>+  - * /</p>
<p>** :  幂运算</p>
<p>( ) : 优先计算</p>
</blockquote>
<p>注意事项:</p>
<ul>
<li>乘法不能省略: 不能写AB, 必须写 A*B</li>
</ul>
<h1>4 输入输出及声明</h1>
<h2 id="4-1-输入-write-输出-print-命令">4-1 输入(write)输出(print)命令</h2>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0401</span><br><span class="line">wirte(*,*) <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="keyword">stop</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Fortran 程序通常以 program 开头,后面接一个自定义的程序名称, 可以用文件名, 如果想不出来, 可以用 main 。</p>
<p>write 表示的作用就是显示后面双引号所包含的字符串。后面的两个星号都有各自的意义，第一个星号表示输出的位置使用默认值，也就是屏幕；第二个星号则表示不特别设置输出格式。</p>
<p>有两点注意：</p>
<ol>
<li>write 后会自动换行</li>
<li>如果要打印双引号，那么要写两次双引号。</li>
</ol>
<p><strong>Fortran90 可以使用双引号或单引号来封装字符串</strong></p>
<p>stop 是终止程序，可以出现在程序的任意一个位置。但是除非必要，不要把STOP使用在主程序结束之外的其他地方。因为有太多的终止点，容易出错。</p>
<p>其实这里不需要 stop，因为主程序已经运行完毕了。</p>
<p>end 是用来封装程序代码使用的，说明程序代码已经编写完毕。</p>
<p>print 也可以打印，下面这一句和 write 一样。</p>
<p>print 不接括号，且只有一个星号，表示不限定输出格式。print 只能打印到屏幕上。作者建议<strong>只使用write</strong>，因为之后如果想输出转移到文件中，write 改起来更方便。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print *,&quot;Hello&quot;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-声明">4-2 声明</h2>
<p>声明是指：在程序代码中，程序员向编译器要求预留一些存放数据的内存空间。</p>
<h3 id="4-2-1-整数类型（integeral）">4-2-1 整数类型（integeral）</h3>
<p>声明一个整型变量的描述如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> a</span><br></pre></td></tr></table></figure>
<p>但是，因为 a 定义为整型变量，因此如果计算结果有小数部分，都会被自动舍去</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">3</span>/<span class="number">2</span> <span class="comment">!A=1</span></span><br><span class="line">A = <span class="number">1</span>/<span class="number">2</span> <span class="comment">!A=0</span></span><br></pre></td></tr></table></figure>
<p>赋值为长整型和短整型的声明方法如下</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span>(<span class="keyword">kind</span>=<span class="number">4</span>) <span class="comment">!4个字节</span></span><br><span class="line"><span class="keyword">integer</span>(<span class="keyword">kind</span>=<span class="number">2</span>) <span class="comment">!2个字节</span></span><br></pre></td></tr></table></figure>
<p>如果想同时声明多个相同数据类型的变量可以写在一行，用逗号分隔</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> a,b,c</span><br></pre></td></tr></table></figure>
<p>命名规则：</p>
<ol>
<li>英文名称开头</li>
<li>不要和执行命令，主程序的名称，已声明的变量同名。</li>
</ol>
<p>Fortran90 在声明变量时，后面先写两个冒号</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a</span><br></pre></td></tr></table></figure>
<h3 id="4-2-2-浮点数（real">4-2-2 浮点数（real)</h3>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">real</span> a</span><br></pre></td></tr></table></figure>
<p>不加任何形容词时，通常会声明占用4个字节的 单精度浮点数。可以进一步准确声明，双精度更准确，但是会占用更多内存。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">4</span>) a</span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">8</span>) a</span><br></pre></td></tr></table></figure>
<p>改写上面的程序</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0407</span><br><span class="line">    <span class="keyword">real</span> :: a</span><br><span class="line">    a = <span class="number">2.5</span>+<span class="number">3.0</span>/<span class="number">2.0</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;2.5+3.0/2.0&quot;</span>,a</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里把 3 和 2 分别写成了 3.0 和 2.0 ，这是必要的操作，确保计算机在计算的时候按照”浮点数“来计算。</p>
<p>如果这里写成 <code>a=2.5+3/2</code> ，结果就会变成 3.5 。因为 3/2 会按照整型计算规则计算。</p>
<p>“有效位数“ 的 概念</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0408</span><br><span class="line">    <span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">4</span>) :: a,b</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">0.1</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a,<span class="string">&quot;+&quot;</span>,b,<span class="string">&quot;=&quot;</span>,a+b</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>我的输出结果如下（很奇怪，0.1最后为什么还有一个数字）</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.00000000</span>     +  <span class="number">0.100000001</span>     =   <span class="number">1.10000002</span></span><br></pre></td></tr></table></figure>
<p>如果改成 a = 1000000 , b= 0.1</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1000000.00</span>     +  <span class="number">0.100000001</span>     =   <span class="number">1000000.12</span></span><br></pre></td></tr></table></figure>
<p>和教科书不一样。</p>
<p>教科书上写单精度的有效数字是6-7位。为了避免有效数字带来的误差，可以使用双精度。</p>
<p><strong>双精度有高达15位的有效数字</strong>。</p>
<p>对单精度设定很大的数时，可以采用 <strong>1E10</strong>, <strong>2.5E23</strong> 这种格式。</p>
<p>对双精度设定很大的数时，可以采用 <strong>1D10</strong>, <strong>2.5D23</strong> 这种格式。</p>
<p>应用 Fortran 数学函数库</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0409</span><br><span class="line">    <span class="keyword">real</span> :: a</span><br><span class="line">    a = <span class="number">3.14159</span>/<span class="number">2.0</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;sin(&quot;</span>,a,<span class="string">&quot;)=&quot;</span>,<span class="built_in">sin</span>(a)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Fortran 中计算平方根，可以用乘幂得到；或者调用数学函数 SQRT完成</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">4.0</span>**<span class="number">0.5</span></span><br><span class="line">a=<span class="built_in">sqrt</span>(<span class="number">4.0</span>)</span><br></pre></td></tr></table></figure>
<p>开立方</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">8.0</span>**(<span class="number">1.0</span>/<span class="number">3.0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="4-2-3-复数（complex）">4-2-3 复数（complex）</h3>
<h3 id="4-2-4-字符及字符串（character）">4-2-4 字符及字符串（character）</h3>
<p>声明一个字符</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">character</span> a</span><br></pre></td></tr></table></figure>
<p>声明一个字符串，同时注明最大长度</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">character</span>(len=<span class="number">10</span>) a</span><br></pre></td></tr></table></figure>
<p>字符串赋值</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">&quot;hello&quot;</span></span><br><span class="line">a=<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">a=<span class="string">&quot;That&#x27;s right&quot;</span> <span class="comment">!用双引号封装时，里面任意使用单引号</span></span><br><span class="line">a=<span class="string">&#x27;That&#x27;</span><span class="string">&#x27;s right&#x27;</span> <span class="comment">!用单引号封装时，输出单引号时要连续使用两个单引号</span></span><br><span class="line">a=<span class="string">&quot;That&#x27;s &quot;</span><span class="string">&quot;right&quot;</span><span class="string">&quot;.&quot;</span> <span class="comment">!用双引号封装时，输出双引号也要连用两个双引号</span></span><br></pre></td></tr></table></figure>
<p>注意，Fortran 是变量名不区分大小写，但是字符串里的字符大小写是区分的，因为这是数据。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0412</span><br><span class="line">    <span class="keyword">character</span> a</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">10</span>) b</span><br><span class="line">    a = <span class="string">&#x27;H&#x27;</span></span><br><span class="line">    b = <span class="string">&#x27;ello&#x27;</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a,b</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br></pre></td></tr></table></figure>
<p>字符串可以一次只改变其中的几个字符（报错，我估计不能修改）</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0413</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) string</span><br><span class="line">    string = <span class="string">&quot;Good morning.&quot;</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) string</span><br><span class="line">    string(<span class="number">6</span>) = <span class="string">&quot;evening.&quot;</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) string</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">EX0413.F90:<span class="number">6.21</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(*,*) string(<span class="number">6</span>)</span><br><span class="line">                     <span class="number">1</span></span><br><span class="line">Error: Syntax error <span class="keyword">in</span> <span class="built_in">WRITE</span> statement at (<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>切片可以</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write</span>(*,*) string(<span class="number">1</span>:<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>拼接字符串</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0414</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">6</span>) first</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">10</span>) second</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) add</span><br><span class="line">    first = <span class="string">&quot;Happy&quot;</span></span><br><span class="line">    second = <span class="string">&quot;Birthday&quot;</span></span><br><span class="line">    add = first//second <span class="comment">!两个连续的/表示拼接</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) add</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Happy Birthday</span><br></pre></td></tr></table></figure>
<p>其他函数</p>
<table>
<thead>
<tr>
<th>char(num)</th>
<th>返回ASCII表上数字num表示的字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>ichar(num)</td>
<td>返回字符在ASCII表上的编号</td>
</tr>
<tr>
<td>len(string)</td>
<td>返回输入字符串的<strong>声明</strong>长度</td>
</tr>
<tr>
<td>len_trim(string)</td>
<td>返回字符串去除尾端空格后的实际空格长度</td>
</tr>
<tr>
<td>index(string, key)</td>
<td>返回 key 子字符串在string中第一次出现的位置（索引应该是从1开始）</td>
</tr>
<tr>
<td>trim(string)</td>
<td>返回把string 字符串尾端多余空格清除过后的字符串</td>
</tr>
</tbody>
</table>
<h3 id="4-2-5-逻辑变量（logical">4-2-5 逻辑变量（logical)</h3>
<p>声明变量</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logical</span> a</span><br><span class="line">a = .true. <span class="comment">!前后有两个点</span></span><br><span class="line">a = .false. </span><br></pre></td></tr></table></figure>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0416</span><br><span class="line">    <span class="keyword">logical</span> a,b</span><br><span class="line">    a = .true.</span><br><span class="line">    b = .false.</span><br><span class="line">    <span class="built_in">write</span>(*,*) a,b</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果只打印 T F</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T F</span><br></pre></td></tr></table></figure>
<h2 id="4-3-输入命令（read）">4-3 输入命令（read）</h2>
<p>通过键盘输入</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0417</span><br><span class="line">    <span class="keyword">integer</span> a </span><br><span class="line">    read(*,*) a</span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>read 命令中第一个*号表示使用默认的设备（键盘），第二个*号表示不指定输入格式。</p>
<p>同一行输入多个值（以空格或逗号分隔，或者每输入一个数按一次enter）</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0418</span><br><span class="line">    <span class="keyword">real</span> a,b,c</span><br><span class="line">    read(*,*) a,b,c</span><br><span class="line">    <span class="built_in">write</span>(*,*) a+b+c</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>如果需要输入字符串，字符串中间如果有空格，会被截断，视为两个字符串</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0419</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) a</span><br><span class="line">    read(*,*) a</span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(base) [zhouziwen@ny gfortran]$ ./ex0419</span><br><span class="line">Happy Birthday <span class="comment">!输入</span></span><br><span class="line"> Happy <span class="comment">!输出</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解决办法是不要用默认的格式读取数据，这是需要格式化输入输出的原因之一。</p>
<h2 id="4-4-格式化输入输出（format）">4-4 格式化输入输出（format）</h2>
<p>格式化输入输出的用处</p>
<ol>
<li>美观</li>
<li>有时读取数据必须要格式化输入</li>
</ol>
<h3 id="4-4-1-格式化输出概论">4-4-1 格式化输出概论</h3>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0420</span><br><span class="line">    <span class="keyword">integer</span> a</span><br><span class="line">    a = <span class="number">100</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="number">100</span>) a <span class="comment">!使用行代码100的地方设置的格式来输出变量a</span></span><br><span class="line">    <span class="number">100</span> <span class="keyword">format</span>(I4) <span class="comment">!最前面的100是行代码</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面这个程序只会使用4个字符宽来输出整数。</p>
<p>通过使用相同的行代码，第四行的数字会通过第五行的格式输出，其中 I4 是说用4列来显示整数a的数值。</p>
<p>fortran 90 只要在每一行的开头设置一个数字，就能取一个行代码。</p>
<p>下面是格式化输出的例子， 1X 应该是输出右跳过1个位置（就是说从第二个位置输出，默认前面存在一个空格）</p>
<p>这种就不需要用什么行代码了，相比之下我也喜欢这种方式。</p>
<p>好处有：</p>
<ol>
<li>减少行数</li>
<li>提高代码可读性。不用向上面那样还要找format语句行。</li>
<li>避免在程序中使用行号</li>
</ol>
<p>缺点是</p>
<ol>
<li>输出格式很麻烦时，编写复杂</li>
<li>在不同的地方使用相同的输出格式时，程序代码会重复（这个我不觉得是缺点，相比于代码重复，可读性更重要）</li>
</ol>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0421</span><br><span class="line">    <span class="keyword">integer</span> a </span><br><span class="line">    <span class="keyword">real</span> b</span><br><span class="line">    <span class="keyword">complex</span> c</span><br><span class="line">    <span class="keyword">logical</span> d</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) e</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    b = <span class="number">12.34</span></span><br><span class="line">    c = (<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    d = .true.</span><br><span class="line">    e = <span class="string">&quot;Fortran&quot;</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(1X,I5)&quot;</span>) a <span class="comment">!用I来格式化整数</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(1X,F5.2)&quot;</span>) b <span class="comment">!用F来格式化浮点数</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(1X,F4.1,F4.1)&quot;</span>) c <span class="comment">!complex</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(1X,L3)&quot;</span>) d <span class="comment">!用L来输出logical</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(1X,A10)&quot;</span>) e <span class="comment">!用A来输出字符串</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(1x,a10)&quot;</span>) e <span class="comment">!a也可以</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有些时候，用 Format 也有好处，只是位置不能乱放，不然代码会很难阅读，要&quot;跳跃式阅读&quot;。（这个我在python中也感觉到了，有些人封装一堆函数，在阅读代码主体的时候，时不时就要去上面翻函数的内容）</p>
<h3 id="4-4-2-详述格式化输出">4-4-2 详述格式化输出</h3>
<p>常用的格式化输出的控制字符有5个</p>
<p>整数格式化：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0422</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(i5)&quot;</span>) <span class="number">100</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(i3)&quot;</span>) <span class="number">10000</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(i5.3)&quot;</span>) <span class="number">10</span> <span class="comment">!固定使用5个字符，至少输出3个数字</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">100</span></span><br><span class="line">***     <span class="comment">!设置的长度低于真实字符长度，输出星号作为警告</span></span><br><span class="line">  <span class="number">010</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>格式化浮点数</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0422_2</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(f9.3)&quot;</span>) <span class="number">123.45</span> <span class="comment">!总共9个字符宽(不足左边补空格)，其中小数部分占3个字符宽（不足补0）</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(e15.7)&quot;</span>) <span class="number">123.45</span> <span class="comment">!用科学计数法，使用15个字符宽，其中小数部分占7个字符宽</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(e9.2e3)&quot;</span>) <span class="number">12.34</span> <span class="comment">!指数部分有3位数字</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">123.450</span> <span class="comment">!不足9位，补三个空格</span></span><br><span class="line">  <span class="number">0.1234500E+03</span> <span class="comment">!总字符长度（包括后面的E+03）不足15位补空格，小数部分不足7位补0</span></span><br><span class="line"><span class="number">0.12E+002</span> <span class="comment">!指数部分不足补0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>字符串格式化</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0422_3</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(a10)&quot;</span>) <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(a3)&quot;</span>) <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">     Hello</span><br><span class="line">Hel <span class="comment">!如果设定的长度低于真实长度，会自动截取</span></span><br></pre></td></tr></table></figure>
<p>输出的位置向右移动</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0422_4</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(5x,i3)&quot;</span>) <span class="number">100</span> <span class="comment">!向右移动5位</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>换行输出 /</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0422_4</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(i3//i3)&quot;</span>) <span class="number">10</span>,<span class="number">10</span> <span class="comment">!中间两个空行</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>输出结果只有一个空行，和书上不一样</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重复地以相同的格式输出数据</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0423</span><br><span class="line">    <span class="keyword">real</span> a,b,c</span><br><span class="line">    a = <span class="number">1.0</span></span><br><span class="line">    b = <span class="number">2.0</span></span><br><span class="line">    c = <span class="number">3.0</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(3(1xf5.2))&quot;</span>) a,b,c</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.00</span>  <span class="number">2.00</span>  <span class="number">3.00</span>、</span><br></pre></td></tr></table></figure>
<p>格式设置的字符串中，还可以放进固定要输出的字符串。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0424</span><br><span class="line">	<span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;3+4=&#x27;,i1)&quot;</span>) <span class="number">3</span>+<span class="number">4</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>+<span class="number">4</span>=<span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>另外，也可以把输出格式单独提取出来，放在一个字符串变量中。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0425</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">10</span>) fmtstring</span><br><span class="line">    fmtstring = <span class="string">&quot;(i2)&quot;</span></span><br><span class="line">    <span class="built_in">write</span>(*,fmtstring) <span class="number">3</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>这种方法的好处是，可以动态地改变输出格式。</p>
<p>输入数据一般不需要设置输入格式，除非输入数据<strong>存在空格</strong>。下面的程序可以读入长度在80字符内，包含任何字符（包括空格和逗号）的字符串。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0426</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) string</span><br><span class="line">    read(*,<span class="string">&quot;(a80)&quot;</span>) string</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(a80)&quot;</span>) string</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-5-声明的其他事项">4-5 声明的其他事项</h2>
<h3 id="4-5-1-变量名称的取名策略">4-5-1 变量名称的取名策略</h3>
<p>英文开头，下划线连接（这个应该所有语言通用）</p>
<h3 id="4-5-2-implicit-命令">4-5-2 implicit 命令</h3>
<p>Fortran 标准中有一项不好的功能，它的变量不一定要经过程序的声明才能使用，编译器会根据变量名称的第一个字母来自动决定这个变量的类型。来看一个实例。</p>
<p>下面这两个数字 fa, fb 没有经过定义就直接用了。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0427</span><br><span class="line">    read(*,*) fa, fb</span><br><span class="line">    <span class="built_in">write</span>(*,*) fa+fb</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>建议不要这么做，理由如下：</p>
<ol>
<li>先定义变量再使用，才能明白地了解程序执行时的内存使用情况。</li>
<li>变量如果不经声明就使用，很容易发生“人为错误”。</li>
</ol>
<p>举一个错误的实例</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0428</span><br><span class="line">    i = <span class="number">123</span> +<span class="number">321</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;123+321=&#x27;, i4)&quot;</span>) j</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span>+<span class="number">321</span>=   <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这里本来要输出 i，但是由于<strong>打错字</strong>，写成了 j 。由于 j 没有设定任何数值，所以会输出0来。</p>
<p>作者建议，在声明前，都加上 <code>implicit none</code> 这个描述（这个命令要放在program 一行的后面，也就是第二行）</p>
<p>implicit 命令的功能是用来设置“默认类型”（即Fortran 不经过声明，由第一个字母来决定变量类型）。</p>
<p>修改 ex0428</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0428</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    i = <span class="number">123</span> +<span class="number">321</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;123+321=&#x27;, i4)&quot;</span>) j</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译报错</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EX0428.F90:<span class="number">3.5</span>:</span><br><span class="line"></span><br><span class="line">    i = <span class="number">123</span> +<span class="number">321</span></span><br><span class="line">     <span class="number">1</span></span><br><span class="line">Error: Symbol <span class="string">&#x27;i&#x27;</span> at (<span class="number">1</span>) has no <span class="keyword">IMPLICIT</span> <span class="keyword">type</span></span><br><span class="line">EX0428.F90:<span class="number">4.34</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;123+321=&#x27;, i4)&quot;</span>) j</span><br><span class="line">                                  <span class="number">1</span></span><br><span class="line">Error: Symbol <span class="string">&#x27;j&#x27;</span> at (<span class="number">1</span>) has no <span class="keyword">IMPLICIT</span> <span class="keyword">type</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-5-3-常数的声明方法（parameter）">4-5-3 常数的声明方法（parameter）</h3>
<p>常数：固定不变的数</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0429</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> pi</span><br><span class="line">    <span class="keyword">parameter</span>(pi=<span class="number">3.14159</span>)</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(f4.2)&quot;</span>) <span class="built_in">sin</span>(pi/<span class="number">6</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.50</span></span><br></pre></td></tr></table></figure>
<p>设定为 parameter 后，不能再更改，不然会报错。</p>
<p>事实上，声明不声明常量，对结果没有影响。但是声明常量还是有他的价值。</p>
<ol>
<li>设置后常数后，再更改会报错，因此会降低错误发生的机会。</li>
<li>把不会改变内容的变量都设置成常数，可以增加程序执行的速度。</li>
</ol>
<p>fortran90 上面两行可以合并</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: pi=<span class="number">3.14159</span> </span><br></pre></td></tr></table></figure>
<h3 id="4-5-4-设置变量的初值">4-5-4 设置变量的初值</h3>
<p>Fortran90 可以在声明变量时直接设置初值，注意不能省略中间的两个冒号。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0430</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">real</span> :: b = <span class="number">2.0</span></span><br><span class="line">    <span class="keyword">complex</span> :: c = (<span class="number">1.0</span>, <span class="number">2.0</span>)</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: str = <span class="string">&quot;Fortran 90&quot;</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a,b,c,str</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-5-5-等价声明（equivalence）">4-5-5 等价声明（equivalence）</h3>
<p>把两个以上的变量，声明它们使用同一个内存地址，就是“等价声明”。使用同一个内存位置的变量，只要改变其中的一个变量，就会同时改变其他变量的数值，因为它们都占用同一块内存。</p>
<p>等价声明的方法如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> a,b</span><br><span class="line"><span class="keyword">equivalence</span>(a,b)</span><br></pre></td></tr></table></figure>
<p>用处：</p>
<ol>
<li>节省内存</li>
<li>精简代码（相当于起了一个短的别名）</li>
</ol>
<h3 id="4-5-6-声明在程序中的结构">4-5-6 声明在程序中的结构</h3>
<p>变量需要先声明，才能赋值处理</p>
<h2 id="4-6-混合运算">4-6 混合运算</h2>
<p>“混合运算” 指的是比如一个整数加一个浮点数。因此需要先进行类型转换。</p>
<p>编译器会自动做一些类型转换的工作，但不一定对。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0431</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">integer</span> :: b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">real</span> :: c</span><br><span class="line">    c = a/b <span class="comment">!这里由于a,b是整数 a/b = 0</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(f5.2)&quot;</span>) c</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.00</span></span><br></pre></td></tr></table></figure>
<p>本来 c = 1/2 ，应该得到结果是 0.5。如果要获得正确答案，改写如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0432</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a=<span class="number">1</span></span><br><span class="line">    <span class="keyword">integer</span> :: b=<span class="number">2</span></span><br><span class="line">    <span class="keyword">real</span> :: c</span><br><span class="line">    c = <span class="keyword">real</span>(a)/<span class="keyword">real</span>(b) <span class="comment">!先进行类型转换</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(f5.2)&quot;</span>) c</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.50</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过 int() 函数将浮点数转化为整数，但是一般这个编译器可以自动地正确地进行类型转换。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0433</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a=<span class="number">1</span></span><br><span class="line">    <span class="keyword">real</span> :: b=<span class="number">2</span></span><br><span class="line">    <span class="keyword">real</span> :: c </span><br><span class="line">    c = a <span class="comment">!整数设置给浮点数地操作会自动转型</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(f5.2)&quot;</span>) c</span><br><span class="line">    c=a/b <span class="comment">!除数和被除数类型不同，结果会以浮点数来表示</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(f5.2)&quot;</span>) c</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.00</span></span><br><span class="line"><span class="number">0.50</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里编译器自动转换是对的，但是为了确保不发生意外，最好是自己手动转换。</p>
<h2 id="4-7-Fortran90-的自定义数据类型">4-7 Fortran90 的自定义数据类型</h2>
<p>我们可以把多个基本数据来创建一个自定义数据类型。</p>
<p>比如我们把一个人的姓名，年龄，身高等信息合并到一起，组成一个 “person” 的数据类型。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0434</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="comment">!开始创建 person 这个类型</span></span><br><span class="line"><span class="keyword">type</span> :: person</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">30</span>) :: <span class="keyword">name</span> </span><br><span class="line">    <span class="keyword">integer</span> :: age</span><br><span class="line">    <span class="keyword">integer</span> :: height</span><br><span class="line">    <span class="keyword">integer</span> :: weight </span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) :: address</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span> person</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>(person) :: a <span class="comment">!声明一个person变量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;name:&quot;</span></span><br><span class="line">read(*,*) a%<span class="keyword">name</span> <span class="comment">!变量和元素以%分隔</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;age:&quot;</span></span><br><span class="line">read(*,*) a%age</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;height:&quot;</span></span><br><span class="line">read(*,*) a%height</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;weight:&quot;</span></span><br><span class="line">read(*,*) a%weight</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;address:&quot;</span></span><br><span class="line">read(*,<span class="string">&quot;(a80)&quot;</span>) a%address</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="number">100</span>) a%<span class="keyword">name</span>, a%age, a%height, a%weight</span><br><span class="line"><span class="number">100</span> <span class="keyword">format</span>(/,<span class="string">&quot;Name:&quot;</span>, a10/, <span class="string">&quot;age:&quot;</span>, i3/, <span class="string">&quot;height:&quot;</span>, i3/, <span class="string">&quot;weight:&quot;</span>, i3, <span class="string">&quot;address:&quot;</span>, a50 )</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">name</span>:</span><br><span class="line">zhouziwen</span><br><span class="line"> age:</span><br><span class="line"><span class="number">18</span></span><br><span class="line"> height:</span><br><span class="line"><span class="number">175</span></span><br><span class="line"> weight:</span><br><span class="line"><span class="number">50</span></span><br><span class="line"> address:</span><br><span class="line">jx</span><br><span class="line"></span><br><span class="line"><span class="keyword">Name</span>:zhouziwen</span><br><span class="line">age: <span class="number">18</span></span><br><span class="line">height:<span class="number">175</span></span><br><span class="line">weight: <span class="number">50</span>address:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以一次设置所有元素</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = person(<span class="string">&quot;peter&quot;</span>, <span class="number">20</span>, <span class="number">170</span>, <span class="number">60</span>,<span class="string">&quot;Taiwan&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="4-8-kind-的使用">4-8 kind 的使用</h2>
<p>kind 是声明变量所占用的内存大小，主要是根据计算时所要使用到的有效位数以及值域范围。各类变量所保存的值域范围如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span>(<span class="keyword">kind</span>=<span class="number">1</span>)  -<span class="number">128</span> ~ <span class="number">127</span></span><br><span class="line"><span class="keyword">integer</span>(<span class="keyword">kind</span>=<span class="number">2</span>)  -<span class="number">32768</span> ~ <span class="number">32767</span></span><br><span class="line"><span class="keyword">integer</span>(<span class="keyword">kind</span>=<span class="number">4</span>)  -<span class="number">2147483648</span> ~ <span class="number">2147483647</span></span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">4</span>)     ±<span class="number">1.18</span>*<span class="number">10</span>^-<span class="number">38</span> ~ ±<span class="number">3.40</span>*<span class="number">10</span>^<span class="number">38</span></span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">8</span>)     ±<span class="number">2.23</span>*<span class="number">10</span>^-<span class="number">308</span> ~ ±<span class="number">1.79</span>*<span class="number">10</span>^<span class="number">308</span></span><br></pre></td></tr></table></figure>
<p>根据取值范围判断需要的kind值（感觉没啥用）</p>
<p>哦哦，果然，作者解释了。主要原因是想在不同的机器上保存同样位数的数值，所使用的 kind 值不一定相同。而且不同的机器所能保存的值域范围也可能不太一样。这里所指的不同机器，是指“等级不同” 的机器，例如工作站和个人计算机之间。</p>
<p>说白了，就是方便程序在不同机器之间移植（目前感觉不到）。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0435</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="comment">!判断可以记录9个位数的整数kind值</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: long_int = <span class="built_in">selected_int_kind</span>(<span class="number">9</span>)</span><br><span class="line"><span class="comment">!判断可以记录3个位数的整数kind值</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: short_int = <span class="built_in">selected_int_kind</span>(<span class="number">3</span>)</span><br><span class="line"><span class="comment">!判断可以有10个有效位数，指数可以记录到50的浮点数kind值</span></span><br><span class="line"><span class="comment">!第一个数字表示需要的最大的十进制位数（10的多少次方），第二个数字表示最小的有效数字</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: long_real = <span class="built_in">selected_real_kind</span>(<span class="number">10</span>,<span class="number">50</span>)</span><br><span class="line"><span class="comment">!判断可以有3个有效位数，指数可以记录到3的浮点数kind值</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: short_real = <span class="built_in">selected_real_kind</span>(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">integer</span>(<span class="keyword">kind</span>=long_int) :: a = <span class="number">12345678</span></span><br><span class="line"><span class="keyword">integer</span>(<span class="keyword">kind</span>=short_int) :: b = <span class="number">12</span></span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=long_real) :: c = <span class="number">1.23456789D45</span></span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=short_real) :: d = <span class="number">1230</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(i3,1x,i10)&quot;</span>) long_int, a</span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(i3,1x,i10)&quot;</span>) short_int, b</span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(i3,1x,e10.5)&quot;</span>) long_real, c</span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(i3,1x,e10.5)&quot;</span>) short_real, d</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>   <span class="number">12345678</span></span><br><span class="line"><span class="number">2</span>         <span class="number">12</span></span><br><span class="line"><span class="number">8</span> <span class="number">.12346E+46</span></span><br><span class="line"><span class="number">4</span> <span class="number">.12300E+04</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>除了在声明的时候指定字符宽度，设置数值时同样可以赋值数字所使用的 KIND 值类型，但这不常用，例子如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0436</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">4</span>) :: a</span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">8</span>) :: b</span><br><span class="line">a = <span class="number">1.0_4</span> <span class="comment">!确保使用单精度</span></span><br><span class="line">b = <span class="number">1.0_8</span> <span class="comment">!确保使用双精度</span></span><br><span class="line"><span class="built_in">write</span>(*,*) a,b</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.00000000</span>       <span class="number">1.0000000000000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-9-习题">4-9 习题</h2>
<p>1 输出字符串</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0437</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Have a good time&quot;</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;That&#x27;s not bad&quot;</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot; &quot;</span><span class="string">&quot;Mary&quot;</span><span class="string">&quot; isn&#x27;t my name.&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Have a good time</span><br><span class="line">That<span class="string">&#x27;s not bad</span></span><br><span class="line"><span class="string"> &quot;Mary&quot; isn&#x27;</span>t my <span class="keyword">name</span>.</span><br></pre></td></tr></table></figure>
<p>2 计算圆的面积</p>
<p>下面这种，把parameter 放在 read 后面会报错。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0438</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> radius,area</span><br><span class="line">    <span class="keyword">real</span> pi</span><br><span class="line">    read(*,*) radius</span><br><span class="line">    <span class="keyword">parameter</span>(pi=<span class="number">3.14159</span>)</span><br><span class="line">    area = pi*(radius**<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(f9.3)&quot;</span>) area</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>报错如下</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EX0438.F90:<span class="number">6.25</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span>(pi=<span class="number">3.14159</span>)</span><br><span class="line">                         <span class="number">1</span></span><br><span class="line">Error: Unexpected <span class="keyword">PARAMETER</span> statement at (<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>调整顺序后如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0438</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> radius,area,pi</span><br><span class="line">    <span class="keyword">parameter</span>(pi=<span class="number">3.14159</span>)</span><br><span class="line">    read(*,*) radius</span><br><span class="line">    area = pi*(radius**<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(f9.3)&quot;</span>) area</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line">   <span class="number">12.566</span></span><br></pre></td></tr></table></figure>
<p>3 调整成绩，对输入值平方后乘以10</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0438</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> old_num, new_num</span><br><span class="line">    read(*,*) old_num</span><br><span class="line">    new_num = <span class="number">10</span>*(old_num**<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(f9.3)&quot;</span>) new_num</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line">   <span class="number">40.000</span></span><br></pre></td></tr></table></figure>
<p>4 请问下面程序的输出结果是什么</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0440</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> a,b</span><br><span class="line"><span class="keyword">real</span> ra,rb</span><br><span class="line">a=<span class="number">2</span></span><br><span class="line">b=<span class="number">3</span></span><br><span class="line">ra=<span class="number">2.0</span></span><br><span class="line">rb=<span class="number">3.0</span></span><br><span class="line"><span class="built_in">write</span>(*,*) b/a</span><br><span class="line"><span class="built_in">write</span>(*,*) rb/ra</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>应该是 1 1.5</p>
<p>输出结果如下</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">        <span class="number">1</span></span><br><span class="line"><span class="number">1.50000000</span></span><br></pre></td></tr></table></figure>
<p>5 自定义类型，定义一个新的类型 distance 。有 3个浮点数的元素，分别以米、厘米、英寸为单位来记录同一段长度。请编写一个程序，程序会以米为单位来读入一段长度，并自动计算其他单位的数值。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0441</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="comment">!创建distance这个类型</span></span><br><span class="line"><span class="keyword">type</span> :: distance</span><br><span class="line">    <span class="keyword">real</span> :: meter</span><br><span class="line">    <span class="keyword">real</span> :: centimeter</span><br><span class="line">    <span class="keyword">real</span> :: inch</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span> distance</span><br><span class="line"><span class="comment">!声明一个distance变量</span></span><br><span class="line"><span class="keyword">type</span>(distance) :: a</span><br><span class="line"><span class="comment">!输入米</span></span><br><span class="line"><span class="keyword">real</span> b</span><br><span class="line">read(*,*) b</span><br><span class="line"></span><br><span class="line">a%meter = b</span><br><span class="line">a%centimeter = <span class="number">100</span>*b</span><br><span class="line">a%inch = <span class="number">100</span>*b/<span class="number">2.54</span></span><br><span class="line"><span class="built_in">write</span>(*,*) a</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">   <span class="number">1.00000000</span>       <span class="number">100.000000</span>       <span class="number">39.3700790</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>5 流程控制与逻辑运算</h1>
<h2 id="5-1-if-语句">5-1 if 语句</h2>
<p>基本语句</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (逻辑判断式) <span class="keyword">then</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ……</span><br><span class="line">    ……</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br></pre></td></tr></table></figure>
<p>用 if 来试着写一个警告车速过快的程序。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0501</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">4</span>) :: speed</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;speed:&quot;</span> </span><br><span class="line">read(*,*) speed</span><br><span class="line"><span class="keyword">if</span> ( speed &gt; <span class="number">100.0</span> ) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Slow down.&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> speed:</span><br><span class="line"><span class="number">120</span></span><br><span class="line"> Slow down.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>写一个小程序，如果一个人的体重大于身高减去100后得到的数值，代表这个人超重。</p>
<p>注意，一样需要有缩进，不然难以阅读。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0502</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">4</span>) :: height </span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">4</span>) :: weight</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;height:&quot;</span></span><br><span class="line">read(*,*) height</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;weight:&quot;</span></span><br><span class="line">read(*,*) weight</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( weight &gt; height - <span class="number">100</span> ) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Too fat&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Under control&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> height:</span><br><span class="line"><span class="number">170</span></span><br><span class="line"> weight:</span><br><span class="line"><span class="number">50</span></span><br><span class="line"> Under control</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-1-2-逻辑运算">5-1-2 逻辑运算</h3>
<p>Fortran90 的逻辑运算符共有以下几种：</p>
<ul>
<li><code>==</code> :  是否相等</li>
<li><code>/=</code> :  是否不相等</li>
<li><code>&gt;</code></li>
<li><code>&gt;=</code></li>
<li><code>&lt;</code></li>
<li><code>&lt;=</code></li>
</ul>
<p>相互关系之间的集合运算符号</p>
<ul>
<li><code>.and.</code>  : 两个表达式均成立</li>
<li><code>.or.</code></li>
<li><code>.not.</code></li>
<li><code>.eqv.</code> ： 两边表达式的逻辑运算结果相同时，整个表达式就成立</li>
<li><code>.neqv.</code>： 两边表达式的逻辑运算结果不同时，整个表达式就成立</li>
</ul>
<p>大于小于等式的运算符号优先级高于集合运算符号，例子如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((a&gt;=<span class="number">80</span>) .and. (a&lt;<span class="number">90</span>)) <span class="keyword">then</span></span><br></pre></td></tr></table></figure>
<p>判断如果风势超过10级或是降雨量超过500厘米，就停止上班上课</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0503</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span> </span><br><span class="line"><span class="keyword">integer</span> rain, windspeed</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Rain:&quot;</span></span><br><span class="line">read(*,*) rain</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Wind:&quot;</span></span><br><span class="line">read(*,*) windspeed</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( rain&gt;=<span class="number">500</span> .or. windspeed &gt;=<span class="number">10</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;停止上班上课&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;照常上班上课&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> Rain:</span><br><span class="line"><span class="number">100</span></span><br><span class="line"> Wind:</span><br><span class="line"><span class="number">8</span></span><br><span class="line"> 照常上班上课</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 if 时，可以先把逻辑运算的结果存放在逻辑变量中，再利用逻辑变量来做条件判断。利用这个方法把程序 ex0503 改写如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0504</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> rain, windspeed</span><br><span class="line"><span class="keyword">logical</span> r,w</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Rain:&quot;</span></span><br><span class="line">read(*,*) rain</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Wind:&quot;</span></span><br><span class="line">read(*,*) windspeed</span><br><span class="line"></span><br><span class="line">r = (rain &gt;= <span class="number">500</span>)</span><br><span class="line">w = (windspeed &gt;= <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r .or. w) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;停止上班上课&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;照常上班上课&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> Rain:</span><br><span class="line"><span class="number">100</span></span><br><span class="line"> Wind:</span><br><span class="line"><span class="number">8</span></span><br><span class="line"> 照常上班上课</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-1-3-多重判断-if-else-if">5-1-3 多重判断 if - else if</h3>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件<span class="number">2</span>) <span class="keyword">then</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br></pre></td></tr></table></figure>
<p>举例，90-100 分为A级，80-89 分为B级，70-79分为C级， 60-69分为D级，60分以下为E级。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0505</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> score</span><br><span class="line"><span class="keyword">character</span> grade</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Score:&quot;</span></span><br><span class="line">read(*,*) score</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( score &gt;= <span class="number">90</span> .and. score &lt;= <span class="number">100</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">80</span> .and. score &lt; <span class="number">90</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">70</span> .and. score &lt; <span class="number">80</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;C&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">60</span> .and. score &lt; <span class="number">70</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;D&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">0</span> .and. score &lt; <span class="number">60</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;E&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    grade = <span class="string">&#x27;?&#x27;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;Grade:&#x27;,A1)&quot;</span>) grade</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Score:</span><br><span class="line"><span class="number">85</span></span><br><span class="line">Grade:B</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于多重判断，只有上一个条件不满足才会判断下一个条件，因此上一个程序可以简化如下（但是我觉得这样写不好，虽然提高了一点效率，但是降低了可读性）</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0505</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> score</span><br><span class="line"><span class="keyword">character</span> grade</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Score:&quot;</span></span><br><span class="line">read(*,*) score</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( score &gt; <span class="number">100</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;?&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">90</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">80</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">70</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;C&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">60</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;D&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">0</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;E&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    grade = <span class="string">&#x27;?&#x27;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;Grade:&#x27;,A1)&quot;</span>) grade</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-1-4-嵌套if语句">5-1-4 嵌套if语句</h3>
<p>多个if 语句嵌套</p>
<p>举例</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0508</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> x,y </span><br><span class="line"><span class="keyword">integer</span> ans</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Imput (x,y)&quot;</span></span><br><span class="line">read(*,*) x,y</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x&gt;<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> (y&gt;<span class="number">0</span>) <span class="keyword">then</span> </span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (y&lt;<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        ans = <span class="number">4</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> (y&gt;<span class="number">0</span>) <span class="keyword">then</span> </span><br><span class="line">        ans = <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (y&lt;<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        ans = <span class="number">3</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ans/=<span class="number">0</span> ) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;第&#x27;,i1,&#x27;象限&#x27;)&quot;</span>) ans</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;落在轴上&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p>输入输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Imput (x,y)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line">第<span class="number">1</span>象限</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-2-浮点数及字符的逻辑运算">5-2 浮点数及字符的逻辑运算</h2>
<h3 id="5-2-1-浮点数的逻辑判断">5-2-1 浮点数的逻辑判断</h3>
<p>使用浮点数来做逻辑运算时，要避免使用“等于”的判断。因为使用浮点数做计算时，有效位数是有限的，难免会出现计算上的误差，理想中的等号不一定会成立。要使用浮点数来做“等于”的逻辑判断时，最好用其他方法来取代。来看看下面的例子</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0509</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> :: a</span><br><span class="line"><span class="keyword">real</span> :: b = <span class="number">3.0</span></span><br><span class="line"></span><br><span class="line">a = <span class="built_in">sqrt</span>(b)**<span class="number">2</span> -b</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">0.0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;a 等于0&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;a不等于0&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然理论上 a = (根号b)^2^  - b = 0。但是用程序执行出来的结果却不见得是0，因为这里求根号时，得到的结果是保留了有效数字的，因此一开始就有误差。</p>
<p>浮点数的计算误差经常发生，所以在判断式中，要给误差预留一点空间。改写上面的例子</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0509</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> :: a</span><br><span class="line"><span class="keyword">real</span> :: b = <span class="number">3.0</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: e = <span class="number">0.0001</span> <span class="comment">!设置误差范围</span></span><br><span class="line"></span><br><span class="line">a = <span class="built_in">sqrt</span>(b)**<span class="number">2</span> -b</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(a-<span class="number">0.0</span>) &lt;= e) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;a 等于0&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;a不等于0&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-2-2-字符的逻辑判断">5-2-2 字符的逻辑判断</h3>
<p>除了数字可以比大小，字符也可以比大小（实际是比ASCII码）</p>
<p>用一个程序读取两个字符串来做比较</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0511</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">character</span>(len=<span class="number">20</span>) :: str1,str2</span><br><span class="line"><span class="keyword">character</span> relation</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;String 1:&quot;</span></span><br><span class="line">read(*,<span class="string">&quot;(a20)&quot;</span>) str1</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;String 2:&quot;</span></span><br><span class="line">read(*,<span class="string">&quot;(a20)&quot;</span>) str2</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str1 &gt; str2) <span class="keyword">then</span></span><br><span class="line">    relation = <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (str1 == str2) <span class="keyword">then</span></span><br><span class="line">    relation = <span class="string">&#x27;=&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    relation = <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;string1&#x27;,a1,&#x27;string2&#x27;)&quot;</span>) relation</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> String <span class="number">1</span>:</span><br><span class="line">zh</span><br><span class="line"> String <span class="number">2</span>:</span><br><span class="line">zi</span><br><span class="line">string1&lt;string2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-3-select-case-语句">5-3 select case 语句</h2>
<p>除了if 外，多重判断的另一种方法（我不喜欢用这个）</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0512</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> score</span><br><span class="line"><span class="keyword">character</span> grade</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Score:&quot;</span></span><br><span class="line">read(*,*) score</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">case</span>(score)</span><br><span class="line"><span class="keyword">case</span>(<span class="number">90</span>:<span class="number">100</span>)</span><br><span class="line">    grade = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">case</span>(<span class="number">80</span>:<span class="number">89</span>)</span><br><span class="line">    grade = <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">case</span>(<span class="number">70</span>:<span class="number">79</span>)</span><br><span class="line">    grade = <span class="string">&#x27;C&#x27;</span></span><br><span class="line"><span class="keyword">case</span>(<span class="number">60</span>:<span class="number">69</span>)</span><br><span class="line">    grade = <span class="string">&#x27;D&#x27;</span></span><br><span class="line"><span class="keyword">case</span>(<span class="number">0</span>:<span class="number">59</span>)</span><br><span class="line">    grade = <span class="string">&#x27;E&#x27;</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">default</span> <span class="comment">!其他情况</span></span><br><span class="line">    grade = <span class="string">&#x27;?&#x27;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">select</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;Grade:&#x27;,a1)&quot;</span>) grade</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>事实上，select case 中的判断经常不是判断是否落在一个数值范围内，而是判断是否等于某个数值。</p>
<p>语法如下：其中 case default 语句不是必需的。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">case</span>(变量)</span><br><span class="line"><span class="keyword">case</span> (数值<span class="number">1</span>)</span><br><span class="line">……</span><br><span class="line"><span class="keyword">case</span> (数值<span class="number">2</span>)</span><br><span class="line">……</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">default</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">select</span></span><br></pre></td></tr></table></figure>
<p>case 详细解释如下</p>
<blockquote>
<p>case(1)  变量=1</p>
<p>case(1:5)  1&lt;=变量&lt;=5</p>
<p>case(1: )   1&lt;=变量</p>
<p>case( :5)   变量 &lt;= 5</p>
<p>case(1,3,5)  变量等于1或3或5</p>
</blockquote>
<p>使用 selct case ，相比于 if ，看上去更加整洁。不过使用 select case 有一些限制：</p>
<ol>
<li>只能使用整数，字符，及逻辑变量，<strong>不能使用浮点数</strong>和复数。</li>
<li>每个 case 中所使用的数值必须是<strong>固定的常量</strong>（parameter），不能使用变量。</li>
</ol>
<h2 id="5-4-其他流程控制">5-4 其他流程控制</h2>
<h3 id="5-4-1-goto">5-4-1 goto</h3>
<p>fortran77 的老语句，不建议使用。</p>
<h3 id="5-4-3-pause-continue-stop">5-4-3 pause, continue, stop</h3>
<p>pause 的功能是当程序执行到 pause 时，会暂停执行，直到用户按下 enter 键才会继续执行。（目前我不知哪里需要用到这个）</p>
<p>continue 没有实际用途，就是放那和不放一样，用不到</p>
<p>stop 结束程序执行，小心使用（貌似类似于shell 的 exit）。</p>
<h2 id="5-5-习题">5-5 习题</h2>
<p>1 判断个人所得税</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0513</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> wage</span><br><span class="line"><span class="keyword">real</span> tax</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;wage:&quot;</span></span><br><span class="line">read(*,*) wage</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (wage &gt; <span class="number">0</span> .and. wage &lt; <span class="number">1000</span>) <span class="keyword">then</span></span><br><span class="line">    tax = <span class="number">0.03</span> * wage</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (wage &gt;=<span class="number">1000</span> .and. wage &lt; <span class="number">5000</span>) <span class="keyword">then</span></span><br><span class="line">    tax = <span class="number">0.1</span> * wage</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (wage &gt;= <span class="number">5000</span>) <span class="keyword">then</span></span><br><span class="line">    tax = <span class="number">0.15</span> * wage</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Error: wage must be a positive number&quot;</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;wage:&#x27;,f9.2,&#x27; tax:&#x27;,f9.2)&quot;</span>) wage,tax</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> wage:</span><br><span class="line"><span class="number">6000</span></span><br><span class="line">wage:  <span class="number">6000.00</span> tax:   <span class="number">900.00</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>输入星期几查询当晚的电视节目</li>
</ol>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0514</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> day</span><br><span class="line"><span class="keyword">character</span> tv</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Today is:&quot;</span></span><br><span class="line">read(*,*) day</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((day == <span class="number">1</span>) .or. (day ==<span class="number">4</span>)) <span class="keyword">then</span></span><br><span class="line">    tv = <span class="string">&#x27;新闻&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((day == <span class="number">2</span>) .or. (day ==<span class="number">5</span>)) <span class="keyword">then</span></span><br><span class="line">    tv = <span class="string">&#x27;电视剧&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((day == <span class="number">3</span>) .or. (day ==<span class="number">6</span>)) <span class="keyword">then</span></span><br><span class="line">    tv = <span class="string">&#x27;卡通片&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">7</span>) <span class="keyword">then</span></span><br><span class="line">    tv = <span class="string">&#x27;电影&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Error: day must be 1 to 7&quot;</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;tv is&#x27;,a3)&quot;</span>) tv</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码没错，但是中文显示不出来</p>
<p>错了，错了。</p>
<p>注意下面这两句的区别。上面只是设置为一个单个字符，下面才是字符串</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">character</span> tv</span><br><span class="line"><span class="keyword">character</span>(len=<span class="number">10</span>) tv</span><br></pre></td></tr></table></figure>
<p>3 个人所得税根据年纪和收入计算</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0515</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> year</span><br><span class="line"><span class="keyword">real</span> wage_year,wage,tax</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;how old are you?&quot;</span></span><br><span class="line">read(*,*) year</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Wage in a year:&quot;</span></span><br><span class="line">read(*,*) wage_year</span><br><span class="line"></span><br><span class="line">wage = wage_year/<span class="number">12</span> <span class="comment">!月收入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (year &lt; <span class="number">50</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> (wage &lt; <span class="number">1000</span>) <span class="keyword">then</span></span><br><span class="line">        tax = wage_year * <span class="number">0.03</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wage &lt; <span class="number">5000</span>) <span class="keyword">then</span></span><br><span class="line">        tax = wage_year * <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tax = wage_year * <span class="number">0.15</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (wage &lt; <span class="number">1000</span>) <span class="keyword">then</span></span><br><span class="line">        tax = wage_year * <span class="number">0.05</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wage &lt; <span class="number">5000</span>) <span class="keyword">then</span></span><br><span class="line">        tax = wage_year * <span class="number">0.07</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tax = wage_year * <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(f9.2)&quot;</span>) tax</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> how old are you?</span><br><span class="line"><span class="number">25</span></span><br><span class="line"> Wage <span class="keyword">in</span> a year:</span><br><span class="line"><span class="number">120000</span></span><br><span class="line"> <span class="number">18000.00</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4 输入年份，判断天数（老题目了）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">program ex0516</span><br><span class="line">implicit none</span><br><span class="line">integer year,days</span><br><span class="line"></span><br><span class="line">write(*,*) &quot;Year:&quot;</span><br><span class="line">read(*,*) year</span><br><span class="line"></span><br><span class="line">if (mod(year,100) &#x3D;&#x3D; 0) then !被100整除</span><br><span class="line">    if (mod(year,400) &#x3D;&#x3D; 0) then !又被400整除</span><br><span class="line">        days &#x3D; 366</span><br><span class="line">    else</span><br><span class="line">        days &#x3D; 365</span><br><span class="line">    end if </span><br><span class="line">else !不能被100整除</span><br><span class="line">    if (mod(year,4) &#x3D;&#x3D; 0) then !被4整除</span><br><span class="line">        days &#x3D; 366</span><br><span class="line">    else</span><br><span class="line">        days &#x3D; 365</span><br><span class="line">    end if </span><br><span class="line">end if </span><br><span class="line"></span><br><span class="line">write(*, &quot;(&#39;days of year &#39;,i4,&#39; is &#39;,i3)&quot;) year,days</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Year:</span><br><span class="line"><span class="number">2000</span></span><br><span class="line">days of <span class="number">2000</span> is <span class="number">366</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>6 循环</h1>
<p>循环可以用来自动重复执行某一段程序代码，善用循环可以让程序代码变得很精简。</p>
<p>循环又两种执行格式，第一种格式会固定重复程序代码 n 次。另一种格式着是不固定重复几次，一直执行到出现跳出循环的命令为止。</p>
<h2 id="6-1-do">6-1 do</h2>
<p>说 10 次 happy birthday</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0601</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> counter</span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: lines = <span class="number">10</span></span><br><span class="line"><span class="comment">! counter &lt;= lines 会一直循环，每执行一次循环 counter 加 1</span></span><br><span class="line"><span class="comment">! counter 称之为 计数器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> counter=<span class="number">1</span>,lines,<span class="number">1</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Happy Birthday&quot;</span>, counter</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Happy Birthday           <span class="number">1</span></span><br><span class="line">Happy Birthday           <span class="number">2</span></span><br><span class="line">Happy Birthday           <span class="number">3</span></span><br><span class="line">Happy Birthday           <span class="number">4</span></span><br><span class="line">Happy Birthday           <span class="number">5</span></span><br><span class="line">Happy Birthday           <span class="number">6</span></span><br><span class="line">Happy Birthday           <span class="number">7</span></span><br><span class="line">Happy Birthday           <span class="number">8</span></span><br><span class="line">Happy Birthday           <span class="number">9</span></span><br><span class="line">Happy Birthday          <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再看一个例子，使用循环计算 2+4+……+10</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0602</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: limit = <span class="number">10</span></span><br><span class="line"><span class="keyword">integer</span> counter</span><br><span class="line"><span class="keyword">integer</span> :: ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> counter=<span class="number">2</span>,limit,<span class="number">2</span></span><br><span class="line">    ans = ans + counter</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>增值（我叫步长）也可以设置为负值。</p>
<p>嵌套循环</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0603</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> i,j</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">3</span></span><br><span class="line">    <span class="keyword">do</span> j=<span class="number">1</span>,<span class="number">3</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(i2,i2)&quot;</span>) i,j</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;another cycle&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line">another <span class="keyword">cycle</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line">another <span class="keyword">cycle</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line">another <span class="keyword">cycle</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-2-do-while-循环">6-2 do while 循环</h2>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> <span class="keyword">while</span> (逻辑运算) <span class="comment">!成立就一直重复执行</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>以这个方法改写 2+4+……10</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0604</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: limit = <span class="number">10</span> </span><br><span class="line"><span class="keyword">integer</span> counter</span><br><span class="line"><span class="keyword">integer</span> :: ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">counter = <span class="number">2</span> </span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span> (counter &lt;= limit)</span><br><span class="line">    ans = ans + counter</span><br><span class="line">    counter = counter + <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) ans</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是 do while 一般不是处理这种任务的，do while 处理的任务一般是不知道要循环几次的。</p>
<p>蔡小姐把她的体重视为秘密，不过这里有个程序可以让大家猜她的体重。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0605</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: weight = <span class="number">45.0</span> <span class="comment">!答案</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: e = <span class="number">0.001</span> <span class="comment">!误差</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">real</span> :: guess = <span class="number">0.0</span> <span class="comment">!猜测值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span> ( <span class="built_in">abs</span>(guess - weight) &gt; e )</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;weight:&quot;</span></span><br><span class="line">    read(*,*) guess</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;You&#x27;re right&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-3-循环的流程控制">6-3 循环的流程控制</h2>
<h3 id="6-3-1-cycle">6-3-1 cycle</h3>
<p>等同于 python 的 continue</p>
<p>假设百货公司共有9层楼，但电梯在4层不停，显示电梯灯号显示情况</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0606</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: dest = <span class="number">9</span></span><br><span class="line"><span class="keyword">integer</span> <span class="built_in">floor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> <span class="built_in">floor</span>=<span class="number">1</span>, dest</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">floor</span> == <span class="number">4</span>) <span class="keyword">cycle</span> <span class="comment">!if 就一行可以这么写</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="built_in">floor</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出如下，跳过了 4</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="6-3-2-exit">6-3-2 exit</h3>
<p>相当于 python 的 break</p>
<p>改写前面的猜体重的程序</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0607</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: weight = <span class="number">45.0</span> <span class="comment">!答案</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: e = <span class="number">0.001</span> <span class="comment">!误差</span></span><br><span class="line"><span class="keyword">real</span> :: guess </span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span> (.true.)</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;weight:&quot;</span></span><br><span class="line">    read(*,*) guess</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(guess - weight) &lt; e) <span class="keyword">exit</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;You&#x27;re right&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里用到了死循环，必须要用 exit</p>
<h3 id="6-3-3-署名的循环">6-3-3 署名的循环</h3>
<p>给循环取名字，避免多层循环弄错</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0608</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> i,j</span><br><span class="line"></span><br><span class="line">outter: <span class="keyword">do</span> i = <span class="number">1</span>,<span class="number">3</span> <span class="comment">!循环取名为outter</span></span><br><span class="line">    inner: <span class="keyword">do</span> j = <span class="number">1</span>,<span class="number">3</span> <span class="comment">!循环取名为inner</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;(&#x27;,i2,&#x27;,&#x27;,i2,&#x27;)&#x27;)&quot;</span>) i,j</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> inner</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span> outter </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">( <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">( <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">( <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">( <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">( <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">( <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">( <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">( <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">( <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>起名字的循环，还可以使用 cycle exit 在内层直接挑出外层的循环，例子如下</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0609</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> i,j</span><br><span class="line"></span><br><span class="line">loop1: <span class="keyword">do</span> i = <span class="number">1</span>,<span class="number">3</span> </span><br><span class="line">    loop2: <span class="keyword">do</span> j = <span class="number">1</span>,<span class="number">3</span> </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">3</span>) <span class="keyword">exit</span> loop1 <span class="comment">!跳离 loop1</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">2</span>) <span class="keyword">cycle</span> loop2 <span class="comment">!重做 loop2</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;(&#x27;,i2,&#x27;,&#x27;,i2,&#x27;)&#x27;)&quot;</span>) i,j</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> loop2</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span> loop1</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">( <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">( <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">( <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">( <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-4-循环的应用">6-4 循环的应用</h2>
<p>实例1 求等差数列1+2+……100</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0610</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> counter</span><br><span class="line"><span class="keyword">integer</span> :: ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">do</span> counter=<span class="number">1</span>,<span class="number">100</span>,<span class="number">1</span></span><br><span class="line">    ans = ans + counter</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">write</span>(*,*) ans</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5050</span></span><br></pre></td></tr></table></figure>
<p>实例2 列举费氏数列前10个数字</p>
<p>f0 = 0, f1 =1, fn = fn-1 + fn-2</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0611</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: counter </span><br><span class="line"><span class="keyword">integer</span> :: fn_1 = <span class="number">1</span></span><br><span class="line"><span class="keyword">integer</span> :: fn_2 = <span class="number">0</span></span><br><span class="line"><span class="keyword">integer</span> :: fn = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) fn_2</span><br><span class="line"><span class="built_in">write</span>(*,*) fn_1</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> counter = <span class="number">2</span>,<span class="number">9</span></span><br><span class="line">    fn = fn_2 + fn_1</span><br><span class="line">    <span class="built_in">write</span>(*,*) fn</span><br><span class="line">    fn_2 = fn_1</span><br><span class="line">    fn_1 = fn</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"> <span class="number">1</span></span><br><span class="line"> <span class="number">1</span></span><br><span class="line"> <span class="number">2</span></span><br><span class="line"> <span class="number">3</span></span><br><span class="line"> <span class="number">5</span></span><br><span class="line"> <span class="number">8</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实例三，做简单的密码加密、解密程序。加密方法很简单，把每个英文字母在ASCII表中的编号加2作为密码来传输，解密就是还原</p>
<p>加密程序</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0612</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> i </span><br><span class="line"><span class="keyword">integer</span> strlen</span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: key = <span class="number">2</span></span><br><span class="line"><span class="keyword">character</span>(len=<span class="number">20</span>) :: string</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;String:&quot;</span></span><br><span class="line">read(*,*) string</span><br><span class="line"></span><br><span class="line">strlen = <span class="built_in">len_trim</span>(string) <span class="comment">!字符串实际长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i = <span class="number">1</span>,strlen</span><br><span class="line">    string(i:i) = <span class="built_in">char</span>( <span class="built_in">ichar</span>(string(i:i)) + key )</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;encoded:&#x27;,a20)&quot;</span>) string</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> String:</span><br><span class="line">attack now</span><br><span class="line">encoded:cvvcem</span><br></pre></td></tr></table></figure>
<p>解密程序 ，就是把 + key 变成了  - key</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0613</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> i </span><br><span class="line"><span class="keyword">integer</span> strlen</span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: key = <span class="number">2</span></span><br><span class="line"><span class="keyword">character</span>(len=<span class="number">20</span>) :: string</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;String:&quot;</span></span><br><span class="line">read(*,*) string</span><br><span class="line"></span><br><span class="line">strlen = <span class="built_in">len_trim</span>(string) <span class="comment">!字符串实际长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i = <span class="number">1</span>,strlen</span><br><span class="line">    string(i:i) = <span class="built_in">char</span>( <span class="built_in">ichar</span>(string(i:i)) - key )</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;encoded:&#x27;,a20)&quot;</span>) string</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> String:</span><br><span class="line">cvvcem</span><br><span class="line">encoded:attack</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个代码有一个问题，输入由于没有格式化，“attack now” 实际只输入了 “attack” 。假如真的是军事命令，比如是 “attack tomorrow&quot; ，就会变成 “attack&quot; ，从明天发起攻击变成了现在就攻击，呕吼。</p>
<p>实例4，写一个小的计算程序，用户输入两个数字和计算符号来进行一次运算。运算结束后，让用户来决定要再做新的计算或结束程序</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0614</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> a,b,ans</span><br><span class="line"><span class="keyword">character</span> :: key = <span class="string">&#x27;y&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span> (key == <span class="string">&#x27;y&#x27;</span> .or. key == <span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">    read(*,*) a</span><br><span class="line">    read(*, <span class="string">&quot;(a1)&quot;</span>) key</span><br><span class="line">    read(*,*) b</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">case</span>(key)</span><br><span class="line">    <span class="keyword">case</span>(<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        ans = a+b</span><br><span class="line">    <span class="keyword">case</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        ans = a-b</span><br><span class="line">    <span class="keyword">case</span>(<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        ans = a*b</span><br><span class="line">    <span class="keyword">case</span>(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        ans = a/b</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">default</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Unknown operater &#x27;,a1)&quot;</span>) key</span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">select</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(f6.2,a1,f6.2,&#x27;=&#x27;,f6.2)&quot;</span>) a,key,b,ans</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;(Y/y) to do again. (other) to exit.&quot;</span></span><br><span class="line">    read(*,<span class="string">&quot;(a1)&quot;</span>) key</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p>输入输出如下</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line">*</span><br><span class="line"><span class="number">5</span></span><br><span class="line">  <span class="number">3.00</span>*  <span class="number">5.00</span>= <span class="number">15.00</span></span><br><span class="line"> (Y/y) to <span class="keyword">do</span> again. (other) to <span class="keyword">exit</span>.</span><br><span class="line">n</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-5-习题">6-5 习题</h2>
<p>1 显示相同的字符串</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0615</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> counter</span><br><span class="line"><span class="keyword">do</span> counter=<span class="number">1</span>,<span class="number">5</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Fortran&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2 计算等差数列 1+3+……99</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0616</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> counter</span><br><span class="line"><span class="keyword">integer</span> :: ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">do</span> counter=<span class="number">1</span>,<span class="number">99</span>,<span class="number">2</span></span><br><span class="line">    ans = ans + counter</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) ans</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>输出结果 2500</p>
<p>3 改变一下猜体重的程序，最多猜5次，最后要告诉用户猜没猜对。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0605</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: weight = <span class="number">45.0</span> <span class="comment">!答案</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: e = <span class="number">0.001</span> <span class="comment">!误差</span></span><br><span class="line"><span class="keyword">real</span> :: guess = <span class="number">0.0</span> <span class="comment">!猜测值</span></span><br><span class="line"><span class="keyword">integer</span> :: counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> counter=<span class="number">1</span>,<span class="number">5</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;weight:&quot;</span></span><br><span class="line">    read(*,*) guess</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(guess - weight) &lt; e) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;You&#x27;re right&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;You&#x27;re wrong&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> weight:</span><br><span class="line"><span class="number">46</span></span><br><span class="line"> weight:</span><br><span class="line"><span class="number">45</span></span><br><span class="line"> You<span class="string">&#x27;re right</span></span><br><span class="line"><span class="string"> You&#x27;</span>re wrong</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我想实现的效果是，如果猜对了，用 stop 直接退出程序，这样就不会打印 ”You’re wrong“ 了。</p>
<p>但是这里 用stop 没有直接退出程序，仅仅是退出了循环。（不清楚什么原因）</p>
<p>重写</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0605</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: weight = <span class="number">45.0</span> <span class="comment">!答案</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: e = <span class="number">0.001</span> <span class="comment">!误差</span></span><br><span class="line"><span class="keyword">real</span> :: guess = <span class="number">0.0</span> <span class="comment">!猜测值</span></span><br><span class="line"><span class="keyword">integer</span> :: counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> counter=<span class="number">1</span>,<span class="number">5</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;weight:&quot;</span></span><br><span class="line">    read(*,*) guess</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(guess - weight) &lt; e) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">exit</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(guess - weight) &lt; e) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;You&#x27;re right&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;You&#x27;re wrong&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>逻辑是这样的，如果五次都没有猜对，最后的判断肯定还是不对的。如果有一次猜对了，退出循环，guess 就是正确的值，最后的判断就是对的。</p>
<p>4 以循环来计算 1/1！+ …… 1/10！</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0618</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> counter1,counter2</span><br><span class="line"><span class="keyword">integer</span> :: ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">integer</span> :: a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> counter1=<span class="number">1</span>,<span class="number">10</span></span><br><span class="line">    <span class="keyword">do</span> counter2=<span class="number">1</span>,counter1</span><br><span class="line">        a = a * counter2</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    ans = ans + <span class="number">1.0</span>/<span class="keyword">real</span>(a) <span class="comment">!必须进行类型转换，整数改为浮点数</span></span><br><span class="line">    a = <span class="number">1</span> <span class="comment">!a重新调整为1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">write</span>(*,*) ans</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为 1</p>
<p>这个结果错了，错的地方在于 ans 的数据格式，不是整数，而是浮点数</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0618</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> counter1,counter2</span><br><span class="line"><span class="keyword">real</span> :: ans = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">integer</span> :: a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> counter1=<span class="number">1</span>,<span class="number">10</span></span><br><span class="line">    <span class="keyword">do</span> counter2=<span class="number">1</span>,counter1</span><br><span class="line">        a = a * counter2</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    ans = ans + <span class="number">1.0</span>/<span class="keyword">real</span>(a) <span class="comment">!必须进行类型转换，整数改为浮点数</span></span><br><span class="line">    a = <span class="number">1</span> <span class="comment">!a重新调整为1</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) ans</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>输出结果为：1.71828163</p>
<p>5 消除字符串的空格（<strong>?</strong>）</p>
<p>这个我只能实现到，把所有非空格的字符打印出来。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0619</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">character</span>(len=<span class="number">30</span>) string</span><br><span class="line"><span class="keyword">integer</span> length</span><br><span class="line"><span class="keyword">integer</span> counter</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;char:&quot;</span></span><br><span class="line">read(*,<span class="string">&quot;(a30)&quot;</span>) string</span><br><span class="line"></span><br><span class="line">length = <span class="built_in">len_trim</span>(string)</span><br><span class="line"><span class="keyword">do</span> counter=<span class="number">1</span>,length</span><br><span class="line">    <span class="keyword">if</span> (string(counter:counter) /= <span class="string">&quot; &quot;</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,<span class="string">&quot;(a1)&quot;</span>) string(counter:counter)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>7 数组</h1>
<h2 id="7-1-基本使用">7-1 基本使用</h2>
<h3 id="7-1-1-一维数组">7-1-1 一维数组</h3>
<p>写一个程序来记录全班5位同学的数学成绩，并提供由座号来查询成绩的功能。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0701</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: students = <span class="number">5</span></span><br><span class="line"><span class="keyword">integer</span> :: student(students)</span><br><span class="line"><span class="keyword">integer</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i = <span class="number">1</span>,students</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Number&#x27;,i2)&quot;</span>) i</span><br><span class="line">    read(*,*) student(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Query:&quot;</span></span><br><span class="line">    read(*,*) i</span><br><span class="line">    <span class="keyword">if</span> (i&lt;=<span class="number">0</span> .or. i&gt;students) <span class="keyword">exit</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) student(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Number</span> <span class="number">1</span></span><br><span class="line"><span class="number">80</span></span><br><span class="line"><span class="keyword">Number</span> <span class="number">2</span></span><br><span class="line"><span class="number">85</span></span><br><span class="line"><span class="keyword">Number</span> <span class="number">3</span></span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="keyword">Number</span> <span class="number">4</span></span><br><span class="line"><span class="number">75</span></span><br><span class="line"><span class="keyword">Number</span> <span class="number">5</span></span><br><span class="line"><span class="number">95</span></span><br><span class="line"> Query:</span><br><span class="line"><span class="number">13</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>数组的声明方法如下（相比于正常的类型，就是加了一个括号而已）</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datatype <span class="keyword">name</span>(<span class="built_in">size</span>)</span><br></pre></td></tr></table></figure>
<p>注意：这里的size 必须为<strong>常量</strong>（直接填入数字或者是使用声明为 parameter 的常数）</p>
<p>数组取值</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student(<span class="number">1</span>) = <span class="number">89</span> <span class="comment">!第一个元素设置为89</span></span><br></pre></td></tr></table></figure>
<p>数组的索引值不需要是常量，也可以是变量。</p>
<p>使用数组时超出范围是很危险的，绝对要避免发生这种情况。</p>
<p>如果不使用数组，这个程序会这样写，非常繁琐（如果是50个人，500个人，这样写是不可能的）：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0702</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: student1,student2,student3,student4,student5</span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Number 1&quot;</span></span><br><span class="line">read(*,*) student1</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Number 2&quot;</span></span><br><span class="line">read(*,*) student2</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Number 3&quot;</span></span><br><span class="line">read(*,*) student3</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Number 4&quot;</span></span><br><span class="line">read(*,*) student4</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Number 5&quot;</span></span><br><span class="line">read(*,*) student5</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>(.true.) </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Query:&quot;</span></span><br><span class="line">    read(*,*) i</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">case</span>(i)</span><br><span class="line">    <span class="keyword">case</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">write</span>(*,*) student1</span><br><span class="line">    <span class="keyword">case</span>(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">write</span>(*,*) student2</span><br><span class="line">    <span class="keyword">case</span>(<span class="number">3</span>)</span><br><span class="line">        <span class="built_in">write</span>(*,*) student3</span><br><span class="line">    <span class="keyword">case</span>(<span class="number">4</span>)</span><br><span class="line">        <span class="built_in">write</span>(*,*) student4</span><br><span class="line">    <span class="keyword">case</span>(<span class="number">5</span>)</span><br><span class="line">        <span class="built_in">write</span>(*,*) student5</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">default</span></span><br><span class="line">        <span class="keyword">exit</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">select</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p>最后再强调一点，数组除了可以使用基本的4种类型之外，还可以使用自定义类型。</p>
<h3 id="7-1-2-二维数组">7-1-2 二维数组</h3>
<p>声明数组大小，如果使用两个数字，它就变成二维数组。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">3</span>,<span class="number">3</span>) <span class="comment">!数组a是3×3的二维数组</span></span><br><span class="line">a(<span class="number">1</span>,<span class="number">1</span>) = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>保存整个年级5个班级，每班5个同学的数学考试成绩</p>
<p>这个程序和ex0701 很类似，差别这个是记录了几个班的学生成绩</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0703</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: classes = <span class="number">5</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: students = <span class="number">5</span></span><br><span class="line"><span class="keyword">integer</span> :: student(students, classes)</span><br><span class="line"><span class="keyword">integer</span> s <span class="comment">!用于赋值学生号码</span></span><br><span class="line"><span class="keyword">integer</span> c <span class="comment">!用于赋值班级号码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> c=<span class="number">1</span>,classes</span><br><span class="line">    <span class="keyword">do</span> s=<span class="number">1</span>,students</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Number &#x27;,i2, &#x27; of class &#x27;,i2)&quot;</span>) s,c</span><br><span class="line">        read(*,*) student(s,c)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;class:&quot;</span></span><br><span class="line">    read(*,*) c</span><br><span class="line">    <span class="keyword">if</span> (c&lt;=<span class="number">0</span> .or. c&gt;classes) <span class="keyword">exit</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;student:&quot;</span></span><br><span class="line">    read(*,*) s</span><br><span class="line">    <span class="keyword">if</span> (s&lt;=<span class="number">0</span> .or. s&gt;students) <span class="keyword">exit</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;score:&#x27;,i3)&quot;</span>) student(s,c) </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再看一个二维数组的例子，二维数组经常被拿来当作矩阵使用。</p>
<p>下面的例子可以让用户输入两个2×2矩阵的值，再把这两个矩阵相加。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0704</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: row = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: col = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span> :: matrixA(row,col)</span><br><span class="line"><span class="keyword">integer</span> :: matrixB(row,col)</span><br><span class="line"><span class="keyword">integer</span> :: matrixC(row,col)</span><br><span class="line"><span class="keyword">integer</span> r</span><br><span class="line"><span class="keyword">integer</span> c</span><br><span class="line"></span><br><span class="line"><span class="comment">!读入矩阵A的内容</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Matrix A&quot;</span></span><br><span class="line"><span class="keyword">do</span> r=<span class="number">1</span>,row</span><br><span class="line">    <span class="keyword">do</span> c=<span class="number">1</span>,col</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;A(&#x27;,i1,&#x27;,&#x27;,i1,&#x27;)=&#x27;)&quot;</span>) r,c</span><br><span class="line">        read(*,*) matrixA(r,c)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!读入矩阵B的内容</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Matrix B&quot;</span></span><br><span class="line"><span class="keyword">do</span> r=<span class="number">1</span>,row</span><br><span class="line">    <span class="keyword">do</span> c=<span class="number">1</span>,col</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;B(&#x27;,i1,&#x27;,&#x27;,i1,&#x27;)=&#x27;)&quot;</span>) r,c</span><br><span class="line">        read(*,*) matrixB(r,c)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!把矩阵A, B相加并输出结果</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Matrix A+B=&quot;</span></span><br><span class="line"><span class="keyword">do</span> r=<span class="number">1</span>,row</span><br><span class="line">    <span class="keyword">do</span> c=<span class="number">1</span>,col</span><br><span class="line">        matrixC(r,c) = matrixA(r,c) + matrixB(r,c)</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;(&#x27;,i1,&#x27;,&#x27;,i1,&#x27;)=&#x27;,i3)&quot;</span>) r,c,matrixC(r,c)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> Matrix A</span><br><span class="line">A(<span class="number">1</span>,<span class="number">1</span>)=</span><br><span class="line"><span class="number">1</span></span><br><span class="line">A(<span class="number">1</span>,<span class="number">2</span>)=</span><br><span class="line"><span class="number">1</span></span><br><span class="line">A(<span class="number">2</span>,<span class="number">1</span>)=</span><br><span class="line"><span class="number">1</span></span><br><span class="line">A(<span class="number">2</span>,<span class="number">2</span>)=</span><br><span class="line"><span class="number">1</span></span><br><span class="line"> Matrix B</span><br><span class="line">B(<span class="number">1</span>,<span class="number">1</span>)=</span><br><span class="line"><span class="number">2</span></span><br><span class="line">B(<span class="number">1</span>,<span class="number">2</span>)=</span><br><span class="line"><span class="number">2</span></span><br><span class="line">B(<span class="number">2</span>,<span class="number">1</span>)=</span><br><span class="line"><span class="number">2</span></span><br><span class="line">B(<span class="number">2</span>,<span class="number">2</span>)=</span><br><span class="line"><span class="number">2</span></span><br><span class="line"> Matrix A+B=</span><br><span class="line">(<span class="number">1</span>,<span class="number">1</span>)=  <span class="number">3</span></span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>)=  <span class="number">3</span></span><br><span class="line">(<span class="number">2</span>,<span class="number">1</span>)=  <span class="number">3</span></span><br><span class="line">(<span class="number">2</span>,<span class="number">2</span>)=  <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-1-3-多维数组">7-1-3 多维数组</h3>
<p>fortran 最高可以声明高达7维的数组。</p>
<p>看一个三维数组的实例，把上面那个矩阵相加的程序使用三维数组来改写。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0705</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: row = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: col = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span> :: matrix(row,col,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">integer</span> m</span><br><span class="line"><span class="keyword">integer</span> r</span><br><span class="line"><span class="keyword">integer</span> c</span><br><span class="line"></span><br><span class="line"><span class="comment">!读入矩阵的内容</span></span><br><span class="line"><span class="keyword">do</span> m=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Matrix &#x27;,i1)&quot;</span>) m</span><br><span class="line">    <span class="keyword">do</span> r=<span class="number">1</span>,row</span><br><span class="line">        <span class="keyword">do</span> c=<span class="number">1</span>,col</span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;(&#x27;,i1,&#x27;,&#x27;,i1,&#x27;)=&#x27;)&quot;</span>) r,c</span><br><span class="line">            read(*,*) matrix(r,c,m)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!把第1，2个矩阵相加</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Matrix 1 + Matrix 2 = &quot;</span></span><br><span class="line"><span class="keyword">do</span> r=<span class="number">1</span>,row</span><br><span class="line">    <span class="keyword">do</span> c=<span class="number">1</span>,col</span><br><span class="line">        matrix(r,c,<span class="number">3</span>) = matrix(r,c,<span class="number">1</span>) + matrix(r,c,<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;(&#x27;,i1,&#x27;,&#x27;,i1,&#x27;)=&#x27;,i3)&quot;</span>) r,c,matrix(r,c,<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-1-4-另类的数组声明">7-1-4 另类的数组声明</h3>
<p>在没有特别赋值的前提下，数组的索引值都是从1开始，例如：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">5</span>) <span class="comment">!共5个元素 a(1)-a(5)</span></span><br></pre></td></tr></table></figure>
<p>可以经过特别声明的办法来改变这个默认的规则，在声明时，可以特别赋值数组的坐标值使用范围，例如：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">0</span>:<span class="number">5</span>) </span><br><span class="line"><span class="comment">! 这个数组可以使用 a(0),a(1)……a(5) 这6个元素</span></span><br></pre></td></tr></table></figure>
<p>其他范围也是可以的。多维数组也是一样的道理。</p>
<h2 id="7-2-数组内容的设置">7-2 数组内容的设置</h2>
<p>数组也可以先设定初值</p>
<h3 id="7-2-1-赋初值">7-2-1 赋初值</h3>
<p>数组也可以像一般变量一样使用DATA 来设置数组的初值。例子如下</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">data</span> a /<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>/</span><br><span class="line"><span class="comment">!这样会把a的初始值设置为1-5</span></span><br></pre></td></tr></table></figure>
<p>data 的数据区还可以使用星号* 来表示数据重复</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">data</span> a /<span class="number">5</span>*<span class="number">3</span>/ <span class="comment">!5*3 在此指有5个3</span></span><br><span class="line"><span class="comment">! a(1) = a(2) = …… a(5) = 3</span></span><br></pre></td></tr></table></figure>
<p>另外有一种”隐含式“ 循环的功能可以用来设置数组的初值</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">integer</span> i</span><br><span class="line"><span class="keyword">data</span>(a(i), i=<span class="number">2</span>, <span class="number">4</span>)/<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>/</span><br><span class="line"><span class="comment">!这就是一个”隐含式”循环，i 会从2增加到4， 依照顺序到后面取数字，初值设定结果为a(2)=2,a(3)=3,</span></span><br><span class="line"><span class="comment">!a(4)=4, a(1)和a(5)没有设置</span></span><br></pre></td></tr></table></figure>
<p>“隐含” 的循环省略了 DO 的描述， 除了应用在声明的初值设置， 还可以应用在其他的程序代码中，像用来输出数组的内容</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write</span>(*,*) (a(i), i=<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">!显示a(2),a(3),a(4)的值</span></span><br></pre></td></tr></table></figure>
<p>“隐含” 循环，只要在最后面再多加一个数字，同样可以改变计数器的累加数值，默认值为1。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(A(i), i=<span class="number">2</span>,<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">!循环执行5次，分别为2 4 6 8 10</span></span><br></pre></td></tr></table></figure>
<p>隐含式循环也可以是多层嵌套的，所以也可以应用在多维数组上：（个人不建议）</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">integer</span> i,j</span><br><span class="line"><span class="keyword">data</span>((a(i,j), i=<span class="number">1</span>,<span class="number">2</span>),j=<span class="number">1</span>,<span class="number">2</span>) /<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>/</span><br><span class="line"><span class="comment">!里面括号的循环会先执行，设置结果为</span></span><br><span class="line">！a(<span class="number">1</span>,<span class="number">1</span>) =<span class="number">1</span> a(<span class="number">2</span>,<span class="number">1</span>)=<span class="number">2</span> a(<span class="number">1</span>,<span class="number">2</span>)=<span class="number">3</span> a(<span class="number">2</span>,<span class="number">2</span>)=<span class="number">4</span> 这个乱了</span><br></pre></td></tr></table></figure>
<p>Fortran90 中，可以省略DATA描述，直接设置初值</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>) =(/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /) <span class="comment">!注意括号和除号间不能有空格</span></span><br></pre></td></tr></table></figure>
<p>这种方式，数组的所有元素都必须给定一个初值。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>) = (/ <span class="number">1</span>,(<span class="number">2</span>,i=<span class="number">2</span>,<span class="number">4</span>),<span class="number">5</span> /)</span><br><span class="line"><span class="comment">!a(1)=1</span></span><br><span class="line"><span class="comment">!a(2)=a(3)=a(4)=2</span></span><br><span class="line"><span class="comment">!a(5)=5</span></span><br></pre></td></tr></table></figure>
<p>Fortran90 隐含式循环的功能可以更强大，例如</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>) = (/ (i,i=<span class="number">1</span>,<span class="number">5</span>) /)</span><br><span class="line"><span class="comment">! a(1)=1, a(2)=2, a(3)=3 ……</span></span><br></pre></td></tr></table></figure>
<p>把查询成绩的程序改写，学生成绩直接写在代码中</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0706</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: students = <span class="number">5</span></span><br><span class="line"><span class="keyword">integer</span> :: student(<span class="number">5</span>) = (/ <span class="number">80</span>,<span class="number">90</span>,<span class="number">85</span>,<span class="number">75</span>,<span class="number">95</span> /)</span><br><span class="line"><span class="keyword">integer</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Query:&quot;</span></span><br><span class="line">    read(*,*) i</span><br><span class="line">    <span class="keyword">if</span> (i&lt;=<span class="number">0</span> .or. i&gt;students) <span class="keyword">exit</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) student(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> Query:</span><br><span class="line"><span class="number">1</span></span><br><span class="line">          <span class="number">80</span></span><br><span class="line"> Query:</span><br><span class="line"><span class="number">2</span></span><br><span class="line">          <span class="number">90</span></span><br><span class="line"> Query:</span><br><span class="line"><span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>设置二维数组的内容，再输出到屏幕上。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0707</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: row = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: col = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span> :: m(row,col)</span><br><span class="line"><span class="keyword">integer</span> r</span><br><span class="line"><span class="keyword">integer</span> c</span><br><span class="line"><span class="keyword">data</span>((m(r,c), r=<span class="number">1</span>,<span class="number">2</span>), c=<span class="number">1</span>,<span class="number">2</span>) /<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>/</span><br><span class="line"></span><br><span class="line"><span class="comment">!按顺序输出m(1,1), m(2,1), m(1,2), m(2,2) 这4个数字</span></span><br><span class="line"><span class="comment">!在write中，用/换行</span></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(i3,i3,/,i3,i3)&quot;</span>) ((m(r,c),c=<span class="number">1</span>,<span class="number">2</span>),r=<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Fortran90 中，可以把所有数组元素都设置为一个相同的数值。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>) = <span class="number">5</span></span><br><span class="line"><span class="comment">!a(1) = a(2) = …… = a(5) =5</span></span><br></pre></td></tr></table></figure>
<h3 id="7-2-2-对整个数组的操作">7-2-2 对整个数组的操作</h3>
<p>Fortran 有一些方便的命名，可以直接操作整个数组。比如：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>这个命令将 a 的每个元素的值都设置为5。以一维的情况来看，这个命令相当于下面的程序代码：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,N</span><br><span class="line">	a(i) = <span class="number">5</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>下面这个命令设置为，a(1) =1， a(2) =2, a(3) =3，注意，这里等号右边所提供的数字数目必须跟数组a的大小一样。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> /)</span><br></pre></td></tr></table></figure>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = b <span class="comment">!将a的元素设置和b相同</span></span><br><span class="line">a = b+c <span class="comment">!+-*/</span></span><br><span class="line">a = <span class="built_in">sin</span>(b)</span><br></pre></td></tr></table></figure>
<p>改写矩阵相加的程序。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0708</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: row = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: col = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span> :: ma(row,col) = <span class="number">1</span></span><br><span class="line"><span class="keyword">integer</span> :: mb(row,col) = <span class="number">4</span></span><br><span class="line"><span class="keyword">integer</span> :: mc(row,col)</span><br><span class="line"><span class="keyword">integer</span> :: i,j</span><br><span class="line"></span><br><span class="line">mc = ma + mb</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(i3,i3,/,i3,i3)&quot;</span>) ((mc(i,j),i=<span class="number">1</span>,<span class="number">2</span>),j=<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>  <span class="number">5</span></span><br><span class="line"><span class="number">5</span>  <span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再介绍一个特别的用法，这个需要和 where 命令搭配</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b &gt; c</span><br></pre></td></tr></table></figure>
<h3 id="7-2-3-对部分数组的操作">7-2-3 对部分数组的操作</h3>
<p>举例如下</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a(<span class="number">3</span>:<span class="number">5</span>) = <span class="number">5</span> <span class="comment">!把a(3) a(4) a(5) 内容设置为5</span></span><br><span class="line">a(<span class="number">3</span>:) =<span class="number">5</span> <span class="comment">!把a(3) 及之后的元素设置为5</span></span><br><span class="line">a(<span class="number">3</span>:<span class="number">5</span>) = (/ <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /)</span><br><span class="line">a(<span class="number">1</span>:<span class="number">3</span>) = b(<span class="number">4</span>:<span class="number">6</span>)</span><br><span class="line">a(<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>) = <span class="number">3</span> <span class="comment">!a(1)=a(3)=a(5)=3</span></span><br><span class="line">a(<span class="number">1</span>:<span class="number">10</span>) = a(<span class="number">10</span>:<span class="number">1</span>:-<span class="number">1</span>) <span class="comment">!反转</span></span><br><span class="line">a(:) = b(:, <span class="number">2</span>) <span class="comment">!a的元素设置为b的第二列</span></span><br></pre></td></tr></table></figure>
<p>要拿数组中一部分内容来使用时，只要把握两个原则就可以：</p>
<ol>
<li>
<p>等号两边所使用的数组元素数目要一样多</p>
</li>
<li>
<p>同时使用多个隐含式循环时，较低维的循环可以想象成是内层的循环。用一个实例来说明这个原则：</p>
</li>
</ol>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">2</span>,<span class="number">2</span>), b(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">b = a(<span class="number">2</span>:<span class="number">1</span>:-<span class="number">1</span>, <span class="number">2</span>:<span class="number">1</span>:-<span class="number">1</span>)</span><br><span class="line"><span class="comment">!b没特别赋值时，等于b(1:2:1, 1:2:1)</span></span><br><span class="line"><span class="comment">!低维的是内层循环，会先执行，所以这个命令结果为</span></span><br><span class="line"><span class="comment">!这个顺序和python的顺序是相反的</span></span><br><span class="line"><span class="comment">!b(1,1) = a(2,2)</span></span><br><span class="line"><span class="comment">!b(2,1) = a(1,2)</span></span><br><span class="line"><span class="comment">!b(1,2) = a(2,1)</span></span><br><span class="line"><span class="comment">!b(2,2) = a(1,1)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面用一个实例来简单示范一下本节的功能</p>
<p>源代码如下</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0709</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: row = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: col = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">2</span>,<span class="number">2</span>)  = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> /)</span><br><span class="line"><span class="comment">! a(1,1)=1,a(2,1)=2,a(1,2)=3,a(2,2)=4</span></span><br><span class="line"><span class="keyword">integer</span> :: b(<span class="number">4</span>) = (/ <span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> /)</span><br><span class="line"><span class="keyword">integer</span> :: c(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) a</span><br><span class="line"><span class="built_in">write</span>(*,*) a(:,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">c = a(:,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">write</span>(*,*) c</span><br><span class="line"></span><br><span class="line">c = a(<span class="number">2</span>,:)</span><br><span class="line"><span class="built_in">write</span>(*,*) c</span><br><span class="line"><span class="built_in">write</span>(*,*) c(<span class="number">2</span>:<span class="number">1</span>:-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">c = b(<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>)</span><br><span class="line"><span class="built_in">write</span>(*,*) c</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>报错了，因为下面这句话，a 是一个二维数组，却赋值给了一个一维数组的值。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">2</span>,<span class="number">2</span>)  = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> /)</span><br></pre></td></tr></table></figure>
<p>改写成如下，另外这里这里声明的 row 和 col 没有用到，可以删掉。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">integer</span> i,j</span><br><span class="line"><span class="keyword">data</span>((a(i,j),i=<span class="number">1</span>,<span class="number">2</span>),j=<span class="number">1</span>,<span class="number">2</span>) /<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>/</span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>           <span class="number">2</span>           <span class="number">3</span>           <span class="number">4</span></span><br><span class="line"><span class="number">1</span>           <span class="number">2</span></span><br><span class="line"><span class="number">1</span>           <span class="number">2</span></span><br><span class="line"><span class="number">2</span>           <span class="number">4</span></span><br><span class="line"><span class="number">4</span>           <span class="number">2</span></span><br><span class="line"><span class="number">5</span>           <span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意 <code>write(*,*) a</code> ，相当于 <code>write(1:2:1,1:2:1) a</code> ，低维的是内层循环，会先进行，所以会按照 a(1,1)  a(2,1) a(1,2)  a(2,2)  的顺序读取。</p>
<h3 id="7-2-4-where">7-2-4 where</h3>
<p>where 是 Fortran95 添加的功能。看一个实例</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0710 </span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>) = (/ (i,i=<span class="number">1</span>,<span class="number">5</span>) /)</span><br><span class="line"><span class="keyword">integer</span> :: b(<span class="number">5</span>) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!把a中小于3的元素设置给b</span></span><br><span class="line"><span class="keyword">where</span>(a&lt;<span class="number">3</span>)</span><br><span class="line">    b = a</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(5(i3,1x))&quot;</span>) b</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="number">2</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这里的 where 相当于</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">5</span></span><br><span class="line">	<span class="keyword">if</span>(a(i) &lt; <span class="number">3</span>) b(i) = a(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>虽然执行结果相同，但是使用 where 更简便，速度更快。</p>
<p>where 描述与 if 有点类似，如果程序模块只有一行命令时，同样可以把这一行命令写在where 后面，并且省略 end where。这个程序的9-11行可以改写为：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span>(a&lt;<span class="number">3</span>) b=a</span><br></pre></td></tr></table></figure>
<p>where 只用于数组，而且用到的所有数组变量，都必须是<strong>同样维数和大小的数组</strong>。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>) = <span class="number">1</span></span><br><span class="line"><span class="keyword">integer</span> :: c(<span class="number">3</span>) = <span class="number">2</span></span><br><span class="line"><span class="keyword">where</span>(a/=<span class="number">0</span>) c=a</span><br><span class="line"><span class="comment">!上一行错误，维数不同</span></span><br><span class="line"><span class="keyword">where</span>(a(<span class="number">1</span>:<span class="number">3</span>)/=<span class="number">0</span>) c=a</span><br><span class="line"><span class="comment">!正确</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>where 还可以配合 elsewhere 来处理逻辑不成立的情况。来看下面的例子。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0711</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>) = (/ (i,i=<span class="number">1</span>,<span class="number">5</span>) /)</span><br><span class="line"><span class="keyword">integer</span> :: b(<span class="number">5</span>) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> (a&lt;<span class="number">3</span>)</span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line"><span class="keyword">elsewhere</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(5(i3,1x))&quot;</span>) b</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">2</span>   <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>where 还可以做多重判断，只要在 elsewhere 后面接上逻辑判断就行了</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span>(a&lt;<span class="number">2</span>)</span><br><span class="line">	b=<span class="number">1</span></span><br><span class="line"><span class="keyword">elsewhere</span>(a&gt;<span class="number">5</span>)</span><br><span class="line">	b=<span class="number">2</span></span><br><span class="line"><span class="keyword">elsewhere</span> <span class="comment">!剩下2&lt;a(i)&lt;5的部分</span></span><br><span class="line">	b=<span class="number">3</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">where</span></span><br></pre></td></tr></table></figure>
<p>where 也可以嵌套，也可以起名字，不过取名的where 描述在结束时 end where 后面一定要接上名字。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">name</span>: <span class="keyword">where</span>(a&lt;<span class="number">5</span>) </span><br><span class="line">	b = a</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">where</span> <span class="keyword">name</span></span><br></pre></td></tr></table></figure>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span>(a&lt;<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">where</span>(a/=<span class="number">2</span>)</span><br><span class="line">		b=<span class="number">3</span></span><br><span class="line">    <span class="keyword">elsewhere</span></span><br><span class="line">    	b=<span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">where</span></span><br><span class="line"><span class="keyword">elsewhere</span></span><br><span class="line">	b = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">where</span></span><br></pre></td></tr></table></figure>
<p>最后再看一个实例，计算10个人的所得税金额</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0712</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"><span class="keyword">real</span> :: income(<span class="number">10</span>) = (/ <span class="number">25000</span>,<span class="number">30000</span>,<span class="number">50000</span>,<span class="number">40000</span>,<span class="number">35000</span>,&amp;</span><br><span class="line">                        <span class="number">60000</span>,<span class="number">27000</span>,<span class="number">45000</span>,<span class="number">20000</span>,<span class="number">70000</span> /)</span><br><span class="line"><span class="keyword">real</span> :: tax(<span class="number">10</span>) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span>(income &lt; <span class="number">30000.0</span>)</span><br><span class="line">    tax = income*<span class="number">0.10</span></span><br><span class="line"><span class="keyword">elsewhere</span>(income &lt; <span class="number">50000.0</span>)</span><br><span class="line">    tax = income*<span class="number">0.12</span></span><br><span class="line"><span class="keyword">elsewhere</span></span><br><span class="line">    tax = income*<span class="number">0.15</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(10(f8.1,1x))&quot;</span>) tax</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2500.0</span>   <span class="number">3600.0</span>   <span class="number">7500.0</span>   <span class="number">4800.0</span>   <span class="number">4200.0</span>   <span class="number">9000.0</span>   <span class="number">2700.0</span>   <span class="number">5400.0</span>   <span class="number">2000.0</span>  <span class="number">10500.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-2-5-forall">7-2-5 forall</h3>
<p>forall 是 Fortran95 添加的功能。它也可以看成是一种使用隐含式循环来使用数组的方式。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0713</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> i</span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">    a(i) = <span class="number">5</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line"><span class="comment">!a(1)=……=a(5)=5</span></span><br><span class="line"><span class="built_in">write</span>(*,*) a</span><br><span class="line"></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">    a(i) = i</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line"><span class="built_in">write</span>(*,*) a</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>           <span class="number">5</span>           <span class="number">5</span>           <span class="number">5</span>           <span class="number">5</span></span><br><span class="line"><span class="number">1</span>           <span class="number">2</span>           <span class="number">3</span>           <span class="number">4</span>           <span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第一段相当于</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">5</span></span><br><span class="line">	a(i) = <span class="number">5</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a(<span class="number">1</span>:<span class="number">5</span>) = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>forall 的 详细语法为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">forall</span> (triplet1[, triplet2[, triplet3……]], mask)</span><br></pre></td></tr></table></figure>
<p>triplet 是用来赋值数组坐标范围的值。</p>
<p>forall 中可以赋值好几个 triplet，数组最多有几维就可以赋值多少个。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">2</span>:<span class="number">10</span>:<span class="number">2</span>, j=<span class="number">1</span>:<span class="number">5</span>) <span class="comment">!二维数组可以用两个数字</span></span><br><span class="line">	a(i,j) = i+j</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br></pre></td></tr></table></figure>
<p>mask 是用来做条件判断，跟 where 命令中使用的条件判断类似，它可以用来限定 forall 程序模块中，只作用于数组中符合条件的元素。还可以做其他的条件限制，直接来看几个例子：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">integer</span> :: i,j</span><br><span class="line"></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>,j=<span class="number">1</span>:<span class="number">5</span>,a(i,j)&lt;<span class="number">10</span>) <span class="comment">!只处理数组a中小于10的元素</span></span><br><span class="line">	a(i,j) = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>,j=<span class="number">1</span>:<span class="number">5</span>,i==j)</span><br><span class="line"><span class="comment">!只做i==j的情况</span></span><br><span class="line">	a(i,j) = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>,j=<span class="number">1</span>:<span class="number">5</span>,((i&gt;j) .and. a(i,j) &gt; <span class="number">0</span>))</span><br><span class="line"><span class="comment">!多个判断条件</span></span><br><span class="line">	a(i,j) = <span class="number">1</span>/a(i,j)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>forall 描述中的程序模块如果只有一行程序代码时，也可以省略 end forall ， 把程序模块跟forall 写在同一行，就跟 if 及 where 的情况相同。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>, j=<span class="number">1</span>:<span class="number">5</span>, a(i,j) /= <span class="number">0</span>) a(i,j) = <span class="number">1</span>/a(i,j) </span><br></pre></td></tr></table></figure>
<p>再看一个实例，声明一个二维数组作为二维矩阵使用。它使用 forall 命令把矩阵的上半部设置为1， 对角线部分设置为2， 下半部设置为3。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0714</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> i,j</span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: <span class="built_in">size</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="built_in">size</span>,<span class="built_in">size</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="built_in">size</span>,j=<span class="number">1</span>:<span class="built_in">size</span>,i&gt;j) a(i,j) = <span class="number">1</span> <span class="comment">!上半部</span></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="built_in">size</span>,j=<span class="number">1</span>:<span class="built_in">size</span>,i==j) a(i,j) = <span class="number">2</span> <span class="comment">!对角线</span></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="built_in">size</span>,j=<span class="number">1</span>:<span class="built_in">size</span>,i&lt;j) a(i,j) = <span class="number">3</span> <span class="comment">!下半部</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(5(5i5,/))&quot;</span>) a</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>    <span class="number">1</span>    <span class="number">1</span>    <span class="number">1</span>    <span class="number">1</span></span><br><span class="line"><span class="number">3</span>    <span class="number">2</span>    <span class="number">1</span>    <span class="number">1</span>    <span class="number">1</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span>    <span class="number">2</span>    <span class="number">1</span>    <span class="number">1</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span>    <span class="number">3</span>    <span class="number">2</span>    <span class="number">1</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span>    <span class="number">3</span>    <span class="number">3</span>    <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>forall 可以写成多层的嵌套结构。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">forall</span>(j=<span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">		a(i,j) = <span class="number">2</span></span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line">	<span class="keyword">forall</span>(j=<span class="number">6</span>:<span class="number">10</span>)</span><br><span class="line">		a(i,j) = <span class="number">2</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br></pre></td></tr></table></figure>
<p>forall 中还可以嵌套 where。不过 where 当中不能使用 forall。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">where</span>(a(:,i)/=<span class="number">0</span>) </span><br><span class="line">		a(:,i) = <span class="number">1.0</span>/a(:,i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">where</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br></pre></td></tr></table></figure>
<h2 id="7-3-数组的保存规则">7-3 数组的保存规则</h2>
<p>一个数组不管是声明成什么“形状”（指维数和大小），它的所有元素都是分布再计算机内存的同一个连续模块当中。一维数组是最简单的，它的元素在内存中的排列位置刚好就依照元素的顺序。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">5</span>)</span><br><span class="line"><span class="comment">!元素在内存连续模块中的排列顺序为</span></span><br><span class="line"><span class="comment">!a(1) → a(2) → a(3) →  a(4) → a(5)</span></span><br></pre></td></tr></table></figure>
<p>多维数组的元素，在内存中的排列情况按照 “Column Major” 的方法来排列。先使用二维数组来解释，会先放入 column 中 每个 row 的元素， 第一个 column 放完了再放第二个 column。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">!a(1,1) → a(2,1) → a(3,1) (先放入第1个column中的元素)</span></span><br><span class="line"><span class="comment">!a(1,2) → a(2,2) → a(3,2) (再放入第2个column中的元素)</span></span><br><span class="line"><span class="comment">!a(1,3) → a(2,3) → a(3,3) (最后放入第3个column中的元素)</span></span><br></pre></td></tr></table></figure>
<p>引申到多维数组，会先放入较低维的元素，再放入较高维的元素。来看一个三维数组的实例</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">!a(1,1,1) → a(2,1,1) (先放入第1维)</span></span><br><span class="line"><span class="comment">!a(1,2,1) → a(2,2,1) (接着放入第2维)</span></span><br><span class="line"><span class="comment">!a(1,1,2) → a(2,1,2) (接着放入第3维)</span></span><br><span class="line"><span class="comment">!a(1,2,2) → a(2,2,2) </span></span><br></pre></td></tr></table></figure>
<p>用循环依照内存顺序读出这个数组的方法为：</p>
<p>这个有点难看懂，首先do 是内层先循环，这里维数越小的放在内层，也就是维数越小的先循环。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">	<span class="keyword">do</span> j=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">		<span class="keyword">do</span> k=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">			<span class="comment">!维越小的使用越内层的循环</span></span><br><span class="line">			<span class="built_in">write</span>(*,*) a(k,j,i)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>计算机原理：如果读取的数据比较近，速度会比较快。</p>
<p>因此，下面这种是比较不好的写法：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">	<span class="keyword">do</span> j=<span class="number">1</span>,m</span><br><span class="line">		a(i,j) = </span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>因为 a(i,j) 和 a(i,j+1) 在内存中的位置并不是连续的。下面的写法会比较好一点：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">	<span class="keyword">do</span> j=<span class="number">1</span>,m</span><br><span class="line">		a(j,i) = </span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>只要简单地把 i, j 的使用位置交换，就可以得到比较好的效率。因为 a(j,i) 和 a(j+1,i) 在内存中的位置是连续的。</p>
<p>解释过数组在内存的排列方法后，再回忆设置初值的部分，现在可以理解下面的程序为什么会有那样子的结果</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">2</span>,<span class="number">2</span>) = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> /)</span><br><span class="line"><span class="comment">!a(1,1)=1, a(2,1)=2, a(1,2)=3, a(2,2)=4</span></span><br><span class="line"><span class="comment">!正好是根据内存的排列顺序来设置数值</span></span><br></pre></td></tr></table></figure>
<h2 id="7-4-可变大小的数组">7-4 可变大小的数组</h2>
<p>某些情况下，要等程序执行之后，才会知道所需要使用的数组大小。</p>
<p>如果数组大小不能改变，只能这么编写程序：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0715</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: <span class="built_in">max</span> = <span class="number">1000</span></span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="built_in">max</span>) <span class="comment">!先声明一个超级大的数组</span></span><br><span class="line"><span class="keyword">integer</span> :: students</span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;How many students:&quot;</span></span><br><span class="line">read(*,*) students <span class="comment">!输入的数值不能超过 max</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!输入成绩</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,students</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Number &#x27;,i3)&quot;</span>) i</span><br><span class="line">    read(*,*) a(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> How many students:</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="keyword">Number</span>   <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">Number</span>   <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个做法是无可奈何的做法，首先声明一个超大的数组，然后再来使用数组的一小部分。</p>
<p>Fortran90 的数组则可以等到程序执行后，根据需求来实时决定它的大小。来看看下面的写法</p>
<p>这里用一个 ：表示 a是一维数组</p>
<p>分配内存空间的值可以使用变量，不像在声明一般数组时需要使用常量。</p>
<p>deallocate 可以释放内存。使用这两个命令可以用来重新设置数组大小。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0716</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: students</span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">allocatable</span> :: a(:) <span class="comment">!声明一个可变大小的一维数组</span></span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;How many students:&quot;</span></span><br><span class="line">read(*,*) students</span><br><span class="line"><span class="built_in">allocate</span>(a(students)) <span class="comment">!配置内存空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!输入成绩</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,students</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Number &#x27;,i3)&quot;</span>) i</span><br><span class="line">    read(*,*) a(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么，我在想，可不可以等知道需要多大的时候，再声明数组。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0716_2</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: students</span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;How many students:&quot;</span></span><br><span class="line">read(*,*) students</span><br><span class="line"></span><br><span class="line"><span class="keyword">integer</span> :: a(students)</span><br><span class="line"></span><br><span class="line"><span class="comment">!输入成绩</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,students</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Number &#x27;,i3)&quot;</span>) i</span><br><span class="line">    read(*,*) a(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不行，报错，貌似声明变量只能放在最前面</p>
<p>Fortran 报错应该也是看第一个报错。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EX0716_2.F90:<span class="number">9.22</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">integer</span> :: a(students)</span><br><span class="line">                      <span class="number">1</span></span><br><span class="line">Error: Unexpected <span class="keyword">data</span> declaration statement at (<span class="number">1</span>)</span><br><span class="line">EX0716_2.F90:<span class="number">14.15</span>:</span><br><span class="line"></span><br><span class="line">    read(*,*) a(i)</span><br><span class="line">               <span class="number">1</span></span><br><span class="line">Error: Syntax error <span class="keyword">in</span> READ statement at (<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于内存空间有限，当然也就不能无限地要求空间。加一个 stat 的文本来判断内存配置是否成功。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">allocate</span>(a(<span class="number">100</span>),stat = error) <span class="comment">!如果error=0 表示分配成功；其他值表示分配失败</span></span><br></pre></td></tr></table></figure>
<p>声明其他维度的数组</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span>,<span class="keyword">allocatable</span> :: a2(:,:) <span class="comment">!二维数组</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">allocatable</span> :: a3(:,:,:) <span class="comment">!三维数组</span></span><br><span class="line"><span class="built_in">allocate</span>(a2(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line"><span class="built_in">allocate</span>(a3(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<p>和 allocate 相关的函数还有 allocated ，用于检查一个可变大小的矩阵是否已经分配内存来使用，它会返回一个逻辑值。例如</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(.not. <span class="built_in">allocated</span>(a)) <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">allocate</span>(a(<span class="number">5</span>))</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="comment">!检查数组a是否分配内存，没有则分配5个</span></span><br></pre></td></tr></table></figure>
<h2 id="7-5-数组的应用">7-5 数组的应用</h2>
<p>首先看一个实用的问题，数组的排序。</p>
<p>先示范一个最简单的排序方法，叫做选择排序法</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0718</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: <span class="built_in">size</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="built_in">size</span>) = (/ <span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">10</span> /)</span><br><span class="line"><span class="keyword">integer</span> :: i,j</span><br><span class="line"><span class="keyword">integer</span> :: t</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="built_in">size</span>-<span class="number">1</span></span><br><span class="line">    <span class="keyword">do</span> j=i+<span class="number">1</span>,<span class="built_in">size</span></span><br><span class="line">        <span class="keyword">if</span>(a(i) &gt; a(j)) <span class="keyword">then</span> <span class="comment">!a(i)跟a(j) 交换</span></span><br><span class="line">            t = a(i) </span><br><span class="line">            a(i) = a(j)</span><br><span class="line">            a(j) = t</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(10i4)&quot;</span>) a</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>这个排序方法很简单，先说明它的步骤：</p>
<ol>
<li>把全部10个数字中，最小的那个找出来，跟 a(1) 交换位置。</li>
<li>把a(2~10)中，最小的那个找出来，跟 a(2) 交换位置。</li>
</ol>
<p>​    ……</p>
<ol start="9">
<li>把a(9~10)中，最小的那个找出来，跟 a(9) 交换位置，排序完成。</li>
</ol>
<p>具体看交换位置的内容</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = a(i) <span class="comment">!先把a(i)存起来</span></span><br><span class="line">a(i) = a(j) <span class="comment">!a(i) 设置成 a(j) 的值</span></span><br><span class="line">a(j) = t <span class="comment">!a(j) 设置成 a(i) 的值</span></span><br></pre></td></tr></table></figure>
<p>这里需要有一个中间变量。如果只用两个变量，会出错</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a(i) = a(j) <span class="comment">!a(i) 设置成 a(j) 的值</span></span><br><span class="line">a(j) = a(i) </span><br><span class="line"><span class="comment">!这里a(j)设置成a(i)的值，不过由于上一行a(i)已经设置成a(j)了。</span></span><br><span class="line"><span class="comment">!所以这一行白做工，啥也没干</span></span><br></pre></td></tr></table></figure>
<p>再看一个实例，做一个矩阵相乘的程序。</p>
<p>假设现在有两个二维矩阵 A, B，其中 A 的大小为 L*M ， B的大小为 M*N。现在要计算 C = A*B，它的大小一定为 L*N</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0719</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: l=<span class="number">3</span>,m=<span class="number">4</span>,n=<span class="number">2</span></span><br><span class="line"><span class="keyword">real</span> :: a(l,m)</span><br><span class="line"><span class="keyword">real</span> :: b(m,n)</span><br><span class="line"><span class="keyword">real</span> :: c(l,n)</span><br><span class="line"><span class="keyword">integer</span> :: i,j,k</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span>((a(i,j),i=<span class="number">1</span>,l),j=<span class="number">1</span>,m) / <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span> /</span><br><span class="line"><span class="keyword">data</span>((b(i,j),i=<span class="number">1</span>,m),j=<span class="number">1</span>,n) / <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> /</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i = <span class="number">1</span>,l</span><br><span class="line">    <span class="keyword">do</span> j = <span class="number">1</span>,n</span><br><span class="line">        c(i,j) = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">do</span> k=<span class="number">1</span>,m</span><br><span class="line">            c(i,j) = c(i,j) + a(i,k)*b(k,j)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,l</span><br><span class="line">    <span class="built_in">write</span>(*,*) c(i,:)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">70.0000000</span>       <span class="number">158.000000</span></span><br><span class="line"><span class="number">80.0000000</span>       <span class="number">184.000000</span></span><br><span class="line"><span class="number">90.0000000</span>       <span class="number">210.000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先要搞清楚，多层循环，内层先循环。这里也就是 i 和 j 不变，k 先循环一遍。得到的累加的结果就是 c(i,j) 的值。</p>
<p>事实上Fortran 90 库存函数就有提供 matmul 函数来做矩阵乘法。不过还是有必要学会作矩阵乘法的程序方法。</p>
<p>如果用函数，就一句解决</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="built_in">matmul</span>(a,b)</span><br></pre></td></tr></table></figure>
<h2 id="7-6-习题">7-6 习题</h2>
<p>1 声明一个大小为 10 的一维数组，初值为 a(i) = 2i ，并计算均值</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0720 </span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"><span class="keyword">integer</span> :: sum_a = <span class="number">0</span></span><br><span class="line"><span class="keyword">real</span> :: mean_a</span><br><span class="line"></span><br><span class="line"><span class="comment">!分配值</span></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">10</span>)</span><br><span class="line">    a(i) = <span class="number">2</span>*i <span class="comment">!开始少了*</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!求和</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">10</span></span><br><span class="line">    sum_a = sum_a + a(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">mean_a = <span class="keyword">real</span>(sum_a)/<span class="number">10.0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(f6.2)&quot;</span>) mean_a</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11.00</span></span><br></pre></td></tr></table></figure>
<p>3 编写一个程序来计算前10个费氏数列，并保存在一个一维数组中。</p>
<p>费氏数列的规则</p>
<p>f(0) = 0</p>
<p>f(1) = 1</p>
<p>当 n &gt; 1, f(n) = f(n-1) + f(n-2)</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0721</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">0</span>:<span class="number">9</span>) <span class="comment">!注意这里的索引从0开始</span></span><br><span class="line"><span class="keyword">integer</span> :: i,j</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">0</span>,<span class="number">9</span></span><br><span class="line">    <span class="keyword">if</span> (i==<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        a(i) = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">        a(i) = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a(i) = a(i-<span class="number">1</span>) + a(i-<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(10i4)&quot;</span>) a</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>   <span class="number">1</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">5</span>   <span class="number">8</span>  <span class="number">13</span>  <span class="number">21</span>  <span class="number">34</span></span><br></pre></td></tr></table></figure>
<p>4 把排序程序 ex0718 改为从大排到小</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0718</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: <span class="built_in">size</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="built_in">size</span>) = (/ <span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">10</span> /)</span><br><span class="line"><span class="keyword">integer</span> :: i,j</span><br><span class="line"><span class="keyword">integer</span> :: t</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="built_in">size</span>-<span class="number">1</span></span><br><span class="line">    <span class="keyword">do</span> j=i+<span class="number">1</span>,<span class="built_in">size</span></span><br><span class="line">        <span class="keyword">if</span>(a(i) &lt; a(j)) <span class="keyword">then</span> <span class="comment">!a(i)跟a(j) 交换</span></span><br><span class="line">            t = a(i) </span><br><span class="line">            a(i) = a(j)</span><br><span class="line">            a(j) = t</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(10i4)&quot;</span>) a</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>就是改一个符号</p>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>   <span class="number">9</span>   <span class="number">8</span>   <span class="number">7</span>   <span class="number">6</span>   <span class="number">5</span>   <span class="number">4</span>   <span class="number">3</span>   <span class="number">2</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1>8 函数</h1>
<p>函数是自定义函数和子程序的统称。</p>
<p>字符 →  Token  → 语句  →  程序单元  → 模块（module）  → 程序</p>
<p>程序单元： 执行某一特定任务的具有一定独立性的代码区域。包括<strong>主程序</strong>，<strong>子程序</strong>，<strong>函数</strong>。</p>
<blockquote>
<p>子程序 是没有返回值的函数</p>
<p>主程序只是默认被系统首次调用的，具有程序入口点作用的函数</p>
<p>程序单元的存在，是为了提高代码<strong>重复利用率</strong>。因此，各程序代码越“独立”，越能体现重复利用的作用。</p>
<p>一组程序单元及一组相关联的变量，可组成模块（module）</p>
</blockquote>
<blockquote>
<p>程序单元间的变量，一般是互相不通的！</p>
<p>implicit none 应该写在每一个程序单元</p>
</blockquote>
<h2 id="8-1-子程序（subroutine）的使用">8-1 子程序（subroutine）的使用</h2>
<p>写程序时，可以把某一段常常被使用、具有特定功能的程序代码独立出来，封装成子程序，以后只要经过调用的 call 命令就可以执行这一段程序代码。</p>
<p>先看一个例子</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0801</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">call</span> message() <span class="comment">!调用子程序 message</span></span><br><span class="line"><span class="keyword">call</span> message() <span class="comment">!再调用一次</span></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!子程序message</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> message()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Hello.&quot;</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>子程序里可以包含所有命令，甚至包括调用其他子程序。</p>
<p>子程序和主程序的最大不同处在于：“主程序的程序代码，在程序一开始就自动会被执行，而子程序则不会自动执行，它需要被别人‘调用’ 才会执行。”</p>
<p>子程序以 subroutine 开头，同样要取一个名字，以end 或 end subroutine 结束（这个觉得更好）。严格地讲， end subroutine 后还可以接子程序的名字。</p>
<p>一个包含子程序的 Fortran 程序在结构上的模样大致如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> main <span class="comment">!主程序</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub1() <span class="comment">!第一个子程序</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> sub1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub2() <span class="comment">!第二个子程序</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> sub2</span><br></pre></td></tr></table></figure>
<p>其中，对主程序和子程序的安放顺序不作要求。</p>
<p>子程序最后一个命令通常是 “return&quot; ，表示程序要”返回“ 原来调用它的地方来继续执行程序（不写也可以，程序会自动返回）。<strong>return 可以使用在子程序中的任何地方，让子程序提早返回</strong>。</p>
<p>子程序除了可以让主程序调用之外，子程序之间也可以互相调用。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0802 </span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">call</span> sub1()</span><br><span class="line"><span class="keyword">call</span> sub2()</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> ex0802</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub1()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span> </span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;This is sub1&quot;</span></span><br><span class="line"><span class="keyword">call</span> sub2()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> sub1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub2()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;This is sub2&quot;</span></span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> sub2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This is sub1 <span class="comment">!调用sub1</span></span><br><span class="line">This is sub2 <span class="comment">!调用sub1, sub1中又调用sub2</span></span><br><span class="line">This is sub2 <span class="comment">!调用sub2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>子程序可以在程序的任何地方被别人调用，甚至可以自己调用自己。这个操作称为”递归“。</p>
<p>关于子程序还有一个重要的概念，就是 ”子程序独立地拥有属于自己的变量声明”。也就是说，在主程序和其他的子程序之间，所声明出来的变量彼此是不相干的，假设在主程序与其他的子程序中使用了相同的变量名称，它们也是没有关系的不同变量。（说白了，就是变量空间呗）</p>
<p>来看一个实例</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0803</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a = <span class="number">1</span></span><br><span class="line"><span class="keyword">call</span> sub1()</span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;a=&#x27;,i2)&quot;</span>) a</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> ex0803</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub1()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a = <span class="number">2</span></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;a=&#x27;,i2)&quot;</span>) a</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> sub1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a= <span class="number">2</span> <span class="comment">!子程序</span></span><br><span class="line">a= <span class="number">1</span> <span class="comment">!主程序</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>除了变量独立以外，子程序也独立地拥有自己的“行代码”。</p>
<p>不过，有时候，调用子程序时，可以同时传递一些变量数据过去让它处理，这个操作叫做 ”传递参数“。</p>
<p>来看一个实例。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0804</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a = <span class="number">1</span></span><br><span class="line"><span class="keyword">integer</span> :: b = <span class="number">2</span></span><br><span class="line"><span class="keyword">call</span> add(a,b)</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> ex0804</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> add(first,second)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: first,second <span class="comment">!内容从 call中得到</span></span><br><span class="line"><span class="built_in">write</span>(*,*) first+second</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> add</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Fortran 在传递参数时使用的是传址调用（call by address/call by reference），这个意思是说所传递的参数，和子程序接收的参数，它们会使用相同的内存地址来记录数据（使用同一块内存来记录，可以视为同一个变量）。</p>
<p>比如，这里 first 和 a 会使用相同的内存地址来存储数值，所以 first 的值会等于 a，而<strong>如果修改first 的值，a 的内容也会跟着修改</strong>。</p>
<p>再来看一个实例。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0805</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a = <span class="number">1</span></span><br><span class="line"><span class="keyword">integer</span> :: b = <span class="number">2</span></span><br><span class="line"><span class="built_in">write</span>(*,*) a,b</span><br><span class="line"><span class="keyword">call</span> add(a)</span><br><span class="line"><span class="keyword">call</span> add(b)</span><br><span class="line"><span class="built_in">write</span>(*,*) a,b</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> ex0805</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> add(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: num</span><br><span class="line">num = num + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> add</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>           <span class="number">2</span></span><br><span class="line"><span class="number">2</span>           <span class="number">3</span> <span class="comment">!调用子程序后，修改了a,b</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有的程序语言会使用 “传值调用” （call by value）来传递参数，像C语言就使用传值调用。使用传值调用的程序语言，在子程序中改变参数内容，不会影响到调用处的变量内容。混合使用这两种语言时要注意这一点。（python 是只能调用，不能改变值的大小）</p>
<p>了解子程序的使用规则后，现在写一些比较有用途的东西。假设在一场田径赛的标枪选项中，有5位选手的投掷标枪的情况如下：</p>
<blockquote>
<p>1号选手：以30度角，每秒25米的速度掷出标枪。</p>
<p>2号选手：以45度角，每秒20米的速度掷出标枪。</p>
<p>3号选手：以35度角，每秒21米的速度掷出标枪。</p>
<p>4号选手：以50度角，每秒27米的速度掷出标枪。</p>
<p>5号选手：以40度角，每秒22米的速度掷出标枪。</p>
</blockquote>
<p>假设忽略空气阻力以及身高等等的因素，请写一个程序来计算选手们的投射距离。（自由投射物体的抛物线距离）。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0806</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: players = <span class="number">5</span></span><br><span class="line"><span class="keyword">real</span> :: angle(players) = (/ <span class="number">30.0</span>,<span class="number">45.0</span>,<span class="number">35.0</span>,<span class="number">50.0</span>,<span class="number">40.0</span> /)</span><br><span class="line"><span class="keyword">real</span> :: speed(players) = (/ <span class="number">25.0</span>,<span class="number">20.0</span>,<span class="number">21.0</span>,<span class="number">27.0</span>,<span class="number">22.0</span> /)</span><br><span class="line"><span class="keyword">real</span> :: distance(players)</span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,players</span><br><span class="line">    <span class="keyword">call</span> get_distance(angle(i),speed(i),distance(i))</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Player &#x27;,i1,&#x27; =&#x27;,f8.2)&quot;</span>) i,distance(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> ex0806</span><br><span class="line"></span><br><span class="line"><span class="comment">!把0-360的角度转换成弧度</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> angle_to_rad(angle,rad)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> angle,rad</span><br><span class="line"><span class="keyword">real</span>,<span class="keyword">parameter</span> :: pi = <span class="number">3.14159</span></span><br><span class="line">rad = angle*pi/<span class="number">180.0</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> angle_to_rad</span><br><span class="line"></span><br><span class="line"><span class="comment">!由角度、切线速度来计算投射距离</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> get_distance(angle,speed,distance)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> angle,speed <span class="comment">!输入的参数</span></span><br><span class="line"><span class="keyword">real</span> distance  <span class="comment">!返回结果</span></span><br><span class="line"><span class="keyword">real</span> rad,vx,time <span class="comment">!内部使用</span></span><br><span class="line"><span class="keyword">real</span>,<span class="keyword">parameter</span> :: g=<span class="number">9.81</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> angle_to_rad(angle,rad) <span class="comment">!单位转换</span></span><br><span class="line">vx = speed*<span class="built_in">cos</span>(rad) <span class="comment">!水平方向速度</span></span><br><span class="line">time = <span class="number">2.0</span>*speed*<span class="built_in">sin</span>(rad)/g <span class="comment">!在空中飞行时间</span></span><br><span class="line">distance = vx*time <span class="comment">!距离</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> get_distance</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Player <span class="number">1</span> =   <span class="number">55.17</span></span><br><span class="line">Player <span class="number">2</span> =   <span class="number">40.77</span></span><br><span class="line">Player <span class="number">3</span> =   <span class="number">42.24</span></span><br><span class="line">Player <span class="number">4</span> =   <span class="number">73.18</span></span><br><span class="line">Player <span class="number">5</span> =   <span class="number">48.59</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>感觉函数和子程序最好还是用<strong>大小写混合</strong>，和一般变量区分开。</p>
<p>这种比较长的程序，需要有一个相应的说明书，写明每个子程序输入的参数、参数类型以及调用的功能。规范如下</p>
<blockquote>
<p><em>subroutine Get_Distance (angle, speed, distance)</em></p>
<p>功能：</p>
<p>计算投掷距离，只要输入速度（speed）及角度（angle），就可以由 distance 返回值中得到投掷距离。</p>
<p>参数：</p>
<p>real angle  输入投掷出去的角度</p>
<p>real speed 输入投掷出去的速度</p>
<p>real distance 返回计算得到的投掷距离</p>
<p><em>subroutine Angle_To_Rad (angle, rad)</em></p>
<p>功能：</p>
<p>把”角度“ 值转换成 ”弧度“， 输入一个角度就可以由 rad 得到转换出来的弧度。</p>
<p>参数：</p>
<p>real angle 输入所有转换的角度值</p>
<p>real rad     返回所对应的弧度值</p>
</blockquote>
<p>知道每一个子程序的功能后，可以直接阅读主程序来了解这个程序的运行。</p>
<h2 id="8-2-自定义函数（function">8-2 自定义函数（function)</h2>
<p>函数和子程序只有两点不同：</p>
<ol>
<li>调用自定义函数前要先声明。</li>
<li>自定义函数执行后会返回一个数值。</li>
</ol>
<p>先来看一个简单的实例</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0807</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> :: a = <span class="number">1</span></span><br><span class="line"><span class="keyword">real</span> :: b = <span class="number">2</span></span><br><span class="line"><span class="keyword">real</span>,<span class="keyword">external</span> :: Add <span class="comment">!声明 add是一个函数而不是变量</span></span><br><span class="line"><span class="comment">!调用函数add，调用函数不必使用call命令</span></span><br><span class="line"><span class="built_in">write</span>(*,*) Add(a,b)</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span></span> Add(a,b)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> :: a,b</span><br><span class="line"><span class="keyword">real</span> :: add</span><br><span class="line"><span class="comment">!add和函数名称一样，这里不是用来声明变量</span></span><br><span class="line"><span class="comment">!是声明这个函数会返回的数值类型</span></span><br><span class="line">add = a+b</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.00000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第14行是声明函数返回值的类型，这句可以合并在 function 的行</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> add(a,b) </span><br></pre></td></tr></table></figure>
<p>使用函数时有一个**”不成文规定“** ：”<strong>传递给函数的参数，只准读取，不要改变它的数值</strong>。</p>
<p>如果想要改变输入的参数时，最好使用子程序，而不是使用函数来完成这个工作。</p>
<p>上一节计算投标枪的程序很适合使用函数来编写，来看看改写后的结果：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0808</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: players = <span class="number">5</span></span><br><span class="line"><span class="keyword">real</span> :: angle(players) = (/ <span class="number">30.0</span>,<span class="number">45.0</span>,<span class="number">35.0</span>,<span class="number">50.0</span>,<span class="number">40.0</span> /)</span><br><span class="line"><span class="keyword">real</span> :: speed(players) = (/ <span class="number">25.0</span>,<span class="number">20.0</span>,<span class="number">21.0</span>,<span class="number">27.0</span>,<span class="number">22.0</span> /)</span><br><span class="line"><span class="keyword">real</span> :: distance(players)</span><br><span class="line"><span class="keyword">real</span>,<span class="keyword">external</span> :: Get_Distance <span class="comment">!声明Get_Distance 是个函数</span></span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,players</span><br><span class="line">    distance(i) =  Get_Distance(angle(i),speed(i))</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Player &#x27;,i1,&#x27; =&#x27;,f8.2)&quot;</span>) i,distance(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> ex0808</span><br><span class="line"></span><br><span class="line"><span class="comment">!把0-360的角度转换成弧度</span></span><br><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Angle_To_Rad(angle)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> angle</span><br><span class="line"><span class="keyword">real</span>,<span class="keyword">parameter</span> :: pi = <span class="number">3.14159</span></span><br><span class="line">Angle_To_Rad = angle*pi/<span class="number">180.0</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!由角度、切线速度来计算投射距离</span></span><br><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Get_Distance(angle,speed)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> angle,speed <span class="comment">!输入的参数</span></span><br><span class="line"><span class="keyword">real</span> rad,vx,time <span class="comment">!内部使用</span></span><br><span class="line"><span class="keyword">real</span>,<span class="keyword">external</span> :: Angle_To_Rad <span class="comment">!声明Angle_To_Rad是个函数</span></span><br><span class="line"><span class="keyword">real</span>,<span class="keyword">parameter</span> :: g=<span class="number">9.81</span></span><br><span class="line"></span><br><span class="line">rad = Angle_To_Rad(angle) <span class="comment">!单位转换</span></span><br><span class="line">vx = speed*<span class="built_in">cos</span>(rad) <span class="comment">!水平方向速度</span></span><br><span class="line">time = <span class="number">2.0</span>*speed*<span class="built_in">sin</span>(rad)/g <span class="comment">!在空中飞行时间</span></span><br><span class="line">Get_Distance = vx*time <span class="comment">!距离</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用函数来改写后，可以比原来的程序少输入一个参数。因为计算结果值直接由函数返回去，不需要另外使用变量来返回结果。</p>
<h2 id="8-3-全局变量（common）">8-3 全局变量（common）</h2>
<p>不同的程序（不同的函数，主程序和函数）之间，除了可以通过传递参数的方法来共享内存，还可以通过“全局变量” 来让不同程序中声明出来的变量使用相同的内存位置。</p>
<h3 id="8-3-1-common-的使用">8-3-1 common 的使用</h3>
<p>来可以一个实例</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0810</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a,b</span><br><span class="line"><span class="keyword">common</span> a,b <span class="comment">!定义a,b是全局变量中的第1及第2个变量</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="keyword">call</span> ShowCommon()</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowCommon()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: num1,num2</span><br><span class="line"><span class="keyword">common</span> num1,num2 <span class="comment">!定义num1,num2是全局变量中的第1个及第2个变量</span></span><br><span class="line"><span class="built_in">write</span>(*,*) num1,num2</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>           <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>取用全局变量时，是根据它们声明时的<strong>相对位置</strong>关系来作对应，而不是使用变量名称。因此这里的 a 和 num1 都是指向第一个全局变量，b 和 num2 都是指向第二个全局变量。</p>
<p>如果在程序的任何一个地方改变了全局变量的值，因为全局变量都使用相同的内存位置，所以程序中的每一个函数中都可以觉察到这个变动。</p>
<p>由于全局变量是使用“地址对应”的方法共享数据，因此如果你只想调出第6个全局变量，也得宣告出前5个全局变量在前面垫着。</p>
<p>这种麻烦在全局变量多的情况之下更为惊人。有一种方法可以减少这个麻烦，就是可以把变量归类，放在彼此独立的 common 区间中。</p>
<p>来看下面这个程序</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0811</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a,b</span><br><span class="line"><span class="keyword">common</span> /group1/ a <span class="comment">!变量a 放在group1中</span></span><br><span class="line"><span class="keyword">common</span> /group2/ b</span><br><span class="line">a=<span class="number">1</span></span><br><span class="line">b=<span class="number">2</span></span><br><span class="line"><span class="keyword">call</span> Show_Group1()</span><br><span class="line"><span class="keyword">call</span> Show_Group2()</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Show_Group1()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: num1</span><br><span class="line"><span class="keyword">common</span> /group1/ num1</span><br><span class="line"><span class="built_in">write</span>(*,*) num1</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Show_Group2()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: num2</span><br><span class="line"><span class="keyword">common</span> /group2/ num2</span><br><span class="line"><span class="built_in">write</span>(*,*) num2</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么，什么时候该使用参数，什么时候该使用全局变量呢？</p>
<p>简单地说，当需要共享的变量不多，而且只有少数几个程序需要使用这些数据时，那就使用参数。需要共享大笔数据，或是有很多个不同程序都需要使用这些数据时，就使用全局变量。</p>
<h3 id="8-3-2-block-data">8-3-2 block data</h3>
<p>关于全局变量，还有一点要介绍的就是设置初值的方法，common 变量不能直接在子程序或主程序中使用 data 来设置初值，要在 block data 程序模块中使用 data 命令来设置初值，直接看一个程序。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0812</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a,b</span><br><span class="line"><span class="keyword">common</span> a,b</span><br><span class="line"><span class="keyword">integer</span> :: c,d</span><br><span class="line"><span class="keyword">common</span> /group1/ c,d</span><br><span class="line"><span class="keyword">integer</span> :: e,f</span><br><span class="line"><span class="keyword">common</span> /group2/ e,f</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(6i4)&quot;</span>) a,b,c,d,e,f</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">block</span> <span class="keyword">data</span></span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> a,b</span><br><span class="line"><span class="keyword">common</span> a,b </span><br><span class="line"><span class="keyword">data</span> a,b /<span class="number">1</span>,<span class="number">2</span>/</span><br><span class="line"><span class="keyword">integer</span> :: c,d</span><br><span class="line"><span class="keyword">common</span> /group1/ c,d</span><br><span class="line"><span class="keyword">data</span> c,d /<span class="number">3</span>,<span class="number">4</span>/</span><br><span class="line"><span class="keyword">integer</span> :: e,f</span><br><span class="line"><span class="keyword">common</span> /group2/ e,f</span><br><span class="line"><span class="keyword">data</span> e,f /<span class="number">5</span>,<span class="number">6</span>/</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">block</span> <span class="keyword">data</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>block data 会自己执行，事实上这一段程序会在主程序执行前就会生效，不过只能设置初值（那有球用）。还有一点，全局变量不能设置为常数，所以block data中不能出现 parameter。</p>
<h3 id="8-3-3-注意事项">8-3-3 注意事项</h3>
<p>使用 common 时要注意两点：</p>
<ol>
<li>变量的类型</li>
<li>变量的位置</li>
</ol>
<p>来看一个例子</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0813</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> a</span><br><span class="line"><span class="keyword">common</span> a <span class="comment">!把浮点数a放在全局变量中</span></span><br><span class="line">a = <span class="number">1.0</span></span><br><span class="line"><span class="keyword">call</span> Show_Common()</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Show_Common()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> a</span><br><span class="line"><span class="keyword">common</span> a</span><br><span class="line"><span class="built_in">write</span>(*,*) a <span class="comment">!把整数a放在全局变量中</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行后输出一个很奇怪的数值</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1065353216</span></span><br></pre></td></tr></table></figure>
<p>主程序把全局变量设置为 1.0 , 但是在子程序中却声明成整数。这是存入数据的时候按照浮点数的规则，读取数据的时候又按照整数的规则。但是浮点数和整数保存规则不同。</p>
<p>使用 common 时还有一些技巧，来看下一个例子。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0814</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> a,b</span><br><span class="line"><span class="keyword">common</span> a,b <span class="comment">!把浮点数a,b加入全局变量中</span></span><br><span class="line">a = <span class="number">1.0</span></span><br><span class="line">b = <span class="number">2.0</span></span><br><span class="line"><span class="keyword">call</span> Show_Common()</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Show_Common()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> a(<span class="number">2</span>) </span><br><span class="line"><span class="keyword">common</span> a <span class="comment">!把数组a放入到全局变量中</span></span><br><span class="line"><span class="built_in">write</span>(*,*) a(<span class="number">1</span>),a(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.00000000</span>       <span class="number">2.00000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里使用全局变量时，把握了它们会使用相同内存空间的策略。主程序中在全局变量中放了两个变量a和b，子程序也放入了两个变量，不过它放的是一个大小为2 的数组。所以数组的第1个值就等于主程序中的变量a，第2个值等于主程序中的变量b。</p>
<p>使用 COMMON 时，编译器并不会帮忙做类型检查的工作，这个责任要由程序员自行负责。有一点很麻烦的是，如果要修改 COMMON 的数据类型，要改的地方可能会很多。</p>
<p>Fortran90 有另一种方法来使用全局变量，它可以避免这两个问题。</p>
<h2 id="8-4-函数中的变量">8-4 函数中的变量</h2>
<h3 id="8-4-1-传递参数的注意事项">8-4-1 传递参数的注意事项</h3>
<p>传递参数给函数时，最重要的一点是：”类型要正确“。</p>
<p>如果类型不同，可以会得到难以预料的结果（因为Fortran实际是传递内存地址，”加密“ ”解密“ 方式不同肯定会出问题）。</p>
<p>这里来做一个实验</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0815</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> :: a=<span class="number">1.0</span></span><br><span class="line">    <span class="keyword">call</span> ShowInteger(a)</span><br><span class="line">    <span class="keyword">call</span> ShowReal(a)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowInteger(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: num </span><br><span class="line">    <span class="built_in">write</span>(*,*) num</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowReal(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> :: num</span><br><span class="line">    <span class="built_in">write</span>(*,*) num</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行输出结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1065353216</span><br><span class="line">  1.00000000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>传递参数也可以直接传递常量，但是记得输入正确的数据类型，区分整数和浮点数；另外，函数中不能修改参数的值，因为常量不能被修改。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> ShowInteger(<span class="number">1</span>) </span><br><span class="line"><span class="keyword">call</span> ShowReal(<span class="number">1.0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="8-4-2-数组参数">8-4-2 数组参数</h3>
<p>数组惠占据一块内存中的连续空间。在传递数组参数时，实际上是传递数组元素当中的某一个内存地址。</p>
<p>举个例子。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0816</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a(<span class="number">5</span>)=(/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /)</span><br><span class="line">    <span class="keyword">call</span> ShowOne(a) <span class="comment">!输入a, 就是输入数组a第一个元素的内存地址</span></span><br><span class="line">    <span class="keyword">call</span> ShowArray5(a)</span><br><span class="line">    <span class="keyword">call</span> ShowArray3(a)</span><br><span class="line">    <span class="keyword">call</span> ShowArray3(a(<span class="number">2</span>)) <span class="comment">!输入a(2), 就是输入数组a第2个元素的内存地址</span></span><br><span class="line">    <span class="keyword">call</span> ShowArray2X2(a)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowOne(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: num <span class="comment">!只取出参数地址中的第1个数字</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) num</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowArray5(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: num(<span class="number">5</span>) <span class="comment">!只取出参数地址中的前5个数字， 当成数组来使用</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) num</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowArray3(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: num(<span class="number">3</span>) <span class="comment">!只取出参数地址中的前3个数字， 当成数组来使用</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) num</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowArray2X2(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: num(<span class="number">2</span>,<span class="number">2</span>) <span class="comment">!只取出参数地址中的前4个数字， 当成2X2数组来使用</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) num(<span class="number">2</span>,<span class="number">1</span>),num(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译时有 warning</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gfortran EX0816.F90</span></span><br><span class="line">EX0816.F90:4.17:</span><br><span class="line"></span><br><span class="line">    call ShowOne(a) !\xE8\xBE\x93\xE5\x85\xA5a, \xE5\xB0\xB1\xE6\x98\xAF\xE8\xBE</span><br><span class="line">                 1</span><br><span class="line">Warning: Rank mismatch in argument &#x27;num&#x27; at (1) (scalar and rank-1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果如下</p>
<p>先看第一个结果， call ShowOne(a) 会将传入的参数作为一个整数接收，这里传进来的是数组a，也就是 a(1) 的地址。</p>
<p>第二个结果，call showArray5(a) 正好将传入的参数作为一个大小为5的一维数组。第三个结果截取了前三个元素。</p>
<p>第四个个结果输入a(2) ，因此返回的数组的起始位置会等于 a(2)。</p>
<p>第五个结果会将参数当作2×2的数组使用。根据数组的内存排列原则，num(1,1) = a(1) , num(2,1) = a(2), num(1,2) = a(3), num(2,2) = a(4)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1           2           3           4           5</span><br><span class="line">1           2           3</span><br><span class="line">2           3           4</span><br><span class="line">2           4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>数组在定义的时候需要使用常量来赋值它的大小。不过在函数中，如果数组是接收用的参数时，可以例外。这个时候可以用变量来赋值它的大小，甚至可以不去赋值大小，来看下面的例子。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0817</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">parameter</span> :: <span class="built_in">size</span> = <span class="number">5</span></span><br><span class="line">    <span class="keyword">integer</span> :: s = <span class="built_in">size</span></span><br><span class="line">    <span class="keyword">integer</span> :: a(<span class="built_in">size</span>) = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /)</span><br><span class="line">    <span class="keyword">call</span> UseArray1(a,<span class="built_in">size</span>) <span class="comment">!把常量size输入做数组大小</span></span><br><span class="line">    <span class="keyword">call</span> UseArray1(a,s) <span class="comment">!把一般变量s输入做数组大小</span></span><br><span class="line">    <span class="keyword">call</span> UseArray2(a) <span class="comment">!不输入数组大小</span></span><br><span class="line">    <span class="keyword">call</span> UseArray3(a) </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> UseArray1(num,<span class="built_in">size</span>)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: <span class="built_in">size</span></span><br><span class="line">    <span class="keyword">integer</span> :: num(<span class="built_in">size</span>) <span class="comment">!输入数组的大小可用变量来赋值</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) num</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> UseArray2(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: num(*) <span class="comment">!不赋值数组大小</span></span><br><span class="line">    <span class="keyword">integer</span> :: i </span><br><span class="line">    <span class="built_in">write</span>(*,*) (num(i),i=<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line">    <span class="comment">!如果输入的数组大于小于5，write在执行时会出现错误</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> UseArray3(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: num(-<span class="number">2</span>:<span class="number">2</span>) <span class="comment">!重新定义数组坐标范围</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) num(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果如下。其中 UseArray1 中使用输入的变量来设置数组的大小，UseArray2 则在设置大小时使用一个星号，代表不指定大小的意思。UseArray3 则重新定义了数组坐标值范围。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1           2           3           4           5</span><br><span class="line">1           2           3           4           5</span><br><span class="line">1           2           3           4           5</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为什么在函数中不用赋值数组大小呢？因为在主程序中已经创建好了数组，在进入到子程序前数组就已经配置到内存空间了。函数不会额外配置新的内存空间，在函数中赋值数组大小只是用来方便检查，不会去重新配置内存，所以可以省略。</p>
<p>子程序 UseArray3 是比较特殊的用法，它定义数组 num 坐标范围为 -2~2, 所以 num(-2) = a(1), num(-1)=a(0) ……。</p>
<p>函数中只要注意使用数组参数时，<strong>不要超过它的实际范围</strong>就行了。其他方面要如何使用都没有关系。如果超出了实际范围，编译时不会出现错误，在执行时会出现奇怪的结果，甚至死机。</p>
<p>顺便提一点，传递字符串变量时，也可以不特别赋值它的长度。原因相同，因为它的长度早就设置好了。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">character</span>(len=*) string</span><br></pre></td></tr></table></figure>
<p>举例</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0818</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: str=<span class="string">&quot;Hello, Fortran 95.&quot;</span></span><br><span class="line">    <span class="keyword">call</span> ShowString(str) <span class="comment">!输入字符串开头地址</span></span><br><span class="line">    <span class="keyword">call</span> ShowString(str(<span class="number">8</span>:)) <span class="comment">!输入字符串第8个字符的地址</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowString(str)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=*) :: str</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="built_in">len_trim</span>(str)</span><br><span class="line">    <span class="built_in">write</span>(*,*) str</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         18</span><br><span class="line">Hello, Fortran 95.</span><br><span class="line">         11</span><br><span class="line">Fortran 95.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>子程序如果赋值字符串长度，不能超过实际长度。</p>
<p>再回到数组的部分，多维数组在传递时，只有最后一维可以不赋值大小，其他维都必须赋值大小，来看一个实例。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0819</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">parameter</span> :: dim1 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">parameter</span> :: dim2 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">parameter</span> :: dim3 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">integer</span> :: a(dim1,dim2,dim3)</span><br><span class="line">    a(:,:,<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">    a(:,:,<span class="number">2</span>) = <span class="number">2</span></span><br><span class="line">    <span class="keyword">call</span> GetArray1(a(:,:,<span class="number">1</span>),dim1,dim2)</span><br><span class="line">    <span class="keyword">call</span> GetArray2(a(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>),dim1)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> GetArray1(a,dim1,dim2)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: dim1,dim2</span><br><span class="line">    <span class="keyword">integer</span> :: a(dim1,dim2)</span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> GetArray2(a,dim1)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: dim1,dim2</span><br><span class="line">    <span class="keyword">integer</span> :: a(dim1,*) <span class="comment">!最后一维可以不赋值数组大小</span></span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="built_in">write</span>(*,*) (a(:,i),i=<span class="number">1</span>,<span class="number">2</span>) <span class="comment">! 必须指定输出哪几维</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1           1           1           1</span><br><span class="line">2           2           2           2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序示范了两个东西，第一是把三维数组传递到子程序中变成二维数组的方法，第二是示范了多维数组的最后一个维度可以不赋值大小。程序第9行是用来输入部分数组。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> GetArray1(a(:,:,<span class="number">1</span>),dim1,dim2)</span><br></pre></td></tr></table></figure>
<p>因为数组 a(1~2, 1~2, 1) 这4个元素在内存中是连续存放的，这里<strong>参数放入a(:,:,1) 就等于放入a(1,1,1) 的地址</strong>。子程序接收时改用二维数组来使用这块内存，所以这里等于是把原来容量为 dim1×dim2×dim3 的 三维数组中拿出当中一小块当成容量为 dim1×dim2 的 二维数组。</p>
<p>第10行是同样的用法，只是它换了一个写法，而且放入的是另一块空间。但是它没有赋值第二维的大小，这是合理的语法。</p>
<p>不过用这个方法后，输出数组a的时候要指定它的范围。因为声明时没说明它的第二维有多大。（—这不是脱裤子××嘛，那就直接指定好范围就行了呗）</p>
<p>你看，后面又建议。</p>
<blockquote>
<p>笔者建议还是不要偷懒，把数组实际声明大小全部都传递出去是比较好的做法。</p>
</blockquote>
<h3 id="8-4-3-变量的生存周期">8-4-3 变量的生存周期</h3>
<p>函数中的变量（不含所输入的参数）有它们的 “生存周期”。它们所能够生存的时间，只有在这个子程序被调用执行的这一段时间中。子程序结束后，它们就“死亡” 了，所保存的数据也会跟着被埋没掉。</p>
<p>在声明中加入 SAVE 可以拯救这些变量。这些变量可以在程序执行中永久记忆住上一次函数调用时所被设置的数值，来看看这一个实例：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0820</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">call</span> sub()</span><br><span class="line">    <span class="keyword">call</span> sub()</span><br><span class="line">    <span class="keyword">call</span> sub()</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub()</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: <span class="built_in">count</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">save</span> <span class="built_in">count</span> <span class="comment">!赋值count变量会永久活着，不会忘记它的内容</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="built_in">count</span></span><br><span class="line">    <span class="built_in">count</span> = <span class="built_in">count</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在 save 命令后面的变量的生存周期将不只局限在子程序的执行过程中，会延申到整个程序的执行时间一样长。<strong>注意，变量的初值只会设置一次</strong>。所以第11行设置 count 初值的操作只会执行一次，并不是每次调用 sub 时，count 都会重新设置为1。</p>
<p>在 Fortran 90 中，可以把 save 和 声明写在同一行，如下</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span>,<span class="keyword">save</span> :: <span class="built_in">count</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>有些编译器不管有没有指明 save，都会记住数值</strong>。我这里做了一次，gfortran 就是这样，注释掉 save 行，输出结果不变。（我感觉这一点不好，我可能会重复运行一个函数，中间的临时变量我肯定希望重置，现在默认都记住了，不知道怎么弄）</p>
<h3 id="8-4-4-传递函数">8-4-4 传递函数</h3>
<p>传递参数时，除了传递数字、字符串等数据外，还可以把一个函数名称传递过去。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0821</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: func <span class="comment">!声明 func 是个自定义函数</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">intrinsic</span> :: <span class="built_in">sin</span> <span class="comment">!声明sin是一个库函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">call</span> ExecFunc(func) <span class="comment">!输入自定义函数 func</span></span><br><span class="line">    <span class="keyword">call</span> ExecFunc(<span class="built_in">sin</span>) <span class="comment">!输入库函数 sin</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ExecFunc(f)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: f <span class="comment">!声明参数f是个函数</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) f(<span class="number">1.0</span>) </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> func(num)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> :: num</span><br><span class="line">    func = num*<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 2.00000000</span><br><span class="line">0.841470957</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第三行的声明中使用了 EXTERNAL,  前面曾介绍过这是用来表明所声明的是一个自定义函数的名称。第四行的声明中使用了一个新的关键字 INTRINSIC, 用来表明所声明的 sin 是 Fortran 的 库存函数，而不是一个变量。在这个程序中 EXTERNAL 和 INTRINSIC 这两个字都不能省略，因为在这里要把函数名称当成参数传递出去。如果纯粹把函数拿来计算使用，不把它当成参数传递出去，声明 func 时可以省略 EXTERNAL，声明 sin 的这一整行则可以完全省略。</p>
<p>第6、7行执行调用了两次子程序 ExecFunc ，分别把自定义函数 func 函数和库函数 sin 输入。</p>
<p>除了函数可以当成参数来传递之外，子程序也可以拿来作为参数传递出去。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0822</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">external</span> sub1,sub2 <span class="comment">!声明sub1 sub2 是子程序名称</span></span><br><span class="line">    <span class="keyword">call</span> sub(sub1) <span class="comment">!把子程序当参数传出去</span></span><br><span class="line">    <span class="keyword">call</span> sub(sub2)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub(sub_name)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">external</span> sub_name <span class="comment">!声明 sub_name 是个子程序</span></span><br><span class="line">    <span class="keyword">call</span> sub_name() <span class="comment">!调用输入的子程序 sub_name</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub1()</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;sub1&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub2()</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;sub2&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sub1</span><br><span class="line">sub2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>8-5 特殊参数的使用方法</h1>
<p>Fortran 90 中，可以赋值参数的属性，设置某些参数是只读不能改变的。它还可以输入不定个数的参数，还可以不按照顺序来传递参数。</p>
<h3 id="8-5-1-参数属性">8-5-1 参数属性</h3>
<p>Fortran 中，参数传递出去后可能在函数中被改变。有的时候程序员会希望某些参数是只读的，它的数值不能在函数中被改变。Fortran 90 的 INTENT 命令可以用来设置函数属性，先来看一个简单的实例：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0823</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a=<span class="number">4</span></span><br><span class="line">    <span class="keyword">integer</span> b</span><br><span class="line">    <span class="keyword">call</span> div(a,b)</span><br><span class="line">    <span class="built_in">write</span>(*,*) a,b</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> div(a,b)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>)::a <span class="comment">!指定a是只读</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">intent</span>(<span class="keyword">out</span>)::b <span class="comment">!指定b在子程序中应该重新设置数值</span></span><br><span class="line">    b=a/<span class="number">2</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里 intent(in) 表示只读， intent(out) 表示指定为应该重新设置数值。</p>
<p>事实上，不指定参数属性并不会影响程序执行结果，加上这两行只是用来避免编写程序时不小心出错。设置成只读的变量，在函数中如果重新设置数值，编译过程中会出现错误。而设置成要输出的变量，如果在函数中没有重新设置一个数值给它，编译过程中会出现警告信息。</p>
<p>在计算丢标枪的实例程序 EX0809 中的两个函数 Angle_To_Rad 及 Get_Distance 都不会去改变参数，这两个函数的参数都是可读的。这个程序严格的写法会变成下面的样子。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0824</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">parameter</span> :: players = <span class="number">5</span></span><br><span class="line">    <span class="keyword">real</span> :: angle(players) = (/<span class="number">30.0</span>,<span class="number">45.0</span>,<span class="number">35.0</span>,<span class="number">50.0</span>,<span class="number">40.0</span>/)</span><br><span class="line">    <span class="keyword">real</span> :: speed(players) = (/<span class="number">25.0</span>,<span class="number">20.0</span>,<span class="number">21.0</span>,<span class="number">27.0</span>,<span class="number">22.0</span>/)</span><br><span class="line">    <span class="keyword">real</span> :: distance(players)</span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: Get_Distance <span class="comment">!声明Get_Distance 是个函数</span></span><br><span class="line">    <span class="keyword">integer</span> :: I</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> I=<span class="number">1</span>,players</span><br><span class="line">        distance(i)=Get_Distance(angle(i),speed(i))</span><br><span class="line">        <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;player &#x27;,I1,&#x27; =&#x27;,F8.2)&quot;</span>) I,distance(i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">!把0~360的角度转换成弧度</span></span><br><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Angle_TO_Rad(angle)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>) :: angle</span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">parameter</span> :: pi = <span class="number">3.14159</span></span><br><span class="line">    Angle_TO_Rad = angle*pi/<span class="number">180.0</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">!由角度，切线速度来计算投射距离</span></span><br><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Get_Distance(angle,speed)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>) :: angle,speed <span class="comment">!输入的参数</span></span><br><span class="line">    <span class="keyword">real</span> rad,Vx,time <span class="comment">!内部使用</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: Angle_TO_Rad <span class="comment">!声明是个函数</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">parameter</span> :: G = <span class="number">9.81</span></span><br><span class="line">    </span><br><span class="line">    rad = Angle_TO_Rad(angle) <span class="comment">!单位转换</span></span><br><span class="line">    Vx = speed*<span class="built_in">cos</span>(rad) <span class="comment">!水平方向速度</span></span><br><span class="line">    time = <span class="number">2.0</span>*speed*<span class="built_in">sin</span>(rad)/G <span class="comment">!在空中飞行时间</span></span><br><span class="line">    Get_Distance = Vx * time <span class="comment">!距离 = 水平方向速度 * 飞行时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>这个程序和原来的程序只有两行的差别，第20，30行。在这里把输入的参数都指定成只读的属性。</p>
<h3 id="8-5-2-函数的使用接口（INTERFACE）">8-5-2 函数的使用接口（INTERFACE）</h3>
<p>INTERFACE 是一段程序模块，用来清楚说明所要调用函数的参数类型及返回值类型等等的”使用接口“。在一般情况下，使用函数时不需要特别说明它们的”使用接口“，不过在下面这些情况下是必要的”</p>
<blockquote>
<ol>
<li>函数返回值为数组时</li>
<li>指定参数位置来传递参数时</li>
<li>所调用的函数参数数目不固定时</li>
<li>输入指标参数时</li>
<li>函数返回值为指针时</li>
</ol>
</blockquote>
<p>第1点很容易理解，目前为止举例中的函数都只返回一个数值，函数的返回值也可以是一个数组，来看下面的实例。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0825</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="comment">!定义函数func的使用接口</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span></span> random10(<span class="built_in">lbound</span>,<span class="built_in">ubound</span>)</span><br><span class="line">            <span class="keyword">implicit</span> <span class="keyword">none</span> </span><br><span class="line">            <span class="keyword">real</span> :: <span class="built_in">lbound</span>,<span class="built_in">ubound</span></span><br><span class="line">            <span class="keyword">real</span> :: random10(<span class="number">10</span>) <span class="comment">!返回值是个数组</span></span><br><span class="line">        <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">real</span> :: a(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">call</span> <span class="built_in">random_seed</span>() <span class="comment">!库存子程序，使用随机数前调用</span></span><br><span class="line">    a = random10(<span class="number">1.0</span>,<span class="number">10.0</span>) <span class="comment">!生成10个1.0~10.0之间的随机数</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(10F6.2)&quot;</span>) a <span class="comment">!输出数组a的内容</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">! random10 会返回10个范围在 lbound 和 ubound 之间的随机数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span></span> random10(<span class="built_in">lbound</span>,<span class="built_in">ubound</span>)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> :: <span class="built_in">lbound</span>,<span class="built_in">ubound</span></span><br><span class="line">    <span class="keyword">real</span> :: len</span><br><span class="line">    <span class="keyword">real</span> :: random10(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">real</span> t</span><br><span class="line">    <span class="keyword">integer</span> i</span><br><span class="line">    len = <span class="built_in">ubound</span> - <span class="built_in">lbound</span> <span class="comment">!计算范围大小</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">10</span></span><br><span class="line">        <span class="keyword">call</span> <span class="built_in">random_number</span>(t) <span class="comment">!t是0~1之间的随机数</span></span><br><span class="line">        random10(i) = <span class="built_in">lbound</span> + len*t <span class="comment">!把t转换成 lbound~ubound 间的随机数</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序会输出10个1~10之间随机生成的随机数，每次执行出来的结果应该均不相同（错了，我重复了两次，结果一样）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) [zhouziwen@ny gfortran]$ gfortran EX0825.F90</span><br><span class="line">(base) [zhouziwen@ny gfortran]$ ./a.out</span><br><span class="line">  9.98  6.10  9.69  7.73  4.31  5.33  1.66  1.05  4.12  4.08</span><br><span class="line">(base) [zhouziwen@ny gfortran]$ gfortran EX0825.F90</span><br><span class="line">(base) [zhouziwen@ny gfortran]$ ./a.out</span><br><span class="line">  9.98  6.10  9.69  7.73  4.31  5.33  1.66  1.05  4.12  4.08</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里先说明随机数的使用方法，在写程序的时候，常常会需要使用类似丢铜板的情况，以随机的方法来决定下一步要怎么做，这时候就要使用随机数。使用随机数前要先调用 random_seed 这个子程序来启动随机数生成器，启动之后就可以通过调用 random_number 来得到一个 0~1 之间的随机数。</p>
<p>这个实例中的函数 random10, 会通过输入的两个参数来决定随机数的值域范围，生成10个随机数，放在一维数组中作为返回值。这里示例了函数返回数组的方法，主程序中要用 interface 来说明函数的使用接口，使用接口包括参数类型及返回值类型。</p>
<p>一般情况并不需要使用 interface, 只有本小节最前面提到的那些情况才需要使用 interface 。声明使用接口，对程序员来说，是一个很麻烦的工作。尤其是在需要调用多个函数时，整个程序代码看起来会很烦杂。以这个例子来说，如果有另一个子程序也要调用 random10, 那在这个子程序中也需要再写清楚函数 random10 的 interface 才行。使用 module 可以减少这个麻烦，下面的章节会介绍 module 的使用。</p>
<p>interface 的编写结构很简单，它一次可以放入好几个函数的使用接口声明：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="comment">!开始写作 interface</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span></span> func_name <span class="comment">!开始定义函数 func_name</span></span><br><span class="line">		<span class="keyword">implicit</span> <span class="keyword">none</span> </span><br><span class="line">		<span class="keyword">real</span> ……  <span class="comment">!这里只能说明参数或传回值类型</span></span><br><span class="line">		<span class="keyword">integer</span> ……</span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span> <span class="comment">!定义函数结束</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> sub_name <span class="comment">!可以再定义另一个子函数/程序</span></span><br><span class="line">    	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    	<span class="keyword">integer</span> ……</span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">interface</span></span><br></pre></td></tr></table></figure>
<h3 id="8-5-3-不定个数的参数传递">8-5-3 不定个数的参数传递</h3>
<p>Fortran 90 当中，可以用 OPTIONAL 命令来表示某些参数是&quot;可以省略的&quot;。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0826</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">interface</span></span><br><span class="line">        <span class="function"><span class="keyword">subroutine</span></span> sub(a,b) <span class="comment">!定义子程序 sub 的使用接口</span></span><br><span class="line">            <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">            <span class="keyword">integer</span> :: a</span><br><span class="line">            <span class="keyword">integer</span>,<span class="keyword">optional</span> :: b</span><br><span class="line">        <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    <span class="comment">!开始编写命令</span></span><br><span class="line">    <span class="keyword">call</span> sub(<span class="number">1</span>) <span class="comment">!使用1个参数</span></span><br><span class="line">    <span class="keyword">call</span> sub(<span class="number">2</span>,<span class="number">3</span>) <span class="comment">!使用2个参数</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub(a,b)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a</span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">optional</span> :: b</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">present</span>(b)) <span class="keyword">then</span><span class="comment">!有输入b时</span></span><br><span class="line">        <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;a=&#x27;,i3,&#x27; b=&#x27;,i3)&quot;</span>) a,b</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;a=&#x27;,i3,&#x27; b=unknown&#x27;)&quot;</span>) a</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;  1 b&#x3D;unknown</span><br><span class="line">a&#x3D;  2 b&#x3D;  3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在子程序sub 及主程序的 interface 声明中，声明第二个参数时可以忽略的。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">optional</span> :: b</span><br></pre></td></tr></table></figure>
<p>函数 present 可以检查一个参数是否传递进来，函数 present 的返回值是布尔变量，如果想要检查的参数传递进来，会返回.true.，没有则返回.false.</p>
<p>注意，调用不定参数时，一定要先声明出函数的 interface，使用 module 时可以省略。</p>
<h3 id="8-5-4-改变参数传递位置的方法">8-5-4 改变参数传递位置的方法</h3>
<p>Fortran 90 中，甚至可以不用按照参数的顺序来传递参数。例如有一个子程序如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub(a,b,c)</span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br></pre></td></tr></table></figure>
<p>调用这个子程序时，可以直接代入子程序的变量名称来做”变换参数位置“的调用，例如：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> sub(b=<span class="number">2</span>,c=<span class="number">3</span>,a=<span class="number">1</span>) <span class="comment">!根据变量名称来传递参数</span></span><br></pre></td></tr></table></figure>
<p>编写程序的时候也可以让某些参数有<strong>默认值</strong>，不输入这些参数时就使用默认值。来看下面的例子，这个例子会编写一个函数来计算 F(X) = A*X^2^ + B*X + C 的值，一定要输入X来计算，A,B,C 没有输入的画默认值为0.</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0827</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">interface</span></span><br><span class="line">        <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> func(x,a,b,c) <span class="comment">!定义子程序func的使用接口</span></span><br><span class="line">            <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">            <span class="keyword">real</span> x</span><br><span class="line">            <span class="keyword">real</span>,<span class="keyword">optional</span> :: a,b,c</span><br><span class="line">        <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    <span class="comment">!开始编写命令</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) func(<span class="number">2.0</span>,c=<span class="number">1.0</span>) <span class="comment">!F(2)=0*2^2 + 0*2 + 1 = 1</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) func(<span class="number">2.0</span>,a=<span class="number">2.0</span>,b=<span class="number">1.0</span>) <span class="comment">!F(2)=2*2^2 + 1*2 + 0 = 10</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">!计算func(X)=A*X^2+B*X+C</span></span><br><span class="line"><span class="comment">!A,B,C不输入的话为0</span></span><br><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> func(x,a,b,c)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> x </span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">optional</span> :: a,b,c <span class="comment">!a,b,c可以不输入</span></span><br><span class="line">    <span class="keyword">real</span> ra,rb,rc <span class="comment">!实际计算的数字</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">present</span>(a)) <span class="keyword">then</span></span><br><span class="line">        ra=a</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ra=<span class="number">0.0</span> <span class="comment">!默认值为0</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">present</span>(b)) <span class="keyword">then</span></span><br><span class="line">        rb=b</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rb=<span class="number">0.0</span> <span class="comment">!默认值为0</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">present</span>(c)) <span class="keyword">then</span></span><br><span class="line">        rc=c</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rc=<span class="number">0.0</span> <span class="comment">!默认值为0</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    func = ra*x**<span class="number">2</span> + rb*x + rc</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.00000000</span><br><span class="line">10.0000000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="8-6-特殊的函数类型">8-6 特殊的函数类型</h2>
<p>Fortran 90 的函数，除了一般正常使用的类型外，还可以特别指定成 RECURSIVE, PURE, ELEMENTAL 这三种类型之一。 RECURSIVE 是让函数可以自己调用自己，即递归。PURE 及 ELEMENTAL 是用来做并行处理时及设置数组时使用。</p>
<h3 id="8-6-1-递归">8-6-1 递归</h3>
<p>函数除了可以让别人调用，自己也可以调用自己来执行，这叫做”递归“。能够”递归“执行的函数有一个必要条件，那就是递归函数每次被调用执行时，函数中所声明的局部变量（指那些不是传递进来的参数，及没有SAVE的变量）都会使用不同的内容地址。简单地说，函数中的局部变量在每次调用时都是独立存在的。</p>
<p>下面的实例程序会使用”递归“的方式来编写计算阶乘的子程序。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0828</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: n</span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">external</span> :: fact</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;N=&quot;</span></span><br><span class="line">    read(*,*) n</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(i2,&#x27;! = &#x27;,i8)&quot;</span>) n,fact(n)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">recursive</span> <span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> fact(n) reasut(ans)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>) :: n</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">then</span> <span class="comment">!不合理的输入</span></span><br><span class="line">        ans = -<span class="number">1</span> <span class="comment">!随便设置一个值</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line">    <span class="comment">!下面表示 n&gt;1 的情况，利用n*(n-1)! 来计算 n!</span></span><br><span class="line">    ans = n * fact(n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> N&#x3D;</span><br><span class="line">5</span><br><span class="line"> 5! &#x3D;      120</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数fact 一开头就以 recursive 开头，表示这个子程序可以递归使用。 result() 表示在函数中使用另外一个名字来设置函数的返回值，这里用 ans 来代替原来的 fact</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">recursive</span> <span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> fact(n) result(ans)</span><br></pre></td></tr></table></figure>
<p>Fortran 90 标准中，递归函数一定要使用 RESULT 来改名。</p>
<p>使用递归要有很清楚的逻辑概念，先分析一下阶乘的计算过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n! &#x3D; n*(n-1)*(n-2)*……*3*2*1</span><br></pre></td></tr></table></figure>
<p>因为 n! = n*(n-1)! ，所以调用函数 fact 来计算 n! 时，又可以再调用一次 fact 函数（自身）。</p>
<p>**递归调用时，需要确定一个明确的”终点“，用于停止递归。**不然会造成函数不断地调用自己来执行，可能会导致程序死机。</p>
<p>这里一开始就加入了两个判断：</p>
<ol>
<li>如果 n &lt; 0，则 n 值不合理，不做计算</li>
<li>若n &lt;= 1，根据数学定义 0! = 1! = 1，这是已知的数值。</li>
</ol>
<p>因此，如果用户一开始输入了一个负值，函数 fact 不做计算，直接 return 。 第二个条件是用来做递归的结束条件，当n减到1时，就不再递归下去。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">then</span> <span class="comment">!不合理的输入</span></span><br><span class="line">    ans = -<span class="number">1</span> <span class="comment">!随便设置一个值</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    ans = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br></pre></td></tr></table></figure>
<p>下面详细列出了整个阶乘计算的运行流程，请记住每一次调用 fact 时，它的局部变量都是独立存在的。</p>
<blockquote>
<p>N=4</p>
<p>主程序读入n值</p>
<p>fact(n) = fact(4)</p>
<p>在主程序中第一次调用函数fact来计算 4!</p>
<p>ans = n * fact(n-1) = 4*fact(3)</p>
<p>第1次执行fact时n=4，因为n&gt;1，所以还要调用 fact(n-1)</p>
<p>ans = n * fact(n-1) = 3*fact(2)</p>
<p>第2次执行fact时n=3，因为n&gt;1，所以还要调用 fact(n-1)</p>
<p>ans = n * fact(n-1) = 2*fact(1)</p>
<p>第3次执行fact时n=2，因为n&gt;1，所以还要调用 fact(n-1)</p>
<p>ans = 1</p>
<p>第4次执行fact时会到达递归调用的终点。因为n = 1，所以 ans = 1。函数会开始一个接着一个 return，先返回第3次执行 fact 的地方继续执行。</p>
<p>n*fact(n-1) = 2*fact(1) = 2*1 = 2 = 2!</p>
<p>第3次执行 fact 时 n = 2</p>
<p>n*fact(n-1) = 3*fact(2) = 3*2 = 6 = 3!</p>
<p>第2次执行 fact 时 n = 3</p>
<p>n*fact(n-1) = 4*fact(3) = 4*6 = 24 = 4!</p>
<p>第1次执行 fact 时 n = 4。这个时候计算结束，返回主程序。</p>
<p>fact(4) = 24</p>
</blockquote>
<p>递归调用的思维就在于把难得问题简化，以这个实例来说，因为计算n的阶乘比较难，可以一步步分解来计算。</p>
<p>把这个程序加入一些额外的信息，再重新看一次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> N&#x3D;</span><br><span class="line">4</span><br><span class="line"> 4! &#x3D;  1th enter,n&#x3D; 4</span><br><span class="line"> 2th enter,n&#x3D; 3</span><br><span class="line"> 3th enter,n&#x3D; 2</span><br><span class="line"> 4th enter,n&#x3D; 1</span><br><span class="line"> 4th exit,n&#x3D; 1 ans&#x3D;       1</span><br><span class="line"> 3th exit,n&#x3D; 2 ans&#x3D;       2</span><br><span class="line"> 2th exit,n&#x3D; 3 ans&#x3D;       6</span><br><span class="line"> 1th exit,n&#x3D; 4 ans&#x3D;      24</span><br><span class="line">      24</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里多加了一些额外信息来显示出程序进行的流程，可以发现函数 fact 会一层一层地深入，再一层一层慢慢 return 回来。第n次调用fact执行完，会回到第 n-1 次调用fact中。</p>
<p>函数 fact 的局部变量 localcount 及 temp 是独立存在于每一次的调用当中，第 n-1 次调用 fact 时的localcount 跟第n次调用 fact 时的localcount 会存放不同的内存中，它们会是两个不同的变量。</p>
<p>用递归的方式计算阶乘， 并不会比使用循环来得好。事实上在这里使用递归程序执行效率会比较差，这里只是为了要示范递归的使用方法而已。不过，在处理某些问题时，使用递归可以大幅精简程序代码。</p>
<h3 id="8-6-2-内部函数">8-6-2 内部函数</h3>
<p>Fortran 90 还可以把函数做一个“归属”，定义出某些函数只能再某些特定的函数中被调用，写法如：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> main 或 <span class="function"><span class="keyword">subroutine</span></span> sub 或 <span class="function"><span class="keyword">function</span></span> func</span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">contains</span> <span class="comment">!contains 后面开始写作局部函数</span></span><br><span class="line">		<span class="function"><span class="keyword">subroutine</span></span> localsub</span><br><span class="line">		……</span><br><span class="line">		<span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span>/<span class="function"><span class="keyword">subroutine</span></span>/<span class="function"><span class="keyword">function</span></span></span><br></pre></td></tr></table></figure>
<p>这个方法，可以用来设计一个函数中的“内部运行”，因为内部运行是不希望被别人所使用的。来看一个实例。</p>
<p>这个程序只是 ex0828 改写后的结果，把函数放在主程序中，这样<strong>函数fact 只能在主程序中被调用，其它函数不能调用它</strong>。还有一点就是在这里<strong>主程序不需要声明就可以直接调用到函数fact</strong>。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0831</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: n</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;N=&#x27;</span></span><br><span class="line">    read(*,*) n</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(i2,&#x27;! = &#x27;,i8)&quot;</span>) n,fact(n)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">contains</span></span><br><span class="line">        <span class="keyword">recursive</span> <span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> fact(n) result(ans)</span><br><span class="line">            <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">            <span class="keyword">integer</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>) :: n</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">then</span> <span class="comment">!不合理的输入</span></span><br><span class="line">                ans = -<span class="number">1</span> <span class="comment">!随便设置一个值</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">                ans = <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line">            <span class="comment">!下面表示 n&gt;1 的情况，利用n*(n-1)! 来计算 n!</span></span><br><span class="line">            ans = n * fact(n-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="8-6-3-PURE函数">8-6-3 PURE函数</h3>
<p>在 function/subroutine 前面加上 pure 就可以使用pure函数。一般情况下不需要使用pure函数，它只是用来配合<strong>并行计算</strong>使用。使用pure函数有很多限制：</p>
<blockquote>
<ol>
<li>pure 函数的参数必须都是只读 intent(in)</li>
<li>pure 子程序的每个参数都要赋值属性</li>
<li>pure 函数中不能使用 save</li>
<li>pure 函数中所包含的内部函数也都必须是 pure 类型函数。</li>
<li>pure 函数中不能使用 stop，print 及跟输出入相关的命令。（如read, write, open, close, backspace,endfile, rewind, inquire）</li>
<li>pure 函数中只能读取，不能改变全局变量的值</li>
</ol>
</blockquote>
<p>这些限制是为了配合并行计算。并行计算可以让程序中，不同部分的程序代码在同时间执行，加快执行速度。如果不对并行计算进行限制，会出现一些问题。例如假设现在同时正在执行函数A和函数B，而这两个函数都可以在屏幕上输出一些信息，假设函数A正好要输出a=1, 函数B正好要输出 b=2，不过由于它们是同时在执行，但是屏幕只有一个，所以有可能会显示 a=b=21, ab==12, b=a1=2 等等的结果。因为 a = 1 跟 b = 2 这两段文本都抢着要输出到屏幕上，结果会导致这两段文本混在一起显示出来。</p>
<p>上面的6项限制，都是为了避免在并行计算时，出现奇怪的执行结果而指定的。</p>
<p>下面我们来看一个实例。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0832</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">external</span> :: func</span><br><span class="line">    <span class="built_in">write</span>(*,*) func(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pure</span> <span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> func(a,b)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>) :: a,b</span><br><span class="line">    func = a+b</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个实例纯粹是示范PURE函数的语法，计算机不具备并行运算能力时，不需要使用PURE函数。</p>
<h3 id="8-6-4-ELEMENTAL-函数">8-6-4 ELEMENTAL 函数</h3>
<p>这个函数也是用于并行计算，它同样有上一个小节中的那6项限制。不过它多了一个功能，可以用来做数组的设置，不过它也多了一个限制，就是它的参数不能是数组。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">10</span>)</span><br><span class="line">a=func(a)</span><br><span class="line"><span class="comment">!如果func 是elemental 函数，这段程序代码执行结果跟下面的循环相同。</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">10</span></span><br><span class="line">a(i) = func(a(i))</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>elemental 函数主要是用来配合 Fortran 90 可以对整个数组操作的语法来设置数组内容。下面是一个实例。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0833</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">interface</span> <span class="comment">!说明函数func的使用接口</span></span><br><span class="line">        <span class="keyword">elemental</span> <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> func(num)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>) :: num </span><br><span class="line">        <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">integer</span> i</span><br><span class="line">    <span class="keyword">real</span> :: a(<span class="number">10</span>) = (/ (i,i=<span class="number">1</span>,<span class="number">10</span>) /)</span><br><span class="line">    <span class="keyword">real</span> :: b(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(10F6.2)&quot;</span>) a</span><br><span class="line">    a = func(a)</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(10F6.2)&quot;</span>) a</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elemental</span> <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> func(num)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>) :: num</span><br><span class="line">    func = <span class="built_in">sin</span>(num) + <span class="built_in">cos</span>(num)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.00  2.00  3.00  4.00  5.00  6.00  7.00  8.00  9.00 10.00</span><br><span class="line">1.38  0.49 -0.85 -1.41 -0.68  0.68  1.41  0.84 -0.50 -1.38</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 elemental 函数时要先说明它的使用接口，主程序才会正确地设置数组地调用。程序的第16行表明上看数据类型并不对，等号左边是个数组，等号右边返回的却只是一个浮点数。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = func(a)</span><br></pre></td></tr></table></figure>
<p>因为函数 func 是 elemental 类型，这一行会自动变成类似使用循环来执行 a(i) = func(a(i)) 的情况，数组中的每一个数值都会重新设置。不管几维数组都可以使用这个方法来设置数值。</p>
<h2 id="8-7-MODULE">8-7 MODULE</h2>
<p>MODULE 可以用来封装程序模块，通常是用来把程序中，具备相关功能的函数及变量封装在一起。</p>
<h3 id="8-7-1-MODULE-中的变量">8-7-1 MODULE 中的变量</h3>
<p>举例来说，需要使用全局变量时，可以把全局变量都声明在MODULE中，需要使用这些变量的函数只要 USE 这个 MODULE 就可以使用它们。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> a,b</span><br><span class="line">    <span class="keyword">common</span> a,b</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0834</span><br><span class="line">    <span class="keyword">use</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">call</span> sub()</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub()</span><br><span class="line">    <span class="keyword">use</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a,b</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1           2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主程序和子程序都没有声明a,b这两个变量，不过主程序和子程序中都有 use global 这一行描述。变量 a, b 都是声明在 module global 当中，所以只要使用了 global 这个程序单元，就可以看到 a, b 这两个变量。</p>
<p>MODULE 的语法如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> module_name</span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">end</span> [<span class="keyword">module</span> [module_name]]</span><br></pre></td></tr></table></figure>
<p>在函数中使用MODULE时，要在开始声明之前就使用 use module_name 的描述来使用某一个 MODULE。这个实例中，如果不使用 MODULE 的话，主程序和子程序中都要编写重复的程序代码来声明全局变量。还有一点，MODULE的程序代码需要编写在前面，这个程序在主程序和子程序中都使用 module global，所以 module global 要编写在最前面。</p>
<p>MODULE 中的变量如果不是声明成全局变量，这些变量被函数使用时，只会是函数中的局部变量。如果想让函数之间通过MODULE中的变量来传递数据，要把这些变量声明成全局变量。或者是在声明变量时加上 SAVE, 在 MODULE 声明中指定要 SAVE 的变量，功能上也等同于全局变量。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">save</span> :: a</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0835</span><br><span class="line">    <span class="keyword">use</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    <span class="keyword">call</span> sub()</span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub()</span><br><span class="line">    <span class="keyword">use</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    a = <span class="number">20</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">20</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="8-7-2-MODULE-中的自定义类型-TYPE">8-7-2 MODULE 中的自定义类型 TYPE</h3>
<p>在第4章第一次介绍自定义类型TYPE 后，就一直没有再使用它。事实上 TYPE 是个很好用的语法，编写大程序时，会把程序分区成很多函数，使用这些函数有时候会需要传递很多参数，使用自定义类型可以减少参数的数目。</p>
<p>就以本章一开始的射标枪程序为例，如果我们考虑更多的因素，比如风速、阻力等，需要传递的参数就不再只是角度和速度而已。传递多个参数时会很容易发生错误，程序员不可能永远记得每个参数的意义，可能会把参数位置弄反，铸成大错。</p>
<p>如果添加一个自定义类型，把这些数值都封装在这个新的类型中，传递参数时只要传递一个变量过去就行了，来看一个实例。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> constant</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">parameter</span> :: PI = <span class="number">3.14159</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">parameter</span> :: G = <span class="number">9.81</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> player</span><br><span class="line">        <span class="keyword">real</span> :: angle</span><br><span class="line">        <span class="keyword">real</span> :: speed</span><br><span class="line">        <span class="keyword">real</span> :: distance</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0836</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">parameter</span> :: players = <span class="number">5</span></span><br><span class="line">    <span class="keyword">type</span>(player) :: people(players) = (/ player(<span class="number">30.0</span>,<span class="number">25.0</span>,<span class="number">0.0</span>),&amp;</span><br><span class="line">                                        player(<span class="number">45.0</span>,<span class="number">20.0</span>,<span class="number">0.0</span>),&amp;</span><br><span class="line">                                        player(<span class="number">35.0</span>,<span class="number">21.0</span>,<span class="number">0.0</span>),&amp;</span><br><span class="line">                                        player(<span class="number">50.0</span>,<span class="number">27.0</span>,<span class="number">0.0</span>),&amp;</span><br><span class="line">                                        player(<span class="number">40.0</span>,<span class="number">22.0</span>,<span class="number">0.0</span>)&amp;</span><br><span class="line">                                    /)</span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: Get_Distance <span class="comment">!声明Get_Distance 是一个函数。  </span></span><br><span class="line">    <span class="keyword">integer</span> :: I</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> I=<span class="number">1</span>,players</span><br><span class="line">        <span class="keyword">call</span> Get_Distance(people(I))</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Player &#x27;,i1,&#x27; =&#x27;,f8.2)&quot;</span>) I,people(I)%distance</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">!把0~360的角度转换成0~2PI的弧度</span></span><br><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Angle_TO_Rad(angle)</span><br><span class="line">    <span class="keyword">use</span> constant</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> angle</span><br><span class="line">    Angle_TO_Rad = angle*pi/<span class="number">180.0</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">!由角度、切线速度来计算投掷距离</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Get_Distance(person)</span><br><span class="line">    <span class="keyword">use</span> constant</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(player) :: person</span><br><span class="line">    <span class="keyword">real</span> rad,Vx,time</span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: Angle_TO_Rad <span class="comment">!声明Angle_TO_Rad 是个函数</span></span><br><span class="line">    </span><br><span class="line">    rad = Angle_TO_Rad(person%angle) <span class="comment">!单位转换</span></span><br><span class="line">    Vx = person%speed * <span class="built_in">cos</span>(rad) <span class="comment">!水平方向速度</span></span><br><span class="line">    time = <span class="number">2.0</span> * person%speed * <span class="built_in">sin</span>(rad)/G <span class="comment">!在空中飞行时间</span></span><br><span class="line">    person%distance = Vx * time </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>报错了，是下面这一行代码编译出错</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">real</span>,<span class="keyword">external</span> :: Get_Distance <span class="comment">!声明Get_Distance 是一个函数。</span></span><br></pre></td></tr></table></figure>
<p>报错的理由好像是说，这一句应该是用在函数上，但是这里 Get_Distance 是一个子程序，不匹配。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EX0836.F90:<span class="number">26.33</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: Get_Distance</span><br><span class="line">                                 <span class="number">1</span></span><br><span class="line">Error: <span class="function"><span class="keyword">FUNCTION</span></span> attribute conflicts with <span class="function"><span class="keyword">SUBROUTINE</span></span> attribute <span class="keyword">in</span> <span class="string">&#x27;get_distance&#x27;</span> at (<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用自定义数据类型封装后，一次只要提交一个变量即可。这里主程序和子程序都要用到 player 类型，如果不使用 MODULE，需要在主程序和子程序中都分别声明一次 player 类型才行，这样会让程序代码显得很罗嗦。把自定义类型 player 写在 MODULE 中，只要在函数中 USE 这个 MODULE 就可以认得 player 类型。</p>
<h3 id="8-7-3-MODULE-中的函数">8-7-3 MODULE 中的函数</h3>
<p>MODULE 中还可以容纳函数，编写结构如下。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> module_name</span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">contains</span> <span class="comment">!从contains后开始写作函数</span></span><br><span class="line">	<span class="function"><span class="keyword">subroutine</span></span> sub_name</span><br><span class="line">		……</span><br><span class="line">		……</span><br><span class="line">	<span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br></pre></td></tr></table></figure>
<p>通常会把功能上相关的函数放在同一个 MODULE 模块中。而程序想要调用 MODULE 中的函数时，也要先通过 use module_name 的命令，才能够调用到它们。这个做法比较符合模块化概念，编写大程序时，可以把程序中属于绘图功能的部分放在 module Graphics 中， 把数值计算的部分放在 module Numerical 中。</p>
<p>Visual Fortran 中所提供的一些扩充函数库就用这个方法归类，像是数值函数库 IMSL 就放在 module IMSL，3D 绘图程序库 OpenGL 的函数就放在 module OpenGL 中。使用它们之前都要先 use IMSL, use OpenGL。</p>
<p>在同一个 MODULE 中的变量及函数间还有一个重要的关系，那就是函数可以直接使用同一个 MODULE 里所声明的变量，说明如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> tool</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">	<span class="keyword">integer</span> :: a <span class="comment">!先声明一个变量a</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">contains</span></span><br><span class="line">		<span class="function"><span class="keyword">subroutine</span></span> add()</span><br><span class="line">		<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">		a = a + <span class="number">1</span> <span class="comment">!module 中的子程序可以使用module中声明的变量</span></span><br><span class="line">		……</span><br><span class="line">		</span><br></pre></td></tr></table></figure>
<p>现在我们看看一个把函数编写在MODULE 中的实例程序，改写 ex0836 如下：</p>
<p>这个程序比前一个多了 module shoot .</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> constant</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">parameter</span> :: PI = <span class="number">3.14159</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">parameter</span> :: G = <span class="number">9.81</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> player</span><br><span class="line">        <span class="keyword">real</span> :: angle</span><br><span class="line">        <span class="keyword">real</span> :: speed</span><br><span class="line">        <span class="keyword">real</span> :: distance</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> shoot </span><br><span class="line">    <span class="keyword">use</span> constant</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">!把0~360的角度转换成0~2PI的弧度</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Angle_TO_Rad(angle)</span><br><span class="line">        <span class="keyword">use</span> constant</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> angle</span><br><span class="line">        Angle_TO_Rad = angle*pi/<span class="number">180.0</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">!由角度、切线速度来计算投掷距离</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Get_Distance(person)</span><br><span class="line">        <span class="keyword">use</span> constant</span><br><span class="line">        <span class="keyword">use</span> typedef</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(player) :: person</span><br><span class="line">        <span class="keyword">real</span> rad,Vx,time</span><br><span class="line">        <span class="keyword">real</span>,<span class="keyword">external</span> :: Angle_TO_Rad <span class="comment">!声明Angle_TO_Rad 是个函数</span></span><br><span class="line">        </span><br><span class="line">        rad = Angle_TO_Rad(person%angle) <span class="comment">!单位转换</span></span><br><span class="line">        Vx = person%speed * <span class="built_in">cos</span>(rad) <span class="comment">!水平方向速度</span></span><br><span class="line">        time = <span class="number">2.0</span> * person%speed * <span class="built_in">sin</span>(rad)/G <span class="comment">!在空中飞行时间</span></span><br><span class="line">        person%distance = Vx * time </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0837</span><br><span class="line">    <span class="keyword">use</span> shoot</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">parameter</span> :: players = <span class="number">5</span></span><br><span class="line">    <span class="keyword">type</span>(player) :: people(players) = (/ player(<span class="number">30.0</span>,<span class="number">25.0</span>,<span class="number">0.0</span>),&amp;</span><br><span class="line">                                        player(<span class="number">45.0</span>,<span class="number">20.0</span>,<span class="number">0.0</span>),&amp;</span><br><span class="line">                                        player(<span class="number">35.0</span>,<span class="number">21.0</span>,<span class="number">0.0</span>),&amp;</span><br><span class="line">                                        player(<span class="number">50.0</span>,<span class="number">27.0</span>,<span class="number">0.0</span>),&amp;</span><br><span class="line">                                        player(<span class="number">40.0</span>,<span class="number">22.0</span>,<span class="number">0.0</span>)&amp;</span><br><span class="line">                                    /)</span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: Get_Distance <span class="comment">!声明Get_Distance 是一个函数。  </span></span><br><span class="line">    <span class="keyword">integer</span> :: I</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> I=<span class="number">1</span>,players</span><br><span class="line">        <span class="keyword">call</span> Get_Distance(people(I))</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Player &#x27;,i1,&#x27; =&#x27;,f8.2)&quot;</span>) I,people(I)%distance</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="8-8-一些少用的功能">8-8 一些少用的功能</h2>
<h3 id="8-8-1-ENTRY">8-8-1 ENTRY</h3>
<p>ENTRY 用来在函数中创建一个新的“入口”，调用这个入口时，会跳过进入点之前的程序代码来执行函数，直接用一个实例来说明：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0838</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">call</span> sub()</span><br><span class="line">    <span class="keyword">call</span> mid()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub()</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Hello.&quot;</span></span><br><span class="line">    <span class="built_in">entry</span> mid() <span class="comment">!另一个进入点mid</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Good morning.&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello.</span><br><span class="line">Good morning.</span><br><span class="line">Good morning.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>前两行输出是调用子程序 sub 时所得到的，第3行输出是调用子程序中的另一个进入点 mid 得到的。 entry 在子程序 sub 建立了一个新的调用进入点 mid。主程序调用 mid 时，会从子程序 sub 中， entry mid() 这一行来执行程序。</p>
<h3 id="8-8-2-特别的-return">8-8-2 <s>特别的 return</s></h3>
<p>从函数中 return 返回调用处时，通常会直接返回调用处来继续执行程序。关于这一点也是可以改变的，调用函数时可以额外指定其他的折返点，这里有一个实例：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0839</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a</span><br><span class="line">    </span><br><span class="line">    read(*,*) a</span><br><span class="line">    <span class="keyword">call</span> sub(a,*<span class="number">100</span>,*<span class="number">200</span>)</span><br><span class="line">    <span class="comment">!特别另外指定两个折返点，分别时行代码100及200这两个地方</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Default&quot;</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line">    <span class="number">100</span> <span class="built_in">write</span>(*,*) <span class="string">&quot;Return 1&quot;</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line">    <span class="number">200</span> <span class="built_in">write</span>(*,*) <span class="string">&quot;Return 2&quot;</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub(a,*,*)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a</span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">0</span>) tehn</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">!返回默认的折返点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="comment">!返回特别指定的第1个折返点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> <span class="comment">!返回特别指定的第2个折返点</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序执行后会要求输入一个整数，输入值小于等于0时，调用子程序 sub 会返回默认折返点。输入值为1时，会返回特定指定的第1个折返点。输入其他值会返回特别指定的第2个折返点。</p>
<p>程序第6行输入的最后两个参数时程序代码中的行代码，要加上星号来做识别，不然会被当成普通的整数，它们用来指定折返点的位置</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> sub(a,*<span class="number">100</span>,*<span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<p>子程序sub接收最后两个参数时只要使用星号就行了，不需要再声明变量去接收。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub(a,*,*)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我一看到行代码，就知道这个我用不上。</p>
</blockquote>
<h2 id="8-9-使用多个文件">8-9 使用多个文件</h2>
<p>程序员通常会把一些具有相关功能的函数，独立编写在不同的文件中，编译器可以分别编译这些程序文件，最后再把它们链接到同一个执行文件中。把程序代码分散在不同的文件中有几个好处：</p>
<ol>
<li>独立文件的函数，可以再拿给其他程序使用</li>
<li>可以加快编译速度，修改其中一个文件时，编译器只需要重新编译这个文件就行了。</li>
</ol>
<p>这个小节会教读者如何把程序代码分散到不同文件中。</p>
<h3 id="8-9-1-include">8-9-1 include</h3>
<p>include 命令用在程序代码中，插入另一个文件中的内容。这是在 Fortran 中使用多个文件的最简单方法，下面的实例包含两个文件，读者要先确定这两个文件都放在同一个目录下再来做编译。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0840m</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">call</span> sub() <span class="comment">!子程序sub写在另一个文件中</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;EX0840S.F90&#x27;</span> <span class="comment">!在这里插入 EX0840S.F90 这个文件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第二个程序 EX0840S.F90</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub()</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Hello.&quot;</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于采用了 include 命令将第二个文件的内容插入了进来，直接编码运行第一个程序即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gfortran EX0840M.F90</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./a.out</span></span><br><span class="line"> Hello.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个实例把主程序和子程序写在两个不同文件中，然后采用 include 合并在一块。</p>
<p>include 命令可以写在任何地方，它只是单纯地用来插入一个文件的内容。有时候也会应用在声明全局变量，先把声明全局变量的程序代码编写在某个文件中，需要使用全局变量的时候再去include这个文件（这种情况用 module 不香嘛，作者也说了 module 更香）。</p>
<h3 id="8-9-4-程序库">8-9-4 程序库</h3>
<p>具有特殊功能的一组函数，可以编译成*.LIB 程序库来给其他人使用。*.LIB 的文件内容经过编译，无法从这个文件中读到初始程序代码。<strong>如果程序员想保留自己的独门技巧不被外人偷学，可以把程序代码编译成程序库之后，再交给其他人使用。</strong></p>
<p>市面上也有一些公司专门开发程序库，著名的有数值运算的 IMSL 等。使用程序库可以减轻程序员的负担。</p>
<h2 id="8-10-函数的应用">8-10 函数的应用</h2>
<h2 id="8-11-习题">8-11 习题</h2>
<h3 id="8-11-1-通过子程序计算圆面积">8-11-1 通过子程序计算圆面积</h3>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">parameter</span> :: pi = <span class="number">3.14159</span></span><br><span class="line">    <span class="keyword">real</span> r,s</span><br><span class="line">    <span class="keyword">common</span> r,s</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0841</span><br><span class="line">    <span class="keyword">use</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;radius is&quot;</span></span><br><span class="line">    read(*,*) r</span><br><span class="line">    <span class="keyword">call</span> Circle_Area()</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Circle_Area()</span><br><span class="line">    <span class="keyword">use</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    s = pi*r**<span class="number">2</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;area is &#x27;,f8.2)&quot;</span>) s</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>输入输出为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> radius is</span><br><span class="line">2</span><br><span class="line">area is    12.57</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="8-11-2-通过函数计算圆面积">8-11-2 通过函数计算圆面积</h3>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0841</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> r,s</span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: Circle_Area <span class="comment">!声明Circle_Area是一个函数</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;radius is&quot;</span></span><br><span class="line">    read(*,*) r</span><br><span class="line">    s = Circle_Area(r)</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;area is &#x27;,f8.2)&quot;</span>) s</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Circle_Area(r)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">parameter</span> :: pi = <span class="number">3.14159</span></span><br><span class="line">    <span class="keyword">real</span> r</span><br><span class="line">    Circle_Area = pi*r**<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数这里不好用 module 来事先指定参数的类型（除非是固定参数，比如这里的pi），比如这里的函数的参数r，好像必须要在函数中指定。</p>
<h3 id="8-11-3-画长条图">8-11-3 画长条图</h3>
<p>pass</p>
<h3 id="8-11-4-计算等差数列1-2-3-……-100的结果">8-11-4 计算等差数列1+2+3+……+100的结果</h3>
<p>直接套用之前阶乘的程序。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0828</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: n</span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">external</span> :: fact</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;N=&quot;</span></span><br><span class="line">    read(*,*) n</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(i2,&#x27;! = &#x27;,i8)&quot;</span>) n,fact(n)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">recursive</span> <span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> fact(n) result(ans)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>) :: n</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">then</span> <span class="comment">!不合理的输入</span></span><br><span class="line">        ans = -<span class="number">1</span> <span class="comment">!随便设置一个值</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line">    <span class="comment">!下面表示 n&gt;1 的情况，利用n*(n-1)! 来计算 n!</span></span><br><span class="line">    ans = n + fact(n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="8-11-5-计算两个整数的最大公因子">8-11-5 计算两个整数的最大公因子</h3>
<p>一开始没想到怎么做，后来想到用<strong>递归</strong>来做，按较小的整数，每次自减1，看能不能被原来的两个整数整除。</p>
<p>先留个伪代码在这。我还不清楚fortran怎么判断整除，但有了这个思路了，写起来也很简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0. 先判断两个整数是不是符合要求，必须为正数。</span><br><span class="line">1. 先看两个整数能否直接整除，如果能，最大公因子就是较小的整数。</span><br><span class="line">2. 如果不能，以较小的数为基本，每次自减1，看能否被两个整数整除。递归的终点是1。</span><br></pre></td></tr></table></figure>
<h1>9 文件</h1>
<p>文件是很实用的功能，使用文件才能永远记录程序的执行结果。</p>
<h2 id="9-1-文件读取的概念">9-1 文件读取的概念</h2>
<p>在 Fortran 语言中，读取文件的操作可以有“顺序读取”及“直接读取” 两种方式。</p>
<p>所谓的“顺序读取”，是指读写一个文件时，只能从头开始，一步步地向下来读取数据，就像听录音带一样。想要略过数据、或是重新读取时，同样要先“快转” 或是 “倒带”。这是最简单地文件运行方式，不过已经足以应付许多的状况。</p>
<p>而“直接读取” 是指在读写文件时，可以任意跳跃到文件的任何一个位置来读写。</p>
<p>另外在文件的“保存格式” 上，也有两种方法：分别是“文本文件” 以及 “二进制文件”。使用二进制文件无法看到内容，它的好处是：一是<strong>读取速度比较快</strong>，因为它的保存格式和数据在内存中的保存方法相同，不像“文本文件”需要经过转换。另一个优点是<strong>较省空间</strong>。</p>
<h2 id="9-2-文件的操作">9-2 文件的操作</h2>
<p>在 Fortran 中，跟文件有关的操作命令非常丰富，不过有很多命令根本就不常用，只需要先浏览一遍。</p>
<h3 id="9-2-1-open-的使用">9-2-1 open 的使用</h3>
<p>前面使用 READ, WRITE 命令时，括号的第一栏都是放一个星号，表示输入/出的位置使用默认值，也就是从键盘输入以及从屏幕输出。使用open命令打开文件之后，就可以对文件进行输入/出，来看看下面这个实例：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0901</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    open(<span class="keyword">unit</span>=<span class="number">10</span>, <span class="keyword">file</span> = <span class="string">&#x27;hello.txt&#x27;</span>)</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">10</span>,*) <span class="string">&quot;hello&quot;</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行后生成了一个文件，程序第3行使用 open 命令来打开文件，open的第1个参数用来给文件指定一个代码（避开1,2,5,6，因为2,6 是默认的输出位置，也就是屏幕。1,5 是默认的输入位置，也就是键盘 ），第二个参数是文件名称（最好不要使用中文名称）。文件打开之后，程序中都会以这个代码来使用 hello.txt 这个文件。</p>
<p>文件打开之后，使用 read, write 命令时，把输入/出的位置指定成某个文件代码，就可以读写文件。</p>
<p>open的具体参数</p>
<blockquote>
<p>open(unit=number, file=filename, form=…, status=…, access=…, recl=length, err=label, iostat=iostat, blank=…, position=…, action=action, pad=…, delim=…,)</p>
<ul>
<li>
<p>form = ‘formatted’ (表示文件使用“文本文件”格式保存) or ‘unformatted’ (“二进制文件”格式保存)</p>
</li>
<li>
<p>status = ‘new’ /  ‘old’ / ‘scratch’ / ‘unkown’</p>
<p>‘new’ : 表示这个文件原本不存在，是第一次打开</p>
<p>’old’ : 表示这个文件原本已经存在</p>
<p>‘replace’ : 文件若已经存在，会重新创建一次，原本的内容会消失。文件若不存在，会创建新文件。</p>
<p>’scratch’ : 表示要打开一个暂存盘，这个时候可以不需要指定文件名称，也就是 FILE 这一栏可以忽略。因为程序本身会自动取一个文件名，至于文件名是什么也不重要，因为暂存盘会在程序结束后自动删除。</p>
<p>‘unknown’ : 由各编译器自定义。通常会同 replace 的效果</p>
<p>这一栏不给定时，默认为 unkonwn</p>
</li>
<li>
<p>access = ‘sequential’ / ‘direct’</p>
<p>设置读写文件的方法。</p>
<p>‘sequential’ ：顺序读取，默认值</p>
<p>‘direct’ ：直接读取，读写文件可以任意指定位置。</p>
</li>
<li>
<p>recl = length</p>
<p>在顺序读取文件中，recl 字段用来设置一次可以读写多大容量的数据。</p>
<p>在打开“直接读取文件”时，recl = length 的 length 值是用来设置文件中的每一个模块单元的区分长度。</p>
</li>
<li>
<p>err = label</p>
<p>这个字段用来设置当文件打开发生错误时，程序会跳跃到 label 所指的行代码处来继续执行程序。</p>
</li>
<li>
<p>iostat = var</p>
<p>这个字段会设置一个整数值给后面的整型变量，这是用来说明文件打开的状态，数值会有三种情况。</p>
<p>var &gt; 0    表示读取操作发生错误</p>
<p>var = 0    表示读取操作正常</p>
<p>var &lt; 0     表示文件终了</p>
</li>
<li>
<p>blank = ‘null’ / ‘zero’</p>
<p>这用来设置文件输入数字时，当所设置的格式字段中有空格存在时所代表的意义。‘null’ 说明空格代表没有东西；’zero’ ，空格部分会自动以0代入。</p>
</li>
</ul>
</blockquote>
<p>以下为 Fortran 90 添加功能</p>
<blockquote>
<ul>
<li>
<p>position = ‘asis’ / ‘rewind’ / ‘append’</p>
<p>‘asis’ :  表示文件打开时的读取位置，不特别指定，通常就是在文件开头。这是默认值。</p>
<p>‘rewind’ ： 表示文件打开时的读取位置移到文件的开头</p>
<p>‘append’ ：表示文件打开时的读取位置移到文件的末尾</p>
</li>
<li>
<p>action = ‘read’ / ‘write’ / ‘readwrite’</p>
<p>‘readwrite’ :  可读可写，默认值</p>
<p>’read’ : 只读</p>
<p>‘write’ : 只写</p>
</li>
<li>
<p>pad = ‘yes’ / ‘no’</p>
<p>‘yes’ :  在格式化输出时，最前面的不足字段会自动以空格填满，默认值</p>
<p>‘no’ :  不会自动以空格填满</p>
</li>
<li>
<p>delim = ‘apostrophe’ / ‘quote’ / ‘none’</p>
<p>‘none’ : 纯粹输出字符串内容</p>
<p>‘quote’ :  输出字符串加上双引号</p>
<p>‘apostrophe’ : 输出字符串加上单引号</p>
</li>
</ul>
</blockquote>
<h3 id="9-2-2-write-read-的使用">9-2-2 write, read 的使用</h3>
<p>先看一个实例</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0902</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: string</span><br><span class="line">    </span><br><span class="line">    open(<span class="keyword">unit</span>=<span class="number">10</span>, <span class="keyword">file</span> = <span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">10</span>,<span class="string">&quot;(a20)&quot;</span>) <span class="string">&quot;Good morning.&quot;</span> <span class="comment">!写到文件中</span></span><br><span class="line">    rewind(<span class="number">10</span>)</span><br><span class="line">    read(<span class="number">10</span>,<span class="string">&quot;(a20)&quot;</span>) string <span class="comment">!从文件中读出来</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(a20)&quot;</span>) string <span class="comment">!写到屏幕上</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>这里通过 <code>rewind(10)</code> 把文件的读写位置移回文件最前面。</p>
<p>现在来详细介绍 read, write 命令的所有功能，这两个命令的设置字段都很类似，所以可以一起介绍：</p>
<blockquote>
<p>write/read(unit=number, fmt=format, nml=namelist, rec=record, iostat=stat, err=errlabel, end=endlabel, advance=advance, size=size)</p>
<ul>
<li>
<p>unit</p>
</li>
<li>
<p>fmt : 指定输入输出格式</p>
</li>
<li>
<p>nml = namelist</p>
<p>指定读写某个 namelist 的内容。</p>
</li>
<li>
<p>rec = record</p>
<p>在直接读取文件中，设置所要读写的文件模块位置</p>
</li>
<li>
<p>iostat,err ： 同上</p>
</li>
<li>
<p>end = endlabel</p>
<p>指定在读写到文件末尾时，要转移到某个行代码来继续执行程序。</p>
</li>
</ul>
</blockquote>
<p>以下是 Fortran 90 添加功能</p>
<blockquote>
<ul>
<li>
<p>advance = ‘yes’ / ‘no’ : 设置在文本格式下的顺序文件中，每一次的 read, write 命令完成后，读写位置会不会自动向下移动一行。</p>
</li>
<li>
<p>size = count</p>
<p>当 advance = ‘no’ 时，才可以用这个字段。它会把这一次输出入的字符数目设置给后面的整型变量</p>
</li>
</ul>
</blockquote>
<h3 id="9-2-3-查询文件的状态">9-2-3 查询文件的状态</h3>
<p>在使用 open 命令打开文件的前后，都可以通过 inquire 命令来查询文件目前的情况，inquire 命令中的每个字段和第一个小节open的字段很类似。先来看一小段程序，编写一个检查某个文件是否存在的程序：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0903</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: filename = <span class="string">&quot;EX0903.F90&quot;</span></span><br><span class="line">    <span class="keyword">logical</span> alive</span><br><span class="line">    </span><br><span class="line">    inquire(<span class="keyword">file</span>=filename, <span class="keyword">exist</span>=alive)</span><br><span class="line">    <span class="keyword">if</span>(alive) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) filename, <span class="string">&quot; exist.&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) filename, <span class="string">&quot; doesn&#x27;t exist&quot;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里通过 inquire 命令来查询字符串 filename 中记录的文件是否存在。文件存在时 alive 会被设为 .true. ， 不存在则会被设为 .false.</p>
<p>下面详细介绍 inquire 的使用方法:</p>
<blockquote>
<p>inquire(unit=number, file=filename, iostat=stat, err=label, exist=exist, opened=opened, number=number, named=named, access=access, sequential=sequential, direct=direct, form=form, formatted=formatted, unformatted=unformatted, recl=recl)</p>
<ul>
<li>
<p>exist = exist</p>
<p>检查文件是否存在，会返回一个布尔向量给后面的逻辑变量。</p>
</li>
<li>
<p>opened = opened</p>
<p>检查文件是否已经使用 open 命令来打开，会返回一个布尔变量给后面的逻辑变量。</p>
</li>
<li>
<p>number = number</p>
<p>由文件名来查询这个文件所给定的代码。</p>
</li>
<li>
<p>named = named</p>
<p>查询文件是否取了名字，也就是检查文件是否为临时保存盘。</p>
</li>
<li>
<p>access = access</p>
<p>检查文件的读取格式，会返回一个字符串，字符串值可以是：</p>
<p>‘sequential’ : 代表文件使用顺序读取格式</p>
<p>‘direct’ : 代表文件使用直接读取格式</p>
<p>‘undefined’ : 代表没有定义</p>
</li>
<li>
<p>sequential = sequential</p>
<p>查看文件是否使用顺序格式，会返回一个字符串，字符串值可以是：</p>
<p>‘yes’ / ‘no’ / ‘unknown’</p>
</li>
<li>
<p>direct = direct</p>
<p>查看文件是否使用直接格式，会返回一个字符串，字符串值可以是：</p>
<p>‘yes’ / ‘no’ / ‘unknown’</p>
</li>
<li>
<p>form = form</p>
<p>查看文件的保存方法，会返回一个字符串，字符串值可以是：</p>
<p>‘formatted’ : 打开的是文本文件</p>
<p>‘unformatted’ : 打开的是二进制文件</p>
<p>‘undefined’ : 没有定义</p>
</li>
<li>
<p>formatted = fmt</p>
<p>查看文件是否是文本文件，会返回一个字符串，字符串值可以是：</p>
<p>‘yes’ / ‘no’ / ‘unknown’</p>
</li>
<li>
<p>recl = length</p>
<p>返回 open 文件时 recl 栏的设置值</p>
</li>
<li>
<p>nextrec = nr</p>
<p>返回下一次文件读写的位置</p>
</li>
<li>
<p>blank = blank</p>
<p>返回值是字符串，用来查看open文件时的blank参数所给定的字符串值。</p>
</li>
</ul>
</blockquote>
<p>以下为 Fortran 90 添加功能</p>
<blockquote>
<ul>
<li>
<p>position=position</p>
<p>返回打开文件时 position 字段所给定的字符串。</p>
</li>
<li>
<p>action=action</p>
<p>返回打开文件时 action 字段所赋值的字符串</p>
</li>
<li>
<p>delim=delim</p>
<p>返回打开文件时 delim 字段所设置的字符串</p>
</li>
<li>
<p>pad=pad</p>
<p>返回打开文件时 pad 字段所设置的字符串</p>
</li>
</ul>
</blockquote>
<p>其他文件运行命令</p>
<blockquote>
<ul>
<li>
<p>backspace(unit=number, err=errlabel, iostat=iostat)</p>
<p>把文件的读写位置退回一步，其他字段参考上一节</p>
</li>
<li>
<p>endfile(unit=number, err=errlabel, iostat=iostat)</p>
<p>把文件的读写位置变成文件的结尾</p>
</li>
<li>
<p>rewind(unit=number, err=errlabel, iostat=iostat)</p>
<p>把文件的读写位置倒回文件开头。</p>
</li>
<li>
<p>close(unit=number, status=string, err=errlabel, iostat=iostat)</p>
<p>把文件关闭，不再进行读写操作</p>
<p>status=‘keep’ 会在文件关闭后，保留住这个文件。默认值</p>
<p>status=‘delete’ 会在文件关闭后，消除这个文件。</p>
</li>
</ul>
</blockquote>
<p>前面示例过 rewind 的 用法，这里来举例编写一个删除文件的程序：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0904</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">logical</span> alive</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: filename;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*)  <span class="string">&quot;filename:&quot;</span></span><br><span class="line">    read(*,<span class="string">&quot;(a20)&quot;</span>) filename</span><br><span class="line">    </span><br><span class="line">    inquire(<span class="keyword">file</span>=filename, <span class="keyword">exist</span>=alive)</span><br><span class="line">    <span class="keyword">if</span> (alive) <span class="keyword">then</span></span><br><span class="line">        open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename)</span><br><span class="line">        close(fileid, <span class="keyword">status</span>=<span class="string">&quot;delete&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="built_in">trim</span>(filename),<span class="string">&quot; doesn&#x27;t exist.&quot;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序执行后会要求输入一个文件名称，如果存在则删除，如果不存在则会输出错误信息。</p>
<p>删除文件的方法很简单，先用 open 打开，再用 close 关闭文件，close 时赋值不保留这个文件就会把它删除。</p>
<h2 id="9-3-顺序文件的操作">9-3 顺序文件的操作</h2>
<p>顺序文件就好像使用录音带、录像带一样，只能慢慢地播放带子。想要略过一些片段时，要使用快进来跳过它们。</p>
<p>在 windows 的命令窗口下，type 命令可以用来在屏幕上快速浏览一个文本文件内容。下面的实例程序有同样的功能。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0905</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">79</span>) :: filename</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">79</span>) :: buffer</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">integer</span> :: <span class="keyword">status</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">logical</span> alive</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Filename:&quot;</span></span><br><span class="line">    read(*, <span class="string">&quot;(a79)&quot;</span>) filename</span><br><span class="line">    inquire(<span class="keyword">file</span>=filename, <span class="keyword">exist</span>=alive)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(alive) <span class="keyword">then</span></span><br><span class="line">        open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename, &amp;</span><br><span class="line">            <span class="keyword">access</span>=<span class="string">&quot;sequential&quot;</span>, <span class="keyword">status</span>=<span class="string">&quot;old&quot;</span>)</span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">            read(<span class="keyword">unit</span>=fileid, <span class="keyword">fmt</span>=<span class="string">&quot;(a79)&quot;</span>, <span class="keyword">iostat</span>=<span class="keyword">status</span>) buffer</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">status</span>/=<span class="number">0</span>) <span class="keyword">exit</span> <span class="comment">!没有数据就跳出循环</span></span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(a79)&quot;</span>) buffer</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="built_in">trim</span>(filename),<span class="string">&quot; doesn&#x27;t exist.&quot;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Filename:</span><br><span class="line">hello.txt</span><br><span class="line"> hello</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序会先要求用户输入所要阅读的文件名，输入完毕后，再使用 inquire 命令来检查文件是否存在。如果文件存在，就会开始读取文件：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename, &amp;</span><br><span class="line">            <span class="keyword">access</span>=<span class="string">&quot;sequential&quot;</span>, <span class="keyword">status</span>=<span class="string">&quot;old&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这里 status 默认值是 unknown ，一般编译的做法是若文件已存在，它会被改写，如果不存在，就会打开一个新的文件。这里由于已经确认这个文件已存在，所以这里 status 设置为 old。</p>
<p>文件打开之后，就使用循环来一行一行地读出文件内容。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">	read(<span class="keyword">unit</span>=fileid, <span class="keyword">fmt</span>=<span class="string">&quot;(a79)&quot;</span>, <span class="keyword">iostat</span>=<span class="keyword">status</span>) buffer</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">status</span>/=<span class="number">0</span>) <span class="keyword">exit</span> <span class="comment">!没有数据就跳出循环</span></span><br><span class="line">	<span class="built_in">write</span>(*, <span class="string">&quot;(a79)&quot;</span>) buffer</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>这个循环的工作是：“每次读入一行后，就把这一行的文本写到屏幕上”。 read 命令每读一次，会自动把读取位置移动到下一行。所以这里每一次 read 命令都会读入一行新的文本。不过在读取字符串时，限定输入格式，限定它一次读入每一行的前79个字符，因为在标准的 DOS 及 windows 命令行窗口中，一次也只能显示 80 个字符，所以读太多字符没有意义。如果刚好输出 80 个字符，有的编译器所编译的程序会发生断行的现象。</p>
<p>因为没有办法事先就知道文件会有几行文本，也就不会事先知道应该执行几次循环。这里循环的终止条件是当变量 status 不为0的时候。</p>
<p>上一个程序只是单纯地读取文件而已，现在来看看一个需要写入文件的程序。下面的实例程序可以用来记录全班同学的中文、英文及数学的考试成绩：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">type</span> student</span><br><span class="line">        <span class="keyword">integer</span> Chinese, English, Math</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0906</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: students</span><br><span class="line">    <span class="keyword">type</span>(student), <span class="keyword">allocatable</span> :: s(:)</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) :: filename = <span class="string">&quot;data.txt&quot;</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;班上有多少学术&quot;</span></span><br><span class="line">    read(*,*) students</span><br><span class="line">    <span class="built_in">allocate</span>(s(students), stat=i)</span><br><span class="line">    <span class="keyword">if</span>(i/=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;Allocate buffer fail.&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    open(fileid, <span class="keyword">file</span>=filename)</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>, students</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;请输入&#x27;i2&#x27;号同学的中文、英文及数学成绩&#x27;&quot;</span>) i</span><br><span class="line">        read(*,*) s(i)%Chinese, s(i)%English, s(i)%Math</span><br><span class="line">        <span class="built_in">write</span>(fileid, <span class="string">&quot;(&#x27;site:&#x27;i2/&#x27;Chinese:&#x27;i3&#x27; English:&#x27;i3&#x27; Math:&#x27;i3)&quot;</span>) i,s(i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    close(fileid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译报错，报错的地方在这一句</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write</span>(fileid, <span class="string">&quot;(&#x27;site:&#x27;i2/&#x27;Chinese:&#x27;i3&#x27; English:&#x27;i3&#x27; Math:&#x27;i3)&quot;</span>) i,s(i)</span><br></pre></td></tr></table></figure>
<p>报错信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Unexpected end of format string in format string at (1)</span><br></pre></td></tr></table></figure>
<p>暂时还不清楚原因。</p>
<p>如果运行成功，data.txt 文件的格式应该如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">座号：1</span><br><span class="line">中文：82 英文：90 数学：95</span><br></pre></td></tr></table></figure>
<p>这里将文件的代码赋值给了一个常数（fileid）, 这个方法可以避免在写大程序时，同时打开多个文件却忘记文件代码，毕竟使用变量名称会比硬记数字容易。（确实好一点，可以和 python 一致）</p>
<p>打开这个文件时并没有赋值 status 字段，没有说明文件是“新的”或是“旧的”。这个方法在第1次执行程序时会创造出新文件，第2次执行后则会重新覆盖掉文件上一次的记录。</p>
<p>循环执行结束后，用 close(fileid) 把文件关闭，程序结束。如果省略关闭文件的操作，在程序结束时其实也会自动关闭文件。不过最好还是养成自己来关闭文件的习惯比较好。</p>
<p>这个程序只是示范了如何把成绩写到文件中，如何把成绩从文件中读出来是另外一个问题。读取成绩时要注意格式，要懂得略过一些没有必要的数据。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">type</span> student</span><br><span class="line">        <span class="keyword">integer</span> Chinese, English, Math</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0907</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(student) :: s</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) :: filename = <span class="string">&quot;data.txt&quot;</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">logical</span> alive </span><br><span class="line">    <span class="keyword">integer</span> :: error</span><br><span class="line">    <span class="keyword">integer</span> :: no</span><br><span class="line">    </span><br><span class="line">    inquire(<span class="keyword">file</span>=filename, <span class="keyword">exist</span>=alive)</span><br><span class="line">    <span class="keyword">if</span>(.not. alive)<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="built_in">trim</span>(filename),<span class="string">&quot; doesn&#x27;t exist.&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    open(fileid, <span class="keyword">file</span>=filename)</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        read(fileid, <span class="string">&quot;(5xi2,/,5xi3,6xi3,6xi3)&quot;</span>, <span class="keyword">iostat</span>=error) no,s</span><br><span class="line">        <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(i2,&#x27;号 中文:&#x27;i3&#x27; 英文:&#x27;i3&#x27; 数学:&#x27;i3)&quot;</span>) no,s</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    close(fileid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于每一位学生的数据都占两行，先保存座号再保存成绩，而且使用的字段是固定的。要读取数据也要用相同的格式及字段来读取数据，下面会把输出跟输入部分的程序代码列出来做比较，读者可以发现输出时的文本部分，在输入时都使用 nX 来跳过它们。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">!输出</span></span><br><span class="line"><span class="built_in">write</span>(fileid, <span class="string">&quot;(&#x27;座号:&#x27;i2/&#x27;中文:&#x27;i3&#x27; 英文:&#x27;i3&#x27; 数学:&#x27;i3)&quot;</span>) i,s(i)</span><br><span class="line"><span class="comment">!输入</span></span><br><span class="line">read(fileid, <span class="string">&quot;(5xi2,/,5xi3,6xi3,6xi3)&quot;</span>, <span class="keyword">iostat</span>=error) no,s</span><br></pre></td></tr></table></figure>
<p>输入时，文本中的一些文本，例如”座号:“ 等字符对程序来说都没有意义，程序只要读取它们后面的数字就行了，这些文本可以跳过去不管它。输入格式中的 nX 都是用来跳过这些文本，<strong>请注意一个中文字占的宽度正好是两个英文字母的宽度，所以”座号:“ 会占用5个英文字母的位置。</strong>（一个中文两个字节）。</p>
<p>上一个实例中，因为学生数据的保存格式是固定的。先保存座号，再根据顺序保存中文、英文、数学成绩。所以程序可以直接略过说明字符串。如果每一条数据的位置不固定，读取数据时会很麻烦。</p>
<p>现在来尝试读取一个版面格式比较自由的文件，这个文件记录了好几位篮球员的姓名、身高、体重、平均得分等等数据，每位球员的第一条数据都固定是姓名，其他数据就不固定顺序。每位球员的数据之间可以有任意数目的空行，这个文件（EX0908DAT.TXT）的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">姓名 王天才</span><br><span class="line">体重 80.5 </span><br><span class="line">身高 195.2</span><br><span class="line">得分 15.8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">姓名 李天才</span><br><span class="line">身高 190.3 </span><br><span class="line">体重 85.1</span><br><span class="line">得分 10.8</span><br><span class="line"></span><br><span class="line">姓名 洪天才</span><br><span class="line">体重 90.8</span><br><span class="line">身高 201.3</span><br><span class="line">得分 19.8</span><br><span class="line"></span><br><span class="line">姓名 彭天才</span><br><span class="line">体重 70.2</span><br><span class="line">得分 22.2 </span><br><span class="line">身高 185.0</span><br><span class="line"></span><br><span class="line">姓名 黄天才</span><br><span class="line">得分 20.1</span><br><span class="line">体重 85.0</span><br><span class="line">身高 190.3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在需要一个程序来读入所有选手的数据，并挑选出平均每场可以得分20分以上的球员来显示他们的数据。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">type</span> player</span><br><span class="line">        <span class="keyword">character</span>(len=<span class="number">80</span>) :: <span class="keyword">name</span></span><br><span class="line">        <span class="keyword">real</span> weight, height</span><br><span class="line">        <span class="keyword">real</span> score</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0908</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: filename = <span class="string">&quot;EX0908DAT.TXT&quot;</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">20</span></span><br><span class="line">    <span class="keyword">logical</span> :: alive <span class="comment">!检查文件是否存在</span></span><br><span class="line">    <span class="keyword">type</span>(player) :: p <span class="comment">!读取选手数据</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">10</span>) :: title <span class="comment">!读取数据项</span></span><br><span class="line">    <span class="keyword">real</span> tempnum <span class="comment">!读取数据</span></span><br><span class="line">    <span class="keyword">logical</span>, <span class="keyword">external</span> :: GetNextPlayer <span class="comment">!找出下一位球员的函数</span></span><br><span class="line">    <span class="keyword">integer</span> i <span class="comment">!循环记数器</span></span><br><span class="line">    <span class="keyword">integer</span> error <span class="comment">!检查文件读取是否正常</span></span><br><span class="line">    </span><br><span class="line">    inquire(<span class="keyword">file</span>=filename, <span class="keyword">exist</span>=alive)</span><br><span class="line">    <span class="keyword">if</span>(.not. alive) <span class="keyword">then</span> <span class="comment">!文件不存在就结束程序</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="built_in">trim</span>(filename),<span class="string">&quot; doesn&#x27;t exist&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename)</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="keyword">if</span>(GetNextPlayer(fileid, p%<span class="keyword">name</span>)) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">3</span></span><br><span class="line">                read(fileid, <span class="string">&quot;(a4,1x,f3.2)&quot;</span>, <span class="keyword">iostat</span>=error) title, tempnum</span><br><span class="line">                <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">                    <span class="built_in">write</span>(*,*) <span class="string">&quot;文件读取错误&quot;</span></span><br><span class="line">                    <span class="keyword">stop</span></span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">                <span class="comment">!要经过每一行最前面两个中文来判断读入的是什么数据</span></span><br><span class="line">                <span class="keyword">select</span> <span class="keyword">case</span>(title)</span><br><span class="line">                <span class="keyword">case</span>(<span class="string">&quot;身高&quot;</span>)</span><br><span class="line">                    p%height = tempnum</span><br><span class="line">                <span class="keyword">case</span>(<span class="string">&quot;体重&quot;</span>)</span><br><span class="line">                    p%weight = tempnum</span><br><span class="line">                <span class="keyword">case</span>(<span class="string">&quot;得分&quot;</span>)</span><br><span class="line">                    p%score = tempnum</span><br><span class="line">                <span class="keyword">case</span> <span class="keyword">default</span></span><br><span class="line">                    <span class="built_in">write</span>(*,*) <span class="string">&quot;出现不正确的数据&quot;</span></span><br><span class="line">                    <span class="keyword">stop</span></span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">select</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">exit</span> <span class="comment">!没有数据了，离开循环</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p%score &gt; <span class="number">20.0</span>) <span class="keyword">then</span> <span class="comment">!显示得分高于20分的选手数据</span></span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;姓名:&#x27;a8/,&#x27;身高:&#x27;f5.1,&#x27; 体重:&#x27;f5.1,&#x27; 得分:&#x27;f4.1)&quot;</span>) p</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">!GetNextPlayer 函数会从文件中找出下一位球员的数据位置</span></span><br><span class="line"><span class="comment">!如果文件中还有数据需要读取，返回.true.</span></span><br><span class="line"><span class="comment">!入股文件中没有数据需要读取，返回.false.</span></span><br><span class="line"><span class="keyword">logical</span> <span class="function"><span class="keyword">function</span></span> GetNextPlayer(fileid, <span class="keyword">name</span>)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">intent</span>(<span class="keyword">in</span>):: fileid</span><br><span class="line">    <span class="keyword">character</span>(len=*), <span class="keyword">intent</span>(<span class="keyword">out</span>) :: <span class="keyword">name</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) title</span><br><span class="line">    <span class="keyword">integer</span> error</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        read(fileid, <span class="string">&quot;(a80)&quot;</span>,<span class="keyword">iostat</span>=error) title</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">then</span> <span class="comment">!文件中已经没有数据了</span></span><br><span class="line">            GetNextPlayer = .false.</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(title(<span class="number">1</span>:<span class="number">4</span>)==<span class="string">&quot;姓名&quot;</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">name</span> = title(<span class="number">6</span>:)</span><br><span class="line">            GetNextPlayer = .true.</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结束之后，啥也没有，这不对啊。应该是打印出来得分高于20的个体信息。</p>
<p>程序代码长了一点，把它分为几部分来说明。第28行之前的程序代码是声明和检查的部分，跟前几个实例差不多，不需要再多做介绍。需要介绍的只有 29~57 行的循环部分和函数 GetNextPlayer。</p>
<p>循环第1行会调用函数 GetNextPlayer，函数 GetNextPlayer 会去寻找文件中保存“姓名”这个字符串的位置，并且读出球员姓名。读取方法是使用循环一次读入一行字符串，检查字符串最前面是否为“姓名”这两个中文字，如果是就取出字符串后半部的球员姓名，并返回主程序；如果不是就再读入下一行。一个中文字会使用 两个character来保存，所以第79行要检查字符串最前面的两个中文字时，等于要检查最前面的4个Character 。下面是函数 GetNextPlayer 的核心部分：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">      read(fileid, <span class="string">&quot;(a80)&quot;</span>,<span class="keyword">iostat</span>=error) title</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">then</span> <span class="comment">!文件中已经没有数据了</span></span><br><span class="line">          GetNextPlayer = .false.</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(title(<span class="number">1</span>:<span class="number">4</span>)==<span class="string">&quot;姓名&quot;</span>) <span class="keyword">then</span></span><br><span class="line">          <span class="keyword">name</span> = title(<span class="number">6</span>:)</span><br><span class="line">          GetNextPlayer = .true.</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">do</span> </span><br></pre></td></tr></table></figure>
<p>文件的代码在整个程序中是共享的，不同的函数可以使用相同的代码来读写同一个文件，函数不会独立拥有自己的文件代码。所以在这边，函数 GetNextPlayer 从参数中得到的文件代码，会和主程序使用相同的文件。</p>
<p>再回到主程序的部分，因为在文件中，每位球员的4项数据都是连续4行写在一起，而调用 GetNextPlayer 时会读入第一行的姓名部分，接下来需要再读入3项数据。第31~49 行是一个固定执行3次的循环，它会连续读入3行数据。不过这3项数据的顺序并不固定，所以要检查每一行最前面的文本才能判断它是什么数据。</p>
<p>读取一位球员的数据后，检查他的平均得分是否超过20分，是就输出这位球员的个人数据。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p%score &gt; <span class="number">20.0</span>) <span class="keyword">then</span> <span class="comment">!显示得分高于20分的选手数据</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;姓名:&#x27;a8/,&#x27;身高:&#x27;f5.1,&#x27; 体重:&#x27;f5.1,&#x27; 得分:&#x27;f4.1)&quot;</span>) p</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br></pre></td></tr></table></figure>
<p>从这可以发现，如果版面格式太过自由，读取数据时会很麻烦。</p>
<p>前面的实例都是单纯的读入数据或是输出文件，现在来示例一个同时读写文件的程序。编写一个程序来把文本文件的内容的最前面加上行号后，输出到另一个文件中。例如文件A的内容为：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">	<span class="keyword">integer</span> a</span><br><span class="line">	……</span><br></pre></td></tr></table></figure>
<p>输出到文件B后，每一行最前面会按照顺序补上行号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.program main</span><br><span class="line">2.	implicit none</span><br><span class="line">3.	integer a</span><br><span class="line">  	……</span><br></pre></td></tr></table></figure>
<p>程序如下</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0909</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: inputfileid = <span class="number">10</span>, outputfileid = <span class="number">11</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: maxbuffer = <span class="number">200</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) :: inputfile, outputfile</span><br><span class="line">    <span class="keyword">character</span>(len=maxbuffer) buffer</span><br><span class="line">    <span class="keyword">integer</span> <span class="built_in">count</span></span><br><span class="line">    <span class="keyword">integer</span> error</span><br><span class="line">    <span class="keyword">logical</span> alive</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Input Filename:&quot;</span></span><br><span class="line">    read(*, <span class="string">&quot;(a80)&quot;</span>) inputfile</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Output Filename:&quot;</span></span><br><span class="line">    read(*, <span class="string">&quot;(a80)&quot;</span>) outputfile</span><br><span class="line">    </span><br><span class="line">    inquire(<span class="keyword">file</span>=inputfile, <span class="keyword">exist</span>=alive)</span><br><span class="line">    <span class="keyword">if</span>(.not. alive) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="built_in">trim</span>(inputfile), <span class="string">&quot; doesn&#x27;t exist.&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    open(<span class="keyword">unit</span>=inputfileid, <span class="keyword">file</span>=inputfile, <span class="keyword">status</span>=<span class="string">&quot;old&quot;</span>)</span><br><span class="line">    open(<span class="keyword">unit</span>=outputfileid, <span class="keyword">file</span>=outputfile, <span class="keyword">status</span>=<span class="string">&quot;replace&quot;</span>)</span><br><span class="line">    <span class="built_in">count</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="comment">!读入一整行的数据</span></span><br><span class="line">        read(inputfileid, <span class="string">&quot;(a200)&quot;</span>, <span class="keyword">iostat</span>=error) buffer</span><br><span class="line">        <span class="keyword">if</span>(error/=<span class="number">0</span>) eixt <span class="comment">!没有数据了 离开循环</span></span><br><span class="line">        <span class="comment">!在最前面加上行号再输出到另一个文件中</span></span><br><span class="line">        <span class="built_in">write</span>(outputfileid, <span class="string">&quot;(i3,&#x27;.&#x27;,A)&quot;</span>) <span class="built_in">count</span>,<span class="built_in">trim</span>(buffer)</span><br><span class="line">        <span class="built_in">count</span> = <span class="built_in">count</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    close(inputfileid)</span><br><span class="line">    close(outputfileid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> Input Filename:</span><br><span class="line">EX0909.F90</span><br><span class="line"> Output Filename:</span><br><span class="line">EX0909_test.F90</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行完后打开输出文件，确实每一行都添加了行号。</p>
<p>这个程序很简单，基本上就是利用循环一行一行地把文件内容当作字符串读进来。读入字符串后，把这个字符串前面加上行号，再输出到另一个文件中。下面就是这个程序的核心部分。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">    <span class="comment">!读入一整行的数据</span></span><br><span class="line">    read(inputfileid, <span class="string">&quot;(a200)&quot;</span>, <span class="keyword">iostat</span>=error) buffer</span><br><span class="line">    <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">exit</span> <span class="comment">!没有数据了 离开循环</span></span><br><span class="line">    <span class="comment">!在最前面加上行号再输出到另一个文件中</span></span><br><span class="line">    <span class="built_in">write</span>(outputfileid, <span class="string">&quot;(i3,&#x27;.&#x27;,A)&quot;</span>) <span class="built_in">count</span>,<span class="built_in">trim</span>(buffer)</span><br><span class="line">    <span class="built_in">count</span> = <span class="built_in">count</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>这个程序示例了一次打开两个文件的办法，程序只要在OPEN, READ, WRITE 时使用不同的 UNIT 值，就可以同时使用多个文件。</p>
<h2 id="9-4-直接访问文件的操作">9-4 直接访问文件的操作</h2>
<p>直接访问文件的意义是：“把文件的空间、内容事先分区成好几个同样大小的小模块，这些模块会自动按顺序编号。读写文件时，要先赋值文件读写位置在第几个模块，再来进行读写的工作”。直接访问文件可以任意到文件的任何一个地方来读写，就像欣赏镭射唱片、影盘片时一样，可以任意跳跃到我们所想要欣赏的片段。</p>
<p>来看一段实例，文件 list.txt 中，按照棒次顺序记录了“熊帝队”选手的打击率：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3.12</span><br><span class="line">2.98</span><br><span class="line">3.34</span><br><span class="line">3.45</span><br><span class="line">2.86</span><br><span class="line">2.54</span><br><span class="line">2.78</span><br><span class="line">2.23</span><br><span class="line">2.56</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编写一个可以经过棒次来查询选手打击率的程序。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0910</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: filename = <span class="string">&quot;list.txt&quot;</span></span><br><span class="line">    <span class="keyword">integer</span> player</span><br><span class="line">    <span class="keyword">real</span> hit</span><br><span class="line">    <span class="keyword">integer</span> error</span><br><span class="line">    <span class="keyword">logical</span> alive</span><br><span class="line">    </span><br><span class="line">    inquire(<span class="keyword">file</span>=filename, <span class="keyword">exist</span>=alive)</span><br><span class="line">    <span class="keyword">if</span>(.not. alive) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="built_in">trim</span>(filename), <span class="string">&quot; doesn&#x27;t exist.&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename, <span class="keyword">access</span>=<span class="string">&quot;direct&quot;</span>,&amp;</span><br><span class="line">        <span class="keyword">form</span>=<span class="string">&quot;formatted&quot;</span>, <span class="keyword">recl</span>=<span class="number">6</span>, <span class="keyword">status</span>=<span class="string">&quot;old&quot;</span>)</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;查询第几棒？&#x27;)&quot;</span>)</span><br><span class="line">        read(*,*) player</span><br><span class="line">        read(fileid, <span class="keyword">fmt</span>=<span class="string">&quot;(f4.2)&quot;</span>, <span class="keyword">rec</span>=player, <span class="keyword">iostat</span>=error) hit</span><br><span class="line">        <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;打击率:&#x27;f4.2)&quot;</span>) hit</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    close(fileid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查询第几棒？</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>没有显示结果啊，应该后面一行跟着打击率结果。</p>
<p>程序使用下面的open命令打开了一个直接读取文件：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename, <span class="keyword">access</span>=<span class="string">&quot;direct&quot;</span>,&amp;</span><br><span class="line">    <span class="keyword">form</span>=<span class="string">&quot;formatted&quot;</span>, <span class="keyword">recl</span>=<span class="number">6</span>, <span class="keyword">status</span>=<span class="string">&quot;old&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>打开直接读取文件时，open命令中的 access = “direct” 及定义模块大小的 recl 字段不能省略。access = ‘direct’ 时，form 的默认值是 “unformatted” （二进制文件），所以要打开直接读取的文本文件时，要记得加上 form=“formatted” 这一参数描述。</p>
<p>文件打开后，使用循环来读取用户所要查询的棒次号码。当用户输入一个不存在的棒次时，会挑出循环。循环的主要工作就是从键盘读取棒次，并且从文件中读出打击率。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read(fileid, <span class="keyword">fmt</span>=<span class="string">&quot;(f4.2)&quot;</span>, <span class="keyword">rec</span>=player, <span class="keyword">iostat</span>=error) hit</span><br></pre></td></tr></table></figure>
<p>这里的 read 命令，rec 字段填入的 player 值，就是用户所输入的棒次号码，也就是所要去读取的文件位置。这一行命令会从文件中的 第 player 笔数据读出打击率给变量 hit。</p>
<p>关于这个程序，读者可能还有一些疑问，就是在 open 文件时，为什么要把 recl 设为6？来看看文件list 的内容。可以发现 list.txt 文件中每一行刚好有4个字符，而上场打击的棒次有九人，所以文件中有9行。<strong>而在window的操作系统中，文本文件每一行的末尾都有两个看不见的符号用来代表一行文本的结束。所以一行文本的长度是 “这一行文本的字符数量再加上2”。</strong></p>
<p>在文本文件格式中，recl 字段设置的值代表一个模块会使用几个字符。</p>
<p>由于这个程序是给用户自行输入所要查询的棒次号码，所以读取数据时常常会在文件中任意跳跃。使用直接读取文件才能任意赋值文件的读取位置。</p>
<p>事实上这个程序的最好的编写方法是声明数组，并打开一个顺序文件来把数据读入数组中。用户查询数据时，直接在数组中读取就好了。**因为数组的数据是在内存中，查询数据的速度远快于硬盘中读取。**这个程序中使用直接访问文件纯粹是为了范例。</p>
<p>来看看一个写入直接访问文件的实例，假如现在需要一个输入选手打击率的程序，这个程序能够自由让用户决定现在要输入哪一位打击者的打击率。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0911</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: filename = <span class="string">&quot;ex0911dat.txt&quot;</span></span><br><span class="line">    <span class="keyword">integer</span> player</span><br><span class="line">    <span class="keyword">real</span> hit</span><br><span class="line">    <span class="keyword">integer</span> error</span><br><span class="line">    </span><br><span class="line">    open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename, <span class="keyword">access</span>=<span class="string">&quot;direct&quot;</span>,&amp;</span><br><span class="line">        <span class="keyword">form</span>=<span class="string">&quot;formatted&quot;</span>, <span class="keyword">recl</span>=<span class="number">6</span>, <span class="keyword">status</span>=<span class="string">&quot;replace&quot;</span>)</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;第几棒?&#x27;)&quot;</span>)</span><br><span class="line">        read(*,*) player</span><br><span class="line">        <span class="keyword">if</span>(player&lt;<span class="number">1</span> .or. player&gt;<span class="number">9</span>) <span class="keyword">exit</span> </span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;打击率?&#x27;)&quot;</span>)</span><br><span class="line">        read(*,*) hit</span><br><span class="line">        <span class="built_in">write</span>(fileid, <span class="keyword">fmt</span>= <span class="string">&quot;(f5.2)&quot;</span>, <span class="keyword">rec</span>=player, <span class="keyword">iostat</span>=error) hit</span><br><span class="line">        <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    close(fileid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">第几棒?</span><br><span class="line"><span class="number">3</span></span><br><span class="line">打击率?</span><br><span class="line"><span class="number">3.2</span></span><br><span class="line">第几棒?</span><br><span class="line"><span class="number">5</span></span><br><span class="line">打击率?</span><br><span class="line"><span class="number">2.8</span></span><br><span class="line">第几棒?</span><br><span class="line"><span class="number">9</span></span><br><span class="line">打击率?</span><br><span class="line"><span class="number">2.3</span></span><br><span class="line">第几棒?</span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入的数据在 ex0911dat.txt 当中。因为只输入了3个棒次的数据，所以其他选手的位置都是空格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.20        2.80                    2.30 </span><br></pre></td></tr></table></figure>
<p>这个实例程序和上一个实例程序差不多，只是在把 read 改成 write 而已。</p>
<p>这个程序只是很简单地做写入文件的范例。通常使用直接格式时，不会使用文本格式而会使用二进制格式来保存数据。</p>
<p>使用直接访问文件时，要小心使用 endfile 命令。使用这个命令时，会把目前所在的文件位置之后的数据都清除掉。</p>
<h2 id="9-5-二进制文件的操作">9-5 二进制文件的操作</h2>
<p>文本文件的内容都是用肉眼就可以明白辨认的，现在来试试看“二进制文件”。使用二进制文件来做直接读取时，open 命令中的 recl 字段所设置的整数 n 值所代表的大小会随着编译器不同而改变。有的编译器会视为 n bytes，有的编译器会视为 n*4 bytes。</p>
<p>把输入棒球选手打击率的程序，改成使用二进制文件来记录：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0912</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: filename = <span class="string">&quot;list.bin&quot;</span></span><br><span class="line">    <span class="keyword">integer</span> player</span><br><span class="line">    <span class="keyword">real</span> :: hit(<span class="number">9</span>) = (/ <span class="number">3.12</span>, <span class="number">2.98</span>, <span class="number">3.34</span>, <span class="number">3.45</span>, <span class="number">2.86</span>, <span class="number">2.54</span>, <span class="number">2.78</span>, <span class="number">2.23</span>, <span class="number">2.56</span> /)</span><br><span class="line">    open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename, <span class="keyword">access</span>=<span class="string">&quot;direct&quot;</span>,&amp;</span><br><span class="line">        <span class="keyword">form</span>=<span class="string">&quot;unformatted&quot;</span>, <span class="keyword">recl</span>=<span class="number">1</span>, <span class="keyword">status</span>=<span class="string">&quot;replace&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> player = <span class="number">1</span>,<span class="number">9</span></span><br><span class="line">        <span class="built_in">write</span>(fileid, <span class="keyword">rec</span>=player) hit(player)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    close(fileid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出报错</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">At line <span class="number">11</span> of <span class="keyword">file</span> EX0912.F90 (<span class="keyword">unit</span> = <span class="number">10</span>, <span class="keyword">file</span> = <span class="string">&#x27;list.bin&#x27;</span>)</span><br><span class="line">Fortran runtime error: <span class="built_in">Write</span> exceeds length of <span class="keyword">DIRECT</span> <span class="keyword">access</span> record</span><br></pre></td></tr></table></figure>
<p>把 open 语句中的 recl 改成 4 ，就好了。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename, <span class="keyword">access</span>=<span class="string">&quot;direct&quot;</span>,&amp;</span><br><span class="line">    <span class="keyword">form</span>=<span class="string">&quot;unformatted&quot;</span>, <span class="keyword">recl</span>=<span class="number">4</span>, <span class="keyword">status</span>=<span class="string">&quot;replace&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>生成的文件 list.bin 放在文本编辑器中看起来会很奇怪。必须另外编写程序才能从 list.bin 中查询数据。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0913</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: filename = <span class="string">&quot;list.bin&quot;</span></span><br><span class="line">    <span class="keyword">integer</span> player</span><br><span class="line">    <span class="keyword">real</span> hit</span><br><span class="line">    <span class="keyword">integer</span> error</span><br><span class="line">    <span class="keyword">logical</span> alive</span><br><span class="line">    </span><br><span class="line">    inquire(<span class="keyword">file</span>=filename, <span class="keyword">exist</span>=alive)</span><br><span class="line">    <span class="keyword">if</span>(.not. alive) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="built_in">trim</span>(filename), <span class="string">&quot; doesn&#x27;t exist.&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename, <span class="keyword">access</span>=<span class="string">&quot;direct&quot;</span>,&amp;</span><br><span class="line">        <span class="keyword">form</span>=<span class="string">&quot;unformatted&quot;</span>, <span class="keyword">recl</span>=<span class="number">4</span>, <span class="keyword">status</span>=<span class="string">&quot;old&quot;</span>)</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;查询第几棒？&#x27;)&quot;</span>)</span><br><span class="line">        read(*,*) player</span><br><span class="line">        read(fileid,  <span class="keyword">rec</span>=player, <span class="keyword">iostat</span>=error) hit</span><br><span class="line">        <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;打击率:&#x27;f5.2)&quot;</span>) hit</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    close(fileid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查询第几棒？</span><br><span class="line">2</span><br><span class="line">打击率: 2.98</span><br><span class="line">查询第几棒？</span><br><span class="line">3</span><br><span class="line">打击率: 3.34</span><br><span class="line">查询第几棒？</span><br><span class="line">0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序和 ex0910 差不多，只是差在常量 recl 字段的值及在 open 中的 form 设为 unformatted ，其实可以省略这一栏，因为打开直接访问文件时 form 的默认值就是 unformatted 。</p>
<p>在这边把 recl 字段设为1（有些编译器必须设为4），ex0910 中把 recl 设置成6是因为输出数据的格式为 f4.2，占4个字段。不过如果两笔数据间没有用空格来区分，在文件中会出现一连串紧密的数字。RECL 设置为6之后，每一条数据都会固定输出6个字符。但是这个程序使用的是二进制文件，就没有必要在数据之间用区分符号来增加文件的可读性，因为二进制文件本来就没有可读性可言。</p>
<p>在这一节的实例程序中，对文件读写时都没有使用任何的输入/出格式。二进制文件是直接把在内存中的二进制数据写入文件，就没有所谓的格式化输入/出存在。</p>
<p>二进制文件可以节省空间，不过在这个例子中还不是很明显。假如要记录 1000 个格式为 f8.3 的浮点数，使用文本文件时，所需要的文件长度理论上最少为 1000*8 = 8000 bytes。但事实上一定还要再数据间加上空格符合来区分数据、方便阅读。所以文件最小长度为 1000*9 = 9000 bytes。</p>
<p>用文本文件保存数字，很可能会造成部分数据流失，因为格式 f8.3 只允许存放3位小数，第3位以下的小数都会被舍去，解决办法是多保存几位数字，不过这样会使用更多的空间。</p>
<p><strong>使用二进制文件时，所需要的文件最少长度为 1000*4 = 4000 bytes，而且不会有任何的数据流失。从这里可以知道，要存放 “精确” 及 “大量” 的数据时，使用二进制文件是较好的选择。</strong> （这里我还是不太理解）</p>
<p>重新看这本书的28-30页，Fortran 的数据类型章节，就大概理解了。</p>
<p>首先根据下面这段话，不同的数据格式会按照不同的规则存储为二进制编码</p>
<blockquote>
<p>程序代码中要清除地指定每种数据所要存储的格式。不同种类的数据需要经过转换才能互通，因为它们可能是使用不同方法来存储的。就以整数和浮点数来说，整数是很单纯地以二进制来存储数字。浮点数和整数的不同在于浮点数可以存储带有小数的实数，浮点数会把数字转换成二进制的指数方法来表示，并把数字分为指数部分和小数部分来做记录。</p>
<p>0.5 = 5.0 * 10 ^-1^ = 1.0 * 2^-1^ 。0.5 这个数值会被分成二进制的数值部分1.0，和指数部分 -1 来记录。</p>
<p>读者不需要实际了解每个数值真正会被记录的格式，只需要知道上面所介绍的整数、浮点数、字符、逻辑这4种数据会使用不同的方法来记录就行了。</p>
</blockquote>
<p>下面这段话就介绍了同样一个数字，以文本格式保存和以数字格式保存的区别。</p>
<blockquote>
<p>假如现在需要记录 15243 这个数字，使用整数来记录的话，会把 15243 转换成二进制的 101111110011 保存在内存。它可以使用短整型（2 bytes）或长整型（4 bytes）来记录。使用字符串来记录的话，需要分别去记录“1”，“5”，“2”，“4”，“3”，这5个字符，需要5 bytes 来记录。</p>
</blockquote>
<p>这里就说的很清楚了， 15243 如果视为一个数字，直接可以转为一个二进制代码。如果视为字符串，那么要视为5个字符，每个字符均需要用一个bytes存储。而且使用字符串来记录数字时，不能直接把它们拿来进行加减乘除的运算，要把字符串先转换成整数或浮点数等等的数值类型才能拿来计算。</p>
<h2 id="9-6-Internal-File（内部文件）">9-6 Internal File（内部文件）</h2>
<p>在前面介绍过把数据写入文本文件的方法，现在再介绍一个类似的新概念——“内部文件”。</p>
<p>“内部文件” 是直接从英文原文翻译成中文的名词，其实如果把它叫做“字符串变量文件”会比较切合原义。因为它是使用写入文件的方法，把数据写到一个字符串变量中，来看一个实例：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0914</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a=<span class="number">2</span></span><br><span class="line">    <span class="keyword">integer</span> :: b=<span class="number">3</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: string</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(<span class="keyword">unit</span>=string, <span class="keyword">fmt</span>= <span class="string">&quot;(i2,&#x27;+&#x27;,i2,&#x27;=&#x27;,i2)&quot;</span>) a,b,a+b</span><br><span class="line">    <span class="built_in">write</span>(*,*) string</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序的重点在第7行，write 命令除了可以赋值一个整数值来作为输出位置之外，还可以赋值一个字符串变量来当做输出的目的。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write</span>(<span class="keyword">unit</span>=string, <span class="keyword">fmt</span>= <span class="string">&quot;(i2,&#x27;+&#x27;,i2,&#x27;=&#x27;,i2)&quot;</span>) a,b,a+b</span><br></pre></td></tr></table></figure>
<p>字符串 string 的内容，会按照赋值的格式得到 “2+3=5” 的值。除了可以把数据经过 write 写入字符串之外，还可以把数据经过 read 命令从字符串中读入数据。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0915</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: string = <span class="string">&quot;123&quot;</span></span><br><span class="line">    </span><br><span class="line">    read(string, *) a</span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行后变量 a 的值被设置成 123，设置的操作是发生在第6行的read命令。read命令可以把输入的来源设置到一个字符串变量中，在这里字符串 string 的内容为 “123” , 所以变量a 会被赋值为123。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read(string, *) a</span><br></pre></td></tr></table></figure>
<p>在某些情况下，需要使用内部文件来设置数据。</p>
<p>使用 read 命令从键盘输入数据时，如果用户输入错误的数据，会导致程序死机。例如需要输入整数时却输入英文字母，就可以会死机。比较好的处理方法是，程序先把数据当成字符串读入，检查字符串中是否含有不合理的字符，如果字符串中都是0-9的数字字符，就把字符串转换成整数，不然就请用户再输入一次。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0916</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> i</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">external</span> :: GetInteger</span><br><span class="line">    i = GetInteger()</span><br><span class="line">    <span class="built_in">write</span>(*,*) i</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> GetIntger()</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) :: string</span><br><span class="line">    <span class="keyword">logical</span> :: invalid</span><br><span class="line">    <span class="keyword">integer</span> i, code</span><br><span class="line">    </span><br><span class="line">    invalid = .true.</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(invalid)</span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;请输入正整数&quot;</span></span><br><span class="line">        read(*, <span class="string">&quot;(a80)&quot;</span>) string</span><br><span class="line">        invalid = .false.</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>, <span class="built_in">len_trim</span>(string)</span><br><span class="line">            <span class="comment">!检查输入的字符是否包含&#x27;0&#x27;~&#x27;9&#x27;以外的字符</span></span><br><span class="line">            code = <span class="built_in">ichar</span>(string(i:i))</span><br><span class="line">            <span class="keyword">if</span>(code &lt; <span class="built_in">ichar</span>(<span class="string">&#x27;0&#x27;</span>) .or. code &gt; <span class="built_in">ichar</span>(<span class="string">&#x27;9&#x27;</span>)) <span class="keyword">then</span></span><br><span class="line">                invalid = .true.</span><br><span class="line">                <span class="keyword">exit</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    read(string, *) GetInteger</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 请输入正整数</span><br><span class="line">2.a</span><br><span class="line"> 请输入正整数</span><br><span class="line">2</span><br><span class="line">           2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>读取数据的程序代码是在函数 GetInteger 中，它会暂时先把数据以字符串方法读入，用循环检查每个字符是否为数字字符，如果发现了不是数字的字符，就会要求重新输入数据。</p>
<p>检查是否为数字字符的方法，是从字符的ASCII 值来看，数字字符0~9在ASCII 中是连号排列，0的ASCII 值最小，9最大。所以只要字符串中有任何一个字符的 ASCII 值小于 0 的ASCII 值，或是大于9的ASCII 值，字符串中就包含非数字的字符。</p>
<p>得到合理的输入后，再使用 read 命令把字符串中的数字读出来。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read(string, *) GetInteger</span><br></pre></td></tr></table></figure>
<p>内部文件还可以应用在动态改变输出格式，输出格式可以事先存放在字符串中，程序进行中，动态改变字符串内容就可以<strong>改变输出格式</strong>（比如整数格式改为字符串），下面是一个实例：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0917</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> a,b</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">30</span>) :: fmtstring = <span class="string">&quot;(i??,&#x27;+&#x27;,i??,&#x27;=&#x27;,i??)&quot;</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">external</span> :: GetInteger</span><br><span class="line">    </span><br><span class="line">    a = GetInteger()</span><br><span class="line">    b = GetInteger()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(fmtstring(<span class="number">3</span>:<span class="number">4</span>), <span class="string">&quot;(i2.2)&quot;</span>) <span class="built_in">int</span>(<span class="built_in">log10</span>(<span class="keyword">real</span>(a))+<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">write</span>(fmtstring(<span class="number">11</span>:<span class="number">12</span>), <span class="string">&quot;(i2.2)&quot;</span>) <span class="built_in">int</span>(<span class="built_in">log10</span>(<span class="keyword">real</span>(b))+<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">write</span>(fmtstring(<span class="number">19</span>:<span class="number">20</span>), <span class="string">&quot;(i2.2)&quot;</span>) <span class="built_in">int</span>(<span class="built_in">log10</span>(<span class="keyword">real</span>(a+b))+<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">write</span>(*,fmtstring) a,b,a+b</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> GetInteger()</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) :: string</span><br><span class="line">    <span class="keyword">logical</span> :: invalid</span><br><span class="line">    <span class="keyword">integer</span> i, code</span><br><span class="line">    </span><br><span class="line">    invalid = .true.</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(invalid)</span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;请输入正整数&quot;</span></span><br><span class="line">        read(*, <span class="string">&quot;(a80)&quot;</span>) string</span><br><span class="line">        invalid = .false.</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>, <span class="built_in">len_trim</span>(string)</span><br><span class="line">            <span class="comment">!检查输入的字符是否包含&#x27;0&#x27;~&#x27;9&#x27;以外的字符</span></span><br><span class="line">            code = <span class="built_in">ichar</span>(string(i:i))</span><br><span class="line">            <span class="keyword">if</span>(code &lt; <span class="built_in">ichar</span>(<span class="string">&#x27;0&#x27;</span>) .or. code &gt; <span class="built_in">ichar</span>(<span class="string">&#x27;9&#x27;</span>)) <span class="keyword">then</span></span><br><span class="line">                invalid = .true.</span><br><span class="line">                <span class="keyword">exit</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    read(string, *) GetInteger</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 请输入正整数</span><br><span class="line">100</span><br><span class="line"> 请输入正整数</span><br><span class="line">1</span><br><span class="line">100+1&#x3D;101</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序的重点在于最后一行的输出，在这里希望能够把数字都很紧密地输出到屏幕上，所以需要知道输入的两个数字占用几个位数，再根据它们的值来决定输出格式。程序10-12行才会计算出这些数字占用几个位数。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write</span>(fmtstring(<span class="number">3</span>:<span class="number">4</span>), <span class="string">&quot;(i2.2)&quot;</span>) <span class="built_in">int</span>(<span class="built_in">log10</span>(<span class="keyword">real</span>(a))+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>从 log10(a) + 1 可以得到变量 a 占用几个位数。因为 0&lt;a&lt;10 时 log10(a)&lt;1, 10&lt;a&lt;100时 log10(a) &lt; 2 …… ，把 log10(a)+1 转化为整数后就是数字 a 所占用的位数。<strong>如果不动态计算数字的位数大小，输出格式一定是固定的，不管数字的大小是多少，都会占用同样的字段宽度来做输出。</strong></p>
<h2 id="9-7-namelist">9-7 namelist</h2>
<p>namelist 也是很特殊的输入/出方法，它可以把一组相关变量封装在一起，输入/出这一组变量时，只要在 write/read 的 nml 字段赋值要使用哪一个 namelist 就行了，下面是一个实例：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0918</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span></span><br><span class="line">    <span class="keyword">namelist</span> /na/ a,b,c</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="keyword">nml</span>=na)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;NA</span><br><span class="line"> A&#x3D;          1,</span><br><span class="line"> B&#x3D;          2,</span><br><span class="line"> C&#x3D;          3,</span><br><span class="line"> &#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序的第4行，把a,b,c 这3个变量放在名字叫做 na 的 namelist 中。namelist 也算是声明的一部分，必须编写在程序执行命令的前面。 namelist 的语法很类似 common ， 不过使用 namelist 时一定要取名字。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namelist</span> /nl_name/ var1,var2,……</span><br></pre></td></tr></table></figure>
<p>封装好 namelist 后，在 write 的 nml 字段中指明要输出哪一个 namelist ，就可以把在 namelist 中的变量全部输出。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write</span>(*,<span class="keyword">nml</span>=na)</span><br></pre></td></tr></table></figure>
<p>输出namelist 时不能赋值输出格式，Fortran 90 标准中规定输出 namelist 时首先会输出符合&amp;，后面紧接着这个namelist 的名字。接着会根据顺序输出变量的名称、等号及内容，变量之间用空格或逗号来做分隔，最后使用除号来作结束。</p>
<p>至于每个数字内容会用什么格式来输出，就由编译器自行决定。（gfortran 的显示结果就和书上不太一样）</p>
<p>namelist 也可以用来输入数据。不过通常都会用来读取文件，不会用在键盘输入，先来看一个键盘输入的实例：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0919</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a,b,c</span><br><span class="line">    <span class="keyword">namelist</span> /na/ a,b,c</span><br><span class="line">    read(*, <span class="keyword">nml</span>=na)</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="keyword">nml</span>=na)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&amp;na a&#x3D;1 b&#x3D;2 c&#x3D;3 &#x2F;</span><br><span class="line">&amp;NA</span><br><span class="line"> A&#x3D;          1,</span><br><span class="line"> B&#x3D;          2,</span><br><span class="line"> C&#x3D;          3,</span><br><span class="line"> &#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里输入必须要按照上面介绍的格式来输入，先输入符号&amp;，紧接namelist 的名字，再输入变量名称、等号及内容，要结束时还要加上除号。</p>
<p>读取namelist 时，可以不填入所有变量的值，只要以&amp;na开始输入，给一个除号就可以结束输入。变量可以不按照顺序输入，程序会自动按照变量名称来设置数值。变量设置可以重复输入，不过变量会得到最后一次设置的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;na a&#x3D;1 a&#x3D;2 &#x2F; (重复设置a两次，变量a最后会等于2)</span><br></pre></td></tr></table></figure>
<p>从这个例子可以发现，使用键盘来输入namelist 的内容会非常麻烦。namelist 通常使用再文本文件的输入/出中，使用 read 从文件中读取数据时，会自动从目前的位置向下寻找存放 namelist 的地方。来看下一个实例：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0920</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">namelist</span> /na/ a</span><br><span class="line">    </span><br><span class="line">    open(<span class="number">10</span>,<span class="keyword">file</span>=<span class="string">&quot;ex0920.txt&quot;</span>)</span><br><span class="line">    read(<span class="number">10</span>,<span class="keyword">nml</span>=na)</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(3i2)&quot;</span>) a</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中 ex0920.txt 的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">happy birthday</span><br><span class="line">&amp;na a&#x3D;1,2,3 &#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序打开时，读写位置在文件的开头。读者可以发现文件开头的内容是字符串 happy birthday ，第7行的read命令会自动向下寻找 na 这个 namelist 的存放位置来读取数据。这边看到了namelist 处理数组的方法，它会在等号后面根据序号显示数组内容。</p>
<h2 id="9-8-文件的应用">9-8 文件的应用</h2>
<p>光盘中 \program\chap09\grades.txt 的文件是一张成绩单，记录了全班 20 位学生的某一次阶段考试成绩。</p>
<p>编写程序来读取成绩单，计算每位同学的总分，及各科的全部平均分，以下面的程序重新输出成绩单的内容：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">type</span> student</span><br><span class="line">        <span class="keyword">integer</span> :: Chinese, English, Math, Natural, Social</span><br><span class="line">        <span class="keyword">integer</span> :: total</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0921</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: students = <span class="number">20</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) :: tempstr</span><br><span class="line">    <span class="keyword">type</span>(student) :: s(students) <span class="comment">!保存学生成绩</span></span><br><span class="line">    <span class="keyword">type</span>(student) :: total <span class="comment">!保存平均分数</span></span><br><span class="line">    <span class="keyword">integer</span> i, num, error</span><br><span class="line">    </span><br><span class="line">    open(fileid, <span class="keyword">file</span>=<span class="string">&quot;grades.txt&quot;</span>, <span class="keyword">status</span>=<span class="string">&quot;old&quot;</span>, <span class="keyword">iostat</span>=error)</span><br><span class="line">    <span class="keyword">if</span> (error/=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;open grades.txt fail&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    read(fileid, <span class="string">&quot;(a80)&quot;</span>) tempstr <span class="comment">!读入第一行文本</span></span><br><span class="line">    total = student(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="comment">!用循环读入每位同学的成绩</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,students</span><br><span class="line">        read(fileid, *) num, s(i)%Chinese, s(i)%English, &amp;</span><br><span class="line">                        s(i)%Math, s(i)%Natural, s(i)%Social</span><br><span class="line">        <span class="comment">!计算总分</span></span><br><span class="line">        s(i)%Total = s(i)%Chinese + s(i)%English + &amp;</span><br><span class="line">                    s(i)%Math + s(i)%Natural + s(i)%Social</span><br><span class="line">        <span class="comment">!累加上各科的分数，计算各科平均时使用</span></span><br><span class="line">        total%Chinese = total%Chinese + s(i)%Chinese</span><br><span class="line">        total%English = total%English + s(i)%English</span><br><span class="line">        total%Math = total%Math + s(i)%Math</span><br><span class="line">        total%Natural = total%Natural + s(i)%Natural</span><br><span class="line">        total%Social = total%Social + s(i)%Social</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">!重新输出每位学生成绩</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(7a7)&quot;</span>) <span class="string">&quot;座号&quot;</span>,<span class="string">&quot;中文&quot;</span>,<span class="string">&quot;英文&quot;</span>,<span class="string">&quot;数学&quot;</span>,<span class="string">&quot;自然&quot;</span>,<span class="string">&quot;社会&quot;</span>,<span class="string">&quot;总分&quot;</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,students</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(7i7)&quot;</span>) i,s(i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">!计算并输出平均分数</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(a7,6f7,1)&quot;</span>) <span class="string">&quot;平均&quot;</span>,&amp;</span><br><span class="line">        <span class="keyword">real</span>(total%Chinese)/<span class="keyword">real</span>(students),&amp;</span><br><span class="line">        <span class="keyword">real</span>(total%English)/<span class="keyword">real</span>(students),&amp;</span><br><span class="line">        <span class="keyword">real</span>(total%Math)/<span class="keyword">real</span>(students),&amp;</span><br><span class="line">        <span class="keyword">real</span>(total%Natural)/<span class="keyword">real</span>(students),&amp;</span><br><span class="line">        <span class="keyword">real</span>(total%Social)/<span class="keyword">real</span>(students),&amp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序使用另一个方法来判断 grades.txt 是否存在，第18行的open 命令中，iostat 字段会把文件打开是否成功的结果放在变量 error 中。 error 的值若不为零代表找不到这个文件。</p>
<p>读入文件时，有几个地方的数据是可以直接跳过去不处理的，像第一行的表头字符串及每一行最前面的学生座号。表头字符串只是用来说明这个位置存放的是哪个科目的成绩，而每一行最前面的学生座号是按照顺序排列下来的。这些固定的数据不需要再处理，把它们读进来之后就可以不再理会它们。程序中的变量 tempstr 和 num 从文件中得到数据后就没有再去使用。</p>
<p>第24行的 read 命令需要赋值输入格式，如果不赋值这里要一口气读入80个字符长度的字符串，读取数据时，grade.txt 中第一行会被当成 6 个小字符串。<strong>使用默认输入格式时，遇到空格符会当成分隔符</strong>。</p>
<p>第28行的 read 命令可以不赋值输入格式，在文本文件格式下，两笔数据之间如果只用空格来做分隔，不特别赋值输入格式就可以正确得到内容。文件 grades.txt 中，从第2行开始，每一行都是连续的 6 个整数，数字之间用空格来分隔，所以从第2行之后，不需要赋值输入格式，每一行都读入6个整数就行了。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(fileid, *) num, s(i)%Chinese, s(i)%English, &amp;</span><br><span class="line">                s(i)%Math, s(i)%Natural, s(i)%Social</span><br></pre></td></tr></table></figure>
<p>这个实例没有做成绩排名，这部分留到习题给读者练习。在这里使用自定义类型来记录每位学生的成绩，如果不用自定义类型时，分别需要对每个科目都声明一个数组来记录成绩，在做排序时交换数据会变得很麻烦。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">!使用自定义类型时，s(j)及s(i) 中就包含了一位学生的全部数据</span></span><br><span class="line">temp = s(j)</span><br><span class="line">s(j) = s(i)</span><br><span class="line">s(i) = temp</span><br><span class="line"></span><br><span class="line"><span class="comment">!不使用自定义类型时，要对每个科目声明一个数组来记录成绩</span></span><br><span class="line"><span class="comment">!需要交换两位学生数据时，要交换5个数组的数据，非常麻烦</span></span><br><span class="line">temp=Chinese(j)</span><br><span class="line">Chinese(j)=Chinese(i)</span><br><span class="line">Chinese(i)=temp</span><br><span class="line">temp=English(j)</span><br><span class="line">English(j)=English(i)</span><br><span class="line">English(i)=temp</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h1>10 指针</h1>
<p>指针是一个很有趣的东西，它最简单的应用可以用来保存变量，或者是动态使用内存。更进一层则可以应用在特别的“数据结构”上，例如创建“串行结构”、“树状结构”等等。</p>
<h2 id="10-1-指针基本概念">10-1 指针基本概念</h2>
<p>简单地说，指针是一种“间接使用数据”的方法。指针变量用来保存一个“内存地址”。当程序要读写指针变量时，实际上会经过两个步骤：</p>
<ol>
<li>取出指针所保存的内存位置。</li>
<li>到这个内存位置读写数据</li>
</ol>
<p>指针变量中所保存的内存地址来源可以有两种：</p>
<ol>
<li>记录其他非指针变量的内存位置。</li>
<li>程序执行中动态配置一块内存。</li>
</ol>
<p>最基本的指针运行，是指指针变量拿来记录另外一个目标变量的地址，再经过指针来读写数据，来看看这个实例：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex1001</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">target</span> :: a=<span class="number">1</span> <span class="comment">!声明一个可以当成目标的变量</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p <span class="comment">!声明一个可以指向整数的指针</span></span><br><span class="line">    p=&gt;a <span class="comment">!把指针p指到变量a</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) p</span><br><span class="line">    a = <span class="number">2</span> <span class="comment">!改变a的值</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) p</span><br><span class="line">    p = <span class="number">3</span> <span class="comment">!改变指针p所指向的内存内容</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 </span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序的第3行出现新的声明方法，第3行的声明中出现新的形容词 target 。声明中加上 target 的变量，在使用上并不会有任何不同，只不过这种变量可以把它的内存地址赋值给指针变量。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">target</span> :: a = <span class="number">1</span> </span><br></pre></td></tr></table></figure>
<p>第4行也出现了新的声明方法，声明中使用了 pointer, 表示这里要声明的是指针变量。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p <span class="comment">!声明一个可以指向整数的指针</span></span><br></pre></td></tr></table></figure>
<p>有了指针之后，程序第5行会把指针p指向变量a。也就是把向量a的内存地址记录在指针p中。请注意在这边使用了类似箭头&quot;=&gt;&quot;的符号来作指针的指向设置，而不是使用等号。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p=&gt;a</span><br></pre></td></tr></table></figure>
<p>指针设置后内存指向位置后，就可以把它当成一般变量来使用。程序会自动取出指针中所记录的内存地址，再对这个内存地址来做读写。第6行输出指针p时，内容为1，正是变量a这个时候的值。</p>
<p>程序第7行把变量a的值重新设置为2，第8行再试着输出指针p的内容，理所当然地可以发现这个时候输出的值为2。使用指针p，就等于使用变量a。</p>
<p>程序第9行会把指针p所指向的内存中的数值设置为3，也就等于把变量a设置成3。</p>
<p>这个程序很简单地示例了指针的使用方法，只要把指针赋值到一个目标变量上，使用指针与使用这个变量会变成没有差别，这是第1种使用方法。下面来看看第2种使用方法，动态配置内存。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex1002</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p <span class="comment">!声明一个可以指向整数的指针</span></span><br><span class="line">    <span class="built_in">allocate</span>(p) <span class="comment">!配置一块可以存放integer 的内存空间给指针p</span></span><br><span class="line">    p=<span class="number">100</span> <span class="comment">!得到内存后指针p可以像一般整数一样来使用</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) p</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure>
<p>这个程序示范了第2种使用指针的方法。函数 allocate 在第7章中曾经介绍过，那个时候是用来配置内存空间给可变大小的矩阵使用，它也可以用来配置一块内存空间给指针使用。程序第4行会把配置到的内存地址存放在指针p中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allocate(p) </span><br></pre></td></tr></table></figure>
<p>如果指针指向变量，指针可以随时重新设置它的指向。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">target</span> :: a = <span class="number">1</span>, b = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p</span><br><span class="line">p=&gt;a <span class="comment">!把p指向a</span></span><br><span class="line"><span class="built_in">write</span>(*,*) p <span class="comment">!会输出1</span></span><br><span class="line">p=&gt;b <span class="comment">!把p指向b</span></span><br><span class="line"><span class="built_in">write</span>(*,*) p <span class="comment">!会输出2</span></span><br></pre></td></tr></table></figure>
<p>不过如果指针中所指向的通过 allocate 所配置的内存，重新改变指向前要对这个内存地址做一些处理，看是把它交给其他指针，或是把内存空间经过 deallocate 释放都行，不然会在计算机中形成一块已经配置、却被丢弃的内存。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">target</span> :: a=<span class="number">1</span>, b=<span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p</span><br><span class="line"><span class="built_in">allocate</span>(p) <span class="comment">!配置内存</span></span><br><span class="line">p=<span class="number">1</span></span><br><span class="line"><span class="built_in">write</span>(*,*) p</span><br><span class="line"><span class="built_in">deallocate</span>(p) <span class="comment">!释放内存</span></span><br><span class="line">p=&gt;a <span class="comment">!再改变指针p的指向</span></span><br></pre></td></tr></table></figure>
<p>上面这段代码中，如果指针在指向变量a之前，没有先把配置得到的内存释放回去，那这块内存空间会变得无人认领。经过函数allocate 得到的内存空间，再经过 dellocate 释放回去，或是程序结束之前，操作系统仍然会认定这块空间是安排给这个程序使用的。如果不先 deallocate，就重新设置指针p的指向，会导致内存空间白白浪费。</p>
<p>使用指针之前，一定要先设置好指针的目标。不然在程序执行时，会发生意想不到的情况。因为使用指针是使用它所记录的内存地址。还没设置指向的指针，不会知道哪里有内存可以使用。在这个时候使用指针，会出现内存使用错误的信息。在 windows 系统下可能会显示一堆内存地址，显示内存读写不正常的信息，然后中断程序。在 Unix 系统下可能会出现 Segmentation fault 的错误信息。</p>
<p>Fortran 提供 associated 函数，用来检查指针是否已经设置指向。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">associated</span>(<span class="keyword">pointer</span>,[<span class="keyword">target</span>])</span><br><span class="line">检查指针是否设置指向，返回值为布尔变量。如果只放入第<span class="number">1</span>个指针参数，会检查这个指针是否已经赋值好”方向“。</span><br><span class="line">如果放入<span class="number">2</span>个变量，则会检查第<span class="number">1</span>个指针变量是否指向第<span class="number">2</span>个变量。</span><br></pre></td></tr></table></figure>
<p>一般来说，判断指针有没有赋值好方向，是检查它的指向是否指到了不可能拿来使用的内存地址。函数 null() 会返回一个不能使用的内存地址，它可以用来把指针初值指向一个不能使用的内存地址，确保 associated 函数可以正确判断出这个指针还没有给定指向</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p =&gt; null() <span class="comment">!把指针初值指向一个不能使用的内存地址</span></span><br></pre></td></tr></table></figure>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NUll()</span><br><span class="line">Fortran <span class="number">95</span> 添加的函数。会返回一个不能使用的内存地址，在指针还没有指向前设置成这个值，</span><br><span class="line">可以让<span class="built_in">associated</span> 函数判断不会出错。</span><br></pre></td></tr></table></figure>
<p>除了函数NULL 之外，还可以使用 nullify 命令来把指针设置成不能使用的内存地址。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nullify</span>(pointer1,[pointer2,...])</span><br><span class="line">用来将指针设置成还没有指向任何内存地址。Fortran <span class="number">90</span> 只能使用 <span class="built_in">nullify</span> 而不能使用 null 函数来设置指针</span><br></pre></td></tr></table></figure>
<p>来看一个实验性质的程序：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex1003</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: a=&gt;null()</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">target</span> :: b=<span class="number">1</span>,c=<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="built_in">associated</span>(a) <span class="comment">!false，指针a尚未赋值</span></span><br><span class="line">    a=&gt;c</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="built_in">associated</span>(a) <span class="comment">!true，指针a已赋值</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="built_in">associated</span>(a,c) <span class="comment">!true，指针a指向c</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="built_in">associated</span>(a,b) <span class="comment">!false，指针a不指向b</span></span><br><span class="line">    <span class="built_in">nullify</span>(a) <span class="comment">!把指针a设为没有指向</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="built_in">associated</span>(a) <span class="comment">!false，指针a尚未赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">F</span><br><span class="line">T</span><br><span class="line">T</span><br><span class="line">F</span><br><span class="line">F</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>指针可以声明成任何数据类型，甚至是使用 type 来自定义的数据类型。有一个概念很重要，那就是不管指针是用来指向哪一种数据类型，不论是integer, real, character, complex 或是自定义类型，每一种指针变量都占用相同的内存空间。因为指针变量实际上是用来记录内存地址，以现在的32位计算机来说，记录一个内存地址，固定需要使用32 bits = 4 bytes 的空间。</p>
<h2 id="10-2-指针数组">10-2 指针数组</h2>
<p>指针也可以声明成数组，声明成数组的指针同样可以有两种使用方法：</p>
<ol>
<li>把指针指到其他数组。</li>
<li>配置内存空间来所用。</li>
</ol>
<p>先来看第一种使用方法：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex1004</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: a(:)</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">target</span> :: b(<span class="number">5</span>)  = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /)</span><br><span class="line">    <span class="comment">!把指针数组a指向数组b</span></span><br><span class="line">    a=&gt;b</span><br><span class="line">    <span class="comment">!a(1~5) =&gt; b(1~5)</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    a=&gt;b(<span class="number">1</span>:<span class="number">3</span>)</span><br><span class="line">    <span class="comment">!a(1)=&gt;b(1),a(2)=&gt;b(2),a(3)=&gt;b(3)</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    a =&gt; b(<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>)</span><br><span class="line">    <span class="comment">!a(1)=&gt;b(1),a(3)=&gt;b(3),a(5)=&gt;b(5)</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    a =&gt; b(<span class="number">5</span>:<span class="number">1</span>:-<span class="number">1</span>)</span><br><span class="line">    <span class="comment">!a(1)=&gt;b(5),a(2)=&gt;b(4),a(3)=&gt;b(3),a(4)=&gt;b(2),a(5)=&gt;b(1)</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1           2           3           4           5</span><br><span class="line">1           2           3</span><br><span class="line">1           3           5</span><br><span class="line">5           4           3           2           1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序实例是指针数组的第一种使用方法，指针数组在声明时只需要说明它的维数就行了，不需要说明它的大小。这一点类似可变大小数组。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">pointer</span> :: a(:) <span class="comment">!声明一维的指针数组</span></span><br></pre></td></tr></table></figure>
<p>被当成目标给指针使用的数组，在声明时同样要加上 target 这个形容词。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">target</span> :: b(<span class="number">5</span>) = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /) <span class="comment">!这个数组可以给指针使用</span></span><br></pre></td></tr></table></figure>
<p>把指针数组指向一个数组可以有很多设置方法，最简单的方法就是直接指过去，就像程序中第6行的做法一样。这种做法会让指针a成为数组b的分身，使用指针a就跟使用数组b完全一样。输出结果的第1行可以证明指针数组a所指到的内容与数组b是完全相同的。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=&gt;b</span><br></pre></td></tr></table></figure>
<p>指针数组可以只选择目标数组中的一小部分来使用，第9行只取出数组b中的前3个变量来使用。这个时候指针数组a的大小为3，使用a等于使用b的前3个变量。输出结果的第2行可以证明这个事实。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=&gt;b(<span class="number">1</span>:<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>除了可以把指针数组拿来指向某个目标数组之外，还可以使用 allocate 来分配一块内存来给它使用，所以指针数组也可以拿来当作可变大小的数组使用。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex1005</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: a(:) <span class="comment">!定义a是一维的指针数组</span></span><br><span class="line">    <span class="built_in">allocate</span>(a(<span class="number">5</span>)) <span class="comment">!配置5个整数的空间给指针a</span></span><br><span class="line">    a = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /)</span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    <span class="built_in">deallocate</span>(a) <span class="comment">!allocate 得到的内存要记得归还</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1           2           3           4           5</span><br></pre></td></tr></table></figure>
<p>在这边还是要提醒一点，allocate 得到的内存，在不需要使用时，要记得用 deallocate 释放回去。</p>
<p>看完了一维指针数组的例子，现在来看看多维指针数组的使用方法：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex1006</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: a(:,:) <span class="comment">!定义a是二维的指针数组</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">target</span> :: b(<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">integer</span> i</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">3</span>)</span><br><span class="line">        b(:,i,<span class="number">1</span>) = i</span><br><span class="line">        b(:,i,<span class="number">2</span>) = <span class="number">2</span>*i</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line">    </span><br><span class="line">    a =&gt; b(:,:,<span class="number">1</span>)</span><br><span class="line">    <span class="comment">! a(i,j) =&gt; b(i,j,1)</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(9i2)&quot;</span>) a</span><br><span class="line">    a =&gt; b(<span class="number">1</span>:<span class="number">3</span>:<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="comment">! a(1,1)=&gt;b(1,1,2), a(2,1)=&gt;b(3,1,2)</span></span><br><span class="line">    <span class="comment">! a(1,2)=&gt;b(1,2,2), a(2,1)=&gt;b(3,2,2)</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(4i2)&quot;</span>) a</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 1 1 2 2 2 3 3 3</span><br><span class="line">2 2 4 4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在程序中需要常常使用数组的一小部分时，声明一个指针来使用这一部分的数组，使用起来会比较方便。</p>
<p>最后说明一个概念，既然指针也可以拿来作为可变大小的数组，那它和第7章中介绍的可变大小数组有什么不同？</p>
<p>声明成 allocatable 的 数组有它的生存周期，它只存在于声明它的函数中，函数结束后数组会自动 deallocate 释放内存空间。如果声明成指针，在函数结束时，不会自动去 deallocate 指针所指到的内存，在程序进行中要程序员自行使用 deallocate 才会释放内存。不然要等到程序结束，让操作系统来回收这一块内存。</p>
<h2 id="10-3-指针与函数">10-3 指针与函数</h2>
<p>指针变量一样可以作为参数在函数之间传递，也可以作为函数的返回值。使用时有下面几种策略：</p>
<ol>
<li>要把指针传递给函数时，要声明这个函数的参数使用接口 interface</li>
<li>指针参数声明时不需要 intent 这个形容词</li>
<li>函数返回值若为指针时，需要定义函数的 interface</li>
</ol>
<p>来看一个实例</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex1007</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">target</span> :: a(<span class="number">8</span>) = (/ <span class="number">10</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">25</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">17</span>, <span class="number">19</span> /)</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p(:)</span><br><span class="line">    <span class="keyword">interface</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span></span> GetMin(p)</span><br><span class="line">            <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p(:)</span><br><span class="line">            <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: getmin</span><br><span class="line">        <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    </span><br><span class="line">    p =&gt; a(<span class="number">1</span>:<span class="number">8</span>:<span class="number">2</span>)</span><br><span class="line">    <span class="comment">! p(1) =&gt; a(1), p(2) =&gt; a(3), p(3) =&gt; a(5), p(4) =&gt; a(7)</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) GetMin(p)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span></span> GetMin(p)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p(:)</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: GetMin</span><br><span class="line">    <span class="keyword">integer</span> i,s</span><br><span class="line">    <span class="keyword">integer</span> <span class="built_in">min</span></span><br><span class="line">    </span><br><span class="line">    s=<span class="built_in">size</span>(p,<span class="number">1</span>) <span class="comment">!查询数组的大小</span></span><br><span class="line">    <span class="built_in">min</span> = <span class="number">2</span>**<span class="number">30</span> <span class="comment">!先把min设置为一个很大的值</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,s</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">min</span>&gt;p(i)) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">min</span>=p(i)</span><br><span class="line">            GetMin=&gt;p(i)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<p>这个程序示例了传递指针给函数，以及从函数中返回指针的方法。函数 GetMin 会把输入的数组值中，最小的数值找出来。函数 GetMin 的参数类型及返回值都是指针，所以在调用前要说明它的使用接口 interface 。没有编写 interface 时，编译过程当中并不一定会出现错误信息，不过在程序执行时会不正确，参数不会正确地传递出去。</p>
<p>程序第12行先设置指针 p 的指向，它指到数组 a中的一部分，再把指针 p 当成参数传给函数 GetMin 使用。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p =&gt; a(<span class="number">1</span>:<span class="number">8</span>:<span class="number">2</span>)</span><br><span class="line"><span class="comment">! p(1) =&gt; a(1), p(2) =&gt; a(3), p(3) =&gt; a(5), p(4) =&gt; a(7)</span></span><br></pre></td></tr></table></figure>
<p>找到最小值的地方，是使用循环来一个一个检查数组中的数值。min 变量在进入循环前先设置成一个很大的数值，在数组中发现比它小的数值时，就重新设置 min 的值。循环执行完后，min 值就会是数组中最小的数值。</p>
<p>编写 interface 是一件麻烦的工作，不过如果函数是封装在 module 中，就等于已经编写好使用接口。来看看这个程序写成 module 的版本。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> func</span><br><span class="line"></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line"><span class="function"><span class="keyword">function</span></span> GetMin(p)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p(:)</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: GetMin</span><br><span class="line">    <span class="keyword">integer</span> i,s</span><br><span class="line">    <span class="keyword">integer</span> <span class="built_in">min</span></span><br><span class="line">    </span><br><span class="line">    s=<span class="built_in">size</span>(p,<span class="number">1</span>) <span class="comment">!查询数组的大小</span></span><br><span class="line">    <span class="built_in">min</span> = <span class="number">2</span>**<span class="number">30</span> <span class="comment">!先把min设置为一个很大的值</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,s</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">min</span>&gt;p(i)) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">min</span>=p(i)</span><br><span class="line">            GetMin=&gt;p(i)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1008</span><br><span class="line">    <span class="keyword">use</span> func</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">target</span> :: a(<span class="number">8</span>) = (/ <span class="number">10</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">25</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">17</span>, <span class="number">19</span> /)</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p(:)</span><br><span class="line">    </span><br><span class="line">    p =&gt; a(<span class="number">1</span>:<span class="number">8</span>:<span class="number">2</span>)</span><br><span class="line">    <span class="comment">! p(1) =&gt; a(1), p(2) =&gt; a(3), p(3) =&gt; a(5), p(4) =&gt; a(7)</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) GetMin(p)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="10-4-基本的指针应用">10-4 基本的指针应用</h2>
<p>读者看过上一节对指针使用的介绍后，大概还是会对指针存在的必要性感到怀疑。究竟这种”间接读写数据“的数据类型有什么作用？</p>
<p>方便使用高维数组中的某一部分元素。</p>
<p>不管指针是用来指向什么类型，它都占用相同的内存空间（在PC上为 4 bytes）。指向自定义类型时，指针可以很快速地交换数据。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">target</span> :: a(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">pointer</span> :: b</span><br><span class="line">b =&gt; a(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">!假如经常要使用 a(2,2,2)的值，就可以通过指针来使用它，程序代码中只要用b就可以代替a(2,2,2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">target</span> :: matrix(<span class="number">100</span>,<span class="number">100</span>)</span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p(:,:)</span><br><span class="line">p =&gt; matrix(<span class="number">10</span>:<span class="number">20</span>,<span class="number">10</span>:<span class="number">20</span>)</span><br><span class="line"><span class="comment">!用这个方法就可以把100×100的矩阵中里面的一块10×10矩阵拿出来使用。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person</span><br><span class="line">	<span class="keyword">character</span>(len=<span class="number">20</span>) <span class="keyword">name</span></span><br><span class="line">	<span class="keyword">real</span> :: weight, height</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!一个type(person)类型至少占用28 bytes</span></span><br><span class="line"><span class="comment">!因为它里面有20个字符及2个浮点数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>(person) :: a,b,temp</span><br><span class="line"><span class="comment">!指向 type(person) 的指针，在PC中每个变量只占4 bytes</span></span><br><span class="line"><span class="keyword">type</span>(person), <span class="keyword">pointer</span> :: pa,pb,pt</span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"><span class="comment">!要交换 type(person) 类型时，最少需要移动 28*3=84 bytes 的空间</span></span><br><span class="line">temp = a</span><br><span class="line">a = b</span><br><span class="line">b = temp</span><br><span class="line"></span><br><span class="line">pa=&gt;a</span><br><span class="line">pb=&gt;b</span><br><span class="line"><span class="comment">!如果拿指针来交换，以PC来说，只需要移动 4*3=12 bytes 的空间</span></span><br><span class="line">pt =&gt; pa</span><br><span class="line">pa =&gt; pb</span><br><span class="line">pb =&gt; pt</span><br></pre></td></tr></table></figure>
<p>来看一个以自定义类型数据来做排序的实例，排序程序常常会需要把两条数据交换，如果不使用指针，交换数据时需要移动很大块的内存空间。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> func</span><br><span class="line"><span class="comment">! person类型至少占用18 bytes</span></span><br><span class="line"><span class="comment">! 因为它有10个字符及2个浮点数</span></span><br><span class="line"><span class="keyword">type</span> person</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">10</span>) :: <span class="keyword">name</span></span><br><span class="line">    <span class="keyword">real</span> :: height, weight</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="comment">! pperson 类型通常占用 4 bytes </span></span><br><span class="line"><span class="comment">! 因为它里面只有一个指针，指针在PC中固定使用 4 bytes</span></span><br><span class="line"><span class="keyword">type</span> pperson</span><br><span class="line">    <span class="keyword">type</span>(person), <span class="keyword">pointer</span> :: p</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sort(p)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(pperson) :: p(:)</span><br><span class="line">    <span class="keyword">type</span>(pperson) :: temp</span><br><span class="line">    <span class="keyword">integer</span> i,j,s</span><br><span class="line">    </span><br><span class="line">    s = <span class="built_in">size</span>(p,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,s-<span class="number">1</span></span><br><span class="line">        <span class="keyword">do</span> j=i+<span class="number">1</span>, s</span><br><span class="line">            <span class="keyword">if</span>(p(j)%p%height &lt; p(i)%p%height) <span class="keyword">then</span></span><br><span class="line">                temp = p(i)</span><br><span class="line">                p(i) = p(j)</span><br><span class="line">                p(j) = temp</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1008</span><br><span class="line">    <span class="keyword">use</span> func</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(person), <span class="keyword">target</span> :: p(<span class="number">5</span>)=(/ person(<span class="string">&quot;陈同学&quot;</span>, <span class="number">180.0</span>, <span class="number">75.0</span>), &amp;</span><br><span class="line">                                person(<span class="string">&quot;黄同学&quot;</span>, <span class="number">170.0</span>,<span class="number">65.0</span>), &amp;</span><br><span class="line">                                person(<span class="string">&quot;刘同学&quot;</span>, <span class="number">175.0</span>,<span class="number">80.0</span>), &amp;</span><br><span class="line">                                person(<span class="string">&quot;蔡同学&quot;</span>, <span class="number">182.0</span>,<span class="number">78.0</span>), &amp;</span><br><span class="line">                                person(<span class="string">&quot;许同学&quot;</span>, <span class="number">178.0</span>,<span class="number">70.0</span>)&amp;</span><br><span class="line">                                                                /)</span><br><span class="line">    <span class="keyword">type</span>(pperson) :: pt(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">integer</span> i</span><br><span class="line">    <span class="comment">! 把pt数组中的指针全部指向数组p</span></span><br><span class="line">    <span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">        pt(i)%p =&gt; p(i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line">    <span class="comment">! 按照身高从小到大排序</span></span><br><span class="line">    <span class="keyword">call</span> sort(pt)</span><br><span class="line">    <span class="comment">! 输出排序的结果</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(5(a10,f6.1,f5.1/))&quot;</span>) (pt(i)%p, i=<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line">    <span class="comment">! 这里书上是 a8, 应该改成 a10，不然输出不完整</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果如下</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">黄同学  <span class="number">170.0</span> <span class="number">65.0</span></span><br><span class="line">刘同学  <span class="number">175.0</span> <span class="number">80.0</span></span><br><span class="line">许同学  <span class="number">178.0</span> <span class="number">70.0</span></span><br><span class="line">陈同学  <span class="number">180.0</span> <span class="number">75.0</span></span><br><span class="line">蔡同学  <span class="number">182.0</span> <span class="number">78.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行过程中发现了一个现象，书上输出语句上是 a8 (字符串指定为8个字符)，而 person 自定义类型声明的时候字符长度是10，导致<strong>字符输出不完整</strong>。如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">黄同▒ 170.0 65.0</span><br><span class="line">刘同▒ 175.0 80.0</span><br><span class="line">许同▒ 178.0 70.0</span><br><span class="line">陈同▒ 180.0 75.0</span><br><span class="line">蔡同▒ 182.0 78.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里程序中使用了两个自定义类型 person 及 pperson 。person 类型可以用来记录人名、身高、体重等数据，pperson 类型中只有一个指向 person 类型的指针。数组p是 type(person) 类型，声明时同时设置了它的初值，数组 pt 则是 type(pperson) 类型。数组 p 最少会使用 28×5=140 bytes 的内存空间，而数组 pt 在目前的 PC 中只需要使用 4×5=20 bytes 的内存空间。</p>
<p>程序第49~51 行用来把数组 pt 中的指针指到数组 p 中。请注意 pt(i) 并不是指针，它是 type(pperson) 类型的变量，数组中的 pt(i)%p 元素才是指针。设置好指针之后，使用  pt(i)%p 就等于使用 pt(i)%p 就等于使用 p(i).</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">! 把pt数组中的指针全部指向数组p</span></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">    pt(i)%p =&gt; p(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br></pre></td></tr></table></figure>
<p>函数 sort 使用的算法是第7章介绍过的选择排序法，他会根据每个人的身高信息来排序。这个程序中，排序程序在做数据交换时只需要交换两条数据的内存地址，不需要去移动两条数据的内存。当自定义数据中的数据量很大时，执行效率可以有明显地提升。</p>
<h2 id="10-5-指针的高级应用">10-5 指针的高级应用</h2>
<p>指针除了可以间接地使用变量，以及当成可变大小数组来使用之外，还有一个很重要的用途，它可以创建各种的”串行结构“ 以及 ” 树状结构“ 等等。</p>
<p>使用指针来创建 ”串行结构“ 可以有很多应用，其中最重要的一项应用是用来动态使用内存。在写程序时常常会遇到无法事先估计数据数目的情况，这个问题最传统的解决方法，是声明一个”超级巨大“的数据来保存数据。而所声明的数组，在使用时大部分的空间都是闲置的。要是空间不够时，那就麻烦大了，所以一开始就尽可能地把数组加大。</p>
<p>使用”串行结构“来解决这一类的问题时，可以配合需要向内存要求刚好的空间。只有一条数据时就要求一条数据的空间，有一千条数据时，就要求一千条数据的空间。这个方法可以非常有效率地来使用内存。</p>
<h3 id="10-5-1-单向串行">10-5-1 单向串行</h3>
<p>如何节省内存，在程序设计中一直是非常重要的课题。很早的时候，节省内存是屈就于现实，因为当时计算机的内存容量都很小，所以程序一定要短小精干才行。虽然现在内存越来越便宜，内存越来越大，节省内存仍然有其必要的价值。<strong>因为无论计算机配备多少的内存，都永远无法满足贪得无厌的人类。</strong></p>
<p>现代的操作系统都号称是”多任务“的操作系统，所谓多任务的操作系统，是指计算机可以同时执行多个程序。而能够执行几个程序就取决于计算机的内存大小，以及程序所占据的内存空间。所以，如果单个程序所占用的内存越少，就可以同时执行更多的程序，或是在执行程序时得到更高的效率。</p>
<p>前面已经介绍过可变大小数组，这个功能已经可以有效率地使用内存。这个做法虽然已经有相当程度的灵活性，但是在某些情况之下仍然不足。要是数组声明好大小以后，却发现不够用了，那该怎么办？先 deallocate 再重新 allocate 吗？ 那原来在数组中已经存放的数据要怎么办？必须另外找地方把它们先保存起来，不然 deallocate 时数据会流失。</p>
<p>还有就是如果想要在数组中 ”插入“ 一个数值，必须要把数组中的数据一个个向后移动。这个方法的执行效率很差，需要做很多次的内存移动。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> j=i+<span class="number">1</span>, size_of_A-<span class="number">1</span></span><br><span class="line">	A(j)=A(j-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">A(i)=n</span><br><span class="line"><span class="comment">!要在数组A(I)插入数值时，必须使用类似上面的方法</span></span><br><span class="line"><span class="comment">!数组A(I)后面的元素必须先一个一个向后移动，再把数值插入A(I)</span></span><br></pre></td></tr></table></figure>
<p>串行结构可以解决这些问题，来看一个最简单的单行串行结构：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef </span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> :: datalink</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1010</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">target</span> :: node1,node2,node3</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    </span><br><span class="line">    node1%i=<span class="number">1</span></span><br><span class="line">    node1%next =&gt; node2</span><br><span class="line">    node2%i=<span class="number">2</span></span><br><span class="line">    node2%next =&gt; node3</span><br><span class="line">    node3%i=<span class="number">3</span></span><br><span class="line">    <span class="built_in">nullify</span>(node3%next)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) node1%i</span><br><span class="line">    <span class="built_in">write</span>(*,*) node1%next%i</span><br><span class="line">    <span class="built_in">write</span>(*,*) node1%next%next%i</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> 2</span><br><span class="line"> 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序在 module typedef 中定义了一个自定义类型 datalink 。这个类型最少占用 8 bytes，因为它里面有一个整数及一个指针。指针 next 还没设置指向谁，是不能使用的。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> :: datalink</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span></span><br></pre></td></tr></table></figure>
<p>读者可能觉得第5行的声明在逻辑上有点奇怪。在这边只要把握一个策略，指针是用来记录内存地址，所以事实上任何类型指针所记录的内容都一样。声明指针时，它的类型只是用来说明指针所记录的内存地址，存放的是什么东西。（这句话是不是所指针的数据类型只是给人看的，电脑并不在乎）</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next</span><br><span class="line"><span class="comment">!在type datalink 声明中，又出现一个 type(datalink)的类型。在这里是合理的，因为变量 next</span></span><br><span class="line"><span class="comment">!是指针，在这儿就不合理。</span></span><br></pre></td></tr></table></figure>
<p>如果 type(datalink) 可以声明成下面的类型，会出现一个问题，那就是这个类型所声明出来的变量 d，所占用的内存空间无法计算。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> :: datalink</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="keyword">type</span>(datalink) :: next <span class="comment">! 错误的声明</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span></span><br></pre></td></tr></table></figure>
<p>如果上面的程序代码是合理的，那变量 d 中可以使用的元素有无限多个，因为按照语法，下面这些变量应该都可以使用。这会导致不管多少内存都不够给变量 d 使用。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d%i</span><br><span class="line">d%next%i</span><br><span class="line">d%next%next%i</span><br><span class="line">d%next%next%next%i</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>把 next 设置成指针就没有这个问题。因为 next 指针本身并不会记录 type(datalink) 类型的内容，它只记录在内存中哪里有 type(datalink) 类型的数据可以使用。在 next 还没设置方向之前，d%next%i 是不存在的。</p>
<p>程序的第15~20行在从事串行的创建。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">node1%i=<span class="number">1</span></span><br><span class="line">node1%next =&gt; node2</span><br><span class="line">node2%i=<span class="number">2</span></span><br><span class="line">node2%next =&gt; node3</span><br><span class="line">node3%i=<span class="number">3</span></span><br><span class="line"><span class="built_in">nullify</span>(node3%next)</span><br></pre></td></tr></table></figure>
<p>串行创建好了之后，可以出现很有趣的使用方法，来看看程序第22~24行的内容：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write</span>(*,*) node1%i</span><br><span class="line"><span class="built_in">write</span>(*,*) node1%next%i</span><br><span class="line"><span class="built_in">write</span>(*,*) node1%next%next%i</span><br></pre></td></tr></table></figure>
<p>程序第16行做了 node1%next =&gt; node2 的设置，所以现在可以使用 node1%next, 使用它就等于使用 node2。第23行使用 node1%next%i，就等于在使用 node2%i</p>
<p>……</p>
<p>程序第20行做了 nullify(node3%next)，这个命令会确保 node3%next 不能使用，也就是所 node1%next%next%next 是不能使用的。</p>
<p>用循环来改写这个程序，看起来会更有趣。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef </span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> :: datalink</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1010</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">target</span> :: node1,node2,node3</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: p</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    </span><br><span class="line">    p=&gt;node1</span><br><span class="line">    node1%i=<span class="number">1</span></span><br><span class="line">    node1%next =&gt; node2</span><br><span class="line">    node2%i=<span class="number">2</span></span><br><span class="line">    node2%next =&gt; node3</span><br><span class="line">    node3%i=<span class="number">3</span></span><br><span class="line">    <span class="built_in">nullify</span>(node3%next)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*,*) p%i</span><br><span class="line">        <span class="keyword">if</span>(.not. <span class="built_in">associated</span>(p%next)) <span class="keyword">exit</span></span><br><span class="line">        p =&gt; p%next <span class="comment">! 把p向后移动，从node(n)移到node(n+1)</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>这个程序和改写前的 ex1011.f90 大同小异，只多使用了一个指针 p。另外在输出串行时，改用循环来输出。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">    <span class="built_in">write</span>(*,*) p%i</span><br><span class="line">    <span class="keyword">if</span>(.not. <span class="built_in">associated</span>(p%next)) <span class="keyword">exit</span></span><br><span class="line">    p =&gt; p%next <span class="comment">! 把p向后移动，从node(n)移到node(n+1)</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>来看看这一段程序为什么可以这样做。因为 p 在一开始做了 p=&gt;node1 的设置，所以刚开始进入循环时，使用p等于使用 node1。</p>
<p>循环中会输出 p%i 的内容，再检查 p%next 有没有设置。如果有设置，就重新设置指针 p 的指向，把它指向 p%next 。如果没设置，就离开循环。</p>
<p>事实上，真正的串行是不会使用本程序的方法来创建的，本程序只是用来给读者一个基础的概念。下面的实例程序才是典型的创建串行方法：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> :: datalink</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1012</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: p, head</span><br><span class="line">    <span class="keyword">integer</span> :: i,n,err</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;Input N:&#x27;</span></span><br><span class="line">    read(*,*) n</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">allocate</span>(head)</span><br><span class="line">    head%i = <span class="number">1</span></span><br><span class="line">    <span class="built_in">nullify</span>(head%next)</span><br><span class="line">    </span><br><span class="line">    p=&gt;head</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">2</span>,n</span><br><span class="line">        <span class="built_in">allocate</span>(p%next, stat=err)</span><br><span class="line">        <span class="keyword">if</span>(err /= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&#x27;Out of memory!&#x27;</span></span><br><span class="line">            <span class="keyword">stop</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        p=&gt;p%next</span><br><span class="line">        p%i=i</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">nullify</span>(p%next)</span><br><span class="line">    </span><br><span class="line">    p=&gt;head</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(i5)&quot;</span>) p%i</span><br><span class="line">        <span class="keyword">if</span>(.not. <span class="built_in">associated</span>(p%next)) <span class="keyword">exit</span></span><br><span class="line">        p =&gt; p%next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> Input N:</span><br><span class="line">5</span><br><span class="line">    1</span><br><span class="line">    2</span><br><span class="line">    3</span><br><span class="line">    4</span><br><span class="line">    5</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序把实例 ex1011.f90 中创建串行的过程，由手动一个一个衔接起来，改成使用循环自动生成。用户可以输入任意长度，由循环来生成串行。</p>
<p>第12行中声明的指针 head 会用来作为串行的”头“，也就是串行的第一条数据。指针p则用来当临时保存变量，在串行中移动。</p>
<p>第18行会配置串行中第一行数据的内存空间，第19、20行则会设置第一行数据的内容。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">allocate</span>(head)</span><br><span class="line">head%i = <span class="number">1</span></span><br><span class="line"><span class="built_in">nullify</span>(head%next)</span><br></pre></td></tr></table></figure>
<p>第22~32 行是创建串行的程序代码，进入循环之前，先把指针p指到串行的头。在循环中会一节一节添加出每个串行，再把它接上去。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p=&gt;head</span><br><span class="line"><span class="keyword">do</span> i=<span class="number">2</span>,n</span><br><span class="line">    <span class="built_in">allocate</span>(p%next, stat=err)</span><br><span class="line">    <span class="keyword">if</span>(err /= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&#x27;Out of memory!&#x27;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    p=&gt;p%next</span><br><span class="line">    p%i=i</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">nullify</span>(p%next) <span class="comment">!出了循环，p就是串行的最后，要设置它后面没东西</span></span><br></pre></td></tr></table></figure>
<h3 id="10-5-2-双向串行、环状串行">10-5-2 双向串行、环状串行</h3>
<p>上一个小节所创建的串行结构，都只能沿着一个方向走。程序只能按照顺序，一条接着一条数据向下读取，没有办法往回走。需要往回走时，要使用双向串行。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> :: datalink</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: prev <span class="comment">!指向上一条数据</span></span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next <span class="comment">!指向下一条数据</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1013</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">target</span> :: node1,node2,node3</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: p</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    </span><br><span class="line">    node1 = datalink(<span class="number">1</span>, null(), node2)</span><br><span class="line">    node2 = datalink(<span class="number">2</span>, node1, node3)</span><br><span class="line">    node3 = datalink(<span class="number">3</span>, node2, null())</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;照顺序输出&quot;</span></span><br><span class="line">    p=&gt;node1</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*,*) p%i</span><br><span class="line">        <span class="keyword">if</span>(.not. <span class="built_in">associated</span>(p%next)) <span class="keyword">exit</span></span><br><span class="line">        p=&gt;p%next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;反过来输出&quot;</span></span><br><span class="line">    p=&gt;node3</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*,*) p%i</span><br><span class="line">        <span class="keyword">if</span>(.not. <span class="built_in">associated</span>(p%prev)) <span class="keyword">exit</span></span><br><span class="line">        p=p%prev</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">照顺序输出</span><br><span class="line">          1</span><br><span class="line">          2</span><br><span class="line">          3</span><br><span class="line">反过来输出</span><br><span class="line">          3</span><br><span class="line">          2</span><br><span class="line">          1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序把前面使用过的自定义类型 datalink 做了一点修改，增加了 prev 这个指针用来指向上一条数据。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> :: datalink</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: prev <span class="comment">!指向上一条数据</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next <span class="comment">!指向下一条数据</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span></span><br></pre></td></tr></table></figure>
<p>创建双向串行的时候，要赋值清楚上一条数据和下一条数据的位置。程序的第17-19行会创建下面的信息。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node1 = datalink(<span class="number">1</span>, null(), node2)</span><br><span class="line">node2 = datalink(<span class="number">2</span>, node1, node3)</span><br><span class="line">node3 = datalink(<span class="number">3</span>, node2, null())</span><br></pre></td></tr></table></figure>
<p>在这里使用另一种语法来设置数据，程序第17行命令的效果，和下面三行代码相同。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node1%i = <span class="number">1</span></span><br><span class="line">node1%prev =&gt; null()</span><br><span class="line">node1%next =&gt; node2</span><br></pre></td></tr></table></figure>
<p>这个程序会使用两种方法来输出串行数据，第1种方法和上一节的方法一样。不过这里由于使用了双向串行，既可以从前向后输出，也可以从后向前输出。</p>
<p>这个实例程序使用手动方法创建串行，实际应用时，应该都是使用自动创建串行的方式。</p>
<p>目前为止所介绍的串行结构都是有头有尾的结构，串行结构还有另外一种类型，叫做环状串行。环状串行简单地说，就是把串行的头跟尾接起来，变成一个圈圈。上一个实例程序中，只要把node1%prev 指向 node3, node3%next 指向 node1 就变成了环状串行。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> :: datalink</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: prev <span class="comment">!指向上一条数据</span></span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next <span class="comment">!指向下一条数据</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1014</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">target</span> :: node1,node2,node3</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: p</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: s=<span class="number">6</span></span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    </span><br><span class="line">    node1 = datalink(<span class="number">1</span>, node3, node2)</span><br><span class="line">    node2 = datalink(<span class="number">2</span>, node1, node3)</span><br><span class="line">    node3 = datalink(<span class="number">3</span>, node2, node1)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;照顺序输出&quot;</span></span><br><span class="line">    p=&gt;node1</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,s</span><br><span class="line">        <span class="built_in">write</span>(*,*) p%i</span><br><span class="line">        <span class="keyword">if</span>(.not. <span class="built_in">associated</span>(p%next)) <span class="keyword">exit</span></span><br><span class="line">        p=&gt;p%next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;反过来输出&quot;</span></span><br><span class="line">    p=&gt;node3</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,s</span><br><span class="line">        <span class="built_in">write</span>(*,*) p%i</span><br><span class="line">        <span class="keyword">if</span>(.not. <span class="built_in">associated</span>(p%prev)) <span class="keyword">exit</span></span><br><span class="line">        p=p%prev</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">照顺序输出</span><br><span class="line">          1</span><br><span class="line">          2</span><br><span class="line">          3</span><br><span class="line">          1</span><br><span class="line">          2</span><br><span class="line">          3</span><br><span class="line">反过来输出</span><br><span class="line">          3</span><br><span class="line">          2</span><br><span class="line">          1</span><br><span class="line">          1</span><br><span class="line">          1</span><br><span class="line">          1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>读者可以发现，在环状串行中，可以一直向后或是向前抓取数据，数据永远不会有结束的时候。</p>
<h3 id="10-5-3-插入及删除">10-5-3 插入及删除</h3>
<p>前面两个小节中介绍了创建串行的方法，不过关于串行的操作还有很多内容要学习。学会创建串行之后，还要学习在串行中插入数据及删除数据的方法。</p>
<p>使用串行的好处是，串行可以很快速地插入或删除一条数据。先来看看在数组中如果想在A(n) 中插入数据，要怎么做</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">!先把a(n)之后的数据都向后移动一个位置</span></span><br><span class="line"><span class="keyword">do</span> i=size_ofA, n,-<span class="number">1</span></span><br><span class="line">	A(I+<span class="number">1</span>) = A(I)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="comment">!再把需要插入的数值放入A(N)中</span></span><br><span class="line">A(n) = <span class="keyword">value</span></span><br></pre></td></tr></table></figure>
<p>当数组A的大小很大时，循环会执行很久。再来看看如果想把A(n)删除，要怎么做</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">!把a(n)之后的数据都向前移动一个位置</span></span><br><span class="line"><span class="keyword">do</span> i=n, size_of_A</span><br><span class="line">	A(i) = A(i+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>想要再数组中插入或删除数据，都非常麻烦，而且数组越大时会越没有效率。在串行中插入或删除数据就没有这个问题，不管这个串行总共有多长，都可以迅速地插入或删除数据。</p>
<p>下面是插入数据的方法：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">!添加一条数据来插入</span></span><br><span class="line"><span class="built_in">allocate</span>(item)</span><br><span class="line"><span class="comment">!把item插入到目前串行位置p的后面</span></span><br><span class="line">item%next =&gt; p%next</span><br><span class="line">item%prev =&gt; p</span><br><span class="line">p%next%prev =&gt; item </span><br><span class="line">p%next =&gt; item</span><br></pre></td></tr></table></figure>
<p>下面是删除数据的方法</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">!把串行目前位置指针p删除</span></span><br><span class="line">p%prev%next =&gt; p%next</span><br><span class="line">p%next%prev =&gt; p%prev</span><br><span class="line"><span class="built_in">deallocate</span>(p)</span><br></pre></td></tr></table></figure>
<p>下面是一个实际的实例程序，插入数据跟删除数据的程序代码，都独立写成两个函数：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> linklist</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> :: datalink</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: prev <span class="comment">! 指向上一条数据</span></span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next <span class="comment">! 指向下一条数据</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> OutputList(list)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: list,p</span><br><span class="line">    p=&gt;list</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(<span class="built_in">associated</span>(p))</span><br><span class="line">        <span class="built_in">write</span>(*,*) p%i</span><br><span class="line">        p =&gt; p%next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="comment">! 把指针所指到的串行位置释放</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> DelItem(item)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: item</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: prev, next</span><br><span class="line">    </span><br><span class="line">    prev =&gt; item%prev <span class="comment">! 记录item上一条数据的位置</span></span><br><span class="line">    next =&gt; item%next <span class="comment">! 记录item下一条数据的位置</span></span><br><span class="line">    <span class="built_in">deallocate</span>(item) <span class="comment">!释放item所占用内存</span></span><br><span class="line">    <span class="comment">!重新设置prev%next, 原本 prev%next=&gt;item, 不过item已经删除了</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">associated</span>(prev)) prev%next =&gt; next</span><br><span class="line">    <span class="comment">!重新设置next%prev, 原本 next%prev=&gt;item, 不过item已经删除了</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">associated</span>(next)) next%prev =&gt; prev</span><br><span class="line">    item =&gt; next</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="comment">! 在pos指针所指到的串行位置中插入 item</span></span><br><span class="line"><span class="comment">! after=.true. 时，item 插在 pos 之后</span></span><br><span class="line"><span class="comment">! after=.false. 时，item 插在 pos 之前</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> InsItem(pos,item, after)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: pos,item</span><br><span class="line">    <span class="keyword">logical</span> :: after</span><br><span class="line">    <span class="keyword">if</span>(after) <span class="keyword">then</span></span><br><span class="line">        <span class="comment">! item 插在 pos 的后面</span></span><br><span class="line">        item%next =&gt; pos%next</span><br><span class="line">        item%prev =&gt; pos</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">associated</span>(pos%next)) <span class="keyword">then</span></span><br><span class="line">            pos%next%prev =&gt; item</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        pos%prev =&gt; item</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1015</span><br><span class="line">    <span class="keyword">use</span> linklist</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: head</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: item, p</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: s=<span class="number">5</span></span><br><span class="line">    <span class="keyword">integer</span> :: i,n,error</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">allocate</span>(head)</span><br><span class="line">    head = datalink(<span class="number">1</span>, null(), null())</span><br><span class="line">    <span class="comment">!创建串行</span></span><br><span class="line">    p=&gt;head</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">2</span>,s</span><br><span class="line">        <span class="built_in">allocate</span>(p%next, stat=error)</span><br><span class="line">        <span class="keyword">if</span>(error /= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;Out of memory&quot;</span></span><br><span class="line">            <span class="keyword">stop</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        p%next = datalink(i,p,null())</span><br><span class="line">        p=&gt;p%next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;拿掉第3条数据&quot;</span></span><br><span class="line">    <span class="keyword">call</span> DelItem(head%next%next)</span><br><span class="line">    <span class="keyword">call</span> OutputList(head)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;插入新的第3条数据&quot;</span></span><br><span class="line">    <span class="built_in">allocate</span>(item)</span><br><span class="line">    item%i = <span class="number">30</span></span><br><span class="line">    <span class="keyword">call</span> InsItem(head%next, item, .true.)</span><br><span class="line">    <span class="keyword">call</span> OutputList(head)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">拿掉第3条数据</span><br><span class="line">          1</span><br><span class="line">          2</span><br><span class="line">          4</span><br><span class="line">          5</span><br><span class="line">插入新的第3条数据</span><br><span class="line">          1</span><br><span class="line">          2</span><br><span class="line">         30</span><br><span class="line">          4</span><br><span class="line">          5</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序的重点在 delitem 和 insitem 这两个子程序。delitem 用来删除串行中的一条数据，insitem 用来插入一条数据。先来看看如何删除数据：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">subroutine</span></span> DelItem(item)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: item</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: prev, next</span><br><span class="line">    </span><br><span class="line">    prev =&gt; item%prev <span class="comment">! 记录item上一条数据的位置</span></span><br><span class="line">    next =&gt; item%next <span class="comment">! 记录item下一条数据的位置</span></span><br><span class="line">    <span class="built_in">deallocate</span>(item) <span class="comment">!释放item所占用内存</span></span><br><span class="line">    <span class="comment">!重新设置prev%next, 原本 prev%next=&gt;item, 不过item已经删除了</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">associated</span>(prev)) prev%next =&gt; next</span><br><span class="line">    <span class="comment">!重新设置next%prev, 原本 next%prev=&gt;item, 不过item已经删除了</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">associated</span>(next)) next%prev =&gt; prev</span><br><span class="line">    item =&gt; next</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br></pre></td></tr></table></figure>
<p>删除数据时，要先记录一些必要的信息。释放item 指针所使用的内存之前，要把item 前后两条数据连接起来，不能让串行因为删除数据而从中间断掉。</p>
<p>数据删除后，还要重新连接串行。把原本 item 指针的上一条数据中的 next 指向原本在 item 中的下一行数据（第31行），还要把原来 item 的下一条数据中的 prev 指向原来在 item 中的上一条数据（第33行）</p>
<p>在重新链接时，要注意两点：</p>
<ol>
<li>如果要删除的 item 是串行中的第1条数据，那它就不会有上一条数据， prev%next 不存在，不需要重接</li>
<li>如果要删除的 item 是串行中的最后1条数据，那它就不会有下一条数据， next%prev 不存在，不需要重接</li>
</ol>
<p>所以，这里用到了 IF 判断。</p>
<p>再来看看插入数据的子程序 insitem 。它需要3个参数，pos 用来赋值数据要插入串行中的哪一个位置，item 是用来插入的数据，after 用来赋值 item 是要拿来插在指针 pos 的前面还是后面。</p>
<p>这个子程序允许用户把数据插入在赋值前面或是后面，所以插入数据的程序会分成两种情况处理。</p>
<p>先来看把数据插在后面的部分：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">item%next =&gt; pos%next</span><br><span class="line">item%prev =&gt; pos</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">associated</span>(pos%next)) <span class="keyword">then</span></span><br><span class="line">    pos%next%prev =&gt; item</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">pos%next =&gt; item</span><br></pre></td></tr></table></figure>
<p>先把新插入的 item 中的 next 及 prev 指针指好位置，再重新设置 pos 中 next 指针及原来在 pos 后面数据中 prev 指针的位置。这两个指针都要重新指向新插入的item。</p>
<p>另一种情况也类似。</p>
<p>这一节的实例程序示例了使用串行的方法，不过目前为止，经过 allocate 所得到的串行数据，在程序代码中都没有使用 deallocate 函数来释放。实际编写程序时最好不要省略这一步。下面列出一段可以释放整个串行的程序代码，只要把串行开头的指针输入，就可以释放整个串行所使用的内存。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">subroutine</span></span> deletelist(list)</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">	<span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: list, next</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">do</span> <span class="keyword">while</span>(<span class="built_in">associated</span>(list))</span><br><span class="line">		next =&gt; list%next</span><br><span class="line">		<span class="built_in">deallocate</span>(list)</span><br><span class="line">		list =&gt; next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br></pre></td></tr></table></figure>
<p>请记住只有通过 allocate 函数所配置到的内存才要使用 deallocate 来释放。所以用变量所创建出来的串行，就不需要，也不可以使用 deallocate 来释放内存。</p>
<h3 id="10-5-4-串行的应用">10-5-4 串行的应用</h3>
<p>串行比数组好用的地方，在于串行可以比较灵活地使用内存。使用串行时可以不用考虑这个串行需要记录多少条数据，反正串行可以很快速的增减数据。</p>
<p>来看一个读取文件的例子。假如我们事先不确定文件中会有多少数据，就不能使用数组来读取数据，因为不知道数组该声明成多大。一定要使用数组的话，就必须把数组设置成很大、一定够用的数量。这个方法会造成内存的浪费，因为很可能这个数组中，实际只用了很小的一部分。</p>
<p>光盘中 program\chap10\data1. txt 及 data2.txt 是两个班级的段考成绩单，两班的人数不同，请编写一个可以读取成绩的程序，让用户输入文件名来决定读取哪一个文件，还要提供给用户通过座号来查询成绩的功能。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> linklist</span><br><span class="line">    <span class="keyword">type</span> student</span><br><span class="line">        <span class="keyword">integer</span> :: num</span><br><span class="line">        <span class="keyword">integer</span> :: Chinese, English, Math, Science, Social</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">type</span> datalink</span><br><span class="line">        <span class="keyword">type</span>(student) :: item</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span></span> SearchList(num, head)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: num</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: head, p</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: SearchList</span><br><span class="line">        </span><br><span class="line">        p=&gt;head</span><br><span class="line">        <span class="built_in">nullify</span>(SearchList)</span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(<span class="built_in">associated</span>(p))</span><br><span class="line">            <span class="keyword">if</span>(p%item%num==num) <span class="keyword">then</span></span><br><span class="line">                SearchList =&gt; p</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">            p=&gt;p%next</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1016</span><br><span class="line">    <span class="keyword">use</span> linklist</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: filename</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) :: tempstr</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: head</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: p</span><br><span class="line">    <span class="keyword">integer</span> i,error,<span class="built_in">size</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;filename: &quot;</span></span><br><span class="line">    read(*,*) filename</span><br><span class="line">    open(<span class="number">10</span>, <span class="keyword">file</span>=filename, <span class="keyword">status</span>=<span class="string">&quot;old&quot;</span>, <span class="keyword">iostat</span>=error)</span><br><span class="line">    <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;Open file fail!&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">allocate</span>(head)</span><br><span class="line">    <span class="built_in">nullify</span>(head%next)</span><br><span class="line">    p=&gt;head</span><br><span class="line">    <span class="built_in">size</span>=<span class="number">0</span></span><br><span class="line">    read(<span class="number">10</span>, <span class="string">&quot;(a80)&quot;</span>) tempstr <span class="comment">!读入第一行字符串，不需要处理它</span></span><br><span class="line">    <span class="comment">! 读入每一位学生的成绩</span></span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        read(<span class="number">10</span>, <span class="keyword">fmt</span>=*, <span class="keyword">iostat</span>=error) p%item</span><br><span class="line">        <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        <span class="built_in">size</span> = <span class="built_in">size</span>+<span class="number">1</span></span><br><span class="line">        <span class="built_in">allocate</span>(p%next, stat=error) <span class="comment">! 添加下一条数据</span></span><br><span class="line">        <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;Out of memory&quot;</span></span><br><span class="line">            <span class="keyword">stop</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        p =&gt; p%next <span class="comment">!移动到串行的下一条数据</span></span><br><span class="line">        <span class="built_in">nullify</span>(p%next)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;总共有&#x27;,i3,&#x27;位学生&#x27;)&quot;</span>) <span class="built_in">size</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;要查询几号同学的成绩？&quot;</span></span><br><span class="line">        read(*,*) i</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">1</span> .or. i&gt;<span class="built_in">size</span>) <span class="keyword">exit</span> <span class="comment">!输入不合理的座号</span></span><br><span class="line">        p =&gt; SearchList(i,head)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">associated</span>(p)) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(5(a6,i3))&quot;</span>) <span class="string">&quot;中文&quot;</span>, p%item%Chinese, &amp;</span><br><span class="line">                                <span class="string">&quot;英文&quot;</span>, p%item%English, &amp;</span><br><span class="line">                                <span class="string">&quot;数学&quot;</span>, p%item%Math, &amp;</span><br><span class="line">                                <span class="string">&quot;自然&quot;</span>, p%item%Science, &amp;</span><br><span class="line">                                <span class="string">&quot;社会&quot;</span>, p%item%Social</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">exit</span> <span class="comment">! 找不到数据，离开循环</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;座号&#x27;,i3,&#x27;不存在，程序结束.&#x27;)&quot;</span>) i</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序使用单向串行来记录学生数据。使用串行的缺点是，不能够很快速地随机使用串行中地第n行数据。串行只适合用来顺序读取数据，不适合做随机读取。函数 SearchList 会根据输入的学生座号，在串行中找出数据的所在位置。</p>
<p>事实上函数 SearchList 可以不需要写得如此麻烦。因为在这里是根据座号来查询成绩，创建串行是，是根据座号一条数据一条数据接起来的。所以第n号学生，也就是串行的第n条数据，在这里可以使用循环来定位出第n条数据的位置。在这个程序中，用下面的 GetN 函数可以做到与 SearchList 相同的效果。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> GetN(num, head)</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">	<span class="keyword">integer</span> :: num</span><br><span class="line">	<span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: head, p</span><br><span class="line">	<span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: GetN</span><br><span class="line">	<span class="keyword">integer</span> i</span><br><span class="line">	p =&gt; head</span><br><span class="line">	<span class="keyword">do</span> i=<span class="number">2</span>,num</span><br><span class="line">		p=&gt;head%next</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">	GetN =&gt; p</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br></pre></td></tr></table></figure>
<p>比较好的编写方法，应该是先使用串行来读取文件。读完文件之后，就会指到学生数目，这时候就可以使用另一个可变大小数组来复制串行中的学生成绩。接着再把串行全部删除，查询成绩时直接使用数组来查询就行了。</p>
<h2 id="11-module-及面向对象">11 module 及面向对象</h2>
<p>第8章并没有完全说明 module 的作用，在这一章会详细解释它的功能。</p>
<h2 id="11-1-结构化与面向对象">11-1 结构化与面向对象</h2>
<h3 id="11-1-1-结构化程序设计概念">11-1-1 结构化程序设计概念</h3>
<p>现在的程序语言，都可以算是”结构化“ 程序语言。结构化程序的特点在于”层次分明“， 检查程序代码时，可以把它们分成不同的程序模块。</p>
<p>结构化的程序代码，可以做出 “层次的分析”。在没有遇到循环、流程控制时，程序代码都属于同一个层次；进入循环、流程控制时，程序代码则会归类成下一个层次。相同层次的程序代码，可以把它们视为相同的程序模块。</p>
<p>同一个模块的程序代码，执行顺序都是由上而下，一行行地来进行。遇到循环时，也是以模块为单位来重复执行程序代码。编写程序时，最好把不同层次的程序模块做不同的画面处理，例如每多一个层次，就多使用两个空格来向后错位，这个习惯可以提高程序代码的可读性。（一直在这么做）。结构化的意义，就在于程序代码是由井然有序的模块结构所创建起来的。</p>
<p>读者应该记得之前介绍过一个很有威力的 goto 命令，但是并不建议读者使用它。因为使用 goto 命令的程序，执行时常常会在程序代码中忽前忽后地跳转，这样会很容易破坏程序结构。</p>
<h3 id="11-1-2-面向对象程序设计概论">11-1-2 面向对象程序设计概论</h3>
<p>新一代地程序语言，出了具有原来地结构化程序设计方法外，还加入了“面向对象”概念。简单地说，面向对象是在做程序代码封装地操作。封装过后的程序代码，在使用上会比较安全。</p>
<p>举个例子，上银行领钱时，一定要通过银行的出纳员或是自动提款机的帮忙，才能领出户头里的钱。为了安全理由，银行不可能直接把金库开放，让客户自行取出属于自己的金钱。要是让每个人都自己去金库领钱，那一定会天下大乱。</p>
<p>为了安全起见，每个人到银行领款，一定要通过出纳员或是提款机的服务才能拿到钱。读者可以把出纳员和提款机想象成是银行对外界服务的接口，这个接口隐含了背后的实际工作情况。</p>
<p>面向对象中很重要的一项工作，就是数据封装。数据经过封装之后可以分为两种数据，一种是可以直接让大家使用的数据，另一种是只能在内部使用的数据。函数也可以拿来做封装，分开公开使用和内部使用的函数。以银行的例子来说，银行里的钱，就算是银行的内部数据，不能直接让外人使用，只有银行内部的员工才能直接接触它们。</p>
<p>出了数据封装外，面向对象的另一个重点是程序代码的重复使用。重复使用程序代码最简单的方法，就是使用函数。面向对象提供另外一种思考方法来重复使用程序代码。</p>
<p>有句俗话说：“老鼠生的儿子会打洞”，这里面有遗传的概念，它假设儿女可以继承父母亲所拥有的能力。虽然在现实生活中，继承的现象不一定会发生，不过在编写程序时，程序员可以强迫它发生，使用 module 可以用类似继承的方法来重复使用程序代码。</p>
<p>简单地说，面向对象给程序员两个新的思考方向：</p>
<ol>
<li>为了安全起见，有些数据不应该让外界使用。</li>
<li>经过继承来重复使用程序代码。</li>
</ol>
<h2 id="11-2-再论-module">11-2 再论 module</h2>
<p>module 是 fortran 90 中很重要的一项添加功能，它不单纯只是一个添加的功能，它还带来了很多新的概念，这一节会把 module 的用法做一个总结。</p>
<h3 id="11-2-1-module-的结构及功能">11-2-1 module 的结构及功能</h3>
<p>第8章已经介绍过 module 的部分功能，再来回顾一下这些内容：</p>
<ol>
<li>module 里面可以声明变量，经常用来声明程序中所需要的常量、或是用来存放全局变量。</li>
<li>module 里面可以定义自定义类型，再经过 use 的命令让程序的每一个函数都能使用这个类型。</li>
<li>module 里面可以编写函数，通常会把功能相关的函数放在同一个 module 中。在 module 外面调用这些函数时，同样要使用 use 命令</li>
<li>module 里面的函数，可以直接使用同一个 module 中所声明的变量。所以 module 里面的函数，可以经过 module 里面的变量来互相传递数据。</li>
</ol>
<h3 id="11-2-2-public-private">11-2-2 public, private</h3>
<p>module 里面的数据和函数，可以通过 public 或 private 命令，来区分成公开使用及私下使用，这里用一个实例程序来模拟到银行领钱的例子。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> bank </span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">private</span> money</span><br><span class="line">    <span class="keyword">public</span> LoadMoney, SaveMoney, Report</span><br><span class="line">    <span class="keyword">integer</span> :: money = <span class="number">1000000</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> LoadMoney(num)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: num</span><br><span class="line">        money = money - num</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> SaveMoney(num)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: num</span><br><span class="line">        money = money + num</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Report()</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;银行目前库存&#x27;,i8,&#x27;元&#x27;)&quot;</span>) money</span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1101</span><br><span class="line">    <span class="keyword">use</span> bank</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">call</span> LoadMoney(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">call</span> SaveMoney(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">call</span> Report()</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">银行目前库存 1000900元</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序执行结果并不重要，这个程序的重点在于 module bank 中把 money 变量限制为私下使用。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> money</span><br></pre></td></tr></table></figure>
<p><strong>经过这个声明，变量 money 只能在 module bank 中使用，所以主程序中不能使用 money 变量。</strong></p>
<p>除了变量，函数也可以经过 private 或 public 来定义它是否能对外公开。 程序第4行定义了几个可以对外界公开使用的接口：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> LoadMoney, SaveMoney, Report</span><br></pre></td></tr></table></figure>
<p>没有特别经过 private 或 public 来赋值时，<strong>默认的状态为 public</strong>。</p>
<p>变量 money 代表银行中目前的库存现金数量。只有银行的出纳员才能直接动用这些现金，所以变量 money 定义为 private 的状态。读者如果试着在主程序中去使用变量 money ，编译时会发生错误。如果外界可以直接使用变量 money ，很可能会发生 “抢银行” 的事件。</p>
<p>上一个实例不太实用，函数 LoadMoney 和 SaveMoney 只是单纯地重新计算银行的库存现金。实际上在提款和存款时，银行一定都会留下记录，下面是比较完整的实例程序。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> bank </span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: money = <span class="number">1000000</span></span><br><span class="line">    <span class="keyword">integer</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">private</span> money, fileid <span class="comment">! 这两个变量不对外公开</span></span><br><span class="line">    <span class="keyword">private</span> TimeLog <span class="comment">!这个函数不对外公开</span></span><br><span class="line">    <span class="comment">! public LoadMoney, SaveMoney, Report</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> TimeLog() <span class="comment">! 在log 文件中写入现在的时间</span></span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: num</span><br><span class="line">        <span class="keyword">character</span>(len=<span class="number">20</span>) :: date, time</span><br><span class="line">        <span class="keyword">call</span> <span class="built_in">Date_And_Time</span>(date,time)</span><br><span class="line">        <span class="built_in">write</span>(fileid, <span class="string">&quot;(&#x27;Date:&#x27;,a8,&#x27; Time:&#x27;,a2,&#x27;:&#x27;,a2,&#x27;:&#x27;,a2)&quot;</span>) &amp;</span><br><span class="line">            date, time(<span class="number">1</span>:<span class="number">2</span>), time(<span class="number">3</span>:<span class="number">4</span>), time(<span class="number">5</span>:<span class="number">6</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> LoadMoney(<span class="keyword">name</span>,num)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">character</span>(len=*) :: <span class="keyword">name</span></span><br><span class="line">        <span class="keyword">integer</span> :: num</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(num&lt;=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;不合理的金额&quot;</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        </span><br><span class="line">        open(fileid, <span class="keyword">file</span>=<span class="string">&quot;log.txt&quot;</span>, <span class="keyword">position</span> = <span class="string">&quot;append&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span>(money &gt;= num) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">call</span> TimeLog() <span class="comment">! 写下时间</span></span><br><span class="line">            <span class="built_in">write</span>(fileid, <span class="string">&quot;(a10, &#x27; 领取&#x27;,i5,&#x27;元&#x27;)&quot;</span>) <span class="keyword">name</span>, num <span class="comment">!提款记录</span></span><br><span class="line">            money = money - num</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">write</span>(fileid, *) <span class="string">&quot;银行目前现金不足&quot;</span></span><br><span class="line">            <span class="built_in">write</span>(*, *) <span class="string">&quot;银行目前现金不足&quot;</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        close(fileid)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> SaveMoney(<span class="keyword">name</span>,num)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">character</span>(len=*) :: <span class="keyword">name</span></span><br><span class="line">        <span class="keyword">integer</span> :: num</span><br><span class="line">        <span class="keyword">if</span>(num&lt;=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;不合理的金额&quot;</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        open(fileid, <span class="keyword">file</span>=<span class="string">&quot;log.txt&quot;</span>, <span class="keyword">position</span>=<span class="string">&quot;append&quot;</span>)</span><br><span class="line">        <span class="keyword">call</span> TimeLog() <span class="comment">! 写下时间</span></span><br><span class="line">        <span class="built_in">write</span>(fileid, <span class="string">&quot;(a10,&#x27; 存入&#x27;,i5,&#x27;元&#x27;)&quot;</span>) <span class="keyword">name</span>, num <span class="comment">! 存款记录</span></span><br><span class="line">        close(fileid)</span><br><span class="line">        money = money + num</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1102</span><br><span class="line">    <span class="keyword">use</span> bank</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">call</span> LoadMoney(<span class="string">&quot;彭先生&quot;</span>,<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">call</span> SaveMoney(<span class="string">&quot;陈先生&quot;</span>,<span class="number">1000</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行后生成 log.txt 文件，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Date:20210310 Time:10:35:56</span><br><span class="line"> 彭先生 领取  100元</span><br><span class="line">Date:20210310 Time:10:35:56</span><br><span class="line"> 陈先生 存入 1000元</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序把原本很不实用的 module bank 做了很多修改，像调用 LoadMoney 来进行提款之前，会判断提款金额是否合理，还会判断银行是否有足够的库存现金来支付。调用 SaveMoney 来进行存款前，会先判断存款金额是否合理。最重要的是在调用 LoadMoney 及 SaveMoney 来提款或存款时，都会在文件 log.txt 中留下记录。</p>
<p>程序中已经调用 Fortran 90 的库存函数 date_and_time，这个函数会用字符串来返回目前的日期和时间。</p>
<p>这个实例程序的 LoadMoney 函数比上一个版本合理，因为它不再只是单纯地重新设置变量 money 的值，他会检查变量 money 的数值，不让 money 变成负值。面向对象中，经过使用接口来操作内部数据，主要时为了避免不正常使用数据，并减少错误发生的机会。</p>
<p>private 和 public 命令也可以通过下面的方法来使用：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="comment">!定义这个module中，没有特别赋值的东西都不对外公开</span></span><br><span class="line"><span class="keyword">public</span> c <span class="comment">!定义变量c可以对外公开</span></span><br></pre></td></tr></table></figure>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="comment">!定义这个module中，没有特别赋值的东西都对外公开</span></span><br><span class="line"><span class="keyword">private</span> c <span class="comment">!定义变量c不对外公开</span></span><br></pre></td></tr></table></figure>
<h3 id="11-2-3-use">11-2-3 use</h3>
<p>第8章已经介绍过 use 命令的使用，编写好 module 之后，要使用 use 命令才能让 module 外的函数使用 module 里面的东西。在 module 中也可以使用另外一个 module。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> A</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">	<span class="keyword">integer</span> :: a,b</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> B</span><br><span class="line">	<span class="keyword">use</span> A <span class="comment">! module中可以使用另外一个 module</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub()</span><br><span class="line">	<span class="keyword">use</span> B <span class="comment">! 函数中要经过 use 才能使用编写好的 module</span></span><br><span class="line">	……</span><br></pre></td></tr></table></figure>
<p>使用 module 的数量并没有限制，可以同时使用好几个 module，只要多写几个 use 就行了。同时使用多个 module 时，可能会遇到变量名称或是函数名称重复的问题。use 命令后面，可以临时把 module 里面的变量或函数名称改名。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> A</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">	<span class="keyword">integer</span> va</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> B</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">	<span class="keyword">integer</span> va</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">	<span class="keyword">use</span> A, aa=&gt;va <span class="comment">!把 module A 的变量va改名为aa来使用</span></span><br><span class="line">	<span class="keyword">use</span> B</span><br><span class="line">	……</span><br></pre></td></tr></table></figure>
<p>上面的例子中，module A 和 module B 都同时拥有名称为 va 的变量。在主程序中同时使用这两个 module 时，会出现呢变量名称重复的问题。所以在主程序中必须临时把 module A 中的变量 va 改成另外一个名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use A, aa&#x3D;&gt;va !把 module A 的变量va改名为aa来使用</span><br></pre></td></tr></table></figure>
<p>改名是解决名称重复的方法，而如果两个 module 中重复的名称太多时，把每个名字都改掉也很麻烦。如果不需要用到两个 module 中的所有东西，可以只选择 module 里某一些东西来使用。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> A, <span class="keyword">only</span> : vc <span class="comment">! 只用 module A 中的变量 vc</span></span><br></pre></td></tr></table></figure>
<p>使用 only 时，同时也可以做临时改名的操作。和前面一样，只要再加上符合 “=&gt;“ 就行了。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> A, <span class="keyword">only</span> : c =&gt; vc <span class="comment">! 只用 module A 中的变量 vc, 并改名为c</span></span><br></pre></td></tr></table></figure>
<p>在 module A 中使用 module B，可以想象是 module A 继承了 module B 的数据和函数。<strong>不过继承的东西只限制在 module B 中对外公开的变量及函数，module B 所私下使用的东西不会被继承。</strong></p>
<p>来看一个例子</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> MA</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> a,b</span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> getx()</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;x=&#x27;,f5.2)&quot;</span>) -b/a</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> MB</span><br><span class="line">    <span class="keyword">use</span> MA</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> c</span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> getx2()</span><br><span class="line">        <span class="keyword">real</span> a2, d, sqrt_d</span><br><span class="line">        a2 = <span class="number">2</span>*a</span><br><span class="line">        d = b*b-<span class="number">4</span>*a*c</span><br><span class="line">        <span class="keyword">if</span>(d&gt;=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            sqrt_d = <span class="built_in">sqrt</span>(d)</span><br><span class="line">            <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;x=&#x27;,f5.2,&#x27;,&#x27;,f5.2)&quot;</span>) (-b+sqrt_d)/a2, (-b-sqrt_d)/a2</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;无实数解&quot;</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub1()</span><br><span class="line">    <span class="keyword">use</span> MA</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    a = <span class="number">2.0</span></span><br><span class="line">    b = <span class="number">3.0</span></span><br><span class="line">    <span class="keyword">call</span> getx()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub2()</span><br><span class="line">    <span class="keyword">use</span> MB</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    a = <span class="number">1.0</span></span><br><span class="line">    b = <span class="number">4.0</span></span><br><span class="line">    c = <span class="number">4.0</span></span><br><span class="line">    <span class="keyword">call</span> getx2()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">call</span> sub1()</span><br><span class="line">    <span class="keyword">call</span> sub2()</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x&#x3D;-1.50</span><br><span class="line">x&#x3D;-2.00,-2.00</span><br></pre></td></tr></table></figure>
<p>这个程序中的 module MA 可以用来解 ax+b=0 的 x值，module MB 则可以用来解 ax+b=0 的 x 值及 ax^2^ + bx + c=0 的 x 值。module MB 中只实现了第2部分的功能，第1部分的功能是从 module MA 中继承来的。</p>
<p>不过有一个地方需要特别介绍一下，程序的第22行使用<code>(-b±sqrt(b^2-4ac))/2a</code> 这个公式来计算两个解。</p>
<p>为了避免重复不必要的计算，程序先把 2a 和 sqrt(b^2-4ac) 的计算结果保存至变量 a2 和 sqrt_d 中，计算 x 值则用下面两个式子来做计算：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x0 = (-b+sqrt_d)/a2</span><br><span class="line">x1 = (-b-sqrt_d)/a2</span><br></pre></td></tr></table></figure>
<p>如果不事先计算 2a 和 sqrt(b^2-4ac)  的结果，计算 x 值时需要用下面这两个算式来计算：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x0 = (-b+<span class="built_in">sqrt</span>(b*b-<span class="number">4</span>*a*c))/(<span class="number">2</span>*a)</span><br><span class="line">x1 = (-b-<span class="built_in">sqrt</span>(b*b-<span class="number">4</span>*a*c))/(<span class="number">2</span>*a)</span><br></pre></td></tr></table></figure>
<p>第2个方法效率比较差，因为这两个算式会重复计算  2a 和 sqrt(b^2-4ac)   的值。在大程序中，这种多余的计算会明显地影响执行效率。</p>
<blockquote>
<p>我不太懂这里的意思，在目前这个程序中，x0 x1均只计算一次，所以 2a 和 sqrt(b^2-4ac) 这两个值事先计算还是放在公式里，都是只算一次啊，哪来的重复计算影响效率。</p>
<p>估计是作者说错了，除非这里用到了循环，事先计算才能提高效率。</p>
</blockquote>
<p>这个实例程序中，module MB 里面使用 getx2 来计算 ax^2^ + bx + c = 0 的 x 值。封装成链接库时，用户要记得 getx 和 getx2 的差别。如果能把所有的名称都统一成 getx 也许会是一个好方法。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> MB</span><br><span class="line">    <span class="keyword">use</span> MA, getx1 =&gt; getx <span class="comment">!MA中的 getx 改为 getx1</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> c</span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> getx() <span class="comment">!MB 中的 getx2 改为 getx</span></span><br><span class="line">        <span class="keyword">real</span> a2, d, sqrt_d</span><br><span class="line">        a2 = <span class="number">2</span>*a</span><br><span class="line">        d = b*b-<span class="number">4</span>*a*c</span><br><span class="line">        <span class="keyword">if</span>(d&gt;=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            sqrt_d = <span class="built_in">sqrt</span>(d)</span><br><span class="line">            <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;x=&#x27;,f5.2,&#x27;,&#x27;,f5.2)&quot;</span>) (-b+sqrt_d)/a2, (-b-sqrt_d)/a2</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;无实数解&quot;</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br></pre></td></tr></table></figure>
<p>把 module MB 经过上面的方法来改写后，使用 module MB 时，可以经过 getx 函数来计算 ax^2^ + bx + c = 0 的 x 值，因为在 module MB 中，继承来的 getx 函数被改名成 getx1，所以可以在 module MB 中显示新的 getx。不过要计算 ax+b=0时，变成要调用 getx1，所以这个方法并不能算是很好的方法，下一节会介绍一个更好的解决方法。</p>
<h2 id="11-3-再论-interface">11-3 再论 interface</h2>
<p>在第8章中，interface 是用来说明函数的参数及返回值类型。不过<strong>当函数封装在 module 里面时，就不需要再使用 interface 来做这些说明</strong>。事实上 interface 的功能不只是这些，它还有其他很强大的功能可以使用。</p>
<h3 id="11-3-1-同名函数的重载（overload）">11-3-1 同名函数的重载（overload）</h3>
<p>overload 的意义是：”在程序代码中可以同时拥有多个名称相同，但是参数类型、数目不同的函数，程序会自动根据输入的参数，来决定要调用哪一个函数“。</p>
<p>Fortran 90 编写函数重载的方法和C++不太一样，在module中使用 interface，可以用来定义一个虚拟的函数名称，来看下面的实例：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> MA</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">interface</span> show <span class="comment">! 虚拟的函数名称 show</span></span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> show_int <span class="comment">!等待选择的函数show_int</span></span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> show_character <span class="comment">!等待选择的函数show_character</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> show_int(n)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span>, <span class="keyword">intent</span>(<span class="keyword">in</span>) :: n</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;n=&#x27;,i3)&quot;</span>) n</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> show_character(str)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">character</span>(len=*), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: str</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;str=&#x27;,a)&quot;</span>) str</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> MA</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">call</span> show_int(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">! 输入的参数是整数，会自动选择调用 show_int</span></span><br><span class="line">    <span class="keyword">call</span> show(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">call</span> show_character(<span class="string">&quot;Fortran 95&quot;</span>)</span><br><span class="line">    <span class="comment">! 输入的参数是字符串，会自动选择调用 show_character</span></span><br><span class="line">    <span class="keyword">call</span> show(<span class="string">&quot;Fortran 95&quot;</span>)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n&#x3D;  1</span><br><span class="line">n&#x3D;  1</span><br><span class="line">str&#x3D;Fortran 95</span><br><span class="line">str&#x3D;Fortran 95</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个实例程序的第4~7行，在 module MA 中使用 interface 定义出虚拟的函数 show。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> show <span class="comment">! 虚拟的函数名称 show</span></span><br><span class="line">    <span class="keyword">module</span> <span class="keyword">procedure</span> show_int <span class="comment">!等待选择的函数show_int</span></span><br><span class="line">    <span class="keyword">module</span> <span class="keyword">procedure</span> show_character <span class="comment">!等待选择的函数show_character</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">interface</span></span><br></pre></td></tr></table></figure>
<p>在 interface show 中，定义的两个函数可以被冒名顶替。在程序进行中调用 show 时，实际上会从这两个函数中挑出一个出来执行，挑选的根据在于调用 show 时所输入的参数。输入一个整数时，会调用 show_int ；输入一个字符串时，会调用 show_character。</p>
<p>因此我们可以改写一下之前计算 ax+b=0 ; ax^2^ + bx +c =0 的程序</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> MA</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">interface</span> getx</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> getx1</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> getx2</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> getx1(a,b)</span><br><span class="line">        <span class="keyword">real</span> a,b</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;x=&#x27;,f5.2)&quot;</span>) -b/a</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> getx2(a,b,c)</span><br><span class="line">        <span class="keyword">real</span> a, b, c</span><br><span class="line">        <span class="keyword">real</span> a2, d, sqrt_d</span><br><span class="line">        a2 = <span class="number">2</span>*a</span><br><span class="line">        d = b*b-<span class="number">4</span>*a*c</span><br><span class="line">        <span class="keyword">if</span>(d&gt;=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            sqrt_d = <span class="built_in">sqrt</span>(d)</span><br><span class="line">            <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;x=&#x27;,f5.2,&#x27;,&#x27;,f5.2)&quot;</span>) (-b+sqrt_d)/a2, (-b-sqrt_d)/a2</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;无实数解&quot;</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> MA</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">call</span> getx(<span class="number">1.0</span>,<span class="number">2.0</span>) <span class="comment">!实际上会调用 getx1</span></span><br><span class="line">    <span class="keyword">call</span> getx(<span class="number">1.0</span>,<span class="number">3.0</span>,<span class="number">2.0</span>) <span class="comment">!实际上会调用 getx2</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x&#x3D;-2.00</span><br><span class="line">x&#x3D;-1.00,-2.00</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序统一调用 getx ，通过参数个数来判断调用哪个函数。</p>
<h3 id="11-3-2-自定义操作符">11-3-2 自定义操作符</h3>
<p>Fortran 基本数值的数据类型，主要有 integer, real 这两种。使用这两种类型所声明出来的变量，除了可以用来保存数值外，还可以拿来做+,-,*,/ 数学计算及 &lt;, &lt;=, &gt;, &gt;=, ==, /= 等等的逻辑判断。而使用 type 所声明的自定义类型，默认时不能拿来做这些运算。不过通过 interface 的帮忙，可以虚拟出上述的运算符号。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> operator(+)</span><br><span class="line">	<span class="comment">!在程序代码中，使用a+b时，若a和b的参数符合下面任何函数中的</span></span><br><span class="line">	<span class="comment">!两个参数类型，会调用其中一个函数来执行</span></span><br><span class="line">	<span class="keyword">module</span> <span class="keyword">procedure</span> add1</span><br><span class="line">	<span class="keyword">module</span> <span class="keyword">procedure</span> add2</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">interface</span></span><br></pre></td></tr></table></figure>
<p>来看一个简单的例子：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> MA</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">	<span class="keyword">type</span> ta</span><br><span class="line">		<span class="keyword">integer</span> a</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line">    <span class="keyword">interface</span> operator(+) <span class="comment">!这个interface让 type(ta) 类型变量也能相加</span></span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> add</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> add(a,b)</span><br><span class="line">        <span class="keyword">type</span>(ta), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: a,b</span><br><span class="line">        add = a%a+b%a</span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1106</span><br><span class="line">    <span class="keyword">use</span> MA</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(ta) :: a,b</span><br><span class="line">    <span class="keyword">integer</span> :: c</span><br><span class="line">    a%a = <span class="number">1</span></span><br><span class="line">    b%a = <span class="number">2</span></span><br><span class="line">    c = a+b <span class="comment">!会调用add(a,b)来执行</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) c</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<p>这正是 a%a + b%b 的结果。这个程序主要是用来示例自定义操作符的方法，在module MA中定义了一个特别的 interface，它把加法 ”+“ 符号也拿来当成虚拟函数的名称。所以主程序中出现加法时，如果相加的两个变量都是 type(ta) 类型，会自动转换成调用函数 add 来执行。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> operator(+) <span class="comment">!这个interface让 type(ta) 类型变量也能相加</span></span><br><span class="line">    <span class="keyword">module</span> <span class="keyword">procedure</span> add</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">interface</span></span><br></pre></td></tr></table></figure>
<p>请注意，要把运算符号拿来当成虚拟函数名称时， interface 后面要先接上 operator 这个字，再用括号把运算符号括起来。另外在 interface 中等待候选的函数，必须明确显示每一个参数属性 intent。</p>
<p>来看一个比较实用的实例：黄先生在这个月的5日 及 20日分别和许律师约谈了1个小时45分，2小时18分。请问黄先生这个月花了多少时间和他的律师讨论有关他的遗产分配问题？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">module time_util</span><br><span class="line">    implicit none</span><br><span class="line">    type :: time</span><br><span class="line">        integer :: hour, minute</span><br><span class="line">    end type time</span><br><span class="line">    interface operator(+) ! 让type(time)类型变量能够相加</span><br><span class="line">        module procedure add</span><br><span class="line">    end interface</span><br><span class="line">    </span><br><span class="line">contains</span><br><span class="line">    function add(a,b)</span><br><span class="line">        implicit none</span><br><span class="line">        type(time),intent(in) :: a,b</span><br><span class="line">        type(time) :: add</span><br><span class="line">        integer :: minutes, carry</span><br><span class="line">        minutes &#x3D; a%minute + b%minute</span><br><span class="line">        carry &#x3D; minutes&#x2F;60</span><br><span class="line">        add%minute &#x3D; mod(minutes,60) !取余数</span><br><span class="line">        add%hour &#x3D; a%hour + b%hour + carry</span><br><span class="line">        return</span><br><span class="line">    end function</span><br><span class="line">    </span><br><span class="line">    subroutine output(t)</span><br><span class="line">        type(time), intent(in) :: t</span><br><span class="line">        write(*, &quot;(i2,&#39;:&#39;,i2.2)&quot;) t%hour, t%minute</span><br><span class="line">        return</span><br><span class="line">    end subroutine</span><br><span class="line"></span><br><span class="line">end module</span><br><span class="line"></span><br><span class="line">program ex1107</span><br><span class="line">    use time_util</span><br><span class="line">    implicit none</span><br><span class="line">    type(time) :: a,b,c</span><br><span class="line">    a &#x3D; time(1,45)</span><br><span class="line">    b &#x3D; time(2,18)</span><br><span class="line">    c&#x3D;a+b !实际上会调用函数add(a,b)</span><br><span class="line">    call output(c)</span><br><span class="line">    </span><br><span class="line">    stop</span><br><span class="line">end program</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>程序执行后会计算出1小时45分加上2小时18分的时间长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4:03</span><br></pre></td></tr></table></figure>
<p>这里的 interface 里面，只有一个”候选“的函数。在这里的候选函数只能是函数，不能是子程序。因为数学计算 a+b 一定要返回一个结果。在主程序中执行 c = a+b 时，实际上执行的是 c=add(a,b) 。经过 interface 的封装，可以让程序代码中使用直观的运算符号来调用这个函数。</p>
<p>使用 interface operator() 来自定义操作符时，还有一点很有趣，程序员可以任意制作出 Fortran 标准中不存在的操作符。</p>
<p>例如在制作”向量类型“时，可能会需要用到 dot，不过Fortran 中并没有 dot 这个操作符，但是可以使用 interface operator(.dot.) 来创造这个操作符。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b .dot. c <span class="comment">!新定义的操作符 dot</span></span><br></pre></td></tr></table></figure>
<p>最后再来看一个比较完整的实例程序，上一个实例程序只定义了 type(time) 类型变量的加法。下面的实例程序会定义出 type(time)+real, real +type(time), 小于的判断及两种等号 type(time)=real, real=type(time) 操作。</p>
<p>代码略。</p>
<p>这里一个加法有三种不同的函数，之所以可行是因为这三种函数的参数的类型不同。如果存在参数个数和类型均相同的两个函数，这里估计会报错。</p>
<h2 id="11-4-实际应用">11-4 实际应用</h2>
<p>这一节会实际示范继承 module 来增强功能的方法，以及比较完整的自定义类型运算。</p>
<h3 id="11-4-1-继承module">11-4-1 继承module</h3>
<h3 id="11-4-2-自定义操作符的应用">11-4-2 自定义操作符的应用</h3>
<p>Fortran 中并没有提供”分数“类型，不过在现实世界中，常常会使用这个类型。分数可以保存更为精确的数值，例如 2/3。因为2/3转换成实数后，会变成循环小数，小数的位数高达无限多个。使用浮点数来记录2/3时，因为有效位数的限制，没有办法正确保存循环小数的值。</p>
<p>下面这个程序实现了分数和分数间的加减乘除。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> rational_util</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span></span><br><span class="line">    <span class="keyword">public</span> :: rational, &amp;</span><br><span class="line">            operator(+),operator(-),operator(*),&amp;</span><br><span class="line">            operator(/),assignment(=),&amp;</span><br><span class="line">            output</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">type</span> :: rational</span><br><span class="line">        <span class="keyword">integer</span> :: num <span class="comment">! 分子</span></span><br><span class="line">        <span class="keyword">integer</span> :: denum <span class="comment">! 分母</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 加法</span></span><br><span class="line">    <span class="keyword">interface</span> operator(+)</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> rat_plus_rat</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    <span class="comment">! 减法</span></span><br><span class="line">    <span class="keyword">interface</span> operator(-)</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> rat_minus_rat</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    <span class="comment">! 乘法</span></span><br><span class="line">    <span class="keyword">interface</span> operator(*)</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> rat_times_rat</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    <span class="comment">! 除法</span></span><br><span class="line">    <span class="keyword">interface</span> operator(/)</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> rat_div_rat</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    <span class="comment">! 等号</span></span><br><span class="line">    <span class="keyword">interface</span> assignment(=)</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> int_eq_rat</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> real_eq_rat</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">!整数=分数</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> int_eq_rat(<span class="built_in">int</span>, rat)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span>, <span class="keyword">intent</span>(<span class="keyword">out</span>) :: <span class="built_in">int</span></span><br><span class="line">        <span class="keyword">type</span>(rational), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: rat</span><br><span class="line">        <span class="comment">!分子除以分母来转换成整数</span></span><br><span class="line">        <span class="built_in">int</span> = rat%num / rat%denum</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!浮点数=分数</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> real_eq_rat(<span class="built_in">float</span>, rat)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">intent</span>(<span class="keyword">out</span>) :: <span class="built_in">float</span></span><br><span class="line">        <span class="keyword">type</span>(rational), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: rat</span><br><span class="line">        <span class="comment">!分子除以分母</span></span><br><span class="line">        <span class="built_in">float</span> = <span class="keyword">real</span>(rat%num) / <span class="keyword">real</span>(rat%denum) <span class="comment">!分子分母先转化为实数类型</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!化简分数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span></span> reduse(a)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(rational), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: a</span><br><span class="line">        <span class="keyword">type</span>(rational) :: temp</span><br><span class="line">        <span class="keyword">integer</span> :: b</span><br><span class="line">        <span class="keyword">integer</span> :: <span class="built_in">sign</span></span><br><span class="line">        <span class="keyword">type</span>(rational) :: reduse</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a%num*a%denum &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">sign</span> = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">sign</span> = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        </span><br><span class="line">        temp%num = <span class="built_in">abs</span>(a%num)</span><br><span class="line">        temp%denum = <span class="built_in">abs</span>(a%denum)</span><br><span class="line">        b=gcv(temp%num, temp%denum) <span class="comment">!找出分子与分母的最大公因子</span></span><br><span class="line">        <span class="comment">!把分子，分母同时除以最大公因子</span></span><br><span class="line">        reduse%num = temp%num / b * <span class="built_in">sign</span></span><br><span class="line">        reduse%denum = temp%denum / b</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="comment">!用辗转相除法找最大公因子</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span></span> gcv(a,b)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span>, <span class="keyword">intent</span>(<span class="keyword">in</span>) :: a,b</span><br><span class="line">        <span class="keyword">integer</span> :: big,small</span><br><span class="line">        <span class="keyword">integer</span> :: temp</span><br><span class="line">        <span class="keyword">integer</span> :: gcv</span><br><span class="line">        </span><br><span class="line">        big = <span class="built_in">max</span>(a,b)</span><br><span class="line">        small = <span class="built_in">min</span>(a,b)</span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(small&gt;<span class="number">1</span>)</span><br><span class="line">            temp=<span class="built_in">mod</span>(big,small)</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">            big = small</span><br><span class="line">            small = temp</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">        gcv = small</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span> gcv</span><br><span class="line">   </span><br><span class="line">    <span class="comment">!分数相加</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span></span> rat_plus_rat(rat1,rat2)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(rational) :: rat_plus_rat</span><br><span class="line">        <span class="keyword">type</span>(rational), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: rat1, rat2</span><br><span class="line">        <span class="keyword">type</span>(rational) :: act</span><br><span class="line">        <span class="comment">! b/a+d/c=(b*c+d*a)/(a*c)</span></span><br><span class="line">        act%denum = rat1%denum * rat2%denum <span class="comment">!a*c</span></span><br><span class="line">        act%num = rat1%num*rat2%denum + rat2%num*rat1%denum <span class="comment">!(b*c+d*a)</span></span><br><span class="line">        rat_plus_rat = reduse(act) <span class="comment">!约分</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="comment">!分数相减</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span></span> rat_minus_rat(rat1,rat2)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(rational) :: rat_minus_rat</span><br><span class="line">        <span class="keyword">type</span>(rational), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: rat1, rat2</span><br><span class="line">        <span class="keyword">type</span>(rational) :: act</span><br><span class="line">        <span class="comment">! b/a-d/c=(b*c-d*a)/(a*c)</span></span><br><span class="line">        act%denum = rat1%denum * rat2%denum <span class="comment">!a*c</span></span><br><span class="line">        act%num = rat1%num*rat2%denum - rat2%num*rat1%denum <span class="comment">!(b*c-d*a)</span></span><br><span class="line">        rat_minus_rat = reduse(act) <span class="comment">!约分</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="comment">!分数相乘</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span></span> rat_times_rat(rat1,rat2)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(rational) :: rat_times_rat</span><br><span class="line">        <span class="keyword">type</span>(rational), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: rat1, rat2</span><br><span class="line">        <span class="keyword">type</span>(rational) :: act</span><br><span class="line">        <span class="comment">! b/a*d/c=(b*d)/(a*c)</span></span><br><span class="line">        act%denum = rat1%denum * rat2%denum <span class="comment">!a*c</span></span><br><span class="line">        act%num = rat1%num*rat2%num <span class="comment">!b*d</span></span><br><span class="line">        rat_times_rat = reduse(act) <span class="comment">!约分</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="comment">!分数相除</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span></span> rat_div_rat(rat1,rat2)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(rational) :: rat_div_rat</span><br><span class="line">        <span class="keyword">type</span>(rational), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: rat1, rat2</span><br><span class="line">        <span class="keyword">type</span>(rational) :: act</span><br><span class="line">        <span class="comment">! (b/a) / (d/c)=(b*c)/(a*d)</span></span><br><span class="line">        act%denum = rat1%denum * rat2%num <span class="comment">!a*d</span></span><br><span class="line">        act%num = rat1%num*rat2%denum <span class="comment">!b*c</span></span><br><span class="line">        rat_div_rat = reduse(act) <span class="comment">!约分</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="comment">!输出</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> output(a)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(rational), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: a</span><br><span class="line">        <span class="keyword">if</span>(a%denum /= <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(1x,&#x27;(&#x27;,i3,&#x27;/&#x27;,i3,&#x27;)&#x27;)&quot;</span>) a%num, a%denum</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(1x,i3)&quot;</span>) a%num</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!主程序</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1110</span><br><span class="line">    <span class="keyword">use</span> rational_util</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(rational) :: a,b,c</span><br><span class="line">    <span class="keyword">real</span> :: f</span><br><span class="line">    </span><br><span class="line">    a=rational(<span class="number">1.0</span>,<span class="number">3.0</span>)</span><br><span class="line">    b=rational(<span class="number">2.0</span>,<span class="number">3.0</span>)</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a4)&quot;</span>,<span class="keyword">advance</span>=<span class="string">&quot;no&quot;</span>) <span class="string">&#x27;a=&#x27;</span></span><br><span class="line">    <span class="keyword">call</span> output(a)</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a4)&quot;</span>,<span class="keyword">advance</span>=<span class="string">&quot;no&quot;</span>) <span class="string">&#x27;b=&#x27;</span></span><br><span class="line">    <span class="keyword">call</span> output(b)</span><br><span class="line">    c=a+b</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a4)&quot;</span>,<span class="keyword">advance</span>=<span class="string">&quot;no&quot;</span>) <span class="string">&#x27;a+b=&#x27;</span></span><br><span class="line">    <span class="keyword">call</span> output(c)</span><br><span class="line">    c=a-b</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a4)&quot;</span>,<span class="keyword">advance</span>=<span class="string">&quot;no&quot;</span>) <span class="string">&#x27;a-b=&#x27;</span></span><br><span class="line">    <span class="keyword">call</span> output(c)</span><br><span class="line">    c=a*b</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a4)&quot;</span>,<span class="keyword">advance</span>=<span class="string">&quot;no&quot;</span>) <span class="string">&#x27;a*b=&#x27;</span></span><br><span class="line">    <span class="keyword">call</span> output(c)</span><br><span class="line">    c=a/b</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a4)&quot;</span>,<span class="keyword">advance</span>=<span class="string">&quot;no&quot;</span>) <span class="string">&#x27;a/b=&#x27;</span></span><br><span class="line">    <span class="keyword">call</span> output(c)</span><br><span class="line">    f=c</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(f6.2)&quot;</span>) f</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  a&#x3D; (  1&#x2F;  3)</span><br><span class="line">  b&#x3D; (  2&#x2F;  3)</span><br><span class="line">a+b&#x3D;   1</span><br><span class="line">a-b&#x3D; ( -1&#x2F;  3)</span><br><span class="line">a*b&#x3D; (  2&#x2F;  9)</span><br><span class="line">a&#x2F;b&#x3D; (  1&#x2F;  2)</span><br><span class="line"> 0.50</span><br></pre></td></tr></table></figure>
<p>这个程序虽然长，但是不难。就是有一点有意思，就是他这里提到的”辗转相除法“ 求余数有点意思，之前没学过。</p>
<p>他这个原理很简单，就是两个数求最大公约数，通过两个数求余不断缩小这两个数，直至一个数为0，此时另一个数就是最大公约数。这样做效率很高。</p>
<p>我自己也简单地证明了一下，假设这两个数是 m n（m比n大），这两个数的最大公约数是k</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m = ak</span><br><span class="line">n = bk</span><br><span class="line">m % n = ak % bk #求余，这里余数设为p</span><br><span class="line">p = m % n = ak - x*bk (x为整除数) = (a-xb)k</span><br><span class="line">#证明余数 p 仍可以整除k</span><br></pre></td></tr></table></figure>
<p>体现在fortran 中的代码为</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">!用辗转相除法找最大公因子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span></span> gcv(a,b)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">intent</span>(<span class="keyword">in</span>) :: a,b</span><br><span class="line">    <span class="keyword">integer</span> :: big,small</span><br><span class="line">    <span class="keyword">integer</span> :: temp</span><br><span class="line">    <span class="keyword">integer</span> :: gcv</span><br><span class="line">    </span><br><span class="line">    big = <span class="built_in">max</span>(a,b)</span><br><span class="line">    small = <span class="built_in">min</span>(a,b)</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(small&gt;<span class="number">1</span>)</span><br><span class="line">        temp=<span class="built_in">mod</span>(big,small)</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        big = small <span class="comment">!此时较大的数改为原来较小的数</span></span><br><span class="line">        small = temp <span class="comment">!此时较小的数改为余数</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    gcv = small</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span> gcv</span><br></pre></td></tr></table></figure>
<p>关于 Fortran 语法的介绍，到这一章算是完全结束。下一章会开始进入 Fortran 应用的部分，都是各自独立的不同应用，可以跳着看。</p>
<h2 id="12-编译器的高级使用">12 编译器的高级使用</h2>
<p>这一章要再次说明编译器的使用。第2章示例过编译程序的方法，整套编译器所提供的功能不只是单纯的编译程序而已，善用编译器所提供的工具，对于开发程序有很大帮助。</p>
<p>除了介绍编译器的使用，这一章还会示例 Fortran 与其他语言的互相链接。还有很重要的一个课题： 如何对程序进行优化。</p>
<h2 id="12-1-编译器的完整功能">12-1 编译器的完整功能</h2>
<p>一般来说，编译器所提供的工具，大概有以下这几大类：</p>
<blockquote>
<ol>
<li>
<p>编译器 (Compiler)</p>
<p>用来把程序代码转换成目的文件（.obj）或执行文件（.exe）的工具，是编译工具的主角。Compiler 在编译时有很多选项可以设置，要如何使用这些设置也是一门学科。不同的设置会编译出不同的机器码。</p>
<p>最常见的选项格式有两种，Release 格式和 Debug 格式。Release 格式所编译出来的执行文件执行效率比较好，Debug 格式所编译出来的文件执行效率比较差，不过可以配合Debug 工具来进行调试。</p>
</li>
<li>
<p>链接器（Link）</p>
<p>用来把 Compiler 所生成的目的文件（.obj）链接成最后的可执行文件（.exe），或是链接库（.lib, .dll）。有的编译器执行后会自动调用Link来生成执行文件，所以很多用户不会发现Link的存在。经过目的文件来生成执行文件有几项好处：</p>
<ol>
<li>可以把大程序拆解成许多小文件来编写。</li>
<li>可以把不同语言程序代码所生成的OBJ文件链接成一个执行文件。</li>
</ol>
</li>
<li>
<p>链接库（Library）</p>
<p>编写 Fortran 程序所使用的库存函数，都是事先写好放在.lib 的链接库中。通常各家编译器会自行额外提供扩充函数，像Visual Fortran 专业版中已经提供 IMSL。</p>
</li>
<li>
<p>说明文件（Help)</p>
</li>
<li>
<p>调试工具（Debug）</p>
<p>调试工具是很重要的一项功能，它的重要性仅次于 Compiler。好的调试工具可以让程序员快速找到程序代码的错误。调试格式下，可以对程序代码设置断点，程序执行到断点会暂停执行。这个时候程序员可以查看变量内容，看看它们是否和预期相同。还可以一行一行来执行程序，检查程序执行流程是否正确。</p>
</li>
<li>
<p>分析工具（Profile）</p>
<p>用于分析程序代码中各个函数所花费的执行时间，可以用来找出程序代码中执行效率最差的部分，程序员可以针对这部分程序代码来作修正。</p>
</li>
</ol>
</blockquote>
<p>这一章以 MS Developer Studio 的使用环境做模板。</p>
<h2 id="12-4-优化">12-4 优化</h2>
<p>在信息界广泛流传这样的一句话：”有90%的程序执行时间是花在10%的程序代码里“。换句话说，假如程序代码总共有1000行的话，可能有900行的程序只花了0.1秒就执行完，但是却有100行程序会花掉0.9秒来执行。</p>
<h3 id="12-4-2-程序代码优化">12-4-2 程序代码优化</h3>
<p>要如何写程序来解决问题，一向没有标准答案。解决同样的问题，可以编写出好几种不同的程序。程序的好坏通常取决于两个方面：</p>
<ol>
<li>执行速度</li>
<li>内存使用量。</li>
</ol>
<p>这个小节会强调执行速度的问题，介绍如何让程序代码拥有更好的执行效率，也就是所谓的程序优化。程序代码优化处理，大致上有下面几个方向。</p>
<ol>
<li>
<p>使用好的算法。</p>
<p>算法是指用来解决某个问题的特定程序方法。以数据排序为例子，前面已经介绍过选择排序法（Selection Sort），一般来说它并不算是个好方法，在排序问题中有一个称为快速排序（Quick sort）的算法，在一般情况下执行效率最高。</p>
<p>再以计算等差数列的和来说，要计算 1+2+3+……+n 的值，用循环累加跟使用梯型公式比较起来，当然是用梯形公式比较快。</p>
</li>
<li>
<p>避免重复的计算</p>
<p>做计算的时候经常会重复使用某一个计算结果。这个时候就应该把这个计算结果事先保存起来，再让其他算式使用。例如要计算 ax^2 + bx + c =0 的解，如果直接根据公式计算，写成代码是</p>
 <figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x1=(-b+<span class="built_in">sqrt</span>(b*b-<span class="number">4</span>*a*c))/(<span class="number">2.0</span>*a)</span><br><span class="line">x1=(-b-<span class="built_in">sqrt</span>(b*b-<span class="number">4</span>*a*c))/(<span class="number">2.0</span>*a)</span><br></pre></td></tr></table></figure>
<p>用这个写法， <code>sqrt(b*b-4*a*c)</code> 和 <code>2.0*a</code> 会重复计算两次。比较好的方法应该是先把这两个值算出来，再计算 x1, x2 的值。</p>
<blockquote>
<p>ok，我现在知道为什么要这么做了，这也太严谨了。</p>
</blockquote>
<p>在循环中很容易会不自觉地出现重复计算，循环里地计算式，如果没有必要写在循环里，就应该把它移到循环外面。</p>
 <figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">10</span></span><br><span class="line">	a(i) = <span class="keyword">real</span>(i)/(b+c)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>上面的循环中，b+c 的值没有必要在循环里计算，因为不管 i 是多少，b + c 的值都不会改变，没有必要在循环中算10次，应该把它移到循环外面来做。（严谨！但是似乎有一点点影响可读性）</p>
 <figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = b+c <span class="comment">! 把b+c的结果记录在变量d中</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">10</span></span><br><span class="line">	a(i) = <span class="keyword">real</span>(i)/d</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>表达式的选择</p>
<p>数学算式中，使用不同的式子可以得到同样的结果，下面是几个例子。</p>
 <figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>*A = A+A</span><br><span class="line">A**<span class="number">2</span> = A*A</span><br><span class="line">X**<span class="number">2</span>+<span class="number">2</span>*X+<span class="number">3</span> = ((X=<span class="number">2</span>)*X)+<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>这3个例子中，等号右边的写法都会比等号左边的写法来得迅速。计算机运算时，做加减法会比做乘除法快，乘法又会比乘幂快。所以计算2A时，用 A+A 会比用 2*A 来得快；同理计算 A*A 会比 计算 A**2 来得快。至于第3个式子，左边的方法会使用1个乘幂，1个乘法，2个加法；右边的方法则会使用1个乘法跟2个加法，很明显的是右边的方法会比较快。</p>
<blockquote>
<p>这有一点吹毛求疵，而且影响了可读性了。我最多接受将乘幂写成乘法，即 A**2 改成 A*A</p>
</blockquote>
</li>
<li>
<p>整数与浮点数的选择</p>
<p>计算机的整数运算比浮点数运算快，能够使用整数时，就应该尽量多使用整数。</p>
<p>在混合使用整数和浮点数的算式中，应该要尽量把整数集合在一起。</p>
<p><strong>使用浮点数时，双精度和单精度的计算速度相同，差别在于内存使用量</strong>。</p>
<p>（为什么？百度百科说CPU处理单精度更快，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8F%8C%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0%EF%BC%89">https://baike.baidu.com/item/双精度浮点数）</a></p>
</li>
<li>
<p>访问速度</p>
<p>不同的变量类型，在使用时会有不同的访问速度。例如声明成 parameter 的常量，使用时会比一般变量快。因为使用常量不用再到内存中取出数据，数字可以直接写在程序代码中。使用常量来做计算时，在编译过程中就会计算完毕，不需要在执行过程中计算。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;b&#x2F;2.0</span><br><span class="line">a&#x3D;b&#x2F;c</span><br></pre></td></tr></table></figure>
<p>使用数组的访问速度比变量慢，而且越高维的数组访问速度越慢。因为使用数组时，要先计算出坐标在数组中的内存位置，越高维的数组需要计算的式子会越长。</p>
 <figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b=a(i)+a(j)</span><br><span class="line">b=e+f <span class="comment">! 假设 e=a(i), f=a(j)</span></span><br></pre></td></tr></table></figure>
<p>使用指针也会比使用变量慢上一点点，因为使用指针要经过两个步骤，先取出指针所保存的内存地址，再去使用这个内存。直接使用变量时不需要第1个操作，使用变量时马上就可以知道它使用哪一块内存。</p>
</li>
<li>
<p>利用 cache</p>
<p>程序执行时，如果能尽量避免跳转式使用内存，会得到比较好的执行效率。使用数组时最需要注意这一点。</p>
 <figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,n1</span><br><span class="line">	<span class="keyword">do</span> j =<span class="number">1</span>,n2</span><br><span class="line">		<span class="keyword">do</span> k=<span class="number">1</span>,n3</span><br><span class="line">			<span class="comment">! s=s+a(i,j,k) !不好的写法</span></span><br><span class="line">			s=s+a(k,j,i) <span class="comment">!比较好的写法</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>上面这两种写法，第2种写法会比较好，因为它会依照内存的排列顺序来使用数组；第1种方法则会跳转式地在内存中访问。</p>
<p>关于计算机的存储知识见：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/71956210">https://zhuanlan.zhihu.com/p/71956210</a></p>
<blockquote>
<p><strong>计算机的存储系统可以看成一个金字塔形结构（也称为 memory hierarchy）</strong>，越是上层的存储设备容量越小、速度越快、价格也越贵，而越是下层的存储设备容量越大、速度越慢、价格也越便宜。</p>
<p>寄存器（Regs）- 一级缓存（L1 cache）- 二级缓存 - 三级缓存 - 内存（Main memory）- 本地磁盘（Local disks）- 网络存储（Network storage）</p>
</blockquote>
<p>下面这段话解释了计算机时如何查找和访问数据的。</p>
<blockquote>
<p>通常来讲，越是上层的存储设备 block size 越小（例如几个字节），而越到下层 block size 越大（例如整个文件）。当我们要读取某个数据的时候，我们沿着金字塔从上往下看。由于越是上层的存储设备访问速度越快，如果该数据在上一层已经被缓存了（称作 cache hit），那么皆大欢喜，我们可以直接读出数据。如果该数据在上一层没有被缓存（称作 cache miss），那么我们只能从下一层取出包含该数据的 block 放到上一层。</p>
<p>**要是上一层的缓存已经全部装满了怎么办？**那我们只能替换掉一个别的 block 了。替换的策略有很多种，最简单的方法当然可以随机选一个倒霉的 block 扔掉，不过这不一定是最好的办法。</p>
<p>由于时间局部性告诉我们，越是最近访问过的数据越应该被缓存，因此另一个常用的策略 LRU (least recently used) 干的事情就是把最久没有访问过的 block 扔掉。</p>
</blockquote>
<p>简单地说，就是按照计算机存储系统从上往下一级一级地查找，找到了就把包含该数据的 block 放到上一层。（注意，这里的一个 block 指的是一段连续的数据，也就是除了要找的数据外它附近的数据也调到上层了，比如你只是查找数组中的某一个元素，那么可能整个数组都会被放到上一层，这样如果你之后查找数组中的其他元素，速度也很快）</p>
<p>如果上一层的缓存已经全部装满，那就将最久没有访问过的 block 扔掉。（因此相关的数据，代码最好放在一块，不要东一块西一块的）</p>
</li>
<li>
<p>减少程序代码的跳转、转向</p>
<p>使用流程控制命令 if, select case, 及 do 循环、调用函数时，都会导致程序执行做出跳转和转向的操作。执行程序和开车一样，在笔直的路上开车是最快的，遇到转弯甚至回转时就需要减速。执行程序时也是相同的，照顺序直线执行的程序会比较快。</p>
 <figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">!比较好的写法</span></span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">20</span>) <span class="keyword">then</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a &gt; <span class="number">10</span>)</span><br><span class="line">……</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!比较不好的写法</span></span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">20</span>) <span class="keyword">then</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">10</span> .and. a&lt;=<span class="number">20</span>) <span class="keyword">then</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">if</span>(a&lt;=<span class="number">10</span>) <span class="keyword">then</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br></pre></td></tr></table></figure>
<p>上面这两种代码效果相同，不过第1种写法比较好，第2种写法固定要做3次if 判断。第1种写法则不一定会做几次if判断，不过最多只会做2次。</p>
 <figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">	read(<span class="number">10</span>, *) a(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>, n</span><br><span class="line">	s = s*a(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,n <span class="comment">!把上面两个循环合并起来</span></span><br><span class="line">	read(<span class="number">10</span>, *) a(i)</span><br><span class="line">	s = s*a(i) </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>上面这两个循环第2种写法比较好，因为这两个循环本来就可以合并，减少一次循环次数。</p>
</li>
</ol>
<p>上面介绍了几个程序优化的策略，<strong>使用这些策略不需要矫枉过正</strong>。</p>
<p>编写程序时，不需要把每个部分都做优化处理。如果某个函数只会调用一次，那就可以不太注意它的执行效率。前面已经提到，通常最花时间的程序代码大概都只会集中在少部分程序中。一般来说，只要把循环中的程序代码，跟经常会调用使用的函数做优化处理，整个程序就可以有不错的执行效率。</p>
<blockquote>
<p>我一直在想，这些优化策略对代码<strong>可读性</strong>的影响。然后我又看了一下 Fortran 代码，Fortran 代码<strong>有个毛线的可读性</strong>，他们正常写的代码都没什么可读性可言。</p>
</blockquote>
<h1>14 数值方法</h1>
<p>数值计算是 Fortran 语言最主要的应用领域，现在就来进入这个课题。本书把数值方法分成两个章节来介绍，这一章会示例如何自行编写程序来求解最基本的几个数值方法问题，第16章会示例如何使用 IMSL 链接库来做数值计算。</p>
<h2 id="14-1-求解非线性函数">14-1 求解非线性函数</h2>
<p>这一节是要示例如何计算函数 f(x) =0 的解。</p>
<h3 id="14-1-1-二分法-Bisection">14-1-1 二分法 Bisection</h3>
<p>二分法是最简单的解法，这个算法只有很简单的几个步骤。</p>
<ol>
<li>先猜两个值a,b，是的 f(a)*f(b) 小于0。</li>
<li>令 c=(a+b)/2 ，如果 f© = 0 ，就找到了一个正解，工作完成。</li>
<li>f© 不为0时，如果f(a), f© 异号，则以a,c 为新的起点。f(b) f© 同理。</li>
</ol>
<p>程序实现如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">! 二分法求解</span></span><br><span class="line"><span class="comment">! by pon 1997/9/2</span></span><br><span class="line"><span class="keyword">module</span> Numerical</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>, <span class="keyword">parameter</span> :: zero = <span class="number">0.00001</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> bisect(a,b)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> a,b <span class="comment">! 输入的猜值</span></span><br><span class="line">        <span class="keyword">real</span> c   <span class="comment">! 用来计算 (a+b)/2</span></span><br><span class="line">        <span class="keyword">real</span> fa  <span class="comment">! 记录f(a)</span></span><br><span class="line">        <span class="keyword">real</span> fb  <span class="comment">! 记录f(b)</span></span><br><span class="line">        <span class="keyword">real</span> fc  <span class="comment">! 记录f(c)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">!先求c,f(c)的值</span></span><br><span class="line">        c = (a+b)/<span class="number">2.0</span></span><br><span class="line">        fc = func(c)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">!abs(f(c)) 小于 zero 时，就视 f(c) = 0，结束循环</span></span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(<span class="built_in">abs</span>(fc)&gt;zero)</span><br><span class="line">            fa = func(a)</span><br><span class="line">            fb = func(b)</span><br><span class="line">            <span class="keyword">if</span> (fa*fc &lt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">                <span class="comment">!以 a,c 值为新的区间</span></span><br><span class="line">                b=c</span><br><span class="line">                c=(a+b)/<span class="number">2.0</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">!不然就是以 b,c 值为新的区间</span></span><br><span class="line">                a=c</span><br><span class="line">                c=(a+b)/<span class="number">2.0</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">            <span class="comment">!求出新的 fc 值</span></span><br><span class="line">            fc = func(c)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        bisect = c</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">!求解用的函数</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> func(x)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> x</span><br><span class="line">        func = (x+<span class="number">3</span>)*(x-<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> numerical</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> a,b <span class="comment">!两个猜值</span></span><br><span class="line">    <span class="keyword">real</span> ans <span class="comment">!算出的值</span></span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;输入两个猜测值&quot;</span></span><br><span class="line">        read(*,*) a,b</span><br><span class="line">        <span class="comment">!f(a)*f(b) &lt; 0 才是有效的猜测值</span></span><br><span class="line">        <span class="keyword">if</span>(func(a)*func(b) &lt; <span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;不正确的猜值&quot;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment">!调用二分法求根的函数</span></span><br><span class="line">    ans = bisect(a,b)</span><br><span class="line">    <span class="comment">!显示结果</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;x=&#x27;,f6.3)&quot;</span>) ans</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 输入两个猜测值</span><br><span class="line">2 100</span><br><span class="line">x&#x3D; 3.000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的实例程序有一个最大的缺点，那就是想要求解的函数已经被固定，即 f(x) = (x+3)*(x-3)。如果程序代码中还要计算其他函数时，最好使用下面的方法：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">! 二分法求解</span></span><br><span class="line"><span class="comment">! by pon 1997/9/2</span></span><br><span class="line"><span class="keyword">module</span> Numerical</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>, <span class="keyword">parameter</span> :: zero = <span class="number">0.00001</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> bisect(a,b,func)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> a,b <span class="comment">! 输入的猜值</span></span><br><span class="line">        <span class="keyword">real</span> c   <span class="comment">! 用来计算 (a+b)/2</span></span><br><span class="line">        <span class="keyword">real</span> fa  <span class="comment">! 记录f(a)</span></span><br><span class="line">        <span class="keyword">real</span> fb  <span class="comment">! 记录f(b)</span></span><br><span class="line">        <span class="keyword">real</span> fc  <span class="comment">! 记录f(c)</span></span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">external</span> :: func <span class="comment">! 所要求解的函数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">!先求c,f(c)的值</span></span><br><span class="line">        c = (a+b)/<span class="number">2.0</span></span><br><span class="line">        fc = func(c)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">!abs(f(c)) 小于 zero 时，就视 f(c) = 0，结束循环</span></span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(<span class="built_in">abs</span>(fc)&gt;zero)</span><br><span class="line">            fa = func(a)</span><br><span class="line">            fb = func(b)</span><br><span class="line">            <span class="keyword">if</span> (fa*fc &lt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">                <span class="comment">!以 a,c 值为新的区间</span></span><br><span class="line">                b=c</span><br><span class="line">                c=(a+b)/<span class="number">2.0</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">!不然就是以 b,c 值为新的区间</span></span><br><span class="line">                a=c</span><br><span class="line">                c=(a+b)/<span class="number">2.0</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">            <span class="comment">!求出新的 fc 值</span></span><br><span class="line">            fc = func(c)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        bisect = c</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">!求解用的函数1</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> f1(x)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> x</span><br><span class="line">        f1 = (x+<span class="number">3</span>)*(x-<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="comment">!求解用的函数2</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> f2(x)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> x</span><br><span class="line">        f2 = (x+<span class="number">4</span>)*(x-<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> numerical</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> a,b <span class="comment">!两个猜值</span></span><br><span class="line">    <span class="keyword">real</span> ans <span class="comment">!算出的值</span></span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;输入两个猜测值&quot;</span></span><br><span class="line">        read(*,*) a,b</span><br><span class="line">        <span class="comment">!f(a)*f(b) &lt; 0 才是有效的猜测值</span></span><br><span class="line">        <span class="keyword">if</span>(f1(a)*f1(b) &lt; <span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;不正确的猜值&quot;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment">!调用二分法求根的函数</span></span><br><span class="line">    ans = bisect(a,b,f1)</span><br><span class="line">    <span class="comment">!显示结果</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;x=&#x27;,f6.3)&quot;</span>) ans</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;输入两个猜测值&quot;</span></span><br><span class="line">        read(*,*) a,b</span><br><span class="line">        <span class="comment">!f(a)*f(b) &lt; 0 才是有效的猜测值</span></span><br><span class="line">        <span class="keyword">if</span>(f2(a)*f2(b) &lt; <span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;不正确的猜值&quot;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment">!调用二分法求根的函数</span></span><br><span class="line">    ans = bisect(a,b,f2)</span><br><span class="line">    <span class="comment">!显示结果</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;x=&#x27;,f6.3)&quot;</span>) ans</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 输入两个猜测值</span><br><span class="line">2 100</span><br><span class="line">x&#x3D; 3.000</span><br><span class="line"> 输入两个猜测值</span><br><span class="line">2 100</span><br><span class="line">x&#x3D; 5.000</span><br></pre></td></tr></table></figure>
<p>这个程序的做法，是把函数当作参数传到 bisect 函数中，函数 bisect 可以用来求解任何输入的函数。 ans = bisect(a,b,f1) 时会求解 f1 函数， ans = bisect(a,b,f2) 时则会求解 f2 函数。</p>
<h3 id="14-1-2-割线法-Secant">14-1-2 割线法 Secant</h3>
<p>现在介绍如何使用割线法，这个方法很适合使用图形来解释，它主要是利用线段来逼近结果，过程如下</p>
<ol>
<li>先选出两个猜测值 a,b</li>
<li>画一条通过 (a, f(a)) (b, f(b)) 这两点的直线，令这条指向与x轴的交点为 c 。检查f© 是否等于0</li>
<li>f© 不为0时，令 b,c 值为新的两个猜值值，回到上一步骤继续。</li>
</ol>
<p>所得到新的猜想 b, c 会比原本的 a, b 更接近答案，一步一步做下去就可以得到 f© = 0 的结果。</p>
<p>程序实现如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> NUMERICAL</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>, <span class="keyword">parameter</span> :: zero = <span class="number">0.00001</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> secant(a,b,f)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: a,b <span class="comment">!起始的两个猜值</span></span><br><span class="line">        <span class="keyword">real</span> :: c   <span class="comment">!新的解</span></span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">external</span> :: f <span class="comment">!输入的求解函数</span></span><br><span class="line">        <span class="keyword">real</span> :: fa,fb,fc <span class="comment">!记录函数结果</span></span><br><span class="line">        </span><br><span class="line">        fa=f(a)</span><br><span class="line">        fb=f(b)</span><br><span class="line">        c = a-fa*(b-a)/(fb-fa)</span><br><span class="line">        fc=f(c)</span><br><span class="line">        <span class="comment">!在趋近于0之前要一直做逼近的工作</span></span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(<span class="built_in">abs</span>(fc) &gt; zero)</span><br><span class="line">            a = b</span><br><span class="line">            b = c</span><br><span class="line">            fa=f(a)</span><br><span class="line">            fb=f(b)</span><br><span class="line">            c = a-fa*(b-a)/(fb-fa)</span><br><span class="line">            fc=f(c)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        secant = c</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> func(x)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: x</span><br><span class="line">        func = <span class="built_in">sin</span>(x)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> NUMERICAL</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> :: a,b <span class="comment">!起始猜值</span></span><br><span class="line">    <span class="keyword">real</span> :: ans</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;输入两个猜值&quot;</span></span><br><span class="line">    read(*,*) a,b</span><br><span class="line">    <span class="comment">! 输入起始猜值及求值的函数</span></span><br><span class="line">    ans = secant(a,b,func)</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;x=&#x27;,f8.4)&quot;</span>) ans</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>请注意，<strong>割线法并不一定保证会找到解</strong>。也有可能 c 值会越来越偏理答案。</p>
<p>比如，实例程序的执行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 输入两个猜值</span><br><span class="line">50 100</span><br><span class="line">x&#x3D;     NaN</span><br></pre></td></tr></table></figure>
<h3 id="14-1-3-牛顿法">14-1-3 牛顿法</h3>
<p>牛顿法也是利用线段来逼近结果，计算过程如下：</p>
<ol>
<li>先做一个猜想 a</li>
<li>以 f’(a) 为斜率，经过 (a, f(a)) 作一条直线，令这条直线与x轴的交点为b。检查 f(b) 是否为0。</li>
<li>f(b) 不为0时，重新令 b 为新的猜值，重复。</li>
</ol>
<p><strong>若初始猜值 a 取的好，f(b) 应该会越来越接近0</strong>。</p>
<p>程序如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> NUMERICAL </span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>, <span class="keyword">parameter</span> :: zero = <span class="number">0.00001</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> newton(a,f,df)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: a <span class="comment">!猜值</span></span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">external</span> :: f <span class="comment">!求值函数</span></span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">external</span> :: df <span class="comment">! f&#x27;(x)的函数</span></span><br><span class="line">        <span class="keyword">real</span> :: b <span class="comment">!解</span></span><br><span class="line">        <span class="keyword">real</span> :: fb</span><br><span class="line">        </span><br><span class="line">        b = a-f(a)/df(a)</span><br><span class="line">        fb = f(b)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(<span class="built_in">abs</span>(fb) &gt; zero)</span><br><span class="line">            a = b</span><br><span class="line">            b = a-f(a)/df(a)</span><br><span class="line">            fb = f(b)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        newton = b</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="comment">!求值的函数</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> func(x)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: x</span><br><span class="line">        func = <span class="built_in">sin</span>(x)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">!f&#x27;(x)</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> dfunc(x)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: x</span><br><span class="line">        dfunc = <span class="built_in">cos</span>(x)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> numerical</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> :: a <span class="comment">!猜值</span></span><br><span class="line">    <span class="keyword">real</span> :: ans <span class="comment">!解</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;输入起始猜值&quot;</span></span><br><span class="line">    read(*,*) a</span><br><span class="line">    ans = newton(a,func,dfunc)</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;x=&#x27;,f8.4)&quot;</span>) ans</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 输入起始猜值</span><br><span class="line"><span class="number">1</span></span><br><span class="line">x=  <span class="number">0.0000</span></span><br></pre></td></tr></table></figure>
<p>使用牛顿法时，如果猜值给的不好，会永远无法逼近结果。实际使用时，应该要检查 f(b) 是否向0逼近。</p>
<h2 id="14-2-线性代数">14-2 线性代数</h2>
<p>学习线性代数的数值方法，就是在学习矩阵的应用。二维数组经常被当成矩阵来使用。</p>
<h3 id="14-2-1-矩阵的加、减、乘法">14-2-1 矩阵的加、减、乘法</h3>
<p>矩阵的加减法其实不需要介绍，因为它只是很单纯地把矩阵中相同坐标位置地数字相加、减而已。Fortran 90 可以直接对整个数组来做计算，所以可以用一个命令就完成矩阵的加减法。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">real</span> a(m,n), b(m,n), c(m,n)</span><br><span class="line">c = a + b <span class="comment">! 矩阵加法完成</span></span><br><span class="line">c = a - b <span class="comment">! 矩阵减法完成</span></span><br></pre></td></tr></table></figure>
<h3 id="14-2-2-三角矩阵">14-2-2 三角矩阵</h3>
<p>这一节和大家介绍如何经过矩阵中的两行数字相减，把矩阵换算成上三角矩阵和下三角矩阵。</p>
<p>使用程序来解决这个问题的方法，和用手计算的过程是一样的，同样是把某一行乘上一个系数之后和另外一行相减。做上三角矩阵时，就先把第1行的第1列以下的元素数值都清为0。再把第2行第2列以下的数值都清为0，…… 如此一直做到 N-1 行为止。</p>
<p>下面是实例程序：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> LinearAlgebra</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">!输出矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> output(matrix)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: m,n</span><br><span class="line">        <span class="keyword">real</span> :: matrix(:,:)</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        <span class="keyword">character</span>(len=<span class="number">20</span>) :: for=<span class="string">&#x27;(??(1x,f6.3))&#x27;</span></span><br><span class="line">        m = <span class="built_in">size</span>(matrix,<span class="number">1</span>)</span><br><span class="line">        n = <span class="built_in">size</span>(matrix,<span class="number">2</span>)</span><br><span class="line">        <span class="comment">!用字符串来设置输出格式</span></span><br><span class="line">        <span class="built_in">write</span>(for(<span class="number">2</span>:<span class="number">3</span>), <span class="string">&#x27;(i2)&#x27;</span>) N</span><br><span class="line">        <span class="keyword">do</span> i = <span class="number">1</span>,n</span><br><span class="line">            <span class="built_in">write</span>(*, <span class="keyword">fmt</span>=for) matrix(i,:)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!求上三角矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Upper(matrix)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: matrix(:,:)</span><br><span class="line">        <span class="keyword">integer</span> :: m,n</span><br><span class="line">        <span class="keyword">integer</span> :: i,j</span><br><span class="line">        <span class="keyword">real</span> :: e</span><br><span class="line">        m = <span class="built_in">size</span>(matrix,<span class="number">1</span>)</span><br><span class="line">        n = <span class="built_in">size</span>(matrix,<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">do</span> j=i+<span class="number">1</span>, m</span><br><span class="line">                e = matrix(j,i)/matrix(i,i)</span><br><span class="line">                <span class="comment">!用90的功能可以少一层xunhuan</span></span><br><span class="line">                matrix(j,i:m) = matrix(j,i:m)-matrix(i,i:m)*e</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!求下三角矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Lower(matrix)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: matrix(:,:)</span><br><span class="line">        <span class="keyword">integer</span> :: m,n</span><br><span class="line">        <span class="keyword">integer</span> :: i,j</span><br><span class="line">        <span class="keyword">real</span> :: e</span><br><span class="line">        m = <span class="built_in">size</span>(matrix,<span class="number">1</span>)</span><br><span class="line">        n = <span class="built_in">size</span>(matrix,<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">do</span> i=n,<span class="number">2</span>,-<span class="number">1</span></span><br><span class="line">            <span class="keyword">do</span> j=i-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span></span><br><span class="line">                e = matrix(j,i)/matrix(i,i)</span><br><span class="line">                <span class="comment">!用90的功能可以少一层xunhuan</span></span><br><span class="line">                matrix(j,<span class="number">1</span>:i) = matrix(j,<span class="number">1</span>:i)-matrix(i,<span class="number">1</span>:i)*e</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> LinearAlgebra</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n = <span class="number">3</span> <span class="comment">!矩阵大小</span></span><br><span class="line">    <span class="keyword">real</span> :: A(n,n) = <span class="built_in">reshape</span>((/<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>/),(/n,n/))</span><br><span class="line">    <span class="keyword">real</span> :: B(n,n)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Matrix A:&quot;</span></span><br><span class="line">    <span class="keyword">call</span> output(A)</span><br><span class="line">    B=A</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Upper:&quot;</span></span><br><span class="line">    <span class="keyword">call</span> Upper(B)</span><br><span class="line">    <span class="keyword">call</span> output(B)</span><br><span class="line">    B=A</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Lower:&quot;</span></span><br><span class="line">    <span class="keyword">call</span> Lower(B)</span><br><span class="line">    <span class="keyword">call</span> output(B)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Matrix A:</span><br><span class="line"> 1.000  3.000  2.000</span><br><span class="line"> 2.000  2.000  3.000</span><br><span class="line"> 1.000  3.000  4.000</span><br><span class="line">Upper:</span><br><span class="line"> 1.000  3.000  2.000</span><br><span class="line"> 0.000 -4.000 -1.000</span><br><span class="line"> 0.000  0.000  2.000</span><br><span class="line">Lower:</span><br><span class="line"> 8.000  0.000  0.000</span><br><span class="line"> 1.250 -0.250  0.000</span><br><span class="line"> 1.000  3.000  4.000</span><br></pre></td></tr></table></figure>
<p>为什么要先学习做上、下三角矩阵的办法呢？因为这个方法可以应用在很多地方，例如应用在用 Determinant, Gauss-Jordan 法求解联立式、求逆矩阵等等。</p>
<p>在这个程序中，传递数组时用了特殊方法。以函数 output 为例，声明数组时没有赋值大小。使用这个方法传递数组时，可以免去传递数组大小。库存函数 size 可以查询出数组的实际大小。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">real</span> :: matrix(:,:)</span><br></pre></td></tr></table></figure>
<h3 id="14-2-3-Determinant-矩阵的值">14-2-3 Determinant 矩阵的值</h3>
<p>求矩阵行列式值的方法很简单，把矩阵用上一个小节中的方法转换成上三角形或下三角矩阵后，把对角线的数值全部乘起来就是答案了。</p>
<p>下面是程序。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> LinearAlgebra</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">!求矩阵的Determinant值</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Determinant(matrix)</span><br><span class="line">        <span class="keyword">real</span> :: matrix(:,:)</span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">allocatable</span> :: ma(:,:)</span><br><span class="line">        <span class="keyword">integer</span> :: i,n</span><br><span class="line">        n = <span class="built_in">size</span>(matrix,<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">allocate</span>(ma(n,n))</span><br><span class="line">        ma = matrix</span><br><span class="line">        <span class="keyword">call</span> Upper(ma)</span><br><span class="line">        Determinant = <span class="number">1.0</span></span><br><span class="line">        <span class="keyword">do</span> i = <span class="number">1</span>,n</span><br><span class="line">            Determinant = Determinant * ma(i,i)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="comment">!求上三角矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Upper(matrix)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: matrix(:,:)</span><br><span class="line">        <span class="keyword">integer</span> :: m,n</span><br><span class="line">        <span class="keyword">integer</span> :: i,j</span><br><span class="line">        <span class="keyword">real</span> :: e</span><br><span class="line">        m = <span class="built_in">size</span>(matrix,<span class="number">1</span>)</span><br><span class="line">        n = <span class="built_in">size</span>(matrix,<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">do</span> j=i+<span class="number">1</span>, m</span><br><span class="line">                e = matrix(j,i)/matrix(i,i)</span><br><span class="line">                <span class="comment">!用90的功能可以少一层xunhuan</span></span><br><span class="line">                matrix(j,i:m) = matrix(j,i:m)-matrix(i,i:m)*e</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> LinearAlgebra</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n=<span class="number">3</span></span><br><span class="line">    <span class="keyword">real</span> :: A(n,n) = <span class="built_in">reshape</span>((/<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>/),(/n,n/))</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;det(A)=&#x27;,f6.2)&quot;</span>) Determinant(A)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">det(A)&#x3D; -8.00</span><br></pre></td></tr></table></figure>
<h3 id="14-2-4-Gauss-Jordan-法求联立方程式">14-2-4 Gauss-Jordan 法求联立方程式</h3>
<p>对于 <code>A*x=b</code> 的方程式，可以用 Gauss-Jordan 法来求解。唯一的差别在于矩阵后方又要夹带数组 b 来做为等号后面的数值。矩阵的每一行在互相加减时，数组 b 也要跟着一起做加减。（这句话的意思，直接把A矩阵转换成上/下三角矩阵即可，就直接得到了x的解。但是做加减的时候数组b要跟着变化。）。</p>
<p>高斯消去法：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%B6%88%E5%8E%BB%E6%B3%95">https://zh.wikipedia.org/wiki/高斯消去法</a></p>
<p>来看代码</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> LinearAlgebra</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">! Gauss_Jordan 法</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Gauss_Jordan(A,S,ANS)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: A(:,:) <span class="comment">!左手项</span></span><br><span class="line">        <span class="keyword">real</span> :: S(:)   <span class="comment">!右手项</span></span><br><span class="line">        <span class="keyword">real</span> :: ANS(:) <span class="comment">!结果文件</span></span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">allocatable</span> :: B(:,:)</span><br><span class="line">        <span class="keyword">integer</span> :: i,n</span><br><span class="line">        n = <span class="built_in">size</span>(A,<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">allocate</span>(B(N,N))</span><br><span class="line">        <span class="comment">! 保存原先的矩阵A及数组S</span></span><br><span class="line">        B=A</span><br><span class="line">        ANS=S</span><br><span class="line">        <span class="comment">! 把B化成对角线矩阵（除了对角线外，都为0）</span></span><br><span class="line">        <span class="keyword">call</span> Upper(B,ANS,N) <span class="comment">!先把B化成上三角矩阵</span></span><br><span class="line">        <span class="keyword">call</span> Lower(B,ANS,N) <span class="comment">!先把B化成下三角矩阵</span></span><br><span class="line">        <span class="comment">! 求解</span></span><br><span class="line">        <span class="keyword">forall</span>(i=<span class="number">1</span>:n)</span><br><span class="line">            ANS(i) = ANS(i)/B(i,i)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!输出等式</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> output(M,S)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: M(:,:), S(:)</span><br><span class="line">        <span class="keyword">integer</span> :: n,i,j</span><br><span class="line">        n = <span class="built_in">size</span>(M,<span class="number">1</span>)</span><br><span class="line">        <span class="comment">! write中加上advance=&quot;no&quot;，可以终止断行发生，使下一次的</span></span><br><span class="line">        <span class="comment">! write接续在同一行当中</span></span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(1x,f5.2,a1)&quot;</span>, <span class="keyword">advance</span>=<span class="string">&quot;NO&quot;</span>) M(i,<span class="number">1</span>), <span class="string">&#x27;A&#x27;</span></span><br><span class="line">            <span class="keyword">do</span> j=<span class="number">2</span>,n</span><br><span class="line">                <span class="keyword">if</span> (M(i,j) &lt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">                    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;-&#x27;,f5.2,a1)&quot;</span>, <span class="keyword">advance</span>=<span class="string">&quot;NO&quot;</span>) -M(i,j),<span class="built_in">char</span>(<span class="number">64</span>+j)</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;+&#x27;,f5.2,a1)&quot;</span>, <span class="keyword">advance</span>=<span class="string">&quot;NO&quot;</span>) M(i,j),<span class="built_in">char</span>(<span class="number">64</span>+j)</span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;=&#x27;,f8.4)&quot;</span>) S(i)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!求上三角矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Upper(M,S,n)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: n</span><br><span class="line">        <span class="keyword">real</span> :: M(n,n)</span><br><span class="line">        <span class="keyword">real</span> :: S(n)</span><br><span class="line">        <span class="keyword">integer</span> :: i,j</span><br><span class="line">        <span class="keyword">real</span> :: e</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">do</span> j=i+<span class="number">1</span>, n</span><br><span class="line">                e = M(j,i)/M(i,i)</span><br><span class="line">                M(j,i:n) = M(j,i:n)-M(i,i:n)*e</span><br><span class="line">                S(j) = S(j) - S(i)*e <span class="comment">!右手项要随着左手项变化而变化</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!求下三角矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Lower(M,S,n)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: n</span><br><span class="line">        <span class="keyword">real</span> :: M(n,n)</span><br><span class="line">        <span class="keyword">real</span> :: S(n)</span><br><span class="line">        <span class="keyword">integer</span> :: i,j</span><br><span class="line">        <span class="keyword">real</span> :: e</span><br><span class="line">        <span class="keyword">do</span> i=n,<span class="number">2</span>,-<span class="number">1</span></span><br><span class="line">            <span class="keyword">do</span> j=i-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span></span><br><span class="line">                e = M(j,i)/M(i,i)</span><br><span class="line">                M(j,i:n) = M(j,i:n)-M(i,i:n)*e</span><br><span class="line">                S(j) = S(j) - S(i)*e</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"><span class="comment">! 求解联立式</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> LinearAlgebra</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n =<span class="number">3</span> </span><br><span class="line">    <span class="keyword">real</span> :: A(n,n) = <span class="built_in">reshape</span>((/<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>/),(/n,n/))</span><br><span class="line">    <span class="keyword">real</span> :: S(n) = (/<span class="number">12</span>,<span class="number">15</span>,<span class="number">17</span>/)</span><br><span class="line">    <span class="keyword">real</span> :: ans(n)</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;Equation:&#x27;</span></span><br><span class="line">    <span class="keyword">call</span> output(A,S)</span><br><span class="line">    <span class="keyword">call</span> Gauss_Jordan(A,S,ANS)</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Ans:&quot;</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a1,&#x27;=&#x27;,f8.4)&quot;</span>) <span class="built_in">char</span>(<span class="number">64</span>+i),ans(i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Equation:</span><br><span class="line"> 1.00A+ 4.00B+ 7.00C&#x3D; 12.0000</span><br><span class="line"> 2.00A+ 5.00B+ 8.00C&#x3D; 15.0000</span><br><span class="line"> 3.00A+ 6.00B+ 8.00C&#x3D; 17.0000</span><br><span class="line">Ans:</span><br><span class="line">A&#x3D;  1.0000</span><br><span class="line">B&#x3D;  1.0000</span><br><span class="line">C&#x3D;  1.0000</span><br></pre></td></tr></table></figure>
<p>这个程序通过<strong>先把矩阵转化为上三角矩阵，再转化为下三角矩阵</strong>的方式，得到对角线矩阵。</p>
<p>这里转化为上/下三角矩阵式，右手项要跟着变化。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">M(j,i:n) = M(j,i:n)-M(i,i:n)*e</span><br><span class="line">S(j) = S(j) - S(i)*e <span class="comment">!右手项要随着左手项变化而变化</span></span><br></pre></td></tr></table></figure>
<p>得到的对角线矩阵还不是单位矩阵，需要除以对角线元素的值</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">! 求解</span></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:n)</span><br><span class="line">    ANS(i) = ANS(i)/B(i,i)</span><br></pre></td></tr></table></figure>
<p>最终得到了解。</p>
<h3 id="14-2-5-逆矩阵">14-2-5 逆矩阵</h3>
<p>逆矩阵的算法与上一个小节中使用的方法差不多，在矩阵后面夹带一个单位矩阵，然后把前面那个矩阵处理成对角线矩阵，矩阵每一次的加减运行时，后面夹带的矩阵也要跟着变化。</p>
<p>再把前面的那个矩阵从对角线矩阵转化为单位矩阵，这个时候第二个矩阵就会变成第一个矩阵的逆矩阵。程序的实际方法与使用 Gauss-Jordan 法来求解联立式的方法非常类似。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> LinearAlgebra</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">! 求逆矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> inverse(A,IA)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: A(:,:), IA(:,:)</span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">allocatable</span> :: B(:,:)  </span><br><span class="line">        <span class="keyword">integer</span> :: i,j,n</span><br><span class="line">        n = <span class="built_in">size</span>(A,<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">allocate</span>(B(N,N))</span><br><span class="line">        <span class="comment">! 先把 IA 设置为单位矩阵</span></span><br><span class="line">        <span class="keyword">forall</span>(i=<span class="number">1</span>:n, j=<span class="number">1</span>:n, i==j)IA(i,j)=<span class="number">1.0</span></span><br><span class="line">        <span class="keyword">forall</span>(i=<span class="number">1</span>:n, j=<span class="number">1</span>:n, i/=j)IA(i,j)=<span class="number">0.0</span></span><br><span class="line">        <span class="comment">! 保存原先的矩阵A,使用B来计算</span></span><br><span class="line">        B=A</span><br><span class="line">        <span class="comment">! 把B化成对角线矩阵（除了对角线外，都为0）</span></span><br><span class="line">        <span class="keyword">call</span> Upper(B,IA,N) <span class="comment">!先把B化成上三角矩阵</span></span><br><span class="line">        <span class="keyword">call</span> Lower(B,IA,N) <span class="comment">!再把B化成下三角矩阵</span></span><br><span class="line">        <span class="comment">! 求解</span></span><br><span class="line">        <span class="keyword">forall</span>(i=<span class="number">1</span>:n)</span><br><span class="line">            IA(i,:) = IA(i,:)/B(i,i)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!输出矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> output(matrix)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: matrix(:,:)</span><br><span class="line">        <span class="keyword">integer</span> :: m,n,i</span><br><span class="line">        <span class="keyword">character</span>(len=<span class="number">20</span>) :: for=<span class="string">&#x27;(??(1x,f6.3))&#x27;</span></span><br><span class="line">        m = <span class="built_in">size</span>(matrix,<span class="number">1</span>)</span><br><span class="line">        n = <span class="built_in">size</span>(matrix,<span class="number">2</span>)</span><br><span class="line">        <span class="comment">!用字符串来设置输出格式</span></span><br><span class="line">        <span class="built_in">write</span>(for(<span class="number">2</span>:<span class="number">3</span>), <span class="string">&#x27;(i2)&#x27;</span>) n</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">            <span class="built_in">write</span>(*,<span class="keyword">fmt</span>=for) matrix(i,:)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!求上三角矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Upper(M,S,n)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: n</span><br><span class="line">        <span class="keyword">real</span> :: M(n,n)</span><br><span class="line">        <span class="keyword">real</span> :: S(n)</span><br><span class="line">        <span class="keyword">integer</span> :: i,j</span><br><span class="line">        <span class="keyword">real</span> :: e</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">do</span> j=i+<span class="number">1</span>, n</span><br><span class="line">                e = M(j,i)/M(i,i)</span><br><span class="line">                M(j,i:n) = M(j,i:n)-M(i,i:n)*e</span><br><span class="line">                S(j) = S(j) - S(i)*e <span class="comment">!右手项要随着左手项变化而变化</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!求下三角矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Lower(M,S,n)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: n</span><br><span class="line">        <span class="keyword">real</span> :: M(n,n)</span><br><span class="line">        <span class="keyword">real</span> :: S(n)</span><br><span class="line">        <span class="keyword">integer</span> :: i,j</span><br><span class="line">        <span class="keyword">real</span> :: e</span><br><span class="line">        <span class="keyword">do</span> i=n,<span class="number">2</span>,-<span class="number">1</span></span><br><span class="line">            <span class="keyword">do</span> j=i-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span></span><br><span class="line">                e = M(j,i)/M(i,i)</span><br><span class="line">                M(j,i:n) = M(j,i:n)-M(i,i:n)*e</span><br><span class="line">                S(j) = S(j) - S(i)*e</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"><span class="comment">! 求解联立式</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> LinearAlgebra</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n =<span class="number">3</span> </span><br><span class="line">    <span class="keyword">real</span> :: A(n,n) = <span class="built_in">reshape</span>((/<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>/),(/n,n/))</span><br><span class="line">    <span class="keyword">real</span> :: IA(n,n)</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;原矩阵&#x27;</span></span><br><span class="line">    <span class="keyword">call</span> output(A)</span><br><span class="line">    <span class="keyword">call</span> inverse(A,IA)</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;逆矩阵&quot;</span></span><br><span class="line">    <span class="keyword">call</span> output(IA)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">原矩阵</span><br><span class="line"> 1.000  4.000  7.000</span><br><span class="line"> 2.000  5.000  8.000</span><br><span class="line"> 3.000  6.000  8.000</span><br><span class="line">逆矩阵</span><br><span class="line">-2.667  0.000  0.000</span><br><span class="line"> 2.667 -0.333 -0.000</span><br><span class="line">-1.000 -0.000 -1.000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="14-2-6-对角矩阵的运行">14-2-6 对角矩阵的运行</h3>
<p>所谓的对角矩阵，就是类似下面的情况：只有靠近对角线位置上2个相邻的位置有数值，其他位置为0。</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%0A%20%5Cbegin%7Bmatrix%7D%0A%20%20%202%20%26%203%20%26%200%20%26%200%20%26%200%20%5C%5C%0A%20%20%200%20%26%202%20%26%203%20%26%200%20%26%200%20%5C%5C%0A%20%20%200%20%26%200%20%26%202%20%26%203%20%26%200%20%5C%5C%0A%20%20%200%20%26%200%20%26%200%20%26%202%20%26%203%0A%20%20%5Cend%7Bmatrix%7D%0A%20%20%5Cright%5D%0A" /></p><p>利用这个特性来保存矩阵，可以节省很多空间。原本 N×N 大小的矩阵需要 N×N  的数组来保存，不过如果要保存想上例中的二对角矩阵，只要用N×2大小的数组就足够了，因为只需要记录有数值的部分就行了，数字为0的部分不需要另辟空间来做记录。</p>
<p>使用这个数据结构来操作矩阵时，与前几个小节的方法比较起来当然是会有一些不同，来看看求解联立方程式要如何运行。</p>
<p>在此同样使用 Gauss-Jordan 法来解联立方程式。事实上，用对角矩阵会比较简单。因为已经知道矩阵哪些低分为0，这些地方在把矩阵对角线化的时候可以不再去理会。简化后的结果，在每一个循环中，只要把矩阵相邻两行来互相加减就够了，不需要把每一行都拿来操作，可以节省大量的运算。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">!三对角阵求解</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main </span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: Width = <span class="number">3</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: Row = <span class="number">5</span> <span class="comment">! size of Matrix</span></span><br><span class="line">    <span class="keyword">real</span> :: A(row, width)=<span class="built_in">reshape</span>((/<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,&amp;</span><br><span class="line">                        <span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,&amp;</span><br><span class="line">                        <span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">0</span>/),(/row,width/))</span><br><span class="line">    <span class="keyword">real</span> :: S(row)=(/<span class="number">3</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">10</span>,<span class="number">3</span>/)</span><br><span class="line">    <span class="keyword">real</span> :: ans(row)</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="comment">! equation:</span></span><br><span class="line">    <span class="comment">! a+2b=3</span></span><br><span class="line">    <span class="comment">! 2b+3c+4d=9</span></span><br><span class="line">    <span class="comment">! 3c+4d+5e=12</span></span><br><span class="line">    <span class="comment">! 4d+5e+f=10</span></span><br><span class="line">    <span class="comment">! e+2f=3</span></span><br><span class="line">    <span class="keyword">call</span> Gauss_Jordan(A,S,ANS,row,width)</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;Ans:&#x27;</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,row</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a1,&#x27;=&#x27;,f8.4)&quot;</span>) <span class="built_in">char</span>(<span class="number">96</span>+i),ANS(i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">! Gauss_Jordan 法的函数</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Gauss_Jordan(A,S,ANS,row,width)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: row, width</span><br><span class="line">    <span class="keyword">real</span> :: A(row, width)</span><br><span class="line">    <span class="keyword">real</span> :: S(row)</span><br><span class="line">    <span class="keyword">real</span> :: ANS(row)</span><br><span class="line">    <span class="keyword">real</span> :: B(row, width)</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 保存原先的矩阵A及数组S</span></span><br><span class="line">    B=A</span><br><span class="line">    ANS=S</span><br><span class="line">    <span class="comment">! 把B化为对角线矩阵</span></span><br><span class="line">    <span class="keyword">call</span> Upper(B,ANS,row,width) <span class="comment">! 先把B化成上三角矩阵</span></span><br><span class="line">    <span class="keyword">call</span> Lower(B,ANS,row,width) <span class="comment">! 再把B化成下三角矩阵</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 求出解</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,row</span><br><span class="line">        ANS(i) = ANS(i)/B(i,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="comment">! 求上三角矩阵的子程序</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Upper(M,S,row,width)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: row, width</span><br><span class="line">    <span class="keyword">real</span> :: M(row,width)</span><br><span class="line">    <span class="keyword">real</span> :: S(row)</span><br><span class="line">    <span class="keyword">integer</span> :: i,j</span><br><span class="line">    <span class="keyword">real</span> :: e</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>, row-<span class="number">1</span></span><br><span class="line">            j=i+<span class="number">1</span></span><br><span class="line">            e = M(j,<span class="number">1</span>)/M(i,<span class="number">2</span>)</span><br><span class="line">            M(j,<span class="number">1</span>:<span class="number">2</span>) = M(j,<span class="number">1</span>:<span class="number">2</span>)-M(i,<span class="number">2</span>:<span class="number">3</span>)*e</span><br><span class="line">            S(j) = S(j) - S(i)*e <span class="comment">!右手项要随着左手项变化而变化</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="comment">!求下三角矩阵的子程序</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Lower(M,S,row,width)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: row, width</span><br><span class="line">    <span class="keyword">real</span> :: M(row,width)</span><br><span class="line">    <span class="keyword">real</span> :: S(row)</span><br><span class="line">    <span class="keyword">integer</span> :: i,j</span><br><span class="line">    <span class="keyword">real</span> :: e</span><br><span class="line">    <span class="keyword">do</span> i=row,<span class="number">2</span>,-<span class="number">1</span></span><br><span class="line">            j=i-<span class="number">1</span></span><br><span class="line">            e = M(j,<span class="number">3</span>)/M(i,<span class="number">2</span>)</span><br><span class="line">            M(j,<span class="number">3</span>) = M(j,<span class="number">3</span>)-M(i,<span class="number">2</span>)*e</span><br><span class="line">            S(j) = S(j) - S(i)*e</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br></pre></td></tr></table></figure>
<p>这个在书上的代码有好几处 bug ，这里是我改过来，能跑通的。但是这个代码我没看懂，而且这里不是自动化的，是只适用他这里的”三对角矩阵“。</p>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ans:</span><br><span class="line">a&#x3D;  1.0000</span><br><span class="line">b&#x3D;  1.0000</span><br><span class="line">c&#x3D;  1.0000</span><br><span class="line">d&#x3D;  1.0000</span><br><span class="line">e&#x3D;  1.0000</span><br></pre></td></tr></table></figure>
<h2 id="14-3-积分">14-3 积分</h2>
<p>做积分的最好方法，当然是先求出积分函数再来求解。<strong>用数值方法来做积分，主要是应用在函数不存在时</strong>。从实验中得到的一连串数据，应该是没有办法刚好适用某一个函数来表示它，要对这一串数据做积分时，只能使用其他算法来做。一般最常见的方法是使用各种已知面积的小图形来填充这些区域，在经过计算这些图形的面积总和来逼近答案。</p>
<h3 id="14-3-1-梯形法积分">14-3-1 梯形法积分</h3>
<p>梯形法做积分的原理很简单，把所需积分的图形，用许多个小梯形方块来将它们填满。实现的程序如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Integral</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>, <span class="keyword">parameter</span> :: pi = <span class="number">3.14159</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">!生成数列</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> GenerateData(datas, width, func)</span><br><span class="line">        <span class="keyword">real</span> datas(:), width</span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">external</span> :: func</span><br><span class="line">        <span class="keyword">real</span> r</span><br><span class="line">        <span class="keyword">integer</span> i, n</span><br><span class="line">        n = <span class="built_in">size</span>(datas,<span class="number">1</span>)</span><br><span class="line">        width = pi/(n-<span class="number">1</span>)</span><br><span class="line">        r = <span class="number">0</span></span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">            datas(i) = func(r)</span><br><span class="line">            r = r + width</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!梯形积分法</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Trape_Integral(datas, width)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> datas(:)</span><br><span class="line">        <span class="keyword">real</span> width <span class="comment">!每条数据的间隔</span></span><br><span class="line">        <span class="keyword">real</span> <span class="built_in">sum</span> <span class="comment">!计算所有上底加下底除以二的和</span></span><br><span class="line">        <span class="keyword">integer</span> i,n</span><br><span class="line">        n = <span class="built_in">size</span>(datas,<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">sum</span> = (datas(<span class="number">1</span>)+datas(n))/<span class="number">2.0</span></span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">2</span>,n-<span class="number">1</span></span><br><span class="line">            <span class="built_in">sum</span> = <span class="built_in">sum</span>+datas(i) <span class="comment">!累加边长</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        Trape_Integral = <span class="built_in">sum</span>*width <span class="comment">!计算面积和</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="comment">! 梯形法积分范例</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> Integral</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: N = <span class="number">10</span></span><br><span class="line">    <span class="keyword">real</span> DATAS(n), width</span><br><span class="line">    <span class="keyword">real</span> ANS <span class="comment">!答案</span></span><br><span class="line">    <span class="keyword">real</span>, <span class="keyword">intrinsic</span> :: <span class="built_in">sin</span> <span class="comment">!仿真用来生成数据的函数</span></span><br><span class="line">    <span class="keyword">call</span> GenerateData(DATAS, width, <span class="built_in">sin</span>) </span><br><span class="line">    ANS = Trape_Integral(DATAS, width) <span class="comment">!计算积分</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;ans=&#x27;,f5.2)&quot;</span>) ANS <span class="comment">!显示答案</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line">            </span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ans&#x3D; 1.98</span><br></pre></td></tr></table></figure>
<p>积分的数据是使用 sin 函数所生成的一长串数值，使用计算机来计算积分时，通常都是面对一串数字来做计算，而不是直接面对一个数学函数。子程序 GenerateData 的作用就是用来生成一串数字来做积分计算，所生成的是X值范围在0~Π之间的sin(x) ，积分的结果应该是2。</p>
<p>他这里求 sum（所有上底加下底除以二的和） 的时候，由于第一个梯形的上底和最后一个梯形的下底只用了一次，因此该除以2；至于中间的函数值，都是既作为一个梯形的上底，又作为另一个梯形的下底，因此乘2除2正好抵消。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span> = (datas(<span class="number">1</span>)+datas(n))/<span class="number">2.0</span> <span class="comment">!第一个梯形的上底和最后一个梯形的下底</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">2</span>,n-<span class="number">1</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span>+datas(i) <span class="comment">!累加边长，其他</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<h3 id="14-3-2-simpson-辛普森法积分">14-3-2 simpson 辛普森法积分</h3>
<p>辛普森法的原理，是把函数图形使用很多段的二次曲线来近似图形，再计算这些二次曲线形成的面积。使用辛普森法有一个限制，一定要有奇数个数据才能计算，因为每一条二次权限都要从数据中取3个点。每一条二次曲线的积分公式如下</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(x) 积分 = （f0 + <span class="number">4</span>*f1 + f2) * h/<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>把每一段二次曲线累加起来，就可以得到整个辛普森法积分的公式：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(x) 积分 = （f0 + <span class="number">4</span>*f1 + <span class="number">2</span>*f2 + <span class="number">4</span>*f3 + <span class="number">2</span>*f4…… + <span class="number">4</span>*fn-<span class="number">1</span> + fn) * h/<span class="number">3</span> </span><br></pre></td></tr></table></figure>
<p>ok, 我压根不知道这是啥，pass</p>
<p>代码略。</p>
<h2 id="14-4-插值法与曲线近似">14-4 插值法与曲线近似</h2>
<p>插值法与曲线近似其实是同样的一个课题，曲线近似的目的经常就是为了要做插值。插值法的应用很频繁，在实验室中，可以使用插值法来利用有限的已知数据点来预测未知的状态。</p>
<h3 id="14-4-1-Lagrange-Interpolation-多项式插值法">14-4-1 Lagrange Interpolation 多项式插值法</h3>
<p>使用多项式来做插值，会经过所获得的 N 个数据点，生成最高项为 N-1 的多项式，这个多项式函数图形会经过这 N 个数据点。Lagrange Interpolation 的公式可以来生成这个多项式。</p>
<p>假设 （X1,Y1),  (X2,Y2) … (Xn, Yn) 为 N 个数据点，经过 Lagrange Interpolation 法所生成通过这 N 个点的多项式函数 g(x) 为：</p>
<p>略</p>
<h3 id="14-4-2-牛顿法-Forward-Interpolation">14-4-2 牛顿法  Forward Interpolation</h3>
<p>看不懂，略。</p>
<h3 id="14-4-3-最小方差法（Least-Square）">14-4-3 最小方差法（Least Square）</h3>
<p>最小方差法是应用在已经可以用理论推得数据的函数形式，而不知道系数数值的时候。因为实验不可能处于完美的情况，所得的数据不可能工整地在函数曲线上，大多都是散步在理论所预测的附近。(这就是最小二乘)</p>
<p>求 N 个点到 Y = aT + b 直线上的距离平方总和。要使距离平方和为最短，可以把上述的式子分别对 a, b 做偏微分，令两式结果为0，并解出 a, b 值即可。联立两式，又可以写成一个新的方程式。（这里我没法把式子列出来，不直观）。</p>
<p>代码略。</p>
<h3 id="14-4-4-曲线近似法（Cubic-Spline）">14-4-4 曲线近似法（Cubic Spline）</h3>
<p>略</p>
<h1>15 数据结构与算法</h1>
<p>这一章所要介绍的课题是数据结构与算法。学会 Fortran 语法，只能算是学会程序设计的皮毛而已。<strong>程序员的能力，主要取决在实现及设计算法的能力，不在于他会使用哪些程序语言</strong>。</p>
<p>数据结构的课题，主要在于讨论如何使用程序语言的基本类型来记录数据的方法。简单的数据结构方法，不需要学习大家就自然会使用，例如使用二维数组来记录矩阵。在前面章节中，已经应用过一些比较复杂的数据结构，例如第10章的串行结构，第14章的对角矩阵等等。</p>
<p>算法是指：”通过编写程序解决问题的方法“。第14章的数值方法中，所介绍的就是各种用来计算数学问题的算法。这一章所要介绍的算法，是在编写每一种程序时，都有可能会使用的基本算法。</p>
<h2 id="15-1-排序">15-1 排序</h2>
<p>”排序“ 的算法很多，在本节会介绍其中的四种。实例程序只范例由小排到大的做法，相信读者应该能自行领会由大排到小的做法。</p>
<h3 id="15-1-1-冒泡排序法（Bubble-Sort）">15-1-1 冒泡排序法（Bubble Sort）</h3>
<p>冒泡排序法是最简单的排序方法之一，它的步骤如下：</p>
<ol>
<li>从第1个数字开始，依序把两个相邻的数值互相比较大小。如果前一个数字比后面一个数字大，就把它们的位置互相交换。</li>
<li>一直做到每一对相邻的数字都比较过后才结束这一轮的工作。</li>
<li>回到第1步，再做下一个循环的比较。如果有 N 个数字要排序，就需要重复 N-1次的扫描工作。</li>
</ol>
<p>第一次扫描，会找出最大的数值，并把它放在数组的最后面。第二次扫描，找出第2大的数值，放在倒数第二个位置……</p>
<p>可以看出，冒泡排序法可以想象成是让重的东西向下沉，轻的东西向上浮。等到状态稳定，就会得到排序结果。下面是冒泡排序法的程序：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">! 冒泡排序法范例</span></span><br><span class="line"><span class="comment">! By perng 1997/8/29</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> bubble_sort_demo</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n = <span class="number">10</span></span><br><span class="line">    <span class="keyword">integer</span> :: a(n) = (/<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>/) <span class="comment">! 待排序的数据</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source=&gt;&#x27;, 10I3)&quot;</span>) a</span><br><span class="line">    <span class="keyword">call</span> Bubble_Sort(a,n) <span class="comment">!调用排序的子程序</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Sort=&gt;&#x27;, 10I3)&quot;</span>) a</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Bubble_Sort(A,N)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: n, a(n)</span><br><span class="line">    <span class="keyword">integer</span> i,j, temp</span><br><span class="line">    <span class="keyword">do</span> i = n-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span> <span class="comment">! 开始做N-1次的扫描</span></span><br><span class="line">        <span class="keyword">do</span> j = <span class="number">1</span>,i  <span class="comment">! 一对一对的比较，i 之后的数字不用比较</span></span><br><span class="line">            <span class="comment">! 如果 A(j) &gt; A(j+1) 就把这两个数值交换</span></span><br><span class="line">            <span class="keyword">if</span> (A(j) &gt; A(j+<span class="number">1</span>)) <span class="keyword">then</span></span><br><span class="line">                temp = a(j)</span><br><span class="line">                a(j) = a(j+<span class="number">1</span>)</span><br><span class="line">                a(j+<span class="number">1</span>) = temp</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Source&#x3D;&gt;  6  2  8  4  0  9  3  5  1  7</span><br><span class="line">Sort&#x3D;&gt;  0  1  2  3  4  5  6  7  8  9</span><br></pre></td></tr></table></figure>
<h3 id="15-1-2-选择排序法（Selection-Sort）">15-1-2 选择排序法（Selection Sort）</h3>
<p>选择排序法的原理很简单，步骤如下：</p>
<ol>
<li>找出全部N个数据中最小的一个，把它和数列的第1个数字交换位置。</li>
<li>找出剩下N-1个数据中最小的一个，把它和数列的第2个数字交换位置。</li>
<li>找出剩下N-2个数据中最小的一个，把它和数列的第3个数字交换位置。</li>
<li>……</li>
<li>一直做到只剩下一个数据为止。</li>
</ol>
<p>选择排序法的过程，就是一步一步地精选出数据中最小的数值，并把它放到所该对应的位置上。需要处理的数据每次会减少一个，一直到只剩下一个数值为止。（这个方法感觉和上一个没啥区别啊）</p>
<p>程序如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">! 选择排序法范例</span></span><br><span class="line"><span class="comment">! By Perng 1997/8/29 </span></span><br><span class="line"><span class="comment">! 果然是一个人发明的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> selection_sort_demo</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n = <span class="number">10</span> </span><br><span class="line">    <span class="keyword">integer</span> :: a(n) = (/<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>/) <span class="comment">! 待排序的数据</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source=&gt;&#x27;, 10I3)&quot;</span>) a</span><br><span class="line">    <span class="keyword">call</span> Selection_Sort(a,n) <span class="comment">!调用排序的子程序</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Sort=&gt;&#x27;, 10I3)&quot;</span>) a</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">!选择排序法的子程序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Selection_Sort(a,n)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: n, a(n)</span><br><span class="line">    <span class="keyword">integer</span> i,j <span class="comment">! 循环计数器</span></span><br><span class="line">    <span class="keyword">integer</span> <span class="built_in">min</span> <span class="comment">! 找出每一轮中的最小值</span></span><br><span class="line">    <span class="keyword">integer</span> temp </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>,n</span><br><span class="line">        <span class="comment">! min = a(i) !暂时令a(i)是最小值 !我感觉这里的min是多余的</span></span><br><span class="line">        <span class="keyword">do</span> j = i+<span class="number">1</span>, n</span><br><span class="line">            <span class="keyword">if</span>(a(i) &gt; a(j)) <span class="keyword">then</span> <span class="comment">! 发现a(i)不是最小</span></span><br><span class="line">                temp = a(j) <span class="comment">!a(i),a(j) 交换</span></span><br><span class="line">                a(j) = a(i)</span><br><span class="line">                a(i) = temp </span><br><span class="line">                <span class="comment">! min = a(i)</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Source&#x3D;&gt;  6  2  8  4  0  9  3  5  1  7</span><br><span class="line">Sort&#x3D;&gt;  0  1  2  3  4  5  6  7  8  9</span><br></pre></td></tr></table></figure>
<p>这里需要注意，书上的代码里 min 这个变量完全是多余的，没有用处。我就删除了，看来作者偶尔也会犯点迷糊。</p>
<h3 id="15-1-3-Shell-排序法">15-1-3 Shell 排序法</h3>
<p>这是 1959 年 D.L.Shell 所发明的排序方法，这个方法和前面两个方法比较起来比较没有那么直观，在此所使用的是比较简单的一种 Shell 排序法。排序 N 个数据项的步骤如下：</p>
<blockquote>
<ol>
<li>令 k = n/2</li>
<li>把数据项分组，第1，1+k 的数字为一组，第2，2+k 为一组，一直到把所有的数据分配完毕为止。（也就是两两一组，那要是奇数个数字怎么办？）</li>
<li>每一组各自互相比较大小，如果前者大于后则J（第n项 &gt; 第n+k项），两者都要交换位置。而且还要再往回取出第n-k, n这两项再来比较，如果第 n-k 项 &gt; 第 n 项，那又要再往回取出 n-2k, n-k 这两项来比较。一直往回取到第 N-nK &lt; 第N - (n-1)K项，或者是到了不能往回取为止。</li>
<li>令 k = k/2 ，再回到第2步重复，一直到 k = 0 为止。</li>
</ol>
</blockquote>
<p>啊，这说的是人话嘛？</p>
<p>我不知道发明这个算法的人是怎么想到的，能搞成这么复杂。而且我粗略地感觉了一个，计算复杂度并不低，从书上看，排序5个数字，也计算了十几次（当然比前面两个算法要好）。</p>
<p>Shell 排序法可以形容成 ” 乱中有序“ ，因为它在每一次的循环中都只能大概地安排每一个元素到更加接近的位置，一直要到最后一次循环，才能确定每个数字的真正位置。</p>
<p>代码略。</p>
<h3 id="15-1-4-快速排序法（Quick-Sort）">15-1-4 快速排序法（Quick Sort）</h3>
<p>这个小节所要介绍的快速排序法，相信任何人听到一定都会非常心动，因为它的名字听起来就很有威力，在一般的情况下，也确实是目前最快的排序方法。这个实例程序会使用递归调用的功能。</p>
<p>快速排序法处理N个数据的步骤如下：</p>
<blockquote>
<ol>
<li>
<p>以数据组中的第1个数字做为键值K，令L=2, R=N。</p>
</li>
<li>
<p>以K值为基准，把小于K的数字向前移动，大于K的数字向后移动。移动的过程中，会同时发现K值在数列中的大小排名，并把K值放在正确的位置上。</p>
</li>
<li>
<p>假设K值排名为S，把移动后的数列分成比K小和比K大这两组。数列中第1~S-1 个数字都比K小，第S+1~N个数字都比K大，再把这两个小组拿去排序。</p>
<p>使用快速排序法时，每一个循环都会生成两个新的小组。切割的操作会一直进行到新的小组中只剩下一个数字为止。步骤2的过程有必要再详细地介绍，同样令 L=2， R=N，num(n) 为数据中第n个数字：</p>
</li>
<li>
<p>从数据组中的第L个数字开始，依序拿下一个数字和键值K来比较，一直到找出&gt;=K 的数值为止。把L重新设置为这个数值在数据中的位置。</p>
</li>
<li>
<p>从数据组中的第R个数字开始，依序拿前一个数字和键值K来比较，一直到找出&lt;=K 的数值为止。把R设为这个数值在数据中的位置。</p>
</li>
<li>
<p>如果 L &lt; R ，把数组中 L，R这两个位置的数值交换，再回到上一个步骤继续执行。如果　L &gt; R , 把数组第1个数字和第R个数字交换位置。到了这个时候，num(1~R-1)&lt;=num®, num(R+1~N) &gt;= num® , 会确定出第R个数值的排名。</p>
</li>
</ol>
</blockquote>
<p>下面这组数字 {3,2,5,1,4} 以快速排序法排序的过程如下：</p>
<p>先取 K = num(1) = 3 为键值来做比较，令 L = 2、R = 5。</p>
<ol>
<li>从第L个数字向后寻找&gt;=K的数值，结果发现 num(3) = 5 &gt; K，所以令L = 3</li>
<li>从第R个数字向前寻找&lt;K 的数值，结果发现 num(4) = 1 &lt; K，所以令R = 4</li>
<li>因为 L=3 &lt; R=4, 所以把 num(3) 及 num(4) 的数值交换，数据变成 {3,2,1,5,4}</li>
<li>再继续从 L=3 的地方向下找 &gt;= K的数值，结果发现num(4)=5&gt;k, 所以令L = 4</li>
<li>再继续从 R=4 的地方向前找 &lt; K 的数值，结果发现num(3)=1&lt;K, 所以令R = 3</li>
<li>因为 L =4 &gt; R=3，所以要把num(1) 和 num® 的数值交换。此时的数列内容为 {1,2,3,5,4}。而这一次的循环会确定 num(3) 的数值（因为 R=3），接下来要把 num(1~2) 的 [1,2] 及 num(4~5)  的 [5,4] 分成两组，再把它们用同样的方法来排序。</li>
</ol>
<p>经过上面的解释，可以简单地把快速排序法做一个简述。快速排序法是一次次地把整个数据细分成许多小组，而每一次都会确定小组的第1个成员在数据中的排名。快速排序法的实现程序如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">! 快速排序法范例</span></span><br><span class="line"><span class="comment">! By Perng 1997/8/30 </span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> QuickSort_Demo</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n = <span class="number">10</span></span><br><span class="line">    <span class="keyword">real</span> :: b(n)</span><br><span class="line">    <span class="keyword">integer</span> :: a(n)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 用随机数生成数列</span></span><br><span class="line">    <span class="keyword">call</span> random_seek()</span><br><span class="line">    <span class="keyword">call</span> <span class="built_in">random_number</span>(b)</span><br><span class="line">    a = b*<span class="number">100</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source=&gt;&#x27;, 10i3)&quot;</span>) a</span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 调用Quick_Sort 时除了要输入数组的信息外，还要给定要排列数组元素</span></span><br><span class="line">    <span class="comment">! 的上下限位置范围，在此当然是要给 1,n ， 表示从头排到尾。</span></span><br><span class="line">    <span class="keyword">call</span> Quick_Sort(a,n,<span class="number">1</span>,n)</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Sort=&gt;&#x27;, 10i3)&quot;</span>) a</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">!快速排序法的子程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">recursive</span> <span class="function"><span class="keyword">subroutine</span></span> Quick_Sort(a,n,s,e)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: n    <span class="comment">! 表示数组的大小</span></span><br><span class="line">    <span class="keyword">integer</span> :: a(n) <span class="comment">! 存放数据的数组</span></span><br><span class="line">    <span class="keyword">integer</span> :: s    <span class="comment">! 输入的参数，这一组的数组的起始位置</span></span><br><span class="line">    <span class="keyword">integer</span> :: e    <span class="comment">! 输入的参数，这一组的数组的结束位置</span></span><br><span class="line">    <span class="keyword">integer</span> :: l,r  <span class="comment">! 用来找a(l) &gt; k 及 a(r) &lt; k 时用的</span></span><br><span class="line">    <span class="keyword">integer</span> :: k    <span class="comment">! 记录键值 a(s) </span></span><br><span class="line">    <span class="keyword">integer</span> :: temp <span class="comment">! 交换两个数值时用的</span></span><br><span class="line">    <span class="comment">! 首先要先给定l, r 的初值。l 要从头开始，r 要从尾开始</span></span><br><span class="line">    l = s</span><br><span class="line">    r = e + <span class="number">1</span></span><br><span class="line">    <span class="comment">! Right 值 &gt; Left 值时才有必要进行排序</span></span><br><span class="line">    <span class="keyword">if</span>(r &lt;= l) <span class="keyword">return</span> <span class="comment">! return 就是提前结束子程序</span></span><br><span class="line">    </span><br><span class="line">    k = a(s) <span class="comment">! 设置键值</span></span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="comment">!找出 A(l) &lt; k 的所在</span></span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">            L = L + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span>((A(l) &gt; k) .or. (l&gt;=e)) <span class="keyword">exit</span> </span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="comment">! 找出 A(r) &gt; k 的所在</span></span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">            r = r-<span class="number">1</span> <span class="comment">!初值设为 e+1,这里就变成了 e</span></span><br><span class="line">            <span class="keyword">if</span>((a(r) &lt; k) .or. (r&lt;=s)) <span class="keyword">exit</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">        <span class="comment">! 如果 right 跑到 left 的 左边时，循环就该结束了</span></span><br><span class="line">        <span class="keyword">if</span>(r &lt;= l) <span class="keyword">exit</span></span><br><span class="line">        <span class="comment">! 交换 a(l), a(r) 的数值</span></span><br><span class="line">        temp = a(l)</span><br><span class="line">        a(l) = a(r)</span><br><span class="line">        a(r) = temp</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment">! 交换a(s), a(r)的数值</span></span><br><span class="line">    temp = a(s)</span><br><span class="line">    a(s) = a(r)</span><br><span class="line">    a(r) = temp</span><br><span class="line">    <span class="comment">! 把r之前的数据重新分组，再做排序</span></span><br><span class="line">    <span class="keyword">call</span> Quick_Sort(A,N,S,R-<span class="number">1</span>)</span><br><span class="line">    <span class="comment">! 把r之后的数据重新分组，再做排序</span></span><br><span class="line">    <span class="keyword">call</span> Quick_Sort(A,N,R+<span class="number">1</span>,E)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Source&#x3D;&gt;  5 45 37 72 29 70 18 46  3 44</span><br><span class="line">Sort&#x3D;&gt;  3  5 18 29 37 44 45 46 70 72</span><br></pre></td></tr></table></figure>
<p>注意，这里用到了递归。这个算法是真的漂亮。</p>
<p>这里所介绍的排序方法，在一般的情况下的工作效率排名为：</p>
<blockquote>
<p>快速排序法 &gt; shell 排序法 &gt; 冒泡排序法 &gt; 选择排序法</p>
</blockquote>
<h2 id="15-2-搜索">15-2 搜索</h2>
<p>搜索是在一堆东西中寻找特定物品。本节将会介绍三种搜索方法。</p>
<h3 id="15-2-1-顺序搜索">15-2-1 顺序搜索</h3>
<p>顺序搜索是最简单的方法，一句话就可以解释完毕：“把东西一个一个拿出来，看看它是不是我们所要找的东西。”</p>
<p>程序实现如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">! 顺序搜索法示范</span></span><br><span class="line"><span class="comment">! By Perng 1997/8/31</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> sequential_search_demo</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n = <span class="number">10</span></span><br><span class="line">    <span class="keyword">integer</span> :: a(n) = (/ <span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span> /) <span class="comment">! 存放数据组的数据</span></span><br><span class="line">    <span class="keyword">integer</span> key <span class="comment">! 记录要找的值</span></span><br><span class="line">    <span class="keyword">integer</span> loc </span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">external</span> :: sequential_search</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source=&gt;&#x27;,10i3)&quot;</span>) a</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;Input Key:&#x27;</span></span><br><span class="line">    read(*,*) key</span><br><span class="line">    <span class="comment">! 调用顺序搜索的函数</span></span><br><span class="line">    loc = sequential_search(a,n,key)</span><br><span class="line">    <span class="keyword">if</span>(loc/=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;A(&#x27;,i2,&#x27; )=&#x27;i3)&quot;</span>) loc, key</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;Not found&quot;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">! 顺序搜索法的子程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> Sequential_Search(a,n,key)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> n, a(n)</span><br><span class="line">    <span class="keyword">integer</span> key </span><br><span class="line">    <span class="keyword">integer</span> i <span class="comment">!循环的计数器</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> i =<span class="number">1</span>,n <span class="comment">!开始做扫描，最多做N次</span></span><br><span class="line">        <span class="keyword">if</span>(key == A(i)) <span class="keyword">then</span></span><br><span class="line">            <span class="comment">! 找到了，返回数字在数组中的位置</span></span><br><span class="line">            <span class="comment">! 但是如果有多个重复值，只会返回第一个位置</span></span><br><span class="line">            sequential_search = i</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment">! 没找到时返回 -1</span></span><br><span class="line">    sequential_search = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个太简单了。</p>
<h3 id="15-2-2-二元搜索">15-2-2 二元搜索</h3>
<p>二元搜索法必须配合<strong>排序好</strong>的数据才能使用，假设所要寻找的数值为K，数据存放在数组中，搜索的步骤如下：</p>
<ol>
<li>取出数组的中间值 M 与 K 值来互相比较，如果 k=M 就找到了；如果 K&gt;M ，那么 K一定在数组的后半段；如果K&lt;M ，同理。</li>
<li>根据K值在数组的前半段/后半段来重新分组，再回到第一步来做搜索。分组会一直细分到数组不能再细分下去为止，而到此时若还没有找到K，代表K值不存在。</li>
</ol>
<p>二元搜索法的程序实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">! 二元搜索法范例</span><br><span class="line">! By Perng 1997&#x2F;8&#x2F;31</span><br><span class="line">program Binary_Search_demo</span><br><span class="line">    implicit none</span><br><span class="line">    integer, parameter :: n &#x3D;10 !数组的大小</span><br><span class="line">    integer :: a(n) &#x3D; (&#x2F; 2,5,7,9,10,11,13,17,21,23 &#x2F;)</span><br><span class="line">    integer key</span><br><span class="line">    integer loc</span><br><span class="line">    integer, external :: binary_search</span><br><span class="line">    </span><br><span class="line">    write(*, &quot;(&#39;Source&#x3D;&gt;&#39;, 10i3)&quot;) A</span><br><span class="line">    write(*,*) &#39;Input Key:&#39;</span><br><span class="line">    read(*,*) key</span><br><span class="line">    !调用二元搜索的子程序</span><br><span class="line">    loc &#x3D; binary_search(a,n,key)</span><br><span class="line">    if(loc&#x2F;&#x3D;0) then</span><br><span class="line">        write(*, &quot;(&#39;A(&#39;,i2,&#39; )&#x3D;&#39;i3)&quot;) loc, key</span><br><span class="line">    else</span><br><span class="line">        write(*,*) &quot;Not found&quot;</span><br><span class="line">    end if</span><br><span class="line">    stop</span><br><span class="line">end program</span><br><span class="line"></span><br><span class="line">! 二元搜索法的子程序</span><br><span class="line"></span><br><span class="line">integer function Binary_Search(a,n,key)</span><br><span class="line">    implicit none</span><br><span class="line">    integer n,a(n)</span><br><span class="line">    integer key   ! 所要寻找的值</span><br><span class="line">    integer l     ! 记录每一个小组的数组起始位置</span><br><span class="line">    integer r     ! 记录每一个小组的数组结束位置</span><br><span class="line">    integer m     ! 记录每一个小组的数组开始位置</span><br><span class="line">    </span><br><span class="line">    ! 一开始的小组范围就是整个数组</span><br><span class="line">    l&#x3D;1</span><br><span class="line">    r&#x3D;n</span><br><span class="line">    m&#x3D;(l+r)&#x2F;2 ! 7&#x2F;2 &#x3D; 3</span><br><span class="line">    </span><br><span class="line">    ! 如果 key 值超出范围，肯定不存在数组中</span><br><span class="line">    if((key &lt; a(l)) .or. (key &gt; a(r))) then</span><br><span class="line">        binary_search &#x3D; 0</span><br><span class="line">        return</span><br><span class="line">    end if</span><br><span class="line">    </span><br><span class="line">    do while(l &lt;&#x3D; r)</span><br><span class="line">        if(key &gt; a(m)) then</span><br><span class="line">            ! 如果 key &gt; 中间值，那就落在后半段</span><br><span class="line">            L &#x3D; M+1</span><br><span class="line">            M &#x3D; (L+R)&#x2F;2</span><br><span class="line">        else if(key &lt; a(m)) then</span><br><span class="line">            ! 如果 key &lt; 中间值，那就落在前半段</span><br><span class="line">            r &#x3D; M -1</span><br><span class="line">            m &#x3D; (l+r)&#x2F;2</span><br><span class="line">        else if(key &#x3D;&#x3D;  a(m)) then</span><br><span class="line">            binary_search &#x3D; m</span><br><span class="line">            return</span><br><span class="line">        end if</span><br><span class="line">    end do</span><br><span class="line">    </span><br><span class="line">    !如果前面都没有找到，返回0</span><br><span class="line">    binary_search &#x3D; 0</span><br><span class="line">    return</span><br><span class="line">end function</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Source=&gt;  <span class="number">2</span>  <span class="number">5</span>  <span class="number">7</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">13</span> <span class="number">17</span> <span class="number">21</span> <span class="number">23</span></span><br><span class="line"> Input Key:</span><br><span class="line"><span class="number">10</span></span><br><span class="line">A( <span class="number">5</span> )= <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h3 id="15-2-3-散列搜索（Hashing）">15-2-3 散列搜索（Hashing）</h3>
<p>这个算法光听名字实在是很难去想象它的作法。散列法的搜索效率很高，如果安排恰当，它几乎每次都只需要做一次对比操作，就可以判断数据是否存在。它主要的精力是放在如何安排数据在内存的位置。将数据安排好之后，搜索数据时只要计算它可能在内存的位置，直接与这个位置上的数据来做对比。</p>
<p>散列搜索法主要在于它的概念，并没有一定的实现方法。任何人都可以自行设计散列公式来计算数据要如何放在数组中。</p>
<p>直接来看一个实例，假如要在 {21,53,71,19,61,81,3,17,44,93} 这一组数字中搜索数据。首先要定义出一个散列公式来决定数据要如何安置。观察这一组数字后，可以发现它们的值域范围在0~100之间，所以可以声明一个大小为100的数组，而且可以使用最简单的方法来决定数据在 array 中的位置，就是直接把数值D放在 array(D) 中。用数学方法来解释这个散列函数，即为 <code>hash(D) = D</code>。</p>
<p>在搜索时，找到K值在数组中的位置，再比较 array(K)  的值是否等于 K 。如果相等就代表搜索成功，如果不相等就代表数据不存在。因此只要比对一次就能确定数据在不在。</p>
<p>程序实现如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">! 散列搜索法示例</span></span><br><span class="line"><span class="comment">! By Perng 1997/8/31</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> Hash_Search_Demo</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n = <span class="number">10</span> </span><br><span class="line">    <span class="keyword">integer</span> Source(n) <span class="comment">! 存放数据组的数组</span></span><br><span class="line">    <span class="keyword">integer</span> A(<span class="number">100</span>)    <span class="comment">! 存放 Hashing 后的数组</span></span><br><span class="line">    <span class="keyword">integer</span> key       <span class="comment">! 记录所要找的值</span></span><br><span class="line">    <span class="keyword">integer</span> i         <span class="comment">! 循环计数器</span></span><br><span class="line">    <span class="keyword">data</span> Source /<span class="number">21</span>,<span class="number">53</span>,<span class="number">71</span>,<span class="number">19</span>,<span class="number">61</span>,<span class="number">81</span>,<span class="number">3</span>,<span class="number">17</span>,<span class="number">44</span>,<span class="number">93</span>/</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source=&gt;&#x27;, 10i3)&quot;</span>) Source</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;Input Key:&#x27;</span></span><br><span class="line">    read(*,*) key</span><br><span class="line">    <span class="keyword">if</span> (key &lt;<span class="number">0</span> .or. key&gt;<span class="number">100</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;Not found&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 创建Hash 表格，表格中放的是数值在数组中的位置</span></span><br><span class="line">    A = <span class="number">0</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">        A(Source(i)) = i</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 在 Hash 表格中寻找数据</span></span><br><span class="line">    <span class="keyword">if</span>(A(key) /= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source(&#x27;,i2,&#x27; )=&#x27;,i3)&quot;</span>) A(key), key</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;Not found&quot;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的散列方法，使用大小为100的数组来存放10个数字。使用比较大的数组来存放数据会比较容易设计散列函数 hash(K)，比较不易发生当 a 不等于 b 时 hash(a) = hash(b) 的现象，可以得到比较好的搜索效率。（hash(a), hash(b) 指的是a,b 在数组中的位置，这个意思就是说不会出现两个不同的值执行同一个内存位置的情况）。</p>
<p>再来看一个新的散列方法，同样用上一个实例中的数据组来做搜索。上一个实例程序只使用了 10% 的数组空间，有 90% 是浪费掉的。这一次不会再浪费那么多内存空间，而是把散列的数据放在大小为10的数组来充方利用内存。散列函数必须重新设计，才能符合新的数组大小。</p>
<p>这一次可以定义 <code>hash(K) = K/10+1</code> ，也就是取出数字的10位数，再加上 1 来当做它在数组中的位置。不过这个方法会发生一个问题，因为<strong>它对不同数字很有可能算出同样的结果来</strong>，例如 hash(11) = hash(12) = 2 。对这个情况要做一些例外处理，可以加上一个条件：如果所要使用的位置已经被其他数字占据，就向后挪一步。</p>
<p>要搜索时，同样先由 L = hash(K) = K/10 + 1 来计算数据位置，但是如果 array(L) 不等于 K 时，并不代表 K 不存在，还要向后一个个来做检查，一直到全部数据都检查过为止。（这也太低效了吧）</p>
<p>实现程序如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">! 散列搜索法示例</span></span><br><span class="line"><span class="comment">! by perng 1997/8/31</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> hashing_search_demo</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n = <span class="number">10</span></span><br><span class="line">    <span class="keyword">integer</span> source(n) <span class="comment">! 存放数据组的数组</span></span><br><span class="line">    <span class="keyword">integer</span> a(n)      <span class="comment">! 存放hashing 后的数组</span></span><br><span class="line">    <span class="keyword">integer</span> key       </span><br><span class="line">    <span class="keyword">integer</span> i</span><br><span class="line">    <span class="keyword">integer</span> loc</span><br><span class="line">    <span class="keyword">data</span> Source /<span class="number">21</span>,<span class="number">53</span>,<span class="number">71</span>,<span class="number">19</span>,<span class="number">61</span>,<span class="number">81</span>,<span class="number">3</span>,<span class="number">17</span>,<span class="number">44</span>,<span class="number">93</span>/</span><br><span class="line">    <span class="keyword">integer</span> hash</span><br><span class="line">    hash(key) = key/<span class="number">10</span> + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source=&gt;&#x27;, 10i3)&quot;</span>) Source</span><br><span class="line">    </span><br><span class="line">    a=<span class="number">0</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">        loc = hash(source(i))</span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">            <span class="keyword">if</span>(a(loc)==<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">                a(loc) = i</span><br><span class="line">                <span class="keyword">exit</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loc = loc + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span>(loc&gt;n) loc = <span class="number">1</span> <span class="comment">!如果loc超出最大值就设为1，再从头循环一遍，反正得放进去</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;Input Key:&#x27;</span></span><br><span class="line">    read(*,*) key</span><br><span class="line">    </span><br><span class="line">    loc = hash(key)</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">        <span class="keyword">if</span>(a(loc)==<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;Not found&quot;</span></span><br><span class="line">            <span class="keyword">exit</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (source(a(loc)) == key) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source(&#x27;,i2,&#x27; )=&#x27;,i3)&quot;</span>) a(loc), key</span><br><span class="line">            <span class="keyword">exit</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            loc = loc + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span>(loc&gt;n) loc = <span class="number">1</span> <span class="comment">!这就是10个数据全部检查一遍</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment">!注意，这里循环结束后，i是11，不是10。所以这里才判断 i&gt;n</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;n) <span class="built_in">write</span>(*,*) <span class="string">&quot;Not found&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里由一个细节，就是 do 循环之后，i 最终的结果是11，而不是10。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">!注意，这里循环结束后，i是11，不是10。所以这里才判断 i&gt;n</span></span><br><span class="line"><span class="keyword">if</span>(i&gt;n) <span class="built_in">write</span>(*,*) <span class="string">&quot;Not found&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面这个方法不算是很有效率的方法。如果所要搜索的数据不存在，要扫描整个数组才能确认这个事实。这主要归咎于散列表格太小，而不是散列法的缺点。如果配合上串行结构来存放数据，可以得到比较好的效率。</p>
<p>现在来示例针对这个散列法所设计的串行结构。在这里使用同样的散列函数 hash(x) = x/10 + 1，hash(x) 的值在1~10之间，所以可以用 10个串行来保存所有数值。这个方法所创建的串行结构如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hash(x)&#x3D;1 的串行：&#x3D;&gt;3</span><br><span class="line">hash(x)&#x3D;2 的串行：&#x3D;&gt;19&#x3D;&gt;17</span><br><span class="line">hash(x)&#x3D;3 的串行：&#x3D;&gt;21</span><br><span class="line">hash(x)&#x3D;4 的串行：没有东西</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>搜索时只要在所属的串行中来搜索即可，不需要跨越到其他的串行中。不必等到扫描整个数据后，才能确认数据不存在。实现的程序如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> NumLink</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n =<span class="number">10</span></span><br><span class="line">    <span class="comment">! 声明制作串行的类型</span></span><br><span class="line">    <span class="keyword">type</span> :: link</span><br><span class="line">        <span class="keyword">integer</span> :: num               <span class="comment">! 保存数据组</span></span><br><span class="line">        <span class="keyword">type</span>(link), <span class="keyword">pointer</span> :: next  <span class="comment">! 指向下一个环结的指针</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">type</span>(link), <span class="keyword">target</span> :: linking(n) <span class="comment">! 保存hashing后的数据</span></span><br><span class="line">    <span class="keyword">type</span>(link), <span class="keyword">pointer</span> :: proc      <span class="comment">! 暂时使用的指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">integer</span> :: Source(n) = (/<span class="number">21</span>,<span class="number">53</span>,<span class="number">71</span>,<span class="number">19</span>,<span class="number">61</span>,<span class="number">81</span>,<span class="number">3</span>,<span class="number">17</span>,<span class="number">44</span>,<span class="number">93</span>/)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> InitLink()</span><br><span class="line">        <span class="keyword">integer</span> i</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">            linking(i) = link(<span class="number">0</span>,null())</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">! hash函数</span></span><br><span class="line">    <span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> hash(key)</span><br><span class="line">        <span class="keyword">integer</span> key</span><br><span class="line">        hash = key/<span class="number">10</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 把数字经过散列处理后放入串行的子程序</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Insert(key, info)</span><br><span class="line">        <span class="keyword">integer</span> :: key, info <span class="comment">! 所要插入的数字及在 Source中的位置</span></span><br><span class="line">        <span class="keyword">integer</span> :: L         <span class="comment">! hashing 后的结果</span></span><br><span class="line">        </span><br><span class="line">        L = hash(key)</span><br><span class="line">        proc=&gt;linking(L) <span class="comment">! 把proc指向数组linking中hash(L)的位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">! 移动到串行中的最后一个位置</span></span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(proc%num /= <span class="number">0</span>)</span><br><span class="line">            proc =&gt; proc%next</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        </span><br><span class="line">        proc%num = INFO</span><br><span class="line">        <span class="comment">! 配置内存空间给 proc%next</span></span><br><span class="line">        <span class="built_in">allocate</span>(proc%next)</span><br><span class="line">        proc =&gt; proc%next</span><br><span class="line">        proc%num = <span class="number">0</span></span><br><span class="line">        <span class="built_in">nullify</span>(proc%next)</span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 在串行中搜索数据的子程序</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Hash_Search(key)</span><br><span class="line">        <span class="keyword">integer</span> :: key  <span class="comment">! 要搜索的值</span></span><br><span class="line">        <span class="keyword">integer</span> :: L    <span class="comment">! 计算hashing后的值</span></span><br><span class="line">        </span><br><span class="line">        L = hash(key)</span><br><span class="line">        proc =&gt; linking(L) <span class="comment">! 把proc指向数组linking中 hash(L)的位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">! 在这一个串行中一直向下顺序搜索到找到为止</span></span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">            <span class="keyword">if</span>(proc%num == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">write</span>(*,*) <span class="string">&quot;Not found&quot;</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line">            <span class="keyword">if</span>(Source(proc%num)==key) <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source(&#x27;,i2,&#x27; )=&#x27;,i3)&quot;</span>) proc%num, key</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">associated</span>(proc%next)) proc = proc%next</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 输出串行中数据的子程序</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> OutputLink()</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">            proc =&gt; linking(i)</span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(1x,i2,&#x27;:&#x27;)&quot;</span>, <span class="keyword">advance</span> = <span class="string">&quot;NO&quot;</span>) i</span><br><span class="line">            <span class="keyword">do</span> <span class="keyword">while</span>(<span class="built_in">associated</span>(proc%next))</span><br><span class="line">                <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;-&gt;&#x27;,i2)&quot;</span>, <span class="keyword">advance</span> = <span class="string">&quot;NO&quot;</span>) Source(proc%num)</span><br><span class="line">                proc =&gt; proc%next</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="comment">! ?</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="comment">! 散列搜索法举例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> hashing_search_demo</span><br><span class="line">    <span class="keyword">use</span> NumLink</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: key <span class="comment">! 记录要找的值</span></span><br><span class="line">    <span class="keyword">integer</span> :: i   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">call</span> InitLink()</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source=&gt;&#x27;,10i3)&quot;</span>) Source</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">        <span class="keyword">call</span> Insert(Source(i),i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Link List=&gt;&quot;</span></span><br><span class="line">    <span class="keyword">call</span> OutputLink()</span><br><span class="line">    <span class="comment">! 读入要找的值</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;Input Key:&#x27;</span></span><br><span class="line">    read(*,*) key</span><br><span class="line">    <span class="comment">! 调用顺序搜索的子程序</span></span><br><span class="line">    <span class="keyword">call</span> Hash_Search(key)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Source&#x3D;&gt; 21 53 71 19 61 81  3 17 44 93</span><br><span class="line"> Link List&#x3D;&gt;</span><br><span class="line">  1:-&gt; 3  2:-&gt;19-&gt;17  3:-&gt;21  4:  5:-&gt;44  6:-&gt;53  7:-&gt;61  8:-&gt;71  9:-&gt;81 10:-&gt;93</span><br><span class="line"> Input Key:</span><br><span class="line">44</span><br><span class="line">Source( 9 )&#x3D; 44</span><br></pre></td></tr></table></figure>
<p>这个程序还没有仔细看，之后有时间再看一下。</p>
<h2 id="15-3-堆栈-Stack">15-3 堆栈 Stack</h2>
<p>&quot;堆栈&quot;的概念很简单，它可以解决许多程序设计的问题。堆栈是一种管理数据进、出内存的规则，这个规则就是：“越早得到的数据越晚输出，越晚得到的数据越早输出”</p>
<h3 id="15-3-1-堆栈的基本范例">15-3-1 堆栈的基本范例</h3>
<p>根据堆栈 “后到先进” 的策略，可以编写一个实例程序来把所输入的一连串数据反向输出。这个程序的目的只是用来实例堆栈的运行过程，真正应用的过程在下一个小节中才会介绍。</p>
<p>来看程序：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> stack_utility</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">private</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: top = <span class="number">50</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">save</span> :: current = <span class="number">0</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">save</span> :: stack(top)</span><br><span class="line">    <span class="keyword">public</span> push, pop</span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">! 把数据放入堆栈中</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> push(<span class="keyword">value</span>)</span><br><span class="line">        <span class="keyword">integer</span> <span class="keyword">value</span></span><br><span class="line">        <span class="keyword">if</span>(current&gt;top) <span class="keyword">then</span> <span class="comment">!超过容量</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;Stack full.&quot;</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        current = current + <span class="number">1</span></span><br><span class="line">        stack(current) = <span class="keyword">value</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">! 从堆栈中取出数据</span></span><br><span class="line">    <span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> pop(<span class="keyword">value</span>)</span><br><span class="line">        <span class="keyword">integer</span> <span class="keyword">value</span></span><br><span class="line">        <span class="keyword">if</span>(current&lt;=<span class="number">0</span>) <span class="keyword">then</span> <span class="comment">! 已经没有东西可以拿了</span></span><br><span class="line">            pop = <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">value</span> = stack(current)</span><br><span class="line">        current = current - <span class="number">1</span></span><br><span class="line">        pop = <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> stack_utility</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n = <span class="number">5</span></span><br><span class="line">    <span class="keyword">integer</span> :: a(n) = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /)</span><br><span class="line">    <span class="keyword">integer</span> i, stat, <span class="keyword">value</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source=&gt;&#x27;, 5i3)&quot;</span>) a</span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>,n</span><br><span class="line">        <span class="keyword">call</span> push(a(i))</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>,n</span><br><span class="line">        stat = pop(<span class="keyword">value</span>)</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(i3)&quot;</span>, <span class="keyword">advance</span> = <span class="string">&quot;no&quot;</span>) <span class="keyword">value</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">write</span>(*,*)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Source&#x3D;&gt;  1  2  3  4  5</span><br><span class="line">  5  4  3  2  1</span><br></pre></td></tr></table></figure>
<p>这里堆栈数据实际上存放在数组 stack 中，变量 current 用来记录目前堆栈保存情况。这些数据被设置成私有的数据，外部数据不能直接访问它们（但是在module 内部一直在记录 current 的变化）。整个模块中，只有 push 和 pop 这两个函数是对外开发的使用接口。</p>
<p>调用 push 可以把数据放在堆栈的最顶端；调用 pop 则可以从堆栈的最顶端取出一条数据。push 和 pop 都不能无限制调用，当 stack 数组用完时，就不能再 push 数据。而堆栈没有数据时，就不能再调用 pop。</p>
<h3 id="15-3-2-堆栈的应用-骑士走棋盘">15-3-2 堆栈的应用 - 骑士走棋盘</h3>
<p>略</p>
<h2 id="15-4-树状结构">15-4 树状结构</h2>
<p>第10章介绍指针时，已经示范过串行结构的使用，指针还经常使用在另外一种称为树状结构的数据结构。被称为树状结构的原因在于，树状结构的链接情况换成图形时，会出现如同树枝状的结构来。</p>
<p>本节介绍二叉树的应用（<strong>二叉树指每一层的分枝都是两个枝干</strong>）。在这里示范应用二叉树来做排序及搜索的方法，二叉树的创建格式为，<strong>左枝所保存的数值，永远都小于跟它对称的右枝所保存的数值</strong>。以这种方式所创建的二叉树，可以很容易地来做数据搜索。从最上端开始来对比，如果要寻找的数据大于目前的树枝中所保存的数值，那么数据一定是落在右枝。如果是小于的话，那就是落在左枝。以这个方法可以很快速地由上而下寻找数据。</p>
<p>二叉树创建后，数据也等于完成“排序” 工作。经过特定的规则来取出二叉树数据，就可以达到排序的效果。以这个例子来看，只要先取出较小，而且较左边枝干中所保存的数值，就可以把数据由小到大来排序。</p>
<p>现在就来实现一个建构二叉树的实例，这个实例示例了如何使用二叉树来记录数据，并且同时完成排序。程序代码有点长，建议读者先翻到后面的程序说明解说部分来阅读，再回过头来看整个程序。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">! 二叉树排序范例</span></span><br><span class="line"><span class="keyword">module</span> typedef </span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> :: <span class="keyword">data</span></span><br><span class="line">        <span class="keyword">integer</span> :: n      <span class="comment">! 存放的数据</span></span><br><span class="line">        <span class="keyword">integer</span> :: <span class="built_in">repeat</span> <span class="comment">! 数据重复的次数</span></span><br><span class="line">        <span class="keyword">type</span>(<span class="keyword">data</span>), <span class="keyword">pointer</span> :: left  <span class="comment">! 左枝</span></span><br><span class="line">        <span class="keyword">type</span>(<span class="keyword">data</span>), <span class="keyword">pointer</span> :: right <span class="comment">! 右枝</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> bin_tree</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">private</span></span><br><span class="line">    <span class="keyword">type</span>(<span class="keyword">data</span>), <span class="keyword">pointer</span> :: tree, <span class="keyword">action</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">save</span> :: numbers = <span class="number">0</span></span><br><span class="line">    <span class="keyword">public</span> add, TraceTree</span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">! 新加入一条数据</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> add(n)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span>, <span class="keyword">intent</span>(<span class="keyword">in</span>) :: n</span><br><span class="line">        <span class="keyword">integer</span> :: err</span><br><span class="line">        <span class="keyword">type</span>(<span class="keyword">data</span>), <span class="keyword">pointer</span> :: new</span><br><span class="line">        <span class="keyword">integer</span> :: level</span><br><span class="line">        level = <span class="number">1</span></span><br><span class="line">        numbers = numbers+<span class="number">1</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a5,i4,a8)&quot;</span>) <span class="string">&quot;Get :&quot;</span>,numbers,<span class="string">&quot; numbers&quot;</span></span><br><span class="line">        <span class="comment">! 配置一块新的空间</span></span><br><span class="line">        <span class="built_in">allocate</span>(new, stat=err)</span><br><span class="line">        <span class="keyword">if</span>(err/=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;Out of memory!&quot;</span></span><br><span class="line">            <span class="keyword">stop</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;root &#x27;)&quot;</span>, <span class="keyword">advance</span> = <span class="string">&quot;no&quot;</span>)</span><br><span class="line">        <span class="comment">! 设置数据</span></span><br><span class="line">        new%<span class="built_in">repeat</span> = <span class="number">1</span></span><br><span class="line">        new%n = n</span><br><span class="line">        <span class="built_in">nullify</span>(new%right, new%left)</span><br><span class="line">        <span class="comment">! 如果是第一条数据</span></span><br><span class="line">        <span class="keyword">if</span>(numbers==<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">action</span> =&gt; new</span><br><span class="line">            tree =&gt; new</span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;: new&#x27;)&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">action</span> =&gt; tree</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">            level = level + <span class="number">1</span></span><br><span class="line">            <span class="comment">! 数据大于目前的枝干的数值时</span></span><br><span class="line">            <span class="keyword">if</span>(n&gt;<span class="keyword">action</span>%n) <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">associated</span>(<span class="keyword">action</span>%right)) <span class="keyword">then</span></span><br><span class="line">                    <span class="keyword">action</span> =&gt; <span class="keyword">action</span>%right <span class="comment">! 再向右去寻找立身处</span></span><br><span class="line">                    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;-&gt;R&#x27;)&quot;</span>, <span class="keyword">advance</span> = <span class="string">&quot;no&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">action</span>%right =&gt; new <span class="comment">!创建新的右枝</span></span><br><span class="line">                    <span class="keyword">action</span> =&gt; new</span><br><span class="line">                    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;-&gt;R: new&#x27;)&quot;</span>)</span><br><span class="line">                    <span class="keyword">exit</span> </span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">            <span class="comment">! 数据小于目前枝干的数值时</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;<span class="keyword">action</span>%n) <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">associated</span>(<span class="keyword">action</span>%left)) <span class="keyword">then</span></span><br><span class="line">                    <span class="keyword">action</span> =&gt; <span class="keyword">action</span>%left <span class="comment">! 再向左去寻找立身处</span></span><br><span class="line">                    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;-&gt;L&#x27;)&quot;</span>, <span class="keyword">advance</span> = <span class="string">&quot;no&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">action</span>%left =&gt; new <span class="comment">!创建新的左枝</span></span><br><span class="line">                    <span class="keyword">action</span> =&gt; new</span><br><span class="line">                    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;-&gt;L: new&#x27;)&quot;</span>)</span><br><span class="line">                    <span class="keyword">exit</span> </span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">            <span class="comment">! 数据等于目前枝干的数值时</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="keyword">action</span>%n) <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">action</span>%<span class="built_in">repeat</span> = <span class="keyword">action</span>%<span class="built_in">repeat</span> + <span class="number">1</span> <span class="comment">! 把重复的数目加1</span></span><br><span class="line">                <span class="built_in">deallocate</span>(new) <span class="comment">! 可以不需要找个新的空间</span></span><br><span class="line">                <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;: Repeat&#x27;)&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> add</span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 显示排序的数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> TraceTree()</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">call</span> show_tree(tree)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 排序数据的子程序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">recursive</span> <span class="function"><span class="keyword">subroutine</span></span> show_tree(show)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(<span class="keyword">data</span>), <span class="keyword">pointer</span> :: show</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">associated</span>(show)) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">call</span> show_tree(show%left) <span class="comment">! 先取出左枝的数据</span></span><br><span class="line">            <span class="keyword">call</span> show_data(show) <span class="comment">! 再取出目前位置的数据</span></span><br><span class="line">            <span class="keyword">call</span> show_tree(show%right) <span class="comment">! 最后才取出右枝的数据</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 显示这个枝干所保存的数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> show_data(show)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(<span class="keyword">data</span>), <span class="keyword">pointer</span> :: show</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>, show%<span class="built_in">repeat</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) show%n</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span> bin_tree</span><br><span class="line"></span><br><span class="line"><span class="comment">! 主程序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main </span><br><span class="line">    <span class="keyword">use</span> bin_tree</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> num </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;请输入整数，输入0代表结束&quot;</span></span><br><span class="line">        read(*,*) num</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        <span class="keyword">call</span> add(num)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">call</span> TraceTree()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> 请输入整数，输入<span class="number">0</span>代表结束</span><br><span class="line"><span class="number">4</span></span><br><span class="line"> Get :   <span class="number">1</span> numbers</span><br><span class="line">root : new</span><br><span class="line"> 请输入整数，输入<span class="number">0</span>代表结束</span><br><span class="line"><span class="number">6</span></span><br><span class="line"> Get :   <span class="number">2</span> numbers</span><br><span class="line">root -&gt;R: new</span><br><span class="line"> 请输入整数，输入<span class="number">0</span>代表结束</span><br><span class="line"><span class="number">2</span></span><br><span class="line"> Get :   <span class="number">3</span> numbers</span><br><span class="line">root -&gt;L: new</span><br><span class="line"> 请输入整数，输入<span class="number">0</span>代表结束</span><br><span class="line"><span class="number">7</span></span><br><span class="line"> Get :   <span class="number">4</span> numbers</span><br><span class="line">root -&gt;R-&gt;R: new</span><br><span class="line"> 请输入整数，输入<span class="number">0</span>代表结束</span><br><span class="line"><span class="number">3</span></span><br><span class="line"> Get :   <span class="number">5</span> numbers</span><br><span class="line">root -&gt;L-&gt;R: new</span><br><span class="line"> 请输入整数，输入<span class="number">0</span>代表结束</span><br><span class="line"><span class="number">5</span></span><br><span class="line"> Get :   <span class="number">6</span> numbers</span><br><span class="line">root -&gt;R-&gt;L: new</span><br><span class="line"> 请输入整数，输入<span class="number">0</span>代表结束</span><br><span class="line"><span class="number">1</span></span><br><span class="line"> Get :   <span class="number">7</span> numbers</span><br><span class="line">root -&gt;L-&gt;L: new</span><br><span class="line"> 请输入整数，输入<span class="number">0</span>代表结束</span><br><span class="line"><span class="number">0</span></span><br><span class="line">           <span class="number">1</span></span><br><span class="line">           <span class="number">2</span></span><br><span class="line">           <span class="number">3</span></span><br><span class="line">           <span class="number">4</span></span><br><span class="line">           <span class="number">5</span></span><br><span class="line">           <span class="number">6</span></span><br><span class="line">           <span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序可以让用户输入一组整数，程序执行时还会同时显示树枝的“生长”情况。输入数字0会结束数据的输入，并把所输入的整数数列由小到大来输出。</p>
<p>程序使用二叉树来保存、同时排序所输入的数据。假如输入了下面的整数数列 [4,6,2,7,3,5,1]。输入第一个数字时，二叉树只有“根”的部分存在，所以整数4会放在二叉树的树根部分。输入第2个数字时，会去比较二叉树树根所保存的数值，如果结果是“大于”，就会向右边生成一根新的树干，并保存这个新的数值；如果结果是“小于”，则会向左边开发。程序会一直重复这个操作，生长处越来越密的枝干，而比较的层次也会一层层地向越小地枝干延申下去。</p>
<p>后面的解析和代码还没仔细看，以后再看。</p>
<h1>16 IMSL 函数库</h1>
<p>数值方法中常遇到的问题，有专门的链接库可以使用。IMSL 是一套在数值方法上经常被使用的商业链接库。</p>
<p><strong>有现成的函数可以使用，不代表程序员不需要学习自行编写数值方法程序的技巧。因为只有了解这些算法的真正运行过程，才能适当地去使用它们。</strong></p>
<p>IMSL 的函数名称中，第1个字母可以用来判断参数的类型。如果第1个字母是D，会使用双精度浮点数来计算并返回答案。第一个字母不是D，则使用单精度浮点数。</p>
<p>因为 IMSL 的函数太多了，在这一章中不会完整介绍所有函数的详细用法。本书会介绍处理线性系统、非线性系统、微积分、微分方程、插值时会使用到的基本功能。</p>
<p>略。</p>
<h1>17 附录</h1>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Fortran/" rel="tag">Fortran</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" rel="tag">数据分析</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/posts/a96a52e9/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            《Bioinformatics Data Skills》读书笔记
          
        </div>
      </a>
    
    
      <a href="/posts/c442673f/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">搭建个人博客</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "yHN3kf7fHt5wvleM2DVoHLdY-gzGzoHsz",
    app_key: "RPIwmdftljIzOtAULwc7JCAp",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "靓仔，看完留个评论再走哇！\n只需要填入昵称和邮箱就可以了",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2019-2022
        <i class="ri-heart-fill heart_icon"></i> Vincere Zhou
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>

    <!-- 与只只在一起天数 -->
	<ul>
		<li><span id="lovetime_span"></span></li>
	</ul>
    <script type="text/javascript">			
        function show_runtime() {
            window.setTimeout("show_runtime()", 1000);
            X = new Date("03/04/2021 22:11:00");
            Y = new Date();
            T = (Y.getTime() - X.getTime());
            M = 24 * 60 * 60 * 1000;
            a = T / M;
            A = Math.floor(a);
            b = (a - A) * 24;
            B = Math.floor(b);
            c = (b - B) * 60;
            C = Math.floor((b - B) * 60);
            D = Math.floor((c - C) * 60);
            lovetime_span.innerHTML = "只只和男朋友在一起了 " + A + "天" + B + "小时" + C + "分" + D + "秒"
        }
        show_runtime();
    </script>

  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/mojie.jpg" alt="VincereZhou&#39;s blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯茶吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/weixinpay.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"left","width":150,"height":300,"hOffset":80,"vOffset":-70},"mobile":{"show":false,"scale":0.5},"log":false});</script></body>

</html>