<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>混合线性模型一之广义最小二乘</title>
    <url>/posts/5e674d74/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这是混合线性模型理论系列的第一篇，内容为概述及广义最小二乘（固定效应的估计）。</p>
<span id="more"></span>
<h1>混合线性模型概述</h1>
<h2 id="前言">前言</h2>
<p>统计分析的目的是推断 (<em>inference</em>) 和预测 (<em>prediction</em>)，推断指估计参数的大小（比如确定哪些自变量有作用，哪些自变量没有作用），预测是对未来的观测值进行预测。</p>
<p>假设我们定义我们的观测值向量是一个 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 维的向量 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，一般来说我们将观测值向量视为对真实的或概念上的<strong>总体</strong>的一次<strong>随机抽样</strong>，即向量 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 是一个随机向量，向量 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的每一个元素是随机变量 。但是我们很少知道总体的分布，一般我们可能会假设总体服从多元正态分布。</p>
<h2 id="模型">模型</h2>
<p>混合线性模型表示如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7By%7D%3D%5Cmathrm%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cmathrm%7BZu%7D%2B%5Cmathbf%7Be%7D%0A" /></p><p>其中，</p>
<blockquote>
<p><img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 是一个已知的固定的 <img src="https://math.now.sh?inline=n%20%5Ctimes%20p%20%5Cquad%20%20%28n%20%3E%20p%29" style="display:inline-block;margin: 0;"/> 的矩阵， 其秩为 <img src="https://math.now.sh?inline=r%20%5Cleq%20p" style="display:inline-block;margin: 0;"/> 。<br>
<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 是一个<strong>固定</strong>的由未知参数组成的 <img src="https://math.now.sh?inline=p%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 向量 。<br>
<img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 是一个已知的固定的 <img src="https://math.now.sh?inline=n%20%5Ctimes%20q" style="display:inline-block;margin: 0;"/> 矩阵。<br>
<img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=q%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 的<strong>随机</strong>向量。<br>
<img src="https://math.now.sh?inline=%5Cmathbf%7Be%7D" style="display:inline-block;margin: 0;"/> 是由随机误差组成的 <img src="https://math.now.sh?inline=n%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 的随机向量</p>
</blockquote>
<p>注意：这里的 <img src="https://math.now.sh?inline=%5Cmathbf%7By%2C%20u%20%2Ce%7D" style="display:inline-block;margin: 0;"/> 均视为从某个真实的或者概念上的总体的一个<strong>随机抽样</strong>，即均为随机向量。这三者的均值和方差，协方差假设如下。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0AE%28%5Cmathbf%7Bu%7D%29%3D%5Cmathbf%7B0%7D%2C%20E(%5Cmathbf%7Be%7D)%3D%5Cmathbf%7B0%7D%2C%20E(%5Cmathbf%7By%7D)%3D%5Cmathbf%7BX%7D%20%5Cbeta%20%5C%5C%0A%5Coperatorname%7BVar%7D(%5Cmathbf%7Bu%7D)%3D%5Cmathbf%7BG%7D%2C%20%5Coperatorname%7BVar%7D(%5Cmathbf%7Be%7D)%3D%5Cmathbf%7BR%7D%2C%20%5Coperatorname%7BCov%7D%5Cleft(%5Cmathbf%7Bu%7D%2C%20%5Cmathbf%7Be%7D%5E%7B%5Cprime%7D%5Cright)%3D%5Cmathbf%7B0%7D%2C%20%5Coperatorname%7BVar%7D(%5Cmathbf%7By%7D)%3D%5Cmathbf%7BZ%20G%20Z%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7BR%7D%0A%5Cend%7Bgathered%7D%0A" /></p><p>这里的协方差矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%2C%20R%7D" style="display:inline-block;margin: 0;"/> 可能是已知的，也可能是未知的。由于 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Be%7D" style="display:inline-block;margin: 0;"/> 均无法观测，因此我们一般不知道 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> ，但是我们可以对这两个协方差矩阵做一些假设，从而减少估计的参数数目。我们一般假设 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> 的非对角线元素均为 0，对角线元素均相同，也就是不同样本具有相同的残差并且彼此的残差之间不相干，即假设 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D%20%3D%20%5Csigma_%7Be%7D%5E%7B2%7D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>其中 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 称为<strong>固定效应</strong>，因为其元素均为<strong>固定的不变的常数</strong>，只是我们不知道具体的值；<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cmu%7D" style="display:inline-block;margin: 0;"/> 称为<strong>随机效应</strong>，因为它是从总体得到的一次随机抽样，其元素均为随机变量，我们无法完全控制其大小。</p>
<p>除了随机误差外，完全由固定效应组成的模型称为<strong>固定效应模型</strong>，或<strong>固定模型</strong>；除群体平均数 <img src="https://math.now.sh?inline=%5Cmu" style="display:inline-block;margin: 0;"/> 之外，完全由随机效应组成的模型称为<strong>随机效应模型</strong>，简称为<strong>随机模型</strong>。</p>
<p>其实所有的线性模型都可以表示为<strong>混合线性模型</strong>，固定模型和随机模型均可以视为混合线性模型的一个特例。这样一来我们可以通过这一个模型的通式来解决所有问题（线性问题）。</p>
<p>在混合线性模型中，我们需要估计固定效应 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 和随机效应 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cmu%7D" style="display:inline-block;margin: 0;"/> ，我们将固定效应的估计称为<strong>估计</strong>，将随机效应的估计称为<strong>预测</strong>。</p>
<p>下面我们看如何通过广义最小二乘法来估计固定效应 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 。</p>
<h1>广义最小二乘</h1>
<p>在普通最小二乘中，我们假设 <img src="https://math.now.sh?inline=%5Coperatorname%7BVar%7D%28%5Cmathbf%7By%7D%29%20%3D%20%5Coperatorname%7BVar%7D(%5Cmathbf%7Be%7D)%20%3D%20%5Csigma_%7Be%7D%5E%7B2%7D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ，此时得到的正规方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%5E%7BT%7DX%20%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%20%3D%20%5Cmathbf%7BX%5E%7BT%7Dy%7D" style="display:inline-block;margin: 0;"/> 及满秩情况下的唯一解 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D_%7B%5Cmathrm%7BLS%7D%7D%3D%5Cleft%28%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BX%7D%5Cright%29%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7By%7D" style="display:inline-block;margin: 0;"/> 即为<strong>最佳线性无偏估计值</strong>  (<em>best linear unbiased estimators</em>, BLUE) 。这一部分内容可见 <a href="https://vincere.fun/posts/55264e6f/#">矩阵微分与正规方程组推导</a> 。</p>
<p>但是如果 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的协方差矩阵并不满足普通最小二乘的假设，此时如果我们仍采用普通最小二乘方法，此时得到的参数估计值就不再是 BLUE ，此时我们需要对 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 作相应的线性变换。</p>
<p>我们考虑一般的情况，假设固定模型如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%20%3D%20%5Cboldsymbol%7BX%20%5Cbeta%7D%20%2B%20%5Cmathbf%7Be%7D%0A" /></p><p>假设<img src="https://math.now.sh?inline=E%28%5Cmathbf%7Be%7D%29%20%3D%20%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/>，  <img src="https://math.now.sh?inline=%5Coperatorname%7BVar%7D%28%5Cmathbf%7By%7D%29%20%3D%20%5Coperatorname%7BVar%7D(%5Cmathbf%7Be%7D)%20%3D%20%5Cmathbf%7BV%7D%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> 为一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的相关系数矩阵，这里  <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> 是一个正定矩阵（ 因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 同样是正定矩阵）。根据正定矩阵的性质，一定存在一个非奇异矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D" style="display:inline-block;margin: 0;"/> 使得</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BQQ%5E%7B%5Cprime%7D%3D%20R%5E%7B-1%7D%7D%0A" /></p><p>用  <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D" style="display:inline-block;margin: 0;"/>  对 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 作线性变换，有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7By%7D%5E%7B*%7D%20%26%3D%5Cmathbf%7BQ%20y%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BQ%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cmathbf%7BQ%7D%20%5Cmathbf%7Be%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BX%7D%5E%7B*%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cmathbf%7Be%7D%5E%7B*%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B*%7D%3D%5Cmathbf%7BQ%7D%20%5Cmathbf%7BX%7D%2C%20%5Cquad%20%5Cmathbf%7Be%7D%5E%7B*%7D%3D%5Cmathbf%7BQ%7D%20%5Cmathbf%7Be%7D" style="display:inline-block;margin: 0;"/>  ，则</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BVar%7D%5Cleft%28%5Cmathbf%7By%7D%5E%7B*%7D%5Cright%29%3D%5Coperatorname%7BVar%7D(%5Cmathbf%7BQ%20y%7D)%3D%5Cmathbf%7BQ%7D%20%5Coperatorname%7BVar%7D(%5Cmathbf%7By%7D)%20%5Cmathbf%7BQ%7D%5E%7B%5Cprime%7D%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7BQ%7D%20%5Cmathbf%7BR%7D%20%5Cmathbf%7BQ%7D%5E%7B%5Cprime%7D%0A" /></p><p>因为 <img src="https://math.now.sh?inline=%5Cmathbf%7BQQ%5E%7B%5Cprime%7D%3D%20R%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> ，对该式左乘 <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> ，右乘  <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D%5E%7B'-1%7D" style="display:inline-block;margin: 0;"/> ，得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D%5E%7B-1%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BQ%7D%5E%7B%5Cprime-1%7D%3D%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ，即 <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%20R%20Q%7D%5E%7B%5Cprime%7D%3D%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ，于是</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BVar%7D%5Cleft%28%5Cmathbf%7By%7D%5E%7B*%7D%5Cright%29%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D%0A" /></p><p>因此，我们知道线性转换后的模型 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%5E%7B*%7D%3D%5Cmathbf%7BX%7D%5E%7B*%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cmathrm%7Be%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 符合普通最小二乘的假设，此时我们得到最小二乘方程组如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D%5E%7B*'%7D%20%5Cmathbf%7BX%7D%5E%7B*%7D%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B*'%7D%20%5Cmathbf%7By%7D%5E%7B*%7D%0A" /></p><p>将 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B*%7D%3D%5Cmathbf%7BQ%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> ， $\mathbf{y}^{*} =\mathbf{Q y} $ 带入，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cmathbf%7BX%7D%5E%7B*'%7D%20%5Cmathbf%7BX%7D%5E%7B*%7D%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B*'%7D%20%5Cmathbf%7By%7D%5E%7B*%7D%20%5C%5C%0A%26%5Cmathbf%7BX'Q'%7D%20%5Cmathbf%7BQX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX'Q'%7D%20%5Cmathbf%7BQy%7D%20%5C%5C%0A%0A%26%5Cmathbf%7BX'R%5E%7B-1%7D%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX'R%5E%7B-1%7D%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%0A%0A%5Cend%7Baligned%7D%0A" /></p><p><img src="https://math.now.sh?inline=%5Cmathbf%7BX'R%5E%7B-1%7D%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX'R%5E%7B-1%7D%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 称为 <strong>广义最小二乘方程组</strong>。 当 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 满秩时，我们得到唯一的广义最小二乘估计值 $ \boldsymbol{\hat{\beta}}= (\mathbf{X’R^{-1}} \mathbf{X})^{-1} \mathbf{X’R^{-1}} \mathbf{y}$ ，也就是最佳线性无偏估计值；当  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 不满秩时，我们有无穷个解，某个解可以表示为 $ \boldsymbol{\hat{\beta}}= (\mathbf{X’R^{-1}} \mathbf{X})^{-} \mathbf{X’R^{-1}} \mathbf{y}$ ，其中 <img src="https://math.now.sh?inline=%28%5Cmathbf%7BX'R%5E%7B-%7D%7D%20%5Cmathbf%7BX%7D%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 为任意一个广义逆，此时若  <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bq'%20%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 为可估计函数，则   <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bq'%20%5Chat%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/>  是对   <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bq'%20%5Cbeta%7D" style="display:inline-block;margin: 0;"/>  的最佳线性无偏估计。</p>
<p>对上面的<strong>广义最小二乘方程组</strong>的左右两侧均乘以 <img src="https://math.now.sh?inline=1%2F%5Csigma%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，我们得到该方程组的另一种形式。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX'V%5E%7B-1%7D%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX'V%5E%7B-1%7D%7D%20%5Cmathbf%7By%7D%0A" /></p><p>上面我们推导了固定模型的情况，我们可以轻松推广至一般的混合线性模型，设混合线性模型表达式同上，我们可以将随机效应和随机误差效应视为一体，即令 <img src="https://math.now.sh?inline=%5Cmathbf%7BZu%20%2B%20e%20%3D%20e%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> ，此时模型写为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%20%3D%20%5Cboldsymbol%7BX%20%5Cbeta%7D%20%2B%20%5Cmathbf%7Be%7D%5E%7B*%7D%0A" /></p><p>此时，<img src="https://math.now.sh?inline=%5Coperatorname%7BVar%7D%28%5Cmathbf%7By%7D%29%20%3D%20%5Coperatorname%7BVar%7D(%5Cmathbf%7Be%5E%7B*%7D%7D)%20%3D%5Cmathbf%7BZ%20G%20Z%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> ，即此时 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D%20%3D%5Cmathbf%7BZ%20G%20Z%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> ，同样有 <img src="https://math.now.sh?inline=%5Cmathbf%7BX'V%5E%7B-1%7D%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX'V%5E%7B-1%7D%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 方程组成立。</p>
<h2 id="另一种证明">另一种证明</h2>
<p>我们接着延续高斯-马尔可夫定理的思想，从所有的线性无偏估计值中找到一个“最佳的”估计值，这里“最佳”的意思是指估计值</p>
<p>具有<strong>最小的</strong>方差。</p>
<p>根据线性，我们设 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的最佳线性无偏估计值为 $  \mathbf{L’ y}$ 。同时根据无偏性，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BE%7D%5Cleft%28%5Cmathbf%7BL%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%3D%5Cmathbf%7BL%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D%20%5Cboldsymbol%7B%5Cbeta%7D%0A" /></p><p>该式对所有可能的 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 均成立，因此我们有 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%3D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>估计值的协方差矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BVar%7D%5Cleft%28%5Cmathbf%7BL%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%3D%20%5Cmathbf%7BL'%20V%20L%7D%0A" /></p><p>因此，我们的问题变成求在 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%3D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> 的约束条件下使得协方差矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BL'%20V%20L%7D" style="display:inline-block;margin: 0;"/> 的对角线元素最小的矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> ，我们构建拉格朗日函数如下（采用迹函数来得到所有参数估计值的方差之和），其中 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Ctheta%7D" style="display:inline-block;margin: 0;"/> 为拉格朗日乘子构成的矩阵。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BF%7D%20%3D%20%5Cmathrm%7Btr%7D%5Cleft%28%5Cmathbf%7BL'%20V%20L%7D%5Cright%29%20%2B%20%5Cmathrm%7Btr%7D%5Cleft((%5Cmathbf%7BL%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20-%20%5Cmathbf%7BI%7D)%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Ctheta%7D%5Cright)%20%3D%20%5Cmathrm%7Btr%7D%5Cleft(%5Cmathbf%7BL'%20V%20L%7D%5Cright)%20%2B%20%5Cmathrm%7Btr%7D%5Cleft(%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BL%7D%20%5Cboldsymbol%7B%5Ctheta%7D%20%20-%20%5Cboldsymbol%7B%5Ctheta%7D%20%5Cright)%0A" /></p><p>分别对  <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/>  和  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Ctheta%7D" style="display:inline-block;margin: 0;"/> 求微分，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cpartial%20%5Cmathbf%7BF%7D%20%2F%20%5Cpartial%20%5Cmathbf%7BL%7D%3D2%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BL%7D%2B%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Ctheta%7D%5E%7B%5Cprime%7D%3D0%20%5C%5C%0A%26%5Cpartial%20%5Cmathbf%7BF%7D%20%2F%20%5Cpartial%20%5Cboldsymbol%7B%5Ctheta%7D%3D%5Cmathbf%7BI%7D-%5Cmathbf%7BL%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%3D0%0A%5Cend%7Baligned%7D%0A" /></p><p>上面两式整理可得</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A2%20%5Cmathbf%7BV%7D%20%26%20%5Cmathbf%7BX%7D%20%5C%5C%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%26%20%5Cmathbf%7B0%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BL%7D%20%5C%5C%0A%5Cboldsymbol%7B%5Ctheta%7D%5E%7B%5Cprime%7D%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7BI%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>如果我们假设左手项的系数矩阵是可逆的，那么根据分块矩阵求逆公式，我们有下式成立</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0AA%20%26%20B%20%5C%5C%0AC%20%26%200%0A%5Cend%7Barray%7D%5Cright%5D%5E%7B-1%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0AA%5E%7B-1%7D-A%5E%7B-1%7D%20B%5Cleft%28C%20A%5E%7B-1%7D%20B%5Cright%29%5E%7B-1%7D%20C%20A%5E%7B-1%7D%20%26%20A%5E%7B-1%7D%20B%5Cleft(C%20A%5E%7B-1%7D%20B%5Cright)%5E%7B-1%7D%20%5C%5C%0A%5Cleft(C%20A%5E%7B-1%7D%20B%5Cright)%5E%7B-1%7D%20C%20A%5E%7B-1%7D%20%26%20-%5Cleft(C%20A%5E%7B-1%7D%20B%5Cright)%5E%7B-1%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>因此，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A2%20%5Cmathbf%7BV%7D%20%26%20%5Cmathbf%7BX%7D%20%5C%5C%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%26%20%5Cmathbf%7B0%7D%0A%5Cend%7Barray%7D%5Cright%5D%5E%7B-1%7D%0A%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cfrac%7B1%7D%7B2%7D%20%5Cmathbf%7BV%5E%7B-1%7D%7D%28%5Cmathbf%7BI-X(X'V%5E%7B-1%7DX%29%5E%7B-1%7DX'V%5E%7B-1%7D%7D)%20%26%20%5Cmathbf%7BV%5E%7B-1%7DX(X'V%5E%7B-1%7DX)%5E%7B-1%7D%7D%20%5C%5C%0A%5Cmathbf%7B(X'V%5E%7B-1%7DX)%5E%7B-1%7DX'V%5E%7B-1%7D%7D%20%26%20-2%20%5Cmathbf%7B(X'V%5E%7B-1%7DX)%5E%7B-1%7D%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>此时我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BL%7D%20%3D%20%5Cmathbf%7BV%5E%7B-1%7DX%28X'V%5E%7B-1%7DX%29%5E%7B-1%7D%7D%0A" /></p><p>因此此时的广义最小二乘估计值为</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%20%3D%20%20%20%5Cmathbf%7BL'%20y%7D%20%3D%20%5Cmathbf%7B%28X'V%5E%7B-1%7DX%29%5E%7B-1%7DX'V%5E%7B-1%7Dy%7D%0A" /></p><p>如果左手项的系数矩阵是秩亏缺的，我暂时还不知道如何证明，不知道这个分块矩阵的广义逆的表达形式。但是我们设下式为系数矩阵的一个广义逆 (分块方式相同)</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BC%7D_%7B11%7D%20%26%20%5Cmathbf%7BC%7D_%7B12%7D%20%5C%5C%0A%5Cmathbf%7BC%7D_%7B21%7D%20%26%20%5Cmathbf%7BC%7D_%7B22%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>那么我们易得 $ \mathbf{L = C_{12}}$ ，$\boldsymbol{\hat{\beta}} =   \mathbf{L’ y} = \mathbf{C_{12}^{\prime} y} $ 。我们已知 $ \boldsymbol{\hat{\beta}}= (\mathbf{X’R^{-1}} \mathbf{X})^{-1} \mathbf{X’R^{-1}} \mathbf{y}$ ，因此应该存在  $ \mathbf{C_{12}^{\prime}} = (\mathbf{X’R^{-1}} \mathbf{X})^{-1} \mathbf{X’R^{-1}}$ 。</p>
<h1>参考文献</h1>
<ol>
<li>Henderson，《Applications_of_Linear_Models_in_Animal_Breeding》, 1984</li>
<li>张沅，张勤，《畜禽育种中的线性模型》</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>批量下载R包</title>
    <url>/posts/c4bb4461/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在一个新服务器上重新安装一堆R包，估计是最让人头疼的事情之一了。</p>
<span id="more"></span>
<h1>第一种方式，复制黏贴 <code>library</code> 文件夹</h1>
<p>如果你在两个服务器中安装的 R 的版本相同，那么最简单的方式就是从旧服务器中R的目录中找到 <code>library</code> 文件夹（比如我的在 <code>*/miniConda/miniconda3/lib/R/library</code> ），然后黏贴到新服务器的相同目录下（记得备份一下新服务器的 <code>library</code> 文件夹 ），如果你够幸运的话就没啥问题了。</p>
<p>但是我旧的R版本是 3.6 ，新的 R 版本是 4.0 ，复制黏贴过去运行R直接报错，这条路就不通了。</p>
<h1>第二种方式，批量安装</h1>
<h2 id="1-查找所有需要安装的-R-包">1. 查找所有需要安装的 R 包</h2>
<p>我采用下面的命令行，在脚本文件夹中便利所有内容，找到所有加载R包的语句</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat * | grep &quot;library(&quot; | sort | uniq</span><br></pre></td></tr></table></figure>
<p>找到一堆 <code>library(*)</code> 的语句后，我是直接复制到 Excel 里，用 excel 的智能填充提取 R 包名称（快捷键为 ctrl+e）, 然后用 f9 提取数组信息提取所有包名，简单处理后得到所有 R 包名称序列，如下。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">all_packages &lt;- <span class="built_in">c</span>(<span class="string">&quot;*&quot;</span>,<span class="string">&quot;*&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="2-简单区分R包来源并安装">2. 简单区分R包来源并安装</h2>
<p>我们通过 <code>available.packages()</code> 函数提取 CRAN 中所有可用的R包</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ap &lt;- available.packages() <span class="comment"># cran 中所有可用的包</span></span><br></pre></td></tr></table></figure>
<p>我们先简单地将需要安装的 R 包分为两类，如果在 <code>ap</code> 中则视为 CRAN 中的 R 包，采用 <code>install.packages()</code> 来安装；如果不在 <code>ap</code> 中则视为 Bioconductor 中的 R 包，采用 <code>BiocManager::install()</code> 命令来安装。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">cran_packages &lt;- all_packages[all_packages %in% rownames(ap)]</span><br><span class="line"><span class="comment"># length(cran_packages)</span></span><br><span class="line"></span><br><span class="line">bio_packages &lt;- all_packages[!(all_packages %in% rownames(ap))]</span><br><span class="line"><span class="comment"># length(bio_packages)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">install.packages(cran_packages) <span class="comment"># 一次性安装所有的 cran 包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!requireNamespace(<span class="string">&quot;BiocManager&quot;</span>, quietly = <span class="literal">TRUE</span>))</span><br><span class="line">    install.packages(<span class="string">&quot;BiocManager&quot;</span>)</span><br><span class="line"></span><br><span class="line">BiocManager::install(bio_packages) <span class="comment"># 一次性安装所有的 bioconductor 包</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-确定哪些R包没有安装成功">3. 确定哪些R包没有安装成功</h2>
<p>将所有需要安装的R包，与所有已经安装的R包进行配对，确定哪些R包没有安装成功</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所有已经安装的 R 包</span></span><br><span class="line"></span><br><span class="line">installed_packages = row.names(installed.packages())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看哪些 R 包还没有安装</span></span><br><span class="line"></span><br><span class="line">no_cran_packages = cran_packages[!(cran_packages %in% installed_packages)]</span><br><span class="line">no_cran_packages <span class="comment"># 2 个 [1] &quot;ggpubr&quot; &quot;car&quot;</span></span><br><span class="line"></span><br><span class="line">no_bio_packages = bio_packages[!(bio_packages %in% installed_packages)]</span><br><span class="line">no_bio_packages <span class="comment"># 0 个</span></span><br><span class="line"></span><br><span class="line">install.packages(no_cran_packages) <span class="comment"># 再来一次</span></span><br><span class="line"></span><br><span class="line">BiocManager::install(no_bio_packages) <span class="comment"># 再来一次</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-需要特殊安装的-R-包">4. 需要特殊安装的 R 包</h2>
<p>有些 R 包其实是从 GitHub 安装的，或者从别的地方安装，因此需要特殊安装一下。</p>
<p>如果你足够幸运的话，你到这一步应该就把所有的 R 包都安装好了，还有没装好的，估计就是遇到问题了。</p>
<h2 id="5-始终安装失败的包，手动下载安装">5.  始终安装失败的包，手动下载安装</h2>
<p>我有两个  CRAN 中的 R 包一直安装不下来，<code>ggpubr</code> 和 <code>car</code> ， 本来打算手动安装。因为存在附属包的情况，所以手动安装往往需要 “套娃式” 安装。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 手动安装 ggpubr， 事先安装 rstatix</span></span><br><span class="line"><span class="built_in">R</span> CMD INSTALL /mnt/<span class="keyword">data</span>/zhouziwen/lib/R_packages/ggpubr_0.<span class="number">4.0</span>.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动安装  car, 事先安装 pbkrtest lme4</span></span><br><span class="line"><span class="built_in">R</span> CMD INSTALL /mnt/<span class="keyword">data</span>/zhouziwen/lib/R_packages/nloptr_2.<span class="number">0.0</span>.tar.gz</span><br><span class="line"><span class="built_in">R</span> CMD INSTALL /mnt/<span class="keyword">data</span>/zhouziwen/lib/R_packages/lme4_1.<span class="number">1</span><span class="literal">-13</span>.tar.gz</span><br><span class="line"><span class="built_in">R</span> CMD INSTALL /mnt/<span class="keyword">data</span>/zhouziwen/lib/R_packages/pbkrtest_0.<span class="number">5.1</span>.tar.gz</span><br><span class="line"><span class="built_in">R</span> CMD INSTALL /mnt/<span class="keyword">data</span>/zhouziwen/lib/R_packages/car_3.<span class="number">0</span><span class="literal">-12</span>.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>并且，手动安装还是遇到了相同的报错。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CMake Error: The source directory &quot;/tmp/RtmpGALOB5/R.INSTALL62081f90ce01/nloptr/src/nlopt-build&quot; does not exist.</span><br><span class="line">Specify --help for usage, or press the help button on the CMake GUI</span><br></pre></td></tr></table></figure>
<p>此时，真正消耗时间和心情的步骤才来了，然后我就在网上搜索这个报错，没有找到清晰的答案（R 包安装不上的情况貌似一向如此，基本上找不到明白的答案，或者说别人的答案你试了可能还是没用）。</p>
<h2 id="5-1-重装-cmake">5.1 重装 cmake</h2>
<p>然后一番东搞西搞以后，我发现有一个 <code>cmake</code> 软件，从 <a href="https://cmake.org/download/">https://cmake.org/download/</a> 下载 <code>cmake-3.22.2-linux-x86_64.tar.gz </code> ，然后先解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zvxf cmake-3.22.2-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压以后，<code>bin</code> 文件夹中就有新的 <code>cmake</code> 软件，将这个 <code>bin</code> 文件夹加入到环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH&#x3D;&quot;*&#x2F;cmake-3.22.2-linux-x86_64&#x2F;bin:$PATH&quot;</span><br></pre></td></tr></table></figure>
<p>之前的版本是 2.8 ，现在的版本如下，估计可能就是版本太低了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cmake --version</span></span><br><span class="line">cmake version 3.22.2</span><br><span class="line"></span><br><span class="line">CMake suite maintained and supported by Kitware (kitware.com/cmake).</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后正常用 <code>install.packages()</code> 命令来安装 <code>ggpubr</code> 和 <code>car</code> 就正常了。</p>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>R</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>奇异值分解与穆尔-彭罗斯伪逆</title>
    <url>/posts/bc1cea9f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>根据奇异值分解得到穆尔-彭罗斯伪逆的一个表达方式，同时证明不满秩情况下最小二乘问题的穆尔-彭罗斯伪逆的解为最小范数最小二乘解。</p>
<span id="more"></span>
<p>本章节内容主要来自于《Linear Algebra with Applications》的第七章数值线性代数。</p>
<h1>奇异值分解</h1>
<p>简要介绍可见<a href="https://vincere.fun/posts/fc532062/#%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3">PCA分析公式推导</a></p>
<p>简单地说，任何一个矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> ，均可以通过奇异值分解拆分为下式：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%20%3D%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7BT%7D%7D%0A" /></p><h1>穆尔-彭罗斯伪逆</h1>
<p>我们知道矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的一个广义逆只需要满足下式，但是这样的广义逆矩阵不是唯一的，存在明显的缺陷。</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%7D%5E%7B-%7D%20%5Cboldsymbol%7BA%7D%3D%5Cboldsymbol%7BA%7D%0A" /></p><p>如果一个实矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B%2B%7D" style="display:inline-block;margin: 0;"/> 满足下面四个条件 (常称 Moore-Penrose 条件)，则矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B%2B%7D" style="display:inline-block;margin: 0;"/> 是<strong>唯一</strong>的，称为穆尔-彭罗斯伪逆。</p>
<p>(1) <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%5E%2B%7D%20%5Cboldsymbol%7BA%7D%3D%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/>;<br>
(2) <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%5E%2B%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%5E%2B%7D%3D%5Cboldsymbol%7BA%5E%2B%7D%20%3B" style="display:inline-block;margin: 0;"/><br>
(3) <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%20A%7D%5E%7B%2B%7D" style="display:inline-block;margin: 0;"/> 为实对称矩阵, 即 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%3D%5Cleft%28%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%5Cright%29%5E%7B%5Cmathrm%7BT%7D%7D" style="display:inline-block;margin: 0;"/>;<br>
(4) <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%5E%2B%7D%20%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 为实对称矩阵, 即 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%20%5Cboldsymbol%7BA%7D%3D%5Cleft%28%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%20%5Cboldsymbol%7BA%7D%5Cright%29%5E%7B%5Cmathrm%7BT%7D%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>如果矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的秩为 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> 的矩阵，我们将其进行奇异值分解，得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%3D%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/> ，其中矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵，并且可以拆分为 (注：矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的秩等于非零的奇异值的数目)</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%5CSigma%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7Cl%7D%0A%5Cmathbf%7B%5CSigma%7D_%7B1%7D%20%26%20O%20%5C%5C%0A%5Chline%20O%20%26%20O%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bllll%7Cl%7D%0A%5Csigma_%7B1%7D%20%26%20%26%20%26%20%26%20%5C%5C%0A%26%20%5Csigma_%7B2%7D%20%26%20%26%20%26%200%20%5C%5C%0A%26%20%26%20%5Cddots%20%26%20%26%20%5C%5C%0A%5Chline%20%26%20%26%20O%20%26%20%26%200%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>同时我们定义 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%5E%2B%7D" style="display:inline-block;margin: 0;"/> 是一个 $n \times m $ 的矩阵</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%5CSigma%5E%2B%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7Cc%7D%0A%5Cmathbf%7B%5CSigma%7D_%7B1%7D%5E%7B-1%7D%20%26%20O%20%5C%5C%0A%5Chline%20O%20%26%20O%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7Cc%7D%0A%5Cfrac%7B1%7D%7B%5Csigma_%7B1%7D%7D%20%26%20%5Cddots%20%26%20%26%20O%20%5C%5C%0A%26%20%26%20%5Cfrac%7B1%7D%7B%5Csigma_%7Br%7D%7D%20%26%20%5C%5C%0A%5Chline%20%26%20%26%20O%20%26%20O%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>我们可以证明穆尔-彭罗斯伪逆可以表示为下式</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%5E%7B%2B%7D%7D%3D%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D%0A" /></p><p>易证明该式符合上面的四个条件。</p>
<p><strong>证明</strong>：</p>
<p>首先易得 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D%20%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D%20%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 格式均为下式</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7Cl%7D%0A%5Cmathbf%7BI%7D%20%26%20O%20%5C%5C%0A%5Chline%20O%20%26%20O%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>因此易得 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D%20%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D%20%5Cmathbf%7B%5CSigma%7D%20%3D%20%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D%20%5Cmathbf%7B%5CSigma%7D%20%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D%20%3D%20%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/> ，同时   <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D%20%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D%20%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 均为对称矩阵，因此  <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/> 是  <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 的穆尔-彭罗斯伪逆。</p>
<p>然后我们证明 $ \mathbf{A^{+}}=\mathbf{V \Sigma^{+} U^{\mathrm{T}}}$ 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的 穆尔-彭罗斯伪逆，过程如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%5E%2B%7D%20%5Cboldsymbol%7BA%7D%0A%26%20%3D%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7BT%7D%7D%20%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%20%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7BT%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BU%20%5CSigma%20%5CSigma%5E%7B%2B%7D%20%5CSigma%20V%5E%7BT%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7BT%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BA%7D%20%5C%5C%0A%0A%5C%5C%0A%0A%5Cboldsymbol%7BA%5E%2B%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%5E%2B%7D%0A%26%3D%20%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7BT%7D%7D%20%20%20%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20%5CSigma%20%5CSigma%5E%7B%2B%7D%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7DU%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BA%5E%7B%2B%7D%7D%20%5C%5C%0A%0A%5C%5C%0A%0A%5Cleft%28%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%5Cright%29%0A%26%3D%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7BT%7D%7D%20%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BU%20%5CSigma%20%7D%20%5Cmathbf%7B%20%5CSigma%5E%7B%2B%7D%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%5C%5C%0A%0A%0A%5Cleft(%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%5Cright)%5E%7B%5Cmathrm%7BT%7D%7D%20%0A%26%3D%20(%5Cmathbf%7BU%20%5CSigma%20%7D%20%5Cmathbf%7B%20%5CSigma%5E%7B%2B%7D%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D%20)%5E%7B%5Cmathrm%7BT%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BU%7D%20(%5Cmathbf%7B%20%5CSigma%20%20%5CSigma%5E%7B%2B%7D%20%7D)%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7B%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%20%5C%5C%0A%26%3D%20%5Cmathbf%7BU%7D%20%5Cmathbf%7B%20%5CSigma%20%20%5CSigma%5E%7B%2B%7D%20%7D%20%5Cmathbf%7B%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%20%5C%5C%0A%26%3D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%0A%0A%5C%5C%0A%0A%5Cleft(%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%20%5Cboldsymbol%7BA%7D%5Cright)%20%0A%26%3D%20%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7BT%7D%7D%20%20%20%5C%5C%0A%26%3D%20%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20%5CSigma%20V%5E%7BT%7D%7D%20%20%5C%5C%0A%0A%5Cleft(%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%20%5Cboldsymbol%7BA%7D%5Cright)%5E%7B%5Cmathrm%7BT%7D%7D%20%0A%26%3D%20(%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20%5CSigma%20V%5E%7BT%7D%7D%20)%5E%7B%5Cmathrm%7BT%7D%7D%20%20%5C%5C%0A%26%3D%20%5Cmathbf%7BV%20(%5CSigma%5E%7B%2B%7D%20%5CSigma)%5E%7B%5Cmathrm%7BT%7D%7D%20V%5E%7BT%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20%5CSigma%20V%5E%7BT%7D%7D%20%5C%5C%0A%26%3D%20%5Cboldsymbol%7BA%5E%7B%2B%7D%7D%20%5Cboldsymbol%7BA%7D%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><h1>满秩情况下的最小二乘解</h1>
<p>在正规方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B%5Cmathrm%7BT%7D%7D%20A%7D%20%5Cmathbf%7Bx%7D%20%3D%20%5Cmathbf%7BA%5E%7B%5Cmathrm%7BT%7D%7D%20b%7D" style="display:inline-block;margin: 0;"/> 中，如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 且秩为 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 的满秩矩阵，<img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的奇异值分解为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%3D%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/> ，因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cleft%28%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%5Cright%29%5E%7B-1%7D%0A%26%3D%20(%5Cmathbf%7BV%20%5CSigma%5E%7BT%7D%20U%5E%7BT%7D%7D%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7BT%7D%7D)%5E%7B-1%7D%20%5C%5C%0A%26%3D%20(%5Cmathbf%7BV%20%5CSigma%5E%7BT%7D%20%5CSigma%20V%5E%7BT%7D%7D)%5E%7B-1%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BV%20(%5CSigma%5E%7BT%7D%20%5CSigma)%5E%7B-1%7D%20V%5E%7BT%7D%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>此时 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 的拆分形式为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%5CSigma%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Br%7D%0A%5Cmathbf%7B%5CSigma%7D_%7B1%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>因此 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%5E%7BT%7D%20%5CSigma%7D%20%3D%20%5Cmathbf%7B%5CSigma%5E%7BT%7D_%7B1%7D%20%5CSigma_%7B1%7D%7D%20%3D%20%5Cmathbf%7B%5CSigma_%7B1%7D%5E%7B2%7D%7D" style="display:inline-block;margin: 0;"/> ，因此我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%5Cright%29%5E%7B-1%7D%20%3D%20%5Cmathbf%7BV%20%5CSigma%5E%7B-2%7D_%7B1%7D%20V%5E%7BT%7D%7D%0A" /></p><p>正规方程组的解为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7Bx%7D%20%0A%0A%26%3D%20%5Cleft%28%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%5Cright%29%5E%7B-1%7D%20%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7Bb%7D%5C%5C%0A%0A%26%3D%20%5Cmathbf%7BV%20%5CSigma%5E%7B-2%7D_%7B1%7D%20V%5E%7BT%7D%7D%20%5Cmathbf%7BV%20%5CSigma%5E%7BT%7D%20U%5E%7BT%7D%7D%20%5Cmathbf%7Bb%7D%20%5C%5C%0A%0A%26%3D%20%5Cmathbf%7BV%20%5CSigma%5E%7B-2%7D_%7B1%7D%20%20%5CSigma%5E%7BT%7D%20U%5E%7BT%7D%7D%20%5Cmathbf%7Bb%7D%20%5C%5C%0A%0A%26%3D%20%5Cmathbf%7BV%20%5CSigma%5E%7B-2%7D_%7B1%7D%20%20%5Cleft%5B%5Cbegin%7Barray%7D%7Br%7D%0A%5Cmathbf%7B%5CSigma%7D_%7B1%7D%20%26%0A%5Cmathbf%7B0%7D%0A%5Cend%7Barray%7D%5Cright%5D%20U%5E%7BT%7D%7D%20%5Cmathbf%7Bb%7D%20%5C%5C%0A%0A%26%3D%20%5Cmathbf%7BV%20%20%20%5Cleft%5B%5Cbegin%7Barray%7D%7Br%7D%0A%5Cmathbf%7B%5CSigma%7D_%7B1%7D%5E%7B-1%7D%20%26%0A%5Cmathbf%7B0%7D%0A%5Cend%7Barray%7D%5Cright%5D%20U%5E%7BT%7D%7D%20%5Cmathbf%7Bb%7D%20%5C%5C%0A%0A%26%3D%20%5Cmathbf%7BV%20%20%20%5CSigma%5E%7B%2B%7D%20U%5E%7BT%7D%20%5Cmathbf%7Bb%7D%7D%20%5C%5C%0A%0A%26%3D%20%5Cmathbf%7BA%5E%7B%2B%7D%20b%7D%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>也就是说，如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 满秩，那么最小二乘问题的解为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B%2B%7D%20b%7D" style="display:inline-block;margin: 0;"/> 。</p>
<h1>不满秩情况下的最小范数最小二乘解</h1>
<p>不满秩情况下，最小二乘问题有无穷多个解，我们证明  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B%2B%7D%20b%7D" style="display:inline-block;margin: 0;"/>  不仅是其中的一个解，而且是 L2 范数最小的解，即<strong>最小范数最小二乘解</strong>。</p>
<p>此时设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 且秩为 <img src="https://math.now.sh?inline=r%20%3C%20n" style="display:inline-block;margin: 0;"/> 的不满秩矩阵，<img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的奇异值分解为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%3D%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>令 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=%5Cmathrm%7BR%5E%7Bn%7D%7D" style="display:inline-block;margin: 0;"/> 中的一个向量，并定义</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bc%7D%3D%5Cmathbf%7BU%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7Bb%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cboldsymbol%7Bc%7D_%7B1%7D%20%5C%5C%0A%5Cboldsymbol%7Bc%7D_%7B2%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5Cquad%20%5Ctext%20%7B%20%2C%20%7D%20%5Cquad%20%5Cboldsymbol%7By%7D%3DV%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7Bx%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cboldsymbol%7By%7D_%7B1%7D%20%5C%5C%0A%5Cboldsymbol%7By%7D_%7B2%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>其中  <img src="https://math.now.sh?inline=%5Cmathbf%7Bc%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 均为 <img src="https://math.now.sh?inline=%5Cmathrm%7BR%5E%7Br%7D%7D" style="display:inline-block;margin: 0;"/> 中的一个向量，由于 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/> 是一个正交矩阵，因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5C%7C%5Cboldsymbol%7Bb%7D-%5Cmathbf%7BA%7D%20%5Cboldsymbol%7Bx%7D%5C%7C_%7B2%7D%5E%7B2%7D%0A%0A%26%3D%5C%7C%5Cmathbf%7BU%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%28%5Cboldsymbol%7Bb%7D-%5Cmathbf%7BA%7D%20%5Cboldsymbol%7Bx%7D%29%5C%7C_%7B2%7D%5E%7B2%7D%20%5C%5C%0A%0A%26%3D%5Cleft%5C%7C%5Cmathbf%7BU%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7Bb%7D-%5Cmathbf%7B%5CSigma%7D%5Cleft(%5Cmathbf%7BV%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7Bx%7D%5Cright)%5Cright%5C%7C_%7B2%7D%5E%7B2%7D%5C%5C%0A%26%3D%5C%7C%5Cmathbf%7Bc%7D-%5Cmathbf%7B%5CSigma%20y%7D%5C%7C_%7B2%7D%5E%7B2%7D%5C%5C%0A%26%3D%5Cleft%5C%7C%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7Bc_%7B1%7D%7D%20%5C%5C%0A%5Cmathbf%7Bc_%7B2%7D%7D%0A%5Cend%7Barray%7D%5Cright%5D-%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7B%5CSigma_%7B1%7D%7D%20%26%20%5Cmathbf%7BO%7D%20%5C%5C%0A%5Cmathbf%7BO%7D%20%26%20%5Cmathbf%7BO%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7By_%7B1%7D%7D%20%5C%5C%0A%5Cmathbf%7By_%7B2%7D%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cright%5C%7C_%7B2%7D%5E%7B2%7D%5C%5C%0A%26%3D%5Cleft%5C%7C%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7Bc_%7B1%7D-%5CSigma_%7B1%7D%20y_%7B1%7D%7D%20%5C%5C%0A%5Cmathbf%7Bc_%7B2%7D%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cright%5C%7C_%7B2%7D%5E%7B2%7D%5C%5C%0A%26%3D%5Cleft%5C%7C%5Cmathbf%7Bc_%7B1%7D-%5CSigma_%7B1%7D%20y_%7B1%7D%7D%5Cright%5C%7C_%7B2%7D%5E%7B2%7D%2B%5Cleft%5C%7C%5Cmathbf%7Bc_%7B2%7D%7D%5Cright%5C%7C_%7B2%7D%5E%7B2%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>由于 <img src="https://math.now.sh?inline=%5Cmathbf%7Bc%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> 与 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> (线性) 无关，可得 <img src="https://math.now.sh?inline=%5C%7C%5Cboldsymbol%7Bb%7D-%5Cmathbf%7BA%7D%20%5Cboldsymbol%7Bx%7D%5C%7C_%7B2%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 取得最小值的充要条件为 <img src="https://math.now.sh?inline=%5Cmathbf%7Bc_%7B1%7D-%5CSigma_%7B1%7D%20y_%7B1%7D%20%3D%200%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>因此最小二乘解的充要条件为 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%20%3D%20Vy%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 向量的形式为</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7B%5CSigma_%7B1%7D%5E%7B-1%7D%20c_%7B1%7D%7D%20%5C%5C%0A%5Cmathbf%7By_%7B2%7D%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>当 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D_%7B2%7D%20%3D%20%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> 时，此时的 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> 为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cboldsymbol%7Bx%7D%20%26%3D%20%5Cmathbf%7BV%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7B%5CSigma_%7B1%7D%5E%7B-1%7D%7D%20%5Cboldsymbol%7Bc%7D_%7B1%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%3D%5Cmathbf%7BV%7D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7B%5CSigma_%7B1%7D%7D%5E%7B-1%7D%20%26%20%5Cmathbf%7BO%7D%20%5C%5C%0A%5Cmathbf%7BO%7D%20%26%20%5Cmathbf%7BO%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cboldsymbol%7Bc%7D_%7B1%7D%20%5C%5C%0A%5Cboldsymbol%7Bc%7D_%7B2%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%3D%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%5Cboldsymbol%7Bb%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BA%5E%7B%2B%7D%7D%20%5Cboldsymbol%7Bb%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>也就是说证明了   <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B%2B%7D%20b%7D" style="display:inline-block;margin: 0;"/>  是其中的一个解。</p>
<p>如果 <img src="https://math.now.sh?inline=%5Cmathbf%7Bz%7D" style="display:inline-block;margin: 0;"/> 是任何其他的解，则  <img src="https://math.now.sh?inline=%5Cmathbf%7Bz%7D" style="display:inline-block;margin: 0;"/>  的形式必须为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bz%7D%3D%5Cmathbf%7BV%20y%7D%3D%5Cmathbf%7BV%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7B%5CSigma_%7B1%7D%5E%7B-1%7D%20c_%7B1%7D%7D%20%5C%5C%0A%5Cmathbf%7By_%7B2%7D%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D_%7B2%7D%20%5Cneq%20%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/>  由此可得</p>
<p style=""><img src="https://math.now.sh?from=%5C%7C%5Cmathbf%7Bz%7D%5C%7C%5E%7B2%7D%3D%5C%7C%5Cmathbf%7By%7D%5C%7C%5E%7B2%7D%3D%5Cleft%5C%7C%5Cmathbf%7B%5CSigma_%7B1%7D%5E%7B-1%7D%20c_%7B1%7D%7D%5Cright%5C%7C%5E%7B2%7D%2B%5Cleft%5C%7C%5Cmathbf%7By_%7B2%7D%7D%5Cright%5C%7C%5E%7B2%7D%3E%5Cleft%5C%7C%5Cmathbf%7B%5CSigma_%7B1%7D%5E%7B-1%7D%20c_%7B1%7D%7D%5Cright%5C%7C%5E%7B2%7D%3D%5C%7C%5Cmathbf%7Bx%7D%5C%7C%5E%7B2%7D%0A" /></p><p>因此我们证明了   <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B%2B%7D%20b%7D" style="display:inline-block;margin: 0;"/>  是最小范数最小二乘解。</p>
<h2 id="证明-mathbf-A-mathrm-’-A-A-prime-A">证明  <img src="https://math.now.sh?inline=%5Cmathbf%7B%28A%5E%7B%5Cmathrm%7B%E2%80%99%7D%7D%20A%29%5E%7B%2B%7DA%5E%7B%5Cprime%7D%20%3D%20A%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/></h2>
<p>如果我们对正规方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B%5Cmathrm%7B'%7D%7D%20A%7D%20%5Cmathbf%7Bx%7D%20%3D%20%5Cmathbf%7BA%5E%7B%5Cmathrm%7B'%7D%7D%20b%7D" style="display:inline-block;margin: 0;"/> 直接求伪逆，得到 $ \mathbf{x = (A^{\mathrm{‘}} A)^{+}A^{’} b}$ ，因此应该存在  <img src="https://math.now.sh?inline=%5Cmathbf%7B%28A%5E%7B%5Cmathrm%7B'%7D%7D%20A%29%5E%7B%2B%7DA%5E%7B'%7D%20%3D%20A%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/>  ，证明这个式子需要用到穆尔-彭罗斯伪逆的一些性质。</p>
<p>首先我们证明 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BA%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BA%7D%5Cright%29%5E%7B%5Cmathbf%7B%2B%7D%7D%3D%5Cmathbf%7BA%5E%2B%7D%5Cleft(%5Cmathbf%7BA%5E%2B%7D%5Cright)%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，根据  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%3D%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7B%5Cprime%7D%7D" style="display:inline-block;margin: 0;"/> ，我们得到  <img src="https://math.now.sh?inline=%5Cmathbf%7BA'A%7D%20%3D%20%5Cmathbf%7BV%20%28%5CSigma%5E%7B'%7D%20%5CSigma%29%20V%5E%7B%E2%80%99%7D%7D" style="display:inline-block;margin: 0;"/> ，易证明该式就是 <img src="https://math.now.sh?inline=%5Cmathbf%7BA'A%7D" style="display:inline-block;margin: 0;"/>  的奇异值分解形式，因此  <img src="https://math.now.sh?inline=%5Cmathbf%7B%28A'A%29%5E%7B%2B%7D%7D%20%3D%20%5Cmathbf%7BV%20(%5CSigma%5E%7B'%7D%20%5CSigma)%5E%7B%2B%7D%20V%5E%7B%5Cprime%7D%7D" style="display:inline-block;margin: 0;"/> , 其中  <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%5E%7B'%7D%7D%20%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 格式为下式</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7Cl%7D%0A%5Cmathbf%7B%5CSigma_%7B1%7D%5E%7B2%7D%7D%20%26%20O%20%5C%5C%0A%5Chline%20O%20%26%20O%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>易得  <img src="https://math.now.sh?inline=%28%5Cmathbf%7B%5CSigma%5E%7B'%7D%7D%20%5Cmathbf%7B%5CSigma%7D%29%5E%7B%2B%7D%20%3D%20%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D%20%5Cmathbf%7B(%5CSigma%5E%7B'%7D)%5E%7B%2B%7D%7D%20%3D%20%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D%20%5Cmathbf%7B(%5CSigma%5E%7B%2B%7D)%5E%7B'%7D%7D" style="display:inline-block;margin: 0;"/>  ，因此我们得证</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%28A'A%29%5E%7B%2B%7D%7D%20%3D%20%5Cmathbf%7BV%20(%5CSigma%5E%7B'%7D%20%5CSigma)%5E%7B%2B%7D%20V%5E%7B%5Cprime%7D%7D%20%20%3D%20%5Cmathbf%7BV%20%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D%20%5Cmathbf%7B(%5CSigma%5E%7B%2B%7D)%5E%7B'%7D%7D%20V%5E%7B%5Cprime%7D%7D%20%3D%20%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20U%5E%7BT%7D%20U%20(%5CSigma%5E%7B%2B%7D)%5E%7B'%7D%20V%5E%7B%5Cprime%7D%7D%20%3D%5Cmathbf%7BA%5E%2B%7D%5Cleft(%5Cmathbf%7BA%5E%2B%7D%5Cright)%5E%7B%5Cprime%7D%0A" /></p><p>因此，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7B%28A%5E%7B%5Cmathrm%7B'%7D%7D%20A%29%5E%7B%2B%7DA%5E%7B'%7D%7D%20%0A%26%20%3D%20%5Cmathbf%7BA%5E%2B%7D%5Cleft(%5Cmathbf%7BA%5E%2B%7D%5Cright)%5E%7B%5Cprime%7D%20%5Cmathbf%7BA%5E%7B'%7D%7D%20%5C%5C%0A%26%20%3D%20%5Cmathbf%7BA%5E%2B%7D%5Cleft(%5Cmathbf%7BAA%5E%2B%7D%5Cright)%5E%7B%5Cprime%7D%20%5C%5C%0A%26%20%3D%20%5Cmathbf%7BA%5E%2B%7D%5Cleft(%5Cmathbf%7BAA%5E%2B%7D%5Cright)%20%5C%5C%0A%26%3D%20%5Cmathbf%7BA%5E%2B%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>得证。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>方阵的秩等于非零特征值的数目吗</title>
    <url>/posts/a67ad139/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这是一句很容易混淆的话，答案是错的，方阵的秩不一定等于非零特征值的数目。</p>
<span id="more"></span>
<p>查了一些资料，但只有一篇文章给出了严密的证明。本文内容来自于张景晓老师的文章，是一篇读书笔记。</p>
<h1>矩阵的秩 <img src="https://math.now.sh?inline=r%28A%29" style="display:inline-block;margin: 0;"/> 和非零特征值个数 <img src="https://math.now.sh?inline=%5Cmu%28A%29" style="display:inline-block;margin: 0;"/> 间的关系</h1>
<p><strong>定理1</strong>：对于任意 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 阶方阵 <img src="https://math.now.sh?inline=%5Cmathbf%28A%29" style="display:inline-block;margin: 0;"/> 都有 <img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%7D%29%20%5Cgeq%20%5Cmu(%5Cmathbf%7BA%7D)" style="display:inline-block;margin: 0;"/> 。</p>
<p>证明：当矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 可逆时，<img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%7D%29%20%3D%20n" style="display:inline-block;margin: 0;"/> ，此时我们设 <img src="https://math.now.sh?inline=%5Clambda_%7B1%7D%2C%20%5Clambda_%7B2%7D%2C%20%5Ccdots%2C%20%5Clambda_%7Bn%7D" style="display:inline-block;margin: 0;"/> 是矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的全部特征根, 则 <img src="https://math.now.sh?inline=%7C%5Cmathbf%7BA%7D%7C%3D%5Clambda_%7B1%7D%20%5Clambda_%7B2%7D%20%5Ccdots%20%5Clambda_%7Bn%7D%20%5Cneq%200" style="display:inline-block;margin: 0;"/> (证明可参考<a href="https://vincere.fun/posts/c98e6ad5/">特征值的乘积与和</a> ), 从而 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 有 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个非零特征值, 故 <img src="https://math.now.sh?inline=%5Cmu%28%5Cmathbf%7BA%7D%29%3Dn" style="display:inline-block;margin: 0;"/>,  此时  <img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%7D%29%20%3D%20%5Cmu(%5Cmathbf%7BA%7D)" style="display:inline-block;margin: 0;"/> ，上面的定理成立。</p>
<p>当矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 不可逆时，此时 <img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%7D%29%3Dr%3Cn" style="display:inline-block;margin: 0;"/> ，矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的行向量组 <img src="https://math.now.sh?inline=%5Calpha_%7B1%7D%2C%20%5Calpha_%7B2%7D%2C%20%5Ccdots%2C%20%5Calpha_%7Bn%7D" style="display:inline-block;margin: 0;"/> 的秩是 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/>, 故该向量组中必有 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> 个向量线性无关，不妨设 前 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> 个向量 <img src="https://math.now.sh?inline=%5Calpha_%7B1%7D%2C%20%5Calpha_%7B2%7D%2C%20%5Ccdots%2C%20%5Calpha_%7Br%7D" style="display:inline-block;margin: 0;"/> 线性无关,则 <img src="https://math.now.sh?inline=%5Calpha_%7Br%2B1%7D%2C%20%5Calpha_%7Br%2B2%7D%2C%20%5Ccdots%2C%20%5Calpha_%7Bn%7D" style="display:inline-block;margin: 0;"/> 均可由 <img src="https://math.now.sh?inline=%5Calpha_%7B1%7D%2C%20%5Calpha_%7B2%7D%2C%20%5Ccdots%2C%20%5Calpha_%7Br%7D" style="display:inline-block;margin: 0;"/> 线性表出, 设 $\alpha_{i}= k_{i 1} \alpha_{1}+k_{i 2} \alpha_{2}+\cdots+k_{i r} \alpha_{r}, \quad i=r+1, r+2, \cdots, n $  ，则有</p>
<p style=""><img src="https://math.now.sh?from=%7C%5Clambda%20%5Cboldsymbol%7BE%7D-%5Cboldsymbol%7BA%7D%7C%3D%5Cleft%7C%5Cbegin%7Barray%7D%7Bccccccc%7D%0A%5Clambda-a_%7B11%7D%20%26%20-a_%7B12%7D%20%26%20%5Ccdots%20%26%20-a_%7B1%20r%7D%20%26%20-a_%7B1%20%28r%2B1%29%7D%20%26%20%5Ccdots%20%26%20-a_%7B1%20n%7D%20%5C%5C%0A-a_%7B21%7D%20%26%20%5Clambda-a_%7B22%7D%20%26%20%5Ccdots%20%26%20-a_%7B2%20r%7D%20%26%20-a_%7B2%20(r%2B1)%7D%20%26%20%5Ccdots%20%26%20-a_%7B2%20n%7D%20%5C%5C%0A%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%5C%5C%0A-a_%7Br%201%7D%20%26%20-a_%7Br%202%7D%20%26%20%5Ccdots%20%26%20%5Clambda-a_%7Br%20r%7D%20%26%20-a_%7Br(r%2B1)%7D%20%26%20%5Ccdots%20%26%20-a_%7Br%20n%7D%20%5C%5C%0A-a_%7B(r%2B1)1%7D%20%26%20-a_%7B(r%2B1)2%7D%20%26%20%5Ccdots%20%26%20-a_%7B(r%2B1)%20r%7D%20%26%20%5Clambda-a_%7B(r%2B1)%20(r%2B1)%7D%20%26%20%5Ccdots%20%26%20-a_%7B(r%2B1)%20n%7D%20%5C%5C%0A%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%5C%5C%0A-a_%7Bn%201%7D%20%26%20-a_%7Bn%202%7D%20%26%20%5Ccdots%20%26%20-a_%7Bn%20r%7D%20%26%20-a_%7Bn%20(r%2B1)%7D%20%26%20%5Ccdots%20%26%20%5Clambda-a_%7Bn%20n%7D%0A%5Cend%7Barray%7D%5Cright%7C%0A" /></p><p>将 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的特征行列式的第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 行 <img src="https://math.now.sh?inline=%28j%3D1%2C2%2C%20%5Ccdots%2C%20r%29" style="display:inline-block;margin: 0;"/> 分别乘以 <img src="https://math.now.sh?inline=-k_%7Bi%20j%7D" style="display:inline-block;margin: 0;"/> 后均加到第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行 <img src="https://math.now.sh?inline=%28i%3Dr%2B1%2C%20r%2B2%2C%20%5Ccdots%2C%20n%29" style="display:inline-block;margin: 0;"/> 上得（注意：这里将第某一个行的倍数加到另外一行，不会改变行列式的大小。）</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0A%5Cleft%7C%5Cbegin%7Barray%7D%7Bccccccc%7D%0A%5Clambda-a_%7B11%7D%20%26%20-a_%7B12%7D%20%26%20%5Ccdots%20%26%20-a_%7B1%20r%7D%20%26%20-a_%7B1%20%28r%2B1%29%7D%20%26%20%5Ccdots%20%26%20-a_%7B1%20n%7D%20%5C%5C%0A-a_%7B21%7D%20%26%20%5Clambda-a_%7B22%7D%20%26%20%5Ccdots%20%26%20-a_%7B2%20r%7D%20%26%20-a_%7B2%20(r%2B1)%7D%20%26%20%5Ccdots%20%26%20-a_%7B2%20n%7D%20%5C%5C%0A%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%5C%5C%0A-a_%7Br%201%7D%20%26%20-a_%7Br%202%7D%20%26%20%5Ccdots%20%26%20%5Clambda-a_%7Br%20r%7D%20%26%20-a_%7Br%20(r%2B1)%7D%20%26%20%5Ccdots%20%26%20-a_%7Br%20n%7D%20%5C%5C%0A-k_%7B(r%2B1)1%7D%20%5Clambda%20%26%20-k_%7B(r%2B1)2%7D%20%5Clambda%20%26%20%5Ccdots%20%26%20-k_%7B(r%2B1)%20r%7D%20%5Clambda%20%26%20%5Clambda%20%26%20%5Ccdots%20%26%200%20%5C%5C%0A%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%5C%5C%0A-k_%7Bn%201%7D%20%5Clambda%20%26%20-k_%7Bn%202%7D%20%5Clambda%20%26%20%5Ccdots%20%26%20-k_%7Bn%20r%7D%20%5Clambda%20%26%200%20%26%20%5Ccdots%20%26%20%5Clambda%0A%5Cend%7Barray%7D%5Cright%7C%3D%20%5C%5C%0A%5Clambda%5E%7Bn-r%7D%5Cleft%7C%5Cbegin%7Barray%7D%7Bccccccc%7D%0A%5Clambda-a_%7B11%7D%20%26%20-a_%7B12%7D%20%26%20%5Ccdots%20%26%20-a_%7B1%20r%7D%20%26%20-a_%7B1%20(r%2B1)%7D%20%26%20%5Ccdots%20%26%20-a_%7B1%20n%7D%20%5C%5C%0A-a_%7B21%7D%20%26%20%5Clambda-a_%7B22%7D%20%26%20%5Ccdots%20%26%20-a_%7B2%20r%7D%20%26%20-a_%7B2%20(r%2B1)%7D%20%26%20%5Ccdots%20%26%20-a_%7B2%20n%7D%20%5C%5C%0A%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%5C%5C%0A-a_%7Br%201%7D%20%26%20-a_%7Br%202%7D%20%26%20%5Ccdots%20%26%20%5Clambda-a_%7Br%20r%7D%20%26%20-a_%7Br%20(r%2B1)%7D%20%26%20%5Ccdots%20%26%20-a_%7Br%20n%7D%20%5C%5C%0A-k_%7B(r%2B1)%201%7D%20%26%20-k_%7B(r%2B1)%202%7D%20%26%20%5Ccdots%20%26%20-k_%7B(r%2B1)%20r%7D%20%26%201%20%26%20%5Ccdots%20%26%200%20%5C%5C%0A%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%5C%5C%0A-k_%7Bn%201%7D%20%26%20-k_%7Bn%202%7D%20%26%20%5Ccdots%20%26%20-k_%7Bn%20r%7D%20%26%200%20%26%20%5Ccdots%20%26%201%0A%5Cend%7Barray%7D%5Cright%7C%3D%5Clambda%5E%7Bn-r%7D%20g(%5Clambda)%0A%5Cend%7Bgathered%7D%0A" /></p><p>由此可知，矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 至少有 <img src="https://math.now.sh?inline=n-r" style="display:inline-block;margin: 0;"/> 个零特征值, 从而 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 至多有 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> 个非零特征值, 因此有 <img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%7D%29%20%5Cgeqslant%20%5Cmu(%5Cmathbf%7BA%7D)" style="display:inline-block;margin: 0;"/> 。</p>
<h1><img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%7D%29%3D%5Cmu(%5Cmathbf%7BA%7D)" style="display:inline-block;margin: 0;"/> 的充分条件</h1>
<h2 id="1-可对角化">1 可对角化</h2>
<p><strong>定理2</strong>： 若矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 可对角化,则 <img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%7D%29%3D%5Cmu(%5Cmathbf%7BA%7D)" style="display:inline-block;margin: 0;"/>.</p>
<p>如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 可对角化.故存在可逆阵 <img src="https://math.now.sh?inline=T" style="display:inline-block;margin: 0;"/> 使得</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7BT%7D%5E%7B-1%7D%20%5Cboldsymbol%7BA%20T%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bllll%7D%0A%5Clambda_%7B1%7D%20%26%20%26%20%26%20%5C%5C%0A%26%20%5Clambda_%7B2%7D%20%26%20%26%20%5C%5C%0A%26%20%26%20%5Cddots%20%26%20%5C%5C%0A%26%20%26%20%26%20%5Clambda_%7B%5Cmathrm%7Bn%7D%7D%0A%5Cend%7Barray%7D%5Cright%29%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Clambda_%7B1%7D%2C%20%5Clambda_%7B2%7D%2C%20%5Ccdots%2C%20%5Clambda_%7Bn%7D" style="display:inline-block;margin: 0;"/> 是矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的全部特征根 ，由于矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D" style="display:inline-block;margin: 0;"/> 可逆，故矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的秩与对角矩阵的秩相同，即等于非零特征值数目，从而有 <img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%7D%29%3D%5Cmu(%5Cmathbf%7BA%7D)" style="display:inline-block;margin: 0;"/> 。</p>
<p><strong>推论 1</strong> 若矩阵 A 的秩与它的非零特征值个数不相等 ，则矩阵 A不可对角化．</p>
<p>该推论是定理2的逆否命题，因此成立。</p>
<p><strong>推论 2</strong> 实对称矩阵的秩与其非零特征 值个数相同。</p>
<p>根据谱定理，实对称矩阵均可对角化，因此该结论成立</p>
<p><strong>推论 3</strong>  设矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/>  的实矩阵，则有 <img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%7D%29%20%20%3D%20%20%5Cmu(%5Cmathbf%7BAA%5E%7BT%7D%7D)%20%3D%20%20%5Cmu(%5Cmathbf%7BA%5E%7BT%7DA%7D%20)" style="display:inline-block;margin: 0;"/> 。</p>
<p>证明：由于矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/>  是实矩 阵 ，从 而 <img src="https://math.now.sh?inline=%5Cmathbf%7BAA%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7BT%7DA%7D" style="display:inline-block;margin: 0;"/>  均实对称 ，由推论 2 得，<img src="https://math.now.sh?inline=r%28%5Cmathbf%7BAA%5E%7BT%7D%7D%29%20%3D%20%5Cmu(%5Cmathbf%7BAA%5E%7BT%7D%7D)" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%5E%7BT%7DA%7D%29%20%3D%20%5Cmu(%5Cmathbf%7BA%5E%7BT%7DA%7D)" style="display:inline-block;margin: 0;"/> ，又因为 <img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%7D%29%3Dr%5Cleft(%5Cmathbf%7BA%20A%5E%7BT%7D%7D%5Cright)%3Dr%5Cleft(%5Cmathbf%7BA%5E%7BT%7D%20A%7D%5Cright)" style="display:inline-block;margin: 0;"/> ，因此我们有  <img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%7D%29%20%20%3D%20%20%5Cmu(%5Cmathbf%7BAA%5E%7BT%7D%7D)%20%3D%20%20%5Cmu(%5Cmathbf%7BA%5E%7BT%7DA%7D%20)" style="display:inline-block;margin: 0;"/></p>
<h2 id="2-矩阵可逆">2 矩阵可逆</h2>
<p>证明见上。</p>
<h1><img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%7D%29%3D%5Cmu(%5Cmathbf%7BA%7D)" style="display:inline-block;margin: 0;"/> 的充分必要条件</h1>
<p>暂时看不懂，放着</p>
<p><img src="1.png" alt=""></p>
<h1>参考文献</h1>
<ol>
<li>张景晓.矩阵的秩与其非零特征值个数相等的条件J.德州学院学报,2012,28(4):5-8</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>AB的每一列均为A的列的线性组合</title>
    <url>/posts/54f5dedf/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>线性代数中，线性组合的概念时常见到，这里记录一下推导过程。</p>
<span id="more"></span>
<h1>Ab 为A的列的线性组合。</h1>
<p>假如 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵，<img src="https://math.now.sh?inline=%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=n%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 的向量，易得</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%5Cmathbf%7Bb%7D%20%3D%20%5Cleft%28%5Cbegin%7Barray%7D%7Br%7D%0A%5Cmathbf%7Ba%7D_%7B1%7D%2C%20%26%0A%5Cmathbf%7Ba%7D_%7B2%7D%2C%20%26%0A%5Ccdots%2C%20%26%0A%5Cmathbf%7Ba%7D_%7Bn%7D%0A%5Cend%7Barray%7D%5Cright%29%0A%5Cleft(%5Cbegin%7Barray%7D%7Br%7D%0Ab_%7B1%7D%20%5C%5C%0Ab_%7B2%7D%20%5C%5C%0A%5Cvdots%20%5C%5C%0Ab_%7Bn%7D%0A%5Cend%7Barray%7D%5Cright)%0A%3D%20%5Cmathbf%7Ba%7D_%7B1%7Db_%7B1%7D%20%2B%20%20%5Cmathbf%7Ba%7D_%7B2%7Db_%7B2%7D%20%2B%20%5Ccdots%20%2B%20%20%20%5Cmathbf%7Ba%7D_%7Bn%7Db_%7Bn%7D%0A" /></p><p>因此，得证<img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的列的线性组合。</p>
<h1>AB 的每一列均为A的列的线性组合</h1>
<p>假如 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵，<img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20q" style="display:inline-block;margin: 0;"/> 的矩阵，我们推导出下式。这里第一个等号中，我们将 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 分别按行和列拆分开，第二个等号为分块矩阵的乘积。第三个等号我们继续将每个 <img src="https://math.now.sh?inline=%5Cmathbf%7Bb%7D%5E%7B'%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 拆分为元素，第四个等号为矩阵加法的结果。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BA%7D%20%5Cmathbf%7BB%7D%26%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Blll%7D%0A%5Cmathbf%7Ba%7D_%7B1%7D%2C%20%5Cmathbf%7Ba%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cmathbf%7Ba%7D_%7Bn%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7Bb%7D%5E%7B'%7D_%7B1%7D%20%5C%5C%0A%5Cmathbf%7Bb%7D%5E%7B'%7D_%7B2%7D%20%5C%5C%0A%5Cvdots%20%5C%5C%0A%5Cmathbf%7Bb%7D%5E%7B'%7D_%7Bn%7D%0A%5Cend%7Barray%7D%5Cright%5D%5C%5C%0A%26%5C%5C%0A%26%3D%5Cmathbf%7Ba%7D_%7B1%7D%20%5Cmathbf%7Bb%7D%5E%7B'%7D_%7B1%7D%2B%5Cmathbf%7Ba%7D_%7B2%7D%20%5Cmathbf%7Bb%7D%5E%7B'%7D_%7B2%7D%2B%5Ccdots%2B%5Cmathbf%7Ba%7D_%7Bn%7D%20%5Cmathbf%7Bb%7D%5E%7B'%7D_%7Bn%7D%20%5C%5C%0A%26%5C%5C%0A%26%3D%5Cleft%5B%5Cmathbf%7Ba%7D_%7B1%7D%20b'_%7B11%7D%2C%20%5Cmathbf%7Ba%7D_%7B1%7D%20b'_%7B12%7D%2C%20%5Ccdots%2C%20%5Cmathbf%7Ba%7D_%7B1%7D%20b'_%7B1q%7D%5Cright%5D%2B%5C%5C%0A%26%20%5Cquad%20%5Cleft%5B%5Cmathbf%7Ba%7D_%7B2%7D%20b'_%7B21%7D%2C%20%5Cmathbf%7Ba%7D_%7B2%7D%20b'_%7B22%7D%2C%20%5Ccdots%2C%20%5Cmathbf%7Ba%7D_%7B2%7D%20b'_%7B2q%7D%5Cright%5D%20%2B%5C%5C%0A%26%20%5Cquad%20%5Ccdots%20%5C%5C%0A%26%20%5Cquad%20%5Cleft%5B%5Cmathbf%7Ba%7D_%7Bn%7D%20b'_%7Bn%201%7D%2C%20%5Cmathbf%7Ba%7D_%7Bn%7D%20b'_%7Bn2%7D%2C%20%5Ccdots%2C%20%5Cmathbf%7Ba%7D_%7Bn%7D%20b'_%7Bnq%7D%5Cright%5D%5C%5C%0A%26%5C%5C%0A%26%3D%5B%5Cmathbf%7Ba%7D_%7B1%7D%20b'_%7B11%7D%20%2B%20%5Cmathbf%7Ba%7D_%7B2%7D%20b'_%7B21%7D%2B%5Ccdots%2B%5Cmathbf%7Ba%7D_%7Bn%7D%20b'_%7Bn%201%7D%2C%20%5C%5C%0A%26%20%5Cquad%20%5Cmathbf%7Ba%7D_%7B1%7D%20b'_%7B12%7D%20%2B%20%5Cmathbf%7Ba%7D_%7B2%7D%20b'_%7B22%7D%2B%5Ccdots%2B%5Cmathbf%7Ba%7D_%7Bn%7D%20b'_%7Bn%202%7D%2C%20%5C%5C%0A%26%20%5Cquad%20%5Ccdots%2C%20%5C%5C%0A%26%20%5Cquad%20%5Cmathbf%7Ba%7D_%7B1%7D%20b'_%7B1q%7D%20%2B%20%5Cmathbf%7Ba%7D_%7B2%7D%20b'_%7B2q%7D%2B%5Ccdots%2B%5Cmathbf%7Ba%7D_%7Bn%7D%20b'_%7Bn%20q%7D%5D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们证明了 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 的每一列均为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的列的线性组合。</p>
<p>其实利用上面的” <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的列的线性组合“这个性质，我们可以更简洁地证明这一点</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BA%7D%20%5Cmathbf%7BB%7D%26%3D%5Cmathbf%7BA%7D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Blll%7D%0A%5Cmathbf%7Bb%7D_%7B1%7D%2C%20%5Cmathbf%7Bb%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cmathbf%7Bb%7D_%7Bq%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%5C%5C%0A%26%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Blll%7D%0A%5Cmathbf%7BA%7D%5Cmathbf%7Bb%7D_%7B1%7D%2C%20%5Cmathbf%7BA%7D%5Cmathbf%7Bb%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cmathbf%7BA%7D%5Cmathbf%7Bb%7D_%7Bq%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>这里，我们同样证明了<img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/>的每一列均为<img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/>的列的线性组合。</p>
<p>举个例子，假设</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Blll%7D%0A2%20%26%202%20%26%203%20%5C%5C%0A1%20%26%200%20%26%201%20%5C%5C%0A3%20%26%202%20%26%204%0A%5Cend%7Barray%7D%5Cright%5D%2C%0A%5Cmathbf%7BB%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A1%20%26%200%20%5C%5C%0A2%20%26%201%20%5C%5C%0A3%20%26%203%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>根据矩阵乘法，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%5Cmathbf%7BB%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A15%20%26%2011%20%5C%5C%0A4%20%26%203%20%5C%5C%0A9%20%26%2014%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>根据我们上面的推导，<img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 每一列可以拆分为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%7B%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A2%20%5C%5C%0A1%20%5C%5C%0A3%0A%5Cend%7Barray%7D%5Cright%5D%201%2B%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A2%20%5C%5C%0A0%20%5C%5C%0A2%0A%5Cend%7Barray%7D%5Cright%5D%202%2B%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A3%20%5C%5C%0A1%20%5C%5C%0A4%0A%5Cend%7Barray%7D%5Cright%5D%203%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A15%20%5C%5C%0A4%20%5C%5C%0A19%0A%5Cend%7Barray%7D%5Cright%5D%7D%20%5C%5C%0A%26%7B%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A2%20%5C%5C%0A1%5C%5C%0A3%0A%5Cend%7Barray%7D%5Cright%5D%200%2B%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A2%20%5C%5C%0A0%20%5C%5C%0A2%0A%5Cend%7Barray%7D%5Cright%5D%201%2B%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A3%20%5C%5C%0A1%20%5C%5C%0A4%0A%5Cend%7Barray%7D%5Cright%5D%203%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A11%20%5C%5C%0A3%20%5C%5C%0A14%0A%5Cend%7Barray%7D%5Cright%5D%7D%0A%5Cend%7Baligned%7D%0A" /></p><h1>AB 的每一行均为B的行的线性组合</h1>
<p>类似上面，假设 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=1%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的行向量，<img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20q" style="display:inline-block;margin: 0;"/> 的矩阵，那么</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%5Cmathbf%7BB%7D%20%3D%20%5Cleft%28%5Cbegin%7Barray%7D%7Br%7D%0Aa_%7B1%7D%2C%20%26%0Aa_%7B2%7D%2C%20%26%0A%5Ccdots%2C%20%26%0Aa_%7Bn%7D%0A%5Cend%7Barray%7D%5Cright%29%0A%5Cleft(%5Cbegin%7Barray%7D%7Br%7D%0A%5Cmathbf%7Bb%7D%5E%7B%5Cprime%7D_%7B1%7D%20%5C%5C%0A%5Cmathbf%7Bb%7D%5E%7B%5Cprime%7D_%7B2%7D%20%5C%5C%0A%5Cvdots%20%5C%5C%0A%5Cmathbf%7Bb%7D%5E%7B%5Cprime%7D_%7Bn%7D%0A%5Cend%7Barray%7D%5Cright)%0A%3Da_%7B1%7D%5Cmathbf%7Bb%7D%5E%7B%5Cprime%7D_%7B1%7D%2B%0Aa_%7B2%7D%5Cmathbf%7Bb%7D%5E%7B%5Cprime%7D_%7B2%7D%20%2B%0A%5Ccdots%20%2B%0Aa_%7Bn%7D%20%5Cmathbf%7Bb%7D%5E%7B%5Cprime%7D_%7Bn%7D%0A%0A" /></p><p>因此，我们证明 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/>的行的线性组合。</p>
<p>假如 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵，<img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20q" style="display:inline-block;margin: 0;"/> 的矩阵，那么</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%5Cmathbf%7BB%7D%20%3D%20%0A%0A%5Cleft%28%5Cbegin%7Barray%7D%7Br%7D%0A%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D_%7B1%7D%20%5C%5C%0A%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D_%7B2%7D%20%5C%5C%0A%5Cvdots%20%5C%5C%0A%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D_%7Bn%7D%0A%5Cend%7Barray%7D%5Cright%29%20%5Cmathbf%7BB%7D%0A%0A%20%3D%20%0A%0A%5Cleft(%5Cbegin%7Barray%7D%7Br%7D%0A%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D_%7B1%7D%20%5Cmathbf%7BB%7D%20%5C%5C%0A%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D_%7B2%7D%20%5Cmathbf%7BB%7D%20%5C%5C%0A%5Cvdots%20%5C%5C%0A%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D_%7Bn%7D%20%5Cmathbf%7BB%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>因此得证 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 的每一行均是 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 的行的线性组合。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>不满秩的线性回归模型的参数估计</title>
    <url>/posts/1c2f25ac/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>上一篇<a href="https://vincere.fun/posts/55264e6f/">矩阵微分与正规方程组推导</a>，我推导了线性回归模型中的正规方程组，以及当矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 满秩时的最小二乘估计值，现在我们考虑当 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 不满秩时的情况。</p>
<p>本章节内容主要来自于 《linear models in statistics》第二版的第十二章 <em>Analysis-of-Variance Models</em> 。</p>
<span id="more"></span>
<h1>不满秩的模型</h1>
<p>首先我们看单变量的模型的例子，假设是平衡数据（各个水平的观测值相同）。</p>
<h2 id="单变量模型">单变量模型</h2>
<p>假设研究人员开发了两种用于增加汽油日程的化学添加剂，假设不添加任何添加剂的情况下，一加仑的汽油平均可以跑 <img src="https://math.now.sh?inline=%5Cmu" style="display:inline-block;margin: 0;"/> 英里。那么假设我们添加化学物质 1，我们期望一加仑汽油的里程数增加 <img src="https://math.now.sh?inline=%5Ctau_%7B1%7D" style="display:inline-block;margin: 0;"/> 英里；而添加化学物质 2，一加仑汽油的里程数增加 <img src="https://math.now.sh?inline=%5Ctau_%7B1%7D" style="display:inline-block;margin: 0;"/> 英里。</p>
<p>因此，这个模型可以表示为</p>
<p style=""><img src="https://math.now.sh?from=y_%7B1%7D%3D%5Cmu%2B%5Ctau_%7B1%7D%2B%5Cvarepsilon_%7B1%7D%2C%20%5Cquad%20y_%7B2%7D%3D%5Cmu%2B%5Ctau_%7B2%7D%2B%5Cvarepsilon_%7B2%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=y_1" style="display:inline-block;margin: 0;"/> 是添加化学物质 1 的日程数， <img src="https://math.now.sh?inline=y_2" style="display:inline-block;margin: 0;"/> 是添加化学物质 2 的日程数。我们想要估计参数 <img src="https://math.now.sh?inline=%5Cmu%2C%20%5Ctau_%7B1%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Ctau_%7B2%7D" style="display:inline-block;margin: 0;"/> ，并且做假设检验，例如 <img src="https://math.now.sh?inline=H_%7B0%7D%3A%20%5Ctau_%7B1%7D%3D%5Ctau_%7B2%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>假设我们做了6次实验，其中每个化学物质做了3次，用矩阵形式表示为</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bl%7D%0Ay_%7B11%7D%20%5C%5C%0Ay_%7B12%7D%20%5C%5C%0Ay_%7B13%7D%20%5C%5C%0Ay_%7B21%7D%20%5C%5C%0Ay_%7B22%7D%20%5C%5C%0Ay_%7B23%7D%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cbegin%7Barray%7D%7Blll%7D%0A1%20%26%201%20%26%200%20%5C%5C%0A1%20%26%201%20%26%200%20%5C%5C%0A1%20%26%201%20%26%200%20%5C%5C%0A1%20%26%200%20%26%201%20%5C%5C%0A1%20%26%200%20%26%201%20%5C%5C%0A1%20%26%200%20%26%201%0A%5Cend%7Barray%7D%5Cright)%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmu%20%5C%5C%0A%5Ctau_%7B1%7D%20%5C%5C%0A%5Ctau_%7B2%7D%0A%5Cend%7Barray%7D%5Cright)%2B%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cvarepsilon_%7B11%7D%20%5C%5C%0A%5Cvarepsilon_%7B12%7D%20%5C%5C%0A%5Cvarepsilon_%7B13%7D%20%5C%5C%0A%5Cvarepsilon_%7B21%7D%20%5C%5C%0A%5Cvarepsilon_%7B22%7D%20%5C%5C%0A%5Cvarepsilon_%7B23%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>或者</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=6%20%5Ctimes%203" style="display:inline-block;margin: 0;"/> 的矩阵，秩为2 ，因为第一列等于第二列和第三列的和。此时我们无法得到估计值 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，因为 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 不存在。</p>
<p>这里我们考虑这些参数的含义。参数 <img src="https://math.now.sh?inline=%5Cmu" style="display:inline-block;margin: 0;"/> 表示不添加任何化学物质的均值，<img src="https://math.now.sh?inline=%5Ctau_%7B1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Ctau_%7B2%7D" style="display:inline-block;margin: 0;"/> 表示两个化学物质的增加量。举个例子，假设 <img src="https://math.now.sh?inline=%5Cmu%3D15%2C%20%5Ctau_%7B1%7D%3D1" style="display:inline-block;margin: 0;"/>,  <img src="https://math.now.sh?inline=%5Ctau_%7B2%7D%3D3" style="display:inline-block;margin: 0;"/> ，那么模型为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Barray%7D%7Bll%7D%0Ay_%7B1%20j%7D%3D15%2B1%2B%5Cvarepsilon_%7B1%20j%7D%3D16%2B%5Cvarepsilon_%7B1%20j%7D%2C%20%26%20j%3D1%2C2%2C3%2C%20%5C%5C%0Ay_%7B2%20j%7D%3D15%2B3%2B%5Cvarepsilon_%7B2%20j%7D%3D18%2B%5Cvarepsilon_%7B2%20j%7D%2C%20%26%20j%3D1%2C2%2C3%20.%0A%5Cend%7Barray%7D%0A" /></p><p>然而，我们从数据中能得到的是 <img src="https://math.now.sh?inline=y_%7B1%20j%7D%3D16%2B%5Cvarepsilon_%7B1%20j%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=y_%7B2%20j%7D%3D18%2B%5Cvarepsilon_%7B2%20j%7D" style="display:inline-block;margin: 0;"/> ，我们无法得到 <img src="https://math.now.sh?inline=%5Cmu%3D15%2C%20%5Ctau_%7B1%7D%3D1" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Ctau_%7B2%7D%3D3" style="display:inline-block;margin: 0;"/>  ，因为很多模型都可以得到这两个式子，比如</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Barray%7D%7Bll%7D%0Ay_%7B1%20j%7D%3D10%2B6%2B%5Cvarepsilon_%7B1%20j%7D%2C%20%26%20j%3D1%2C2%2C3%2C%20%5C%5C%0Ay_%7B2%20j%7D%3D10%2B8%2B%5Cvarepsilon_%7B2%20j%7D%2C%20%26%20j%3D1%2C2%2C3%2C%0A%5Cend%7Barray%7D%0A" /></p><p>又比如，</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Barray%7D%7Bll%7D%0Ay_%7B1%20j%7D%3D25-9%2B%5Cvarepsilon_%7B1%20j%7D%2C%20%26%20j%3D1%2C2%2C3%20%5C%5C%0Ay_%7B2%20j%7D%3D25-7%2B%5Cvarepsilon_%7B2%20j%7D%2C%20%26%20j%3D1%2C2%2C3%0A%5Cend%7Barray%7D%0A" /></p><p>我们有无穷的参数组合可以实现这一点。也就是说，我们无法得到唯一的 <img src="https://math.now.sh?inline=%5Cmu%2C%20%5Ctau_%7B1%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Ctau_%7B2%7D" style="display:inline-block;margin: 0;"/> ，此时我们称这个模型为 <strong>过度参数化的</strong> (<em>overparameterized</em>) 。在平衡数据中，你增加数据量无助于这一点，因为不会改变 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的秩。</p>
<p>我们很多种方法可以解决这一点，来获得唯一的估计值，但是这些方法各有利弊。第一种，重新定义一个模型，减少参数的数目，使得参数估计值唯一；第二种，模型不变，但是对参数增加<strong>约束条件</strong>，使得参数估计值唯一；第三种，模型不变，估计某个唯一的<strong>参数的线性组合</strong>。下面我们来简单地介绍这三种方法。</p>
<p><strong>第一种方法</strong>：为了减少参数数量，考虑到下面两个式子成立</p>
<p style=""><img src="https://math.now.sh?from=y_%7B1%20j%7D%3D16%2B%5Cvarepsilon_%7B1%20j%7D%20%5Cquad%20%5Ctext%20%7B%20and%20%7D%20%5Cquad%20y_%7B2%20j%7D%3D18%2B%5Cvarepsilon_%7B2%20j%7D%0A" /></p><p>这里，16 和 18 是添加两种化学物质之后的均值，我们可以将其标记为 <img src="https://math.now.sh?inline=%5Cmu_%7B1%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cmu_%7B2%7D" style="display:inline-block;margin: 0;"/> ，我们可以将模型修改为</p>
<p style=""><img src="https://math.now.sh?from=y_%7B1%20j%7D%3D%5Cmu_%7B1%7D%2B%5Cvarepsilon_%7B1%20j%7D%20%5Cquad%20%5Ctext%20%7B%20and%20%7D%20%5Cquad%20y_%7B2%20j%7D%3D%5Cmu_%7B2%7D%2B%5Cvarepsilon_%7B2%20j%7D%20.%0A" /></p><p>此时我们要估计的参数就是  <img src="https://math.now.sh?inline=%5Cmu_%7B1%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cmu_%7B2%7D" style="display:inline-block;margin: 0;"/> ，观测值的矩阵表示式为</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bl%7D%0Ay_%7B11%7D%20%5C%5C%0Ay_%7B12%7D%20%5C%5C%0Ay_%7B13%7D%20%5C%5C%0Ay_%7B21%7D%20%5C%5C%0Ay_%7B22%7D%20%5C%5C%0Ay_%7B23%7D%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cbegin%7Barray%7D%7Bll%7D%0A1%20%26%200%20%5C%5C%0A1%20%26%200%20%5C%5C%0A1%20%26%200%20%5C%5C%0A0%20%26%201%20%5C%5C%0A0%20%26%201%20%5C%5C%0A0%20%26%201%0A%5Cend%7Barray%7D%5Cright)%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmu_%7B1%7D%20%5C%5C%0A%5Cmu_%7B2%7D%0A%5Cend%7Barray%7D%5Cright)%2B%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cvarepsilon_%7B11%7D%20%5C%5C%0A%5Cvarepsilon_%7B12%7D%20%5C%5C%0A%5Cvarepsilon_%7B13%7D%20%5C%5C%0A%5Cvarepsilon_%7B21%7D%20%5C%5C%0A%5Cvarepsilon_%7B22%7D%20%5C%5C%0A%5Cvarepsilon_%7B23%7D%0A%5Cend%7Barray%7D%5Cright)%2C%0A" /></p><p>这可以写作</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%3D%5Cmathbf%7BW%7D%20%5Cboldsymbol%7B%5Cmu%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D%0A" /></p><p>其中矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D" style="display:inline-block;margin: 0;"/> 是一个满秩矩阵，因此我们可以得到唯一的参数估计值为</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cboldsymbol%7B%5Cmu%7D%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bl%7D%0A%5Chat%7B%5Cmu%7D_%7B1%7D%20%5C%5C%0A%5Chat%7B%5Cmu%7D_%7B2%7D%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BW%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BW%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A" /></p><p>这种解决方法也称为 <strong>再参数化</strong> (<em>reparameterization</em>)</p>
<p><strong>第二种方法</strong>：我们需要添加一个约束条件，我们定义加了约束条件的参数为 <img src="https://math.now.sh?inline=%5Cmu%5E%7B*%7D%2C%20%5Ctau_%7B1%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Ctau_%7B2%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/>，约束条件为  <img src="https://math.now.sh?inline=%5Ctau_%7B1%7D%5E%7B*%7D%2B%5Ctau_%7B2%7D%5E%7B*%7D%3D0" style="display:inline-block;margin: 0;"/> 。此时定义的 <img src="https://math.now.sh?inline=%5Cmu%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 有一个特殊含义， 表示采用处理后的新的均值，而 <img src="https://math.now.sh?inline=%5Ctau_%7B1%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Ctau_%7B2%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 表示对这个均值的偏差。采用这个限制条件，上面的例子可以<strong>唯一</strong>的表示为</p>
<p style=""><img src="https://math.now.sh?from=y_%7B1%20j%7D%3D17-1%2B%5Cvarepsilon_%7B1%20j%7D%2C%20%5Cquad%20y_%7B2%20j%7D%3D17%2B1%2B%5Cvarepsilon_%7B2%20j%7D%20.%0A" /></p><p>这种约束条件通常称为 <strong>附加条件</strong> (<em>side conditions</em>) ，我们可以将上面的模型用 <img src="https://math.now.sh?inline=%5Ctau_%7B2%7D%5E%7B*%7D%3D-%5Ctau_%7B1%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 表示为</p>
<p><img src="https://math.now.sh?inline=y_%7B1%20j%7D%3D%5Cmu%5E%7B*%7D%2B%5Ctau_%7B1%7D%5E%7B*%7D%2B%5Cvarepsilon_%7B1%20j%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=y_%7B2%20j%7D%3D%5Cmu%5E%7B*%7D-%5Ctau_%7B1%7D%5E%7B*%7D%2B%5Cvarepsilon_%7Bi%20j%7D" style="display:inline-block;margin: 0;"/> ，观测值向量可以表示为</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bl%7D%0Ay_%7B11%7D%20%5C%5C%0Ay_%7B12%7D%20%5C%5C%0Ay_%7B13%7D%20%5C%5C%0Ay_%7B21%7D%20%5C%5C%0Ay_%7B22%7D%20%5C%5C%0Ay_%7B23%7D%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cbegin%7Barray%7D%7Brr%7D%0A1%20%26%201%20%5C%5C%0A1%20%26%201%20%5C%5C%0A1%20%26%201%20%5C%5C%0A1%20%26%20-1%20%5C%5C%0A1%20%26%20-1%20%5C%5C%0A1%20%26%20-1%0A%5Cend%7Barray%7D%5Cright)%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmu%5E%7B*%7D%20%5C%5C%0A%5Ctau_%7B1%7D%5E%7B*%7D%0A%5Cend%7Barray%7D%5Cright)%2B%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cvarepsilon_%7B11%7D%20%5C%5C%0A%5Cvarepsilon_%7B12%7D%20%5C%5C%0A%5Cvarepsilon_%7B13%7D%20%5C%5C%0A%5Cvarepsilon_%7B21%7D%20%5C%5C%0A%5Cvarepsilon_%7B22%7D%20%5C%5C%0A%5Cvarepsilon_%7B23%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>或者</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%5E%7B*%7D%20%5Cboldsymbol%7B%5Cmu%7D%5E%7B*%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 是一个满秩矩阵，因此可以得到唯一的一个参数估计值。但是需要注意，添加的约束条件相当于对参数做了一个新的定义。</p>
<p><strong>第三种方法</strong>：我们从之前的结果可以看到，一些参数的线性组合的值是唯一的。比如 <img src="https://math.now.sh?inline=%5Ctau_%7B1%7D-%5Ctau_%7B2%7D%3D-2%2C%20%5Cquad%20%5Cmu%2B%5Ctau_%7B1%7D%3D16" style="display:inline-block;margin: 0;"/>  和 <img src="https://math.now.sh?inline=%5Cmu%2B%5Ctau_%7B2%7D%3D18" style="display:inline-block;margin: 0;"/> 对于所有可能的参数的值均成立，因为我们可以估计这种唯一的线性组合的值。</p>
<h2 id="双变量模型">双变量模型</h2>
<p>和单变量相比无新增内容，略</p>
<h1>估计参数</h1>
<p>在这一章节中，我们考虑不满秩的模型 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> 的参数 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的估计。这里我们采用再参数化或者添加约束条件，这里也不假设正态分布。</p>
<h2 id="估计-boldsymbol-beta">估计  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/></h2>
<p>我们将其一般化，考虑固定模型</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D%2C%0A" /></p><p>根据最小二乘，存在正规方程组</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 且秩为 <img src="https://math.now.sh?inline=k%20%3C%20p%20%5Cleq%20n" style="display:inline-block;margin: 0;"/> 的矩阵，即不满秩，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 无逆矩阵，正规方程组无唯一解。但是，我们可以证明 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 有解（无穷多解）。</p>
<p>根据广义逆的性质，对于线性方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7BAx%20%3Dc%20%7D" style="display:inline-block;margin: 0;"/> ，当且仅当对于任意一个 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B-%7D" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20A%7D%5E%7B-%7D%20%5Cmathbf%7Bc%7D%3D%5Cmathbf%7Bc%7D" style="display:inline-block;margin: 0;"/>  均成立时，方程组才相容。因此我们只需要证明  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，这里 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 是任意一个广义逆，根据广义逆性质我们知道 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，因此该式子成立，正规方程组相容。</p>
<p>既然正规方程组相容，那么它的一个解可以用广义逆表示为</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 是  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的任意一个广义逆。此时 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 的期望值为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%28%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29%20%26%3D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20E(%5Cmathbf%7By%7D)%20%5C%5C%0A%26%3D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>因为 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cneq%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ，因此  <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的一个<strong>有偏估计值</strong>。并且 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 会随着  <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/>  的选择而发生改变，也就是说，每一个选中的 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 的 <img src="https://math.now.sh?inline=E%28%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29" style="display:inline-block;margin: 0;"/> 均不相同。</p>
<p>我们可以进一步证明，此时所有的 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的线性组合均不是  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的无偏估计值。假设我们存在一个 <img src="https://math.now.sh?inline=p%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 使得 <img src="https://math.now.sh?inline=E%28%5Cmathbf%7BA%20y%7D%29%3D%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> ，那么</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Cbeta%7D%3DE%28%5Cmathbf%7BA%20y%7D%29%3DE%5B%5Cmathbf%7BA%7D(%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D)%5D%3DE(%5Cmathbf%7BA%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%2B%5Cmathbf%7BA%7D%20E(%5Cboldsymbol%7B%5Cvarepsilon%7D)%3D%5Cmathbf%7BA%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%0A" /></p><p>该式对所有可能的 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 均成立，因此我们有 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20X%7D%3D%5Cmathbf%7BI%7D_%7Bp%7D" style="display:inline-block;margin: 0;"/> 。但是我们知道 <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28%20%5Cmathbf%7BA%7D%20%5Cmathbf%7BX%7D%29%20%5Cleq%20%5Coperatorname%7Brank%7D(%5Cmathbf%7BX%7D)%20%3D%20k%20%3C%20p" style="display:inline-block;margin: 0;"/> ，而 <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28%20%5Cmathbf%7BI%7D_%7Bp%7D%20%29%20%3D%20p" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20X%7D" style="display:inline-block;margin: 0;"/> 不可能等于 <img src="https://math.now.sh?inline=%5Cmathbf%7BI%7D_%7Bp%7D" style="display:inline-block;margin: 0;"/> ，因此我们证明没有一个  <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的线性组合是  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的无偏估计值 ，得证。</p>
<h2 id="估计-boldsymbol-beta-的函数">估计  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的函数</h2>
<p>上面我们证明了我们无法估计 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> ，那么我们能不能估计任何一个  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的线性组合呢？也就是说，估计  $ \boldsymbol{\lambda^{\prime} \boldsymbol{\beta}}$ 。</p>
<p>如果存在一个观测值 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的线性组合的期望等于  $ \boldsymbol{\lambda^{\prime} \boldsymbol{\beta}}$ ，我们就称这个参数的线性组合  $ \boldsymbol{\lambda^{\prime} \boldsymbol{\beta}}$ 是<strong>可估计的</strong> (<em>estimable</em>) ，也就是说，存在一个向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D" style="display:inline-block;margin: 0;"/> ，使得下式成立</p>
<p style=""><img src="https://math.now.sh?from=E%5Cleft%28%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%0A" /></p><p>在下面的定理中，我们用三种方法来确定是否一个线性函数  $ \boldsymbol{\lambda^{\prime} \boldsymbol{\beta}}$  是可以估计的。</p>
<p><strong>定理</strong>：在模型  <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> 中，其中 <img src="https://math.now.sh?inline=E%28%5Cmathbf%7By%7D%29%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的秩为 $k &lt; p \leq n $ 的矩阵。那么当且仅当下面任何一个等式条件成立时，线性函数 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 可估计。</p>
<p>(1) <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的行的线性组合，也就是说存在一个向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D" style="display:inline-block;margin: 0;"/> 使得下式成立</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Ba%7D%20%3D%5Cboldsymbol%7B%5Clambda%7D%20%5CRightarrow%20%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%0A" /></p><p>(2)  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的行的线性组合，或者 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/>  是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的列的线性组合，也就是说，存在一个向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D" style="display:inline-block;margin: 0;"/> 使得</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cquad%20%5Ctext%20%7B%20or%20%7D%20%5Cquad%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D%3D%5Cboldsymbol%7B%5Clambda%7D%0A" /></p><p>(3) <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> 或者 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 满足下式</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cboldsymbol%7B%5Clambda%7D%3D%5Cboldsymbol%7B%5Clambda%7D%20%5Cquad%20%5Ctext%20%7B%20or%20%7D%20%5Cquad%20%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 是  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/>  的任何一个（对称的）广义逆。</p>
<p><strong>证明</strong>：对于 (1) ，我们同时证明 “if” 和 “only if” ；对于 (2) 和 (3) ，这里只证明了  “if” 部分。</p>
<p>(1) 如果存在一个向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D" style="display:inline-block;margin: 0;"/> 使得 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%3D%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> ，那么我没有</p>
<p style=""><img src="https://math.now.sh?from=E%5Cleft%28%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%3D%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20E(%5Cmathbf%7By%7D)%3D%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%0A" /></p><p>反过来，如果 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 可估计，那么存在一个向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D" style="display:inline-block;margin: 0;"/> 使得 <img src="https://math.now.sh?inline=E%5Cleft%28%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 对于所有可能的 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 均成立，因此 $\mathbf{a}^{\prime} \mathbf{X}=\boldsymbol{\lambda}^{\prime} $</p>
<p>(2) 如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D%3D%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> ，通过定义 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%3D%5Cmathbf%7BX%20r%7D" style="display:inline-block;margin: 0;"/> ，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%5Cleft%28%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%20%26%3DE%5Cleft(%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright)%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20E(%5Cmathbf%7By%7D)%20%5C%5C%0A%26%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>(3) 如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cboldsymbol%7B%5Clambda%7D%3D%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> ，那么 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> 就是上面 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%20r%7D%3D%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> 的一个解。</p>
<p>根据这个定理第一条等式，我们知道对于 <img src="https://math.now.sh?inline=i%3D1%2C2%2C%20%5Cldots%2C%20n" style="display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 均可估计，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D_%7Bi%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 是矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行。因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的每一行 (元素) 均是可估计的，我们可以说  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 本身是可以估计的。同样地，根据第二条等式，我们得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的每一行 (元素) 均是可估计的，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 也是可估计的。反过来说，所有的可估计函数都可以从 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 或 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 中得到。</p>
<p>如果系数向量 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D_%7B1%7D%2C%20%5Cboldsymbol%7B%5Clambda%7D_%7B2%7D%2C%20%5Cldots%2C%20%5Cboldsymbol%7B%5Clambda%7D_%7Bm%7D" style="display:inline-block;margin: 0;"/> 之间线性无关，那么这些线性函数 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2C%20%5Cboldsymbol%7B%5Clambda%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2C%20%5Cldots%2C%20%5Cboldsymbol%7B%5Clambda%7D_%7Bm%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 称为线性无关的。下面的定理给出了线性无关的可估计函数的数目。</p>
<p><strong>定理</strong>：在不满秩的模型 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> 中，线性无关的可估计函数的数目等于 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的秩。</p>
<p>缺证明，见 Graybill (1976, pp. 485 – 486)</p>
<h1>估计值</h1>
<h2 id="boldsymbol-lambda-prime-boldsymbol-beta-的估计值">$ \boldsymbol{\lambda^{\prime} \boldsymbol{\beta}}$ 的估计值</h2>
<p>根据上面的定理第一条和第二条，我们有 <img src="https://math.now.sh?inline=%5Clambda%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的估计值 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 满足 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%3D%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 。 <img src="https://math.now.sh?inline=%5Clambda%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 第三个估计值就是 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> ，其中<img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的任意一个解。在下面的定理，我们讨论 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 的一些性质，我们不会讨论 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的性质，因为这个式子不能保证有最小方差（个人理解 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 中的 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 是不唯一的，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 不一定满足最小方差）。</p>
<p><strong>定理</strong>：如果 $ \boldsymbol{\lambda^{\prime} \boldsymbol{\beta}}$ 是不满秩模型的一个可估计函数，设 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 是正规方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的任意一个解，<img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D%3D%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> 的任意一个解。那么两个估计值 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 有下面的性质：</p>
<ol>
<li><img src="https://math.now.sh?inline=E%5Cleft%28%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5Cright%29%3DE%5Cleft(%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright)%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/></li>
<li>对于任意一个 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 或 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D" style="display:inline-block;margin: 0;"/>  ，<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%20%3D%20%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/></li>
<li><img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的值不会随着 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 或 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D" style="display:inline-block;margin: 0;"/> 的选择而改变。</li>
</ol>
<p>证明：</p>
<p>(1) 我们有</p>
<p style=""><img src="https://math.now.sh?from=E%5Cleft%28%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5Cright%29%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20E(%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%0A" /></p><p>根据上面的定理的第三条等式，我们有 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，因此</p>
<p style=""><img src="https://math.now.sh?from=E%5Cleft%28%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5Cright%29%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%0A" /></p><p>同样地，我们有</p>
<p style=""><img src="https://math.now.sh?from=E%5Cleft%28%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20E(%5Cmathbf%7By%7D)%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%0A" /></p><p>(2) 对于正规方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 乘以 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A" /></p><p>因为  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/>  ，带入得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A" /></p><p>(3) 为了证明 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 与 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D" style="display:inline-block;margin: 0;"/> 的选择无关，设 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> 满足 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D_%7B1%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D_%7B2%7D%3D%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> ，那么</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Br%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7Br%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%5Cquad%20%5Ctext%20%7B%20and%20%7D%20%5Cquad%20%5Cmathbf%7Br%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7Br%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A" /></p><p>因为 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cmathbf%7Br%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> ，因此我们有 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%3D%5Cmathbf%7Br%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>同样的，我们可以证明  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 的值不会随着  <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 的选择而改变，设  <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7B1%7D%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7B2%7D%7D" style="display:inline-block;margin: 0;"/>  是正规方程组  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/>  的两个解，那么</p>
<p>根据上面定理，我们知道存在一个向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D" style="display:inline-block;margin: 0;"/> ，使得 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 。 因此</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7B1%7D%7D%20%3D%20%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7B1%7D%7D%20%3D%20%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7B2%7D%7D%20%3D%20%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7B2%7D%7D%20%3D%20%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A" /></p><p>因此  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7B1%7D%7D%20%20%3D%20%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7B2%7D%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>估计值 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/>  或  <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的方差有以下定理。</p>
<p><strong>定理</strong>：<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 是不满秩模型 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> 的一个可估计函数，<img src="https://math.now.sh?inline=%5Coperatorname%7Bcov%7D%28%5Cmathbf%7By%7D%29%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%20r%7D%3D%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> 的一个解， <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 是  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的一个解，那么 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/>  或  <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的方差有以下性质：</p>
<p>(1) <img src="https://math.now.sh?inline=%5Coperatorname%7Bvar%7D%5Cleft%28%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Clambda%7D%20%3D%20%5Csigma%5E%7B2%7D%20%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/><br>
(2) <img src="https://math.now.sh?inline=%5Coperatorname%7Bvar%7D%5Cleft%28%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5Cright%29%3D%5Csigma%5E%7B2%7D%20%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/><br>
( 3) <img src="https://math.now.sh?inline=%5Coperatorname%7Bvar%7D%5Cleft%28%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Coperatorname%7Bvar%7D%5Cleft%28%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 值唯一，也就是说与 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D" style="display:inline-block;margin: 0;"/> 或 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/>的选择无关，因此 <img src="https://math.now.sh?inline=%5Coperatorname%7Bvar%7D%5Cleft%28%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%20%3D%20%5Coperatorname%7Bvar%7D%5Cleft(%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5Cright)" style="display:inline-block;margin: 0;"/> 。</p>
<p><strong>证明</strong>：</p>
<p>(1)</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Bvar%7D%5Cleft%28%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%20%26%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Coperatorname%7Bcov%7D(%5Cmathbf%7By%7D)%20%5Cmathbf%7BX%20r%7D%20%20%5C%5C%0A%26%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cleft(%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D%5Cright)%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D%5C%5C%0A%26%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D%20%5C%5C%0A%26%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Clambda%7D%20%0A%5Cend%7Baligned%7D%0A" /></p><p>(2)</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Bvar%7D%5Cleft%28%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5Cright%29%20%26%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Coperatorname%7Bcov%7D(%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%20%5Cboldsymbol%7B%5Clambda%7D%20%5C%5C%0A%26%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Coperatorname%7Bcov%7D(%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D)%20%5Cboldsymbol%7B%5Clambda%7D%20%5C%5C%0A%26%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%20%5Coperatorname%7Bcov%7D(%5Cmathbf%7By%7D)%20%5Cmathbf%7BX%7D%20%20%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cboldsymbol%7B%5Clambda%7D%20%5C%5C%0A%26%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%20(%5Csigma%5E2%20%5Cmathbf%7BI%7D)%20%5Cmathbf%7BX%7D%20%20%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cboldsymbol%7B%5Clambda%7D%20%5C%5C%0A%26%3D%5Csigma%5E%7B2%7D%20%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cboldsymbol%7B%5Clambda%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>根据定理 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/>，因此</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Bvar%7D%5Cleft%28%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5Cright%29%3D%5Csigma%5E%7B2%7D%20%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cboldsymbol%7B%5Clambda%7D%0A" /></p><p>(3)  为了 证明 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> 与 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D" style="display:inline-block;margin: 0;"/> 无关，设  <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> 满足 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%20r%7D_%7B1%7D%3D%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D_%7B2%7D%3D%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> 。这两个等式分别乘以 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D_%7B2%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D_%7B1%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Br%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%20r%7D_%7B1%7D%3D%5Cmathbf%7Br%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Clambda%7D%20%5Cquad%20%5Ctext%20%7B%20and%20%7D%20%5Cquad%20%5Cmathbf%7Br%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%20r%7D_%7B2%7D%3D%5Cmathbf%7Br%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Clambda%7D%20.%0A" /></p><p>这两个式子的左手项互为转置且为标量，因此二者相等，因此右手项也相等，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Br%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Clambda%7D%3D%5Cmathbf%7Br%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Clambda%7D%0A" /></p><p>为了证明 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> 与 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 的选择无关，设 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的两个广义逆，根据广义逆的性质，无论 <img src="https://math.now.sh?inline=%28%5Cmathbf%7BA%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BA%7D%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 取何值， <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5Cleft%28%5Cmathbf%7BA%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BA%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BA%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/>  均保持不变（缺证明）。因此我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%20G%7D_%7B1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%3D%5Cmathbf%7BX%7D%20%5Cmathbf%7BG%7D_%7B2%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%0A" /></p><p>两边均乘以 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D" style="display:inline-block;margin: 0;"/> 使得  <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%20G%7D_%7B1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Ba%7D%20%26%3D%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%20G%7D_%7B2%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Ba%7D%2C%20%5C%5C%0A%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BG%7D_%7B1%7D%20%5Cboldsymbol%7B%5Clambda%7D%20%26%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BG%7D_%7B2%7D%20%5Cboldsymbol%7B%5Clambda%7D%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>得证。</p>
<p>两个可估计函数的估计值存在以下定理。</p>
<p><strong>定理</strong>：如果 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 是不满秩模型的两个可估计函数，<img src="https://math.now.sh?inline=%5Coperatorname%7Bcov%7D%28%5Cmathbf%7By%7D%29%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ，这两个可估计函数的估计值的协方差为</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Bcov%7D%5Cleft%28%5Cboldsymbol%7B%5Clambda%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%2C%20%5Cboldsymbol%7B%5Clambda%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5Cright%29%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7Br%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Clambda%7D_%7B2%7D%3D%5Csigma%5E%7B2%7D%20%5Cboldsymbol%7B%5Clambda%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Br%7D_%7B2%7D%3D%5Csigma%5E%7B2%7D%20%5Cboldsymbol%7B%5Clambda%7D_%7B1%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cboldsymbol%7B%5Clambda%7D_%7B2%7D%2C%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D_%7B1%7D%3D%5Cboldsymbol%7B%5Clambda%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D_%7B2%7D%3D%5Cboldsymbol%7B%5Clambda%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> 。缺证明。</p>
<p><strong>定理</strong>：如果 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 是不满秩模型的一个可估计函数，<img src="https://math.now.sh?inline=%5Coperatorname%7Bcov%7D%28%5Cmathbf%7By%7D%29%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ， 那么估计值 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 是 <strong>BLUE</strong> 值。</p>
<p>证明：假设 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 可以表示为 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，我们表示 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> (为什么这是一个一般的式子?)，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%20r%7D%3D%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> 的一个解。为了确保无偏性，我们必须保证</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3DE%5Cleft%28%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%3D%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cleft(%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%2B%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cleft(%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%20%5Cboldsymbol%7B%5Cbeta%7D%0A" /></p><p>该式必须对所有 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 均成立，因此我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cmathbf%7B0%7D%5E%7B%5Cprime%7D%0A" /></p><p>我们进一步得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Bvar%7D%5Cleft%28%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%20%26%3D%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Coperatorname%7Bcov%7D(%5Cmathbf%7By%7D)%20%5Cmathbf%7Ba%7D%3D%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D%20%5Cmathbf%7Ba%7D%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Ba%7D%20%5C%5C%0A%26%3D%5Csigma%5E%7B2%7D%5Cleft(%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%5Cright)(%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D%2B%5Cmathbf%7Bc%7D)%20%5C%5C%0A%26%3D%5Csigma%5E%7B2%7D%5Cleft(%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D%2B%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bc%7D%2B%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D%2B%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bc%7D%5Cright)%20%5C%5C%0A%26%3D%5Csigma%5E%7B2%7D%5Cleft(%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D%2B%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bc%7D%5Cright)%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>因此为了最小化 <img src="https://math.now.sh?inline=%5Coperatorname%7Bvar%7D%5Cleft%28%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29" style="display:inline-block;margin: 0;"/> ，我们只能使得 <img src="https://math.now.sh?inline=%5Cmathbf%7Bc%7D%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> ，此时满足 <img src="https://math.now.sh?inline=%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cmathbf%7B0%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 。因此  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/>  的 BLUE 值就是 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>这个证明感觉不够好，不够清晰。</p>
<h2 id="sigma-2-的估计值"><img src="https://math.now.sh?inline=%5Csigma%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 的估计值</h2>
<p>SSE 计算公式为</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BSSE%7D%3D%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29%5E%7B%5Cprime%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的任意一个解。SSE 的另外两个表达式为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0A%5Cmathrm%7BSSE%7D%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D-%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%5Cmathrm%7BSSE%7D%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%5Cleft%5B%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%20%5Cmathbf%7By%7D%0A%5Cend%7Bgathered%7D%0A" /></p><p>我们定义 <img src="https://math.now.sh?inline=s%5E2" style="display:inline-block;margin: 0;"/> 作为 <img src="https://math.now.sh?inline=%5Csigma%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 的估计值，计算公式为</p>
<p style=""><img src="https://math.now.sh?from=s%5E%7B2%7D%3D%5Cfrac%7B%5Cmathrm%7BSSE%7D%7D%7Bn-k%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵的行数，<img src="https://math.now.sh?inline=k%3D%5Coperatorname%7Brank%7D%28%5Cmathbf%7BX%7D%29" style="display:inline-block;margin: 0;"/></p>
<p><img src="https://math.now.sh?inline=s%5E2" style="display:inline-block;margin: 0;"/> 的两个性质表示为以下定理。</p>
<p><strong>定理</strong>：在不满秩模型中定义的 <img src="https://math.now.sh?inline=s%5E2" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Coperatorname%7Bcov%7D%28%5Cmathbf%7By%7D%29%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ，我们有以下性质：</p>
<p>(1) <img src="https://math.now.sh?inline=E%5Cleft%28s%5E%7B2%7D%5Cright%29%3D%5Csigma%5E%7B2%7D" style="display:inline-block;margin: 0;"/></p>
<p>(2) <img src="https://math.now.sh?inline=s%5E2" style="display:inline-block;margin: 0;"/> 不会随着 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 或  <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 的选择而改变</p>
<p>证明：</p>
<p>(1) 根据公式，我们有 <img src="https://math.now.sh?inline=E%28%5Cmathrm%7BSSE%7D%29%3DE%5Cleft%5C%7B%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%5Cleft%5B%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%20%5Cmathbf%7By%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> ，根据二次型的期望计算公式 $E\left(\mathbf{y}^{\prime} \mathbf{A} \mathbf{y}\right)=\operatorname{tr}(\mathbf{A} \mathbf{\Sigma})+\boldsymbol{\mu}^{\prime} \mathbf{A} \boldsymbol{\mu} $ ，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%28%5Cmathrm%7BSSE%7D%29%26%3D%5Coperatorname%7Btr%7D%5Cleft%5C%7B%5Cleft%5B%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%5Cleft(%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D%5Cright)%5Cright%5C%7D%2B%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cleft%5B%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft%5C%7B%5Cleft%5B%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%5Cleft(%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D%5Cright)%5Cright%5C%7D%2B%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20-%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft%5C%7B%5Cleft%5B%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%5Cleft(%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D%5Cright)%5Cright%5C%7D%20%5C%5C%0A%0A%26%3D%5Csigma%5E%7B2%7D%5Cleft%5C%7B%5Coperatorname%7Btr%7D(%5Cmathbf%7BI%7D)-%5Coperatorname%7Btr%7D%5Cleft%5B%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%5Cright%5D%5Cright%5C%7D%20%5C%5C%0A%26%3D(n-k)%20%5Csigma%5E%7B2%7D%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=k%3D%5Coperatorname%7Brank%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%3D%5Coperatorname%7Brank%7D(%5Cmathbf%7BX%7D)" style="display:inline-block;margin: 0;"/> 。</p>
<p>这里少了一步证明，就是 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%5B%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%5Cright%5D%20%3D%20k" style="display:inline-block;margin: 0;"/> 的证明，首先根据广义逆的性质，我们有 <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%5Cleft%28%5Cmathbf%7BA%7D%5E%7B-%7D%20%5Cmathbf%7BA%7D%5Cright%29%3D%5Coperatorname%7Brank%7D%5Cleft(%5Cmathbf%7BA%7D%20%5Cmathbf%7BA%7D%5E%7B-%7D%5Cright)%3D%5Coperatorname%7Brank%7D(%5Cmathbf%7BA%7D)%3Dr" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%5Cleft%5B%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%5Cright%5D%20%3D%20k" style="display:inline-block;margin: 0;"/> 。而 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 同时是一个幂等矩阵，因此 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%5B%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%5Cright%5D%20%3D%5Coperatorname%7Brank%7D%5Cleft%5B%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%5Cright%5D%20%3D%20k" style="display:inline-block;margin: 0;"/>  。</p>
<p>(2) 因为 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 可估计，因此 <img src="https://math.now.sh?inline=X%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 对于不同的  <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/>  具有不变性，因此 <img src="https://math.now.sh?inline=%5Cmathrm%7BSSE%7D%3D%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29%5E%7B%5Cprime%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)" style="display:inline-block;margin: 0;"/> 具有不变性。从另一个公式来说，<img src="https://math.now.sh?inline=%5Cmathrm%7BSSE%7D%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%5Cleft%5B%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 中的 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 也具有不变性，同样可证明 SSE 具有不变性，因此 <img src="https://math.now.sh?inline=s%5E2" style="display:inline-block;margin: 0;"/> 具有不变性。</p>
<h2 id="假设正态分布的模型">假设正态分布的模型</h2>
<p>对于不满秩的模型 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> ，我们现在假设</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%20%5Ctext%20%7B%20is%20%7D%20N_%7Bn%7D%5Cleft%28%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2C%20%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D%5Cright%29%20%5Cquad%20%5Ctext%20%7B%20or%20%7D%20%5Cquad%20%5Cboldsymbol%7B%5Cvarepsilon%7D%20%5Ctext%20%7B%20is%20%7D%20N_%7Bn%7D%5Cleft(%5Cmathbf%7B0%7D%2C%20%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D%5Cright)%0A" /></p><p>新增了正态分布假设后，我们现在可以计算得到最大似然估计值。</p>
<p><strong>定理</strong>：如果 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%20%5Csim%20%20N_%7Bn%7D%5Cleft%28%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2C%20%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D%5Cright%29" style="display:inline-block;margin: 0;"/>  ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的秩为 <img src="https://math.now.sh?inline=k%20%3C%20p%20%5Cleq%20n" style="display:inline-block;margin: 0;"/> 的矩阵，那么 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Csigma%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 的最大似然估计值为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0A%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%2C%20%5C%5C%0A%5Chat%7B%5Csigma%7D%5E%7B2%7D%3D%5Cfrac%7B1%7D%7Bn%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%5E%7B%5Cprime%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%20.%0A%5Cend%7Bgathered%7D%0A" /></p><p><strong>证明</strong>：不满秩模型和满秩模型一样，其似然函数和对数似然函数为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0AL%5Cleft%28%5Cboldsymbol%7B%5Cbeta%7D%2C%20%5Csigma%5E%7B2%7D%5Cright%29%3D%5Cfrac%7B1%7D%7B%5Cleft(2%20%5Cpi%20%5Csigma%5E%7B2%7D%5Cright)%5E%7Bn%20%2F%202%7D%7D%20e%5E%7B-(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%5E%7B%5Cprime%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%20%2F%202%20%5Csigma%5E%7B2%7D%7D%2C%20%5C%5C%0A%5Cln%20L%5Cleft(%5Cboldsymbol%7B%5Cbeta%7D%2C%20%5Csigma%5E%7B2%7D%5Cright)%3D-%5Cfrac%7Bn%7D%7B2%7D%20%5Cln%20(2%20%5Cpi)-%5Cfrac%7Bn%7D%7B2%7D%20%5Cln%20%5Csigma%5E%7B2%7D-%5Cfrac%7B1%7D%7B2%20%5Csigma%5E%7B2%7D%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%5E%7B%5Cprime%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%20.%0A%5Cend%7Bgathered%7D%0A" /></p><p>求偏导，使之为0，得到（缺证明）</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%2C%20%5C%5C%0A%5Chat%7B%5Csigma%7D%5E%7B2%7D%3D%5Cfrac%7B1%7D%7Bn%7D%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29%5E%7B%5Cprime%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%2C%0A%5Cend%7Bgathered%7D%0A" /></p><p>这里 $\hat{\boldsymbol{\beta}} $ 是任意一个解，即</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A" /></p><p>同样的，这里 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 与最小二乘估计值一样，但是 <img src="https://math.now.sh?inline=%5Chat%7B%5Csigma%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 是<strong>有偏的</strong>。</p>
<p>下面的定理给出最大似然估计值的一些性质。</p>
<p><strong>定理</strong>：上面的最大似然估计值有以下性质</p>
<p>(1) <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> is <img src="https://math.now.sh?inline=N_%7Bp%7D%5Cleft%5B%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2C%20%5Csigma%5E%7B2%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%5Cright%5D%20." style="display:inline-block;margin: 0;"/><br>
(2) <img src="https://math.now.sh?inline=%28n-k%29%20s%5E%7B2%7D%20%2F%20%5Csigma%5E%7B2%7D" style="display:inline-block;margin: 0;"/> is <img src="https://math.now.sh?inline=%5Cchi%5E%7B2%7D%28n-k%29" style="display:inline-block;margin: 0;"/>.<br>
(3) <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> and <img src="https://math.now.sh?inline=s%5E%7B2%7D" style="display:inline-block;margin: 0;"/> are independent.</p>
<p>缺证明，证明过程与满秩模型应该差不多。注意到 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 的均值和协方差矩阵等都受到  <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 选择的影响，而 <img src="https://math.now.sh?inline=s%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 则对于  <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/>  或  <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/>  的选择具有不变性。</p>
<p><strong>定理</strong>：对于正态分布假设下的不满秩模型，如果 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 是一个可估计函数，那么 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 在所有的无偏估计值中具有最小的方差（注意，没有线性两个字）。</p>
<p>如果没有正态假设，那么  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/>  仅仅是 <strong>BLUE</strong> , 也就是<strong>线性</strong>无偏估计值中方差最小的。但是满足正态假设后，  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/>  是 <strong>BUE</strong> ，是所有无偏估计值中方差最小的 。</p>
<h1>不满秩模型中最小二乘估计值的几何含义</h1>
<p>不满秩模型类似与满秩模型，但是有一些重要的差别。</p>
<p>我们还是有三个空间，参数空间，数据空间和预测空间。<img src="https://math.now.sh?inline=n%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 可以拆分为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D%3D%5Cleft%28%5Cmathbf%7Bx%7D_%7B1%7D%2C%20%5Cmathbf%7Bx%7D_%7B2%7D%2C%20%5Cldots%2C%20%5Cmathbf%7Bx%7D_%7Bp%7D%5Cright%29%0A" /></p><p>矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的每一列均是数据空间中的向量，但是由于 <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28%5Cmathbf%7BX%7D%29%3Dk%3Cp" style="display:inline-block;margin: 0;"/> ，因此这些列向量之间不是线性独立的，但是预测空间还是由这些列的所有可能的线性组合组成。此时，参数空间的维度是 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> ，但是预测空间的维度是 <img src="https://math.now.sh?inline=k%20%3C%20p" style="display:inline-block;margin: 0;"/> 。因此，矩阵乘积  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%20u%7D" style="display:inline-block;margin: 0;"/> ，这里 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> 是参数空间的任意一个向量，是一个从参数空间到预测空间的<strong>多对一</strong>的映射（根据矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 列向量之间的线性相关的关系，易知存在多个不同的  <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> 可以得到相同的乘积）。</p>
<p>根据模型设定  <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/>  ，其中 <img src="https://math.now.sh?inline=E%28%5Cmathbf%7By%7D%29%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> , 根据最小二乘的思想，我们想从预测空间找到一个 <img src="https://math.now.sh?inline=E%28%5Cmathbf%7By%7D%29" style="display:inline-block;margin: 0;"/> 的估计值  <img src="https://math.now.sh?inline=%5Chat%7B%5Cmathbf%7By%7D%7D" style="display:inline-block;margin: 0;"/>  ，使得其与 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的距离最近。这里我们同样需要需要满足  <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cvarepsilon%7D%7D%3D%5Cmathbf%7By%7D-%5Chat%7B%5Cmathbf%7By%7D%7D" style="display:inline-block;margin: 0;"/> 与预测空间正交，因此同样有 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cvarepsilon%7D%7D%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> ，得到正规方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>然后我们再根据这个  <img src="https://math.now.sh?inline=%5Chat%7B%5Cmathbf%7By%7D%7D" style="display:inline-block;margin: 0;"/>  ，推导 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的估计值。由于这里是<strong>多对一</strong>的映射，因此可以得到   <img src="https://math.now.sh?inline=%5Chat%7B%5Cmathbf%7By%7D%7D" style="display:inline-block;margin: 0;"/>  的  <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 不唯一，求解正规方程组，得到 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，也就是说我们有无穷多个解。但是<strong>注意 <img src="https://math.now.sh?inline=%5Chat%7B%5Cmathbf%7By%7D%7D%3D%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 是唯一的</strong>。</p>
<h1>再参数化</h1>
<p>我们现在来正式地了解一下再参数化的例子。在再参数化中，我们将一个不满秩的模型 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的秩为 <img src="https://math.now.sh?inline=k%20%3C%20p%20%5Cleq%20n" style="display:inline-block;margin: 0;"/> 的矩阵，转化为一个满秩的模型 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%5Cmathbf%7BZ%7D%20%5Cboldsymbol%7B%5Cgamma%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20k" style="display:inline-block;margin: 0;"/> 的秩为 $k $ 的矩阵，并且 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cgamma%7D%3D%5Cmathbf%7BU%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 是由 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 个<strong>线性独立的</strong> <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的可估计函数组成的向量。因此我们可以写作</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BZ%7D%20%5Cboldsymbol%7B%5Cgamma%7D%3D%5Cmathbf%7BZ%7D%20%5Cboldsymbol%7BU%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%3D%5Cmathbf%7BZ%20U%7D" style="display:inline-block;margin: 0;"/> ，由于 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=k%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的秩为 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 的矩阵（秩为 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> ，是因为根据要求， <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 的行彼此独立），因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D%20%5Cmathbf%7BU%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 是一个非奇异矩阵，我们可以对 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%20U%7D%3D%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 乘以 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 来得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 的表达式</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BZ%7D%20%5Cmathbf%7BU%7D%20%5Cmathbf%7BU%7D%5E%7B%5Cprime%7D%20%26%3D%5Cmathbf%7BX%7D%20%5Cmathbf%7BU%7D%5E%7B%5Cprime%7D%20%5C%5C%0A%5Cmathbf%7BZ%7D%20%26%3D%5Cmathbf%7BX%7D%20%5Cmathbf%7BU%7D%5E%7B%5Cprime%7D%5Cleft%28%5Cmathbf%7BU%7D%20%5Cmathbf%7BU%7D%5E%7B%5Cprime%7D%5Cright%29%5E%7B-1%7D%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>我们可以证明  <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 满秩，我们有 <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28%5Cmathbf%7BZ%7D%29%20%5Cgeq%20%5Coperatorname%7Brank%7D(%5Cmathbf%7BZ%7D%20%5Cmathbf%7BU%7D)%3D%5Coperatorname%7Brank%7D(%5Cmathbf%7BX%7D)%3Dk" style="display:inline-block;margin: 0;"/> ，但是  <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 的秩最大值为 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> ，因此  <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 的秩为 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 。因此，<img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%5Cmathbf%7BZ%7D%20%5Cboldsymbol%7B%5Cgamma%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> 是一个满秩的模型，可以得到唯一的解 <img src="https://math.now.sh?inline=%5Chat%7B%5Cgamma%7D%3D%5Cleft%28%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>在再参数化的满秩模型中，<img src="https://math.now.sh?inline=%5Csigma%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 的无偏估计值为</p>
<p style=""><img src="https://math.now.sh?from=s%5E%7B2%7D%3D%5Cfrac%7B1%7D%7Bn-k%7D%28%5Cmathbf%7By%7D-%5Cmathbf%7BZ%7D%20%5Chat%7B%5Cgamma%7D%29%5E%7B%5Cprime%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BZ%7D%20%5Chat%7B%5Cgamma%7D)%0A" /></p><p>因为 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D%20%5Cboldsymbol%7B%5Cgamma%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D%20%5Chat%7B%5Cgamma%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 也是相同的，也就是预测值是相同的。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BZ%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cgamma%7D%7D%3D%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%0A" /></p><p>然后两次计算的 SSE 也是相同的</p>
<p style=""><img src="https://math.now.sh?from=%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29%5E%7B%5Cprime%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%3D(%5Cmathbf%7By%7D-%5Cmathbf%7BZ%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cgamma%7D%7D)%5E%7B%5Cprime%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BZ%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cgamma%7D%7D)%0A" /></p><h1>附加条件</h1>
<p>通过添加<strong>附加条件</strong> (<em>side conditions</em>) 使得参数估计值唯一，此时得到的参数估计值<strong>与某个特定的广义逆参数估计值相同</strong>。</p>
<p>我们知道 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 可以理解为 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> 个可估计函数组成的向量，如果一个附加条件（的左手项）是一个可估计函数，那么这个附加条件（的左手项）可以表示为  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的行的线性组合，因此无法有助于改善 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的秩亏缺的状态，因此正规方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 还是没有唯一解 。因此，<strong>附加条件必须是一个不可估计函数</strong>。</p>
<p><img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的秩为 <img src="https://math.now.sh?inline=k%20%3C%20p%20%5Cleq%20n" style="display:inline-block;margin: 0;"/> 的矩阵，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 缺少的秩为 <img src="https://math.now.sh?inline=p-k" style="display:inline-block;margin: 0;"/> 。为了得到唯一估计值 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> ，我们需要添加附件条件使得 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 满秩。因此，我们定义附加条件 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> 或 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=%28p-k%29%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的秩为 <img src="https://math.now.sh?inline=p-k" style="display:inline-block;margin: 0;"/> 的矩阵，并且 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 是由<strong>不可估计函数</strong>组成的向量。</p>
<p><strong>定理</strong>：在满足上面的条件下，同时满足 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> 的参数估计值 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 是<strong>唯一的</strong>。</p>
<p><strong>证明</strong>：这里我们有两个方程组</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D%20%5C%5C%0A%26%5Cmathbf%7B0%7D%3D%5Cmathbf%7BT%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cmathbf%7B0%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>我们可以将其合并为一个</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7By%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BX%7D%20%5C%5C%0A%5Cmathbf%7BT%7D%0A%5Cend%7Barray%7D%5Cright)%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cboldsymbol%7B%5Cvarepsilon%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>因为矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D" style="display:inline-block;margin: 0;"/> 的行之间线性无关，并且不是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的行的线性函数，因此矩阵 <img src="https://math.now.sh?inline=%5Cleft%28%5Cbegin%7Barray%7D%7Bl%7D%5Cmathbf%7BX%7D%20%5C%5C%20%5Cmathbf%7BT%7D%5Cend%7Barray%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=%28n%2Bp-k%29%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的秩为 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> 的矩阵，也就是满秩矩阵。因此 <img src="https://math.now.sh?inline=%5Cleft%28%5Cbegin%7Barray%7D%7Bl%7D%5Cmathbf%7BX%7D%20%5C%5C%20%5Cmathbf%7BT%7D%5Cend%7Barray%7D%5Cright%29%5E%7B%5Cprime%7D%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%5Cmathbf%7BX%7D%20%5C%5C%20%5Cmathbf%7BT%7D%5Cend%7Barray%7D%5Cright)" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=p%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的秩为 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> 的矩阵，最小二乘的正规方程组</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BX%7D%20%5C%5C%0A%5Cmathbf%7BT%7D%0A%5Cend%7Barray%7D%5Cright%29%5E%7B%5Cprime%7D%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BX%7D%20%5C%5C%0A%5Cmathbf%7BT%7D%0A%5Cend%7Barray%7D%5Cright)%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BX%7D%20%5C%5C%0A%5Cmathbf%7BT%7D%0A%5Cend%7Barray%7D%5Cright)%5E%7B%5Cprime%7D%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7By%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>具有唯一解，为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%20%26%3D%5Cleft%5B%5Cleft%28%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BX%7D%20%5C%5C%0A%5Cmathbf%7BT%7D%0A%5Cend%7Barray%7D%5Cright%29%5E%7B%5Cprime%7D%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BX%7D%20%5C%5C%0A%5Cmathbf%7BT%7D%0A%5Cend%7Barray%7D%5Cright)%5Cright%5D%5E%7B-1%7D%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BX%7D%20%5C%5C%0A%5Cmathbf%7BT%7D%0A%5Cend%7Barray%7D%5Cright)%5E%7B%5Cprime%7D%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7By%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%0A%5Cend%7Barray%7D%5Cright)%20%5C%5C%0A%26%3D%5Cleft%5B%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%2C%20%5Cmathbf%7BT%7D%5E%7B%5Cprime%7D%5Cright)%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BX%7D%20%5C%5C%0A%5Cmathbf%7BT%7D%0A%5Cend%7Barray%7D%5Cright)%5Cright%5D%5E%7B-1%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%2C%20%5Cmathbf%7BT%7D%5E%7B%5Cprime%7D%5Cright)%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7By%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%0A%5Cend%7Barray%7D%5Cright)%20%5C%5C%0A%26%3D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%2B%5Cmathbf%7BT%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BT%7D%5Cright)%5E%7B-1%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%2B%5Cmathbf%7BT%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7B0%7D%5Cright)%20%5C%5C%0A%26%3D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%2B%5Cmathbf%7BT%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BT%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>添加附加条件的方式不适合满秩的模型，如果模型满秩，此时 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=p%20%5Ctimes%20%20p" style="display:inline-block;margin: 0;"/> 的非奇异矩阵，也就是说  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 有 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> 的线性无关的行，因此   <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的所有行是 <img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7Bp%7D" style="display:inline-block;margin: 0;"/> 的一组基，因此任意一个 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D" style="display:inline-block;margin: 0;"/> 矩阵的行一定是   <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的所有行的线性组合，也就是说，你找不到一个 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D" style="display:inline-block;margin: 0;"/> 矩阵，使得 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 是由不可估计函数组成的向量。</p>
<p>这里得到 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 仍然满足原始的正规方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，因为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%2B%5Cmathbf%7BT%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BT%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%26%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%5Cquad%20%5Cbecause%20%5Cmathbf%7BT%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%26%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>我有几个问题，这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵的秩 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 在实际数据中是一个不确定的数，也就是说我们需要添加的附加条件的数目 <img src="https://math.now.sh?inline=p-k" style="display:inline-block;margin: 0;"/> 也不定；第二，我们怎么找到这个 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D" style="display:inline-block;margin: 0;"/> 矩阵，使得 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 是由不可估计函数组成的向量呢？我感觉这个方法不好实现，就是在实际处理中，用了附件条件也不一定能得到唯一解，可能还是要求广义逆的解。再说了，最终得到的所谓的唯一的  <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/>  ，实际上还是之前的不满秩矩阵的一个解，我感觉没有必要非要这么折腾一下，可以直接求广义逆的解。</p>
<p>从现实的角度来看，好像一般是几种方式联合使用，比如添加附加条件 + 广义逆求解，再参数化 + 广义逆求解等。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>18位身份证号的编码规则</title>
    <url>/posts/75bebd59/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>突然有一个疑问，身份证号码是如何编码的？最主要是如何避免身份证号重复的（同一个行政区域内的同年同月同日生的同性别的新生儿）？</p>
<span id="more"></span>
<h1>18位身份证号编码规则</h1>
<p>知乎的一篇博文<a href="https://zhuanlan.zhihu.com/p/21286417">实名认证前传之身份证号码编码规则</a> 感觉已经说得很清楚了，用我自己的身份证号测试了一下，最后一位的校验码的规则应该是对的。</p>
<p>下面的内容均来自这一篇博文。</p>
<blockquote>
<p><strong>一、身份证号码结构</strong></p>
<p>早期‘身份证号码’叫‘社会保障号’，为15位，1999年开始更名为公民身份证号码，即第二代身份证，为18位，且终身不变。</p>
<p>430512198908131367</p>
<p>公民身份号码是特征组合码，由前十七位数字本体码和最后一位数字校验码组成。排列顺序从左至右依次为六位数字地址码，八位数字出生日期码，三位数字顺序码和一位数字校验码。</p>
<p><strong>地址码</strong>： 6位，表示编码对象常住户口所在县(市、旗、区)的行政区划代码。对于新生儿，该地址码为户口登记地行政区划代码。需要没说明的是，随着行政区划的调整，同一个地方进行户口登记的可能存在地址码不一致的情况。行政区划代码按GB/T2260的规定执行。</p>
<p><strong>出生日期码</strong>：8位，表示编码对象出生的年、月、日，年、月、日代码之间不用分隔符，格式为YYYYMMDD，如19880328。按GB/T 7408的规定执行。原15位身份证号码中出生日期码还有对百岁老人特定的标识，其中999、998、997、996分配给百岁老人。</p>
<p><strong>顺序码</strong>： 3位，表示在同一地址码所标识的区域范围内，对同年、同月、同日出生的人编定的顺序号，顺序码的奇数分配给男性，偶数分配给女性。</p>
<p><strong>校验码</strong>： 1位，根据本体码，通过采用ISO 7064:1983,MOD 11-2校验码系统计算出校验码。算法可参考下文。前面有提到数字校验码，我们知道校验码也有X的，实质上为罗马字符X，相当于10.</p>
</blockquote>
<h2 id="校验码算法">校验码算法</h2>
<p>校验码是通过前 17 位数字通过下面这个算法进行计算得到的，也就是说前 17 位数字确定了，第 18 位数字也就确定了。</p>
<p>举个例子，假设本体码为  11010519491231002</p>
<p>第一步：根据下表，将本体码的前17位数字乘以相应的加权因子，求和，按上面的例子，就是 $1 \times 7+1 \times 9+ \cdots +2 \times 2 = 167 $</p>
<table>
<thead>
<tr>
<th>身份证位置序号</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
<th>17</th>
</tr>
</thead>
<tbody>
<tr>
<td>加权因子</td>
<td>7</td>
<td>9</td>
<td>10</td>
<td>5</td>
<td>8</td>
<td>4</td>
<td>2</td>
<td>1</td>
<td>6</td>
<td>3</td>
<td>7</td>
<td>9</td>
<td>10</td>
<td>5</td>
<td>8</td>
<td>4</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>第二步，对上面的和除以11计算余数，这里就是 <img src="https://math.now.sh?inline=167%5C%2511%20%3D%202" style="display:inline-block;margin: 0;"/></p>
<p>第三步，根据余数对照下面，最终得到校验码为  X</p>
<table>
<thead>
<tr>
<th>余数</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td>校验码</td>
<td>1</td>
<td>0</td>
<td>X</td>
<td>9</td>
<td>8</td>
<td>7</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>因此，本例的完整身份证号为 11010519491231002X</p>
<h1>如何避免重复呢？</h1>
<p>我的问题是，同一个县同一天肯定不只是一个人出生（顺序码从 000 到 999 一共是1000个数，也就是一个县同一天能落户的新生儿数目的最大值是 1000 ），同一个县可以用于落户的派出所应该有多个，那么同一天同一性别的多个初生儿同时分别去多个派出所落户，是如何确保他们分配得到的身份证号是唯一的呢？</p>
<p>这个问题我不知道，但是我感觉这应该是数据库的一个操作。我能想到的是，可能在同一个县里如果有人新建记录的时候就锁住数据库，不允许其他人再往数据库里插入记录，这样就可以避免身份证号的重复问题。</p>
<p>然后我咨询了一下小强，他和我说这就是数据库的一个基本特性，如果有多个人同时往数据库里插入了主键相同的一行，那么应该有一个人会插入成功，其他人会显示失败。</p>
<h2 id="数据库事务">数据库事务</h2>
<p>下面的内容主要来自维基百科 <a href="https://www.wikiwand.com/zh-hans/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1">数据库事务</a> 。</p>
<blockquote>
<p><strong>数据库事务</strong>（简称：<strong>事务</strong>）是<a href="https://www.wikiwand.com/zh-hans/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">数据库管理系统</a>执行过程中的一个逻辑单位，由一个有限的<a href="https://www.wikiwand.com/zh-hans/%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a>操作序列构成。</p>
<h2 id="概要">概要</h2>
<p>数据库事务通常包含了一个序列的对数据库的读/写操作。包含有以下两个目的：</p>
<ol>
<li>为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。</li>
<li>当多个<a href="https://www.wikiwand.com/zh-hans/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">应用程序</a>在<a href="https://www.wikiwand.com/zh-hans/%E5%B9%B6%E5%8F%91">并发</a>访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。</li>
</ol>
<p>当事务被提交给了<a href="https://www.wikiwand.com/zh-hans/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">数据库管理系统</a>（DBMS），则<strong>DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要<a href="https://www.wikiwand.com/zh-hans/%E5%9B%9E%E6%BB%9A_(%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86)">回滚</a>，回到事务执行前的状态；同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行</strong>。</p>
<h3 id="例子">例子</h3>
<p>某人要在商店使用<a href="https://www.wikiwand.com/zh-hans/%E9%9B%BB%E5%AD%90%E8%B2%A8%E5%B9%A3">电子货币</a>购买100元的东西，当中至少包括两个操作：</p>
<ol>
<li>该人帐户减少100元</li>
<li>商店帐户增加100元</li>
</ol>
<p><strong>支援交易的资料库管理系统</strong>（<strong>transactional DBMS</strong>）就是要确保以上两个操作（整个“交易”）都能完成，或一起取消；否则就会出现100元平白消失或出现的情况。</p>
<p>但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、<a href="https://www.wikiwand.com/zh-hans/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F">数据库系统</a>／<a href="https://www.wikiwand.com/zh-hans/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>出错，甚至是存储介质出错等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的<a href="https://www.wikiwand.com/zh-hans/%E4%B8%80%E8%87%B4%E6%80%A7">一致性</a>得到保证的状态）。为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志（英语：<a href="https://www.wikiwand.com/en/Transaction_log">Transaction log</a>）以追踪事务中所有影响数据库数据的操作[<a href="https://www.wikiwand.com/zh-hans/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1#citenote1">1]</a>[<a href="https://www.wikiwand.com/zh-hans/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1#citenote2">2]</a>。</p>
</blockquote>
<h2 id="ACID-性质">ACID 性质</h2>
<p>下文内容主要来自于 <a href="https://blog.csdn.net/qq_39521554/article/details/80240841">数据库的ACID（原子性、一致性、隔离性与持久性）</a></p>
<p>数据库管理系统中**事务(transaction)**的四个特性（分析时根据首字母缩写依次解释）：<strong>原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）</strong></p>
<p>详解</p>
<ol>
<li>原子性</li>
</ol>
<blockquote>
<p>原子性是指事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生。</p>
<p>可采用“A向B转账”这个例子来说明解释</p>
<p>在DBMS中，默认情况下一条SQL就是一个单独事务，事务是自动提交的。只有显式的使用start transaction开启一个事务，才能将一个代码块放在事务中执行。</p>
</blockquote>
<p>新增解释，根据 <a href="https://www.zhihu.com/question/30272728/answer/72476703">数据库事务原子性、一致性是怎样实现的？ - 左轻侯的回答 - 知乎</a></p>
<blockquote>
<p>为了实现原子性，需要通过<strong>日志</strong>：将所有对数据的更新操作都写入日志，如果一个事务中的一部分 操作已经成功，但以后的操作，由于断电/系统崩溃/其它的软硬件错误而无法继续，则通过回溯日志，将已经执行成功的操作撤销，从而达到 “全部操作失败&quot; 的目的。最常见的场景是，<strong>数据库系统崩溃后重启，此时数据库处于不一致的状态，必须先执行一个crash recovery的过程：读取日志 进行REDO</strong>（重演将所有已经执行成功但尚末写入到磁盘的操作，保证持久性），再对所有到崩溃 时尚末成功提交的事务进行UNDO (撤销所有执行了一部分但尚末提交的操作，保证原子性)。 crash recovery结束后，数据库恢复到一致性状态，可以继续被使用。</p>
</blockquote>
<ol start="2">
<li>一致性</li>
</ol>
<blockquote>
<p>一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</p>
<p>如A给B转账，不论转账的事务操作是否成功，其两者的存款总额不变（这是业务逻辑的一致性，至于数据库关系约束的完整性就更好理解了）。</p>
<p>保障机制（也从两方面着手）：数据库层面会在一个事务执行之前和之后，数据会符合你设置的约束（唯一约束，外键约束,check约束等)和触发器设置；此外，数据库的内部数据结构（如 B 树索引或双向链表）都必须是正确的。业务的一致性一般由开发人员进行保证，亦可转移至数据库层面。</p>
</blockquote>
<ol start="3">
<li>隔离性</li>
</ol>
<blockquote>
<p>多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。</p>
<p>在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</p>
<p>事务最复杂问题都是由事务隔离性引起的。完全的隔离性是不现实的，完全的隔离性要求数据库同一时间只执行一条事务，这样会严重影响性能。关于隔离性中的事务隔离等级（事务之间影响），参见相应博文</p>
</blockquote>
<p>这里解释的还不够细，当存在并发操作时，原子性并不能保证一致性，因此引入了隔离性。详细回答见  <a href="https://www.zhihu.com/question/30272728/answer/72476703">数据库事务原子性、一致性是怎样实现的？ - 左轻侯的回答 - 知乎</a></p>
<p>下面最核心的话是，<strong>多个事务并发执行后的状态，和它们串行执行后的状态是等价的</strong>。如何实现隔离性很复杂，但是我也不太关心。</p>
<blockquote>
<p>但是，原子性并不能完全保证一致性。在多个事务并行进行的情况下，即使保证了每一个事务的原 子性，仍然可能导致数据不一致的结果。例如，事务1需要将100元转入帐号A: 先读取帐号A的 值，然后在这个值上加上 100 。但是，在这两个操作之间，另一个事务 2 修改了帐号 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的值，为它增 加了100元。那么最后的结果应该是A增加了200元。但事实上，事务1最终完成后，帐号A只增加 了100元，因为事务2的修改结果被事务1覆盖掉了。<br>
为了保证并发情况下的一致性，引入了隔离性，即保证每一个事务能够看到的数据总是一致的，就好象其它并发事务并不存在一样。用术语来说，就是<strong>多个事务并发执行后的状态，和它们串行执行后的状态是等价的</strong>。怎样实现隔离性，已经有很多人回答过了，原则上无非是两种类型的锁:<br>
一种是悲观锁 <img src="https://math.now.sh?inline=%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，即当前事务将所有涉及操作的对象加锁，操作完成后释放给其它对象使用。为了尽 可能提高性能，发明了各种粒度（数据库级/表级/行级…)/各种性质（共享钓/排他锁/共享意向 锁/排他意向锁/共享排他意向锁…) 的锁。为了解决死锁问题，又发明了两阶段锁协议/死锁检测 等一系列的技术。<br>
一种是乐观锁，即不同的事务可以同时看到同一对象 (一般是数据行) 的不同历史版本。如果有两 个事务同时修改了同一数据行，那么在较晩的事务提交时进行冲突检测。实现也有两种，一种是通 过日志UND <img src="https://math.now.sh?inline=%5E%7B%5Ccirc%7D" style="display:inline-block;margin: 0;"/> O的方式来获取数据行的历史版本，一种是简单地在内存中保存同一数据行的多个历 史版本，通过时间濯 <img src="https://math.now.sh?inline=%5E%7B%5Cmathrm%7Ba%7D%7D" style="display:inline-block;margin: 0;"/> 来区分。<br>
锁也是数据库实现中最复杂的部分之一。同样，如果涉及到分布式系统（分布式锁和两阶段提交是 分布式事务的基础)，会比上述场景还要复杂得多。</p>
</blockquote>
<ol start="4">
<li>持久性</li>
</ol>
<blockquote>
<p>这是最好理解的一个特性：持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。（完成的事务是系统永久的部分，对系统的影响是永久性的，该修改即使出现致命的系统故障也将一直保持）</p>
<p><code>write ahead logging</code>：SQL Server中使用了WAL（Write-Ahead Logging）技术来保证事务日志的ACID特性，在数据写入到数据库之前，先写入到日志，再将日志记录变更到存储器中。</p>
</blockquote>
<blockquote>
<p>————————————————<br>
版权声明：本文为CSDN博主「图灵的猫i」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：<a href="https://blog.csdn.net/qq_39521554/article/details/80240841">https://blog.csdn.net/qq_39521554/article/details/80240841</a></p>
</blockquote>
<h2 id="身份证号码重复与隔离性">身份证号码重复与隔离性</h2>
<p>上面的身份证号码避免重复的问题就是用到了隔离性，如果我们把身份证号码设置位主键，那么往数据库中同时插入多个相同主键的行这一并发操作，按照隔离性的性质，和它们<strong>串行执行后的状态是等价的</strong>，也就是说最终应该是<strong>有一个插入操作成功，其他插入操作应该会报错</strong>，从而避免违背一致性，即数据库中出现重复的主键。</p>
<p>所以我的担心是多余的，数据库系统的基本特性本身就可以避免身份证号码重复这个问题的发生。</p>
]]></content>
      <tags>
        <tag>数据分析</tag>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>特征值的乘积与和</title>
    <url>/posts/c98e6ad5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>证明特征值的乘积为行列式，特征值的和为迹。</p>
<span id="more"></span>
<h1>特征值和特征向量</h1>
<p>这一小节的内容主要来自于吴恩达老师的讲义。</p>
<p><img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的特征值和特征向量满足关系：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%20x%3D%5Clambda%20x%2C%20%5Cquad%20x%20%5Cneq%200%0A" /></p><p>我们注意到对于任何特征向量 <img src="https://math.now.sh?inline=x%20%5Cin%20%5Cmathbb%7BC%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> ，和特征值 <img src="https://math.now.sh?inline=t%20%5Cin%20%5Cmathbb%7BC%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%28c%20x%29%3Dc%20%5Cmathbf%7BA%7D%20x%3Dc%20%5Clambda%20x%3D%5Clambda(c%20x)" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=c%20x" style="display:inline-block;margin: 0;"/> 一样是 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的特征向量。因此，当我们提到与特征值 <img src="https://math.now.sh?inline=%5Clambda" style="display:inline-block;margin: 0;"/> 的特征向量 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 时，<strong>我们一般假定特征向量 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 是标准化的</strong>，即 <img src="https://math.now.sh?inline=%5C%7Cx%5C%7C%20%3D%201" style="display:inline-block;margin: 0;"/> 。但是，我们注意到，<img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=-x" style="display:inline-block;margin: 0;"/> 都是特征向量，因此我们无法保证特征向量的符号。</p>
<p>我们可以将上式改写为：</p>
<p style=""><img src="https://math.now.sh?from=%7C%28%5Cmathbf%7BA%7D-%5Clambda%20I%29%7C%3D0%0A" /></p><p>如果我们将上式中的行列式展开，我们得到一个变量为 <img src="https://math.now.sh?inline=%5Clambda" style="display:inline-block;margin: 0;"/> 的 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 次多项式。</p>
<p style=""><img src="https://math.now.sh?from=p%28%5Clambda%29%20%3D%20%7C(%5Cmathbf%7BA%7D-%5Clambda%20I)%7C%0A" /></p><p>这个多项式称为<strong>特征多项式</strong> (<em>characteristic polynomial</em>) ，而 <img src="https://math.now.sh?inline=%7C%28%5Cmathbf%7BA%7D-%5Clambda%20I%29%7C%3D0" style="display:inline-block;margin: 0;"/> 这个方程称为矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的<strong>特征方程</strong>  (<em>characteristic equation</em>) 。特征多项式的根即为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的特征值，如果对重根也计数，那么 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 将有 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个特征值，但是某些特征值可能会是复数，这一点可以通过<strong>代数基本定理</strong>证明。</p>
<p>举个例子，假设  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%203%20%26%202%20%5C%5C%203%20%26%20-2%20%5Cend%7Barray%7D%20%5Cright%5D" style="display:inline-block;margin: 0;"/> ，那么其特征方程为</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%7C%5Cbegin%7Barray%7D%7Bc%7D%203-%5Clambda%20%26%202%20%5C%5C%203%20%26%20-2-%5Clambda%20%5Cend%7Barray%7D%20%5Cright%7C%20%3D%200%20%5Cquad%20%5Ctext%7B%20%E6%88%96%20%7D%20%5Cquad%20%5Clambda%5E%7B2%7D-%5Clambda%2B12%3D0%0A" /></p><p>那么<img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的特征值为 <img src="https://math.now.sh?inline=%5Clambda_%7B1%7D%20%3D%204" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Clambda_%7B2%7D%20%3D%20-3" style="display:inline-block;margin: 0;"/></p>
<h1>代数基本定理</h1>
<p>维基百科的说明如下</p>
<blockquote>
<p><strong>代数基本定理</strong>说明，任何一个一元复系数<a href="https://www.wikiwand.com/zh-hans/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%96%B9%E7%A8%8B">多项式方程</a>都至少有一个复数<a href="https://www.wikiwand.com/zh-hans/%E6%A0%B9_(%E6%95%B0%E5%AD%A6)">根</a>。也就是说，<a href="https://www.wikiwand.com/zh-hans/%E8%A4%87%E6%95%B8_(%E6%95%B8%E5%AD%B8)">复数</a><a href="https://www.wikiwand.com/zh-hans/%E4%BD%93_(%E6%95%B0%E5%AD%A6)">域</a>是<a href="https://www.wikiwand.com/zh-hans/%E4%BB%A3%E6%95%B0%E5%B0%81%E9%97%AD%E5%9F%9F">代数封闭</a>的。</p>
<p>有时这个定理表述为：任何一个非零的一元n次复系数多项式，都正好有n个复数根（重根视为多个根）。这似乎是一个更强的命题，但实际上是“至少有一个根”的直接结果，因为不断把多项式除以它的线性因子，即可从有一个根推出有n个根。也就是说，<strong>任何一个n次多项式，都可以因式分解为n个复系数一次多项式的乘积</strong>。</p>
</blockquote>
<p>代数基本定理是高斯发现的，高斯总共给出了四个证明，但是我看维基百科后面的证明过程都看不懂。</p>
<p>有一个<a href="https://www.shuxuele.com">数学乐</a>的网址，更简单直观地解释了代数基本定理，感兴趣可以去看一下这里 <a href="https://www.shuxuele.com/algebra/fundamental-theorem-algebra.html">代数基本定理</a> 。</p>
<p>简单地说，就是任何一个一元 <strong>n</strong> 次多项式均有 <strong>n</strong> 个根（包括重根），但是可能是复数。任何一元 <strong>n</strong> 次多项式可以因式分解为下面地形式，其中 <img src="https://math.now.sh?inline=r_1%2Cr_2%2C%5Ccdots%2Cr_n" style="display:inline-block;margin: 0;"/> 为 <strong>n</strong> 个根 ，并且易得 <img src="https://math.now.sh?inline=a" style="display:inline-block;margin: 0;"/> 为多项式第一项 <img src="https://math.now.sh?inline=x%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 的系数。</p>
<p style=""><img src="https://math.now.sh?from=a%28x-r_%7B1%7D%29(x-r_%7B2%7D)%5Ccdots(x-r_%7Bn%7D)%0A" /></p><p>如果多项式有复数根，它所有的复数根必然为共轭对 (<img src="https://math.now.sh?inline=a%2Bb%5Cmathbf%7Bi%7D" style="display:inline-block;margin: 0;"/>  和 <img src="https://math.now.sh?inline=a-b%5Cmathbf%7Bi%7D" style="display:inline-block;margin: 0;"/>)。</p>
<h1>特征值的乘积与和</h1>
<p>这一节内容主要来自于《linear algebra with applications》 的第六章特征值。</p>
<p>若 <img src="https://math.now.sh?inline=p%28%5Clambda%29" style="display:inline-block;margin: 0;"/> 为矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的特征多项式，则</p>
<p style=""><img src="https://math.now.sh?from=p%28%5Clambda%29%3D%5Coperatorname%7Bdet%7D(%5Cmathbf%7BA%7D-%5Clambda%20I)%3D%5Cleft%7C%5Cbegin%7Barray%7D%7Bcccc%7D%0Aa_%7B11%7D-%5Clambda%20%26%20a_%7B12%7D%20%26%20%5Ccdots%20%26%20a_%7B1%20n%7D%20%5C%5C%0Aa_%7B21%7D%20%26%20a_%7B22%7D-%5Clambda%20%26%20%5Ccdots%20%26%20a_%7B2%20n%7D%20%5C%5C%0A%5Cvdots%20%26%20%26%20%26%20%5C%5C%0Aa_%7Bn%201%7D%20%26%20a_%7Bn%202%7D%20%26%20%5Ccdots%20%26%20a_%7Bn%20n%7D-%5Clambda%0A%5Cend%7Barray%7D%5Cright%7C%0A" /></p><p>按照第一列展开，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Bdet%7D%28%5Cmathbf%7BA%7D-%5Clambda%20I%29%3D%5Cleft(a_%7B11%7D-%5Clambda%5Cright)%20%5Coperatorname%7Bdet%7D%5Cleft(%5Cmathbf%7BM%7D_%7B11%7D%5Cright)%2B%5Csum_%7Bi%3D2%7D%5E%7Bn%7D%20a_%7Bi%201%7D(-1)%5E%7Bi%2B1%7D%20%5Coperatorname%7Bdet%7D%5Cleft(%5Cmathbf%7BM%7D_%7Bi%201%7D%5Cright)%0A" /></p><p>我们注意到，子式 <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D_%7B11%7D" style="display:inline-block;margin: 0;"/> 不包含一个对角线元素 (<img src="https://math.now.sh?inline=a_%7B11%7D-%5Clambda" style="display:inline-block;margin: 0;"/>) ，而其他子式 <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D_%7Bi1%7D" style="display:inline-block;margin: 0;"/> (<img src="https://math.now.sh?inline=i%3D2%2C%5Ccdots%2Cn" style="display:inline-block;margin: 0;"/>)  不包含两个对角线元素 <img src="https://math.now.sh?inline=%5Cleft%28a_%7B11%7D-%5Clambda%5Cright%29" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cleft%28a_%7Bii%7D-%5Clambda%5Cright%29" style="display:inline-block;margin: 0;"/> 。</p>
<p>将子式 <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D_%7B11%7D" style="display:inline-block;margin: 0;"/>  采用相同的方法展开，我们得到下式是 <img src="https://math.now.sh?inline=%5Coperatorname%7Bdet%7D%28%5Cmathbf%7BA%7D-%5Clambda%20I%29" style="display:inline-block;margin: 0;"/>  的展开式中<strong>唯一包含超过 <img src="https://math.now.sh?inline=n-2" style="display:inline-block;margin: 0;"/> 个对角线元素</strong>的项（不好直接证明，在草稿上继续展开，就可以看出规律，其他项应该都是包括了<img src="https://math.now.sh?inline=n-2" style="display:inline-block;margin: 0;"/> 个对角线元素 ）。</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28a_%7B11%7D-%5Clambda%5Cright%29%5Cleft(a_%7B22%7D-%5Clambda%5Cright)%20%5Ccdots%5Cleft(a_%7Bn%20n%7D-%5Clambda%5Cright)%0A" /></p><p>我们把这个式子展开后，易得 <img src="https://math.now.sh?inline=%5Clambda%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 的系数为 <img src="https://math.now.sh?inline=%28-1%29%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> ，因此  <img src="https://math.now.sh?inline=p%28%5Clambda%29" style="display:inline-block;margin: 0;"/>  的首系数为  <img src="https://math.now.sh?inline=%28-1%29%5E%7Bn%7D" style="display:inline-block;margin: 0;"/>  。根据代数基本定理，如果  <img src="https://math.now.sh?inline=%5Clambda_1%2C%5Clambda_2%2C%5Ccdots%2C%5Clambda_n" style="display:inline-block;margin: 0;"/> 为方阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的特征根，那么  <img src="https://math.now.sh?inline=p%28%5Clambda%29" style="display:inline-block;margin: 0;"/> 可以因式分解为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ap%28%5Clambda%29%20%26%3D(-1)%5E%7Bn%7D%5Cleft(%5Clambda-%5Clambda_%7B1%7D%5Cright)%5Cleft(%5Clambda-%5Clambda_%7B2%7D%5Cright)%20%5Ccdots%5Cleft(%5Clambda-%5Clambda_%7Bn%7D%5Cright)%20%5C%5C%0A%26%3D%5Cleft(%5Clambda_%7B1%7D-%5Clambda%5Cright)%5Cleft(%5Clambda_%7B2%7D-%5Clambda%5Cright)%20%5Ccdots%5Cleft(%5Clambda_%7Bn%7D-%5Clambda%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们得到下式，证明方阵的所有特征值之积为其行列式。</p>
<p style=""><img src="https://math.now.sh?from=p%280%29%20%3D%20%5Clambda_%7B1%7D%20%5Clambda_%7B2%7D%5Ccdots%20%5Clambda_%7Bn%7D%20%3D%20%5Cdet(%5Cmathbf%7BA%7D)%20%0A" /></p><p>由 <img src="https://math.now.sh?inline=%5Cleft%28a_%7B11%7D-%5Clambda%5Cright%29%5Cleft(a_%7B22%7D-%5Clambda%5Cright)%20%5Ccdots%5Cleft(a_%7Bn%20n%7D-%5Clambda%5Cright)" style="display:inline-block;margin: 0;"/> ，我们同样可以看出 <img src="https://math.now.sh?inline=%28-%5Clambda%29%5E%7Bn-1%7D" style="display:inline-block;margin: 0;"/> 的系数为  <img src="https://math.now.sh?inline=%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20a_%7Bii%7D" style="display:inline-block;margin: 0;"/> 。如果对 <img src="https://math.now.sh?inline=p%28%5Clambda%29%3D%5Cleft(%5Clambda_%7B1%7D-%5Clambda%5Cright)%5Cleft(%5Clambda_%7B2%7D-%5Clambda%5Cright)%20%5Ccdots%5Cleft(%5Clambda_%7Bn%7D-%5Clambda%5Cright)" style="display:inline-block;margin: 0;"/> 同样求 <img src="https://math.now.sh?inline=%28-%5Clambda%29%5E%7Bn-1%7D" style="display:inline-block;margin: 0;"/> 的系数，可以得到其为  <img src="https://math.now.sh?inline=%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Clambda_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，因此我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Clambda_%7Bi%7D%20%3D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20a_%7Bii%7D%0A" /></p><p>因此我们证明所有特征值之和为矩阵的迹。</p>
<h1>相似矩阵</h1>
<p>这一节内容主要来自于《linear algebra with applications》 的第六章特征值。</p>
<p>对于矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 和矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> ，若存在一个非奇异矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7BS%7D" style="display:inline-block;margin: 0;"/>，使得  <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D%20%3D%20%5Cmathbf%7BS%5E%7B-1%7DAS%7D" style="display:inline-block;margin: 0;"/> ，那么我们称矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> <strong>相似于</strong>矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/>  。</p>
<p><strong>定理</strong>：令矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 和矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 矩阵，若 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 相似于 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/>，则这两个矩阵有相同的特征多项式，且相应地有相同的特征值。</p>
<p>证明：令 <img src="https://math.now.sh?inline=p_%7BA%7D%28%5Clambda%29" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=p_%7BB%7D%28%5Clambda%29" style="display:inline-block;margin: 0;"/> 分别为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 的特征多项式。因为 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 相似于 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/>，则存在一个非奇异矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7BS%7D" style="display:inline-block;margin: 0;"/>，使得  <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D%20%3D%20%5Cmathbf%7BS%5E%7B-1%7DAS%7D" style="display:inline-block;margin: 0;"/> 。因此</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ap_%7BB%7D%28%5Clambda%29%20%26%3D%5Coperatorname%7Bdet%7D(%5Cmathbf%7BB%7D-%5Clambda%20%5Cmathbf%7BI%7D)%20%5C%5C%0A%26%3D%5Coperatorname%7Bdet%7D%5Cleft(%5Cmathbf%7BS%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D%20%5Cmathbf%7BS%7D-%5Clambda%20%5Cmathbf%7BI%7D%5Cright)%20%5C%5C%0A%26%3D%5Coperatorname%7Bdet%7D%5Cleft(%5Cmathbf%7BS%7D%5E%7B-1%7D(%5Cmathbf%7BA%7D-%5Clambda%20%5Cmathbf%7BI%7D)%20%5Cmathbf%7BS%7D%5Cright)%20%5C%5C%0A%26%3D%5Coperatorname%7Bdet%7D%5Cleft(%5Cmathbf%7BS%7D%5E%7B-1%7D%5Cright)%20%5Coperatorname%7Bdet%7D(%5Cmathbf%7BA%7D-%5Clambda%20%5Cmathbf%7BI%7D)%20%5Coperatorname%7Bdet%7D(%5Cmathbf%7BS%7D)%20%5C%5C%0A%26%3Dp_%7BA%7D(%5Clambda)%0A%5Cend%7Baligned%7D%0A" /></p><p>一个矩阵的特征值为特征多项式的根。因为两个矩阵有相同的特征多项式，所以它们必有相同的特征值。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>最小二乘的几何含义</title>
    <url>/posts/e4aae57/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我不知道有多少人认为自己对最小二乘法的思想理解不够清晰，其实如果从几何的角度，可以轻松掌握最小二乘的内涵。</p>
<span id="more"></span>
<h1>为什么是最小二乘/最小平方？</h1>
<p>在学习线性回归的过程中，往往一给出模型式子 $y=\beta_{0}+\beta_{1} x_{1}+\beta_{2} x_{2}+\cdots+\beta_{k} x_{k}+\varepsilon $ ，后面就要讲到用最小二乘来估计参数 <img src="https://math.now.sh?inline=%5Cbeta_i" style="display:inline-block;margin: 0;"/>  。但是在讲到最小二乘法的时候，要么就是把最小二乘法视为“显然”的“公理”，不加解释；要么从直观上来说，我们要找一条直线与这些点的距离要足够近，也就是是残差 <img src="https://math.now.sh?inline=y_%7Bi%7D%20-%20%20%5Chat%7By%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 最小，但是由于残差有正有负，因此我们采用残差的平方，需要使得所有残差的平方和最小，然后我当时就产生了一个疑问，那为什么不用残差的绝对值呢？</p>
<p>后来听了吴恩达老师的课，我认识到当代价函数采用平方和的时候，对其求导很简单，因此此时求解比较容易。如果你采用残差的绝对值的形式，绝对值不是处处可导，求解比较麻烦。然后我就产生了一种想法，就是因为绝对值求解不易，所以最小二乘是为了求解方便的一种退而求其次的方法。</p>
<p>最近，从《linear models in statistic》和 《linear algebra with applications》这两本书中，我发现从几何角度去看，最小二乘法其实是一种很自然的估计参数的方法。</p>
<h1>最小二乘的参数估计值</h1>
<p>根据我之前的博客 <a href="https://vincere.fun/posts/55264e6f/">矩阵微分与正规方程组推导</a> ，对于多元线性回归模型 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> 而言，最小二乘估计值满足正规方程组</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20.%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 为一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20%28k%2B1%29" style="display:inline-block;margin: 0;"/> 的矩阵，这里 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 是样本数目，<img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 为特征数目，并且 <img src="https://math.now.sh?inline=k%2B1%20%3C%20n" style="display:inline-block;margin: 0;"/> 。</p>
<p>如果  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵的秩为 <img src="https://math.now.sh?inline=k%2B1" style="display:inline-block;margin: 0;"/> ，那么该方程组存在唯一解</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A" /></p><p>下面我们均假设  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵的秩为 <img src="https://math.now.sh?inline=k%2B1" style="display:inline-block;margin: 0;"/> ，即其为一个列满秩矩阵。</p>
<h1>最小二乘的几何性质</h1>
<p>我们现在完全从最小二乘的几何性质出发去推导这些参数估计值。这部分内容来源于 《linear models in statistic》。</p>
<h2 id="参数空间、数据空间和预测空间">参数空间、数据空间和预测空间</h2>
<p>最小二乘的几何方法首先要从两个高维空间中说起，一个 <img src="https://math.now.sh?inline=%28k%2B1%29" style="display:inline-block;margin: 0;"/> 维的空间，一个 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 维的空间。未知参数向量 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 可以视为 <img src="https://math.now.sh?inline=%28k%2B1%29" style="display:inline-block;margin: 0;"/> 维的空间中的一个点，其坐标轴分别为  <img src="https://math.now.sh?inline=%28k%2B1%29" style="display:inline-block;margin: 0;"/> 个回归系数 <img src="https://math.now.sh?inline=%5Cbeta_%7B0%7D%2C%20%5Cbeta_%7B1%7D%2C%20%5Cbeta_%7B0%7D%2C%20%5Cldots%2C%20%5Cbeta_%7Bk%7D" style="display:inline-block;margin: 0;"/> ，因此我们可以称这个空间为<strong>参数空间</strong> (<em>parameter space</em>) 。相似地，数据向量 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 可以视为在 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 维向量空间中的一个点，其坐标轴分别为 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个观测值，我们称这个空间为<strong>数据空间</strong> (<em>data space</em>) 。</p>
<p>多元线性回归的 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵可以写为下面的形式</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D%3D%5Cleft%28%5Cmathbf%7Bj%7D%2C%20%5Cmathbf%7Bx%7D_%7B1%7D%2C%20%5Cmathbf%7Bx%7D_%7B2%7D%2C%20%5Cmathbf%7Bx%7D_%7B3%7D%2C%20%5Cldots%2C%20%5Cmathbf%7Bx%7D_%7Bk%7D%5Cright%29%0A" /></p><p><img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵的每一列都是 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 维向量，因此每一列都是数据空间中的一个点。因为我们假设 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵的秩为 <img src="https://math.now.sh?inline=k%2B1" style="display:inline-block;margin: 0;"/> ，因此其列向量是线性无关的，<img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵的列向量的线性组合组成了数据空间的一个子空间（易证其符合可加性和齐次性），可以写成</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%20b%7D%3Db_%7B0%7D%20%5Cmathbf%7Bj%7D%2Bb_%7B1%7D%20%5Cmathbf%7Bx%7D_%7B1%7D%2Bb_%7B2%7D%20%5Cmathbf%7Bx%7D_%7B2%7D%2B%5Ccdots%2Bb_%7Bk%7D%20%5Cmathbf%7Bx%7D_%7Bk%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> 是任意一个 <img src="https://math.now.sh?inline=k%2B1" style="display:inline-block;margin: 0;"/> 的向量，因此  <img src="https://math.now.sh?inline=%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> 是参数空间中的一个向量。</p>
<p>我们称<img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵的列向量的线性组合组成的子空间为<strong>预测空间</strong> (<em>prediction space</em>), <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵的列组成了预测空间的一组基。</p>
<p>三个向量空间的可视化见下图</p>
<p><img src="1.png" alt=""></p>
<h2 id="多元线性回归模型的几何解释">多元线性回归模型的几何解释</h2>
<p>多元线性回归认为 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=E%28%5Cmathbf%7By%7D%29%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/>  。我 们的问题是 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D%2C%20%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> 均不知道，我们可以其以几何形式表示为下图</p>
<p><img src="2.png" alt=""></p>
<p>如果我们忽略残差项 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> ，此时 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 一般是一个超定方程组（独立的方程的数目超过了未知数的数目），超定方程组是无解的，也就是说我们一般无法找到一个 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/>  ，使得 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 正好等于  <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>那么，我们估计 <img src="https://math.now.sh?inline=E%28%5Cmathbf%7By%7D%29" style="display:inline-block;margin: 0;"/> 的一个合理的几何思想是从预测空间中找到一个点 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 与 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 距离最近。而两个向量之间的距离我们用范数来定义为</p>
<p style=""><img src="https://math.now.sh?from=%5C%7C%20%5Cmathbf%7By%7D%20-%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%20%5C%7C%0A" /></p><p>如果我们定义残差向量 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Chat%7B%5Cvarepsilon%7D%7D%20%3D%20%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> ，此时也就是需要找到一个 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> ，使得 <img src="https://math.now.sh?inline=%5C%7C%5Cboldsymbol%7B%5Chat%7B%5Cvarepsilon%7D%7D%5C%7C" style="display:inline-block;margin: 0;"/> 最小。最小化 <img src="https://math.now.sh?inline=%5C%7C%5Cboldsymbol%7B%5Chat%7B%5Cvarepsilon%7D%7D%5C%7C" style="display:inline-block;margin: 0;"/> 等价于最小化 <img src="https://math.now.sh?inline=%5C%7C%5Cboldsymbol%7B%5Chat%7B%5Cvarepsilon%7D%7D%5C%7C%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，而  <img src="https://math.now.sh?inline=%5C%7C%5Cboldsymbol%7B%5Chat%7B%5Cvarepsilon%7D%7D%5C%7C%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 就是<strong>残差平方和</strong>，因此此时的几何思想就是最小二乘的思想。</p>
<p>进一步，我们可以发现与 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 距离最近的点， <img src="https://math.now.sh?inline=%5Chat%7B%5Cmathbf%7By%7D%7D" style="display:inline-block;margin: 0;"/>  的一个条件是 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cvarepsilon%7D%7D%3D%5Cmathbf%7By%7D-%5Chat%7B%5Cmathbf%7By%7D%7D" style="display:inline-block;margin: 0;"/> 必须与预测空间（的所有向量）正交，也就是说，  <img src="https://math.now.sh?inline=%5Chat%7B%5Cmathbf%7By%7D%7D" style="display:inline-block;margin: 0;"/>  是  <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/>  在预测空间 <img src="https://math.now.sh?inline=R%28A%29" style="display:inline-block;margin: 0;"/> 的<strong>投影</strong>（可以通过勾股定理来证明）。更进一步，由于预测空间被 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的列张成，因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%28%5Cmathbf%7BXb%7D%29%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cvarepsilon%7D%7D%20%3D%20%5Cmathbf%7Bb%7D%5E%7B%5Cprime%7D%20%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cvarepsilon%7D%7D%20%20%3D%20%5Cmathbf%7B0%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>该式对任意 <img src="https://math.now.sh?inline=%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> 均成立，因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cvarepsilon%7D%7D%3D%5Cmathbf%7B0%7D%0A" /></p><p>即</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%28%5Cmathbf%7By%7D-%5Chat%7B%5Cmathbf%7By%7D%7D%29%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7B0%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A" /></p><p>由于 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 列满秩，因此存在唯一解</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A" /></p><p>这里我们采用了纯粹的几何思想，我们同样得到了正规方程组和最小二乘估计值。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归与R代码实现</title>
    <url>/posts/6cb58071/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>线性回归是最基础的统计模型，也应该是应用最广泛的应用模型。线性回归的因变量必须为连续变量；自变量可以为连续变量，也可以为分类变量（转化为哑变量/虚拟变量）</p>
<p>这里是我通过看资料对线性回归的总结。</p>
<span id="more"></span>
<h1>参考资料</h1>
<p><a href="https://www.statlearning.com/">An Introduction to Statistical Learning</a>，下文简称 <strong>ISL</strong></p>
<h1>线性回归的假设</h1>
<h2 id="1-自变量和因变量线性相关">1 自变量和因变量线性相关</h2>
<p>线性相关的意思是，无论自变量多大，自变量每增加一个单位，因变量都会产生固定的变化。</p>
<h2 id="2-多个自变量之间具有可加性">2 多个自变量之间具有可加性</h2>
<p>无论 X1 多大，X2 每增加一个单位，因变量都会产生固定的变化。如果满足这个条件，说明 X1和X2 之间具有可加性。否则说明 X1 和 X2 之间存在<strong>互作</strong>效应。用图表示如下（左图两条线平行说明不存在互作，右图不平行说明存在互作）：</p>
<p><img src="12.png" alt="1"></p>
<h2 id="3-多个自变量之间彼此独立">3 多个自变量之间彼此独立</h2>
<p>多个自变量之间不能存在<strong>相关</strong>关系。相关关系分为两种，一种是简单的两两之间的相关，这个通过相关系数矩阵就能看出来是否存在两个变量之间的明显的相关（看绝对值）；第二种是多重线性相关（Multicollinearity），例如 X1 = a + bX2 + cX3，一个自变量可以用其他的多个自变量来解释，就说明存在多重线性相关。</p>
<h2 id="4-观测值的误差项之间互相独立">4 观测值的误差项之间互相独立</h2>
<p>误差项即实际值 - 预测值。如果观测值之间存在我们没有添加到模型中的其他影响因素，那么误差项之间就可能存在相关关系，比如有些样本搜集自同一个家庭的成员，而我们没有把家庭这个因素加入到模型中。</p>
<h2 id="5-误差项（ε）呈正态分布，期望为0，方差为定值">5 误差项（ε）呈正态分布，期望为0，方差为定值</h2>
<blockquote>
<p>这里其实分为两个假设。第一个假设：误差项服从均值为0的正态分布。第二个假设：误差项的方差为定值（不变）。这两个假设是为了保证回归模型在小样本下能够顺利进行假设检验。正态分布假设仅在小样本的情况下需要，大样本的情况下则不需要，因为有中心极限定理做正态性的支撑。而方差齐性则保证最小二乘法估计出来的统计量具有最小的方差。如果违反了这个假设，置信区间会变宽，这称之为<strong>异方差性（heteroscedasticity）</strong>。当异方差性出现的时候，如果仍采用最小二乘法估计参数，会导致参数的t检验值被高估，可能造成本来不显著的某些参数变为显著，使假设检验失去意义。</p>
<p><a href="https://www.cnblogs.com/HuZihu/p/10142737.html">https://www.cnblogs.com/HuZihu/p/10142737.html</a></p>
</blockquote>
<h2 id="6-自变量和误差项之间互相独立">6 自变量和误差项之间互相独立</h2>
<blockquote>
<p>模型中一个或多个自变量与随机误差项存在相关关系，这称之为<strong>内生性（endogeneity）</strong>。内生性通常由于遗漏变量而导致的，因此是一个普遍存在的问题。内生性会导致模型参数估计不准确。</p>
<p><a href="https://www.cnblogs.com/HuZihu/p/10142737.html">https://www.cnblogs.com/HuZihu/p/10142737.html</a></p>
</blockquote>
<h1>简单线性回归</h1>
<h2 id="β0-β1-参数估计-最小二乘法">β0, β1 参数估计 - 最小二乘法</h2>
<p>最小二乘的思路是，查找使得<strong>误差平方和</strong>或<strong>均方误差</strong>最小的参数。</p>
<p>我们首先知道，<strong>误差 = 实际值 - 预测值</strong>，我们的目的实际是想要所有观察值的总体的误差最小，因为误差有正有负，如果采用误差项直接相加会互相抵消，因为我们采用误差的平方进行相加，得到误差平方和 (<abbr title="residual sum of squares">RSS</abbr>)。</p>
<p><img src="1.png" alt="1"></p>
<p>或者写成</p>
<p><img src="2.png" alt="1"></p>
<p>除以总共的样本数 n，便得到<abbr title="mean square error, MSE"><strong>均方误差</strong></abbr>，使得 RSS/MSE 最小的参数便是最小二乘的最优解。写成公式如下（缺推导过程）：</p>
<p><img src="3.png" alt="1"></p>
<p>画成等高图如下（作图横纵坐标为β0和β1，图中一圈表示相同的RSS，数字即为 RSS 大小），我们可以看到这是向下凹的图形，只有一个点RSS 最小。</p>
<p><img src="4.png" alt="1"></p>
<h3 id="为什么不用残差的绝对值？">为什么不用残差的绝对值？</h3>
<p>我上统计课的时候就有这个问题，就一直有这个疑问，如果因为残差有方向，不能直接求和，那为什么不直接用绝对值呢？这不是更直接的更贴近残差本质的思路吗？</p>
<p>使用残差绝对值作为代价函数，在统计的历史上是存在的，称为<strong>最小一乘法</strong>。查看了很多网页的回答，感觉这个回答比较全 <a href="https://zhuanlan.zhihu.com/p/104391088">为什么是“最小二乘”而不是“最小一乘”？</a></p>
<h4 id="最小一乘法的解不一定唯一">最小一乘法的解不一定唯一</h4>
<p>举个简单的例子，根据下图中的四个点，可以构建出无数条回归直线，只要这些直线同时与 AB, CD 相交即可。</p>
<p><img src="29.png" alt="1"></p>
<h4 id="最小二乘求解方便">最小二乘求解方便</h4>
<p>后来上了吴恩达老师的机器学习课，知道了代价函数的概念，寻找代价函数最小值的最简单的方法就是<strong>求导</strong>。最小二乘法的代价函数就是 RSS/MSE，由于这里采用平方和（二次函数），<strong>求导会直接变成一次函数</strong>。而如果使用残差的绝对值的和，根本无法进行简单的求导，就无法简单地得到最优解的公式（而且绝对值在 x = 0 处不可导）。</p>
<h4 id="最小二乘估计结果与正态分布假设下的最大似然估计结果相同">最小二乘估计结果与正态分布假设下的最大似然估计结果相同</h4>
<p>可以证明，当误差服从正态分布时，最大似然法估计结果和最小二乘相同（注意最小二乘与最大似然是截然不同的两种思想，两种方法。最小二乘没有对观测值的分布做假设）。下方证明参考<a href="https://rayleizhu.github.io/2018/12/16/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%B9%B3%E6%96%B9%E8%AF%AF%E5%B7%AE/">最小二乘法为什么使用平方误差</a> 。</p>
<p>当你用线性回归拟合数据时，其实模型包括了两部分，回归项和残差项：</p>
<p style=""><img src="https://math.now.sh?from=y_%7Bi%7D%3Dw%5E%7BT%7D%20x_%7Bi%7D%2B%5Cepsilon_%7Bi%7D%0A" /></p><p>之后我们用<strong>最大似然方法</strong>来估计参数，假设样本数目为n，似然函数表达式如下 (给定一组参数下得到这些观测值的似然值，等于得到这些残差的似然值)：</p>
<p style=""><img src="https://math.now.sh?from=p%28y%20%5Cmid%20w%2C%20b%29%3D%5Cprod_%7Bi%3D1%7D%5E%7Bn%7D%20p%5Cleft(y_%7Bi%7D%20%5Cmid%20w%2C%20b%5Cright)%3D%5Cprod_%7Bi%3D1%7D%5E%7Bn%7D%20p%5Cleft(%5Cepsilon_%7Bi%7D%3Dy_%7Bi%7D-%5Cleft(w%5E%7BT%7D%20x_%7Bi%7D%2Bb%5Cright)%5Cright)%0A" /></p><p>我们需要找到使得似然函数最大的一组参数。</p>
<p>假设残差独立同分布于正态分布 N(0, σ<sup>2</sup>) ，单个残差的概率密度函数如下：</p>
<p style=""><img src="https://math.now.sh?from=f%28%5Cepsilon_i%20%3D%20y_i%20-%20(w%5ETx_i%20%2B%20b%29)%20%3D%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%5Cpi%7D%20%5Csigma%7D%20exp(-%5Cfrac%7B%5Cepsilon_i%5E2%7D%7B2%5Csigma%20%5E%202%7D)%0A" /></p><p>多个残差服从多元正态分布，联合概率密度函数如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Af%28%5Cvarepsilon%29%20%26%3D%5Cprod_%7Bi%3D1%7D%5E%7Bn%7D%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%7D%20%5Csigma%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B%5Cvarepsilon_%7Bi%7D%5E%7B2%7D%7D%7B2%20%5Csigma%5E%7B2%7D%7D%5Cright)%20%5C%5C%0A%26%3D%5Cleft(%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%7D%5Csigma%7D%5Cright)%5E%7Bn%7D%20%5Cexp%20%5Cleft(-%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cfrac%7B%5Cvarepsilon_%7Bi%7D%5E%7B2%7D%7D%7B2%20%5Csigma%5E%7B2%7D%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>因此这个问题就转换成了求使得**联合概率密度函数<code>f(ε)</code>最大 **的一组参数，这组参数就是最大似然法的估计参数。仔细查看 **联合概率密度函数<code>f(ε)</code> **的式子，不难发现该式最大时，即误差平方和最小。</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Cepsilon_%7Bi%7D%5E%7B2%7D%0A" /></p><p>因此当<strong>残差符合正态分布</strong>时，最小二乘法的参数估计值与最大似然法一致，最小二乘法的参数估计值就是最可能的参数估计值。</p>
<h3 id="为什么不用三次方，平方和？">为什么不用三次方，平方和？</h3>
<p>为什么最小二乘法要用最小误差平方和来拟合（为什么不用立方和，或者开方和）?  首先你要保证误差项永远是正数，因此三次方和其他奇数次方不成立。对于四次项及更高的偶数次项，效果还没有最小二乘好，因为会<strong>放大极端值的影响</strong>。开方更不可能了，因为残差可能是负数，无法求开方。</p>
<h2 id="参数估计准确性">参数估计准确性</h2>
<p>我们使用的模型为</p>
<p><img src="5.png" alt="1"></p>
<p>这里的<strong>残差项包含了所有我们模型中没有考虑到的地方</strong>，比如Y 和 X 的关系不是线性的，还有其他的影响因素，存在测量误差等等。</p>
<p>为了估计参数的估计值与真实值之间的误差，我们需要计算两个参数估计值的标准误，使用下列公式（缺证明）</p>
<p><img src="6.png" alt="1"></p>
<p>这里 σ2 是残差方差，是未知的。残差标准差 σ 可以用 RSE (residual standard error) 来估计（缺证明）。</p>
<p><img src="7.png" alt="1"></p>
<p>知道了标准误，我们可以计算<strong>β0、β1的置信区间</strong>，例如 β1 的 95%的置信区间为：</p>
<p><img src="8.png" alt="1"></p>
<p>如果  β1 的 95%的置信区间 <strong>包含 0</strong>，那说明不能拒绝  β1  = 0 的原假设，我们认为不存在线性相关。</p>
<p>我们也可以通过 t 检验得到 P值。构建 t 统计量如下（自由度 n-2）：</p>
<p><img src="9.png" alt="1"></p>
<p>同理可以检验β0 估计值的P值（零假设：β0 = 0），但实际上截距的显著性没啥大的意义，主要还是看 β1。如果  β1 的 P值小于 0.05，我们认为  β1 ≠ 0。</p>
<h2 id="模型准确性">模型准确性</h2>
<p>上面是得到估计的两个参数的准确性，这里我们想知道，我们构建的简单线性模型与数据的契合程度（<em>which the model fits the data</em>）。</p>
<p>线性模型一般用两个指标， <em>residual standard error</em>(RSE) 和 R<sup>2</sup> 。</p>
<h3 id="RSE">RSE</h3>
<p><img src="7.png" alt="1"></p>
<p>RSE 是<strong>残差的标准误的估计值</strong>，它表示<strong>预测值与真实值的平均偏差量</strong>（这句话需要理解标准误的概念：标准误是样本统计量的标准差，均值为真值，结合标准差的公式，可知标准误就是预测值与真实值的平均偏差量（绝对值），所以一般提供参数估计值的时候，都会写成 参数估计值±<strong>标准误</strong>的形式）。</p>
<p>RSE 是最直接说明模型准确性的统计量，它的缺点是有单位，是一个绝对值，仅仅是RSE你不知道到底是大还是小，所以你还得和因变量的均值啥的进行比较才知道相对大小。</p>
<h3 id="R-sup-2-sup">R<sup>2</sup></h3>
<p>R<sup>2</sup> 指的是因变量方差能够被线性模型解释的比例，始终在0和1之间，是一个相对值，越大越好。公式如下：</p>
<p><img src="10.png" alt="1"></p>
<p>其中<abbr title="total sum of squares">TSS</abbr> 计算如下，表示因变量的总的方差。</p>
<p><img src="11.png" alt="1"></p>
<p>R<sup>2</sup> 比 RSE 更容易解释，因此更常用，但是还是面临一个问题，<strong>R<sup>2</sup> 多大才算结果很好呢？<strong>这可能得根据实际情况来定，在我们一般的实验中，实际上往往还有很多</strong>未测量的影响因素</strong>，所以 RSS 可能比较大，这时可能 R<sup>2</sup> 哪怕比较小可能也说明有用。</p>
<h1>多重线性回归</h1>
<p>简单线性回归只有一个自变量，但在实际情况中，我们往往有多个自变量（即生活中其实几乎不存在简单线性回归的应用场景）。例如，如果我们有三个影响因素，我们如何同时分析这三个影响因素呢？</p>
<p>一种思路是我们分别做上次简单的线性回归，但是这种思路无法令人满意。首先，如果给定一组三个自变量的值，我们无法给出因变量的预测值；其次，每一次简单回归都忽视了其他两个影响因素的作用，这可能会带来严重的误判。更好的解决思路是同时将多个自变量均放到线性回归的模型中。</p>
<p>ISL 书中提到了一个例子，销量和三种媒体预算的回归分析。在简单线性回归下，报纸的作用是显著的，如下图。</p>
<p><img src="13.png" alt="1"></p>
<p>但是，同时考虑三种媒体后，报纸的P值是不显著的。这说明简单线性回归和多重线性回归的结果是不一样的。这种差距的出现的原因是，简单回归得到的<strong>斜率</strong>是不考虑其他因素（TV 和 radio）下得到的，而多重回归得到的<strong>斜率</strong>是<strong>保持 TV 和 radio 固定不变</strong>的基础上计算得到的。</p>
<p><img src="14.png" alt="1"></p>
<p>这种情况说明了什么呢，说明这三个自变量之间并不是互相独立的，通过下面的相关矩阵我们可以看到，radio 和 newspaper 的相关系数为0.35，表示当投资人在 radio advertising 花更多的钱的同时，存在一种趋势在 newspaper advertising 上也花更多的钱。因此，我们对 newspaper 进行简单回归时得到的显著性，<strong>实际不是 newspaper 的作用，而是 radio 因素的作用</strong>。</p>
<p>这样的例子实际上比比皆是。ISL 提了一个离谱的例子来说明这一点。如果我们计算<strong>沙滩冰淇淋销量</strong>对<strong>鲨鱼伤人事件的数量</strong>求回归，我们应该能得到一个正向的关系，类似于上面的 newpaper 的例子。但是这实际是很荒谬的，这两个事件不存在因果关系，<strong>你无法通过禁止销售冰淇淋来减少鲨鱼伤人的事件</strong>。实际上是高温天气促使了人们去海边，从而导致更多的冰淇淋销量和鲨鱼伤人事件。<strong>如果你同时考虑冰淇淋销量和天气，对鲨鱼伤人事件做多重回归，你就会发现冰淇淋销量不再是一个显著的影响因素</strong>。</p>
<h2 id="决定重要的影响因素">决定重要的影响因素</h2>
<p>当我们有多个影响因素时，很有可能所有的影响因素都和因变量是有联系的，但是因变量可能仅仅是由其中的一小部分自变量决定的（相关不等于因果，比如上面的冰淇淋销量的例子）。我们把如何挑选自变量的过程称为 <em>variable selection</em>。</p>
<p>理想情况下，我们可以通过<strong>穷举</strong>所有的模型，每种模型均包含一部分的自变量。通过对比所有模型的表现，我们就可以得到最佳的自变量的集合。例如假如我们手上总共有2个可选的自变量X1 X2，那么总共就有4种可能的模型，（1）不包含任何自变量 ；（2）包含X1 ；（3）包含X2；（4）包含X1和X2。但是我们用什么指标来判断不同模型的优劣呢？<strong>这里有很多的判定模型优劣的统计量，比如<abbr title="Akaike information criterion">AIC</abbr>， <abbr title="Bayesian information criterion">BIC</abbr>  , 校正后R<sup>2</sup> 等。</strong></p>
<h3 id="为什么使用校正后的R-sup-2-sup">为什么使用校正后的R<sup>2</sup></h3>
<p>我们看R<sup>2</sup> 的计算公式，可以看到 TSS 是固定值。如果你增加了变量后（比如原来只包含X1，到包含X1和X2），<strong>残差平方和只会减少</strong>（这就是overfitting的原理，哪怕仅仅是增加了无关变量，也会造成与本次数据的拟合程度“变好”）。这导致增加了变量后，R<sup>2</sup>只会进一步增加。</p>
<p><img src="10.png" alt="1"></p>
<p>校正后的R<sup>2</sup>的公式如下，考虑了自变量个数的影响。可以看到，校正后的R<sup>2</sup> 随着自变量个数的增加而降低，并且始终低于未校正的R<sup>2</sup>。</p>
<p><img src="15.png" alt="1"></p>
<p>ISL 还提到了了使用 RSE 来校正自变量个数的影响。</p>
<p><img src="7.png" alt="1"></p>
<h3 id="三种经典的挑选变量的思路">三种经典的挑选变量的思路</h3>
<ul>
<li><em>Forward selection</em>:  先从<em>null model</em> (没有任何变量的模型)出发，对所有的候选因素（假设 <em>p</em> 个）各做一次简单回归，然后挑选结果中 RSS 最低的变量加入到模型中。然后我们将剩下的 <em>p</em>-1 个候选因素，挨个加入到目前的模型中，再挑选结果中 RSS 最低的变量加入到模型中。一直循环下去，知道达到了某个终止条件。</li>
<li><em>Backward selection</em>:  首先将所有的变量均加入到模型中，然后移除其中 P值最大的变量，我们就得到了一个 <em>p</em>-1个变量的模型。循环往复直到达到终止条件（比如所有剩下的变量的P值均低于某个值）。</li>
<li><em>Mixed selection</em>: 结合了上述的两个方法，我们先从空的模型出发，就像第一种方法的示例，不停地往里加变量，直到最佳。在加变量的过程中，我们观察有没有变量的P值变大并且超出了我们设定的阈值，如果存在这种现象，我们就从模型中移除这个变量（backward）。我们一直重复这种添加变量和删除变量的操作，直到最终实现<strong>所有剩下的变量的P值均很低，所有剔除的变量只要加入到模型中就会有一个很大的P值</strong>。</li>
</ul>
<p>如果变量的个数超过了记录数，那么我们无法用 <em>Backward selection</em> (因为将所有变量均加入到模型中，会发生<a href="https://zh.wikipedia.org/wiki/%E7%BB%B4%E6%95%B0%E7%81%BE%E9%9A%BE">维数灾难</a>)，此时 <em>Forward selection</em> 是可用的。但是<strong><em>Forward selection</em> 是一种贪婪算法</strong>，早期加入的变量可能是多余的，而  <em>Mixed selection</em> 算法修正了这一点。</p>
<h2 id="变量之间是否存在互作">变量之间是否存在互作</h2>
<p>还是采用上面三种媒介的例子，我们已经确定了 newpaper 没有作用， TV  和 radio 对 sales 有作用，那是不是模型就是下面的形式呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Y &#x3D; β0 + β1*TV + β2*radio + e</span><br></pre></td></tr></table></figure>
<p>我们可以通过这个模型画出一个三维图，图中的平面为预测值。我们可以看到当主要的钱都投向一种媒体时，销量会低于预测值；而如果我们均衡投资这两种媒体，销量会高于预测值（虽然我没有很好的看懂这个三维图）。这说明<strong>TV 和 radio 这两个因素之间存在互作。</strong></p>
<p><img src="16.png" alt="1"></p>
<h2 id="预测的不确定性">预测的不确定性</h2>
<p>一旦我们得到了最终的多重线性回归模型，我们就可以基于一套自变量的值来预测反应变量的值。但是，我们所做的预测至少存在三种不确定性。</p>
<ol>
<li>
<p>我们得到的仅仅是 β0, β1, β2……等参数的估计值。这些参数的估计值与真实值存在差距，这种差距是<strong>可消除误差(<em>reducible error</em>)</strong> 的一种。我们统计计算一个 <em><strong>confidence interval</strong></em> 来决定估计参数得到的预测值与真实参数得到的预测值的差距。</p>
</li>
<li>
<p>第二种不确定性是由于线性模型仅仅是对实际数据的一个近似，这种带来的错误我们称之为<em><strong>model bias</strong></em> 。</p>
</li>
<li>
<p>即使我们知道真实的模型 f(x)（我们知道所有参数的真实值），我们也不能完全精确地预测因变量，因为还存在<strong>随机误差(<em>random error</em>)</strong>，这种属于<strong>不可消除误差(<em>irreducible error</em>)</strong>。真实模型的预测值与真实值之间的差距，用<em><strong>prediction intervals</strong></em> 来评价。<em>prediction intervals</em> 通常比 <em>confidence intervals</em> 更宽， 因为 <em>prediction intervals</em> 不仅包括了可消除误差，也包含了不可预测误差（ <em>prediction intervals</em> 包含了 <em>confidence interval</em> ）。下面这段话解释地更明确一点：</p>
<p><img src="27.png" alt="1"></p>
</li>
</ol>
<h1>线性回归潜在的问题</h1>
<h2 id="1-自变量与因变量之间为非线性关系">1 自变量与因变量之间为非线性关系</h2>
<p>线性回归假设因变量与自变量之间存在直接的线性关系。如果因变量与自变量之间不是线性关系，那么线性回归的准确性会显著降低。</p>
<p>我们一般通过<strong>残差图</strong>来确定非线性关系。如果是简单线性回归，横坐标可以是自变量X，纵坐标是残差e；但是如果是多重线性回归，由于存在多个自变量，横坐标改为因变量的预测值。</p>
<p>下边左图为简单线性回归的残差图，可以看到残差不是均匀地分布在均值为0这条线地上下两侧，说明存在非线性关系。右图通过<strong>多项式回归</strong>，残差图的结果变好了很多，虽然看上去还是有一点非随机分布。</p>
<p><img src="17.png" alt="1"></p>
<h2 id="2-残差项的相关">2 残差项的相关</h2>
<p>线性回归的一个重要的假设是残差项，e<sub>1</sub>,e<sub>2</sub>,e<sub>3</sub>…… e<sub>n</sub> 之间是不相关的。这句话的含义是，如果残差项是不相关的，那么某一个残差项的值不受其他残差项的影响。ISL 原文如下：</p>
<blockquote>
<p>For instance, if the errors are uncorrelated, then the fact that ε<sub>i</sub> is positive provides little or no information about the sign of ε<sub>i+1</sub>.</p>
</blockquote>
<p>预测参数或预测值的<strong>标准误</strong>都是基于残差不相关的假设计算得到的。<strong>如果实际上残差项之间存在相关，那么标准误倾向于被低估</strong>（缺解释），因此置信区间也会比正常情况下更窄，因此 p值会更低，容易出现<strong>假阳性</strong>。</p>
<p>下面这段话举了个例子，但是我没理解。这里假如我们不小心把数据重复了一遍（本来是n条数据，现在是2n条数据），参数估计的置信区间会缩减 √2 。</p>
<p><img src="18.png" alt="1"></p>
<p>**什么时候会出现残差项的相关？**这种情况频繁出现在 <em>time series</em> 数据，也有在不同的时间点去观测得到的数据。在很多情况下，相邻时间观测到的记录之间会有正相关的残差项。为了确定这种情况，我们可以画一个横坐标是时间的残差图，如果残差项之间是不相关的，你就不会观测到明显的模式（残差应该是忽上忽下）；相反，如果残差项之间是正相反的，你可以会发现相邻时间的残差会倾向于有相似的值。</p>
<p>下图就体现了这一点，最上面是没有残差相关的图，越往下残差相关越高，我们可以看到很清晰的模式 - 相邻的点之间倾向于有相似的值。</p>
<p><img src="19.png" alt="1"></p>
<p>除了  <em>time series</em> 数据以外，其他数据也可能出现残差相关。举个例子，假设我们有一个研究通过体重去预测一个人的身高。如果有一些研究个体来自于相同的家庭，或吃相同的饮食，又或者面临某些相同的环境因素，那么残差不相关的假设就可能被打破。</p>
<p>一般来说，<strong>残差不相关</strong>的假设对于线性回归和其他统计方法是非常重要的。<strong>良好的实验设计</strong>对于减少残差不相关的风险至关重要。</p>
<h3 id="为什么会出现残差相关？">为什么会出现残差相关？</h3>
<p>因为<strong>残差是个筐，啥都往里装</strong>。我们的模型中所有没有考虑到的影响因素都会包含在这个残差里。实际上我们的模型不可能包含所有的影响因素，我们也不可能收集到所有影响因素的数据，所以我感觉残差相关是不可能完全避免的，或多或少有一点，只要不是很严重。</p>
<p>所以<strong>实验设计</strong>很重要，你要事先把重要的影响因素考虑到，而且把这些数据收集到。如果没有收集到相应的数据，貌似都无法发现残差相关，比如上面的 <em>time series</em> 数据，如果你没有搜集每个数据的时间信息，你都没法画上面的残差图。你不知道就等于没有了。</p>
<h2 id="3-残差方差不齐性">3 残差方差不齐性</h2>
<p>线性回归的另一个重要的假设是所有残差项均有一个固定的方差。我们计算标准误、置信区间等都依赖于这个假设。</p>
<p>但不幸地是，残差项的方差不是固定的，才是通常的情况。比如，残差方差可能会随着因变量值的提高而提高。我们可以通过残差图来发现这一点，比如下图的左图。<strong>当面临这种情况时，一个可能的解决思路是将反应变量Y 转换为 log(Y)  或 √Y</strong> ，这两个函数对于较大的值都会有一个很好的收缩效应，从而导致方差不齐性的改善。下图的右图就展示了转换后的残差图，我们可以看到方差不齐性的结果大大改善了（残差的宽度都差不多了），但是存在轻微的非线性关系。</p>
<p><img src="20.png" alt="1"></p>
<h2 id="4-Outliers">4 Outliers</h2>
<p><strong>Outliers 的定义是这个点的真实值与预测值偏差很大</strong>。Outliers 出现的原因有很多，比如错误记录。</p>
<p>下图中的红点（观测值为20）就是一个典型的Outlier。左边图中的红线是包含了Outlier的回归线，蓝色虚线是剔除了Outlier的回归线，我们可以看到移除或不移除这个Outlier对参数估计的影响很小。</p>
<p>但是Outliers 还会造成另外的问题。比如，在这个例子中，如果包括Outlier 计算得到的 RSE 为 1.09 ，如果剔除Outlier 得到的 RSE 为 0.77 。因为 RSE 在计算置信区间和 p值时均会用到，这样因为一个点导致RSE剧增会影响到回归方差拟合效果的解释。相似地，加入这个 Outlier， R<sup>2</sup> 从 0.892 降低到 0.805。</p>
<p>我们可以通过残差图来找到Outlier。在本例中我们轻松地找到这个Outlier，但是在实际应用中，我们很难决定到底偏离多少才可以视为一个 Outlier。为了解决这个问题，我们可以画图<em><strong>studentized residuals</strong></em> 图，纵坐标时残差除以它的标准误估计值。如果学生残差超过3，我们一般就认为可能是Outlier。在下图的右图中，我们发现这个Outlier的学生残差超过了6，而其他点均在 -2 与 2 之间。</p>
<p>如果你相信Outlier的出现是由于<strong>数据记录或收集时出错</strong>，那么解决办法就是移除这个观测值。但是你需要担心，Outlier的出现也可能是说明你的<strong>模型不完善</strong>，比如缺了一个影响因子。</p>
<p><img src="21.png" alt="1"></p>
<h2 id="5-High-Leverage-Points">5 High Leverage Points</h2>
<p><em><strong>High Leverage Points</strong></em> 仅指<strong>拥有异常的 x<sub>i</sub> 的观测值</strong>。例如，下图中的观测值 41 就是一个 <em>High Leverage Point</em>。 左图中的红线为包含这个点的回归直线，蓝色虚线是剔除了这个点的回归直线。我们可以看到， <em>High Leverage Point</em> 的影响很大，因此找 <em>High Leverage Point</em> 很重要。</p>
<p>对于简单线性回归， <em>High Leverage Point</em> 很容易找到，我们可以直接从 X-Y 图中直接看出。但是多重线性回归存在多个因变量，有可能一个观测值的<strong>所有的自变量单独看都在合理的范围</strong>，但是<strong>这一组自变量的组合是异常的</strong>。下图中间的图就显示了这一点，这是一个有两个自变量(X1, X2)的回归。很多观测值的两个自变量均落在蓝色虚线框定的椭圆中，但是这个红色的点不在这个范围内，虽然这个点的 X1 和 X2 值单独看都不是异常的值。**因此对于多重回归，如果仅仅看单个自变量是否存在 <em>High Leverage Point</em>，我们可能会漏掉一些 <em>High Leverage Point</em>。 ** 但是对于超过2个变量的多重回归模型，如果能够同时查看多个自变量组合的 <em>High Leverage Point</em>  就是一个问题，因为你没法针对2维以上的变量进行画图。</p>
<p><img src="22.png" alt="1"></p>
<p>为了确定一个观测值的 leverage，我们可以计算一个 <em>leverage statistic</em> 。这个值越大说明 leverage 程度越高。对于一个简单线性回归，公式如下（多重回归的公式未给）：</p>
<p><img src="23.png" alt="1"></p>
<p>这个统计量的值在 1/n 与 1 之间，而且所有的观测值的  <em>leverage statistic</em> 的均值是 (p+1)/n 。所以如果一个观测值的  <em>leverage statistic</em> 远超均值，我们就可以怀疑这是一个  <em>High Leverage Point</em></p>
<p>上图 3.13 中的右图是 学生残差 vs h<sub>i</sub>  的散点图。观测值41 的 h<sub>i</sub> 和 学生残差均特别高，说明**这个点即是   <em>High Leverage Point</em>  ，也是一个 outlier ** 。这种情况是非常危险的组合，会对回归结果造成很大的影响，相比之下观测值20 虽然是一个 outlier, 但是 leverage 很低，最起码对回归方程没什么影响。</p>
<h2 id="6-Collinearity">6  Collinearity</h2>
<p><em>Collinearity</em> 表示<strong>两个或更多个自变量之间具有紧密的相关关系</strong>。<em>Collinearity</em> 可以用下图来表示，左图中的两个变量之间表现出来没有明显的关系，而右图的两个变量之间存在<strong>高度</strong>的相关关系（我不知道这个等高图为什么可以这么解释）。</p>
<p><img src="24.png" alt="1"></p>
<p><em>Collinearity</em> 的影响在于无非区分开多个自变量对因变量的影响程度。比如右图中，RSS最低的（β<sub>Limit</sub> , β<sub>Rating</sub>）有很多个，他们在一个狭长的椭圆当中，这导致了参数估计的不确定性。</p>
<p><em>Collinearity</em> 会降低回归参数估计的准确性，导致斜率估计的标准误增加，因此 P 值会增加，会导致 power（正确地拒绝原假设的概率） 降低。下图就是两次回归得到的回归系数和 P值，我们可以看到由于存在 <em>Collinearity</em> ，导致 limit 因素第二次分析时变得不显著。</p>
<p><img src="25.png" alt="1"></p>
<p>因此<strong>我们需要在进行回归分析前进行 <em>Collinearity</em> 的检测</strong>。一个简单的思路是看<strong>自变量之间的相关矩阵</strong>，看是否存在相关系数很高的情况。但是有可能存在一种情况，就是自变量之间不存在两两之间的强相关，但是存在三个及以上的变量之间的相关（例如 X1 = a + bX2 + cX3）。我们把这种情况称为 <em><strong>multicollinearity</strong></em> 。因此我们不采用自变量的相关矩阵，我们引入了一个新的统计量来检测 <em>Collinearity</em>，就是 <abbr title="variance inflation factor">VIF</abbr> 。定义如下：</p>
<blockquote>
<p>The VIF is  the ratio of the variance of ˆβ<sub>j</sub> when fitting the full model divided by the variance of ˆβ<sub>j</sub> if fit on its own.</p>
</blockquote>
<p>VIF 的最小值为1， 说明完全没有<em>Collinearity</em> ，一般来说自变量之间存在一定的 <em>Collinearity</em> , 一般我们认为 VIF 超过 5 或 10 就说明存在严重的 <em>Collinearity</em> 。对于每个变量的 VIF 计算公式为</p>
<p><img src="26.png" alt="1"></p>
<p>在上面的例子中，对 age, rating  和 limit 这三个变量做 VIF 分析，计算结果分别为 1.01， 160.67 和 160.59 。</p>
<p>如果面临 <em>Collinearity</em>  的问题，有两个简单的思路：<strong>一是删除其中一个变量</strong>，这通常不会导致模型拟合程度的降低，因为变量之间的信息是冗余的；<strong>二是合并共显性的变量为一个变量</strong>。</p>
<h1>R代码实现</h1>
<h2 id="简单线性回归">简单线性回归</h2>
<p>回归分析</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简单回归</span></span><br><span class="line">library(MASS)</span><br><span class="line">library(ISLR)</span><br><span class="line"><span class="comment">## 采用MASS包的Boston数据集</span></span><br><span class="line">lm.fit = lm(medv~lstat, data = Boston)</span><br><span class="line">summary(lm.fit) <span class="comment">#各种回归的信息</span></span><br></pre></td></tr></table></figure>
<p>回归分析结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Call:</span><br><span class="line">lm(formula &#x3D; medv ~ lstat, data &#x3D; Boston)</span><br><span class="line"></span><br><span class="line">Residuals:</span><br><span class="line">    Min      1Q  Median      3Q     Max </span><br><span class="line">-15.168  -3.990  -1.318   2.034  24.500 </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">            Estimate Std. Error t value Pr(&gt;|t|)    </span><br><span class="line">(Intercept) 34.55384    0.56263   61.41   &lt;2e-16 ***</span><br><span class="line">lstat       -0.95005    0.03873  -24.53   &lt;2e-16 ***</span><br><span class="line">---</span><br><span class="line">Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1</span><br><span class="line"></span><br><span class="line">Residual standard error: 6.216 on 504 degrees of freedom</span><br><span class="line">Multiple R-squared:  0.5441,	Adjusted R-squared:  0.5432 </span><br><span class="line">F-statistic: 601.6 on 1 and 504 DF,  p-value: &lt; 2.2e-16</span><br></pre></td></tr></table></figure>
<p>只看系数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; coef(lm.fit)</span><br><span class="line">(Intercept)       lstat </span><br><span class="line"> <span class="number">34.5538409</span>  -<span class="number">0.9500494</span> </span><br></pre></td></tr></table></figure>
<p>查看系数的置信区间（confidence interval ）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; confint(lm.fit)</span><br><span class="line">                <span class="number">2.5</span> %     97.5 %</span><br><span class="line">(Intercept) <span class="number">33.448457</span> <span class="number">35.6592247</span></span><br><span class="line">lstat       -<span class="number">1.026148</span> -<span class="number">0.8739505</span></span><br></pre></td></tr></table></figure>
<p>画 x-y 散点图，并添加回归线</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot(Boston$lstat, Boston$medv)</span><br><span class="line">abline(lm.fit)</span><br></pre></td></tr></table></figure>
<p>我们可以查看检查线性回归是否正常的图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">par(mfrow&#x3D;c(2,2))</span><br><span class="line">plot(lm.fit) # 直接画4副图</span><br></pre></td></tr></table></figure>
<p>绘图如下：上方左图就是正常的残差图，可以查看<strong>非线性</strong>，<strong>残差异方差</strong>等，我们可以看到这里存在非线性关系；上方右图就是QQ图，用于<strong>检验残差是否符合正态分布</strong>；下方左图也是一个残差图，不过就是把纵坐标改成了 <em><strong>standardized residuals</strong></em>（缺公式）；下方右图用于判断 <em>Outlier</em> 和  <em>High Leverage Point</em>  ，横坐标是 leverage， 通常大于 4/n (n 是样本点的数目)，就算 <em>High Leverage Point</em> ； 纵轴是residuals，通常小样本大于2，大样本大于4的算作outliers 。</p>
<p><img src="28.png" alt="1"></p>
<h2 id="多重线性回归">多重线性回归</h2>
<p>看一下数据结构</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; str(Boston)</span><br><span class="line"><span class="string">&#x27;data.frame&#x27;</span>:	<span class="number">506</span> obs. of  <span class="number">14</span> variables:</span><br><span class="line"> $ crim   : num  <span class="number">0.00632</span> <span class="number">0.02731</span> <span class="number">0.02729</span> <span class="number">0.03237</span> <span class="number">0.06905</span> ...</span><br><span class="line"> $ zn     : num  <span class="number">18</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">12.5</span> <span class="number">12.5</span> <span class="number">12.5</span> <span class="number">12.5</span> ...</span><br><span class="line"> $ indus  : num  <span class="number">2.31</span> <span class="number">7.07</span> <span class="number">7.07</span> <span class="number">2.18</span> <span class="number">2.18</span> <span class="number">2.18</span> <span class="number">7.87</span> <span class="number">7.87</span> <span class="number">7.87</span> <span class="number">7.87</span> ...</span><br><span class="line"> $ chas   : int  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> ...</span><br><span class="line"> $ nox    : num  <span class="number">0.538</span> <span class="number">0.469</span> <span class="number">0.469</span> <span class="number">0.458</span> <span class="number">0.458</span> <span class="number">0.458</span> <span class="number">0.524</span> <span class="number">0.524</span> <span class="number">0.524</span> <span class="number">0.524</span> ...</span><br><span class="line"> $ rm     : num  <span class="number">6.58</span> <span class="number">6.42</span> <span class="number">7.18</span> <span class="number">7</span> <span class="number">7.15</span> ...</span><br><span class="line"> $ age    : num  <span class="number">65.2</span> <span class="number">78.9</span> <span class="number">61.1</span> <span class="number">45.8</span> <span class="number">54.2</span> <span class="number">58.7</span> <span class="number">66.6</span> <span class="number">96.1</span> <span class="number">100</span> <span class="number">85.9</span> ...</span><br><span class="line"> $ dis    : num  <span class="number">4.09</span> <span class="number">4.97</span> <span class="number">4.97</span> <span class="number">6.06</span> <span class="number">6.06</span> ...</span><br><span class="line"> $ rad    : int  <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> ...</span><br><span class="line"> $ tax    : num  <span class="number">296</span> <span class="number">242</span> <span class="number">242</span> <span class="number">222</span> <span class="number">222</span> <span class="number">222</span> <span class="number">311</span> <span class="number">311</span> <span class="number">311</span> <span class="number">311</span> ...</span><br><span class="line"> $ ptratio: num  <span class="number">15.3</span> <span class="number">17.8</span> <span class="number">17.8</span> <span class="number">18.7</span> <span class="number">18.7</span> <span class="number">18.7</span> <span class="number">15.2</span> <span class="number">15.2</span> <span class="number">15.2</span> <span class="number">15.2</span> ...</span><br><span class="line"> $ black  : num  <span class="number">397</span> <span class="number">397</span> <span class="number">393</span> <span class="number">395</span> <span class="number">397</span> ...</span><br><span class="line"> $ lstat  : num  <span class="number">4.98</span> <span class="number">9.14</span> <span class="number">4.03</span> <span class="number">2.94</span> <span class="number">5.33</span> ...</span><br><span class="line"> $ medv   : num  <span class="number">24</span> <span class="number">21.6</span> <span class="number">34.7</span> <span class="number">33.4</span> <span class="number">36.2</span> <span class="number">28.7</span> <span class="number">22.9</span> <span class="number">27.1</span> <span class="number">16.5</span> <span class="number">18.9</span> ...</span><br></pre></td></tr></table></figure>
<p>两个回归因素，lstat 和 age</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; lm.fit=lm(medv~lstat+age,data=Boston)</span><br><span class="line">&gt; summary(lm.fit)</span><br><span class="line"></span><br><span class="line">Call:</span><br><span class="line">lm(formula = medv ~ lstat + age, data = Boston)</span><br><span class="line"></span><br><span class="line">Residuals:</span><br><span class="line">    Min      <span class="number">1</span>Q  Median      <span class="number">3</span>Q     Max </span><br><span class="line">-<span class="number">15.981</span>  -<span class="number">3.978</span>  -<span class="number">1.283</span>   <span class="number">1.968</span>  <span class="number">23.158</span> </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">            Estimate Std. Error t value Pr(&gt;|t|)    </span><br><span class="line">(Intercept) <span class="number">33.22276</span>    <span class="number">0.73085</span>  <span class="number">45.458</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">lstat       -<span class="number">1.03207</span>    <span class="number">0.04819</span> -<span class="number">21.416</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">age          <span class="number">0.03454</span>    <span class="number">0.01223</span>   <span class="number">2.826</span>  <span class="number">0.00491</span> ** </span><br><span class="line">---</span><br><span class="line">Signif. codes:  <span class="number">0</span> ‘***’ <span class="number">0.001</span> ‘**’ <span class="number">0.01</span> ‘*’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error: <span class="number">6.173</span> on <span class="number">503</span> degrees of freedom</span><br><span class="line">Multiple R-squared:  <span class="number">0.5513</span>,	Adjusted R-squared:  <span class="number">0.5495</span> </span><br><span class="line"><span class="built_in">F</span>-statistic:   <span class="number">309</span> on <span class="number">2</span> and <span class="number">503</span> DF,  p-value: &lt; <span class="number">2.2e-16</span></span><br></pre></td></tr></table></figure>
<p>Boston 数据集总共有 13 个自变量，我们可以通过这种简写方式，直接使用所有的自变量（前提是除了因变量以外，其他全是自变量）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; lm.fit=lm(medv~.,data=Boston)</span><br><span class="line">&gt; summary(lm.fit)</span><br><span class="line"></span><br><span class="line">Call:</span><br><span class="line">lm(formula = medv ~ ., data = Boston)</span><br><span class="line"></span><br><span class="line">Residuals:</span><br><span class="line">    Min      <span class="number">1</span>Q  Median      <span class="number">3</span>Q     Max </span><br><span class="line">-<span class="number">15.595</span>  -<span class="number">2.730</span>  -<span class="number">0.518</span>   <span class="number">1.777</span>  <span class="number">26.199</span> </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">              Estimate Std. Error t value Pr(&gt;|t|)    </span><br><span class="line">(Intercept)  <span class="number">3.646e+01</span>  <span class="number">5.103e+00</span>   <span class="number">7.144</span> <span class="number">3.28e-12</span> ***</span><br><span class="line">crim        -<span class="number">1.080e-01</span>  <span class="number">3.286e-02</span>  -<span class="number">3.287</span> <span class="number">0.001087</span> ** </span><br><span class="line">zn           <span class="number">4.642e-02</span>  <span class="number">1.373e-02</span>   <span class="number">3.382</span> <span class="number">0.000778</span> ***</span><br><span class="line">indus        <span class="number">2.056e-02</span>  <span class="number">6.150e-02</span>   <span class="number">0.334</span> <span class="number">0.738288</span>    </span><br><span class="line">chas         <span class="number">2.687e+00</span>  <span class="number">8.616e-01</span>   <span class="number">3.118</span> <span class="number">0.001925</span> ** </span><br><span class="line">nox         -<span class="number">1.777e+01</span>  <span class="number">3.820e+00</span>  -<span class="number">4.651</span> <span class="number">4.25e-06</span> ***</span><br><span class="line">rm           <span class="number">3.810e+00</span>  <span class="number">4.179e-01</span>   <span class="number">9.116</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">age          <span class="number">6.922e-04</span>  <span class="number">1.321e-02</span>   <span class="number">0.052</span> <span class="number">0.958229</span>    </span><br><span class="line">dis         -<span class="number">1.476e+00</span>  <span class="number">1.995e-01</span>  -<span class="number">7.398</span> <span class="number">6.01e-13</span> ***</span><br><span class="line">rad          <span class="number">3.060e-01</span>  <span class="number">6.635e-02</span>   <span class="number">4.613</span> <span class="number">5.07e-06</span> ***</span><br><span class="line">tax         -<span class="number">1.233e-02</span>  <span class="number">3.760e-03</span>  -<span class="number">3.280</span> <span class="number">0.001112</span> ** </span><br><span class="line">ptratio     -<span class="number">9.527e-01</span>  <span class="number">1.308e-01</span>  -<span class="number">7.283</span> <span class="number">1.31e-12</span> ***</span><br><span class="line">black        <span class="number">9.312e-03</span>  <span class="number">2.686e-03</span>   <span class="number">3.467</span> <span class="number">0.000573</span> ***</span><br><span class="line">lstat       -<span class="number">5.248e-01</span>  <span class="number">5.072e-02</span> -<span class="number">10.347</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">---</span><br><span class="line">Signif. codes:  <span class="number">0</span> ‘***’ <span class="number">0.001</span> ‘**’ <span class="number">0.01</span> ‘*’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error: <span class="number">4.745</span> on <span class="number">492</span> degrees of freedom</span><br><span class="line">Multiple R-squared:  <span class="number">0.7406</span>,	Adjusted R-squared:  <span class="number">0.7338</span> </span><br><span class="line"><span class="built_in">F</span>-statistic: <span class="number">108.1</span> on <span class="number">13</span> and <span class="number">492</span> DF,  p-value: &lt; <span class="number">2.2e-16</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以通过car包的 vif() 函数计算 各个因子的VIF，这里可以看到 rad 和 tax 这两个因素的 VIF 比较高。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; library(car)</span><br><span class="line">载入需要的程辑包：carData</span><br><span class="line">Registered S3 methods overwritten by <span class="string">&#x27;tibble&#x27;</span>:</span><br><span class="line">  method     from  </span><br><span class="line">  format.tbl pillar</span><br><span class="line">  print.tbl  pillar</span><br><span class="line">Warning messages:</span><br><span class="line">1: 程辑包‘car’是用R版本<span class="number">4.0</span>.3 来建造的 </span><br><span class="line">2: 程辑包‘carData’是用R版本<span class="number">4.0</span>.3 来建造的 </span><br><span class="line">&gt; vif(lm.fit)</span><br><span class="line">    crim       zn    indus     chas      nox       rm      age      dis      rad      tax </span><br><span class="line">1.792192 <span class="number">2.298758</span> <span class="number">3.991596</span> <span class="number">1.073995</span> <span class="number">4.393720</span> <span class="number">1.933744</span> <span class="number">3.100826</span> <span class="number">3.955945</span> <span class="number">7.484496</span> <span class="number">9.008554</span> </span><br><span class="line"> ptratio    black    lstat </span><br><span class="line">1.799084 <span class="number">1.348521</span> <span class="number">2.941491</span> </span><br></pre></td></tr></table></figure>
<p>使用除了某一个因子外的其他所有因子的回归（采用 - 号），例如剔除 age 因子。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt;lm.fit1 = lm(medv∼.-age,data=Boston)</span><br><span class="line">&gt;summary(lm.fit1)</span><br></pre></td></tr></table></figure>
<h2 id="互作项">互作项</h2>
<p>回归模型中 ， <code>lstat:black</code> 表示新增一个 <code>lstat</code> 和 <code>black</code> 的互作项。<code>lstat*age</code> 表示同时<code>lstat</code>, <code>age</code> 和他们之间的互作项，是 <code>lstat+age+lstat:age</code> 的简写。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; summary(lm(medv~lstat*age,data=Boston))</span><br><span class="line"></span><br><span class="line">Call:</span><br><span class="line">lm(formula = medv ~ lstat * age, data = Boston)</span><br><span class="line"></span><br><span class="line">Residuals:</span><br><span class="line">    Min      <span class="number">1</span>Q  Median      <span class="number">3</span>Q     Max </span><br><span class="line">-<span class="number">15.806</span>  -<span class="number">4.045</span>  -<span class="number">1.333</span>   <span class="number">2.085</span>  <span class="number">27.552</span> </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">              Estimate Std. Error t value Pr(&gt;|t|)    </span><br><span class="line">(Intercept) <span class="number">36.0885359</span>  <span class="number">1.4698355</span>  <span class="number">24.553</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">lstat       -<span class="number">1.3921168</span>  <span class="number">0.1674555</span>  -<span class="number">8.313</span> <span class="number">8.78e-16</span> ***</span><br><span class="line">age         -<span class="number">0.0007209</span>  <span class="number">0.0198792</span>  -<span class="number">0.036</span>   <span class="number">0.9711</span>    </span><br><span class="line">lstat:age    <span class="number">0.0041560</span>  <span class="number">0.0018518</span>   <span class="number">2.244</span>   <span class="number">0.0252</span> *  </span><br><span class="line">---</span><br><span class="line">Signif. codes:  <span class="number">0</span> ‘***’ <span class="number">0.001</span> ‘**’ <span class="number">0.01</span> ‘*’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error: <span class="number">6.149</span> on <span class="number">502</span> degrees of freedom</span><br><span class="line">Multiple R-squared:  <span class="number">0.5557</span>,	Adjusted R-squared:  <span class="number">0.5531</span> </span><br><span class="line"><span class="built_in">F</span>-statistic: <span class="number">209.3</span> on <span class="number">3</span> and <span class="number">502</span> DF,  p-value: &lt; <span class="number">2.2e-16</span></span><br></pre></td></tr></table></figure>
<h2 id="自变量的非线性转换">自变量的非线性转换</h2>
<p>我们可以创建一个新的自变量 X<sup>2</sup>，采用 <code>I(X^2)</code> 函数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; lm.fit2 = lm(medv~lstat+I(lstat^<span class="number">2</span>), data = Boston)</span><br><span class="line">&gt; summary(lm.fit2)</span><br><span class="line"></span><br><span class="line">Call:</span><br><span class="line">lm(formula = medv ~ lstat + I(lstat^<span class="number">2</span>), data = Boston)</span><br><span class="line"></span><br><span class="line">Residuals:</span><br><span class="line">     Min       <span class="number">1</span>Q   Median       <span class="number">3</span>Q      Max </span><br><span class="line">-<span class="number">15.2834</span>  -<span class="number">3.8313</span>  -<span class="number">0.5295</span>   <span class="number">2.3095</span>  <span class="number">25.4148</span> </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">             Estimate Std. Error t value Pr(&gt;|t|)    </span><br><span class="line">(Intercept) <span class="number">42.862007</span>   <span class="number">0.872084</span>   <span class="number">49.15</span>   &lt;<span class="number">2e-16</span> ***</span><br><span class="line">lstat       -<span class="number">2.332821</span>   <span class="number">0.123803</span>  -<span class="number">18.84</span>   &lt;<span class="number">2e-16</span> ***</span><br><span class="line">I(lstat^<span class="number">2</span>)   <span class="number">0.043547</span>   <span class="number">0.003745</span>   <span class="number">11.63</span>   &lt;<span class="number">2e-16</span> ***</span><br><span class="line">---</span><br><span class="line">Signif. codes:  <span class="number">0</span> ‘***’ <span class="number">0.001</span> ‘**’ <span class="number">0.01</span> ‘*’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error: <span class="number">5.524</span> on <span class="number">503</span> degrees of freedom</span><br><span class="line">Multiple R-squared:  <span class="number">0.6407</span>,	Adjusted R-squared:  <span class="number">0.6393</span> </span><br><span class="line"><span class="built_in">F</span>-statistic: <span class="number">448.5</span> on <span class="number">2</span> and <span class="number">503</span> DF,  p-value: &lt; <span class="number">2.2e-16</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看到二次项的P值也是显著的，说明模型拟合结果有所改善。我们可以使用 <code>anova()</code> 函数来比对两个模型。</p>
<p>这里 Model 1 表示原来的线性模型，Model 2 表示二次项回归模型。这个  <code>anova()</code> 函数执行了一个比对两个模型的假设检验，零假设是两个模型拟合程度一致，备择假设是更全的模型更好。这里F统计量是135， 相应的 P值也很低，说明二次项模型拟合程度更好。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; lm.fit = lm(medv~lstat, data=Boston)</span><br><span class="line">&gt; anova(lm.fit, lm.fit2)</span><br><span class="line">Analysis of Variance Table</span><br><span class="line"></span><br><span class="line">Model <span class="number">1</span>: medv ~ lstat</span><br><span class="line">Model <span class="number">2</span>: medv ~ lstat + I(lstat^<span class="number">2</span>)</span><br><span class="line">  Res.Df   RSS Df Sum of Sq     <span class="built_in">F</span>    Pr(&gt;<span class="built_in">F</span>)    </span><br><span class="line">1    <span class="number">504</span> <span class="number">19472</span>                                 </span><br><span class="line">2    <span class="number">503</span> <span class="number">15347</span>  <span class="number">1</span>    <span class="number">4125.1</span> <span class="number">135.2</span> &lt; <span class="number">2.2e-16</span> ***</span><br><span class="line">---</span><br><span class="line">Signif. codes:  <span class="number">0</span> ‘***’ <span class="number">0.001</span> ‘**’ <span class="number">0.01</span> ‘*’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如果要建立<strong>三次型</strong>方程，我们可以新增一个变量 <code>I(X^3)</code> 。但是，这种写法比较啰嗦。一个更好的写法是使用<code>poly()</code> 函数来创建一个多项式。比如下面就会创建一个自由度为5的二次型拟合</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; lm.fit5 = lm(medv~poly(lstat,<span class="number">5</span>),data=Boston)</span><br><span class="line">&gt; summary(lm.fit5)</span><br><span class="line"></span><br><span class="line">Call:</span><br><span class="line">lm(formula = medv ~ poly(lstat, <span class="number">5</span>), data = Boston)</span><br><span class="line"></span><br><span class="line">Residuals:</span><br><span class="line">     Min       <span class="number">1</span>Q   Median       <span class="number">3</span>Q      Max </span><br><span class="line">-<span class="number">13.5433</span>  -<span class="number">3.1039</span>  -<span class="number">0.7052</span>   <span class="number">2.0844</span>  <span class="number">27.1153</span> </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">                 Estimate Std. Error t value Pr(&gt;|t|)    </span><br><span class="line">(Intercept)       <span class="number">22.5328</span>     <span class="number">0.2318</span>  <span class="number">97.197</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">poly(lstat, <span class="number">5</span>)<span class="number">1</span> -<span class="number">152.4595</span>     <span class="number">5.2148</span> -<span class="number">29.236</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">poly(lstat, <span class="number">5</span>)<span class="number">2</span>   <span class="number">64.2272</span>     <span class="number">5.2148</span>  <span class="number">12.316</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">poly(lstat, <span class="number">5</span>)<span class="number">3</span>  -<span class="number">27.0511</span>     <span class="number">5.2148</span>  -<span class="number">5.187</span> <span class="number">3.10e-07</span> ***</span><br><span class="line">poly(lstat, <span class="number">5</span>)<span class="number">4</span>   <span class="number">25.4517</span>     <span class="number">5.2148</span>   <span class="number">4.881</span> <span class="number">1.42e-06</span> ***</span><br><span class="line">poly(lstat, <span class="number">5</span>)<span class="number">5</span>  -<span class="number">19.2524</span>     <span class="number">5.2148</span>  -<span class="number">3.692</span> <span class="number">0.000247</span> ***</span><br><span class="line">---</span><br><span class="line">Signif. codes:  <span class="number">0</span> ‘***’ <span class="number">0.001</span> ‘**’ <span class="number">0.01</span> ‘*’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error: <span class="number">5.215</span> on <span class="number">500</span> degrees of freedom</span><br><span class="line">Multiple R-squared:  <span class="number">0.6817</span>,	Adjusted R-squared:  <span class="number">0.6785</span> </span><br><span class="line"><span class="built_in">F</span>-statistic: <span class="number">214.2</span> on <span class="number">5</span> and <span class="number">500</span> DF,  p-value: &lt; <span class="number">2.2e-16</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里说明如果增加二次项，加到5， 可以增加模型的拟合程度。但是，进一步研究会发现，如果增加超过项数超过5的项，这些超过5的项的p值均不显著。</p>
<p>当然，除了使用二次项以外，我们还可以使用其他转换函数，比如<strong>log函数</strong>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">summary(lm(medv~<span class="built_in">log</span>(rm), data=Boston))</span><br></pre></td></tr></table></figure>
<h2 id="分类因子">分类因子</h2>
<p>这里我们用 <code>ISLR</code> 包的 <code>Carseats</code> 数据集。我们想要预测的变量是 <em>Sales</em></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; library(ISLR)</span><br><span class="line">&gt; fix(Carseats)</span><br><span class="line">&gt; str(Carseats)</span><br><span class="line"><span class="string">&#x27;data.frame&#x27;</span>:	<span class="number">400</span> obs. of  <span class="number">11</span> variables:</span><br><span class="line"> $ Sales      : num  <span class="number">9.5</span> <span class="number">11.22</span> <span class="number">10.06</span> <span class="number">7.4</span> <span class="number">4.15</span> ...</span><br><span class="line"> $ CompPrice  : num  <span class="number">138</span> <span class="number">111</span> <span class="number">113</span> <span class="number">117</span> <span class="number">141</span> <span class="number">124</span> <span class="number">115</span> <span class="number">136</span> <span class="number">132</span> <span class="number">132</span> ...</span><br><span class="line"> $ Income     : num  <span class="number">73</span> <span class="number">48</span> <span class="number">35</span> <span class="number">100</span> <span class="number">64</span> <span class="number">113</span> <span class="number">105</span> <span class="number">81</span> <span class="number">110</span> <span class="number">113</span> ...</span><br><span class="line"> $ Advertising: num  <span class="number">11</span> <span class="number">16</span> <span class="number">10</span> <span class="number">4</span> <span class="number">3</span> <span class="number">13</span> <span class="number">0</span> <span class="number">15</span> <span class="number">0</span> <span class="number">0</span> ...</span><br><span class="line"> $ Population : num  <span class="number">276</span> <span class="number">260</span> <span class="number">269</span> <span class="number">466</span> <span class="number">340</span> <span class="number">501</span> <span class="number">45</span> <span class="number">425</span> <span class="number">108</span> <span class="number">131</span> ...</span><br><span class="line"> $ Price      : num  <span class="number">120</span> <span class="number">83</span> <span class="number">80</span> <span class="number">97</span> <span class="number">128</span> <span class="number">72</span> <span class="number">108</span> <span class="number">120</span> <span class="number">124</span> <span class="number">124</span> ...</span><br><span class="line"> $ ShelveLoc  : Factor w/ <span class="number">3</span> levels <span class="string">&quot;Bad&quot;</span>,<span class="string">&quot;Good&quot;</span>,<span class="string">&quot;Medium&quot;</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> ...</span><br><span class="line"> $ Age        : num  <span class="number">42</span> <span class="number">65</span> <span class="number">59</span> <span class="number">55</span> <span class="number">38</span> <span class="number">78</span> <span class="number">71</span> <span class="number">67</span> <span class="number">76</span> <span class="number">76</span> ...</span><br><span class="line"> $ Education  : num  <span class="number">17</span> <span class="number">10</span> <span class="number">12</span> <span class="number">14</span> <span class="number">13</span> <span class="number">16</span> <span class="number">15</span> <span class="number">10</span> <span class="number">10</span> <span class="number">17</span> ...</span><br><span class="line"> $ Urban      : Factor w/ <span class="number">2</span> levels <span class="string">&quot;No&quot;</span>,<span class="string">&quot;Yes&quot;</span>: <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> ...</span><br><span class="line"> $ US         : Factor w/ <span class="number">2</span> levels <span class="string">&quot;No&quot;</span>,<span class="string">&quot;Yes&quot;</span>: <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> ...</span><br></pre></td></tr></table></figure>
<p>这里包含了类似于 <code>ShelveLoc</code> 的分类变量。如果使用分类变量，R会<strong>自动转变为哑变量</strong>。下面我们进行包含了一些互作项的多重回归模型。</p>
<p>这里  <code>ShelveLoc</code>  生成了两个哑变量 ShelveLocGood 和 ShelveLocMedium ，Bad 水平视为基础水平。我们可以看到 Good 和 Medium 水平的斜率都是正数，且均显著，说明 Good 和 Medium 水平的因变量的均值均比 Bad 水平要高。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; lm.fit=lm(Sales~.+Income:Advertising +Price:Age,data=Carseats)</span><br><span class="line">&gt; summary(lm.fit)</span><br><span class="line"></span><br><span class="line">Call:</span><br><span class="line">lm(formula = Sales ~ . + Income:Advertising + Price:Age, data = Carseats)</span><br><span class="line"></span><br><span class="line">Residuals:</span><br><span class="line">    Min      <span class="number">1</span>Q  Median      <span class="number">3</span>Q     Max </span><br><span class="line">-<span class="number">2.9208</span> -<span class="number">0.7503</span>  <span class="number">0.0177</span>  <span class="number">0.6754</span>  <span class="number">3.3413</span> </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">                     Estimate Std. Error t value Pr(&gt;|t|)    </span><br><span class="line">(Intercept)         <span class="number">6.5755654</span>  <span class="number">1.0087470</span>   <span class="number">6.519</span> <span class="number">2.22e-10</span> ***</span><br><span class="line">CompPrice           <span class="number">0.0929371</span>  <span class="number">0.0041183</span>  <span class="number">22.567</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">Income              <span class="number">0.0108940</span>  <span class="number">0.0026044</span>   <span class="number">4.183</span> <span class="number">3.57e-05</span> ***</span><br><span class="line">Advertising         <span class="number">0.0702462</span>  <span class="number">0.0226091</span>   <span class="number">3.107</span> <span class="number">0.002030</span> ** </span><br><span class="line">Population          <span class="number">0.0001592</span>  <span class="number">0.0003679</span>   <span class="number">0.433</span> <span class="number">0.665330</span>    </span><br><span class="line">Price              -<span class="number">0.1008064</span>  <span class="number">0.0074399</span> -<span class="number">13.549</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">ShelveLocGood       <span class="number">4.8486762</span>  <span class="number">0.1528378</span>  <span class="number">31.724</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">ShelveLocMedium     <span class="number">1.9532620</span>  <span class="number">0.1257682</span>  <span class="number">15.531</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">Age                -<span class="number">0.0579466</span>  <span class="number">0.0159506</span>  -<span class="number">3.633</span> <span class="number">0.000318</span> ***</span><br><span class="line">Education          -<span class="number">0.0208525</span>  <span class="number">0.0196131</span>  -<span class="number">1.063</span> <span class="number">0.288361</span>    </span><br><span class="line">UrbanYes            <span class="number">0.1401597</span>  <span class="number">0.1124019</span>   <span class="number">1.247</span> <span class="number">0.213171</span>    </span><br><span class="line">USYes              -<span class="number">0.1575571</span>  <span class="number">0.1489234</span>  -<span class="number">1.058</span> <span class="number">0.290729</span>    </span><br><span class="line">Income:Advertising  <span class="number">0.0007510</span>  <span class="number">0.0002784</span>   <span class="number">2.698</span> <span class="number">0.007290</span> ** </span><br><span class="line">Price:Age           <span class="number">0.0001068</span>  <span class="number">0.0001333</span>   <span class="number">0.801</span> <span class="number">0.423812</span>    </span><br><span class="line">---</span><br><span class="line">Signif. codes:  <span class="number">0</span> ‘***’ <span class="number">0.001</span> ‘**’ <span class="number">0.01</span> ‘*’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error: <span class="number">1.011</span> on <span class="number">386</span> degrees of freedom</span><br><span class="line">Multiple R-squared:  <span class="number">0.8761</span>,	Adjusted R-squared:  <span class="number">0.8719</span> </span><br><span class="line"><span class="built_in">F</span>-statistic:   <span class="number">210</span> on <span class="number">13</span> and <span class="number">386</span> DF,  p-value: &lt; <span class="number">2.2e-16</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是线性</title>
    <url>/posts/c2b5c4e7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天发现，我们一直在说的“线性”二字居然是一个有歧义的概念。</p>
<span id="more"></span>
<h1>概述</h1>
<p>我查了一些资料，目前感觉还是维基百科对这个问题讲得最清楚全面，因此本文主要内容来自于<a href="https://www.wikiwand.com/zh-tw/%E7%B7%9A%E6%80%A7%E9%97%9C%E4%BF%82">维基百科-线性关系</a>。</p>
<blockquote>
<p>在现代学术界中，<strong>线性关系</strong>一词存在2种不同的含义。其一，若某数学函数或数学关系的函数图形呈现为一条直线或线段，那么这种关系就是一种<strong>线性</strong>的关系。其二，在线性代数和数学分析中，如果一种运算同时满足<strong>可加性</strong>和<strong>齐次性</strong>，则称这种运算是线性的。</p>
</blockquote>
<h1>定义</h1>
<blockquote>
<p>如果称一个数学函数 <img src="https://math.now.sh?inline=L%28x%29" style="display:inline-block;margin: 0;"/> 为线性的，可以是指：</p>
<ul>
<li><strong>定义1</strong>： <img src="https://math.now.sh?inline=L%28x%29" style="display:inline-block;margin: 0;"/> 是一个只有一个变量的一阶多项式函数，即可以表示为 <img src="https://math.now.sh?inline=L%28x%29%3Dk%20x%2Bb" style="display:inline-block;margin: 0;"/> 的形式（其中 k,b 为常数），此时的函数图形是一条直线。</li>
<li><strong>定义2</strong>： <img src="https://math.now.sh?inline=L%28x%29" style="display:inline-block;margin: 0;"/> 满足以下两个性质：
<ul>
<li>可加性：<img src="https://math.now.sh?inline=L%28x%2Bt%29%3DL(x)%2BL(t)" style="display:inline-block;margin: 0;"/></li>
<li>齐次性：<img src="https://math.now.sh?inline=L%28m%20x%29%3Dm%20L(x)" style="display:inline-block;margin: 0;"/></li>
</ul>
</li>
</ul>
<p>需要注意这两种定义分别描述的是2种不同的事物。在初等数学中（主要是与方程组与一次函数有关的理论），使用的是定义1。但在高等数学（尤其是纯数学）中所说的线性一般使用的是定义2。如对线性相关和线性变换的定义。但是初等数学中有关【线性】的一些习惯术语也仍然在高等数学中沿用，如<strong>线性回归</strong>。</p>
<p>定义1 的定义动机是把函数图像为直线的数量关系称作线性的关系。从这种几何意义出发，定义1本来不具有对多元函数进行推广的必要，因为形如 <img src="https://math.now.sh?inline=f%5Cleft%28x_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Cldots%2C%20x_%7Bn%7D%5Cright%29%3Dk_%7B1%7D%20*%20x_%7B1%7D%2Bk_%7B2%7D%20*%20x_%7B2%7D%2B%5Cldots%2Bk_%7Bn%7D%20*%20x_%7Bn%7D%2Bb" style="display:inline-block;margin: 0;"/> 的函数的图形根本不是直线，而是平面或<strong>超平面</strong>，因此也就谈不上“线性”了。但是我们还是有这种做法出现。</p>
</blockquote>
<h1>例子</h1>
<blockquote>
<ul>
<li>按照定义1，一次函数描述的都是不同变量间的线性的数量关系，而高次函数描述的都不是线性的数量关系。比如 <img src="https://math.now.sh?inline=y_%7B1%7D%3D3%20x%2C%20%5Cquad%20y_%7B2%7D%3D%5Cfrac%7B1%7D%7B3%7D%20x" style="display:inline-block;margin: 0;"/>  和  <img src="https://math.now.sh?inline=y_%7B3%7D%3D3%20x%2B1" style="display:inline-block;margin: 0;"/>  都属于这种意义下的线性函数，但 <img src="https://math.now.sh?inline=y_%7B4%7D%3Dx%5E%7B2%7D%20%2C%5Cquad%20y_%7B5%7D%3Dx%2Bz%20%2C%5Cquad%20y_%7B6%7D%3Dx%2Bz%2B2" style="display:inline-block;margin: 0;"/>  和  <img src="https://math.now.sh?inline=y_%7B7%7D%3Dx%20z" style="display:inline-block;margin: 0;"/> 则不是。（如果将这种意义下的【线性】概念推广到多元函数，则 <img src="https://math.now.sh?inline=y_6" style="display:inline-block;margin: 0;"/> 也能算。事实上，【多元线性回归】的【线性】指的就是这种线性。）</li>
<li>而按照定义2，若以一元函数为例，则截距为 0 的一次函数 (即正比例函数) 属于线性函数，但截距不为 0 的一次函数则不属于线性函数。又如 <img src="https://math.now.sh?inline=y_%7B1%7D%3D3%20x%2C%5Cquad%20y_%7B2%7D%3D%5Cfrac%7B1%7D%7B3%7D%20x" style="display:inline-block;margin: 0;"/>  和  <img src="https://math.now.sh?inline=y_%7B5%7D%3Dx%2Bz" style="display:inline-block;margin: 0;"/> 都属于这种意义下的线性函数（<img src="https://math.now.sh?inline=y_5" style="display:inline-block;margin: 0;"/> 特征向量的维数为 2 ，即此时 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D%20%3D%20%28x%2Cz%29'" style="display:inline-block;margin: 0;"/> ，此时可以轻易证明其符合可加性和齐次性 ）。但是 <img src="https://math.now.sh?inline=y_%7B3%7D%3D3%20x%2B1%2C%5Cquad%20y_%7B4%7D%3Dx%5E%7B2%7D%2C%5Cquad%20y_%7B6%7D%3Dx%2Bz%2B2" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=y_%7B7%7D%3Dx%20z" style="display:inline-block;margin: 0;"/> 都不是。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>假设检验中的alpha,beta及power</title>
    <url>/posts/5cc421e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在统计的假设检验中，α，β，power ，一型错误，二型错误这几个概念/概率总是容易混淆，或者一下子忘了啥意思，把它们放在一个表里方便查找。</p>
<span id="more"></span>
<h1>假设检验</h1>
<p>假设检验是先对总体参数提出一个假设值，然后利用样本信息判断这一假设是否成立<a href="%5B%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C%E2%80%94%E2%80%94%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86%5D(https://zhuanlan.zhihu.com/p/86178674)">^1</a>。</p>
<p>假设检验的步骤如下[^1][^2]。</p>
<ul>
<li>
<p>提出原假设与备择假设</p>
<p>原假设一般时你想要拒绝的假设，备择假设时你想要接受的假设。</p>
</li>
<li>
<p>从所研究总体中出抽取随机一次样本</p>
</li>
<li>
<p>构造检验统计量</p>
</li>
<li>
<p>根据显著性水平确定拒绝域临界值</p>
</li>
<li>
<p>计算检验统计量与临界值进行比较</p>
</li>
</ul>
<h1>假设检验表格</h1>
<p>α，β，power 定义见下表[^3]。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>真实情况</th>
<th>真实情况</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>H0为真</td>
<td>H0为假</td>
</tr>
<tr>
<td><strong>根据研究结果的判断</strong></td>
<td>拒绝 H0</td>
<td>错误判断 (假阳性，一型错误，弃真错误)，发生概率为 α （显著性水平）</td>
<td>正确判断，发生概率 1-β (统计功效)</td>
</tr>
<tr>
<td><strong>根据研究结果的判断</strong></td>
<td>接受 H0</td>
<td>正确判断，发生概率 1-α</td>
<td>错误判断（假阴性，二型错误，存伪错误），发生概率为 β</td>
</tr>
</tbody>
</table>
<p>[^2]: 假设检验的逻辑是是什么？ - GRAYLAMB的回答 - 知乎 <a href="https://www.zhihu.com/question/20254932/answer/459073864">https://www.zhihu.com/question/20254932/answer/459073864</a><br>
[^3]: <a href="https://www.wikiwand.com/zh/%E6%AA%A2%E5%AE%9A%E5%8A%9B">https://www.wikiwand.com/zh/檢定力</a></p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>统计</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>PCA分析公式推导</title>
    <url>/posts/fc532062/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>吴老师的CS229课程里讲到了PCA分析，但是感觉有些地方不清晰，查阅了一些资料，自己整理了一下。</p>
<span id="more"></span> 
<h1>特征值分解与奇异值分解</h1>
<p>首先我们需要了解一些特征值分解与奇异值分解的一些背景知识。</p>
<h2 id="特征值分解">特征值分解</h2>
<h3 id="特征值和特征向量">特征值和特征向量</h3>
<p>矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的特征值和特征向量满足关系：</p>
<p style=""><img src="https://math.now.sh?from=A%20x%3D%5Clambda%20x%2C%20%5Cquad%20x%20%5Cneq%200%0A" /></p><p>我们注意到对于任何特征向量 <img src="https://math.now.sh?inline=x%20%5Cin%20%5Cmathbb%7BC%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> ，和特征值 <img src="https://math.now.sh?inline=t%20%5Cin%20%5Cmathbb%7BC%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=A%28c%20x%29%3Dc%20A%20x%3Dc%20%5Clambda%20x%3D%5Clambda(c%20x)" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=c%20x" style="display:inline-block;margin: 0;"/> 一样是 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的特征向量。因此，当我们提到与特征值 <img src="https://math.now.sh?inline=%5Clambda" style="display:inline-block;margin: 0;"/> 的特征向量 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 时，<strong>我们一般假定特征向量 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 是标准化的</strong>，即 <img src="https://math.now.sh?inline=%5C%7Cx%5C%7C%20%3D%201" style="display:inline-block;margin: 0;"/> 。但是，我们注意到，<img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=-x" style="display:inline-block;margin: 0;"/> 都是特征向量，因此我们无法保证特征向量的符号。</p>
<p>我们可以将上式改写为：</p>
<p style=""><img src="https://math.now.sh?from=%7C%28%5Clambda%20I-A%29%7C%3D0%0A" /></p><p>方阵 <img src="https://math.now.sh?inline=A%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bn%20%5Ctimes%20n%7D" style="display:inline-block;margin: 0;"/> 一定有 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个特征值（可能是复数）。</p>
<p>特征值和特征向量有以下性质：</p>
<ul>
<li>方阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的迹等于所有特征值之和。</li>
</ul>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%20A%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Clambda_%7Bi%7D%0A" /></p><p>证明如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Btr%7D%28A%29%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(Q%20%5CLambda%20Q%5E%7B-1%7D%5Cright)%20%5Cquad%20%5Cbecause%20%5Ctext%20%7B%20%E5%AF%B9%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5%E8%BF%9B%E8%A1%8C%E7%89%B9%E5%BE%81%E5%80%BC%E5%88%86%E8%A7%A3%20%7D%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(Q%5E%7B-1%7D%20Q%20%5CLambda%5Cright)%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D(%5CLambda)%20%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Clambda_%7Bi%7D%0A%5Cend%7Baligned%7D%0A" /></p><ul>
<li>方阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的行列式等于其所有特征值的乘积（缺证明）</li>
</ul>
<p style=""><img src="https://math.now.sh?from=%7CA%7C%3D%5Cprod_%7Bi%3D1%7D%5E%7Bn%7D%20%5Clambda_%7Bi%7D%0A" /></p><ul>
<li>
<p><strong>方阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的秩等于其非零特征值的数目</strong>（缺证明）</p>
</li>
<li>
<p>如果 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 非奇异，那么 <img src="https://math.now.sh?inline=1%2F%5Clambda" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=A%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 的特征值和特征向量。</p>
<p>证明，对 <img src="https://math.now.sh?inline=Ax%20%3D%20%5Clambda%20x" style="display:inline-block;margin: 0;"/> 左右两项均左乘一个 <img src="https://math.now.sh?inline=A%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> ，得到</p>
<p style=""><img src="https://math.now.sh?from=A%5E%7B-1%7DA%20x%20%3D%20A%5E%7B-1%7D%20%5Clambda%20x%20%5C%5C%0A%281%2F%5Clambda%29%20x%20%3D%20A%5E%7B-1%7Dx%0A" /></p></li>
<li>
<p>对角矩阵<img src="https://math.now.sh?inline=D%3D%5Coperatorname%7Bdiag%7D%5Cleft%28d_%7B1%7D%2C%20%5Cldots%20d_%7Bn%7D%5Cright%29" style="display:inline-block;margin: 0;"/>  的特征值就是其对角线元素</p>
<p>证明：因为，<img src="https://math.now.sh?inline=Dx%20%3D%20%5Bd_%7B1%7Dx_%7B1%7D%20%5Cquad%20d_%7B2%7Dx_%7B2%7D%20%5Cquad%20%5Ccdots%20%5Cquad%20d_%7Bn%7Dx_%7Bn%7D%20%5D%5E%7BT%7D" style="display:inline-block;margin: 0;"/>  ，   <img src="https://math.now.sh?inline=d_%7Bi%7Dx%20%3D%20%5Bd_%7Bi%7Dx_%7B1%7D%20%5Cquad%20d_%7Bi%7Dx_%7B2%7D%20%5Cquad%20%5Ccdots%20%5Cquad%20d_%7Bi%7Dx_%7Bn%7D%20%5D%5E%7BT%7D" style="display:inline-block;margin: 0;"/> ，那么我们只需要设 <img src="https://math.now.sh?inline=x_%7Bi%7D" style="display:inline-block;margin: 0;"/> 为任一非零实数，而其他 <img src="https://math.now.sh?inline=x_%7Bj%7D" style="display:inline-block;margin: 0;"/> (<img src="https://math.now.sh?inline=j%20%5Cneq%20i" style="display:inline-block;margin: 0;"/> ) 均为0，那么就满足  <img src="https://math.now.sh?inline=Dx%20%3D%20d_%7Bi%7Dx" style="display:inline-block;margin: 0;"/> ，即对角线元素 <img src="https://math.now.sh?inline=d_%7Bi%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=D" style="display:inline-block;margin: 0;"/> 的特征值。</p>
</li>
</ul>
<p>我们可以将特征方程写为</p>
<p style=""><img src="https://math.now.sh?from=A%20X%3DX%20%5CLambda%0A" /></p><p>其中 <img src="https://math.now.sh?inline=X%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bn%20%5Ctimes%20n%7D" style="display:inline-block;margin: 0;"/> ，每一列表示一个特征向量，而 <img src="https://math.now.sh?inline=%5CLambda" style="display:inline-block;margin: 0;"/> 为对角矩阵，对角线为特征值，即：</p>
<p style=""><img src="https://math.now.sh?from=X%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bn%20%5Ctimes%20n%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cmid%20%26%20%5Cmid%20%26%20%26%20%5Cmid%20%5C%5C%0Ax_%7B1%7D%20%26%20x_%7B2%7D%20%26%20%5Ccdots%20%26%20x_%7Bn%7D%20%5C%5C%0A%5Cmid%20%26%20%5Cmid%20%26%20%26%20%5Cmid%0A%5Cend%7Barray%7D%5Cright%5D%2C%20%5CLambda%3D%5Coperatorname%7Bdiag%7D%5Cleft%28%5Clambda_%7B1%7D%2C%20%5Cldots%2C%20%5Clambda_%7Bn%7D%5Cright%29%0A" /></p><p>证明如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7DA%20X%20%26%3DA%5Cleft%5Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Cldots%2C%20x_%7Bn%7D%5Cright%5D%20%5C%5C%26%3D%5Cleft%5B%5Clambda_%7B1%7D%20x_%7B1%7D%2C%20%5Clambda_%7B2%7D%20x_%7B2%7D%2C%20%5Cldots%2C%20%5Clambda_%7Bn%7D%20x_%7Bn%7D%5Cright%5D%20%5C%5C%26%3D%5Cleft%5Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Cldots%2C%20x_%7Bn%7D%5Cright%5D%20%5CLambda%20%5C%5C%26%3DX%20%5CLambda%5Cend%7Baligned%7D%0A" /></p><p>如果 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的特征向量之间<strong>线性无关</strong>，那么 <img src="https://math.now.sh?inline=X" style="display:inline-block;margin: 0;"/> 可逆，因此存在下式</p>
<p style=""><img src="https://math.now.sh?from=A%3DX%20%5CLambda%20X%5E%7B-1%7D%0A" /></p><p>最后，我们的约束条件是 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 有 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/>个 线性无关的特征向量，而不是矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 本身是否满秩，矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 无论是否满秩都有可能有 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个线性无关的特征向量。</p>
<h3 id="对称矩阵的特征值和特征向量">对称矩阵的特征值和特征向量</h3>
<p>对称矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的特征值和特征向量有两个重要的性质，<strong>首先，对称矩阵所有的特征值均是实数；第二，对称矩阵的特征向量彼此正交</strong>（缺证明）。因此，此时的 <img src="https://math.now.sh?inline=X" style="display:inline-block;margin: 0;"/> 矩阵为正交矩阵，此时我们定义特征向量的矩阵为 <img src="https://math.now.sh?inline=U" style="display:inline-block;margin: 0;"/> ，即我们表示对称矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 为下式</p>
<p style=""><img src="https://math.now.sh?from=A%3DQ%20%5CLambda%20Q%5E%7B-1%7D%3DQ%20%5CLambda%20Q%5E%7BT%7D%0A" /></p><p><strong>证明：</strong> <img src="https://math.now.sh?inline=Q%5E%7B-1%7D%3DQ%5E%7BT%7D" style="display:inline-block;margin: 0;"/> (其实就是正交矩阵的基本性质)</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26Q%5E%7BT%7D%20Q%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A-%20q_%7B1%7D%20-%20%5C%5C%0A-%20q_%7B2%7D%20-%20%5C%5C%0A%5Ccdots%20%5C%5C%0A-%20q_%7Bn%7D%20-%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D%0A%7C%20%26%20%7C%20%26%20%5Cvdots%20%26%20%7C%20%5C%5C%0Aq_%7B1%7D%20%26%20q_%7B2%7D%20%26%20%5Cvdots%20%26%20q_%7Bn%7D%20%5C%5C%0A%7C%20%26%20%7C%20%26%20%5Cvdots%20%26%20%7C%0A%5Cend%7Barray%7D%5Cright%5D%5C%5C%0A%26%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0Aq_%7B1%7D%5E%7BT%7D%20q_%7B1%7D%20%26%20q_%7B1%7D%5E%7BT%7D%20q_%7B2%7D%20%26%20%5Ccdots%20%26%20q_%7B1%7D%5E%7BT%7D%20q_%7Bn%7D%20%5C%5C%0Aq_%7B2%7D%5E%7BT%7D%20q_%7B1%7D%20%26%20q_%7B2%7D%5E%7BT%7D%20q_%7B2%7D%20%26%20%5Ccdots%20%26%20q_%7B2%7D%5E%7BT%7D%20q_%7Bn%7D%20%5C%5C%0A%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%5C%5C%0Aq_%7Bn%7D%5E%7BT%7D%20q_%7B1%7D%20%26%20q_%7Bn%7D%5E%7BT%7D%20q_%7B2%7D%20%26%20%5Ccdots%20%26%20q_%7Bn%7D%5E%7BT%7D%20q_%7Bn%7D%0A%5Cend%7Barray%7D%5Cright%5D%5C%5C%0A%5C%5C%0A%26%3DI%20%5Cquad%20%5Cbecause%20%E5%AF%B9%E8%A7%92%E7%BA%BF%E4%B8%BA%E6%A8%A1%E9%95%BF%E5%BA%A6%EF%BC%8C%E9%9D%9E%E5%AF%B9%E8%A7%92%E7%BA%BF%E6%A0%B9%E6%8D%AE%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F%E4%B8%A4%E4%B8%A4%E6%AD%A3%E4%BA%A4%E7%9A%84%E6%80%A7%E8%B4%A8%E5%9D%87%E4%B8%BA0%5C%20%0A%5Cend%7Baligned%7D%0A" /></p><p>此时，我们可以表示二次型为</p>
<p style=""><img src="https://math.now.sh?from=x%5E%7BT%7D%20A%20x%3Dx%5E%7BT%7D%20U%20%5CLambda%20U%5E%7BT%7D%20x%3Dy%5E%7BT%7D%20%5CLambda%20y%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Clambda_%7Bi%7D%20y_%7Bi%7D%5E%7B2%7D%0A" /></p><p>其中  <img src="https://math.now.sh?inline=y%3DU%5E%7BT%7D%20x" style="display:inline-block;margin: 0;"/> 。</p>
<p>因为 $y_{i}^{2} \geq 0 $， 因此，二次型的符号完全由特征值 <img src="https://math.now.sh?inline=%5Clambda_%7Bi%7D" style="display:inline-block;margin: 0;"/> 决定。如果所有的特征值均满足 <img src="https://math.now.sh?inline=%5Clambda_%7Bi%7D%20%3E%200" style="display:inline-block;margin: 0;"/> ，那么这个矩阵便是正定矩阵；如果所有的特征值  <img src="https://math.now.sh?inline=%5Clambda_%7Bi%7D%20%5Cgeq%200" style="display:inline-block;margin: 0;"/> （也就是存在特征值为0），那么这个矩阵就是半正定矩阵。相似地，如果所有的特征值满足 <img src="https://math.now.sh?inline=%5Clambda_%7Bi%7D%3C0" style="display:inline-block;margin: 0;"/> 或 <img src="https://math.now.sh?inline=%5Clambda_%7Bi%7D%20%5Cleq%200" style="display:inline-block;margin: 0;"/> ，此时矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 就是一个负定或半负定矩阵。如果矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 同时有正数和负数的特征值，说明 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 为不定矩阵</p>
<h2 id="奇异值分解">奇异值分解</h2>
<p>下面这段话全部来自于别人的文章<a href="https://zhuanlan.zhihu.com/p/26306568">^3</a></p>
<p>当给定一个大小为 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> ，虽然矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 不一定是方阵，但大小为 <img src="https://math.now.sh?inline=m%20%5Ctimes%20m" style="display:inline-block;margin: 0;"/> 的 <img src="https://math.now.sh?inline=A%20A%5E%7BT%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的 <img src="https://math.now.sh?inline=A%5E%7BT%7D%20A" style="display:inline-block;margin: 0;"/> 却是对称矩阵，可以进行特征值分解。若  <img src="https://math.now.sh?inline=A%20A%5E%7BT%7D%3DP%20%5CLambda_%7B1%7D%20P%5E%7BT%7D" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=A%5E%7BT%7D%20A%3DQ%20%5CLambda_%7B2%7D%20Q%5E%7BT%7D" style="display:inline-block;margin: 0;"/> 则矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/>  的奇异值分解为</p>
<p style=""><img src="https://math.now.sh?from=A%3DP%20%5CSigma%20Q%5E%7BT%7D%0A" /></p><p>满足</p>
<p style=""><img src="https://math.now.sh?from=P%5E%7BT%7D%20%3D%20P%5E%7B-1%7D%5C%5C%0AQ%5E%7BT%7D%20%3D%20Q%5E%7B-1%7D%5C%5C%0A" /></p><p>其中，矩阵 <img src="https://math.now.sh?inline=P%3D%5Cleft%28%5Cvec%7Bp%7D_%7B1%7D%2C%20%5Cvec%7Bp%7D_%7B2%7D%2C%20%5Cldots%2C%20%5Cvec%7Bp%7D_%7Bm%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 的大小为 <img src="https://math.now.sh?inline=m%20%5Ctimes%20m" style="display:inline-block;margin: 0;"/> ，列向量 <img src="https://math.now.sh?inline=%5Cvec%7Bp%7D_%7B1%7D%2C%20%5Cvec%7Bp%7D_%7B2%7D%2C%20%5Cldots%2C%20%5Cvec%7Bp%7D_%7Bm%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=A%20A%5E%7BT%7D" style="display:inline-block;margin: 0;"/> 的特征向量，也 被称为矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的左奇异向量 (left singular vector) ; 矩阵 <img src="https://math.now.sh?inline=Q%3D%5Cleft%28%5Cvec%7Bq%7D_%7B1%7D%2C%20%5Cvec%7Bq%7D_%7B2%7D%2C%20%5Cldots%2C%20%5Cvec%7Bq%7D_%7Bn%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 的大小为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> ， 列向量 <img src="https://math.now.sh?inline=%5Cvec%7Bq%7D_%7B1%7D%2C%20%5Cvec%7Bq%7D_%7B2%7D%2C%20%5Cldots%2C%20%5Cvec%7Bq%7D_%7Bn%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=A%5E%7BT%7D%20A" style="display:inline-block;margin: 0;"/> 的特征向量，也被称为矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的右奇异向量 (right singular vector) ; 矩阵 <img src="https://math.now.sh?inline=%5CLambda_%7B1%7D" style="display:inline-block;margin: 0;"/> 大小为 <img src="https://math.now.sh?inline=m%20%5Ctimes%20m" style="display:inline-block;margin: 0;"/> ，矩阵 <img src="https://math.now.sh?inline=%5CLambda_%7B2%7D" style="display:inline-block;margin: 0;"/> 大小为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> ，两个矩阵对角线上的非零元素相同 (即矩阵 <img src="https://math.now.sh?inline=A%20A%5E%7BT%7D" style="display:inline-block;margin: 0;"/> 和矩阵 <img src="https://math.now.sh?inline=A%5E%7BT%7D%20A" style="display:inline-block;margin: 0;"/> 的非零特征值相同，推导过程见下) ; 矩阵 <img src="https://math.now.sh?inline=%5CSigma" style="display:inline-block;margin: 0;"/> 的大小为 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> ，位 于对角线上的元素被称为奇异值 (singular value)。</p>
<p>接下来，我们来看看矩阵 <img src="https://math.now.sh?inline=%5CSigma" style="display:inline-block;margin: 0;"/> 与矩阵 <img src="https://math.now.sh?inline=A%20A%5E%7BT%7D" style="display:inline-block;margin: 0;"/> 和矩阵 <img src="https://math.now.sh?inline=A%5E%7BT%7D%20A" style="display:inline-block;margin: 0;"/> 的关系。令常数 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 是矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的秩，则 <img src="https://math.now.sh?inline=k%20%5Cleq%20%5Cmin%20%28m%2C%20n%29" style="display:inline-block;margin: 0;"/> ，当 <img src="https://math.now.sh?inline=m%20%5Cneq%20n" style="display:inline-block;margin: 0;"/> 时，很明显，矩阵 <img src="https://math.now.sh?inline=%5CLambda_%7B1%7D" style="display:inline-block;margin: 0;"/> 和矩阵 <img src="https://math.now.sh?inline=%5CLambda_%7B2%7D" style="display:inline-block;margin: 0;"/> 的大小不同，但矩阵 <img src="https://math.now.sh?inline=%5CLambda_%7B1%7D" style="display:inline-block;margin: 0;"/> 和矩阵 <img src="https://math.now.sh?inline=%5CLambda_%7B2%7D" style="display:inline-block;margin: 0;"/> 对 角线上的非零元素却是相同的，若将矩阵 <img src="https://math.now.sh?inline=%5CLambda_%7B1%7D" style="display:inline-block;margin: 0;"/> (或矩阵 <img src="https://math.now.sh?inline=%5CLambda_%7B2%7D" style="display:inline-block;margin: 0;"/> ) 对角线上的非零元素分别为 <img src="https://math.now.sh?inline=%5Clambda_%7B1%7D%2C%20%5Clambda_%7B2%7D%2C%20%5Cldots%2C%20%5Clambda_%7Bk%7D" style="display:inline-block;margin: 0;"/> （因为  <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%5Cleft%28%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%5Cright%29%3D%5Coperatorname%7Brank%7D%5Cleft(%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%5Cright)%3D%5Coperatorname%7Brank%7D(%5Cboldsymbol%7BA%7D)" style="display:inline-block;margin: 0;"/> ），其中，这些特征值也都是非负的（需证明 <img src="https://math.now.sh?inline=AA%5ET" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=A%5ETA" style="display:inline-block;margin: 0;"/> 是半正定的，见下），再令矩阵 <img src="https://math.now.sh?inline=%5C%20Sigma" style="display:inline-block;margin: 0;"/> 对角线上的非零元素分别为 <img src="https://math.now.sh?inline=%5Csigma_%7B1%7D%2C%20%5Csigma_%7B2%7D%2C%20%5Cldots%2C%20%5Csigma_%7Bk%7D" style="display:inline-block;margin: 0;"/> ，则</p>
<p style=""><img src="https://math.now.sh?from=%5Csigma_%7B1%7D%3D%5Csqrt%7B%5Clambda_%7B1%7D%7D%2C%20%5Csigma_%7B2%7D%3D%5Csqrt%7B%5Clambda_%7B2%7D%7D%2C%20%5Cldots%2C%20%5Csigma_%7Bk%7D%3D%5Csqrt%7B%5Clambda_%7Bk%7D%7D%0A" /></p><p>即非零奇异值的平方对应着矩阵 <img src="https://math.now.sh?inline=%5CLambda_%7B1%7D" style="display:inline-block;margin: 0;"/> (或矩阵 <img src="https://math.now.sh?inline=%5CLambda_%7B2%7D" style="display:inline-block;margin: 0;"/> ) 的非零特征值，到这里，我们就不难看出奇异值分解与对称对角化分解（特征分解）的关系了，即我们可以由对称对角化分解得到我们想要的奇异值分解。<br>
为了便于理解，在这里，给定一个大小为 <img src="https://math.now.sh?inline=2%20%5Ctimes%202" style="display:inline-block;margin: 0;"/> 的矩阵 <img src="https://math.now.sh?inline=A%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D4%20%26%204%20%5C%5C%20-3%20%26%203%5Cend%7Barray%7D%5Cright%5D" style="display:inline-block;margin: 0;"/> ，虽然这个矩阵是方阵，但 却不是对称矩阵，我们来看看它的奇异值分解是怎样的。<br>
由 <img src="https://math.now.sh?inline=A%20A%5E%7BT%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D32%20%26%200%20%5C%5C%200%20%26%2018%5Cend%7Barray%7D%5Cright%5D" style="display:inline-block;margin: 0;"/> 进行对称对角化分解，得到特征值为 <img src="https://math.now.sh?inline=%5Clambda_%7B1%7D%3D32%20%EF%BC%8C%20%5Clambda_%7B2%7D%3D18" style="display:inline-block;margin: 0;"/> ，相应地，特征向量 为 <img src="https://math.now.sh?inline=%5Cvec%7Bp%7D_%7B1%7D%3D%281%2C0%29%5E%7BT%7D%20%EF%BC%8C%20%5Cvec%7Bp%7D_%7B2%7D%3D(0%2C1)%5E%7BT%7D" style="display:inline-block;margin: 0;"/>; 由 <img src="https://math.now.sh?inline=A%5E%7BT%7D%20A%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D25%20%26%207%20%5C%5C%207%20%26%2025%5Cend%7Barray%7D%5Cright%5D" style="display:inline-block;margin: 0;"/> 进行对称对角化分解，得到特征值为 <img src="https://math.now.sh?inline=%5Clambda_%7B1%7D%3D32%20%EF%BC%8C%20%5Clambda_%7B2%7D%3D18%20%EF%BC%8C" style="display:inline-block;margin: 0;"/> 相应地，特征向量为 <img src="https://math.now.sh?inline=%5Cvec%7Bq%7D_%7B1%7D%3D%5Cleft%28%5Cfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%2C%20%5Cfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%5Cright%29%5E%7BT%7D%20%EF%BC%8C%20%5Cvec%7Bq%7D_%7B2%7D%3D%5Cleft(-%5Cfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%2C%20%5Cfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%5Cright)%5E%7BT%7D" style="display:inline-block;margin: 0;"/> 。取 <img src="https://math.now.sh?inline=%5CSigma%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D4%20%5Csqrt%7B2%7D%20%26%200%20%5C%5C%200%20%26%203%20%5Csqrt%7B2%7D%5Cend%7Barray%7D%5Cright%5D" style="display:inline-block;margin: 0;"/> ，则矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的奇异值分解为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26A%3DP%20%5CSigma%20Q%5E%7BT%7D%3D%5Cleft%28%5Cvec%7Bp%7D_%7B1%7D%2C%20%5Cvec%7Bp%7D_%7B2%7D%5Cright%29%20%5CSigma%5Cleft(%5Cvec%7Bq%7D_%7B1%7D%2C%20%5Cvec%7Bq%7D_%7B2%7D%5Cright)%5E%7BT%7D%20%5C%5C%0A%26%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A1%20%26%200%20%5C%5C%0A0%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A4%20%5Csqrt%7B2%7D%20%26%200%20%5C%5C%0A0%20%26%203%20%5Csqrt%7B2%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%20%26%20%5Cfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%20%5C%5C%0A-%5Cfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%20%26%20%5Cfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A4%20%26%204%20%5C%5C%0A-3%20%26%203%0A%5Cend%7Barray%7D%5Cright%5D%0A%5Cend%7Baligned%7D%0A" /></p><p>如果 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 是一个<strong>对称方阵</strong>，则 <img src="https://math.now.sh?inline=AA%5ET%3DA%5ETA" style="display:inline-block;margin: 0;"/> ，此时左奇异向量和右奇异向量构成的矩阵也是相等的，即 <img src="https://math.now.sh?inline=P%3DQ" style="display:inline-block;margin: 0;"/> 。更为神奇的是，<strong>对称方阵的奇异值分解与特征分解结果相同</strong>，证明见下。</p>
<h3 id="证明：矩阵-A-A-T-和矩阵-A-T-A-的非零特征值相同">证明：矩阵 <img src="https://math.now.sh?inline=A%20A%5E%7BT%7D" style="display:inline-block;margin: 0;"/> 和矩阵 <img src="https://math.now.sh?inline=A%5E%7BT%7D%20A" style="display:inline-block;margin: 0;"/> 的非零特征值相同</h3>
<p>下面这段话来自网络<a href="https://math.stackexchange.com/questions/1249497/largest-eigenvalues-of-aa-equals-to-aa">^4</a></p>
<blockquote>
<p>For any <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> and <img src="https://math.now.sh?inline=n%20%5Ctimes%20m" style="display:inline-block;margin: 0;"/> matrices <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> and <img src="https://math.now.sh?inline=B" style="display:inline-block;margin: 0;"/>, the nonzero eigenvalues of <img src="https://math.now.sh?inline=A%20B" style="display:inline-block;margin: 0;"/> and <img src="https://math.now.sh?inline=B%20A" style="display:inline-block;margin: 0;"/> are the same. Namely, if <img src="https://math.now.sh?inline=A%20B%20v%3D%5Clambda%20v" style="display:inline-block;margin: 0;"/> with <img src="https://math.now.sh?inline=%5Clambda%20%5Cneq%200" style="display:inline-block;margin: 0;"/> and <img src="https://math.now.sh?inline=v%20%5Cneq%200" style="display:inline-block;margin: 0;"/>, then <img src="https://math.now.sh?inline=B%20v%20%5Cneq%200" style="display:inline-block;margin: 0;"/> （因为 <img src="https://math.now.sh?inline=A%20B%20v%3D%5Clambda%20v%20%5Cneq%200" style="display:inline-block;margin: 0;"/> ，如果 <img src="https://math.now.sh?inline=B%20v%20%3D%200" style="display:inline-block;margin: 0;"/>，则 <img src="https://math.now.sh?inline=ABv%20%3D%200" style="display:inline-block;margin: 0;"/>，与原条件相悖，因此  <img src="https://math.now.sh?inline=B%20v%20%5Cneq%200" style="display:inline-block;margin: 0;"/>  ）and <img src="https://math.now.sh?inline=B%20A%28B%20v%29%3DB(A%20B%20v)%3D%5Clambda%20B%20v" style="display:inline-block;margin: 0;"/>  ，即 <img src="https://math.now.sh?inline=%5Clambda" style="display:inline-block;margin: 0;"/> 同样为 <img src="https://math.now.sh?inline=BA" style="display:inline-block;margin: 0;"/> 的特征值，因此 <img src="https://math.now.sh?inline=AB" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=BA" style="display:inline-block;margin: 0;"/> 的非零特征值相同。</p>
</blockquote>
<h3 id="证明：矩阵-A-A-T-和矩阵-A-T-A-半正定">证明：矩阵 <img src="https://math.now.sh?inline=A%20A%5E%7BT%7D" style="display:inline-block;margin: 0;"/> 和矩阵 <img src="https://math.now.sh?inline=A%5E%7BT%7D%20A" style="display:inline-block;margin: 0;"/> 半正定</h3>
<p>首先，证明  <img src="https://math.now.sh?inline=A%5E%7BT%7D%20A" style="display:inline-block;margin: 0;"/> 半正定 ，证明如下：</p>
<p style=""><img src="https://math.now.sh?from=x%5E%7BT%7D%5Cleft%28A%5E%7BT%7D%20A%5Cright%29%20x%3D%5Cleft(x%5E%7BT%7D%20A%5E%7BT%7D%5Cright)(A%20x)%3D(A%20x)%5E%7BT%7D(A%20x)%20%5Cgeq%200%0A" /></p><p>同理，可证  <img src="https://math.now.sh?inline=A%20A%5E%7BT%7D" style="display:inline-block;margin: 0;"/> 半正定。</p>
<h3 id="证明：对称方阵的奇异值分解与特征分解结果相同">证明：对称方阵的奇异值分解与特征分解结果相同</h3>
<p>当 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 为对称方阵时，<img src="https://math.now.sh?inline=AA%5ET%3DA%5ETA%20%3D%20A%5E2" style="display:inline-block;margin: 0;"/> 。</p>
<p>假设 <img src="https://math.now.sh?inline=%5Clambda" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=u" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的一个特征值和相应的特征方程，此时存在：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26A%5E%7B2%7D%20u%20%5C%5C%0A%26%3DA%28Au%29%20%5C%5C%0A%26%3DA(%5Clambda%20u)%20%5C%5C%0A%26%3D%5Clambda%20A%20u%20%5C%5C%0A%26%3D%5Clambda%5E2%20u%20%5C%5C%20%0A%5Cend%7Baligned%7D%0A" /></p><p>因此， <img src="https://math.now.sh?inline=%5Clambda%5E2" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=u" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=A%5E2" style="display:inline-block;margin: 0;"/> 的特征值和特征向量。</p>
<p>因此，此时，<img src="https://math.now.sh?inline=P%2C%20Q" style="display:inline-block;margin: 0;"/> 为特征分解的特征向量矩阵，而 <img src="https://math.now.sh?inline=%5CSigma" style="display:inline-block;margin: 0;"/> 为特征值组成的对角矩阵。也就是说，对称方阵的奇异值分解与特征分解结果相同</p>
<h1>PCA 预处理</h1>
<p>在使用PCA分析前，我们需要先进行<strong>特征缩放</strong>。</p>
<blockquote>
<ol>
<li>Let <img src="https://math.now.sh?inline=%5Cmu%3D%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/>.</li>
<li>Replace each <img src="https://math.now.sh?inline=x%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> with <img src="https://math.now.sh?inline=x%5E%7B%28i%29%7D-%5Cmu" style="display:inline-block;margin: 0;"/>.</li>
<li>Let <img src="https://math.now.sh?inline=%5Csigma_%7Bj%7D%5E%7B2%7D%3D%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%7D%5Cleft%28x_%7Bj%7D%5E%7B(i%29%7D%5Cright)%5E%7B2%7D" style="display:inline-block;margin: 0;"/></li>
<li>Replace each <img src="https://math.now.sh?inline=x_%7Bj%7D%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> with <img src="https://math.now.sh?inline=x_%7Bj%7D%5E%7B%28i%29%7D%20%2F%20%5Csigma_%7Bj%7D" style="display:inline-block;margin: 0;"/>.</li>
</ol>
</blockquote>
<p>前两步将均值改为 0，后两步将方差均调整为1，使得不同特征具有相同的取值范围 ( “scale”) 。如果你的特征本身就已经是范围一致，那就不用进行后两步，举个例子，假如你的输入特征是图像像素的灰度，那么你的特征取值都是 <img src="https://math.now.sh?inline=%5C%7B0%2C1%2C%20%5Cldots%2C%20255%5C%7D" style="display:inline-block;margin: 0;"/> ，那么就不需要对范围做处理。</p>
<h1>PCA 直观解释</h1>
<p>吴老师说 PCA 分析结果可以有八九种解释的方式，但是我知道的只有两种。</p>
<p>第一种解释方式是找到一个超平面，使得样本点在这个超平面上尽可能分开，也就是投影点的方差尽可能大。如下图，叉形点是二维空间的样本点，我们想找到某个单位向量 <img src="https://math.now.sh?inline=u" style="display:inline-block;margin: 0;"/> ，使得数据投影到  <img src="https://math.now.sh?inline=u" style="display:inline-block;margin: 0;"/> 方向的点的方差最大化。</p>
<p>第二种解释是我们希望所有的样本到这个超平面的距离足够近（所有样本点到超平面距离的平方和最小），对应着下图的虚线。</p>
<p><img src="1.png" alt=""></p>
<h1>推导第一主成分的方向</h1>
<p>这里就是说，如果我们就像上面图中一样，找一个单位向量 <img src="https://math.now.sh?inline=u" style="display:inline-block;margin: 0;"/> 构成的一条直线方向，使得 数据投影到  <img src="https://math.now.sh?inline=u" style="display:inline-block;margin: 0;"/> 方向的点的方差最大化。这里设样本数为 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> ，特征数为 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/>，我们知道给定一个单位向量 <img src="https://math.now.sh?inline=u" style="display:inline-block;margin: 0;"/> 和某个点 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 投射到 <img src="https://math.now.sh?inline=u" style="display:inline-block;margin: 0;"/> 上投影点的长度为 <img src="https://math.now.sh?inline=x%5E%7BT%7Du" style="display:inline-block;margin: 0;"/> （内积的性质）。我们上面提到了最大化投影点的方差，因此，我们需要最大化下式<a href="https://www.bilibili.com/video/BV1EW411R7g6?p=14">^5</a>：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cmax%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%28x%5E%7B(i%29%5E%7BT%7D%7D%20u%5Cright)%5E%7B2%7D%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20(u%5E%7BT%7D%20x%5E%7B(i)%7D)%20(x%5E%7B(i)%5E%7BT%7D%7D%20u)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20u%5E%7BT%7D%20x%5E%7B(i)%7D%20x%5E%7B(i)%5E%7BT%7D%7D%20u%20%5C%5C%0A%26%3Du%5E%7BT%7D%5Cleft(%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B(i)%7D%20x%5E%7B(i)%5E%7BT%7D%7D%5Cright)%20u%20%5C%5C%0A%5C%5C%0A%26%20s.t.%20%5Cquad%20%5C%7C%5Cmu%5C%7C_%7B2%7D%20%3D%201%0A%5Cend%7Baligned%7D%0A" /></p><p>这里，一个隐含的性质是，投影的点的均值也为 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B0%7D" style="display:inline-block;margin: 0;"/> ，证明如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%28x%5E%7B(i%29%5E%7BT%7D%7D%20u%5Cright)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft(x%5E%7B(i)%5E%7BT%7D%7D%20%5Cright)%20u%20%5C%5C%0A%26%3D%200u%20%5Cquad%20%5Cbecause%20x%E8%BF%9B%E8%A1%8C%E4%BA%86%E4%B8%AD%E5%BF%83%E5%8C%96%EF%BC%8C%20%E5%9D%87%E5%80%BC%E4%B8%BA%200%5C%5C%0A%26%3D0%0A%5Cend%7Baligned%7D%0A" /></p><p>我们发现这个解为 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 的协方差矩阵 <img src="https://math.now.sh?inline=%5CSigma%3D%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B%28i%29%7D%7Bx%7D%5E%7B(i)%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/> 的 <strong>主特征值(principal eigenvector)</strong>  （特征值中模最大的特征值称为主特征值，相应的特征向量称为主特征向量）。</p>
<p><strong>证明</strong>：我们可以通过构建拉格朗日乘子式来求解上面的问题：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AL%28u%2C%20%5Clambda%29%20%26%3Du%5E%7BT%7D%20%5CSigma%20u-%5Clambda%5Cleft(u%5E%7BT%7D%20u-1%5Cright)%20%5C%5C%0A%26%3Du%5E%7BT%7D%20%5CSigma%20u-%5Clambda%5Cleft(u%5E%7BT%7D%20I%20u-1%5Cright)%20%5C%5C%0A%5Cnabla_%7Bu%7D%20L%20%26%3D%5Cleft(%5CSigma%2B%5CSigma%5E%7BT%7D%5Cright)%20u-%5Clambda%5Cleft(I%2BI%5E%7BT%7D%5Cright)%20u%20%5Cquad%20%5Cbecause%20%5Cfrac%7B%5Cpartial%5Cleft(%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BX%7D%5Cright)%7D%7B%5Cpartial%20%5Cboldsymbol%7BX%7D%7D%3D%5Cleft(%5Cboldsymbol%7BA%7D%2B%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%5Cright)%20%5Cboldsymbol%7BX%7D%20%5C%5C%0A%26%3D2(%5CSigma%20u-%5Clambda%20u)%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，下式成立，即 <img src="https://math.now.sh?inline=u%0A" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Clambda" style="display:inline-block;margin: 0;"/> 分别为 <img src="https://math.now.sh?inline=%5CSigma" style="display:inline-block;margin: 0;"/> 的特征向量和特征值。</p>
<p style=""><img src="https://math.now.sh?from=%5CSigma%20u%3D%5Clambda%20u%0A" /></p><p>代入原式，得到我们要找的特征向量 <img src="https://math.now.sh?inline=u" style="display:inline-block;margin: 0;"/> 就是<strong>主特征向量</strong>。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Coperatorname%7Bmax%7D%5Cleft%28u%5E%7BT%7D%20%5CSigma%20u%5Cright%29%20%26%20%5C%5C%0A%3D%26%20%5Cmax%20%5Cleft(u%5E%7BT%7D%20%5Clambda%20u%5Cright)%20%5C%5C%0A%3D%26%20%5Cmax%20(%5Clambda)%0A%5Cend%7Baligned%7D%0A" /></p><p>于是，我们得到投影数据最佳的一维子空间，也就是第一主成分。</p>
<p>下面，我们将其一般化，推导 PCA 前 <img src="https://math.now.sh?inline=n'" style="display:inline-block;margin: 0;"/>个主成分 。</p>
<h1>PCA一般推导</h1>
<p>推导过程主要来自于西瓜书和南瓜书[^6][^7]。</p>
<h2 id="最小投影距离">最小投影距离</h2>
<p>假设 <img src="https://math.now.sh?inline=%5Cmathrm%7Bm%7D" style="display:inline-block;margin: 0;"/> 个 <img src="https://math.now.sh?inline=%5Cmathrm%7Bn%7D" style="display:inline-block;margin: 0;"/> 维数据 <img src="https://math.now.sh?inline=%5C%7Bx%5E%7B%281%29%7D%2C%20x%5E%7B(2)%7D%2C%20%5Cldots%2C%20x%5E%7B(m)%7D%5C%7D" style="display:inline-block;margin: 0;"/> 都已经进行了中心化，即 <img src="https://math.now.sh?inline=%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B%28i%29%7D%3D0" style="display:inline-block;margin: 0;"/> 。经过投影变换后得到的新坐标系为 <img src="https://math.now.sh?inline=%5Cleft%5C%7Bw_%7B1%7D%2C%20w_%7B2%7D%2C%20%5Cldots%2C%20w_%7Bn%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/>, 其中 <img src="https://math.now.sh?inline=w_%7Bi%7D" style="display:inline-block;margin: 0;"/> 是标准正交基向量 (<img src="https://math.now.sh?inline=n%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 维向量)，即 <img src="https://math.now.sh?inline=%5C%7Cw_%7Bi%7D%5C%7C_%7B2%7D%3D1%2C%20w_%7Bi%7D%5E%7BT%7D%20w_%7Bj%7D%3D0" style="display:inline-block;margin: 0;"/> 。</p>
<p>如果我们将数据从 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 维降到 <img src="https://math.now.sh?inline=n%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 维，即丟弃新坐标系中的部分坐标，则新的坐标系为 <img src="https://math.now.sh?inline=%5Cleft%5C%7Bw_%7B1%7D%2C%20w_%7B2%7D%2C%20%5Cldots%2C%20w_%7Bn%5E%7B%5Cprime%7D%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/>。样本点 <img src="https://math.now.sh?inline=x%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> 在 <img src="https://math.now.sh?inline=n%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 维坐标系中的投影为: <img src="https://math.now.sh?inline=z%5E%7B%28i%29%7D%3D%5Cleft(z_%7B1%7D%5E%7B(i)%7D%2C%20z_%7B2%7D%5E%7B(i)%7D%2C%20%5Cldots%2C%20z_%7Bn%5E%7B%5Cprime%7D%7D%5E%7B(i)%7D%5Cright)%5E%7BT%7D" style="display:inline-block;margin: 0;"/>. 其中， <img src="https://math.now.sh?inline=z_%7Bj%7D%5E%7B%28i%29%7D%3Dw_%7Bj%7D%5E%7BT%7D%20x%5E%7B(i)%7D" style="display:inline-block;margin: 0;"/> 是  <img src="https://math.now.sh?inline=x%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> 在低维坐标系里第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 维的坐标。</p>
<p>如果我们用 <img src="https://math.now.sh?inline=z%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> 来恢复原始数据 <img src="https://math.now.sh?inline=x%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/>, 则得到的恢复数据 <img src="https://math.now.sh?inline=%5Chat%7Bx%7D%5E%7B%28i%29%7D%3D%5Csum_%7Bj%3D1%7D%5E%7Bn%5E%7B%5Cprime%7D%7D%20z_%7Bj%7D%5E%7B(i)%7D%20w_%7Bj%7D%3DW%20z%5E%7B(i)%7D" style="display:inline-block;margin: 0;"/>,  其中， <strong><img src="https://math.now.sh?inline=W" style="display:inline-block;margin: 0;"/> 为标准正交基组成的 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n'" style="display:inline-block;margin: 0;"/> 矩阵</strong>。</p>
<p style=""><img src="https://math.now.sh?from=W%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D%0A%7C%20%26%20%7C%20%26%20%5Cvdots%20%26%20%7C%20%5C%5C%0Aw_%7B1%7D%20%26%20w_%7B2%7D%20%26%20%5Cvdots%20%26%20w_%7Bn'%7D%20%5C%5C%0A%7C%20%26%20%7C%20%26%20%5Cvdots%20%26%20%7C%0A%5Cend%7Barray%7D%5Cright%5D%5C%5C%0A" /></p><p>带入上式，易知，<img src="https://math.now.sh?inline=z%5E%7B%28i%29%7D%3DW%5E%7BT%7D%20x%5E%7B(i)%7D" style="display:inline-block;margin: 0;"/> 。并且存在，<img src="https://math.now.sh?inline=W%5ETW%3DI" style="display:inline-block;margin: 0;"/> ，证明如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26W%5E%7BT%7D%20W%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A-%20w_%7B1%7D%20-%20%5C%5C%0A-%20w_%7B2%7D%20-%20%5C%5C%0A%5Ccdots%20%5C%5C%0A-%20w_%7Bn'%7D%20-%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D%0A%7C%20%26%20%7C%20%26%20%5Cvdots%20%26%20%7C%20%5C%5C%0Aw_%7B1%7D%20%26%20w_%7B2%7D%20%26%20%5Cvdots%20%26%20w_%7Bn'%7D%20%5C%5C%0A%7C%20%26%20%7C%20%26%20%5Cvdots%20%26%20%7C%0A%5Cend%7Barray%7D%5Cright%5D%5C%5C%0A%26%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0Aw_%7B1%7D%20%5Ccdot%20w_%7B1%7D%20%26%20w_%7B1%7D%20%5Ccdot%20w_%7B2%7D%20%26%20%5Ccdots%20%26%20w_%7B1%7D%20%5Ccdot%20w_%7Bn'%7D%20%5C%5C%0Aw_%7B2%7D%20%5Ccdot%20w_%7B1%7D%20%26%20w_%7B2%7D%20%5Ccdot%20w_%7B2%7D%20%26%20%5Ccdots%20%26%20w_%7B2%7D%20%5Ccdot%20w_%7Bn'%7D%20%5C%5C%0A%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%5C%5C%0Aw_%7Bn'%7D%20%5Ccdot%20w_%7B1%7D%20%26%20w_%7Bn'%7D%5Ccdot%20w_%7B2%7D%20%26%20%5Ccdots%20%26%20w_%7Bn'%7D%20%5Ccdot%20w_%7Bn'%7D%0A%5Cend%7Barray%7D%5Cright%5D%5C%5C%0A%5C%5C%0A%26%3DI%20%5Cquad%20%5Cbecause%20%E5%AF%B9%E8%A7%92%E7%BA%BF%E4%B8%BA%E6%A8%A1%E9%95%BF%E5%BA%A6%EF%BC%8C%E9%9D%9E%E5%AF%B9%E8%A7%92%E7%BA%BF%E6%A0%B9%E6%8D%AE%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F%E4%B8%A4%E4%B8%A4%E6%AD%A3%E4%BA%A4%E7%9A%84%E6%80%A7%E8%B4%A8%E5%9D%87%E4%B8%BA0%5C%20%0A%5Cend%7Baligned%7D%0A" /></p><p>现在我们考虑整个样本集，我们莃望所有的样本到这个超平面的距离足够近，即最小化下式:</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%5C%7C%5Chat%7Bx%7D%5E%7B%28i%29%7D-x%5E%7B(i)%7D%5Cright%5C%7C_%7B2%7D%5E%7B2%7D%0A" /></p><p>将这个式子进行整理，可以得到:</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%5C%7C%5Chat%7Bx%7D%5E%7B%28i%29%7D-x%5E%7B(i)%7D%5Cright%5C%7C_%7B2%7D%5E%7B2%7D%20%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%5C%7CW%20z%5E%7B(i)%7D-x%5E%7B(i)%7D%5Cright%5C%7C_%7B2%7D%5E%7B2%7D%20%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft(%5Cmathbf%7BW%7D%20%5Cboldsymbol%7Bz%7D%5E%7B(i)%7D-%5Cboldsymbol%7Bx%7D%5E%7B(i)%7D%5Cright)%5E%7B%5Cmathrm%7BT%7D%7D%5Cleft(%5Cmathbf%7BW%7D%20%5Cboldsymbol%7Bz%7D%5E%7B(i)%7D-%5Cboldsymbol%7Bx%7D%5E%7B(i)%7D%5Cright)%20%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft(%5Cboldsymbol%7Bz%7D%5E%7B(i)T%7D%20%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BW%7D%20%5Cboldsymbol%7Bz%7D%5E%7B(i)%7D-%5Cboldsymbol%7Bz%7D%5E%7B(i)T%7D%20%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7Bx%7D%5E%7B(i)%7D-%5Cboldsymbol%7Bx%7D%5E%7B(i)T%7D%20%5Cmathbf%7BW%7D%20%5Cboldsymbol%7Bz%7D%5E%7B(i)%7D%2B%5Cboldsymbol%7Bx%7D%5E%7B(i)T%7D%20%5Cboldsymbol%7Bx%7D%5E%7B(i)%7D%5Cright)%20%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft(%5Cboldsymbol%7Bz%7D%5E%7B(i)T%7D%20%5Cboldsymbol%7Bz%7D%5E%7B(i)%7D-2%20%5Cboldsymbol%7Bz%7D%5E%7B(i)T%7D%20%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7Bx%7D%5E%7B(i)%7D%2B%5Cboldsymbol%7Bx%7D%5E%7B(i)T%7D%20%5Cboldsymbol%7Bx%7D%5E%7B(i)%7D%5Cright)%20%5Cquad%20%5Cbecause%20%5Cboldsymbol%7Bz%7D%5E%7B(i)T%7D%20%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7Bx%7D%5E%7B(i)%7D%20%5Ctext%7B%20%E5%92%8C%20%7D%20%5Cboldsymbol%7Bx%7D%5E%7B(i)T%7D%20%5Cmathbf%7BW%7D%20%5Cboldsymbol%7Bz%7D%5E%7B(i)%7D%20%E4%BA%92%E4%B8%BA%E8%BD%AC%E7%BD%AE%E4%B8%94%E4%B8%BA%E6%A0%87%E9%87%8F%EF%BC%8C%E5%9B%A0%E6%AD%A4%E4%BA%8C%E8%80%85%E7%9B%B8%E7%AD%89%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20z%5E%7B(i)%20T%7D%20z%5E%7B(i)%7D-2%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20z%5E%7B(i)%20T%7D%20z%5E%7B(i)%7D%2B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B(i)%20T%7D%20x%5E%7B(i)%7D%20%5C%5C%0A%26%3D-%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20z%5E%7B(i)%20T%7D%20z%5E%7B(i)%7D%2B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B(i)%20T%7D%20x%5E%7B(i)%7D%20%5C%5C%0A%26%3D-%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Coperatorname%7Btr%7D%20%5Cleft(z%5E%7B(i)%7D%20z%5E%7B(i)%20T%7D%5Cright)%2B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B(i)%20T%7D%20x%5E%7B(i)%7D%20%5Cquad%20%5Cbecause%20%5Coperatorname%7Btr%7D%20%5Cleft(z%5E%7B(i)%7D%20z%5E%7B(i)%20T%7D%5Cright)%20%3D%20z%5E%7B(i)%20T%7D%20z%5E%7B(i)%7D%5C%5C%0A%26%3D-%20%5Coperatorname%7Btr%7D%20%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20z%5E%7B(i)%7D%20z%5E%7B(i)%20T%7D%5Cright)%2B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B(i)%20T%7D%20x%5E%7B(i)%7D%20%5C%5C%0A%26%3D-%20%5Coperatorname%7Btr%7D%20%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20W%5E%7BT%7D%20x%5E%7B(i)%7D%20x%5E%7B(i)T%7D%20W%20%20%5Cright)%2B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B(i)%20T%7D%20x%5E%7B(i)%7D%20%5C%5C%0A%26%3D-%5Coperatorname%7Btr%7D%5Cleft(W%5E%7BT%7D%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B(i)%7D%20x%5E%7B(i)%20T%7D%5Cright)%20W%5Cright)%2B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B(i)%20T%7D%20x%5E%7B(i)%7D%20%5C%5C%0A%26%3D-%5Coperatorname%7Btr%7D%5Cleft(W%5E%7BT%7D%20X%5E%7BT%7D%20X%20W%5Cright)%2B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B(i)%20T%7D%20x%5E%7B(i)%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>注意到 <img src="https://math.now.sh?inline=%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B%28i%29%7D%20x%5E%7B(i)%20T%7D" style="display:inline-block;margin: 0;"/> 是数据集的协方差矩阵（从协方差矩阵准取定义看，这个公式少了 <img src="https://math.now.sh?inline=1%2Fm" style="display:inline-block;margin: 0;"/> ，但是对我们这里推导无影响，下同），可以写成<strong>设计矩阵</strong>的格式（行是样本，列是特征，因此 <strong><img src="https://math.now.sh?inline=X" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵</strong>）。而 <img src="https://math.now.sh?inline=%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B%28i%29%20T%7D%20x%5E%7B(i)%7D" style="display:inline-block;margin: 0;"/> 是一个常量。</p>
<p>最小化上式等价于:</p>
<p style=""><img src="https://math.now.sh?from=%5Cunderbrace%7B%5Carg%20%5Cmin%20%7D_%7BW%7D-%5Coperatorname%7Btr%7D%5Cleft%28W%5E%7BT%7D%20X%5E%7BT%7D%20X%20W%5Cright%29%20%5C%5C%20%5Ctext%20%7B%20s.t.%20%7D%20W%5E%7BT%7D%20W%3DI%0A" /></p><p>构建拉格朗日函数如下<a href="%E3%80%8A%E5%8D%97%E7%93%9C%E4%B9%A6%E3%80%8B">^8</a> ，这里拉格朗日乘子矩阵  <img src="https://math.now.sh?inline=%5CTheta" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=n'%20%5Ctimes%20n'" style="display:inline-block;margin: 0;"/> 的矩阵，与约束条件维度相同</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AL%28%5Cmathbf%7BW%7D%2C%20%5CTheta%29%20%26%3D-%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%5Cright)%2B%5Cleft%5Clangle%5CTheta%2C%20%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BW%7D-%5Cmathbf%7BI%7D%5Cright%5Crangle%20%5Cquad%20%5Cbecause%20%E8%BF%99%E9%87%8C%E6%98%AF%E4%B8%A4%E4%B8%AA%E7%9F%A9%E9%98%B5%E7%9A%84%E5%86%85%E7%A7%AF%EF%BC%8C%E7%AD%89%E4%BA%8E%E4%B8%A4%E4%B8%AA%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%90%8C%E4%BD%8D%E7%BD%AE%E5%85%83%E7%B4%A0%E4%B9%98%E7%A7%AF%E4%B9%8B%E5%92%8C%EF%BC%8C%E5%8F%AF%E7%94%A8%E8%BF%B9%E5%87%BD%E6%95%B0%E8%A1%A8%E7%A4%BA%5C%5C%0A%26%3D-%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%5Cright)%2B%5Coperatorname%7Btr%7D%5Cleft(%5CTheta%5E%7B%5Cmathrm%7BT%7D%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BW%7D-%5Cmathbf%7BI%7D%5Cright)%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>若此时仅考虑约束 <img src="https://math.now.sh?inline=w_%7Bi%7D%5E%7B%5Cmathrm%7BT%7D%7D%20w_%7Bi%7D%3D1" style="display:inline-block;margin: 0;"/> ，即只考虑 <img src="https://math.now.sh?inline=W%5ETW" style="display:inline-block;margin: 0;"/> 的对角线元素的约束，此时拉格朗日乘子矩阵 <img src="https://math.now.sh?inline=%5CTheta" style="display:inline-block;margin: 0;"/> 为<strong>对角矩阵</strong>，令新的拉格朗日乘子矩阵为 <img src="https://math.now.sh?inline=%5CLambda%3D%5Coperatorname%7Bdiag%7D%5Cleft%28%5Clambda_%7B1%7D%2C%20%5Clambda_%7B2%7D%2C%20%5Cldots%2C%20%5Clambda_%7Bn%5E%7B%5Cprime%7D%7D%5Cright%29" style="display:inline-block;margin: 0;"/> , 此时的拉格朗日函数为</p>
<p style=""><img src="https://math.now.sh?from=L%28%5Cmathbf%7BW%7D%2C%20%5CLambda%29%3D-%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%5Cright)%2B%5Coperatorname%7Btr%7D%5Cleft(%5CLambda%5E%7B%5Cmathrm%7BT%7D%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BW%7D-%5Cmathbf%7BI%7D%5Cright)%5Cright)%0A" /></p><p>对拉格朗日函数关于 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D" style="display:inline-block;margin: 0;"/> 求导可得</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cfrac%7B%5Cpartial%20L%28%5Cmathbf%7BW%7D%2C%20%5CLambda%29%7D%7B%5Cpartial%20%5Cmathbf%7BW%7D%7D%20%26%3D%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Cmathbf%7BW%7D%7D%5Cleft%5B-%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%5Cright)%2B%5Coperatorname%7Btr%7D%5Cleft(%5CLambda%5E%7B%5Cmathrm%7BT%7D%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BW%7D-%5Cmathbf%7BI%7D%5Cright)%5Cright)%5Cright%5D%20%5C%5C%0A%26%3D-%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Cmathbf%7BW%7D%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%5Cright)%2B%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Cmathbf%7BW%7D%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5CLambda%5E%7B%5Cmathrm%7BT%7D%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BW%7D-%5Cmathbf%7BI%7D%5Cright)%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>由矩阵微分公式 <img src="https://math.now.sh?inline=%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Cmathbf%7BX%7D%7D%20%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BB%7D%20%5Cmathbf%7BX%7D%5Cright%29%3D%5Cmathbf%7BB%7D%20%5Cmathbf%7BX%7D%2B%5Cmathbf%7BB%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%2C%20%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Cmathbf%7BX%7D%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BB%20X%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%5Cright)%3D%5Cmathbf%7BX%20B%7D%5E%7B%5Cmathrm%7BT%7D%7D%2B%5Cmathbf%7BX%20B%7D" style="display:inline-block;margin: 0;"/> 可得</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cfrac%7B%5Cpartial%20L%28%5Cmathbf%7BW%7D%2C%20%5CLambda%29%7D%7B%5Cpartial%20%5Cmathbf%7BW%7D%7D%20%26%3D-2%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%2B%5Cmathbf%7BW%7D%20%5CLambda%2B%5Cmathbf%7BW%7D%20%5CLambda%5E%7B%5Cmathrm%7BT%7D%7D%20%5C%5C%0A%26%3D-2%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%2B%5Cmathbf%7BW%7D%5Cleft(%5CLambda%2B%5CLambda%5E%7B%5Cmathrm%7BT%7D%7D%5Cright)%20%5C%5C%0A%26%3D-2%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%2B2%20%5Cmathbf%7BW%7D%20%5CLambda%0A%5Cend%7Baligned%7D%0A" /></p><p>令 <img src="https://math.now.sh?inline=%5Cfrac%7B%5Cpartial%20L%28%5Cmathbf%7BW%7D%2C%20%5CLambda%29%7D%7B%5Cpartial%20%5Cmathbf%7BW%7D%7D%3D0" style="display:inline-block;margin: 0;"/> 可得</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A-2%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%2B2%20%5Cmathbf%7BW%7D%20%5CLambda%20%26%3D%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%20%26%3D%5Cmathbf%7BW%7D%20%5CLambda%0A%5Cend%7Baligned%7D%0A" /></p><p>将 <img src="https://math.now.sh?inline=%5Cmathrm%7BW%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5CLambda" style="display:inline-block;margin: 0;"/> 展开可得</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%5Cboldsymbol%7Bw%7D_%7Bi%7D%3D%5Clambda_%7Bi%7D%20%5Cboldsymbol%7Bw%7D_%7Bi%7D%2C%20%5Cquad%20i%3D1%2C2%2C%20%5Cldots%2C%20n%5E%7B%5Cprime%7D%0A" /></p><blockquote>
<p>显然, 此式为矩阵特征值和特征向量的定义式, 其中 <img src="https://math.now.sh?inline=%5Clambda_%7Bi%7D%2C%20w_%7Bi%7D" style="display:inline-block;margin: 0;"/> 分别表示矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的特征值和单位特征向量。由于以上是仅考虑约束 <img src="https://math.now.sh?inline=w_%7Bi%7D%5E%7B%5Cmathrm%7BT%7D%7D%20w_%7Bi%7D%3D1" style="display:inline-block;margin: 0;"/> 所求得的结果, 而 <img src="https://math.now.sh?inline=w_%7Bi%7D" style="display:inline-block;margin: 0;"/> 还需满足约束 <img src="https://math.now.sh?inline=w_%7Bi%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7Bw%7D_%7Bj%7D%3D0%28i%20%5Cneq%20j%29" style="display:inline-block;margin: 0;"/> 。观察 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的定义可知, <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 是一个实对称矩阵, 实对称矩阵的不同特征值所对应的特征向量之间相互正交, <strong>同一 特征值的不同特征向量可以通过施密特正交化使其变得正交</strong>, 所以通过上式求得的 <img src="https://math.now.sh?inline=w_%7Bi%7D" style="display:inline-block;margin: 0;"/> 可以同时满足约束 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D_%7Bi%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7Bw%7D_%7Bi%7D%3D1%2C%20%5Cboldsymbol%7Bw%7D_%7Bi%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7Bw%7D_%7Bj%7D%3D0%28i%20%5Cneq%20j%29" style="display:inline-block;margin: 0;"/> 。根据拉格朗日乘子法的原理可知, 此时求得的结果仅是最优解的必要条件, 而且 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 有 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个相互正交的单位特征向量, 所以还需要从这 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个特征向量里找出 <img src="https://math.now.sh?inline=n%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 个能使得目标函数 达到最优值的特征向量作为最优解。将 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20W%3D%20W%20%5CLambda" style="display:inline-block;margin: 0;"/> 代人目标函数可得<a href="%E3%80%8A%E5%8D%97%E7%93%9C%E4%B9%A6%E3%80%8B">^9</a></p>
</blockquote>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmin%20_%7B%5Cmathrm%7BW%7D%7D-%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%5Cright%29%20%26%3D%5Cmax%20_%7B%5Cmathbf%7BW%7D%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%5Cright)%20%5C%5C%0A%26%3D%5Cmax%20_%7B%5Cmathbf%7BW%7D%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BW%7D%20%5CLambda%20%5Cright)%20%5C%5C%0A%26%3D%5Cmax%20_%7B%5Cmathbf%7BW%7D%7D%20%5Coperatorname%7Btr%7D%5Cleft(%20%5CLambda%20%5Cright)%20%20%5Cquad%20%5Cbecause%20%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BW%7D%20%3D%20%5Cmathbf%7BI%7D%20%20%5C%5C%0A%26%3D%5Cmax%20_%7B%5Cmathbf%7BW%7D%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%5E%7B%5Cprime%7D%7D%20%5Clambda_%7Bi%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>显然, 此时只需要令 <img src="https://math.now.sh?inline=%5Clambda_%7B1%7D%2C%20%5Clambda_%7B2%7D%2C%20%5Cldots%2C%20%5Clambda_%7Bn%5E%7B%5Cprime%7D%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=w_%7B1%7D%2C%20w_%7B2%7D%2C%20%5Cldots%2C%20w_%7Bn%5E%7B%5Cprime%7D%7D" style="display:inline-block;margin: 0;"/> 分别为矩阵 <img src="https://math.now.sh?inline=%5Cmathrm%7BXX%7D%5E%7B%5Cmathrm%7BT%7D%7D" style="display:inline-block;margin: 0;"/> 的前 <img src="https://math.now.sh?inline=n%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 个最大的特征值和单位特征向量就能使得目标函数达到最优值。</p>
<h2 id="最大投影方差">最大投影方差</h2>
<p>我们知道样本点在超平面上的投影为 <img src="https://math.now.sh?inline=z%5E%7B%28i%29%7D%3DW%5E%7BT%7D%20x%5E%7B(i)%7D" style="display:inline-block;margin: 0;"/> ，首先我们证明投影点的均值同样为 <img src="https://math.now.sh?inline=%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%20%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20z%5E%7B%28i%29%7D%20%5C%5C%0A%3D%26%20%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20W%5E%7BT%7D%20x%5E%7B(i)%7D%20%5C%5C%0A%3D%26%20W%5E%7BT%7D%5Cleft(%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B%5Cleft(i%5Cright)%7D%5Cright)%20%5C%5C%0A%3D%26%20W%5E%7BT%7D%20%5Cboldsymbol%7B0%7D%20%5C%5C%0A%3D%26%20%5Cboldsymbol%7B0%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，投影点的协方差矩阵为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%20%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20z%5E%7B%28i%29%7D%20z%5E%7B(i)%20T%7D%20%5C%5C%0A%3D%26%20%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20W%5E%7BT%7D%20x%5E%7B(i)%7D%20x%5E%7B(i)%20T%7D%20W%20%5C%5C%0A%3D%26%20%5Cfrac%7B1%7D%7Bm%7D%20W%5E%7BT%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft(%20x%5E%7B(i)%7D%20x%5E%7B(i)%20T%7D%20%5Cright)%20W%20%5C%5C%0A%3D%26%20%5Cfrac%7B1%7D%7Bm%7D%20W%5E%7BT%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft(%20x%5E%7B(i)%7D%20x%5E%7B(i)%20T%7D%20%5Cright)%20W%20%5C%5C%0A%3D%26%20%5Cfrac%7B1%7D%7Bm%7D%20W%5E%7BT%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20W%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>投影点的方差为其协方差矩阵的迹，即为 <img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7Bm%7D%20%5Coperatorname%7Btr%7D%5Cleft%28W%5E%7BT%7D%20X%5E%7BT%7D%20X%20W%5Cright%29" style="display:inline-block;margin: 0;"/></p>
<p>于是，此时我们的优化目标为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cunderbrace%7B%5Carg%20%5Cmax%20%7D_%7BW%7D%20%26%20%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%5Cright%29%20%5C%5C%0A%5Ctext%20%7B%20s.t.%20%7D%20%26%20%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BW%7D%3D%5Cmathbf%7BI%7D%0A%5Cend%7Barray%7D%0A" /></p><p>这和上面的最小投影距离的优化目标一致。</p>
<h1>选择合适的 <img src="https://math.now.sh?inline=n'" style="display:inline-block;margin: 0;"/></h1>
<p>当你对协方差矩阵 <img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7Bm%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 进行奇异值分解或特征值分解后，你可以得到总共 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个特征值。这时你可以指定一个阈值 <img src="https://math.now.sh?inline=%5Cmathrm%7Bt%7D" style="display:inline-block;margin: 0;"/>, 这个阈值 <img src="https://math.now.sh?inline=%5Cmathrm%7Bt%7D" style="display:inline-block;margin: 0;"/> 在 <img src="https://math.now.sh?inline=%280%2C1%29" style="display:inline-block;margin: 0;"/> 之间，表示保留的方差比例，一般惯例可选 0.90，0.95 和 0.99。假如我们的 <img src="https://math.now.sh?inline=%5Cmathrm%7Bn%7D" style="display:inline-block;margin: 0;"/> 个特征值为 <img src="https://math.now.sh?inline=%5Clambda_%7B1%7D%20%5Cgeq%20%5Clambda_%7B2%7D%20%5Cgeq%20%5Cldots%20%5Cgeq%20%5Clambda_%7Bn%7D" style="display:inline-block;margin: 0;"/> ，则n’可以通过下式得到:</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bn%5E%7B%5Cprime%7D%7D%20%5Clambda_%7Bi%7D%7D%7B%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Clambda_%7Bi%7D%7D%20%5Cgeq%20t%0A" /></p><p>吴老师提到过这个公式，很多人的博客也提到了这个公式，但是没有告诉你这个公式怎么来的。这个公式在我看来没有这么一目了然，应该给证明过程的。</p>
<p>我思考了半天，才弄懂原理。这个公式蕴含的一个前提是，协方差矩阵所有特征值之和等于样本点的方差。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7BVar%7D%28x%29%20%26%3D%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%5C%7Cx%5E%7B(i)%7D%5Cright%5C%7C%5E%7B2%7D%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(%5Coperatorname%7BCov%7D(x)%5Cright)%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cfrac%7B1%7D%7Bm%7D%20X%5E%7BT%7D%20X%5Cright)%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(Q%20%5CLambda%20Q%5E%7B-1%7D%5Cright)%20%5Cquad%20%5Cbecause%20%E5%AF%B9%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5%E8%BF%9B%E8%A1%8C%E7%89%B9%E5%BE%81%E5%80%BC%E5%88%86%E8%A7%A3%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(Q%5E%7B-1%7D%20Q%20%5CLambda%5Cright)%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D(%5CLambda)%20%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Clambda_%7Bi%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，当你需要计算方差比例的时候，总方差可以通过对所有特征值求和得到，也可以通过对协方差矩阵对角线所有元素求和得到。</p>
<h1>疑问</h1>
<ol>
<li>
<p>为什么对称矩阵就一定可以进行特征值分解（存在 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个线性无关的特征向量），并且其特征向量是一个正交矩阵？</p>
<p>我现在知道这个性质来自于<a href="https://en.wikipedia.org/wiki/Spectral_theorem">谱定理(Spectral theorem)</a>，吴老师说这可能是线性代数中最重要的一个定理，以后有机会再看吧。</p>
</li>
<li>
<p>为什么用 <img src="https://math.now.sh?inline=z%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> 来恢复原始数据 <img src="https://math.now.sh?inline=x%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> 的公式为  <img src="https://math.now.sh?inline=%5Chat%7Bx%7D%5E%7B%28i%29%7D%3D%5Csum_%7Bj%3D1%7D%5E%7Bn%5E%7B%5Cprime%7D%7D%20z_%7Bj%7D%5E%7B(i)%7D%20w_%7Bj%7D%3DW%20z%5E%7B(i)%7D" style="display:inline-block;margin: 0;"/> ？</p>
<p>这种转换其实就是<strong>基变换</strong>，基变换的内容可以看我的博客<a href="https://vincere.fun/posts/6ea65792/">矩阵乘法的内涵和本质</a>。<img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 的标准基为 <img src="https://math.now.sh?inline=%5C%7Be_1%2C%20e_2%2C%20%5Ccdots%2C%20e_n%5C%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个特征向量  <img src="https://math.now.sh?inline=%5Cleft%5C%7Bw_%7B1%7D%2C%20w_%7B2%7D%2C%20%5Cldots%2C%20w_%7Bn%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> 也是<img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 的一组基（为方便称呼，我下面称呼其为”新基“），从”新基“转换到标准基的转移矩阵就是 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D" style="display:inline-block;margin: 0;"/> ，因此如果我们已知某个样本点在”新基“中的坐标为  <img src="https://math.now.sh?inline=z%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> ，其中我们只用前 <img src="https://math.now.sh?inline=n'" style="display:inline-block;margin: 0;"/> 维的信息，等同于我们设 <img src="https://math.now.sh?inline=n'" style="display:inline-block;margin: 0;"/> 维以后的维度的坐标均为 0，因此存在</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7Bx%7D%5E%7B%28i%29%7D%3DW%20z%5E%7B(i)%7D%3D%5Csum_%7Bj%3D1%7D%5E%7Bn%5E%7B%5Cprime%7D%7D%20z_%7Bj%7D%5E%7B(i)%7D%20w_%7Bj%7D%20%2B%20%20%5Csum_%7Bj%3Dn'%2B1%7D%5E%7Bn%7D%200%20%20%5Ctimes%20w_%7Bj%7D%20%3D%5Csum_%7Bj%3D1%7D%5E%7Bn%5E%7B%5Cprime%7D%7D%20z_%7Bj%7D%5E%7B(i)%7D%20w_%7Bj%7D%0A" /></p></li>
<li>
<p>不是很清楚拉格朗日函数的矩阵形式</p>
<p>其实压根就没有什么所谓的矩阵形式的拉格朗日函数，我们采用矩阵的目标是为了方便书写和运算，比如一个线性方程组你直接写出多个等式，你也可以用矩阵表达为 <img src="https://math.now.sh?inline=Ax%3Db" style="display:inline-block;margin: 0;"/> ，二者的内容是一致的。</p>
<p>这里第一次构建拉格朗日乘子式，限制条件是  <img src="https://math.now.sh?inline=W%5E%7BT%7D%20W-I%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> ，如果我们把它写成多个等式的形式，其实就是 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n%20%3D%20n%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 个等式的约束条件，即可以将 <img src="https://math.now.sh?inline=W%5E%7BT%7D%20W-I%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/>  写为下面这种形式：</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%20w_%7Bik%7Dw_%7Bjk%7D%20-1%20%3D%200%2C%20%5Cquad%20%5Ctext%7B%20if%20%7D%20i%3Dj%20%5C%5C%0A%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%20w_%7Bik%7Dw_%7Bjk%7D%20%3D%200%2C%20%5Cquad%20%5Ctext%7B%20if%20%7D%20i%20%5Cneq%20j%20%5C%5C%0Ai%20%3D%201%2C%5Ccdots%2C%20n%3B%20%5Cquad%20j%20%3D%201%2C%5Ccdots%2C%20n%0A" /></p><p>此时构建的拉格朗日乘子式即为下式，后面的一项就是 <img src="https://math.now.sh?inline=n%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 个等式的约束条件，只是表示为迹的形式。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AL%28%5Cmathbf%7BW%7D%2C%20%5CTheta%29%20%26%3D-%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%5Cright)%2B%5Cleft%5Clangle%5CTheta%2C%20%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BW%7D-%5Cmathbf%7BI%7D%5Cright%5Crangle%20%5Cquad%20%5Cbecause%20%E8%BF%99%E9%87%8C%E6%98%AF%E4%B8%A4%E4%B8%AA%E7%9F%A9%E9%98%B5%E7%9A%84%E5%85%83%E7%B4%A0%E4%B9%98%E7%A7%AF%EF%BC%8C%E7%AD%89%E4%BA%8E%E4%B8%A4%E4%B8%AA%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%90%8C%E4%BD%8D%E7%BD%AE%E5%85%83%E7%B4%A0%E4%B9%98%E7%A7%AF%E4%B9%8B%E5%92%8C%EF%BC%8C%E5%8F%AF%E7%94%A8%E8%BF%B9%E5%87%BD%E6%95%B0%E8%A1%A8%E7%A4%BA%5C%5C%0A%26%3D-%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%5Cright)%2B%5Coperatorname%7Btr%7D%5Cleft(%5CTheta%5E%7B%5Cmathrm%7BT%7D%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BW%7D-%5Cmathbf%7BI%7D%5Cright)%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>但是我认为，这里其实没有  <img src="https://math.now.sh?inline=n%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 个等式的约束条件，因为 <img src="https://math.now.sh?inline=W%5E%7BT%7D%20W-I" style="display:inline-block;margin: 0;"/> 是一个对称矩阵，实际上只有 <img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7B2%7Dn%28n%2B1%29" style="display:inline-block;margin: 0;"/> 个等式约束条件（上三角的元素数目），因此这里应该要需要限制   <img src="https://math.now.sh?inline=%5CTheta" style="display:inline-block;margin: 0;"/>  为一个 <strong>对称</strong>矩阵，从而将约束条件数目降为  <img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7B2%7Dn%28n%2B1%29" style="display:inline-block;margin: 0;"/> 。</p>
<p>第二次构建拉格朗日函数时，我们只考虑 <img src="https://math.now.sh?inline=W%5ETW" style="display:inline-block;margin: 0;"/> 的对角线元素的约束，此时只有 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个约束条件，我们将  <img src="https://math.now.sh?inline=%5CTheta" style="display:inline-block;margin: 0;"/> 改为一个对角矩阵 <img src="https://math.now.sh?inline=%5CLambda" style="display:inline-block;margin: 0;"/> 。</p>
</li>
</ol>
<p>[^6]: 《机器学习》- 周志华<br>
[^7]: <a href="https://www.cnblogs.com/pinard/p/6239403.html">https://www.cnblogs.com/pinard/p/6239403.html</a></p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>证明皮尔逊相关系数绝对值小于1</title>
    <url>/posts/e627bd97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>简单记录一下，内容基本来自于<a href="https://brooksj.com/2019/08/09/%E7%9A%AE%E5%B0%94%E9%80%8A%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0%E7%BB%9D%E5%AF%B9%E5%80%BC%E5%B0%8F%E4%BA%8E1%E7%9A%84%E8%AF%81%E6%98%8E/">皮尔逊相关系数绝对值小于1的证明</a></p>
<span id="more"></span>
<h1>皮尔逊相关定义</h1>
<p>总体的相关系数定义为</p>
<p style=""><img src="https://math.now.sh?from=%5Crho_%7BX%2C%20Y%7D%3D%5Cfrac%7B%5Coperatorname%7Bcov%7D%28X%2C%20Y%29%7D%7B%5Csigma_%7BX%7D%20%5Csigma_%7BY%7D%7D%3D%5Cfrac%7BE%5Cleft%5B%5Cleft(X-%5Cmu_%7BX%7D%5Cright)%5Cleft(Y-%5Cmu_%7BY%7D%5Cright)%5Cright%5D%7D%7B%5Csigma_%7BX%7D%20%5Csigma_%7BY%7D%7D%0A" /></p><p>样本的相关系数计算公式为</p>
<p style=""><img src="https://math.now.sh?from=r%3D%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28X_%7Bi%7D-%5Cbar%7BX%7D%5Cright%29%5Cleft(Y_%7Bi%7D-%5Cbar%7BY%7D%5Cright)%7D%7B%5Csqrt%7B%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(X_%7Bi%7D-%5Cbar%7BX%7D%5Cright)%5E%7B2%7D%7D%20%5Csqrt%7B%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(Y_%7Bi%7D-%5Cbar%7BY%7D%5Cright)%5E%7B2%7D%7D%7D%0A" /></p><h1>证明皮尔逊相关绝对值小于1</h1>
<p>如果我们定义 <img src="https://math.now.sh?inline=X_%7Bi%7D-%5Cbar%7BX%7D%3Dx_%7Bi%7D%2C%20Y_%7Bi%7D-%5Cbar%7BY%7D%3Dy_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，由 <img src="https://math.now.sh?inline=x_i" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=y_i" style="display:inline-block;margin: 0;"/> 组成的向量为 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cboldsymbol%7By%7D" style="display:inline-block;margin: 0;"/> ，则样本的相关系数计算公式此时为</p>
<p style=""><img src="https://math.now.sh?from=r%20%3D%20%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20x_%7Bi%7D%20y_%7Bi%7D%7D%7B%5Csqrt%7B%5Cleft%28%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20x_%7Bi%7D%5E%7B2%7D%5Cright%29%7D%5Csqrt%7B%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20y_%7Bi%7D%5E%7B2%7D%5Cright)%7D%7D%0A" /></p><p>根据<a href="https://www.wikiwand.com/zh/%E6%9F%AF%E8%A5%BF-%E6%96%BD%E7%93%A6%E8%8C%A8%E4%B8%8D%E7%AD%89%E5%BC%8F">柯西-施瓦茨不等式</a>，我们有</p>
<p style=""><img src="https://math.now.sh?from=%7C%5Clangle%20%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7By%7D%5Crangle%7C%20%5Cleq%5C%7C%5Cboldsymbol%7Bx%7D%5C%7C%20%5Ccdot%5C%7C%5Cboldsymbol%7By%7D%5C%7C%0A" /></p><p>因此</p>
<p style=""><img src="https://math.now.sh?from=%7C%5Clangle%20%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7By%7D%5Crangle%7C%20%3D%20%5Cleft%7C%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20x_%7Bi%7D%20y_%7Bi%7D%5Cright%7C%20%5Cleq%20%5Csqrt%7B%5Cleft%28%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20x_%7Bi%7D%5E%7B2%7D%5Cright%29%7D%20%5Csqrt%7B%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20y_%7Bi%7D%5E%7B2%7D%5Cright)%7D%20%3D%20%5C%7C%5Cboldsymbol%7Bx%7D%5C%7C%20%5Ccdot%5C%7C%5Cboldsymbol%7By%7D%5C%7C%0A" /></p><p>换句话说，皮尔逊相关系数等于下式</p>
<p style=""><img src="https://math.now.sh?from=r%20%3D%20%5Cfrac%7B%5Clangle%20%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7By%7D%5Crangle%7D%7B%5C%7C%5Cboldsymbol%7Bx%7D%5C%7C%20%5Ccdot%5C%7C%5Cboldsymbol%7By%7D%5C%7C%7D%20%3D%20%5Ccos%28%5Ctheta%29%0A" /></p><p>即可以视为  <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cboldsymbol%7By%7D" style="display:inline-block;margin: 0;"/> 夹角的余弦值。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵乘法的内涵和本质</title>
    <url>/posts/6ea65792/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>理解矩阵乘法的内涵和本质。</p>
<p>下面的内容主要来自于《Linear Algebra with Applications》的第三章 向量空间和第四章 线性变换。[^1]</p>
<span id="more"></span>
<h1>向量空间</h1>
<h2 id="子空间与张成-空间">子空间与张成(空间)</h2>
<p>我们先看子空间的概念。</p>
<p><strong>定义</strong> 若 <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> 为向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 的非空子集, 且 <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> 满足如下条件：</p>
<ul>
<li>对任意标量 <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/>, 若 <img src="https://math.now.sh?inline=x%20%5Cin%20S" style="display:inline-block;margin: 0;"/>, 则 <img src="https://math.now.sh?inline=%5Calpha%20x%20%5Cin%20S" style="display:inline-block;margin: 0;"/>.</li>
<li>若 <img src="https://math.now.sh?inline=x%20%5Cin%20S" style="display:inline-block;margin: 0;"/> 且 <img src="https://math.now.sh?inline=y%20%5Cin%20S" style="display:inline-block;margin: 0;"/>, 则 <img src="https://math.now.sh?inline=x%2By%20%5Cin%20S" style="display:inline-block;margin: 0;"/>.</li>
</ul>
<p>则 <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> 称为 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 的<strong>子空间</strong> (subspace).</p>
<p>也就是说子空间  <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/>  在标量乘法和向量加法的意义上应该是封闭的。</p>
<p>我们再看向量集合的<strong>张成</strong>的概念，如下：</p>
<p><strong>定义</strong> 令 <img src="https://math.now.sh?inline=v_%7B1%7D%2C%20v_%7B2%7D%2C%20%5Ccdots%2C%20v_%7Bn%7D" style="display:inline-block;margin: 0;"/> 为向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 中的向量. <img src="https://math.now.sh?inline=%5Calpha_%7B1%7D%20v_%7B1%7D%2B%5Calpha_%7B2%7D%20v_%7B2%7D%2B%5Ccdots%2B%5Calpha_%7Bn%7D%20v_%7Bn%7D" style="display:inline-block;margin: 0;"/> (其中 <img src="https://math.now.sh?inline=%5Calpha_%7B1%7D" style="display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=%5Calpha_%7B2%7D%2C%20%5Ccdots%2C%20%5Calpha_%7Bn%7D" style="display:inline-block;margin: 0;"/> 为标量) 称为向量 <img src="https://math.now.sh?inline=v_%7B1%7D%2C%20v_%7B2%7D%2C%20%5Ccdots%2C%20v_%7Bn%7D" style="display:inline-block;margin: 0;"/> 的<strong>线性组合</strong> (linear combination).  向量 <img src="https://math.now.sh?inline=v_%7B1%7D" style="display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=v_%7B2%7D%2C%20%5Ccdots%2C%20v_%7Bn%7D" style="display:inline-block;margin: 0;"/> 的所有线性组合构成的集合称为 <img src="https://math.now.sh?inline=v_%7B1%7D%2C%20%5Ccdots%2C%20v_%7Bn%7D" style="display:inline-block;margin: 0;"/> 的<strong>张成</strong> (span). 向量 <img src="https://math.now.sh?inline=v_%7B1%7D%2C%20%5Ccdots%2C%20v_%7Bn%7D" style="display:inline-block;margin: 0;"/> 的张成记 为 <img src="https://math.now.sh?inline=%5Coperatorname%7BSpan%7D%5Cleft%28v_%7B1%7D%2C%20%5Ccdots%2C%20v_%7Bn%7D%5Cright%29" style="display:inline-block;margin: 0;"/>.</p>
<p>易证明，向量组合的张成是向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/>  的一个子空间。如果张成空间等于向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/>  ，此时我们称向量集合 <img src="https://math.now.sh?inline=v_%7B1%7D" style="display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=v_%7B2%7D%2C%20%5Ccdots%2C%20v_%7Bn%7D" style="display:inline-block;margin: 0;"/>  是  <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 的一个<strong>张集</strong>。</p>
<p>举个例子，**基向量 <img src="https://math.now.sh?inline=e_1%2C%20e_2%2C%20e_3" style="display:inline-block;margin: 0;"/> ** 就是 <img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7B3%7D" style="display:inline-block;margin: 0;"/> 的一个张集， <img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7B3%7D" style="display:inline-block;margin: 0;"/> 中任何一个向量 <img src="https://math.now.sh?inline=%28a%2C%20b%2C%20c%29%5E%7BT%7D" style="display:inline-block;margin: 0;"/> 均可以表示为</p>
<p style=""><img src="https://math.now.sh?from=%28a%2C%20b%2C%20c%29%5E%7BT%7D%20%3D%20a%5Cmathbf%7Be_1%7D%20%2B%20b%5Cmathbf%7Be_2%7D%20%2B%20%20c%5Cmathbf%7Be_3%7D%0A" /></p><p>再举个例子，<img src="https://math.now.sh?inline=%5Cleft%5C%7B%281%2C1%2C1%29%5E%7B%5Cmathrm%7BT%7D%7D%2C(1%2C1%2C0)%5E%7B%5Cmathrm%7BT%7D%7D%2C(1%2C0%2C0)%5E%7B%5Cmathrm%7BT%7D%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/>  是不是 <img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7B3%7D" style="display:inline-block;margin: 0;"/> 的一个张集呢？这个问题等价于，对于<img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7B3%7D" style="display:inline-block;margin: 0;"/> 中任何一个向量 <img src="https://math.now.sh?inline=%28a%2C%20b%2C%20c%29%5E%7BT%7D" style="display:inline-block;margin: 0;"/>  是不是都可以表示为这三个向量的线性组合？即总能找到相应的 <img src="https://math.now.sh?inline=%5Calpha_1%2C%20%5Calpha_2%2C%20%5Calpha_3" style="display:inline-block;margin: 0;"/> ，使得下式成立</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0Aa%20%5C%5C%0Ab%20%5C%5C%0Ac%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Calpha_%7B1%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A1%20%5C%5C%0A1%20%5C%5C%0A1%0A%5Cend%7Barray%7D%5Cright%5D%2B%5Calpha_%7B2%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A1%20%5C%5C%0A1%20%5C%5C%0A0%0A%5Cend%7Barray%7D%5Cright%5D%2B%5Calpha_%7B3%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A1%20%5C%5C%0A0%20%5C%5C%0A0%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>你可以轻松证明，这三个向量是 <img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7B3%7D" style="display:inline-block;margin: 0;"/> 的一个张集。</p>
<h2 id="线性相关和线性无关">线性相关和线性无关</h2>
<p><strong>定义</strong> 如果向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 中的向量 <img src="https://math.now.sh?inline=v_%7B1%7D%2C%20v_%7B2%7D%2C%20%5Ccdots%2C%20v_%7Bn%7D" style="display:inline-block;margin: 0;"/> 满足 <img src="https://math.now.sh?inline=c_%7B1%7D%20v_%7B1%7D%2Bc_%7B2%7D%20v_%7B2%7D%2B%5Ccdots%2Bc_%7Bn%7D%20v_%7Bn%7D%3D0" style="display:inline-block;margin: 0;"/> 就可推出所有标量 <img src="https://math.now.sh?inline=c_%7B1%7D%2C%20%5Ccdots%2C%20c_%7Bn%7D" style="display:inline-block;margin: 0;"/> 必为 0 , 则称它们为<strong>线性无关</strong>的 (linearly independent)，反之则称它们是<strong>线性相关</strong>的。</p>
<p>如果一组向量线性相关，那就说明<strong>至少</strong>有一个向量可以表示为其他向量的线性组合。</p>
<h2 id="基和维数">基和维数</h2>
<p><strong>定义</strong> 当且仅当向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 中的向量 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bv%7D_%7B1%7D%2C%20%5Cboldsymbol%7Bv%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cboldsymbol%7Bv%7D_%7Bn%7D" style="display:inline-block;margin: 0;"/> 满足</p>
<ul>
<li><img src="https://math.now.sh?inline=v_%7B1%7D%2C%20%5Ccdots%2C%20v_%7Bn%7D" style="display:inline-block;margin: 0;"/> 线性无关,</li>
<li><img src="https://math.now.sh?inline=v_%7B1%7D%2C%20%5Ccdots%2C%20v_%7Bn%7D" style="display:inline-block;margin: 0;"/> 张成 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/></li>
</ul>
<p>时, 称它们是向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 的<strong>基</strong> (basis)，如果  <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 的一组基含有 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个向量，那么我们称  <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 的**维数 (dimension)**为 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 。</p>
<p>我们称 <img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 的<strong>标准基</strong>为 <img src="https://math.now.sh?inline=%5C%7Be_1%2C%20e_2%2C%20%5Ccdots%2C%20e_n%5C%7D" style="display:inline-block;margin: 0;"/> ，之所以称这个基为标准基，是因为使用这个基表示向量空间  <img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 最为自然。</p>
<p>举个例子， <img src="https://math.now.sh?inline=e_1%2C%20e_2%2C%20e_3" style="display:inline-block;margin: 0;"/> 就是 <img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7B3%7D" style="display:inline-block;margin: 0;"/> 的<strong>标准基</strong>，但是实际上 <img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7B3%7D" style="display:inline-block;margin: 0;"/> 的基有无穷多种取法，比如上面例子中的 <img src="https://math.now.sh?inline=%5Cleft%5C%7B%281%2C1%2C1%29%5E%7B%5Cmathrm%7BT%7D%7D%2C(1%2C1%2C0)%5E%7B%5Cmathrm%7BT%7D%7D%2C(1%2C0%2C0)%5E%7B%5Cmathrm%7BT%7D%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/>  也是 <img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7B3%7D" style="display:inline-block;margin: 0;"/> 的基。</p>
<p>这里定义基时要求线性无关，是因为只有  <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bv%7D_%7B1%7D%2C%20%5Cboldsymbol%7Bv%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cboldsymbol%7Bv%7D_%7Bn%7D" style="display:inline-block;margin: 0;"/>  线性无关时，张集中的向量数目最小，并且向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 才可以<strong>唯一地</strong>用  <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bv%7D_%7B1%7D%2C%20%5Cboldsymbol%7Bv%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cboldsymbol%7Bv%7D_%7Bn%7D" style="display:inline-block;margin: 0;"/> 的 线性组合来表示。反过来说，如果张集的向量之间存在线性相关，那么对于向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/>的每一个向量，你都可以找到张集的多个线性组合来表示这个向量。</p>
<p><strong>定理</strong> 若 <img src="https://math.now.sh?inline=%5Cleft%5C%7Bv_%7B1%7D%2C%20v_%7B2%7D%2C%20%5Ccdots%2C%20v_%7Bn%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> 为向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 的一个张集, 则 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 中的任何 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> ( <img src="https://math.now.sh?inline=m%3En" style="display:inline-block;margin: 0;"/>) 个向量必线性相关.</p>
<p>证 令 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bu%7D_%7B1%7D%2C%20%5Cboldsymbol%7Bu%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cboldsymbol%7Bu%7D_%7Bm%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 中的 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> 个向量, 其中 <img src="https://math.now.sh?inline=m%3En" style="display:inline-block;margin: 0;"/>. 那么, 由于 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bv%7D_%7B1%7D%2C%20%5Cboldsymbol%7Bv%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cboldsymbol%7Bv_%7Bn%7D%7D" style="display:inline-block;margin: 0;"/> 张成 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/>, 我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7Bu%7D_%7Bi%7D%3Da_%7Bi%201%7D%20%5Cboldsymbol%7Bv%7D_%7B1%7D%2Ba_%7Bi%202%7D%20%5Cboldsymbol%7Bv%7D_%7B2%7D%2B%5Ccdots%2Ba_%7Bi%20n%7D%20%5Cboldsymbol%7Bv%7D_%7Bn%7D%2C%20%5Cquad%20i%3D1%2C2%2C%20%5Ccdots%2C%20m%0A" /></p><p>线性组合 <img src="https://math.now.sh?inline=c_%7B1%7D%20%5Cboldsymbol%7Bu%7D_%7B1%7D%2Bc_%7B2%7D%20%5Cboldsymbol%7Bu%7D_%7B2%7D%2B%5Ccdots%2Bc_%7Bm%7D%20%5Cboldsymbol%7Bu%7D_%7Bm%7D" style="display:inline-block;margin: 0;"/> 可写为</p>
<p style=""><img src="https://math.now.sh?from=c_%7B1%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20a_%7B1%20j%7D%20%5Cboldsymbol%7Bv%7D_%7Bj%7D%2Bc_%7B2%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20a_%7B2%20j%7D%20%5Cboldsymbol%7Bv%7D_%7Bj%7D%2B%5Ccdots%2Bc_%7Bm%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20a_%7Bm%20j%7D%20%5Cboldsymbol%7Bv%7D_%7Bj%7D%0A" /></p><p>重新排列各项, 我们看到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ac_%7B1%7D%20%5Cboldsymbol%7Bu%7D_%7B1%7D%2Bc_%7B2%7D%20%5Cboldsymbol%7Bu%7D_%7B2%7D%2B%5Ccdots%2Bc_%7Bm%7D%20%5Cboldsymbol%7Bu%7D_%7Bm%7D%20%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%5Bc_%7Bi%7D%5Cleft%28%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20a_%7Bi%20j%7D%20%5Cboldsymbol%7Bv%7D_%7Bj%7D%5Cright%29%5Cright%5D%20%5C%5C%0A%26%3D%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20a_%7Bi%20j%7D%20c_%7Bi%7D%5Cright)%20%5Cboldsymbol%7Bv%7D_%7Bj%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>现在我们看下面这个方程组</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20a_%7Bi%20j%7D%20c_%7Bi%7D%3D0%2C%20%5Cquad%20j%3D1%2C2%2C%20%5Ccdots%2C%20n%0A" /></p><p>这个齐次方程组的变量个数 (<img src="https://math.now.sh?inline=c_%7Bi%7D" style="display:inline-block;margin: 0;"/> 个数为 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> ) 多于方程个数 ( <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> ). 因此,  方程组必有非平凡解 <img src="https://math.now.sh?inline=%5Cleft%28%5Chat%7Bc%7D_%7B1%7D%2C%20%5Chat%7Bc%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Chat%7Bc%7D_%7Bm%7D%5Cright%29%5E%7B%5Cmathrm%7BT%7D%7D" style="display:inline-block;margin: 0;"/>. 而将其代入到上式中我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7Bc%7D_%7B1%7D%20%5Cboldsymbol%7Bu%7D_%7B1%7D%2B%5Chat%7Bc%7D_%7B2%7D%20%5Cboldsymbol%7Bu%7D_%7B2%7D%2B%5Ccdots%2B%5Chat%7Bc%7D_%7Bm%7D%20%5Cboldsymbol%7Bu%7D_%7Bm%7D%3D%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%200%20%5Cboldsymbol%7Bv%7D_%7Bj%7D%3D%5Cmathbf%7B0%7D%0A" /></p><p>于是 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bu%7D_%7B1%7D%2C%20%5Cboldsymbol%7Bu%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cboldsymbol%7Bu%7D_%7Bm%7D" style="display:inline-block;margin: 0;"/> 为线性相关的。</p>
<p>根据这个定理，我们可以很容易推导出一个向量空间的维数是固定的，也就是说同一个向量空间的不同基的向量数目相同。另外，对于维数为 <img src="https://math.now.sh?inline=n%20%3E%200" style="display:inline-block;margin: 0;"/> 的向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/>，任意 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个线性无关的向量张成 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 。</p>
<h2 id="基变换">基变换</h2>
<p>很多应用问题可以通过从一个坐标转化为另一坐标系而得到简化。<strong>在一个向量空间中转换坐标系，等同于从一组基转换为另外一组基</strong>。</p>
<p>当我们从一组基转换为另一组基时，可以通过将给定的<strong>坐标向量 (coordinate vector) <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/></strong> （定义为由有序基的基向量的长度组成的向量）  左乘一个**非奇异矩阵 <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> **来实现，即新坐标为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%20%3D%20%5Cmathbf%7BS%7D%5Cmathbf%7Bx%7D%0A" /></p><p>我们以最简单也是最常用的情况为例，假如我们希望用一组不同的基替代  <img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 的标准基，我们设新的基</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%5Cmu_%7B1%7D%7D%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A3%20%5C%5C%0A2%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%2C%20%5Cquad%20%0A%5Cmathbf%7B%5Cmu_%7B2%7D%7D%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A1%20%5C%5C%0A1%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>给定一个向量在新的基中的坐标向量为 <img src="https://math.now.sh?inline=%5Bc_%7B1%7D%2C%20c_%7B2%7D%5D" style="display:inline-block;margin: 0;"/> ，我们可以计算得到其在标准基中的坐标</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ac_1%5Cmathbf%7B%5Cmu_1%7D%20%2B%20c_2%5Cmathbf%7B%5Cmu_2%7D%20%26%3D%20c_1%283%5Cmathbf%7Be_1%7D%2B2%5Cmathbf%7Be_2%7D%29%2Bc_2(1%5Cmathbf%7Be_1%7D%2B1%5Cmathbf%7Be_2%7D)%5C%5C%0A%26%3D(3c_1%2Bc_2)%20%5Cmathbf%7Be_1%7D%20%2B%20(2c_1%2Bc_2)%20%5Cmathbf%7Be_2%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>如果令</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BU%7D%3D%20%28%5Cmathbf%7B%5Cmu_1%2C%20%5Cmu_2%7D%29%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A3%20%26%201%20%5C%5C%0A2%20%26%201%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>上面的坐标转换等同于</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bx%7D%20%3D%20%5Cmathbf%7BU%7D%20%5Cmathbf%7Bc%7D%0A" /></p><p>我们称矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 为从基 <img src="https://math.now.sh?inline=%5B%5Cmathbf%7B%5Cmu_%7B1%7D%7D%2C%20%5Cmathbf%7B%5Cmu_%7B2%7D%7D%5D" style="display:inline-block;margin: 0;"/> 转换到基  <img src="https://math.now.sh?inline=%5B%5Cmathbf%7Be_%7B1%7D%7D%2C%20%5Cmathbf%7Be_%7B2%7D%7D%5D" style="display:inline-block;margin: 0;"/> 的<strong>转移矩阵 (transition matrix)</strong> ，其为非奇异矩阵，因此反过来有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bc%7D%20%3D%20%5Cmathbf%7BU%7D%5E%7B-1%7D%20%5Cmathbf%7Bx%7D%0A" /></p><p>即矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 为从基 <img src="https://math.now.sh?inline=%5B%5Cmathbf%7Be_%7B1%7D%7D%2C%20%5Cmathbf%7Be_%7B2%7D%7D%5D" style="display:inline-block;margin: 0;"/> 转换到基  <img src="https://math.now.sh?inline=%5B%5Cmathbf%7B%5Cmu_%7B1%7D%7D%2C%20%5Cmathbf%7B%5Cmu_%7B2%7D%7D%5D" style="display:inline-block;margin: 0;"/>  的<strong>转移矩阵 (transition matrix)</strong> 。</p>
<p>我们可以轻松推广多任意两个基的转换，如果我们设两个基为  <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bv%7D_%7B1%7D%2C%20%5Cboldsymbol%7Bv%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cboldsymbol%7Bv%7D_%7Bn%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D_%7B1%7D%2C%20%5Cboldsymbol%7Bw%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cboldsymbol%7Bw%7D_%7Bn%7D" style="display:inline-block;margin: 0;"/> ，关键在于如何将 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bv%7D" style="display:inline-block;margin: 0;"/> 中的每一个基向量  <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bv_%7Bi%7D%7D" style="display:inline-block;margin: 0;"/> 表示为  <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D_%7B1%7D%2C%20%5Cboldsymbol%7Bw%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cboldsymbol%7Bw%7D_%7Bn%7D" style="display:inline-block;margin: 0;"/> ，然后我们就可以像上面一样构建转移矩阵。</p>
<h2 id="小结">小结</h2>
<p>这里我们看到一种矩阵乘法的情况，当一个非奇异矩阵乘以一组坐标向量时，其本质是基变换。两组基之间的转换是可逆的，二者的转移矩阵互为逆矩阵。</p>
<h1>线性变换</h1>
<p>在向量空间的学习中, 最重要的一类映射为线性变换.<br>
<strong>定义</strong> 一个将向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 映射到向量空间 <img src="https://math.now.sh?inline=W" style="display:inline-block;margin: 0;"/> 的映射 <img src="https://math.now.sh?inline=L" style="display:inline-block;margin: 0;"/>, 如果对所有 <img src="https://math.now.sh?inline=v_%7B1%7D%2C%20v_%7B2%7D%20%5Cin%20V" style="display:inline-block;margin: 0;"/> 及所有的标量 <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cbeta" style="display:inline-block;margin: 0;"/>,</p>
<p style=""><img src="https://math.now.sh?from=L%5Cleft%28%5Calpha%20v_%7B1%7D%2B%5Cbeta%20v_%7B2%7D%5Cright%29%3D%5Calpha%20L%5Cleft(v_%7B1%7D%5Cright)%2B%5Cbeta%20L%5Cleft(v_%7B2%7D%5Cright)%0A" /></p><p>我们将该线性变换标记为：</p>
<p style=""><img src="https://math.now.sh?from=L%3AV%20%5Crightarrow%20W%0A" /></p><p>我们称线性变换 <img src="https://math.now.sh?inline=L%3AV%20%5Crightarrow%20V" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 上的<strong>线性算子 (linear operator)</strong> （翻译成函数或者映射不行吗，非要整一个新名词，算子）。</p>
<p>事实上，我们可以将每一个线性变换均表示为一个矩阵，存在以下定理：</p>
<p><strong>定理</strong> 若 <img src="https://math.now.sh?inline=L" style="display:inline-block;margin: 0;"/> 为一从 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 到 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D%5E%7Bm%7D" style="display:inline-block;margin: 0;"/> 的线性变换, 则存在一个 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/>, 使得对 每一 <img src="https://math.now.sh?inline=x%20%5Cin%20%5Cmathbf%7BR%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/>, 有</p>
<p style=""><img src="https://math.now.sh?from=L%28x%29%3DA%20x%0A" /></p><p>事实上, <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 个列向量为</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7Ba%7D_%7Bj%7D%3DL%5Cleft%28%5Cboldsymbol%7Be%7D_%7Bj%7D%5Cright%29%20%5Cquad%20j%3D1%2C2%2C%20%5Ccdots%2C%20n%0A" /></p><p><strong>证明</strong>：</p>
<p>若</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7Bx%7D%3Dx_%7B1%7D%20%5Cboldsymbol%7Be%7D_%7B1%7D%2Bx_%7B2%7D%20%5Cboldsymbol%7Be%7D_%7B2%7D%2B%5Ccdots%2Bx_%7Bn%7D%20%5Cboldsymbol%7Be%7D_%7Bn%7D%0A" /></p><p>为 <img src="https://math.now.sh?inline=%5Cmathrm%7BR%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 中的任意元素, 则</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AL%28%5Cboldsymbol%7Bx%7D%29%20%26%20%3D%20Ax%20%5C%5C%0A%26%3D%5Cleft(%5Cboldsymbol%7Ba%7D_%7B1%7D%2C%20%5Cboldsymbol%7Ba%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cboldsymbol%7Ba%7D_%7Bn%7D%5Cright)%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0Ax_%7B1%7D%20%5C%5C%0Ax_%7B2%7D%20%5C%5C%0A%5Cvdots%20%5C%5C%0Ax_%7Bn%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%3Dx_%7B1%7D%20%5Cboldsymbol%7Ba%7D_%7B1%7D%2Bx_%7B2%7D%20%5Cboldsymbol%7Ba%7D_%7B2%7D%2B%5Ccdots%2Bx_%7Bn%7D%20%5Cboldsymbol%7Ba%7D_%7Bn%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>易得 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Ba%7D_%7Bj%7D%3DL%5Cleft%28%5Cboldsymbol%7Be%7D_%7Bj%7D%5Cright%29" style="display:inline-block;margin: 0;"/></p>
<p>因此，我们可以通过这个特性对每一个特定的线性变换 <img src="https://math.now.sh?inline=L" style="display:inline-block;margin: 0;"/> 构建矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 。举个例子，定义线性变换 <img src="https://math.now.sh?inline=L%3A%20%5Cmathbb%7BR%7D%5E%7B3%7D%20%5Crightarrow%20%5Cmathbb%7BR%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 为</p>
<p style=""><img src="https://math.now.sh?from=L%28%5Cboldsymbol%7Bx%7D%29%3D%5Cleft(x_%7B1%7D%2Bx_%7B2%7D%2C%20x_%7B2%7D%2Bx_%7B3%7D%5Cright)%5E%7B%5Cmathrm%7BT%7D%7D%0A" /></p><p>容易验证 <img src="https://math.now.sh?inline=L" style="display:inline-block;margin: 0;"/> 为一线性变换. 我们希望求一个矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/>, 使得对每一 <img src="https://math.now.sh?inline=x%20%5Cin%20%5Cmathbf%7BR%7D%5E%7B2%7D%2C%20L%28x%29%3DA%20x" style="display:inline-block;margin: 0;"/>. 用 做到这一点, 我们必须求 <img src="https://math.now.sh?inline=L%5Cleft%28e_%7B1%7D%5Cright%29%2C%20L%5Cleft(e_%7B2%7D%5Cright)" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=L%5Cleft%28e_%7B3%7D%5Cright%29" style="display:inline-block;margin: 0;"/> :</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26L%5Cleft%28%5Cboldsymbol%7Be%7D_%7B1%7D%5Cright%29%3DL%5Cleft((1%2C0%2C0)%5E%7B%5Cmathrm%7BT%7D%7D%5Cright)%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A1%20%5C%5C%0A0%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26L%5Cleft(%5Cboldsymbol%7Be%7D_%7B2%7D%5Cright)%3DL%5Cleft((0%2C1%2C0)%5E%7B%5Cmathrm%7BT%7D%7D%5Cright)%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A1%20%5C%5C%0A1%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26L%5Cleft(%5Cboldsymbol%7Be%7D_%7B3%7D%5Cright)%3DL%5Cleft((0%2C0%2C1)%5E%7B%5Cmathrm%7BT%7D%7D%5Cright)%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A0%20%5C%5C%0A1%0A%5Cend%7Barray%7D%5Cright%5D%0A%5Cend%7Baligned%7D%0A" /></p><p>选择这些向量作为矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的列向量:</p>
<p style=""><img src="https://math.now.sh?from=A%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Blll%7D%0A1%20%26%201%20%26%200%20%5C%5C%0A0%20%26%201%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>为验证结果, 计算 <img src="https://math.now.sh?inline=A%20x" style="display:inline-block;margin: 0;"/>;</p>
<p style=""><img src="https://math.now.sh?from=A%20x%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Blll%7D%0A1%20%26%201%20%26%200%20%5C%5C%0A0%20%26%201%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0Ax_%7B1%7D%20%5C%5C%0Ax_%7B2%7D%20%5C%5C%0Ax_%7B3%7D%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0Ax_%7B1%7D%2Bx_%7B2%7D%20%5C%5C%0Ax_%7B2%7D%2Bx_%7B3%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>我们注意到在线性转换前后的<strong>坐标轴</strong>往往发生了改变，在这个例子中转换之前的坐标轴为</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7Be%7D_%7B1%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A1%20%5C%5C%0A0%20%5C%5C%0A0%0A%5Cend%7Barray%7D%5Cright%5D%2C%0A%5Cboldsymbol%7Be%7D_%7B2%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A0%20%5C%5C%0A1%20%5C%5C%0A0%0A%5Cend%7Barray%7D%5Cright%5D%2C%0A%5Cboldsymbol%7Be%7D_%7B3%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A0%20%5C%5C%0A0%20%5C%5C%0A1%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>转换之后的坐标轴为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7Be%7D_%7B1%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A1%20%5C%5C%0A0%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%2C%0A%5Cboldsymbol%7Be%7D_%7B2%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A0%20%5C%5C%0A1%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><h2 id="小结-2">小结</h2>
<p>矩阵乘法 <img src="https://math.now.sh?inline=Ax" style="display:inline-block;margin: 0;"/> 是一个函数，其本质是一个<strong>线性变换</strong>。如果 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 是一个  <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵，那么就对应着一个 <img src="https://math.now.sh?inline=L%3A%5Cmathbb%7BR%7D%5E%7Bn%7D%20%5Crightarrow%20%5Cmathbb%7BR%7D%5E%7Bm%7D" style="display:inline-block;margin: 0;"/> 的线性变换，在线性变换的过程中向量空间发生了改变。</p>
<h1>总结</h1>
<p>一般的矩阵乘法 <img src="https://math.now.sh?inline=y%20%3D%20Ax" style="display:inline-block;margin: 0;"/> 对应着一个线性变换，一般来说这种线性变换不可逆，也就是一般找不到逆函数。</p>
<p>但是存在一种特殊情况，当 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 是一个<strong>非奇异矩阵</strong>时，此时  <img src="https://math.now.sh?inline=y%20%3D%20Ax" style="display:inline-block;margin: 0;"/>  可以理解为基变换，即在两个坐标系中转换坐标，此时的线性变换可逆。</p>
<p>[^1]: 《Linear Algebra with Applications》 Ninth Edition<br>
[^2]: <a href="https://www.matongxue.com/madocs/555/">如何理解矩阵乘法？- 马同学</a></p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>python批量下载url</title>
    <url>/posts/3290d880/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天需要从网上批量下载文件，如果手动下载需要频繁点击很烦人，尝试用 python 批量下载。</p>
<span id="more"></span>
<h1>问题描述</h1>
<p>我要下载的东西，网址都是很有规律的，就是其中的一个数字发生改变而已。手动一个一个点击很烦，就从网上搜索了一下，目前只找到了一种可行的方案<a href="https://blog.csdn.net/sinat_38682860/article/details/114438555">^1</a>。</p>
<p>很多别的方式我试了不行，但我也不太清楚为什么不行，比如这个 requests 包。</p>
<h1>wget 包</h1>
<p>首先用 pip 安装这个包，之后的脚本如下。</p>
<p>实际下载的密码只有一行 <code>wget.download(url, path)</code> ，只有两个参数，第一个是网址，第二个是存放路径。如果下载网址有规律的话，使用一个 for 循环就能批量下载了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 批量下载 pdf</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> wget</span><br><span class="line"></span><br><span class="line">path = <span class="string">&#x27;D:\Desktop&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">20</span>):</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">10</span>:</span><br><span class="line">        new_i = <span class="string">&quot;0&quot;</span>+<span class="built_in">str</span>(i) <span class="comment"># 如果是单个数字，前面加零</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new_i = <span class="built_in">str</span>(i)</span><br><span class="line">      </span><br><span class="line">    url = <span class="string">f&#x27;https://see.stanford.edu/materials/lsocoee364a/transcripts/ConvexOptimizationI-Lecture<span class="subst">&#123;new_i&#125;</span>.pdf&#x27;</span></span><br><span class="line">    wget.download(url, path)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>正定矩阵都是对称矩阵吗</title>
    <url>/posts/37a2cb0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>正定矩阵的概念来自于二次型，在定义正定矩阵时，就已经明确了<strong>正定矩阵是 Hermitian 矩阵的一种</strong> (对于实数矩阵，就是指对称矩阵)。</p>
<span id="more"></span>
<h1>矩阵的二次型</h1>
<p>下面的内容来自于张贤达老师的《矩阵分析与应用》书中。</p>
<p>任意一个<strong>方阵</strong> <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 的二次型定义为 <img src="https://math.now.sh?inline=x%5E%7B%5Cmathrm%7BH%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D" style="display:inline-block;margin: 0;"/>, 其中 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D" style="display:inline-block;margin: 0;"/> 可以是任意的<strong>非零复向量</strong>。 以实矩阵为例, 考查二次型</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%20%26%3D%5Cleft%5Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20x_%7B3%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D%0A1%20%26%204%20%26%202%20%5C%5C%0A-1%20%26%207%20%26%205%20%5C%5C%0A-1%20%26%206%20%26%203%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0Ax_%7B1%7D%20%5C%5C%0Ax_%7B2%7D%20%5C%5C%0Ax_%7B3%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%3Dx_%7B1%7D%5E%7B2%7D%2B7%20x_%7B2%7D%5E%7B2%7D%2B3%20x_%7B3%7D%5E%7B2%7D%2B3%20x_%7B1%7D%20x_%7B2%7D%2Bx_%7B1%7D%20x_%7B3%7D%2B11%20x_%7B2%7D%20x_%7B3%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>这是变元 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 的二次型函数, 故称 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D" style="display:inline-block;margin: 0;"/> 为矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 的二次型。<br>
推而广之, 若 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%3D%5Cleft%5Bx_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bn%7D%5Cright%5D%5E%7B%5Cmathrm%7BT%7D%7D" style="display:inline-block;margin: 0;"/>, 且 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 的元素为 <img src="https://math.now.sh?inline=a_%7Bi%20j%7D" style="display:inline-block;margin: 0;"/>, 则二次型</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%20%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20x_%7Bi%7D%20x_%7Bj%7D%20a_%7Bi%20j%7D%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20a_%7Bi%20i%7D%20x_%7Bi%7D%5E%7B2%7D%2B%5Csum_%7Bi%3D1%2C%20i%20%5Cneq%20j%7D%5E%7Bn%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20a_%7Bi%20j%7D%20x_%7Bi%7D%20x_%7Bj%7D%20%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20a_%7Bi%20i%7D%20x_%7Bi%7D%5E%7B2%7D%2B%5Csum_%7Bi%3D1%7D%5E%7Bn-1%7D%20%5Csum_%7Bj%3Di%2B1%7D%5E%7Bn%7D%5Cleft%28a_%7Bi%20j%7D%2Ba_%7Bj%20i%7D%5Cright%29%20x_%7Bi%7D%20x_%7Bj%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>根据这一公式, 显然</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cboldsymbol%7BA%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Brrr%7D%0A1%20%26%204%20%26%202%20%5C%5C%0A-1%20%26%207%20%26%205%20%5C%5C%0A-1%20%26%206%20%26%203%0A%5Cend%7Barray%7D%5Cright%5D%2C%20%5Cquad%20%5Cboldsymbol%7BB%7D%3D%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Brrr%7D%0A1%20%26%20-1%20%26%20-1%20%5C%5C%0A4%20%26%207%20%26%206%20%5C%5C%0A2%20%26%205%20%26%203%0A%5Cend%7Barray%7D%5Cright%5D%2C%20%5Cquad%20%5Cboldsymbol%7BC%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Blll%7D%0A1.0%20%26%201.5%20%26%200.5%20%5C%5C%0A1.5%20%26%207.0%20%26%205.5%20%5C%5C%0A0.5%20%26%205.5%20%26%203.0%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%5Cboldsymbol%7BD%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Brrr%7D%0A1%20%26%20114%20%26%2052%20%5C%5C%0A-111%20%26%207%20%26%202%20%5C%5C%0A-51%20%26%209%20%26%203%0A%5Cend%7Barray%7D%5Cright%5D%2C%20%5Cquad%20%5Cboldsymbol%7BF%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Brrr%7D%0A1%20%26%20114%20%26%2052%20%5C%5C%0A-111%20%26%207%20%26%204%20%5C%5C%0A-51%20%26%207%20%26%203%0A%5Cend%7Barray%7D%5Cright%5D%2C%20%5Cquad%20%5Ccdots%0A%5Cend%7Baligned%7D%0A" /></p><p>具有相同的二次型, 即</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%20%26%3D%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BB%7D%20%5Cboldsymbol%7Bx%7D%3D%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BC%7D%20%5Cboldsymbol%7Bx%7D%3D%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BD%7D%20%5Cboldsymbol%7Bx%7D%3D%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BF%7D%20%5Cboldsymbol%7Bx%7D%20%5C%5C%0A%26%3Dx_%7B1%7D%5E%7B2%7D%2B7%20x_%7B2%7D%5E%7B2%7D%2B3%20x_%7B3%7D%5E%7B2%7D%2B3%20x_%7B1%7D%20x_%7B2%7D%2Bx_%7B1%7D%20x_%7B3%7D%2B11%20x_%7B2%7D%20x_%7B3%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>这就是说, 对于任何一个二次型函数</p>
<p style=""><img src="https://math.now.sh?from=f%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bn%7D%5Cright%29%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Calpha_%7Bi%20i%7D%20x_%7Bi%7D%5E%7B2%7D%2B%5Csum_%7Bi%3D1%2C%20i%20%5Cneq%20j%7D%5E%7Bn%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20%5Calpha_%7Bi%20j%7D%20x_%7Bi%7D%20x_%7Bj%7D%0A" /></p><p>而言, 存在许多矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/>, 它们的二次型 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%3Df%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bn%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 相同。但是, 只有<strong>一个唯一的对称矩阵</strong> <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 满足 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%3Df%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bn%7D%5Cright%29" style="display:inline-block;margin: 0;"/>, 其元素为 <img src="https://math.now.sh?inline=a_%7Bi%20j%7D%3Da_%7Bj%20i%7D%3D%5Cfrac%7B1%7D%7B2%7D%5Cleft%28%5Calpha_%7Bi%20j%7D%2B%5Calpha_%7Bj%20i%7D%5Cright%29" style="display:inline-block;margin: 0;"/>, 其 中, <img src="https://math.now.sh?inline=i%3D1%2C%20%5Ccdots%2C%20n%2C%20j%3D1%2C%20%5Ccdots%2C%20n" style="display:inline-block;margin: 0;"/> 。因此, 为了保证定义的唯一性, <strong>在讨论矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 的二次型 时, 有必要假定 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 为实对称矩阵或复共轭对称 (即 Hermitian) 矩阵</strong>。</p>
<p>因此，在二次型的概念中，我们不严格要求矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 为实对称矩阵或复共轭对称 (即 Hermitian) 矩阵，仅仅要求 其为方阵，但是通常我们还是假定其为实对称矩阵或复共轭对称 (即 Hermitian) 矩阵。</p>
<h1>正定矩阵定义</h1>
<p>下面这几段话来自于维基百科<a href="https://www.wikiwand.com/zh/%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5">^1</a>。</p>
<blockquote>
<p>在线性代数裡，正定矩阵 (英語: positive-definite matrix) 是<strong>埃尔米特矩阵</strong>的一种，有时会简称为正定阵。在线性代数中，正定矩阵的性质類似复数中的正实数。</p>
<p>一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的<strong>实对称矩阵</strong> <img src="https://math.now.sh?inline=M" style="display:inline-block;margin: 0;"/> 是正定的，当且仅当对于所有的非零实系数向量 <img src="https://math.now.sh?inline=z" style="display:inline-block;margin: 0;"/> ，都有 <img src="https://math.now.sh?inline=z%5E%7B%5Cmathrm%7BT%7D%7D%20M%20z%3E0" style="display:inline-block;margin: 0;"/> 。其 中 <img src="https://math.now.sh?inline=z%5E%7B%5Ctop%7D" style="display:inline-block;margin: 0;"/> 表示 <img src="https://math.now.sh?inline=z" style="display:inline-block;margin: 0;"/> 的转置。<br>
对于复数的情况，定义则为: 一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的埃尔米特矩阵(或厄米矩阵) <img src="https://math.now.sh?inline=M" style="display:inline-block;margin: 0;"/> 是正定的当且仅当对于每个非零的禎向量 <img src="https://math.now.sh?inline=Z" style="display:inline-block;margin: 0;"/> ，都有 <img src="https://math.now.sh?inline=z%5E%7B*%7D%20M%20z%3E0" style="display:inline-block;margin: 0;"/> 。其中 <img src="https://math.now.sh?inline=z%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 表示 <img src="https://math.now.sh?inline=Z" style="display:inline-block;margin: 0;"/> 的共轭转置。由于 <img src="https://math.now.sh?inline=M" style="display:inline-block;margin: 0;"/> 是埃尔米特矩阵，经计算可知，对于任意的複向量 <img src="https://math.now.sh?inline=z%20%EF%BC%8C%20z%5E%7B*%7D%20M%20z" style="display:inline-block;margin: 0;"/> 必然是实数，从而可以与比较大小。因此这个定义是自洽的。</p>
</blockquote>
<p>我们可以看到，对于实数矩阵而言，正定矩阵定义时就要求其为<strong>对称矩阵</strong>。</p>
<h1>非埃尔米特矩阵的情况</h1>
<p>下面这段话主要来自于维基百科<a href="https://www.wikiwand.com/zh/%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5">^1</a>。</p>
<blockquote>
<p>如果一个非对称的实数矩阵<strong>M</strong>满足对所有非零实向量 <em>x</em>，有 <img src="https://math.now.sh?inline=x%5E%7BT%7DMx%20%3E%200" style="display:inline-block;margin: 0;"/> ，当且仅当对称矩阵 <img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7B2%7D%20%28M%20%2B%20M%5E%7BT%7D%29" style="display:inline-block;margin: 0;"/> 是正定矩阵。</p>
<p>对于复系数矩阵，情况可能不太一样。主要看的是怎样扩展 <img src="https://math.now.sh?inline=z%5E%7B*%7D%20%5Cmathbf%7BM%7D%20z%3E0" style="display:inline-block;margin: 0;"/> 这一性质。要使 <img src="https://math.now.sh?inline=z%5E%7B*%7D%20%5Cmathbf%7BM%7D%20z" style="display:inline-block;margin: 0;"/> 总为实数，矩阵 <img src="https://math.now.sh?inline=M" style="display:inline-block;margin: 0;"/> 必须是埃尔米特矩阵。因此，若 <img src="https://math.now.sh?inline=Z%5E%7B*%7D%20M%20Z" style="display:inline-block;margin: 0;"/> 总是正实数， <img src="https://math.now.sh?inline=M" style="display:inline-block;margin: 0;"/> 必然是正定的埃尔米特矩 阵。如果将 <img src="https://math.now.sh?inline=z%5E%7B*%7D%20%5Cmathbf%7BM%7D%20z%3E0" style="display:inline-block;margin: 0;"/> 扩展为 <img src="https://math.now.sh?inline=%5Coperatorname%7BRe%7D%5Cleft%28z%5E%7B*%7D%20%5Cmathbf%7BM%7D%20z%5Cright%29%3E0" style="display:inline-block;margin: 0;"/> ，则等价于 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BM%7D%2B%5Cmathbf%7BM%7D%5E%7B*%7D%5Cright%29%20%2F%202" style="display:inline-block;margin: 0;"/> 为正定阵。</p>
</blockquote>
<p>然后从知乎找到了一个回答[^2]。其证明了一个非对称的实数矩阵<img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的二次型等于对称矩阵 <img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7B2%7D%28A%20%2B%20A%5E%7BT%7D%29" style="display:inline-block;margin: 0;"/> 的二次型。</p>
<p>对于任何一个方阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> ，我们都可以将其分解为：</p>
<p style=""><img src="https://math.now.sh?from=A%20%3D%20%5Cfrac%7B1%7D%7B2%7D%28A%20%2B%20A%5E%7BT%7D%29%20%2B%20%5Cfrac%7B1%7D%7B2%7D(A%20-%20A%5E%7BT%7D)%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7B2%7D%28A%20%2B%20A%5E%7BT%7D%29" style="display:inline-block;margin: 0;"/> 是对称矩阵，前面已经提到了。后面 <img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7B2%7D%28A%20-%20A%5E%7BT%7D%29" style="display:inline-block;margin: 0;"/> 为反对称矩阵，下面来证明</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%28A-A%5E%7BT%7D%29_%7Bij%7D%20%26%3D%20A_%7Bij%7D-A%7Bji%7D%5C%5C%0A(A-A%5E%7BT%7D)_%7Bji%7D%20%26%3D%20A_%7Bji%7D-A%7Bij%7D%5C%5C%0A%5Ctherefore%20(A-A%5E%7BT%7D)_%7Bij%7D%20%26%3D%20-%20(A-A%5E%7BT%7D)_%7Bji%7D%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，易得 <img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7B2%7D%28A%20-%20A%5E%7BT%7D%29" style="display:inline-block;margin: 0;"/> 的二次型为 0 。方阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的二次型为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ax%5E%7BT%7DAx%20%26%3D%20x%5E%7BT%7D%28%5Cfrac%7B1%7D%7B2%7D(A%20%2B%20A%5E%7BT%7D%29%20%2B%20%5Cfrac%7B1%7D%7B2%7D(A%20-%20A%5E%7BT%7D))x%20%5C%5C%0A%26%20%3D%20%20x%5E%7BT%7D(%5Cfrac%7B1%7D%7B2%7D(A%20%2B%20A%5E%7BT%7D)%20)x%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，从个人理解来说，由于所有非对称方阵的二次型均可以转化为对称方阵，再加上对称矩阵的诸多优良性质，那就不如直接将正定矩阵定义在对称矩阵的基础上。</p>
<p>[^2]:  正定矩阵一定是对称阵吗？ - 益者三友的回答 - 知乎 <a href="https://www.zhihu.com/question/66922790/answer/1463342936">https://www.zhihu.com/question/66922790/answer/1463342936</a></p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>证明AB的秩小于等于A的秩</title>
    <url>/posts/6c72beb0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>矩阵秩的性质的证明比较少，看到了一个很好的回答，简单地记录一下。</p>
<p>本文内容基本来自于 <a href="https://yutsumura.com/rank-of-the-product-of-matrices-ab-is-less-than-or-equal-to-the-rank-of-a/">Rank of the Product of Matrices ABAB is Less than or Equal to the Rank of A</a> ，感兴趣的可以自己去看一下。</p>
<span id="more"></span>
<h1>问题</h1>
<p>如果 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵，<img src="https://math.now.sh?inline=B" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20q" style="display:inline-block;margin: 0;"/> 的矩阵，证明下面两个性质：</p>
<p>(a) <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28A%20B%29%20%5Cleq%20%5Coperatorname%7Brank%7D(A)" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28A%20B%29%20%5Cleq%20%5Coperatorname%7Brank%7D(B)" style="display:inline-block;margin: 0;"/></p>
<p>(b) 如果 <img src="https://math.now.sh?inline=B" style="display:inline-block;margin: 0;"/> 非奇异，<img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28A%20B%29%20%3D%20%5Coperatorname%7Brank%7D(A)" style="display:inline-block;margin: 0;"/></p>
<p>解决这个问题前，首先我们要先看看矩阵<strong>列空间</strong>的定义和性质。</p>
<h1>矩阵的列空间</h1>
<p>下面这段话来自于吴恩达老师 CS229 课程的讲义。</p>
<p>一个向量集合的<strong>张成空间 (span)</strong> 定义为这些向量的线性组合，即为：</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Bspan%7D%5Cleft%28%5Cleft%5C%7Bx_%7B1%7D%2C%20%5Cldots%20x_%7Bn%7D%5Cright%5C%7D%5Cright%29%3D%5Cleft%5C%7Bv%3A%20v%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Calpha_%7Bi%7D%20x_%7Bi%7D%2C%20%5Calpha_%7Bi%7D%20%5Cin%20%5Cmathbb%7BR%7D%5Cright%5C%7D%0A" /></p><p>如果 <img src="https://math.now.sh?inline=%5Cleft%5C%7Bx_%7B1%7D%2C%20%5Cldots%2C%20x_%7Bn%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个线性无关的向量，那么其张成空间就是 <img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>一个向量 <img src="https://math.now.sh?inline=y%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bm%7D" style="display:inline-block;margin: 0;"/> 在 <img src="https://math.now.sh?inline=%5Cleft%5C%7Bx_%7B1%7D%2C%20%5Cldots%2C%20x_%7Bn%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> 的张成空间的<strong>投影 (projection)</strong> ，定义为在张成空间中与 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 距离最近的一个点 (向量)，写作：</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BProj%7D%5Cleft%28y%20%3B%5Cleft%5C%7Bx_%7B1%7D%2C%20%5Cldots%20x_%7Bn%7D%5Cright%5C%7D%5Cright%29%3D%5Coperatorname%7Bargmin%7D_%7Bv%20%5Cin%20%5Coperatorname%7Bspan%7D%5Cleft(%5Cleft%5C%7Bx_%7B1%7D%2C%20%5Cldots%2C%20x_%7Bn%7D%5Cright%5C%7D%5Cright)%7D%5C%7Cy-v%5C%7C_%7B2%7D%0A" /></p><p>一个矩阵 <img src="https://math.now.sh?inline=A%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bm%20%5Ctimes%20n%7D" style="display:inline-block;margin: 0;"/> 的<strong>列空间 (range, column space)</strong> 是它的列张成的空间，即为 <img src="https://math.now.sh?inline=%5Cmathcal%7BR%7D%28A%29" style="display:inline-block;margin: 0;"/> （好像也有人写作 <img src="https://math.now.sh?inline=C%28A%29" style="display:inline-block;margin: 0;"/>  或 <img src="https://math.now.sh?inline=Col%28A%29" style="display:inline-block;margin: 0;"/> ），即：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathcal%7BR%7D%28A%29%3D%5Cleft%5C%7Bv%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bm%7D%3A%20v%3DA%20x%2C%20x%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bn%7D%5Cright%5C%7D%0A" /></p><p>为什么可以写成 <img src="https://math.now.sh?inline=Ax" style="display:inline-block;margin: 0;"/> 呢，我们可以将 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 写成列向量的形式，得到下式，因此  <img src="https://math.now.sh?inline=Ax" style="display:inline-block;margin: 0;"/> 就是 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的列的张成空间。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AA%20x%20%26%3D%5Cleft%5Ba_%7B1%7D%20a_%7B2%7D%20%5Ccdots%20a_%7Bn%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0Ax_%7B1%7D%20%5C%5C%0A%5Cvdots%20%5C%5C%0Ax_%7Bn%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%3Dx_%7B1%7D%20a_%7B1%7D%2Bx_%7B2%7D%20a_%7B2%7D%2B%5Ccdots%2Bx_%7Bn%7D%20a_%7Bn%7D%0A%5Cend%7Baligned%7D%0A" /></p><h2 id="列空间的维度">列空间的维度</h2>
<p>矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的列空间的维度等于矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的秩，即存在</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Bdim%7D%20%5Cmathcal%7BR%7D%28%5Cmathbf%7BA%7D%29%3D%5Coperatorname%7Brank%7D(%5Cmathbf%7BA%7D)%0A" /></p><p>这个很好证明，假设矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 有 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 个线性无关的列，即 <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28%5Cmathbf%7BA%7D%29%20%3D%20k" style="display:inline-block;margin: 0;"/> ，那么矩阵  <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的所有列张成的空间就是其 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 个线性无关的列张成的空间（因为其他列都是这 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 列的线性组合），而  <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 个线性无关的列的张成空间的维度就是 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> ，即  <img src="https://math.now.sh?inline=%5Coperatorname%7Bdim%7D%20%5Cmathcal%7BR%7D%28%5Cmathbf%7BA%7D%29%3D%20k" style="display:inline-block;margin: 0;"/> ，因此得证矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的列空间的维度等于矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的秩。</p>
<h1>证明 AB 的秩小于等于 A</h1>
<p>根据列空间的性质，我们有：</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Brank%7D%28A%20B%29%3D%5Coperatorname%7Bdim%7D(%5Cmathcal%7BR%7D(A%20B))%2C%20%5Cquad%20%5Coperatorname%7Brank%7D(A)%3D%5Coperatorname%7Bdim%7D(%5Cmathcal%7BR%7D(A))%0A" /></p><p>我们知道，如果一个向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 是向量空间 <img src="https://math.now.sh?inline=W" style="display:inline-block;margin: 0;"/> 的子空间，那么必然存在：</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Bdim%7D%28V%29%20%5Cleq%20%5Coperatorname%7Bdim%7D(W)%0A" /></p><p>因此，我们只需要证明 <img src="https://math.now.sh?inline=%5Cmathcal%7BR%7D%28A%20B%29" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathcal%7BR%7D%28A%29" style="display:inline-block;margin: 0;"/> 的子空间即可。</p>
<p>现在假定对于任意一个向量 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%20%5Cin%20%5Cmathcal%7BR%7D%28A%20B%29" style="display:inline-block;margin: 0;"/> ，因此存在一个相应的 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D%20%5Cin%20R%5E%7Bq%7D" style="display:inline-block;margin: 0;"/>，使得  <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%28A%20B%29%20%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> ，以符合列空间的定义。</p>
<p>此时，我们设 <img src="https://math.now.sh?inline=%5Cmathbf%7Bz%7D%3DB%20%5Cmathbf%7Bx%7D%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> ，因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%3DA%28B%20%5Cmathbf%7Bx%7D%29%3DA%20%5Cmathbf%7Bz%7D%0A" /></p><p>因此， <img src="https://math.now.sh?inline=%5Cmathcal%7BR%7D%28AB%29" style="display:inline-block;margin: 0;"/> 中的任何一个向量 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 均同样在  <img src="https://math.now.sh?inline=%5Cmathcal%7BR%7D%28A%29" style="display:inline-block;margin: 0;"/> 中，也就是说， <img src="https://math.now.sh?inline=%5Cmathcal%7BR%7D%28AB%29" style="display:inline-block;margin: 0;"/> 是  <img src="https://math.now.sh?inline=%5Cmathcal%7BR%7D%28A%29" style="display:inline-block;margin: 0;"/> 的一个子空间，因此，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Brank%7D%28A%20B%29%3D%5Coperatorname%7Bdim%7D(%5Cmathcal%7BR%7D(A%20B))%20%5Cleq%20%5Coperatorname%7Bdim%7D(%5Cmathcal%7BR%7D(A))%3D%5Coperatorname%7Brank%7D(A)%0A" /></p><p>得证。</p>
<h1>证明 AB 的秩小于等于 B</h1>
<p>首先，我们知道矩阵的转置与原矩阵的秩相同（矩阵线性无关的列数=线性无关的行数）。因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Brank%7D%28AB%29%20%26%3D%20%5Coperatorname%7Brank%7D(B%5E%7BT%7DA%5E%7BT%7D)%20%5C%5C%0A%26%20%5Cleq%20%5Coperatorname%7Brank%7D(B%5E%7BT%7D)%20%5C%5C%0A%26%20%3D%20%5Coperatorname%7Brank%7D(B)%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>这里第二行采用了上面的结论，AB 的秩小于等于 A。</p>
<p>因此，我们得证 <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28A%20B%29%20%5Cleq%20%5Coperatorname%7Brank%7D(B)" style="display:inline-block;margin: 0;"/> ，联合这两个性质，则有</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Brank%7D%28A%20B%29%20%5Cleq%20%5Cmin%5C%7B%5Coperatorname%7Brank%7D(A)%2C%5Coperatorname%7Brank%7D(B)%5C%7D%0A" /></p><h1>证明如果 B​ 非奇异, AB 的秩等于 A</h1>
<p>我们已知 <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28A%20B%29%20%5Cleq%20%5Coperatorname%7Brank%7D(A)" style="display:inline-block;margin: 0;"/> ，因此存在：</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Brank%7D%5Cleft%28(A%20B%29%20B%5E%7B-1%7D%5Cright)%20%5Cleq%20%5Coperatorname%7Brank%7D(A%20B)%0A" /></p><p>再采用这个性质，因此我们有：</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Brank%7D%28A%29%3D%5Coperatorname%7Brank%7D%5Cleft((A%20B)%20B%5E%7B-1%7D%5Cright)%20%5Cleq%20%5Coperatorname%7Brank%7D(A%20B)%20%5Cleq%20%5Coperatorname%7Brank%7D(A)%0A" /></p><p>如果一系列不等式的两头相等，那么中间的所有不等式就一定为等式，因此此时，我们有：</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Brank%7D%28A%20B%29%20%3D%20%5Coperatorname%7Brank%7D(A)%0A" /></p><h1>闲话</h1>
<p>从这个帖子的网站主页来看，这个网站貌似就是解决数学问题的，或者证明数学公式的，有时间可以看看，网址见下方。</p>
<p><a href="https://yutsumura.com/">https://yutsumura.com/</a></p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>计算trios的孟德尔错误率</title>
    <url>/posts/7bc46342/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>当系谱中个体-父-母三者均有基因型时，计算该trios的孟德尔错误率。</p>
<span id="more"></span>
<h1>原理简介</h1>
<p>上一篇见 <a href="https://vincere.fun/posts/42752926/">基于芯片数据的亲子鉴定分析代码</a></p>
<p>原理非常简单，就是孟德尔定律，之前只是针对亲子两个个体之间统计孟德尔错误位点，现在这个程序就是计算父母子三者之间不符合孟德尔定理的位点数目和比例，举个例子，如果父母的基因型都是 AA，子代基因型只要不是 AA ，就算一个孟德尔错误位点。</p>
<p>但是想要<strong>快速</strong>统计trios的孟德尔错误位点并不容易，假设父母子在某个位点均不为缺失，那么父母子总共可能的基因型情况有 18 种（不区分两个亲本），其中不符合孟德尔定律的有 8 种情况，那么我们怎么快速统计孟德尔错误位点总数呢？</p>
<p>下表为trios所有基因型情况的统计（这里设 1 和 3 为两种纯和子，2 为杂合子）。</p>
<table>
<thead>
<tr>
<th>亲本1</th>
<th>亲本1</th>
<th>符合孟德尔定律的后代基因型</th>
<th>违背孟德尔定律的后代基因型</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2,3</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>1,2</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>2</td>
<td>1,3</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>1,2,3</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>2,3</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>3</td>
<td>1,2</td>
</tr>
</tbody>
</table>
<p>根据我之前的做法，我是通过亲子对基因型的乘积来判断这个位点是否为孟德尔错误位点，这里我同样沿用了这种做法。</p>
<p>首先将后代/个体的基因型编码改为从 1 2 3 分别改为 5 7 8，亲本基因型编码不变，此时 trios所有基因型情况和 trios 基因型乘积情况见下表。</p>
<table>
<thead>
<tr>
<th>亲本1</th>
<th>亲本2</th>
<th>符合孟德尔定律的后代基因型</th>
<th>违背孟德尔定律的后代基因型</th>
<th>符合孟德尔定律的trios基因型乘积</th>
<th>违背孟德尔定律的trios基因型乘积</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>5</td>
<td>7,8</td>
<td>5</td>
<td>7,8</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>5,7</td>
<td>8</td>
<td>10,14</td>
<td>16</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>7</td>
<td>5,8</td>
<td>21</td>
<td>15,24</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>5,7,8</td>
<td>-</td>
<td>20,28,32</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>7,8</td>
<td>5</td>
<td>42,48</td>
<td>30</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>8</td>
<td>5,7</td>
<td>72</td>
<td>45,63</td>
</tr>
</tbody>
</table>
<p>我们发现，此时符合孟德尔定律的 trios 基因型乘积和 违背孟德尔定律的 trios 基因型乘积之间<strong>没有重叠的数字</strong>，然后你就同样可以直接根据<strong>trios 基因型的乘积</strong>来判断该位点是否符合孟德尔定律。此时，8 种违背孟德尔定律的基因型情况对应的基因型乘积为 <img src="https://math.now.sh?inline=%5C%7B7%2C8%2C15%2C16%2C24%2C30%2C45%2C63%5C%7D" style="display:inline-block;margin: 0;"/> 。</p>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么GCTA做PCA分析是对G阵进行特征值分解</title>
    <url>/posts/1e12f93e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在机器学习中，进行PCA分析时都是说对<strong>特征的协方差矩阵</strong> <img src="https://math.now.sh?inline=%5CSigma" style="display:inline-block;margin: 0;"/> 进行特征值分解，得到特征向量 <img src="https://math.now.sh?inline=%5Cleft%5C%7Bw_%7B1%7D%2C%20w_%7B2%7D%2C%20%5Cldots%2C%20w_%7Bn%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/>  后，再利用特征向量与特征的内积，计算样本点的新坐标 <img src="https://math.now.sh?inline=z" style="display:inline-block;margin: 0;"/>（<strong>主成分</strong>）。</p>
<p>但是在我们对基因型数据进行PCA分析时，我们使用的常规软件 (例如plink 和 GCTA)，其算法都是对<strong>G阵</strong>(可以理解为样本的协方差矩阵)进行特征值分解，然后得到的特征向量直接就是主成分。这里主要以 GCTA 文章为例，推导这种做法的合理性。</p>
<p>建议先看上一篇 <a href="https://vincere.fun/posts/fc532062/">PCA分析公式推导</a></p>
<span id="more"></span> 
<h1>GCTA算法[^1]</h1>
<p>这里我稍微改了一些文章中使用的符号，为了与我之前的符号习惯，或者说吴老师的符号习惯一致。</p>
<h2 id="构建G阵">构建G阵</h2>
<p>假设我们使用混合线性模型如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%3D%5Cmathbf%7BK%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cmathbf%7BX%7D%20%5Cmathbf%7Bu%7D%2B%5Cvarepsilon%20%5Ctext%20%7B%20with%20%7D%20%5Coperatorname%7Bvar%7D%28%5Cmathbf%7By%7D%29%3D%5Cmathbf%7BV%7D%3D%5Cmathbf%7BX%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Csigma_%7B%5Cmathrm%7Bu%7D%7D%5E%7B2%7D%2B%5Cmathbf%7BI%7D%20%5Csigma_%7B%5Cvarepsilon%7D%5E%7B2%7D%2C%0A" /></p><p><img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=m%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 的表型向量，<img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 为表型数目。<img src="https://math.now.sh?inline=%5Cmathbf%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 为固定效应，如PCA的主成分;  <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D" style="display:inline-block;margin: 0;"/> 为相应的设计矩阵。<img src="https://math.now.sh?inline=%5Cmu" style="display:inline-block;margin: 0;"/> 为  <img src="https://math.now.sh?inline=n%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 的SNP 效应向量（<img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 为SNP数目，也就是机器学习的特征数目），为随机效应，服从分布 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D%20%5Csim%20N%5Cleft%280%2C%20%5Cmathbf%7BI%7D%20%5Csigma_%7B%5Cmathrm%7Bu%7D%7D%5E%7B2%7D%5Cright%29" style="display:inline-block;margin: 0;"/> ；<img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 为相应的设计矩阵。</p>
<p>这里着重说一下 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵，其维度为 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> ，也就是说一行表示一个样本，一列是一个SNP（文章里存在一处笔误，对这个矩阵行和列说反了）。这个矩阵的构建分为两步:</p>
<ol>
<li>我们统计每个SNP中指定碱基（文章中指定是<code>reference allele</code>，但这一点无所谓）的数目，作为中间矩阵的元素，此时这个矩阵元素只可能是0,1和 2 ；</li>
<li>我们对上面这个矩阵的每一列（SNP）进行<strong>标准化</strong> ，便得到了   <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵。</li>
</ol>
<p>这里我们假设第一步构建的中间矩阵为  <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D" style="display:inline-block;margin: 0;"/>， 则  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵的元素 <img src="https://math.now.sh?inline=x_%7Bi%20j%7D%3D%5Cleft%28m_%7Bi%20j%7D-2%20p_%7Bj%7D%5Cright%29%2F%5Csqrt%7B2%20p_%7Bj%7D%5Cleft(1-p_%7Bj%7D%5Cright)%7D" style="display:inline-block;margin: 0;"/> ，这里 <img src="https://math.now.sh?inline=p_%7Bj%7D" style="display:inline-block;margin: 0;"/> 为第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 列 SNP 指定碱基的基因频率。也就是说，这里设第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 列 SNP的均值为 <img src="https://math.now.sh?inline=2p_%7Bj%7D" style="display:inline-block;margin: 0;"/> ，其方差为 <img src="https://math.now.sh?inline=2p_%7Bj%7D%281-p_%7Bj%7D%29" style="display:inline-block;margin: 0;"/> ，下面开始证明这两点。</p>
<p>我们设第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 列 SNP中0,1,2三种基因型在样本中出现的频率分别为 <img src="https://math.now.sh?inline=a%2Cb%2Cc" style="display:inline-block;margin: 0;"/> ，因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26a%2Bb%2Bc%3D1%20%5C%5C%0A%26%5Cfrac%7B1%7D%7B2%7D%20b%2Bc%3Dp_%7Bj%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>则很容易计算 <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D" style="display:inline-block;margin: 0;"/> 矩阵第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 列的均值</p>
<p style=""><img src="https://math.now.sh?from=E%28M_%7Bj%7D%29%3D0%20%5Ctimes%20a%2B1%20%5Ctimes%20b%2B2%20%5Ctimes%20c%3D2%20p_%7Bj%7D%0A" /></p><p>证明 <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D" style="display:inline-block;margin: 0;"/> 矩阵第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 列的方差则需要<strong>哈温平衡假设</strong>。当群体处于哈温平衡时，此时存在：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26a%3D%5Cleft%281-p_%7Bj%7D%5Cright%29%5E%7B2%7D%20%5C%5C%0A%26b%3D2%20p_%7Bj%7D%5Cleft(1-p_%7Bj%7D%5Cright)%20%5C%5C%0A%26c%3Dp_%7Bj%7D%5E%7B2%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 列的方差为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7BVar%7D%5Cleft%28M_%7Bj%7D%5Cright%29%20%26%3DE%5Cleft(M_%7Bj%7D%5E%7B2%7D%5Cright)-%5Cleft(E%5Cleft(M_%7Bj%7D%5Cright)%5Cright)%5E%7B2%7D%20%5C%5C%0A%26%3D%5Cleft(0%20%5Ctimes%20a%2B1%20%5Ctimes%20b%20%2B4%20%5Ctimes%20c%5Cright)-4%20p_%7Bj%7D%5E%7B2%7D%20%5C%5C%0A%26%3D2%20p_%7Bj%7D%2B2%20c-4%20p_%7Bj%7D%5E%7B2%7D%20%5Cquad%20%5Cbecause%20%E5%93%88%E6%B8%A9%E5%B9%B3%E8%A1%A1%E5%81%87%E8%AE%BE%5C%5C%0A%26%3D2%20p_%7Bj%7D%2B2%20p_%7Bj%7D%5E%7B2%7D-4%20p_%7Bi%7D%5E%7B2%7D%20%5C%5C%0A%26%3D2%20p_%7Bj%7D%5Cleft(1-p_%7Bj%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>这里我们得到的  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵与机器学习中使用的设计矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵一模一样，都是 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵，并且对特征进行了标准。</p>
<p>我们定义<strong>亲缘关系矩阵 (genetic relationship matrix, GRM)</strong>   <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BG%7D%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BX%7D%5E%7B%5Ctop%7D%0A" /></p><p>我们发现这里定义的 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵 看上去和机器学习中使用的协方差矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 很像，如果我们不管常数项，这里就是矩阵乘积的顺序换了。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%5CSigma%7D%3D%5Cfrac%7B1%7D%7Bm%7D%20%5Cmathbf%7BX%7D%5E%7B%5Ctop%7D%20%5Cmathbf%7BX%7D%0A" /></p><p>我们知道协方差矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵，<strong>其元素  <img src="https://math.now.sh?inline=%5CSigma_%7Bij%7D" style="display:inline-block;margin: 0;"/> 为特征 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 和特征 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 的协方差</strong>；那么这里类似的，  <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵是一个 <img src="https://math.now.sh?inline=m%20%5Ctimes%20m" style="display:inline-block;margin: 0;"/> 的矩阵，<strong>其元素  <img src="https://math.now.sh?inline=G_%7Bij%7D" style="display:inline-block;margin: 0;"/> 便可解释为个体 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 和个体 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 的协方差</strong>， <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵可以理解为个体间的协方差矩阵。</p>
<p>同时定义 <img src="https://math.now.sh?inline=%5Csigma_%7Bg%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 为所有SNP 解释的方差，比如 <img src="https://math.now.sh?inline=%5Csigma_%7B%5Cmathrm%7Bg%7D%7D%5E%7B2%7D%3Dn%20%5Csigma_%7B%5Cmathrm%7Bu%7D%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，此时上面的模型等价于</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%3D%5Cmathbf%7BK%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cmathbf%7Bg%7D%2B%5Cvarepsilon%20%5Ctext%20%7B%20with%20%7D%20%5Cmathbf%7BV%7D%3D%5Cmathbf%7BG%7D%20%5Csigma_%7B%5Cmathrm%7Bg%7D%7D%5E%7B2%7D%2B%5Cmathbf%7BI%7D%20%5Csigma_%7B%5Cvarepsilon%7D%5E%7B2%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cmathrm%7Bg%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=m%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 的个体的总的加性效应向量，服从分布 <img src="https://math.now.sh?inline=%5Cmathbf%7Bg%7D%20%5Csim%20N%5Cleft%280%2C%20%5Cmathbf%7BG%7D%20%5Csigma_%7B%5Cmathrm%7Bg%7D%7D%5E%7B2%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 。我们注意到，我们上面说 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵可以理解为个体间的协方差矩阵，那为什么这里个体间的协方差矩阵用的是 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D%20%5Csigma_%7B%5Cmathrm%7Bg%7D%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 呢？个人理解，因为构建 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵进行了标准化，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵中的方差或协方差相比于个体间真实的方差或协方差的取值范围不一样，因此需要乘以  <img src="https://math.now.sh?inline=%5Csigma_%7Bg%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/>  来还原。</p>
<h2 id="PCA分析">PCA分析</h2>
<p>PCA 做起来非常简单，就一步，就是对上面的<img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵进行特征值分解，得到的前 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 个特征向量就是我们需要的主成分。</p>
<p>这里我们与一般的PCA分析进行比较，首先我们先看一个简单的性质。当你对矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 乘以一个常数 <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/> <img src="https://math.now.sh?inline=%28%20%5Calpha%20%3E%200%29" style="display:inline-block;margin: 0;"/> 时，设 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的一组特征值和特征向量分别为 <img src="https://math.now.sh?inline=%5Clambda" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmu" style="display:inline-block;margin: 0;"/>,  则 <img src="https://math.now.sh?inline=%5Calpha%20%5Clambda" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmu" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=%5Calpha%20A" style="display:inline-block;margin: 0;"/> 的特征值和特征向量。证明很简单，见下。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Calpha%20A%20%5Cmu%20%26%3D%20%5Calpha%20%5Clambda%20%5Cmu%20%5Cquad%20%E5%B7%A6%E5%8F%B3%E5%90%84%E4%B9%98%E4%BB%A5%E4%B8%80%E4%B8%AA%20%5Calpha%20%5C%5C%0A%28%5Calpha%20A%29%20%5Cmu%20%26%3D%20(%5Calpha%20%5Clambda)%20%5Cmu%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，这说明大于<img src="https://math.now.sh?inline=0" style="display:inline-block;margin: 0;"/>的常数项不会影响我们提取前<img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 个特征向量的结果（特征值绝对大小改变，但是相对大小和排名不变；特征向量不变），因此我们可以忽略 <img src="https://math.now.sh?inline=1%2Fm" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=1%2Fn" style="display:inline-block;margin: 0;"/> 。我们就只需要比较 $ \mathbf{X} \mathbf{X}^{\top}$ 和 $ \mathbf{X}^{\top} \mathbf{X}$ 特征值分解的异同。</p>
<p>我们再回顾一个性质，<strong>矩阵 <img src="https://math.now.sh?inline=A%20A%5E%7BT%7D" style="display:inline-block;margin: 0;"/> 和矩阵 <img src="https://math.now.sh?inline=A%5E%7BT%7D%20A" style="display:inline-block;margin: 0;"/> 的非零特征值相同</strong>，证明如下<a href="https://math.stackexchange.com/questions/1249497/largest-eigenvalues-of-aa-equals-to-aa">^2</a></p>
<blockquote>
<p>For any <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> and <img src="https://math.now.sh?inline=n%20%5Ctimes%20m" style="display:inline-block;margin: 0;"/> matrices <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> and <img src="https://math.now.sh?inline=B" style="display:inline-block;margin: 0;"/>, the nonzero eigenvalues of <img src="https://math.now.sh?inline=A%20B" style="display:inline-block;margin: 0;"/> and <img src="https://math.now.sh?inline=B%20A" style="display:inline-block;margin: 0;"/> are the same. Namely, if <img src="https://math.now.sh?inline=A%20B%20v%3D%5Clambda%20v" style="display:inline-block;margin: 0;"/> with <img src="https://math.now.sh?inline=%5Clambda%20%5Cneq%200" style="display:inline-block;margin: 0;"/> and <img src="https://math.now.sh?inline=v%20%5Cneq%200" style="display:inline-block;margin: 0;"/>, then <img src="https://math.now.sh?inline=B%20v%20%5Cneq%200" style="display:inline-block;margin: 0;"/> （因为 <img src="https://math.now.sh?inline=A%20B%20v%3D%5Clambda%20v%20%5Cneq%200" style="display:inline-block;margin: 0;"/> ，如果 <img src="https://math.now.sh?inline=B%20v%20%3D%200" style="display:inline-block;margin: 0;"/>，则 <img src="https://math.now.sh?inline=ABv%20%3D%200" style="display:inline-block;margin: 0;"/>，与原条件相悖，因此  <img src="https://math.now.sh?inline=B%20v%20%5Cneq%200" style="display:inline-block;margin: 0;"/>  ）and <img src="https://math.now.sh?inline=B%20A%28B%20v%29%3DB(A%20B%20v)%3D%5Clambda%20B%20v" style="display:inline-block;margin: 0;"/>  ，即 <img src="https://math.now.sh?inline=%5Clambda" style="display:inline-block;margin: 0;"/> 同样为 <img src="https://math.now.sh?inline=BA" style="display:inline-block;margin: 0;"/> 的特征值，因此 <img src="https://math.now.sh?inline=AB" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=BA" style="display:inline-block;margin: 0;"/> 的非零特征值相同。</p>
</blockquote>
<p>因此，我们知道 $ \mathbf{X} \mathbf{X}^{\top}$ 和 $ \mathbf{X}^{\top} \mathbf{X}$ 特征值相同，而且根据上面的证明过程，二者的特征向量存在下面的关系。</p>
<p>若 <img src="https://math.now.sh?inline=%28%5Clambda%2C%20%5Cmu%29" style="display:inline-block;margin: 0;"/> 为   $ \mathbf{X}^{\top} \mathbf{X}$ 的一组特征值和特征向量，则 <img src="https://math.now.sh?inline=%28%5Clambda%2C%20X%5Cmu%29" style="display:inline-block;margin: 0;"/> 为  $ \mathbf{X} \mathbf{X}^{\top}$ 的一组特征值和特征向量。也就是我们对 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵和 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 矩阵进行特征值分解，其特征向量的关系为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmu_%7BG%7D%20%3D%20X%20%5Cmu_%7B%5CSigma%7D%0A" /></p><p>其中，<img src="https://math.now.sh?inline=%5Cmu_%7BG%7D" style="display:inline-block;margin: 0;"/>  表示为<img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵的一个特征向量，  <img src="https://math.now.sh?inline=%5Cmu_%20%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 表示为相应的 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 矩阵的一个特征向量。</p>
<p>而，<img src="https://math.now.sh?inline=X%20%5Cmu_%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 就是<strong>所有样本在这个新坐标轴的坐标组成的向量</strong>（<img src="https://math.now.sh?inline=%5Cmu_%20%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 可以理解为新的坐标系的某一个轴）。这就和我们之前提到的先对<strong>特征的协方差矩阵</strong> <img src="https://math.now.sh?inline=%5CSigma" style="display:inline-block;margin: 0;"/> 进行特征值分解，得到特征向量 <img src="https://math.now.sh?inline=%5Cleft%5C%7Bw_%7B1%7D%2C%20w_%7B2%7D%2C%20%5Cldots%2C%20w_%7Bn%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/>  后，再利用特征向量与特征的内积，计算样本点的新坐标 <img src="https://math.now.sh?inline=z" style="display:inline-block;margin: 0;"/> ，这个过程是一致的。</p>
<p>因此，这里证明了直接对 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵进行特征值分解，其特征向量直接就是主成分，这种做法和常规的PCA分析做法是一致的。</p>
<h1>疑问</h1>
<h2 id="构建G阵的假设有哪些？">构建G阵的假设有哪些？</h2>
<p>第一，构建G阵<strong>最重要的假设就是群体处于哈温平衡状态</strong>。在上面推导每一列SNP的方差时便需要用到哈温平衡的假设，但是这个假设我感觉很难成立。与之有关的另一个问题是使用的等位基因频率。我的理解是我们使用的基因型样本可以视为对总体的一个抽样，我们是用我们手上的样本的等位基因频率去估计总体的等位基因频率，那么只有符合哈温平衡时我们这么做才合理。因此只有符合哈温平衡时，不同的世代的等位基因频率才保持不变，因此对当前世代或当前群体的等位基因频率就可以有效地估计总体的等位基因频率。</p>
<p>第二，标记之间彼此独立，换句话说，不存在连锁不平衡，因为这里我们假设所有SNP的分布为  <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D%20%5Csim%20N%5Cleft%280%2C%20%5Cmathbf%7BI%7D%20%5Csigma_%7B%5Cmathrm%7Bu%7D%7D%5E%7B2%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 。</p>
<p>应该没有别的假设了。</p>
<h2 id="当基因型存在缺失时，如何构建的G阵？">当基因型存在缺失时，如何构建的G阵？</h2>
<p>当我们使用 plink 或 GCTA 进行PCA分析时，我们可以直接用下机的基因型数据进行分析，而不需要填充，那么问题来了，此时基因型存在缺失，怎么构建的G阵呢？</p>
<p>GCTA文章指向了 EIGENSTART 软件，然后我就看了这边软件的文章[^3]，原文见下图。</p>
<p>我个人理解是，</p>
<ol>
<li>
<p>首先计算每一列SNP的等位基因频率 <img src="https://math.now.sh?inline=p_%7Bj%7D" style="display:inline-block;margin: 0;"/> 时剔除缺失位点。</p>
</li>
<li>
<p>然后我们对每一列SNP进行标准化，在标准化过程中直接将 <img src="https://math.now.sh?inline=X" style="display:inline-block;margin: 0;"/> 矩阵中基因型缺失的地方设为 0（按照图中的说法，顺序是先进行中心化，再将缺失位点的值调整为0，最后除以标准差）。</p>
<p style=""><img src="https://math.now.sh?from=x_%7Bi%20j%7D%3D%20%5Cbegin%7Bcases%7D%5Cleft%28m_%7Bi%20j%7D-2%20p_%7Bj%7D%5Cright%29%2F%5Csqrt%7B2%20p_%7Bj%7D%5Cleft(1-p_%7Bj%7D%5Cright)%7D%20%26%20%5Ctext%20%7B%20if%20%7D%20x_%7Bi%20j%7D%20%5Ctext%7B%20%E4%B8%8D%E4%B8%BA%E7%BC%BA%E5%A4%B1%7D%20%20%5C%5C%200%20%26%20%5Ctext%20%7B%20if%20%7D%20x_%7Bi%20j%7D%20%5Ctext%7B%20%E7%BC%BA%E5%A4%B1%7D%5Cend%7Bcases%7D%0A" /></p></li>
</ol>
<p>注意，下图中的  <img src="https://math.now.sh?inline=X" style="display:inline-block;margin: 0;"/> 矩阵是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20m" style="display:inline-block;margin: 0;"/> 的矩阵，和本文中使用的 <img src="https://math.now.sh?inline=X" style="display:inline-block;margin: 0;"/> 矩阵不是同一个，二者是互为转置的关系。</p>
<p>这种做法就仍然是采用了极大似然估计的思想，当基因型数据存在缺失，这里用最可能出现的值去填补，也就是用群体均值。那么，这种做法和对基因型进行填充再构建G阵的做法，这两种做法那种更好呢？我个人认为是后者，举个例子，假设某个SNP在群体里中的等位基因频率 <img src="https://math.now.sh?inline=p_j%20%3D%200.3" style="display:inline-block;margin: 0;"/> ，那么当这个位点存在缺失时，按上面的做法相当于我们将其基因型填补为 0.6 ，这百分百是一个错误的估计值，因为一个位点的基因型只能是0,1,2。但是，当我们对基因型进行填充时，利用位点间的连锁不平衡或样本间的亲缘关系，我们有很大的几率将其填充为正确的基因型。当然，在基因型缺失率比较低的情况下，这两种做法结果区别不大。</p>
<p><img src="1.png" alt="1"></p>
<p>[^1]: GCTA: A Tool for Genome-wide Complex Trait Analysis</p>
<p>[^3]: Principal components analysis corrects for stratification in genome-wide association studies</p>
]]></content>
  </entry>
  <entry>
    <title>为什么样本方差分母为n-1</title>
    <url>/posts/c8ae5def/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在学习吴恩达老师的机器学习课上，碰到了一个旧知识点：在统计上，样本方差的分母应该是 n-1 ，这样才是对总体方差的无偏估计。在网上查了很多资料，根据自己的理解总结了一下，水平有限，如有不当之处敬请指正。</p>
<span id="more"></span>
<h1>问题</h1>
<p>首先我们要理清楚问题是什么，假设我们拿到了一组数据，样本数为 n，我们认为这些数据服从<strong>独立同分布</strong>的正态分布，我们想知道它们服从的正态分布的均值和方差是多少，或者说想估计它们服从的正态分布的均值和方差。</p>
<h1>最大似然估计</h1>
<p>这种从已有数据推断参数的事情，第一时间我想的就是最大似然估计。首先，一维正态分布的概率密度函数长这样：</p>
<p style=""><img src="https://math.now.sh?from=f%28x%29%3D%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%7D%20%5Csigma%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B(x-%5Cmu)%5E%7B2%7D%7D%7B2%20%5Csigma%5E%7B2%7D%7D%5Cright)%0A" /></p><p>由于不同的样本服从独立同分布，因此所有样本的联合概率密度函数如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Af%28%5Ctextbf%7Bx%7D%7C%CE%BC%2C%5Csigma%5E%7B2%7D%29%20%26%3D%5Cprod_%7Bi%3D1%7D%5E%7Bn%7D%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%7D%20%5Csigma%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B(x-%5Cmu)%5E%7B2%7D%7D%7B2%20%5Csigma%5E%7B2%7D%7D%5Cright)%20%5C%5C%0A%26%3D%5Cleft(%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%7D%5Csigma%7D%5Cright)%5E%7Bn%7D%20%5Cexp%20%5Cleft(-%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cfrac%7B(x-%5Cmu)%5E%7B2%7D%7D%7B2%20%5Csigma%5E%7B2%7D%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们要求出现这组数据或更极端数据出现的似然值<strong>最大</strong>，也就是求使上式的联合概率密度函数最大的一组参数。我们对联合概率密度函数采用对数函数，可以简化运算：</p>
<p style=""><img src="https://math.now.sh?from=%5Cln%20f%5Cleft%28%5Cmathbf%7Bx%7D%20%5Cmid%20%5Cmu%2C%20%5Csigma%5E%7B2%7D%5Cright%29%3D-%5Cfrac%7B1%7D%7B2%20%5Csigma%5E%7B2%7D%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-%5Cmu%5Cright)%5E%7B2%7D-%5Cfrac%7Bn%7D%7B2%7D%20%5Cln%20%5Csigma%5E%7B2%7D-%5Cfrac%7Bn%7D%7B2%7D%20%5Cln%20(2%20%5Cpi)%0A" /></p><p>为了方便查看，这里我们将 σ<sup>2</sup> 替换为 v 。</p>
<p style=""><img src="https://math.now.sh?from=%5Cln%20f%5Cleft%28%5Cmathbf%7Bx%7D%20%5Cmid%20%5Cmu%2C%20v%5Cright%29%3D-%5Cfrac%7B1%7D%7B2%20v%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-%5Cmu%5Cright)%5E%7B2%7D-%5Cfrac%7Bn%7D%7B2%7D%20%5Cln%20v-%5Cfrac%7Bn%7D%7B2%7D%20%5Cln%20(2%20%5Cpi)%0A" /></p><p>这里要求该式的极值，想到了对该式求偏导，计算两个偏导等于 0 时的参数值。首先对参数 μ 求偏导。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20%5Cmu%7D%20%26%3D-%5Cfrac%7B1%7D%7B2%20v%7D%20%5Ccdot%202%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28x_%7Bi%7D-%5Cmu%5Cright%29(-1)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bv%7D%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20X_%7Bi%7D-n%20%5Cmu%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>求该式为 0 ，得到参数 μ 的最大似然值如下，就是样本均值（下标 ML 表示最大似然估计值，下图）</p>
<p style=""><img src="https://math.now.sh?from=%5Cmu_%7BML%7D%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20X_%7Bi%7D%0A" /></p><p>再对参数 v (即σ<sup>2</sup>) 求偏导</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20v%7D%3D%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28x_%7Bi%7D-%5Cmu%5Cright%29%5E%7B2%7D%20v%5E%7B-2%7D-%5Cfrac%7Bn%7D%7B2%7D%20v%5E%7B-1%7D%0A" /></p><p>求该式为 0 ，得到参数 v  (即σ<sup>2</sup>)  的最大似然值如下。</p>
<p style=""><img src="https://math.now.sh?from=%5Csigma%5E%7B2%7D_%7BML%7D%20%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28x_%7Bi%7D-%5Cmu%5Cright%29%5E%7B2%7D%0A" /></p><p>易证，最大似然估计的两个参数值均为无偏估计，证明如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%28%5Cmu_%7BML%7D%29%20%26%3DE%5Cleft(%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20x_%7Bi%7D%5Cright)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20E%5Cleft(x_%7Bi%7D%5Cright)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%20n%20%5Cmu%20%5C%5C%0A%26%3D%5Cmu%20%5C%5C%0AE%5Cleft(%5Csigma%5E%7B2%7D_%7BML%7D%5Cright)%20%26%3DE%5Cleft(%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-u%5Cright)%5E%7B2%7D%5Cright)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20E%5Cleft(x_%7Bi%7D-u%5Cright)%5E%7B2%7D%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%20n%20%5Csigma%5E%7B2%7D%20%5C%5C%0A%26%3D%5Csigma%5E%7B2%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，最大似然估计的方差是无偏的，没有问题。但是注意，<strong>这里得到的方差估计值的公式中含有总体均值 μ</strong>。看我们的问题，我们并不知道总体均值，我们上面得到了总体均值的最大似然估计值就是样本均值，我们能不能直接将总体均值替换为样本均值呢？就是下式：</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Csigma%5E%7B2%7D%7D%20%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28x_%7Bi%7D-%5Cbar%7BX%7D%5Cright%29%5E%7B2%7D%0A" /></p><p>这里我们可以证明这样做得到的估计量会<strong>低于</strong>极大似然估计值，是一个有偏估计量。</p>
<h1>证明分母为n的样本方差会低于极大似然估计值</h1>
<p>我们这里构建一个函数 f(a)</p>
<p style=""><img src="https://math.now.sh?from=f%28a%29%20%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-a%5Cright)%5E%7B2%7D%0A" /></p><p>求导得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Af'%28a%29%20%26%3D%5Cfrac%7B2%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-a%5Cright)(-1)%20%5C%5C%0A%26%3D%5Cfrac%7B2%7D%7Bn%7D%5Cleft(n%20a-%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20x_%7Bi%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>当导数为 0 时，a 等于</p>
<p style=""><img src="https://math.now.sh?from=a%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20x_%7Bi%7D%3D%5Cbar%7BX%7D%0A" /></p><p>易知，当 a 等于样本均值时，该式最小。因此，下式成立</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28X_%7Bi%7D-%5Cbar%7BX%7D%5Cright%29%5E%7B2%7D%20%5Cleq%20%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(X_%7Bi%7D-%5Cmu%5Cright)%5E%7B2%7D%0A" /></p><p>证明分母为n的样本方差会低估总体方差估计值。</p>
<h2 id="第二种证明方法">第二种证明方法</h2>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Csigma%5E%7B2%7D_%7BML%7D%20%26%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28x_%7Bi%7D-u%5Cright%29%5E%7B2%7D%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(%5Cleft(x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright)%2B(%5Cbar%7Bx%7D-u)%5Cright)%5E%7B2%7D%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright)%5E%7B2%7D%2B%5Cfrac%7B2%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright)(%5Cbar%7Bx%7D-u)%2B(%5Cbar%7Bx%7D-u)%5E%7B2%7D%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright)%5E%7B2%7D%2B%5Cfrac%7B2%7D%7Bn%7D(%5Cbar%7Bx%7D-u)%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20x_%7Bi%7D-n%20%5Cbar%7Bx%7D%5Cright)%2B(%5Cbar%7Bx%7D-u)%5E%7B2%7D%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright)%5E%7B2%7D%2B(%5Cbar%7Bx%7D-u)%5E%7B2%7D%20%5C%5C%0A%26%20%5Cgeqslant%20%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright)%5E%7B2%7D%0A%5Cend%7Baligned%7D%0A" /></p><h1>样本方差推导</h1>
<p>具体小多少，可以通过求期望计算一下<a href="https://www.zhihu.com/question/20099757">^1</a></p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%5Cleft%28%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Cleft(X_%7Bi%7D-%5Cbar%7BX%7D%5Cright%29%5E%7B2%7D%20%5Cright)%20%26%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20E%5Cleft(%5Cleft(X_%7Bi%7D-%5Cbar%7BX%7D%5Cright)%5E%7B2%7D%5Cright)%3D%5Cfrac%7B1%7D%7Bn%7D%20E%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(X_%7Bi%7D-%5Cmu%2B%5Cmu-%5Cbar%7BX%7D%5Cright)%5E%7B2%7D%5Cright)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%20E%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(%5Cleft(X_%7Bi%7D-%5Cmu%5Cright)%5E%7B2%7D-2%5Cleft(X_%7Bi%7D-%5Cmu%5Cright)(%5Cbar%7BX%7D-%5Cmu)%2B(%5Cbar%7BX%7D-%5Cmu)%5E%7B2%7D%5Cright)%5Cright)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%20E%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(X_%7Bi%7D-%5Cmu%5Cright)%5E%7B2%7D-2%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(X_%7Bi%7D-%5Cmu%5Cright)(%5Cbar%7BX%7D-%5Cmu)%2Bn(%5Cbar%7BX%7D-%5Cmu)%5E%7B2%7D%5Cright)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%20E%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(X_%7Bi%7D-%5Cmu%5Cright)%5E%7B2%7D-2%20n(%5Cbar%7BX%7D-%5Cmu)(%5Cbar%7BX%7D-%5Cmu)%2Bn(%5Cbar%7BX%7D-%5Cmu)%5E%7B2%7D%5Cright)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%20E%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(X_%7Bi%7D-%5Cmu%5Cright)%5E%7B2%7D-n(%5Cbar%7BX%7D-%5Cmu)%5E%7B2%7D%5Cright)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20E%5Cleft(%5Cleft(X_%7Bi%7D-%5Cmu%5Cright)%5E%7B2%7D%5Cright)-n%20E%5Cleft((%5Cbar%7BX%7D-%5Cmu)%5E%7B2%7D%5Cright)%5Cright)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D(n%20%5Coperatorname%7BVar%7D(X)-n%20%5Coperatorname%7BVar%7D(%5Cbar%7BX%7D))%20%5C%5C%0A%26%3D%5Coperatorname%7BVar%7D(X)-%5Coperatorname%7BVar%7D(%5Cbar%7BX%7D)%0A%5Cend%7Baligned%7D%0A" /></p><p>其中, <img src="https://math.now.sh?inline=%5Coperatorname%7BVar%7D%28%5Cbar%7BX%7D%29" style="display:inline-block;margin: 0;"/> 证明如下。首先方差存在下面的性质</p>
<blockquote>
<p>If <img src="https://math.now.sh?inline=X_%7B1%7D%2C%20%5Cldots%2C%20X_%7Bn%7D" style="display:inline-block;margin: 0;"/> are independent and <img src="https://math.now.sh?inline=a_%7B1%7D%2C%20%5Cldots%2C%20a_%7Bn%7D" style="display:inline-block;margin: 0;"/> are constants, then</p>
</blockquote>
<p style=""><img src="https://math.now.sh?from=%5Cmathbb%7BV%7D%5Cleft%28%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20a_%7Bi%7D%20X_%7Bi%7D%5Cright%29%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20a_%7Bi%7D%5E%7B2%7D%20%5Cmathbb%7BV%7D%5Cleft(X_%7Bi%7D%5Cright)%0A" /></p><p>所以，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%20%5Coperatorname%7BVar%7D%28%5Cbar%7BX%7D%29%20%5C%5C%0A%3D%26%20%5Coperatorname%7Bvar%7D%5Cleft(%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20x_%7Bi%7D%5Cright)%20%5C%5C%0A%3D%26%20%5Cfrac%7B1%7D%7Bn%5E%7B2%7D%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Coperatorname%7Bvar%7D%5Cleft(x_%7Bi%7D%5Cright)%20%5C%5C%0A%3D%26%20%5Cfrac%7B1%7D%7Bn%5E%7B2%7D%7D%20n%20%5Coperatorname%7Bvar%7D(x)%20%5C%5C%0A%3D%26%20%5Cfrac%7B%5Csigma%5E%7B2%7D%7D%7Bn%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>所以，</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%5Cleft%28%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Cleft(X_%7Bi%7D-%5Cbar%7BX%7D%5Cright%29%5E%7B2%7D%20%5Cright)%26%3D%5Coperatorname%7BVar%7D(X)-%5Coperatorname%7BVar%7D(%5Cbar%7BX%7D)%3D%5Csigma%5E%7B2%7D-%5Cfrac%7B%5Csigma%5E%7B2%7D%7D%7Bn%7D%3D%5Cfrac%7Bn-1%7D%7Bn%7D%20%5Csigma%5E%7B2%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，为了避免使用有偏差的估计值，略加转换，我们得到下式：</p>
<p style=""><img src="https://math.now.sh?from=S%5E%7B2%7D%3D%5Cfrac%7B1%7D%7Bn-1%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28X_%7Bi%7D-%5Cbar%7BX%7D%5Cright%29%5E%7B2%7D%0A" /></p><h2 id="第二种证明方法-2">第二种证明方法</h2>
<p>我感觉像上面一样，直接从 <img src="https://math.now.sh?inline=%5Cmathrm%7BE%7D%28%5Csigma%5E%7B2%7D_%7BML%7D%29" style="display:inline-block;margin: 0;"/> 去推公式，结果更直观一点。首先我们需要拆分一下 <img src="https://math.now.sh?inline=%5Csigma%5E%7B2%7D_%7BML%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p style=""><img src="https://math.now.sh?from=%5Csigma%5E%7B2%7D_%7BML%7D%20%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright%29%5E%7B2%7D%2B(%5Cbar%7Bx%7D-u)%5E%7B2%7D%20%5C%5C%0A" /></p><p>同时对左右两侧求期望，得到：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathrm%7BE%7D%28%5Csigma%5E%7B2%7D_%7BML%7D%29%26%3D%5Cmathrm%7BE%7D%5Cleft(%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright)%5E%7B2%7D%2B(%5Cbar%7Bx%7D-u)%5E%7B2%7D%5Cright)%20%5C%5C%0A%26%3D%5Cmathrm%7BE%7D%5Cleft(%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright)%5E%7B2%7D%5Cright)%20%2B%20%5Cmathrm%7BE%7D%5Cleft((%5Cbar%7Bx%7D-u)%5E%7B2%7D%5Cright)%20%5C%5C%0A%26%3D%5Cmathrm%7BE%7D%5Cleft(%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright)%5E%7B2%7D%5Cright)%20%2B%20%5Coperatorname%7BVar%7D(%5Cbar%7BX%7D)%20%5C%5C%0A%26%3D%5Cmathrm%7BE%7D%5Cleft(%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright)%5E%7B2%7D%5Cright)%20%2B%20%5Cfrac%7B%5Csigma%5E%7B2%7D%7D%7Bn%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>左侧 <img src="https://math.now.sh?inline=%5Csigma%5E%7B2%7D_%7BML%7D" style="display:inline-block;margin: 0;"/> 期望为总体方差 <img src="https://math.now.sh?inline=%5Csigma%5E2" style="display:inline-block;margin: 0;"/> （  <img src="https://math.now.sh?inline=%5Cbecause%20%5Cmathrm%7BE%7D%28%5Csigma%5E%7B2%7D_%7BML%7D%29%20%3D%20%5Csigma%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ） ，因此</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Csigma%5E%7B2%7D%20%26%3D%5Cmathrm%7BE%7D%5Cleft%28%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright%29%5E%7B2%7D%5Cright)%20%2B%20%5Cfrac%7B%5Csigma%5E%7B2%7D%7D%7Bn%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>所以</p>
<p style=""><img src="https://math.now.sh?from=E%5Cleft%28%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Cleft(X_%7Bi%7D-%5Cbar%7BX%7D%5Cright%29%5E%7B2%7D%20%5Cright)%3D%5Csigma%5E%7B2%7D-%5Cfrac%7B%5Csigma%5E%7B2%7D%7D%7Bn%7D%3D%5Cfrac%7Bn-1%7D%7Bn%7D%20%5Csigma%5E%7B2%7D%0A" /></p>]]></content>
      <categories>
        <category>理论学习</category>
        <category>统计</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>python脚本编译及转为exe可执行文件</title>
    <url>/posts/45f5af89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>一般我们执行 python 脚本都是在 python 环境中运行，这里通过将python脚本转化为一个 exe 文件，这样只需要在windows环境下双击 exe 文件就可以运行程序，方便其他人使用。</p>
<span id="more"></span>
<h1>python脚本转为exe方法</h1>
<p>根据某个网上的教程<a href="http://zhaoxuhui.top/blog/2017/05/22/Python%E8%84%9A%E6%9C%AC%E8%BD%ACexe%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6.html">^1</a>，这里使用 PyInstaller 模块实现这个功能。</p>
<h2 id="安装-PyInstaller">安装 PyInstaller</h2>
<p>在 windows 的控制台下，运行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install pyinstaller</span><br></pre></td></tr></table></figure>
<h2 id="python-转为-exe">python 转为 exe</h2>
<p>在 windows 的控制台下，运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyinstaller -F split_plink.py</span><br></pre></td></tr></table></figure>
<p>在当前目录下会生成很多文件夹和文件，其他都不用管，我们需要的就是 <code>dist</code> 目录下的  <code>split_plink.exe</code> 程序文件。</p>
<p>这里如果不使用 <code>-F</code> 选项，那么 <code>dist</code> 目录下除了相应的 <code>exe</code> 文件还会生成很多别的文件，运行 <code>exe</code> 程序时，必须同时包含<code>dist</code> 文件夹下的其他文件，只有  <code>exe</code> 程序 运行不成功。我们使用了  <code>-F</code> 选项 ，就只有一个  <code>exe</code> 程序 ，拷贝程序只要拷贝这个 <code>exe</code> 程序即可，更加方便。</p>
<p>如果不想要控制台窗口，可以采用 <code>-w</code> 选项。</p>
<blockquote>
<p>注意PyInstaller打包的执行文件，只能在和打包机器系统同样的环境下。也就是说，不具备可移植性，若需要在不同系统上运行，就必须针对该平台进行打包<a href="%5Bpython%E4%B9%8Bpyinstaller%E5%BA%93%E5%B0%86python%E8%84%9A%E6%9C%AC%E7%BC%96%E8%AF%91%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%EF%BC%88windows%E7%B3%BB%E7%BB%9F%EF%BC%89%5D(https://www.cnblogs.com/hls-code/p/15005345.html)">^2</a>。</p>
</blockquote>
<h2 id="更详细的解释">更详细的解释</h2>
<p>可见 <a href="https://www.cnblogs.com/hls-code/p/15005345.html">python之pyinstaller库将python脚本编译成可执行程序（windows系统）</a> <a href="%5Bpython%E4%B9%8Bpyinstaller%E5%BA%93%E5%B0%86python%E8%84%9A%E6%9C%AC%E7%BC%96%E8%AF%91%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%EF%BC%88windows%E7%B3%BB%E7%BB%9F%EF%BC%89%5D(https://www.cnblogs.com/hls-code/p/15005345.html)">^2</a></p>
<h1>python 脚本编译</h1>
<p>python 脚本文件经过编译后可以生成 pyc 文件，提高加载速度。</p>
<p>对于单个 python 脚本，可以通过下面的 python 命令编译</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> py_compile</span><br><span class="line">py_compile.<span class="built_in">compile</span>(<span class="string">&#x27;*.py&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>命令行方式为 <code>python -m *.py</code> ，但是这种方式我试了会报错（如果脚本用 <code>sys.argv</code> 传参的话）。</p>
<p>针对一个目录下所有的 python 脚本，可以通过 <code>compileall</code> 模块来批量化编译（目录的绝对路径前面加 ‘r’ ，是为了告诉编译器这是个 <code>raw string</code> ，不要对该字符串转意）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> compileall</span><br><span class="line">compileall.compile_dir(<span class="string">r&#x27;/path&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>注意，编译以后得到 pyc 文件只能在编译时的 python 编译器下运行，否则可能会报错，报错信息类似下面。根据网上的说法，只要运行 pyc 文件采用的 python 编译器版本与编译时用的一样就行，举例而言，就是说你在 3.7 版本的  python 编译器编译得到的 pyc 文件只能在 3.7 版本下运行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RuntimeError: Bad magic number <span class="keyword">in</span> .pyc file</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么最大似然估计使用概率密度</title>
    <url>/posts/f86994ef/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在看极大似然估计的公式时，一个问题一直盘旋在我的心中，为什么对于连续变量采用概率密度函数呢？</p>
<span id="more"></span> 
<h1>极大似然估计概述</h1>
<p>直接把维基百科的话复制过来如下<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1">^1</a>：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BL%7D%5Cleft%28%5Ctheta%20%5Cmid%20x_%7B1%7D%2C%20%5Cldots%2C%20x_%7Bn%7D%5Cright%29%3Df_%7B%5Ctheta%7D%5Cleft(x_%7B1%7D%2C%20%5Cldots%2C%20x_%7Bn%7D%5Cright)%0A" /></p><p>若 <img src="https://math.now.sh?inline=D" style="display:inline-block;margin: 0;"/> 是离散分布， <img src="https://math.now.sh?inline=f_%7B%5Ctheta%7D" style="display:inline-block;margin: 0;"/> 即是在参数为 <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/> 时观测到这一采样的概率。**若其是连续分布， <img src="https://math.now.sh?inline=f_%7B%5Ctheta%7D" style="display:inline-block;margin: 0;"/> 则为 <img src="https://math.now.sh?inline=X_%7B1%7D%2C%20X_%7B2%7D%2C%20%5Cldots%2C%20X_%7Bn%7D" style="display:inline-block;margin: 0;"/> 联合分布的概率密度函数在观测值处的取值。**一旦我们获得 <img src="https://math.now.sh?inline=X_%7B1%7D%2C%20X_%7B2%7D%2C%20%5Cldots%2C%20X_%7Bn%7D" style="display:inline-block;margin: 0;"/>, 我们就能求得一个关于 <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/> 的估计。最大似然估计会寻找关于 <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/> 的最可能的值 (即, 在所<br>
注意</p>
<ul>
<li>这裡的似然函数是指 <img src="https://math.now.sh?inline=x_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Cldots%2C%20x_%7Bn%7D" style="display:inline-block;margin: 0;"/> 不变时， 关于 <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/> 的一个函数。</li>
<li>最大似然估计不一定存在，也不一定唯一。</li>
</ul>
<h1>问题</h1>
<p>我同时查看了很多知乎上的回答，基本上所有人提到 <img src="https://math.now.sh?inline=X" style="display:inline-block;margin: 0;"/> 为<strong>连续变量</strong>时，则似然函数采用联合概率密度值。就仅仅是这么一笔带过，没有人给我任何解释为什么这里用概率密度。但是，所有人在解释极大似然的含义时，均称极大似然函数在参数为 <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/> 时这些样本点出现的概率或可能性。那么我的问题来了，<strong>极大似然为什么用概率密度函数表示这些点出现的概率？</strong></p>
<p>学过概率论都知道，第一，<strong>概率密度不是概率，概率密度函数的积分才是概率</strong>，你怎么指着概率密度说是概率呢？；第二，<strong>连续变量在某一点的概率为0</strong>，所以你说连续变量出现在某一个点的概率高低根本毫无意义啊。</p>
<p>我知道似然函数定义就是这样，但我觉得如果有人只告诉我定义就是这样，这不能让我信服。</p>
<p>我一开始有一个误解，我为了说通似然函数采用概率密度这件事，我将其理解成 P值的概念，即<strong>出现比这个残差相同或更极端情况的概率</strong>。比如正态分布，画出图像如下（图片来自网络，侵删）。我们可以看到出现这个残差或更极端情况的概率，与<strong>该残差的概率密度函数的值的大小成正比</strong>。于是似然函数中直接使用概率密度貌似就可以理解了。但是我慢慢发现，这个理解不对。</p>
<p><img src="1.png" alt="1"></p>
<h1>新的理解</h1>
<p>后面我查看Fisher在1922年发表的论文<a href="https://royalsocietypublishing.org/doi/10.1098/rsta.1922.0009">^2</a>，这好像也是第一次提论最大似然的地方。水平有限，看不太懂，但我还是找到了 Fisher 对于最大似然的阐述：</p>
<p><img src="2.png" alt="1"></p>
<p>我不是很理解第二个公式是怎么得到的，但从第一个公式我们可以清楚地看到，对于连续变量 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> ，<strong>极大似然需要最大化的是在该点的相邻区域的出现概率</strong>。</p>
<p>这里仍然用一元正态分布的图来直观理解一下，需要计算的相邻区域的概率即为下图阴影区域，根据微积分，其计算公式为 <img src="https://math.now.sh?inline=P%20%3D%20f%28x%29dx" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=P%20%5Cpropto%20f%28x%29" style="display:inline-block;margin: 0;"/> ，因此，<img src="https://math.now.sh?inline=%5Carg%20%5Cmax_%7B%5Ctheta%7D%20P%20%3D%20%5Carg%20%5Cmax_%7B%5Ctheta%7D%20f%28x%29" style="display:inline-block;margin: 0;"/> ，所以似然函数可以直接使用（联合）概率密度函数的值。</p>
<p><img src="3.png" alt="1"></p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>统计</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>吴恩达CS229机器学习笔记-上</title>
    <url>/posts/1cf2f50c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这门课果然和上一门课《吴恩达机器学习》不一样，感觉上一门课偏通识，这门课偏理论推导。感谢吴恩达老师！</p>
<span id="more"></span>
<h1>课程来源</h1>
<p><a href="https://www.bilibili.com/video/BV1EW411R7g6/">斯坦福 吴恩达《CS229机器学习》</a>:  这个是2008年的，评论说是更加经典的一版。</p>
<p><a href="https://github.com/econti/cs229">cs229</a> ： 我找到的讲义。</p>
<h1>机器学习的动机与应用</h1>
<p>机器学习的定义如下，重点在于不需要具体地告诉机器怎么做，我感觉像“专家系统”这种就不是很智能了，这是由行业专家的经验加上一系列判断组成的，这个系统一旦构建好就是固定的，没法移植到别的数据上。更加符合机器学习的定义的情况应该是，我给你一堆数据/特征和它们的标签，给你一个函数表现的数字标准，机器自动从这些数据中找出规律，进行预测。如果更换了别的数据，代码不需要变动，机器又会从新的数据中学习到新的规律。</p>
<p><img src="1.png" alt="1"></p>
<h1><s>监督学习应用梯度下降</s></h1>
<p>这一部分内容可见张贤达老师的《矩阵分析与应用》更加详细，或者看我整理的博客内容，<a href="https://vincere.fun/posts/55264e6f/">矩阵微分与正规方程组推导</a></p>
<h2 id="矩阵求导-matrix-derivatives">矩阵求导 (matrix derivatives)</h2>
<p>线性回归的方程式求解，吴老师有一个自己的符号，可以简化推导。</p>
<p>首先，我们将梯度下降写成向量形式，已知梯度可以写成一个向量</p>
<p style=""><img src="https://math.now.sh?from=%5Cnabla_%7B%5Ctheta%7D%20J%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cfrac%7B%5Cpartial%20J%7D%7B%5Cpartial%20%5Ctheta_%7B0%7D%7D%20%5C%5C%0A%5Cfrac%7B%5Cpartial%20%5Cpi%7D%7B%5Cpartial%20%5Ctheta_%7B2%7D%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bn%2B1%7D%0A" /></p><p>因此，每次梯度下降参数变化如下，这里的 θ 也是一个 n+1 维的向量。</p>
<p style=""><img src="https://math.now.sh?from=%5Ctheta%20%3D%20%5Ctheta%20-%20%5Calpha%5Cnabla_%7B%5Ctheta%7D%20J%0A" /></p><p>假设你有一个函数，输入是一个 m×n 的矩阵，输出是一个实数。</p>
<p style=""><img src="https://math.now.sh?from=f%20%3A%20R%5E%7Bm%C3%97n%7D%20%5Crightarrow%20R%0A" /></p><p>这里定义<strong>函数 f 关于它的输入矩阵的梯度</strong>，这里也定义为一个矩阵。</p>
<p style=""><img src="https://math.now.sh?from=%5Cnabla_%7BA%7D%20f%28A%29%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D%0A%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20A_%7B11%7D%7D%20%26%20%5Ccdots%20%26%20%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20A_%7B1%20n%7D%7D%20%5C%5C%0A%5Cvdots%20%26%20%5Ccdots%20%26%20%5Cvdots%20%5C%5C%0A%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20A_%7Bn1%7D%7D%20%26%20%5Ccdots%20%26%20%5Cfrac%7B%5Cpartial%20t%7D%7B%5Cpartial%20A%20n%20n%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>举个例子，假设 A 为一个 2×2 的方阵。存在一个函数 f(A) 如下：</p>
<p style=""><img src="https://math.now.sh?from=A%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0AA_%7B11%7D%20%26%20A_%7B12%7D%20%5C%5C%0AA_%7B21%7D%20%26%20A_%7B22%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p style=""><img src="https://math.now.sh?from=f%28A%29%3D%5Cfrac%7B3%7D%7B2%7D%20A_%7B11%7D%2B5%20A_%7B12%7D%5E%7B2%7D%2BA_%7B21%7D%20A_%7B22%7D%0A" /></p><p>因此，这里我们既可以函数 f 的梯度，如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cnabla_%7BA%7D%20f%28A%29%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cfrac%7B3%7D%7B2%7D%20%26%2010%20A_%7B12%7D%20%5C%5C%0AA_%7B22%7D%20%26%20A_%7B21%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><h2 id="迹的定义与性质">迹的定义与性质</h2>
<p>另一个定义，如果 A 是一个n×n的方阵。 矩阵 A 的<strong>迹</strong>就是对角线元素之后。</p>
<p style=""><img src="https://math.now.sh?from=tr%28A%29%20%3D%20%5Csum_%7Bi%3D1%7D%5En%20A_%7Bii%7D%0A" /></p><p>存在下列定理</p>
<p style=""><img src="https://math.now.sh?from=tr%28AB%29%20%3D%20tr(BA)%0A" /></p><p>因此，引申出</p>
<p style=""><img src="https://math.now.sh?from=tr%28ABC%29%20%3D%20tr(CAB)%20%3D%20tr(BCA)%0A" /></p><h2 id="trAB-trBA-证明">trAB = trBA 证明</h2>
<p>假设 A 为 m × n 的矩阵，B 为 n × m 的矩阵，运用矩阵乘法，存在下式</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Btr%7D%28A%20B%29%20%26%3D%5Csum_%7Bi%3D1%7D%5E%7BM%7D%20A%20B_%7Bi%20i%7D%20%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20A_%7Bi%20j%7D%20B_%7Bj%20i%7D%0A%5Cend%7Baligned%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Btr%7D%28B%20A%29%20%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20B%20A_%7Bj%20j%7D%20%5C%5C%0A%26%3D%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20B_%7Bji%7D%20A_%7Bi%20j%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>观察一下，得知二者相等，得证 trAB = trBA 。</p>
<h2 id="矩阵求导的性质">矩阵求导的性质</h2>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cnabla_%7BA%7D%20%5Coperatorname%7Btr%7D%20A%20B%20%26%3DB%5E%7BT%7D%20%5C%5C%0A%5Cnabla_%7BA%5E%7BT%7D%7D%20f%28A%29%20%26%3D%5Cleft(%5Cnabla_%7BA%7D%20f(A)%5Cright)%5E%7BT%7D%20%5C%5C%0A%5Cnabla_%7BA%7D%20%5Coperatorname%7Btr%7D%20A%20B%20A%5E%7BT%7D%20C%20%26%3DC%20A%20B%2BC%5E%7BT%7D%20A%20B%5E%7BT%7D%20%5C%5C%0A%5Cnabla_%7BA%7D%7CA%7C%20%26%3D%7CA%7C%5Cleft(A%5E%7B-1%7D%5Cright)%5E%7BT%7D%0A%5Cend%7Baligned%7D%0A" /></p><h3 id="证明第一条性质">证明第一条性质</h3>
<p>假设 A 为 m × n 的矩阵，B 为 n × m 的矩阵,  tr(AB) 为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Btr%7D%28A%20B%29%20%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20A%20B_%7Bi%20i%7D%20%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20A_%7Bi%20j%7D%20B_%7Bj%20i%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>已知当你对 A<sub>ij</sub> 求导时，其导数为 B<sub>ji</sub> ，因此该式的导数便是 B 的转置矩阵。</p>
<h3 id="证明第二条性质">证明第二条性质</h3>
<p>一开始我理解错了这条公式的含义，我理解成了</p>
<p style=""><img src="https://math.now.sh?from=%5Cnabla_%7BA%5E%7BT%7D%7D%20f%28A%5E%7BT%7D%29%20%3D%5Cleft(%5Cnabla_%7BA%7D%20f(A)%5Cright)%5E%7BT%7D%0A" /></p><p>完全不知道怎么证明，最后是代入上面哪个例子，证伪了。</p>
<p style=""><img src="https://math.now.sh?from=%5Cnabla_%7BA%5E%7BT%7D%7D%20f%28A%5E%7BT%7D%29%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cfrac%7B3%7D%7B2%7D%20%26%2010%20A_%7B12%7D%5E%7BT%7D%20%5C%5C%0AA_%7B22%7D%5E%7BT%7D%20%26%20A_%7B21%7D%5E%7BT%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cfrac%7B3%7D%7B2%7D%20%26%2010%20A_%7B21%7D%20%5C%5C%0AA_%7B22%7D%20%26%20A_%7B12%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>这个解显然不是上面的梯度矩阵的转置矩阵，因此该式不成立。</p>
<p>这条性质应该是左边，左边式子中还是 f(A) ，因此这个式子含义还是说对输入为 A 矩阵的f 函数求梯度，而不是对 A<sup>T</sup> 。这个式子仅仅是说梯度矩阵里面的元素排列按照 A<sup>T</sup> 的顺序，也就是这条式子仅仅是左右两边写法不一样而已，目前我个人理解是这样。</p>
<p style=""><img src="https://math.now.sh?from=%5Cnabla_%7BA%5E%7BT%7D%7D%20f%28A%29%0A" /></p><p>简单证明如下，左式中随便取一个元素，均存在</p>
<p style=""><img src="https://math.now.sh?from=%5Cnabla_%7BA%5E%7BT%7D%7D%20f%28A%29_%7Bij%7D%20%3D%5Cleft(%5Cnabla_%7BA%7D%20f(A)%5Cright)_%7Bji%7D%0A" /></p><p>因此，左右两式互为转置函数。（这个矩阵就是 Jacobian 矩阵，和梯度矩阵互为转置）</p>
<h3 id="证明第三条性质">证明第三条性质</h3>
<p style=""><img src="https://math.now.sh?from=%5Cnabla_%7BA%7D%20%5Coperatorname%7Btr%7D%20A%20B%20A%5E%7BT%7D%20C%20%3DC%20A%20B%2BC%5E%7BT%7D%20A%20B%5E%7BT%7D%0A" /></p><p>不会证明，没有头绪。</p>
<h3 id="证明第四条性质">证明第四条性质</h3>
<p style=""><img src="https://math.now.sh?from=%5Cnabla_%7BA%7D%7CA%7C%20%3D%7CA%7C%5Cleft%28A%5E%7B-1%7D%5Cright%29%5E%7BT%7D%0A" /></p><p>我看懂讲义下面的描述了，这个设计到线性代数的一些知识。</p>
<p><img src="2.png" alt="2"></p>
<h2 id="线性回归求解">线性回归求解</h2>
<p>有了矩阵求导的帮助后，我们可以查看使得 J(θ) 最小的参数。</p>
<p>首先我们要将 J(θ) 写成矩阵形式</p>
<p>我们定义设计矩阵 X 是一个 m × n+1 维度的矩阵，表示训练集的输入值：（m 为样本数，n + 1 为参数数目）</p>
<p style=""><img src="https://math.now.sh?from=X%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A-%5Cleft%28x%5E%7B(1%29%7D%5Cright)%5E%7BT%7D-%20%5C%5C%0A-%5Cleft(x%5E%7B(2)%7D%5Cright)%5E%7BT%7D-%20%5C%5C%0A%5Cvdots%20%5C%5C%0A-%5Cleft(x%5E%7B(m)%7D%5Cright)%5E%7BT%7D-%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>训练集的反应变量为</p>
<p style=""><img src="https://math.now.sh?from=%5Cvec%7By%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0Ay%5E%7B%281%29%7D%20%5C%5C%0Ay%5E%7B(2)%7D%20%5C%5C%0A%5Cvdots%20%5C%5C%0Ay%5E%7B(m)%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>因此，估计值与真值之差为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0AX%20%5Ctheta-%5Cvec%7By%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cleft%28x%5E%7B(1%29%7D%5Cright)%5E%7BT%7D%20%5Ctheta%20%5C%5C%0A%5Cvdots%20%5C%5C%0A%5Cleft(x%5E%7B(m)%7D%5Cright)%5E%7BT%7D%20%5Ctheta%0A%5Cend%7Barray%7D%5Cright%5D-%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0Ay%5E%7B(1)%7D%20%5C%5C%0A%5Cvdots%20%5C%5C%0Ay%5E%7B(m)%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0Ah_%7B%5Ctheta%7D%5Cleft(x%5E%7B(1)%7D%5Cright)-y%5E%7B(1)%7D%20%5C%5C%0A%5Cvdots%20%5C%5C%0Ah_%7B%5Ctheta%7D%5Cleft(x%5E%7B(m)%7D%5Cright)-y%5E%7B(m)%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A%5Cend%7Bgathered%7D%0A" /></p><p>因此，损失函数可以写成：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cfrac%7B1%7D%7B2%7D%28X%20%5Ctheta-%5Cvec%7By%7D%29%5E%7BT%7D(X%20%5Ctheta-%5Cvec%7By%7D)%20%26%3D%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft(h_%7B%5Ctheta%7D%5Cleft(x%5E%7B(i)%7D%5Cright)-y%5E%7B(i)%7D%5Cright)%5E%7B2%7D%20%5C%5C%0A%26%3DJ(%5Ctheta)%0A%5Cend%7Baligned%7D%0A" /></p><p>联用第二条性质和第三条性质，因此下式成立：</p>
<p style=""><img src="https://math.now.sh?from=%5Cnabla_%7BA%5E%7BT%7D%7D%20%5Coperatorname%7Btr%7D%20A%20B%20A%5E%7BT%7D%20C%3DB%5E%7BT%7D%20A%5E%7BT%7D%20C%5E%7BT%7D%2BB%20A%5E%7BT%7D%20C%0A" /></p><p>因此，下式成立。前三步不用讲，第四步可以转为<strong>迹</strong>的理由是，因此 J(θ) 是一个实数，一个实数的迹等于它本身；第五步利用 trA = trA<sup>T</sup> 这一性质。第六步应用上面的性质，其中 A<sup>T</sup> = θ， B = B<sup>T</sup> = X<sup>T</sup>X ， C = I 。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cnabla_%7B%5Ctheta%7D%20J%28%5Ctheta%29%20%26%3D%5Cnabla_%7B%5Ctheta%7D%20%5Cfrac%7B1%7D%7B2%7D(X%20%5Ctheta-%5Cvec%7By%7D)%5E%7BT%7D(X%20%5Ctheta-%5Cvec%7By%7D)%20%5C%5C%0A%26%3D%5Cnabla_%7B%5Ctheta%7D%20%5Cfrac%7B1%7D%7B2%7D(%5Ctheta%5E%7BT%7DX%5E%7BT%7D-%5Cvec%7By%7D%5E%7BT%7D)(X%20%5Ctheta-%5Cvec%7By%7D)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7B2%7D%20%5Cnabla_%7B%5Ctheta%7D%5Cleft(%5Ctheta%5E%7BT%7D%20X%5E%7BT%7D%20X%20%5Ctheta-%5Ctheta%5E%7BT%7D%20X%5E%7BT%7D%20%5Cvec%7By%7D-%5Cvec%7By%7D%5E%7BT%7D%20X%20%5Ctheta%2B%5Cvec%7By%7D%5E%7BT%7D%20%5Cvec%7By%7D%5Cright)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7B2%7D%20%5Cnabla_%7B%5Ctheta%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Ctheta%5E%7BT%7D%20X%5E%7BT%7D%20X%20%5Ctheta-%5Ctheta%5E%7BT%7D%20X%5E%7BT%7D%20%5Cvec%7By%7D-%5Cvec%7By%7D%5E%7BT%7D%20X%20%5Ctheta%2B%5Cvec%7By%7D%5E%7BT%7D%20%5Cvec%7By%7D%5Cright)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7B2%7D%20%5Cnabla_%7B%5Ctheta%7D%5Cleft(%5Coperatorname%7Btr%7D%20%5Ctheta%5E%7BT%7D%20X%5E%7BT%7D%20X%20%5Ctheta-2%20%5Coperatorname%7Btr%7D%20%5Cvec%7By%7D%5E%7BT%7D%20X%20%5Ctheta%5Cright)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7B2%7D%5Cleft(X%5E%7BT%7D%20X%20%5Ctheta%2BX%5E%7BT%7D%20X%20%5Ctheta-2%20X%5E%7BT%7D%20%5Cvec%7By%7D%5Cright)%20%5C%5C%0A%26%3DX%5E%7BT%7D%20X%20%5Ctheta-X%5E%7BT%7D%20%5Cvec%7By%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>为了求 J(θ) 的最小值，<strong>我们将其导数设为0</strong>。因此我们获得了<strong>正规方程组(normal equations)</strong>。</p>
<p style=""><img src="https://math.now.sh?from=X%5E%7BT%7D%20X%20%5Ctheta%3DX%5E%7BT%7D%20%5Cvec%7By%7D%0A" /></p><p>因此，</p>
<p style=""><img src="https://math.now.sh?from=%5Ctheta%3D%5Cleft%28X%5E%7BT%7D%20X%5Cright%29%5E%7B-1%7D%20X%5E%7BT%7D%20%5Cvec%7By%7D%0A" /></p><p>吴老师这个证明思路是很巧妙，但是我感觉有点像是为了证明而证明。我看张沅老师的教材《畜禽育种中的线性模型》中就是直接矩阵求导，一点也不麻烦，吴老师这种看着更绕。</p>
<h2 id="最小二乘的概率学解释">最小二乘的概率学解释</h2>
<p>首先，我们假定目标变量和输入变量的关系如下</p>
<p style=""><img src="https://math.now.sh?from=y%5E%7B%28i%29%7D%3D%5Ctheta%5E%7BT%7D%20x%5E%7B(i)%7D%2B%5Cepsilon%5E%7B(i)%7D%0A" /></p><p>这里添加了一个误差项，误差项的来源包括<strong>未添加到模型中的因素</strong>和<strong>随机噪音 (random noise)</strong>。我们进一步假设误差间服从<strong>独立同分布</strong>的<strong>正态分布</strong>，其<strong>均值为0</strong>。即可以写作</p>
<p style=""><img src="https://math.now.sh?from=%5Cepsilon%5E%7B%28i%29%7D%20%5Csim%20N(0%2C%5Csigma%5E%7B2%7D)%0A" /></p><p>其概率密度函数为</p>
<p style=""><img src="https://math.now.sh?from=p%5Cleft%28%5Cepsilon%5E%7B(i%29%7D%5Cright)%3D%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%7D%20%5Csigma%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B%5Cleft(%5Cepsilon%5E%7B(i)%7D%5Cright)%5E%7B2%7D%7D%7B2%20%5Csigma%5E%7B2%7D%7D%5Cright)%0A" /></p><p>也就是</p>
<p style=""><img src="https://math.now.sh?from=p%5Cleft%28y%5E%7B(i%29%7D%20%5Cmid%20x%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%3D%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%7D%20%5Csigma%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B%5Cleft(y%5E%7B(i)%7D-%5Ctheta%5E%7BT%7D%20x%5E%7B(i)%7D%5Cright)%5E%7B2%7D%7D%7B2%20%5Csigma%5E%7B2%7D%7D%5Cright)%0A" /></p><p>下式表明给定 x<sup>(i)</sup> 和 θ 值时 y<sup>(i)</sup> 的 分布，注意这里不是条件分布。</p>
<p style=""><img src="https://math.now.sh?from=p%5Cleft%28y%5E%7B(i%29%7D%20%5Cmid%20x%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%0A" /></p><p>为什么可以这么写呢？因为残差服从正态分布，就是说明反应变量也是服从正态分布，其分布如下</p>
<p style=""><img src="https://math.now.sh?from=y%5E%7B%28i%29%7D%20%5Csim%20N(%5Ctheta%5E%7BT%7D%20x%5E%7B(i)%7D%2C%5Csigma%5E%7B2%7D)%0A" /></p><p>下面这段话没太看懂。哦哦，这里就是说上面那个函数看上去像是对 y<sup>(i)</sup> 的函数，我们想得到一个关于参数 θ 的函数，我们就将上面这个函数换一个高大上一点的名字，<strong>似然函数</strong>，视为关于参数 θ 的函数，函数值也给一个新的名称，<strong>似然值</strong>，而不是概率。</p>
<p><strong>参数的似然值，数据的概率</strong>。这样说就很明确了。注意要这么说，我们要挑一组参数，使得<strong>这组参数的似然值最大，或者说这些数据出现的概率/可能性最大</strong>。</p>
<p><img src="3.png" alt="2"></p>
<p>基于残差的<strong>独立性</strong>假设（因此，x 和 y 也是彼此独立的 ），我们可以写成：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AL%28%5Ctheta%29%20%26%3D%5Cprod_%7Bi%3D1%7D%5E%7Bm%7D%20p%5Cleft(y%5E%7B(i)%7D%20%5Cmid%20x%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%20%5C%5C%0A%26%3D%5Cprod_%7Bi%3D1%7D%5E%7Bm%7D%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%7D%20%5Csigma%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B%5Cleft(y%5E%7B(i)%7D-%5Ctheta%5E%7BT%7D%20x%5E%7B(i)%7D%5Cright)%5E%7B2%7D%7D%7B2%20%5Csigma%5E%7B2%7D%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>我们需要找到使得 L(θ) 最大的一组参数。我们可以先用 log 函数简化运算：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cell%28%5Ctheta%29%20%26%3D%5Clog%20L(%5Ctheta)%20%5C%5C%0A%26%3D%5Clog%20%5Cprod_%7Bi%3D1%7D%5E%7Bm%7D%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%7D%20%5Csigma%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B%5Cleft(y%5E%7B(i)%7D-%5Ctheta%5E%7BT%7D%20x%5E%7B(i)%7D%5Cright)%5E%7B2%7D%7D%7B2%20%5Csigma%5E%7B2%7D%7D%5Cright)%20%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Clog%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%7D%20%5Csigma%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B%5Cleft(y%5E%7B(i)%7D-%5Ctheta%5E%7BT%7D%20x%5E%7B(i)%7D%5Cright)%5E%7B2%7D%7D%7B2%20%5Csigma%5E%7B2%7D%7D%5Cright)%20%5C%5C%0A%26%3Dm%20%5Clog%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%7D%20%5Csigma%7D-%5Cfrac%7B1%7D%7B%5Csigma%5E%7B2%7D%7D%20%5Ccdot%20%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft(y%5E%7B(i)%7D-%5Ctheta%5E%7BT%7D%20x%5E%7B(i)%7D%5Cright)%5E%7B2%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，最大似然估计结果同样是使得最小二乘误差最小：</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%28y%5E%7B(i%29%7D-%5Ctheta%5E%7BT%7D%20x%5E%7B(i)%7D%5Cright)%5E%7B2%7D%0A" /></p><p>下面这段话没太看懂。大概意思是说虽然当满足一些假设下，最小二乘的解与最大似然相同，但是二者还是不一样的，最小二乘并不需要满足最大似然的那些假设，或者说还有别的方式可以证实最小二乘算法的有效性。</p>
<p><img src="4.png" alt="2"></p>
<h1>欠拟合和过拟合</h1>
<h2 id="Locally-weighted-linear-regression">Locally weighted linear regression</h2>
<p>假设有这样的数据，如果我们用正常的线性回归是<strong>欠拟合</strong>的。</p>
<p><img src="5.png" alt="2"></p>
<p>假如你有足够的训练集数据，你可以构建局部加权回归（LWR）, 其代价函数改为</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bi%7D%20w%5E%7B%28i%29%7D%5Cleft(y%5E%7B(i)%7D-%5Ctheta%5E%7BT%7D%20x%5E%7B(i)%7D%5Cright)%5E%7B2%7D%0A" /></p><p>其中 w<sup>(i)</sup> 为非负数的权重。如果某个样本的权重很大，那么就会尽可以缩减其误差方差；如果某个样本的样本的权重很小，那么我们就不会管这个样本的误差方差。（这样 w 参数的数目与样本数目相同，参数的数目也太多了吧）</p>
<p>权重的一个标准选择是</p>
<p style=""><img src="https://math.now.sh?from=w%5E%7B%28i%29%7D%3D%5Cexp%20%5Cleft(-%5Cfrac%7B%5Cleft(x%5E%7B(i)%7D-x%5Cright)%5E%7B2%7D%7D%7B2%20%5Ctau%5E%7B2%7D%7D%5Cright)%0A" /></p><p>如果 x 与 x<sup>(i)</sup> 很接近，那么 w<sup>(i)</sup> 就会接近于 1 ；如果  x 与 x<sup>(i)</sup> 距离很远，那么 w<sup>(i)</sup> 就会接近于 0。因此这样拟合的结果就是只注重与 x<sup>(i)</sup> 距离近的点，忽略那些距离很远的点的贡献。这里的参数 τ 为<strong>波长参数</strong>，它控制了权重随距离下降的幅度，这个参数越大，下降幅度越慢，有点类似与正态分布的标准差，都是钟形。</p>
<p><img src="6.png" alt="2"></p>
<p>也就说，你每次预测某个 x<sup>(i)</sup> 时，你都需要用这个算法拟合一次参数，才能得到预测值。这一组参数就是特定的与  x<sup>(i)</sup> 绑定的一组参数。所以这是一种<strong>非参数方法</strong>。</p>
<h2 id="逻辑回归">逻辑回归</h2>
<p>略，对我没有新东西</p>
<h1>牛顿方法</h1>
<p><strong>牛顿方法是和梯度下降一样，求函数极值的方法</strong>。</p>
<p>假设存在一个函数 f(θ): R → R，你想找到一个θ值，使得 f(θ) = 0 。 我们可以用牛顿方法使用下式来不断更新 θ 值</p>
<p style=""><img src="https://math.now.sh?from=%5Ctheta%3A%3D%5Ctheta-%5Cfrac%7Bf%28%5Ctheta%29%7D%7Bf%5E%7B%5Cprime%7D(%5Ctheta)%7D%0A" /></p><p>后面这部分就相当于目前位置与切线和X轴交点的距离。</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7Bf%28%5Ctheta%29-0%7D%7Bf%5E%7B%5Cprime%7D(%5Ctheta)%7D%20%3D%20%5Cfrac%7B%5CDelta%20f%7D%7Bf%5E%7B%5Cprime%7D(%5Ctheta)%7D%20%3D%20%7B%5CDelta%20%5Ctheta%7D%0A" /></p><p>因此每一次就是迭代到切线与X轴的交点，画图如下</p>
<p><img src="7.png" alt="2"></p>
<p>如果你要找某个函数的最大值或最小值，比如似然函数 L(θ) 。你需要计算<strong>一阶导数等于0</strong>的地方，因此你可以将上面的 f(θ) 替换为 L’(θ)</p>
<p style=""><img src="https://math.now.sh?from=%5Ctheta%3A%3D%5Ctheta-%5Cfrac%7B%5Cell%5E%7B%5Cprime%7D%28%5Ctheta%29%7D%7B%5Cell%5E%7B%5Cprime%20%5Cprime%7D(%5Ctheta)%7D%0A" /></p><p>上面的 θ 只是单个数字，我们将其推广为一般化的向量。</p>
<p style=""><img src="https://math.now.sh?from=%5Ctheta%3A%3D%5Ctheta-H%5E%7B-1%7D%20%5Cnabla_%7B%5Ctheta%7D%20%5Cell%28%5Ctheta%29%0A" /></p><p>这里 H 是一个 n+1 × n+1 （n 是特征的数目）的矩阵，称为 <strong>Hessian</strong> 矩阵，其元素为：</p>
<p style=""><img src="https://math.now.sh?from=H_%7Bi%20j%7D%3D%5Cfrac%7B%5Cpartial%5E%7B2%7D%20%5Cell%28%5Ctheta%29%7D%7B%5Cpartial%20%5Ctheta_%7Bi%7D%20%5Cpartial%20%5Ctheta_%7Bj%7D%7D%0A" /></p><p>牛顿方法收敛速度非常快，一般十几次迭代就收敛了。但是牛顿方法的每次迭代比梯度下降方法要慢得多，因为设计到 H 矩阵的求逆。但是如果特征数目不是特别大时，牛顿方法还是会快很多。当你将牛顿方法用于逻辑回归时，这时也称为 <strong>Fisher scoring</strong>。</p>
<h2 id="Generalized-Linear-Models">Generalized Linear Models</h2>
<p>线性回归 y 服从高斯分布，逻辑回归中 y 服从伯努利分布。我们可以证明这两种方法都是一个更广的模型家族的一个例子，这个模型家族称为<strong>一般线性模型 (Generalized Linear Models， GLMs)</strong>。</p>
<h3 id="The-exponential-family">The exponential family</h3>
<p>我们首先从定义<strong>指数族分布(exponential family distributions)</strong>。指数族分布均可以写成下式：（这里 η<sup>T</sup> 是转置矩阵的意思，下面的例子首先将 η 视为一个实数）</p>
<p style=""><img src="https://math.now.sh?from=p%28y%20%3B%20%5Ceta%29%3Db(y)%20%5Cexp%20%5Cleft(%5Ceta%5E%7BT%7D%20T(y)-a(%5Ceta)%5Cright)%0A" /></p><p>其中，η 称为自然参数(natural parameter)；T(y) 称为充分统计量(sufficient statistic)，通常就是 y 。</p>
<p><img src="8.png" alt="2"></p>
<p>下面我们要证明高斯分布和伯努利分布均是指数族分布的一个特例，首先我没看伯努利分布，伯努利分布只有一个参数</p>
<p style=""><img src="https://math.now.sh?from=p%28y%3D1%20%3B%20%5Cphi%29%3D%5Cphi%20%3B%20p(y%3D0%20%3B%20%5Cphi)%3D1-%5Cphi%0A" /></p><p>我们可以将伯努利分布写成下式</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ap%28y%20%3B%20%5Cphi%29%20%26%3D%5Cphi%5E%7By%7D(1-%5Cphi)%5E%7B1-y%7D%20%5C%5C%0A%26%3D%5Cexp%20(y%20%5Clog%20%5Cphi%2B(1-y)%20%5Clog%20(1-%5Cphi))%20%5C%5C%0A%26%3D%5Cexp%20%5Cleft(%5Cleft(%5Clog%20%5Cleft(%5Cfrac%7B%5Cphi%7D%7B1-%5Cphi%7D%5Cright)%5Cright)%20y%2B%5Clog%20(1-%5Cphi)%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>我们就得到了</p>
<p style=""><img src="https://math.now.sh?from=%5Ceta%3D%5Clog%20%28%5Cphi%20%2F(1-%5Cphi%29)%0A" /></p><p>针对这个式子，如果我们反过来求 Φ ，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cphi%20%3D%201%20%2F%5Cleft%281%2Be%5E%7B-%5Ceta%7D%5Cright%29%0A" /></p><p>这个函数就是 sigmoid 函数。完善将伯努利分布转化为指数族分布的公式，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AT%28y%29%20%26%3Dy%20%5C%5C%0Aa(%5Ceta)%20%26%3D-%5Clog%20(1-%5Cphi)%20%5C%5C%0A%26%3D%5Clog%20%5Cleft(1%2Be%5E%7B%5Ceta%7D%5Cright)%20%5C%5C%0Ab(y)%20%26%3D1%0A%5Cend%7Baligned%7D%0A" /></p><p>让我们再看高斯分布如何转化为指数族分布的形式。在前面的例子中，极大似然估计参数中 σ<sup>2</sup> 没有发挥作用，处于简化推导的目的，这里设置 σ<sup>2</sup> = 1 ，把它忽视掉，见下式。如果考虑  σ<sup>2</sup> ，那么此时的 η 会是一个二维的向量。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ap%28y%20%3B%20%5Cmu%29%20%26%3D%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%7D%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B1%7D%7B2%7D(y-%5Cmu)%5E%7B2%7D%5Cright)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%7D%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B1%7D%7B2%7D%20y%5E%7B2%7D%5Cright)%20%5Ccdot%20%5Cexp%20%5Cleft(%5Cmu%20y-%5Cfrac%7B1%7D%7B2%7D%20%5Cmu%5E%7B2%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，高斯分布也是一个指数族分布，其中</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Ceta%20%26%3D%5Cmu%20%5C%5C%0AT%28y%29%20%26%3Dy%20%5C%5C%0Aa(%5Ceta)%20%26%3D%5Cmu%5E%7B2%7D%20%2F%202%20%5C%5C%0A%26%3D%5Ceta%5E%7B2%7D%20%2F%202%20%5C%5C%0Ab(y)%20%26%3D(1%20%2F%20%5Csqrt%7B2%20%5Cpi%7D)%20%5Cexp%20%5Cleft(-y%5E%7B2%7D%20%2F%202%5Cright)%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>还有很多其他分布，比如多元正态分布，泊松分布，指数分布等也服从指数族分布</p>
<h2 id="Constructing-GLMs">Constructing GLMs</h2>
<p>对于一个预测 y 的回归或分类问题，为了构建 GLM 来解决这个问题，我们需要做出下面这三个假设。首先，我们需要指定当给定 x 和 θ 时，假设 y 服从某个指数族分布。第二，我们的预测值是 E[y|x]，即 y 的期望 。第三，我们假设自然参数 η 与输入特征之间为<strong>线性相关关系</strong>，即</p>
<p style=""><img src="https://math.now.sh?from=%5Ceta%3D%5Ctheta%5E%7BT%7D%20x%0A" /></p><h3 id="线性回归">线性回归</h3>
<p>我们现在如果用推导GLM 的方式求解逻辑回归和线性回归。先看线性回归，在上面的推导过程中，我们得知高斯分布可以转换为指数族分布，参数 η = μ ，其实其GLM 预测值为（高斯分布的期望值就是 μ）：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ah_%7B%5Ctheta%7D%28x%29%20%26%3DE%5By%20%5Cmid%20x%20%3B%20%5Ctheta%5D%20%5C%5C%0A%26%3D%5Cmu%20%5C%5C%0A%26%3D%5Ceta%20%5C%5C%0A%26%3D%5Ctheta%5E%7BT%7D%20x%0A%5Cend%7Baligned%7D%0A" /></p><h3 id="逻辑回归-2">逻辑回归</h3>
<p>再看逻辑回归，其预测值为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ah_%7B%5Ctheta%7D%28x%29%20%26%3DE%5By%20%5Cmid%20x%20%3B%20%5Ctheta%5D%20%5C%5C%0A%26%3Dp(y%3D1%7Cx%2C%20%5Ctheta)%20%5C%5C%0A%26%3D%5Cphi%20%5C%5C%0A%26%3D1%20%2F%5Cleft(1%2Be%5E%7B-%5Ceta%7D%5Cright)%20%5C%5C%0A%26%3D1%20%2F%5Cleft(1%2Be%5E%7B-%5Ctheta%5E%7BT%7D%20x%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>因此我们就得到了逻辑回顾的 sigmoid 函数，这是解释为什么使用 sigmoid 函数的一个理由。</p>
<p>最后，下面这个函数称为<strong>正则响应函数 (canonical response function)</strong>，其逆函数 g<sup>-1</sup> 称为<strong>正则关联函数 (canonical link function)</strong>。</p>
<p style=""><img src="https://math.now.sh?from=g%28%5Ceta%29%20%3D%20E%5BT(y)%20%5Cmid%20x%20%3B%20%5Ctheta%5D%0A" /></p><p>比如上面的逻辑回归的正则响应函数为</p>
<p style=""><img src="https://math.now.sh?from=g%28%5Ceta%29%20%3D%201%20%2F%5Cleft(1%2Be%5E%7B-%5Ceta%7D%5Cright)%0A" /></p><h3 id="Softmax-Regression">Softmax Regression</h3>
<p>让我们看一个更复杂的GLM的例子，假设有一个分类问题，其中反应变量可以取 k 个值，</p>
<p style=""><img src="https://math.now.sh?from=y%20%5Cin%20%5C%7B1%2C2%2C...%2Ck%5C%7D%0A" /></p><p>我们现在可以假设反应变量服从一个<strong>多项式分布 (multinomial distribution)</strong>。我们统一可以使用 GLM 来拟合这类数据，首先我们要见多项式分布写成指数族分布的形式。</p>
<p>为了将多项式分布分布参数化，你可以会想用 k 个参数 Φ<sub>1</sub>, … , Φ<sub>k</sub> 来表示每个输出结果的概率。但是，<strong>这些参数之间存在冗余，或者说彼此不独立</strong>（假设知道了 k-1 个参数的数值，那么最后一个参数的数值也就知道了）。因此，我们只设定 k-1 个参数， Φ<sub>1</sub>, … , Φ<sub>k-1</sub> ，最后一个输出结果的概率通过计算得到。</p>
<p>我们定义 T(y) 如下（T(y) 为一个 k-1 维的向量）</p>
<p style=""><img src="https://math.now.sh?from=%7BT%28y%3D1%29%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A1%20%5C%5C%0A0%20%5C%5C%0A0%20%5C%5C%0A%5Cvdots%20%5C%5C%0A0%0A%5Cend%7Barray%7D%5Cright%5D%2C%0A%7BT(y%3D2)%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A0%20%5C%5C%0A1%20%5C%5C%0A0%20%5C%5C%0A%5Cvdots%20%5C%5C%0A0%0A%5Cend%7Barray%7D%5Cright%5D%2C%0A%7BT(y%3D3)%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A0%20%5C%5C%0A0%20%5C%5C%0A1%20%5C%5C%0A%5Cvdots%20%5C%5C%0A0%0A%5Cend%7Barray%7D%5Cright%5D%2C%0A%5Cdots%0A%7BT(y%3Dk-1)%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A0%20%5C%5C%0A0%20%5C%5C%0A0%20%5C%5C%0A%5Cvdots%20%5C%5C%0A1%0A%5Cend%7Barray%7D%5Cright%5D%2C%0A%7BT(y%3Dk)%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A0%20%5C%5C%0A0%20%5C%5C%0A0%20%5C%5C%0A%5Cvdots%20%5C%5C%0A0%0A%5Cend%7Barray%7D%5Cright%5D%2C%0A" /></p><p>这里不像之前的例子，T(y) 并没有设置为 y 。这里我们定义 <code>1&#123;.&#125;</code>  为一个<strong>指示函数</strong>，如果方括号内的内容为真则该式为1，反之为0 。比如 <code>1&#123;2=3&#125; = 0</code> 。因此我们可以将 T(y) 和 y 之间的关系写成：</p>
<p style=""><img src="https://math.now.sh?from=%28T(y%29)_%7Bi%7D%20%3D%201%5C%7By%3Di%5C%7D%0A" /></p><p>另外，存在</p>
<p style=""><img src="https://math.now.sh?from=E%5B%28T(y%29)_%7Bi%7D%5D%20%3D%20P(y%3Di)%20%3D%20%5Cphi_%7Bi%7D%0A" /></p><p>现在我们可以看看如何将多项式分布转化为指数族分布了。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ap%28y%20%3B%20%5Cphi%29%3D%26%20%5Cphi_%7B1%7D%5E%7B1%5C%7By%3D1%5C%7D%7D%20%5Cphi_%7B2%7D%5E%7B1%5C%7By%3D2%5C%7D%7D%20%5Ccdots%20%5Cphi_%7Bk%7D%5E%7B1%5C%7By%3Dk%5C%7D%7D%20%5C%5C%0A%3D%26%20%5Cphi_%7B1%7D%5E%7B1%5C%7By%3D1%5C%7D%7D%20%5Cphi_%7B2%7D%5E%7B1%5C%7By%3D2%5C%7D%7D%20%5Ccdots%20%5Cphi_%7Bk%7D%5E%7B1-%5Csum_%7Bi%3D1%7D%5E%7Bk-1%7D%201%5C%7By%3Di%5C%7D%7D%20%5C%5C%0A%3D%26%20%5Cphi_%7B1%7D%5E%7B(T(y))_%7B1%7D%7D%20%5Cphi_%7B2%7D%5E%7B(T(y))_%7B2%7D%7D%20%5Ccdots%20%5Cphi_%7Bk%7D%5E%7B1-%5Csum_%7Bi%3D1%7D%5E%7Bk-1%7D(T(y))_%7Bi%7D%7D%20%5C%5C%0A%3D%26%20%5Cexp%20%5Cleft((T(y))_%7B1%7D%20%5Clog%20%5Cleft(%5Cphi_%7B1%7D%5Cright)%2B(T(y))_%7B2%7D%20%5Clog%20%5Cleft(%5Cphi_%7B2%7D%5Cright)%2B%5Cright.%5C%5C%0A%26%5Cleft.%5Cquad%20%5Ccdots%2B%5Cleft(1-%5Csum_%7Bi%3D1%7D%5E%7Bk-1%7D(T(y))_%7Bi%7D%5Cright)%20%5Clog%20%5Cleft(%5Cphi_%7Bk%7D%5Cright)%5Cright)%20%5C%5C%0A%3D%26%20%5Cexp%20%5Cleft((T(y))_%7B1%7D%20%5Clog%20%5Cleft(%5Cphi_%7B1%7D%20%2F%20%5Cphi_%7Bk%7D%5Cright)%2B(T(y))_%7B2%7D%20%5Clog%20%5Cleft(%5Cphi_%7B2%7D%20%2F%20%5Cphi_%7Bk%7D%5Cright)%2B%5Cright.%5C%5C%0A%26%5Cleft.%5Cquad%20%5Ccdots%2B(T(y))_%7Bk-1%7D%20%5Clog%20%5Cleft(%5Cphi_%7Bk-1%7D%20%2F%20%5Cphi_%7Bk%7D%5Cright)%2B%5Clog%20%5Cleft(%5Cphi_%7Bk%7D%5Cright)%5Cright)%20%5C%5C%0A%3D%26%20b(y)%20%5Cexp%20%5Cleft(%5Ceta%5E%7BT%7D%20T(y)-a(%5Ceta)%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>其中</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Ceta%20%26%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Clog%20%5Cleft%28%5Cphi_%7B1%7D%20%2F%20%5Cphi_%7Bk%7D%5Cright%29%20%5C%5C%0A%5Clog%20%5Cleft(%5Cphi_%7B2%7D%20%2F%20%5Cphi_%7Bk%7D%5Cright)%20%5C%5C%0A%5Cvdots%20%5C%5C%0A%5Clog%20%5Cleft(%5Cphi_%7Bk-1%7D%20%2F%20%5Cphi_%7Bk%7D%5Cright)%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0Aa(%5Ceta)%20%26%3D-%5Clog%20%5Cleft(%5Cphi_%7Bk%7D%5Cright)%20%5C%5C%0Ab(y)%20%26%3D1%0A%5Cend%7Baligned%7D%0A" /></p><p>正则关联函数为</p>
<p style=""><img src="https://math.now.sh?from=%5Ceta_%7Bi%7D%3D%5Clog%20%5Cfrac%7B%5Cphi_%7Bi%7D%7D%7B%5Cphi_%7Bk%7D%7D%0A" /></p><p>为了方便，我们同样定义 η<sup>k</sup> 。</p>
<p style=""><img src="https://math.now.sh?from=%5Ceta_%7Bk%7D%3D%5Clog%20%5Cleft%28%5Cphi_%7Bk%7D%20%2F%20%5Cphi_%7Bk%7D%5Cright%29%3D0%0A" /></p><p>为了求关联函数的逆函数，得到正则响应函数，我们得到如下式子：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ae%5E%7B%5Ceta_%7Bi%7D%7D%20%26%3D%5Cfrac%7B%5Cphi_%7Bi%7D%7D%7B%5Cphi_%7Bk%7D%7D%20%5C%5C%0A%5Cphi_%7Bk%7D%20e%5E%7B%5Ceta_%7Bi%7D%7D%20%26%3D%5Cphi_%7Bi%7D%20%5C%5C%0A%5Cphi_%7Bk%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ceta_%7Bi%7D%7D%20%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bk%7D%20%5Cphi_%7Bi%7D%3D1%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，</p>
<p style=""><img src="https://math.now.sh?from=%5Cphi_%7Bk%7D%3D1%20%2F%20%5Csum_%7Bi%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ceta_%7Bi%7D%7D%0A" /></p><p>将该式代入到上式中，得到：</p>
<p style=""><img src="https://math.now.sh?from=%5Cphi_%7Bi%7D%3D%5Cfrac%7Be%5E%7B%5Ceta_%7Bi%7D%7D%7D%7B%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ceta_%7Bj%7D%7D%7D%0A" /></p><p>这个函数就是这里的正则响应函数，这里也称为 <strong>softmax</strong> 函数。</p>
<p>根据假设3，即 η 和 输入变量 x 是线性相关的，因此</p>
<p style=""><img src="https://math.now.sh?from=%5Ceta_%7Bi%7D%3D%5Ctheta_%7Bi%7D%5E%7BT%7D%20x%28%5Ctext%20%7B%20for%20%7D%20i%3D1%2C%20%5Cldots%2C%20k-1%29%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Ctheta_%7B1%7D%2C%20%5Cldots%2C%20%5Ctheta_%7Bk-1%7D%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bn%2B1%7D%0A" /></p><p>为了书写方便，我们定义 θ<sub>k</sub> = 0 ，因此</p>
<p style=""><img src="https://math.now.sh?from=%5Ceta_%7Bk%7D%3D%5Ctheta_%7Bk%7D%5E%7BT%7D%20x%3D0%0A" /></p><p>因此，该GLM的分布为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ap%28y%3Di%20%5Cmid%20x%20%3B%20%5Ctheta%29%20%26%3D%5Cphi_%7Bi%7D%20%5C%5C%0A%26%3D%5Cfrac%7Be%5E%7B%5Ceta_%7Bi%7D%7D%7D%7B%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ceta_%7Bj%7D%7D%7D%20%5C%5C%0A%26%3D%5Cfrac%7Be%5E%7B%5Ctheta_%7Bi%7D%5E%7BT%7D%20x%7D%7D%7B%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%7D%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>这个用于 k 个分类水平问题的模型称为 <strong>softmax regression</strong> 。<strong>它是逻辑回归的一般化形式</strong>。</p>
<p>我们的假设会输出 k 个水平的预测概率</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0Ah_%7B%5Ctheta%7D%28x%29%3D%5Cmathrm%7BE%7D%5BT(y)%20%5Cmid%20x%20%3B%20%5Ctheta%5D%20%5C%5C%0A%3D%5Cmathrm%7BE%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A1%5C%7By%3D1%5C%7D%20%5C%5C%0A1%5C%7By%3D2%5C%7D%20%5C%5C%0A%5Cvdots%20%5C%5C%0A1%5C%7By%3Dk%5C%7D%0A%5Cend%7Barray%7D%20%5Cmid%20x%20%3B%20%5Ctheta%5Cright.%20%5C%5C%0A%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cphi_%7B1%7D%20%5C%5C%0A%5Cphi_%7B2%7D%20%5C%5C%0A%5Cvdots%20%5C%5C%0A%5Cphi_%7Bk%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cfrac%7B%5Cexp%20%5Cleft(%5Ctheta_%7B1%7D%5E%7BT%7D%20x%5Cright)%7D%7B%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%20%5Cexp%20%5Cleft(%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5Cright)%7D%20%5C%5C%0A%5Cfrac%7B%5Cexp%20%5Cleft(%5Ctheta_%7B2%7D%5E%7BT%7D%20x%5Cright)%7D%7B%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%20%5Cexp%20%5Cleft(%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5Cright)%7D%20%5C%5C%0A%5Cvdots%20%5C%5C%0A%5Cfrac%7B%5Cexp%20%5Cleft(%5Ctheta_%7Bk%7D%5E%7BT%7D%20x%5Cright)%7D%7B%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%20%5Cexp%20%5Cleft(%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5Cright)%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%0A%5Cend%7Bgathered%7D%0A" /></p><p>最后，让我们讨论一下参数拟合的问题。类似于线性回归和逻辑回归，我们同样会使用<strong>最大似然法</strong>进行参数拟合。假设训练集中有 m 个样本，我们可以计算除其<strong>对数似然函数</strong>如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cell%28%5Ctheta%29%20%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Clog%20p%5Cleft(y%5E%7B(i)%7D%20%5Cmid%20x%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%20%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Clog%20%5Cprod_%7Bl%3D1%7D%5E%7Bk%7D%5Cleft(%5Cfrac%7Be%5E%7B%5Ctheta_%7Bl%7D%5E%7BT%7D%20x%5E%7B(i)%7D%7D%7D%7B%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%20e%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7D%20x%5E%7B(i)%7D%7D%7D%5Cright)%5E%7B1%5Cleft%5C%7By%5E%7B(i)%7D%3Dl%5Cright%5C%7D%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>之后你就可以用梯度下降法或牛顿法来求 L(θ) 求得最大值的一组参数。</p>
<h3 id="思考">思考</h3>
<p>根据GLM 的概念，那么只要指定 y 服从某种指数族分布，那么后续的推导就是自动进行的，你就会自动得到一个学习算法和预测函数。比如，你指定 y 服从<strong>正态分布</strong>，套用 GLM 的公式和推导，你就得到了<strong>线性回归</strong>；你指定 y 服从<strong>伯努利分布</strong>，套用 GLM 的公式和推导，你就得到了<strong>逻辑回归</strong>。</p>
<p><code>Softmax Regression</code> 让我想到了神经网络，像是没有隐藏层的多分类的神经网络。</p>
<h1>生成学习算法</h1>
<p>逻辑回归是直接预测 p(y|x），感受器方法是想将输入特征 X 的空间直接标记为标签 {0,1} ，这类方法都称为<strong>判别方法 (discriminative learning algorithms)</strong> 。</p>
<p>这里我们要讨论的算法尝试模拟 p(x|y) 和 p(y) ，这类算法称为<strong>生成方法 (generative learning algorithms)</strong> 。计算出  p(x|y) 和 p(y)  后，就可以通过贝叶斯法则计算后验概率：</p>
<p style=""><img src="https://math.now.sh?from=p%28y%20%5Cmid%20x%29%3D%5Cfrac%7Bp(x%20%5Cmid%20y)%20p(y)%7D%7Bp(x)%7D%0A" /></p><p>分母部分可以用全概率公式进行展开。但是，当我们要做决策时，我们实际上只需要看分子部分，因为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Carg%20%5Cmax%20_%7By%7D%20p%28y%20%5Cmid%20x%29%20%26%3D%5Carg%20%5Cmax%20_%7By%7D%20%5Cfrac%7Bp(x%20%5Cmid%20y)%20p(y)%7D%7Bp(x)%7D%20%5C%5C%0A%26%3D%5Carg%20%5Cmax%20_%7By%7D%20p(x%20%5Cmid%20y)%20p(y)%0A%5Cend%7Baligned%7D%0A" /></p><h2 id="Gaussian-discriminant-analysis">Gaussian discriminant analysis</h2>
<p>GDA 是第一个要介绍的生成算法，在这个模型中，我们假设 <strong>p(x | y) 服从多元正态分布</strong>。我们先简要介绍一下多元正态分布的一些性质：</p>
<h3 id="多元正态分布">多元正态分布</h3>
<p>n维的多元正态分布存在两个参数，一个是 均值向量 μ ∈ R<sup>n</sup> ，一个是方差矩阵 Σ ∈ R<sup>n×n</sup> ，方差矩阵是对称矩阵并且是半正定矩阵。其概率密度函数写作：</p>
<p style=""><img src="https://math.now.sh?from=p%28x%20%3B%20%5Cmu%2C%20%5CSigma%29%3D%5Cfrac%7B1%7D%7B(2%20%5Cpi)%5E%7Bn%20%2F%202%7D%7C%5CSigma%7C%5E%7B1%20%2F%202%7D%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B1%7D%7B2%7D(x-%5Cmu)%5E%7BT%7D%20%5CSigma%5E%7B-1%7D(x-%5Cmu)%5Cright)%0A" /></p><p>在该式中，<code>|Σ|</code> 表示行列式。</p>
<p>下面三个图分别是服从 N(<strong>0</strong>，<strong>I</strong>) ，  N(<strong>0</strong>，<strong>0.6I</strong>) ， N(<strong>0</strong>，<strong>2I</strong>) ，我们可以看到随着方差变大，分布越矮胖。</p>
<p><img src="9.png" alt="9"></p>
<p>下面是三个图的均值均为 0 向量，方差组分分别如下：</p>
<p style=""><img src="https://math.now.sh?from=%5CSigma%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A1%20%26%200%20%5C%5C%0A0%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%20%3B%20%5Cquad%20%5CSigma%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A1%20%26%200.5%20%5C%5C%0A0.5%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%20%3B%20%5Cquad%20.%20%5CSigma%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A1%20%26%200.8%20%5C%5C%0A0.8%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>画图为：</p>
<p><img src="10.png" alt="9"></p>
<p>我们可以看到随着非对角线元素的增加，密度函数的图像变得越来越像 45度方向（x1=x2）挤压。我们看等高图，可以看到更加明显地变化。</p>
<p><img src="11.png" alt="9"></p>
<h3 id="GDA-model">GDA model</h3>
<p>当我们面临一个分类问题，其特征都是<strong>连续变量</strong>，我们可以使用<strong>Gaussian Discriminant Analysis (GDA)</strong> 模型。这里的 GDA 模型就是 ISL 书里的 <strong>Linear Discriminant Analysis (LDA)</strong> 模型。</p>
<p>我们<strong>假设 p(x|y) 服从方差相同的多元正态分布</strong>，模型如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ay%20%26%20%5Csim%20%5Coperatorname%7BBernoulli%7D%28%5Cphi%29%20%5C%5C%0Ax%20%5Cmid%20y%3D0%20%26%20%5Csim%20%5Cmathcal%7BN%7D%5Cleft(%5Cmu_%7B0%7D%2C%20%5CSigma%5Cright)%20%5C%5C%0Ax%20%5Cmid%20y%3D1%20%26%20%5Csim%20%5Cmathcal%7BN%7D%5Cleft(%5Cmu_%7B1%7D%2C%20%5CSigma%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们可以写下分布如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ap%28y%29%20%26%3D%5Cphi%5E%7By%7D(1-%5Cphi)%5E%7B1-y%7D%20%5C%5C%0Ap(x%20%5Cmid%20y%3D0)%20%26%3D%5Cfrac%7B1%7D%7B(2%20%5Cpi)%5E%7Bn%20%2F%202%7D%7C%5CSigma%7C%5E%7B1%20%2F%202%7D%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B1%7D%7B2%7D%5Cleft(x-%5Cmu_%7B0%7D%5Cright)%5E%7BT%7D%20%5CSigma%5E%7B-1%7D%5Cleft(x-%5Cmu_%7B0%7D%5Cright)%5Cright)%20%5C%5C%0Ap(x%20%5Cmid%20y%3D1)%20%26%3D%5Cfrac%7B1%7D%7B(2%20%5Cpi)%5E%7Bn%20%2F%202%7D%7C%5CSigma%7C%5E%7B1%20%2F%202%7D%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B1%7D%7B2%7D%5Cleft(x-%5Cmu_%7B1%7D%5Cright)%5E%7BT%7D%20%5CSigma%5E%7B-1%7D%5Cleft(x-%5Cmu_%7B1%7D%5Cright)%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>对数似然函数为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cell%5Cleft%28%5Cphi%2C%20%5Cmu_%7B0%7D%2C%20%5Cmu_%7B1%7D%2C%20%5CSigma%5Cright%29%20%26%3D%5Clog%20%5Cprod_%7Bi%3D1%7D%5E%7Bm%7D%20p%5Cleft(x%5E%7B(i)%7D%2C%20y%5E%7B(i)%7D%20%3B%20%5Cphi%2C%20%5Cmu_%7B0%7D%2C%20%5Cmu_%7B1%7D%2C%20%5CSigma%5Cright)%20%5C%5C%0A%26%3D%5Clog%20%5Cprod_%7Bi%3D1%7D%5E%7Bm%7D%20p%5Cleft(x%5E%7B(i)%7D%20%5Cmid%20y%5E%7B(i)%7D%20%3B%20%5Cmu_%7B0%7D%2C%20%5Cmu_%7B1%7D%2C%20%5CSigma%5Cright)%20p%5Cleft(y%5E%7B(i)%7D%20%3B%20%5Cphi%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>这里的似然函数称为 <strong>Joint likelihood</strong>，因为里面的项是 p(x, y)。逻辑回归的似然函数称为<strong>conditional likelihood</strong>，因为里面的项是 p(y | x) 。</p>
<p>通过最大化似然函数（求偏导为0，缺证明，不会证明），我们发现这些参数的最大似然估计值为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cphi%20%26%3D%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7By%5E%7B%28i%29%7D%3D1%5Cright%5C%7D%20%5C%5C%0A%5Cmu_%7B0%7D%20%26%3D%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7By%5E%7B(i)%7D%3D0%5Cright%5C%7D%20x%5E%7B(i)%7D%7D%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7By%5E%7B(i)%7D%3D0%5Cright%5C%7D%7D%20%5C%5C%0A%5Cmu_%7B1%7D%20%26%3D%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7By%5E%7B(i)%7D%3D1%5Cright%5C%7D%20x%5E%7B(i)%7D%7D%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7By%5E%7B(i)%7D%3D1%5Cright%5C%7D%7D%20%5C%5C%0A%5CSigma%20%26%3D%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft(x%5E%7B(i)%7D-%5Cmu_%7By%5E%7B(i)%7D%7D%5Cright)%5Cleft(x%5E%7B(i)%7D-%5Cmu_%7By%5E%7B(i)%7D%7D%5Cright)%5E%7BT%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>下图为可视化结果，图中的两个等高图就是对两个水平拟合的高斯分布，我们注意到由于方差相同，这两个等高图的形状一模一样。图中直线为决策线，在该条线上 p(y=1|x) = 0.5 。</p>
<p><img src="12.png" alt="9"></p>
<h3 id="Discussion-GDA-and-logistic-regression">Discussion: GDA and logistic regression</h3>
<p>逻辑回归算法是要找一条直线，将两类数据尽可能分开。GDA 和 逻辑回归存在一定关系，如果逆看一下GDA 算法的 <img src="https://math.now.sh?inline=p%28y%20%3D%201%7Cx%3B%20%5Cphi%2C%20%5Cmu_%7B0%7D%2C%20%5Cmu_%7B1%7D%2C%20%5CSigma%29" style="display:inline-block;margin: 0;"/> ，你会发现它同样可以表达为下面这种形式（缺证明）</p>
<p style=""><img src="https://math.now.sh?from=p%5Cleft%28y%3D1%20%5Cmid%20x%20%3B%20%5Cphi%2C%20%5CSigma%2C%20%5Cmu_%7B0%7D%2C%20%5Cmu_%7B1%7D%5Cright%29%3D%5Cfrac%7B1%7D%7B1%2B%5Cexp%20%5Cleft(-%5Ctheta%5E%7BT%7D%20x%5Cright)%7D%0A" /></p><p>这里 θ 是关于 $ \phi, \mu_{0}, \mu_{1}, \Sigma$ 的一个函数。这个形式就正好是逻辑回归的形式。但是这里 θ 不一样，因此逻辑回归和GDA找到的决策线并不相同。那么，我们什么时候用逻辑回归，什么时候用 GDA 呢？</p>
<p>我们说如果 p(x|y) 如果满足多元高斯分布的假设，那么 p(y|x) 就服从 sigmoid 函数。但是反过来这句话不成立，也就是说 p(y | x) 如果服从 sigmoid 函数，p(x|y) 不一定满足多元高斯分布。这说明 GDA 算法对数据的假设更&quot;强&quot;，或者说更严格 (<strong>stronger modeling assumptions</strong>) 。事实证明，如果模型假设是对的（p(x|y) 服从方差相同的多元正态分布），那么 GDA 拟合效果更好。相反，逻辑回归由于没有对 p(x|y) 分布做严格假设，因此更加稳健（i<strong>事实上， p(x|y) 只要服从某种指数族分布，那么 p(y=1 | x) 就服从 sigmoid 函数</strong>。但是这句话反过来不成立。）。由于逻辑回归假设弱得多，因此逻辑回归拟合相比于GDA需要更多的数据。</p>
<p>因此，从实践角度上说，逻辑回归比GDA用得更多。</p>
<h2 id="Naive-Bayes">Naive Bayes</h2>
<p>在 GDA 算法中 ，x 都是连续变量组成的向量。让我们假设另外一种情况，假设 x 都是<strong>离散变量</strong>。</p>
<p>假设我们需要建立一个垃圾邮件监测系统，首先我们需要从邮件内容中构建特征。假设我们将每个可能出现的单词作为一个特征，如果邮件内容中包含这个单词，则 x<sub>i</sub> = 1，反之则为 0 。举例如下：</p>
<p><img src="13.png" alt="9"></p>
<p>之后我们需要构建我们的生成算法，因此我们需要对 p(x|y) 进行建模。但是，假如我们总共有 50000 个单词，那么如果我们用多项式分布对总共 2<sup>50000</sup> 种可能的结果进行建模，那么我们就会有 (2<sup>50000</sup> -1) 维度的参数向量，那么参数就太多了。</p>
<p>因此，为了对 p(x|y) 建模，我们需要做一个更强的假设。我们假设当给定 y 值后，x 之间是<strong>条件独立</strong>的。这个假设也称为<strong>朴素贝叶斯假设 (Naive Bayes assumption)</strong> ，相应的算法称为 <strong>Naive Bayes classifier</strong> 。举个例子，假设 y =1 表示垃圾邮件，“buy” 是第2087个单词，“price” 是第39831个单词，那么当我告诉你 y =1 时 (这个邮件是垃圾邮件)，你对 x<sub>2087</sub> 的认识，不会影响你对 x<sub>39831</sub> 的认识。正式的写法如下式。</p>
<p style=""><img src="https://math.now.sh?from=p%5Cleft%28x_%7B2087%7D%20%5Cmid%20y%5Cright%29%3Dp%5Cleft(x_%7B2087%7D%20%5Cmid%20y%2C%20x_%7B39831%7D%5Cright)%20.%0A" /></p><p>注意，这并不是说 x<sub>2087</sub> 和 x<sub>39831</sub> 彼此独立，如果是二者彼此独立的话，应该写作下式：</p>
<p style=""><img src="https://math.now.sh?from=p%5Cleft%28x_%7B2087%7D%5Cright%29%3Dp%5Cleft(x_%7B2087%7D%20%5Cmid%20x_%7B39831%7D%5Cright)%0A" /></p><p>这里，我们只是说当给定y时， x<sub>2087</sub> 和 x<sub>39831</sub> 是<strong>条件独立的 (conditionally independent)</strong> 。</p>
<p>因此，此时我们有下式，第一个等号是通用的概率论上的公式，第二个等号来自于朴素贝叶斯假设。此时我们知道NB假设是一个非常强的假设，这个假设明显是错的，如果你看到了 cs229 这个单词，那么你就很有可能看到吴老师或助教的名字，但是朴素贝叶斯方法仍然是一个很有效的方法。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ap%5Cleft%28x_%7B1%7D%2C%20%5Cldots%2C%20x_%7B50000%7D%20%5Cmid%20y%5Cright%29%20%5C%5C%0A%26%3Dp%5Cleft(x_%7B1%7D%20%5Cmid%20y%5Cright)%20p%5Cleft(x_%7B2%7D%20%5Cmid%20y%2C%20x_%7B1%7D%5Cright)%20p%5Cleft(x_%7B3%7D%20%5Cmid%20y%2C%20x_%7B1%7D%2C%20x_%7B2%7D%5Cright)%20%5Ccdots%20p%5Cleft(x_%7B50000%7D%20%5Cmid%20y%2C%20x_%7B1%7D%2C%20%5Cldots%2C%20x_%7B49999%7D%5Cright)%20%5C%5C%0A%26%3Dp%5Cleft(x_%7B1%7D%20%5Cmid%20y%5Cright)%20p%5Cleft(x_%7B2%7D%20%5Cmid%20y%5Cright)%20p%5Cleft(x_%7B3%7D%20%5Cmid%20y%5Cright)%20%5Ccdots%20p%5Cleft(x_%7B50000%7D%20%5Cmid%20y%5Cright)%20%5C%5C%0A%26%3D%5Cprod_%7Bi%3D1%7D%5E%7Bn%7D%20p%5Cleft(x_%7Bi%7D%20%5Cmid%20y%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>因此NB算法的参数包括</p>
<p style=""><img src="https://math.now.sh?from=%5Cphi_%7Bi%20%5Cmid%20y%3D1%7D%3Dp%5Cleft%28x_%7Bi%7D%3D1%20%5Cmid%20y%3D1%5Cright%29%20%5Ctext%20%7B%2C%20%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cphi_%7Bi%20%5Cmid%20y%3D0%7D%3Dp%5Cleft%28x_%7Bi%7D%3D1%20%5Cmid%20y%3D0%5Cright%29%20%5Ctext%20%7B%2C%20%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cphi_%7By%7D%3Dp%28y%3D1%29%0A" /></p><p><strong>joint likelihood</strong> 似然函数为（m 为样本数目）：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathcal%7BL%7D%5Cleft%28%5Cphi_%7By%7D%2C%20%5Cphi_%7Bj%20%5Cmid%20y%3D0%7D%2C%20%5Cphi_%7Bj%20%5Cmid%20y%3D1%7D%5Cright%29%3D%5Cprod_%7Bi%3D1%7D%5E%7Bm%7D%20p%5Cleft(x%5E%7B(i)%7D%2C%20y%5E%7B(i)%7D%5Cright)%0A" /></p><p>求似然函数最大值，得到最大似然估计值如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0A%5Cphi_%7Bj%20%5Cmid%20y%3D1%7D%3D%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7Bx_%7Bj%7D%5E%7B%28i%29%7D%3D1%20%5Cwedge%20y%5E%7B(i)%7D%3D1%5Cright%5C%7D%7D%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7By%5E%7B(i)%7D%3D1%5Cright%5C%7D%7D%20%5C%5C%0A%5Cphi_%7Bj%20%5Cmid%20y%3D0%7D%3D%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7Bx_%7Bj%7D%5E%7B(i)%7D%3D1%20%5Cwedge%20y%5E%7B(i)%7D%3D0%5Cright%5C%7D%7D%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7By%5E%7B(i)%7D%3D0%5Cright%5C%7D%7D%20%5C%5C%0A%5Cphi_%7By%7D%3D%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7By%5E%7B(i)%7D%3D1%5Cright%5C%7D%7D%7Bm%7D%0A%5Cend%7Bgathered%7D%0A" /></p><p>在上式中，符号 ^ 表示 “and” 。上面的参数有着非常自然的解释，比如 <img src="https://math.now.sh?inline=%5Cphi_%7Bj%7Cy%3D1%7D" style="display:inline-block;margin: 0;"/> 就是垃圾邮件中单词 j 出现的比例。</p>
<p>拟合参数之后，为了对一个新的样本进行预测，我们可以直接计算</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ap%28y%3D1%20%5Cmid%20x%29%20%26%3D%5Cfrac%7Bp(x%20%5Cmid%20y%3D1)%20p(y%3D1)%7D%7Bp(x)%7D%20%5C%5C%0A%26%3D%5Cfrac%7B%5Cleft(%5Cprod_%7Bi%3D1%7D%5E%7Bn%7D%20p%5Cleft(x_%7Bi%7D%20%5Cmid%20y%3D1%5Cright)%5Cright)%20p(y%3D1)%7D%7B%5Cleft(%5Cprod_%7Bi%3D1%7D%5E%7Bn%7D%20p%5Cleft(x_%7Bi%7D%20%5Cmid%20y%3D1%5Cright)%5Cright)%20p(y%3D1)%2B%5Cleft(%5Cprod_%7Bi%3D1%7D%5E%7Bn%7D%20p%5Cleft(x_%7Bi%7D%20%5Cmid%20y%3D0%5Cright)%5Cright)%20p(y%3D0)%7D%2C%0A%5Cend%7Baligned%7D%0A" /></p><p>最后我们挑后验概率最高的那个水平。</p>
<p>朴素贝叶斯算法主要用于特征为<strong>离散变量</strong>的情况，这里我们仅讨论了特征均为二分类变量的情况，我们可以直接推广到特征为多分类变量的情况。 这里我们直接将 p(x<sub>i</sub>|y) 为一个多项式分布，而不是一个伯努利分布。我们也可以通过分组，将一些连续变量转变为多分类的离散变量。</p>
<h3 id="Laplace-smoothing">Laplace smoothing</h3>
<p>我们可以对朴素贝叶斯算法做一个简单的改变，可以让其效果更好，尤其是对于文本识别任务。我们先讨论一个目前朴素贝叶斯算法的问题，再说如何修正它。</p>
<p>假设新邮件中有一个缩写单词 “nips” ，这个单词没有在训练集中出现过。假设你之前选特征的时候是直接使用了整本字典的单词，“nips” 是字典中第 35000 个单词，那么该单词参数的最大似然估计值为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cphi_%7B35000%20%5Cmid%20y%3D1%7D%3D%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7Bx_%7B35000%7D%5E%7B%28i%29%7D%3D1%20%5Cwedge%20y%5E%7B(i)%7D%3D1%5Cright%5C%7D%7D%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7By%5E%7B(i)%7D%3D1%5Cright%5C%7D%7D%3D0%20%5C%5C%0A%26%5Cphi_%7B35000%20%5Cmid%20y%3D0%7D%3D%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7Bx_%7B35000%7D%5E%7B(i)%7D%3D1%20%5Cwedge%20y%5E%7B(i)%7D%3D0%5Cright%5C%7D%7D%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7By%5E%7B(i)%7D%3D0%5Cright%5C%7D%7D%3D0%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，当你尝试决定一封包含 “nips” 单词的新邮件是否为垃圾邮件，计算后验概率如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ap%28y%3D1%20%5Cmid%20x%29%20%26%3D%5Cfrac%7B%5Cprod_%7Bi%3D1%7D%5E%7Bn%7D%20p%5Cleft(x_%7Bi%7D%20%5Cmid%20y%3D1%5Cright)%20p(y%3D1)%7D%7B%5Cprod_%7Bi%3D1%7D%5E%7Bn%7D%20p%5Cleft(x_%7Bi%7D%20%5Cmid%20y%3D1%5Cright)%20p(y%3D1)%2B%5Cprod_%7Bi%3D1%7D%5E%7Bn%7D%20p%5Cleft(x_%7Bi%7D%20%5Cmid%20y%3D0%5Cright)%20p(y%3D0)%7D%20%5C%5C%0A%26%3D%5Cfrac%7B0%7D%7B0%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>现在就出现了问题，分子分母都是 0 。</p>
<p>在统计上，仅仅因为在训练集中没有出现，就将一个某个事件出现概率估计为 0 是一个不好的做法。举个例子，假设你的学校篮球队过去五年的篮球比赛没有赢过一场，那么你如果根据过去表现预测今年比赛的胜率是0，这似乎有些苛刻，你可以给一个很小的胜率，比如 1/7 。再举个例子，假设你过去一个月都看到了太阳升起，你也没法说明天太阳就一定会升起。</p>
<p>正式地说，假设变量 z 服从多项式分布，可能的值为 {1, … ,k} 。训练集中共有 m 个样本，参数的最大似然估计值为</p>
<p style=""><img src="https://math.now.sh?from=%5Cphi_%7Bj%7D%3D%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7Bz%5E%7B%28i%29%7D%3Dj%5Cright%5C%7D%7D%7Bm%7D%0A" /></p><p>就像前面看到的，有一些参数的最大似然估计值就有可能是 0 。为了避免这一点，我们可以使用 <strong>拉普拉斯平滑 (Laplace smoothing)</strong> ，采用下面的估计值（k 为分类水平数）。</p>
<p style=""><img src="https://math.now.sh?from=%5Cphi_%7Bj%7D%3D%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7Bz%5E%7B%28i%29%7D%3Dj%5Cright%5C%7D%2B1%7D%7Bm%2Bk%7D%0A" /></p><p>这里我们对分子部分增加了 1，分母部分增加了 k，所有参数估计值相加仍然为 1，但是所有参数估计值均不可能为 0 。在某些特定的条件下，采用拉普拉斯平滑的参数估计值可能更好。</p>
<p>回到我们的朴素贝叶斯分类器，如果采用 Laplace smoothing ，我们可以画的下面的参数估计值：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cphi_%7Bj%20%5Cmid%20y%3D1%7D%3D%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7Bx_%7Bj%7D%5E%7B%28i%29%7D%3D1%20%5Cwedge%20y%5E%7B(i)%7D%3D1%5Cright%5C%7D%2B1%7D%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7By%5E%7B(i)%7D%3D1%5Cright%5C%7D%2B2%7D%20%5C%5C%0A%26%5Cphi_%7Bj%20%5Cmid%20y%3D0%7D%3D%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7Bx_%7Bj%7D%5E%7B(i)%7D%3D1%20%5Cwedge%20y%5E%7B(i)%7D%3D0%5Cright%5C%7D%2B1%7D%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7By%5E%7B(i)%7D%3D0%5Cright%5C%7D%2B2%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>拉普拉斯平滑一般不需要对 <img src="https://math.now.sh?inline=%5Cphi_%7By%7D" style="display:inline-block;margin: 0;"/> 进行处理，因为正常来说垃圾邮件和非垃圾邮件均占有一定比例，二者均不能是 0 。</p>
<h1>朴素贝叶斯算法</h1>
<h2 id="Event-models-for-text-classification">Event models for text classification</h2>
<p>这种算法是朴素贝叶斯方法对文本识别的效果更好的一种变体，称为<strong>多项式事件模型 (Multinomial Event Model)</strong>。朴素贝叶斯模型也可以称为<strong>多元伯努利事件模型 （Multivariate Bernoulli event model ）</strong>。</p>
<p>在这种模型下，我们构建的特征向量（feature vector，翻译过来差点看不懂）如下，假设训练集一封邮件的单词长度为 n ，其特征向量为 <img src="https://math.now.sh?inline=%5Cleft%28x_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Cldots%2C%20x_%7Bn%7D%5Cright%29" style="display:inline-block;margin: 0;"/> ，其中 x<sub>i</sub> 的值表示其在字典中的位置（字典就是你构建模型使用的全部单词），因此其可能的取值为 <img src="https://math.now.sh?inline=%5C%7B1%2C%20%5Cldots%2C%7CV%7C%5C%7D" style="display:inline-block;margin: 0;"/> ，其中 |V| 为 字典的长度。</p>
<p>此时每一个特征就是服从多项式分布，而不是伯努利分布了。这里我们假设<strong>单词的位置没有影响</strong>，不同位置的单词服从一个相同的多项式分布，不同位置的特征之间服从条件独立（也就是说你把一封邮件的所有单词打乱重排，结果仍一样）。因此一封邮件发生的概率为 <img src="https://math.now.sh?inline=p%28y%29%20%5Cprod_%7Bi%3D1%7D%5E%7Bn%7D%20p%5Cleft(x_%7Bi%7D%20%5Cmid%20y%5Cright)" style="display:inline-block;margin: 0;"/> ，这里 n 为邮件单词数目。</p>
<p>这里我们需要的参数是</p>
<p style=""><img src="https://math.now.sh?from=%5Cphi_%7By%7D%3Dp%28y%29%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cphi_%7Bk%20%5Cmid%20y%3D1%7D%3Dp%5Cleft%28x_%7Bj%7D%3Dk%20%5Cmid%20y%3D1%5Cright%29%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cphi_%7Bk%20%5Cmid%20y%3D0%7D%3Dp%5Cleft%28x_%7Bj%7D%3Dk%20%5Cmid%20y%3D0%5Cright%29%0A" /></p><p>假设我们有一个样本数为 m 的训练集 <img src="https://math.now.sh?inline=%5Cleft%5C%7B%5Cleft%28x%5E%7B(i%29%7D%2C%20y%5E%7B(i)%7D%5Cright)%20%3B%20i%3D1%2C%20%5Cldots%2C%20m%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=x%5E%7B%28i%29%7D%20%3D%20%5Cleft(x_%7B1%7D%5E%7B(i)%7D%2C%20x_%7B2%7D%5E%7B(i)%7D%2C%20%5Cldots%2C%20x_%7Bn_%7Bi%7D%7D%5E%7B(i)%7D%5Cright)" style="display:inline-block;margin: 0;"/> 。因此，似然函数为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathcal%7BL%7D%5Cleft%28%5Cphi%2C%20%5Cphi_%7Bk%20%5Cmid%20y%3D0%7D%2C%20%5Cphi_%7Bk%20%5Cmid%20y%3D1%7D%5Cright%29%20%26%3D%5Cprod_%7Bi%3D1%7D%5E%7Bm%7D%20p%5Cleft(x%5E%7B(i)%7D%2C%20y%5E%7B(i)%7D%5Cright)%20%5C%5C%0A%26%3D%5Cprod_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft(%5Cprod_%7Bj%3D1%7D%5E%7Bn_%7Bi%7D%7D%20p%5Cleft(x_%7Bj%7D%5E%7B(i)%7D%20%5Cmid%20y%20%3B%20%5Cphi_%7Bk%20%5Cmid%20y%3D0%7D%2C%20%5Cphi_%7Bk%20%5Cmid%20y%3D1%7D%5Cright)%5Cright)%20p%5Cleft(y%5E%7B(i)%7D%20%3B%20%5Cphi_%7By%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>求该式最大值，我们得到参数的最大似然估计值为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cphi_%7Bk%20%5Cmid%20y%3D1%7D%3D%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn_%7Bi%7D%7D%201%5Cleft%5C%7Bx_%7Bj%7D%5E%7B%28i%29%7D%3Dk%20%5Cwedge%20y%5E%7B(i)%7D%3D1%5Cright%5C%7D%7D%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7By%5E%7B(i)%7D%3D1%5Cright%5C%7D%20n_%7Bi%7D%7D%20%5C%5C%0A%26%5Cphi_%7Bk%20%5Cmid%20y%3D0%7D%3D%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn_%7Bi%7D%7D%201%5Cleft%5C%7Bx_%7Bj%7D%5E%7B(i)%7D%3Dk%20%5Cwedge%20y%5E%7B(i)%7D%3D0%5Cright%5C%7D%7D%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7By%5E%7B(i)%7D%3D0%5Cright%5C%7D%20n_%7Bi%7D%7D%20%5C%5C%0A%26%5Cphi_%7By%7D%3D%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7By%5E%7B(i)%7D%3D1%5Cright%5C%7D%7D%7Bm%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>我们采用拉普拉斯平滑效果更好，因此前两个参数估计值改为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cphi_%7Bk%20%5Cmid%20y%3D1%7D%3D%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn_%7Bi%7D%7D%201%5Cleft%5C%7Bx_%7Bj%7D%5E%7B%28i%29%7D%3Dk%20%5Cwedge%20y%5E%7B(i)%7D%3D1%5Cright%5C%7D%2B1%7D%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7By%5E%7B(i)%7D%3D1%5Cright%5C%7D%20n_%7Bi%7D%2B%7CV%7C%7D%20%5C%5C%0A%26%5Cphi_%7Bk%20%5Cmid%20y%3D0%7D%3D%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn_%7Bi%7D%7D%201%5Cleft%5C%7Bx_%7Bj%7D%5E%7B(i)%7D%3Dk%20%5Cwedge%20y%5E%7B(i)%7D%3D0%5Cright%5C%7D%2B1%7D%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7By%5E%7B(i)%7D%3D0%5Cright%5C%7D%20n_%7Bi%7D%2B%7CV%7C%7D%0A%5Cend%7Baligned%7D%0A" /></p><h2 id="支持向量机">支持向量机</h2>
<p>前面讲到的分类方法，包括逻辑回归和朴素贝叶斯，都属于线性方法，那么我们要如何得到一个非线性分类器呢？神经网络和支持向量机就是两种得到非线性分类器的方法。</p>
<p>首先我们先要再讲一些线性分类器的知识。</p>
<h3 id="Margins-Intuition">Margins: Intuition</h3>
<p>先考虑逻辑回归，如果 <img src="https://math.now.sh?inline=%5Ctheta%5E%7BT%7D%20x%20%5Cgeq%200" style="display:inline-block;margin: 0;"/> ，那么我们就会判定 y = 1。因此如果 <img src="https://math.now.sh?inline=%5Ctheta%5E%7BT%7D%20x" style="display:inline-block;margin: 0;"/> 越大，预测 y = 1 的概率就越大，我们就越有”信心“相信 y = 1。反之，如果<img src="https://math.now.sh?inline=%5Ctheta%5E%7BT%7D%20x%20%5Cleq%200" style="display:inline-block;margin: 0;"/>，那么我们很有信心相信 y = 0 。因此对于一个训练集，我们希望找到一组参数 θ，使得当 y = 1时， <img src="https://math.now.sh?inline=%5Ctheta%5E%7BT%7D%20x%20%5Cgeq%200" style="display:inline-block;margin: 0;"/> ，当 y = 0 时， <img src="https://math.now.sh?inline=%5Ctheta%5E%7BT%7D%20x%20%5Cleq%200" style="display:inline-block;margin: 0;"/> 。因此，这可以作为一个我们的目标。</p>
<p>我们举个例子，假设存在数据如下图，点 A 距离决策线很远，因此我们似乎很有理由相信在这一点 y = 1 。点 C 距离决策线很近，只要决策线稍作改变，点 C 就可以从判定 y =1 改为判定为 y = 0 。因此我们想要找的决策线，既要满足错误率最低，还要满足判定信心最高（所有点尽可能远离决策线）</p>
<p><img src="14.png" alt="9"></p>
<h3 id="Notation">Notation</h3>
<p>为了更好地讨论 SVM 算法，我们需要先引入一些符号。我们假设一个二分类问题，y ∈ {-1，1} ，而不是之前的 {0，1} 。同样地，我们不再线性分类方法的参数 θ，而是使用参数 w, b ，将分类器写为：</p>
<p style=""><img src="https://math.now.sh?from=h_%7Bw%2C%20b%7D%28x%29%3Dg%5Cleft(w%5E%7BT%7D%20x%2Bb%5Cright)%0A" /></p><p style=""><img src="https://math.now.sh?from=g%28z%29%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bcl%7D%0A1%20%26%20%5Ctext%20%7B%20if%20%7D%20z%20%5Cgeqslant%200%20%5C%5C%0A-1%20%26%20%5Ctext%20%7B%20if%20%7D%20z%20%5Ctextless%200%20%5C%5C%0A%5Cend%7Barray%7D%5Cright.%0A" /></p><p>如果 <img src="https://math.now.sh?inline=z%20%5Cgeq%200" style="display:inline-block;margin: 0;"/> ，则判定 g(z) =1 ，反之则判定 g(z) = -1 。这里将截距 b 拆分出来，这样我们后面可以单独对截距进行处理。这里同样放弃了前面设定 x<sub>0</sub> =1 的做法。因此，b 就是前面的 θ<sub>0</sub> ，而 w 就是 <img src="https://math.now.sh?inline=%5Cleft%5B%5Ctheta_%7B1%7D%20%5Cldots%20%5Ctheta_%7Bn%7D%5Cright%5D%5E%7BT%7D" style="display:inline-block;margin: 0;"/></p>
<p>注意，这里我们根据 <img src="https://math.now.sh?inline=w%5E%7BT%7D%20x%2Bb" style="display:inline-block;margin: 0;"/> 的大小直接预测 1 或者 -1 , 就像感受器算法，而不像是逻辑回归，还需要先预测 y = 1的概率，再进行判定。</p>
<h3 id="Functional-and-geometric-margins">Functional and geometric margins</h3>
<p>假设存在一个训练集样本 <img src="https://math.now.sh?inline=%28x%5E%7B(i%29%7D%2C%20y%5E%7B(i)%7D)" style="display:inline-block;margin: 0;"/> , 我们定义 <strong>函数间隔 (functional margin)</strong> of (w,b) 为</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cgamma%7D%5E%7B%28i%29%7D%3Dy%5E%7B(i)%7D%5Cleft(w%5E%7BT%7D%20x%2Bb%5Cright)%0A" /></p><p>假设 <img src="https://math.now.sh?inline=y%5E%7B%28i%29%7D%20%3D%201" style="display:inline-block;margin: 0;"/> ，那么为了让函数间隔越大，那么我们就需要让 <img src="https://math.now.sh?inline=w%5E%7BT%7D%20x%2Bb" style="display:inline-block;margin: 0;"/> 是一个很大的正数；反之则需要让 <img src="https://math.now.sh?inline=w%5E%7BT%7D%20x%2Bb" style="display:inline-block;margin: 0;"/> 为一个很大的负数。其实，如果 <img src="https://math.now.sh?inline=y%5E%7B%28i%29%7D%5Cleft(w%5E%7BT%7D%20x%2Bb%5Cright)%20%3E%200" style="display:inline-block;margin: 0;"/> 成立，那么我们对这个样本的预测就是对的。因此，函数间隔越大，我们对预测的信心越大。</p>
<p>但是函数间隔有一个不好的性质，假设我们将参数w,b直接翻倍为 2w,2b，那么模型的预测结果不会改变（因为模型预测结果只看符号），但是函数间隔扩大了一倍（没有意义）。因此，我们可能需要往函数间隔的公式加入一些参数标准化的条件，比如 $||w||_{2} =1 $ 。</p>
<p>假设我们有一个训练集 <img src="https://math.now.sh?inline=S%3D%5Cleft%5C%7B%5Cleft%28x%5E%7B(i%29%7D%2C%20y%5E%7B(i)%7D%5Cright)%20%3B%20i%3D1%2C%20%5Cldots%2C%20m%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> ，我们定义训练集S某组参数 (w,b) 的函数间隔为最小的单个样本的函数间隔，写作下式：</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cgamma%7D%3D%5Cmin%20_%7Bi%3D1%2C%20%5Cldots%2C%20m%7D%20%5Chat%7B%5Cgamma%7D%5E%7B%28i%29%7D%0A" /></p><p>下面，我们来看一下<strong>几何间隔 (geometric margins)</strong>。决策线如下图所示，图上同样显示了 w 向量。我们知道 w 向量<strong>正交于</strong>分隔超平面。假设我们在 A 点，此处的预测值为1，该点与决策线的距离为线段 AB 。</p>
<p><img src="15.png" alt="9"></p>
<p>那么我们如何确定几何间隔的值呢？也就是 AB 长度如何计算？首先，<img src="https://math.now.sh?inline=w%20%2F%5C%7Cw%5C%7C" style="display:inline-block;margin: 0;"/> 表示单位长度的 w 向量。因为 点A 表示 x<sup>(i)</sup> ，因此我们发现点B 可以写为 <img src="https://math.now.sh?inline=x%5E%7B%28i%29%7D-%5Cgamma%5E%7B(i)%7D%20%5Ccdot%20w%20%2F%5C%7Cw%5C%7C" style="display:inline-block;margin: 0;"/> 。又因为点 B 在决策线上，而决策线上的点均满足 <img src="https://math.now.sh?inline=w%5E%7BT%7Dx%2Bb%3D0" style="display:inline-block;margin: 0;"/>，因此</p>
<p style=""><img src="https://math.now.sh?from=w%5E%7BT%7D%5Cleft%28x%5E%7B(i%29%7D-%5Cgamma%5E%7B(i)%7D%20%5Cfrac%7Bw%7D%7B%5C%7Cw%5C%7C%7D%5Cright)%2Bb%3D0%0A" /></p><p>因此，我们得到下式（因为 <img src="https://math.now.sh?inline=w%5E%7BT%7Dw%3D%7C%7Cw%7C%7C%5E%7B2%7D" style="display:inline-block;margin: 0;"/>）</p>
<p style=""><img src="https://math.now.sh?from=%5Cgamma%5E%7B%28i%29%7D%3D%5Cfrac%7Bw%5E%7BT%7D%20x%5E%7B(i)%7D%2Bb%7D%7B%5C%7Cw%5C%7C%7D%3D%5Cleft(%5Cfrac%7Bw%7D%7B%5C%7Cw%5C%7C%7D%5Cright)%5E%7BT%7D%20x%5E%7B(i)%7D%2B%5Cfrac%7Bb%7D%7B%5C%7Cw%5C%7C%7D%0A" /></p><p>这个式子只对于在决策线上方（预测y=1）有用，为了使得几何间隔对所有样本点均实用，我们实际定义几何间隔如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cgamma%5E%7B%28i%29%7D%3Dy%5E%7B(i)%7D%5Cleft(%5Cleft(%5Cfrac%7Bw%7D%7B%5C%7Cw%5C%7C%7D%5Cright)%5E%7BT%7D%20x%5E%7B(i)%7D%2B%5Cfrac%7Bb%7D%7B%5C%7Cw%5C%7C%7D%5Cright)%0A" /></p><p>从该式可知，如果 <img src="https://math.now.sh?inline=%7C%7Cw%7C%7C%3D1" style="display:inline-block;margin: 0;"/>，那么函数间隔与几何间隔相同。放大或缩小参数对几何间隔没有影响，比如我们将 w 和 b 均扩大两倍，几何间隔不变。</p>
<p>最后，对于一个训练集 S ，我们同样定义对于训练集 S 的一组参数 (w, b) 的几何间隔等于单个样本点的几何间隔的最小值</p>
<p style=""><img src="https://math.now.sh?from=%5Cgamma%3D%5Cmin%20_%7Bi%3D1%2C%20%5Cldots%2C%20m%7D%20%5Cgamma%5E%7B%28i%29%7D%0A" /></p><h3 id="为什么-w-是-w-Tx-b-0-平面的法向量？">为什么 <img src="https://math.now.sh?inline=w" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=w%5ETx%2Bb%3D0" style="display:inline-block;margin: 0;"/> 平面的法向量？</h3>
<p>这个问题的解答其实就是来自于对平面的定义和描述。资源来源于一个微积分课程 - <a href="https://tutorial.math.lamar.edu/Classes/CalcII/CalcII.aspx">Calcll</a>  的第六章 <code>3-Dimensional Space</code>。</p>
<p>假设在一个三维平面上，假设我们已知平面上的一个点 <img src="https://math.now.sh?inline=P_%7B0%7D%3D%5Cleft%28x_%7B0%7D%2C%20y_%7B0%7D%2C%20z_%7B0%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 及其正交向量/法向量 <img src="https://math.now.sh?inline=%5Cvec%7Bn%7D%3D%5Clangle%20a%2C%20b%2C%20c%5Crangle" style="display:inline-block;margin: 0;"/> 。我们假设 <img src="https://math.now.sh?inline=P%3D%28x%2C%20y%2C%20z%29" style="display:inline-block;margin: 0;"/> 是平面上的任何一点，我们分别用 <img src="https://math.now.sh?inline=%5Cvec%7Br_%7B0%7D%7D" style="display:inline-block;margin: 0;"/>  和 <img src="https://math.now.sh?inline=%5Cvec%7Br%7D" style="display:inline-block;margin: 0;"/>  表示 <img src="https://math.now.sh?inline=P_%7B0%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=P" style="display:inline-block;margin: 0;"/> 的位置向量，如下图所示：</p>
<p><img src="16.png" alt="16"></p>
<p>我们注意到向量 <img src="https://math.now.sh?inline=%5Cvec%7Br%7D%20-%20%5Cvec%7Br_%7B0%7D%7D" style="display:inline-block;margin: 0;"/> 正好处于这个平面上，我们又已知平面的正交向量 <img src="https://math.now.sh?inline=%5Cvec%7Bn%7D" style="display:inline-block;margin: 0;"/> ，因此  <img src="https://math.now.sh?inline=%5Cvec%7Bn%7D" style="display:inline-block;margin: 0;"/> 同样正交于  <img src="https://math.now.sh?inline=%5Cvec%7Br%7D%20-%20%5Cvec%7Br_%7B0%7D%7D" style="display:inline-block;margin: 0;"/> ，存在下式</p>
<p style=""><img src="https://math.now.sh?from=%5Cvec%7Bn%7D%20%5Ccdot%5Cleft%28%5Cvec%7Br%7D-%5Cvec%7Br%7D_%7B0%7D%5Cright%29%3D0%20%5Cquad%20%5CRightarrow%20%5Cquad%20%5Cvec%7Bn%7D%20%5Ccdot%20%5Cvec%7Br%7D%3D%5Cvec%7Bn%7D%20%5Ccdot%20%5Cvec%7Br%7D_%7B0%7D%0A" /></p><p>这称为<strong>平面的向量方程 (vector equation of the plane)</strong>，将上面的式子拆开，我们得到下式（<strong>平面的标量表达式 (scalar equation of plane)</strong>）</p>
<p style=""><img src="https://math.now.sh?from=a%5Cleft%28x-x_%7B0%7D%5Cright%29%2Bb%5Cleft(y-y_%7B0%7D%5Cright)%2Bc%5Cleft(z-z_%7B0%7D%5Cright)%3D0%0A" /></p><p>通常我们会将该式写为</p>
<p style=""><img src="https://math.now.sh?from=a%20x%2Bb%20y%2Bc%20z%3Dd%20%5C%5C%0A%5Ctext%7B%20%E5%85%B6%E4%B8%AD%2C%20%20%7D%20d%20%3D%20ax_0%20%2B%20by_0%20%2B%20cz_0%0A" /></p><p>这个式子就是通常我们给出的平面表达式，因此当我们看到这个平面的表达式，我们马上就知道这个平面的法向量为</p>
<p style=""><img src="https://math.now.sh?from=%5Cvec%7Bn%7D%3D%5Clangle%20a%2C%20b%2C%20c%5Crangle%0A" /></p><h1>最优间隔分类器问题</h1>
<h3 id="The-optimal-margin-classfier">The optimal margin classfier</h3>
<p>我们想要找一个 margin 最大的决策线（假设训练集是线性可分的），然后我们如果找到一个几何间隔最大的决策线呢？我们得到下面的优化问题：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmax%20_%7B%5Cgamma%2C%20w%2C%20b%7D%20%26%20%5Cgamma%20%5C%5C%0A%5Ctext%20%7B%20s.t.%20%7D%20%26%20y%5E%7B%28i%29%7D%5Cleft(w%5E%7BT%7D%20x%5E%7B(i)%7D%2Bb%5Cright)%20%5Cgeq%20%5Cgamma%2C%20%5Cquad%20i%3D1%2C%20%5Cldots%2C%20m%20%5C%5C%0A%26%5C%7Cw%5C%7C%3D1%0A%5Cend%7Baligned%7D%0A" /></p><p>但是 <img src="https://math.now.sh?inline=%5C%7Cw%5C%7C%3D1" style="display:inline-block;margin: 0;"/> 这个限制条件是一个 <code>nasty(non-convex)</code> 的限制条件（不懂），这个问题无法用标准的优化软件来解决。因此，我们将这个优化问题改为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmax%20_%7B%5Chat%7B%5Cgamma%7D%2C%20w%2C%20b%7D%20%26%20%5Cfrac%7B%5Chat%7B%5Cgamma%7D%7D%7B%5C%7Cw%5C%7C%7D%20%5C%5C%0A%5Ctext%20%7B%20s.t.%20%7D%20%26%20y%5E%7B%28i%29%7D%5Cleft(w%5E%7BT%7D%20x%5E%7B(i)%7D%2Bb%5Cright)%20%5Cgeq%20%5Chat%7B%5Cgamma%7D%2C%20%5Cquad%20i%3D1%2C%20%5Cldots%2C%20m%0A%5Cend%7Baligned%7D%0A" /></p><p>但是 <img src="https://math.now.sh?inline=%5Cfrac%7B%5Chat%7B%5Cgamma%7D%7D%7B%5C%7Cw%5C%7C%7D" style="display:inline-block;margin: 0;"/> 这个目标函数也是 <code>nasty (non-convex)</code> 的，因此我们依然无法解决这个问题。因此，我们还需要继续做转换，考虑到参数 <img src="https://math.now.sh?inline=w" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=b" style="display:inline-block;margin: 0;"/> 可以随意缩放使得函数间隔取得任意值，因此我们使得参数缩放至函数间隔正好为1：</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cgamma%7D%3D1%0A" /></p><p>此时相当于上面的优化问题乘以了某个常数，代入上式，得到优化目标为 <img src="https://math.now.sh?inline=%5Chat%7B%5Cgamma%7D%20%2F%5C%7Cw%5C%7C%3D1%20%2F%5C%7Cw%5C%7C" style="display:inline-block;margin: 0;"/> ，等同于最小化 <img src="https://math.now.sh?inline=%5C%7Cw%5C%7C%5E2" style="display:inline-block;margin: 0;"/> ，因此我们有了下面的优化问题:</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmin%20_%7B%5Cgamma%2C%20w%2C%20b%7D%20%26%20%5Cfrac%7B1%7D%7B2%7D%5C%7Cw%5C%7C%5E%7B2%7D%20%5C%5C%0A%5Ctext%20%7B%20s.t.%20%7D%20%26%20y%5E%7B%28i%29%7D%5Cleft(w%5E%7BT%7D%20x%5E%7B(i)%7D%2Bb%5Cright)%20%5Cgeq%201%2C%20%5Cquad%20i%3D1%2C%20%5Cldots%2C%20m%0A%5Cend%7Baligned%7D%0A" /></p><p>这个优化问题是可以被有效解决的，其目标函数是一个凸函数，限制条件为线性限制。这个优化问题的解便是 <strong>最大间隔分类器 (optimal margin classifier)</strong> 。这个优化问题可以用<strong>商业二次规划代码 (commercial quadratic programming code)</strong> 解决。</p>
<p>这里我们可能要打断一下来讨论一下<strong>拉格朗日对偶 (Lagrange duality)</strong> 。这可以将我们的优化问题转为对偶形式，从而使得我们使用不同的核函数来高效地得到最大间隔分类器，这往往比一般地二次规划软件更好。</p>
<h3 id="Lagrange-duality">Lagrange duality</h3>
<p>让我们先把 SVM 和 最大间隔分类器啥的放在一边，讨论一下如何解决有约束条件的优化问题。</p>
<p>假设一个优化问题的形式如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Barray%7D%7Brl%7D%0A%5Cmin%20_%7Bw%7D%20%26%20f%28w%29%20%5C%5C%0A%5Ctext%20%7B%20s.t.%20%7D%20%26%20h_%7Bi%7D(w)%3D0%2C%20%5Cquad%20i%3D1%2C%20%5Cldots%2C%20l%0A%5Cend%7Barray%7D%0A" /></p><p>你可能回忆起如果使用**拉格朗日乘子 (Lagrange multipliers)**来解决这个问题（没有！）。在这种方式中，我们定义拉格朗日函数如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathcal%7BL%7D%28w%2C%20%5Cbeta%29%3Df(w)%2B%5Csum_%7Bi%3D1%7D%5E%7Bl%7D%20%5Cbeta_%7Bi%7D%20h_%7Bi%7D(w)%0A" /></p><p>这里的 <img src="https://math.now.sh?inline=%5Cbeta_%7Bi%7D" style="display:inline-block;margin: 0;"/> 称为拉格朗日乘子。我们需要使得偏导数均为0</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%5Cpartial%20%5Cmathcal%7BL%7D%7D%7B%5Cpartial%20w_%7Bi%7D%7D%3D0%20%3B%20%5Cquad%20%5Cfrac%7B%5Cpartial%20%5Cmathcal%7BL%7D%7D%7B%5Cpartial%20%5Cbeta_%7Bi%7D%7D%3D0%0A" /></p><p>从而求解 <img src="https://math.now.sh?inline=w" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cbeta" style="display:inline-block;margin: 0;"/> 。</p>
<p>在这一章节，我们需要将其扩展，同时包含等式约束条件和不等式约束条件，原始优化问题如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Barray%7D%7Brl%7D%0A%5Cmin%20_%7Bw%7D%20%26%20f%28w%29%20%5C%5C%0A%5Ctext%20%7B%20s.t.%20%7D%20%26%20g_%7Bi%7D(w)%20%5Cleq%200%2C%20%5Cquad%20i%3D1%2C%20%5Cldots%2C%20k%20%5C%5C%0A%26%20h_%7Bi%7D(w)%3D0%2C%20%5Cquad%20i%3D1%2C%20%5Cldots%2C%20l%0A%5Cend%7Barray%7D%0A" /></p><p>为了解决这个问题，我们开始定义<strong>广义拉格朗日函数 (generalized Lagrangian)</strong> 如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathcal%7BL%7D%28w%2C%20%5Calpha%2C%20%5Cbeta%29%3Df(w)%2B%5Csum_%7Bi%3D1%7D%5E%7Bk%7D%20%5Calpha_%7Bi%7D%20g_%7Bi%7D(w)%2B%5Csum_%7Bi%3D1%7D%5E%7Bl%7D%20%5Cbeta_%7Bi%7D%20h_%7Bi%7D(w)%0A" /></p><p>这里的 <img src="https://math.now.sh?inline=%5Calpha_%7Bi%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cbeta_%7Bi%7D" style="display:inline-block;margin: 0;"/> 均为拉格朗日乘子，考虑下面的函数</p>
<p style=""><img src="https://math.now.sh?from=%5Ctheta_%7B%5Cmathcal%7BP%7D%7D%28w%29%3D%5Cmax%20_%7B%5Calpha%2C%20%5Cbeta%3A%20%5Calpha_%7Bi%7D%20%5Cgeq%200%7D%20%5Cmathcal%7BL%7D(w%2C%20%5Calpha%2C%20%5Cbeta)%0A" /></p><p>这里的 “P” 表示 “primal” ，原始的意思。假设我们有某个 <img src="https://math.now.sh?inline=w" style="display:inline-block;margin: 0;"/> ，如果 <img src="https://math.now.sh?inline=w" style="display:inline-block;margin: 0;"/> 违背了任何一个原始限制条件（<img src="https://math.now.sh?inline=g_%7Bi%7D%28w%29%3E0" style="display:inline-block;margin: 0;"/> or <img src="https://math.now.sh?inline=h_%7Bi%7D%28w%29%20%5Cneq%200" style="display:inline-block;margin: 0;"/> ），那么你可以验证下式成立（如果某个 <img src="https://math.now.sh?inline=g_%7Bi%7D%28w%29%3E0" style="display:inline-block;margin: 0;"/> ，那么下式会将相应的 <img src="https://math.now.sh?inline=%5Calpha_i" style="display:inline-block;margin: 0;"/> 变成正无穷；如果 <img src="https://math.now.sh?inline=h_%7Bi%7D%28w%29%20%5Cneq%200" style="display:inline-block;margin: 0;"/> , 根据其符号下式就会将相应的 <img src="https://math.now.sh?inline=%5Cbeta_i" style="display:inline-block;margin: 0;"/> 调整为正无穷或负无穷 ）</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Ctheta_%7B%5Cmathcal%7BP%7D%7D%28w%29%20%26%3D%5Cmax%20_%7B%5Calpha%2C%20%5Cbeta%3A%20%5Calpha_%7Bi%7D%20%5Cgeq%200%7D%20f(w)%2B%5Csum_%7Bi%3D1%7D%5E%7Bk%7D%20%5Calpha_%7Bi%7D%20g_%7Bi%7D(w)%2B%5Csum_%7Bi%3D1%7D%5E%7Bl%7D%20%5Cbeta_%7Bi%7D%20h_%7Bi%7D(w)%20%5C%5C%0A%26%3D%5Cinfty%0A%5Cend%7Baligned%7D%0A" /></p><p>反过来说，如果 <img src="https://math.now.sh?inline=w" style="display:inline-block;margin: 0;"/>  符合所有的限制条件，那么 <img src="https://math.now.sh?inline=%5Ctheta_%7B%5Cmathcal%7BP%7D%7D%28w%29%3Df(w)" style="display:inline-block;margin: 0;"/>  (此时后面两项均会设为0) ，因此</p>
<p style=""><img src="https://math.now.sh?from=%5Ctheta_%7B%5Cmathcal%7BP%7D%7D%28w%29%3D%20%5Cbegin%7Bcases%7Df(w)%20%26%20%5Ctext%20%7B%20if%20%7D%20w%20%5Ctext%20%7B%20satisfies%20primal%20constraints%20%7D%20%5C%5C%20%5Cinfty%20%26%20%5Ctext%20%7B%20otherwise.%20%7D%5Cend%7Bcases%7D%0A" /></p><p>因此，我们考虑下面的最小化问题</p>
<p style=""><img src="https://math.now.sh?from=%5Cmin%20_%7Bw%7D%20%5Ctheta_%7B%5Cmathcal%7BP%7D%7D%28w%29%3D%5Cmin%20_%7Bw%7D%20%5Cmax%20_%7B%5Calpha%2C%20%5Cbeta%3A%20%5Calpha_%7Bi%7D%20%5Cgeq%200%7D%20%5Cmathcal%7BL%7D(w%2C%20%5Calpha%2C%20%5Cbeta)%0A" /></p><p>我们看到这个优化问题和我们原始的优化问题一样。因此，我们定义这个优化目标的最理想的值为 <img src="https://math.now.sh?inline=p%5E%7B*%7D%3D%5Cmin%20_%7Bw%7D%20%5Ctheta_%7B%5Cmathcal%7BP%7D%7D%28w%29" style="display:inline-block;margin: 0;"/> ，我们称之为 <code>the value of the primal problem</code> 。</p>
<p>此时，我们看一个不一样的问题，我们定义</p>
<p style=""><img src="https://math.now.sh?from=%5Ctheta_%7B%5Cmathcal%7BD%7D%7D%28%5Calpha%2C%20%5Cbeta%29%3D%5Cmin%20_%7Bw%7D%20%5Cmathcal%7BL%7D(w%2C%20%5Calpha%2C%20%5Cbeta)%0A" /></p><p>这里，”D&quot; 表示 “dual&quot; 。我们现在提出<strong>对偶优化问题 (dual optimization problem)</strong>：（对偶问题和原始问题仅仅是将 max 和 min 的顺序进行了调换）</p>
<p style=""><img src="https://math.now.sh?from=%5Cmax%20_%7B%5Calpha%2C%20%5Cbeta%3A%20%5Calpha_%7Bi%7D%20%5Cgeq%200%7D%20%5Ctheta_%7B%5Cmathcal%7BD%7D%7D%28%5Calpha%2C%20%5Cbeta%29%3D%5Cmax%20_%7B%5Calpha%2C%20%5Cbeta%3A%20%5Calpha_%7Bi%7D%20%5Cgeq%200%7D%20%5Cmin%20_%7Bw%7D%20%5Cmathcal%7BL%7D(w%2C%20%5Calpha%2C%20%5Cbeta)%0A" /></p><p>我们同样定义这个对偶优化目标的最优值为 <img src="https://math.now.sh?inline=d%5E%7B*%7D%3D%5Cmax%20_%7B%5Calpha%2C%20%5Cbeta%3A%20%5Calpha_%7Bi%7D%20%5Cgeq%200%7D%20%5Ctheta_%7B%5Cmathcal%7BD%7D%7D%28w%29" style="display:inline-block;margin: 0;"/></p>
<p>那我们如何将原始优化问题和对偶优化问题联系起来呢？存在下式（缺证明）：</p>
<p style=""><img src="https://math.now.sh?from=d%5E%7B*%7D%3D%5Cmax%20_%7B%5Calpha%2C%20%5Cbeta%3A%20%5Calpha_%7Bi%7D%20%5Cgeq%200%7D%20%5Cmin%20_%7Bw%7D%20%5Cmathcal%7BL%7D%28w%2C%20%5Calpha%2C%20%5Cbeta%29%20%5Cleq%20%5Cmin%20_%7Bw%7D%20%5Cmax%20_%7B%5Calpha%2C%20%5Cbeta%3A%20%5Calpha_%7Bi%7D%20%5Cgeq%200%7D%20%5Cmathcal%7BL%7D(w%2C%20%5Calpha%2C%20%5Cbeta)%3Dp%5E%7B*%7D%0A" /></p><blockquote>
<p>(You should convince yourself of this; this follows from the “max min” of a function always being less than or equal to the “min max.”)</p>
</blockquote>
<p>然而，在某些条件下，我们有下式（<img src="https://math.now.sh?inline=p%5E*" style="display:inline-block;margin: 0;"/> 是原始问题的值，也就是 <img src="https://math.now.sh?inline=f%28w%29" style="display:inline-block;margin: 0;"/> 的最小值，此时 <img src="https://math.now.sh?inline=d%5E*" style="display:inline-block;margin: 0;"/> 也是最小值，因此此时求解对偶问题就是求解原问题）</p>
<p style=""><img src="https://math.now.sh?from=d%5E%7B*%7D%3Dp%5E%7B*%7D%0A" /></p><p>因此此时我们可以通过解决对偶问题，来解决原始优化问题（因为对偶问题往往更加简单，具有更多有用的性质）。让我们看看这些条件是什么。</p>
<p>假设 <img src="https://math.now.sh?inline=f" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=g_i" style="display:inline-block;margin: 0;"/> 都是凸函数（如果 <img src="https://math.now.sh?inline=f" style="display:inline-block;margin: 0;"/> 存在 Hessian 矩阵，当且仅当其 Hessian 矩阵为半正定矩阵时<img src="https://math.now.sh?inline=f" style="display:inline-block;margin: 0;"/> 为凸函数 ），<img src="https://math.now.sh?inline=h_i" style="display:inline-block;margin: 0;"/> 为<strong>仿射函数 (affine)</strong>（假如存在特定的 <img src="https://math.now.sh?inline=a_i" style="display:inline-block;margin: 0;"/> , <img src="https://math.now.sh?inline=b_i" style="display:inline-block;margin: 0;"/>,  使得 <img src="https://math.now.sh?inline=h_%7Bi%7D%28w%29%20%3D%20a_%7Bi%7D%5E%7BT%7Dw%20%2B%20b_%7Bi%7D" style="display:inline-block;margin: 0;"/> 。仿射类似于线性函数（如果没有截距，线性函数要求 <img src="https://math.now.sh?inline=h%28c_1w_1%2Bc_2w_2%29%20%3D%20c_1h(w_1)%20%2B%20c_2h(w_2)" style="display:inline-block;margin: 0;"/>）,只是这里允许添加一个额外的截距项 <img src="https://math.now.sh?inline=b_i" style="display:inline-block;margin: 0;"/> ）。另外，假设限制条件 <img src="https://math.now.sh?inline=g_i" style="display:inline-block;margin: 0;"/> 是可以实现的，即存在某个 <img src="https://math.now.sh?inline=w" style="display:inline-block;margin: 0;"/> 使得所有的 $g_{i}(w) &lt; 0 $</p>
<p>在这些假设成立下，我们一定可以找到一个 <img src="https://math.now.sh?inline=w%5E%7B*%7D%2C%20%5Calpha%5E%7B*%7D%2C%20%5Cbeta%5E%7B*%7D" style="display:inline-block;margin: 0;"/> ，使得 <img src="https://math.now.sh?inline=w%5E*" style="display:inline-block;margin: 0;"/> 是原始优化问题的解，$ \alpha^{<em>}, \beta^{</em>}$ 是对偶问题的解，而且存在 <img src="https://math.now.sh?inline=p%5E%7B*%7D%3Dd%5E%7B*%7D%3D%5Cmathcal%7BL%7D%5Cleft%28w%5E%7B*%7D%2C%20%5Calpha%5E%7B*%7D%2C%20%5Cbeta%5E%7B*%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 。更进一步，这三个参数会服从 <strong>Karush-Kuhn-Tucker (KKT) conditions</strong> ，如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20w_%7Bi%7D%7D%20%5Cmathcal%7BL%7D%5Cleft%28w%5E%7B*%7D%2C%20%5Calpha%5E%7B*%7D%2C%20%5Cbeta%5E%7B*%7D%5Cright%29%20%26%3D0%2C%20%5Cquad%20i%3D1%2C%20%5Cldots%2C%20n%20%5C%5C%0A%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Cbeta_%7Bi%7D%7D%20%5Cmathcal%7BL%7D%5Cleft(w%5E%7B*%7D%2C%20%5Calpha%5E%7B*%7D%2C%20%5Cbeta%5E%7B*%7D%5Cright)%20%26%3D0%2C%20%5Cquad%20i%3D1%2C%20%5Cldots%2C%20l%20%5C%5C%0A%5Calpha_%7Bi%7D%5E%7B*%7D%20g_%7Bi%7D%5Cleft(w%5E%7B*%7D%5Cright)%20%26%3D0%2C%20%5Cquad%20i%3D1%2C%20%5Cldots%2C%20k%20%5C%5C%0Ag_%7Bi%7D%5Cleft(w%5E%7B*%7D%5Cright)%20%26%20%5Cleq%200%2C%20%5Cquad%20i%3D1%2C%20%5Cldots%2C%20k%20%5C%5C%0A%5Calpha%5E%7B*%7D%20%26%20%5Cgeq%200%2C%20%5Cquad%20i%3D1%2C%20%5Cldots%2C%20k%0A%5Cend%7Baligned%7D%0A" /></p><p>更进一步，如果某个  <img src="https://math.now.sh?inline=w%5E%7B*%7D%2C%20%5Calpha%5E%7B*%7D%2C%20%5Cbeta%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 满足这些 KKT 条件，那么这就是原始优化问题和对偶问题的解。</p>
<p>KKT 条件中第三个条件称为 <strong>KKT dual complementarity conditi on</strong> 。这个条件隐含如果 <img src="https://math.now.sh?inline=%5Calpha_%7Bi%7D%5E%7B*%7D%20%3E%200" style="display:inline-block;margin: 0;"/> ，那么 <img src="https://math.now.sh?inline=g_%7Bi%7D%28w%5E*%29%20%3D%200" style="display:inline-block;margin: 0;"/> ，此时我们称 <img src="https://math.now.sh?inline=g_i" style="display:inline-block;margin: 0;"/> 是一个 <code>active constraint</code> 。</p>
<p style=""><img src="https://math.now.sh?from=%5Calpha_%7Bi%7D%5E%7B*%7D%20g_%7Bi%7D%5Cleft%28w%5E%7B*%7D%5Cright%29%20%3D0%2C%20%5Cquad%20i%3D1%2C%20%5Cldots%2C%20k%20%5C%5C%0A" /></p><h3 id="如何理解拉格朗日乘子法">如何理解拉格朗日乘子法</h3>
<p>这个回答很好，直接复制过来的。</p>
<blockquote>
<p>作者：戏言玩家<br>
链接：<a href="https://www.zhihu.com/question/38586401/answer/105588901">https://www.zhihu.com/question/38586401/answer/105588901</a><br>
来源：知乎<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>这个可以比较直观的解释。</p>
<p>想象一下，目标函数<img src="https://math.now.sh?inline=f%28x%2Cy%29" style="display:inline-block;margin: 0;"/>是一座山的高度，约束<img src="https://math.now.sh?inline=g%28x%2Cy%29%3DC" style="display:inline-block;margin: 0;"/> 是镶嵌在山上的一条曲线如下图。</p>
<p><img src="17.png" alt="17"></p>
<p>你为了找到曲线上的最低点，就从最低的等高线（0那条）开始网上数。数到第三条，等高线终于和曲线有交点了（如上图所示）。因为比这条等高线低的地方都不在约束范围内，所以这肯定是这条约束曲线的最低点了。</p>
<p>而且约束曲线在这里不可能和等高线相交，一定是相切。因为如果是相交的话，如下图所示，那么曲线一定会有一部分在B区域，但是B区域比等高线低，这是不可能的。</p>
<p><img src="18.png" alt="17"></p>
<p>两条曲线相切，意味着他们在这点的法线平行，也就是法向量只差一个任意的常数乘子（取为<img src="https://math.now.sh?inline=-%5Clambda" style="display:inline-block;margin: 0;"/>）：<img src="https://math.now.sh?inline=%5Cnabla%20f%28x%2Cy%29%20%3D%20-%20%5Clambda%20%5Cnabla%20g(x%2Cy)" style="display:inline-block;margin: 0;"/>, 我们把这个式子的右边移到左边，并把常数移进微分算子，就得到 <img src="https://math.now.sh?inline=%5Cnabla%20%28f(x%2Cy%29%20%2B%20%5Clambda%20g(x%2Cy))" style="display:inline-block;margin: 0;"/> 。</p>
<p>把这个式子重新解释一下，这个就是函数 <img src="https://math.now.sh?inline=f%28x%2Cy%29%20%2B%20%5Clambda%20g(x%2Cy)" style="display:inline-block;margin: 0;"/> 无约束情况下极值点的必要条件。</p>
<h3 id="Optimal-margin-classifiers">Optimal margin classifiers</h3>
<p>让我们回到找最大间隔分类器的优化问题：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmin%20_%7B%5Cgamma%2C%20w%2C%20b%7D%20%26%20%5Cfrac%7B1%7D%7B2%7D%5C%7Cw%5C%7C%5E%7B2%7D%20%5C%5C%0A%5Ctext%20%7B%20s.t.%20%7D%20%26%20y%5E%7B%28i%29%7D%5Cleft(w%5E%7BT%7D%20x%5E%7B(i)%7D%2Bb%5Cright)%20%5Cgeq%201%2C%20%5Cquad%20i%3D1%2C%20%5Cldots%2C%20m%0A%5Cend%7Baligned%7D%0A" /></p><p>我们可以将这个限制条件写为</p>
<p style=""><img src="https://math.now.sh?from=g_%7Bi%7D%28w%29%3D-y%5E%7B(i)%7D%5Cleft(w%5E%7BT%7D%20x%5E%7B(i)%7D%2Bb%5Cright)%2B1%20%5Cleq%200%0A" /></p><p>我们对每个训练集的样本均存在这样一个限制条件。通过 KKT 互补条件，我们知道只有当训练集样本的函数间隔正好为1时（<img src="https://math.now.sh?inline=g_i%28w%29%20%3D%200" style="display:inline-block;margin: 0;"/>），才有 <img src="https://math.now.sh?inline=%5Calpha_%7Bi%7D%20%3E%200" style="display:inline-block;margin: 0;"/> （通常如此，但不一定，此时 <img src="https://math.now.sh?inline=%5Calpha_%7Bi%7D" style="display:inline-block;margin: 0;"/> 也可以等于 0）。 根据下面的图片，最大间隔的超平面就是下面的实线。</p>
<p><img src="19.png" alt="19"></p>
<p>间隔最小的样本就是距离决策线最近的点，在这里是三个点，它们在平行于决策线的虚线上。因此只有三个 <img src="https://math.now.sh?inline=%5Calpha_%7Bi%7D" style="display:inline-block;margin: 0;"/> 不等于0。这三个点称为<strong>支持向量 (support vectors)</strong>。</p>
<p>我们构建拉格朗日函数如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathcal%7BL%7D%28w%2C%20b%2C%20%5Calpha%29%3D%5Cfrac%7B1%7D%7B2%7D%5C%7Cw%5C%7C%5E%7B2%7D-%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7D%5Cleft%5By%5E%7B(i)%7D%5Cleft(w%5E%7BT%7D%20x%5E%7B(i)%7D%2Bb%5Cright)-1%5Cright%5D%0A" /></p><p>我们注意到这里只有 <img src="https://math.now.sh?inline=%5Calpha_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，没有 <img src="https://math.now.sh?inline=%5Cbeta_%7Bi%7D" style="display:inline-block;margin: 0;"/>，因为这里只有不等式约束条件。</p>
<p>让我们看一下这个问题的对偶形式。首先我们要先<strong>固定 <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/></strong> ，针对 <img src="https://math.now.sh?inline=w" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=b" style="display:inline-block;margin: 0;"/> 最小化 <img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D%28w%2C%20b%2C%20%5Calpha%29" style="display:inline-block;margin: 0;"/> ，来得到 <img src="https://math.now.sh?inline=%5Ctheta_%7B%5Cmathcal%7BD%7D%7D" style="display:inline-block;margin: 0;"/> 。即，我们求 <img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D" style="display:inline-block;margin: 0;"/> 对 <img src="https://math.now.sh?inline=w" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=b" style="display:inline-block;margin: 0;"/> 的偏导为0。我们有：</p>
<p style=""><img src="https://math.now.sh?from=%5Cnabla_%7Bw%7D%20%5Cmathcal%7BL%7D%28w%2C%20b%2C%20%5Calpha%29%3Dw-%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7D%20y%5E%7B(i)%7D%20x%5E%7B(i)%7D%3D0%0A" /></p><p><strong>证明</strong>：</p>
<p>首先看第一部分的梯度，<img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7B2%7D%5C%7Cw%5C%7C%5E%7B2%7D%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%28w_%7Bi%7D%5E2%29" style="display:inline-block;margin: 0;"/> ，因此易知 <img src="https://math.now.sh?inline=%28%5Cnabla_%7Bw%7D%20%5Cfrac%7B1%7D%7B2%7D%5C%7Cw%5C%7C%5E%7B2%7D%29_%7Bi%7D%20%3D%20w_%7Bi%7D" style="display:inline-block;margin: 0;"/>  ，故  <img src="https://math.now.sh?inline=%28%5Cnabla_%7Bw%7D%20%5Cfrac%7B1%7D%7B2%7D%5C%7Cw%5C%7C%5E%7B2%7D%29%20%3D%20w" style="display:inline-block;margin: 0;"/> 。</p>
<p>再看 <img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D" style="display:inline-block;margin: 0;"/> 的第一部分，我们剔除与 <img src="https://math.now.sh?inline=w" style="display:inline-block;margin: 0;"/> 无关的项，得到 <img src="https://math.now.sh?inline=%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7Dy%5E%7B%28i%29%7Dw%5E%7BT%7D%20x%5E%7B(i)%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Calpha_%7Bi%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=y%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> 为固定的常数，因此只要看 <img src="https://math.now.sh?inline=w%5E%7BT%7D%20x%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> ,由于这是个向量内积，易知，<img src="https://math.now.sh?inline=%5Cnabla%20%28w%5E%7BT%7D%20x%5E%7B(i%29%7D)%20%3D%20%20x%5E%7B(i)%7D" style="display:inline-block;margin: 0;"/> ，整理一下，得证上式。</p>
<p>回到上面，因此存在下式，即 <img src="https://math.now.sh?inline=w" style="display:inline-block;margin: 0;"/> 是训练集所有输入特征的线性组合。</p>
<p style=""><img src="https://math.now.sh?from=w%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7D%20y%5E%7B%28i%29%7D%20%5Cboldsymbol%7Bx%5E%7B(i)%7D%7D%0A" /></p><p>当我们对 b 求偏导，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20b%7D%20%5Cmathcal%7BL%7D%28w%2C%20b%2C%20%5Calpha%29%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7D%20y%5E%7B(i)%7D%3D0%0A" /></p><p>我们将得到的 <img src="https://math.now.sh?inline=w" style="display:inline-block;margin: 0;"/> 的式子代入到拉格朗日函数，简化得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathcal%7BL%7D%28w%2C%20b%2C%20%5Calpha%29%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7D-%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bi%2C%20j%3D1%7D%5E%7Bm%7D%20y%5E%7B(i)%7D%20y%5E%7B(j)%7D%20%5Calpha_%7Bi%7D%20%5Calpha_%7Bj%7D%5Cleft(x%5E%7B(i)%7D%5Cright)%5E%7BT%7D%20x%5E%7B(j)%7D-b%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7D%20y%5E%7B(i)%7D%0A" /></p><p><strong>证明</strong>：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26L%28w%2C%20b%2C%20%5Calpha%29%3D%5Cfrac%7B1%7D%7B2%7D%20w%5E%7BT%7D%20w-%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7D%5Cleft%5By%5E%7B(i)%7D%5Cleft(w%5E%7BT%7D%20x%5E%7B(i)%7D%2Bb%5Cright)-1%5Cright%5D%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7B2%7D%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7D%20y%5E%7B(i)%7D%20x%5E%7B(i)%7D%5Cright)%5E%7BT%7D%5Cleft(%5Csum_%7Bj%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bj%7D%20y%5E%7B(j)%7D%20x%5E%7B(j)%7D%5Cright)%5C%5C%0A%26%20%5Cquad%20-%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7D%5Cleft%5By%5E%7B(i)%7D%5Cleft(%5Cleft(%5Csum_%7Bj%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bj%7D%20y%5E%7B(j)%7D%20x%5E%7B(j)%7D%5Cright)%5E%7BT%7D%20x%5E%7B(i)%7D%2Bb%5Cright)-1%5Cright%5D%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20y%5E%7B(i)%7D%20y%5E%7B(j)%7D%20%5Calpha_%7Bi%7D%20%5Calpha_%7Bj%7D%5Cleft%5Clangle%20x%5E%7B(i)%7D%2C%20x%5E%7B(j)%7D%5Cright%5Crangle%5C%5C%0A%26%20%5Cquad%20-%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20y%5E%7B(i)%7D%20y%5E%7B(j)%7D%20%5Calpha_%7Bi%7D%20%5Calpha_%7Bj%7D%5Cleft%5Clangle%20x%5E%7B(i)%7D%2C%20x%5E%7B(j)%7D%5Cright%5Crangle%5C%5C%0A%26%20%5Cquad%20-b%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7D%20y%5E%7B(i)%7D%2B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7D%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7D-%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bi%2C%20j%3D1%7D%5E%7Bm%7D%20y%5E%7B(i)%7D%20y%5E%7B(j)%7D%20%5Calpha_%7Bi%7D%20%5Calpha_%7Bj%7D%5Cleft(x%5E%7B(i)%7D%5Cright)%5E%7BT%7D%20x%5E%7B(j)%7D-b%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7D%20y%5E%7B(i)%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>根据 b 的偏导，我们知道最后一项为 0，因此，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathcal%7BL%7D%28w%2C%20b%2C%20%5Calpha%29%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7D-%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bi%2C%20j%3D1%7D%5E%7Bm%7D%20y%5E%7B(i)%7D%20y%5E%7B(j)%7D%20%5Calpha_%7Bi%7D%20%5Calpha_%7Bj%7D%5Cleft(x%5E%7B(i)%7D%5Cright)%5E%7BT%7D%20x%5E%7B(j)%7D%20.%0A" /></p><p>这个式子就是对 <img src="https://math.now.sh?inline=w" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=b" style="display:inline-block;margin: 0;"/> 最小化 <img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D" style="display:inline-block;margin: 0;"/> 的式子，整理一下（加入限制条件），得到对偶优化问题：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmax%20_%7B%5Calpha%7D%20%26%20W%28%5Calpha%29%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7D-%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bi%2C%20j%3D1%7D%5E%7Bm%7D%20y%5E%7B(i)%7D%20y%5E%7B(j)%7D%20%5Calpha_%7Bi%7D%20%5Calpha_%7Bj%7D%5Cleft%5Clangle%20x%5E%7B(i)%7D%2C%20x%5E%7B(j)%7D%5Cright%5Crangle%20%5C%5C%0A%5Ctext%20%7B%20s.t.%20%7D%20%26%20%5Calpha_%7Bi%7D%20%5Cgeq%200%2C%20%5Cquad%20i%3D1%2C%20%5Cldots%2C%20m%20%5C%5C%0A%26%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7D%20y%5E%7B(i)%7D%3D0%0A%5Cend%7Baligned%7D%0A" /></p><p>你可以检查这个式子满足了 KKT 的所有条件（嗯？貌似KKT 还有一个条件没满足，就是 <img src="https://math.now.sh?inline=%5Calpha_%7Bi%7D%5E%7B*%7D%20g_%7Bi%7D%5Cleft%28w%5E%7B*%7D%5Cright%29%20%3D0%2C%20%5Cquad%20i%3D1%2C%20%5Cldots%2C%20k" style="display:inline-block;margin: 0;"/>）。在上面的优化式子，你可以得到 <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/> ，将 <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/> 的值代入 <img src="https://math.now.sh?inline=w" style="display:inline-block;margin: 0;"/> 的式子就能得到 <img src="https://math.now.sh?inline=w" style="display:inline-block;margin: 0;"/> 。最后，当你已知 <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=w" style="display:inline-block;margin: 0;"/> ，你可以很轻易地得到 b (不同的 b 为不同的平行的超平面)， 吴老师说是将 <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=w" style="display:inline-block;margin: 0;"/> 代入原始优化问题中 ，最终 b 的计算公式如下（缺证明）</p>
<p style=""><img src="https://math.now.sh?from=b%5E%7B*%7D%3D-%5Cfrac%7B%5Cmax%20_%7Bi%3A%20y%5E%7B%28i%29%7D%3D-1%7D%20w%5E%7B*%20T%7D%20x%5E%7B(i)%7D%2B%5Cmin%20_%7Bi%3A%20y%5E%7B(i)%7D%3D1%7D%20w%5E%7B*%20T%7D%20x%5E%7B(i)%7D%7D%7B2%7D%0A" /></p><p>假设我们已经拟合了所有参数，预测新样本时只需要计算 <img src="https://math.now.sh?inline=w%5E%7BT%7Dx%2Bb" style="display:inline-block;margin: 0;"/> ，看这个值的符号。我们可以将 <img src="https://math.now.sh?inline=w" style="display:inline-block;margin: 0;"/> 的计算式子代入，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Aw%5E%7BT%7D%20x%2Bb%20%26%3D%5Cleft%28%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7D%20y%5E%7B(i%29%7D%20x%5E%7B(i)%7D%5Cright)%5E%7BT%7D%20x%2Bb%20%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7D%20y%5E%7B(i)%7D%5Cleft%5Clangle%20x%5E%7B(i)%7D%2C%20x%5Cright%5Crangle%2Bb%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，如果我们得到了 <img src="https://math.now.sh?inline=%5Calpha_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，预测时我们只需要 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 和训练集所有样本点的<strong>内积</strong>。更进一步，在前面我们看到除了 <strong>support vectors</strong> ，其他的 <img src="https://math.now.sh?inline=%5Calpha_%7Bi%7D" style="display:inline-block;margin: 0;"/> 均等于0 ，因此我们只需要计算 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 和支持向量之间的内积，这个计算量很小。</p>
<h1>顺序最小优化算法</h1>
<h2 id="Kernels">Kernels</h2>
<p>考虑线性回归的问题，假设我们用房屋面积 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 预测房价，我们使用特征 <img src="https://math.now.sh?inline=x%2C%20x%5E%7B2%7D%2C%20x%5E%7B3%7D" style="display:inline-block;margin: 0;"/> 来拟合模型。我们称”原来“的输入值 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 称为 <strong>attributes</strong> ，我们同样使用 <img src="https://math.now.sh?inline=%5Cphi" style="display:inline-block;margin: 0;"/> 表示 <strong>feature mapping</strong> ，表示从 attributes 到 features 的映射关系，比如在这个例子中，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cphi%28x%29%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0Ax%20%5C%5C%0Ax%5E%7B2%7D%20%5C%5C%0Ax%5E%7B3%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>因此我们可以不对原始的 attributes 采用 SVM ，而对 <img src="https://math.now.sh?inline=%5Cphi%20%28x%29" style="display:inline-block;margin: 0;"/> 进行分析。因为 SVM 算法可以完全写成<strong>内积</strong> <img src="https://math.now.sh?inline=%5Clangle%20x%2Cz%20%5Crangle" style="display:inline-block;margin: 0;"/>  的形式，因此这里我们采用 <img src="https://math.now.sh?inline=%5Clangle%20%5Cphi%20%28x%29%2C%20%5Cphi%20(x)%20%5Crangle" style="display:inline-block;margin: 0;"/> 。特别的，基于一个给定的特征映射 <img src="https://math.now.sh?inline=%5Cphi" style="display:inline-block;margin: 0;"/> ，我们可以定义相应的 <strong>Kernel</strong> 为：</p>
<p style=""><img src="https://math.now.sh?from=K%28x%2C%20z%29%3D%5Cphi(x)%5E%7BT%7D%20%5Cphi(z)%0A" /></p><p>虽然 <img src="https://math.now.sh?inline=%5Cphi%20%28x%29" style="display:inline-block;margin: 0;"/> 的计算量很大（因为维度高），但是奇迹的是 <img src="https://math.now.sh?inline=K%28x%2Cz%29" style="display:inline-block;margin: 0;"/> 计算量不大。因为在 SVM 算法中，计算  <img src="https://math.now.sh?inline=K%28x%2Cz%29" style="display:inline-block;margin: 0;"/>  并不需要先计算  <img src="https://math.now.sh?inline=%5Cphi%20%28x%29" style="display:inline-block;margin: 0;"/> 。</p>
<p>举个例子，假设 <img src="https://math.now.sh?inline=x%2Cz%20%5Cin%20R%5En" style="display:inline-block;margin: 0;"/> ，并且考虑</p>
<p style=""><img src="https://math.now.sh?from=K%28x%2C%20z%29%3D%5Cleft(x%5E%7BT%7D%20z%5Cright)%5E%7B2%7D%0A" /></p><p>因此我们可以将这个式子写成</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AK%28x%2C%20z%29%20%26%3D%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20x_%7Bi%7D%20z_%7Bi%7D%5Cright)%5Cleft(%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20x_%7Bi%7D%20z_%7Bi%7D%5Cright)%20%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20x_%7Bi%7D%20x_%7Bj%7D%20z_%7Bi%7D%20z_%7Bj%7D%20%5C%5C%0A%26%3D%5Csum_%7Bi%2C%20j%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D%20x_%7Bj%7D%5Cright)%5Cleft(z_%7Bi%7D%20z_%7Bj%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们知道 <img src="https://math.now.sh?inline=K%28x%2C%20z%29%3D%5Cphi(x)%5E%7BT%7D%20%5Cphi(z)" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cphi" style="display:inline-block;margin: 0;"/> 等于下式 (n=3)</p>
<p style=""><img src="https://math.now.sh?from=%5Cphi%28x%29%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0Ax_%7B1%7D%20x_%7B1%7D%20%5C%5C%0Ax_%7B1%7D%20x_%7B2%7D%20%5C%5C%0Ax_%7B1%7D%20x_%7B3%7D%20%5C%5C%0Ax_%7B2%7D%20x_%7B1%7D%20%5C%5C%0Ax_%7B2%7D%20x_%7B2%7D%20%5C%5C%0Ax_%7B2%7D%20x_%7B3%7D%20%5C%5C%0Ax_%7B3%7D%20x_%7B1%7D%20%5C%5C%0Ax_%7B3%7D%20x_%7B2%7D%20%5C%5C%0Ax_%7B3%7D%20x_%7B3%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>我们看到这里计算 <img src="https://math.now.sh?inline=%5Cphi%20%28x%29" style="display:inline-block;margin: 0;"/> 需要 <img src="https://math.now.sh?inline=O%28n%5E%7B2%7D%29" style="display:inline-block;margin: 0;"/> 的计算量，而计算 <img src="https://math.now.sh?inline=K%28x%2Cz%29" style="display:inline-block;margin: 0;"/> 需要 <img src="https://math.now.sh?inline=O%28n%29" style="display:inline-block;margin: 0;"/> 的计算量。</p>
<p>对于一个相关的 kernel ，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AK%28x%2C%20z%29%20%26%3D%5Cleft(x%5E%7BT%7D%20z%2Bc%5Cright)%5E%7B2%7D%20%5C%5C%0A%26%3D%5Csum_%7Bi%2C%20j%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D%20x_%7Bj%7D%5Cright)%5Cleft(z_%7Bi%7D%20z_%7Bj%7D%5Cright)%2B%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(%5Csqrt%7B2%20c%7D%20x_%7Bi%7D%5Cright)%5Cleft(%5Csqrt%7B2%20c%7D%20z_%7Bi%7D%5Cright)%2Bc%5E%7B2%7D%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>相应的 <img src="https://math.now.sh?inline=%5Cphi" style="display:inline-block;margin: 0;"/> 为（n=3）</p>
<p style=""><img src="https://math.now.sh?from=%5Cphi%28x%29%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0Ax_%7B1%7D%20x_%7B1%7D%20%5C%5C%0Ax_%7B1%7D%20x_%7B2%7D%20%5C%5C%0Ax_%7B1%7D%20x_%7B3%7D%20%5C%5C%0Ax_%7B2%7D%20x_%7B1%7D%20%5C%5C%0Ax_%7B2%7D%20x_%7B2%7D%20%5C%5C%0Ax_%7B2%7D%20x_%7B3%7D%20%5C%5C%0Ax_%7B3%7D%20x_%7B1%7D%20%5C%5C%0Ax_%7B3%7D%20x_%7B2%7D%20%5C%5C%0Ax_%7B3%7D%20x_%7B3%7D%20%5C%5C%0A%5Csqrt%7B2%20c%7D%20x_%7B1%7D%20%5C%5C%0A%5Csqrt%7B2%20c%7D%20x_%7B2%7D%20%5C%5C%0A%5Csqrt%7B2%20c%7D%20x_%7B3%7D%20%5C%5C%0Ac%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p><img src="21.png" alt="20"></p>
<p>也就是通过核函数，你可以隐式地处理非常高维度的特征向量的数据。</p>
<p>我们讨论一下创造 kernels 的不同观点。从直觉理解来说，如果 <img src="https://math.now.sh?inline=%5Cphi%28x%29" style="display:inline-block;margin: 0;"/> 和 $\phi (z) $ 距离很近，那么我们期望 <img src="https://math.now.sh?inline=K%28x%2C%20z%29%3D%5Cphi(x)%5E%7BT%7D%20%5Cphi(z)" style="display:inline-block;margin: 0;"/> 值应该很大，反之如果 <img src="https://math.now.sh?inline=%5Cphi%28x%29" style="display:inline-block;margin: 0;"/> 和 $\phi (z) $ 距离很远，则 <img src="https://math.now.sh?inline=K%28x%2Cz%29" style="display:inline-block;margin: 0;"/> 值应该很小。因此我们认为， <img src="https://math.now.sh?inline=K%28x%2Cz%29" style="display:inline-block;margin: 0;"/> 应该是衡量  <img src="https://math.now.sh?inline=%5Cphi%28x%29" style="display:inline-block;margin: 0;"/> 和 $\phi (z) $ 相似度的一个指标，或者 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=z" style="display:inline-block;margin: 0;"/> 相似度的一个指标。</p>
<p>在这种直觉下，你可以用别的函数作为核函数，比如</p>
<p style=""><img src="https://math.now.sh?from=K%28x%2C%20z%29%3D%5Cexp%20%5Cleft(-%5Cfrac%7B%5C%7Cx-z%5C%7C%5E%7B2%7D%7D%7B2%20%5Csigma%5E%7B2%7D%7D%5Cright)%0A" /></p><p>如果  <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=z" style="display:inline-block;margin: 0;"/> 很接近，那么这个核函数就接近 1 ，反之则接近 0 。那么这个函数能否作为核函数呢？答案是可以的，这个核函数称为 <strong>高斯核函数 (Gaussian kernel)</strong> ，因为可以找到相应的有限维度的特征映射 <img src="https://math.now.sh?inline=%5Cphi" style="display:inline-block;margin: 0;"/> 。</p>
<p>那么更进一步，给定某个函数 <img src="https://math.now.sh?inline=K" style="display:inline-block;margin: 0;"/> ，我们如何分辨这个函数是否为一个合法的核函数呢？也就是说，我们如何分辨对于函数 <img src="https://math.now.sh?inline=K" style="display:inline-block;margin: 0;"/> 能否找到某个特征映射函数 <img src="https://math.now.sh?inline=%5Cphi" style="display:inline-block;margin: 0;"/> ，使得 <img src="https://math.now.sh?inline=K%28x%2C%20z%29%3D%5Cphi(x)%5E%7BT%7D%20%5Cphi(z)" style="display:inline-block;margin: 0;"/>  呢？</p>
<p>现在我们假设 <img src="https://math.now.sh?inline=K" style="display:inline-block;margin: 0;"/> 就是一个合法的核函数，其特征映射为 <img src="https://math.now.sh?inline=%5Cphi" style="display:inline-block;margin: 0;"/> 。假设我们有一组 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> 个样本点，定义一个 <img src="https://math.now.sh?inline=m%20%5Ctimes%20m" style="display:inline-block;margin: 0;"/> 矩阵 <img src="https://math.now.sh?inline=K" style="display:inline-block;margin: 0;"/> ，其元素为 <img src="https://math.now.sh?inline=K_%7Bi%20j%7D%3DK%5Cleft%28x%5E%7B(i%29%7D%2C%20x%5E%7B(j)%7D%5Cright)" style="display:inline-block;margin: 0;"/> ，我们称这个矩阵为 <strong>核矩阵 (Kernel matrix)</strong> （这里用 <img src="https://math.now.sh?inline=K" style="display:inline-block;margin: 0;"/> 这个符号同时表示核函数与核矩阵）。</p>
<p>由于 <img src="https://math.now.sh?inline=K" style="display:inline-block;margin: 0;"/> 函数是一个合法的核函数，因此 <img src="https://math.now.sh?inline=K_%7Bi%20j%7D%3DK%5Cleft%28x%5E%7B(i%29%7D%2C%20x%5E%7B(j)%7D%5Cright)%3DK%5Cleft(x%5E%7B(j)%7D%2C%20x%5E%7B(i)%7D%5Cright)%3DK_%7Bj%20i%7D" style="display:inline-block;margin: 0;"/> ，即 <img src="https://math.now.sh?inline=K" style="display:inline-block;margin: 0;"/> 矩阵是一个对阵矩阵。进一步，我们使用 <img src="https://math.now.sh?inline=%5Cphi%20_%7Bk%7D%20%28x%29" style="display:inline-block;margin: 0;"/> 表示 <img src="https://math.now.sh?inline=%5Cphi%20%28x%29" style="display:inline-block;margin: 0;"/> 的第 k 个元素的值，我们发现对于任何向量 <img src="https://math.now.sh?inline=z" style="display:inline-block;margin: 0;"/> ，均存在：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Az%5E%7BT%7D%20K%20z%20%26%3D%5Csum_%7Bi%7D%20%5Csum_%7Bj%7D%20z_%7Bi%7D%20K_%7Bi%20j%7D%20z_%7Bj%7D%20%5C%5C%0A%26%3D%5Csum_%7Bi%7D%20%5Csum_%7Bj%7D%20z_%7Bi%7D%20%5Cphi%5Cleft%28x%5E%7B(i%29%7D%5Cright)%5E%7BT%7D%20%5Cphi%5Cleft(x%5E%7B(j)%7D%5Cright)%20z_%7Bj%7D%20%5C%5C%0A%26%3D%5Csum_%7Bi%7D%20%5Csum_%7Bj%7D%20z_%7Bi%7D%20%5Csum_%7Bk%7D%20%5Cphi_%7Bk%7D%5Cleft(x%5E%7B(i)%7D%5Cright)%20%5Cphi_%7Bk%7D%5Cleft(x%5E%7B(j)%7D%5Cright)%20z_%7Bj%7D%20%5C%5C%0A%26%3D%5Csum_%7Bk%7D%20%5Csum_%7Bi%7D%20%5Csum_%7Bj%7D%20z_%7Bi%7D%20%5Cphi_%7Bk%7D%5Cleft(x%5E%7B(i)%7D%5Cright)%20%5Cphi_%7Bk%7D%5Cleft(x%5E%7B(j)%7D%5Cright)%20z_%7Bj%7D%20%5C%5C%0A%26%3D%5Csum_%7Bk%7D%5Cleft(%5Csum_%7Bi%7D%20z_%7Bi%7D%20%5Cphi_%7Bk%7D%5Cleft(x%5E%7B(i)%7D%5Cright)%5Cright)%5E%7B2%7D%20%5C%5C%0A%26%20%5Cgeq%200%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>所以，K 矩阵是一个半正定矩阵（表示为 <img src="https://math.now.sh?inline=K%20%5Cgeq%200" style="display:inline-block;margin: 0;"/> ）。</p>
<p>因此，我们证明了如果 K 函数是一个合法的核函数（对应某个特征映射 <img src="https://math.now.sh?inline=%5Cphi" style="display:inline-block;margin: 0;"/>），那么其相应的核矩阵就是一个<strong>对称半正定矩阵</strong>。事实上这是证明核函数的<strong>充分必要条件</strong>，称为 <strong>Mercer 定理</strong>。因此证明核函数只需要证明其对应的核矩阵就是一个对称半正定矩阵。举个例子，假设 <img src="https://math.now.sh?inline=K%28x%2Cx%29%20%3D%20-1" style="display:inline-block;margin: 0;"/> ，那么这个 K 肯定不是一个合法的核函数 （<img src="https://math.now.sh?inline=K%28x%2C%20x%29%3D%5Cphi(x)%5E%7BT%7D%20%5Cphi(x)%20%5Cgeq%200" style="display:inline-block;margin: 0;"/>）。</p>
<p><img src="20.png" alt="20"></p>
<p>我们先来讨论几个例子，比如数字识别问题，输入为 <img src="https://math.now.sh?inline=16%20%5Ctimes%2016" style="display:inline-block;margin: 0;"/> 的图像，输出为 <img src="https://math.now.sh?inline=0-9" style="display:inline-block;margin: 0;"/> 的数字。 通过使用一个简单多项式的核函数 (<img src="https://math.now.sh?inline=K%28x%2C%20z%29%3D%5Cleft(x%5E%7BT%7D%20z%5Cright)%5E%7Bd%7D" style="display:inline-block;margin: 0;"/>) 或高斯核函数，SVM 可以在这个问题表现很好。你仅仅需要将原来计算内积 <img src="https://math.now.sh?inline=%5Clangle%20x%5E%7B%28i%29%7D%2C%20x%5E%7B(j)%7D%20%5Crangle" style="display:inline-block;margin: 0;"/> 的地方替换为 <img src="https://math.now.sh?inline=K%28x%5E%7B(i%29%7D%2C%20x%5E%7B(j)%7D)" style="display:inline-block;margin: 0;"/> ，实际上这个过程就是你将原来的特征 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 替换为维度很高的特征 <img src="https://math.now.sh?inline=%5Cphi%28x%29" style="display:inline-block;margin: 0;"/> 。</p>
<p>为什么我们要这么做呢？因为我们使用 SVM 就是为了解决<strong>非线性问题</strong>，实际上就是做了 feature engineer ，将无法线性可分的问题转到高纬度空间后变成了线性可分的问题。</p>
<h2 id="Regularization-and-the-non-separable-case">Regularization and the non-separable case</h2>
<p>之前对 SVM 的推导都是假设数据是<strong>线性可分的前提</strong>下，但是我们并不确定将数据转换为高纬度的特征空间就能使得数据线性可分。有些时候，我们也不想找一个线性可分的超平面，因为这很容易受到<strong>异常值</strong>的影响。举个例子，左图为最大间隔分类器结果，右图为在左上角新增了一个异常值的结果，我们发现分界线发生了很大的偏移，分类器的几何间隔变小。</p>
<p><img src="22.png" alt="22"></p>
<p>为了使得这个算法可以满足<strong>非线性</strong>的情况，我们将优化目标改为下式（使用 L1 正则化）</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmin%20_%7B%5Cgamma%2C%20w%2C%20b%7D%20%26%20%5Cfrac%7B1%7D%7B2%7D%5C%7Cw%5C%7C%5E%7B2%7D%2BC%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Cxi_%7Bi%7D%20%5C%5C%0A%5Ctext%20%7B%20s.t.%20%7D%20%26%20y%5E%7B%28i%29%7D%5Cleft(w%5E%7BT%7D%20x%5E%7B(i)%7D%2Bb%5Cright)%20%5Cgeq%201-%5Cxi_%7Bi%7D%2C%20%5Cquad%20i%3D1%2C%20%5Cldots%2C%20m%20%5C%5C%0A%26%20%5Cxi_%7Bi%7D%20%5Cgeq%200%2C%20%5Cquad%20i%3D1%2C%20%5Cldots%2C%20m%0A%5Cend%7Baligned%7D%0A" /></p><p>就像之前一样，我们可以使用拉格朗日乘子法</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathcal%7BL%7D%28w%2C%20b%2C%20%5Cxi%2C%20%5Calpha%2C%20r%29%3D%5Cfrac%7B1%7D%7B2%7D%20w%5E%7BT%7D%20w%2BC%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Cxi_%7Bi%7D-%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7D%5Cleft%5By%5E%7B(i)%7D%5Cleft(x%5E%7BT%7D%20w%2Bb%5Cright)-1%2B%5Cxi_%7Bi%7D%5Cright%5D-%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20r_%7Bi%7D%20%5Cxi_%7Bi%7D%0A" /></p><p>这里的 <img src="https://math.now.sh?inline=%5Calpha_%7Bi%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=r_%7Bi%7D" style="display:inline-block;margin: 0;"/> 是拉格朗日乘子。通过设定 <img src="https://math.now.sh?inline=w" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=b" style="display:inline-block;margin: 0;"/> 的导数为 0 ，替换，简化，我们最终得到对偶形式如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmax%20_%7B%5Calpha%7D%20%26%20W%28%5Calpha%29%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7D-%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bi%2C%20j%3D1%7D%5E%7Bm%7D%20y%5E%7B(i)%7D%20y%5E%7B(j)%7D%20%5Calpha_%7Bi%7D%20%5Calpha_%7Bj%7D%5Cleft%5Clangle%20x%5E%7B(i)%7D%2C%20x%5E%7B(j)%7D%5Cright%5Crangle%20%5C%5C%0A%5Ctext%20%7B%20s.t.%20%7D%20%26%200%20%5Cleq%20%5Calpha_%7Bi%7D%20%5Cleq%20C%2C%20%5Cquad%20i%3D1%2C%20%5Cldots%2C%20m%20%5C%5C%0A%26%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7D%20y%5E%7B(i)%7D%3D0%0A%5Cend%7Baligned%7D%0A" /></p><p>和上面一样 ，<img src="https://math.now.sh?inline=w" style="display:inline-block;margin: 0;"/> 可以表示为相同的 <img src="https://math.now.sh?inline=%5Calpha_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的表达式。我们发现通过增加 L1 正则项，唯一的改变仅仅是对偶问题的约束条件从 $ 0 \leq \alpha_{i}$ 改为  $ 0 \leq \alpha_{i} \leq C$ 。这里 <img src="https://math.now.sh?inline=b%5E*" style="display:inline-block;margin: 0;"/> 的计算表达式发生了改变。</p>
<p>KKT 对偶互补条件为（缺证明，不理解）（我看 John Platt 的论文，这三个条件都是双向箭头）</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Calpha_%7Bi%7D%3D0%20%26%20%5CRightarrow%20y%5E%7B%28i%29%7D%5Cleft(w%5E%7BT%7D%20x%5E%7B(i)%7D%2Bb%5Cright)%20%5Cgeq%201%20%5C%5C%0A%5Calpha_%7Bi%7D%3DC%20%26%20%5CRightarrow%20y%5E%7B(i)%7D%5Cleft(w%5E%7BT%7D%20x%5E%7B(i)%7D%2Bb%5Cright)%20%5Cleq%201%20%5C%5C%0A0%3C%5Calpha_%7Bi%7D%3CC%20%26%20%5CRightarrow%20y%5E%7B(i)%7D%5Cleft(w%5E%7BT%7D%20x%5E%7B(i)%7D%2Bb%5Cright)%3D1%0A%5Cend%7Baligned%7D%0A" /></p><h2 id="The-SMO-algorithm">The SMO algorithm</h2>
<p><strong>The SMO (sequential minimal optimization)</strong> 算法是用来解决 SVM 的对偶问题的。让我们先中断一下，讨论一下 the coordinate ascent algorithm 。</p>
<h3 id="Coordinate-ascent">Coordinate ascent</h3>
<p>假设我们需要解决一个无约束的优化问题</p>
<p style=""><img src="https://math.now.sh?from=%5Cmax%20_%7B%5Calpha%7D%20W%5Cleft%28%5Calpha_%7B1%7D%2C%20%5Calpha_%7B2%7D%2C%20%5Cldots%2C%20%5Calpha_%7Bm%7D%5Cright%29%0A" /></p><p>这里，我们认为 <img src="https://math.now.sh?inline=W" style="display:inline-block;margin: 0;"/> 仅仅是关于参数 <img src="https://math.now.sh?inline=%5Calpha_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的函数。我们现在已经看到了两个优化算法，梯度下降和牛顿法。我们这里考虑的新算法称为 <strong>coordinate ascent (坐标上升)</strong> :</p>
<p>Loop until convergence: {<br>
For <img src="https://math.now.sh?inline=i%3D1%2C%20%5Cldots%2C%20m%2C%5C%7B" style="display:inline-block;margin: 0;"/></p>
<p style=""><img src="https://math.now.sh?from=%5Calpha_%7Bi%7D%3A%3D%5Carg%20%5Cmax%20_%7B%5Chat%7B%5Calpha%7D_%7Bi%7D%7D%20W%5Cleft%28%5Calpha_%7B1%7D%2C%20%5Cldots%2C%20%5Calpha_%7Bi-1%7D%2C%20%5Chat%7B%5Calpha%7D_%7Bi%7D%2C%20%5Calpha_%7Bi%2B1%7D%2C%20%5Cldots%2C%20%5Calpha_%7Bm%7D%5Cright%29%0A" /></p><p>​	}</p>
<p>}</p>
<p>因此，在每一次内部循环中，我们固定其他参数，只改变某个 <img src="https://math.now.sh?inline=%5Calpha_i" style="display:inline-block;margin: 0;"/> ，使得 <img src="https://math.now.sh?inline=W" style="display:inline-block;margin: 0;"/> 相对于  <img src="https://math.now.sh?inline=%5Calpha_i" style="display:inline-block;margin: 0;"/> 取得最大值。</p>
<p>举个例子如下图所示（这里是找最小值，也是一样的）</p>
<p><img src="23.png" alt="22"></p>
<p>当固定其他参数，只对一个参数进行优化很容易时，<strong>坐标上升法</strong>就有优势。</p>
<h3 id="SMO">SMO</h3>
<p>首先，我们需要解决的对偶优化如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmax%20_%7B%5Calpha%7D%20%26%20W%28%5Calpha%29%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7D-%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bi%2C%20j%3D1%7D%5E%7Bm%7D%20y%5E%7B(i)%7D%20y%5E%7B(j)%7D%20%5Calpha_%7Bi%7D%20%5Calpha_%7Bj%7D%5Cleft%5Clangle%20x%5E%7B(i)%7D%2C%20x%5E%7B(j)%7D%5Cright%5Crangle%20.%20%5C%5C%0A%5Ctext%20%7B%20s.t.%20%7D%20%26%200%20%5Cleq%20%5Calpha_%7Bi%7D%20%5Cleq%20C%2C%20%5Cquad%20i%3D1%2C%20%5Cldots%2C%20m%20%5C%5C%0A%26%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7D%20y%5E%7B(i)%7D%3D0%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>如果我们有一组 <img src="https://math.now.sh?inline=%5Calpha_i" style="display:inline-block;margin: 0;"/> 满足上面的两个限制条件，那么我们能不能用 Coordinate ascent 方法每次优化其中一个参数（例如 <img src="https://math.now.sh?inline=%5Calpha_1" style="display:inline-block;margin: 0;"/>）呢？答案是否定的，因为限制条件使得</p>
<p style=""><img src="https://math.now.sh?from=%5Calpha_%7B1%7D%20y%5E%7B%281%29%7D%3D-%5Csum_%7Bi%3D2%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7D%20y%5E%7B(i)%7D%0A" /></p><p>因此，如果你固定了其他参数，那么  <img src="https://math.now.sh?inline=%5Calpha_1" style="display:inline-block;margin: 0;"/> 的值也就固定了，所以你每次至少要同时修改两个参数的值。这就产生了 SMO 算法，其简要概述如下：</p>
<blockquote>
<p>Repeat till convergence {</p>
<ol>
<li>Select some pair <img src="https://math.now.sh?inline=%5Calpha_%7Bi%7D" style="display:inline-block;margin: 0;"/> and <img src="https://math.now.sh?inline=%5Calpha_%7Bj%7D" style="display:inline-block;margin: 0;"/> to update next (using a heuristic that tries to pick the two that will allow us to make the biggest progress towards the global maximum)（括号里是啥？吴老师说启发式法则就是经验法则）.</li>
<li>Reoptimize <img src="https://math.now.sh?inline=W%28%5Calpha%29" style="display:inline-block;margin: 0;"/> with respect to <img src="https://math.now.sh?inline=%5Calpha_%7Bi%7D" style="display:inline-block;margin: 0;"/> and <img src="https://math.now.sh?inline=%5Calpha_%7Bj%7D" style="display:inline-block;margin: 0;"/>, while holding all the other <img src="https://math.now.sh?inline=%5Calpha_%7Bk%7D" style="display:inline-block;margin: 0;"/> 's <img src="https://math.now.sh?inline=%28k%20%5Cneq%20i%2C%20j%29" style="display:inline-block;margin: 0;"/> fixed.</li>
</ol>
<p>}</p>
</blockquote>
<p>为了检验这个算法是否收敛，我们可以查看上面的三个 KKT 互补条件是否在某个范围内满足 (the convergence tolerance parameter, 通常为 0.01 到 0.001 ) 。</p>
<p>SMO 是一个高效算法的主要理由是，它每一次更新  <img src="https://math.now.sh?inline=%5Calpha_%7Bi%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Calpha_%7Bj%7D" style="display:inline-block;margin: 0;"/> 都非常迅速。让我们来看一下这个算法如何更新参数。假设我们将 <img src="https://math.now.sh?inline=%5Calpha_%7B3%7D%2C%20%5Cldots%2C%20%5Calpha_%7Bm%7D" style="display:inline-block;margin: 0;"/> 固定，只针对  <img src="https://math.now.sh?inline=%5Calpha_%7B1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Calpha_%7B2%7D" style="display:inline-block;margin: 0;"/> 进行更新 <img src="https://math.now.sh?inline=W" style="display:inline-block;margin: 0;"/>。 首先，存在限制条件：</p>
<p style=""><img src="https://math.now.sh?from=%5Calpha_%7B1%7D%20y%5E%7B%281%29%7D%2B%5Calpha_%7B2%7D%20y%5E%7B(2)%7D%3D-%5Csum_%7Bi%3D3%7D%5E%7Bm%7D%20%5Calpha_%7Bi%7D%20y%5E%7B(i)%7D%0A" /></p><p>右手项是一个固定的常数，我们将其表示为 <img src="https://math.now.sh?inline=%5Czeta" style="display:inline-block;margin: 0;"/></p>
<p style=""><img src="https://math.now.sh?from=%5Calpha_%7B1%7D%20y%5E%7B%281%29%7D%2B%5Calpha_%7B2%7D%20y%5E%7B(2)%7D%3D%20%5Czeta%0A" /></p><p>我们可以画出   <img src="https://math.now.sh?inline=%5Calpha_%7B1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Calpha_%7B2%7D" style="display:inline-block;margin: 0;"/>  的限制条件，首先我们已知   <img src="https://math.now.sh?inline=%5Calpha_%7B1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Calpha_%7B2%7D" style="display:inline-block;margin: 0;"/> 必须在 <img src="https://math.now.sh?inline=%5B0%2C%20C%5D%20%5Ctimes%5B0%2C%20C%5D" style="display:inline-block;margin: 0;"/> 正方形中，其次它们必须在 <img src="https://math.now.sh?inline=%5Calpha_%7B1%7D%20y%5E%7B%281%29%7D%2B%5Calpha_%7B2%7D%20y%5E%7B(2)%7D%3D%20%5Czeta" style="display:inline-block;margin: 0;"/>  这条线上，也就是说   <img src="https://math.now.sh?inline=%5Calpha_%7B1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Calpha_%7B2%7D" style="display:inline-block;margin: 0;"/>  必须在正方形中的某个线段上。</p>
<p><img src="24.png" alt="22"></p>
<p>我们可以将 <img src="https://math.now.sh?inline=%5Calpha_1" style="display:inline-block;margin: 0;"/> 写成  <img src="https://math.now.sh?inline=%5Calpha_2" style="display:inline-block;margin: 0;"/> 的式子 (由于 <img src="https://math.now.sh?inline=y%5E%7B%281%29%7D" style="display:inline-block;margin: 0;"/> 只能是 -1 和 1，因此其倒数等于本身，利用这个性质化简得到下式)</p>
<p style=""><img src="https://math.now.sh?from=%5Calpha_%7B1%7D%3D%5Cleft%28%5Czeta-%5Calpha_%7B2%7D%20y%5E%7B(2%29%7D%5Cright)%20y%5E%7B(1)%7D%0A" /></p><p>而   <img src="https://math.now.sh?inline=%5Calpha_2" style="display:inline-block;margin: 0;"/>  我们可以找到其相应的定义域 （<img src="https://math.now.sh?inline=L%20%5Cleq%20%5Calpha_2%20%5Cleq%20H" style="display:inline-block;margin: 0;"/>）。因此，我们可以将 <img src="https://math.now.sh?inline=W%28%5Calpha%29" style="display:inline-block;margin: 0;"/> 写成下式：</p>
<p style=""><img src="https://math.now.sh?from=W%5Cleft%28%5Calpha_%7B1%7D%2C%20%5Calpha_%7B2%7D%2C%20%5Cldots%2C%20%5Calpha_%7Bm%7D%5Cright%29%3DW%5Cleft(%5Cleft(%5Czeta-%5Calpha_%7B2%7D%20y%5E%7B(2)%7D%5Cright)%20y%5E%7B(1)%7D%2C%20%5Calpha_%7B2%7D%2C%20%5Cldots%2C%20%5Calpha_%7Bm%7D%5Cright)%0A" /></p><p>将 <img src="https://math.now.sh?inline=%5Calpha_%7B3%7D%2C%20%5Cldots%2C%20%5Calpha_%7Bm%7D" style="display:inline-block;margin: 0;"/> 视为常数，因此这是一个关于 <img src="https://math.now.sh?inline=%5Calpha_2" style="display:inline-block;margin: 0;"/> 的一元二次函数，可以表示为 <img src="https://math.now.sh?inline=a%20%5Calpha_%7B2%7D%5E%7B2%7D%2Bb%20%5Calpha_%7B2%7D%2Bc" style="display:inline-block;margin: 0;"/> ，也就是转化为求这个二次函数在定义域 <img src="https://math.now.sh?inline=%5BL%2C%20H%5D" style="display:inline-block;margin: 0;"/> 的最大值，这就很简单了。</p>
<h1>经验风险最小化</h1>
<h2 id="The-Bias-Variance-Tradeoff">The Bias-Variance Tradeoff</h2>
<p>假设你用训练集拟合线性回归的参数，你想用<strong>测试集</strong>来验证效果，得到 MSE</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbb%7BE%7D_%7B%28x%2C%20y%29%20%5Csim%20%5Ctext%20%7B%20test%20set%20%7D%7D%7C%5Chat%7Bf%7D(x)-y%7C%5E%7B2%7D%0A" /></p><p>如果测试集的 MSE 特别高，可能的解释如下</p>
<blockquote>
<ul>
<li>Overfitting: the model is too closely related to the examples in the training set and doesn’t generalize well to other examples.</li>
<li>Underfitting: the model didn’t gather enough information from the training set, and doesn’t capture the link between the features <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> and the target <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/>.</li>
<li>The data is simply noisy, that is the model is neither overfitting or underfitting, and the high MSE is simply due to the amount of noise in the dataset.</li>
</ul>
</blockquote>
<p>假设<strong>训练集和测试集的所有样本点均来自于一个相似的分布</strong>，即存在：</p>
<p style=""><img src="https://math.now.sh?from=y_%7Bi%7D%3Df%5Cleft%28x_%7Bi%7D%5Cright%29%2B%5Cepsilon_%7Bi%7D%2C%20%5Cquad%20%5Ctext%20%7B%20where%20the%20noise%20%7D%20%5Cepsilon_%7Bi%7D%20%5Ctext%20%7B%20satisfies%20%7D%20%5Cmathbb%7BE%7D%5Cleft(%5Cepsilon_%7Bi%7D%5Cright)%3D0%2C%20%5Coperatorname%7BVar%7D%5Cleft(%5Cepsilon_%7Bi%7D%5Cright)%3D%5Csigma%5E%7B2%7D%0A" /></p><p>然后你的目的是计算 <img src="https://math.now.sh?inline=f" style="display:inline-block;margin: 0;"/> 。通过使用你的训练集数据，你得到了一个估计函数 <img src="https://math.now.sh?inline=%5Chat%7Bf%7D" style="display:inline-block;margin: 0;"/> ，这个估计函数 <img src="https://math.now.sh?inline=%5Chat%7Bf%7D%28x%29" style="display:inline-block;margin: 0;"/> 是随机的，因为它取决于训练集的残差，因此这就是为什么我们说存在偏差  <img src="https://math.now.sh?inline=%5Cmathbb%7BE%7D%28%5Chat%7Bf%7D(x%29-f(x))" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Chat%7Bf%7D" style="display:inline-block;margin: 0;"/> 的方差。</p>
<p>我们现在可以计算测试集的 MSE 如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Ctext%20%7B%20Test%20%7D%20%5Coperatorname%7BMSE%7D%20%26%3D%5Cmathbb%7BE%7D%5Cleft%28(y-%5Chat%7Bf%7D(x%29)%5E%7B2%7D%5Cright)%20%5C%5C%0A%26%3D%5Cmathbb%7BE%7D%5Cleft((%5Cepsilon%2Bf(x)-%5Chat%7Bf%7D(x))%5E%7B2%7D%5Cright)%20%5C%5C%0A%26%3D%5Cmathbb%7BE%7D%5Cleft(%5Cepsilon%5E%7B2%7D%5Cright)%2B%5Cmathbb%7BE%7D%5Cleft((f(x)-%5Chat%7Bf%7D(x))%5E%7B2%7D%5Cright)%20%2B%20%20%5Cmathbb%7BE%7D%5Cleft(%5Cepsilon%20(f(x)-%5Chat%7Bf%7D(x))%5Cright)%5C%5C%0A%26%3D%5Cmathbb%7BE%7D%5Cleft(%5Cepsilon%5E%7B2%7D%5Cright)%2B%5Cmathbb%7BE%7D%5Cleft((f(x)-%5Chat%7Bf%7D(x))%5E%7B2%7D%5Cright)%20%5Cquad%20(%5Cbecause%20E(%5Cepsilon)%20%3D%200%20)%5C%5C%20%0A%26%3D%5Csigma%5E%7B2%7D%2B(%5Cmathbb%7BE%7D(f(x)-%5Chat%7Bf%7D(x)))%5E%7B2%7D%2B%5Coperatorname%7BVar%7D(f(x)-%5Chat%7Bf%7D(x))%20%5Cquad%20(%5Cbecause%20E(X%5E2)%20%3D%20%5Cmu%5E%7B2%7D%20%2B%20V(X))%5C%5C%20%0A%26%3D%5Csigma%5E%7B2%7D%2B(%5Coperatorname%7BBias%7D%20%5Chat%7Bf%7D(x))%5E%7B2%7D%2B%5Coperatorname%7BVar%7D(%5Chat%7Bf%7D(x))%20%5Cquad%20(%5Cbecause%20f(x)%20%E8%A7%86%E4%B8%BA%E5%B8%B8%E9%87%8F%EF%BC%8Cvar(X%2Bb)%20%3D%20var(X))%0A%5Cend%7Baligned%7D%0A" /></p><p>我们对这里的第一项噪音方差无法改善，因为根据定义，我们无法预测噪音 <img src="https://math.now.sh?inline=%5Cepsilon_i" style="display:inline-block;margin: 0;"/> 。bias 项来自于欠拟合，表示平均而言，<img src="https://math.now.sh?inline=%5Chat%7Bf%7D" style="display:inline-block;margin: 0;"/> 与 <img src="https://math.now.sh?inline=f" style="display:inline-block;margin: 0;"/> 的偏差。最后一项与过拟合紧密相关，<img src="https://math.now.sh?inline=%5Chat%7Bf%7D" style="display:inline-block;margin: 0;"/> 随着训练集数据的改变而有较大变动。</p>
<p>总结一下，我们可以将测试集 MSE 拆分为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Ctext%20%7B%20High%20Bias%20%7D%20%26%20%5Clongleftrightarrow%20%5Ctext%20%7B%20Underfitting%20%7D%20%5C%5C%0A%5Ctext%20%7B%20High%20Variance%20%7D%20%26%20%5Clongleftrightarrow%20%5Ctext%20%7B%20Overfitting%20%7D%20%5C%5C%0A%5Ctext%20%7B%20Large%20%7D%20%5Csigma%5E%7B2%7D%20%26%20%5Clongleftrightarrow%20%5Ctext%20%7B%20Noisy%20data%20%7D%0A%5Cend%7Baligned%7D%0A" /></p><h2 id="Error-Analysis">Error Analysis</h2>
<p>虽然知道我们的算法是高偏差还是高方差很重要，但是更重要的是到底是算法的那一部分导致了这个问题。</p>
<p>假设你创建一个复杂的 AI pipeline , 你想知道到底那一部分影响最大。我们可以对每一部分组件输入<strong>真值</strong>，查看准确性变化程度。比如在人脸识别的项目中，你通过跳过背景移除的步骤，直接输入手动剔除背景的真值，发现整体准确率提高了 0.1% ，这就是背景移除这一步优化的<strong>上限</strong>，也是就是说无论你的算法在这一步做的多好，整体准确率最多也就提高 0.1% 。</p>
<p>然后我们接着跳过第二步，一直到最后一步，使得整体准确性为 100% ，如下表所示：</p>
<p><img src="25.png" alt="25"></p>
<h2 id="Ablative-analysis">Ablative analysis</h2>
<p>Ablative analysis 用于解释目前模型表型和要求的基准线之间差距的原因。假设你设计了一个反垃圾邮件的系统，你往逻辑回归中增加了很多巧妙地特征如下：</p>
<blockquote>
<ul>
<li>Spelling correction</li>
<li>Sender host features</li>
<li>Email header features</li>
<li>Email text parser features</li>
<li>Javascript parser</li>
<li>Features from embedded images</li>
</ul>
</blockquote>
<p>那么我们的问题是：每一个组分到底帮助有多大呢？</p>
<p>假设我们不加上面这些特征的总体准确性是 94% ，加了这些特征之后是 99.9% 。在 ablative analysis 中，我们反过来做，我们从添加了所有特征的模型中逐个逐个将这些特征移除，参看准确性如何变化，见下表。</p>
<p><img src="26.png" alt="25"></p>
<p>从这里你可以看出来，哪些特征更加重要。（问题来了，那我们逐个逐个添加特征应该效果是一样的吧）</p>
<h2 id="Analyze-your-mistakes">Analyze your mistakes</h2>
<p>查看哪些分错的样本，你可以知道你是不是遗漏了什么东西。</p>
<p>总结一下，不要浪费时间在哪些几乎不会降低错误率的组分，把时间花在刀刃上，也就是可以大幅降低错误率的组分。</p>
<h2 id="Preliminaries">Preliminaries</h2>
<p>我们先看两个引理：</p>
<blockquote>
<p><strong>Lemma</strong>. (The union bound). Let <img src="https://math.now.sh?inline=A_%7B1%7D%2C%20A_%7B2%7D%2C%20%5Cldots%2C%20A_%7Bk%7D" style="display:inline-block;margin: 0;"/> be <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> different events (that may not be independent). Then</p>
<p style=""><img src="https://math.now.sh?from=P%5Cleft%28A_%7B1%7D%20%5Ccup%20%5Ccdots%20%5Ccup%20A_%7Bk%7D%5Cright%29%20%5Cleq%20P%5Cleft(A_%7B1%7D%5Cright)%2B%5Cldots%2BP%5Cleft(A_%7Bk%7D%5Cright)%0A" /></p><p>In probability theory, the union bound is usually stated as an axiom (and thus we won’t try to prove it), but it also makes intuitive sense: The probability of any one of <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> events happening is at most the sums of the probabilities of the <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> different events.</p>
<p><strong>Lemma. (Hoeffding inequality)</strong> Let <img src="https://math.now.sh?inline=Z_%7B1%7D%2C%20%5Cldots%2C%20Z_%7Bm%7D" style="display:inline-block;margin: 0;"/> be <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> independent and identically distributed (iid) random variables drawn from a <img src="https://math.now.sh?inline=%5Coperatorname%7BBernoulli%7D%28%5Cphi%29" style="display:inline-block;margin: 0;"/> distribution. I.e., <img src="https://math.now.sh?inline=P%5Cleft%28Z_%7Bi%7D%3D1%5Cright%29%3D%5Cphi" style="display:inline-block;margin: 0;"/>, and <img src="https://math.now.sh?inline=P%5Cleft%28Z_%7Bi%7D%3D0%5Cright%29%3D1-%5Cphi" style="display:inline-block;margin: 0;"/>. Let <img src="https://math.now.sh?inline=%5Chat%7B%5Cphi%7D%3D%281%20%2F%20m%29%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20Z_%7Bi%7D" style="display:inline-block;margin: 0;"/> be the mean of these random variables, and let any <img src="https://math.now.sh?inline=%5Cgamma%3E0" style="display:inline-block;margin: 0;"/> be fixed. Then</p>
<p style=""><img src="https://math.now.sh?from=P%28%7C%5Cphi-%5Chat%7B%5Cphi%7D%7C%3E%5Cgamma%29%20%5Cleq%202%20%5Cexp%20%5Cleft(-2%20%5Cgamma%5E%7B2%7D%20m%5Cright)%0A" /></p></blockquote>
<p>第二个引理说明，只要 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> 足够大，那么 <img src="https://math.now.sh?inline=%5Chat%7B%5Cphi%7D" style="display:inline-block;margin: 0;"/> 与 真实值 <img src="https://math.now.sh?inline=%5Cphi" style="display:inline-block;margin: 0;"/> 差距很大的概率非常小。</p>
<p>通过这两个引理，我们可以证明学习理论中一些最重要的结论。为了简化问题，我们现在只考虑二分类问题，其中 <img src="https://math.now.sh?inline=y%20%5Cin%20%5C%7B0%2C1%5C%7D" style="display:inline-block;margin: 0;"/> ，但是我们这里所说的东西都可以适用于其他学习方法。</p>
<p>我们假设我们有一个大小为 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> 的训练集  <img src="https://math.now.sh?inline=S%3D%5Cleft%5C%7B%5Cleft%28x%5E%7B(i%29%7D%2C%20y%5E%7B(i)%7D%5Cright)%20%3B%20i%3D1%2C%20%5Cldots%2C%20m%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> ，其中的样本 <img src="https://math.now.sh?inline=%5Cleft%28x%5E%7B(i%29%7D%2C%20y%5E%7B(i)%7D%5Cright)" style="display:inline-block;margin: 0;"/> <strong>独立同分布</strong>于某个分布 <img src="https://math.now.sh?inline=%5Cmathcal%7BD%7D" style="display:inline-block;margin: 0;"/> 。针对某个假设 <img src="https://math.now.sh?inline=h" style="display:inline-block;margin: 0;"/> ，我们定义训练集的误差为 （<strong>training error</strong>，或称为， <strong>empirical risk</strong>, <strong>empirical error</strong> ）</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cvarepsilon%7D%28h%29%3D%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%201%5Cleft%5C%7Bh%5Cleft(x%5E%7B(i)%7D%5Cright)%20%5Cneq%20y%5E%7B(i)%7D%5Cright%5C%7D%0A" /></p><p>这就是训练集中有多少比例的样本被错误分类了（<img src="https://math.now.sh?inline=%5Chat%7B%5Cepsilon%7D%28h%29" style="display:inline-block;margin: 0;"/> 的帽子一般表示估计值，这里表示对泛化误差的估计）。我们定义泛化误差（实际计算为验证群的误差）为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cvarepsilon%28h%29%3DP_%7B(x%2C%20y)%20%5Csim%20%5Cmathcal%7BD%7D%7D(h(x)%20%5Cneq%20y)%0A" /></p><p>这个概率指，如果我们从这个分布  <img src="https://math.now.sh?inline=%5Cmathcal%7BD%7D" style="display:inline-block;margin: 0;"/>  随机抽取一个新样本 <img src="https://math.now.sh?inline=%28x%2Cy%29" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=h" style="display:inline-block;margin: 0;"/> 会将其错误分类的概率。</p>
<p>这里假设我们使用线性分类器，设定 <img src="https://math.now.sh?inline=h_%7B%5Ctheta%7D%28x%29%3D1%5Cleft%5C%7B%5Ctheta%5E%7BT%7D%20x%20%5Cgeq%200%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> 。那么我们拟合参数 <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/> 的一个合理的方法是什么呢？一种方式就是使得训练集误差最小，即</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Ctheta%7D%3D%5Carg%20%5Cmin%20_%7B%5Ctheta%7D%20%5Chat%7B%5Cvarepsilon%7D%5Cleft%28h_%7B%5Ctheta%7D%5Cright%29%0A" /></p><p>我们称这个过程为 <strong>经验风险最小化 (empirical risk minimization, ERM)</strong> ，我们称 ERM 为最基础的学习算法（类似于逻辑回归这些算法可以视为 ERM 算法的近似算法）。</p>
<p>我们定义一个学习算法的 <strong>hypothesis class <img src="https://math.now.sh?inline=%5Cmathcal%7BH%7D" style="display:inline-block;margin: 0;"/></strong> 为该算法所有可用的假设/函数。对于线性分类器，存在   <img src="https://math.now.sh?inline=%5Cmathcal%7BH%7D%3D%5Cleft%5C%7Bh_%7B%5Ctheta%7D%3A%20h_%7B%5Ctheta%7D%28x%29%3D1%5Cleft%5C%7B%5Ctheta%5E%7BT%7D%20x%20%5Cgeq%200%5Cright%5C%7D%2C%20%5Ctheta%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bn%2B1%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>ERM 算法就是从所有可用的假设中挑选训练集误差最小的假设，即：</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7Bh%7D%3D%5Carg%20%5Cmin%20_%7Bh%20%5Cin%20%5Cmathcal%7BH%7D%7D%20%5Chat%7B%5Cvarepsilon%7D%28h%29%0A" /></p><h2 id="The-case-of-finite-mathcal-H">The case of finite <img src="https://math.now.sh?inline=%5Cmathcal%7BH%7D" style="display:inline-block;margin: 0;"/></h2>
<p>假设  <strong>hypothesis class <img src="https://math.now.sh?inline=%5Cmathcal%7BH%7D" style="display:inline-block;margin: 0;"/></strong> 由有限的 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 个假设组成，即 <img src="https://math.now.sh?inline=%5Cmathcal%7BH%7D%3D%5Cleft%5C%7Bh_%7B1%7D%2C%20%5Cldots%2C%20h_%7Bk%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> 。因此，ERM 算法就是从这  <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 个假设中挑出训练集误差最小的一个。</p>
<p>我们希望对 <img src="https://math.now.sh?inline=%5Chat%7Bh%7D" style="display:inline-block;margin: 0;"/> 的泛化误差有一定保证。因此我们需要证明两步，第一证明对于所有的 <img src="https://math.now.sh?inline=h" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Chat%7B%5Cepsilon%7D%28h%29" style="display:inline-block;margin: 0;"/>  都是 <img src="https://math.now.sh?inline=%5Cepsilon%28h%29" style="display:inline-block;margin: 0;"/>  的可靠的估计值；第二，我们希望能得到泛化误差 <img src="https://math.now.sh?inline=%5Cepsilon%28h%29" style="display:inline-block;margin: 0;"/> 的<strong>上限</strong>。</p>
<p>我们随便取一个假设，<img src="https://math.now.sh?inline=h_%7Bi%7D%20%5Cin%20%5Cmathcal%7BH%7D" style="display:inline-block;margin: 0;"/> 。假设一个服从伯努利分布的随机向量 <img src="https://math.now.sh?inline=Z" style="display:inline-block;margin: 0;"/> ，从 <img src="https://math.now.sh?inline=%5Cmathcal%7BD%7D" style="display:inline-block;margin: 0;"/> 中随机抽取一个样本 <img src="https://math.now.sh?inline=%28x%2Cy%29" style="display:inline-block;margin: 0;"/> ，我们设定 <img src="https://math.now.sh?inline=Z%3D1%5Cleft%5C%7Bh_%7Bi%7D%28x%29%20%5Cneq%20y%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> ，也就是说  <img src="https://math.now.sh?inline=Z" style="display:inline-block;margin: 0;"/> 表示是否会对样本进行错误分类。相似地，我们定义 <img src="https://math.now.sh?inline=Z_%7Bj%7D%20%3D%201%5Cleft%5C%7Bh_%7Bi%7D%28x%29%5E%7B(j)%7D%20%5Cneq%20y%5E%7B(j)%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> 。因为训练集样本服从独立同分布，因此 <img src="https://math.now.sh?inline=Z" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=Z_%7Bj%7D" style="display:inline-block;margin: 0;"/> 服从相同的分布。</p>
<p>因此， <img src="https://math.now.sh?inline=%5Cepsilon%28h%29" style="display:inline-block;margin: 0;"/> 就是 <img src="https://math.now.sh?inline=Z" style="display:inline-block;margin: 0;"/> (<img src="https://math.now.sh?inline=Z_j" style="display:inline-block;margin: 0;"/>) 的期望值（<img src="https://math.now.sh?inline=P%28Z%3D1%29%3D%5Cepsilon(h)" style="display:inline-block;margin: 0;"/>）。进一步的说，训练集误差可以写为</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cvarepsilon%7D%5Cleft%28h_%7Bi%7D%5Cright%29%3D%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bm%7D%20Z_%7Bj%7D%0A" /></p><p>因此，训练集误差的期望就是泛化误差。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%20E%5Cleft%28%5Chat%7B%5Cvarepsilon%7D%5Cleft(h_%7Bi%7D%5Cright%29%5Cright)%20%5C%5C%0A%3D%26%20%5Cfrac%7B1%7D%7Bm%7D%20E%5Cleft(%5Csum_%7Bj%3D1%7D%5E%7Bm%7D%20Z_%7Bj%7D%5Cright)%20%5C%5C%0A%3D%26%20%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bm%7D%20E(Z_j)%20%5C%5C%0A%3D%26%20%5Cfrac%7B1%7D%7Bm%7D%20m%20%5Cvarepsilon%20%5Cleft(h_%7Bi%7D%5Cright)%20%5C%5C%0A%3D%26%20%5Cvarepsilon%20%5Cleft(h_%7Bi%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>采用霍夫丁不等式，存在</p>
<p style=""><img src="https://math.now.sh?from=P%5Cleft%28%5Cleft%7C%5Cvarepsilon%5Cleft(h_%7Bi%7D%5Cright%29-%5Chat%7B%5Cvarepsilon%7D%5Cleft(h_%7Bi%7D%5Cright)%5Cright%7C%3E%5Cgamma%5Cright)%20%5Cleq%202%20%5Cexp%20%5Cleft(-2%20%5Cgamma%5E%7B2%7D%20m%5Cright)%0A" /></p><p>这说明，对于某个假设 <img src="https://math.now.sh?inline=h_i" style="display:inline-block;margin: 0;"/> ，<strong>如果 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> 很大</strong>，那么训练集误差和泛化误差大概率很接近。但是我们不仅是想看某一个 <img src="https://math.now.sh?inline=h_i" style="display:inline-block;margin: 0;"/> 存在训练集误差和泛化误差大概率很接近  ，我们想证明这同时对于所有的 <img src="https://math.now.sh?inline=h%20%5Cin%20%5Cmathcal%7BH%7D" style="display:inline-block;margin: 0;"/> 均成立。为了简化写法，我们设 <img src="https://math.now.sh?inline=A_i" style="display:inline-block;margin: 0;"/> 表示 <img src="https://math.now.sh?inline=%5Cleft%7C%5Cvarepsilon%5Cleft%28h_%7Bi%7D%5Cright%29-%5Chat%7B%5Cvarepsilon%7D%5Cleft(h_%7Bi%7D%5Cright)%5Cright%7C%3E%5Cgamma" style="display:inline-block;margin: 0;"/> 这个<strong>事件</strong>。我们已经知道，对于任何一个  <img src="https://math.now.sh?inline=A_i" style="display:inline-block;margin: 0;"/> ，均存在 <img src="https://math.now.sh?inline=P%28A_%7Bi%7D%29%20%5Cleq%202%20%5Cexp%20%5Cleft(-2%20%5Cgamma%5E%7B2%7D%20m%5Cright)" style="display:inline-block;margin: 0;"/> 。因此，使用 union bound 定理，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AP%5Cleft%28%5Cexists%20h%20%5Cin%20%5Cmathcal%7BH%7D%20.%5Cleft%7C%5Cvarepsilon%5Cleft(h_%7Bi%7D%5Cright%29-%5Chat%7B%5Cvarepsilon%7D%5Cleft(h_%7Bi%7D%5Cright)%5Cright%7C%3E%5Cgamma%5Cright)%20%26%3DP%5Cleft(A_%7B1%7D%20%5Ccup%20%5Ccdots%20%5Ccup%20A_%7Bk%7D%5Cright)%20%5C%5C%0A%26%20%5Cleq%20%5Csum_%7Bi%3D1%7D%5E%7Bk%7D%20P%5Cleft(A_%7Bi%7D%5Cright)%20%5C%5C%0A%26%20%5Cleq%20%5Csum_%7Bi%3D1%7D%5E%7Bk%7D%202%20%5Cexp%20%5Cleft(-2%20%5Cgamma%5E%7B2%7D%20m%5Cright)%20%5C%5C%0A%26%3D2%20k%20%5Cexp%20%5Cleft(-2%20%5Cgamma%5E%7B2%7D%20m%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>如果两边都用 1减去原式，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AP%5Cleft%28%5Cneg%20%5Cexists%20h%20%5Cin%20%5Cmathcal%7BH%7D%20.%5Cleft%7C%5Cvarepsilon%5Cleft(h_%7Bi%7D%5Cright%29-%5Chat%7B%5Cvarepsilon%7D%5Cleft(h_%7Bi%7D%5Cright)%5Cright%7C%3E%5Cgamma%5Cright)%20%26%3DP%5Cleft(%5Cforall%20h%20%5Cin%20%5Cmathcal%7BH%7D%20.%5Cleft%7C%5Cvarepsilon%5Cleft(h_%7Bi%7D%5Cright)-%5Chat%7B%5Cvarepsilon%7D%5Cleft(h_%7Bi%7D%5Cright)%5Cright%7C%20%5Cleq%20%5Cgamma%5Cright)%20%5C%5C%0A%26%20%5Cgeq%201-2%20k%20%5Cexp%20%5Cleft(-2%20%5Cgamma%5E%7B2%7D%20m%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，至少有 <img src="https://math.now.sh?inline=1-2%20k%20%5Cexp%20%5Cleft%28-2%20%5Cgamma%5E%7B2%7D%20m%5Cright%29" style="display:inline-block;margin: 0;"/>  的概率，对于所有 <img src="https://math.now.sh?inline=h%20%5Cin%20%5Cmathcal%7BH%7D" style="display:inline-block;margin: 0;"/> ，均有 <img src="https://math.now.sh?inline=%5Chat%7B%5Cepsilon%7D%28h%29" style="display:inline-block;margin: 0;"/>  与 <img src="https://math.now.sh?inline=%5Cepsilon%28h%29" style="display:inline-block;margin: 0;"/>  的差距小于 <img src="https://math.now.sh?inline=%5Cgamma" style="display:inline-block;margin: 0;"/> 。这称为一个  <em>uniform convergence result</em> ，因为这是对于所有的  <img src="https://math.now.sh?inline=h%20%5Cin%20%5Cmathcal%7BH%7D" style="display:inline-block;margin: 0;"/> 均同时成立的一个边界。这里有三个我们感兴趣的参数： <img src="https://math.now.sh?inline=m%2C%20%5Cgamma" style="display:inline-block;margin: 0;"/>，错误概率 ( <img src="https://math.now.sh?inline=%5Cdelta%20%3D%202%20k%20%5Cexp%20%5Cleft%28-2%20%5Cgamma%5E%7B2%7D%20m%5Cright%29" style="display:inline-block;margin: 0;"/>) 。给定其中两个值，我们可以计算出另外一个。</p>
<p>举个例子，假设给定某个 <img src="https://math.now.sh?inline=%5Cgamma" style="display:inline-block;margin: 0;"/> 和某个 <img src="https://math.now.sh?inline=%5Cdelta%20%3E%200" style="display:inline-block;margin: 0;"/> ，那么我们需要多大的m呢？通过代入 <img src="https://math.now.sh?inline=%5Cdelta%20%3D%202%20k%20%5Cexp%20%5Cleft%28-2%20%5Cgamma%5E%7B2%7D%20m%5Cright%29" style="display:inline-block;margin: 0;"/>  ，你就得到下式，这个式子同样称为<strong>样本复杂度 (sample complexity)</strong>。我们注意到这个式子仅仅是关于假设数目 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 的函数，这一点后面会用到。</p>
<p style=""><img src="https://math.now.sh?from=m%20%5Cgeq%20%5Cfrac%7B1%7D%7B2%20%5Cgamma%5E%7B2%7D%7D%20%5Clog%20%5Cfrac%7B2%20k%7D%7B%5Cdelta%7D%0A" /></p><p>相似地，如果我们固定 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cdelta" style="display:inline-block;margin: 0;"/> ，然后求解 <img src="https://math.now.sh?inline=%5Cgamma" style="display:inline-block;margin: 0;"/> ，我们可以得到</p>
<p style=""><img src="https://math.now.sh?from=%20%5Cgamma%20%5Cgeq%20%5Csqrt%7B%5Cfrac%7B1%7D%7B2%20m%7D%20%5Clog%20%5Cfrac%7B2%20k%7D%7B%5Cdelta%7D%7D%0A" /></p><p>这里我们回顾一下，我们从训练集中选择训练集误差最低的假设 <img src="https://math.now.sh?inline=%5Chat%7Bh%7D" style="display:inline-block;margin: 0;"/> ，另外假设我们有无穷多的训练集数据，我们能找到真正的最好的假设 <img src="https://math.now.sh?inline=h%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7Bh%7D%3D%5Carg%20%5Cmin%20_%7Bh%20%5Cin%20%5Cmathcal%7BH%7D%7D%20%5Chat%7B%5Cvarepsilon%7D%28h%29%0A" /></p><p style=""><img src="https://math.now.sh?from=h%5E%7B*%7D%20%3D%5Carg%20%5Cmin%20_%7Bh%20%5Cin%20%5Cmathcal%7BH%7D%7D%20%5Cvarepsilon%28h%29%0A" /></p><p>我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cvarepsilon%28%5Chat%7Bh%7D%29%20%26%20%5Cleq%20%5Chat%7B%5Cvarepsilon%7D(%5Chat%7Bh%7D)%2B%5Cgamma%20%5Cquad%20%5Cbecause%20%5Ctext%7Buniform%20convergence%20assumption%7D%20%5C%5C%0A%26%20%5Cleq%20%5Chat%7B%5Cvarepsilon%7D%5Cleft(h%5E%7B*%7D%5Cright)%2B%5Cgamma%20%20%5Cquad%20%5Cbecause%20%5Chat%7Bh%7D%3D%5Carg%20%5Cmin%20_%7Bh%20%5Cin%20%5Cmathcal%7BH%7D%7D%20%5Chat%7B%5Cvarepsilon%7D(h)%20%5Ctherefore%20%5Chat%7B%5Cvarepsilon%7D(%5Chat%7Bh%7D)%20%5Cleq%20%5Chat%7B%5Cvarepsilon%7D(h%5E%7B*%7D)%20%20%5C%5C%20%0A%26%20%5Cleq%20%5Cvarepsilon%5Cleft(h%5E%7B*%7D%5Cright)%2B2%20%5Cgamma%20%20%5Cquad%20%5Cbecause%20%5Ctext%7Buniform%20convergence%20assumption%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们发现，在 <em>uniform convergence</em> 发生的前提下，<img src="https://math.now.sh?inline=%5Chat%7Bh%7D" style="display:inline-block;margin: 0;"/> 的泛化误差比 <img src="https://math.now.sh?inline=%5Cmathcal%7BH%7D" style="display:inline-block;margin: 0;"/> 中最好的模型的泛化误差最多差 <img src="https://math.now.sh?inline=2%20%5Cgamma" style="display:inline-block;margin: 0;"/> 。</p>
<p>让我们将这些整理成一个定理</p>
<blockquote>
<p><strong>Theorem</strong>. Let <img src="https://math.now.sh?inline=%7C%5Cmathcal%7BH%7D%7C%3Dk" style="display:inline-block;margin: 0;"/>, and let any <img src="https://math.now.sh?inline=m%2C%20%5Cdelta" style="display:inline-block;margin: 0;"/> be fixed. Then with probability at least <img src="https://math.now.sh?inline=1-%5Cdelta" style="display:inline-block;margin: 0;"/>, we have that</p>
</blockquote>
<p style=""><img src="https://math.now.sh?from=%5Cvarepsilon%28%5Chat%7Bh%7D%29%20%5Cleq%5Cleft(%5Cmin%20_%7Bh%20%5Cin%20%5Cmathcal%7BH%7D%7D%20%5Cvarepsilon(h)%5Cright)%2B2%20%5Csqrt%7B%5Cfrac%7B1%7D%7B2%20m%7D%20%5Clog%20%5Cfrac%7B2%20k%7D%7B%5Cdelta%7D%7D%0A" /></p><p>这里将 <img src="https://math.now.sh?inline=%5Cgamma" style="display:inline-block;margin: 0;"/> 改为了根号项。这个式子同时可以定量说明 bias-variance tradeoff ，假设我们从一个假设集合 <img src="https://math.now.sh?inline=%5Cmathcal%7BH%7D" style="display:inline-block;margin: 0;"/> 转向了一个更大的假设集合 <img src="https://math.now.sh?inline=%5Cmathcal%7BH%7D%5E%7B%5Cprime%7D%20%5Csupseteq%20%5Cmathcal%7BH%7D" style="display:inline-block;margin: 0;"/> ，我们可以想到上面式子的第一项只会下降（因为我们是从一个更大的函数集合取最小值），因此通过使用一个更大的假设集合我们的 “bias&quot; 会下降。但是此时 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 会增加，因此第二项会增加，对应于我们的 ”variance&quot; 会增加。</p>
<p>通过固定 <img src="https://math.now.sh?inline=%5Cgamma" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cdelta" style="display:inline-block;margin: 0;"/> ，然后像上面一样计算 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> ，我们可以得到下面的样本复杂度 (这不是和上面一样嘛)。</p>
<blockquote>
<p>Corollary. Let <img src="https://math.now.sh?inline=%7C%5Cmathcal%7BH%7D%7C%3Dk" style="display:inline-block;margin: 0;"/>, and let any <img src="https://math.now.sh?inline=%5Cdelta%2C%20%5Cgamma" style="display:inline-block;margin: 0;"/> be fixed. Then for <img src="https://math.now.sh?inline=%5Cvarepsilon%28%5Chat%7Bh%7D%29%20%5Cleq" style="display:inline-block;margin: 0;"/> <img src="https://math.now.sh?inline=%5Cmin%20_%7Bh%20%5Cin%20%5Cmathcal%7BH%7D%7D%20%5Cvarepsilon%28h%29%2B2%20%5Cgamma" style="display:inline-block;margin: 0;"/> to hold with probability at least <img src="https://math.now.sh?inline=1-%5Cdelta" style="display:inline-block;margin: 0;"/>, it suffices that</p>
</blockquote>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Am%20%26%20%5Cgeq%20%5Cfrac%7B1%7D%7B2%20%5Cgamma%5E%7B2%7D%7D%20%5Clog%20%5Cfrac%7B2%20k%7D%7B%5Cdelta%7D%20%5C%5C%0A%26%3DO%5Cleft%28%5Cfrac%7B1%7D%7B%5Cgamma%5E%7B2%7D%7D%20%5Clog%20%5Cfrac%7Bk%7D%7B%5Cdelta%7D%5Cright%29%0A%5Cend%7Baligned%7D%0A" /></p><h1>特征选择</h1>
<h2 id="The-case-of-infinite-mathcal-H">The case of infinite <img src="https://math.now.sh?inline=%5Cmathcal%7BH%7D" style="display:inline-block;margin: 0;"/></h2>
<p>我们上面证明了一些有限假设集合的性质，但是很多假设集合实际上包含了无限个函数，我们能得到相似的结果嘛？</p>
<p>让我们先看一些不是很对的论述，帮助我们直观理解。假设我们有一个通过 <img src="https://math.now.sh?inline=d" style="display:inline-block;margin: 0;"/> 个参数确定的假设集合 <img src="https://math.now.sh?inline=%5Cmathcal%7BH%7D" style="display:inline-block;margin: 0;"/> 。假设在电脑里我们用双精度保存浮点数，也就是 64 位。因此，我们的假设实际包含最多 <img src="https://math.now.sh?inline=k%3D2%5E%7B64%20d%7D" style="display:inline-block;margin: 0;"/> 个不同的假设。根据上面最后的推论，我们因此发行，为了确保 <img src="https://math.now.sh?inline=%5Cvarepsilon%28%5Chat%7Bh%7D%29%20%5Cleq%20%5Cvarepsilon%5Cleft(h%5E%7B*%7D%5Cright)%2B2%20%5Cgamma" style="display:inline-block;margin: 0;"/> 在至少 <img src="https://math.now.sh?inline=1-%5Cdelta" style="display:inline-block;margin: 0;"/> 的概率下成立，我们有 <img src="https://math.now.sh?inline=m%20%5Cgeq%20O%5Cleft%28%5Cfrac%7B1%7D%7B%5Cgamma%5E%7B2%7D%7D%20%5Clog%20%5Cfrac%7B2%5E%7B64%20d%7D%7D%7B%5Cdelta%7D%5Cright%29%3DO%5Cleft(%5Cfrac%7Bd%7D%7B%5Cgamma%5E%7B2%7D%7D%20%5Clog%20%5Cfrac%7B1%7D%7B%5Cdelta%7D%5Cright)%3DO_%7B%5Cgamma%2C%20%5Cdelta%7D(d)" style="display:inline-block;margin: 0;"/> （这里的 <img src="https://math.now.sh?inline=%5Cgamma%2C%5Cdelta" style="display:inline-block;margin: 0;"/> 下标表示这里的 <img src="https://math.now.sh?inline=O%28%29" style="display:inline-block;margin: 0;"/> 函隐藏了关于  <img src="https://math.now.sh?inline=%5Cgamma%2C%5Cdelta" style="display:inline-block;margin: 0;"/> 的常数 ）。因此，需要的训练集样本的数目和模型参数数目是线性关系。</p>
<p>为了推导一些更一般的结论，我们需要先定义一些东西。</p>
<p>假设有一个与训练集无关的集合 <img src="https://math.now.sh?inline=S%3D%5Cleft%5C%7Bx%5E%7B%28i%29%7D%2C%20%5Cldots%2C%20x%5E%7B(d)%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=x%5E%7B%28i%29%7D%20%5Cin%20%5Cmathcal%7BX%7D" style="display:inline-block;margin: 0;"/> （不知道 <img src="https://math.now.sh?inline=%5Cmathcal%7BX%7D" style="display:inline-block;margin: 0;"/> 是啥），我们称 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cmathcal%7BH%7D%20%5Ctext%7B%20shatters%20%7D%20S%7D" style="display:inline-block;margin: 0;"/> ，如果 <img src="https://math.now.sh?inline=%5Cmathcal%7BH%7D" style="display:inline-block;margin: 0;"/> 可以实现 <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> 上任何一种标签形式。也就是说，对于任何一个标签集合 <img src="https://math.now.sh?inline=%5Cleft%5C%7By%5E%7B%281%29%7D%2C%20%5Cldots%2C%20y%5E%7B(d)%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/>, 均存在某个 <img src="https://math.now.sh?inline=h%20%5Cin%20%5Cmathcal%7BH%7D" style="display:inline-block;margin: 0;"/> 使得 <img src="https://math.now.sh?inline=h%5Cleft%28x%5E%7B(i%29%7D%5Cright)%3Dy%5E%7B(i)%7D" style="display:inline-block;margin: 0;"/> 针对所有 <img src="https://math.now.sh?inline=i%3D1%2C%20%5Cldots%20d" style="display:inline-block;margin: 0;"/> 均成立。</p>
<p>给定一个假设集合 <img src="https://math.now.sh?inline=%5Cmathcal%7BH%7D" style="display:inline-block;margin: 0;"/> ，我们定义它的 <strong>Vapnik-Chervonenkis dimension</strong> ，写作 <img src="https://math.now.sh?inline=VC%28%5Cmathcal%7BH%7D%29" style="display:inline-block;margin: 0;"/> ，为  <img src="https://math.now.sh?inline=%5Cmathcal%7BH%7D" style="display:inline-block;margin: 0;"/>  可以 shattered 的最大集合的维度。如果  <img src="https://math.now.sh?inline=%5Cmathcal%7BH%7D" style="display:inline-block;margin: 0;"/>  可以shatter 任意大的集合，那么称  <img src="https://math.now.sh?inline=VC%28%5Cmathcal%7BH%7D%29%3D%20%5Cinfty" style="display:inline-block;margin: 0;"/> 。</p>
<p>举个例子，考虑下面这三个点的集合</p>
<p><img src="27.png" alt="27"></p>
<p>那么一个二维的线性分类器 <img src="https://math.now.sh?inline=%5Cmathcal%7BH%7D" style="display:inline-block;margin: 0;"/> ( <img src="https://math.now.sh?inline=h%28x%29%3D1%5Cleft%5C%7B%5Ctheta_%7B0%7D%2B%5Ctheta_%7B1%7D%20x_%7B1%7D%2B%5Ctheta_%7B2%7D%20x_%7B2%7D%20%5Cgeq%200%5Cright%5C%7D" style="display:inline-block;margin: 0;"/>)  能不能 shatter 上面这个集合呢？答案是可以的。如下图，对于上面这三个点的任何一种标签，我们都可以找到一种线性分类器将它们完美分开。</p>
<p><img src="28.png" alt="28"></p>
<p>进一步，我们发现，没有一个由4个点组成的集合，能够被这个假设 shatter 。因此，这个假设最大能 shatter 的集合维度为 3 ， 即 <img src="https://math.now.sh?inline=VC%28%5Cmathcal%7BH%7D%29%3D%203" style="display:inline-block;margin: 0;"/> 。</p>
<p>注意，这里说 <img src="https://math.now.sh?inline=VC%28%5Cmathcal%7BH%7D%29%3D%203" style="display:inline-block;margin: 0;"/> 仅仅是说存在维度为3的集合能够被上面的假设 shatter ，而不是所有的维度为3的集合均能被 shatter ，比如如果这 3 个点排成一条直线就不能被 shatter</p>
<p><img src="29.png" alt="28"></p>
<p>也就是说，为了证明 <img src="https://math.now.sh?inline=VC%28%5Cmathcal%7BH%7D%29" style="display:inline-block;margin: 0;"/> 至少是 <img src="https://math.now.sh?inline=d" style="display:inline-block;margin: 0;"/> ，我们只需要证明存在一个维度为 d 的集合能够被 <img src="https://math.now.sh?inline=%5Cmathcal%7BH%7D" style="display:inline-block;margin: 0;"/>  shatter 。</p>
<p>从 Vapnik 这里，我们得到下面这个定理</p>
<p><img src="30.png" alt="28"></p>
<p>因此，如果一个假设集合存在一个有限的 VC 维度，那么只要 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> 很大，那么 <em>uniform convergence</em> 同样成立。和之前一样，我们可以给 <img src="https://math.now.sh?inline=%5Cvarepsilon%28h%29" style="display:inline-block;margin: 0;"/> 一个基于 <img src="https://math.now.sh?inline=%5Cvarepsilon%5Cleft%28h%5E%7B*%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 的边界，上面第二个式子其实应该是 2 乘以 <img src="https://math.now.sh?inline=O%28%29" style="display:inline-block;margin: 0;"/> 式子，这里由于用 <img src="https://math.now.sh?inline=O%28%29" style="display:inline-block;margin: 0;"/> 函数省略了这个 2 。</p>
<p>我们同时有下面这个推论（怎么得到的？我的理解是通过 <img src="https://math.now.sh?inline=%5Cgamma%20%3D%20O%5Cleft%28%5Csqrt%7B%5Cfrac%7Bd%7D%7Bm%7D%20%5Clog%20%5Cfrac%7Bm%7D%7Bd%7D%2B%5Cfrac%7B1%7D%7Bm%7D%20%5Clog%20%5Cfrac%7B1%7D%7B%5Cdelta%7D%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 这个式子求 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> ，但是我不会求 ）</p>
<p><img src="31.png" alt="28"></p>
<p>换句话说，如果想通过 <img src="https://math.now.sh?inline=%5Cmathcal%7BH%7D" style="display:inline-block;margin: 0;"/> 训练出一个很好的模型（训练集误差和泛化误差很接近），<strong>需要的训练集样本数目与 VC 维度成正比</strong>。而对于大多数模型，VC 维度往往和参数数目成正比。因此我们得到结果，训练集样本数目通常需要和 <img src="https://math.now.sh?inline=%5Cmathcal%7BH%7D" style="display:inline-block;margin: 0;"/> 的参数数目呈线性关系。</p>
<h2 id="Regularization-and-model-selection">Regularization and model selection</h2>
<h3 id="Cross-validation">Cross validation</h3>
<p>第一种交叉验证方法称为 <strong>hold-out cross validation</strong> ，或者称为简单交叉验证。就是你随机将数据分为训练集（比如 70%）和验证集（剩下的 30%），你用训练集拟合模型，然后用验证集进行模型选择。选择好要使用的模型后，一般最后再用全部数据重新拟合一下参数。</p>
<p>这种方法的缺点在于 “浪费” 了这 30% 的数据，因为在选择模型时我们只用了 70% 的数据用来拟合模型。如果我们的数据量非常大或者数据收集很容易，这种做法没问题。反之，我们可能希望有更好的方法。</p>
<p>第二种交叉验证方法称为 <strong>k-fold cross validation</strong> ，一般我们会取 k = 10（此时，每次你使用了 90% 的数据来拟合模型，比上面用到的数据更多。） 。如果 k = m，此时这种方法有一个单独的名字，<strong>leave-one-out cross validation</strong> 。</p>
<h3 id="Feature-Selection">Feature Selection</h3>
<p>模型选择一个特殊且重要的例子是特征选择。假设你现在有一个监督学习问题，特征数目 n 非常大 (可能 <img src="https://math.now.sh?inline=n%20%5Cgg%20m" style="display:inline-block;margin: 0;"/> ) ，但是你认为这里只有一小部分特征和反应变量有关。这里你即便用一个线性分类器来拟合这 n 个参数，你的假设集合的 VC 维度仍然是 <img src="https://math.now.sh?inline=O%28n%29" style="display:inline-block;margin: 0;"/> ，<strong>因此除非训练集非常大，不然就很有可能过拟合</strong>。</p>
<p>在这种情况下，你可以需要先用一个<strong>特征选择</strong>算法来剔除一些特征。当有 n 个特征时，总共有 <img src="https://math.now.sh?inline=2%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 可能的特征子集合，因此特征选择可以视为对  <img src="https://math.now.sh?inline=2%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 个可能的模型的模型选择。当 n 很大时，我们几乎无法对所有的  <img src="https://math.now.sh?inline=2%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 个可能的模型进行拟合和遍历，所以我们需要一些启发式地算法来查找一个不错的特征子集合。下面的过程称为 <strong>向前选择 (forward search)</strong> :</p>
<p><img src="32.png" alt="32"></p>
<p>这里第二步外层循环的终止条件可以是 $ \mathcal{F} = {1, \cdots, n}$ ，也就是所有特征的集合，或当参数个体超过你自己设定的阈值时终止。第三步是说还需要用交叉验证选择第二步中特征数量从 1 到 n （或者你设定的参数阈值）的所有模型中的最佳模型（感觉通过画个图来选择特征数量更清晰）。</p>
<p>向前选择是<strong>封装特征选择 (wrapper model feature selection)</strong> 的一个例子。封装的意思就是说，你需要一直拟合不同的特征子集合组成的模型。除了向前选择外，我们还有其他的方法可以选择。比如，<strong>向后选择 (backward search)</strong> 从 <img src="https://math.now.sh?inline=%5Cmathcal%7BF%7D%3D%5C%7B1%2C%20%5Cldots%2C%20n%5C%7D" style="display:inline-block;margin: 0;"/> 出发，每次迭代均剔除一个特征（方法和向前选择一样）直到 <img src="https://math.now.sh?inline=%5Cmathcal%7BF%7D%3D%5Cemptyset" style="display:inline-block;margin: 0;"/> 。</p>
<p><strong>封装特征选择通常效果很好（虽然找到的不一定是最优解），但是计算量非常大</strong>，因为需要不断地拟合模型。实际上，对 n 个特征采用向前选择需要拟合 <img src="https://math.now.sh?inline=O%28n%5E%7B2%7D%29" style="display:inline-block;margin: 0;"/> 次模型。</p>
<p><strong>过滤式特征选择 (Filter feature selection)</strong> 模型采用一种启发式的，计算量非常小的选择特征的方式。其实现就是采用某种简单的评分 <img src="https://math.now.sh?inline=S%28i%29" style="display:inline-block;margin: 0;"/> ，用于衡量每个特征 <img src="https://math.now.sh?inline=x_%7Bi%7D" style="display:inline-block;margin: 0;"/> 对于标签 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 的影响程度。之后我们就只需要挑选具有最大评分的前 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 个特征即可。</p>
<p>评分的一种选择是训练集  <strong><img src="https://math.now.sh?inline=x_%7Bi%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 的相关系数的绝对值</strong>。实际上，更普遍的选择是<strong>相互信息 (mutual information)</strong> <img src="https://math.now.sh?inline=MI%28x_%7Bi%7D%2Cy%29" style="display:inline-block;margin: 0;"/> ，特别是对于离散特征 <img src="https://math.now.sh?inline=x_%7Bi%7D" style="display:inline-block;margin: 0;"/> 。下式中认为  <img src="https://math.now.sh?inline=x_%7Bi%7D" style="display:inline-block;margin: 0;"/> 是二分类，但是多分类也可以，式子中的概率均通过训练集数据得到。</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BMI%7D%5Cleft%28x_%7Bi%7D%2C%20y%5Cright%29%3D%5Csum_%7Bx_%7Bi%7D%20%5Cin%5C%7B0%2C1%5C%7D%7D%20%5Csum_%7By%20%5Cin%5C%7B0%2C1%5C%7D%7D%20p%5Cleft(x_%7Bi%7D%2C%20y%5Cright)%20%5Clog%20%5Cfrac%7Bp%5Cleft(x_%7Bi%7D%2C%20y%5Cright)%7D%7Bp%5Cleft(x_%7Bi%7D%5Cright)%20p(y)%7D%20.%0A" /></p><p>事实上，相互信息就是信息论中的 Kullback-Leibler (KL) divergence: （没学过，可以理解为 <img src="https://math.now.sh?inline=p%5Cleft%28x_%7Bi%7D%2C%20y%5Cright%29%20%5Ctext%7B%20%E5%92%8C%20%7D%20p%5Cleft(x_%7Bi%7D%5Cright)%20p(y)" style="display:inline-block;margin: 0;"/> 之间的距离，如果  <img src="https://math.now.sh?inline=x_%7Bi%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 彼此独立，那么<img src="https://math.now.sh?inline=p%5Cleft%28x_%7Bi%7D%2C%20y%5Cright%29%20%3D%20p%5Cleft(x_%7Bi%7D%5Cright)%20p(y)" style="display:inline-block;margin: 0;"/>， 他们的 KL 距离就是 0；如果  <img src="https://math.now.sh?inline=x_%7Bi%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/>  关联度很高，那么它们的 KL 距离就很大）</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BMI%7D%5Cleft%28x_%7Bi%7D%2C%20y%5Cright%29%3D%5Cmathrm%7BKL%7D%5Cleft(p%5Cleft(x_%7Bi%7D%2C%20y%5Cright)%20%5C%7C%20p%5Cleft(x_%7Bi%7D%5Cright)%20p(y)%5Cright)%0A" /></p><p>最后一个问题，选取前 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 个特征中的 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 最后通过交叉验证来得到。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>AB=I证明BA=I</title>
    <url>/posts/cdd811e7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>假设 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的方阵，存在 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BAB%3DI%7D" style="display:inline-block;margin: 0;"/> ，证明  <img src="https://math.now.sh?inline=%5Cboldsymbol%7BBA%3DI%7D" style="display:inline-block;margin: 0;"/> ，或者说  <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/> 互为逆矩阵。</p>
<span id="more"></span>
<p>首先我们看逆矩阵定义：</p>
<blockquote>
<p>一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的正方矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/> 满足 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%20A%7D%3D%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BB%7D%3D%5Cboldsymbol%7BI%7D" style="display:inline-block;margin: 0;"/> 时, 就称矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/> 是矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 的逆矩阵, 记为 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> <a href="%E5%BC%A0%E8%B4%A4%E8%BE%BE%EF%BC%9A%E3%80%8A%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%89%88">^1</a>。</p>
</blockquote>
<p>也就说根据定义，证明逆矩阵需要证明两边均成立，即  <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%20A%7D%3D%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BB%7D%3D%5Cboldsymbol%7BI%7D" style="display:inline-block;margin: 0;"/> ，这里我们提出的问题就是只要证明一边就行了。</p>
<h1>第一种证明：根据秩的性质</h1>
<p>我们可以根据秩的一个性质来证明<a href="https://math.stackexchange.com/questions/3852/if-ab-i-then-ba-i">^2</a>，存在</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Brank%7D%28%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BB%7D%29%20%5Cleqslant%20%5Cmin%20%5C%7B%5Coperatorname%7Brank%7D(%5Cboldsymbol%7BA%7D)%2C%20%5Coperatorname%7Brank%7D(%5Cboldsymbol%7BB%7D)%5C%7D%0A" /></p><p>因为 <img src="https://math.now.sh?inline=rank%28%5Cboldsymbol%7BAB%7D%29%20%3D%20rank(%5Cboldsymbol%7BI%7D)%20%3D%20n" style="display:inline-block;margin: 0;"/> ，所以 <img src="https://math.now.sh?inline=rank%28%5Cboldsymbol%7BA%7D%29%20%5Cgeq%20n" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=rank%28%5Cboldsymbol%7BB%7D%29%20%5Cgeq%20n" style="display:inline-block;margin: 0;"/>  ，由于<img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/> 的秩最大为 n，所以  <img src="https://math.now.sh?inline=rank%28%5Cboldsymbol%7BA%7D%29%20%3D%20rank(%5Cboldsymbol%7BB%7D)%3D%20n" style="display:inline-block;margin: 0;"/> ，二者均为非奇异矩阵。所以</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7BA%5E%7B-1%7DAB%3DA%5E%7B-1%7DI%7D%20%5Cquad%20%5CRightarrow%20%5Cquad%20%5Cboldsymbol%7BB%3DA%5E%7B-1%7D%7D%0A" /></p><p>所以， <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/> 互为逆矩阵。</p>
<h1>第二种证明：根据行列式的性质</h1>
<p style=""><img src="https://math.now.sh?from=det%28%5Cboldsymbol%7BAB%7D%29%3Ddet(%5Cboldsymbol%7BA%7D)det(%5Cboldsymbol%7BB%7D)%3Ddet(%5Cboldsymbol%7BI%7D)%3D1%20%5C%5C%0A%5Ctherefore%20det(%5Cboldsymbol%7BA%7D)%20%5Cneq%200%2C%20%5Cquad%20det(%5Cboldsymbol%7BB%7D)%20%5Cneq%200%0A" /></p><p>因此  <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/>  均为非奇异矩阵，证明二者互逆同上。</p>
<h1>第三种证明：根据齐次方程解的数目</h1>
<p>假设 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BBX%3D0%7D" style="display:inline-block;margin: 0;"/> 是一个齐次方程组，存在<a href="https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/product-equals-identity-implies-invertible.html">^3</a></p>
<p style=""><img src="https://math.now.sh?from=B%20X%3D0%20%5CLongrightarrow%20A%28B%20X%29%3DA%200%20%5CLongrightarrow(A%20B)%20X%3D0%20%5CLongrightarrow%20I%20X%3D0%20%5CRightarrow%20X%3D0%0A" /></p><p>因此，<img src="https://math.now.sh?inline=%5Cboldsymbol%7BX%3D0%7D" style="display:inline-block;margin: 0;"/> 是该齐次方程组的<strong>唯一解</strong>，所以 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/> 为非奇异矩阵，证明二者互逆同上。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵微分与正规方程组推导</title>
    <url>/posts/55264e6f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在看吴恩达老师CS229课程时，看吴老师推导线性回归的<strong>正规方程组</strong>（<img src="https://math.now.sh?inline=X%5E%7BT%7D%20X%20%5Ctheta%3DX%5E%7BT%7D%20y" style="display:inline-block;margin: 0;"/>）时，感觉不是很系统，而且引入了一个新的概念，<strong>矩阵求导</strong>。这部分内容之前上育种课的时候就感觉云里雾里，这次花了些时间，把这一部分内容搞懂了。</p>
<span id="more"></span> 
<h1>问题描述</h1>
<p>线性回归可以用向量的形式描述为下式（向量表示为加粗的小写字母，默认为竖向量；矩阵表示为加粗的大写字母，下同）</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7By%3DX%5Cbeta%2Be%7D%0A" /></p><p>根据最小二乘法，代价函数定义为 （假设样本数为 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/>，参数数目为 <img src="https://math.now.sh?inline=n%2B1" style="display:inline-block;margin: 0;"/>, 使用向量外积转为向量乘法形式）:</p>
<p style=""><img src="https://math.now.sh?from=J%28%5Cboldsymbol%7B%5Cbeta%7D%29%20%20%3D%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft(h_%7B%5Cbeta%7D%5Cleft(x%5E%7B(i)%7D%5Cright)-y%5E%7B(i)%7D%5Cright)%5E%7B2%7D%20%3D%20%0A%5Cfrac%7B1%7D%7B2%7D%5Cboldsymbol%7B(X%20%5Cbeta-y)%5E%7BT%7D(X%20%5Cbeta-y)%7D%20%5C%5C%0A" /></p><p>我们需要寻找使得代价函数（平方误差和或均方误差）最小的一组常数 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> ，这是一个优化问题（求一个函数的极值：极大值或极小值）。</p>
<p>在高中就学过，一个函数的极值往往是其导数为0的位置，因此我们需要求使得代价函数的导数为0（梯度为 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B0%7D" style="display:inline-block;margin: 0;"/> 向量）的 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 值，而这就牵涉到了矩阵微分或矩阵求导。（实际上，一阶导数为0的点仅仅是一个驻点或称平稳点，一阶导数为0仅仅是全局极小点的<strong>必要不充分</strong>条件。但是最小二乘的代价函数是一个凸函数，因此一阶导为0的点就是全局极小点，这些概念具体可见张贤达老师的《矩阵分析与应用》<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="张贤达《矩阵分析与应用（第二版）》">[1]</span></a></sup>。）</p>
<p>所以，这里需要先了解矩阵微分的一些概念和知识，这一部分内容同样见于张贤达老师的书<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="张贤达《矩阵分析与应用（第二版）》">[1]</span></a></sup>，知乎上也有人进行了一些梳理<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://zhuanlan.zhihu.com/p/305171795">[2]</span></a></sup>。</p>
<h1>矩阵微分</h1>
<h2 id="梯度矩阵定义">梯度矩阵定义</h2>
<p>首先，我们将线性代数中的函数依据其输入输出划分为下面这些类型，输入可以为向量或矩阵，输出可以分为标量、向量和矩阵（函数定义就是一个映射关系，线性代数里的函数仅仅是将输入输出换成了向量和矩阵，比如矩阵乘法 <img src="https://math.now.sh?inline=f%28%5Cboldsymbol%7Bx%7D%29%20%3D%20%5Cboldsymbol%7BAx%7D" style="display:inline-block;margin: 0;"/> 就是一个映射/函数）。</p>
<p><img src="1.png" alt="1"></p>
<p>这里只考虑<strong>输入为一个向量的标量函数</strong>（<img src="https://math.now.sh?inline=R%5Em%20%5Crightarrow%20R" style="display:inline-block;margin: 0;"/> ）。</p>
<p>矩阵微分有两种定义方式，一种称为 Jacobian 矩阵，一种称为梯度矩阵，二者的内容均为<strong>偏导数</strong>，仅仅是结果的布局不同，互为转置矩阵。这里只说梯度矩阵，更详细的内容见张贤达老师的书。</p>
<p>实值标量函数 <img src="https://math.now.sh?inline=f%28x%29" style="display:inline-block;margin: 0;"/> 的梯度向量 <img src="https://math.now.sh?inline=%5Cnabla_%7B%5Cboldsymbol%7Bx%7D%7D%20f%28%5Cboldsymbol%7Bx%7D%29" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=m%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 列向量, 定义为 (输入为一个向量，输出为一个标量)</p>
<p style=""><img src="https://math.now.sh?from=%5Cnabla_%7B%5Cboldsymbol%7Bx%7D%7D%20f%28%5Cboldsymbol%7Bx%7D%29%20%5Cstackrel%7B%5Ctext%20%7B%20def%20%7D%7D%7B%3D%7D%5Cleft%5B%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20x_%7B1%7D%7D%2C%20%5Ccdots%2C%20%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20x_%7Bm%7D%7D%5Cright%5D%5E%7B%5Cmathrm%7BT%7D%7D%3D%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%7D%0A" /></p><h2 id="梯度矩阵性质">梯度矩阵性质</h2>
<h2 id="梯度矩阵计算">梯度矩阵计算</h2>
<p>那么我们如何计算一个梯度函数的梯度向量或梯度矩阵呢？你可以直接通过定义拆分成元素级别来计算，</p>
<p>例如求实值函数 <img src="https://math.now.sh?inline=f%28x%29%3D%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D" style="display:inline-block;margin: 0;"/> 的梯度矩阵。由于 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%3D%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%20%5Csum_%7Bl%3D1%7D%5E%7Bn%7D%20a_%7Bk%20l%7D%20x_%7Bk%7D%20x_%7Bl%7D" style="display:inline-block;margin: 0;"/>, 故可求出梯度向量 <img src="https://math.now.sh?inline=%5Cfrac%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%7D%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%7D" style="display:inline-block;margin: 0;"/> 的第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 个分量为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cfrac%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%7D%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%7D%5Cright%5D_%7Bi%7D%3D%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20x_%7Bi%7D%7D%20%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%20%5Csum_%7Bl%3D1%7D%5E%7Bn%7D%20a_%7Bk%20l%7D%20x_%7Bk%7D%20x_%7Bl%7D%3D%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%20x_%7Bk%7D%20a_%7Bk%20i%7D%2B%5Csum_%7Bl%3D1%7D%5E%7Bn%7D%20x_%7Bl%7D%20a_%7Bi%20l%7D%20%3D%20%5Cboldsymbol%7B%28A%5E%7BT%7Dx%7D%29_%7Bi%7D%20%2B%20%5Cboldsymbol%7B(Ax%7D)_%7Bi%7D%0A" /></p><p>立即得梯度向量 <img src="https://math.now.sh?inline=%5Cnabla_%7B%5Cboldsymbol%7BX%7D%7D%20f%28%5Cboldsymbol%7Bx%7D%29%3D%5Cleft(%5Cboldsymbol%7BA%5ET%7D%2B%5Cboldsymbol%7BA%7D%5Cright)%20%5Cboldsymbol%7Bx%7D_%7B%5Ctext%20%7B%E3%80%82%20%7D%7D" style="display:inline-block;margin: 0;"/></p>
<p>但是这样做很麻烦，而已有的函数可能不好拆解成元素级别的式子，也不符合线性代数一向简洁的特点。</p>
<p>我们可以通过一个<strong>矩阵微分</strong>的性质来求解梯度矩阵，下面就简单介绍一下<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="张贤达《矩阵分析与应用（第二版）》">[1]</span></a></sup>。在介绍矩阵微分之前，需要掌握一些<strong>矩阵的迹</strong>的性质</p>
<h3 id="矩阵的迹">矩阵的迹</h3>
<p><strong>定义</strong> $ n \times n$ 矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 的对角元素之和称为 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 的迹 (trace), 记作 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BA%7D%29" style="display:inline-block;margin: 0;"/>, 即有</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BA%7D%29%3Da_%7B11%7D%2B%5Ccdots%2Ba_%7Bn%20n%7D%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20a_%7Bi%20i%7D%0A" /></p><p><strong>非正方矩阵无迹的定义</strong>。</p>
<p>下面是矩阵的迹满足的一些性质。</p>
<p>(1) 若 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/> 均为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 矩阵, 则 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BA%7D%20%5Cpm%20%5Cboldsymbol%7BB%7D%29%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BA%7D)%20%5Cpm%20%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BB%7D)" style="display:inline-block;margin: 0;"/> 。<br>
(2) 若 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/> 均为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 矩阵, 并且 <img src="https://math.now.sh?inline=c_%7B1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=c_%7B2%7D" style="display:inline-block;margin: 0;"/> 为常数, 则 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28c_%7B1%7D%20%5Cboldsymbol%7BA%7D%20%5Cpm%20c_%7B2%7D%20%5Cboldsymbol%7BB%7D%5Cright%29%3Dc_%7B1%7D%20%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BA%7D)%20%5Cpm" style="display:inline-block;margin: 0;"/> <img src="https://math.now.sh?inline=c_%7B2%7D%20%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BB%7D%29" style="display:inline-block;margin: 0;"/> 。特别地, 若 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%7D%3D%5Cboldsymbol%7BO%7D" style="display:inline-block;margin: 0;"/>, 则 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%28c%20%5Cboldsymbol%7BA%7D%29%3Dc%20%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BA%7D)" style="display:inline-block;margin: 0;"/> 。<br>
(3) 矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 的转置、复数共轭和复共轭转置的迹分别为 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%5Cright%29%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BA%7D)%2C%20%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7BA%7D%5E%7B*%7D%5Cright)%3D" style="display:inline-block;margin: 0;"/> <img src="https://math.now.sh?inline=%5B%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BA%7D%29%5D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BH%7D%7D%5Cright%29%3D%5B%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BA%7D)%5D%5E%7B*%7D%7B%20%7D%5E%7B%5Ccirc%7D" style="display:inline-block;margin: 0;"/><br>
(4) 若 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D%20%5Cin%20%5Cmathbb%7BC%7D%5E%7Bm%20%5Ctimes%20n%7D%2C%20%5Cboldsymbol%7BB%7D%20%5Cin%20%5Cmathbb%7BC%7D%5E%7Bn%20%5Ctimes%20m%7D" style="display:inline-block;margin: 0;"/>, 则 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BA%20B%7D%29%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BB%7D%20%5Cboldsymbol%7BA%7D)" style="display:inline-block;margin: 0;"/> 。</p>
<p>证明，运用矩阵乘法，存在下式</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Btr%7D%28A%20B%29%20%26%3D%5Csum_%7Bi%3D1%7D%5E%7BM%7D%20A%20B_%7Bi%20i%7D%20%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20A_%7Bi%20j%7D%20B_%7Bj%20i%7D%0A%5Cend%7Baligned%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Btr%7D%28B%20A%29%20%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20B%20A_%7Bj%20j%7D%20%5C%5C%0A%26%3D%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20B_%7Bji%7D%20A_%7Bi%20j%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>观察一下，得知二者相等，得证 <img src="https://math.now.sh?inline=tr%28AB%29%20%3D%20tr(BA)" style="display:inline-block;margin: 0;"/> 。</p>
<p>(5) 若 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 矩阵, 则 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BH%7D%7D%20%5Cboldsymbol%7BA%7D%5Cright%29%3D0%20%5CLongleftrightarrow%20%5Cboldsymbol%7BA%7D%3D%5Cboldsymbol%7BO%7D_%7Bm%20%5Ctimes%20n%7D(" style="display:inline-block;margin: 0;"/> 零矩阵 <img src="https://math.now.sh?inline=%29" style="display:inline-block;margin: 0;"/> 。</p>
<p>证明</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%20%5Coperatorname%7Btr%7D%5Cleft%28A%5E%7BT%7D%20A%5Cright%29%20%5C%5C%0A%3D%26%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20(A%5E%7BT%7D%20A)_%7Bi%20i%7D%20%5C%5C%0A%3D%26%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Csum_%7Bj%3D1%7D%5E%7Bm%7D%20A_%7Bi%20j%7D%5E%7BT%7D%20A_%7Bj%20i%7D%20%5C%5C%0A%3D%26%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bm%7D%20A_%7Bj%20i%7D%5E%7B2%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，<img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BH%7D%7D%20%5Cboldsymbol%7BA%7D%5Cright%29%3D0%20%5CLongleftrightarrow%20%5Cboldsymbol%7BA%7D%3D%5Cboldsymbol%7BO%7D_%7Bm%20%5Ctimes%20n%7D" style="display:inline-block;margin: 0;"/><br>
(6) <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BH%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%3D%5Coperatorname%7Btr%7D%5Cleft%28%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%20%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BH%7D%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7By%7D%5E%7B%5Cmathrm%7BH%7D%7D%20%5Cboldsymbol%7Bx%7D%3D%5Coperatorname%7Btr%7D%5Cleft%28%5Cboldsymbol%7Bx%7D%20%5Cboldsymbol%7By%7D%5E%7B%5Cmathrm%7BH%7D%7D%5Cright%29" style="display:inline-block;margin: 0;"/>。</p>
<p>证明：这里只证明前半部分，后半部分我直接脑补出来了。</p>
<p style=""><img src="https://math.now.sh?from=x_%7Bn%20%5Ctimes%201%7D%3D%5Cleft%28x_%7Bi%7D%5Cright%29%2C%20%5Cquad%20A_%7Bn%20%5Ctimes%20n%7D%3D%5Cleft%5Ba_%7Bi%20j%7D%5Cright%5D%5C%5C%0A" /></p><p>设</p>
<p style=""><img src="https://math.now.sh?from=B%3Dx%20x%5E%7BT%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D%0Ax_%7B1%7D%5E%7B2%7D%20%26%20x_%7B1%7D%20x_%7B2%7D%20%26%20%5Ccdots%20%26%20x_%7B1%7D%20x_%7Bn%7D%20%5C%5C%0A%5Cvdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Cvdots%20%5C%5C%0Ax_%7Bn%7D%20x_%7B1%7D%20%26%20x_%7Bn%7D%20x_%7B2%7D%20%26%20%5Ccdots%20%26%20x_%7Bn%7D%20x_%7Bn%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Atr%28Axx%5E%7BT%7D%29%0A%26%3D%5Coperatorname%7Btr%7D(A%20B)%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D(A%20B)_%7Bi%20i%7D%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20A_%7Bi%20j%7D%20B_%7Bj%20i%7D%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20a_%7Bi%20j%7D%20x_%7Bj%7D%20x_%7Bi%7D%5C%5C%0A%26%3Dx%5E%7BT%7D%20A%20x%0A%5Cend%7Baligned%7D%0A" /></p><p>(7) 迹等于特征值之和, 即 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BA%7D%29%3D%5Clambda_%7B1%7D%2B%5Ccdots%2B%5Clambda_%7Bn%7D" style="display:inline-block;margin: 0;"/> 。<br>
(8) 分块矩阵的迹满足</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cboldsymbol%7BA%7D%20%26%20%5Cboldsymbol%7BB%7D%20%5C%5C%0A%5Cboldsymbol%7BC%7D%20%26%20%5Cboldsymbol%7BD%7D%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BA%7D%29%2B%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BD%7D)%0A" /></p><p>式中, <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D%20%5Cin%20%5Cmathbb%7BC%7D%5E%7Bm%20%5Ctimes%20m%7D%2C%20%5Cboldsymbol%7BB%7D%20%5Cin%20%5Cmathbb%7BC%7D%5E%7Bm%20%5Ctimes%20n%7D%2C%20%5Cboldsymbol%7BC%7D%20%5Cin%20%5Cmathbb%7BC%7D%5E%7Bn%20%5Ctimes%20m%7D%2C%20%5Cboldsymbol%7BD%7D%20%5Cin%20%5Cmathbb%7BC%7D%5E%7Bn%20%5Ctimes%20n%7D" style="display:inline-block;margin: 0;"/> 。<br>
(9) 对于任何正整数 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/>, 有</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%28%5Cboldsymbol%7BA%7D%5E%7Bk%7D%5Cright%29%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Clambda_%7Bi%7D%5E%7Bk%7D%0A" /></p><p>灵活运用迹的等式 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BU%7D%20%5Cboldsymbol%7BV%7D%29%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BV%7D%20%5Cboldsymbol%7BU%7D)" style="display:inline-block;margin: 0;"/>, 可以得到一些常用的重要结果。例如, 矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BH%7D%7D%20%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%20A%7D%5E%7B%5Cmathrm%7BH%7D%7D" style="display:inline-block;margin: 0;"/> 的迹相等, 且有</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%28%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BH%7D%7D%20%5Cboldsymbol%7BA%7D%5Cright%29%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BH%7D%7D%5Cright)%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20a_%7Bi%20j%7D%20a_%7Bi%20j%7D%5E%7B*%7D%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%5Cleft%7Ca_%7Bi%20j%7D%5Cright%7C%5E%7B2%7D%0A" /></p><p>又如, 在迹的等式 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BU%7D%20%5Cboldsymbol%7BV%7D%29%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BV%7D%20%5Cboldsymbol%7BU%7D)" style="display:inline-block;margin: 0;"/> 中, 若分别令 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BU%7D%3D%5Cboldsymbol%7BA%7D%2C%20%5Cboldsymbol%7BV%7D%3D%5Cboldsymbol%7BB%7D%20%5Cboldsymbol%7BC%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=U%3DA%20%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=%5Cboldsymbol%7BV%7D%3D%5Cboldsymbol%7BC%7D" style="display:inline-block;margin: 0;"/>, 则有</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BA%20B%20C%7D%29%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BB%20C%20A%7D)%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BC%20A%20B%7D)%0A" /></p><p>类似地, 若分别令 <img src="https://math.now.sh?inline=U%3DA%2C%20V%3DB%20C%20D%20%3B%20U%3DA%20B%2C%20V%3DC%20D" style="display:inline-block;margin: 0;"/> 及 <img src="https://math.now.sh?inline=U%3DA%20B%20C%2C%20V%3DD" style="display:inline-block;margin: 0;"/>, 又有</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BA%20B%20C%20D%7D%29%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BB%20C%20D%20A%7D)%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BC%20D%20A%20B%7D)%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BD%7D%20%5Cboldsymbol%7BA%20B%20C%7D)%0A" /></p><p>利用上式还易知, 若矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 与 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/> 均为 <img src="https://math.now.sh?inline=m%20%5Ctimes%20m" style="display:inline-block;margin: 0;"/> 矩阵, 且 <img src="https://math.now.sh?inline=B" style="display:inline-block;margin: 0;"/> 非奇异, 则</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%28%5Cboldsymbol%7BB%7D%20%5Cboldsymbol%7BA%20B%7D%5E%7B-1%7D%5Cright%29%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7BB%7D%5E%7B-1%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BB%7D%5Cright)%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7BA%20B%20B%7D%5E%7B-1%7D%5Cright)%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BA%7D)%0A" /></p><h3 id="一阶矩阵微分">一阶矩阵微分</h3>
<h3 id="一阶实矩阵微分">一阶实矩阵微分</h3>
<p>矩阵微分用符号 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D" style="display:inline-block;margin: 0;"/> 表示, 定义为 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D%3D%5Cleft%5B%5Cmathrm%7Bd%7D%20X_%7Bi%20j%7D%5Cright%5D_%7Bi%3D1%2C%20j%3D1%7D%5E%7Bm%2C%20n%7D" style="display:inline-block;margin: 0;"/> 。<br>
例 考虑标量函数 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BU%7D%29" style="display:inline-block;margin: 0;"/> 的微分, 得</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7Bd%7D%28%5Coperatorname%7Btr%7D%20%5Cboldsymbol%7BU%7D%29%3D%5Cmathrm%7Bd%7D%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20u_%7Bi%20i%7D%5Cright)%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Cmathrm%7B~d%7D%20u_%7Bi%20i%7D%3D%5Coperatorname%7Btr%7D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BU%7D)%0A" /></p><p>即有 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%28%5Coperatorname%7Btr%7D%20%5Cboldsymbol%7BU%7D%29%3D%5Coperatorname%7Btr%7D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BU%7D)" style="display:inline-block;margin: 0;"/> 。<br>
例 考虑矩阵乘积 <img src="https://math.now.sh?inline=U%20V" style="display:inline-block;margin: 0;"/> 的微分矩阵, 有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5B%5Cmathrm%7Bd%7D%28%5Cboldsymbol%7BU%7D%20%5Cboldsymbol%7BV%7D%29%5D_%7Bi%20j%7D%20%26%3D%5Cmathrm%7Bd%7D%5Cleft(%5B%5Cboldsymbol%7BU%7D%20%5Cboldsymbol%7BV%7D%5D_%7Bi%20j%7D%5Cright)%3D%5Cmathrm%7Bd%7D%5Cleft(%5Csum_%7Bk%7D%20u_%7Bi%20k%7D%20v_%7Bk%20j%7D%5Cright)%3D%5Csum_%7Bk%7D%20%5Cmathrm%7B~d%7D%5Cleft(u_%7Bi%20k%7D%20v_%7Bk%20j%7D%5Cright)%20%5C%5C%0A%26%3D%5Csum_%7Bk%7D%5Cleft%5B%5Cleft(%5Cmathrm%7B~d%7D%20u_%7Bi%20k%7D%5Cright)%20v_%7Bk%20j%7D%2Bu_%7Bi%20k%7D%20%5Cmathrm%7B~d%7D%20v_%7Bk%20j%7D%5Cright%5D%3D%5Csum_%7Bk%7D%5Cleft(%5Cmathrm%7B~d%7D%20u_%7Bi%20k%7D%5Cright)%20v_%7Bk%20j%7D%2B%5Csum_%7Bk%7D%20u_%7Bi%20k%7D%20%5Cmathrm%7B~d%7D%20v_%7Bk%20j%7D%20%5C%5C%0A%26%3D%5B(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BU%7D)%20%5Cboldsymbol%7BV%7D%5D_%7Bi%20j%7D%2B%5B%5Cboldsymbol%7BU%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BV%7D%5D_%7Bi%20j%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>从而得 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%28%5Cboldsymbol%7BU%7D%20%5Cboldsymbol%7BV%7D%29%3D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BU%7D)%20%5Cboldsymbol%7BV%7D%2B%5Cboldsymbol%7BU%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BV%7D" style="display:inline-block;margin: 0;"/> 。<br>
以上举例表明, 实矩阵微分具有以下两个基本性质:<br>
<strong>转置</strong> 矩阵转置的微分等于矩阵微分的转置, 即有 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%5Cleft%28%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%5Cright%29%3D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D)%5E%7B%5Cmathrm%7BT%7D%7D" style="display:inline-block;margin: 0;"/> 。<br>
<strong>线性</strong> <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%28%5Calpha%20%5Cboldsymbol%7BX%7D%2B%5Cbeta%20%5Cboldsymbol%7BY%7D%29%3D%5Calpha%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D%2B%5Cbeta%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BY%7D" style="display:inline-block;margin: 0;"/> 。<br>
下面汇总了矩阵微分的常用计算公式  。<br>
(1) 常数矩阵的微分矩阵为零矩阵, 即 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BA%7D%3D%5Cboldsymbol%7BO%7D" style="display:inline-block;margin: 0;"/> 。<br>
(2) 常数 <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/> 与矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BX%7D" style="display:inline-block;margin: 0;"/> 的乘积的微分矩阵 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%28%5Calpha%20%5Cboldsymbol%7BX%7D%29%3D%5Calpha%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D" style="display:inline-block;margin: 0;"/> 。<br>
(3) 矩阵转置的微分矩阵等于原矩阵的微分矩阵的转置, 即 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%5Cleft%28%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%5Cright%29%3D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D)%5E%7B%5Cmathrm%7BT%7D%7D" style="display:inline-block;margin: 0;"/> 。<br>
(4) 两个矩阵函数的和 (差) 的微分矩阵为 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%28%5Cboldsymbol%7BU%7D%20%5Cpm%20%5Cboldsymbol%7BV%7D%29%3D%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BU%7D%20%5Cpm%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BV%7D" style="display:inline-block;margin: 0;"/> 。<br>
(5) 常数矩阵与矩阵乘积的微分矩阵为 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%28%5Cboldsymbol%7BA%20X%7D%20%5Cboldsymbol%7BB%7D%29%3D%5Cboldsymbol%7BA%7D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D)%20%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/> 。<br>
(6) 矩阵函数 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BU%7D%3D%5Cboldsymbol%7BF%7D%28%5Cboldsymbol%7BX%7D%29%2C%20%5Cboldsymbol%7BV%7D%3D%5Cboldsymbol%7BG%7D(%5Cboldsymbol%7BX%7D)%2C%20%5Cboldsymbol%7BW%7D%3D%5Cboldsymbol%7BH%7D(%5Cboldsymbol%7BX%7D)" style="display:inline-block;margin: 0;"/> 乘积的微分矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathrm%7Bd%7D%28%5Cboldsymbol%7BU%7D%20%5Cboldsymbol%7BV%7D%29%20%26%3D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BU%7D)%20%5Cboldsymbol%7BV%7D%2B%5Cboldsymbol%7BU%7D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BV%7D)%20%5C%5C%0A%5Cmathrm%7Bd%7D(%5Cboldsymbol%7BU%7D%20%5Cboldsymbol%7BV%7D%20%5Cboldsymbol%7BW%7D)%20%26%3D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BU%7D)%20%5Cboldsymbol%7BV%7D%20%5Cboldsymbol%7BW%7D%2B%5Cboldsymbol%7BU%7D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BV%7D)%20%5Cboldsymbol%7BW%7D%2B%5Cboldsymbol%7BU%7D%20%5Cboldsymbol%7BV%7D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BW%7D)%0A%5Cend%7Baligned%7D%0A" /></p><p>(7) 矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BX%7D" style="display:inline-block;margin: 0;"/> 的迹的矩阵微分 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%28%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BX%7D%29)" style="display:inline-block;margin: 0;"/> 等于矩阵微分 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D" style="display:inline-block;margin: 0;"/> 的迹 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%28%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D%29" style="display:inline-block;margin: 0;"/>, 即</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7Bd%7D%28%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BX%7D%29)%3D%5Coperatorname%7Btr%7D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D)%0A" /></p><p>特别地, 矩阵函数 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BF%7D%28%5Cboldsymbol%7BX%7D%29" style="display:inline-block;margin: 0;"/> 的迹的矩阵微分为 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%28%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BF%7D(%5Cboldsymbol%7BX%7D%29))%3D%5Coperatorname%7Btr%7D(%5Cmathrm%7Bd%7D(%5Cboldsymbol%7BF%7D(%5Cboldsymbol%7BX%7D)))" style="display:inline-block;margin: 0;"/> 。</p>
<h3 id="标量函数的梯度矩阵辨识">标量函数的梯度矩阵辨识</h3>
<p>在多变量函数的微积分中, 称多变量函数 <img src="https://math.now.sh?inline=f%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 在点 <img src="https://math.now.sh?inline=%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 可微分, 若 <img src="https://math.now.sh?inline=f%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 的全改变量可以写作</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5CDelta%20f%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%5Cright%29%20%26%3Df%5Cleft(x_%7B1%7D%2B%5CDelta%20x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%2B%5CDelta%20x_%7Bm%7D%5Cright)-f%5Cleft(x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%5Cright)%20%5C%5C%0A%26%3DA_%7B1%7D%20%5CDelta%20x_%7B1%7D%2B%5Ccdots%2BA_%7Bm%7D%20%5CDelta%20x_%7Bm%7D%2BO%5Cleft(%5CDelta%20x_%7B1%7D%2C%20%5Ccdots%2C%20%5CDelta%20x_%7Bm%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>式中, <img src="https://math.now.sh?inline=A_%7B1%7D%2C%20%5Ccdots%2C%20A_%7Bm%7D" style="display:inline-block;margin: 0;"/> 分别与 <img src="https://math.now.sh?inline=%5CDelta%20x_%7B1%7D%2C%20%5Ccdots%2C%20%5CDelta%20x_%7Bm%7D" style="display:inline-block;margin: 0;"/> 无关, 而 <img src="https://math.now.sh?inline=O%5Cleft%28%5CDelta%20x_%7B1%7D%2C%20%5Ccdots%2C%20%5CDelta%20x_%7Bm%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 表示偏改变量 <img src="https://math.now.sh?inline=%5CDelta%20x_%7B1%7D" style="display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=%5Ccdots%2C%20%5CDelta%20x_%7Bm%7D" style="display:inline-block;margin: 0;"/> 的二阶及高阶项。这时，函数 <img src="https://math.now.sh?inline=f%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 的偏导数 <img src="https://math.now.sh?inline=%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7B1%7D%7D%2C%20%5Ccdots%2C%20%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7Bm%7D%7D" style="display:inline-block;margin: 0;"/> 一定存在,</p>
<p>并且</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7B1%7D%7D%3DA_%7B1%7D%2C%20%5Cquad%20%5Ccdots%20%5Cquad%2C%20%5Cquad%20%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7Bm%7D%7D%3DA_%7Bm%7D%0A" /></p><p>全改变量 <img src="https://math.now.sh?inline=%5CDelta%20f%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 的线性主部</p>
<p style=""><img src="https://math.now.sh?from=A_%7B1%7D%20%5CDelta%20x_%7B1%7D%2B%5Ccdots%2BA_%7Bm%7D%20%5CDelta%20x_%7Bm%7D%3D%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7B1%7D%7D%20%5Cmathrm%7B~d%7D%20x_%7B1%7D%2B%5Ccdots%2B%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7Bm%7D%7D%20%5Cmathrm%7B~d%7D%20x_%7Bm%7D%0A" /></p><p>称为多变量函数 <img src="https://math.now.sh?inline=f%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 的全微分, 记为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7Bd%7D%20f%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%5Cright%29%3D%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7B1%7D%7D%20%5Cmathrm%7B~d%7D%20x_%7B1%7D%2B%5Ccdots%2B%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7Bm%7D%7D%20%5Cmathrm%7B~d%7D%20x_%7Bm%7D%0A" /></p><p><strong>多变量函数 <img src="https://math.now.sh?inline=f%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 在点 <img src="https://math.now.sh?inline=%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 可微分的充分条件是: 偏导数 <img src="https://math.now.sh?inline=%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7B1%7D%7D%2C%20%5Ccdots" style="display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7Bm%7D%7D" style="display:inline-block;margin: 0;"/> 均存在, 并且连续。</strong><br>
一阶实矩阵微分为、 矩阵的辨识提供了一种有效的方法。</p>
<h4 id="标量函数-f-boldsymbol-x-的梯度矩阵辩识">标量函数 <img src="https://math.now.sh?inline=f%28%5Cboldsymbol%7Bx%7D%29" style="display:inline-block;margin: 0;"/> 的梯度矩阵辩识</h4>
<p>考虑标量函数 <img src="https://math.now.sh?inline=f%28x%29" style="display:inline-block;margin: 0;"/>, 其变元向量 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%3D%5Cleft%5Bx_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%5Cright%5D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bm%7D" style="display:inline-block;margin: 0;"/> 。将变元向量的元素 <img src="https://math.now.sh?inline=x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D" style="display:inline-block;margin: 0;"/> 视为 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> 个变量, 利用式 (3.2.14), 可以直接引出以向量为变元的标量函数 <img src="https://math.now.sh?inline=f%28%5Cboldsymbol%7Bx%7D%29" style="display:inline-block;margin: 0;"/> 的全微分表达式</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathrm%7Bd%7D%20f%28%5Cboldsymbol%7Bx%7D%29%20%26%3D%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20x_%7B1%7D%7D%20%5Cmathrm%7B~d%7D%20x_%7B1%7D%2B%5Ccdots%2B%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20x_%7Bm%7D%7D%20%5Cmathrm%7B~d%7D%20x_%7Bm%7D%20%5C%5C%0A%26%3D%5Cleft%5B%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20x_%7B1%7D%7D%2C%20%5Ccdots%2C%20%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20x_%7Bm%7D%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathrm%7Bd%7D%20x_%7B1%7D%20%5C%5C%0A%5Cvdots%20%5C%5C%0A%5Cmathrm%7Bd%7D%20x_%7Bm%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A%5Cend%7Baligned%7D%0A" /></p><p>或简记为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7Bd%7D%20f%28%5Cboldsymbol%7Bx%7D%29%3D%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D%3D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D)%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%7D%0A" /></p><p>式中</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0A%5Cfrac%7B%5Cpartial%20f%28%5Cboldsymbol%7Bx%7D%29%7D%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%7D%3D%5Cleft%5B%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20x_%7B1%7D%7D%2C%20%5Ccdots%2C%20%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20x_%7Bm%7D%7D%5Cright%5D%20%5C%5C%0A%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D%3D%5Cleft%5B%5Cmathrm%7Bd%7D%20x_%7B1%7D%2C%20%5Ccdots%2C%20%5Cmathrm%7Bd%7D%20x_%7Bm%7D%5Cright%5D%5E%7B%5Cmathrm%7BT%7D%7D%0A%5Cend%7Bgathered%7D%0A" /></p><p>式 (3.2.16) 称为微分法则的向量形式, 它启示了一个重要的应用: 若令 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D%3D%5Cfrac%7B%5Cpartial%20f%28%5Cboldsymbol%7Bx%7D%29%7D%7B%5Cpartial%20%5Cboldsymbol%7Bx%5ET%7D%7D" style="display:inline-block;margin: 0;"/>, 则一阶微分可以写作迹函数形式 (第二个等号应用标量的迹等于本身)</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7Bd%7D%20f%28%5Cboldsymbol%7Bx%7D%29%3D%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BA%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D)%0A" /></p><p>这表明, 标量函数 <img src="https://math.now.sh?inline=f%28x%29" style="display:inline-block;margin: 0;"/> 的梯度矩阵与微分矩阵之间存在等价关系</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7Bd%7D%20f%28%5Cboldsymbol%7Bx%7D%29%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BA%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D)%20%5CLongleftrightarrow%20%5Cnabla_%7B%5Cboldsymbol%7Bx%7D%7D%20f(%5Cboldsymbol%7Bx%7D)%3D%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%7D%3D%5Cboldsymbol%7BA%5ET%7D%0A" /></p><p>换言之, 若函数 <img src="https://math.now.sh?inline=f%28%5Cboldsymbol%7Bx%7D%29" style="display:inline-block;margin: 0;"/> 的微分可以写作 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%20f%28%5Cboldsymbol%7Bx%7D%29%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BA%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D)" style="display:inline-block;margin: 0;"/>, 则矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 就是函数 <img src="https://math.now.sh?inline=f%28%5Cboldsymbol%7Bx%7D%29" style="display:inline-block;margin: 0;"/> 关于 其变元向量 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D" style="display:inline-block;margin: 0;"/> 的 梯度矩阵的转置。</p>
<p>因此，我们得到了一个计算梯度矩阵的有效方法:</p>
<p>(1) 求实值函数 <img src="https://math.now.sh?inline=f%28%5Cboldsymbol%7BX%7D%29" style="display:inline-block;margin: 0;"/> 相对于变元矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BX%7D" style="display:inline-block;margin: 0;"/> 的矩阵微分 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%20f%28%5Cboldsymbol%7BX%7D%29" style="display:inline-block;margin: 0;"/>, 并将其表示成规范形式 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%20f%28%5Cboldsymbol%7BX%7D%29%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BA%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D)" style="display:inline-block;margin: 0;"/>;<br>
(2) 实值函数 <img src="https://math.now.sh?inline=f%28%5Cboldsymbol%7BX%7D%29" style="display:inline-block;margin: 0;"/> 相对于 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 变元矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BX%7D" style="display:inline-block;margin: 0;"/> 的梯度矩阵等于 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%5ET%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>此时，考察二次型函数 <img src="https://math.now.sh?inline=f%28x%29%3Dx%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D" style="display:inline-block;margin: 0;"/>, 其中, <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 是一个正方的常数矩阵。首先将标量函数写成迹函数形式, 然后利用矩阵乘积的微分易得</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathrm%7Bd%7D%20f%28%5Cboldsymbol%7Bx%7D%29%20%26%3D%5Cmathrm%7Bd%7D%5Cleft(%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%5Cright)%5Cright)%3D%5Coperatorname%7Btr%7D%5Cleft%5B(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D)%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%2B%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D%5Cright%5D%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%5Cright)%2B%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D%5Cright)%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(%5B%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%5D%5E%7B%5Cmathrm%7BT%7D%7D%5Cright)%2B%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D%5Cright)%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D%5Cright)%2B%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D%5Cright)%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%5Cleft(%5Cboldsymbol%7BA%7D%2B%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%5Cright)%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>直接得二次型函数 <img src="https://math.now.sh?inline=f%28%5Cboldsymbol%7Bx%7D%29%3D%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D" style="display:inline-block;margin: 0;"/> 关于变元向量 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D" style="display:inline-block;margin: 0;"/> 的梯度向量为</p>
<p style=""><img src="https://math.now.sh?from=%5Cnabla_%7B%5Cboldsymbol%7Bx%7D%7D%5Cleft%28%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%5Cright%29%3D%5Cfrac%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%7D%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%7D%3D%5Cleft%5B%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%5Cleft(%5Cboldsymbol%7BA%7D%2B%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%5Cright)%5Cright%5D%5E%7B%5Cmathrm%7BT%7D%7D%3D%5Cleft(%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%2B%5Cboldsymbol%7BA%7D%5Cright)%20%5Cboldsymbol%7Bx%7D%0A" /></p><p>显然, 若 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 为对称矩阵, 则 <img src="https://math.now.sh?inline=%5Cnabla_%7B%5Cboldsymbol%7Bx%7D%7D%5Cleft%28%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%5Cright%29%3D%5Cfrac%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%7D%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%7D%3D2%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D" style="display:inline-block;margin: 0;"/> 。</p>
<h4 id="矩阵的标量函数：迹">矩阵的标量函数：迹</h4>
<p>根据<strong>迹</strong>的性质，我们可以得到：</p>
<p>(1) 标量函数 <img src="https://math.now.sh?inline=f%28%5Cboldsymbol%7BX%7D%29" style="display:inline-block;margin: 0;"/> 总可以写成迹函数的形式, 因为 <img src="https://math.now.sh?inline=f%28%5Cboldsymbol%7BX%7D%29%3D%5Coperatorname%7Btr%7D(f(%5Cboldsymbol%7BX%7D))" style="display:inline-block;margin: 0;"/>;<br>
(2) 无论 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D" style="display:inline-block;margin: 0;"/> 出现在迹函数内的任何位置, 总可以通过迹函数的性质 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5B%5Cboldsymbol%7BA%7D%28%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D%29%20%5Cboldsymbol%7BB%7D%5D%3D" style="display:inline-block;margin: 0;"/> <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BB%7D%20%5Cboldsymbol%7BA%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D%29" style="display:inline-block;margin: 0;"/>, 将 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D" style="display:inline-block;margin: 0;"/> 写到迹函数变量的最右端, 从而得到迹函数微分矩阵的规范形式。<br>
(3) 对于 <img src="https://math.now.sh?inline=%28%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D%29%5E%7B%5Cmathrm%7BT%7D%7D" style="display:inline-block;margin: 0;"/>, 总可以通过迹函数的性质 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%5B%5Cboldsymbol%7BA%7D%28%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D%29%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BB%7D%5Cright%5D%3D%5Cboldsymbol%7B%5Coperatorname%7Btr%7D(B%5E%7BT%7DdXA%5ET)%7D%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BB%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D%5Cright)" style="display:inline-block;margin: 0;"/> , 写成迹函数微分矩阵的规范形式。</p>
<h1>推导正规方程组</h1>
<p>回到我们的问题，这里我们将最小二乘法的损失函数展开，得到</p>
<p style=""><img src="https://math.now.sh?from=J%28%5Cboldsymbol%7B%5Cbeta%7D%29%3D%5Cboldsymbol%7B(X%20%5Cbeta-y)%5E%7B%5Cmathrm%7BT%7D%7D(X%20%5Cbeta-y)%7D%3D%5Cboldsymbol%7B(%5Cbeta%5E%7B%5Cmathrm%7BT%7D%7D%20X%5E%7B%5Cmathrm%7BT%7D%7D%20-y%5E%7B%5Cmathrm%7BT%7D%7D)(X%20%5Cbeta-y)%7D%3D%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D-%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7By%7D-%5Cboldsymbol%7By%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7By%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7By%7D%0A" /></p><p>注意到，<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7By%7D%20%5Ctext%7B%20%E4%B8%8E%20%7D%20%5Cboldsymbol%7By%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 二者互为转置，并且二者均为标量，因此二者相等。损失函数写为</p>
<p style=""><img src="https://math.now.sh?from=J%28%5Cboldsymbol%7B%5Cbeta%7D%29%3D%5Cboldsymbol%7B(X%20%5Cbeta-y)%5E%7B%5Cmathrm%7BT%7D%7D(X%20%5Cbeta-y)%7D%3D%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D-2%5Cboldsymbol%7By%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7By%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7By%7D%0A" /></p><p>求 <img src="https://math.now.sh?inline=J%28%5Cboldsymbol%7B%5Cbeta%7D%29" style="display:inline-block;margin: 0;"/> 相对于 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的导数, 并令其结果等于零</p>
<p>求梯度向量的过程需要用到上面提到的矩阵微分的性质。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7Bd%7D%20f%28%5Cboldsymbol%7B%5Cbeta%7D%29%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BX%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%20%5CLongleftrightarrow%20%5Cnabla_%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%20f(%5Cboldsymbol%7B%5Cbeta%7D)%3D%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%0A" /></p><p>证明过程如下（这里我们先求解两个子式的微分，注意到这两个子式也是标量，最后一个子式 <img src="https://math.now.sh?inline=%5Cboldsymbol%7By%5ET%20y%7D" style="display:inline-block;margin: 0;"/> 不是关于 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的式子，因此其微分矩阵为 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B0%7D" style="display:inline-block;margin: 0;"/> 矩阵）</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26d%5Cleft%28%5Cboldsymbol%7B%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X%20%5Cbeta%7D%5Cright%29%5C%5C%0A%26%3Dd%5Cleft(%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7B%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X%20%5Cbeta%7D%5Cright)%5Cright)%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(d%5Cleft(%5Cboldsymbol%7B%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X%20%5Cbeta%7D%5Cright)%5Cright)%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(d%5Cboldsymbol%7B%5Cleft(%5Cbeta%5E%7BT%7D%5Cright)%20X%5E%7BT%7D%20X%20%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X%20d(%5Cbeta)%7D%5Cright)%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7Bd%5Cleft(%5Cbeta%5E%7BT%7D%5Cright)%20X%5E%7BT%7D%20X%20%5Cbeta%7D%5Cright)%2B%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7B%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X%20d(%5Cbeta)%7D%5Cright)%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7B%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X%20d(%5Cbeta)%7D%5Cright)%2B%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7B%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X%20d(%5Cbeta)%7D%5Cright)%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(2%5Cboldsymbol%7B%20%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X%20d(%5Cbeta)%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%20d%5Cleft%28%5Cboldsymbol%7By%5E%7BT%7D%20X%20%5Cbeta%7D%5Cright%29%20%5C%5C%0A%3D%26%20d%5Cleft(t%20r%5Cleft(%5Cboldsymbol%7By%5E%7BT%7D%20X%20%5Cbeta%7D%5Cright)%5Cright)%20%5C%5C%0A%3D%26%20%5Coperatorname%7Btr%7D%5Cleft(d%5Cleft(%5Cboldsymbol%7By%5E%7BT%7D%20X%20%5Cbeta%7D%5Cright)%5Cright)%20%5C%5C%0A%3D%26%20%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7By%5E%7BT%7D%20X%20d(%5Cbeta)%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cboldsymbol%7Bd%20%5Cbeta%7D%20%26%3Dd%5Cleft%28%5Cboldsymbol%7B%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X%20%5Cbeta-2%20y%5E%7BT%7D%20X%20%5Cbeta%2By%5E%7BT%7D%20y%7D%5Cright%29%20%5C%5C%0A%26%3Dd%5Cleft(%5Cboldsymbol%7B%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X%20%5Cbeta%7D%5Cright)-2%20d%20%5Cleft(%5Cboldsymbol%7By%5E%7BT%7D%20X%20%5Cbeta%7D%5Cright)%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(2%20%5Cboldsymbol%7B%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X%20d(%5Cbeta)%7D%5Cright)-2%20tr%5Cleft(%5Cboldsymbol%7By%5E%7BT%7D%20X%20d(%5Cbeta)%7D%5Cright)%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cleft(%5Cboldsymbol%7B2%20%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X-2%20y%5E%7BT%7D%20X%7D%5Cright)%20d(%5Cboldsymbol%7B%5Cbeta%7D)%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cboldsymbol%7B%5Cnabla_%7B%5Cbeta%7D%20%5Cbeta%7D%20%26%3D%5Cboldsymbol%7B%5Cleft%282%20%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X-2%20y%5E%7BT%7D%20X%5Cright%29%5E%7BT%7D%7D%20%5C%5C%0A%26%3D2%5Cboldsymbol%7B%5Cleft(X%5E%7BT%7D%20X%20%5Cbeta-X%5E%7BT%7D%20y%5Cright)%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>也就是说, 解 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 必然满足</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7By%7D%0A" /></p><p>这就是线性回归的<strong>正规方程组</strong>。</p>
<p>如果 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BX%5E%7B%5Cmathrm%7BT%7D%7D%20X%7D" style="display:inline-block;margin: 0;"/> 非奇异,  该方程有唯一的解</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Cbeta%7D_%7B%5Cmathrm%7BLS%7D%7D%3D%5Cleft%28%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BX%7D%5Cright%29%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7By%7D%0A" /></p><h1>最小二乘估计值的性质</h1>
<p>这一部分内容来自于《linear models in statistics》<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="《linear models in statistics》
">[3]</span></a></sup></p>
<p>如果 <img src="https://math.now.sh?inline=E%28%5Cmathbf%7By%7D%29%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> ，那么最小二乘估计值 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的无偏估计值。</p>
<p>证明：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%28%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29%20%26%3DE%5Cleft%5B%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%5D%20%5C%5C%0A%26%3D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20E(%5Cmathbf%7By%7D)%20%5C%5C%0A%26%3D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20%5C%5C%0A%26%3D%5Cboldsymbol%7B%5Cbeta%7D%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>如果 <img src="https://math.now.sh?inline=%5Coperatorname%7Bcov%7D%28%5Cmathbf%7By%7D%29%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ，那么最小二乘估计值 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 的协方差矩阵为 <img src="https://math.now.sh?inline=%5Csigma%5E%7B2%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>证明：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Bcov%7D%28%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29%20%26%3D%5Coperatorname%7Bcov%7D%5Cleft%5B%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%5D%20%5C%5C%0A%26%3D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Coperatorname%7Bcov%7D(%5Cmathbf%7By%7D)%5Cleft%5B%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%5E%7B%5Cprime%7D%20%5C%5C%0A%26%3D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cleft(%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D%5Cright)%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5C%5C%0A%26%3D%5Csigma%5E%7B2%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5C%5C%0A%26%3D%5Csigma%5E%7B2%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%0A%5Cend%7Baligned%7D%0A" /></p><p><strong>定理</strong>：<strong>(Gauss – Markov Theorem)</strong>，如果同时满足  <img src="https://math.now.sh?inline=E%28%5Cmathbf%7By%7D%29%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/>  ， <img src="https://math.now.sh?inline=%5Coperatorname%7Bcov%7D%28%5Cmathbf%7By%7D%29%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ，那么最小二乘估计值 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7Bj%7D%7D" style="display:inline-block;margin: 0;"/>  , <img src="https://math.now.sh?inline=j%3D0%2C1%2C%20%5Cldots%2C%20k" style="display:inline-block;margin: 0;"/> 在所有的线性无偏估计值中具有<strong>最小的方差</strong>。</p>
<p>证明：</p>
<p>注意这里的“线性”指的是 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7Bj%7D%7D" style="display:inline-block;margin: 0;"/> 是关于  <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的线性变换。假设我们有一个 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的无偏线性估计值为 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BAy%7D" style="display:inline-block;margin: 0;"/>  ，我们想要找到一个矩阵  <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 使得  <img src="https://math.now.sh?inline=%5Cboldsymbol%7BAy%7D" style="display:inline-block;margin: 0;"/>  的方差最小。</p>
<p>因为  <img src="https://math.now.sh?inline=%5Cboldsymbol%7BAy%7D" style="display:inline-block;margin: 0;"/> 无偏，我们有 <img src="https://math.now.sh?inline=E%28%5Cmathbf%7BA%20y%7D%29%3D%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 。根据假设 <img src="https://math.now.sh?inline=E%28%5Cmathbf%7By%7D%29%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> ，我们可以将其写为</p>
<p style=""><img src="https://math.now.sh?from=E%28%5Cmathbf%7BA%20y%7D%29%3D%5Cmathbf%7BA%7D%20E(%5Cmathbf%7By%7D)%3D%5Cmathbf%7BA%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cboldsymbol%7B%5Cbeta%7D%0A" /></p><p>该式需要对所有可能的  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 均成立（这句话我理解了半天， <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 是由未知参数组成的向量，既然是未知的参数，那就是说每个参数可能是任意实数，因此 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/>  可以是欧几里得空间中任意一个点），那么存在</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%20%5Cmathbf%7BX%7D%3D%5Cmathbf%7BI%7D%0A" /></p><p><img src="https://math.now.sh?inline=%5Cboldsymbol%7BAy%7D" style="display:inline-block;margin: 0;"/> 的协方差矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Bcov%7D%28%5Cmathbf%7BA%20y%7D%29%3D%5Cmathbf%7BA%7D%5Cleft(%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D%5Cright)%20%5Cmathbf%7BA%7D%5E%7B%5Cprime%7D%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7BA%7D%20%5Cmathbf%7BA%7D%5E%7B%5Cprime%7D%0A" /></p><p><img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D_%7Bj%7D" style="display:inline-block;margin: 0;"/> 的方差为协方差矩阵的对角线元素，因此我们需要挑一个矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/>, 使得 $ \mathbf{A} \mathbf{A}^{\prime}$ 矩阵的对角线元素最小。为了让其与最小二乘估计值有关系，我们将其写作</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BA%7D%20%5Cmathbf%7BA%7D%5E%7B%5Cprime%7D%20%26%3D%20%5Cleft%5B%5Cmathbf%7BA%7D-%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%2B%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%5Cleft%5B%5Cmathbf%7BA%7D-%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%2B%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%5E%7B%5Cprime%7D%20%5C%5C%0A%26%3D%20%5Cleft%5B(%5Cmathbf%7BA%7D-%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20)%2B%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%5Cleft%5B(%5Cmathbf%7BA%7D%5E%7B%5Cprime%7D-%20%5Cmathbf%7BX%7D%20%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D)%20%2B%20%20%5Cmathbf%7BX%7D%20%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%5Cright%5D%20%5C%5C%0A%26%3D%5Cleft%5B%5Cmathbf%7BA%7D-%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%5Cleft%5B%5Cmathbf%7BA%7D-%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%5E%7B%5Cprime%7D%20%2B%20%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%26%20%20%5Cbecause%20%5Cmathbf%7BA%7D%20%5Cmathbf%7BX%7D%3D%5Cmathbf%7BI%7D%20%5C%5C%20%0A%5Cend%7Baligned%7D%0A" /></p><p>因为 <img src="https://math.now.sh?inline=%5Cleft%5B%5Cmathbf%7BA%7D-%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%5Cleft%5B%5Cmathbf%7BA%7D-%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 是一个半正定矩阵（<img src="https://math.now.sh?inline=%5Cmathbf%7BAA'%7D" style="display:inline-block;margin: 0;"/> 是一个半正定矩阵 ），根据半正定矩阵的性质，其对角线元素大于等于 0 。因此，只有当我们设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%3D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> （此时仍满足 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20X%7D%3D%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ）时，上式的对角线元素才均为 0 ，此时 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/>  的最小方差估计值为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%20y%7D%3D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A" /></p><p>该式正好就是最小二乘估计值。</p>
<p>Gauss – Markov 定理有时也表述为，如果满足  <img src="https://math.now.sh?inline=E%28%5Cmathbf%7By%7D%29%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/>  ， <img src="https://math.now.sh?inline=%5Coperatorname%7Bcov%7D%28%5Cmathbf%7By%7D%29%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ，那么最小二乘估计值 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7Bj%7D%7D" style="display:inline-block;margin: 0;"/>  , <img src="https://math.now.sh?inline=j%3D0%2C1%2C%20%5Cldots%2C%20k" style="display:inline-block;margin: 0;"/> 称为<strong>最佳线性无偏估计值</strong> (<em>best linear unbiased estimators</em>, BLUE)。这里最佳指最小方差，线性指  <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7Bj%7D%7D" style="display:inline-block;margin: 0;"/> 是  <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的线性函数。</p>
<p>Gauss – Markov 定理的最显著特点是<strong>其对任意分布均成立</strong>，这里并不要求满足正态分布。但是如果满足上面的两个假设，那么此时最小二乘估计值可能有偏，或者其真实方差大于估计方差。</p>
<p>Gauss – Markov 定理可以轻松推广到  <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7Bj%7D%7D" style="display:inline-block;margin: 0;"/>  的线性组合。</p>
<p><strong>推论</strong>：如果满足  <img src="https://math.now.sh?inline=E%28%5Cmathbf%7By%7D%29%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/>  ， <img src="https://math.now.sh?inline=%5Coperatorname%7Bcov%7D%28%5Cmathbf%7By%7D%29%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ，那么 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的最小线性无偏估计值就是 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/>，其中 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 是最小二乘估计值。</p>
<p>最小二乘估计值的最后一个性质是，特征的范围 (<em>scale of x</em>) 不会影响预测结果，存在以下定理。</p>
<p><strong>定理</strong>：如果 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D%3D%5Cleft%281%2C%20x_%7B1%7D%2C%20%5Cldots%2C%20x_%7Bk%7D%5Cright%29%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathbf%7Bz%7D%3D%5Cleft%281%2C%20c_%7B1%7D%20x_%7B1%7D%2C%20%5Cldots%2C%20c_%7Bk%7D%20x_%7Bk%7D%5Cright%29%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，那么 <img src="https://math.now.sh?inline=%5Chat%7By%7D%20%3D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bx%7D%3D%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D_%7Bz%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bz%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D_%7Bz%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 关于 <img src="https://math.now.sh?inline=%5Cmathbf%7Bz%7D" style="display:inline-block;margin: 0;"/> 的最小二乘估计参数。</p>
<p>我们可以将 <img src="https://math.now.sh?inline=%5Cmathbf%7Bz%7D" style="display:inline-block;margin: 0;"/> 重写为 <img src="https://math.now.sh?inline=%5Cmathbf%7Bz%7D%3D%5Cmathbf%7BD%7D%20%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D%3D%5Coperatorname%7Bdiag%7D%5Cleft%281%2C%20c_%7B1%7D%2C%20c_%7B2%7D%2C%20%5Cldots%2C%20c_%7Bk%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 。那么存在 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D%3D%5Cmathbf%7BX%20D%7D" style="display:inline-block;margin: 0;"/> ，我们将其带入到 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D_%7Bz%7D%3D%5Cleft%28%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D_%7Bz%7D%20%26%3D%5Cleft%28%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5C%5C%0A%26%3D%5Cleft%5B(%5Cmathbf%7BX%20D%7D)%5E%7B%5Cprime%7D(%5Cmathbf%7BX%20D%7D)%5Cright%5D%5E%7B-1%7D(%5Cmathbf%7BX%20D%7D)%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%26%3D%5Cleft%5B%5Cmathbf%7BD%7D(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cmathbf%7BX%7D)%5Cmathbf%7BD%7D)%5Cright%5D%5E%7B-1%7D%20%5Cmathbf%7BD%7D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BD%7D%5E%7B-1%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%20(%5Cmathbf%7BD%7D%5E%7B-1%7D%20%5Cmathbf%7BD%7D)%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%20%5C%5C%0A%26%3D%5Cmathbf%7BD%7D%5E%7B-1%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%20%5C%5C%0A%26%3D%5Cmathbf%7BD%7D%5E%7B-1%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 为  <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 关于 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> 的最小二乘估计参数。那么</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D_%7Bz%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bz%7D%3D%5Cleft%28%5Cmathbf%7BD%7D%5E%7B-1%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5Cright%29%5E%7B%5Cprime%7D%20%5Cmathbf%7BD%7D%20%5Cmathbf%7Bx%7D%3D%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bx%7D%0A" /></p><p>得证。</p>
<p>接下来，我们可以将这个定理推广到任何关于 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/>  变量的满秩线性变换中。</p>
<p><strong>推论</strong>：当新变量是关于 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/>  变量的满秩线性变换时，预测值 <img src="https://math.now.sh?inline=%5Chat%7By%7D" style="display:inline-block;margin: 0;"/>  不变</p>
<p>证明：我们可以将 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/>  变量的满秩线性变换表示为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BZ%7D%3D%5Cmathbf%7BX%20K%7D%3D%5Cleft%28%5Cmathbf%7Bj%7D%2C%20%5Cmathbf%7BX%7D_%7B1%7D%5Cright%29%5Cleft(%5Cbegin%7Barray%7D%7Bcc%7D%0A1%20%26%20%5Cmathbf%7B0%7D%5E%7B%5Cprime%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BK%7D_%7B1%7D%0A%5Cend%7Barray%7D%5Cright)%3D%5Cleft(%5Cmathbf%7Bj%7D%2B%5Cmathbf%7BX%7D_%7B1%7D%20%5Cmathbf%7B0%7D%2C%20%5Cmathbf%7Bj%7D%20%5Cmathbf%7B0%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7BX%7D_%7B1%7D%20%5Cmathbf%7BK%7D_%7B1%7D%5Cright)%3D%5Cleft(%5Cmathbf%7Bj%7D%2C%20%5Cmathbf%7BX%7D_%7B1%7D%20%5Cmathbf%7BK%7D_%7B1%7D%5Cright)%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 是一个非奇异矩阵（<img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D_%7B1%7D%20%5Cmathbf%7BK%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 的每一列新特征均是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 的列的线性组合），并且</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D_%7B1%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D%0Ax_%7B11%7D%20%26%20x_%7B12%7D%20%26%20%5Cldots%20%26%20x_%7B1%20k%7D%20%5C%5C%0Ax_%7B21%7D%20%26%20x_%7B22%7D%20%26%20%5Cldots%20%26%20x_%7B2%20k%7D%20%5C%5C%0A%5Cvdots%20%26%20%5Cvdots%20%26%20%26%20%5Cvdots%20%5C%5C%0Ax_%7Bn%201%7D%20%26%20x_%7Bn%202%7D%20%26%20%5Cldots%20%26%20x_%7Bn%20k%7D%0A%5Cend%7Barray%7D%5Cright%29%0A" /></p><p>这里我们将 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D" style="display:inline-block;margin: 0;"/> 拆分开，这样 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 只包含 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 变量。此时 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D_%7Bz%7D" style="display:inline-block;margin: 0;"/> 变成</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D_%7Bz%7D%26%3D%5Cleft%28%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%26%3D%20((%5Cmathbf%7BX%20K%7D)'%5Cmathbf%7BX%20K%7D)%5E%7B-1%7D%20(%5Cmathbf%7BX%20K%7D)'%20%5Cmathbf%7By%7D%5C%5C%0A%26%3D%20(%5Cmathbf%7BK%7D'%20%5Cmathbf%7BX%7D'%20%5Cmathbf%7BX%20K%7D)%5E%7B-1%7D%20%5Cmathbf%7BK%7D'%20%5Cmathbf%7BX%7D'%20%5Cmathbf%7By%7D%5C%5C%0A%26%3D%20%5Cmathbf%7BK%7D%5E%7B-1%7D%20(%5Cmathbf%7BX%7D'%20%5Cmathbf%7BX%7D)%5E%7B-1%7D%20%5Cmathbf%7BK%7D%5E%7B-T%7D%20%5Cmathbf%7BK%7D'%20%5Cmathbf%7BX%7D'%20%5Cmathbf%7By%7D%5C%5C%0A%26%3D%20%5Cmathbf%7BK%7D%5E%7B-1%7D%20(%5Cmathbf%7BX%7D'%20%5Cmathbf%7BX%7D)%5E%7B-1%7D%20%20%5Cmathbf%7BX%7D'%20%5Cmathbf%7By%7D%5C%5C%0A%26%3D%5Cmathbf%7BK%7D%5E%7B-1%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7Bx%7D%7D%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7By%7D%3D%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D_%7Bz%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bz%7D%3D%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D_%7B%5Cmathbf%7Bx%7D%7D%5E%7B%5Cprime%7D%5Cmathbf%7Bx%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7Bz%7D%3D%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> （这里有一点绕，主要在于 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的一行组成的列向量，不是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的一列，违背了一般的向量符号表示方法，也就是这里  <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/>  是表示某一个观测值的特征组成的列向量。根据 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D%3D%5Cmathbf%7BX%20K%7D" style="display:inline-block;margin: 0;"/> ，有 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D'%3D%5Cmathbf%7BK'%20X'%7D" style="display:inline-block;margin: 0;"/> ，因此  <img src="https://math.now.sh?inline=%5Cmathbf%7Bz%7D%3D%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> ）。</p>
<p>得证。</p>
<p>除了预测值 <img src="https://math.now.sh?inline=%5Chat%7By%7D" style="display:inline-block;margin: 0;"/>  ，样本方差 <img src="https://math.now.sh?inline=s%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 同样不受特征的范围 (<em>scale of x</em>) 的影响。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">张贤达《矩阵分析与应用（第二版）》<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://zhuanlan.zhihu.com/p/305171795<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">《linear models in statistics》<a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>统计SNP基因型频率及MAF代码实现</title>
    <url>/posts/636ff051/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近准备一些材料时需要计算每个SNP三种分型的基因型频率和MAF，plink 软件只给出 MAF，因此写了一个简单的代码实现它。</p>
<span id="more"></span>
<h1>使用软件</h1>
<ul>
<li>python 3.8 及以上版本，事先安装好 Numpy 模块</li>
</ul>
<h1>背景知识</h1>
<p>假设一个SNP，它有两种碱基 A 和 T，那么就有三种可能的基因型 AA, AT, TT。</p>
<p>假设某个群体样本数目为 100 ，在这个SNP 中有 5 个样本分型失败，有 20 个样本分型为 AA, 有 30 个样本分型为 AT，有45 个样本分型为 TT，计算三种分型的基因型频率如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AP%28AA%29%20%3D%20%5Cfrac%7BAA%7D%7BAA%2BAT%2BTT%7D%20%3D%20%5Cfrac%7B20%7D%7B95%7D%20%3D%200.211%20%5C%5C%0AP(AT)%20%3D%20%5Cfrac%7BAT%7D%7BAA%2BAT%2BTT%7D%20%3D%20%5Cfrac%7B30%7D%7B95%7D%20%3D%200.316%20%5C%5C%0AP(TT)%20%3D%20%5Cfrac%7BTT%7D%7BAA%2BAT%2BTT%7D%20%3D%20%5Cfrac%7B45%7D%7B95%7D%20%3D%200.474%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>注意，分母计算总数时需要剔除分型失败的样本，三种基因型频率相加为1。</p>
<p>现在再看MAF计算方式，MAF 是最小等位基因频率的缩写。因此，我们可以将 P(A) 和 P(T) 都计算出来，看看哪个数值更小，那就是MAF</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AP%28A%29%20%3D%20%5Cfrac%7B2*P(AA)%2BP(AT)%7D%7B2%7D%20%3D%200.368%20%5C%5C%0AP(T)%20%3D%20%5Cfrac%7B2*P(TT)%2BP(AT)%7D%7B2%7D%20%3D%200.632%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>从上面三种基因型频率结果可以看出，A 是较小的等位基因，而 T 是较大的等位基因。判断理由很简单，因为 P(AT) 不影响 P(A) 和 P(T) 的相对大小，只要看 P(AA) 和 P(TT) 哪个更小，哪个就是最小等位基因了。</p>
<h1>输入文件</h1>
<p>使用 plink 软件的 <code>recodeA</code> 命令生成的 raw 文件。这里每个SNP占据一列，值为最小等位基因的数目（0 1 2），缺失值记为 NA。</p>
<h1>输出文件</h1>
<p>输出文件共5列，第一列为SNP名称，第二列为较小等位基因纯和子的基因型频率，第三列为杂合子基因型频率，第四列为另一类纯和子基因型频率，第五列为MAF。</p>
<table>
<thead>
<tr>
<th>seq-rs80960919</th>
<th>0.119152</th>
<th>0.497401</th>
<th>0.383447</th>
<th>0.367853</th>
</tr>
</thead>
<tbody>
<tr>
<td>seq-rs81350349</td>
<td>0.195922</td>
<td>0.530588</td>
<td>0.273491</td>
<td>0.461216</td>
</tr>
<tr>
<td>seq-rs81349911</td>
<td>0.2088</td>
<td>0.5384</td>
<td>0.2528</td>
<td>0.478</td>
</tr>
</tbody>
</table>
<h1>运行代码</h1>
<p>代码文件见：<a href="https://github.com/VincereZhou/code_backup/blob/master/genotype_frequency.py">genotype_frequency.py</a></p>
<p>将输入文件和本程序放在同一文件夹下，运行命令示范如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python genotype_frequency.py A.raw A_frequency.txt</span><br></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<p><code>A.raw</code>: 输入文件名称</p>
<p><code>A_frequency.txt</code>: 结果文件名称</p>
<p>运行结束后，生成以第二个参数为名称的结果文件</p>
<h1>代码说明</h1>
<h2 id="替换分型缺失值">替换分型缺失值</h2>
<p>首先我用 linux 的 sed 命令来精准查找 NA，替换为 3，生成中间文件 temp.raw。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os,sys</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">raw_file_name = sys.argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">f&quot;sed &#x27;s/\&lt;NA\&gt;/3/g&#x27; <span class="subst">&#123;raw_file_name&#125;</span> &gt; temp.raw&quot;</span>) <span class="comment"># 改为精准匹配</span></span><br></pre></td></tr></table></figure>
<h2 id="读取raw文件">读取raw文件</h2>
<p>首先从标题中提取 SNP 名称</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">raw_file = <span class="built_in">open</span>(<span class="string">&quot;temp.raw&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">raw_file_title = raw_file.readline().split() <span class="comment">#剔除标题</span></span><br><span class="line">title_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> raw_file_title[<span class="number">6</span>:]:</span><br><span class="line">    title_list.append(i[:-<span class="number">2</span>]) <span class="comment"># snp 名称列表</span></span><br></pre></td></tr></table></figure>
<p>之后将基因型信息存在到一个二维数组 array1 中，每一行表示一个样本，每一列表示一个SNP</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">raw_list=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> raw_file:</span><br><span class="line">    f = i.split()</span><br><span class="line">    raw_list.append(f[<span class="number">6</span>:])</span><br><span class="line">    </span><br><span class="line">raw_file.close()</span><br><span class="line"></span><br><span class="line">array1 = np.array(raw_list, dtype=np.int8)</span><br></pre></td></tr></table></figure>
<h2 id="统计基因型频率和MAF">统计基因型频率和MAF</h2>
<p>首先统计每列SNP中 2,1, 0 三种分型的数目，各自除以三种分型总数，便得到了三种基因型频率。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计三种基因型数据</span></span><br><span class="line"></span><br><span class="line">p_array = (array1==<span class="number">2</span>).<span class="built_in">sum</span>(axis=<span class="number">0</span>) <span class="comment"># 按列求和, 较小等位基因的纯合子</span></span><br><span class="line">h_array = (array1==<span class="number">1</span>).<span class="built_in">sum</span>(axis=<span class="number">0</span>) <span class="comment"># 按列求和</span></span><br><span class="line">r_array = (array1==<span class="number">0</span>).<span class="built_in">sum</span>(axis=<span class="number">0</span>) <span class="comment"># 按列求和</span></span><br><span class="line"></span><br><span class="line">p_rate = p_array/(p_array+h_array+r_array)</span><br><span class="line">h_rate = h_array/(p_array+h_array+r_array)</span><br><span class="line">r_rate = r_array/(p_array+h_array+r_array)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根据基因型频率，计算MAF</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">maf_rate = (<span class="number">2</span>*p_rate + h_rate)/<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="写入结果文件">写入结果文件</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写入结果文件</span></span><br><span class="line">out_file = <span class="built_in">open</span>(sys.argv[<span class="number">2</span>],<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">snp_num = <span class="built_in">len</span>(title_list)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(snp_num):</span><br><span class="line">    out_file.write(title_list[i]+<span class="string">&quot;\t&quot;</span>+<span class="built_in">str</span>(p_rate[i])+<span class="string">&quot;\t&quot;</span>+<span class="built_in">str</span>(h_rate[i])+<span class="string">&quot;\t&quot;</span>+<span class="built_in">str</span>(r_rate[i])+<span class="string">&quot;\t&quot;</span>+<span class="built_in">str</span>(maf_rate[i])+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">out_file.close()</span><br></pre></td></tr></table></figure>
<p>最后，剔除中间文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.system(<span class="string">&quot;rm temp.raw&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1>小结</h1>
<p>这个代码中计算的MAF 和 Plink 软件计算的 MAF 比对过，是一样的。</p>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>吴恩达机器学习笔记</title>
    <url>/posts/a473f09a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>吴恩达老师的课确实详细易懂，就是感觉 SVM 部分没太听清楚。</p>
<p>感谢吴恩达老师！之前觉得好长好啰嗦，听完以后我想说吴老师不要走，我还要听课。</p>
<span id="more"></span>
<h1>2 单变量线性回归</h1>
<h2 id="梯度下降">梯度下降</h2>
<h3 id="所有参数应该同时更新">所有参数应该同时更新</h3>
<p><img src="1.png" alt="1"></p>
<h2 id="“Batch”-Gradient-Descent">“Batch” Gradient Descent</h2>
<p>普通的梯度下降也成为 “Batch” Gradient Descent，定义为每一步迭代都使用<strong>训练集的全部数据</strong>。</p>
<h1>5 多变量线性回归</h1>
<p>线性回归可以写成向量的形式，<strong>θ<sup>T</sup>X</strong> (假设 x<sub>0</sub> = 1)</p>
<p><img src="2.png" alt="1"></p>
<h2 id="多元梯度下降">多元梯度下降</h2>
<p>多元梯度下降如下，和单变量差不多。</p>
<p><img src="3.png" alt="1"></p>
<h2 id="特征缩放">特征缩放</h2>
<p>如果特征的范围不同，代价函数的等高线就是一个<strong>很扁的椭圆</strong>，下降速度很慢。如果特征的范围都差不多，比如均在[0,1]范围内，则等高线就是一个圆形，梯度下降会始终沿着指向圆心的方向。</p>
<p><img src="4.png" alt="1"></p>
<p>一般来说，我们会将特征缩放到大概 <strong>-1 到 1</strong> 的范围。</p>
<h3 id="均值归一化-Mean-normalization">均值归一化 (Mean normalization)</h3>
<p>中心化：将每个值减去均值，使得特征的均值为0。<strong>特征缩放不需要太精确，只需要将不同的特征调整为近似的范围即可</strong>。</p>
<p>下式中分母可以是标准差，也可以是最大值减去最小值得到的范围。</p>
<p><img src="5.png" alt="1"></p>
<p>查了一个<a href="https://medium.com/analytics-vidhya/mean-normalization-and-feature-scaling-a-simple-explanation-3b9be7bfd3e8">网页资料</a>，均值标准化 (Mean normalization) 一般分母是除以范围，公式如下</p>
<p style=""><img src="https://math.now.sh?from=x%5E%7B%5Cprime%7D%3D%5Cfrac%7Bx-%5Cmu%7D%7B%5Cmax%20%28x%29-%5Cmin%20(x)%7D%0A" /></p><p>如果除以标准差，则称为<strong>标准化(Standardization)</strong> ，公式如下</p>
<p style=""><img src="https://math.now.sh?from=x%5E%7B%5Cprime%7D%3D%5Cfrac%7Bx-%5Cmu%7D%7B%5Csigma%7D%0A" /></p><h2 id="学习率">学习率</h2>
<p>通过查看每次迭代 J(θ) 的变化，确保梯度下降方法正确运行（正常情况下，每一次迭代代价函数都在下降）。</p>
<p>通过给定ε (如 10<sup>-3</sup> ) , 如果 J(θ) 在一次迭代后下降幅度低于 ε ，则判定收敛，但有时可能人手动判断比较好。</p>
<p>如果每次迭代，代价函数不是一直下降，那么就<strong>降低你的学习率</strong>。下图中可以通过尝试不同的学习率，来找到一个合适的值。</p>
<p><img src="6.png" alt="1"></p>
<h2 id="多项式拟合">多项式拟合</h2>
<p>添加二项式、三项式等，注意如果要用<strong>梯度下降</strong>，这里需要进行<strong>特征缩放</strong>。</p>
<h2 id="正规方程">正规方程</h2>
<p>除了梯度下降，我们还可以用正规方程来对线性回归求解。</p>
<p>简单的话，就是求<strong>导数/偏导数为0</strong>的一组参数。</p>
<p>计算公式如下（缺证明）</p>
<p><img src="7.png" alt="1"></p>
<p>如果你用正规方程求解，<strong>不需要做特征缩放</strong>。</p>
<h3 id="何时用特征下降，何时用正规方程">何时用特征下降，何时用正规方程</h3>
<p>当<strong>特征数量很多</strong>时，特征下降方法可以正常运行，但是正规方程速度很慢，因为<strong>需要对 (X<sup>T</sup>X) 进行求逆</strong>（求逆的计算量一般以矩阵维度的三次方增长，即 O(n<sup>3</sup>) ）。</p>
<p>一般来说，如果特征数量不超过一万，倾向于使用正规方程，反之使用梯度下降。</p>
<p><img src="8.png" alt="1"></p>
<h3 id="正规方程在矩阵不可逆情况下的求解">正规方程在矩阵不可逆情况下的求解</h3>
<p>问题：如果  (X<sup>T</sup>X) 不可逆怎么办？</p>
<p>如果你在 Octave 使用 <code>pinv()</code> 求逆（<code>pinv()</code> 和 <code>inv()</code> ），你永远可以得到一个解（伪逆函数）。</p>
<p>一般来说不会出现不可逆的情况，如果出现了可能的原因如下：</p>
<ul>
<li>
<p>冗余的特征（线性相关的特征）</p>
<p>例如 x<sub>1</sub> 是以平方英尺为单位的面积，x<sub>2</sub> 是以平方米为单位的面积，很明显这两个特征信息是一样的。</p>
</li>
<li>
<p>特征过多（特折数目远大于样本数目）</p>
<p>建议删除一些特征或使用正则化</p>
</li>
</ul>
<h1>6 Octave 教程</h1>
<h2 id="基本操作">基本操作</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; 1 &#x3D;&#x3D;2</span><br><span class="line">ans &#x3D; 0</span><br><span class="line">&gt;&gt; 1&#x2F;2</span><br><span class="line">ans &#x3D; 0.5000</span><br><span class="line">&gt;&gt; 2&#x2F;2</span><br><span class="line">ans &#x3D; 1</span><br><span class="line">&gt;&gt; a &#x3D; 3</span><br><span class="line">a &#x3D; 3</span><br><span class="line">&gt;&gt; a &#x3D;&#x3D; 3</span><br><span class="line">ans &#x3D; 1</span><br><span class="line">&gt;&gt; a ~&#x3D; 3</span><br><span class="line">ans &#x3D; 0</span><br><span class="line">&gt;&gt; 1 &amp;&amp; 0</span><br><span class="line">ans &#x3D; 0</span><br><span class="line">&gt;&gt; 1 || 0</span><br><span class="line">ans &#x3D; 1</span><br><span class="line">&gt;&gt; xor(1,0)</span><br><span class="line">ans &#x3D; 1</span><br><span class="line">&gt;&gt; a &#x3D; 3;</span><br><span class="line">&gt;&gt; a</span><br><span class="line">a &#x3D; 3</span><br><span class="line">&gt;&gt; c&#x3D; (3&gt;&#x3D;1);</span><br><span class="line">&gt;&gt; c</span><br><span class="line">c &#x3D; 1</span><br><span class="line">&gt;&gt; disp(c)</span><br><span class="line">1</span><br><span class="line">&gt;&gt; disp(spintf(&#39;2 decimals: %0.2f&#39;, c))</span><br><span class="line">error: &#39;spintf&#39; undefined near line 1, column 1</span><br><span class="line">&gt;&gt; disp(sprintf(&#39;2 decimals: %0.2f&#39;, c))</span><br><span class="line">2 decimals: 1.00</span><br><span class="line">&gt;&gt; a</span><br><span class="line">a &#x3D; 3</span><br><span class="line">&gt;&gt; a&#x3D; 1&#x2F;2</span><br><span class="line">a &#x3D; 0.5000</span><br><span class="line">&gt;&gt; format long</span><br><span class="line">&gt;&gt; a</span><br><span class="line">a &#x3D; 0.500000000000000</span><br><span class="line">&gt;&gt; format short</span><br><span class="line">&gt;&gt; a</span><br><span class="line">a &#x3D; 0.5000</span><br><span class="line">&gt;&gt;</span><br><span class="line">&gt;&gt; A &#x3D; [1 2; 3 4; 5 6]</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; v &#x3D; [1 2 3]</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2   3</span><br><span class="line"></span><br><span class="line">&gt;&gt; v &#x3D; [1; 2; 3;]</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">   2</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">&gt;&gt; v &#x3D; [1; 2; 3]</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">   2</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">&gt;&gt; v &#x3D; 1:0.1:2</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">    1.0000    1.1000    1.2000    1.3000    1.4000    1.5000    1.6000    1.7000    1.8000    1.9000    2.0000</span><br><span class="line"></span><br><span class="line">&gt;&gt; v &#x3D; 1:6</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2   3   4   5   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; ones(2,3)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1   1   1</span><br><span class="line">   1   1   1</span><br><span class="line"></span><br><span class="line">&gt;&gt; C &#x3D; 2*ones(2,3)</span><br><span class="line">C &#x3D;</span><br><span class="line"></span><br><span class="line">   2   2   2</span><br><span class="line">   2   2   2</span><br><span class="line"></span><br><span class="line">&gt;&gt; zeros(1,3)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">  0  0  0</span><br><span class="line"></span><br><span class="line">&gt;&gt; rand(1,3)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   0.5413   0.8539   0.5904</span><br><span class="line"></span><br><span class="line">&gt;&gt; randn(1,3)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">  -1.3434e+00   2.5391e-01  -9.3182e-03</span><br><span class="line"></span><br><span class="line">&gt;&gt; w &#x3D; -6 + sqrt(10)*(randn(1,10000)</span><br><span class="line">hist(w)</span><br><span class="line">error: parse error:</span><br><span class="line"></span><br><span class="line">  syntax error</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; hist(w)</span><br><span class="line">       ^</span><br><span class="line">&gt;&gt; hist(w)</span><br><span class="line">error: &#39;w&#39; undefined near line 1, column 1</span><br><span class="line">&gt;&gt; w &#x3D; -6 + sqrt(10)*(randn(1,10000);</span><br><span class="line">error: parse error:</span><br><span class="line"></span><br><span class="line">  syntax error</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; w &#x3D; -6 + sqrt(10)*(randn(1,10000);</span><br><span class="line">                                     ^</span><br><span class="line">&gt;&gt; w &#x3D; -6 + sqrt(10)*(randn(1,10000));</span><br><span class="line">&gt;&gt; hist(w)</span><br><span class="line">&gt;&gt; hist(w,50)</span><br><span class="line">&gt;&gt;</span><br><span class="line">&gt;&gt; eye(4)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">Diagonal Matrix</span><br><span class="line"></span><br><span class="line">   1   0   0   0</span><br><span class="line">   0   1   0   0</span><br><span class="line">   0   0   1   0</span><br><span class="line">   0   0   0   1</span><br><span class="line"></span><br><span class="line">&gt;&gt; help eye</span><br></pre></td></tr></table></figure>
<h2 id="移动数据">移动数据</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A</span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>   <span class="number">2</span></span><br><span class="line">   <span class="number">3</span>   <span class="number">4</span></span><br><span class="line">   <span class="number">5</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; size(A)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   <span class="number">3</span>   <span class="number">2</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; size(A,<span class="number">1</span>)</span><br><span class="line">ans = <span class="number">3</span></span><br><span class="line">&gt;&gt; size(A,<span class="number">2</span>)</span><br><span class="line">ans = <span class="number">2</span></span><br><span class="line">&gt;&gt; v = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">v =</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; length(v)</span><br><span class="line">ans = <span class="number">4</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">&gt;&gt; pwd</span><br><span class="line">ans = C:\Users\zhou</span><br><span class="line">&gt;&gt; % change directory</span><br><span class="line">&gt;&gt; cd <span class="string">&#x27;D:\Desktop&#x27;</span></span><br><span class="line">&gt;&gt; pwd</span><br><span class="line">ans = D:\Desktop</span><br><span class="line">&gt;&gt; ls</span><br><span class="line"> Volume <span class="keyword">in</span> drive D <span class="keyword">is</span> LENOVO</span><br><span class="line"> Volume Serial Number <span class="keyword">is</span> 3AAD-0FC6</span><br><span class="line"></span><br><span class="line"> Directory of D:\Desktop</span><br><span class="line"></span><br><span class="line">[.]           [blog]        [markdown]    [下下载载文文献献]        [杂杂]           [系系谱谱纠纠偏偏]</span><br><span class="line">[..]          [blog_zhizhi] [writing]     [暑暑期期学学校校课课件件<span class="number">2021</span>]  [档档案案]          [考考研研英英语语真真题题]</span><br><span class="line">               <span class="number">0</span> File(s)              <span class="number">0</span> <span class="built_in">bytes</span></span><br><span class="line">              <span class="number">12</span> Dir(s)  <span class="number">338</span>,004,<span class="number">676</span>,<span class="number">608</span> <span class="built_in">bytes</span> free</span><br><span class="line">&gt;&gt; who</span><br><span class="line">Variables visible <span class="keyword">from</span> the current scope:</span><br><span class="line"></span><br><span class="line">A    C    a    ans  c    v    w</span><br><span class="line"></span><br><span class="line">&gt;&gt; whos</span><br><span class="line">Variables visible <span class="keyword">from</span> the current scope:</span><br><span class="line"></span><br><span class="line">variables <span class="keyword">in</span> scope: top scope</span><br><span class="line"></span><br><span class="line">   Attr Name        Size                     Bytes  Class</span><br><span class="line">   ==== ====        ====                     =====  =====</span><br><span class="line">        A           3x2                         <span class="number">48</span>  double</span><br><span class="line">        C           2x3                         <span class="number">48</span>  double</span><br><span class="line">        a           1x1                          <span class="number">8</span>  double</span><br><span class="line">        ans         1x10                        <span class="number">10</span>  char</span><br><span class="line">        c           1x1                          <span class="number">1</span>  logical</span><br><span class="line">        v           1x4                         <span class="number">32</span>  double</span><br><span class="line">        w           1x10000                  <span class="number">80000</span>  double</span><br><span class="line"></span><br><span class="line">Total <span class="keyword">is</span> <span class="number">10028</span> elements using <span class="number">80147</span> <span class="built_in">bytes</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; clear c</span><br><span class="line">&gt;&gt; who</span><br><span class="line">Variables visible <span class="keyword">from</span> the current scope:</span><br><span class="line"></span><br><span class="line">A    C    a    ans  v    w</span><br><span class="line"></span><br><span class="line">&gt;&gt; save hello.mat A;</span><br><span class="line">&gt;&gt; load hello.mat</span><br><span class="line">&gt;&gt; hell</span><br><span class="line">error: <span class="string">&#x27;hell&#x27;</span> undefined near line <span class="number">1</span>, column <span class="number">1</span></span><br><span class="line">&gt;&gt; hello</span><br><span class="line">error: <span class="string">&#x27;hello&#x27;</span> undefined near line <span class="number">1</span>, column <span class="number">1</span></span><br><span class="line">&gt;&gt; who</span><br><span class="line">Variables visible <span class="keyword">from</span> the current scope:</span><br><span class="line"></span><br><span class="line">A    C    a    ans  v    w</span><br><span class="line"></span><br><span class="line">&gt;&gt; v</span><br><span class="line">v =</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; save hello.txt A;</span><br><span class="line">&gt;&gt; load hello.txt</span><br><span class="line">&gt;&gt; who</span><br><span class="line">Variables visible <span class="keyword">from</span> the current scope:</span><br><span class="line"></span><br><span class="line">A    C    a    ans  v    w</span><br><span class="line"></span><br><span class="line">&gt;&gt; A</span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>   <span class="number">2</span></span><br><span class="line">   <span class="number">3</span>   <span class="number">4</span></span><br><span class="line">   <span class="number">5</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; A(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">ans = <span class="number">6</span></span><br><span class="line">&gt;&gt; A(<span class="number">3</span>,<span class="string">&quot;)</span></span><br><span class="line"><span class="string">error: parse error:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  syntax error</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt; A(3,&quot;</span>)</span><br><span class="line">         ^</span><br><span class="line">&gt;&gt; A(<span class="number">3</span>,:)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   <span class="number">5</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; A(:,<span class="number">2</span>)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   <span class="number">2</span></span><br><span class="line">   <span class="number">4</span></span><br><span class="line">   <span class="number">6</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; A([<span class="number">1</span> <span class="number">3</span>],:)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>   <span class="number">2</span></span><br><span class="line">   <span class="number">5</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; A(:,<span class="number">2</span>) = [<span class="number">10</span>; <span class="number">11</span>; <span class="number">12</span>]</span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span>   <span class="number">10</span></span><br><span class="line">    <span class="number">3</span>   <span class="number">11</span></span><br><span class="line">    <span class="number">5</span>   <span class="number">12</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; A = [A, [<span class="number">100</span> <span class="number">101</span> <span class="number">102</span>]]; <span class="comment"># append</span></span><br><span class="line">error: horizontal dimensions mismatch (3x2 vs 1x3)</span><br><span class="line">&gt;&gt; A = [A, [<span class="number">100</span>; <span class="number">101</span>; <span class="number">102</span>]]; <span class="comment"># append</span></span><br><span class="line">&gt;&gt; A</span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span>    <span class="number">10</span>   <span class="number">100</span></span><br><span class="line">     <span class="number">3</span>    <span class="number">11</span>   <span class="number">101</span></span><br><span class="line">     <span class="number">5</span>    <span class="number">12</span>   <span class="number">102</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; A(:)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">     <span class="number">1</span></span><br><span class="line">     <span class="number">3</span></span><br><span class="line">     <span class="number">5</span></span><br><span class="line">    <span class="number">10</span></span><br><span class="line">    <span class="number">11</span></span><br><span class="line">    <span class="number">12</span></span><br><span class="line">   <span class="number">100</span></span><br><span class="line">   <span class="number">101</span></span><br><span class="line">   <span class="number">102</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">&gt;&gt; A = [<span class="number">1</span> <span class="number">2</span>; <span class="number">3</span> <span class="number">4</span>; <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line">A =</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>   <span class="number">2</span></span><br><span class="line">   <span class="number">3</span>   <span class="number">4</span></span><br><span class="line">   <span class="number">5</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; B = [<span class="number">11</span> <span class="number">12</span>; <span class="number">13</span> <span class="number">14</span>; <span class="number">15</span> <span class="number">16</span>]</span><br><span class="line">B =</span><br><span class="line"></span><br><span class="line">   <span class="number">11</span>   <span class="number">12</span></span><br><span class="line">   <span class="number">13</span>   <span class="number">14</span></span><br><span class="line">   <span class="number">15</span>   <span class="number">16</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; C = [A B&#125;</span><br><span class="line">error: parse error:</span><br><span class="line"></span><br><span class="line">  syntax error</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C = [A B&#125;</span><br><span class="line">             ^</span><br><span class="line">&gt;&gt; C = [A B]</span><br><span class="line">C =</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span>    <span class="number">2</span>   <span class="number">11</span>   <span class="number">12</span></span><br><span class="line">    <span class="number">3</span>    <span class="number">4</span>   <span class="number">13</span>   <span class="number">14</span></span><br><span class="line">    <span class="number">5</span>    <span class="number">6</span>   <span class="number">15</span>   <span class="number">16</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; C = [A; B]</span><br><span class="line">C =</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line">    <span class="number">3</span>    <span class="number">4</span></span><br><span class="line">    <span class="number">5</span>    <span class="number">6</span></span><br><span class="line">   <span class="number">11</span>   <span class="number">12</span></span><br><span class="line">   <span class="number">13</span>   <span class="number">14</span></span><br><span class="line">   <span class="number">15</span>   <span class="number">16</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="计算数据">计算数据</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; A &#x3D; [1 2; 3 4; 5 6]</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; B &#x3D; [11 12; 13 14; 15 16]</span><br><span class="line">B &#x3D;</span><br><span class="line"></span><br><span class="line">   11   12</span><br><span class="line">   13   14</span><br><span class="line">   15   16</span><br><span class="line"></span><br><span class="line">&gt;&gt; C &#x3D; [1 1; 2 2]</span><br><span class="line">C &#x3D;</span><br><span class="line"></span><br><span class="line">   1   1</span><br><span class="line">   2   2</span><br><span class="line"></span><br><span class="line">&gt;&gt; A*C</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    5    5</span><br><span class="line">   11   11</span><br><span class="line">   17   17</span><br><span class="line"></span><br><span class="line">&gt;&gt; A .* B</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   11   24</span><br><span class="line">   39   56</span><br><span class="line">   75   96</span><br><span class="line"></span><br><span class="line">&gt;&gt; A .^ 2</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    1    4</span><br><span class="line">    9   16</span><br><span class="line">   25   36</span><br><span class="line"></span><br><span class="line">&gt;&gt; v &#x3D; [1; 2; 3]</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">   2</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">&gt;&gt; 1 .&#x2F; v</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1.0000</span><br><span class="line">   0.5000</span><br><span class="line">   0.3333</span><br><span class="line"></span><br><span class="line">&gt;&gt; 1 .&#x2F; A</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1.0000   0.5000</span><br><span class="line">   0.3333   0.2500</span><br><span class="line">   0.2000   0.1667</span><br><span class="line"></span><br><span class="line">&gt;&gt; log(v)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">        0</span><br><span class="line">   0.6931</span><br><span class="line">   1.0986</span><br><span class="line"></span><br><span class="line">&gt;&gt; exp(v)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    2.7183</span><br><span class="line">    7.3891</span><br><span class="line">   20.0855</span><br><span class="line"></span><br><span class="line">&gt;&gt; abs(v)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">   2</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">&gt;&gt; -v</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">  -1</span><br><span class="line">  -2</span><br><span class="line">  -3</span><br><span class="line"></span><br><span class="line">&gt;&gt; v + ones(length(v),1)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   2</span><br><span class="line">   3</span><br><span class="line">   4</span><br><span class="line"></span><br><span class="line">&gt;&gt; v + 1</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   2</span><br><span class="line">   3</span><br><span class="line">   4</span><br><span class="line"></span><br><span class="line">&gt;&gt; A</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; A&#39;</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1   3   5</span><br><span class="line">   2   4   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; (A&#39;)&#39;</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; a &#x3D; [1 15 2 0.5]</span><br><span class="line">a &#x3D;</span><br><span class="line"></span><br><span class="line">    1.0000   15.0000    2.0000    0.5000</span><br><span class="line"></span><br><span class="line">&gt;&gt; val &#x3D; max(a)</span><br><span class="line">val &#x3D; 15</span><br><span class="line">&gt;&gt; [val,ind] &#x3D; max(a)</span><br><span class="line">val &#x3D; 15</span><br><span class="line">ind &#x3D; 2</span><br><span class="line">&gt;&gt; max(A)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   5   6</span><br><span class="line"></span><br><span class="line">&gt;&gt; a &lt; 3</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">  1  0  1  1</span><br><span class="line"></span><br><span class="line">&gt;&gt; find(a&lt;3)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1   3   4</span><br><span class="line"></span><br><span class="line">&gt;&gt; A &#x3D; magic(3)</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   8   1   6</span><br><span class="line">   3   5   7</span><br><span class="line">   4   9   2</span><br><span class="line"></span><br><span class="line">&gt;&gt; [r,c]&#x3D;find(A&gt;&#x3D;7)</span><br><span class="line">r &#x3D;</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">   3</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">c &#x3D;</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">   2</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">&gt;&gt; a</span><br><span class="line">a &#x3D;</span><br><span class="line"></span><br><span class="line">    1.0000   15.0000    2.0000    0.5000</span><br><span class="line"></span><br><span class="line">&gt;&gt; sum(a)</span><br><span class="line">ans &#x3D; 18.500</span><br><span class="line">&gt;&gt; prod(a)</span><br><span class="line">ans &#x3D; 15</span><br><span class="line">&gt;&gt; floor(a)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    1   15    2    0</span><br><span class="line"></span><br><span class="line">&gt;&gt; ceil(a)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    1   15    2    1</span><br><span class="line"></span><br><span class="line">&gt;&gt; rand(3)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   9.0145e-01   2.9375e-01   7.3094e-02</span><br><span class="line">   2.1412e-01   9.8457e-01   3.0340e-01</span><br><span class="line">   9.6136e-01   3.3710e-01   1.6999e-04</span><br><span class="line"></span><br><span class="line">&gt;&gt; max(rand(3), rand(3))</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   0.3017   0.8929   0.3524</span><br><span class="line">   0.9903   0.8076   0.9236</span><br><span class="line">   0.4903   0.5741   0.8563</span><br><span class="line"></span><br><span class="line">&gt;&gt; A</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   8   1   6</span><br><span class="line">   3   5   7</span><br><span class="line">   4   9   2</span><br><span class="line"></span><br><span class="line">&gt;&gt; max(A,[],1)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   8   9   7</span><br><span class="line"></span><br><span class="line">&gt;&gt; max(A,[],2)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   8</span><br><span class="line">   7</span><br><span class="line">   9</span><br><span class="line"></span><br><span class="line">&gt;&gt; max(A)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   8   9   7</span><br><span class="line"></span><br><span class="line">&gt;&gt; max(max(A))</span><br><span class="line">ans &#x3D; 9</span><br><span class="line">&gt;&gt; max(A(:))</span><br><span class="line">ans &#x3D; 9</span><br><span class="line">&gt;&gt; A &#x3D; magic(9)</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   47   58   69   80    1   12   23   34   45</span><br><span class="line">   57   68   79    9   11   22   33   44   46</span><br><span class="line">   67   78    8   10   21   32   43   54   56</span><br><span class="line">   77    7   18   20   31   42   53   55   66</span><br><span class="line">    6   17   19   30   41   52   63   65   76</span><br><span class="line">   16   27   29   40   51   62   64   75    5</span><br><span class="line">   26   28   39   50   61   72   74    4   15</span><br><span class="line">   36   38   49   60   71   73    3   14   25</span><br><span class="line">   37   48   59   70   81    2   13   24   35</span><br><span class="line"></span><br><span class="line">&gt;&gt; sum(A,1)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   369   369   369   369   369   369   369   369   369</span><br><span class="line"></span><br><span class="line">&gt;&gt; sum(A,2)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   369</span><br><span class="line">   369</span><br><span class="line">   369</span><br><span class="line">   369</span><br><span class="line">   369</span><br><span class="line">   369</span><br><span class="line">   369</span><br><span class="line">   369</span><br><span class="line">   369</span><br><span class="line"></span><br><span class="line">&gt;&gt; A .* eye(9)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   47    0    0    0    0    0    0    0    0</span><br><span class="line">    0   68    0    0    0    0    0    0    0</span><br><span class="line">    0    0    8    0    0    0    0    0    0</span><br><span class="line">    0    0    0   20    0    0    0    0    0</span><br><span class="line">    0    0    0    0   41    0    0    0    0</span><br><span class="line">    0    0    0    0    0   62    0    0    0</span><br><span class="line">    0    0    0    0    0    0   74    0    0</span><br><span class="line">    0    0    0    0    0    0    0   14    0</span><br><span class="line">    0    0    0    0    0    0    0    0   35</span><br><span class="line"></span><br><span class="line">&gt;&gt; sum(sum(A.*eye(9)))</span><br><span class="line">ans &#x3D; 369</span><br><span class="line">&gt;&gt; flipup(eye(9))</span><br><span class="line">error: &#39;flipup&#39; undefined near line 1, column 1</span><br><span class="line">&gt;&gt; flipud(eye(9))</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">Permutation Matrix</span><br><span class="line"></span><br><span class="line">   0   0   0   0   0   0   0   0   1</span><br><span class="line">   0   0   0   0   0   0   0   1   0</span><br><span class="line">   0   0   0   0   0   0   1   0   0</span><br><span class="line">   0   0   0   0   0   1   0   0   0</span><br><span class="line">   0   0   0   0   1   0   0   0   0</span><br><span class="line">   0   0   0   1   0   0   0   0   0</span><br><span class="line">   0   0   1   0   0   0   0   0   0</span><br><span class="line">   0   1   0   0   0   0   0   0   0</span><br><span class="line">   1   0   0   0   0   0   0   0   0</span><br><span class="line"></span><br><span class="line">&gt;&gt; A &#x3D; magic(3)</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   8   1   6</span><br><span class="line">   3   5   7</span><br><span class="line">   4   9   2</span><br><span class="line"></span><br><span class="line">&gt;&gt; pinv(A)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   0.147222  -0.144444   0.063889</span><br><span class="line">  -0.061111   0.022222   0.105556</span><br><span class="line">  -0.019444   0.188889  -0.102778</span><br><span class="line"></span><br><span class="line">&gt;&gt; temp &#x3D; pinv(A)</span><br><span class="line">temp &#x3D;</span><br><span class="line"></span><br><span class="line">   0.147222  -0.144444   0.063889</span><br><span class="line">  -0.061111   0.022222   0.105556</span><br><span class="line">  -0.019444   0.188889  -0.102778</span><br><span class="line"></span><br><span class="line">&gt;&gt; teme*A</span><br><span class="line">error: &#39;teme&#39; undefined near line 1, column 1</span><br><span class="line">&gt;&gt; temp*A</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1.0000e+00   8.3267e-17  -2.9698e-15</span><br><span class="line">  -6.0507e-15   1.0000e+00   6.3283e-15</span><br><span class="line">   2.9421e-15   4.4409e-16   1.0000e+00</span><br></pre></td></tr></table></figure>
<h2 id="数据绘制">数据绘制</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; t&#x3D;[0:0.01:0.98]</span><br><span class="line">t &#x3D;</span><br><span class="line"></span><br><span class="line"> Columns 1 through 13:</span><br><span class="line"></span><br><span class="line">        0   0.0100   0.0200   0.0300   0.0400   0.0500   0.0600   0.0700   0.0800   0.0900   0.1000   0.1100   0.1200</span><br><span class="line"></span><br><span class="line"> Columns 14 through 26:</span><br><span class="line"></span><br><span class="line">   0.1300   0.1400   0.1500   0.1600   0.1700   0.1800   0.1900   0.2000   0.2100   0.2200   0.2300   0.2400   0.2500</span><br><span class="line"></span><br><span class="line"> Columns 27 through 39:</span><br><span class="line"></span><br><span class="line">   0.2600   0.2700   0.2800   0.2900   0.3000   0.3100   0.3200   0.3300   0.3400   0.3500   0.3600   0.3700   0.3800</span><br><span class="line"></span><br><span class="line"> Columns 40 through 52:</span><br><span class="line"></span><br><span class="line">   0.3900   0.4000   0.4100   0.4200   0.4300   0.4400   0.4500   0.4600   0.4700   0.4800   0.4900   0.5000   0.5100</span><br><span class="line"></span><br><span class="line"> Columns 53 through 65:</span><br><span class="line"></span><br><span class="line">   0.5200   0.5300   0.5400   0.5500   0.5600   0.5700   0.5800   0.5900   0.6000   0.6100   0.6200   0.6300   0.6400</span><br><span class="line"></span><br><span class="line"> Columns 66 through 78:</span><br><span class="line"></span><br><span class="line">   0.6500   0.6600   0.6700   0.6800   0.6900   0.7000   0.7100   0.7200   0.7300   0.7400   0.7500   0.7600   0.7700</span><br><span class="line"></span><br><span class="line"> Columns 79 through 91:</span><br><span class="line"></span><br><span class="line">   0.7800   0.7900   0.8000   0.8100   0.8200   0.8300   0.8400   0.8500   0.8600   0.8700   0.8800   0.8900   0.9000</span><br><span class="line"></span><br><span class="line"> Columns 92 through 99:</span><br><span class="line"></span><br><span class="line">   0.9100   0.9200   0.9300   0.9400   0.9500   0.9600   0.9700   0.9800</span><br><span class="line"></span><br><span class="line">&gt;&gt; y1 &#x3D; sin(2*pi*4*t);</span><br><span class="line">&gt;&gt; plot(t,y1);</span><br><span class="line">&gt;&gt; y2 &#x3D; cos(2*pi*4*t);</span><br><span class="line">&gt;&gt; plot(t,y2);</span><br><span class="line">&gt;&gt; hole on;</span><br><span class="line">error: &#39;hole&#39; undefined near line 1, column 1</span><br><span class="line">&gt;&gt; hold on;</span><br><span class="line">&gt;&gt; plot(t,y1,&#39;r&#39;);</span><br><span class="line">&gt;&gt; xlabel(&#39;time&#39;)</span><br><span class="line">&gt;&gt; ylabel(&#39;value&#39;)</span><br><span class="line">&gt;&gt; legend(&#39;cos&#39;,&#39;sin&#39;)</span><br><span class="line">&gt;&gt; title(&#39;my plot&#39;)</span><br><span class="line">&gt;&gt; cd &#39;D:\Desktop&#39;</span><br><span class="line">&gt;&gt; print -dng &#39;myPlot.png&#39;</span><br><span class="line">error: print: unknown device ng</span><br><span class="line">error: called from</span><br><span class="line">    __print_parse_opts__ at line 420 column 5</span><br><span class="line">    print at line 415 column 8</span><br><span class="line">&gt;&gt; print -dpng &#39;myPlot.png&#39;</span><br><span class="line">&gt;&gt; close</span><br><span class="line">&gt;&gt; figure(1); plot(t,y1);</span><br><span class="line">&gt;&gt; figuer(2); plot(t,y2);</span><br><span class="line">error: &#39;figuer&#39; undefined near line 1, column 1</span><br><span class="line">&gt;&gt; figure(2); plot(t,y2);</span><br><span class="line">&gt;&gt; close</span><br><span class="line">&gt;&gt; close</span><br><span class="line">&gt;&gt; subplot(1,2,1); % Divides plot as a 1*2 grid, access first element</span><br><span class="line">&gt;&gt; plot(t,y1)</span><br><span class="line">&gt;&gt; subplot(1,2,2)</span><br><span class="line">&gt;&gt; plot(t,y2)</span><br><span class="line">&gt;&gt; axis([0.5 1 -1 1]) % set x and y&#39;s range</span><br><span class="line">&gt;&gt; clf;</span><br><span class="line">&gt;&gt; % clear figure</span><br><span class="line">&gt;&gt; A &#x3D; magic(5)</span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">   17   24    1    8   15</span><br><span class="line">   23    5    7   14   16</span><br><span class="line">    4    6   13   20   22</span><br><span class="line">   10   12   19   21    3</span><br><span class="line">   11   18   25    2    9</span><br><span class="line"></span><br><span class="line">&gt;&gt; imagesc(A)</span><br><span class="line">&gt;&gt; % plot heatmap</span><br><span class="line">&gt;&gt; imagesc(A), colorbar, colormap gray;</span><br><span class="line">&gt;&gt; a&#x3D;1, b&#x3D;2, c&#x3D;3</span><br><span class="line">a &#x3D; 1</span><br><span class="line">b &#x3D; 2</span><br><span class="line">c &#x3D; 3</span><br><span class="line">&gt;&gt; a&#x3D;1; b&#x3D;2&#39; c&#x3D;3</span><br><span class="line">error: parse error:</span><br><span class="line"></span><br><span class="line">  syntax error</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; a&#x3D;1; b&#x3D;2&#39; c&#x3D;3</span><br><span class="line">              ^</span><br><span class="line">&gt;&gt; a&#x3D;1; b&#x3D;2; c&#x3D;3</span><br><span class="line">c &#x3D; 3</span><br><span class="line">&gt;&gt; a&#x3D;1, b&#x3D;2, c&#x3D;3</span><br><span class="line">a &#x3D; 1</span><br><span class="line">b &#x3D; 2</span><br><span class="line">c &#x3D; 3</span><br></pre></td></tr></table></figure>
<p>保存的图片</p>
<p><img src="9.png" alt="9"></p>
<h2 id="控制语句：for-while-if">控制语句：for,while,if</h2>
<p>貌似空格和逗号分隔的语句就会打印变量内容；而冒号分隔则不会打印变量内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt; v = zeros(<span class="number">10</span>,<span class="number">1</span>)</span><br><span class="line">v =</span><br><span class="line"></span><br><span class="line">   <span class="number">0</span></span><br><span class="line">   <span class="number">0</span></span><br><span class="line">   <span class="number">0</span></span><br><span class="line">   <span class="number">0</span></span><br><span class="line">   <span class="number">0</span></span><br><span class="line">   <span class="number">0</span></span><br><span class="line">   <span class="number">0</span></span><br><span class="line">   <span class="number">0</span></span><br><span class="line">   <span class="number">0</span></span><br><span class="line">   <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="keyword">for</span> i=<span class="number">1</span>:<span class="number">10</span>,</span><br><span class="line">     v(i) = <span class="number">2</span>^i;</span><br><span class="line">   end;</span><br><span class="line">&gt;&gt; v</span><br><span class="line">v =</span><br><span class="line"></span><br><span class="line">      <span class="number">2</span></span><br><span class="line">      <span class="number">4</span></span><br><span class="line">      <span class="number">8</span></span><br><span class="line">     <span class="number">16</span></span><br><span class="line">     <span class="number">32</span></span><br><span class="line">     <span class="number">64</span></span><br><span class="line">    <span class="number">128</span></span><br><span class="line">    <span class="number">256</span></span><br><span class="line">    <span class="number">512</span></span><br><span class="line">   <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; indices = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">indices =</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span>    <span class="number">2</span>    <span class="number">3</span>    <span class="number">4</span>    <span class="number">5</span>    <span class="number">6</span>    <span class="number">7</span>    <span class="number">8</span>    <span class="number">9</span>   <span class="number">10</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="keyword">for</span> i=indices,</span><br><span class="line">       disp(i);</span><br><span class="line">   end;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">&gt;&gt; i = <span class="number">1</span>;</span><br><span class="line">&gt;&gt; <span class="keyword">while</span> i &lt;= <span class="number">5</span>,</span><br><span class="line">      v(i) = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">Display all 1765 possibilities? (y or n)</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="keyword">while</span> i &lt;= <span class="number">5</span>,</span><br><span class="line">       v(i) = <span class="number">100</span>;</span><br><span class="line">       i = i+<span class="number">1</span>;</span><br><span class="line">   end;</span><br><span class="line">&gt;&gt; v</span><br><span class="line">v =</span><br><span class="line"></span><br><span class="line">    <span class="number">100</span></span><br><span class="line">    <span class="number">100</span></span><br><span class="line">    <span class="number">100</span></span><br><span class="line">    <span class="number">100</span></span><br><span class="line">    <span class="number">100</span></span><br><span class="line">     <span class="number">64</span></span><br><span class="line">    <span class="number">128</span></span><br><span class="line">    <span class="number">256</span></span><br><span class="line">    <span class="number">512</span></span><br><span class="line">   <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; i = <span class="number">1</span>;</span><br><span class="line">&gt;&gt; <span class="keyword">while</span> true,</span><br><span class="line">      v(i) = <span class="number">999</span></span><br><span class="line">      i = i+<span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> i == <span class="number">6</span>,</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      end;</span><br><span class="line">   end;</span><br><span class="line">v =</span><br><span class="line"></span><br><span class="line">    <span class="number">999</span></span><br><span class="line">    <span class="number">100</span></span><br><span class="line">    <span class="number">100</span></span><br><span class="line">    <span class="number">100</span></span><br><span class="line">    <span class="number">100</span></span><br><span class="line">     <span class="number">64</span></span><br><span class="line">    <span class="number">128</span></span><br><span class="line">    <span class="number">256</span></span><br><span class="line">    <span class="number">512</span></span><br><span class="line">   <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">v =</span><br><span class="line"></span><br><span class="line">    <span class="number">999</span></span><br><span class="line">    <span class="number">999</span></span><br><span class="line">    <span class="number">100</span></span><br><span class="line">    <span class="number">100</span></span><br><span class="line">    <span class="number">100</span></span><br><span class="line">     <span class="number">64</span></span><br><span class="line">    <span class="number">128</span></span><br><span class="line">    <span class="number">256</span></span><br><span class="line">    <span class="number">512</span></span><br><span class="line">   <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">3</span></span><br><span class="line">v =</span><br><span class="line"></span><br><span class="line">    <span class="number">999</span></span><br><span class="line">    <span class="number">999</span></span><br><span class="line">    <span class="number">999</span></span><br><span class="line">    <span class="number">100</span></span><br><span class="line">    <span class="number">100</span></span><br><span class="line">     <span class="number">64</span></span><br><span class="line">    <span class="number">128</span></span><br><span class="line">    <span class="number">256</span></span><br><span class="line">    <span class="number">512</span></span><br><span class="line">   <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">4</span></span><br><span class="line">v =</span><br><span class="line"></span><br><span class="line">    <span class="number">999</span></span><br><span class="line">    <span class="number">999</span></span><br><span class="line">    <span class="number">999</span></span><br><span class="line">    <span class="number">999</span></span><br><span class="line">    <span class="number">100</span></span><br><span class="line">     <span class="number">64</span></span><br><span class="line">    <span class="number">128</span></span><br><span class="line">    <span class="number">256</span></span><br><span class="line">    <span class="number">512</span></span><br><span class="line">   <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">5</span></span><br><span class="line">v =</span><br><span class="line"></span><br><span class="line">    <span class="number">999</span></span><br><span class="line">    <span class="number">999</span></span><br><span class="line">    <span class="number">999</span></span><br><span class="line">    <span class="number">999</span></span><br><span class="line">    <span class="number">999</span></span><br><span class="line">     <span class="number">64</span></span><br><span class="line">    <span class="number">128</span></span><br><span class="line">    <span class="number">256</span></span><br><span class="line">    <span class="number">512</span></span><br><span class="line">   <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>可以用 <code>addpath()</code> 添加环境变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; v</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">    999</span><br><span class="line">    999</span><br><span class="line">    999</span><br><span class="line">    999</span><br><span class="line">    999</span><br><span class="line">    999</span><br><span class="line">    128</span><br><span class="line">    256</span><br><span class="line">    512</span><br><span class="line">   1024</span><br><span class="line"></span><br><span class="line">&gt;&gt; v(1) &#x3D; 2</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">      2</span><br><span class="line">    999</span><br><span class="line">    999</span><br><span class="line">    999</span><br><span class="line">    999</span><br><span class="line">    999</span><br><span class="line">    128</span><br><span class="line">    256</span><br><span class="line">    512</span><br><span class="line">   1024</span><br><span class="line"></span><br><span class="line">&gt;&gt; if v(1)&#x3D;&#x3D;1,</span><br><span class="line">      disp(&#39;The value is one&#39;);</span><br><span class="line">   elseif v(1) &#x3D;&#x3D; 2,</span><br><span class="line">      disp(&#39;The value is two&#39;);</span><br><span class="line">   else</span><br><span class="line">      disp(&#39;The value is not one or two.&#39;);</span><br><span class="line">   end;</span><br><span class="line">The value is two</span><br><span class="line">&gt;&gt; addpath(&#39;D:\Desktop&#39;)</span><br></pre></td></tr></table></figure>
<h2 id="函数">函数</h2>
<h3 id="计算线性回归的损失函数">计算线性回归的损失函数</h3>
<p>这里我还是用了我最熟悉的Python Numpy 。根据前面几节课，我感觉 Octave 在矩阵运算上很简洁，画图也很方便，但是和 Python 没有拉开特别大的差距，所以还是用 Python 吧。</p>
<p>首先，定义设计矩阵 X, 反应变量 y ，回归参数 theta</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: X = np.array([[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: X.shape</span><br><span class="line">Out[<span class="number">3</span>]: (<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: y = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: y</span><br><span class="line">Out[<span class="number">5</span>]: array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: theta = np.array([<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>定义函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CostFunctionJ</span>(<span class="params">X, y, theta</span>):</span></span><br><span class="line">    <span class="comment"># 计算线性回归的代价函数</span></span><br><span class="line">    <span class="comment"># X 是设计矩阵，y 为真实结果，theta 为线性回归的参数</span></span><br><span class="line">    <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">    m = X.shape[<span class="number">0</span>] <span class="comment"># 样本数</span></span><br><span class="line">    predictions = np.dot(X,theta) <span class="comment"># 预测值，等于 X*θ</span></span><br><span class="line">    sqrErrors = np.square(predictions - y) <span class="comment"># 平方误差, 求平方只能用 np.square()</span></span><br><span class="line">    J = <span class="number">1</span>/(2m)*<span class="built_in">sum</span>(sqrErrors)</span><br><span class="line">    <span class="keyword">return</span>(J)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>计算代价函数，这里由于是完全拟合，因此代价函数的结果为0。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">32</span>]: %paste</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CostFunctionJ</span>(<span class="params">X, y, theta</span>):</span></span><br><span class="line">    <span class="comment"># 计算线性回归的代价函数</span></span><br><span class="line">    <span class="comment"># X 是设计矩阵，y 为真实结果，theta 为线性回归的参数</span></span><br><span class="line">    <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">    m = X.shape[<span class="number">0</span>] <span class="comment"># 样本数</span></span><br><span class="line">    predictions = np.dot(X,theta) <span class="comment"># 预测值，等于 X*θ</span></span><br><span class="line">    sqrErrors = np.square(predictions - y) <span class="comment"># 平方误差, 求平方只能用 np.square()</span></span><br><span class="line">    J = <span class="number">1</span>/(<span class="number">2</span>*m)*<span class="built_in">sum</span>(sqrErrors)</span><br><span class="line">    <span class="keyword">return</span>(J)</span><br><span class="line"></span><br><span class="line"><span class="comment">## -- End pasted text --</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: j =  CostFunctionJ(X, y, theta)</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: j</span><br><span class="line">Out[<span class="number">34</span>]: <span class="number">0.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>改变一下参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">35</span>]: theta = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: CostFunctionJ(X, y, theta)</span><br><span class="line">Out[<span class="number">36</span>]: <span class="number">2.333333333333333</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="矢量化">矢量化</h2>
<p>比如线性回归的梯度下降，可以写成矢量的形式，而不需要使用 for 循环。</p>
<p>首先，这里将梯度下降的右边拆成了三部分，第一部分是 θ（n+1维的向量），第二部分为 α （实数），第三部分称为 δ （n+1维的向量）。</p>
<p><img src="10.png" alt="10"></p>
<p>为什么 δ 是n+1维的向量呢？下一步继续拆分，这一部分有一点难理解，我在纸上画了一下才懂，估计之后还是会忘 。</p>
<p><img src="11.png" alt="10"></p>
<h1>7 logistic 回归</h1>
<h2 id="线性回归用在二分类问题的弊端">线性回归用在二分类问题的弊端</h2>
<ol>
<li>容易受到极端的点的影响</li>
<li>预测值超出[0,1]范围，不好解释</li>
</ol>
<p><img src="12.png" alt="10"></p>
<h2 id="假设陈述">假设陈述</h2>
<p>逻辑回归预测值的 含义</p>
<p><img src="13.png" alt="10"></p>
<h2 id="决策界限">决策界限</h2>
<p>如果 <strong>θ<sup>T</sup>x  大于等于0，那么就判定 y = 1</strong>，反之判定为 0。</p>
<p><img src="14.png" alt="10"></p>
<p>因此，逻辑回归的决策界限(<strong>decision boundary</strong>)是<strong>线性</strong>的，举个例子如下</p>
<p><img src="15.png" alt="10"></p>
<p>对于非线性的决策界限，你可以像线性回归一样添加多项式，如下</p>
<p><img src="16.png" alt="10"></p>
<h2 id="代价函数">代价函数</h2>
<p>如果你将线性回归的代价函数代入到逻辑回归，你会发现此时的代价函数是一个<strong>非凸函数</strong>，如下面左图。我们期望的一个代价函数应该是一个凸函数，如右图。</p>
<p><img src="17.png" alt="10"></p>
<p>实际使用的cost function 如下：先看 y =1 时（y=0同理）</p>
<p><img src="18.png" alt="10"></p>
<h2 id="简化代价函数与梯度下降">简化代价函数与梯度下降</h2>
<p>由于 y 只能是0或1，因此我们可以将代价函数的两个式子合成一个</p>
<p><img src="19.png" alt="10"></p>
<p>因此，总的代价函数为</p>
<p><img src="20.png" alt="10"></p>
<p>我们同样可以使用梯度下降来求参数</p>
<p><img src="21.png" alt="10"></p>
<p>经过求偏导，简化得到下面式子（我证明出来啦），ppt 给出的公式应该是少了 1/m 。这里得到的<strong>梯度下降的式子和线性回归中的式子一模一样</strong>。</p>
<p><img src="22.png" alt="10"></p>
<p>逻辑回归的梯度下降同样需要<strong>特征缩放</strong>，以加快计算速度。</p>
<h3 id="逻辑回归代价函数证明-最大似然法">逻辑回归代价函数证明-最大似然法</h3>
<p>根据最大似然法，可以得到逻辑回归的代价函数，这个来自于李宏毅老师的视频。</p>
<p>这个证明过程也很简单，这一页有个文本错误，y_hat<sup>2</sup>  应该为1，而 y_hat<sup>3</sup>  应该为0 。另外我觉得这里y   不应该加<code>hat</code> ，因为这个y是真实的标签，而不是预测值。</p>
<p><img src="43.png" alt="10"></p>
<h2 id="高级优化">高级优化</h2>
<p>除了梯度下降，还有共轭梯度等方法进行参数估计，这些方法的优缺点如下：</p>
<p><img src="23.png" alt="10"></p>
<h2 id="多元分类：one-vs-all">多元分类：one-vs-all</h2>
<p>具有多个分类的分类问题，这里介绍一种算法“一对多” (One-vs-all or one-vs-rest)。</p>
<p>比如三种分类的问题，剖分成<strong>三个二分类问题</strong>，这样就可以继续使用逻辑回归了。</p>
<p><img src="24.png" alt="10"></p>
<p>最后，为了预测一个新的输入 x 的结果，我们将其代入到这3个分类器中，选择概率最高的那个分类。</p>
<h1>8 正则化</h1>
<h2 id="过拟合问题">过拟合问题</h2>
<p>当你有很多变量时，你无法通过可视化的方法来发现过拟合问题。为了避免或解决过拟合的问题，可用的方法包括：</p>
<ol>
<li>
<p>较少特征数量</p>
<p>手动选择、算法选择</p>
</li>
<li>
<p>正则化 (Regularization)</p>
<ul>
<li>
<p>保留所有的变量，但是减小参数的值</p>
</li>
<li>
<p>当特征数量很多时效果很好，每个特征对于预测均有贡献。</p>
</li>
</ul>
</li>
</ol>
<h2 id="代价函数-2">代价函数</h2>
<p>正则化的代价函数多增加了一项。</p>
<p><img src="25.png" alt="10"></p>
<h2 id="线性回归的正则化">线性回归的正则化</h2>
<p>正则化之后的梯度回归如下图，θ<sub>0</sub> 不变，其他相当于第一项乘以了一个略小于1的数，例如0.99。</p>
<p><img src="26.png" alt="10"></p>
<p>此时的正规方程求解如下</p>
<p><img src="27.png" alt="10"></p>
<p>正规方程的不可逆问题，如果<strong>样本数目远小于特征数目</strong>，那么此时 (X<sup>T</sup>X) 不可逆，但是如果使用正则化，那么此时得到的需要求逆的矩阵就一定是可逆的。</p>
<p><img src="28.png" alt="10"></p>
<h2 id="逻辑回归的正则化">逻辑回归的正则化</h2>
<p>类似于线性回归，损失函数同样添加相同的惩罚项，梯度下降的式子看上去也和线性回归一样。</p>
<h1>9 神经网络学习</h1>
<h2 id="非线性假设">非线性假设</h2>
<p>如果特折数目过多，往线性方法里添加多项式并不现实，因为太多了。比如二次项的数目是 n(n-1)/2 项。</p>
<p><img src="29.png" alt="10"></p>
<h2 id="神经元与大脑">神经元与大脑</h2>
<p>大脑有可能是采用一种学习算法来处理不同的数据。</p>
<h2 id="模型展示Ⅰ">模型展示Ⅰ</h2>
<p>这里的 <code>activation function</code> 就是指非线性函数，是神经网络中的术语。参数 θ 在神经网络中称为“权重”(<strong>weights</strong>)</p>
<p>下图为单个神经元。</p>
<p><img src="30.png" alt="10"></p>
<p>神经网络是一组神经元连接在一起的集合。第一层一般称为 <code>input layer</code>，中间层称为<code>hidden layer</code>，最后一层称为<code>output layer</code> 。</p>
<p><img src="31.png" alt="10"></p>
<p>具体展开如下：这里的 <code>g()</code> 就是 <code>sigmod</code> 函数</p>
<p><img src="32.png" alt="10"></p>
<h2 id="模型展示Ⅱ">模型展示Ⅱ</h2>
<p>将神经网络的模型进行<strong>向量化</strong>，这种算法又称为 <code>Forward propagation</code>(向前传播) ，因为这是从第一层到第二层等，一直到最后一层。</p>
<p><img src="33.png" alt="10"></p>
<p>如果我们只看最后一层，我们就会发现这里就是一个<strong>逻辑回归</strong>。</p>
<p>神经网络的<strong>架构(architecture)</strong>：不同神经元的连接方式，比如下面就是一种新的架构。</p>
<p><img src="34.png" alt="10"></p>
<h2 id="例子与直觉理解Ⅰ">例子与直觉理解Ⅰ</h2>
<p>假设我们有两个二进制的输入变量 x<sub>1</sub>, x<sub>2</sub> ，这两个变量只能取值0或1。y 分为两类，x<sub>1</sub> 异或 x<sub>2</sub> (x<sub>1</sub> XOR x<sub>2</sub>) 和 其他 (x<sub>1</sub> NXOR x<sub>2</sub>,  等于 NOT (x<sub>1</sub> XOR x<sub>2</sub>))。</p>
<p><img src="35.png" alt="10"></p>
<p>那么我们能不能构建一个神经网络来判定这个分类问题呢？</p>
<p>先看一个简单的 AND 神经元，下面这个神经元的作用相当于一个逻辑与的操作。</p>
<p><img src="36.png" alt="10"></p>
<p>再看一个逻辑 OR 功能的神经元</p>
<p><img src="37.png" alt="10"></p>
<h2 id="例子与直觉理解Ⅱ">例子与直觉理解Ⅱ</h2>
<p>再看一个 NOT 功能的神经元</p>
<p><img src="38.png" alt="10"></p>
<p>将上面的这些组合到一起，生成  x<sub>1</sub> XNOR x<sub>2</sub></p>
<p><img src="39.png" alt="10"></p>
<h2 id="多元分类">多元分类</h2>
<p>要在神经网络中实现多元分类，采用的方法本质上是一种<strong>一对多法</strong>的拓展，这里我们建立一个多个输出值的输出形式，每个输出值表示对一个分类的预测结果，如下图。</p>
<p><img src="40.png" alt="10"></p>
<h2 id=""></h2>
<p>重新排布一下</p>
<p><img src="41.png" alt="10"></p>
<h1>10 神经网络参数的反向传播算法</h1>
<h2 id="代价函数-3">代价函数</h2>
<p>一些基本定义</p>
<p><img src="42.png" alt="10"></p>
<p>现在我们为神经网络定义损失函数。首先我们看逻辑回归的一般模式（加上正则化）：</p>
<p style=""><img src="https://math.now.sh?from=J%28%5Ctheta%29%3D-%5Cfrac%7B1%7D%7Bm%7D%5Cleft%5B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20y%5E%7B(i)%7D%20%5Clog%20h_%7B%5Ctheta%7D%5Cleft(x%5E%7B(i)%7D%5Cright)%2B%5Cleft(1-y%5E%7B(i)%7D%5Cright)%20%5Clog%20%5Cleft(1-h_%7B%5Ctheta%7D%5Cleft(x%5E%7B(i)%7D%5Cright)%5Cright)%5Cright%5D%2B%5Cfrac%7B%5Clambda%7D%7B2%20m%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20%5Ctheta_%7Bj%7D%5E%7B2%7D%0A" /></p><p>对于神经网络，会是这个式子的一般化，式子如下。这里的第二项看上去复杂，其实就和逻辑回归一样，是所有参数的平方和（不包括 bias）。</p>
<p><img src="44.png" alt="10"></p>
<h2 id="反向传播算法">反向传播算法</h2>
<p>上面已经定义了损失函数，我们现在需要找到使得这个损失函数最小的一组参数。如果使用梯度下降等方法，我们就需要计算每一步的损失函数和偏导数。</p>
<p>假设我们的训练集只有一个样本 (x, y) ，首先我们看向前传播过程如下</p>
<p><img src="45.png" alt="10"></p>
<p>为了计算导数项，这里我们采用一种称为反向传播 (Backpropagation) 的算法。</p>
<p>这里我们定义 δ 为某个结点的 “error” ，这里第一层是不计算 δ 的，因为第一层是输入的特征，我们认为是没有误差的。</p>
<p>通过这些 δ 值，我们可以很快地计算偏导数（下图红框，缺证明，单纯记公式），这里的偏导数忽视了正则项。</p>
<p><img src="46.png" alt="10"></p>
<p>整理一下整个过程，有点懵逼了。而且求偏导数，含有正则项的那个式子，应该是少了 1/m 吧。</p>
<p><img src="47.png" alt="10"></p>
<h2 id="理解反向传播">理解反向传播</h2>
<p>假设只有一个输出值（二分类），并且训练集只有一个样本，忽视正则项。为了理解，你可以把此时的损失函数视为某种残差方差函数 (疑问？)</p>
<p><img src="48.png" alt="10"></p>
<p>现在再看反向传播的过程，这些 δ 项可以视为激活项的误差。正式地说，δ 项是代价函数关于 z 的偏导数（没听懂）。</p>
<p><img src="49.png" alt="10"></p>
<p>这里举了个例子，计算 δ<sup>(2)</sup><sub>2</sub>  项，见下图红框。有个疑问，这里没有点乘 g’(z) 。</p>
<p><img src="50.png" alt="10"></p>
<h2 id="使用注意：展开参数">使用注意：展开参数</h2>
<p>神经网络的参数是一个矩阵，但是 octave 使用的参数是一个向量，因此 <strong>需要将矩阵转为向量</strong>（梯度同理）。</p>
<p>举个例子，下图的神经网络共三层，第一层和第二层均是 10 个单元，第三层是一个单元。因此 Θ<sup>(1)</sup> 是一个 10×11 的矩阵。在 octave 中，将所有参数转为一个向量的方式如下：</p>
<p><img src="51.png" alt="10"></p>
<p>在octave 的代码展示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; Theta1 &#x3D; ones(10,11)</span><br><span class="line">Theta1 &#x3D;</span><br><span class="line"></span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line"></span><br><span class="line">&gt;&gt; Theta2 &#x3D; 2*ones(10,11)</span><br><span class="line">Theta2 &#x3D;</span><br><span class="line"></span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line"></span><br><span class="line">&gt;&gt; Theta3 &#x3D; 3*ones(1,11)</span><br><span class="line">Theta3 &#x3D;</span><br><span class="line"></span><br><span class="line">   3   3   3   3   3   3   3   3   3   3   3</span><br><span class="line"></span><br><span class="line">&gt;&gt; thetaVec &#x3D; [ Theta1(:); Theta2(:); Theta3(:) ];</span><br><span class="line">&gt;&gt; size(thetaVec)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   231     1</span><br><span class="line"></span><br><span class="line">&gt;&gt; reshape(thetaVec(1:110), 10,11)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line"></span><br><span class="line">&gt;&gt; reshape(thetaVec(111:220), 10,11)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line"></span><br><span class="line">&gt;&gt; reshape(thetaVec(221:231), 1,11)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   3   3   3   3   3   3   3   3   3   3   3</span><br></pre></td></tr></table></figure>
<h2 id="梯度检测">梯度检测</h2>
<p>反向传播的算法有一些 bug (?) ，在与梯度下降等算法同时使用时，虽然可能看上去每一步的代价函数都在下降，但是可能到了最后，你得到的神经网络其误差将比在无bug的情况下高出一个量级。有一种思路称为梯度检测（Gradient Checking）。</p>
<p>首先我们看如何估计梯度值，举个例子，假设 θ 是一个实数，如果我们要估计 J(θ) 在 θ 的梯度/导数，我们该点左右 ε 距离各取一个点，连接这两个点形成一条直线，该直线的斜率就是该点导数的近似值，这称为双侧差分（two-sided difference）。如果仅取一个点，那么则称为单侧差分（one-sided difference）。双侧差分能得到更加准确的结果，因此一般用双侧积分。</p>
<p><img src="52.png" alt="10"></p>
<p>估计梯度公式如下</p>
<p><img src="53.png" alt="10"></p>
<p>我们得到了梯度的估计值，就和反向传播计算得到的梯度值进行比对，看看二者是不是差不多。</p>
<p>要点如下：先用反向传播得到梯度向量，再用梯度检测得到近似值，比对后如果没问题，关闭梯度检测，直接使用反向传播（因为梯度检测很耗时，如果每次迭代都检测，那么就会很慢）。</p>
<p>有一点不太清楚，这是只用了一轮迭代去检查反向传播有没有问题吗？还是说先用个简单的测试数据从头到尾跑完，对每一次迭代都检查呢？</p>
<p><img src="54.png" alt="10"></p>
<p>我懂了，梯度检查是用来检查你写的代码是否有<strong>bug</strong>，检查的是你的代码，而不是这个算法。如果你写的代码没问题，反向传播的结果就应该是正确的。或者你直接用的大家都用的模块或包，就应该不太需要进行梯度检查了。</p>
<p><img src="55.png" alt="10"></p>
<h2 id="随机初始化">随机初始化</h2>
<p>对于梯度下降或其他优化算法，需要给定一个参数起始值 Θ 。一般我们可能全部设置为0，但是在神经网络中行不通。</p>
<p>因为如果参数都是0，那么所有线的权重均相同，计算的误差项及梯度也均相同，那么每次迭代同一级参数的变化也相同，同一级的参数始终保持一致。</p>
<p><img src="56.png" alt="10"></p>
<p>因此我们对参数进行<strong>随机</strong>初始化，因此我们将所有的参数都从一个范围中随机取值。</p>
<p><img src="57.png" alt="10"></p>
<h2 id="组合到一起">组合到一起</h2>
<p>将前面的串到一起，形容如何构建一个神经网络的全过程。</p>
<h3 id="1-挑选神经网络架构">(1) 挑选神经网络架构</h3>
<p>首先，你需要挑一个神经网络的架构 (architecture) ，架构就是说神经元之间的连接模式（几层，每一层几个神经元）。第一层神经元的数目就是特征的数量，最后一层神经元的数目和分类数目有关。对于隐藏层，一般会设置为1；如果隐藏层数目大于1，那么每一层的神经元的数目通常是一样的（每一层神经元数目越多越好，但是一般和输入特征数目是匹配的，比如相同或是输入特征数目的2倍，3倍等）。</p>
<p><img src="58.png" alt="10"></p>
<h3 id="2-训练神经网络">(2) 训练神经网络</h3>
<p>又分为以下四步。一般来说，我们会用一个 for 循环遍历所有的样本。</p>
<p><img src="59.png" alt="10"></p>
<p>第5步， 使用梯度检查确认计算的梯度没有问题，然后就停用梯度检查（这个意思貌似就是只在第一次迭代进行梯度检查）。第6步，使用梯度下降或其他方法求解参数 Θ</p>
<p><img src="60.png" alt="10"></p>
<p>但是对于神经网络，J(Θ) 是一个<strong>非凸函数</strong>，因此理论上可能收敛于<strong>局部最小值</strong>，但是一般结果还是比较好的，接近于绝对最小值。举个例子，见下图。</p>
<p><img src="61.png" alt="10"></p>
<h1>11 应用机器学习的建议</h1>
<h2 id="决定下一步做什么">决定下一步做什么</h2>
<p>假设你使用一个正则化的线性回归来预测房价，但是你使用测试集来检验效果，发现预测误差很大。那么下一步你要怎么做呢？</p>
<p><img src="62.png" alt="10"></p>
<p>如果你只采用某一种方法，之后你可能会发现可能不是这个原因。</p>
<p>我们会用一种称为<strong>机器学习诊断</strong>的方法来判断哪里有问题，如果去优化。</p>
<h2 id="评估假设">评估假设</h2>
<p>这个标题翻译得不好，英文是 Evaluating your hypothesis ，其实意思是评估你拟合的函数/模型。</p>
<p>一般你可以将数据<strong>随机</strong>分为训练集和测试集，一般来说划分比例是 <strong>7:3</strong> 。用训练集拟合模型，用测试集计算损失函数或其他衡量错误比例的指标。下图为逻辑回归的指标 (test error)。</p>
<p><img src="63.png" alt="10"></p>
<h2 id="模型选择和训练、验证、测试集">模型选择和训练、验证、测试集</h2>
<p>如果设计到模型选择的问题，那么你就要将数据分为三部分，也就是训练集、验证集和测试集。</p>
<p>假设你面临的模型选择问题是，从不同的多项式回归中选择一个函数：</p>
<p><img src="64.png" alt="10"></p>
<p>如果你只将数据分为训练集和测试集，用训练集拟合模型，用测试集来挑最好的模型，假设最后挑中了自由度为 5 的模型为最佳模型。此时我们如果看这个模型的泛化能力呢？如果你还用测试集去计算，这就不是一个对泛化误差的有效估计。</p>
<p><img src="65.png" alt="10"></p>
<p>为了解决这个问题，我们将数据分为三部分，训练集，验证集 (交叉验证集)和测试集，一般这三者的比例是 <strong>6:2:2</strong> 。</p>
<p><img src="66.png" alt="10"></p>
<p>我们用训练集拟合模型，然后用验证集挑选模型，用测试集求泛化误差。</p>
<h2 id="诊断偏差与方差">诊断偏差与方差</h2>
<p>如果你的模型的效果比较差，<strong>要么就是你的偏差比较大，要么就是你的方差比较大</strong>。也就是说，要么就是欠拟合问题，要么就是过拟合问题。因此，一个有效的问题是到底你的问题是偏差大呢还是方差大呢？</p>
<p>根据下图，通过计算 J<sub>train</sub>(Θ) 和 J<sub>cv</sub>(Θ) 并比较，就可以判断到底是偏差大还是方差大。</p>
<p><img src="67.png" alt="10"></p>
<h2 id="正则化和偏差、方差">正则化和偏差、方差</h2>
<p>通过调节正则化参数 λ 可以调节偏差大或方差大的问题。这里用的一系列的 λ 值是每一次是上一次的两倍。注意，我们只用含有正则化的损失函数用于训练集拟合参数，真正计算训练集、验证集和测试集的效果时不包含正则项。</p>
<p><img src="68.png" alt="10"></p>
<p>也就说我们使用正则化的损失函数用于训练集拟合不同 λ 的参数，根据拟合的参数和一般的损失函数用于验证集计算不同λ在验证集的效果，根据这个结果选择一个最佳的  λ 值和相应的参数。最后用选好的参数和模型计算测试集的损失函数（不包含正则项），表示泛化效果。</p>
<p><img src="69.png" alt="10"></p>
<h2 id="学习曲线">学习曲线</h2>
<p>描绘一个横坐标为<strong>训练集样本数目</strong>，纵坐标为 error  的曲线。当样本数量很少时，训练集可以很好地拟合甚至完美拟合，因此训练集的误差很小；反之则越大。对于验证集，结论则相反。</p>
<p><img src="70.png" alt="10"></p>
<p>我们现在来看 high bias 和 high variance 下的学习曲线。首先看 high bias 的情况，也就是欠拟合。随着样本数量的增加，训练集误差首先会很快提高，之后无论样本数量如何提高都几乎不变；验证集误差首先会很快降低，之后无论样本数量如何提高都几乎不变。并且最后训练集和验证集二者的误差非常接近。<strong>这是因为你的模型太简单了，提高训练集的数据量没有太大的帮助，模型后期几乎不会变化</strong>。</p>
<p><img src="71.png" alt="10"></p>
<p>然后我们再看 high variance 的情况，也就是过拟合。随着训练集数据量的提高，虽然还存在过拟合，但是可能就无法完全拟合了，因此训练集误差会逐渐提高；验证集误差会逐渐降低，但是<strong>验证集误差与训练集误差之间始终会存在很大的间隔 (gap)</strong> 。<strong>过拟合情况下，提高训练集的数据量是有作用的</strong>。</p>
<p><img src="72.png" alt="10"></p>
<h2 id="决定接下来做什么">决定接下来做什么</h2>
<p>回到我们最初的问题，假如你用一个正则化的线性回归预测房价，效果很差。那么下一步你该如何改善模型呢？</p>
<p>万变不离其宗，首先你要判断你现在到底是处于<strong>高偏差</strong>还是处于<strong>高方差</strong>的情况？然后再挑选相应的处理方式。</p>
<p><img src="73.png" alt="10"></p>
<p>以神经网络为例，你可以选择一种复杂的神经网络，但是容易欠拟合；你也可以用复杂的神经网络，同时使用正则化来解决过拟合的问题。一般来说，这两种思路中第二种比较好。</p>
<p>你还需要选择隐藏层的数目，一层还是多层。这个可以通过交叉验证来解决，选择最优的层数。</p>
<p><img src="74.png" alt="10"></p>
<h1>12 机器学习系统设计</h1>
<h2 id="确定执行的优先级">确定执行的优先级</h2>
<p>假设我们要区分垃圾邮件和非垃圾邮件，我们的特征就是 100 个单词的指示变量（如果出现了该单词则为1，反之则为0）（实践中一般是选取训练集中出现频率最高的单词）。</p>
<p>那么如何使你的模型错误率最低呢？</p>
<ul>
<li>
<p>收集大量数据</p>
</li>
<li>
<p>从邮件标题中创建更复杂精巧的特征</p>
</li>
<li>
<p>从邮件内容中创建更复杂精巧的特征，比如 “discount&quot; 和 “discounts” 是否应视为同一个单词？又或者 “deal” 和 “Dealer” ?  标点符号作为特征？</p>
</li>
<li>
<p>设计复杂的算法来检测错误拼写（垃圾邮件可能通过故意拼错单词来躲避检测）</p>
</li>
</ul>
<p>你可能会想到很多方法。</p>
<h2 id="误差分析">误差分析</h2>
<p>当你开发机器学习应用时，建议：</p>
<ol>
<li>一开始通过<strong>简单的算法</strong>迅速实现，然后使用验证集进行验证（不要花太长时间）。</li>
<li>第二步，通过画<strong>学习曲线</strong>来决定是否需要更多的数据，更多的特征等措施。</li>
<li>进行<strong>误差分析</strong>，手动检查验证集中分错的样本的情况，查看这些经常分错的样本有没有什么共同的特征或规律。</li>
</ol>
<p>接着上面的垃圾邮件的例子，假设验证群有500封邮件，这个算法就分错了100封邮件。你现在要做的是，首先手动对这些邮件进行分类（比如都是买手表的，医院的等），第二判断哪些特征加入进来可以有助于将这些邮件正确分类。</p>
<p><img src="75.png" alt="10"></p>
<p>你需要有一个数值型的评价指标评估模型好坏。比如我们考虑是否将 discount/discounts/discounted/discounting 这些单词视为相同的单词？我们需要用 ”stemming&quot; 软件吗？（这种软件会查看一个单词的前几个字母来判断是否视为相同单词）。但是这种做法也有一些问题，比如 universe/university 。此时误差分析可能也无助于事，唯一的办法就是两种都试一下，看看效果（需要有一个数值指标判断效果）。</p>
<p><img src="76.png" alt="10"></p>
<p>注意误差分析要在<strong>验证集</strong>上做，而不是训练集。</p>
<h2 id="不对称分类的误差评估">不对称分类的误差评估</h2>
<p>训练逻辑回归用于判断用户是否患有癌症，如果你的训练集中只有 0.5% 的癌症样本，那么只要你写一个永远返回 0 的函数，错误率就只有 0.5% 。</p>
<p><img src="77.png" alt="10"></p>
<p>我们将两种分类比例非常极端的情况称为<strong>偏斜类 (skewed classes)</strong>。面对这种数据时，我们可能希望一个不同于错误率的指标，称为<strong>精确率和召回率（Precision/Recall）</strong>。</p>
<p>如何理解这个概念呢？我们先画一个2×2的表格，定义这两个概念如下：注意，我们都是默认 y = 1 表示频率很低地那个分类。</p>
<p><img src="78.png" alt="10"></p>
<p>如果我们用这两个指标，如果模型只是简单地将返回 y = 0，那么精确率和召回率就都是 0 ，这就说明这不是一个好的分类模型。</p>
<h2 id="精确度和召回率的权衡">精确度和召回率的权衡</h2>
<p>这里仍然采用上面的例子，用逻辑回归预测癌症。假设我们希望只有我们置信度很高时才预测 y = 1 。因此，我们将预测癌症时的判定阈值从 0.5 改为 0.7，此时<strong>精确度会提高，而召回率会降低</strong>。</p>
<p>反过来，假设我们想避免遗漏太多癌症病例（避免<strong>假阴性</strong>），换句通俗的话说，宁可错杀一千，不可放过一个。此时，我们就会将预测时的判定阈值改得比较低，比如 0.3 ，此时<strong>召回率会提高，而精确度会降低</strong>。</p>
<p>画图结果如下</p>
<p><img src="79.png" alt="10"></p>
<p>那么如何比较不同的模型呢？我们可以创建一个新的指标，综合精准度和召回率。如果你采用二者的平均值，那么就会得到一个极端的模型，见下图。实际上我们有一个指标，称为 F<sub>1</sub> Score</p>
<p><img src="80.png" alt="10"></p>
<h2 id="机器学习数据">机器学习数据</h2>
<p>根据前人的研究，当训练集的数据量不断增加时，不同算法的效果可能会趋近，甚至可能一些认为比较差的算法会超过比较好的算法。这种情况什么时候是真的，什么时候是假的呢？</p>
<p><img src="81.png" alt="10"></p>
<p>让我们有假设各种不同的情况，如果特征 x 有足够的信息来确认 y ，那么这种情况可能是成立的。反过来如果特征信息不够，那么增大数据量是没啥用的，比如只用房屋面积去预测房子价格。一个有用的测试是，假如你拿着这些信息去问一个经验丰富的”专家“，比如你只拿着房屋面积去问一个房地产专家预测一下这个房子价格，他也不可能告诉你房子的预测价格。</p>
<p>现在我们假设特征 x 具有足够的信息去预测 y ，假设你使用一个<strong>参数很多</strong>的学习算法，因此可以拟合非常复杂的参数。此时如果你用一个<strong>非常大</strong>的训练集，那么就不太可能出现过拟合现象。</p>
<h1>13 支持向量机</h1>
<h2 id="优化目标">优化目标</h2>
<p>先从逻辑回归开始引出支持向量机，先看损失函数</p>
<p><img src="82.png" alt="10"></p>
<p>SVM 的损失函数如下：</p>
<p><img src="83.png" alt="10"></p>
<h2 id="直观上对大间隔的理解">直观上对大间隔的理解</h2>
<p>如果两类分类是线性可分的，那么 SVM 会以最大的间距分隔这两类（前提是 C值很大）。</p>
<p><img src="84.png" alt="10"></p>
<p>但是这种大间隔算法容易受到<strong>异常值</strong>的影响，需要通过调节参数 C 来解决这个问题。</p>
<p><img src="85.png" alt="10"></p>
<h2 id="大间隔分类器的数学原理">大间隔分类器的数学原理</h2>
<p>这一节是讲解原理，选修，感觉不是很清晰，略过。</p>
<h2 id="核函数1">核函数1</h2>
<p>如果你要构造一个非线性的决策线，你可能会想到使用多项式，但是当特征数量很多时，使用多项式并不现实。现在有一种新的构建新的特征的方法， 先选取几个点称为标记（landmarks），新的特征就是就是样本点与这些标记的相似度，如下图。<strong>这里计算相似度的函数就称为核函数</strong>。</p>
<p><img src="86.png" alt="10"></p>
<p>我们进一步看看这里的核函数（高斯核函数）是如何发挥作用的</p>
<p><img src="87.png" alt="10"></p>
<p>我们看个例子，画图如下</p>
<p><img src="88.png" alt="10"></p>
<p>使用新的特征预测，举例如下图。决策线只是对于新的特征是线性的，因此对于原来的特征就可以是非线性的。</p>
<p><img src="89.png" alt="10"></p>
<h2 id="核函数2">核函数2</h2>
<p>那么如何设置标记点呢？假设你见每个样本点均设置为一个标记，如下图</p>
<p><img src="90.png" alt="10"></p>
<p><img src="91.png" alt="10"></p>
<p>SVM 参数的作用如下</p>
<pre><code>![10](92.png)
</code></pre>
<h2 id="使用SVM">使用SVM</h2>
<p>你需要确认参数 C 的大小和需要使用的核函数。</p>
<pre><code>![10](93.png)
</code></pre>
<p>使用高斯核函数前需要进行特征缩放。</p>
<pre><code>![10](94.png)
</code></pre>
<p>逻辑回归与SVM的比较。当你的特征数量相对样本数很多时，建议使用逻辑回归或不使用核函数的SVM；当特征数目相对较少，样本数量中等时，建议使用高斯核函数的SVM；当特征数目较少，样本数量非常大时，使用高斯核函数的SVM速度很慢，此时建议使用逻辑回归或不使用核函数的SVM。但是，这里所有的情况下，神经网络都可能适合使用，只是可能速度比较慢。</p>
<pre><code>![10](95.png)
</code></pre>
<h1>14 无监督学习</h1>
<h2 id="K-Means-算法">K-Means 算法</h2>
<p>你需要事先指定分类数 K 的值，K均值算法过程描述如下：</p>
<pre><code>![10](96.png)
</code></pre>
<h2 id="优化目标-2">优化目标</h2>
<p>K均值算法的代价函数是所有样本到其所属的cluster的欧几里得距离的平方和。</p>
<pre><code>![10](97.png)
</code></pre>
<p>我们再看一些细节，K均值算法中簇分配的过程，其实就是在最小化代价函数（缺证明）。</p>
<pre><code>![10](98.png)
</code></pre>
<h2 id="随机初始化-2">随机初始化</h2>
<p><strong>K近邻的分类结果是一个局部最优解，受到初始值的影响</strong>。为了避免局部最优解，可以随机初始化K近邻一开始的cluster中心，重复多次。比如假设 K=2，你可以每次随机挑选两个样本，作为一开始的cluster中心。</p>
<p>举个例子，如果你重复做<strong>100</strong>次随机初始化的 K近邻，得到这 100 次的代价函数，选择其中<strong>代价函数最低</strong>的一次结果。这样做适用 K 比较小的时候，如果 K 很大，可能做一次就行了，重复多次效果提升不大。</p>
<h2 id="选取聚类数量">选取聚类数量</h2>
<p>选取聚类数量，也就是 K 值基本上还是手动选择的，比如查看可视化的图等。有一个方法称为<strong>肘部法则</strong>。你可以通过画一个代价函数与K值的曲线，你可以找到一个<strong>肘部</strong>的地方，那么可能这个地方就是一个比较合理的分类方法。但是这个方法并不常用，因为实际情况下你可能不太容易找到一个肘部的分界点。下图左边是一个理想情况，右边是一个不理想情况。</p>
<pre><code>![10](99.png)
</code></pre>
<p>还有一种选择K值的方法，就是你根据<strong>聚类的目的</strong>作为标准来挑选合适的K值。假设你想对T恤进行分类，你可以从商业的角度去思考，到底分类数目多少比较合适。</p>
<pre><code>![10](100.png)
</code></pre>
<h1>15 降维</h1>
<h2 id="目标Ⅰ：数据压缩">目标Ⅰ：数据压缩</h2>
<p>略</p>
<h2 id="目标Ⅱ：可视化">目标Ⅱ：可视化</h2>
<p>略</p>
<h2 id="主成分分析问题规划1">主成分分析问题规划1</h2>
<p>使用PCA分析前，需要进行<strong>特征缩放</strong>。PCA 的思路就是使<strong>投影误差的平方</strong>（样本点到线/平面的垂直距离的平方）最小。</p>
<pre><code>![10](101.png)
</code></pre>
<p>PCA 分析与线性回归不一样，定义的距离不一样，线性回归是两个点的距离，PCA分析是与直线的垂直距离。</p>
<pre><code>![10](102.png)
</code></pre>
<h2 id="主成分分析问题规划2">主成分分析问题规划2</h2>
<p>PCA 分析前的预处理：特征缩放/均值标准化 (mean normalization)，内容见上。</p>
<p>PCA 求解可以通过对协方差矩阵进行奇异值分解（这里特征值分解结果一样，因为协方差矩阵是一个正定对称矩阵，其特征值分解与奇异值分解结果一样。）</p>
<p>然后我们提取 <img src="https://math.now.sh?inline=U" style="display:inline-block;margin: 0;"/> 矩阵的前 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 个列向量（这里 <img src="https://math.now.sh?inline=U" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 应该是一样的），获得一个  <img src="https://math.now.sh?inline=n%20%5Ctimes%20k" style="display:inline-block;margin: 0;"/> 的矩阵 <img src="https://math.now.sh?inline=U_%7Breduce%7D" style="display:inline-block;margin: 0;"/> ，这就是我们需要的特征向量。我们得到的降维后的数据为   <img src="https://math.now.sh?inline=z%5E%7B%28i%29%7D%20%3D%20U_%7Breduce%7D%5E%7BT%7D%20x%5E%7B(i)%7D" style="display:inline-block;margin: 0;"/> ，这里  <img src="https://math.now.sh?inline=U_%7Breduce%7D%5E%7BT%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=k%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵，<img src="https://math.now.sh?inline=x%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=n%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 的向量，因此 <img src="https://math.now.sh?inline=z%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=k%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 的向量。</p>
<p><img src="172.png" alt="10"></p>
<h2 id="主成分数量选择">主成分数量选择</h2>
<p>我们希望挑选的k值（主成分数目），使得满足下式：</p>
<p>​    <img src="103.png" alt="10"></p>
<p>计算如下：</p>
<p>​    <img src="104.png" alt="10"></p>
<p>整理如下：</p>
<p><img src="105.png" alt="10"></p>
<h2 id="压缩重现">压缩重现</h2>
<p>我们一般将PCA视为降维的方法，那么如何从降维后的数据返回到降维前的数据呢？</p>
<p>看不懂，返回的是一个近似值，计算公式如下（下面公式是一个线性映射，这个公式得到的<img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 只是  <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 维空间的一个子空间）</p>
<p style=""><img src="https://math.now.sh?from=x_%7Bapprox%7D%20%3D%20U_%7Breduce%7D%20z%20%0A" /></p><p>这里  <img src="https://math.now.sh?inline=U_%7Breduce%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=n%20%5Ctimes%20k" style="display:inline-block;margin: 0;"/> 的矩阵，<img src="https://math.now.sh?inline=z" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=k%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 的向量，因此 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=n%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 的向量。</p>
<p><img src="106.png" alt="10"></p>
<h2 id="应用PCA的建议">应用PCA的建议</h2>
<p>假设你有一个监督学习问题，特征数量特征多，比如 100×100的像素点，那么就是 10,000 个特征。如果你直接把这些特征代入到机器学习的算法中，计算速度会很慢。<strong>这里你可以先用PCA对特征进行降维</strong>。</p>
<p><img src="107.png" alt="10"></p>
<p>PCA 的应用总结如下：</p>
<p><img src="108.png" alt="10"></p>
<p>PCA 分析的错误应用是用于避免过拟合，避免过拟合应该使用正则化。PCA 压缩过程中没有考虑标签，因此可能会丢失一些有用的信息。PCA 降维用于分析的主要目的是<strong>提速</strong>。</p>
<p><img src="109.png" alt="10"></p>
<p>在你使用 PCA 前，你最好先用原始特征计算一下，<strong>能不用PCA就不用</strong>，除非速度太慢。</p>
<p><img src="110.png" alt="10"></p>
<h1>16 异常检测</h1>
<h2 id="问题动机">问题动机</h2>
<p>首先，什么是异常检测呢？举个例子，假设你是个飞机引擎制造商，在生产过程中你需要进行质控测试，你测量了一些特征变量，比如产生的热量等。因此，你拿到了一些无标签的数据，如果这时候有一个新的引擎的数据，你想知道这个引擎是否有异常。</p>
<p><img src="111.png" alt="10"></p>
<p>这个过程就是计算这个新数据出现的概率，如果概率低于某个值，你就认为这个新数据存在异常。</p>
<p><img src="112.png" alt="10"></p>
<h2 id="高斯分布">高斯分布</h2>
<p>参数估计，假设你得到一组数据，并且认为它们服从正态分布，那么如果估计参数 μ 和 σ<sup>2</sup> 呢？根据最大似然法的思想，你可以得到这两个参数的估计值就是样本均值和样本方差（除以 1/(m-1) ，而不是 1/m）（证明可以参考我自己整理的博客<a href="https://vincere.fun/posts/c8ae5def/">为什么样本方差分母为n-1</a>）。但是在机器学习中，出于惯例一般还是使用 1/m （实践中，二者相差很小）。</p>
<h2 id="异常检测-算法">异常检测 算法</h2>
<p>假设我们有一个共有 m 个样本的无标签训练集，假设所有特征均服从正态分布。那么一个新的数据出现的概率如下（假设不同特征彼此独立，但是吴老师不独立实际效果也可以）：</p>
<p><img src="113.png" alt="10"></p>
<p>因此，创建一个异常检测算法的步骤如下。这里有一个小问题，新样本出现的概率计算的是<strong>概率密度函数值</strong>，并不是概率，这里也没有解释。</p>
<p><img src="114.png" alt="10"></p>
<p>举个例子，如下图。这里画的圈圈是决策线，就是说在这个圈以外的点出现的概率就比较低，就会认定为异常值。</p>
<p><img src="115.png" alt="10"></p>
<h2 id="开发和评估异常检测系统">开发和评估异常检测系统</h2>
<p>假设你有一些带有标签的数据（正常则 y=0，异常则 y=1）,我们将数据分为三类，训练集是不带有标签的正常数据，交叉验证集和测试集则是两种情况都有带有标签的数据。举个例子，假设你总共有 10000 个正常的飞机引擎和 20 个异常的飞机引擎，这是你全部的数据。你可以按照下面的方式分配数据。</p>
<p><img src="116.png" alt="10"></p>
<p>有一种不好的做法是将相同的数据分配同时分配给交叉验证集和测试集。这三个数据集应该是要彼此分开的。</p>
<p>因为这里用到的数据是非常 skewed ，正常的数据比异常数据多很多，因此分类错误率就不再是一个合格的指标，因此要用别的指标。你可以用交叉验证的方法选择好使用哪些特征，ε 参数的值等。</p>
<p><img src="117.png" alt="10"></p>
<h2 id="异常检测-VS-监督学习">异常检测 VS 监督学习</h2>
<p>上一节使用了带有标签的数据，那么有一个问题就是，为什么我们不用监督学习的方法呢？比如用逻辑回归。则二者的对比如下（吴老师讲得太清晰了）</p>
<p><img src="118.png" alt="10"></p>
<p>二者的应用举例如下</p>
<p><img src="119.png" alt="10"></p>
<h2 id="选择要使用的特征">选择要使用的特征</h2>
<p>由于我们假定特征服从正态分布，因此你可以先画直方图看一下这些特征是不是类似正态分布。如果有特征不符合正态分布，你可能要做一些转换，使得数据更符合高斯分布，比如使用 log() 函数进行<strong>对数转换</strong>，或者使用开发等，可以调节这里的参数。</p>
<p><img src="120.png" alt="10"></p>
<p>使用 octave 进行转换，代码截图</p>
<p><img src="121.png" alt="10"></p>
<p>还有一个问题，如何新增特征，提高异常检测的效果，一个通用的方法是<strong>误差分析</strong>。一个通常的问题是正常样本和异常样本的概率密度值都很大。下图中，异常样本在特征 x1 中的概率密度值很大，因此我们想要找到一个新的特征 x2 ，使得这个异常样本的  x2 的概率密度值很小。</p>
<p><img src="122.png" alt="10"></p>
<p>特征挑选时，一般要挑选哪些异常样本的值特别大或特别小的特征，以电脑异常的例子，举例如下：</p>
<p><img src="123.png" alt="10"></p>
<h2 id="多变量高斯分布">多变量高斯分布</h2>
<p>举个例子，检测计算机是否异常，假设有两个特征，有一个新的数据如图，根据之前提到的异常检测算法，不会将这个数据视为异常数据，这就有点问题。这里我感觉就是这两个特征之间不独立造成的，CPU占用高时一般内存占用也高。</p>
<p><img src="124.png" alt="10"></p>
<p>为了解决这个问题，我们采用多元正态分布。</p>
<p><img src="125.png" alt="10"></p>
<p>让我们来看一些多元正态分布的例子。</p>
<p><img src="126.png" alt="10"></p>
<p>如果两个特征的方差不一样，则如下图</p>
<p><img src="127.png" alt="10"></p>
<p>多元正态分布的优点在于可以捕捉特征之间的<strong>相关</strong>，只要修改方差矩阵即可</p>
<p><img src="128.png" alt="10"></p>
<p>如果协方差为负数，则画图如下：</p>
<p><img src="129.png" alt="10"></p>
<h2 id="使用多变量高斯分布的异常检测">使用多变量高斯分布的异常检测</h2>
<p>首先我们看如何估计参数，见下式（缺证明）</p>
<p><img src="130.png" alt="10"></p>
<p>构建算法如下：</p>
<p><img src="131.png" alt="10"></p>
<p>这和之前的算法有什么联系呢？实际上，之前的算法是一种特殊的多元高斯分布，其<strong>方差矩阵非对角线元素均为0</strong>（不同特征彼此独立），也就是说它的方差矩阵是一个对角阵，它的概率分布是<strong>轴对称</strong>的。</p>
<p>那么你在什么时候应该用原来的模型，什么时候应该用多元高斯分布呢？如果你想用原来的模型捕捉特征之间的相关，那么你要自己手动新建特征，比如说 x3 = x1/x2 。二者的比对如下</p>
<p><img src="132.png" alt="10"></p>
<p>一般来说原来的模型用的更多。如果你使用多元高斯分布，发现方差矩阵不可逆，可能有两个原因，第一是没有满足样本数远大于特征数，第二是存在冗余的特征，或者说特征之间存在线性相关。</p>
<h1>17 推荐系统</h1>
<h2 id="问题规划">问题规划</h2>
<p>举个电影评分的例子，假设我们要预测不同的人的电影评分，以更好地推荐新电影。</p>
<p><img src="133.png" alt="10"></p>
<h2 id="基于内容的推荐算法">基于内容的推荐算法</h2>
<p>接着上面的例子，假设每部电影有两个特征，表示电影的浪漫程度和动作成分。我们可以对每个用户做一个线性回归，每个用户有自己的参数，然后预测他们没看过的电影的评分。</p>
<p><img src="134.png" alt="10"></p>
<p>问题解析如下：</p>
<p><img src="135.png" alt="10"></p>
<p>整理一下，下面是对全部参数进行拟合。这和普通的线性回归差不多。</p>
<p><img src="136.png" alt="10"></p>
<h2 id="协同过滤">协同过滤</h2>
<p>这是一种新的算法，它有一个特性称为<strong>特征学习(feature learning)</strong> ，这种算法可以自行决定使用什么特征。</p>
<p>接着上面的例子，假设我们不知道电影的两个特征的值，我们知道每个用户对不同题材电影的喜爱程度，那我们就可以反推每部电影的两个特征的值。</p>
<p><img src="137.png" alt="10"></p>
<p>将问题标准化</p>
<p><img src="138.png" alt="10"></p>
<p>我们将这两种方式总结一下，便是协同过滤的算法：我们先给定一个参数初始值 θ，然后估计出一组特征值 x,  用这组特征值再估计出一个更好的参数估计值 θ，依次循环往复。</p>
<p><img src="139.png" alt="10"></p>
<p>协同过滤算法需要观察大量的用户，观察这些用户的实际行为，来协同地得到更佳的每个人对电影的评分值。如果每个用户都对一部分电影进行了评分，那么每个用户都在帮助算法学习出更合适的特征，然后这些学习出的特征又可以被用来更好地预测其他用户的评分。因此协同的另一层意思是说每位用户都在帮助算法更好地进行特征学习。</p>
<h2 id="协同过滤算法">协同过滤算法</h2>
<p>根据上面的算法，只要给定参数或特征中的一个，我们就能估计另一个。下面这种算法，我们可以同时估计参数和特征（将两个损失函数合并到一块），这样就不用再来回迭代估计参数和特征，可以一步到位。<strong>这种算法放弃了一个惯例，不再编码 x<sub>0</sub> 和 θ<sub>0</sub></strong> ，因为现在是在学习全部的特征，不再需要强行设置一个值全为1的特征，如果算法真的需要一个特征永远为 1，它可以靠自己实现，比如可以将特征 x<sub>1</sub> 设为 1。</p>
<p>因此这里的协同过滤算法描述如下：</p>
<p><img src="140.png" alt="10"></p>
<h2 id="矢量化：低轶矩阵分解">矢量化：低轶矩阵分解</h2>
<p>协同过算法的矢量化实现方法。首先将数据转为矩阵：</p>
<p><img src="141.png" alt="10"></p>
<p>这种计算方法又称为<strong>低秩矩阵分解 (low rank matrix factorization)</strong> ， 因为 XΘ<sup>T</sup> 是低秩的。</p>
<p>当我们拟合出一系列特征之后，我们如果计算两部电影的相关呢？我们可以用两个电影特征值的距离来表示相关。因此你可以找到与某一部电影最相似的5部电影，用于推荐给用户。</p>
<p><img src="142.png" alt="10"></p>
<h2 id="实施细节：均值归一化">实施细节：均值归一化</h2>
<p>假设我们有一个新的用户 Eve, 她没有给任何一部电影打分，出于最小化代价函数的目的，她的参数估计值会全是 0 ，因此新用户所有电影的预测值均为0，因此无法给她推荐电影，这个结果并不好。均值归一化的思想可以让我们解决这个问题。（下图预测值写反了吧，不是 XΘ<sup>T</sup>  吗？）</p>
<p><img src="143.png" alt="10"></p>
<p>如果我们要实现均值归一化，首先我们对数据矩阵按行进行中心化，然后使用这个数据矩阵进行估计参数和特征，最后预测时需要加上行均值。此时，新用户的预测值就是每一部电影的平均评分。（额，这里是中心化，不是均值均一化啊）。</p>
<p><img src="144.png" alt="10"></p>
<h1>18 大规模机器学习</h1>
<h2 id="学习大数据集">学习大数据集</h2>
<p>当你数据量很大，比如过亿，假设你用梯度下降对线性回归拟合参数，那么每一步你都需要进行上亿步的求和操作，计算量很大。这时候你可以先随机抽取一个小样本，比如1000个样本，用于初始拟合参数，先看一下情况，看一下学习曲线。</p>
<p><img src="145.png" alt="10"></p>
<h2 id="随机梯度下降">随机梯度下降</h2>
<p>假设你正在用梯度下降来拟合线性回归，每一次都要对所有样本进行计算，计算量很大，这种算法也称为  <strong>批量梯度下降 (Batch gradient descent)</strong> 。一种更好的算法称为<strong>随机梯度下降算法 (Stochastic gradient descent)</strong> 。</p>
<p><img src="146.png" alt="10"></p>
<p>整理一下，随机梯度下降下山速度更快，因为每次只算一个样本，但是每一步方向并不是直指圆心，但是总体还是向局部最小值移动的，随机梯度下降不会收敛，而是在局部最小值附近震荡，最终我们会得到一个<strong>很接近</strong>局部最小值/全局最小值的参数，这对实际应用来说已经足够了。<strong>随机梯度外层循环一般 1-10 次左右</strong>。如果你的数据量非常大，比如3亿，那么你可能只要做一次外层循环就够用了。</p>
<p><img src="147.png" alt="10"></p>
<h2 id="Mini-Batch-梯度下降">Mini-Batch 梯度下降</h2>
<p>Mini-Batch 算法介于批次梯度下降和随机梯度下降之间，每次使用 b 个样本，一般 b 设置为 10 ，范围一般在 2 -100。算法描述如下图，<strong>Mini-Batch 算法可能比随机梯度下降算法更快</strong>，因为这 10 个样本求和可以使用<strong>向量化</strong>的方式执行。</p>
<p><img src="148.png" alt="10"></p>
<h2 id="随机梯度下降收敛">随机梯度下降收敛</h2>
<p>当你使用批量梯度下降时，你可以通过观察每一步的损失函数变化来查看是否收敛。但是当数据量很大时，整体的 损失函数计算量很大，查看损失函数方式如下：</p>
<p><img src="149.png" alt="10"></p>
<p>下面是几幅损失函数下降的图片。左上图是理想情况，红线是采用了更小的学习率的情况，因为随机梯度下降算法最终结果会在一个区间内震荡，如果学习率更小，那么震荡可能更小，但是一般差距不大。右上图红线为每隔 5000 步计算一次损失函数均值的情况，会更加平缓。左下图蓝线为每隔 1000 步的情况，红线为每隔 5000 步的情况，这时候就是因为求均值的样本太少了，所以包含了太多的噪音导致看不出趋势，橙线为每隔5000步的另一种情况，此时还是比较平坦，那么可能就是学习率或特征选择的问题。右下图显示损失函数在增加，这种情况下说明你需要使用更小的学习率。</p>
<p><img src="150.png" alt="10"></p>
<p>在随机梯度下降中的经典应用中，学习率一般是一个不变的常数。如果你想要更好地收敛到全局最小值，你可以让学习随时间逐渐减少。但是很多人不愿意用这个方式，因为你需要花额外的时间来确认这两个额外的参数，这使得算法更加复杂。</p>
<p><img src="151.png" alt="10"></p>
<h2 id="在线学习">在线学习</h2>
<p>假设你从事运输服务，经常有新用户询问你把包裹从A地运到B地的服务。同时你有一个网站，上面有很多用户需要寄包裹，网站会提供一个价格，用户可能会选择接受这个价格（y = 1），有时不会（y = 0）。假设我们想优化我们的算法，来给用户提供一个更好的价格。这里的特征就是用户的一些特点, 包裹起始地和我们提供的价格，我们想计算用户接受这个价格的概率。这是一个分类问题，我们可以用逻辑回归或神经网络，这里我们选择用逻辑回归。</p>
<p>由于你的网页是一直运行的，一直会有人访问，提供新的数据，因此你可以实时更新估计参数（采用梯度回归）。此时你的训练集的数据量是不固定的，<strong>每一个样本只用一次，用完就丢掉</strong>。这种方式适合大型网站，有持续的数据流，因为你可以获取的数据是无限的，因此没有必要多次使用一个样本（给我的感觉是财大气粗，数据太多了，浪费一点无所谓了）。但是，如果你只有少量的用户，那么你最好不要用这种算法，最好是将所有数据保存起来。</p>
<p>在线学习算法的另一个优势是<strong>可以适应变化的用户偏好</strong>。举个例子，假设当用户对价格更加敏感或不敏感，这种算法可以更加变化的用户偏好进行调试。说白了，就是在线学习会始终追随最新的用户数据进行调整。</p>
<p><img src="152.png" alt="10"></p>
<p>举个其他例子，假设你是一个买手机的， 你的用户界面可以让用户输入一些关键词，比如安卓 1080p 摄像等。假设你的店铺中有100部手机，每次搜索会返回 10 个结果。我们需要一个算法来指定返回哪10步手机，下面是一个解决思路，这里的特征是手机的特点，搜索词与手机名的匹配程度，搜索词与手机描述词的匹配程度等，y 是用户是否会点击链接。这种问题一般也称为<strong>点击率预测学习问题</strong>（点击率就是用户点击链接的概率）。</p>
<p>如果你使用在线学习的算法，那么每次一个用户来搜索一次，那么就会新增 10 个数据，那么你可以做10次梯度下降，更新参数，然后你就可以丢弃这些数据。这样的例子还有很多。</p>
<p><img src="153.png" alt="10"></p>
<p>总的来说，在线学习算法与随机梯度下降算法很类似，只是不再使用固定的训练集。</p>
<h2 id="Map-reduce与并行计算">Map-reduce与并行计算</h2>
<p>有时数据量太大而不能在一台机器上运行。MapReduce 是可以用于大规模数据的另一种算法。举个例子，假设你想要对线性回归采用梯度下降，总共有400个样本，分成4份，给四台机器进行运算，最后再汇总，这样速度理论上会提升4倍。</p>
<p><img src="154.png" alt="10"></p>
<p>MapReduce 算法如下，首先将训练集随机划分为几部分，分别给一台机器进行运算，最后再汇总（这个好像多进程）。</p>
<p><img src="155.png" alt="10"></p>
<p>如果你的计算是用到了<strong>训练集数据的求和</strong>，那么你就可以考虑使用 MapReduce 方法。</p>
<p><img src="156.png" alt="10"></p>
<p>一台机器也可以这么做，因为 CPU 有多核心，例如四核，那么你就可以将训练集拆分成四分。这样你就不用在不同机器之间进行通信，不用考虑网络延迟的影响。实际上，很多线代库中的函数都会自发采用多个核心进行并行代数运算。</p>
<p><img src="157.png" alt="10"></p>
<h1>19 应用举例：照片OCR</h1>
<h2 id="问题描述与OCR-pipeline">问题描述与OCR pipeline</h2>
<p><strong>照片光学字符识别 (Photo Optical Character Recognition)</strong> ，简称OCR 。OCR 问题是计算机如何读取图片中的文字。流程如下：</p>
<p><img src="158.png" alt="10"></p>
<p>这个流程成为 OCR pipeline ，每一部分可以单独构建一个模块，最后将这几个模块拼接起来。在分配工作的时候，你可以将这个模块分配给不同的人去实现。</p>
<h2 id="滑动窗口">滑动窗口</h2>
<p>第一步文字识别是计算机视觉中比较难的部分。我们先举一个简单的例子，行人检测的例子，这个问题简单在于行人的长宽比的比例很接近。假如你要建立一个行人检测的系统，首先你要确定一个比例，假设为 82×36 ，从数据集中筛选出一些 Positive 和 Negative 的例子。然后你就训练你的神经网络。</p>
<p><img src="159.png" alt="10"></p>
<p>当你构建好了一个分类器，有一张新的图片，你可以每次取一个小矩形，每一次移动一小步（步长），遍历完整张图片；之后你可以用一个更大的矩形（需要先调整为 82×36 的格式），再遍历一次。</p>
<p><img src="160.png" alt="10"></p>
<p>回到文字检测的例子，和行人检测一样，你首先也要准备一些Positive 和 negative 的图片，用于训练。</p>
<p><img src="161.png" alt="10">训练后，针对一个新的图片，按照上面行人检测的做法，检测出所有存在文字的矩形区域，下图中采用白色来表示文本区域，从黑到白表示文本的概率越来越高。这一步还没完，你还要划分文本区域，此时用到了一种叫做<strong>expansion operator</strong>的算法，其原理就是判断一个白色小块附近（5到10个像素）有没有其他的白色像素，如果有就把整个范围的像素都变成白色。之后你可以提出一些形状比较奇怪的区域。</p>
<p><img src="162.png" alt="10"></p>
<p>现在我们看流水线的第二步，文字划分。这一步的训练集如下，判断图片中是否存在文字分割的地方，这一步也用到了滑动窗口的方法。</p>
<p><img src="163.png" alt="10"></p>
<p>最后一步文本识别就是一个多分类问题。</p>
<h2 id="获取大量数据和人工数据">获取大量数据和人工数据</h2>
<p>一个最可靠的得到高性能机器学习系统的方法，是使用一个低偏差的机器学习方法，并且使用庞大的训练集去训练它。不过你该从哪里去获取这么多数据呢？机器学习有一个概念称为<strong>人工数据合成(artificial data synthesis)</strong>。</p>
<p>人工数据合并主要有两种形式。第一种是自己创造数据，第二种是我们有一个小的训练集，我们可以通过这个数据集手动生成一个更大的数据集。</p>
<p>我们首先以文字识别作为例子，如果你想要更多数据，你可以用不同的字体库的字母，黏贴到不同背景中，自己合成字体图片，当然这个过程很花心思。</p>
<p><img src="164.png" alt="10"></p>
<p>另一种方式是使用真实样本生成数据，扩充数据集。比如，下面对A这个字母进行不同的拉伸。但是你要仔细考虑哪些拉伸是合理的，哪些是不合理的。</p>
<p><img src="165.png" alt="10"></p>
<p>举个语音识别的例子，加入你要一段语音，你可以通过不同处理（比如加入不同的噪音）得到新的数据。</p>
<p>总结一下，在引入失真的过程中，你应该引入那些<strong>在测试集中有代表性的失真</strong>。如果是没有意义的噪音，那么对你的结果就没有帮助。</p>
<p><img src="166.png" alt="10"></p>
<p>最后讨论一下，首先你要确保你的算法是低偏差的，这样提供大量数据才有意义。</p>
<p><img src="167.png" alt="10"></p>
<h2 id="上限分析（应该放在误差分析内）">上限分析（应该放在误差分析内）</h2>
<p>在机器学习系统中，最宝贵的就是<strong>开发者的时间</strong>。我们可以通过<strong>上限分析 (ceiling analysis)<strong>来发现流程中的哪一部分最值得你花时间去研究。这里接着用 OCR 工作流的例子，首先我们需要一个</strong>数值的指标</strong>来衡量整个系统，假设我们现在整个系统在测试集的准确率是 72% ，这个时候你可以跳过第一部分文字识别，手动从测试集中将文字区域划分出来（也就是说，这一步准确率100%），作为第二步的输入，然后一直运行结果，查看这次的准确率（也就是说，跳过了第一步的总体准确率）。之后你可以继续这么做，跳过第二步，直接给第三步正确的输入；跳过第三步，直接给正确的输出（这一步正确率肯定是 100%）。这个过程就是上限分析。假设分析结果如下图，你就可以看出你<strong>每一步能提高的理论上限</strong>。</p>
<p><img src="168.png" alt="10"></p>
<p>我们举一个人脸识别的例子，其工作流如下</p>
<p><img src="169.png" alt="10"></p>
<p>那么你怎么做上限分析呢？</p>
<p><img src="170.png" alt="10"></p>
<h1>20 总结与感谢</h1>
<p>感谢吴恩达老师！</p>
<p><img src="171.png" alt="10"></p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>以某列作为主键比对两个文件内容代码实现</title>
    <url>/posts/705b018f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>有的时候，你可能需要比较两个文件的<strong>实质内容</strong>是否一样，或者某一个文件的内容是否均包含在另一个文件，你可以看看本代码。</p>
<span id="more"></span>
<h1>前言</h1>
<p>这两天老得比对各种文件，比对我手上的数据和你手上的数据是否一致，比对上传的数据和计算用的数据是否一致等。但是之前用的一些比对文件的方法又不能很好地满足我的需求，总得手动各种弄，就写了这个小脚本。</p>
<p>我一般用的比对方式有三种，notpad++ 的 Compare 插件，Excel 的  Vlookup 函数 + 排序 + IF， linux 的 diff 命令。但是问题在于第一种和第三种主要用在两个文件行的排序一致的情况，而且也得肉眼去看比对结果。第二种用 Excel 倒是灵活，就是得手动各种弄，偶尔一次可以，经常这样做就废时间了。</p>
<h1>脚本逻辑</h1>
<p>这个脚本要求两个文件的<strong>列数相同</strong>，并且<strong>列的顺序也一样</strong>。两个文件指定以某一列作为主键（数据库的概念，主键不可以出现重复）。</p>
<p>首先比较两个文件的主键，画个韦恩图如下，最左边的部分表示只在第一个文件的主键，也就是只在第一个文件中的行（如果存在，则写入文件 only_in_file1.txt ），最右边同理 。中间重叠的部分就是两个文件共同的主键。</p>
<p><img src="1.png" alt="1"></p>
<p>然后查看两个文件共同的主键部分，比对同一个主键在两个文件的行的内容是否一致，如果不一致，则将这两行内容写入到 diff_rows.txt 。</p>
<p>如果<strong>只在文件1中的行</strong>，<strong>只在文件2中的行</strong>，<strong>共同主键但是行内容不同的行</strong>，这三个<strong>均不存在</strong>，那就说明这<strong>两个文件在内容上完全一致</strong>。</p>
<h1>使用软件</h1>
<ul>
<li>python 3.8 及以上版本</li>
</ul>
<h1>输入文件格式</h1>
<p>文本格式</p>
<h1>输出文件格式</h1>
<p>如果两个文件存在不一致，那么可能出现这三个文件。</p>
<p><code>only_in_file1.txt</code> :  只在第一个文件出现的行</p>
<p><code>only_in_file2.txt</code> :  只在第二个文件出现的行</p>
<p><code>diff_rows.txt</code> : 两个文件主键相同但是行内容不一致的内容。</p>
<p>前两个文件就不用说了，唯一注意的地方是这三个文件文件分隔符用的都是tab，可能和输入文件的分隔符不一样。</p>
<p>第三个文件举个例子，见下方，前两行为一个不一致的地方，第一行为主键<code>YYLNWJ119077114</code>在第一个文件中的内容，第二行则为主键<code>YYLNWJ119077114</code>在第二个文件中的内容，可以看到这两行在最后一列内容不一致，第一个文件为 9，第二个文件为 -999 。第三行为空行，作为分隔。第四行和第五行是第二个不一致的地方。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YYLNWJ119077114	F	7	YYCFJYA1872471220191013	243.76	9</span><br><span class="line">YYLNWJ119077114	F	7	YYCFJYA1872471220191013	243.76	-999</span><br><span class="line"></span><br><span class="line">YYLNWJ119083106	F	8	YYCFJYA1874850920191031	193.26	9</span><br><span class="line">YYLNWJ119083106	F	8	YYCFJYA1874850920191031	193.26	-999</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>运行代码</h1>
<p>代码文件见: <a href="https://github.com/VincereZhou/code_backup/blob/master/compair_two_files.py">compair_two_files.py</a></p>
<p>将两个需要比较的文件和本程序放在一个文件夹内，运行命令示范如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python compair_two_files.py --file1 in_sz_phe --file2 out_sz_phe</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong>：</p>
<p><code>--file1</code>: 第一个输入文件名称，必选</p>
<p><code>--file2</code>: 第二个输入文件名称，必选</p>
<p><code>--key-column</code>:  主键所在的列，可选，默认为 1，即默认第一列为主键。如果数据中无法指定一列作为主键，现在可以指定多列内容作为主键，以逗号分隔。举个例子，假如比对文件为母猪的繁殖数据，此时由于一头母猪有多条数据，你不能将母猪ID作为主键，因为会重复；但是你可以通过母猪ID+胎次来保证一行数据的唯一性，如果母猪ID为第一列，胎次为第4列，则此时这个参数的值为 1,4 。</p>
<p><code>--file-separator</code>:  文件中的分隔符，可选，默认为空白字符。</p>
<h1>代码说明</h1>
<h2 id="输入参数，打印参数">输入参数，打印参数</h2>
<p>略</p>
<h2 id="检验参数">检验参数</h2>
<p>检验两个文件是否存在且非空，两个文件的列数是否相同，主键是否为数字且在列数的范围内。如果存在问题，报错退出</p>
<h2 id="检查文件">检查文件</h2>
<h3 id="第一个文件">第一个文件</h3>
<p>对于每一行判断列数，判断整行内容是否重复，判断主键是否重复，将内容写入到 dict1 中。</p>
<h3 id="第二个文件">第二个文件</h3>
<p>正常检查同第一个文件，判断第二个文件的主键是否在第一个文件中，将共同主键的行内容写入到 dict2 ，将只在第二个文件的行内容写入到 only_in_file2_list 。</p>
<h3 id="提取只在第一个文件中的主键的行">提取只在第一个文件中的主键的行</h3>
<p>上面已经提取了只在第二个文件中的行的内容，这里就提取只在第一个文件的内容，写入 only_in_file1_list</p>
<h3 id="比较共同主键的行">比较共同主键的行</h3>
<p>比较两个文件共同主键的行的内容是否一致</p>
<h2 id="综合判断">综合判断</h2>
<p>结合上述内容，综合判断，如果完全一致则打印退出。如果存在不一致，将不一致的地方写入文件。</p>
<h1>更新</h1>
<h2 id="2021年12月4号">2021年12月4号</h2>
<ol>
<li>
<p>之前数据每行内容拆分时，漏了使用指定的分隔符，改回来了</p>
</li>
<li>
<p><code>--key-column</code> 参数现在可以指定多列。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>基于两个plink文件共同样本共同位点的基因型比对代码实现</title>
    <url>/posts/9ad0a746/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>比对两个plink文件共同样本共同位点的基因型，合并了 <a href="https://vincere.fun/posts/fa9e0b0e/">两个Plink文件样本间基因型比对代码实现</a> 和 <a href="https://vincere.fun/posts/6897c9bb/">两个Plink文件同一SNP基因型比对代码实现</a> 的内容。</p>
<span id="more"></span>
<h1>前言</h1>
<p>整理文档的时候突然想到，既然比对两个plink文件时从共同样本角度和从共同SNP角度比对都需要进行，那为什么不合并成一个脚本呢？</p>
<p>是的，这里需要合并成一个脚本，因此就有了这个脚本。这个脚本是在<a href="https://github.com/VincereZhou/code_backup/blob/master/compair_snps.py">compair_snps.py</a>基础上新增了一些代码得到的，同时从共同样本和共同SNP角度去比较基因型。</p>
<h1>使用软件</h1>
<ul>
<li>python 3.8 及以上版本</li>
<li>plink 软件 v1.90 版本</li>
</ul>
<h1>输入文件格式</h1>
<h2 id="plink-文本文件">plink 文本文件</h2>
<p>格式说明见<a href="https://vincere.fun/posts/506fc784/">根据芯片号拆分plink文件的代码实现</a></p>
<h1>输出文件说明</h1>
<p>两个输出文件名称前面相同，后面分别为 <code>_snp.txt</code> 和 <code>_sample.txt</code> ，分别为从SNP角度和样本角度的比对结果。</p>
<p><code>*_snp.txt</code> :  第一列为SNP名称，第二列为两个plink文件中共同样本中不一致的样本数目，第三列为共同样本总数，第四列为前两列相除得到的不一致率。</p>
<p>示例如下：</p>
<table>
<thead>
<tr>
<th>8_118011832</th>
<th>3508</th>
<th>3529</th>
<th>0.994</th>
</tr>
</thead>
<tbody>
<tr>
<td>5_39432167</td>
<td>3459</td>
<td>3524</td>
<td>0.9816</td>
</tr>
<tr>
<td>14_133523132</td>
<td>3428</td>
<td>3518</td>
<td>0.9744</td>
</tr>
</tbody>
</table>
<p><code>*_sample.txt</code> :  第一列为样本名称，第二列为两个plink文件中该样本的共同位点中不一致的样本数目，第三列为共同位点总数，第四列为前两列相除得到的不一致率。</p>
<table>
<thead>
<tr>
<th>202888800026_R03C02</th>
<th>0</th>
<th>51315</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>202888800026_R03C03</td>
<td>0</td>
<td>51315</td>
<td>0</td>
</tr>
<tr>
<td>202888800026_R03C04</td>
<td>0</td>
<td>51315</td>
<td>0</td>
</tr>
</tbody>
</table>
<h1>运行代码</h1>
<p>代码文件见：<a href="https://github.com/VincereZhou/code_backup/blob/master/compair_two_plinks.py">compair_two_plinks.py</a></p>
<p>将输入文件和本程序放在同一文件夹下，运行命令示范为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python compair_two_plinks.py --plink1 plink1 --plink2 plink2</span><br></pre></td></tr></table></figure>
<p><strong>可用参数说明</strong>：</p>
<p><code>--plink1</code>: 第一个plink文件前缀，必选。</p>
<p><code>--plink2</code>: 第二个plink文件前缀，可选。</p>
<p><code>--exclude-miss</code> : 基因型比对是否先剔除缺失值，可选，只能为yes和no，默认为yes。如果该选项设置为no，比对时不会剔除缺失样本对，如果存在同一个样本，在一个基因型文件中有基因型，另一个基因型文件中则为缺失，该样本同样会被视为不一致位点；如果该选项设置为 yes ，比对时会剔除至少一个样本为缺失的位点，只比对两个样本均不为缺失的位点。</p>
<p><code>--save-temp</code> :  是否保留中间文件，可选，只能为yes和no，默认为 no。</p>
<p><code>--out-prefix</code> : 结果文件前缀，可选，默认为 <code>cmp_two_plinks</code></p>
<h1>代码说明</h1>
<p>由于这个脚本是基于 <a href="https://github.com/VincereZhou/code_backup/blob/master/compair_snps.py">compair_snps.py</a> 的基础修改的，前面的内容基本没变，只看后面修改的地方。</p>
<h2 id="计算不一致率">计算不一致率</h2>
<p>这里新增了从样本角度比对的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#计算不一致率</span></span><br><span class="line">out_sample_list = []</span><br><span class="line">out_snp_list = []</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> args.exclude_miss == <span class="string">&#x27;yes&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(snp_num):</span><br><span class="line">        first_index = <span class="built_in">range</span>(<span class="number">0</span>,common_sample_num)</span><br><span class="line">        second_index = <span class="built_in">range</span>(common_sample_num,total_sample_num)</span><br><span class="line">        v1 = array1[first_index,i]</span><br><span class="line">        v2 = array1[second_index,i]</span><br><span class="line">        non_miss_index = np.where((v1!=<span class="number">3</span>) &amp; (v2!=<span class="number">3</span>))</span><br><span class="line">        total_num = non_miss_index[<span class="number">0</span>].shape[<span class="number">0</span>]</span><br><span class="line">        v1_new = v1[non_miss_index]</span><br><span class="line">        v2_new = v2[non_miss_index]</span><br><span class="line">        no_match_num = np.count_nonzero(v1_new!=v2_new)</span><br><span class="line">        <span class="keyword">if</span> total_num &gt; <span class="number">0</span>:</span><br><span class="line">            no_match_rate = no_match_num/total_num</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            no_match_rate = <span class="number">0</span></span><br><span class="line">        out_snp_list.append([snp_list[i],<span class="string">f&quot;<span class="subst">&#123;no_match_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;total_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;no_match_rate:<span class="number">.4</span>f&#125;</span>&quot;</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(common_sample_list)):</span><br><span class="line">        first_index = i</span><br><span class="line">        second_index = i+common_sample_num</span><br><span class="line">        v1 = array1[first_index,:]</span><br><span class="line">        v2 = array1[second_index,:]</span><br><span class="line">        non_miss_index = np.where((v1!=<span class="number">3</span>) &amp; (v2!=<span class="number">3</span>))</span><br><span class="line">        total_num = non_miss_index[<span class="number">0</span>].shape[<span class="number">0</span>]</span><br><span class="line">        v1_new = v1[non_miss_index]</span><br><span class="line">        v2_new = v2[non_miss_index]</span><br><span class="line">        no_match_num = np.count_nonzero(v1_new!=v2_new)</span><br><span class="line">        <span class="keyword">if</span> total_num &gt; <span class="number">0</span>:</span><br><span class="line">            no_match_rate = no_match_num/total_num</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            no_match_rate = <span class="number">0</span></span><br><span class="line">        out_sample_list.append([common_sample_list[i],<span class="string">f&quot;<span class="subst">&#123;no_match_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;total_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;no_match_rate:<span class="number">.4</span>f&#125;</span>&quot;</span>])</span><br><span class="line">        </span><br><span class="line"><span class="keyword">elif</span> args.exclude_miss == <span class="string">&#x27;no&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(snp_num):</span><br><span class="line">        first_index = <span class="built_in">range</span>(<span class="number">0</span>,common_sample_num)</span><br><span class="line">        second_index = <span class="built_in">range</span>(common_sample_num,total_sample_num)</span><br><span class="line">        v1 = array1[first_index,i]</span><br><span class="line">        v2 = array1[second_index,i]</span><br><span class="line">        total_num = common_sample_num</span><br><span class="line">        no_match_num = np.count_nonzero(v1!=v2)</span><br><span class="line">        no_match_rate = no_match_num/total_num</span><br><span class="line">        out_snp_list.append([snp_list[i],<span class="string">f&quot;<span class="subst">&#123;no_match_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;total_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;no_match_rate:<span class="number">.4</span>f&#125;</span>&quot;</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(common_sample_list)):</span><br><span class="line">        first_index = i</span><br><span class="line">        second_index = i+common_sample_num</span><br><span class="line">        v1 = array1[first_index,:]</span><br><span class="line">        v2 = array1[second_index,:]</span><br><span class="line">        total_num = snp_num</span><br><span class="line">        no_match_num = np.count_nonzero(v1!=v2)</span><br><span class="line">        no_match_rate = no_match_num/total_num</span><br><span class="line">        out_sample_list.append([common_sample_list[i],<span class="string">f&quot;<span class="subst">&#123;no_match_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;total_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;no_match_rate:<span class="number">.4</span>f&#125;</span>&quot;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="将比对结果按从不一致率从大到小">将比对结果按从不一致率从大到小</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sorted_out_snp_list = <span class="built_in">sorted</span>(out_snp_list, key = <span class="keyword">lambda</span> s:<span class="built_in">float</span>(s[<span class="number">3</span>]), reverse = <span class="literal">True</span>) <span class="comment">#不一致率从大到小</span></span><br><span class="line">sorted_out_sample_list = <span class="built_in">sorted</span>(out_sample_list, key = <span class="keyword">lambda</span> s:<span class="built_in">float</span>(s[<span class="number">3</span>]), reverse = <span class="literal">True</span>) <span class="comment">#不一致率从大到小</span></span><br></pre></td></tr></table></figure>
<h2 id="写入结果文件，统计不一致的SNP数目和样本数目。">写入结果文件，统计不一致的SNP数目和样本数目。</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">unconsistent_snp_num = <span class="number">0</span> <span class="comment"># 不一致的SNP数目</span></span><br><span class="line">unconsistent_sample_num = <span class="number">0</span> <span class="comment"># 不一致的样本数目</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sorted_out_snp_list:</span><br><span class="line">    out_snp_file.write(<span class="string">&#x27;\t&#x27;</span>.join(i)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(i[<span class="number">1</span>]) &gt; <span class="number">0</span>:</span><br><span class="line">        unconsistent_snp_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sorted_out_sample_list:</span><br><span class="line">    out_sample_file.write(<span class="string">&#x27;\t&#x27;</span>.join(i)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(i[<span class="number">1</span>]) &gt; <span class="number">0</span>:</span><br><span class="line">        unconsistent_sample_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;unconsistent sample number: <span class="subst">&#123;unconsistent_sample_num&#125;</span>\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;unconsistent  snp   number: <span class="subst">&#123;unconsistent_snp_num&#125;</span>\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1>闲话</h1>
<p>定期整理文档，梳理之前写的代码是有益的。</p>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>生物信息</tag>
      </tags>
  </entry>
  <entry>
    <title>通过比对bim文件查找有问题基因型文件代码实现</title>
    <url>/posts/58fe67f5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>当你用 plink 软件合并同一款芯片的多对plink文件时，出现了下述报错，提示有些位点不是二等位基因型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Error: Variant <span class="string">&#x27;1_242598&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> biallelic.</span><br></pre></td></tr></table></figure>
<p>这时候你就需要找到有问题的plink文件</p>
<span id="more"></span>
<h1>前言</h1>
<p>这种情况比较罕见，正常情况下不会发生，最可能的原因有两个</p>
<ol>
<li>虽然是同一款芯片，但是可能存在更换了注释文件，导致同一个位点分型出来的两个碱基不同。</li>
<li>弄混了 Top 链 和 Forward 链的 plink 文件</li>
</ol>
<h1>使用软件</h1>
<ul>
<li>python 3.8 及以上版本</li>
<li>plink 软件 v1.90 版本</li>
</ul>
<h1>输入文件格式</h1>
<h2 id="plink-文本文件">plink 文本文件</h2>
<p>格式说明见<a href="https://vincere.fun/posts/506fc784/">根据芯片号拆分plink文件的代码实现</a></p>
<h2 id="plink-二进制文件">plink 二进制文件</h2>
<p>通过 plink 软件的 <code>--make-bed</code> 命令生成的二进制基因型文件，具体格式说明见<a href="https://vincere.fun/posts/def937d0/">plink学习笔记</a>。这里我们需要的就是后缀为<code>.bim</code> 的文件，这个文件在map文件的基础上新增了两列，为该SNP的两个碱基。</p>
<p>举个例子，下表为 bim 文件中的内容，第一行中的SNP的第一个碱基为 0 ，说明这个SNP均为一种分型（GG）。</p>
<table>
<thead>
<tr>
<th>1</th>
<th>CNCB10000545</th>
<th>0</th>
<th>119120907</th>
<th>0</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>CNC10012269</td>
<td>0</td>
<td>119133853</td>
<td>A</td>
<td>G</td>
</tr>
<tr>
<td>1</td>
<td>CNC10012270</td>
<td>0</td>
<td>119144804</td>
<td>G</td>
<td>C</td>
</tr>
</tbody>
</table>
<h1>比对多对plink文件代码</h1>
<h2 id="运行代码">运行代码</h2>
<p>代码文件见: <a href="https://github.com/VincereZhou/code_backup/blob/master/cmp_bims.py">cmp_bims.py</a></p>
<p>将所有需要检验的plink文本文件和本程序放在一个文件夹内，运行命令示范如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python cmp_bims.py in_path</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong>：</p>
<p><code>in_path</code> ：需要检验的多对plink文本文件所在的文件夹路径，注意一对<code>ped</code>文件和<code>map</code>文件的前缀必须相同。</p>
<h2 id="代码说明">代码说明</h2>
<h3 id="每对plink文件生成同名二进制文件">每对plink文件生成同名二进制文件</h3>
<p>首先导入需要的模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys,os</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br></pre></td></tr></table></figure>
<p>唯一的一个参数命名为 <code>work_path</code>，即工作路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">work_path = sys.argv[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>创建一个报错提示逻辑值<code>total_error_status</code> ，初始化为 <code>False</code> 。如果值为 <code>True</code> ，表示存在报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total_error_status = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>切换目录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换目录</span></span><br><span class="line">os.chdir(work_path) </span><br></pre></td></tr></table></figure>
<p>每对plink文件生成 <code>bim</code> 文件。这里是遍历输入路径下的所有文件，找到后缀为<code>.ped</code> 的文件，查找是否存在相应前缀的<code>.map</code> 文件，如果不存在则报错；之后使用 plink 软件生成二进制文件，将退出码赋给 <code>exit_code</code> ，如果退出码不为0，说明plink 软件生成二进制文件存在报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每对plink文件生成 bim 文件</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> os.listdir(<span class="string">&quot;.&quot;</span>):</span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(i): <span class="comment">#判断是文件</span></span><br><span class="line">        <span class="keyword">if</span> i[-<span class="number">4</span>:] == <span class="string">&quot;.ped&quot;</span>: <span class="comment">#判断后缀是.ped</span></span><br><span class="line">            prefix = i[:-<span class="number">4</span>]   <span class="comment">#去除.ped</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">f&quot;<span class="subst">&#123;prefix&#125;</span>.map&quot;</span>):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Error: have <span class="subst">&#123;prefix&#125;</span>.ped but not have <span class="subst">&#123;prefix&#125;</span>.map\n&quot;</span>)</span><br><span class="line">                total_error_status = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                exit_code = os.system(<span class="string">f&quot;plink --allow-extra-chr --chr-set 95 --file <span class="subst">&#123;prefix&#125;</span> --out <span class="subst">&#123;prefix&#125;</span> &amp;&gt; /dev/null&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> exit_code != <span class="number">0</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;Error: plink file <span class="subst">&#123;prefix&#125;</span> has problems and can&#x27;t go through plink software, please see <span class="subst">&#123;prefix&#125;</span>.log\n&quot;</span>)</span><br><span class="line">                    total_error_status = <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面一步中，只要存在报错，<code>total_error_status</code> 的值就会改为<code>True</code> 。如果有问题，程序中止。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> total_error_status:</span><br><span class="line">    sys.exit(<span class="number">1</span>) </span><br></pre></td></tr></table></figure>
<h3 id="遍历所有bim文件，查找有问题的plink文件">遍历所有bim文件，查找有问题的plink文件</h3>
<p>这里首先是遍历输入文件的 <code>bim</code> 文件，将第一个<code>bim</code>文件所有SNP的碱基信息存入到<code>dict1</code> 字典中，键为SNP名称，值为该SNP的碱基的集合（包含 “0”）。</p>
<p>然后以第一个<code>bim</code>文件为模块，比对其他<code>bim</code> 文件。如果其他<code>bim</code> 文件的位点不再第一个<code>bim</code> 文件中，或者某个SNP的两个碱基与第一个<code>bim</code>文件不匹配，则打印报错信息，否则就打印<code>***.bim is well</code> ，说明<strong>与第一个<code>bim</code>文件相比较</strong>，这个<code>bim</code>文件没问题。</p>
<p>注意，由于这里第一个<code>bim</code>文件是随机选择的，因此如果恰好第一个<code>bim</code>文件就是有问题的，那么可能出现其他<code>bim</code> 文件均报错的情况。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#遍历所有的bim文件</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> os.listdir(<span class="string">&quot;.&quot;</span>):</span><br><span class="line">    <span class="keyword">if</span> (os.path.isfile(i)) <span class="keyword">and</span> (i[-<span class="number">4</span>:] == <span class="string">&quot;.bim&quot;</span>): <span class="comment">#判断是文件，后缀为bim</span></span><br><span class="line">        <span class="comment"># prefix = i[:-4]   #去除.bim</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span> is first bim&quot;</span>) <span class="comment"># 打印第一个文件</span></span><br><span class="line">            bim_file = <span class="built_in">open</span>(i,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> i2 <span class="keyword">in</span> bim_file:</span><br><span class="line">                f2 = i2.split()</span><br><span class="line">                temp_alleles_set = dict1[f2[<span class="number">1</span>]] <span class="comment"># 该SNP的碱基集合</span></span><br><span class="line">                temp_alleles_set.add(<span class="string">&quot;0&quot;</span>) <span class="comment"># 先添加0</span></span><br><span class="line">                temp_alleles_set.add(f2[-<span class="number">2</span>])</span><br><span class="line">                temp_alleles_set.add(f2[-<span class="number">1</span>])</span><br><span class="line">            bim_file.close()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 以第一个bim为模板，比对其他bim文件。</span></span><br><span class="line">            bim_file = <span class="built_in">open</span>(i,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> i2 <span class="keyword">in</span> bim_file:</span><br><span class="line">                f2 = i2.split()</span><br><span class="line">                <span class="keyword">if</span> f2[<span class="number">1</span>] <span class="keyword">in</span> dict1:</span><br><span class="line">                    temp_alleles_set = dict1[f2[<span class="number">1</span>]].copy() <span class="comment"># 第一个文件该SNP碱基集合的拷贝</span></span><br><span class="line">                    temp_alleles_set.add(f2[-<span class="number">2</span>])</span><br><span class="line">                    temp_alleles_set.add(f2[-<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(temp_alleles_set) &gt; <span class="number">3</span>: <span class="comment"># 如果超过了两个碱基</span></span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">f&quot;Error: SNP <span class="subst">&#123;f2[<span class="number">1</span>]&#125;</span> in <span class="subst">&#123;i&#125;</span> is not consistent with first bim\n&quot;</span>) <span class="comment">#打印错误文件的错误碱基</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;Error: SNP <span class="subst">&#123;f2[<span class="number">1</span>]&#125;</span> in <span class="subst">&#123;i&#125;</span> not in first bim\n&quot;</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span> is well&quot;</span>) <span class="comment">#没有问题则打印没问题</span></span><br><span class="line">            bim_file.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>比对两个bim文件代码</h1>
<h2 id="前言">前言</h2>
<p>假如你在上一步找到有问题的plink文件，你先看看这个plink文件与所谓的正常的plink文件到底是哪些位点的等位基因不一样，你就可以接着运行这个脚本。</p>
<p>或者你总共就只有两对plink文件，合并报错，你也可以直接运行这个脚本。</p>
<h2 id="运行代码-2">运行代码</h2>
<p>代码文件见: <a href="https://github.com/VincereZhou/code_backup/blob/master/cmp_two_bims.py">cmp_two_bims.py</a></p>
<p>将需要检验的bim文件和本程序放在一个文件夹内，运行命令示范如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python cmp_two_bims.py 1.bim 2.bim cmp_two_bims.txt</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong>：</p>
<p><code>1.bim</code>: 第一个<code>bim</code>文件名称</p>
<p><code>2.bim</code>: 第二个<code>bim</code>文件名称</p>
<p><code>cmp_two_bims.txt</code> : 结果文件名称</p>
<p>注意：这里直接用的是<code>bim</code>文件，如果没有生成就先用plink软件生成一下。</p>
<h2 id="输出文件格式">输出文件格式</h2>
<p>输出文件为<strong>不一致</strong>位点的碱基信息，总共5列，第一列为SNP名称，第二列和第三列为该SNP在第一个<code>bim</code>文件的两个碱基，第四列和第五列为该SNP在第二个<code>bim</code>文件的两个碱基。示例如下</p>
<table>
<thead>
<tr>
<th>CNC10012269</th>
<th>A</th>
<th>G</th>
<th>A</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>CNC10012270</td>
<td>G</td>
<td>C</td>
<td>A</td>
<td>T</td>
</tr>
</tbody>
</table>
<h2 id="代码说明-2">代码说明</h2>
<h3 id="读取文件">读取文件</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">bim1 = <span class="built_in">open</span>(sys.argv[<span class="number">1</span>],<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">bim2 = <span class="built_in">open</span>(sys.argv[<span class="number">2</span>],<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">out_file = <span class="built_in">open</span>(sys.argv[<span class="number">3</span>],<span class="string">&#x27;w&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出文件写入标题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">out_file.write(<span class="string">&quot;\t&quot;</span>.join([<span class="string">&quot;snp&quot;</span>,<span class="string">&quot;bim1_A1&quot;</span>,<span class="string">&quot;bim1_A2&quot;</span>,<span class="string">&quot;bim2_A1&quot;</span>,<span class="string">&quot;bim2_A2&quot;</span>])+<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="遍历第一个bim文件">遍历第一个bim文件</h3>
<p>将第一个<code>bim</code>文件SNP的两个碱基信息写入一个字典中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dick = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> bim1:</span><br><span class="line">    f = i.split()</span><br><span class="line">    dick[f[<span class="number">1</span>]] = f[-<span class="number">2</span>:] <span class="comment">#snp名称：倒数第二列</span></span><br></pre></td></tr></table></figure>
<h3 id="遍历第二个bim文件，比对SNP">遍历第二个bim文件，比对SNP</h3>
<p>首先判断第二个<code>bim</code>文件的SNP是否均在第一个<code>bim</code>文件中，如果不是则报错中止程序。</p>
<p>之后检查每个SNP在两个<code>bim</code>文件中的碱基数目是否超过 2 (加上 “0” 超过3) ，超过了就说明有问题，将该SNP数据的信息写入输出文件，不一致位点数 <code>error_base_num </code> 加1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">error_base_num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> bim2:</span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> dick:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error: &#123;&#125; in bim2 not in bim1&quot;</span>.<span class="built_in">format</span>(f[<span class="number">1</span>]))</span><br><span class="line">        sys.exit()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        bim1_alleles_set = <span class="built_in">set</span>(dick[f[<span class="number">1</span>]])</span><br><span class="line">        bim1_alleles_set.add(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">        bim1_alleles_set.add(f[-<span class="number">2</span>])</span><br><span class="line">        bim1_alleles_set.add(f[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(bim1_alleles_set) &gt; <span class="number">3</span>: <span class="comment">#如果包括0，两个bim合并的等位基因数目大于3，就有问题</span></span><br><span class="line">            error_base_num += <span class="number">1</span></span><br><span class="line">            bim1_alleles = <span class="string">&#x27;\t&#x27;</span>.join(dick[f[<span class="number">1</span>]])</span><br><span class="line">            out_file.write(<span class="string">f&quot;<span class="subst">&#123;f[<span class="number">1</span>]&#125;</span>\t<span class="subst">&#123;bim1_alleles&#125;</span>\t<span class="subst">&#123;f[-<span class="number">2</span>]&#125;</span>\t<span class="subst">&#123;f[-<span class="number">1</span>]&#125;</span>\n&quot;</span>)</span><br><span class="line">            <span class="comment"># print(&quot;Error: &#123;&#125; in bim2 file has more than 2 alleles&quot;.format(f[1]))</span></span><br><span class="line">            <span class="comment"># sys.exit()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="打印提示信息">打印提示信息</h3>
<p>如果不一致位点数为0，那么打印祝贺信息；反之提示有几个不一致位点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> error_base_num == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Congradulation: two bim fils is consistent&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;error_base_num&#125;</span> bases has more than 2 alleles&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="关闭文件">关闭文件</h3>
<p>用完记得关闭文件，这是个好习惯</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bim1.close()</span><br><span class="line">bim2.close()</span><br><span class="line">out_file.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>调整plink文件SNP顺序代码实现</title>
    <url>/posts/c9697aaa/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>一般来说 Plink 文件中的SNP顺序并不影响任何操作，如果有必要的话，可以通过下面这个代码以指定SNP顺序调整plink文件。</p>
<span id="more"></span>
<h1>前言</h1>
<p>经过 plink 软件处理的基因型文件，位点会按照物理位置的顺序进行排序，而且性染色体会重命名为常染色体+1 或 常染色体+2。这里我们同样可以利用 plink 软件的这个特性来实现以我们指定的顺序排序SNP的目的。</p>
<h1>使用软件</h1>
<ul>
<li>python 3.8 及以上版本</li>
<li>plink 软件 v1.90 版本</li>
</ul>
<h1>输入输出文件格式</h1>
<h2 id="plink-文件">plink 文件</h2>
<p>格式说明见<a href="https://vincere.fun/posts/506fc784/">根据芯片号拆分plink文件的代码实现</a></p>
<h1>运行代码</h1>
<p>代码文件见：<a href="https://github.com/VincereZhou/code_backup/blob/master/snp_order.py">snp_order.py</a></p>
<p>将所有输入文件和本程序放在同一文件夹下，运行命令示范如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python snp_order.py cn1.map plink_order cn1_2</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong>：</p>
<p><code>cn1.map</code> :  参考map文件，即为预期调整好SNP顺序之后的map 文件</p>
<p><code>plink_order</code> :  输入plink文件前缀</p>
<p><code>cn1_2</code> : 输出plink文件前缀</p>
<p>注意，参考map文件与输入plink文件的map文件的内容一致，仅仅是SNP顺序变动了。最终会将输入的plink文件的SNP顺序调整为参考map文件的SNP顺序。</p>
<h1>代码说明</h1>
<h2 id="输入参数">输入参数</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os,sys</span><br><span class="line"></span><br><span class="line">ref_map_name = sys.argv[<span class="number">1</span>]</span><br><span class="line">in_plink_prefix = sys.argv[<span class="number">2</span>]</span><br><span class="line">out_plink_prefix = sys.argv[<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<h2 id="判断参数和文件内容">判断参数和文件内容</h2>
<p>这里我们先用一个变量 <code>error_status</code> 作为总的判断异常的逻辑值，默认是 <code>False</code> ，如果运行过程中出现问题，则修改为 <code>True</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">error_status = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>写了一个函数，判断文件名是否存在且非空</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断输入文件是否存在且非空</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Judge_file</span>(<span class="params">file_path</span>):</span></span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(file_path):</span><br><span class="line">        <span class="keyword">if</span> os.path.getsize(file_path):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之后就是对输入输出文件进行判断，判断三个输入文件是否存在；判断输入plink前缀是否等于输出plink前缀。如果有问题，程序中止。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> Judge_file(ref_map_name):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;ref_map_name&#125;</span> not exist or is empty file\n&quot;</span>)</span><br><span class="line">    error_status = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> Judge_file(<span class="string">f&quot;<span class="subst">&#123;in_plink_prefix&#125;</span>.ped&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;in_plink_prefix&#125;</span>.ped not exist or is empty file\n&quot;</span>)</span><br><span class="line">    error_status = <span class="literal">True</span></span><br><span class="line"><span class="keyword">elif</span> <span class="keyword">not</span> Judge_file(<span class="string">f&quot;<span class="subst">&#123;in_plink_prefix&#125;</span>.map&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;in_plink_prefix&#125;</span>.map not exist or is empty file\n&quot;</span>)</span><br><span class="line">    error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> in_plink_prefix == out_plink_prefix:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: second argument is same with third argument\n&quot;</span>)</span><br><span class="line">    error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> error_status:</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之后判断参考map文件和输入plink文件的map文件内容是否有问题，两个map文件的SNP名称是否完全一致。如果有问题，程序中止。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断两个map的SNP名称是否完全一致</span></span><br><span class="line">ref_map_file = <span class="built_in">open</span>(ref_map_name,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">in_map_file = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;in_plink_prefix&#125;</span>.map&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ref_snp_list = []</span><br><span class="line">ref_snp_dick = &#123;&#125;</span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">temp_id_set = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ref_map_file:</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(f) == <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> temp_id_set:</span><br><span class="line">            temp_id_set.add(f[<span class="number">1</span>])</span><br><span class="line">            ref_snp_list.append(f[<span class="number">1</span>])</span><br><span class="line">            ref_snp_dick[f[<span class="number">1</span>]] = <span class="built_in">str</span>(j) <span class="comment"># snp: 序号</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated id <span class="subst">&#123;f[<span class="number">1</span>]&#125;</span> in <span class="subst">&#123;ref_map_name&#125;</span>\n&quot;</span>)</span><br><span class="line">            error_status = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;j&#125;</span> row in <span class="subst">&#123;ref_map_name&#125;</span> has less or more than 4 columns\n&quot;</span>)</span><br><span class="line">        error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">in_snp_list = []</span><br><span class="line">not_in_snp_list = [] <span class="comment"># 不在参考map中的snp</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">temp_id_set = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> in_map_file:</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(f) == <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> temp_id_set:</span><br><span class="line">            temp_id_set.add(f[<span class="number">1</span>])</span><br><span class="line">            in_snp_list.append(f[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> ref_snp_dick:</span><br><span class="line">                not_in_snp_list.append(f[<span class="number">1</span>])</span><br><span class="line">                error_status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated id <span class="subst">&#123;f[<span class="number">1</span>]&#125;</span> in <span class="subst">&#123;in_plink_prefix&#125;</span>.map\n&quot;</span>)</span><br><span class="line">            error_status = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;j&#125;</span> row in <span class="subst">&#123;in_plink_prefix&#125;</span>.map has less or more than 4 columns\n&quot;</span>)</span><br><span class="line">        error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ref_map_file.close()</span><br><span class="line">in_map_file.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> not_in_snp_list:</span><br><span class="line">    temp_str = <span class="string">&quot;, &quot;</span>.join(not_in_snp_list)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: snp in <span class="subst">&#123;in_plink_prefix&#125;</span>.map but not in <span class="subst">&#123;ref_map_name&#125;</span>: <span class="subst">&#123;temp_str&#125;</span>\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">not</span> error_status) <span class="keyword">and</span> (<span class="built_in">len</span>(ref_snp_list) != <span class="built_in">len</span>(in_snp_list)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: snp numbers of <span class="subst">&#123;in_plink_prefix&#125;</span>.map and <span class="subst">&#123;ref_map_name&#125;</span> are not same\n&quot;</span>)</span><br><span class="line">    error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> error_status:</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="SNP顺序重排">SNP顺序重排</h2>
<p>下面这一步是重点，我生成一个临时map文件，其中第二列与输入文件的map文件一致，但是物理位置却是参考map文件的SNP序号（染色体都设为1）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成临时map文件，染色体均设为1，物理位置设置为参考map的序号</span></span><br><span class="line">temp_map_file = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;in_plink_prefix&#125;</span>_temp.map&quot;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> in_snp_list:</span><br><span class="line">    temp_map_file.write(<span class="string">&#x27;1&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+i+<span class="string">&#x27;\t&#x27;</span>+<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+ref_snp_dick[i]+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">temp_map_file.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后再用这个临时map文件去过一遍plink软件，plink 软件就会傻憨憨地按照第四列的”物理位置“进行SNP重新排序，实际就是按照参考map文件的SNP序号排序。说白了，这里就是我骗了一下plink软件，用plink软件自动按物理位置排序的性质，实现了以任何一种给定SNP顺序排序的目的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重排</span></span><br><span class="line">os.system(<span class="string">f&quot;plink --allow-extra-chr --chr-set 95 --ped <span class="subst">&#123;in_plink_prefix&#125;</span>.ped --map <span class="subst">&#123;in_plink_prefix&#125;</span>_temp.map --recode --out <span class="subst">&#123;out_plink_prefix&#125;</span> &gt; /dev/null&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我们使用参考map文件替换结果map文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用参考map替换结果map</span><br><span class="line">os.system(f&quot;cp &#123;ref_map_name&#125; &#123;out_plink_prefix&#125;.map&quot;)</span><br></pre></td></tr></table></figure>
<p>最后删除中间文件，这里就是那个临时map文件，过河拆桥了属于是。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除中间文件</span></span><br><span class="line">os.system(<span class="string">&quot;rm *temp*&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1>闲话</h1>
<p>我写这个脚本时的需求，就是为了将plink软件处理后的基因型数据调整成plink软件处理前的顺序。也就是，就是用了 plink 软件导致SNP顺序改变了，plink 软件是这个问题的源头。然后，我现在又通过给plink 软件提供一个虚假的map文件，用 plink 软件又把SNP顺序调整回来了，也就是现在 plink 软件又成了这个问题的解药。感觉有点哲学的意思，就像金庸先生说的 “毒物旁边往往生长着解药” 。</p>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>提取FASTA文件描述行中含有特定字符记录的python代码实现</title>
    <url>/posts/a96c56b8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这个代码是提取FASTA文件描述行中含有特定字符的记录。</p>
<p>这个脚本代码量很少，但是需要动一下脑子，难点在于序列部分的行数是不固定的。</p>
<span id="more"></span>
<h1>使用软件</h1>
<ul>
<li>python 3.8 及以上版本</li>
</ul>
<h1>输入输出文件格式</h1>
<p>输入文件为一个FASTA文件，示例数据见 <a href="https://github.com/VincereZhou/code_backup/blob/master/tiao_Sus/1_fa.txt">1_fa.txt</a>。输出数据为提取特定记录后生成的FASTA文件，示例结果文件见 <a href="https://github.com/VincereZhou/code_backup/blob/master/tiao_Sus/out_fa.txt">out_fa.txt</a></p>
<p>FASTA 可以存储任何的序列数据，比如参考基因组文件，蛋白质序列，coding DNA sequence (CDS) , 转录序列等。</p>
<p>FASTA 文件的每条记录包含两个部分：一个是描述部分（&gt; 开始，包含序列名称和其他信息），一个是序列数据部分（第二行直至到描述行，<strong>可占据多行</strong>）。</p>
<p>FASTA 文件的灵活性导致它的结构定义很宽泛，结构不严谨，运行程序可能会遭遇未知的错误。</p>
<p>举个例子，示例数据的第一条记录见下，第一行是描述行，第二行和第三行是序列（应该是RNA序列）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop</span><br><span class="line">UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC</span><br><span class="line">UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA</span><br></pre></td></tr></table></figure>
<h1>运行代码</h1>
<p>代码文件见：<a href="https://github.com/VincereZhou/code_backup/blob/master/tiao_Sus/tiao_Sus.py">tiao_Sus.py</a></p>
<p>将输入文件和本程序放在同一文件夹下，运行命令示范如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python tiao_Sus.py 1_fa.txt Sus out_fa.txt</span><br></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<p><code>1_fa.txt</code>: 第一个参数为输入 FASTA 文件名称</p>
<p><code>Sus</code>:  第二个参数为提取的描述部分字段</p>
<p><code>out_fa.txt</code>: 第三个参数为输出文件名称</p>
<h1>代码说明</h1>
<h2 id="输入参数，打开文件">输入参数，打开文件</h2>
<p>导入 sys 模块，输入参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="comment">#挑不规则行数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">in_file = <span class="built_in">open</span>(sys.argv[<span class="number">1</span>],<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">field = sys.argv[<span class="number">2</span>]</span><br><span class="line">out_file = <span class="built_in">open</span>(sys.argv[<span class="number">3</span>],<span class="string">&#x27;w&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="遍历输入文件">遍历输入文件</h2>
<p>先创建一个空字典，然后遍历输入FASTA文件，字典 <code>dick</code> 的键是行索引 (从0开始)，值为该行的内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dick = &#123;&#125;</span><br><span class="line"></span><br><span class="line">j=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> in_file:</span><br><span class="line">    dick[j] = i <span class="comment">#行：内容 从0开始</span></span><br><span class="line">    j+=<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="遍历字典">遍历字典</h2>
<p>这里是<strong>重点</strong>。遍历字典 <code>dick</code> ，这里其实是 <code>j</code> 的递增来实现文件内容的换行；<code>j</code> 每增加1，相当于文件跳到下一行。通过第一个while 循环 (<code>while j &lt; len(dick)</code>) 保证迭代到文件的最后一行。之后就是一个判断，需要同时满足两个条件：<code>&gt;</code> 在这一行中并且需要查找的特定字符也在这一行中。如果满足这个条件，将这一行内容写入到输出文件中，跳到下一行，再通过 while 循环将后面跟着的序列行也写入到输出文件中（这里用 while 循环是解决序列行数不固定的问题）。如果不满足上面的判断，那么直接跳到下一行。</p>
<p>上面说了一堆逻辑，有点啰嗦，其实你看着输入文件和脚本，<strong>在脑子里运行一遍</strong>就清楚了。我写这个脚本的时候，也是在脑子里运行一遍才明确没有问题的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">j=<span class="number">0</span> </span><br><span class="line"><span class="keyword">while</span> j &lt; <span class="built_in">len</span>(dick): <span class="comment">#不是&lt;=</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;&gt;&#x27;</span> <span class="keyword">in</span> dick[j]) <span class="keyword">and</span> (field <span class="keyword">in</span> dick[j]):</span><br><span class="line">        out_file.write(dick[j])</span><br><span class="line">        j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="string">&#x27;&gt;&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> dick[j]):</span><br><span class="line">            out_file.write(dick[j])</span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        j+=<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="关闭文件">关闭文件</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">in_file.close()</span><br><span class="line">out_file.close()</span><br></pre></td></tr></table></figure>
<h1>闲话</h1>
<p>这是几年前给涛哥写的小代码，虽然代码很短，但是确实花了心思。</p>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>规整某类基因型数据R代码与python代码实现</title>
    <url>/posts/2c9b1be7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这个是规整某类格式”不规范“的基因型数据的脚本实现说明，同时采用了 R 和 python 进行实现。</p>
<p>这个需求实现起来说难不难，说易不易，仅是为了将下面我要提到的这类下机的基因型数据转变为常用的plink格式。这里的两个代码可能本身对其他人无法直接使用，但是还是有些借鉴作用。</p>
<span id="more"></span>
<h1>使用软件</h1>
<ul>
<li>python 3.8 及以上版本</li>
<li>plink 软件 v1.90，并且提前加到环境变量中。</li>
</ul>
<h1>输入文件格式</h1>
<h2 id="下机基因型数据">下机基因型数据</h2>
<p>示例数据见 <a href="https://github.com/VincereZhou/code_backup/blob/master/mass_to_plink/rawdata.xlsx">rawdata.xlsx</a> ，是一个 Excel 表，内容见下表。第一列是样本名称，后面每一列表示一个SNP，标题是SNP的名称。也就是说，一行表示一个样本，一列表示一个SNP。如果基因型为两个字符，说明是杂合子，例如GA；如果基因型是一个字符，说明是纯合子，例如T (正常应该记为TT，这里省略了一个字符)；如果单元格内容为空，说明此处基因型缺失。</p>
<table>
<thead>
<tr>
<th>id</th>
<th>seq-rs319899733</th>
<th>seq-rs320947633</th>
<th>seq-rs326926754</th>
<th>seq-rs327695512</th>
</tr>
</thead>
<tbody>
<tr>
<td>24</td>
<td>T</td>
<td>A</td>
<td></td>
<td>CT</td>
</tr>
<tr>
<td>31</td>
<td>T</td>
<td>GA</td>
<td>C</td>
<td>C</td>
</tr>
<tr>
<td>23</td>
<td>CT</td>
<td>GA</td>
<td>C</td>
<td>C</td>
</tr>
<tr>
<td>29</td>
<td>T</td>
<td>GA</td>
<td></td>
<td>T</td>
</tr>
</tbody>
</table>
<h2 id="参考map文件">参考map文件</h2>
<p>包含下机基因型所有SNP的 map 文件，根据这个文件来生成下机基因型数据的map文件，示例数据见 <a href="https://github.com/VincereZhou/code_backup/blob/master/mass_to_plink/raw.map">raw.map</a></p>
<p>map 文件格式说明见<a href="https://vincere.fun/posts/506fc784/">根据芯片号拆分plink文件的代码实现</a></p>
<h1>输出文件格式</h1>
<p>一对 plink 文件，文件格式说明见<a href="https://vincere.fun/posts/506fc784/">根据芯片号拆分plink文件的代码实现</a></p>
<h1>运行代码</h1>
<h2 id="运行R代码">运行R代码</h2>
<p>R 代码文件见：<a href="https://github.com/VincereZhou/code_backup/blob/master/mass_to_plink/mass_to_plink.R">mass_to_plink.R</a></p>
<p>将两个输入文件和本程序放在同一文件夹下，运行命令示范如下。运行结束后，会生成规整后的 plink 文件 <code>new.ped/map</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Rscript mass_to_plink.R rawdata.xlsx raw.map</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong>：</p>
<p><code>rawdata.xlsx</code>: 第一个参数为下机基因型数据</p>
<p><code>raw.map</code>：第二个参数为参考map文件。</p>
<h2 id="运行python代码">运行python代码</h2>
<p>python 代码文件见：<a href="https://github.com/VincereZhou/code_backup/blob/master/mass_to_plink/mass_to_plink.py">mass_to_plink.py</a></p>
<p>将两个输入文件和本程序放在同一文件夹下，运行命令示范如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python mass_to_plink.py rawdata.xlsx raw.map new2</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong>：</p>
<p><code>rawdata.xlsx</code>: 第一个参数为下机基因型数据</p>
<p><code>raw.map</code>：第二个参数为参考map文件。</p>
<p><code>new2</code> : 输出plink文件前缀</p>
<p>运行结束后，生成以第三个参数为前缀的plink 文件。</p>
<h2 id="示例">示例</h2>
<p>示例数据和代码我都放到了一个文件夹内 <a href="https://github.com/VincereZhou/code_backup/blob/master/mass_to_plink">mass_to_plink</a> ，有兴趣可以自己跑一下。</p>
<h1>代码说明</h1>
<p>这两个代码内部我都有比较详细的注释，这里就不再贴代码了。</p>
<p>两个代码的实现思路是一样的，首先要对基因型数据进行规整，缺失要替换为00，纯合子要改为两个字符，生成 compound 格式的 ped  文件（正常的ped文件一个SNP占两列，compound 格式则是一个SNP占一列，一个SNP的两个碱基之间无分隔符）。之后从参考map中提取相应的SNP的行，生成需要的map文件。最后通过 plink 软件将 compound 格式的文件转化为正常的plink格式。</p>
<h1>后续</h1>
<p>R 本身就有 <code>dataframe</code> 这种数据类型，而 python 是需要借助 pandas 模块进行处理。其实我第一次是用 R 实现的，后面又用 python 写了一遍。分别用 R 和 python 跑了一遍以后，我又用之前提到的比对基因型的代码，比较了两个生成的plink文件，基因型完全一致（具体参考 <a href="https://vincere.fun/posts/fa9e0b0e/">两个Plink文件样本间基因型比对代码实现</a> 和 <a href="https://vincere.fun/posts/6897c9bb/">两个Plink文件同一SNP基因型比对代码实现</a>）。</p>
<p>这里也有一个简单的办法，就是通过 sha1sum 或 md5sum 进行文件校验，你会发现两个 ped 文件 或 map 文件都是一样的。但是这种做法并不稳健，如果校验码不一致，不一定说明两个plink文件基因型不一致，还有很多原因导致校验码不同，比如 SNP 顺序不同，性染色体编码不同，杂合子显示顺序不同（如 A G 与 G A）等等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sha1sum new*.ped</span></span><br><span class="line">5150663442126f2f4e5b57e9d2d58118bf1f90f3  new1.ped</span><br><span class="line">5150663442126f2f4e5b57e9d2d58118bf1f90f3  new2.ped</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sha1sum new*.map</span></span><br><span class="line">f899867a1d9f762b7a3d7fb231d5fc13fdc44aa4  new1.map</span><br><span class="line">f899867a1d9f762b7a3d7fb231d5fc13fdc44aa4  new2.map</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>根据芯片号拆分plink文件的代码实现</title>
    <url>/posts/506fc784/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这个代码同样是一个处理基因型数据的<strong>入门级别</strong>的 python 脚本。</p>
<p>目的是根据芯片号，将一对plink文件，提取相应的基因型个体，拆分为一对或多对子文件。</p>
<span id="more"></span>
<h1>使用软件</h1>
<ul>
<li>python 3.8 及以上版本</li>
</ul>
<h1>输入文件格式</h1>
<h2 id="plink-文件">plink 文件</h2>
<p>plink格式的基因型文件包含两个文件：基因型文件（以.ped结尾）和图谱文件（以.map结尾），格式如下：</p>
<p>（1）基因型文件（ped文件）</p>
<p>FAM001 IND001 0 0 1 2 A A G G A C  …</p>
<p>FAM001 IND002 0 0 1  2 A A A G 0 0  …</p>
<p>……</p>
<p>格式说明：前6列分别是：家系编号，个体编号，父亲编号，母亲编号，性别，表型值；性别编码规则：‘1’代表雄性，‘2’代表雌性，其他字符代表性别未知；从第7列开始是基因型（只支持二等位位点），每个位点2列，默认‘0’代表基因型缺失。</p>
<p>（2）图谱文件（MAP文件）</p>
<p>1 rs234567 0 1237793</p>
<p>1 rs224534 0 1237697</p>
<p>1 rs233556  0 1337456</p>
<p>……</p>
<p>格式说明：包含4列：染色体编号，标记名称，标记遗传图谱，标记物理位置；对于性染色体和线粒体的‘染色体’编号规则：总的常染色体对数加一 表示X染色体，Y染色体、假常染色体和线粒体在此基础上依次加一。</p>
<p>更加详细说明见<a href="https://www.cog-genomics.org/plink/1.9/data">官网</a></p>
<h2 id="拆分文件">拆分文件</h2>
<p>一列或两列，无标题，以空格或制表符分隔。</p>
<p>如果是一列，则为一列芯片号，程序会将这一列芯片号的基因型提取出来，生成一对子文件，命名为 <code>split_plink.ped</code> 和 <code>split_plink.map</code></p>
<p>如果是两列，第一列是芯片号，第二列是芯片分类名（例如品种）。此时程序会将不同分类的芯片提取出来，各生成一对plink文件，plink文件前缀即为分类名。</p>
<h1>输出文件格式</h1>
<p>一对或多对 plink 文件。</p>
<h1>运行代码</h1>
<p>代码文件见：<a href="https://github.com/VincereZhou/code_backup/blob/master/split_plink.py">split_plink.py</a></p>
<p>将两个输入文件和本程序放在同一文件夹下，运行命令示范如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python split_plink.py plink_prefix split_plink.txt</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong>：</p>
<p><code>plink_prefix</code> : 第一个参数为总的plink前缀</p>
<p><code>split_plink.txt</code>：第二个参数为拆分文件</p>
<h1>例子</h1>
<p>举个简单的例子，方便理解。</p>
<p>总的plink为 1.ped 1.map。</p>
<p>1.ped 内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">221 30800300 0 0 0 -9 C C T T T T A A C C</span><br><span class="line">222 30800299 0 0 0 -9 T C T T T T G A T C</span><br><span class="line">223 30800298 0 0 0 -9 T C T T T T A A C C</span><br><span class="line">224 30800297 0 0 0 -9 C C T T T T G A T C</span><br><span class="line">225 30800296 0 0 0 -9 T C T T T T A A C C</span><br></pre></td></tr></table></figure>
<p>1.map 内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>	<span class="number">1_242598</span>	<span class="number">0</span>	<span class="number">242598</span></span><br><span class="line"><span class="number">1</span>	<span class="number">1_10673082</span>	<span class="number">16.99376</span>	<span class="number">10673082</span></span><br><span class="line"><span class="number">1</span>	<span class="number">1_10723065</span>	<span class="number">17.17102</span>	<span class="number">10723065</span></span><br><span class="line"><span class="number">1</span>	<span class="number">1_11407894</span>	<span class="number">19.59961</span>	<span class="number">11407894</span></span><br><span class="line"><span class="number">1</span>	<span class="number">1_11426075</span>	<span class="number">19.66408</span>	<span class="number">11426075</span></span><br></pre></td></tr></table></figure>
<p>第一个拆分文件为 split_plink1.py ，内容只有一列，为3个芯片号。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">30800300</span></span><br><span class="line"><span class="number">30800299</span></span><br><span class="line"><span class="number">30800298</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行命令，提取这三个个体的基因型，第一个参数为 1，为总的plink文件前缀；第二个参数为拆分文件名。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python split_plink.py <span class="number">1</span> split_plink1.txt</span><br></pre></td></tr></table></figure>
<p>生成 <code>split_plink.ped</code> 和 <code>split_plink.map</code> ，生成的 <code>split_plink.map</code>文件与<code>1.map</code> 一致，<code> split_plink.ped</code>  文件内容如下，为需要的三个芯片号的基因型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">221</span> <span class="number">30800300</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">9</span> C C T T T T A A C C</span><br><span class="line"><span class="number">222</span> <span class="number">30800299</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">9</span> T C T T T T G A T C</span><br><span class="line"><span class="number">223</span> <span class="number">30800298</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">9</span> T C T T T T A A C C</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第二个拆分文件为 split_plink2.py ，内容为两列，第二列模拟为 3 个物种，分别命名为 DD, LL,  YY</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">30800300</span>	DD</span><br><span class="line"><span class="number">30800299</span>	DD</span><br><span class="line"><span class="number">30800298</span>	LL</span><br><span class="line"><span class="number">30800297</span>	YY</span><br><span class="line"><span class="number">30800296</span>	YY</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行命令，提取这三个个体的基因型，第一个参数为 1，为总的plink文件前缀；第二个参数为拆分文件名。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python split_plink.py <span class="number">1</span> split_plink2.txt</span><br></pre></td></tr></table></figure>
<p>生成了三对 plink 文件，DD.ped/map ，LL.ped/map ,  YY.ped/map ，三个map 文件均与 <code>1.map</code> 一致。三个 ped 文件内容如下：</p>
<p>DD.ped 内容为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">221</span> <span class="number">30800300</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">9</span> C C T T T T A A C C</span><br><span class="line"><span class="number">222</span> <span class="number">30800299</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">9</span> T C T T T T G A T C</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>LL.ped 内容为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">223 30800298 0 0 0 -9 T C T T T T A A C C</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>YY.ped 内容为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">224</span> <span class="number">30800297</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">9</span> C C T T T T G A T C</span><br><span class="line"><span class="number">225</span> <span class="number">30800296</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">9</span> T C T T T T A A C C</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实现了将不同分类拆分为不同plink文件的需求。</p>
<h1>代码说明</h1>
<h2 id="注释说明">注释说明</h2>
<p>首先是两行注释，第一句以<code>#!</code>开头，后面接着的是我在linux系统中安装的python路径。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/mnt/data/zhouziwen/bin/miniConda/miniconda3/bin/python</span></span><br></pre></td></tr></table></figure>
<p>添加这句话的目的是指定解释器，就是说用什么去执行这个脚本。添加这个命令后，在给这个程序添加<strong>执行权限</strong>后（如何添加执行权限见<a href="https://www.runoob.com/linux/linux-comm-chmod.html">linux 的 chmod命令</a> ），可以将这个脚本视为正常的shell脚本执行，例子如下（<strong>需要先修改为你自己的python路径</strong>）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">./pick0.py <span class="built_in">id</span>.txt bigfile.txt out.txt</span><br></pre></td></tr></table></figure>
<p>如果你没看懂，不要紧，这个不重要，你就还是按照上面的<code>运行代码</code>部分写的运行命令去运行即可。</p>
<p>第二行注释是指定字符编码为 <code>utf-8</code>（字符编码的内容可以看看这篇博客，<a href="https://juejin.cn/post/6844903623474806792">字符编码那点事</a>） ，不然写中文注释会报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br></pre></td></tr></table></figure>
<p>后面是我自己写的两行注释，说明代码功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按照一个芯片号文件拆分plink文件</span></span><br><span class="line"><span class="comment"># 如果芯片号文件只有一列，默认输出文件为 split_plink.ped split_plink.map</span></span><br></pre></td></tr></table></figure>
<h2 id="导入模块和参数">导入模块和参数</h2>
<p>这里只导入了三个内置模块。</p>
<p>导入 <code>defaultdict</code> 函数的作用是可以指定字典的值为一种默认的数据类型，比如列表，下面会用到。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os,sys</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br></pre></td></tr></table></figure>
<p>接下来，导入参数并读取文件。这里将第一个参数 (<code>sys.argv[1]</code>) 命名为 <code>plink_prefix</code> ，即 plink 文件前缀。第二个参数为拆分文件，打开文件，命名为 <code>split_file</code> 。打开 <code>ped</code> 文件，命名为 <code>plink_file</code> 。 最后一句将map文件名命名为 <code>map_file_name</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plink_prefix = sys.argv[<span class="number">1</span>] <span class="comment"># plink文件前缀</span></span><br><span class="line">split_file = <span class="built_in">open</span>(sys.argv[<span class="number">2</span>],<span class="string">&#x27;r&#x27;</span>) <span class="comment"># 拆分信息文件，无标题，一列（芯片号）或两列（芯片号-分类名）</span></span><br><span class="line">plink_file = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix&#125;</span>.ped&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">map_file_name = <span class="string">f&quot;<span class="subst">&#123;plink_prefix&#125;</span>.map&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="获取拆分文件列数">获取拆分文件列数</h2>
<p>这里是通过 <code>readline()</code> 读取拆分文件的第一行内容，然后使用 <code>split()</code> 函数对第一行内容按空白字符拆分为列表，最后用 <code>len()</code> 函数求列表元素的个数。通过这种方法，实际获取的是拆分文件第一行的列数，命名为 <code>column_num</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">column_num = <span class="built_in">len</span>(split_file.readline().split())</span><br></pre></td></tr></table></figure>
<p>之后记得通过 <code>seek(0)</code> 函数将指针复原，不然下面对文件进行循环就是从第二行开始了，相当于剔除了第一行。使用了 <code>seek(0)</code> ，下面对文件进行循环，就依然是从第一行开始。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">split_file.seek(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="读取拆分文件内容">读取拆分文件内容</h2>
<p>先创建一个空列表和 一个值默认为列表的字典</p>
<p>注意，使用 <code>defaultdict(list)</code> 必须先从<code>collections</code> 包中导入<code>defaultdict</code> 函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set1 = <span class="built_in">set</span>()</span><br><span class="line">dick = defaultdict(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<p>遍历拆分文件内容，形成 <code>dick</code> 字典的内容。这里分了两种情况，拆分文件为一列和两列的情况，但是内容大同小异。</p>
<p>此处代码对于拆分文件的每一行首先判断列数是否均符合要求（是不是都是一列或两列），存在不符合要求的行，则报错 (<code>sys.exit(1)</code>) ；之后判断不同行之间的芯片号是否出现重复（通过 set1 进行判断），如果重复，则报错；最后将文件内容放入 <code>dick</code> 字典中，字典的键为分类名（如果拆分文件只有一列，则所有芯片号的分类名均设置为 <code>split_plink</code>），值为属于该分类名的所有芯片号组成的列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">j=<span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> column_num == <span class="number">1</span>: <span class="comment"># 只有一列</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> split_file:</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        f = i.split()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(f) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> f[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> set1:</span><br><span class="line">                set1.add(f[<span class="number">0</span>])</span><br><span class="line">                dick[<span class="string">&quot;split_plink&quot;</span>].append(f[<span class="number">0</span>]) <span class="comment"># 品种：芯片号的列表</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated chipid <span class="subst">&#123;f[<span class="number">0</span>]&#125;</span> in <span class="subst">&#123;sys.argv[<span class="number">1</span>]&#125;</span>\n&quot;</span>)</span><br><span class="line">                sys.exit(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error:<span class="subst">&#123;j&#125;</span> row in <span class="subst">&#123;sys.argv[<span class="number">1</span>]&#125;</span> is not 1 columns\n&quot;</span>)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">elif</span> column_num == <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> split_file:</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        f = i.split()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(f) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> f[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> set1:</span><br><span class="line">                set1.add(f[<span class="number">0</span>])</span><br><span class="line">                dick[f[<span class="number">1</span>]].append(f[<span class="number">0</span>]) <span class="comment"># 品种：芯片号的列表</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated chipid <span class="subst">&#123;f[<span class="number">0</span>]&#125;</span> in <span class="subst">&#123;sys.argv[<span class="number">1</span>]&#125;</span>\n&quot;</span>)</span><br><span class="line">                sys.exit(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error:<span class="subst">&#123;j&#125;</span> row in <span class="subst">&#123;sys.argv[<span class="number">1</span>]&#125;</span> is not 2 columns\n&quot;</span>)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: first row in <span class="subst">&#123;sys.argv[<span class="number">1</span>]&#125;</span> is not 1 or 2 columns\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="读取-ped-文件内容">读取 ped 文件内容</h2>
<p>先创建一个空集合和空字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set2=<span class="built_in">set</span>()</span><br><span class="line">dick2 = &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>遍历 ped 文件，只做是否存在重复芯片号的判断，如果存在则报错，程序中止。</p>
<p>生成键为芯片号，值为整行内容的字典 <code>dick2</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> plink_file:</span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> set2:</span><br><span class="line">        set2.add(f[<span class="number">1</span>])</span><br><span class="line">        dick2[f[<span class="number">1</span>]] = i <span class="comment"># 芯片号：芯片信息的行</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated chipid <span class="subst">&#123;f[<span class="number">1</span>]&#125;</span> in <span class="subst">&#123;sys.argv[<span class="number">2</span>]&#125;</span>.ped\n&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="写入结果文件">写入结果文件</h2>
<p>这里我们遍历 dick 的所有键，即遍历所有的分类名。首先这里先将原始的map文件复制为当前的分类名的map文件；之后我们创建<code>out_plink_list</code> 这个列表，作为拆分的<code>ped</code>文件内容的临时存储的地方；然后遍历该分类名下的所有芯片号，将这些芯片号的基因型信息存放在<code>out_plink_list</code> 列表中（这里会判断这些芯片号是否均在 plink 文件中，如果不在则程序报错中）。最后创建以分类号为前缀的 <code>ped</code> 文件，将  <code>out_plink_list</code>  中的全部内容写入其中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dick: <span class="comment"># 所有品种</span></span><br><span class="line">    <span class="comment"># 复制map文件</span></span><br><span class="line">    os.system(<span class="string">f&quot;cp <span class="subst">&#123;map_file_name&#125;</span> <span class="subst">&#123;i&#125;</span>.map&quot;</span>) </span><br><span class="line">    out_plink_list = []</span><br><span class="line">    <span class="keyword">for</span> i2 <span class="keyword">in</span> dick[i]:</span><br><span class="line">        <span class="comment"># 如果芯片号不在plink文件中报错</span></span><br><span class="line">        <span class="keyword">if</span> i2 <span class="keyword">not</span> <span class="keyword">in</span> dick2:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;i2&#125;</span> in <span class="subst">&#123;sys.argv[<span class="number">1</span>]&#125;</span> not in <span class="subst">&#123;sys.argv[<span class="number">2</span>]&#125;</span>\n&quot;</span>)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line">        out_plink_list.append(dick2[i2])</span><br><span class="line">    <span class="comment"># 生成plink 文件</span></span><br><span class="line">    out_plink_file = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span>.ped&quot;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    out_plink_file.writelines(out_plink_list)</span><br><span class="line">    out_plink_file.close()</span><br></pre></td></tr></table></figure>
<p>这里，如果拆分文件只有一列，那么 <code>dick</code> 中只有一种分类号，即<code>split_plink</code> ，因此最终只会生成一对plink文件，即 <code>split_plink.ped/map</code> 。</p>
<h2 id="关闭文件">关闭文件</h2>
<p>所有打开的文件记得关闭，由于写入的文件已经在循环中关闭了，最后只需要关闭读取的两个文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">split_file.close()</span><br><span class="line">plink_file.close()</span><br></pre></td></tr></table></figure>
<h1>小结</h1>
<p>这个脚本其实和上一篇<a href="https://vincere.fun/posts/a3902eec/">根据ID提取文件中相应行的python脚本实现与详细讲解</a> 有异曲同工之处，说白了都是根据某一列从提取需要的特定行，像这种需求用 python 很容易实现，而且可以再加一些判断，可以做到比较稳健。</p>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>根据ID提取文件中相应行的python脚本实现与详细讲解</title>
    <url>/posts/a3902eec/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这个代码是一个处理数据<strong>入门级别</strong>的 python 脚本，我尽可能详细地解释一下，方便小白入门。</p>
<p>这个代码目的是根据提供的ID文件从大文件中提取这些ID的行，生成一个新的文件， 与 Excel 的 <code>vlookup</code> 函数功能相似，优点是自动化。另外Excel 处理大数据会卡，甚至卡死，这时必须要用代码。</p>
<span id="more"></span>
<h1>使用软件</h1>
<ul>
<li>python 3.8 及以上版本</li>
</ul>
<h1>输入文件格式</h1>
<ul>
<li>
<p>ID 文件：第一列必须为需要提取的ID，可以包含其他无关列，以空格或制表符分隔。</p>
</li>
<li>
<p>大文件：用于提取信息的文件，第一列为ID，<strong>ID不能重复</strong>，以空格或制表符分隔。</p>
</li>
</ul>
<h1>输出文件格式</h1>
<p>输出文件为 ID 文件中的 ID 在大文件中的行。</p>
<h1>运行代码</h1>
<p>代码文件见：<a href="https://github.com/VincereZhou/code_backup/blob/master/pick0.py">pick0.py</a></p>
<p>将两个输入文件和本程序放在同一文件夹下，运行命令示范如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python pick0.py <span class="built_in">id</span>.txt bigfile.txt out.txt</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong>：</p>
<p><code>id.txt</code> : 第一个参数为 ID文件名称</p>
<p><code>bigfile.txt</code>：第二个参数为大文件名称</p>
<p><code>out.txt</code>：第三个参数为输出文件名称</p>
<h1>例子</h1>
<p>举个简单的例子。</p>
<p>id 文件为 id.txt ，内容如下</p>
<table>
<thead>
<tr>
<th>YYJXNM518090007</th>
</tr>
</thead>
<tbody>
<tr>
<td>YYJXNM518088704</td>
</tr>
<tr>
<td>YYJXNM518086910</td>
</tr>
</tbody>
</table>
<p>大文件为 big.txt，内容如下</p>
<table>
<thead>
<tr>
<th>YYJXNM518090007</th>
<th>202733730005_R01C02</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>YYJXNM518087902</td>
<td>202733730005_R01C04</td>
<td>1</td>
</tr>
<tr>
<td>YYJXNM518091108</td>
<td>202733730005_R02C01</td>
<td>1</td>
</tr>
<tr>
<td>YYJXNM518089506</td>
<td>202733730005_R02C02</td>
<td>1</td>
</tr>
<tr>
<td>YYJXNM518088704</td>
<td>202733730005_R02C03</td>
<td>1</td>
</tr>
<tr>
<td>YYJXNM518089706</td>
<td>202733730005_R02C04</td>
<td>1</td>
</tr>
<tr>
<td>YYJXNM518087310</td>
<td>202733730005_R03C01</td>
<td>1</td>
</tr>
<tr>
<td>YYJXNM518083704</td>
<td>202733730005_R03C03</td>
<td>1</td>
</tr>
<tr>
<td>YYJXNM518088705</td>
<td>202733730005_R03C04</td>
<td>1</td>
</tr>
<tr>
<td>YYJXNM518086910</td>
<td>202733730005_R04C01</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>执行命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python pick0.py <span class="built_in">id</span>.txt big.txt out.txt</span><br></pre></td></tr></table></figure>
<p>结果文件为 out.txt，内容如下，顺序与ID文件一致。</p>
<table>
<thead>
<tr>
<th>YYJXNM518090007</th>
<th>202733730005_R01C02</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>YYJXNM518088704</td>
<td>202733730005_R02C03</td>
<td>1</td>
</tr>
<tr>
<td>YYJXNM518086910</td>
<td>202733730005_R04C01</td>
<td>1</td>
</tr>
</tbody>
</table>
<h1>代码说明</h1>
<h2 id="注释说明">注释说明</h2>
<p>首先是两行注释，第一句以<code>#!</code>开头，后面接着的是我在linux系统中安装的python路径。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/mnt/data/zhouziwen/bin/miniConda/miniconda3/bin/python</span></span><br></pre></td></tr></table></figure>
<p>添加这句话的目的是指定解释器，就是说用什么去执行这个脚本。添加这个命令后，在给这个程序添加<strong>执行权限</strong>后（如何添加执行权限见<a href="https://www.runoob.com/linux/linux-comm-chmod.html">linux 的 chmod命令</a> ），可以将这个脚本视为正常的shell脚本执行，例子如下（<strong>需要先修改为你自己的python路径</strong>）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">./pick0.py <span class="built_in">id</span>.txt bigfile.txt out.txt</span><br></pre></td></tr></table></figure>
<p>如果你没看懂，不要紧，这个不重要，你就还是按照上面的<code>运行代码</code>部分写的运行命令去运行即可。</p>
<p>第二行注释是指定字符编码为 <code>utf-8</code>（字符编码的内容可以看看这篇博客，<a href="https://juejin.cn/post/6844903623474806792">字符编码那点事</a>） ，不然写中文注释会报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br></pre></td></tr></table></figure>
<h2 id="导入模块">导入模块</h2>
<p>python 的模块就相当于 R中的安装包，这里我们使用一个内置模块<code>sys</code>，目的是可以输入参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys </span><br></pre></td></tr></table></figure>
<h2 id="打开文件">打开文件</h2>
<p>这里我们使用 <code>sys</code> 模块的 <code>sys.argv</code> 导入外部参数，这里 <code>sys.argv[1]</code> 就是第一个参数，<code>sys.argv[2]</code> 就是第二个参数，以此类推。</p>
<p>在 python 中使用 <code>open</code> 函数打开文件，后面跟着 <code>'r'</code> 是读取文件，<code>'w'</code> 则是写入文件（没有则新建，已有该文件会直接覆盖），这两个分别是 <code>read</code> 和 <code>write</code> 的缩写。<code>open</code> 函数更具体的说明见<a href="https://www.runoob.com/python/python-func-open.html">open() 函数-菜鸟教程</a></p>
<p>这里的意思就是说，将输入的第一个参数以只读模式打开，命名为 <code>id</code> ；同样将第二个参数以只读模式打开，命名为 <code>bigfile</code> ；将第三个参数以<strong>写入模型</strong>打开，命名为 <code>outfile</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">id</span> = <span class="built_in">open</span>(sys.argv[<span class="number">1</span>],<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">bigfile = <span class="built_in">open</span>(sys.argv[<span class="number">2</span>],<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">outfile = <span class="built_in">open</span>(sys.argv[<span class="number">3</span>],<span class="string">&#x27;w&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="创建集合和字典">创建集合和字典</h2>
<p>这里我们创建一个空的集合和一个空的字典，分别命名为 set1 和 dick，一行同时创建两个变量用分号隔开。</p>
<p>集合和字典都是 python的可变数据结构，底层都是采用了哈希表。集合是存储单个值，字典是存储键值对，二者的共同特点是<strong>键不能重复</strong>，键出现重复会直接覆盖旧的数据。这一块我一句两句讲不清楚，不知道的可以自行上网看一些python的资料，只需要输入python和数据结构两个关键字，就能找到一堆资料了。</p>
<p>我这里用集合和字典，主要是利用它们查询快的特点（查看某个值是否在集合/字典中）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set1 = <span class="built_in">set</span>();dick=&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历大文件">遍历大文件</h2>
<p>python 可以使用 for 循环对一个文件的所有行进行遍历。不同的层次结构用缩进表示，每次缩进必须为 4 个空格。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> bigfile:</span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> f[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> dick:</span><br><span class="line">        dick[f[<span class="number">0</span>]] = i</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated id <span class="subst">&#123;f[<span class="number">0</span>]&#125;</span> in <span class="subst">&#123;sys.argv[<span class="number">2</span>]&#125;</span>\n&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>下面我们一行一行来看，第一句是 for 循环，遍历所有行，每一行的内容为一个字符串，并且这里命名为<code>i</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> bigfile:</span><br></pre></td></tr></table></figure>
<p>第二句话利用python字符串对象的 <code>split()</code>函数，将每一行的内容按照空白符（空格或制表符）进行分割，分隔结果为一个由各列内容组成的列表，命名为 <code>f</code>。<code>split()</code> 函数的具体解释见<a href="https://www.runoob.com/python/att-string-split.html">split() 函数-菜鸟教程</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = i.split()</span><br></pre></td></tr></table></figure>
<p>下面就是一个 <code>if-else</code> 结构，由于 python 索引是从0开始的，因此 <code>f[0]</code> 表示第一列的内容。</p>
<p>首先判断 <code>f[0]</code> 是否在 <code>dick</code> 字典中，<code>in</code> 表示 f[0] 是否在 dick 中，加 <code>not</code> 表示否定，也就是如果 <code>f[0]</code> 不在 <code>dick</code> 中的话，那么执行 <code>dick[f[0]] = i</code>，即在<code>dick</code> 字典中新增键为 <code>f[0]</code> ，值为 <code>i</code> （<code>i</code> 为整行的内容）的一条记录。如果 <code>f[0]</code> 在 <code>dick</code> 中，此时说明第一列存在重复ID，执行<code>else</code> 部分，<code>else</code> 部分首先用 <code>print</code>函数打印了一条报错信息，内部采用了 python新推出的 <code>f-string</code> ，用于格式化字符串（具体可见<a href="https://cloud.tencent.com/developer/article/1618028">f-string格式化输出</a>），简单地说，就是将<code>&#123;&#125;</code>的部分使用其中变量的内容，<code>f-string</code>不清楚可以先放一放；然后采用 <code>sys.exit(1)</code> 直接退出程序。</p>
<p>我再用人话说一遍目的，这里就是判断大文件的ID是否有重复，只要存在重复那么程序会直接报错终止。不存在重复的话，那么就会往<code>dick</code>字典中新增内容，键为ID，值为整行内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> f[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> dick:</span><br><span class="line">    dick[f[<span class="number">0</span>]] = i</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated id <span class="subst">&#123;f[<span class="number">0</span>]&#125;</span> in <span class="subst">&#123;sys.argv[<span class="number">2</span>]&#125;</span>\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="遍历ID文件，生成结果文件">遍历ID文件，生成结果文件</h2>
<p>这里首先新增了两个数字变量和一个列表。这三个的目的是，<code>not_in_num</code> 是ID文件中的ID不在大文件中的数目，<code>duplicate_id_num</code> 是ID文件中剔除的重复ID的数目，<code>not_in_list</code> 是是ID文件中的ID不在大文件中的ID组成的列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">not_in_num = <span class="number">0</span></span><br><span class="line">duplicate_id_num = <span class="number">0</span></span><br><span class="line">not_in_list = []</span><br></pre></td></tr></table></figure>
<p>遍历ID文件，这里将一下流程，首先会对ID进行去重，然后判断ID是否在dick中，如果在，那么就将这个ID对应的大文件中的行内容写入到输出文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">id</span>:</span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> f[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> set1: <span class="comment">#id文件去重</span></span><br><span class="line">        set1.add(f[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> f[<span class="number">0</span>] <span class="keyword">in</span> dick:</span><br><span class="line">            outfile.write(dick[f[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            not_in_num += <span class="number">1</span></span><br><span class="line">            not_in_list.append(f[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        duplicate_id_num += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如果ID文件中存在重复ID，打印信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> duplicate_id_num &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Warning: <span class="subst">&#123;duplicate_id_num&#125;</span> duplicated id in <span class="subst">&#123;sys.argv[<span class="number">1</span>]&#125;</span>\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>如果存在不在大文件中的ID，生成一个新的文件，<code>pick0_not_in_id.txt</code>，内容就是不在大文件中的ID，即 <code>not_in_list</code> 的内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> not_in_num &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Warning: <span class="subst">&#123;not_in_num&#125;</span> id not in <span class="subst">&#123;sys.argv[<span class="number">2</span>]&#125;</span>\n&quot;</span>)</span><br><span class="line">    not_in_file = <span class="built_in">open</span>(<span class="string">&#x27;pick0_not_in_id.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> not_in_list:</span><br><span class="line">        not_in_file.write(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span>\n&quot;</span>)</span><br><span class="line">    not_in_file.close()</span><br></pre></td></tr></table></figure>
<h2 id="关闭文件">关闭文件</h2>
<p>使用 <code>open</code>函数打开文件后，记得关闭文件，这是一个好习惯。写入的文件（即<code>'w'</code>模式）只有关闭了文件，才会真正写入到硬盘中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">id</span>.close()</span><br><span class="line">bigfile.close()</span><br><span class="line">outfile.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>两个Plink文件同一SNP基因型比对代码实现</title>
    <url>/posts/6897c9bb/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本软件是<a href="https://vincere.fun/posts/fa9e0b0e/">两个Plink文件样本间基因型比对代码实现</a>的另一种比对角度， 前面的思路是在比较两个基因型文件中，同一个样本之间有多少位点不一致，这里是比较同一个SNP有多少样本的分型不一致。在比对同一个群体的两个plink文件时，如果存在不一致，这两种比对角度都是必需的。</p>
<span id="more"></span>
<p>举个例子，比对某个群体基因型文件填充前后的基因型变化，查看样本间不一致率，发现所有样本都有几十个位点不一致，前三行如下：</p>
<table>
<thead>
<tr>
<th>202884940104_R14C04</th>
<th>202884940104_R14C04</th>
<th>15</th>
<th>34653</th>
<th>0.0004</th>
</tr>
</thead>
<tbody>
<tr>
<td>202884940104_R11C01</td>
<td>202884940104_R11C01</td>
<td>17</td>
<td>34665</td>
<td>0.0005</td>
</tr>
<tr>
<td>202888800049_R23C04</td>
<td>202888800049_R23C04</td>
<td>17</td>
<td>34658</td>
<td>0.0005</td>
</tr>
</tbody>
</table>
<p>而通过相同的 SNP 间的不一致率，发现大部分 SNP 在两个基因型文件中完全一致，只有一小部分SNP存在不一致，前三行如下：</p>
<table>
<thead>
<tr>
<th>8_118011832</th>
<th>3508</th>
<th>3529</th>
<th>0.994</th>
</tr>
</thead>
<tbody>
<tr>
<td>5_39432167</td>
<td>3459</td>
<td>3524</td>
<td>0.9816</td>
</tr>
<tr>
<td>14_133523132</td>
<td>3428</td>
<td>3518</td>
<td>0.9744</td>
</tr>
</tbody>
</table>
<h1>前提条件</h1>
<p>两个 plink 文件中的 map 文件的染色体、SNP名称及物理位置必须保持一致，样本名称保持一致（两个plink 文件中同一样本的芯片号相同，可能需要自己手动转plink文件的样本名称）。</p>
<h1>使用软件</h1>
<ul>
<li>python 3.0以上版本，事先安装 numpy 模块。</li>
<li>plink 1.9 , 并将 plink 添加到环境变量中。</li>
</ul>
<h1>输入文件格式</h1>
<ul>
<li>plink 文件 ：前缀相同的一对文件，后缀分别为<code>.ped</code> ，<code>.map</code> 。</li>
</ul>
<h1>输出文件说明</h1>
<p><code>cmp_common_samples.txt</code> :  第一列为SNP名称，第二列为两个plink文件中共同样本中不一致的样本数目，第三列为共同样本总数，第四列为前两列相除得到的不一致率。</p>
<p>示例如下：</p>
<table>
<thead>
<tr>
<th>8_118011832</th>
<th>3508</th>
<th>3529</th>
<th>0.994</th>
</tr>
</thead>
<tbody>
<tr>
<td>5_39432167</td>
<td>3459</td>
<td>3524</td>
<td>0.9816</td>
</tr>
<tr>
<td>14_133523132</td>
<td>3428</td>
<td>3518</td>
<td>0.9744</td>
</tr>
</tbody>
</table>
<h1>运行代码</h1>
<p>代码文件见：<a href="https://github.com/VincereZhou/code_backup/blob/master/compair_snps.py">compair_snps.py</a></p>
<p>将输入文件和本程序放在同一文件夹下，运行命令示范为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python compair_snps.py --plink1 plink1 --plink2 plink2</span><br></pre></td></tr></table></figure>
<p><strong>可用参数说明</strong>：</p>
<p><code>--plink1</code>: 第一个plink文件前缀，必选。</p>
<p><code>--plink2</code>: 第二个plink文件前缀，可选。</p>
<p><code>--exclude-miss</code> : 基因型比对是否先剔除缺失值，可选，只能为yes和no，默认为yes。如果该选项设置为no，比对时不会剔除缺失样本对，如果存在同一个样本，在一个基因型文件中有基因型，另一个基因型文件中则为缺失，该样本同样会被视为不一致位点；如果该选项设置为 yes ，比对时会剔除至少一个样本为缺失的位点，只比对两个样本均不为缺失的位点。</p>
<p><code>--save-temp</code> :  是否保留中间文件，可选，只能为yes和no，默认为 no。</p>
<p><code>--out</code> : 结果文件名称，可选，默认为 <code>cmp_common_samples.txt</code></p>
<h1>代码说明</h1>
<h2 id="检验参数">检验参数</h2>
<p>检验输入的各个参数是否合规</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#检验参数</span></span><br><span class="line">legal_argument_set = <span class="built_in">set</span>([<span class="string">&quot;yes&quot;</span>, <span class="string">&quot;no&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">f&quot;<span class="subst">&#123;args.plink1&#125;</span>.ped&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: not exist <span class="subst">&#123;args.plink1&#125;</span>.ped\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">f&quot;<span class="subst">&#123;args.plink1&#125;</span>.map&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: not exist <span class="subst">&#123;args.plink1&#125;</span>.map\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">f&quot;<span class="subst">&#123;args.plink2&#125;</span>.ped&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: not exist <span class="subst">&#123;args.plink2&#125;</span>.ped\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">f&quot;<span class="subst">&#123;args.plink2&#125;</span>.map&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: not exist <span class="subst">&#123;args.plink2&#125;</span>.map\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.exclude_miss <span class="keyword">not</span> <span class="keyword">in</span> legal_argument_set:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: illegal input, --exclude-miss must be yes or no\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> args.save_temp <span class="keyword">not</span> <span class="keyword">in</span> legal_argument_set:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: illegal input, --save-temp must be yes or no\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="复制基因型文件">复制基因型文件</h2>
<p>这里根据原始plink文件重新生成两套新的plink文件，其中芯片号使用数字代替。</p>
<p>这里会提取<strong>共同位点，共同样本</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plink_prefix1 = args.plink1</span><br><span class="line">plink_prefix2 = args.plink2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制 map</span></span><br><span class="line">os.system(<span class="string">f&quot;cp <span class="subst">&#123;plink_prefix1&#125;</span>.map <span class="subst">&#123;plink_prefix1&#125;</span>_temp.map&quot;</span>)</span><br><span class="line">os.system(<span class="string">f&quot;cp <span class="subst">&#123;plink_prefix2&#125;</span>.map <span class="subst">&#123;plink_prefix2&#125;</span>_temp.map&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新生成plink 文件</span></span><br><span class="line">ped1 = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix1&#125;</span>.ped&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">map1 = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix1&#125;</span>.map&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ped2 = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix2&#125;</span>.ped&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">map2 = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix2&#125;</span>.map&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">re_ped1 = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix1&#125;</span>_temp.ped&quot;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">re_ped2 = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix2&#125;</span>_temp.ped&quot;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">common_snp_file = <span class="built_in">open</span>(<span class="string">f&#x27;<span class="subst">&#123;plink_prefix1&#125;</span>_<span class="subst">&#123;plink_prefix2&#125;</span>_common_snp_temp.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">error_status = <span class="literal">False</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#提取共同位点</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">temp_id_set = <span class="built_in">set</span>()</span><br><span class="line">temp_line_set = <span class="built_in">set</span>()</span><br><span class="line">map1_dick = &#123;&#125;  <span class="comment"># SNP名称：染色体_物理位置</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> map1:</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">len</span>(f) == <span class="number">4</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;\t&#x27;</span>.join(f) <span class="keyword">not</span> <span class="keyword">in</span> temp_line_set:</span><br><span class="line">            temp_line_set.add(<span class="string">&#x27;\t&#x27;</span>.join(f))</span><br><span class="line">            <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> temp_id_set:</span><br><span class="line">                temp_id_set.add(f[<span class="number">1</span>])</span><br><span class="line">                map1_dick[f[<span class="number">1</span>]] = f[<span class="number">0</span>]+<span class="string">&quot;_&quot;</span>+f[<span class="number">3</span>] <span class="comment"># SNP名称：“染色体_物理位置”</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated id <span class="subst">&#123;f[<span class="number">1</span>]&#125;</span> in different rows in <span class="subst">&#123;plink_prefix1&#125;</span>.map\n&quot;</span>) </span><br><span class="line">                error_status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicted row <span class="subst">&#123;j&#125;</span> in <span class="subst">&#123;plink_prefix1&#125;</span>.map\n&quot;</span>)</span><br><span class="line">            error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;j&#125;</span> row in <span class="subst">&#123;plink_prefix1&#125;</span>.map has less or more than 4 coloums\n&quot;</span>)</span><br><span class="line">        error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">temp_id_set = <span class="built_in">set</span>()</span><br><span class="line">temp_line_set = <span class="built_in">set</span>()</span><br><span class="line">common_snp_num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> map2:</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">len</span>(f) == <span class="number">4</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;\t&#x27;</span>.join(f) <span class="keyword">not</span> <span class="keyword">in</span> temp_line_set:</span><br><span class="line">            temp_line_set.add(<span class="string">&#x27;\t&#x27;</span>.join(f))</span><br><span class="line">            <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> temp_id_set:</span><br><span class="line">                temp_id_set.add(f[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">in</span> map1_dick:</span><br><span class="line">                    common_snp_num += <span class="number">1</span></span><br><span class="line">                    common_snp_file.write(f[<span class="number">1</span>]+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated id <span class="subst">&#123;f[<span class="number">1</span>]&#125;</span> in different rows in <span class="subst">&#123;plink_prefix2&#125;</span>.map\n&quot;</span>) </span><br><span class="line">                error_status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicted row <span class="subst">&#123;j&#125;</span> in <span class="subst">&#123;plink_prefix2&#125;</span>.map\n&quot;</span>)</span><br><span class="line">            error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;j&#125;</span> row in <span class="subst">&#123;plink_prefix2&#125;</span>.map has less or more than 4 coloums\n&quot;</span>)</span><br><span class="line">        error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nNumber of common SNPs in two plink files: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(common_snp_num))</span><br><span class="line">   </span><br><span class="line"><span class="comment">#重命名</span></span><br><span class="line"><span class="comment"># newid_dick = &#123;&#125; #chipid/sampleid:newid</span></span><br><span class="line"><span class="comment"># sampleid_dick = &#123;&#125; #newid:chipid/sampleid</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#ped重编码为数字(1-indexed)</span></span><br><span class="line"><span class="comment"># 第一次结果不对</span></span><br><span class="line"><span class="comment"># 我懂了，plink 的 merge 命令会重新排列样本顺序，所以不是按照ped1,ped2的顺序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改程序，严格按照想要的总文件的顺序，重编码芯片号。然后合并时先合并ped2,再合并ped1</span></span><br><span class="line"><span class="comment"># 重编码 ped 文件，第一列家系号替换为0，个体号重编码为数字。因为 merge 命令会按照 家系号 + 个体号进行排序。</span></span><br><span class="line"></span><br><span class="line">ped1_dick = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ped1:</span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> ped1_dick:</span><br><span class="line">        ped1_dick[f[<span class="number">1</span>]] = <span class="string">&#x27;\t&#x27;</span>.join(f[<span class="number">2</span>:])+<span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        error_status = <span class="literal">True</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated chip id <span class="subst">&#123;f[<span class="number">1</span>]&#125;</span> in <span class="subst">&#123;plink_prefix1&#125;</span>.ped\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">sample1_num = <span class="built_in">len</span>(ped1_dick)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of records present in plink1 file: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(sample1_num))</span><br><span class="line"></span><br><span class="line">common_sample_list = []</span><br><span class="line">common_sample_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">j=<span class="number">0</span></span><br><span class="line">temp_id_set = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ped2:</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> temp_id_set:</span><br><span class="line">        temp_id_set.add(f[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">in</span> ped1_dick:</span><br><span class="line">            common_sample_num += <span class="number">1</span></span><br><span class="line">            common_sample_list.append(f[<span class="number">1</span>]) <span class="comment">#两个样本重复样的芯片号</span></span><br><span class="line">            re_ped2.write(<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(j)+<span class="string">&#x27;\t&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>.join(f[<span class="number">2</span>:])+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        error_status = <span class="literal">True</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated chip id <span class="subst">&#123;f[<span class="number">1</span>]&#125;</span> in <span class="subst">&#123;plink_prefix2&#125;</span>.ped\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">sample2_num = j</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of records present in plink2 file: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(sample2_num))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of common samples in two plink file: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(common_sample_num))</span><br><span class="line"></span><br><span class="line"><span class="comment">## re_ped1 重排个体顺序，使得与 re_ped2 一致</span></span><br><span class="line"><span class="comment">## 这里的 j 沿着上面递增，没有初始化 j = 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> common_sample_list:</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">    re_ped1.write(<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(j)+<span class="string">&#x27;\t&#x27;</span>+ped1_dick[i])</span><br><span class="line"></span><br><span class="line">ped1.close()</span><br><span class="line">map1.close()</span><br><span class="line">ped2.close()</span><br><span class="line">map2.close()</span><br><span class="line">re_ped1.close()</span><br><span class="line">re_ped2.close()</span><br><span class="line">common_snp_file.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="合并基因型">合并基因型</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果没有共同个体，程序中止</span></span><br><span class="line"><span class="keyword">if</span> common_sample_num == <span class="number">0</span>: <span class="comment">#如果没有共同个体，报错</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: two plink file has no same samples, check your data again!&quot;</span>)</span><br><span class="line">    error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果读取文件过程中出现错误退出</span></span><br><span class="line"><span class="keyword">if</span> error_status:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Please check your file again!&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># extract merge recodeA</span></span><br><span class="line"><span class="comment"># 合并文件是第二个plink文件的共同样本在上方，第一个plink的共同样本在下方，二者样本的顺序一致。</span></span><br><span class="line"></span><br><span class="line">merge_status = os.system(<span class="string">f&quot;plink --allow-extra-chr --chr-set 95 --file <span class="subst">&#123;plink_prefix2&#125;</span>_temp --merge <span class="subst">&#123;plink_prefix1&#125;</span>_temp --extract <span class="subst">&#123;plink_prefix1&#125;</span>_<span class="subst">&#123;plink_prefix2&#125;</span>_common_snp_temp.txt --recodeA --out <span class="subst">&#123;plink_prefix1&#125;</span>_<span class="subst">&#123;plink_prefix2&#125;</span>_merge_temp &gt; /dev/null&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> merge_status != <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error in merge two plink data\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Maybe some common SNP from Complementary strands, check your data again&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#raw文件处理</span></span><br><span class="line">os.system(<span class="string">f&quot;sed &#x27;s/NA/3/g&#x27; <span class="subst">&#123;plink_prefix1&#125;</span>_<span class="subst">&#123;plink_prefix2&#125;</span>_merge_temp.raw &gt; <span class="subst">&#123;plink_prefix1&#125;</span>_<span class="subst">&#123;plink_prefix2&#125;</span>_merge_temp_sed.raw&quot;</span>)</span><br><span class="line">raw_file = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix1&#125;</span>_<span class="subst">&#123;plink_prefix2&#125;</span>_merge_temp_sed.raw&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">out_file = <span class="built_in">open</span>(args.out,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理标题，得到 SNP 名称</span></span><br><span class="line">snp_list = []</span><br><span class="line">title = raw_file.readline().split() <span class="comment">#剔除标题</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> title[<span class="number">6</span>:]:</span><br><span class="line">    snp_name = i[:-<span class="number">2</span>]</span><br><span class="line">    snp_list.append(snp_name) <span class="comment"># SNP名称的列表</span></span><br><span class="line"></span><br><span class="line">raw_list=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> raw_file:</span><br><span class="line">    f = i.split()</span><br><span class="line">    raw_list.append(f[<span class="number">6</span>:])</span><br><span class="line"></span><br><span class="line">array1 = np.array(raw_list, dtype=np.int8)</span><br><span class="line"></span><br><span class="line">total_sample_num = array1.shape[<span class="number">0</span>]</span><br><span class="line">snp_num = array1.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of records present in merged ped file: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(total_sample_num))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of SNPs in merged plink files: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(snp_num))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (total_sample_num != (<span class="number">2</span>*common_sample_num)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: total samples number of merged plink file is not 2 fold of common samples in two plink files\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="比对同一个SNP的基因型">比对同一个SNP的基因型</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#计算不一致率</span></span><br><span class="line">out_list = []</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> args.exclude_miss == <span class="string">&#x27;yes&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(snp_num):</span><br><span class="line">        first_index = <span class="built_in">range</span>(<span class="number">0</span>,common_sample_num)</span><br><span class="line">        second_index = <span class="built_in">range</span>(common_sample_num,total_sample_num)</span><br><span class="line">        v1 = array1[first_index,i]</span><br><span class="line">        v2 = array1[second_index,i]</span><br><span class="line">        non_miss_index = np.where((v1!=<span class="number">3</span>) &amp; (v2!=<span class="number">3</span>))</span><br><span class="line">        total_num = non_miss_index[<span class="number">0</span>].shape[<span class="number">0</span>]</span><br><span class="line">        v1_new = v1[non_miss_index]</span><br><span class="line">        v2_new = v2[non_miss_index]</span><br><span class="line">        no_match_num = np.count_nonzero(v1_new!=v2_new)</span><br><span class="line">        <span class="keyword">if</span> total_num &gt; <span class="number">0</span>:</span><br><span class="line">            no_match_rate = no_match_num/total_num</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            no_match_rate = <span class="number">0</span></span><br><span class="line">        out_list.append([snp_list[i],<span class="string">f&quot;<span class="subst">&#123;no_match_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;total_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;no_match_rate:<span class="number">.4</span>f&#125;</span>&quot;</span>])</span><br><span class="line"><span class="keyword">elif</span> args.exclude_miss == <span class="string">&#x27;no&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(snp_num):</span><br><span class="line">        first_index = <span class="built_in">range</span>(<span class="number">0</span>,common_sample_num)</span><br><span class="line">        second_index = <span class="built_in">range</span>(common_sample_num,total_sample_num)</span><br><span class="line">        v1 = array1[first_index,i]</span><br><span class="line">        v2 = array1[second_index,i]</span><br><span class="line">        total_num = common_sample_num</span><br><span class="line">        no_match_num = np.count_nonzero(v1!=v2)</span><br><span class="line">        no_match_rate = no_match_num/total_num</span><br><span class="line">        out_list.append([snp_list[i],<span class="string">f&quot;<span class="subst">&#123;no_match_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;total_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;no_match_rate:<span class="number">.4</span>f&#125;</span>&quot;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sorted_out_list = <span class="built_in">sorted</span>(out_list, key = <span class="keyword">lambda</span> s:<span class="built_in">float</span>(s[<span class="number">3</span>]), reverse = <span class="literal">True</span>) <span class="comment">#不一致率从大到小</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sorted_out_list:</span><br><span class="line">    out_file.write(<span class="string">&#x27;\t&#x27;</span>.join(i)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">raw_file.close()</span><br><span class="line">out_file.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="删除中间文件">删除中间文件</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除中间文件</span></span><br><span class="line"><span class="keyword">if</span> args.save_temp == <span class="string">&quot;yes&quot;</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">elif</span> args.save_temp == <span class="string">&quot;no&quot;</span>:</span><br><span class="line">    os.system(<span class="string">f&quot;rm *temp*&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>生物信息</tag>
      </tags>
  </entry>
  <entry>
    <title>两个Plink文件样本间基因型比对代码实现</title>
    <url>/posts/fa9e0b0e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本软件对两个plink文件中的样本的共同的SNP位点进行比对，可以应用于同一群体不同处理之后得到的基因型文件的比对（例如比较不同的填充方式得到的plink文件）。</p>
<p>前提条件为，两个map的染色体、SNP名称及物理位置必须保持一致。</p>
<span id="more"></span>
<h1>使用软件</h1>
<ul>
<li>python 3.0以上版本，事先安装 numpy 模块。</li>
<li>plink 1.9 , 并将 plink 添加到环境变量中。</li>
</ul>
<h1>输入文件格式</h1>
<ul>
<li>plink 文件 ：前缀相同的一对文件，后缀分别为<code>.ped</code> ，<code>.map</code> 。</li>
<li>映射文件： 两列，所有基因型个体的芯片号与个体号，空格或 tab分隔，无标题。</li>
</ul>
<h1>输出文件说明</h1>
<ul>
<li>
<p><code>cmp_two_plinks.txt</code> :  第一列为第一个plink文件某个个体的个体号，第二列为第二个plink文件某个个体的个体号，第三列为两个样本不一致的位点数目，第四列为位点总数，第五列为前两列相除得到的不一致率。</p>
<p>示例如下：</p>
<table>
<thead>
<tr>
<th>202309870171_R01C01</th>
<th>202309870171_R01C01</th>
<th>0</th>
<th>43279</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>202309870171_R01C02</td>
<td>202309870171_R01C02</td>
<td>0</td>
<td>43289</td>
<td>0</td>
</tr>
<tr>
<td>202309870171_R02C01</td>
<td>202309870171_R02C01</td>
<td>0</td>
<td>43268</td>
<td>0</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h1>运行代码</h1>
<p>代码文件见：<a href="https://github.com/VincereZhou/code_backup/blob/master/compair_samples.py">compair_samples.py</a></p>
<p>将输入文件和本程序放在同一文件夹下，运行命令示范为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python compair_samples.py --plink1 plink1 --plink2 plink2</span><br></pre></td></tr></table></figure>
<p><strong>可用参数说明</strong>：</p>
<p><code>--plink1</code>: 第一个plink文件前缀，必选。</p>
<p><code>--plink2</code>: 第二个plink文件前缀，可选。</p>
<p><code>--chipid1</code> : 第一个基因型个体映射文件名，芯片和个体号均不能出现重复，可选。如果提供这个文件，那么基因型样本会使用映射文件的个体号。</p>
<p><code>--chipid2</code> : 第二个基因型个体映射文件名，芯片和个体号均不能出现重复，可选。如果提供这个文件，那么基因型样本会使用映射文件的个体号。</p>
<p><code>--cmp-all</code> : 是否需要所有配对两两遍历，可选，只能为yes和no，默认为no。如果该选项设置为yes，则会对两个plink文件中所有样本之间所有可能的组合进行比较，输出所有配对结果；如果设置为no, 则仅针对两个plink文件的共同样本进行基因型比对，输出两个plink文件的同名的样本间的基因型比对结果。</p>
<p><code>--exclude-miss</code> : 基因型比对是否先剔除缺失值，可选，只能为yes和no，默认为yes。如果该选项设置为no，比对时不会剔除缺失位点，如果存在同一个SNP，一个样本有基因型，一个样本为缺失，该SNP同样会被视为不一致位点；如果该选项设置为 yes ，比对时会剔除至少一个样本为缺失的位点，只比对两个样本均不为缺失的位点。</p>
<p><code>--save-temp</code> :  是否保留中间文件，可选，只能为yes和no，默认为 no。</p>
<p><code>--out</code> : 结果文件名称，可选，默认为 cmp_two_plinks.txt</p>
<h1>流程说明</h1>
<p>先对两个ped文件中的芯片号进行重编码，并获取两个ped文件相同的芯片号信息。之后从两个map中提取相同的SNP位点，使用plink软件提取共同位点并合并两个plink文件，得到012编码的raw文件。最后默认对raw文件中两个plink文件中的共同样本进行基因型比对。</p>
<h1>代码说明</h1>
<h2 id="检验参数">检验参数</h2>
<p>检验输入的各个参数是否合规</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#检验参数</span></span><br><span class="line">legal_argument_set = <span class="built_in">set</span>([<span class="string">&quot;yes&quot;</span>, <span class="string">&quot;no&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_number</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">float</span>(s)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">f&quot;<span class="subst">&#123;args.plink1&#125;</span>.ped&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: not exist <span class="subst">&#123;args.plink1&#125;</span>.ped\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">f&quot;<span class="subst">&#123;args.plink1&#125;</span>.map&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: not exist <span class="subst">&#123;args.plink1&#125;</span>.map\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.chipid1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">f&quot;<span class="subst">&#123;args.chipid1&#125;</span>&quot;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: not exist <span class="subst">&#123;args.chipid1&#125;</span>\n\n&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">f&quot;<span class="subst">&#123;args.plink2&#125;</span>.ped&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: not exist <span class="subst">&#123;args.plink2&#125;</span>.ped\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">f&quot;<span class="subst">&#123;args.plink2&#125;</span>.map&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: not exist <span class="subst">&#123;args.plink2&#125;</span>.map\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.chipid2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">f&quot;<span class="subst">&#123;args.chipid2&#125;</span>&quot;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: not exist <span class="subst">&#123;args.chipid2&#125;</span>\n\n&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.cmp_all <span class="keyword">not</span> <span class="keyword">in</span> legal_argument_set:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: illegal input, --cmp-all must be yes or no\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.exclude_miss <span class="keyword">not</span> <span class="keyword">in</span> legal_argument_set:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: illegal input, --exclude-miss must be yes or no\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.save_temp <span class="keyword">not</span> <span class="keyword">in</span> legal_argument_set:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: illegal input, --save-temp must be yes or no\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="复制文件">复制文件</h2>
<p>这里根据原始plink文件重新生成两套新的plink文件，其中芯片号使用数字代替。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开始流程</span></span><br><span class="line"></span><br><span class="line">plink_prefix1 = args.plink1</span><br><span class="line">plink_prefix2 = args.plink2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制 map</span></span><br><span class="line">os.system(<span class="string">f&quot;cp <span class="subst">&#123;plink_prefix1&#125;</span>.map <span class="subst">&#123;plink_prefix1&#125;</span>_temp.map&quot;</span>)</span><br><span class="line">os.system(<span class="string">f&quot;cp <span class="subst">&#123;plink_prefix2&#125;</span>.map <span class="subst">&#123;plink_prefix2&#125;</span>_temp.map&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新生成plink 文件</span></span><br><span class="line">ped1 = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix1&#125;</span>.ped&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">map1 = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix1&#125;</span>.map&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ped2 = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix2&#125;</span>.ped&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">map2 = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix2&#125;</span>.map&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">re_ped1 = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix1&#125;</span>_temp.ped&quot;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">re_ped2 = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix2&#125;</span>_temp.ped&quot;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">rename_chipid_file = <span class="built_in">open</span>(<span class="string">&#x27;rename_chipid_temp.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">common_snp_file = <span class="built_in">open</span>(<span class="string">f&#x27;<span class="subst">&#123;plink_prefix1&#125;</span>_<span class="subst">&#123;plink_prefix2&#125;</span>_common_snp_temp.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="提取共同位点">提取共同位点</h2>
<p>读入两个 map 文件，提取共同的 snp 名称。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">error_status = <span class="literal">False</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#提取共同位点</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">temp_id_set = <span class="built_in">set</span>()</span><br><span class="line">temp_line_set = <span class="built_in">set</span>()</span><br><span class="line">map1_dick = &#123;&#125;  <span class="comment"># SNP名称：染色体_物理位置</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> map1:</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">len</span>(f) == <span class="number">4</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;\t&#x27;</span>.join(f) <span class="keyword">not</span> <span class="keyword">in</span> temp_line_set:</span><br><span class="line">            temp_line_set.add(<span class="string">&#x27;\t&#x27;</span>.join(f))</span><br><span class="line">            <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> temp_id_set:</span><br><span class="line">                temp_id_set.add(f[<span class="number">1</span>])</span><br><span class="line">                map1_dick[f[<span class="number">1</span>]] = f[<span class="number">0</span>]+<span class="string">&quot;_&quot;</span>+f[<span class="number">3</span>] <span class="comment"># SNP名称：“染色体_物理位置”</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated id <span class="subst">&#123;f[<span class="number">1</span>]&#125;</span> in different rows in <span class="subst">&#123;plink_prefix1&#125;</span>.map\n&quot;</span>) </span><br><span class="line">                error_status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicted row <span class="subst">&#123;j&#125;</span> in <span class="subst">&#123;plink_prefix1&#125;</span>.map\n&quot;</span>)</span><br><span class="line">            error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;j&#125;</span> row in <span class="subst">&#123;plink_prefix1&#125;</span>.map has less or more than 4 coloums\n&quot;</span>)</span><br><span class="line">        error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">temp_id_set = <span class="built_in">set</span>()</span><br><span class="line">temp_line_set = <span class="built_in">set</span>()</span><br><span class="line">common_snp_num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> map2:</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">len</span>(f) == <span class="number">4</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;\t&#x27;</span>.join(f) <span class="keyword">not</span> <span class="keyword">in</span> temp_line_set:</span><br><span class="line">            temp_line_set.add(<span class="string">&#x27;\t&#x27;</span>.join(f))</span><br><span class="line">            <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> temp_id_set:</span><br><span class="line">                temp_id_set.add(f[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">in</span> map1_dick:</span><br><span class="line">                    common_snp_num += <span class="number">1</span></span><br><span class="line">                    common_snp_file.write(f[<span class="number">1</span>]+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated id <span class="subst">&#123;f[<span class="number">1</span>]&#125;</span> in different rows in <span class="subst">&#123;plink_prefix2&#125;</span>.map\n&quot;</span>) </span><br><span class="line">                error_status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicted row <span class="subst">&#123;j&#125;</span> in <span class="subst">&#123;plink_prefix2&#125;</span>.map\n&quot;</span>)</span><br><span class="line">            error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;j&#125;</span> row in <span class="subst">&#123;plink_prefix2&#125;</span>.map has less or more than 4 coloums\n&quot;</span>)</span><br><span class="line">        error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nNumber of common SNPs in two plink files: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(common_snp_num))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="ped文件芯片号重编码">ped文件芯片号重编码</h2>
<p>将ped文件中的芯片号改为重编码的数字，如果有映射文件，在此处读取映射文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建一个函数，得到芯片号-个体号的字典(chipid_sampleid_dick 提前创建)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Chipid_Sampleid</span>(<span class="params">chipid_file_name</span>):</span></span><br><span class="line">    chipid_file = <span class="built_in">open</span>(chipid_file_name,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="keyword">global</span> error_status</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    temp_id_set = <span class="built_in">set</span>()</span><br><span class="line">    temp_id_set2 = <span class="built_in">set</span>()</span><br><span class="line">    temp_line_set = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> chipid_file:</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        f = i.split()</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(f) &gt;= <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;\t&#x27;</span>.join(f) <span class="keyword">not</span> <span class="keyword">in</span> temp_line_set:</span><br><span class="line">                temp_line_set.add(<span class="string">&#x27;\t&#x27;</span>.join(f))</span><br><span class="line">                <span class="keyword">if</span> f[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> temp_id_set:</span><br><span class="line">                    temp_id_set.add(f[<span class="number">0</span>])</span><br><span class="line">                    <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> temp_id_set2:</span><br><span class="line">                        temp_id_set2.add(f[<span class="number">1</span>])</span><br><span class="line">                        chipid_sampleid_dick[f[<span class="number">0</span>]] = f[<span class="number">1</span>] <span class="comment">#芯片号：个体号</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated sample id <span class="subst">&#123;f[<span class="number">1</span>]&#125;</span> in different rows in <span class="subst">&#123;chipid_file_name&#125;</span>\n&quot;</span>) </span><br><span class="line">                        error_status = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated chip id <span class="subst">&#123;f[<span class="number">0</span>]&#125;</span> in different rows in <span class="subst">&#123;chipid_file_name&#125;</span>\n&quot;</span>) </span><br><span class="line">                    error_status = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Warinning: duplicted row <span class="subst">&#123;j&#125;</span> in <span class="subst">&#123;chipid_file_name&#125;</span>\n&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;j&#125;</span> row in <span class="subst">&#123;chipid_file_name&#125;</span> has less than 2 coloums\n&quot;</span>)</span><br><span class="line">            error_status = <span class="literal">True</span></span><br><span class="line">    chipid_file.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">#重命名</span></span><br><span class="line">newid_dick = &#123;&#125; <span class="comment">#chipid/sampleid:newid</span></span><br><span class="line">sampleid_dick = &#123;&#125; <span class="comment">#newid:chipid/sampleid</span></span><br><span class="line"></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ped重编码为数字(1-indexed)，家系号设定为0。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看是否存在chipid1</span></span><br><span class="line"><span class="keyword">if</span> args.chipid1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    chipid_sampleid_dick = &#123;&#125;</span><br><span class="line">    Chipid_Sampleid(args.chipid1) <span class="comment">#运行函数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ped1:</span><br><span class="line">        f = i.split()</span><br><span class="line">        <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">in</span> chipid_sampleid_dick:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            newid_dick[chipid_sampleid_dick[f[<span class="number">1</span>]]] = j</span><br><span class="line">            sampleid_dick[j] = chipid_sampleid_dick[f[<span class="number">1</span>]]</span><br><span class="line">            rename_chipid_file.write(<span class="string">f&quot;<span class="subst">&#123;chipid_sampleid_dick[f[<span class="number">1</span>]]&#125;</span>\t<span class="subst">&#123;j&#125;</span>\n&quot;</span>)</span><br><span class="line">            f[<span class="number">1</span>] = <span class="built_in">str</span>(j)</span><br><span class="line">            re_ped1.write(<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>.join(f[<span class="number">1</span>:])+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Warning: <span class="subst">&#123;f[<span class="number">1</span>]&#125;</span> in <span class="subst">&#123;args.plink1&#125;</span>.ped not in chpid file&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ped1:</span><br><span class="line">        f = i.split()</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        newid_dick[f[<span class="number">1</span>]] = j</span><br><span class="line">        sampleid_dick[j] = f[<span class="number">1</span>]</span><br><span class="line">        rename_chipid_file.write(<span class="string">f&quot;<span class="subst">&#123;f[<span class="number">1</span>]&#125;</span>\t<span class="subst">&#123;j&#125;</span>\n&quot;</span>)            </span><br><span class="line">        f[<span class="number">1</span>] = <span class="built_in">str</span>(j)</span><br><span class="line">        re_ped1.write(<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>.join(f[<span class="number">1</span>:])+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">sample1_num = j</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of records present in plink1 ped file: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(sample1_num))</span><br><span class="line"></span><br><span class="line">common_sample_list = []</span><br><span class="line">common_sample_num = <span class="number">0</span></span><br><span class="line"><span class="comment">#查看是否存在chipid2</span></span><br><span class="line"><span class="keyword">if</span> args.chipid2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    chipid_sampleid_dick = &#123;&#125;</span><br><span class="line">    Chipid_Sampleid(args.chipid2) <span class="comment">#运行函数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ped2:</span><br><span class="line">        f = i.split()</span><br><span class="line">        <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">in</span> chipid_sampleid_dick:</span><br><span class="line">            j += <span class="number">1</span> <span class="comment">#接着上面递增</span></span><br><span class="line">            sampleid_dick[j] = chipid_sampleid_dick[f[<span class="number">1</span>]]</span><br><span class="line">            <span class="keyword">if</span> chipid_sampleid_dick[f[<span class="number">1</span>]] <span class="keyword">in</span> newid_dick: <span class="comment">#提取相同样本</span></span><br><span class="line">                common_sample_num += <span class="number">1</span></span><br><span class="line">                common_sample_list.append([newid_dick[chipid_sampleid_dick[f[<span class="number">1</span>]]],j]) <span class="comment">#两个重编号  </span></span><br><span class="line">            rename_chipid_file.write(<span class="string">f&quot;<span class="subst">&#123;chipid_sampleid_dick[f[<span class="number">1</span>]]&#125;</span>\t<span class="subst">&#123;j&#125;</span>\n&quot;</span>)</span><br><span class="line">            f[<span class="number">1</span>] = <span class="built_in">str</span>(j)</span><br><span class="line">            re_ped2.write(<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>.join(f[<span class="number">1</span>:])+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Warning: <span class="subst">&#123;f[<span class="number">1</span>]&#125;</span> in <span class="subst">&#123;args.plink2&#125;</span>.ped not in chpid file&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ped2:</span><br><span class="line">        f = i.split()</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        sampleid_dick[j] = f[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">in</span> newid_dick:</span><br><span class="line">                common_sample_num += <span class="number">1</span></span><br><span class="line">                common_sample_list.append([newid_dick[f[<span class="number">1</span>]],j]) <span class="comment">#两个重编号  </span></span><br><span class="line">        rename_chipid_file.write(<span class="string">f&quot;<span class="subst">&#123;f[<span class="number">1</span>]&#125;</span>\t<span class="subst">&#123;j&#125;</span>\n&quot;</span>)            </span><br><span class="line">        f[<span class="number">1</span>] = <span class="built_in">str</span>(j)</span><br><span class="line">        re_ped2.write(<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>.join(f[<span class="number">1</span>:])+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">sample2_num = j - sample1_num</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of records present in plink2 ped file: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(sample2_num))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of common samples in two plink file: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(common_sample_num))</span><br><span class="line">    </span><br><span class="line">ped1.close()</span><br><span class="line">map1.close()</span><br><span class="line">ped2.close()</span><br><span class="line">map2.close()</span><br><span class="line">re_ped1.close()</span><br><span class="line">re_ped2.close()</span><br><span class="line">rename_chipid_file.close()</span><br><span class="line">common_snp_file.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果上面出现错误，报错，中止程序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果输入文件出现错误</span></span><br><span class="line"><span class="keyword">if</span> error_status:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Please check your file again!&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="提取共同位点，合并基因型">提取共同位点，合并基因型</h2>
<p>提取两个plink文件的共同位点，合并基因型，生成 012 编码的 raw 文件。如果合并的过程中出现报错，程序中止，一般这种报错都是由于非二等位基因造成的，即两个plink文件中某个位点的两个碱基不一样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#extract merge recodeA</span></span><br><span class="line"></span><br><span class="line">merge_status = os.system(<span class="string">f&quot;plink --allow-extra-chr --chr-set 95 --file <span class="subst">&#123;plink_prefix1&#125;</span>_temp --merge <span class="subst">&#123;plink_prefix2&#125;</span>_temp --extract <span class="subst">&#123;plink_prefix1&#125;</span>_<span class="subst">&#123;plink_prefix2&#125;</span>_common_snp_temp.txt --recodeA --out <span class="subst">&#123;plink_prefix1&#125;</span>_<span class="subst">&#123;plink_prefix2&#125;</span>_merge_temp &gt; /dev/null&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> merge_status != <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error in merge two plink data\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Maybe some common SNP from Complementary strands,check your data again&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将缺失位点替换为3，将合并基因型读取为二维数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#raw文件处理</span></span><br><span class="line">os.system(<span class="string">f&quot;sed &#x27;s/NA/3/g&#x27; <span class="subst">&#123;plink_prefix1&#125;</span>_<span class="subst">&#123;plink_prefix2&#125;</span>_merge_temp.raw &gt; <span class="subst">&#123;plink_prefix1&#125;</span>_<span class="subst">&#123;plink_prefix2&#125;</span>_merge_temp_sed.raw&quot;</span>)</span><br><span class="line">raw_file = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix1&#125;</span>_<span class="subst">&#123;plink_prefix2&#125;</span>_merge_temp_sed.raw&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">out_file = <span class="built_in">open</span>(args.out,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gene_list=[]</span><br><span class="line">raw_list=[]</span><br><span class="line">title = raw_file.readline() <span class="comment">#剔除标题</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> raw_file:</span><br><span class="line">    f = i.split()</span><br><span class="line">    gene_list.append(<span class="built_in">int</span>(f[<span class="number">1</span>]))</span><br><span class="line">    raw_list.append(f[<span class="number">6</span>:])</span><br><span class="line"></span><br><span class="line">gene_id_array1 = np.array(gene_list)</span><br><span class="line"></span><br><span class="line">array1 = np.array(raw_list, dtype=np.int8)</span><br><span class="line"></span><br><span class="line">total_sample_num = array1.shape[<span class="number">0</span>]</span><br><span class="line">snp_num = array1.shape[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of records present in merged ped file: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(total_sample_num))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of SNPs in merged plink files: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(snp_num))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="比对两个样本的基因型">比对两个样本的基因型</h2>
<p>创建了两个比对函数（是否剔除缺失值）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建比对函数（是否剔除缺失值）</span></span><br><span class="line"><span class="comment">#这个函数定死了使用 array1 first_index second index</span></span><br><span class="line"><span class="comment">#创建两个函数，这样只要判断一次，而不要每个pair都要判断是否剔除缺失值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Exclude_Miss_Yes</span>():</span></span><br><span class="line">    <span class="comment">#输出变量设置为全局变量</span></span><br><span class="line">    <span class="keyword">global</span> total_num,no_match_num,no_match_rate</span><br><span class="line">    v1 = array1[first_index,:]</span><br><span class="line">    v2 = array1[second_index,:]</span><br><span class="line">    non_miss_index = np.where((v1!=<span class="number">3</span>) &amp; (v2!=<span class="number">3</span>))</span><br><span class="line">    total_num = non_miss_index[<span class="number">0</span>].shape[<span class="number">0</span>]</span><br><span class="line">    v1_new = v1[non_miss_index]</span><br><span class="line">    v2_new = v2[non_miss_index]</span><br><span class="line">    no_match_num = np.count_nonzero(v1_new!=v2_new)</span><br><span class="line">    no_match_rate = no_match_num/total_num</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Exclude_Miss_No</span>():</span></span><br><span class="line">    <span class="comment">#输出变量设置为全局变量</span></span><br><span class="line">    <span class="keyword">global</span> total_num,no_match_num,no_match_rate</span><br><span class="line">    v1 = array1[first_index,:]</span><br><span class="line">    v2 = array1[second_index,:]</span><br><span class="line">    total_num = v1.shape[<span class="number">0</span>]</span><br><span class="line">    no_match_num = np.count_nonzero(v1!=v2)</span><br><span class="line">    no_match_rate = no_match_num/total_num</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>计算两个样本的不一致，分两种情况，比较所有配对和只比较同名样本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#计算不一致率</span></span><br><span class="line">out_list = []</span><br><span class="line"><span class="keyword">if</span> args.cmp_all == <span class="string">&#x27;yes&#x27;</span>: <span class="comment">#计算所有pairs</span></span><br><span class="line">    <span class="keyword">if</span> args.exclude_miss == <span class="string">&#x27;yes&#x27;</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(sample1_num):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(sample1_num, total_sample_num):</span><br><span class="line">                first_index = i</span><br><span class="line">                second_index = j</span><br><span class="line">                <span class="comment">#计算去除缺失后的不一致位点数</span></span><br><span class="line">                Exclude_Miss_Yes()</span><br><span class="line">                <span class="comment">#newid = index + 1</span></span><br><span class="line">                out_list.append([sampleid_dick[first_index+<span class="number">1</span>],sampleid_dick[second_index+<span class="number">1</span>],<span class="string">f&quot;<span class="subst">&#123;no_match_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;total_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;no_match_rate:<span class="number">.4</span>f&#125;</span>&quot;</span>])</span><br><span class="line">    <span class="keyword">elif</span> args.exclude_miss == <span class="string">&#x27;no&#x27;</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(sample1_num):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(sample1_num, total_sample_num):</span><br><span class="line">                first_index = i</span><br><span class="line">                second_index = j</span><br><span class="line">                <span class="comment">#计算去除缺失后的不一致位点数</span></span><br><span class="line">                Exclude_Miss_No()</span><br><span class="line">                <span class="comment">#newid = index + 1</span></span><br><span class="line">                out_list.append([sampleid_dick[first_index+<span class="number">1</span>],sampleid_dick[second_index+<span class="number">1</span>],<span class="string">f&quot;<span class="subst">&#123;no_match_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;total_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;no_match_rate:<span class="number">.4</span>f&#125;</span>&quot;</span>])                             </span><br><span class="line"><span class="keyword">elif</span> args.cmp_all == <span class="string">&#x27;no&#x27;</span>: <span class="comment">#只计算个体号相同的pairs</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(common_sample_list) == <span class="number">0</span>: <span class="comment">#如果没有共同个体，报错</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error: two ped file has no same samples, check your data again!&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> args.exclude_miss == <span class="string">&#x27;yes&#x27;</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> common_sample_list:</span><br><span class="line">                <span class="comment">#index = newid - 1</span></span><br><span class="line">                first_index = i[<span class="number">0</span>] - <span class="number">1</span></span><br><span class="line">                second_index = i[<span class="number">1</span>] -<span class="number">1</span> </span><br><span class="line">                <span class="comment">#计算去除缺失后的不一致位点数</span></span><br><span class="line">                Exclude_Miss_Yes()</span><br><span class="line">                out_list.append([sampleid_dick[i[<span class="number">0</span>]],sampleid_dick[i[<span class="number">1</span>]],<span class="string">f&quot;<span class="subst">&#123;no_match_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;total_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;no_match_rate:<span class="number">.4</span>f&#125;</span>&quot;</span>])</span><br><span class="line">        <span class="keyword">elif</span> args.exclude_miss == <span class="string">&#x27;no&#x27;</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> common_sample_list:</span><br><span class="line">                <span class="comment">#index = newid - 1</span></span><br><span class="line">                first_index = i[<span class="number">0</span>] - <span class="number">1</span></span><br><span class="line">                second_index = i[<span class="number">1</span>] -<span class="number">1</span> </span><br><span class="line">                <span class="comment">#计算去除缺失后的不一致位点数</span></span><br><span class="line">                Exclude_Miss_No()</span><br><span class="line">                out_list.append([sampleid_dick[i[<span class="number">0</span>]],sampleid_dick[i[<span class="number">1</span>]],<span class="string">f&quot;<span class="subst">&#123;no_match_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;total_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;no_match_rate:<span class="number">.4</span>f&#125;</span>&quot;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sorted_out_list = <span class="built_in">sorted</span>(out_list, key = <span class="keyword">lambda</span> s:(<span class="built_in">float</span>(s[<span class="number">4</span>]),s[<span class="number">0</span>])) <span class="comment">#不一致率从小到大</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sorted_out_list:</span><br><span class="line">    out_file.write(<span class="string">&#x27;\t&#x27;</span>.join(i)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">raw_file.close()</span><br><span class="line">out_file.close()</span><br></pre></td></tr></table></figure>
<h2 id="删除中间文件">删除中间文件</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> args.save_temp == <span class="string">&quot;yes&quot;</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">elif</span> args.save_temp == <span class="string">&quot;no&quot;</span>:</span><br><span class="line">    os.system(<span class="string">f&quot;rm *temp*&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>生物信息</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy和Pandas模块学习</title>
    <url>/posts/428cb22d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这里将我所有之前学习整理的 Numpy 和 Pandas 模块的所有资料合并到了一起。</p>
<p>最主要的资料是《利用Python进行数据分析》</p>
<span id="more"></span>
<h1>IPython</h1>
<p>IPython 是一个强化的 python 解释器；而 Jupyter notebooks 是一个网页代码笔记本，它原本是 IPython 的一个子项目。</p>
<p>通过 ipython 进入，默认采用序号的格式 <code>In [1]:</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ ipython</span><br><span class="line">Python <span class="number">3.7</span><span class="number">.6</span> (default, Jan  <span class="number">8</span> <span class="number">2020</span>, <span class="number">19</span>:<span class="number">59</span>:<span class="number">22</span>)</span><br><span class="line"><span class="type">Type</span> <span class="string">&#x27;copyright&#x27;</span>, <span class="string">&#x27;credits&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;license&#x27;</span> <span class="keyword">for</span> more information</span><br><span class="line">IPython <span class="number">7.12</span><span class="number">.0</span> -- An enhanced Interactive Python. <span class="type">Type</span> <span class="string">&#x27;?&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>.</span><br><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: exit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ipython 的优点在于<strong>打印结果形式更加易读</strong>，或称为 <code>pretty-printed</code> 。</p>
<p>另外一个优点在于 <strong>Tab 补全</strong>（按一次Tab后，接着按Tab选词），这也可以用于函数的形式参数。</p>
<h2 id="">?</h2>
<p>变量的后面加 <code>?</code>，可以显示对象信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">4</span>]: b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [5]: b?</span><br><span class="line"><span class="type">Type</span>:        <span class="built_in">list</span></span><br><span class="line">String form: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">Length:      <span class="number">3</span></span><br><span class="line">Docstring:</span><br><span class="line">Built-<span class="keyword">in</span> mutable sequence.</span><br><span class="line"></span><br><span class="line">If no argument <span class="keyword">is</span> given, the constructor creates a new empty <span class="built_in">list</span>.</span><br><span class="line">The argument must be an iterable <span class="keyword">if</span> specified.</span><br><span class="line"></span><br><span class="line">In [6]: print?</span><br><span class="line">Docstring:</span><br><span class="line"><span class="built_in">print</span>(value, ..., sep=<span class="string">&#x27; &#x27;</span>, end=<span class="string">&#x27;\n&#x27;</span>, file=sys.stdout, flush=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">Prints the values to a stream, <span class="keyword">or</span> to sys.stdout by default.</span><br><span class="line"><span class="type">Optional</span> keyword arguments:</span><br><span class="line">file:  a file-like <span class="built_in">object</span> (stream); defaults to the current sys.stdout.</span><br><span class="line">sep:   string inserted between values, default a space.</span><br><span class="line">end:   string appended after the last value, default a newline.</span><br><span class="line">flush: whether to forcibly flush the stream.</span><br><span class="line"><span class="type">Type</span>:      builtin_function_or_method</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果对象是一个函数也可以显示信息。假设我们写了一个这样的函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">8</span>]: <span class="function"><span class="keyword">def</span> <span class="title">add_numbers</span>(<span class="params">a, b</span>):</span></span><br><span class="line">   ...:     <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   ...:     Add two numbers together</span></span><br><span class="line"><span class="string">   ...:     Returns</span></span><br><span class="line"><span class="string">   ...:     -------</span></span><br><span class="line"><span class="string">   ...:     the_sum : type of arguments</span></span><br><span class="line"><span class="string">   ...:     &quot;&quot;&quot;</span></span><br><span class="line">   ...:     <span class="keyword">return</span> a + b</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [9]: add_numbers?</span><br><span class="line">Signature: add_numbers(a, b)</span><br><span class="line">Docstring:</span><br><span class="line">Add two numbers together</span><br><span class="line">Returns</span><br><span class="line">-------</span><br><span class="line">the_sum : <span class="built_in">type</span> of arguments</span><br><span class="line">File:      /mnt/data/zhouziwen/test/test/zhouziwen/&lt;ipython-<span class="built_in">input</span>-<span class="number">8</span>-df2a0125a605&gt;</span><br><span class="line"><span class="type">Type</span>:      function</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用 <code>??</code> 可以显示源码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [10]: add_numbers??</span><br><span class="line">Signature: add_numbers(a, b)</span><br><span class="line">Source:</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_numbers</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Add two numbers together</span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    the_sum : type of arguments</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">File:      /mnt/data/zhouziwen/test/test/zhouziwen/&lt;ipython-<span class="built_in">input</span>-<span class="number">8</span>-df2a0125a605&gt;</span><br><span class="line"><span class="type">Type</span>:      function</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>?</code> 还可以与通配符结合，查看可能的命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">11</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">In [12]: np.*load*?</span><br><span class="line">np.__loader__</span><br><span class="line">np.load</span><br><span class="line">np.loads</span><br><span class="line">np.loadtxt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="run">%run</h2>
<p>你可以用<code>%run</code>命令运行所有的Python程序。假设有一个文件 ipython_script_test.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x, y, z</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (x + y) / z</span><br><span class="line"></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line">b = <span class="number">6</span></span><br><span class="line">c = <span class="number">7.5</span></span><br><span class="line"></span><br><span class="line">result = f(a, b, c)</span><br></pre></td></tr></table></figure>
<p>可以直接在 ipython 运行（这和你在命令行中直接运行一样）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: %run ipython_script_test.py</span><br></pre></td></tr></table></figure>
<p>但是文件中所有定义的变量（import、函数和全局变量，除非抛出异常），都可以在IPython shell中随后访问：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">2</span>]: c</span><br><span class="line">Out[<span class="number">2</span>]: <span class="number">7.5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: result</span><br><span class="line">Out[<span class="number">3</span>]: <span class="number">1.4666666666666666</span></span><br></pre></td></tr></table></figure>
<p>如果脚本文件后面有参数， <code>%run</code>命令后面可以直接接参数，就像正常运行一样。</p>
<h2 id="快捷键">快捷键</h2>
<p><img src="1.png" alt="1"></p>
<h2 id="IPython-运行-linux-命令">IPython 运行 linux 命令</h2>
<p>直接在 linux 命令前面加 <code>!</code> 即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">14</span>]: !pwd</span><br><span class="line">/mnt/data/zhouziwen/GS/isolate/jxzb/YY/<span class="number">2021</span>-07-<span class="number">26</span>/dat2/y1_y2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="time-和-timeit">%time 和 %timeit</h2>
<p>一般来说，我们统计程序运行时间，可能会通过 time 模块的 <code>time.time()</code> 函数手动编写代码统计，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iterations):</span><br><span class="line">    <span class="comment"># some code to run here</span></span><br><span class="line">elapsed_per = (time.time() - start) / iterations</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>%time 会运行一次语句，报告总共的执行时间。假设我们有一个大的字符串列表，我们想比较不同的可以挑选出特定开头字符串的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: strings = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foobar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="string">&#x27;qux&#x27;</span>, <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;Guido Van Rossum&#x27;</span>] * <span class="number">100000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: %time method1 = [x <span class="keyword">for</span> x <span class="keyword">in</span> strings <span class="keyword">if</span> x.startswith(<span class="string">&#x27;foo&#x27;</span>)]</span><br><span class="line">CPU times: user <span class="number">74.8</span> ms, sys: <span class="number">3.43</span> ms, total: <span class="number">78.2</span> ms</span><br><span class="line">Wall time: <span class="number">76.4</span> ms</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: %time method1 = [x <span class="keyword">for</span> x <span class="keyword">in</span> strings <span class="keyword">if</span> x[<span class="number">0</span>:<span class="number">3</span>] == <span class="string">&#x27;foo&#x27;</span>]</span><br><span class="line">CPU times: user <span class="number">58.6</span> ms, sys: <span class="number">931</span> µs, total: <span class="number">59.5</span> ms</span><br><span class="line">Wall time: <span class="number">58.6</span> ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里我们主要关注 Wall time (wall-clock time 的简写)。但是这种单次测量的方法并不准确。如果使用 %time 多次测量，你就会发现结果是变化的。</p>
<p>如果想要更准确的比较，可以使用 <code>%timit</code> 方法，它能多次运行单条语句以得到一个更为准确的时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">20</span>]: %timeit method1 = [x <span class="keyword">for</span> x <span class="keyword">in</span> strings <span class="keyword">if</span> x.startswith(<span class="string">&#x27;foo&#x27;</span>)]</span><br><span class="line"><span class="number">54.5</span> ms ± <span class="number">2.02</span> ms per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">10</span> loops each)</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: %timeit method1 = [x <span class="keyword">for</span> x <span class="keyword">in</span> strings <span class="keyword">if</span> x[<span class="number">0</span>:<span class="number">3</span>] == <span class="string">&#x27;foo&#x27;</span>]</span><br><span class="line"><span class="number">48.2</span> ms ± <span class="number">1.52</span> ms per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">10</span> loops each)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，这两个命令只能计算<strong>单条命令</strong>的时间，多条命令应该需要用函数啥的先黏在一块才行。</p>
<h1>Numpy 基础</h1>
<blockquote>
<p>NumPy之于数值计算特别重要的原因之一，是因为它可以高效处理大数组的数据。这是因为：</p>
<ul>
<li>
<p>NumPy是在一个连续的内存块中存储数据，独立于其他Python内置对象。NumPy的C语言编写的算法库可以操作内存，而不必进行类型检查或其它前期工作。比起Python的内置序列，NumPy数组使用的内存更少。</p>
</li>
<li>
<p>NumPy可以在整个数组上执行复杂的计算，而不需要Python的for循环</p>
</li>
</ul>
</blockquote>
<p>举个简单的例子，查看一个包含一百万整数的数组和一个等价的 Python 列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">83</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: my_arr = np.arange(<span class="number">1000000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">85</span>]: my_list = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1000000</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: %time <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>): my_arr2 = my_arr * <span class="number">2</span></span><br><span class="line">CPU times: user <span class="number">16.6</span> ms, sys: <span class="number">10.1</span> ms, total: <span class="number">26.7</span> ms</span><br><span class="line">Wall time: <span class="number">25.1</span> ms</span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: %time <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>): my_list2 = [x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> my_list]</span><br><span class="line">CPU times: user <span class="number">480</span> ms, sys: <span class="number">236</span> ms, total: <span class="number">716</span> ms</span><br><span class="line">Wall time: <span class="number">714</span> ms</span><br></pre></td></tr></table></figure>
<p>wall time 和 CPU time 的解释如下：</p>
<blockquote>
<p>最常见的就是计算使用的时间，也就是wall-clock time或者wall time。这个很好理解，它就是我们从计算开始到计算结束等待的时间。除此之外，CPU time也是一个常见的时间数据。CPU time衡量的是CPU用来执行程序的时间。当软件使用一个线程时，由于需要等待IO完成或者用户输入等原因，CPU并不总是100%被使用，这导致CPU time一般比wall time小。当我们使用多线程的时候，程序的CPU time是各个线程的CPU time之和。</p>
</blockquote>
<p>这里我们可以看到基于 Numpy 的算法要比纯 Python 快 10到100倍，并且使用的内存更少。</p>
<p>numpy 创建的数组的所有数据必须是<strong>同一数据类型</strong>。</p>
<h2 id="数据类型">数据类型</h2>
<p>创建数组的过程中可以指定数据类型，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">42</span>]: a = np.arange(<span class="number">10</span>, dtype=np.int8)</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: a</span><br><span class="line">Out[<span class="number">43</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], dtype=int8)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="37.png" alt="1"></p>
<h2 id="axis-中-0轴-和-1轴-的定义"><code>axis</code> 中 0轴 和 1轴 的定义</h2>
<p>网上找了一堆资料，都说不清楚。我感觉下面这个说的相对比较清楚了。</p>
<p><a href="https://www.cnblogs.com/rrttp/p/8028421.html">https://www.cnblogs.com/rrttp/p/8028421.html</a></p>
<p>也许简单的来记就是axis=0代表往<strong>跨行（down)</strong>，而axis=1代表<strong>跨列（across)</strong>，作为方法动作的副词（译者注）</p>
<p>换句话说:</p>
<ul>
<li>使用0值表示沿着每一列或行标签\索引值向下执行方法</li>
<li>使用1值表示沿着每一行或者列标签模向执行对应的方法</li>
</ul>
<p>下图代表在DataFrame当中axis为0和1时分别代表的含义:</p>
<p><img src="5.png" alt="1"></p>
<p>个人理解：如果指定 <code>axis=0</code> 那么就是沿着纵轴/列的方向进行，比如求和，那么就会得到每一列的和；但是在 <code>np.take</code> 中，指定 <code>axis = 0</code> 那么就是提取特定的行。</p>
<h2 id="数组基本运算">数组基本运算</h2>
<p>类似于R</p>
<p>注意，这里的 <code>a*b</code> 不是矩阵乘积，还是元素运算（我正好需要这个功能）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array( [<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>] )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.arange( <span class="number">4</span> )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = a-b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">array([<span class="number">20</span>, <span class="number">29</span>, <span class="number">38</span>, <span class="number">47</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b**<span class="number">2</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a&lt;<span class="number">35</span></span><br><span class="line">array([ <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a*b</span><br><span class="line">array([  <span class="number">0</span>,  <span class="number">30</span>,  <span class="number">80</span>, <span class="number">150</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>矩阵运算的乘积，可以使用 @ 符号（python &gt;=3.5） 或 dot 函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = np.array( [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B = np.array( [[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A*B</span><br><span class="line">array([[<span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A@B</span><br><span class="line">array([[<span class="number">5</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.dot(B)</span><br><span class="line">array([[<span class="number">5</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>]])</span><br></pre></td></tr></table></figure>
<p>类似的操作还有 <code>+=</code> ，<code>*=</code> ， 这两个操作符是就地修改，而不是创建新的。</p>
<p>注意：</p>
<ol>
<li><code>+=</code> ，<code>*=</code> 中间不能有空格</li>
<li>如果操作的两个数组的数据类型不一样，结果会自动变成更一般化的数据类型（整数和浮点型数据放在一起，结果就是浮点型）。如果数据类型有设定，可能会报错。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.ones((<span class="number">2</span>,<span class="number">3</span>), dtype=<span class="built_in">int</span>) <span class="comment">#只写 int 实际是int64</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a * = <span class="number">3</span></span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">    a * = <span class="number">3</span></span><br><span class="line">        ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a *= <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a += <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.random.random((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a+=b</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">numpy.core._exceptions.UFuncTypeError: Cannot cast ufunc <span class="string">&#x27;add&#x27;</span> output <span class="keyword">from</span> dtype(<span class="string">&#x27;float64&#x27;</span>) to dtype(<span class="string">&#x27;int64&#x27;</span>) <span class="keyword">with</span> casting rule <span class="string">&#x27;same_kind&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>求和，最大值，最小值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.<span class="built_in">sum</span>()</span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.<span class="built_in">max</span>()</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.<span class="built_in">min</span>()</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>对于二维矩阵，按行或列求最大值，最小值，求和</p>
<p>注意，这里 axis = 1，才是对每<strong>行</strong>操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.<span class="built_in">sum</span>(axis=<span class="number">0</span>) <span class="comment">#axis=0，对列</span></span><br><span class="line">array([<span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">21</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.<span class="built_in">min</span>(axis=<span class="number">1</span>) <span class="comment">#axis=1,对行</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.cumsum(axis=<span class="number">1</span>)</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">3</span>,  <span class="number">6</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">9</span>, <span class="number">15</span>, <span class="number">22</span>],</span><br><span class="line">       [ <span class="number">8</span>, <span class="number">17</span>, <span class="number">27</span>, <span class="number">38</span>]])</span><br></pre></td></tr></table></figure>
<p>通用函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.arange(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.exp(b)</span><br><span class="line">array([<span class="number">1.</span>        , <span class="number">2.71828183</span>, <span class="number">7.3890561</span> ])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.sqrt(b)</span><br><span class="line">array([<span class="number">0.</span>        , <span class="number">1.</span>        , <span class="number">1.41421356</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=np.array([<span class="number">2.</span>,-<span class="number">1.</span>,<span class="number">4.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.add(b,c)</span><br><span class="line">array([<span class="number">2.</span>, <span class="number">0.</span>, <span class="number">6.</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="二维数组的切片">二维数组的切片</h2>
<h3 id="切片索引">切片索引</h3>
<p>二维数组中，各索引位置上的元素不再是标量而是一维数组。</p>
<p>先创建一个二维数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">2</span>]: arr2d = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: arr2d</span><br><span class="line">Out[<span class="number">3</span>]:</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">       [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br></pre></td></tr></table></figure>
<p>如果只提供一个数字，则是提取<strong>行</strong>。下例为提取第3行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">4</span>]: arr2d[<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">4</span>]: array([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure>
<p>也可以提取单个元素，下面这两种方式效果一致。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">5</span>]: arr2d[<span class="number">0</span>][<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">5</span>]: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: arr2d[<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">6</span>]: <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以用 <code>:</code> 提取来连续的行或列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">9</span>]: arr2d[:<span class="number">2</span>] <span class="comment"># 提取前两行</span></span><br><span class="line">Out[<span class="number">9</span>]:</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: arr2d[:<span class="number">2</span>, <span class="number">1</span>:] <span class="comment"># 提取前两行，不要第一列</span></span><br><span class="line">Out[<span class="number">10</span>]:</span><br><span class="line">array([[<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure>
<p>只有 <code>:</code> ，说明提取整个轴</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">11</span>]: arr2d[:, <span class="number">1</span>:] <span class="comment"># 提取所有行，不要第一列</span></span><br><span class="line">Out[<span class="number">11</span>]:</span><br><span class="line">array([[<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">       [<span class="number">8</span>, <span class="number">9</span>]])</span><br></pre></td></tr></table></figure>
<p>下图说明了二维数组的索引方式。轴0 作为行，轴1 作为列。</p>
<p><img src="2.png" alt="1"></p>
<h3 id="布尔型索引">布尔型索引</h3>
<p>这里我嫌弃文中的例子罗嗦，用了自己的。</p>
<p>布尔型索引可以根据某个条件快速定位，替换。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: arr2d &gt; <span class="number">4</span></span><br><span class="line">Out[<span class="number">12</span>]:</span><br><span class="line">array([[<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">       [<span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>],</span><br><span class="line">       [ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: arr2d[arr2d &gt; <span class="number">4</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: arr2d</span><br><span class="line">Out[<span class="number">14</span>]:</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="操作符用来取反"><code>~</code> 操作符用来取反</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">15</span>]: arr2d = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: ~(arr2d &gt; <span class="number">4</span>)</span><br><span class="line">Out[<span class="number">16</span>]:</span><br><span class="line">array([[ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>],</span><br><span class="line">       [ <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">       [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="和-、-或"><code>&amp;</code> (和) 、<code>|</code> (或)</h4>
<p>这里不能用 <code>and</code> 和 <code>or</code> ，必须得用 <code>&amp;</code> (和) 、<code>|</code> (或)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: (arr2d &gt;<span class="number">4</span>) &amp; (arr2d &lt; <span class="number">7</span>)</span><br><span class="line">Out[<span class="number">17</span>]:</span><br><span class="line">array([[<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">       [<span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>],</span><br><span class="line">       [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: (arr2d &lt;=<span class="number">4</span>) | (arr2d &gt;= <span class="number">7</span>)</span><br><span class="line">Out[<span class="number">18</span>]:</span><br><span class="line">array([[ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>],</span><br><span class="line">       [ <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">       [ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="花式索引">花式索引</h3>
<p>花式索引（Fancy indexing）是一个NumPy 术语，它指的是<strong>利用整数数组</strong>进行索引。</p>
<p><strong>花式索引跟切片不一样，它总是将数据复制到新数组中。</strong></p>
<p>假设我们有一个 8×4 数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">21</span>]: arr = np.empty((<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    ...:     arr[i] = i</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: arr</span><br><span class="line">Out[<span class="number">23</span>]:</span><br><span class="line">array([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>],</span><br><span class="line">       [<span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>],</span><br><span class="line">       [<span class="number">4.</span>, <span class="number">4.</span>, <span class="number">4.</span>, <span class="number">4.</span>],</span><br><span class="line">       [<span class="number">5.</span>, <span class="number">5.</span>, <span class="number">5.</span>, <span class="number">5.</span>],</span><br><span class="line">       [<span class="number">6.</span>, <span class="number">6.</span>, <span class="number">6.</span>, <span class="number">6.</span>],</span><br><span class="line">       [<span class="number">7.</span>, <span class="number">7.</span>, <span class="number">7.</span>, <span class="number">7.</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们通过传入<strong>行序号组成的列表/数组</strong>，可以提取相应的行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">24</span>]: arr[[<span class="number">4</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">6</span>]]</span><br><span class="line">Out[<span class="number">24</span>]:</span><br><span class="line">array([[<span class="number">4.</span>, <span class="number">4.</span>, <span class="number">4.</span>, <span class="number">4.</span>],</span><br><span class="line">       [<span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">6.</span>, <span class="number">6.</span>, <span class="number">6.</span>, <span class="number">6.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: arr[[-<span class="number">2</span>,-<span class="number">1</span>]] <span class="comment"># 使用负索引</span></span><br><span class="line">Out[<span class="number">25</span>]:</span><br><span class="line">array([[<span class="number">6.</span>, <span class="number">6.</span>, <span class="number">6.</span>, <span class="number">6.</span>],</span><br><span class="line">       [<span class="number">7.</span>, <span class="number">7.</span>, <span class="number">7.</span>, <span class="number">7.</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果一次传入<strong>两个</strong>列表，那么会返回一个一维数组。</p>
<p>下例中，最终选出的是元素(1,0)、(5,3)、(7,1) 和 (2,2) 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">26</span>]: arr[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">Out[<span class="number">26</span>]: array([<span class="number">1.</span>, <span class="number">5.</span>, <span class="number">7.</span>, <span class="number">2.</span>])</span><br></pre></td></tr></table></figure>
<h4 id="np-take">np.take</h4>
<p>花式索引的等价函数，好处在于可以指定<strong>行/列</strong>。</p>
<p>对于二维数组，如果不指定 <code>axis</code> ，那么 <code>np.take</code> 应该就是把二维数组当一维数组去对待取数，最终返回一个一维数组。比如下面的例子，<code>arr</code> 是一个二维数组，如果进行扁平化或者从内存位置的角度，由于 numpy 默认是<strong>行优先顺序</strong>，因此是 <code>[ 0.08966036, -1.89793365, -0.88573795, -0.99033984, ……]</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">127</span>]: arr = np.random.randn(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">128</span>]: arr</span><br><span class="line">Out[<span class="number">128</span>]:</span><br><span class="line">array([[ <span class="number">0.08966036</span>, -<span class="number">1.89793365</span>, -<span class="number">0.88573795</span>, -<span class="number">0.99033984</span>],</span><br><span class="line">       [ <span class="number">0.50694474</span>,  <span class="number">0.58910697</span>,  <span class="number">1.81629683</span>,  <span class="number">1.41723295</span>],</span><br><span class="line">       [-<span class="number">0.53507013</span>, -<span class="number">0.56261648</span>,  <span class="number">1.04681696</span>, -<span class="number">0.18998693</span>],</span><br><span class="line">       [ <span class="number">0.74739199</span>,  <span class="number">0.96309443</span>, -<span class="number">0.06967462</span>,  <span class="number">2.06858121</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">129</span>]: inds = [<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">130</span>]: np.take(arr,inds) <span class="comment"># 直接提取会返回一维数组</span></span><br><span class="line">Out[<span class="number">130</span>]: array([-<span class="number">0.88573795</span>,  <span class="number">0.08966036</span>, -<span class="number">0.88573795</span>, -<span class="number">1.89793365</span>])</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此，对二维数组提取特定行或列，<code>np.take</code> 必须指定轴</p>
<p>这里发现，<code>axis=0</code>才是提取行，这和 <code>np.sum</code> 相反。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">132</span>]: np.take(arr,inds,axis=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">132</span>]:</span><br><span class="line">array([[-<span class="number">0.53507013</span>, -<span class="number">0.56261648</span>,  <span class="number">1.04681696</span>, -<span class="number">0.18998693</span>],</span><br><span class="line">       [ <span class="number">0.08966036</span>, -<span class="number">1.89793365</span>, -<span class="number">0.88573795</span>, -<span class="number">0.99033984</span>],</span><br><span class="line">       [-<span class="number">0.53507013</span>, -<span class="number">0.56261648</span>,  <span class="number">1.04681696</span>, -<span class="number">0.18998693</span>],</span><br><span class="line">       [ <span class="number">0.50694474</span>,  <span class="number">0.58910697</span>,  <span class="number">1.81629683</span>,  <span class="number">1.41723295</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">133</span>]: np.take(arr,inds,axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">133</span>]:</span><br><span class="line">array([[-<span class="number">0.88573795</span>,  <span class="number">0.08966036</span>, -<span class="number">0.88573795</span>, -<span class="number">1.89793365</span>],</span><br><span class="line">       [ <span class="number">1.81629683</span>,  <span class="number">0.50694474</span>,  <span class="number">1.81629683</span>,  <span class="number">0.58910697</span>],</span><br><span class="line">       [ <span class="number">1.04681696</span>, -<span class="number">0.53507013</span>,  <span class="number">1.04681696</span>, -<span class="number">0.56261648</span>],</span><br><span class="line">       [-<span class="number">0.06967462</span>,  <span class="number">0.74739199</span>, -<span class="number">0.06967462</span>,  <span class="number">0.96309443</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="实战：获取子矩阵">实战：获取子矩阵</h4>
<p>资料：<a href="https://www.codenong.com/19161512/">https://www.codenong.com/19161512/</a></p>
<p>numpy 不存在直接根据索引直接获取子矩阵的方法，处理该需求最简单的办法就是先提取相应行，再提取相应列</p>
<p>举个，假如我们有一个数组 <code>arr</code> 和需要提取的行/列的索引列表 <code>index_list</code> :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">9</span>]: arr = np.empty((<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    ...:     arr[i] = i</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: arr</span><br><span class="line">Out[<span class="number">11</span>]:</span><br><span class="line">array([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>],</span><br><span class="line">       [<span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>],</span><br><span class="line">       [<span class="number">4.</span>, <span class="number">4.</span>, <span class="number">4.</span>, <span class="number">4.</span>, <span class="number">4.</span>, <span class="number">4.</span>, <span class="number">4.</span>, <span class="number">4.</span>],</span><br><span class="line">       [<span class="number">5.</span>, <span class="number">5.</span>, <span class="number">5.</span>, <span class="number">5.</span>, <span class="number">5.</span>, <span class="number">5.</span>, <span class="number">5.</span>, <span class="number">5.</span>],</span><br><span class="line">       [<span class="number">6.</span>, <span class="number">6.</span>, <span class="number">6.</span>, <span class="number">6.</span>, <span class="number">6.</span>, <span class="number">6.</span>, <span class="number">6.</span>, <span class="number">6.</span>],</span><br><span class="line">       [<span class="number">7.</span>, <span class="number">7.</span>, <span class="number">7.</span>, <span class="number">7.</span>, <span class="number">7.</span>, <span class="number">7.</span>, <span class="number">7.</span>, <span class="number">7.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: index_list = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>] <span class="comment"># 假设需要提取index_list 的行和列，形成一个新的子矩阵</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试使用 <code>[index_list, :]</code>  和   <code>[:, index_list]</code> 分别提取行和列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: arr[index_list, :]</span><br><span class="line">Out[<span class="number">13</span>]:</span><br><span class="line">array([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>],</span><br><span class="line">       [<span class="number">4.</span>, <span class="number">4.</span>, <span class="number">4.</span>, <span class="number">4.</span>, <span class="number">4.</span>, <span class="number">4.</span>, <span class="number">4.</span>, <span class="number">4.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: arr[:, index_list] <span class="comment"># 获取列</span></span><br><span class="line">Out[<span class="number">14</span>]:</span><br><span class="line">array([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>],</span><br><span class="line">       [<span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>],</span><br><span class="line">       [<span class="number">4.</span>, <span class="number">4.</span>, <span class="number">4.</span>],</span><br><span class="line">       [<span class="number">5.</span>, <span class="number">5.</span>, <span class="number">5.</span>],</span><br><span class="line">       [<span class="number">6.</span>, <span class="number">6.</span>, <span class="number">6.</span>],</span><br><span class="line">       [<span class="number">7.</span>, <span class="number">7.</span>, <span class="number">7.</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>成功，合并这两个命令，即可实现提取子矩阵</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">16</span>]: arr[index_list, :][:, index_list]</span><br><span class="line">Out[<span class="number">16</span>]:</span><br><span class="line">array([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>],</span><br><span class="line">       [<span class="number">4.</span>, <span class="number">4.</span>, <span class="number">4.</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="切片不是复制">切片不是复制</h3>
<p>切片不会创建一个新的数组，<strong>修改切片会直接修改原数组</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">51</span>]: a = np.arange(<span class="number">25</span>).reshape(<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: a</span><br><span class="line">Out[<span class="number">52</span>]:</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>],</span><br><span class="line">       [<span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">       [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: s = a[:, <span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">54</span>]: s</span><br><span class="line">Out[<span class="number">54</span>]:</span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [<span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line">       [<span class="number">16</span>, <span class="number">17</span>],</span><br><span class="line">       [<span class="number">21</span>, <span class="number">22</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: s[:] = <span class="number">10</span> <span class="comment"># 所有元素改为10</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">56</span>]: a</span><br><span class="line">Out[<span class="number">56</span>]:</span><br><span class="line">array([[ <span class="number">0</span>, <span class="number">10</span>, <span class="number">10</span>,  <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>],</span><br><span class="line">       [<span class="number">15</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">       [<span class="number">20</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">23</span>, <span class="number">24</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果需要复制生成一个新数组，需要使用 <strong>copy()</strong> 函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">57</span>]: d = a.copy()</span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: d <span class="keyword">is</span> a</span><br><span class="line">Out[<span class="number">58</span>]: <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: d[<span class="number">0</span>,<span class="number">0</span>]=<span class="number">9999</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: a</span><br><span class="line">Out[<span class="number">60</span>]:</span><br><span class="line">array([[ <span class="number">0</span>, <span class="number">10</span>, <span class="number">10</span>,  <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>],</span><br><span class="line">       [<span class="number">15</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">       [<span class="number">20</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">23</span>, <span class="number">24</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="利用数组进行数据处理">利用数组进行数据处理</h2>
<p>Numpy 允许你用简洁的数组表达式来替代循环函数，这种方式称为<strong>矢量化</strong>，速度一般比等价的纯Python方式快上一两个数量级。</p>
<h3 id="矢量化简介">矢量化简介</h3>
<p>矢量化是将标量程序转换为矢量程序的术语。矢量化程序可以从一条指令中运行多个操作，而标量只能一次对操作数进行操作。</p>
<p><a href="https://www.codenong.com/1422149/">https://www.codenong.com/1422149/</a></p>
<p>标量方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">   C[i] = A[i]*B[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>矢量化方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i+=<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">   C[i:i+<span class="number">3</span>] = A[i:i+<span class="number">3</span>]*B[i:i+<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="条件表达式-np-where">条件表达式 (np.where)</h3>
<p><code>numpy.where</code> 是三元表达式 <code>x if condition else y</code> 的矢量化版本。假设我们有3个数组如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">36</span>]: xarr = np.array([<span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">1.5</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: yarr = np.array([<span class="number">2.1</span>, <span class="number">2.2</span>, <span class="number">2.3</span>, <span class="number">2.4</span>, <span class="number">2.5</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: cond = np.array([<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设我们想要根据 cond 中的值选取 xarr 和 yarr 的 值： 当 cond 中的值为 True 时，选取 xarr 的 值，否则从 yarr 中选取。列表推导式的写法应该如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">39</span>]: result = [(x <span class="keyword">if</span> c <span class="keyword">else</span> y) <span class="keyword">for</span> x,y,c <span class="keyword">in</span> <span class="built_in">zip</span>(xarr,yarr,cond)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: result</span><br><span class="line">Out[<span class="number">40</span>]: [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">2.5</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是，这对大数组的处理速度不是很快。如果使用 <code>np.where</code> ，则可以将该功能写得非常简洁：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">41</span>]: result = np.where(cond, xarr, yarr)</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: result</span><br><span class="line">Out[<span class="number">42</span>]: array([<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">2.5</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 <code>np.where</code> ，第二个和第三个参数不必是数组，它们都可以是标量值。在数据分析工作中，<code>np.where</code> 通常用于根据另一个数组而产生一个新的数组。假设有一个由随机数据组成的矩阵，你希望将所有正值替换为2，将所有负值替换为 -2。如果使用 <code>np.where</code> ，则会非常简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">43</span>]: arr = np.random.randn(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: arr</span><br><span class="line">Out[<span class="number">44</span>]:</span><br><span class="line">array([[ <span class="number">1.24501831</span>, -<span class="number">1.1364485</span> , -<span class="number">0.21286997</span>,  <span class="number">0.93445777</span>],</span><br><span class="line">       [-<span class="number">0.66131158</span>, -<span class="number">0.51465519</span>, -<span class="number">0.49713506</span>, -<span class="number">0.55298134</span>],</span><br><span class="line">       [ <span class="number">0.22794101</span>, -<span class="number">0.28197764</span>, -<span class="number">1.23257136</span>,  <span class="number">0.05819466</span>],</span><br><span class="line">       [ <span class="number">0.65403202</span>,  <span class="number">0.47576908</span>,  <span class="number">1.30552203</span>,  <span class="number">0.44683928</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: np.where(arr&gt;<span class="number">0</span>,<span class="number">2</span>,-<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">45</span>]:</span><br><span class="line">array([[ <span class="number">2</span>, -<span class="number">2</span>, -<span class="number">2</span>,  <span class="number">2</span>],</span><br><span class="line">       [-<span class="number">2</span>, -<span class="number">2</span>, -<span class="number">2</span>, -<span class="number">2</span>],</span><br><span class="line">       [ <span class="number">2</span>, -<span class="number">2</span>, -<span class="number">2</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 <code>np.where</code> ，可以将标量和数组结合起来。例如，我可以用常数 2 替换 arr 中的所有正值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">46</span>]: np.where(arr&gt;<span class="number">0</span>,<span class="number">2</span>,arr)</span><br><span class="line">Out[<span class="number">46</span>]:</span><br><span class="line">array([[ <span class="number">2.</span>        , -<span class="number">1.1364485</span> , -<span class="number">0.21286997</span>,  <span class="number">2.</span>        ],</span><br><span class="line">       [-<span class="number">0.66131158</span>, -<span class="number">0.51465519</span>, -<span class="number">0.49713506</span>, -<span class="number">0.55298134</span>],</span><br><span class="line">       [ <span class="number">2.</span>        , -<span class="number">0.28197764</span>, -<span class="number">1.23257136</span>,  <span class="number">2.</span>        ],</span><br><span class="line">       [ <span class="number">2.</span>        ,  <span class="number">2.</span>        ,  <span class="number">2.</span>        ,  <span class="number">2.</span>        ]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="均值，求和">均值，求和</h3>
<h4 id="axis-0-列-，axis-1-行">axis=0(列)，axis=1(行)</h4>
<ul>
<li>
<p><code>np.mean</code>  ： 均值</p>
</li>
<li>
<p><code>np.sum</code> ：求和</p>
</li>
<li>
<p><code>np.std</code>/<code>np.var</code>  ： 标准差/方差</p>
</li>
<li>
<p><code>np.min</code>/<code>np.max</code>：最大值和最小值的索引</p>
</li>
<li>
<p><code>np.argmin</code>/<code>np.argmax</code>：最大值和最小值的索引</p>
</li>
<li>
<p><code>np.cumsum</code>/<code>np.cumprob</code> :  累计和/累计积</p>
</li>
</ul>
<p>这些都有一个参数 <code>axis</code>， <strong>0是列，1是行</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">50</span>]: test = np.where(arr&gt;<span class="number">0</span>,<span class="number">2</span>,-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: test</span><br><span class="line">Out[<span class="number">51</span>]:</span><br><span class="line">array([[ <span class="number">2</span>, -<span class="number">2</span>, -<span class="number">2</span>,  <span class="number">2</span>],</span><br><span class="line">       [-<span class="number">2</span>, -<span class="number">2</span>, -<span class="number">2</span>, -<span class="number">2</span>],</span><br><span class="line">       [ <span class="number">2</span>, -<span class="number">2</span>, -<span class="number">2</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: np.<span class="built_in">sum</span>(test,axis=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">52</span>]: array([ <span class="number">4</span>, -<span class="number">4</span>, -<span class="number">4</span>,  <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: np.<span class="built_in">sum</span>(test,axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">53</span>]: array([ <span class="number">0</span>, -<span class="number">8</span>,  <span class="number">0</span>,  <span class="number">8</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>np.sum(test,axis=1)</code>  和 <code>test.sum(axis=1)</code> ，但是我觉得前面的写法可读性好一点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: np.<span class="built_in">sum</span>(test,axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">56</span>]: array([ <span class="number">0</span>, -<span class="number">8</span>,  <span class="number">0</span>,  <span class="number">8</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">57</span>]: test.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">57</span>]: array([ <span class="number">0</span>, -<span class="number">8</span>,  <span class="number">0</span>,  <span class="number">8</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>np.cumsum</code> 计算累计和，产生一个由中间结果组成的数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">58</span>]: arr = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: arr.cumsum()</span><br><span class="line">Out[<span class="number">59</span>]: array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">3</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">28</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="排序">排序</h3>
<p>一维数组，就和列表一样可以就地排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">63</span>]: arr = np.random.randn(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: arr</span><br><span class="line">Out[<span class="number">64</span>]:</span><br><span class="line">array([ <span class="number">0.42339199</span>, -<span class="number">0.62071329</span>,  <span class="number">0.78341808</span>,  <span class="number">0.23957701</span>, -<span class="number">1.25798173</span>,</span><br><span class="line">        <span class="number">1.16677285</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: arr.sort()</span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: arr</span><br><span class="line">Out[<span class="number">66</span>]:</span><br><span class="line">array([-<span class="number">1.25798173</span>, -<span class="number">0.62071329</span>,  <span class="number">0.23957701</span>,  <span class="number">0.42339199</span>,  <span class="number">0.78341808</span>,</span><br><span class="line">        <span class="number">1.16677285</span>])</span><br></pre></td></tr></table></figure>
<p>如果用 <code>np.sort</code> 那么会创建一个新的数组，原数组不变。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">67</span>]: arr = np.random.randn(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: arr</span><br><span class="line">Out[<span class="number">68</span>]:</span><br><span class="line">array([-<span class="number">0.19195542</span>,  <span class="number">1.40905321</span>, -<span class="number">0.92385414</span>, -<span class="number">0.3974612</span> , -<span class="number">0.58201622</span>,</span><br><span class="line">        <span class="number">0.90084506</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">69</span>]: np.sort(arr)</span><br><span class="line">Out[<span class="number">69</span>]:</span><br><span class="line">array([-<span class="number">0.92385414</span>, -<span class="number">0.58201622</span>, -<span class="number">0.3974612</span> , -<span class="number">0.19195542</span>,  <span class="number">0.90084506</span>,</span><br><span class="line">        <span class="number">1.40905321</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: arr</span><br><span class="line">Out[<span class="number">70</span>]:</span><br><span class="line">array([-<span class="number">0.19195542</span>,  <span class="number">1.40905321</span>, -<span class="number">0.92385414</span>, -<span class="number">0.3974612</span> , -<span class="number">0.58201622</span>,</span><br><span class="line">        <span class="number">0.90084506</span>])</span><br></pre></td></tr></table></figure>
<p>二维数组排序需要指定 <code>axis</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">71</span>]: arr = np.random.randn(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: arr</span><br><span class="line">Out[<span class="number">72</span>]:</span><br><span class="line">array([[ <span class="number">0.71559313</span>, -<span class="number">0.81124772</span>,  <span class="number">0.09263225</span>],</span><br><span class="line">       [ <span class="number">0.99991354</span>,  <span class="number">1.23772904</span>, -<span class="number">0.00689</span>   ],</span><br><span class="line">       [ <span class="number">0.32068133</span>, -<span class="number">1.01139384</span>,  <span class="number">1.38105619</span>],</span><br><span class="line">       [-<span class="number">0.50530594</span>, -<span class="number">0.09772928</span>,  <span class="number">1.8015256</span> ],</span><br><span class="line">       [-<span class="number">0.40187181</span>,  <span class="number">0.83434417</span>, -<span class="number">0.87762611</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">73</span>]: np.sort(arr,axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">73</span>]:</span><br><span class="line">array([[-<span class="number">0.81124772</span>,  <span class="number">0.09263225</span>,  <span class="number">0.71559313</span>],</span><br><span class="line">       [-<span class="number">0.00689</span>   ,  <span class="number">0.99991354</span>,  <span class="number">1.23772904</span>],</span><br><span class="line">       [-<span class="number">1.01139384</span>,  <span class="number">0.32068133</span>,  <span class="number">1.38105619</span>],</span><br><span class="line">       [-<span class="number">0.50530594</span>, -<span class="number">0.09772928</span>,  <span class="number">1.8015256</span> ],</span><br><span class="line">       [-<span class="number">0.87762611</span>, -<span class="number">0.40187181</span>,  <span class="number">0.83434417</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是，<code>np.sort</code> 不能选择从大到小排序，即没有 <code>reverse</code> 选项。</p>
<h3 id="去重">去重</h3>
<p><code>np.unique</code> 用于找出数组中的唯一值并返回<strong>已排序的结果</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">74</span>]: names = np.array([<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">75</span>]: np.unique(names)</span><br><span class="line">Out[<span class="number">75</span>]: array([<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Will&#x27;</span>], dtype=<span class="string">&#x27;&lt;U4&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="集合运算">集合运算</h3>
<p><img src="3.png" alt="3"></p>
<p>例如，我们可以用 <code>np.in1d</code> 函数测试一个数组中的值在另一个数组中的成员资格，返回一个布尔型数组。（我感觉 <code>1d</code> 应该就是说只适用于一维数组）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">76</span>]: values = np.array([<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: np.in1d(values, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>])</span><br><span class="line">Out[<span class="number">77</span>]: array([ <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="随机打乱数组">随机打乱数组</h3>
<p>对于一个一维数组，可以采用 <code>np.random.shuffle</code> 进行随机打乱。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">79</span>]: arr = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: arr</span><br><span class="line">Out[<span class="number">80</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">81</span>]: np.random.shuffle(arr)</span><br><span class="line"></span><br><span class="line">In [<span class="number">82</span>]: arr</span><br><span class="line">Out[<span class="number">82</span>]: array([<span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="reshape-与-ravel">reshape 与 ravel</h3>
<p>通过 reshape 可以改变维度，二维数组可以设定其中一个维度为 -1，表示根据另一个维度推断而来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">83</span>]: arr = np.arange(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: arr.reshape(<span class="number">5</span>,-<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">84</span>]:</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">       [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>相反，将多维转为一维的操作称为<strong>扁平化</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">86</span>]: arr = np.arange(<span class="number">15</span>).reshape(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: arr</span><br><span class="line">Out[<span class="number">87</span>]:</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">       [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: np.ravel(arr)</span><br><span class="line">Out[<span class="number">88</span>]: array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">89</span>]: arr</span><br><span class="line">Out[<span class="number">89</span>]:</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">       [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="行-列优先顺序">行/列优先顺序</h3>
<p>默认情况下，Numpy 数组是按行优先顺序创建的，也就是说，对于一个二维数组，<strong>同一行</strong>的数据是存放在<strong>相邻的内存位置上</strong>的。另一种顺序是列顺序，即每一列中的数据项是放在相邻内存位置上的。</p>
<p>由于历史原因，行和列优先顺序又分别称为 C 和 Fortran 顺序。</p>
<p>像reshape和reval这样的函数，都可以接受一个表示数组数据存放顺序的order参数。一般可以是’C’或’F’ 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">91</span>]: arr = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">92</span>]: arr</span><br><span class="line">Out[<span class="number">92</span>]:</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">93</span>]: arr.ravel()</span><br><span class="line">Out[<span class="number">93</span>]: array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: arr.ravel(order=<span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">Out[<span class="number">94</span>]: array([ <span class="number">0</span>,  <span class="number">4</span>,  <span class="number">8</span>,  <span class="number">1</span>,  <span class="number">5</span>,  <span class="number">9</span>,  <span class="number">2</span>,  <span class="number">6</span>, <span class="number">10</span>,  <span class="number">3</span>,  <span class="number">7</span>, <span class="number">11</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下图为详细说明</p>
<p><img src="4.png" alt="3"></p>
<h3 id="数组合并与拆分">数组合并与拆分</h3>
<p><code>np.concatenate</code> 可以按照指定轴将一个由数组组成的序列连接到一起。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">95</span>]: arr1 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">96</span>]: arr2 = np.array([[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: np.concatenate([arr1,arr2],axis=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">97</span>]:</span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>],</span><br><span class="line">       [ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: np.concatenate([arr1,arr2],axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">98</span>]:</span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里也可以使用 <code>np.vstack</code> 和 <code>np.hstack</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">99</span>]: np.vstack((arr1,arr2))</span><br><span class="line">Out[<span class="number">99</span>]:</span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>],</span><br><span class="line">       [ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: np.hstack((arr1,arr2))</span><br><span class="line">Out[<span class="number">100</span>]:</span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br></pre></td></tr></table></figure>
<p>与此相反，<code>np.split</code> 用于将一个数组沿指定轴拆分为多个数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">101</span>]: arr = np.random.randn(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">102</span>]: arr</span><br><span class="line">Out[<span class="number">102</span>]:</span><br><span class="line">array([[ <span class="number">0.71839418</span>,  <span class="number">0.26244041</span>],</span><br><span class="line">       [ <span class="number">0.06017772</span>,  <span class="number">0.3727177</span> ],</span><br><span class="line">       [ <span class="number">1.52919536</span>, -<span class="number">0.05853283</span>],</span><br><span class="line">       [ <span class="number">0.52980523</span>,  <span class="number">1.0209942</span> ],</span><br><span class="line">       [ <span class="number">0.52921784</span>, -<span class="number">0.21331381</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: first, second, third = np.split(arr,[<span class="number">1</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">104</span>]: first</span><br><span class="line">Out[<span class="number">104</span>]: array([[<span class="number">0.71839418</span>, <span class="number">0.26244041</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">105</span>]: second</span><br><span class="line">Out[<span class="number">105</span>]:</span><br><span class="line">array([[ <span class="number">0.06017772</span>,  <span class="number">0.3727177</span> ],</span><br><span class="line">       [ <span class="number">1.52919536</span>, -<span class="number">0.05853283</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">106</span>]: third</span><br><span class="line">Out[<span class="number">106</span>]:</span><br><span class="line">array([[ <span class="number">0.52980523</span>,  <span class="number">1.0209942</span> ],</span><br><span class="line">       [ <span class="number">0.52921784</span>, -<span class="number">0.21331381</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>传入到<code>np.split</code> 的值[1,3]指示在哪个索引处分割数组。</p>
<h3 id="重复：tile-repeat">重复：tile, repeat</h3>
<blockquote>
<p>笔记：跟其他流行的数组编程语言（如MATLAB）不同，NumPy中很少需要对数组进行重复（replicate）。这主要是因为广播（broadcasting）能更好地满足该需求。</p>
</blockquote>
<p><code>np.repeat</code> 会将数组中的各个元素重复一定次数，从而产生一个更大的数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">110</span>]: arr</span><br><span class="line">Out[<span class="number">110</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">111</span>]: np.repeat(arr,<span class="number">3</span>)</span><br><span class="line">Out[<span class="number">111</span>]: array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>np.tile</code> 的功能是沿指定轴向堆叠数组的副本。你可以形象地将其想象成“铺瓷砖”：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">114</span>]: arr = np.random.randn(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">115</span>]: arr</span><br><span class="line">Out[<span class="number">115</span>]:</span><br><span class="line">array([[-<span class="number">0.28292737</span>, -<span class="number">0.75282542</span>],</span><br><span class="line">       [ <span class="number">1.062867</span>  ,  <span class="number">0.59542565</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: np.tile(arr,<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">116</span>]:</span><br><span class="line">array([[-<span class="number">0.28292737</span>, -<span class="number">0.75282542</span>, -<span class="number">0.28292737</span>, -<span class="number">0.75282542</span>],</span><br><span class="line">       [ <span class="number">1.062867</span>  ,  <span class="number">0.59542565</span>,  <span class="number">1.062867</span>  ,  <span class="number">0.59542565</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">117</span>]: np.tile(arr,(<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line">Out[<span class="number">117</span>]:</span><br><span class="line">array([[-<span class="number">0.28292737</span>, -<span class="number">0.75282542</span>],</span><br><span class="line">       [ <span class="number">1.062867</span>  ,  <span class="number">0.59542565</span>],</span><br><span class="line">       [-<span class="number">0.28292737</span>, -<span class="number">0.75282542</span>],</span><br><span class="line">       [ <span class="number">1.062867</span>  ,  <span class="number">0.59542565</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="广播">广播</h2>
<p>广播指不同形状的数组之间的算术运算的执行方式。</p>
<p>将标量值与数组合并时就会发生最简单的广播。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">134</span>]: arr = np.arange(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">135</span>]: arr</span><br><span class="line">Out[<span class="number">135</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">136</span>]: arr * <span class="number">4</span></span><br><span class="line">Out[<span class="number">136</span>]: array([ <span class="number">0</span>,  <span class="number">4</span>,  <span class="number">8</span>, <span class="number">12</span>, <span class="number">16</span>])</span><br></pre></td></tr></table></figure>
<p>看一个，对矩阵的<strong>列</strong>进行<strong>中心化</strong>（均值为0）。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">137</span>]: arr = np.random.randn(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">138</span>]: np.mean(arr,axis=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">138</span>]: array([ <span class="number">0.13832533</span>, -<span class="number">0.47971553</span>,  <span class="number">0.52635801</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">139</span>]: col_center_arr = arr - np.mean(arr,axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">140</span>]: col_center_arr</span><br><span class="line">Out[<span class="number">140</span>]:</span><br><span class="line">array([[-<span class="number">0.55713481</span>, -<span class="number">0.55726651</span>,  <span class="number">1.24535274</span>],</span><br><span class="line">       [-<span class="number">1.55961791</span>,  <span class="number">0.66395791</span>, -<span class="number">0.55885849</span>],</span><br><span class="line">       [ <span class="number">0.63712699</span>, -<span class="number">0.22694898</span>,  <span class="number">0.44549285</span>],</span><br><span class="line">       [ <span class="number">1.47962573</span>,  <span class="number">0.12025757</span>, -<span class="number">1.13198709</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">141</span>]: np.mean(col_center_arr, axis=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">141</span>]: array([-<span class="number">5.55111512e-17</span>,  <span class="number">1.38777878e-17</span>,  <span class="number">0.00000000e+00</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下图为图示说明（只有一维的数组实际是一行多列，即下面的 (3,) 应该理解为 (1,3) ）</p>
<p><img src="6.png" alt="6"></p>
<p>假如我们要对<strong>行</strong>进行中心化，较小的那个数组的形状必须为 (4,1)，因此需要 <code>reshape</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">142</span>]: arr</span><br><span class="line">Out[<span class="number">142</span>]:</span><br><span class="line">array([[-<span class="number">0.41880948</span>, -<span class="number">1.03698204</span>,  <span class="number">1.77171074</span>],</span><br><span class="line">       [-<span class="number">1.42129258</span>,  <span class="number">0.18424238</span>, -<span class="number">0.03250049</span>],</span><br><span class="line">       [ <span class="number">0.77545233</span>, -<span class="number">0.70666451</span>,  <span class="number">0.97185086</span>],</span><br><span class="line">       [ <span class="number">1.61795106</span>, -<span class="number">0.35945796</span>, -<span class="number">0.60562908</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">143</span>]: row_means = np.mean(arr,axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">144</span>]: row_means.shape</span><br><span class="line">Out[<span class="number">144</span>]: (<span class="number">4</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">145</span>]: row_means.reshape((<span class="number">4</span>,<span class="number">1</span>)) <span class="comment">#改变形状为(4,1)</span></span><br><span class="line">Out[<span class="number">145</span>]:</span><br><span class="line">array([[ <span class="number">0.10530641</span>],</span><br><span class="line">       [-<span class="number">0.42318356</span>],</span><br><span class="line">       [ <span class="number">0.34687956</span>],</span><br><span class="line">       [ <span class="number">0.21762134</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">146</span>]: row_center_arr = arr - row_means.reshape((<span class="number">4</span>,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">147</span>]: np.mean(row_center_arr, axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">147</span>]: array([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>图示如下：</p>
<p><img src="7.png" alt="6"></p>
<p>测试了一下 <code>(4,3) - (2,3)</code> 和 <code>(4,3) - (2,1)</code> 这种情况，即较小的数组总共是2行，报错了，很合理，<strong>每个维度的值要么相同，要么有一个是1</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">152</span>]: arr</span><br><span class="line">Out[<span class="number">152</span>]:</span><br><span class="line">array([[-<span class="number">0.41880948</span>, -<span class="number">1.03698204</span>,  <span class="number">1.77171074</span>],</span><br><span class="line">       [-<span class="number">1.42129258</span>,  <span class="number">0.18424238</span>, -<span class="number">0.03250049</span>],</span><br><span class="line">       [ <span class="number">0.77545233</span>, -<span class="number">0.70666451</span>,  <span class="number">0.97185086</span>],</span><br><span class="line">       [ <span class="number">1.61795106</span>, -<span class="number">0.35945796</span>, -<span class="number">0.60562908</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">154</span>]: test</span><br><span class="line">Out[<span class="number">154</span>]:</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">155</span>]: arr - test</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">ValueError                                Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">155</span>-85d32d9f06c6&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; 1 arr - test</span><br><span class="line"></span><br><span class="line">ValueError: operands could <span class="keyword">not</span> be broadcast together <span class="keyword">with</span> shapes (<span class="number">4</span>,<span class="number">3</span>) (<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">156</span>]: test = np.array([[<span class="number">0</span>],[<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">157</span>]: test</span><br><span class="line">Out[<span class="number">157</span>]:</span><br><span class="line">array([[<span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">158</span>]: arr - test</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">ValueError                                Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">158</span>-85d32d9f06c6&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; 1 arr - test</span><br><span class="line"></span><br><span class="line">ValueError: operands could <span class="keyword">not</span> be broadcast together <span class="keyword">with</span> shapes (<span class="number">4</span>,<span class="number">3</span>) (<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="广播规则">广播规则</h3>
<p>这本书的作者解释得不好。还不如 <a href="https://www.runoob.com/numpy/numpy-broadcast.html">NumPy 广播 | 菜鸟教程</a></p>
<blockquote>
<p><strong>广播的规则:</strong></p>
<ul>
<li>让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐。</li>
<li>输出数组的形状是输入数组形状的各个维度上的最大值。</li>
<li>如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。</li>
<li><strong>当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。</strong></li>
</ul>
<p>**简单理解：**对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足：</p>
<ul>
<li>数组拥有相同形状。</li>
<li>当前维度的值相等。</li>
<li>当前维度的值有一个是 1。</li>
<li>最终的shape是输入数组shape各个轴上的最大值。</li>
</ul>
<p>若条件不满足，抛出 <strong>“ValueError: frames are not aligned”</strong> 异常。</p>
</blockquote>
<p>例如，下式中 <code>(3×1) + (1×2)</code> ，3×1 会复制成 3×2，1×2 也会复制成 3×2，再进行元素相加。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">63</span>]: v = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]).reshape(<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: w = np.array([<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: v</span><br><span class="line">Out[<span class="number">65</span>]:</span><br><span class="line">array([[<span class="number">1</span>],</span><br><span class="line">       [<span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: w</span><br><span class="line">Out[<span class="number">66</span>]: array([<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: v + <span class="number">2</span></span><br><span class="line">Out[<span class="number">67</span>]:</span><br><span class="line">array([[<span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>],</span><br><span class="line">       [<span class="number">5</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: v + w</span><br><span class="line">Out[<span class="number">68</span>]:</span><br><span class="line">array([[<span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">       [<span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="用-Numba-编写快速-Numpy-函数">用 Numba 编写快速 Numpy 函数</h2>
<p>Numba 是一个开源项目，它可以利用 CPUs，GPUs 或其它硬件为类似 Numpy 的数据创建快速函数。网上说，Numba 适合 for 循环 和 numpy 数组 的数值计算加速。这部分作者讲得不详细，建议去看<a href="https://numba.pydata.org/numba-doc/dev/index.html">官网</a> 。</p>
<p>举个例子，假设我们使用 for 循环计算表达式 (x-y).mean() :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: <span class="keyword">from</span> numba <span class="keyword">import</span> njit</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: <span class="function"><span class="keyword">def</span> <span class="title">mean_distance</span>(<span class="params">x, y</span>):</span></span><br><span class="line">   ...:     nx = <span class="built_in">len</span>(x)</span><br><span class="line">   ...:     result = <span class="number">0.0</span></span><br><span class="line">   ...:     count = <span class="number">0</span></span><br><span class="line">   ...:     <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nx):</span><br><span class="line">   ...:         result += x[i] - y[i]</span><br><span class="line">   ...:         count += <span class="number">1</span></span><br><span class="line">   ...:     <span class="keyword">return</span> result/count</span><br><span class="line">   ...:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根据本书和网上的说法，建议直接使用 <strong>njit</strong> 函数 。</p>
<blockquote>
<p>Numba的 jit 函数有一个选项，nopython=True，它限制了可以被转换为Python代码的代码，这些代码可以编译为LLVM，但没有任何Python C API调用。jit(nopython=True)有一个简短的别名numba.njit。</p>
</blockquote>
<p>上面使用 for 循环，速度比较慢：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">4</span>]: x = np.random.randn(<span class="number">10000000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: y = np.random.randn(<span class="number">10000000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: %timeit mean_distance(x,y)</span><br><span class="line"><span class="number">3.76</span> s ± <span class="number">51.2</span> ms per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">1</span> loop each)</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: %timeit (x-y).mean()</span><br><span class="line"><span class="number">56.4</span> ms ± <span class="number">103</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">10</span> loops each)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 Numpy 的版本比该函数快一百倍左右。 我们可以转换这个函数为编译的 Numba 函数，直接在函数上方添加一行 <code>@njit</code> ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">8</span>]: @njit</span><br><span class="line">   ...: <span class="function"><span class="keyword">def</span> <span class="title">mean_distance</span>(<span class="params">x, y</span>):</span></span><br><span class="line">   ...:     nx = <span class="built_in">len</span>(x)</span><br><span class="line">   ...:     result = <span class="number">0.0</span></span><br><span class="line">   ...:     count = <span class="number">0</span></span><br><span class="line">   ...:     <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nx):</span><br><span class="line">   ...:         result += x[i] - y[i]</span><br><span class="line">   ...:         count += <span class="number">1</span></span><br><span class="line">   ...:     <span class="keyword">return</span> result/count</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: %timeit mean_distance(x,y)</span><br><span class="line"><span class="number">15.5</span> ms ± <span class="number">97.1</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">1</span> loop each)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果直接对 Numpy 的矢量化操作进行加速呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">11</span>]: @njit</span><br><span class="line">    ...: <span class="function"><span class="keyword">def</span> <span class="title">mean_distance2</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    ...:     <span class="keyword">return</span> (x-y).mean()</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: %timeit mean_distance2(x,y)</span><br><span class="line"><span class="number">65.9</span> ms ± <span class="number">1.78</span> ms per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">1</span> loop each)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试了一下，<strong>发现没有效果</strong>，甚至慢了一点。看来 numba 本身加速主要也就是<strong>矢量化</strong>，对于已经矢量化操作的代码就没什么用了。</p>
<p>看来 numba 只适用于 <strong>for 循环的加速</strong>。</p>
<p>如果从 numba 中获取最好的性能，可见官网的<a href="https://numba.pydata.org/numba-doc/dev/user/performance-tips.html#performance-tips">Performance Tips</a></p>
<h3 id="Numba-的精度问题">Numba 的精度问题</h3>
<p>Numba 会自动转换数据类型以适合计算。</p>
<blockquote>
<p>但是在个别时候，<strong>这种自动转变类型可能会引起一些计算误差</strong>。通常这个误差是非常小的，几乎不会造成任何影响。但如果你所处理的问题会积累误差，比如求解非线性方程，那么在非常多的计算之后误差可能就是肉眼可见了。**如果你发现有这样的问题，记得在jit中指定输入输出的数据类型。**numba具有C所有的数据类型，比如对上面的求和函数，只需要把@nb.jit()改为@nb.jit(nb.int64(nb.int32[:]))即可。nb.int64是说输出的数字为int64类型，nb.int32是说输入的数据类型为int32，而[:]是说输入的是数组。</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU5ODgzMjI3OA==&amp;mid=2247483743&amp;idx=1&amp;sn=0725661e287365c9ced5f7884d243bc7&amp;chksm=febf64a6c9c8edb019c9d408953341155c6d3c3fc0f319b44a1c1091027fb50a7cca22ef3155&amp;token=1439145616&amp;lang=zh_CN#rd">https://mp.weixin.qq.com/s?__biz=MzU5ODgzMjI3OA==&amp;mid=2247483743&amp;idx=1&amp;sn=0725661e287365c9ced5f7884d243bc7&amp;chksm=febf64a6c9c8edb019c9d408953341155c6d3c3fc0f319b44a1c1091027fb50a7cca22ef3155&amp;token=1439145616&amp;lang=zh_CN#rd</a></p>
</blockquote>
<h3 id="用-Numba-创建自定义-numpy-ufunc-对象">用 Numba 创建自定义 numpy.ufunc 对象</h3>
<blockquote>
<p>ufunc是universal function的缩写，意思是这些函数能够作用于narray对象的每一个元素上，而不是针对narray对象操作，numpy提供了大量的ufunc的函数。这些函数在对narray进行运算的速度比使用循环或者列表推导式要快很多。</p>
<p><a href="https://blog.csdn.net/unixtch/article/details/78531585">https://blog.csdn.net/unixtch/article/details/78531585</a></p>
</blockquote>
<p>根据<a href="https://numba.pydata.org/numba-doc/dev/user/vectorize.html#vectorize">官网说明</a>，创建 ufunc 对象会进行<strong>元素</strong>级别的运算，简单地说，就是将输入的数组视为标量，进行标量之间的运算。</p>
<p>例如 np.add(x, y) ，针对 x 和 y 的每一个元素进行求和。我简单地测试了一下，直接使用 <code>x+y</code> 和 <code>np.add(x, y)</code> 效果一样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">25</span>]: %timeit x+y</span><br><span class="line"><span class="number">51.4</span> ms ± <span class="number">1.39</span> ms per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">10</span> loops each)</span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: %timeit np.add(x, y)</span><br><span class="line"><span class="number">51.5</span> ms ± <span class="number">717</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">10</span> loops each)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以用 numba.vectorize 创建一个编译的 ufunc 函数，它与内置的 ufunc 很像。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">33</span>]: <span class="keyword">from</span> numba <span class="keyword">import</span> vectorize</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: @vectorize</span><br><span class="line">    ...: <span class="function"><span class="keyword">def</span> <span class="title">nb_add</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    ...:     <span class="keyword">return</span> x+y</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: x = np.random.randn(<span class="number">1000000</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: %timeit nb_add(x, x)</span><br><span class="line"><span class="number">667</span> µs ± <span class="number">4.92</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">1000</span> loops each)</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: %timeit np.add(x, x)</span><br><span class="line"><span class="number">638</span> µs ± <span class="number">11.5</span> µs per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">1000</span> loops each)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>速度和内置的ufunc 函数一样。</p>
<h4 id="为什么不用-jit">为什么不用@jit</h4>
<p>从上面的例子来看，完全可以直接创建一个循环，使用 @jit 装饰器，那么为什么要用 @vectorize 呢？</p>
<p>官网的回答是创建了 ufuncs 函数，可以自动获取其他属性。</p>
<blockquote>
<p>The answer is that NumPy ufuncs automatically get other features such as reduction, accumulation or broadcasting. Using the example above.</p>
</blockquote>
<p><img src="38.png" alt="6"></p>
<p><img src="39.png" alt="6"></p>
<p>但是，我运行了一下，报错了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">80</span>]: a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">81</span>]: a</span><br><span class="line">Out[<span class="number">81</span>]:</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">82</span>]: nb_add.reduce(a, axis=<span class="number">0</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">82</span>-89838648a736&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; 1 nb_add.reduce(a, axis=0)</span><br><span class="line"></span><br><span class="line">TypeError: No loop matching the specified signature <span class="keyword">and</span> casting was found <span class="keyword">for</span> ufunc nb_add</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="实践：numba-函数-只能-return-一个数">实践：numba 函数 只能 return 一个数</h3>
<p>我想返回两个值，用元组，列表，一维数组都不行，全部报错，看来只能返回一个数值。</p>
<p>举例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">9</span>]: @njit</span><br><span class="line">   ...: <span class="function"><span class="keyword">def</span> <span class="title">Check_error_num</span>(<span class="params">arr1, arr2</span>):</span></span><br><span class="line">   ...:     error_snp_nums = <span class="number">0</span></span><br><span class="line">   ...:     miss_snp_nums = <span class="number">0</span></span><br><span class="line">   ...:     <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(snp_num):</span><br><span class="line">   ...:         product = (arr1[i] * arr2[i])</span><br><span class="line">   ...:         <span class="keyword">if</span> (product == <span class="number">3</span>):</span><br><span class="line">   ...:             error_snp_nums += <span class="number">1</span></span><br><span class="line">   ...:             <span class="keyword">if</span> error_snp_nums &gt; biggest_error_num:</span><br><span class="line">   ...:                 <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">   ...:         <span class="keyword">elif</span> (product == <span class="number">0</span>):</span><br><span class="line">   ...:             miss_snp_nums += <span class="number">1</span></span><br><span class="line">   ...:     <span class="keyword">return</span> error_snp_nums, miss_snp_nums</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: Check_error_num(first_array, second_array)</span><br><span class="line">    ...:</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypingError                               Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">10</span>-9288ee526588&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; 1 Check_error_num(first_array, second_array)</span><br><span class="line"></span><br><span class="line">/root/anaconda3/lib/python3<span class="number">.7</span>/site-packages/numba/dispatcher.py <span class="keyword">in</span> _compile_for_args(self, *args, **kws)</span><br><span class="line">    <span class="number">399</span>                 e.patch_message(msg)</span><br><span class="line">    <span class="number">400</span></span><br><span class="line">--&gt; 401             error_rewrite(e, &#x27;typing&#x27;)</span><br><span class="line">    <span class="number">402</span>         <span class="keyword">except</span> errors.UnsupportedError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="number">403</span>             <span class="comment"># Something unsupported is present in the user code, add help info</span></span><br><span class="line"></span><br><span class="line">/root/anaconda3/lib/python3<span class="number">.7</span>/site-packages/numba/dispatcher.py <span class="keyword">in</span> error_rewrite(e, issue_type)</span><br><span class="line">    <span class="number">342</span>                 <span class="keyword">raise</span> e</span><br><span class="line">    <span class="number">343</span>             <span class="keyword">else</span>:</span><br><span class="line">--&gt; 344                 reraise(type(e), e, None)</span><br><span class="line">    <span class="number">345</span></span><br><span class="line">    <span class="number">346</span>         argtypes = []</span><br><span class="line"></span><br><span class="line">/root/anaconda3/lib/python3<span class="number">.7</span>/site-packages/numba/six.py <span class="keyword">in</span> reraise(tp, value, tb)</span><br><span class="line">    <span class="number">666</span>             value = tp()</span><br><span class="line">    <span class="number">667</span>         <span class="keyword">if</span> value.__traceback__ <span class="keyword">is</span> <span class="keyword">not</span> tb:</span><br><span class="line">--&gt; 668             raise value.with_traceback(tb)</span><br><span class="line">    <span class="number">669</span>         <span class="keyword">raise</span> value</span><br><span class="line">    <span class="number">670</span></span><br><span class="line"></span><br><span class="line">TypingError: Failed <span class="keyword">in</span> nopython mode pipeline (step: nopython frontend)</span><br><span class="line">Can<span class="string">&#x27;t unify return type from the following types: Literal[int](0), UniTuple(int64 x 2)</span></span><br><span class="line"><span class="string">Return of: IR name &#x27;</span>$66return_value<span class="number">.2</span><span class="string">&#x27;, type &#x27;</span><span class="type">Literal</span>[<span class="built_in">int</span>](<span class="number">0</span>)<span class="string">&#x27;, location:</span></span><br><span class="line"><span class="string">File &quot;&lt;ipython-input-9-d6e01b85e8ff&gt;&quot;, line 10:</span></span><br><span class="line"><span class="string">def Check_error_num(arr1, arr2):</span></span><br><span class="line"><span class="string">    &lt;source elided&gt;</span></span><br><span class="line"><span class="string">            if error_snp_nums &gt; biggest_error_num:</span></span><br><span class="line"><span class="string">                return 0</span></span><br><span class="line"><span class="string">                ^</span></span><br><span class="line"><span class="string">Return of: IR name &#x27;</span>$96return_value<span class="number">.3</span><span class="string">&#x27;, type &#x27;</span>UniTuple(int64 x <span class="number">2</span>)<span class="string">&#x27;, location:</span></span><br><span class="line"><span class="string">File &quot;&lt;ipython-input-9-d6e01b85e8ff&gt;&quot;, line 13:</span></span><br><span class="line"><span class="string">def Check_error_num(arr1, arr2):</span></span><br><span class="line"><span class="string">    &lt;source elided&gt;</span></span><br><span class="line"><span class="string">            miss_snp_nums += 1</span></span><br><span class="line"><span class="string">    return error_snp_nums, miss_snp_nums</span></span><br><span class="line"><span class="string">    ^</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<h1>pandas 入门</h1>
<blockquote>
<p>pandas是本书后续内容的首选库。它含有使数据清洗和分析工作变得更快更简单的数据结构和操作工具。pandas经常和其它工具一同使用，如数值计算工具NumPy和SciPy，分析库statsmodels和scikit-learn，和数据可视化库matplotlib。<strong>pandas是基于NumPy数组构建的</strong>，特别是基于数组的函数和不使用for循环的数据处理。</p>
<p>虽然pandas采用了大量的NumPy编码风格，但二者最大的不同是<strong>pandas是专门为处理表格和混杂数据设计的</strong>。而<strong>NumPy更适合处理统一的数值数组数据</strong>。</p>
</blockquote>
<h2 id="pandas的数据结构介绍">pandas的数据结构介绍</h2>
<p>pandas 的两个主要的数据结构是 Series 和 DataFrame 。</p>
<h3 id="Series">Series</h3>
<p>Series 是一种类似于一维数组的对象，它由一组数据（各种Numpy数据类型）以及一组与之相关的数据标签（即索引）组成。仅由一组数据即可产生最简单的 Series:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">3</span>]: obj = pd.Series([<span class="number">4</span>,<span class="number">7</span>,-<span class="number">5</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: obj</span><br><span class="line">Out[<span class="number">4</span>]:</span><br><span class="line"><span class="number">0</span>    <span class="number">4</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">5</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Series 的字符串表现形式为：索引在左边，值在右边。由于我们没有为数据指定索引，于是会自动创建一个0到N-1的整数型索引。你可以通过 Series 的 values 和 index 属性获取其数组表示形式和索引对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">5</span>]: obj.values</span><br><span class="line">Out[<span class="number">5</span>]: array([ <span class="number">4</span>,  <span class="number">7</span>, -<span class="number">5</span>,  <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: obj.index</span><br><span class="line">Out[<span class="number">6</span>]: RangeIndex(start=<span class="number">0</span>, stop=<span class="number">4</span>, step=<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通常，我们希望所创建的 Series 带有一个可以对各个数据点进行标记的索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">7</span>]: obj2 = pd.Series([<span class="number">4</span>,<span class="number">7</span>,-<span class="number">5</span>,<span class="number">3</span>], index=[<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: obj2</span><br><span class="line">Out[<span class="number">8</span>]:</span><br><span class="line">d    <span class="number">4</span></span><br><span class="line">b    <span class="number">7</span></span><br><span class="line">a   -<span class="number">5</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>与普通Numpy数组相比，你可以通过索引的方式选取 Series 中的单一或一组值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">11</span>]: obj2[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">Out[<span class="number">11</span>]: -<span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: obj2[[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]]</span><br><span class="line">Out[<span class="number">12</span>]:</span><br><span class="line">a   -<span class="number">5</span></span><br><span class="line">b    <span class="number">7</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>说白了就是一个有名字的一维数组，Series 还可以看成是一个定长的有序字典，因为它是索引值到数据值的一个映射。它可以用在许多原本需要字典参数的函数中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: <span class="string">&#x27;b&#x27;</span> <span class="keyword">in</span> obj2</span><br><span class="line">Out[<span class="number">13</span>]: <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果数据存放在一个 Python 字典中，也可以直接通过这个字典来创建 Series:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">14</span>]: sdata = &#123;<span class="string">&#x27;Ohio&#x27;</span>: <span class="number">35000</span>, <span class="string">&#x27;Texas&#x27;</span>: <span class="number">71000</span>, <span class="string">&#x27;Oregon&#x27;</span>: <span class="number">16000</span>, <span class="string">&#x27;Utah&#x27;</span>: <span class="number">5000</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: obj3 = pd.Series(sdata)</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: obj3</span><br><span class="line">Out[<span class="number">16</span>]:</span><br><span class="line">Ohio      <span class="number">35000</span></span><br><span class="line">Texas     <span class="number">71000</span></span><br><span class="line">Oregon    <span class="number">16000</span></span><br><span class="line">Utah       <span class="number">5000</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里你可以通过传入排好序的字典的键以改变顺序。在下面这个例子中，有一个索引 “California” 在字典中找不到对应的键，所以结果为 <strong>NaN</strong> (非数字，not a number)，在 pandas 中表示缺失。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: states = [<span class="string">&#x27;California&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Oregon&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: obj4 = pd.Series(sdata, index=states)</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: obj4</span><br><span class="line">Out[<span class="number">19</span>]:</span><br><span class="line">California        NaN</span><br><span class="line">Ohio          <span class="number">35000.0</span></span><br><span class="line">Oregon        <span class="number">16000.0</span></span><br><span class="line">Texas         <span class="number">71000.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>pandas 的 <code>isnull</code> 和 <code>notnull</code> 函数可用于检测缺失数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">20</span>]: pd.isnull(obj4)</span><br><span class="line">Out[<span class="number">20</span>]:</span><br><span class="line">California     <span class="literal">True</span></span><br><span class="line">Ohio          <span class="literal">False</span></span><br><span class="line">Oregon        <span class="literal">False</span></span><br><span class="line">Texas         <span class="literal">False</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: pd.notnull(obj4)</span><br><span class="line">Out[<span class="number">21</span>]:</span><br><span class="line">California    <span class="literal">False</span></span><br><span class="line">Ohio           <span class="literal">True</span></span><br><span class="line">Oregon         <span class="literal">True</span></span><br><span class="line">Texas          <span class="literal">True</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Series 对象本身及其索引都有一个 name 属性，该属性跟 pandas 其他的关键功能非常密切：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">22</span>]: obj4.name = <span class="string">&quot;population&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: obj4.index.name = <span class="string">&quot;state&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: obj4</span><br><span class="line">Out[<span class="number">24</span>]:</span><br><span class="line">state</span><br><span class="line">California        NaN</span><br><span class="line">Ohio          <span class="number">35000.0</span></span><br><span class="line">Oregon        <span class="number">16000.0</span></span><br><span class="line">Texas         <span class="number">71000.0</span></span><br><span class="line">Name: population, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Series 的索引可以通过赋值的方式就地修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">25</span>]: obj</span><br><span class="line">Out[<span class="number">25</span>]:</span><br><span class="line"><span class="number">0</span>    <span class="number">4</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">5</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: obj.index = [<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span>, <span class="string">&#x27;Jeff&#x27;</span>, <span class="string">&#x27;Ryan&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: obj</span><br><span class="line">Out[<span class="number">27</span>]:</span><br><span class="line">Bob      <span class="number">4</span></span><br><span class="line">Steve    <span class="number">7</span></span><br><span class="line">Jeff    -<span class="number">5</span></span><br><span class="line">Ryan     <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="DataFrame">DataFrame</h3>
<p>DataFrame 就是一个二维表格，不同的列可以是不同的数据类型。</p>
<p>建立 DataFrame 的办法有很多，最常用的一种是直接传入一个由等长列表或Numpy数组组成的字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">28</span>]: data = &#123;<span class="string">&#x27;state&#x27;</span>: [<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>],<span class="string">&#x27;year&#x27;</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2</span></span><br><span class="line">    ...: 003],<span class="string">&#x27;pop&#x27;</span>: [<span class="number">1.5</span>, <span class="number">1.7</span>, <span class="number">3.6</span>, <span class="number">2.4</span>, <span class="number">2.9</span>, <span class="number">3.2</span>]&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: frame = pd.DataFrame(data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果 DataFrame 会自动加上索引。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">30</span>]: frame</span><br><span class="line">Out[<span class="number">30</span>]:</span><br><span class="line">    state  year  pop</span><br><span class="line"><span class="number">0</span>    Ohio  <span class="number">2000</span>  <span class="number">1.5</span></span><br><span class="line"><span class="number">1</span>    Ohio  <span class="number">2001</span>  <span class="number">1.7</span></span><br><span class="line"><span class="number">2</span>    Ohio  <span class="number">2002</span>  <span class="number">3.6</span></span><br><span class="line"><span class="number">3</span>  Nevada  <span class="number">2001</span>  <span class="number">2.4</span></span><br><span class="line"><span class="number">4</span>  Nevada  <span class="number">2002</span>  <span class="number">2.9</span></span><br><span class="line"><span class="number">5</span>  Nevada  <span class="number">2003</span>  <span class="number">3.2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于特别大的 DataFrame, head 方法会选取前5行。这里我用 <code>pd.head(frame)</code> 直接报错了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">32</span>]: frame.head()</span><br><span class="line">Out[<span class="number">32</span>]:</span><br><span class="line">    state  year  pop</span><br><span class="line"><span class="number">0</span>    Ohio  <span class="number">2000</span>  <span class="number">1.5</span></span><br><span class="line"><span class="number">1</span>    Ohio  <span class="number">2001</span>  <span class="number">1.7</span></span><br><span class="line"><span class="number">2</span>    Ohio  <span class="number">2002</span>  <span class="number">3.6</span></span><br><span class="line"><span class="number">3</span>  Nevada  <span class="number">2001</span>  <span class="number">2.4</span></span><br><span class="line"><span class="number">4</span>  Nevada  <span class="number">2002</span>  <span class="number">2.9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果制定了列序列，则 DataFrame 的列就会按照指定顺序进行排列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">33</span>]: pd.DataFrame(data, columns=[<span class="string">&#x27;year&#x27;</span>,<span class="string">&#x27;state&#x27;</span>,<span class="string">&#x27;pop&#x27;</span>])</span><br><span class="line">Out[<span class="number">33</span>]:</span><br><span class="line">   year   state  pop</span><br><span class="line"><span class="number">0</span>  <span class="number">2000</span>    Ohio  <span class="number">1.5</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2001</span>    Ohio  <span class="number">1.7</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2002</span>    Ohio  <span class="number">3.6</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2001</span>  Nevada  <span class="number">2.4</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2002</span>  Nevada  <span class="number">2.9</span></span><br><span class="line"><span class="number">5</span>  <span class="number">2003</span>  Nevada  <span class="number">3.2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果传入的列在数据中找不到，就会在结果中产生缺失值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">34</span>]: pd.DataFrame(data, columns=[<span class="string">&#x27;year&#x27;</span>,<span class="string">&#x27;state&#x27;</span>,<span class="string">&#x27;pop&#x27;</span>,<span class="string">&#x27;debt&#x27;</span>])</span><br><span class="line">Out[<span class="number">34</span>]:</span><br><span class="line">   year   state  pop debt</span><br><span class="line"><span class="number">0</span>  <span class="number">2000</span>    Ohio  <span class="number">1.5</span>  NaN</span><br><span class="line"><span class="number">1</span>  <span class="number">2001</span>    Ohio  <span class="number">1.7</span>  NaN</span><br><span class="line"><span class="number">2</span>  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>  NaN</span><br><span class="line"><span class="number">3</span>  <span class="number">2001</span>  Nevada  <span class="number">2.4</span>  NaN</span><br><span class="line"><span class="number">4</span>  <span class="number">2002</span>  Nevada  <span class="number">2.9</span>  NaN</span><br><span class="line"><span class="number">5</span>  <span class="number">2003</span>  Nevada  <span class="number">3.2</span>  NaN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过类似于字典的方式，可以将 DataFrame 的列获取为一个 Series。</p>
<p>返回的 Series 拥有原 DataFrame 相同的索引，且其 name 属性也已经被相应地设置好了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">35</span>]: frame[<span class="string">&#x27;state&#x27;</span>]</span><br><span class="line">Out[<span class="number">35</span>]:</span><br><span class="line"><span class="number">0</span>      Ohio</span><br><span class="line"><span class="number">1</span>      Ohio</span><br><span class="line"><span class="number">2</span>      Ohio</span><br><span class="line"><span class="number">3</span>    Nevada</span><br><span class="line"><span class="number">4</span>    Nevada</span><br><span class="line"><span class="number">5</span>    Nevada</span><br><span class="line">Name: state, dtype: <span class="built_in">object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>列可以通过赋值的方式进行修改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">37</span>]: frame[<span class="string">&#x27;debt&#x27;</span>] = <span class="number">16.5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: frame</span><br><span class="line">Out[<span class="number">38</span>]:</span><br><span class="line">    state  year  pop  debt</span><br><span class="line"><span class="number">0</span>    Ohio  <span class="number">2000</span>  <span class="number">1.5</span>  <span class="number">16.5</span></span><br><span class="line"><span class="number">1</span>    Ohio  <span class="number">2001</span>  <span class="number">1.7</span>  <span class="number">16.5</span></span><br><span class="line"><span class="number">2</span>    Ohio  <span class="number">2002</span>  <span class="number">3.6</span>  <span class="number">16.5</span></span><br><span class="line"><span class="number">3</span>  Nevada  <span class="number">2001</span>  <span class="number">2.4</span>  <span class="number">16.5</span></span><br><span class="line"><span class="number">4</span>  Nevada  <span class="number">2002</span>  <span class="number">2.9</span>  <span class="number">16.5</span></span><br><span class="line"><span class="number">5</span>  Nevada  <span class="number">2003</span>  <span class="number">3.2</span>  <span class="number">16.5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将列表或数组赋值给某个列时，其长度必须和 DataFrame 的长度相匹配。如果赋值的是一个 Series，就会精确匹配 DataFrame 的索引，所有的空位都被填上缺失值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">39</span>]: val = pd.Series([-<span class="number">1.2</span>, -<span class="number">1.5</span>, -<span class="number">1.7</span>], index=[<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: frame[<span class="string">&#x27;debt&#x27;</span>] = val</span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: frame</span><br><span class="line">Out[<span class="number">41</span>]:</span><br><span class="line">    state  year  pop  debt</span><br><span class="line"><span class="number">0</span>    Ohio  <span class="number">2000</span>  <span class="number">1.5</span>   NaN</span><br><span class="line"><span class="number">1</span>    Ohio  <span class="number">2001</span>  <span class="number">1.7</span>   NaN</span><br><span class="line"><span class="number">2</span>    Ohio  <span class="number">2002</span>  <span class="number">3.6</span>  -<span class="number">1.2</span></span><br><span class="line"><span class="number">3</span>  Nevada  <span class="number">2001</span>  <span class="number">2.4</span>   NaN</span><br><span class="line"><span class="number">4</span>  Nevada  <span class="number">2002</span>  <span class="number">2.9</span>  -<span class="number">1.5</span></span><br><span class="line"><span class="number">5</span>  Nevada  <span class="number">2003</span>  <span class="number">3.2</span>  -<span class="number">1.7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关键字 del 用于删除列。这里先添加一个新的布尔值的列，表示 state 是否为 ‘Ohio’</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">43</span>]: frame[<span class="string">&#x27;eastern&#x27;</span>] = frame[<span class="string">&#x27;state&#x27;</span>] == <span class="string">&#x27;Ohio&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: frame</span><br><span class="line">Out[<span class="number">44</span>]:</span><br><span class="line">    state  year  pop  debt  eastern</span><br><span class="line"><span class="number">0</span>    Ohio  <span class="number">2000</span>  <span class="number">1.5</span>   NaN     <span class="literal">True</span></span><br><span class="line"><span class="number">1</span>    Ohio  <span class="number">2001</span>  <span class="number">1.7</span>   NaN     <span class="literal">True</span></span><br><span class="line"><span class="number">2</span>    Ohio  <span class="number">2002</span>  <span class="number">3.6</span>  -<span class="number">1.2</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">3</span>  Nevada  <span class="number">2001</span>  <span class="number">2.4</span>   NaN    <span class="literal">False</span></span><br><span class="line"><span class="number">4</span>  Nevada  <span class="number">2002</span>  <span class="number">2.9</span>  -<span class="number">1.5</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">5</span>  Nevada  <span class="number">2003</span>  <span class="number">3.2</span>  -<span class="number">1.7</span>    <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>del 方法删除这列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">45</span>]: <span class="keyword">del</span> frame[<span class="string">&#x27;eastern&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: frame.columns</span><br><span class="line">Out[<span class="number">46</span>]: Index([<span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;debt&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：通过索引方式返回的列只是相应数据的视图而已，并不是副本。因此，对返回的Series所做的任何就地修改全都会反映到源DataFrame上。通过Series的copy方法即可指定复制列，</p>
</blockquote>
<p>另一种常见的数据形式是嵌套字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">47</span>]:  pop = &#123;<span class="string">&#x27;Nevada&#x27;</span>: &#123;<span class="number">2001</span>: <span class="number">2.4</span>, <span class="number">2002</span>: <span class="number">2.9</span>&#125;,</span><br><span class="line">    ...:         <span class="string">&#x27;Ohio&#x27;</span>: &#123;<span class="number">2000</span>: <span class="number">1.5</span>, <span class="number">2001</span>: <span class="number">1.7</span>, <span class="number">2002</span>: <span class="number">3.6</span>&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果嵌套字典传给 DataFrame， pandas 就会解释为：外层字典的键作为列，内层键则作为行索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">48</span>]: frame3 = pd.DataFrame(pop)</span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: frame3</span><br><span class="line">Out[<span class="number">49</span>]:</span><br><span class="line">      Nevada  Ohio</span><br><span class="line"><span class="number">2001</span>     <span class="number">2.4</span>   <span class="number">1.7</span></span><br><span class="line"><span class="number">2002</span>     <span class="number">2.9</span>   <span class="number">3.6</span></span><br><span class="line"><span class="number">2000</span>     NaN   <span class="number">1.5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你也可以使用类似NumPy数组的方法，对DataFrame进行转置（交换行和列）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">50</span>]: frame3.T</span><br><span class="line">Out[<span class="number">50</span>]:</span><br><span class="line">        <span class="number">2001</span>  <span class="number">2002</span>  <span class="number">2000</span></span><br><span class="line">Nevada   <span class="number">2.4</span>   <span class="number">2.9</span>   NaN</span><br><span class="line">Ohio     <span class="number">1.7</span>   <span class="number">3.6</span>   <span class="number">1.5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>行的顺序可能是乱的，可以指定索引顺序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">51</span>]: frame3 = pd.DataFrame(pop, index=[<span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2003</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: frame3</span><br><span class="line">Out[<span class="number">52</span>]:</span><br><span class="line">      Nevada  Ohio</span><br><span class="line"><span class="number">2001</span>     <span class="number">2.4</span>   <span class="number">1.7</span></span><br><span class="line"><span class="number">2002</span>     <span class="number">2.9</span>   <span class="number">3.6</span></span><br><span class="line"><span class="number">2003</span>     NaN   NaN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果设置了DataFrame 的index和columns的name属性，则这些信息也会被显示出来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: frame3.index.name = <span class="string">&#x27;year&#x27;</span>; frame3.columns.name = <span class="string">&#x27;state&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">57</span>]: frame3</span><br><span class="line">Out[<span class="number">57</span>]:</span><br><span class="line">state  Nevada  Ohio</span><br><span class="line">year</span><br><span class="line"><span class="number">2001</span>      <span class="number">2.4</span>   <span class="number">1.7</span></span><br><span class="line"><span class="number">2002</span>      <span class="number">2.9</span>   <span class="number">3.6</span></span><br><span class="line"><span class="number">2003</span>      NaN   NaN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>除此以外，DataFrame 函数可以接受 <strong>二维Numpy数组</strong>的输入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">58</span>]: a = np.arange(<span class="number">20</span>).reshape(<span class="number">4</span>,-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: a</span><br><span class="line">Out[<span class="number">59</span>]:</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>],</span><br><span class="line">       [<span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: test = pd.DataFrame(a)</span><br><span class="line"></span><br><span class="line">In [<span class="number">61</span>]: test</span><br><span class="line">Out[<span class="number">61</span>]:</span><br><span class="line">    <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span></span><br><span class="line"><span class="number">0</span>   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span></span><br><span class="line"><span class="number">1</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span></span><br><span class="line"><span class="number">2</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span></span><br><span class="line"><span class="number">3</span>  <span class="number">15</span>  <span class="number">16</span>  <span class="number">17</span>  <span class="number">18</span>  <span class="number">19</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>跟 Series 一样，values 属性也以二维 ndarray 的形式返回 DataFrame 中的数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">62</span>]: frame3.values</span><br><span class="line">Out[<span class="number">62</span>]:</span><br><span class="line">array([[<span class="number">2.4</span>, <span class="number">1.7</span>],</span><br><span class="line">       [<span class="number">2.9</span>, <span class="number">3.6</span>],</span><br><span class="line">       [nan, nan]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果 DataFrame 各列的数据类型不同，则值数组的 dtype 就会选用能兼容所有列的数据类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">64</span>]: frame.values</span><br><span class="line">Out[<span class="number">64</span>]:</span><br><span class="line">array([[<span class="string">&#x27;Ohio&#x27;</span>, <span class="number">2000</span>, <span class="number">1.5</span>, nan],</span><br><span class="line">       [<span class="string">&#x27;Ohio&#x27;</span>, <span class="number">2001</span>, <span class="number">1.7</span>, nan],</span><br><span class="line">       [<span class="string">&#x27;Ohio&#x27;</span>, <span class="number">2002</span>, <span class="number">3.6</span>, -<span class="number">1.2</span>],</span><br><span class="line">       [<span class="string">&#x27;Nevada&#x27;</span>, <span class="number">2001</span>, <span class="number">2.4</span>, nan],</span><br><span class="line">       [<span class="string">&#x27;Nevada&#x27;</span>, <span class="number">2002</span>, <span class="number">2.9</span>, -<span class="number">1.5</span>],</span><br><span class="line">       [<span class="string">&#x27;Nevada&#x27;</span>, <span class="number">2003</span>, <span class="number">3.2</span>, -<span class="number">1.7</span>]], dtype=<span class="built_in">object</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="基本功能">基本功能</h2>
<h3 id="重新索引">重新索引</h3>
<p>pandas 对象的一个重要方法是 reindex，其作用是创建一个新对象，它的数据符合新的索引。</p>
<p>看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">65</span>]: obj = pd.Series([<span class="number">4.5</span>, <span class="number">7.2</span>, -<span class="number">5.3</span>, <span class="number">3.6</span>], index=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: obj</span><br><span class="line">Out[<span class="number">66</span>]:</span><br><span class="line">d    <span class="number">4.5</span></span><br><span class="line">b    <span class="number">7.2</span></span><br><span class="line">a   -<span class="number">5.3</span></span><br><span class="line">c    <span class="number">3.6</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 <code>reindex</code> 方法进行重排。如果某个索引值当前不存在，就引入缺失值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">67</span>]: obj2 = obj.reindex([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: obj2</span><br><span class="line">Out[<span class="number">68</span>]:</span><br><span class="line">a   -<span class="number">5.3</span></span><br><span class="line">b    <span class="number">7.2</span></span><br><span class="line">c    <span class="number">3.6</span></span><br><span class="line">d    <span class="number">4.5</span></span><br><span class="line">e    NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于时间序列这样的有序数据，重新索引时可能需要做一些插值处理。method选项即可达到此目的，例如，使用ffill可以实现前向值填充：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">69</span>]: obj3 = pd.Series([<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;purple&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>], index=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: obj3</span><br><span class="line">Out[<span class="number">70</span>]:</span><br><span class="line"><span class="number">0</span>      blue</span><br><span class="line"><span class="number">2</span>    purple</span><br><span class="line"><span class="number">4</span>    yellow</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: obj3.reindex(<span class="built_in">range</span>(<span class="number">6</span>), method=<span class="string">&#x27;ffill&#x27;</span>)</span><br><span class="line">Out[<span class="number">71</span>]:</span><br><span class="line"><span class="number">0</span>      blue</span><br><span class="line"><span class="number">1</span>      blue</span><br><span class="line"><span class="number">2</span>    purple</span><br><span class="line"><span class="number">3</span>    purple</span><br><span class="line"><span class="number">4</span>    yellow</span><br><span class="line"><span class="number">5</span>    yellow</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于 DataFrame，reindex 可以修改行索引和列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">72</span>]: frame = pd.DataFrame(np.arange(<span class="number">9</span>).reshape((<span class="number">3</span>, <span class="number">3</span>)),</span><br><span class="line">    ...:                     index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">    ...:                     columns=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;California&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">73</span>]: frame</span><br><span class="line">Out[<span class="number">73</span>]:</span><br><span class="line">   Ohio  Texas  California</span><br><span class="line">a     <span class="number">0</span>      <span class="number">1</span>           <span class="number">2</span></span><br><span class="line">c     <span class="number">3</span>      <span class="number">4</span>           <span class="number">5</span></span><br><span class="line">d     <span class="number">6</span>      <span class="number">7</span>           <span class="number">8</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">74</span>]: frame2 = frame.reindex([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">75</span>]: frame2</span><br><span class="line">Out[<span class="number">75</span>]:</span><br><span class="line">   Ohio  Texas  California</span><br><span class="line">a   <span class="number">0.0</span>    <span class="number">1.0</span>         <span class="number">2.0</span></span><br><span class="line">b   NaN    NaN         NaN</span><br><span class="line">c   <span class="number">3.0</span>    <span class="number">4.0</span>         <span class="number">5.0</span></span><br><span class="line">d   <span class="number">6.0</span>    <span class="number">7.0</span>         <span class="number">8.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>列可以用 columns 关键字重新索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">76</span>]: frame3 = frame.reindex([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>], columns=[<span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Utah&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: frame3</span><br><span class="line">Out[<span class="number">77</span>]:</span><br><span class="line">   Texas  Utah</span><br><span class="line">a    <span class="number">1.0</span>   NaN</span><br><span class="line">b    NaN   NaN</span><br><span class="line">c    <span class="number">4.0</span>   NaN</span><br><span class="line">d    <span class="number">7.0</span>   NaN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="索引、选取和过滤">索引、选取和过滤</h3>
<p>Series 索引的工作方式类似于 Numpy 数组的索引，只不过 Series 的索引值不只是整数。下面是几个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">78</span>]: obj = pd.Series(np.arange(<span class="number">4.</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">79</span>]: obj</span><br><span class="line">Out[<span class="number">79</span>]:</span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: obj[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">Out[<span class="number">80</span>]: <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">81</span>]: obj[<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">81</span>]: <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">83</span>]: obj[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">83</span>]:</span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: obj[obj&lt;<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">84</span>]:</span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>利用标签的切片运算与普通的Python切片运算不同，其末端是包含的</strong>（不好，而且不优雅）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">85</span>]: obj[<span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">Out[<span class="number">85</span>]:</span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对 DataFrame 进行索引是 <strong>提取列</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">86</span>]: data = pd.DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>)),</span><br><span class="line">    ...:                     index=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>],</span><br><span class="line">    ...:                     columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: data</span><br><span class="line">Out[<span class="number">87</span>]:</span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: data[<span class="string">&#x27;two&#x27;</span>]</span><br><span class="line">Out[<span class="number">88</span>]:</span><br><span class="line">Ohio         <span class="number">1</span></span><br><span class="line">Colorado     <span class="number">5</span></span><br><span class="line">Utah         <span class="number">9</span></span><br><span class="line">New York    <span class="number">13</span></span><br><span class="line">Name: two, dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">89</span>]: data[[<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>]]</span><br><span class="line">Out[<span class="number">89</span>]:</span><br><span class="line">          two  three</span><br><span class="line">Ohio        <span class="number">1</span>      <span class="number">2</span></span><br><span class="line">Colorado    <span class="number">5</span>      <span class="number">6</span></span><br><span class="line">Utah        <span class="number">9</span>     <span class="number">10</span></span><br><span class="line">New York   <span class="number">13</span>     <span class="number">14</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还可以通过布尔型数组选取数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">93</span>]: data[data[<span class="string">&#x27;three&#x27;</span>]&gt;<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">93</span>]:</span><br><span class="line">          one  two  three  four</span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="用loc和iloc进行选取">用loc和iloc进行选取</h3>
<p>对于 DataFrame 的行的标签索引，可以使用轴标签（loc）或整数索引（iloc），从DataFrame选择行和列的子集。</p>
<p>作为一个初步示例，让我们通过标签选择一行多列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">94</span>]: data.loc[<span class="string">&#x27;Colorado&#x27;</span>, [<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]]</span><br><span class="line">Out[<span class="number">94</span>]:</span><br><span class="line">two      <span class="number">5</span></span><br><span class="line">three    <span class="number">6</span></span><br><span class="line">Name: Colorado, dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后用 iloc 和 整数进行选取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">95</span>]: data.iloc[<span class="number">2</span>,[<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">Out[<span class="number">95</span>]:</span><br><span class="line">four    <span class="number">11</span></span><br><span class="line">one      <span class="number">8</span></span><br><span class="line">two      <span class="number">9</span></span><br><span class="line">Name: Utah, dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: data.iloc[<span class="number">2</span>] <span class="comment"># 提取第3行</span></span><br><span class="line">Out[<span class="number">98</span>]:</span><br><span class="line">one       <span class="number">8</span></span><br><span class="line">two       <span class="number">9</span></span><br><span class="line">three    <span class="number">10</span></span><br><span class="line">four     <span class="number">11</span></span><br><span class="line">Name: Utah, dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">99</span>]: data.iloc[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">Out[<span class="number">99</span>]:</span><br><span class="line">          four  one  two</span><br><span class="line">Colorado     <span class="number">7</span>    <span class="number">4</span>    <span class="number">5</span></span><br><span class="line">Utah        <span class="number">11</span>    <span class="number">8</span>    <span class="number">9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="整数索引">整数索引</h3>
<p>pandas 处理整数索引和 Python 内置的语法不同。例如，下面这个例子会出错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">101</span>]: ser = pd.Series(np.arange(<span class="number">3.</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">102</span>]: ser</span><br><span class="line">Out[<span class="number">102</span>]:</span><br><span class="line"><span class="number">0</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">2.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: ser[-<span class="number">1</span>]</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">KeyError                                  Traceback (most recent call last)</span><br><span class="line">……</span><br><span class="line">KeyError: -<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的逻辑是因为本身 ser有 0,1,2 组成的索引， 因此 pandas 认为 -1 不在所有索引中，便会出现报错。</p>
<p>解决方法是，<strong>所有需要使用索引的地方，需要注明使用 loc 还是 iloc</strong> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">106</span>]: ser.iloc[-<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">106</span>]: <span class="number">2.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="算术运算和数据对齐">算术运算和数据对齐</h3>
<p>pandas 可以对<strong>不同索引</strong>的对象进行算术计算。如果两个对象有不同的索引对，则结果的索引是两个对象所有索引的<strong>并集</strong>。</p>
<p>来看一个简单的例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">107</span>]: s1 = pd.Series([<span class="number">7.3</span>, -<span class="number">2.5</span>, <span class="number">3.4</span>, <span class="number">1.5</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">108</span>]: s2 = pd.Series([-<span class="number">2.1</span>, <span class="number">3.6</span>, -<span class="number">1.5</span>, <span class="number">4</span>, <span class="number">3.1</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">109</span>]: s1</span><br><span class="line">Out[<span class="number">109</span>]:</span><br><span class="line">a    <span class="number">7.3</span></span><br><span class="line">c   -<span class="number">2.5</span></span><br><span class="line">d    <span class="number">3.4</span></span><br><span class="line">e    <span class="number">1.5</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">110</span>]: s2</span><br><span class="line">Out[<span class="number">110</span>]:</span><br><span class="line">a   -<span class="number">2.1</span></span><br><span class="line">c    <span class="number">3.6</span></span><br><span class="line">e   -<span class="number">1.5</span></span><br><span class="line">f    <span class="number">4.0</span></span><br><span class="line">g    <span class="number">3.1</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">111</span>]: s1 + s2</span><br><span class="line">Out[<span class="number">111</span>]:</span><br><span class="line">a    <span class="number">5.2</span></span><br><span class="line">c    <span class="number">1.1</span></span><br><span class="line">d    NaN</span><br><span class="line">e    <span class="number">0.0</span></span><br><span class="line">f    NaN</span><br><span class="line">g    NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>自动的数据对齐操作在不重叠的索引处引入了NA值。</p>
<p>对于 DataFrame， 对齐操作会同时发生在行和列上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">4</span>]: df1 = pd.DataFrame(np.arange(<span class="number">9.</span>).reshape((<span class="number">3</span>, <span class="number">3</span>)), columns=<span class="built_in">list</span>(<span class="string">&#x27;bcd&#x27;</span>),</span><br><span class="line">   ...:     index=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: df2 = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)), columns=<span class="built_in">list</span>(<span class="string">&#x27;bde&#x27;</span>),</span><br><span class="line">   ...:     index=[<span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Oregon&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: df1</span><br><span class="line">Out[<span class="number">6</span>]:</span><br><span class="line">            b    c    d</span><br><span class="line">Ohio      <span class="number">0.0</span>  <span class="number">1.0</span>  <span class="number">2.0</span></span><br><span class="line">Texas     <span class="number">3.0</span>  <span class="number">4.0</span>  <span class="number">5.0</span></span><br><span class="line">Colorado  <span class="number">6.0</span>  <span class="number">7.0</span>  <span class="number">8.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: df2</span><br><span class="line">Out[<span class="number">7</span>]:</span><br><span class="line">          b     d     e</span><br><span class="line">Utah    <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>   <span class="number">4.0</span>   <span class="number">5.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: df1 + df2</span><br><span class="line">Out[<span class="number">8</span>]:</span><br><span class="line">            b   c     d   e</span><br><span class="line">Colorado  NaN NaN   NaN NaN</span><br><span class="line">Ohio      <span class="number">3.0</span> NaN   <span class="number">6.0</span> NaN</span><br><span class="line">Oregon    NaN NaN   NaN NaN</span><br><span class="line">Texas     <span class="number">9.0</span> NaN  <span class="number">12.0</span> NaN</span><br><span class="line">Utah      NaN NaN   NaN NaN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="在算术方法中填充值">在算术方法中填充值</h3>
<p>在对不同索引的对象进行算术运算时，你可能希望当一个对象中某个轴标签在另一个对象中找不到时填充一个特殊值（比如0）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: df1 = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">3</span>, <span class="number">4</span>)),</span><br><span class="line">    ...:     columns=<span class="built_in">list</span>(<span class="string">&#x27;abcd&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: df2 = pd.DataFrame(np.arange(<span class="number">20.</span>).reshape((<span class="number">4</span>, <span class="number">5</span>)),</span><br><span class="line">    ...:     columns=<span class="built_in">list</span>(<span class="string">&#x27;abcde&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: df1</span><br><span class="line">Out[<span class="number">12</span>]:</span><br><span class="line">     a    b     c     d</span><br><span class="line"><span class="number">0</span>  <span class="number">0.0</span>  <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">3.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4.0</span>  <span class="number">5.0</span>   <span class="number">6.0</span>   <span class="number">7.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">8.0</span>  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: df2.loc[<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>] = np.nan <span class="comment"># 将[1,&#x27;b&#x27;]位置的值改为 nan</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: df2</span><br><span class="line">Out[<span class="number">15</span>]:</span><br><span class="line">      a     b     c     d     e</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">3.0</span>   <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">5.0</span>   NaN   <span class="number">7.0</span>   <span class="number">8.0</span>   <span class="number">9.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">10.0</span>  <span class="number">11.0</span>  <span class="number">12.0</span>  <span class="number">13.0</span>  <span class="number">14.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">15.0</span>  <span class="number">16.0</span>  <span class="number">17.0</span>  <span class="number">18.0</span>  <span class="number">19.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将他们相加时，没有重叠的位置就会产生NA值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">16</span>]: df1 + df2</span><br><span class="line">Out[<span class="number">16</span>]:</span><br><span class="line">      a     b     c     d   e</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>   <span class="number">2.0</span>   <span class="number">4.0</span>   <span class="number">6.0</span> NaN</span><br><span class="line"><span class="number">1</span>   <span class="number">9.0</span>   NaN  <span class="number">13.0</span>  <span class="number">15.0</span> NaN</span><br><span class="line"><span class="number">2</span>  <span class="number">18.0</span>  <span class="number">20.0</span>  <span class="number">22.0</span>  <span class="number">24.0</span> NaN</span><br><span class="line"><span class="number">3</span>   NaN   NaN   NaN   NaN NaN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 df1 的 add 方法，传入 df2 以及一个 fill_value 参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: df1.add(df2,fill_value=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">17</span>]:</span><br><span class="line">      a     b     c     d     e</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>   <span class="number">2.0</span>   <span class="number">4.0</span>   <span class="number">6.0</span>   <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">9.0</span>   <span class="number">5.0</span>  <span class="number">13.0</span>  <span class="number">15.0</span>   <span class="number">9.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">18.0</span>  <span class="number">20.0</span>  <span class="number">22.0</span>  <span class="number">24.0</span>  <span class="number">14.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">15.0</span>  <span class="number">16.0</span>  <span class="number">17.0</span>  <span class="number">18.0</span>  <span class="number">19.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下表列出了 Series 和 DataFrame 的算术方法。它们每个都有一个副本，以字母r开头，它会翻转参数。</p>
<p><img src="8.png" alt="8"></p>
<p>因此这两个语句是等价的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: <span class="number">1</span>/df1</span><br><span class="line">Out[<span class="number">18</span>]:</span><br><span class="line">       a         b         c         d</span><br><span class="line"><span class="number">0</span>    inf  <span class="number">1.000000</span>  <span class="number">0.500000</span>  <span class="number">0.333333</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.250</span>  <span class="number">0.200000</span>  <span class="number">0.166667</span>  <span class="number">0.142857</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.125</span>  <span class="number">0.111111</span>  <span class="number">0.100000</span>  <span class="number">0.090909</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: df1.rdiv(<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">19</span>]:</span><br><span class="line">       a         b         c         d</span><br><span class="line"><span class="number">0</span>    inf  <span class="number">1.000000</span>  <span class="number">0.500000</span>  <span class="number">0.333333</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.250</span>  <span class="number">0.200000</span>  <span class="number">0.166667</span>  <span class="number">0.142857</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.125</span>  <span class="number">0.111111</span>  <span class="number">0.100000</span>  <span class="number">0.090909</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>与此类似，在对 Series 或 DataFrame 重新索引时，也可以指定一个填充值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">20</span>]: df1.reindex(columns=df2.columns, fill_value=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">20</span>]:</span><br><span class="line">     a    b     c     d  e</span><br><span class="line"><span class="number">0</span>  <span class="number">0.0</span>  <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">3.0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4.0</span>  <span class="number">5.0</span>   <span class="number">6.0</span>   <span class="number">7.0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">8.0</span>  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span>  <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="DataFrame-和-Series之间的运算">DataFrame 和 Series之间的运算</h3>
<p>跟不同维度的 Numpy 数组一样，DataFrame 和 Series 之间算术运算也是有明确规定的。</p>
<p>先看一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">21</span>]: frame = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)),</span><br><span class="line">    ...:     columns=<span class="built_in">list</span>(<span class="string">&#x27;bde&#x27;</span>),</span><br><span class="line">    ...:     index=[<span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Oregon&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: series = frame.iloc[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: frame</span><br><span class="line">Out[<span class="number">23</span>]:</span><br><span class="line">          b     d     e</span><br><span class="line">Utah    <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>   <span class="number">4.0</span>   <span class="number">5.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: series</span><br><span class="line">Out[<span class="number">24</span>]:</span><br><span class="line">b    <span class="number">0.0</span></span><br><span class="line">d    <span class="number">1.0</span></span><br><span class="line">e    <span class="number">2.0</span></span><br><span class="line">Name: Utah, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>默认情况下，DataFrame 和 Serious 之间的算术运算会将 Series 的索引匹配到 DataFrame 的列，然后沿着行一直向下广播：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">25</span>]: frame - series</span><br><span class="line">Out[<span class="number">25</span>]:</span><br><span class="line">          b    d    e</span><br><span class="line">Utah    <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">0.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>  <span class="number">3.0</span>  <span class="number">3.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>  <span class="number">6.0</span>  <span class="number">6.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">9.0</span>  <span class="number">9.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果某个索引值在 DataFrame 的列或 Series 的索引中找不到，则结果会是二者的<strong>并集</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">27</span>]: series2 = pd.Series(<span class="built_in">range</span>(<span class="number">3</span>),index=[<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: frame + series2</span><br><span class="line">Out[<span class="number">28</span>]:</span><br><span class="line">          b   d     e   f</span><br><span class="line">Utah    <span class="number">0.0</span> NaN   <span class="number">3.0</span> NaN</span><br><span class="line">Ohio    <span class="number">3.0</span> NaN   <span class="number">6.0</span> NaN</span><br><span class="line">Texas   <span class="number">6.0</span> NaN   <span class="number">9.0</span> NaN</span><br><span class="line">Oregon  <span class="number">9.0</span> NaN  <span class="number">12.0</span> NaN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你希望在列上广播，则必须使用算术方法。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">29</span>]: series3 = frame[<span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: series3</span><br><span class="line">Out[<span class="number">30</span>]:</span><br><span class="line">Utah       <span class="number">1.0</span></span><br><span class="line">Ohio       <span class="number">4.0</span></span><br><span class="line">Texas      <span class="number">7.0</span></span><br><span class="line">Oregon    <span class="number">10.0</span></span><br><span class="line">Name: d, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: frame</span><br><span class="line">Out[<span class="number">31</span>]:</span><br><span class="line">          b     d     e</span><br><span class="line">Utah    <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>   <span class="number">4.0</span>   <span class="number">5.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: frame.sub(series3, axis=<span class="string">&#x27;index&#x27;</span>)</span><br><span class="line">Out[<span class="number">32</span>]:</span><br><span class="line">          b    d    e</span><br><span class="line">Utah   -<span class="number">1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br><span class="line">Ohio   -<span class="number">1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br><span class="line">Texas  -<span class="number">1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br><span class="line">Oregon -<span class="number">1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>传入的轴号就是希望匹配的轴。在本例中，我们的目的是匹配 DataFrame 的行索引（axis = ‘index’ or axis = 0）并进行广播。</p>
<h3 id="函数应用和映射">函数应用和映射</h3>
<p>Numpy 的 ufuncs （元素级数组方法）也可以用于操作 pandas 对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">3</span>]: frame = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">3</span>), columns=<span class="built_in">list</span>(<span class="string">&#x27;bde&#x27;</span>),</span><br><span class="line">   ...:                       index=[<span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;Oregon&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: frame</span><br><span class="line">Out[<span class="number">4</span>]:</span><br><span class="line">               b         d         e</span><br><span class="line">Utah    <span class="number">0.486038</span>  <span class="number">0.543491</span> -<span class="number">0.088382</span></span><br><span class="line">Ohio   -<span class="number">1.394360</span> -<span class="number">0.016164</span> -<span class="number">0.886950</span></span><br><span class="line">Texas  -<span class="number">0.625081</span> -<span class="number">0.671539</span>  <span class="number">1.164966</span></span><br><span class="line">Oregon -<span class="number">1.180228</span> -<span class="number">0.029372</span> -<span class="number">0.368598</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: np.<span class="built_in">abs</span>(frame)</span><br><span class="line">Out[<span class="number">5</span>]:</span><br><span class="line">               b         d         e</span><br><span class="line">Utah    <span class="number">0.486038</span>  <span class="number">0.543491</span>  <span class="number">0.088382</span></span><br><span class="line">Ohio    <span class="number">1.394360</span>  <span class="number">0.016164</span>  <span class="number">0.886950</span></span><br><span class="line">Texas   <span class="number">0.625081</span>  <span class="number">0.671539</span>  <span class="number">1.164966</span></span><br><span class="line">Oregon  <span class="number">1.180228</span>  <span class="number">0.029372</span>  <span class="number">0.368598</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一个常见的操作是，将函数应用到由各列或行所形成的一维数组上。DataFrame 的 apply 方法即可实现此功能：</p>
<p>下式计算每列的最大值和最小值的差。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">6</span>]: f = <span class="keyword">lambda</span> x: x.<span class="built_in">max</span>() - x.<span class="built_in">min</span>()</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: frame.apply(f)</span><br><span class="line">Out[<span class="number">7</span>]:</span><br><span class="line">b    <span class="number">1.880398</span></span><br><span class="line">d    <span class="number">1.215029</span></span><br><span class="line">e    <span class="number">2.051916</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果给 apply 传递参数 <code>axis='columns'</code> ，这个函数会在每行执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">8</span>]: frame.apply(f, axis=<span class="string">&#x27;columns&#x27;</span>)</span><br><span class="line">Out[<span class="number">8</span>]:</span><br><span class="line">Utah      <span class="number">0.631873</span></span><br><span class="line">Ohio      <span class="number">1.378196</span></span><br><span class="line">Texas     <span class="number">1.836504</span></span><br><span class="line">Oregon    <span class="number">1.150856</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>传递到 apply 的函数不是必须返回一个标量，还可以返回由多个值组成的 Series :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">9</span>]: <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">   ...:     <span class="keyword">return</span> pd.Series([x.<span class="built_in">min</span>(), x.<span class="built_in">max</span>()], index=[<span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;max&#x27;</span>])</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: frame.apply(f)</span><br><span class="line">Out[<span class="number">10</span>]:</span><br><span class="line">            b         d         e</span><br><span class="line"><span class="built_in">min</span> -<span class="number">1.394360</span> -<span class="number">0.671539</span> -<span class="number">0.886950</span></span><br><span class="line"><span class="built_in">max</span>  <span class="number">0.486038</span>  <span class="number">0.543491</span>  <span class="number">1.164966</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>元素级的 Python 函数也可以用。假如你想得到 frame 中各个浮点值得格式化字符串，使用 applymap 即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">11</span>]: <span class="built_in">format</span> = <span class="keyword">lambda</span> x:<span class="string">f&quot;<span class="subst">&#123;x:<span class="number">0.2</span>f&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: frame.applymap(<span class="built_in">format</span>)</span><br><span class="line">Out[<span class="number">12</span>]:</span><br><span class="line">            b      d      e</span><br><span class="line">Utah     <span class="number">0.49</span>   <span class="number">0.54</span>  -<span class="number">0.09</span></span><br><span class="line">Ohio    -<span class="number">1.39</span>  -<span class="number">0.02</span>  -<span class="number">0.89</span></span><br><span class="line">Texas   -<span class="number">0.63</span>  -<span class="number">0.67</span>   <span class="number">1.16</span></span><br><span class="line">Oregon  -<span class="number">1.18</span>  -<span class="number">0.03</span>  -<span class="number">0.37</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之所以叫做 applymap ， 是因为 Series 有一个用于应用元素级函数得map方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: frame[<span class="string">&#x27;e&#x27;</span>].<span class="built_in">map</span>(<span class="built_in">format</span>)</span><br><span class="line">Out[<span class="number">13</span>]:</span><br><span class="line">Utah      -<span class="number">0.09</span></span><br><span class="line">Ohio      -<span class="number">0.89</span></span><br><span class="line">Texas      <span class="number">1.16</span></span><br><span class="line">Oregon    -<span class="number">0.37</span></span><br><span class="line">Name: e, dtype: <span class="built_in">object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="排序和排名">排序和排名</h3>
<p>使用 sort_index 方法，会返回一个已排序的新对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">14</span>]: obj = pd.Series(<span class="built_in">range</span>(<span class="number">4</span>), index=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: obj.sort_index()</span><br><span class="line">Out[<span class="number">15</span>]:</span><br><span class="line">a    <span class="number">1</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">d    <span class="number">0</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于 DataFrame ，则可以根据任意一个轴上的索引进行排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">16</span>]: frame = pd.DataFrame(np.arange(<span class="number">8</span>).reshape((<span class="number">2</span>, <span class="number">4</span>)),</span><br><span class="line">    ...:         index=[<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">    ...:         columns=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: frame</span><br><span class="line">Out[<span class="number">17</span>]:</span><br><span class="line">       d  a  b  c</span><br><span class="line">three  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line">one    <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: frame.sort_index()</span><br><span class="line">Out[<span class="number">18</span>]:</span><br><span class="line">       d  a  b  c</span><br><span class="line">one    <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></span><br><span class="line">three  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: frame.sort_index(axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">19</span>]:</span><br><span class="line">       a  b  c  d</span><br><span class="line">three  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">0</span></span><br><span class="line">one    <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>数据默认是按升序排序的，但也可以降序排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">20</span>]: frame.sort_index(axis=<span class="number">1</span>, ascending=<span class="literal">False</span>)</span><br><span class="line">Out[<span class="number">20</span>]:</span><br><span class="line">       d  c  b  a</span><br><span class="line">three  <span class="number">0</span>  <span class="number">3</span>  <span class="number">2</span>  <span class="number">1</span></span><br><span class="line">one    <span class="number">4</span>  <span class="number">7</span>  <span class="number">6</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>若要按值对 Series 进行排序，可以使用 sort_values 方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">21</span>]: obj = pd.Series([<span class="number">4</span>,<span class="number">7</span>,-<span class="number">3</span>,<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: obj.sort_values()</span><br><span class="line">Out[<span class="number">22</span>]:</span><br><span class="line"><span class="number">2</span>   -<span class="number">3</span></span><br><span class="line"><span class="number">3</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>    <span class="number">4</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在排序时，任何缺失值默认都会被放在Series 的末尾：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">23</span>]: obj = pd.Series([<span class="number">4</span>, np.nan, <span class="number">7</span>, np.nan, -<span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: obj.sort_values()</span><br><span class="line">Out[<span class="number">24</span>]:</span><br><span class="line"><span class="number">4</span>   -<span class="number">3.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">0</span>    <span class="number">4.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">7.0</span></span><br><span class="line"><span class="number">1</span>    NaN</span><br><span class="line"><span class="number">3</span>    NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当排序一个 DataFrame 时，你可能希望根据一个或多个列中的值进行排序。将一个或多个列的名字传递给 sort_values 的 by 选项即可达到这个目的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">25</span>]: frame = pd.DataFrame(&#123;<span class="string">&#x27;b&#x27;</span>: [<span class="number">4</span>, <span class="number">7</span>, -<span class="number">3</span>, <span class="number">2</span>], <span class="string">&#x27;a&#x27;</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: frame</span><br><span class="line">Out[<span class="number">26</span>]:</span><br><span class="line">   b  a</span><br><span class="line"><span class="number">0</span>  <span class="number">4</span>  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">7</span>  <span class="number">1</span></span><br><span class="line"><span class="number">2</span> -<span class="number">3</span>  <span class="number">0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2</span>  <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: frame.sort_values(by=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">Out[<span class="number">27</span>]:</span><br><span class="line">   b  a</span><br><span class="line"><span class="number">2</span> -<span class="number">3</span>  <span class="number">0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2</span>  <span class="number">1</span></span><br><span class="line"><span class="number">0</span>  <span class="number">4</span>  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">7</span>  <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要根据多个列进行排序，传入名称的列表即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">28</span>]: frame.sort_values(by=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">Out[<span class="number">28</span>]:</span><br><span class="line">   b  a</span><br><span class="line"><span class="number">2</span> -<span class="number">3</span>  <span class="number">0</span></span><br><span class="line"><span class="number">0</span>  <span class="number">4</span>  <span class="number">0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2</span>  <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  <span class="number">7</span>  <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>rank 方法可以给出所有元素的排名，相同的元素会分配一个<strong>平均排名</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">29</span>]: obj = pd.Series([<span class="number">7</span>, -<span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: obj.rank()</span><br><span class="line">Out[<span class="number">30</span>]:</span><br><span class="line"><span class="number">0</span>    <span class="number">6.5</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">6.5</span></span><br><span class="line"><span class="number">3</span>    <span class="number">4.5</span></span><br><span class="line"><span class="number">4</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">6</span>    <span class="number">4.5</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以根据值在原数据中出现的顺序给出排名：（相同值的元素按照出现前后排名）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">31</span>]: obj.rank(method=<span class="string">&#x27;first&#x27;</span>)</span><br><span class="line">Out[<span class="number">31</span>]:</span><br><span class="line"><span class="number">0</span>    <span class="number">6.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">7.0</span></span><br><span class="line"><span class="number">3</span>    <span class="number">4.0</span></span><br><span class="line"><span class="number">4</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">6</span>    <span class="number">5.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，条目0和2没有使用平均排名6.5，它们被设成了6和7，因为数据中标签0位于标签2的前面。</p>
<p>你也可以按降序进行排名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">32</span>]: obj.rank(ascending=<span class="literal">False</span>, method=<span class="string">&#x27;first&#x27;</span>)</span><br><span class="line">Out[<span class="number">32</span>]:</span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">4</span>    <span class="number">5.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">6.0</span></span><br><span class="line"><span class="number">6</span>    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>method 选项所有可用的值如下：</p>
<p><img src="9.png" alt="9"></p>
<p>DataFrame 可以在行或者列上计算排名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">34</span>]: frame = pd.DataFrame(&#123;<span class="string">&#x27;b&#x27;</span>: [<span class="number">4.3</span>, <span class="number">7</span>, -<span class="number">3</span>, <span class="number">2</span>], <span class="string">&#x27;a&#x27;</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">    ...:                         <span class="string">&#x27;c&#x27;</span>: [-<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, -<span class="number">2.5</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: frame</span><br><span class="line">Out[<span class="number">35</span>]:</span><br><span class="line">     b  a    c</span><br><span class="line"><span class="number">0</span>  <span class="number">4.3</span>  <span class="number">0</span> -<span class="number">2.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">7.0</span>  <span class="number">1</span>  <span class="number">5.0</span></span><br><span class="line"><span class="number">2</span> -<span class="number">3.0</span>  <span class="number">0</span>  <span class="number">8.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2.0</span>  <span class="number">1</span> -<span class="number">2.5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: frame.rank(axis=<span class="string">&#x27;columns&#x27;</span>)</span><br><span class="line">Out[<span class="number">36</span>]:</span><br><span class="line">     b    a    c</span><br><span class="line"><span class="number">0</span>  <span class="number">3.0</span>  <span class="number">2.0</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">3.0</span>  <span class="number">1.0</span>  <span class="number">2.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">1.0</span>  <span class="number">2.0</span>  <span class="number">3.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">3.0</span>  <span class="number">2.0</span>  <span class="number">1.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="汇总和计算描述统计">汇总和计算描述统计</h2>
<p>numpy 的统计函数只要含有缺失值，那么结果就是 <strong>nan</strong> :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">38</span>]: a = np.array([<span class="number">1</span>,<span class="number">2</span>,np.nan,np.nan])</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: a</span><br><span class="line">Out[<span class="number">39</span>]: array([ <span class="number">1.</span>,  <span class="number">2.</span>, nan, nan])</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: a.<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">40</span>]: nan</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Pandas 的相应的方法会自动过滤缺失值进行计算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">41</span>]: df = pd.DataFrame([[<span class="number">1.4</span>, np.nan], [<span class="number">7.1</span>, -<span class="number">4.5</span>],</span><br><span class="line">    ...:                     [np.nan, np.nan], [<span class="number">0.75</span>, -<span class="number">1.3</span>]],</span><br><span class="line">    ...:                     index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">    ...:                     columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: df</span><br><span class="line">Out[<span class="number">42</span>]:</span><br><span class="line">    one  two</span><br><span class="line">a  <span class="number">1.40</span>  NaN</span><br><span class="line">b  <span class="number">7.10</span> -<span class="number">4.5</span></span><br><span class="line">c   NaN  NaN</span><br><span class="line">d  <span class="number">0.75</span> -<span class="number">1.3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>调用 DataFrame 的 sum 方法将会返回一个含有列的和的 Series :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">43</span>]: df.<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">43</span>]:</span><br><span class="line">one    <span class="number">9.25</span></span><br><span class="line">two   -<span class="number">5.80</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>传入 axis = ‘columns’ 或 axis = 1 将会按行进行求和计算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">44</span>]: df.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">44</span>]:</span><br><span class="line">a    <span class="number">1.40</span></span><br><span class="line">b    <span class="number">2.60</span></span><br><span class="line">c    <span class="number">0.00</span></span><br><span class="line">d   -<span class="number">0.55</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>NA值会自动被排除，除非整个切片都是NA。通过 skipna 选项可以禁用该功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">45</span>]: df.mean(axis=<span class="string">&#x27;columns&#x27;</span>, skipna=<span class="literal">False</span>)</span><br><span class="line">Out[<span class="number">45</span>]:</span><br><span class="line">a      NaN</span><br><span class="line">b    <span class="number">1.300</span></span><br><span class="line">c      NaN</span><br><span class="line">d   -<span class="number">0.275</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 describe 方法可以产生多个汇总统计：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">46</span>]: df.describe()</span><br><span class="line">Out[<span class="number">46</span>]:</span><br><span class="line">            one       two</span><br><span class="line">count  <span class="number">3.000000</span>  <span class="number">2.000000</span></span><br><span class="line">mean   <span class="number">3.083333</span> -<span class="number">2.900000</span></span><br><span class="line">std    <span class="number">3.493685</span>  <span class="number">2.262742</span></span><br><span class="line"><span class="built_in">min</span>    <span class="number">0.750000</span> -<span class="number">4.500000</span></span><br><span class="line"><span class="number">25</span>%    <span class="number">1.075000</span> -<span class="number">3.700000</span></span><br><span class="line"><span class="number">50</span>%    <span class="number">1.400000</span> -<span class="number">2.900000</span></span><br><span class="line"><span class="number">75</span>%    <span class="number">4.250000</span> -<span class="number">2.100000</span></span><br><span class="line"><span class="built_in">max</span>    <span class="number">7.100000</span> -<span class="number">1.300000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于非数值型数据，describe会产生另外一种汇总统计：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">47</span>]: obj = pd.Series([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>] * <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: obj.describe()</span><br><span class="line">Out[<span class="number">48</span>]:</span><br><span class="line">count     <span class="number">16</span></span><br><span class="line">unique     <span class="number">3</span></span><br><span class="line">top        a</span><br><span class="line">freq       <span class="number">8</span></span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下表为所有与描述统计相关的方法。</p>
<p><img src="10.png" alt="9"></p>
<h3 id="相关系数与协方差">相关系数与协方差</h3>
<p>首先，这里数据中的 return 是一个 DataFrame</p>
<p><img src="11.png" alt="9"></p>
<p>两个Series 之间的相关系数 ( corr ) ，协方差 ( cov ) ，举例如下：</p>
<p><img src="12.png" alt="9"></p>
<p>DataFrame 的 corr 方法 和 cov 方法将返回相关系数矩阵/协方差矩阵</p>
<p><img src="13.png" alt="9"></p>
<p>DataFrame 的 corrwith 方法可以计算某列与这个DataFrame所有列的相关系数</p>
<p><img src="14.png" alt="9"></p>
<p>DataFrame 的 corrwith 方法如果传入另一个 DataFrame ，那么就会计算两个 DataFrame 中相同列名配对的相关系数。</p>
<p>如果传入axis='columns’即可按行进行计算。</p>
<h3 id="唯一值、值计数以及成员资格">唯一值、值计数以及成员资格</h3>
<ul>
<li>unique() : 去重，获得未排序的唯一值</li>
<li>value_counts() : 计数</li>
<li>isin() : 判断成员资格</li>
</ul>
<p>去重举例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">7</span>]: obj = pd.Series([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: uniques = obj.unique()</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: uniques</span><br><span class="line">Out[<span class="number">9</span>]: array([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], dtype=<span class="built_in">object</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>计数举例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: obj.value_counts()</span><br><span class="line">Out[<span class="number">10</span>]:</span><br><span class="line">a    <span class="number">3</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">d    <span class="number">1</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>isin 判断是否在集合中，可以用于过滤 Series 或 DataFrame</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">11</span>]: mask = obj.isin([<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: mask</span><br><span class="line">Out[<span class="number">12</span>]:</span><br><span class="line"><span class="number">0</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">1</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">3</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">4</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">5</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">6</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">7</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">8</span>     <span class="literal">True</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: obj[mask]</span><br><span class="line">Out[<span class="number">13</span>]:</span><br><span class="line"><span class="number">0</span>    c</span><br><span class="line"><span class="number">5</span>    b</span><br><span class="line"><span class="number">6</span>    b</span><br><span class="line"><span class="number">7</span>    c</span><br><span class="line"><span class="number">8</span>    c</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>文件读写</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.read_table(<span class="string">&quot;temp.mibs&quot;</span>, header=<span class="literal">None</span>, sep=<span class="string">&#x27;\s+&#x27;</span>) </span><br><span class="line"></span><br><span class="line">df = pd.read_table(<span class="string">&quot;qc.raw&quot;</span>, header=<span class="number">0</span>, sep=<span class="string">&#x27;\s+&#x27;</span>, na_values=[<span class="string">&#x27;NA&#x27;</span>]) </span><br><span class="line">df.fillna(<span class="number">3</span>, inplace=<span class="literal">True</span>) <span class="comment"># 缺失值填充为3，原地修改</span></span><br><span class="line"></span><br><span class="line">data.to_csv(<span class="string">&quot;file.csv&quot;</span>, index=<span class="literal">False</span>, header=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h2 id="读取-Excel">读取 Excel</h2>
<p>两种读取 Excel 方式，第一种使用 ExcelFile 方法，可以读取一个Excel 的多个 sheet</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xlsx = pd.ExcelFile(<span class="string">&#x27;examples/ex1.xlsx&#x27;</span>)</span><br><span class="line">pd.read_excel(xlsx, <span class="string">&#x27;Sheet1&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>你也可以将文件名直接传递到 pandas.read_excel :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame = pd.read_excel(<span class="string">&#x27;examples/ex1.xlsx&#x27;</span>, <span class="string">&#x27;Sheet1&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>如果要将 pandas 数据写入为 Excel 格式，你必须首先创建一个 ExcelWriter , 然后使用 pandas 对象的 to_excel 方法将数据写入到其中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">writer = pd.ExcelWriter(<span class="string">&#x27;examples/ex2.xlsx&#x27;</span>)</span><br><span class="line">frame.to_excel(writer, <span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line">writer.save()</span><br></pre></td></tr></table></figure>
<p>而也可以直接传递文件路径到 to_excel 函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame.to_excel(<span class="string">&#x27;examples/ex2.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="数据库交互">数据库交互</h2>
<p>在商业场景下，大多数数据可能不是存储在文本或 Excel 文件中。基于 SQL 的 关系型数据库使用非常广泛，其他一些数据库也很流行。数据库的选择通常取决于新能、数据完整性以及应用程序的伸缩性需求。</p>
<p>将数据从 SQL 加载到 DataFrame 的过程很简单，此外 pandas 还有一些能够简化该过程的函数。例如，这里使用 SQLite 数据库（通过 python 内置的 sqlite3 驱动器）</p>
<p>后面暂时没看懂……</p>
<h1>数据清洗和准备</h1>
<h2 id="处理缺失数据">处理缺失数据</h2>
<p>在许多数据分析工作中，缺失数据是经常发生的。pandas 的目标之一就是尽量轻松地处理缺失数据。例如，pandas 对象的所有描述性统计默认都不包括缺失数据。</p>
<p>对于数值数据，pandas 使用浮点值 NaN (Not a Number) 表示缺失数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">22</span>]: string_data = pd.Series([<span class="string">&#x27;aardvark&#x27;</span>, <span class="string">&#x27;artichoke&#x27;</span>, np.nan, <span class="string">&#x27;avocado&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: string_data</span><br><span class="line">Out[<span class="number">23</span>]:</span><br><span class="line"><span class="number">0</span>     aardvark</span><br><span class="line"><span class="number">1</span>    artichoke</span><br><span class="line"><span class="number">2</span>          NaN</span><br><span class="line"><span class="number">3</span>      avocado</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: string_data.isnull()</span><br><span class="line">Out[<span class="number">24</span>]:</span><br><span class="line"><span class="number">0</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">1</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">3</span>    <span class="literal">False</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在 pandas 中，我们采用了R语言中的惯用法，即将缺失值表示为 NA， 它表示不可用 (not available) 。在统计应用中，NA 数据可能是不存在的数据或者虽然存在，但是没有观察到。</p>
<p>python 内置的 None 值在对象数组中也可以作为 NA ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">25</span>]: string_data[<span class="number">0</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: string_data</span><br><span class="line">Out[<span class="number">26</span>]:</span><br><span class="line"><span class="number">0</span>         <span class="literal">None</span></span><br><span class="line"><span class="number">1</span>    artichoke</span><br><span class="line"><span class="number">2</span>          NaN</span><br><span class="line"><span class="number">3</span>      avocado</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: string_data.isnull()</span><br><span class="line">Out[<span class="number">27</span>]:</span><br><span class="line"><span class="number">0</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">1</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">3</span>    <span class="literal">False</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="滤除缺失数据">滤除缺失数据</h3>
<p>对于一个 Series, dropna 返回一个仅含非空数据和索引值的 Series :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">30</span>]: data = pd.Series([<span class="number">1</span>,np.nan,<span class="number">3.5</span>,np.nan,<span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: data</span><br><span class="line">Out[<span class="number">31</span>]:</span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    NaN</span><br><span class="line"><span class="number">2</span>    <span class="number">3.5</span></span><br><span class="line"><span class="number">3</span>    NaN</span><br><span class="line"><span class="number">4</span>    <span class="number">7.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: data.dropna()</span><br><span class="line">Out[<span class="number">32</span>]:</span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">3.5</span></span><br><span class="line"><span class="number">4</span>    <span class="number">7.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这等价于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">33</span>]: data[data.notnull()]</span><br><span class="line">Out[<span class="number">33</span>]:</span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">3.5</span></span><br><span class="line"><span class="number">4</span>    <span class="number">7.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而对于 DataFrame 对象，事情就有点复杂了。你可能希望丢弃<strong>全部为NA</strong> 或 <strong>含有NA</strong> 的 行或列。dropna 默认丢弃任何含有缺失值的行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">35</span>]: <span class="keyword">from</span> numpy <span class="keyword">import</span> nan <span class="keyword">as</span> NA</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: data = pd.DataFrame([[<span class="number">1.</span>, <span class="number">6.5</span>, <span class="number">3.</span>], [<span class="number">1.</span>, NA, NA],</span><br><span class="line">    ...:                     [NA, NA, NA], [NA, <span class="number">6.5</span>, <span class="number">3.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: cleaned = data.dropna()</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: data</span><br><span class="line">Out[<span class="number">38</span>]:</span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">6.5</span>  <span class="number">3.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  NaN  NaN</span><br><span class="line"><span class="number">2</span>  NaN  NaN  NaN</span><br><span class="line"><span class="number">3</span>  NaN  <span class="number">6.5</span>  <span class="number">3.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: cleaned</span><br><span class="line">Out[<span class="number">39</span>]:</span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">6.5</span>  <span class="number">3.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>传入 how=‘all’ 将只丢弃全为 NA 的 那些行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">40</span>]: data.dropna(how=<span class="string">&#x27;all&#x27;</span>)</span><br><span class="line">Out[<span class="number">40</span>]:</span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">6.5</span>  <span class="number">3.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  NaN  NaN</span><br><span class="line"><span class="number">3</span>  NaN  <span class="number">6.5</span>  <span class="number">3.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用这种方式丢弃列，只需要传入 axis = 1即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">45</span>]: data[<span class="number">4</span>] = NA</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: data</span><br><span class="line">Out[<span class="number">46</span>]:</span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span>   <span class="number">4</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">6.5</span>  <span class="number">3.0</span> NaN</span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  NaN  NaN NaN</span><br><span class="line"><span class="number">2</span>  NaN  NaN  NaN NaN</span><br><span class="line"><span class="number">3</span>  NaN  <span class="number">6.5</span>  <span class="number">3.0</span> NaN</span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: data.dropna(axis=<span class="number">1</span>, how=<span class="string">&#x27;all&#x27;</span>)</span><br><span class="line">Out[<span class="number">47</span>]:</span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">6.5</span>  <span class="number">3.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  NaN  NaN</span><br><span class="line"><span class="number">2</span>  NaN  NaN  NaN</span><br><span class="line"><span class="number">3</span>  NaN  <span class="number">6.5</span>  <span class="number">3.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="填充缺失数据">填充缺失数据</h3>
<p>fillna 方法可以将缺失值替换为某个值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">50</span>]: df = pd.DataFrame(np.random.randn(<span class="number">7</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: df.iloc[:<span class="number">4</span>, <span class="number">1</span>] = NA</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: df.iloc[:<span class="number">2</span>, <span class="number">2</span>] = NA</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: df</span><br><span class="line">Out[<span class="number">53</span>]:</span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0.418771</span>       NaN       NaN</span><br><span class="line"><span class="number">1</span> -<span class="number">0.486958</span>       NaN       NaN</span><br><span class="line"><span class="number">2</span>  <span class="number">1.188390</span>       NaN  <span class="number">0.242646</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.571728</span>       NaN -<span class="number">0.877406</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.474029</span> -<span class="number">2.365030</span>  <span class="number">0.336269</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.539957</span> -<span class="number">0.958257</span> -<span class="number">1.703004</span></span><br><span class="line"><span class="number">6</span> -<span class="number">1.519931</span>  <span class="number">0.547993</span> -<span class="number">1.417637</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">54</span>]: df.dropna()</span><br><span class="line">Out[<span class="number">54</span>]:</span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.474029</span> -<span class="number">2.365030</span>  <span class="number">0.336269</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.539957</span> -<span class="number">0.958257</span> -<span class="number">1.703004</span></span><br><span class="line"><span class="number">6</span> -<span class="number">1.519931</span>  <span class="number">0.547993</span> -<span class="number">1.417637</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: df.fillna(<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">55</span>]:</span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0.418771</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.486958</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="number">2</span>  <span class="number">1.188390</span>  <span class="number">0.000000</span>  <span class="number">0.242646</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.571728</span>  <span class="number">0.000000</span> -<span class="number">0.877406</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.474029</span> -<span class="number">2.365030</span>  <span class="number">0.336269</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.539957</span> -<span class="number">0.958257</span> -<span class="number">1.703004</span></span><br><span class="line"><span class="number">6</span> -<span class="number">1.519931</span>  <span class="number">0.547993</span> -<span class="number">1.417637</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>fillna 默认会返回新对象，但也可以对现有对象进行就地修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: df.fillna(<span class="number">0</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">57</span>]: df</span><br><span class="line">Out[<span class="number">57</span>]:</span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0.418771</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="number">1</span> -<span class="number">0.486958</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="number">2</span>  <span class="number">1.188390</span>  <span class="number">0.000000</span>  <span class="number">0.242646</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.571728</span>  <span class="number">0.000000</span> -<span class="number">0.877406</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.474029</span> -<span class="number">2.365030</span>  <span class="number">0.336269</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.539957</span> -<span class="number">0.958257</span> -<span class="number">1.703004</span></span><br><span class="line"><span class="number">6</span> -<span class="number">1.519931</span>  <span class="number">0.547993</span> -<span class="number">1.417637</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="数据转换">数据转换</h2>
<h3 id="移除重复数据">移除重复数据</h3>
<p>DataFrame 中出现重复行有很多原因。下面就是一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">58</span>]: data = pd.DataFrame(&#123;<span class="string">&#x27;k1&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>] * <span class="number">3</span> + [<span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">    ...:                     <span class="string">&#x27;k2&#x27;</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: data</span><br><span class="line">Out[<span class="number">59</span>]:</span><br><span class="line">    k1  k2</span><br><span class="line"><span class="number">0</span>  one   <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  two   <span class="number">1</span></span><br><span class="line"><span class="number">2</span>  one   <span class="number">2</span></span><br><span class="line"><span class="number">3</span>  two   <span class="number">3</span></span><br><span class="line"><span class="number">4</span>  one   <span class="number">3</span></span><br><span class="line"><span class="number">5</span>  two   <span class="number">4</span></span><br><span class="line"><span class="number">6</span>  two   <span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>DataFrame 的 duplicated 方法返回一个布尔型 Series， 表示各行是否是重复行（前面出现过的行）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">60</span>]: data.duplicated()</span><br><span class="line">Out[<span class="number">60</span>]:</span><br><span class="line"><span class="number">0</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">1</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">3</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">4</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">5</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">6</span>     <span class="literal">True</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过 drop_duplicates 方法，它会返回一个 DataFrame ， 重复的数组会标为 False :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">61</span>]: data.drop_duplicates()</span><br><span class="line">Out[<span class="number">61</span>]:</span><br><span class="line">    k1  k2</span><br><span class="line"><span class="number">0</span>  one   <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  two   <span class="number">1</span></span><br><span class="line"><span class="number">2</span>  one   <span class="number">2</span></span><br><span class="line"><span class="number">3</span>  two   <span class="number">3</span></span><br><span class="line"><span class="number">4</span>  one   <span class="number">3</span></span><br><span class="line"><span class="number">5</span>  two   <span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这两个方法会判断全部列，你也可以指定部分列进行重复项判断。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">63</span>]: data.drop_duplicates([<span class="string">&#x27;k1&#x27;</span>])</span><br><span class="line">Out[<span class="number">63</span>]:</span><br><span class="line">    k1  k2</span><br><span class="line"><span class="number">0</span>  one   <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  two   <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>duplicated 和 drop_duplicates 默认保留的是第一个出现的值的组合。传入 keep = ‘last’ 则保留最后一个：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">64</span>]: data.drop_duplicates(keep=<span class="string">&#x27;last&#x27;</span>)</span><br><span class="line">Out[<span class="number">64</span>]:</span><br><span class="line">    k1  k2</span><br><span class="line"><span class="number">0</span>  one   <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  two   <span class="number">1</span></span><br><span class="line"><span class="number">2</span>  one   <span class="number">2</span></span><br><span class="line"><span class="number">3</span>  two   <span class="number">3</span></span><br><span class="line"><span class="number">4</span>  one   <span class="number">3</span></span><br><span class="line"><span class="number">6</span>  two   <span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="利用函数或映射进行数据转换">利用函数或映射进行数据转换</h3>
<p>对于很多数据，你可能需要进行数据的转换。来看下面这组关于肉类的数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">65</span>]: data = pd.DataFrame(&#123;<span class="string">&#x27;food&#x27;</span>: [<span class="string">&#x27;bacon&#x27;</span>, <span class="string">&#x27;pulled pork&#x27;</span>, <span class="string">&#x27;bacon&#x27;</span>,</span><br><span class="line">    ...:                     <span class="string">&#x27;Pastrami&#x27;</span>, <span class="string">&#x27;corned beef&#x27;</span>, <span class="string">&#x27;Bacon&#x27;</span>,</span><br><span class="line">    ...:                     <span class="string">&#x27;pastrami&#x27;</span>, <span class="string">&#x27;honey ham&#x27;</span>, <span class="string">&#x27;nova lox&#x27;</span>],</span><br><span class="line">    ...:                     <span class="string">&#x27;ounces&#x27;</span>: [<span class="number">4</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">7.5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: data</span><br><span class="line">Out[<span class="number">66</span>]:</span><br><span class="line">          food  ounces</span><br><span class="line"><span class="number">0</span>        bacon     <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>  pulled pork     <span class="number">3.0</span></span><br><span class="line"><span class="number">2</span>        bacon    <span class="number">12.0</span></span><br><span class="line"><span class="number">3</span>     Pastrami     <span class="number">6.0</span></span><br><span class="line"><span class="number">4</span>  corned beef     <span class="number">7.5</span></span><br><span class="line"><span class="number">5</span>        Bacon     <span class="number">8.0</span></span><br><span class="line"><span class="number">6</span>     pastrami     <span class="number">3.0</span></span><br><span class="line"><span class="number">7</span>    honey ham     <span class="number">5.0</span></span><br><span class="line"><span class="number">8</span>     nova lox     <span class="number">6.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设你想要添加一列表示该肉类食物来源的动物类型。我们先编写一个不同肉类到动物的映射：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">67</span>]: meat_to_animal = &#123;</span><br><span class="line">    ...:   <span class="string">&#x27;bacon&#x27;</span>: <span class="string">&#x27;pig&#x27;</span>,</span><br><span class="line">    ...:   <span class="string">&#x27;pulled pork&#x27;</span>: <span class="string">&#x27;pig&#x27;</span>,</span><br><span class="line">    ...:   <span class="string">&#x27;pastrami&#x27;</span>: <span class="string">&#x27;cow&#x27;</span>,</span><br><span class="line">    ...:   <span class="string">&#x27;corned beef&#x27;</span>: <span class="string">&#x27;cow&#x27;</span>,</span><br><span class="line">    ...:   <span class="string">&#x27;honey ham&#x27;</span>: <span class="string">&#x27;pig&#x27;</span>,</span><br><span class="line">    ...:   <span class="string">&#x27;nova lox&#x27;</span>: <span class="string">&#x27;salmon&#x27;</span></span><br><span class="line">    ...: &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Series 的 map 方法可以接受一个函数或含有映射关系的字典型对象。但是这里有个问题，有些肉类的首字母大写了，这里可以用 Series 的 str.lower 方法，将大写字符串转为小写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">68</span>]: lowercased = data[<span class="string">&#x27;food&#x27;</span>].<span class="built_in">str</span>.lower()</span><br><span class="line"></span><br><span class="line">In [<span class="number">69</span>]: lowercased</span><br><span class="line">Out[<span class="number">69</span>]:</span><br><span class="line"><span class="number">0</span>          bacon</span><br><span class="line"><span class="number">1</span>    pulled pork</span><br><span class="line"><span class="number">2</span>          bacon</span><br><span class="line"><span class="number">3</span>       pastrami</span><br><span class="line"><span class="number">4</span>    corned beef</span><br><span class="line"><span class="number">5</span>          bacon</span><br><span class="line"><span class="number">6</span>       pastrami</span><br><span class="line"><span class="number">7</span>      honey ham</span><br><span class="line"><span class="number">8</span>       nova lox</span><br><span class="line">Name: food, dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: data[<span class="string">&#x27;animal&#x27;</span>] = lowercased.<span class="built_in">map</span>(meat_to_animal)</span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: data</span><br><span class="line">Out[<span class="number">71</span>]:</span><br><span class="line">          food  ounces  animal</span><br><span class="line"><span class="number">0</span>        bacon     <span class="number">4.0</span>     pig</span><br><span class="line"><span class="number">1</span>  pulled pork     <span class="number">3.0</span>     pig</span><br><span class="line"><span class="number">2</span>        bacon    <span class="number">12.0</span>     pig</span><br><span class="line"><span class="number">3</span>     Pastrami     <span class="number">6.0</span>     cow</span><br><span class="line"><span class="number">4</span>  corned beef     <span class="number">7.5</span>     cow</span><br><span class="line"><span class="number">5</span>        Bacon     <span class="number">8.0</span>     pig</span><br><span class="line"><span class="number">6</span>     pastrami     <span class="number">3.0</span>     cow</span><br><span class="line"><span class="number">7</span>    honey ham     <span class="number">5.0</span>     pig</span><br><span class="line"><span class="number">8</span>     nova lox     <span class="number">6.0</span>  salmon</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们也可以传入一个能够完成全部这些工作的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">73</span>]: data[<span class="string">&#x27;food&#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: meat_to_animal[x.lower()])</span><br><span class="line">Out[<span class="number">73</span>]:</span><br><span class="line"><span class="number">0</span>       pig</span><br><span class="line"><span class="number">1</span>       pig</span><br><span class="line"><span class="number">2</span>       pig</span><br><span class="line"><span class="number">3</span>       cow</span><br><span class="line"><span class="number">4</span>       cow</span><br><span class="line"><span class="number">5</span>       pig</span><br><span class="line"><span class="number">6</span>       cow</span><br><span class="line"><span class="number">7</span>       pig</span><br><span class="line"><span class="number">8</span>    salmon</span><br><span class="line">Name: food, dtype: <span class="built_in">object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 map函数 是一种实现元素级转换以及其他数据清理工作的便捷方式。</p>
<h3 id="替换值">替换值</h3>
<p>replace 是实现替换的简单方式。我们来看看下面这个 Series :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">74</span>]: data = pd.Series([<span class="number">1</span>, -<span class="number">999</span>, <span class="number">2</span>, -<span class="number">999</span>, -<span class="number">1000</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">75</span>]: data</span><br><span class="line">Out[<span class="number">75</span>]:</span><br><span class="line"><span class="number">0</span>       <span class="number">1</span></span><br><span class="line"><span class="number">1</span>    -<span class="number">999</span></span><br><span class="line"><span class="number">2</span>       <span class="number">2</span></span><br><span class="line"><span class="number">3</span>    -<span class="number">999</span></span><br><span class="line"><span class="number">4</span>   -<span class="number">1000</span></span><br><span class="line"><span class="number">5</span>       <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里，-999 这个值可能是一个表示缺失数据的标记值。要将其替换为 pandas 中的 NA 值。我们可以利用 replace 来产生一个新的 Series （除非传入 inplace = True）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">76</span>]: data.replace(-<span class="number">999</span>, np.nan)</span><br><span class="line">Out[<span class="number">76</span>]:</span><br><span class="line"><span class="number">0</span>       <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>       NaN</span><br><span class="line"><span class="number">2</span>       <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>       NaN</span><br><span class="line"><span class="number">4</span>   -<span class="number">1000.0</span></span><br><span class="line"><span class="number">5</span>       <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你希望一次性替换多个值，可以传入一个列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">77</span>]: data.replace([-<span class="number">999</span>,-<span class="number">1000</span>], np.nan)</span><br><span class="line">Out[<span class="number">77</span>]:</span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    NaN</span><br><span class="line"><span class="number">2</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>    NaN</span><br><span class="line"><span class="number">4</span>    NaN</span><br><span class="line"><span class="number">5</span>    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>传入的参数也可以是字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">78</span>]: data.replace(&#123;-<span class="number">999</span>: np.nan, -<span class="number">1000</span>:<span class="number">0</span>&#125;)</span><br><span class="line">Out[<span class="number">78</span>]:</span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    NaN</span><br><span class="line"><span class="number">2</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>    NaN</span><br><span class="line"><span class="number">4</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="重命名轴索引">重命名轴索引</h3>
<p>轴标签也可以通过函数或映射进行转换，从而得到一个新的不同标签的对象。轴标签也可以就地修改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">79</span>]: data = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>)),</span><br><span class="line">    ...:         index=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>],</span><br><span class="line">    ...:         columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: data</span><br><span class="line">Out[<span class="number">80</span>]:</span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">New York    <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>跟 Series 一样，轴索引也有一个 map 方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">81</span>]: transform = <span class="keyword">lambda</span> x: x[:<span class="number">4</span>].upper()</span><br><span class="line"></span><br><span class="line">In [<span class="number">82</span>]: data.index.<span class="built_in">map</span>(transform)</span><br><span class="line">Out[<span class="number">82</span>]: Index([<span class="string">&#x27;OHIO&#x27;</span>, <span class="string">&#x27;COLO&#x27;</span>, <span class="string">&#x27;NEW &#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你可以将其赋值给 index，这样就可以对 DataFrame 进行就地修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">83</span>]: data.index = data.index.<span class="built_in">map</span>(transform)</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: data</span><br><span class="line">Out[<span class="number">84</span>]:</span><br><span class="line">      one  two  three  four</span><br><span class="line">OHIO    <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">COLO    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">NEW     <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="检测和过滤异常值">检测和过滤异常值</h3>
<p>过滤和变换异常值（outlier）在很大程度上就是运用数组运算。</p>
<p>来看一个含有一个正态分布数据的 DataFrame :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">85</span>]: data = pd.DataFrame(np.random.randn(<span class="number">1000</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: data.describe()</span><br><span class="line">Out[<span class="number">86</span>]:</span><br><span class="line">                 <span class="number">0</span>            <span class="number">1</span>            <span class="number">2</span>            <span class="number">3</span></span><br><span class="line">count  <span class="number">1000.000000</span>  <span class="number">1000.000000</span>  <span class="number">1000.000000</span>  <span class="number">1000.000000</span></span><br><span class="line">mean      <span class="number">0.000828</span>     <span class="number">0.030084</span>    -<span class="number">0.004967</span>     <span class="number">0.026485</span></span><br><span class="line">std       <span class="number">1.011837</span>     <span class="number">1.013934</span>     <span class="number">1.005909</span>     <span class="number">1.024894</span></span><br><span class="line"><span class="built_in">min</span>      -<span class="number">3.162753</span>    -<span class="number">3.586335</span>    -<span class="number">3.170137</span>    -<span class="number">2.855527</span></span><br><span class="line"><span class="number">25</span>%      -<span class="number">0.707506</span>    -<span class="number">0.700249</span>    -<span class="number">0.726677</span>    -<span class="number">0.672128</span></span><br><span class="line"><span class="number">50</span>%      -<span class="number">0.031726</span>     <span class="number">0.055311</span>    -<span class="number">0.006061</span>     <span class="number">0.039701</span></span><br><span class="line"><span class="number">75</span>%       <span class="number">0.651613</span>     <span class="number">0.729527</span>     <span class="number">0.639024</span>     <span class="number">0.718360</span></span><br><span class="line"><span class="built_in">max</span>       <span class="number">3.785688</span>     <span class="number">3.149813</span>     <span class="number">3.447185</span>     <span class="number">3.570132</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设你想要找出某列中绝对值大小超过 3 的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">87</span>]: col = data[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: col[np.<span class="built_in">abs</span>(col) &gt; <span class="number">3</span>]</span><br><span class="line">Out[<span class="number">88</span>]:</span><br><span class="line"><span class="number">2</span>     -<span class="number">3.170137</span></span><br><span class="line"><span class="number">667</span>    <span class="number">3.447185</span></span><br><span class="line">Name: <span class="number">2</span>, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要选出含有“超过3或-3的值”的行，你可以在布尔型 DataFrame 中使用 any 方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">89</span>]: data[(np.<span class="built_in">abs</span>(data) &gt; <span class="number">3</span>).<span class="built_in">any</span>(<span class="number">1</span>)]</span><br><span class="line">Out[<span class="number">89</span>]:</span><br><span class="line">            <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span>         <span class="number">3</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">0.415636</span>  <span class="number">0.656499</span> -<span class="number">3.170137</span> -<span class="number">1.842275</span></span><br><span class="line"><span class="number">243</span> -<span class="number">0.304126</span> -<span class="number">3.121881</span> -<span class="number">0.048463</span> -<span class="number">0.486253</span></span><br><span class="line"><span class="number">379</span> -<span class="number">3.162753</span>  <span class="number">0.825682</span> -<span class="number">1.102310</span>  <span class="number">1.743414</span></span><br><span class="line"><span class="number">392</span> -<span class="number">0.123267</span> -<span class="number">3.499491</span>  <span class="number">1.072530</span>  <span class="number">1.416515</span></span><br><span class="line"><span class="number">438</span>  <span class="number">0.458157</span> -<span class="number">1.116196</span> -<span class="number">0.075348</span>  <span class="number">3.434403</span></span><br><span class="line"><span class="number">623</span> -<span class="number">0.777676</span> -<span class="number">3.586335</span>  <span class="number">0.465894</span>  <span class="number">1.855256</span></span><br><span class="line"><span class="number">632</span>  <span class="number">3.237445</span>  <span class="number">1.179572</span> -<span class="number">0.005501</span>  <span class="number">0.359590</span></span><br><span class="line"><span class="number">660</span>  <span class="number">0.744454</span> -<span class="number">0.643434</span> -<span class="number">0.735077</span>  <span class="number">3.570132</span></span><br><span class="line"><span class="number">667</span>  <span class="number">0.913089</span>  <span class="number">0.726744</span>  <span class="number">3.447185</span>  <span class="number">1.039869</span></span><br><span class="line"><span class="number">683</span>  <span class="number">0.104698</span>  <span class="number">3.149813</span> -<span class="number">1.450257</span>  <span class="number">2.559909</span></span><br><span class="line"><span class="number">756</span>  <span class="number">3.377305</span>  <span class="number">0.030219</span> -<span class="number">1.689867</span> -<span class="number">0.799859</span></span><br><span class="line"><span class="number">997</span>  <span class="number">3.785688</span>  <span class="number">0.105340</span>  <span class="number">0.371458</span>  <span class="number">1.618220</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根据这些条件，就可以对值进行设置。下面的代码可以将值限制在区间 -3 到 3 以内：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">90</span>]: data[np.<span class="built_in">abs</span>(data) &gt; <span class="number">3</span>] = np.sign(data)*<span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">91</span>]: data.describe()</span><br><span class="line">Out[<span class="number">91</span>]:</span><br><span class="line">                 <span class="number">0</span>            <span class="number">1</span>            <span class="number">2</span>            <span class="number">3</span></span><br><span class="line">count  <span class="number">1000.000000</span>  <span class="number">1000.000000</span>  <span class="number">1000.000000</span>  <span class="number">1000.000000</span></span><br><span class="line">mean     -<span class="number">0.000409</span>     <span class="number">0.031142</span>    -<span class="number">0.005244</span>     <span class="number">0.025480</span></span><br><span class="line">std       <span class="number">1.006769</span>     <span class="number">1.009561</span>     <span class="number">1.003948</span>     <span class="number">1.021720</span></span><br><span class="line"><span class="built_in">min</span>      -<span class="number">3.000000</span>    -<span class="number">3.000000</span>    -<span class="number">3.000000</span>    -<span class="number">2.855527</span></span><br><span class="line"><span class="number">25</span>%      -<span class="number">0.707506</span>    -<span class="number">0.700249</span>    -<span class="number">0.726677</span>    -<span class="number">0.672128</span></span><br><span class="line"><span class="number">50</span>%      -<span class="number">0.031726</span>     <span class="number">0.055311</span>    -<span class="number">0.006061</span>     <span class="number">0.039701</span></span><br><span class="line"><span class="number">75</span>%       <span class="number">0.651613</span>     <span class="number">0.729527</span>     <span class="number">0.639024</span>     <span class="number">0.718360</span></span><br><span class="line"><span class="built_in">max</span>       <span class="number">3.000000</span>     <span class="number">3.000000</span>     <span class="number">3.000000</span>     <span class="number">3.000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里 np.sign(data) 可以生成 1 和 -1 , 表示数值的符号：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">92</span>]: np.sign(data).head()</span><br><span class="line">Out[<span class="number">92</span>]:</span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span>    <span class="number">3</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span> -<span class="number">1.0</span> -<span class="number">1.0</span> -<span class="number">1.0</span></span><br><span class="line"><span class="number">1</span> -<span class="number">1.0</span> -<span class="number">1.0</span>  <span class="number">1.0</span> -<span class="number">1.0</span></span><br><span class="line"><span class="number">2</span> -<span class="number">1.0</span>  <span class="number">1.0</span> -<span class="number">1.0</span> -<span class="number">1.0</span></span><br><span class="line"><span class="number">3</span> -<span class="number">1.0</span> -<span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">4</span> -<span class="number">1.0</span>  <span class="number">1.0</span>  <span class="number">1.0</span> -<span class="number">1.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="排列和随机采样">排列和随机采样</h3>
<p>利用 numpy.random.permutation 函数可以轻松实现对 Series 或 DataFrame 的列的排序工作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">93</span>]: df = pd.DataFrame(np.arange(<span class="number">20</span>).reshape(<span class="number">5</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: sampler = np.random.permutation(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">95</span>]: sampler</span><br><span class="line">Out[<span class="number">95</span>]: array([<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后就可以在基于 iloc 的索引操作或 take 函数中使用该数组了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">107</span>]: df</span><br><span class="line">Out[<span class="number">107</span>]:</span><br><span class="line">    <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">0</span>   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">1</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span></span><br><span class="line"><span class="number">2</span>   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span></span><br><span class="line"><span class="number">3</span>  <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span></span><br><span class="line"><span class="number">4</span>  <span class="number">16</span>  <span class="number">17</span>  <span class="number">18</span>  <span class="number">19</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">108</span>]: df.take(sampler)</span><br><span class="line">Out[<span class="number">108</span>]:</span><br><span class="line">    <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">0</span>   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">3</span>  <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span></span><br><span class="line"><span class="number">4</span>  <span class="number">16</span>  <span class="number">17</span>  <span class="number">18</span>  <span class="number">19</span></span><br><span class="line"><span class="number">1</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span></span><br><span class="line"><span class="number">2</span>   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">109</span>]: df.iloc[sampler]</span><br><span class="line">Out[<span class="number">109</span>]:</span><br><span class="line">    <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">0</span>   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">3</span>  <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span></span><br><span class="line"><span class="number">4</span>  <span class="number">16</span>  <span class="number">17</span>  <span class="number">18</span>  <span class="number">19</span></span><br><span class="line"><span class="number">1</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span></span><br><span class="line"><span class="number">2</span>   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果不想用替换的方式选取随机子集，可以在 Series 和 DataFrame 上使用 sample 方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">111</span>]: df.sample(n=<span class="number">3</span>)</span><br><span class="line">Out[<span class="number">111</span>]:</span><br><span class="line">    <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">4</span>  <span class="number">16</span>  <span class="number">17</span>  <span class="number">18</span>  <span class="number">19</span></span><br><span class="line"><span class="number">0</span>   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">1</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果允许重复抽样（可放回），可以传递 replace=True 到 sample</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">113</span>]: choices = pd.Series([<span class="number">5</span>,<span class="number">7</span>,-<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">114</span>]: draws = choices.sample(n=<span class="number">10</span>, replace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">115</span>]: draws</span><br><span class="line">Out[<span class="number">115</span>]:</span><br><span class="line"><span class="number">0</span>    <span class="number">5</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">1</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line"><span class="number">4</span>    <span class="number">4</span></span><br><span class="line"><span class="number">0</span>    <span class="number">5</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">1</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="计算指标-哑变量">计算指标/哑变量</h3>
<p>另一种常用于统计模型或机器学习的转换方式是：将分类变量转换为<strong>哑变量</strong>/指标矩阵。</p>
<p>pandas 有一个 get_dummies 函数可以实现该功能，举例而言：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">119</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">     ...:                 <span class="string">&#x27;data1&#x27;</span>: <span class="built_in">range</span>(<span class="number">6</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">120</span>]: pd.get_dummies(df[<span class="string">&#x27;key&#x27;</span>])</span><br><span class="line">Out[<span class="number">120</span>]:</span><br><span class="line">   a  b  c</span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span></span><br><span class="line"><span class="number">4</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有时候，你可能想给指标 DataFrame 的列加上一个前缀，以便能够跟其他数据进行合并。get_dummies 的 prefix 参数可以实现该功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">121</span>]: dummies = pd.get_dummies(df[<span class="string">&#x27;key&#x27;</span>], prefix=<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: df_with_dummy = df[[<span class="string">&#x27;data1&#x27;</span>]].join(dummies)</span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: df_with_dummy</span><br><span class="line">Out[<span class="number">123</span>]:</span><br><span class="line">   data1  key_a  key_b  key_c</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">1</span>      <span class="number">0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>      <span class="number">0</span>      <span class="number">1</span>      <span class="number">0</span></span><br><span class="line"><span class="number">2</span>      <span class="number">2</span>      <span class="number">1</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">3</span>      <span class="number">3</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">1</span></span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>      <span class="number">1</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>      <span class="number">0</span>      <span class="number">1</span>      <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>数据规整：聚合、合并和重塑</h1>
<h2 id="使用列当作索引">使用列当作索引</h2>
<p>我们可能会希望将 DataFrame 的某列当作行索引来用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">126</span>]: frame = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>), <span class="string">&#x27;b&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>, <span class="number">0</span>, -<span class="number">1</span>),</span><br><span class="line">     ...:                       <span class="string">&#x27;c&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;two&#x27;</span>,</span><br><span class="line">     ...:                           <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">     ...:                       <span class="string">&#x27;d&#x27;</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">127</span>]: frame</span><br><span class="line">Out[<span class="number">127</span>]:</span><br><span class="line">   a  b    c  d</span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">7</span>  one  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">6</span>  one  <span class="number">1</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2</span>  <span class="number">5</span>  one  <span class="number">2</span></span><br><span class="line"><span class="number">3</span>  <span class="number">3</span>  <span class="number">4</span>  two  <span class="number">0</span></span><br><span class="line"><span class="number">4</span>  <span class="number">4</span>  <span class="number">3</span>  two  <span class="number">1</span></span><br><span class="line"><span class="number">5</span>  <span class="number">5</span>  <span class="number">2</span>  two  <span class="number">2</span></span><br><span class="line"><span class="number">6</span>  <span class="number">6</span>  <span class="number">1</span>  two  <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>set_index 函数会将某列转换成行索引，并创建一个新的 DataFrame</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">128</span>]: frame2 = frame.set_index([<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">129</span>]: frame2</span><br><span class="line">Out[<span class="number">129</span>]:</span><br><span class="line">     a  b  d</span><br><span class="line">c</span><br><span class="line">one  <span class="number">0</span>  <span class="number">7</span>  <span class="number">0</span></span><br><span class="line">one  <span class="number">1</span>  <span class="number">6</span>  <span class="number">1</span></span><br><span class="line">one  <span class="number">2</span>  <span class="number">5</span>  <span class="number">2</span></span><br><span class="line">two  <span class="number">3</span>  <span class="number">4</span>  <span class="number">0</span></span><br><span class="line">two  <span class="number">4</span>  <span class="number">3</span>  <span class="number">1</span></span><br><span class="line">two  <span class="number">5</span>  <span class="number">2</span>  <span class="number">2</span></span><br><span class="line">two  <span class="number">6</span>  <span class="number">1</span>  <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>默认情况下，那些列会从 DataFrame 中移除，但也可以将其保留下来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">130</span>]: frame.set_index([<span class="string">&#x27;c&#x27;</span>], drop=<span class="literal">False</span>)</span><br><span class="line">Out[<span class="number">130</span>]:</span><br><span class="line">     a  b    c  d</span><br><span class="line">c</span><br><span class="line">one  <span class="number">0</span>  <span class="number">7</span>  one  <span class="number">0</span></span><br><span class="line">one  <span class="number">1</span>  <span class="number">6</span>  one  <span class="number">1</span></span><br><span class="line">one  <span class="number">2</span>  <span class="number">5</span>  one  <span class="number">2</span></span><br><span class="line">two  <span class="number">3</span>  <span class="number">4</span>  two  <span class="number">0</span></span><br><span class="line">two  <span class="number">4</span>  <span class="number">3</span>  two  <span class="number">1</span></span><br><span class="line">two  <span class="number">5</span>  <span class="number">2</span>  two  <span class="number">2</span></span><br><span class="line">two  <span class="number">6</span>  <span class="number">1</span>  two  <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>reset_index 的功能跟 set_index 刚好相反，原索引会被转移到列里面：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">131</span>]: frame2.reset_index()</span><br><span class="line">Out[<span class="number">131</span>]:</span><br><span class="line">     c  a  b  d</span><br><span class="line"><span class="number">0</span>  one  <span class="number">0</span>  <span class="number">7</span>  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  one  <span class="number">1</span>  <span class="number">6</span>  <span class="number">1</span></span><br><span class="line"><span class="number">2</span>  one  <span class="number">2</span>  <span class="number">5</span>  <span class="number">2</span></span><br><span class="line"><span class="number">3</span>  two  <span class="number">3</span>  <span class="number">4</span>  <span class="number">0</span></span><br><span class="line"><span class="number">4</span>  two  <span class="number">4</span>  <span class="number">3</span>  <span class="number">1</span></span><br><span class="line"><span class="number">5</span>  two  <span class="number">5</span>  <span class="number">2</span>  <span class="number">2</span></span><br><span class="line"><span class="number">6</span>  two  <span class="number">6</span>  <span class="number">1</span>  <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="合并数据集">合并数据集</h2>
<p>pandas 对象中的数据可以通过一些方式进行合并：</p>
<ul>
<li>pandas.merge 可根据一个或多个键将不同 DataFrame 中的行连接起来，类似于数据库的 join 操作。</li>
<li>pandas.concat 可以沿着一条轴将多个对象堆叠到一起。</li>
<li>实例方法 combine_first 可以将重复数据拼接在一起，用一个对象中的值填充另一个对象的缺失值。</li>
</ul>
<h2 id="数据库风格的DataFrame-合并">数据库风格的DataFrame 合并</h2>
<p>merge 函数，例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">132</span>]: df1 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">     ...:                     <span class="string">&#x27;data1&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">133</span>]: df2 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>:[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;d&#x27;</span>], <span class="string">&#x27;data2&#x27;</span>:<span class="built_in">range</span>(<span class="number">3</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">134</span>]: df1</span><br><span class="line">Out[<span class="number">134</span>]:</span><br><span class="line">  key  data1</span><br><span class="line"><span class="number">0</span>   b      <span class="number">0</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>   a      <span class="number">2</span></span><br><span class="line"><span class="number">3</span>   c      <span class="number">3</span></span><br><span class="line"><span class="number">4</span>   a      <span class="number">4</span></span><br><span class="line"><span class="number">5</span>   a      <span class="number">5</span></span><br><span class="line"><span class="number">6</span>   b      <span class="number">6</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">135</span>]: df2</span><br><span class="line">Out[<span class="number">135</span>]:</span><br><span class="line">  key  data2</span><br><span class="line"><span class="number">0</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>   d      <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>merge 函数默认采用<strong>内连接</strong>方式，通过 on 函数指定哪一列为键。（这里有个问题，df1 的 key 列有重复，这在数据库里是不允许的，但是 pandas 可以）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">136</span>]: pd.merge(df1,df2, on=<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line">Out[<span class="number">136</span>]:</span><br><span class="line">  key  data1  data2</span><br><span class="line"><span class="number">0</span>   b      <span class="number">0</span>      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span>      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>   b      <span class="number">6</span>      <span class="number">1</span></span><br><span class="line"><span class="number">3</span>   a      <span class="number">2</span>      <span class="number">0</span></span><br><span class="line"><span class="number">4</span>   a      <span class="number">4</span>      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>   a      <span class="number">5</span>      <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果两个对象的列名不同，也可以分别进行指定：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">137</span>]: df3 = pd.DataFrame(&#123;<span class="string">&#x27;lkey&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">     ...:                     <span class="string">&#x27;data1&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">138</span>]: df4 = pd.DataFrame(&#123;<span class="string">&#x27;rkey&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">     ...:                     <span class="string">&#x27;data2&#x27;</span>: <span class="built_in">range</span>(<span class="number">3</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">139</span>]: pd.merge(df3, df4, left_on=<span class="string">&#x27;lkey&#x27;</span>, right_on=<span class="string">&#x27;rkey&#x27;</span>)</span><br><span class="line">Out[<span class="number">139</span>]:</span><br><span class="line">  lkey  data1 rkey  data2</span><br><span class="line"><span class="number">0</span>    b      <span class="number">0</span>    b      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>    b      <span class="number">1</span>    b      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>    b      <span class="number">6</span>    b      <span class="number">1</span></span><br><span class="line"><span class="number">3</span>    a      <span class="number">2</span>    a      <span class="number">0</span></span><br><span class="line"><span class="number">4</span>    a      <span class="number">4</span>    a      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>    a      <span class="number">5</span>    a      <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>除了内连接，其他方式还有 ”left&quot;, “right”, “outer” 。这里，外连接求取的是键的并集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">140</span>]: pd.merge(df1, df2, on=<span class="string">&#x27;key&#x27;</span>, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">Out[<span class="number">140</span>]:</span><br><span class="line">  key  data1  data2</span><br><span class="line"><span class="number">0</span>   b    <span class="number">0.0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>   b    <span class="number">1.0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>   b    <span class="number">6.0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">3</span>   a    <span class="number">2.0</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">4</span>   a    <span class="number">4.0</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">5</span>   a    <span class="number">5.0</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">6</span>   c    <span class="number">3.0</span>    NaN</span><br><span class="line"><span class="number">7</span>   d    NaN    <span class="number">2.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果两个数据集含有重复的列名，合并后貌似是自动加<code>_x</code>  <code>_y</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">141</span>]: df1 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">     ...:                     <span class="string">&#x27;data&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">142</span>]:</span><br><span class="line"></span><br><span class="line">In [<span class="number">142</span>]: df2 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>:[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;d&#x27;</span>], <span class="string">&#x27;data&#x27;</span>:<span class="built_in">range</span>(<span class="number">3</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">143</span>]: pd.merge(df1, df2, on=<span class="string">&quot;key&quot;</span>)</span><br><span class="line">Out[<span class="number">143</span>]:</span><br><span class="line">  key  data_x  data_y</span><br><span class="line"><span class="number">0</span>   b       <span class="number">0</span>       <span class="number">1</span></span><br><span class="line"><span class="number">1</span>   b       <span class="number">1</span>       <span class="number">1</span></span><br><span class="line"><span class="number">2</span>   b       <span class="number">6</span>       <span class="number">1</span></span><br><span class="line"><span class="number">3</span>   a       <span class="number">2</span>       <span class="number">0</span></span><br><span class="line"><span class="number">4</span>   a       <span class="number">4</span>       <span class="number">0</span></span><br><span class="line"><span class="number">5</span>   a       <span class="number">5</span>       <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过 suffixes 选项，指定重复列名附加的字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">144</span>]: pd.merge(df1, df2, on=<span class="string">&quot;key&quot;</span>, suffixes=(<span class="string">&#x27;_left&#x27;</span>, <span class="string">&#x27;_right&#x27;</span>))</span><br><span class="line">Out[<span class="number">144</span>]:</span><br><span class="line">  key  data_left  data_right</span><br><span class="line"><span class="number">0</span>   b          <span class="number">0</span>           <span class="number">1</span></span><br><span class="line"><span class="number">1</span>   b          <span class="number">1</span>           <span class="number">1</span></span><br><span class="line"><span class="number">2</span>   b          <span class="number">6</span>           <span class="number">1</span></span><br><span class="line"><span class="number">3</span>   a          <span class="number">2</span>           <span class="number">0</span></span><br><span class="line"><span class="number">4</span>   a          <span class="number">4</span>           <span class="number">0</span></span><br><span class="line"><span class="number">5</span>   a          <span class="number">5</span>           <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="索引上的合并">索引上的合并</h3>
<p>有时候，DataFrame 中的连接键位于其索引中。在这种情况下，你可以传入 left_index = True 或 right_index = True  (或两个都传) 以说明索引应该被用作连接键：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">154</span>]: left1 = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">     ...:                         <span class="string">&#x27;value&#x27;</span>: <span class="built_in">range</span>(<span class="number">6</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">155</span>]: right1 = pd.DataFrame(&#123;<span class="string">&#x27;group_val&#x27;</span>: [<span class="number">3.5</span>, <span class="number">7</span>]&#125;, index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">156</span>]: left1</span><br><span class="line">Out[<span class="number">156</span>]:</span><br><span class="line">  key  value</span><br><span class="line"><span class="number">0</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>   a      <span class="number">2</span></span><br><span class="line"><span class="number">3</span>   a      <span class="number">3</span></span><br><span class="line"><span class="number">4</span>   b      <span class="number">4</span></span><br><span class="line"><span class="number">5</span>   c      <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">157</span>]: right1</span><br><span class="line">Out[<span class="number">157</span>]:</span><br><span class="line">   group_val</span><br><span class="line">a        <span class="number">3.5</span></span><br><span class="line">b        <span class="number">7.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">158</span>]: pd.merge(left1, right1, left_on=<span class="string">&#x27;key&#x27;</span>, right_index=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">158</span>]:</span><br><span class="line">  key  value  group_val</span><br><span class="line"><span class="number">0</span>   a      <span class="number">0</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">2</span>   a      <span class="number">2</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">3</span>   a      <span class="number">3</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span>        <span class="number">7.0</span></span><br><span class="line"><span class="number">4</span>   b      <span class="number">4</span>        <span class="number">7.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="轴向连接">轴向连接</h3>
<p>另一种数据运算也被称作连接（concatenation）。</p>
<p>numpy 的 concatenation 函数可以用数组来做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">159</span>]: arr = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">160</span>]: arr</span><br><span class="line">Out[<span class="number">160</span>]:</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">161</span>]: np.concatenate([arr,arr], axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">161</span>]:</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是对于 pandas 对象，由于 pandas 对象带有<strong>标签</strong>，你需要分不同情况讨论。</p>
<p>首先我们看 Series 的合并，假设我们有三个没有重叠索引的 Series :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">162</span>]: s1 = pd.Series([<span class="number">0</span>, <span class="number">1</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">163</span>]: s2 = pd.Series([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">164</span>]: s3 = pd.Series([<span class="number">5</span>, <span class="number">6</span>], index=[<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对这些对象调用 concat 可以将值和索引粘合在一起：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">165</span>]: pd.concat([s1, s2, s3])</span><br><span class="line">Out[<span class="number">165</span>]:</span><br><span class="line">a    <span class="number">0</span></span><br><span class="line">b    <span class="number">1</span></span><br><span class="line">c    <span class="number">2</span></span><br><span class="line">d    <span class="number">3</span></span><br><span class="line">e    <span class="number">4</span></span><br><span class="line">f    <span class="number">5</span></span><br><span class="line">g    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>默认情况下，concat 是在 axis=0 上工作的，最终产生一个新的 Series。如果传入 axis=1 ，则结果就会变成一个 DataFrame (axis=1是列)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">166</span>]: pd.concat([s1, s2, s3], axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">166</span>]:</span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line">a  <span class="number">0.0</span>  NaN  NaN</span><br><span class="line">b  <span class="number">1.0</span>  NaN  NaN</span><br><span class="line">c  NaN  <span class="number">2.0</span>  NaN</span><br><span class="line">d  NaN  <span class="number">3.0</span>  NaN</span><br><span class="line">e  NaN  <span class="number">4.0</span>  NaN</span><br><span class="line">f  NaN  NaN  <span class="number">5.0</span></span><br><span class="line">g  NaN  NaN  <span class="number">6.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>默认得到并集结果，传入 join=‘inner’ 即可得到它们的交集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">168</span>]: s4 = pd.concat([s1,s3])</span><br><span class="line"></span><br><span class="line">In [<span class="number">169</span>]: s4</span><br><span class="line">Out[<span class="number">169</span>]:</span><br><span class="line">a    <span class="number">0</span></span><br><span class="line">b    <span class="number">1</span></span><br><span class="line">f    <span class="number">5</span></span><br><span class="line">g    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">170</span>]: pd.concat([s1,s4], axis =<span class="number">1</span> )</span><br><span class="line">Out[<span class="number">170</span>]:</span><br><span class="line">     <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">a  <span class="number">0.0</span>  <span class="number">0</span></span><br><span class="line">b  <span class="number">1.0</span>  <span class="number">1</span></span><br><span class="line">f  NaN  <span class="number">5</span></span><br><span class="line">g  NaN  <span class="number">6</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">171</span>]: pd.concat([s1,s4], axis =<span class="number">1</span>, join=<span class="string">&#x27;inner&#x27;</span> )</span><br><span class="line">Out[<span class="number">171</span>]:</span><br><span class="line">   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">a  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">b  <span class="number">1</span>  <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>DataFrame 合并类似</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">172</span>]: df1 = pd.DataFrame(np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>, <span class="number">2</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">     ...:                     columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">173</span>]: df2 = pd.DataFrame(<span class="number">5</span> + np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>, <span class="number">2</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">     ...:                     columns=[<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">174</span>]: df1</span><br><span class="line">Out[<span class="number">174</span>]:</span><br><span class="line">   one  two</span><br><span class="line">a    <span class="number">0</span>    <span class="number">1</span></span><br><span class="line">b    <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">c    <span class="number">4</span>    <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">175</span>]: df2</span><br><span class="line">Out[<span class="number">175</span>]:</span><br><span class="line">   three  four</span><br><span class="line">a      <span class="number">5</span>     <span class="number">6</span></span><br><span class="line">c      <span class="number">7</span>     <span class="number">8</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">176</span>]: pd.concat([df1, df2],axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">176</span>]:</span><br><span class="line">   one  two  three  four</span><br><span class="line">a    <span class="number">0</span>    <span class="number">1</span>    <span class="number">5.0</span>   <span class="number">6.0</span></span><br><span class="line">b    <span class="number">2</span>    <span class="number">3</span>    NaN   NaN</span><br><span class="line">c    <span class="number">4</span>    <span class="number">5</span>    <span class="number">7.0</span>   <span class="number">8.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果DataFrame 的<strong>行索引没有意义</strong>，传入 <code>ignore_index=True</code> 即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">177</span>]: df1 = pd.DataFrame(np.random.randn(<span class="number">3</span>, <span class="number">4</span>), columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">178</span>]: df2 = pd.DataFrame(np.random.randn(<span class="number">2</span>, <span class="number">3</span>), columns=[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">179</span>]: df1</span><br><span class="line">Out[<span class="number">179</span>]:</span><br><span class="line">          a         b         c         d</span><br><span class="line"><span class="number">0</span> -<span class="number">0.448668</span> -<span class="number">0.536682</span> -<span class="number">1.084406</span> -<span class="number">0.776954</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.187011</span>  <span class="number">1.842820</span>  <span class="number">1.446364</span>  <span class="number">0.852555</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.972662</span> -<span class="number">0.821236</span> -<span class="number">1.273319</span> -<span class="number">0.426185</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">180</span>]: df2</span><br><span class="line">Out[<span class="number">180</span>]:</span><br><span class="line">          b         d         a</span><br><span class="line"><span class="number">0</span>  <span class="number">1.033835</span> -<span class="number">0.286986</span> -<span class="number">0.151656</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.814084</span> -<span class="number">0.319707</span>  <span class="number">2.325506</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">181</span>]: pd.concat([df1, df2], ignore_index=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">181</span>]:</span><br><span class="line">          a         b         c         d</span><br><span class="line"><span class="number">0</span> -<span class="number">0.448668</span> -<span class="number">0.536682</span> -<span class="number">1.084406</span> -<span class="number">0.776954</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.187011</span>  <span class="number">1.842820</span>  <span class="number">1.446364</span>  <span class="number">0.852555</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.972662</span> -<span class="number">0.821236</span> -<span class="number">1.273319</span> -<span class="number">0.426185</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.151656</span>  <span class="number">1.033835</span>       NaN -<span class="number">0.286986</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2.325506</span>  <span class="number">0.814084</span>       NaN -<span class="number">0.319707</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="15.png" alt="15"></p>
<h3 id="合并重叠数据">合并重叠数据</h3>
<p>还有一种数据组合问题不能用简单的合并 (merge) 或 连接 (concatenation) 运算来处理。比如说，你可能有<strong>索引全部或部分重叠</strong>的两个数据集。举个有启发性的例子，我们使用 Numpy 的 where 函数，他表示一种等价于面向数组的 if-else：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">182</span>]: a = pd.Series([np.nan, <span class="number">2.5</span>, np.nan, <span class="number">3.5</span>, <span class="number">4.5</span>, np.nan],</span><br><span class="line">     ...:     index=[<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">183</span>]: b = pd.Series(np.arange(<span class="built_in">len</span>(a), dtype=np.float64),</span><br><span class="line">     ...:     index=[<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">184</span>]: b[-<span class="number">1</span>] = np.nan</span><br><span class="line"></span><br><span class="line">In [<span class="number">185</span>]: b</span><br><span class="line">Out[<span class="number">185</span>]:</span><br><span class="line">f    <span class="number">0.0</span></span><br><span class="line">e    <span class="number">1.0</span></span><br><span class="line">d    <span class="number">2.0</span></span><br><span class="line">c    <span class="number">3.0</span></span><br><span class="line">b    <span class="number">4.0</span></span><br><span class="line">a    NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">186</span>]: a</span><br><span class="line">Out[<span class="number">186</span>]:</span><br><span class="line">f    NaN</span><br><span class="line">e    <span class="number">2.5</span></span><br><span class="line">d    NaN</span><br><span class="line">c    <span class="number">3.5</span></span><br><span class="line">b    <span class="number">4.5</span></span><br><span class="line">a    NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">187</span>]: np.where(pd.isnull(a),b,a)</span><br><span class="line">Out[<span class="number">187</span>]: array([<span class="number">0.</span> , <span class="number">2.5</span>, <span class="number">2.</span> , <span class="number">3.5</span>, <span class="number">4.5</span>, nan])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Series 有一个 combine_first 方法，实现的也是一样的功能，还带有 pandas 的数据对齐：</p>
<p>不知道这里的 <code>[:-2]</code>  <code>[2:]</code> 啥的，都是什么意思</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">188</span>]: b[:-<span class="number">2</span>].combine_first(a[<span class="number">2</span>:])</span><br><span class="line">Out[<span class="number">188</span>]:</span><br><span class="line">a    NaN</span><br><span class="line">b    <span class="number">4.5</span></span><br><span class="line">c    <span class="number">3.0</span></span><br><span class="line">d    <span class="number">2.0</span></span><br><span class="line">e    <span class="number">1.0</span></span><br><span class="line">f    <span class="number">0.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于 DataFrame，combine_first 自然也会在列上做同样的事情，因此你可以将其看做：用传递对象的数据为调用对象的缺失数据“打补丁”：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">190</span>]: df1 = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: [<span class="number">1.</span>, np.nan, <span class="number">5.</span>, np.nan],</span><br><span class="line">     ...:                     <span class="string">&#x27;b&#x27;</span>: [np.nan, <span class="number">2.</span>, np.nan, <span class="number">6.</span>],</span><br><span class="line">     ...:                     <span class="string">&#x27;c&#x27;</span>: <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">18</span>, <span class="number">4</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">191</span>]: df2 = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: [<span class="number">5.</span>, <span class="number">4.</span>, np.nan, <span class="number">3.</span>, <span class="number">7.</span>],</span><br><span class="line">     ...:                     <span class="string">&#x27;b&#x27;</span>: [np.nan, <span class="number">3.</span>, <span class="number">4.</span>, <span class="number">6.</span>, <span class="number">8.</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">192</span>]: df1</span><br><span class="line">Out[<span class="number">192</span>]:</span><br><span class="line">     a    b   c</span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  NaN   <span class="number">2</span></span><br><span class="line"><span class="number">1</span>  NaN  <span class="number">2.0</span>   <span class="number">6</span></span><br><span class="line"><span class="number">2</span>  <span class="number">5.0</span>  NaN  <span class="number">10</span></span><br><span class="line"><span class="number">3</span>  NaN  <span class="number">6.0</span>  <span class="number">14</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">193</span>]: df2</span><br><span class="line">Out[<span class="number">193</span>]:</span><br><span class="line">     a    b</span><br><span class="line"><span class="number">0</span>  <span class="number">5.0</span>  NaN</span><br><span class="line"><span class="number">1</span>  <span class="number">4.0</span>  <span class="number">3.0</span></span><br><span class="line"><span class="number">2</span>  NaN  <span class="number">4.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">3.0</span>  <span class="number">6.0</span></span><br><span class="line"><span class="number">4</span>  <span class="number">7.0</span>  <span class="number">8.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">194</span>]: df1.combine_first(df2)</span><br><span class="line">Out[<span class="number">194</span>]:</span><br><span class="line">     a    b     c</span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  NaN   <span class="number">2.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4.0</span>  <span class="number">2.0</span>   <span class="number">6.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">5.0</span>  <span class="number">4.0</span>  <span class="number">10.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">3.0</span>  <span class="number">6.0</span>  <span class="number">14.0</span></span><br><span class="line"><span class="number">4</span>  <span class="number">7.0</span>  <span class="number">8.0</span>   NaN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>绘图和可视化</h1>
<h2 id="matplotlib-入门">matplotlib 入门</h2>
<p>导入模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">198</span>]: <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
<p>使用举例，这里最后要用 <code>plt.show()</code> 才能显示图片。</p>
<p>这里有个问题，<strong>运行过<code>plt.show()</code>以后，再跑一次就啥也没有了</strong>。必须要再次先运行前面的代码，再重新跑 <code>plt.show()</code>  。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">205</span>]: data = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">206</span>]: data</span><br><span class="line">Out[<span class="number">206</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">207</span>]: plt.plot(data)</span><br><span class="line">Out[<span class="number">207</span>]: [&lt;matplotlib.lines.Line2D at <span class="number">0x2b4ff7e71110</span>&gt;]</span><br><span class="line"></span><br><span class="line">In [<span class="number">208</span>]: plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Figure-和-Subplot">Figure 和 Subplot</h3>
<p>matplotlib 的图像都位于 Figure 对象中。你可以用 plt.figure 创建一个新的 Figure :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">209</span>]: fig = plt.figure()</span><br></pre></td></tr></table></figure>
<p>下条代码表示图像应该是 2×2 的（即最多4张图），且当前选中的第一个子图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">210</span>]: ax1 = fig.add_subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>再创建两个子图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">211</span>]: ax2 = fig.add_subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">212</span>]: ax3 = fig.add_subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>显示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">213</span>]: plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="16.png" alt="15"></p>
<p>这时候如果执行一条绘图命令会在最后一个子图上绘制，下面的命令中 “k–” 表示绘制黑色虚线图。这里需要将前面画图的地方再跑一遍。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax1 = fig.add_subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">ax2 = fig.add_subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">ax3 = fig.add_subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">plt.plot(np.random.randn(<span class="number">50</span>).cumsum(), <span class="string">&#x27;k--&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="17.png" alt="15"></p>
<p>其他空着的子图也可以画图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fig &#x3D; plt.figure()</span><br><span class="line">ax1 &#x3D; fig.add_subplot(2,2,1)</span><br><span class="line">ax2 &#x3D; fig.add_subplot(2,2,2)</span><br><span class="line">ax3 &#x3D; fig.add_subplot(2,2,3)</span><br><span class="line">plt.plot(np.random.randn(50).cumsum(), &#39;k--&#39;)</span><br><span class="line">ax1.hist(np.random.randn(100), bins&#x3D;20, color&#x3D;&#39;k&#39;, alpha&#x3D;0.3)</span><br><span class="line">ax2.scatter(np.arange(30), np.arange(30) + 3 * np.random.randn(30))</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="18.png" alt="15"></p>
<p>创建子图有一个更为方便的方法 plt.subplots，它可以创建一个新的 Figure，并返回一个含有已创建的 subplot 对象的 Numpy 数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">230</span>]: fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">231</span>]: axes</span><br><span class="line">Out[<span class="number">231</span>]:</span><br><span class="line">array([[&lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x2b5006ae1890</span>&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x2b5006f2ff90</span>&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x2b5006f6e250</span>&gt;],</span><br><span class="line">       [&lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x2b5006f9f510</span>&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x2b5006fd18d0</span>&gt;,</span><br><span class="line">        &lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x2b50070062d0</span>&gt;]],</span><br><span class="line">      dtype=<span class="built_in">object</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这非常实用，因为可以轻松地对 axes 数组进行索引，就像一个二维数组一样，例如 axes[0, 1] 。你还可以通过 sharex 和 sharey 指定所有的子图应该具有相同的 X轴 或 Y轴。在比较相同范围的数据时，这也是非常实用的，否则，matplotlib 会自动缩放各图表的界限。更多信息见下表：</p>
<p><img src="19.png" alt="15"></p>
<h3 id="调整-subplot-周围的间距">调整 subplot 周围的间距</h3>
<p>通过 Figure 的 subplots_adjust 方法可以修改子图外围和子图之间的间距：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">subplots_adjust(left=<span class="literal">None</span>, bottom=<span class="literal">None</span>, right=<span class="literal">None</span>, top=<span class="literal">None</span>,</span><br><span class="line">                wspace=<span class="literal">None</span>, hspace=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>wspace 和 hspace 用于控制宽度和高度的百分比，可以用作子图之间的间距。下面是一个简单的例子，这里将间距收缩到了0</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">2</span>, sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">		axes[i, j].hist(np.random.randn(<span class="number">500</span>), bins=<span class="number">50</span>, color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.subplots_adjust(wspace=<span class="number">0</span>, hspace=<span class="number">0</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="20.png" alt="15"></p>
<p>不难看出，这里轴标签重叠了。</p>
<h3 id="颜色、标记和线性">颜色、标记和线性</h3>
<p>matplotlib 的 plot 函数接受一组 X 和 Y 坐标，还可以接受一个表示颜色和线型的字符串缩写。例如，要根据x和y绘制绿色虚线，你可以执行如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax.plot(x,y, <span class="string">&#x27;g--&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax.plot(x,y linestyle=<span class="string">&#x27;--&#x27;</span>, color=g)</span><br></pre></td></tr></table></figure>
<p>常用的颜色可以实用颜色缩写，你也可以指定颜色码（例如，‘#CECECE’）。</p>
<p>线图可以实用标记强调数据点，如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">239</span>]: plt.plot(np.random.randn(<span class="number">30</span>).cumsum(), <span class="string">&#x27;ko--&#x27;</span>)</span><br><span class="line">Out[<span class="number">239</span>]: [&lt;matplotlib.lines.Line2D at <span class="number">0x2b500738aa10</span>&gt;]</span><br><span class="line"></span><br><span class="line">In [<span class="number">240</span>]: plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(np.random.randn(<span class="number">30</span>).cumsum(), color=<span class="string">&#x27;k&#x27;</span>, linestyle=<span class="string">&#x27;dashed&#x27;</span>, marker=<span class="string">&#x27;o&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="设置标题">设置标题</h3>
<p>先创建一个随机的折线图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">ax.plot(np.random.randn(<span class="number">1000</span>).cumsum())</span><br></pre></td></tr></table></figure>
<p>要改变X 轴刻度，最简单的方法就是实用 set_xticks 和 set_xticklabels 。 前者告诉 matplotlib 要将刻度放在哪些位置，后面可以修改标签的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ticks = ax.set_xticks([<span class="number">0</span>, <span class="number">250</span>, <span class="number">500</span>, <span class="number">750</span>, <span class="number">1000</span>])</span><br><span class="line">labels = ax.set_xticklabels([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>], rotation=<span class="number">30</span>, fontsize=<span class="string">&#x27;small&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>rotation 设定x轴标签倾斜 30 度。最后用 sex_xlabel 为X轴设置一个名称，并用 set_title 设置一个标题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax.set_title(<span class="string">&#x27;My first matplotlib plot&#x27;</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;Stages&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="22.png" alt="15"></p>
<p>Y 轴的修改方式与此类似，只需将上述代码中的 x 替换为 y 即可。</p>
<p>轴的类有集合方法，可以批量设定绘图选项，例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">props = &#123;</span><br><span class="line">	<span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;My first matplotlib plot&#x27;</span></span><br><span class="line">	<span class="string">&#x27;xlabel&#x27;</span>: <span class="string">&#x27;Stages&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">ax.<span class="built_in">set</span>(**props)</span><br></pre></td></tr></table></figure>
<h3 id="添加图例">添加图例</h3>
<p>图例 (legend) 添加可以使用 label 参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> randn</span><br><span class="line">fig = plt.figure(); ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">ax.plot(randn(<span class="number">1000</span>).cumsum(), <span class="string">&#x27;k&#x27;</span>, label=<span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">ax.plot(randn(<span class="number">1000</span>).cumsum(), <span class="string">&#x27;k--&#x27;</span>, label=<span class="string">&#x27;two&#x27;</span>)</span><br><span class="line">ax.plot(randn(<span class="number">1000</span>).cumsum(), <span class="string">&#x27;k.&#x27;</span>, label=<span class="string">&#x27;three&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="23.png" alt="15"></p>
<p>这里 loc 选项选择图例位置，“best” 会选择最不碍事的位置放图例。</p>
<h3 id="注解">注解</h3>
<p>除标准的绘图类型，你可能还希望绘制一些子集的注解，可能是文本、箭头或其他图形等。注解和文字可以通过 text, arrow 和 annotate 函数进行添加。text 可以将文本绘制在图表的指定坐标 (x,y) ，还可以添加一些自定义格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax.text(x,y, <span class="string">&#x27;Hello world&#x27;</span>, family=<span class="string">&#x27;monospace&#x27;</span>, fontsize=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<h3 id="将图表保存到文件">将图表保存到文件</h3>
<p>利用 plt.savefig 可以将当前图表保存到文件。例如，要将图表保存为 SVG 文件，你只需输入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.savefig(<span class="string">&#x27;fig.svg&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这个命令和 <code>plt.show()</code> 冲突，运行过  <code>plt.show()</code> 之后再保存图片就是空的，需要再次运行画图代码。</p>
<p>SVG 图片可以直接通过拖到浏览器查看。</p>
<p>保存的文件类型是通过文件扩展名推断出来的。因此，如果你使用的是 <code>.pdf</code> ，就会得到一个PDF文件。另外两个重要的选项是 dpi (分辨率，每英寸像素点) 和 bbox_inches (剪除图表周围的空白部分)。</p>
<p>如果要得到一张带有最小白边且分辨率为 5400 dpi 的 PNG 图片，你可以输入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.savefig(<span class="string">&#x27;figpath.png&#x27;</span>, dpi=<span class="number">400</span>, bbox_inches=<span class="string">&#x27;tight&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>savefit 的其他选项如下：<br>
<img src="24.png" alt="15"></p>
<h2 id="使用-pandas-和-seaborn-绘图">使用 pandas 和 seaborn 绘图</h2>
<p>matplotlib 实际上是一种比较低级的工具。</p>
<p>在 pandas 中，我们有多列数据，还有行和列标签。pandas 自身就有内置方法，可以画图。</p>
<h3 id="线型图">线型图</h3>
<p>Series 和 DataFrame 都有一个用于生成各类图表的 plot 方法。默认情况下，他们所生成的是线型图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = pd.Series(np.random.randn(<span class="number">10</span>).cumsum(), index=np.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>))</span><br><span class="line">s.plot()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="25.png" alt="25"></p>
<p>该 Series 对象的索引会被传给 matplotlib ，并用于绘制 X 轴。可以通过 use_index = False 禁用该功能。可用参数如下：</p>
<p><img src="26.png" alt="25"></p>
<p>DataFrame 的 plot 方法会在一个子图中为各列绘制一条线，并自动创建图例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: df = pd.DataFrame(np.random.randn(<span class="number">10</span>, <span class="number">4</span>).cumsum(<span class="number">0</span>),</span><br><span class="line">    ...:     columns=[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>],</span><br><span class="line">    ...:     index=np.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: df.plot()</span><br><span class="line">Out[<span class="number">11</span>]: &lt;matplotlib.axes._subplots.AxesSubplot at <span class="number">0x2b1c67f15090</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="27.png" alt="25"></p>
<p>plot 属性包含一批不同绘图类型的方法。例如，df.plot() 等价于 df.plot.line() 。</p>
<p>DataFrame 还有一些用于对列进行灵活处理的选项，例如，是见所有列都绘制到一个子图中还是创建各自的子图。详细信息见下表：</p>
<p><img src="28.png" alt="25"></p>
<p>下面我自己简单测试了一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: df.plot(subplots=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">13</span>]:</span><br><span class="line">array([&lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x2b1c66166590</span>&gt;,</span><br><span class="line">       &lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x2b1c760f3e50</span>&gt;,</span><br><span class="line">       &lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x2b1c76125f50</span>&gt;,</span><br><span class="line">       &lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x2b1c76166ad0</span>&gt;],</span><br><span class="line">      dtype=<span class="built_in">object</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="29.png" alt="25"></p>
<p>X 轴 公用，Y轴不共用。</p>
<p>设定了 sharex, sharey ，才保持一致</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">19</span>]: df.plot(subplots=<span class="literal">True</span>, sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">19</span>]:</span><br><span class="line">array([&lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x2b1c76661d50</span>&gt;,</span><br><span class="line">       &lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x2b1c767dac10</span>&gt;,</span><br><span class="line">       &lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x2b1c7680ce50</span>&gt;,</span><br><span class="line">       &lt;matplotlib.axes._subplots.AxesSubplot <span class="built_in">object</span> at <span class="number">0x2b1c76849dd0</span>&gt;],</span><br><span class="line">      dtype=<span class="built_in">object</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="30.png" alt="25"></p>
<h3 id="柱状图">柱状图</h3>
<p>plot.bar() 和 plot.barh() 分布绘制水平和垂直的柱状图。这时，Series 和 DataFrame 的索引将会被用作 X 或 Y 轴刻度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">21</span>]: fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: data = pd.Series(np.random.randn(<span class="number">16</span>), index=<span class="built_in">list</span>(<span class="string">&#x27;abcdefghijklmnop&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: data.plot.bar(ax=axes[<span class="number">0</span>], color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.7</span>)</span><br><span class="line">Out[<span class="number">23</span>]: &lt;matplotlib.axes._subplots.AxesSubplot at <span class="number">0x2b1c7691da50</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: data.plot.barh(ax=axes[<span class="number">1</span>], color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.7</span>)</span><br><span class="line">Out[<span class="number">24</span>]: &lt;matplotlib.axes._subplots.AxesSubplot at <span class="number">0x2b1c76aeb1d0</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="31.png" alt="25"></p>
<p>color=‘k’ 将颜色设定为黑色。</p>
<p>对于 DataFrame ，柱状图会将每一行的值分为一组，并排显示，如下例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">26</span>]: df = pd.DataFrame(np.random.rand(<span class="number">6</span>, <span class="number">4</span>),</span><br><span class="line">    ...:         index=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>, <span class="string">&#x27;six&#x27;</span>],</span><br><span class="line">    ...:         columns=pd.Index([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>], name=<span class="string">&#x27;Genus&#x27;</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: df</span><br><span class="line">Out[<span class="number">27</span>]:</span><br><span class="line">Genus         A         B         C         D</span><br><span class="line">one    <span class="number">0.439900</span>  <span class="number">0.741166</span>  <span class="number">0.833590</span>  <span class="number">0.686111</span></span><br><span class="line">two    <span class="number">0.259917</span>  <span class="number">0.567687</span>  <span class="number">0.336494</span>  <span class="number">0.338792</span></span><br><span class="line">three  <span class="number">0.190885</span>  <span class="number">0.642303</span>  <span class="number">0.042369</span>  <span class="number">0.729165</span></span><br><span class="line">four   <span class="number">0.513517</span>  <span class="number">0.561645</span>  <span class="number">0.416062</span>  <span class="number">0.622564</span></span><br><span class="line">five   <span class="number">0.735675</span>  <span class="number">0.802471</span>  <span class="number">0.830851</span>  <span class="number">0.300943</span></span><br><span class="line">six    <span class="number">0.127605</span>  <span class="number">0.102774</span>  <span class="number">0.951503</span>  <span class="number">0.604227</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: df.plot.bar()</span><br><span class="line">Out[<span class="number">28</span>]: &lt;matplotlib.axes._subplots.AxesSubplot at <span class="number">0x2b1c76de1550</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="32.png" alt="25"></p>
<p>注意，DataFrame 各列的名称 “Genus” 被用作了图例的标题。</p>
<p>设置 stacked=True 即可为 DataFrame 生成堆积柱状图，这样每行的值会被堆积在一起。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">32</span>]: df.plot.barh(stacked=<span class="literal">True</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">Out[<span class="number">32</span>]: &lt;matplotlib.axes._subplots.AxesSubplot at <span class="number">0x2b1c76e59050</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="33.png" alt="25"></p>
<blockquote>
<p>笔记：柱状图有一个非常不错的用法：利用value_counts图形化显示Series中各值的出现频<br>
率，比如s.value_counts().plot.bar()。</p>
</blockquote>
<p>后面的内容有些鸡肋，深度不够，不够细。</p>
<p>这里作者主要推荐的是用 pandas，matplotlib, seaborn 三个包来画图。</p>
<h1>数据聚合与分组运算</h1>
<p>对数据集进行分组并对各组应用一个函数，通常是数据分析中的重要环节。</p>
<p>关系型数据库和 SQL语言能够如此流行的原因之一就是能方便地对数据进行连接、过滤、转换和聚合。但是，像SQL这样的查询语言所能执行的分组运算的种类很有限。而由于 Python 和 pandas 强大的表达能力，我们可以执行复杂得多的分组运算。</p>
<h2 id="GroupBy-机制">GroupBy 机制</h2>
<p>Hadley Wickham 创造了一个用于表示分组运算的术语 “split-apply-combine” （拆分-应用-合并）。举例如下：</p>
<p><img src="34.png" alt="25"></p>
<p>来看例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">34</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span> : [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>],</span><br><span class="line">    ...:                    <span class="string">&#x27;key2&#x27;</span> : [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">    ...:                    <span class="string">&#x27;data1&#x27;</span> : np.random.randn(<span class="number">5</span>),</span><br><span class="line">    ...:                    <span class="string">&#x27;data2&#x27;</span> : np.random.randn(<span class="number">5</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: df</span><br><span class="line">Out[<span class="number">35</span>]:</span><br><span class="line">  key1 key2     data1     data2</span><br><span class="line"><span class="number">0</span>    a  one -<span class="number">0.859564</span>  <span class="number">0.339009</span></span><br><span class="line"><span class="number">1</span>    a  two -<span class="number">0.916791</span>  <span class="number">2.481367</span></span><br><span class="line"><span class="number">2</span>    b  one  <span class="number">0.839091</span> -<span class="number">0.046682</span></span><br><span class="line"><span class="number">3</span>    b  two -<span class="number">0.082457</span>  <span class="number">0.491686</span></span><br><span class="line"><span class="number">4</span>    a  one -<span class="number">0.750082</span> -<span class="number">0.349382</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设你想要按 key1 进行分组，并计算 data1 列的平均值。这里我们可以调用 groupby ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">36</span>]: grouped = df[<span class="string">&#x27;data1&#x27;</span>].groupby(df[<span class="string">&#x27;key1&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: grouped</span><br><span class="line">Out[<span class="number">37</span>]: &lt;pandas.core.groupby.generic.SeriesGroupBy <span class="built_in">object</span> at <span class="number">0x2b1c773de190</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>变量 grouped 是一个 GroupBy 对象。它实际上还没有进行任何计算，只是含有一些有关分组键 df[‘key1’] 的中间数据而已。</p>
<p>下面，我们可以调用 GroupBy 的 mean 方法来计算分组平均值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">38</span>]: grouped.mean()</span><br><span class="line">Out[<span class="number">38</span>]:</span><br><span class="line">key1</span><br><span class="line">a   -<span class="number">0.842146</span></span><br><span class="line">b    <span class="number">0.378317</span></span><br><span class="line">Name: data1, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用于分组键除了是 Series，也可以是任何长度相同的数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">39</span>]: states = np.array([<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: df[<span class="string">&#x27;data1&#x27;</span>].groupby(states).mean()</span><br><span class="line">Out[<span class="number">40</span>]:</span><br><span class="line">California   -<span class="number">0.038850</span></span><br><span class="line">Ohio         -<span class="number">0.564034</span></span><br><span class="line">Name: data1, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果要处理整个 DataFrame，可以直接将列名作为分组键，这样所有<strong>数值列</strong>都会被统计：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">41</span>]: df.groupby(<span class="string">&#x27;key1&#x27;</span>).mean()</span><br><span class="line">Out[<span class="number">41</span>]:</span><br><span class="line">         data1     data2</span><br><span class="line">key1</span><br><span class="line">a    -<span class="number">0.842146</span>  <span class="number">0.823665</span></span><br><span class="line">b     <span class="number">0.378317</span>  <span class="number">0.222502</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>GroupBy 的 size 方法，可以返回一个含有分组大小的 Series :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">42</span>]: df.groupby(<span class="string">&#x27;key1&#x27;</span>).size()</span><br><span class="line">Out[<span class="number">42</span>]:</span><br><span class="line">key1</span><br><span class="line">a    <span class="number">3</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，<strong>任何分组关键中的缺失值，都会被从结果中剔除</strong>。</p>
<h3 id="选取一列或列的子集">选取一列或列的子集</h3>
<p>对于 DataFrame 产生的 GroupBy 对象，可以通过列名进行索引，提取部分列进行聚合，例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.groupby(<span class="string">&#x27;key1&#x27;</span>)[<span class="string">&#x27;data1&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;data1&#x27;</span>].groupby(df[<span class="string">&#x27;key1&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h3 id="通过字典或-Series-进行分组">通过字典或 Series 进行分组</h3>
<p>除数组以外，分组信息还可以其他形式存在。来看另一个示例 DataFrame :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">43</span>]: people = pd.DataFrame(np.random.randn(<span class="number">5</span>, <span class="number">5</span>),</span><br><span class="line">    ...:                       columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>],</span><br><span class="line">    ...:                       index=[<span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span>, <span class="string">&#x27;Wes&#x27;</span>, <span class="string">&#x27;Jim&#x27;</span>, <span class="string">&#x27;Travis&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: people.iloc[<span class="number">2</span>:<span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>]] = np.nan <span class="comment"># Add a few NA values</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: people</span><br><span class="line">Out[<span class="number">45</span>]:</span><br><span class="line">               a         b         c         d         e</span><br><span class="line">Joe    -<span class="number">0.710077</span>  <span class="number">1.798009</span>  <span class="number">1.145594</span> -<span class="number">0.092056</span> -<span class="number">0.771903</span></span><br><span class="line">Steve  -<span class="number">0.421123</span> -<span class="number">0.114673</span> -<span class="number">1.686388</span>  <span class="number">0.208454</span> -<span class="number">0.079794</span></span><br><span class="line">Wes    -<span class="number">0.914421</span>       NaN       NaN  <span class="number">0.139538</span> -<span class="number">0.602301</span></span><br><span class="line">Jim     <span class="number">0.500169</span>  <span class="number">0.547281</span>  <span class="number">0.281964</span> -<span class="number">1.698055</span>  <span class="number">0.692408</span></span><br><span class="line">Travis  <span class="number">1.505062</span> -<span class="number">0.920465</span>  <span class="number">0.119292</span> -<span class="number">0.955576</span> -<span class="number">0.666082</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，假设已知列的分组关系，并希望根据分组计算列的和：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">46</span>]: mapping = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;c&#x27;</span>: <span class="string">&#x27;blue&#x27;</span>,</span><br><span class="line">    ...:             <span class="string">&#x27;d&#x27;</span>: <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;e&#x27;</span>: <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;f&#x27;</span> : <span class="string">&#x27;orange&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>现在，你可以将这个字典传给 groupby</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">47</span>]: by_column = people.groupby(mapping, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: by_column.<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">48</span>]:</span><br><span class="line">            blue       red</span><br><span class="line">Joe     <span class="number">1.053538</span>  <span class="number">0.316029</span></span><br><span class="line">Steve  -<span class="number">1.477934</span> -<span class="number">0.615591</span></span><br><span class="line">Wes     <span class="number">0.139538</span> -<span class="number">1.516722</span></span><br><span class="line">Jim    -<span class="number">1.416092</span>  <span class="number">1.739859</span></span><br><span class="line">Travis -<span class="number">0.836284</span> -<span class="number">0.081486</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Series 也有同样的功能，它可以被看做一个固定大小的映射：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">49</span>]: map_series = pd.Series(mapping)</span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: map_series</span><br><span class="line">Out[<span class="number">50</span>]:</span><br><span class="line">a       red</span><br><span class="line">b       red</span><br><span class="line">c      blue</span><br><span class="line">d      blue</span><br><span class="line">e       red</span><br><span class="line">f    orange</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: people.groupby(map_series, axis=<span class="number">1</span>).<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">51</span>]:</span><br><span class="line">            blue       red</span><br><span class="line">Joe     <span class="number">1.053538</span>  <span class="number">0.316029</span></span><br><span class="line">Steve  -<span class="number">1.477934</span> -<span class="number">0.615591</span></span><br><span class="line">Wes     <span class="number">0.139538</span> -<span class="number">1.516722</span></span><br><span class="line">Jim    -<span class="number">1.416092</span>  <span class="number">1.739859</span></span><br><span class="line">Travis -<span class="number">0.836284</span> -<span class="number">0.081486</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="通过函数进行分组">通过函数进行分组</h3>
<p>比起使用字典或 Series,  使用Python函数是一种更原生的方法定义分组映射。任何被当作分组键的函数都会在各个索引值上被调用一次，其返回值就会被用作分组名称。具体点所，以上一小节的示例 DataFrame 为例，其索引值为人的名字。你可以计算一个字符串长度的数组，更简单的方法是传入 len 函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">53</span>]: people.groupby(<span class="built_in">len</span>).<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">53</span>]:</span><br><span class="line">          a         b         c         d         e</span><br><span class="line"><span class="number">3</span> -<span class="number">1.124329</span>  <span class="number">2.345290</span>  <span class="number">1.427558</span> -<span class="number">1.650573</span> -<span class="number">0.681796</span></span><br><span class="line"><span class="number">5</span> -<span class="number">0.421123</span> -<span class="number">0.114673</span> -<span class="number">1.686388</span>  <span class="number">0.208454</span> -<span class="number">0.079794</span></span><br><span class="line"><span class="number">6</span>  <span class="number">1.505062</span> -<span class="number">0.920465</span>  <span class="number">0.119292</span> -<span class="number">0.955576</span> -<span class="number">0.666082</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="数据聚合">数据聚合</h2>
<p>聚合指的是任何能够<strong>从数组产生标量值</strong>的数据转换过程。常见的聚合运算如下：</p>
<p><img src="35.png" alt="25"></p>
<p>quantile 可以计算 Series 的 样本分位数，也可以用于 GroupBy</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">58</span>]: df</span><br><span class="line">Out[<span class="number">58</span>]:</span><br><span class="line">  key1 key2     data1     data2</span><br><span class="line"><span class="number">0</span>    a  one -<span class="number">0.859564</span>  <span class="number">0.339009</span></span><br><span class="line"><span class="number">1</span>    a  two -<span class="number">0.916791</span>  <span class="number">2.481367</span></span><br><span class="line"><span class="number">2</span>    b  one  <span class="number">0.839091</span> -<span class="number">0.046682</span></span><br><span class="line"><span class="number">3</span>    b  two -<span class="number">0.082457</span>  <span class="number">0.491686</span></span><br><span class="line"><span class="number">4</span>    a  one -<span class="number">0.750082</span> -<span class="number">0.349382</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: grouped = df.groupby(<span class="string">&#x27;key1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: grouped[<span class="string">&#x27;data1&#x27;</span>].quantile(<span class="number">0.9</span>)</span><br><span class="line">Out[<span class="number">60</span>]:</span><br><span class="line">key1</span><br><span class="line">a   -<span class="number">0.771979</span></span><br><span class="line">b    <span class="number">0.746936</span></span><br><span class="line">Name: data1, dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果要使用你自己的聚合函数，只需将其传入 aggregate 或 agg 方法即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">61</span>]: <span class="function"><span class="keyword">def</span> <span class="title">peak_to_peak</span>(<span class="params">arr</span>):</span></span><br><span class="line">    ...:     <span class="keyword">return</span> arr.<span class="built_in">max</span>() - arr.<span class="built_in">min</span>()</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: grouped.agg(peak_to_peak)</span><br><span class="line">Out[<span class="number">62</span>]:</span><br><span class="line">         data1     data2</span><br><span class="line">key1</span><br><span class="line">a     <span class="number">0.166709</span>  <span class="number">2.830750</span></span><br><span class="line">b     <span class="number">0.921549</span>  <span class="number">0.538368</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是，自定义聚合函数要比上表中那些经过优化的函数慢得多。</p>
<h1>pandas 建模库介绍</h1>
<p>python 有两个流行的建模工具，statsmodels 和 scikit-learn 。</p>
<h2 id="pandas-与模型代码的接口">pandas 与模型代码的接口</h2>
<p>模型开发的通常工作流是使用 pandas 进行数据加载和清洗，然后切换到建模库进行建模。</p>
<p>pandas 与 其他分析库通常是靠 Numpy 的数组联系起来的。将 DataFrame 转换为 Numpy 数组，可以使用 <code>.value</code> 属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">63</span>]: data = pd.DataFrame(&#123;</span><br><span class="line">    ...:     <span class="string">&#x27;x0&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">    ...:     <span class="string">&#x27;x1&#x27;</span>: [<span class="number">0.01</span>, -<span class="number">0.01</span>, <span class="number">0.25</span>, -<span class="number">4.1</span>, <span class="number">0.</span>],</span><br><span class="line">    ...:     <span class="string">&#x27;y&#x27;</span>: [-<span class="number">1.5</span>, <span class="number">0.</span>, <span class="number">3.6</span>, <span class="number">1.3</span>, -<span class="number">2.</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: data</span><br><span class="line">Out[<span class="number">64</span>]:</span><br><span class="line">   x0    x1    y</span><br><span class="line"><span class="number">0</span>   <span class="number">1</span>  <span class="number">0.01</span> -<span class="number">1.5</span></span><br><span class="line"><span class="number">1</span>   <span class="number">2</span> -<span class="number">0.01</span>  <span class="number">0.0</span></span><br><span class="line"><span class="number">2</span>   <span class="number">3</span>  <span class="number">0.25</span>  <span class="number">3.6</span></span><br><span class="line"><span class="number">3</span>   <span class="number">4</span> -<span class="number">4.10</span>  <span class="number">1.3</span></span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>  <span class="number">0.00</span> -<span class="number">2.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: data.columns</span><br><span class="line">Out[<span class="number">65</span>]: Index([<span class="string">&#x27;x0&#x27;</span>, <span class="string">&#x27;x1&#x27;</span>, <span class="string">&#x27;y&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: data.values</span><br><span class="line">Out[<span class="number">66</span>]:</span><br><span class="line">array([[ <span class="number">1.</span>  ,  <span class="number">0.01</span>, -<span class="number">1.5</span> ],</span><br><span class="line">       [ <span class="number">2.</span>  , -<span class="number">0.01</span>,  <span class="number">0.</span>  ],</span><br><span class="line">       [ <span class="number">3.</span>  ,  <span class="number">0.25</span>,  <span class="number">3.6</span> ],</span><br><span class="line">       [ <span class="number">4.</span>  , -<span class="number">4.1</span> ,  <span class="number">1.3</span> ],</span><br><span class="line">       [ <span class="number">5.</span>  ,  <span class="number">0.</span>  , -<span class="number">2.</span>  ]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要转换回 DataFrame，可以传递一个二维 ndarray ，可带有列名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">67</span>]: df2 = pd.DataFrame(data.values, columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: df2</span><br><span class="line">Out[<span class="number">68</span>]:</span><br><span class="line">   one   two  three</span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">0.01</span>   -<span class="number">1.5</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2.0</span> -<span class="number">0.01</span>    <span class="number">0.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3.0</span>  <span class="number">0.25</span>    <span class="number">3.6</span></span><br><span class="line"><span class="number">3</span>  <span class="number">4.0</span> -<span class="number">4.10</span>    <span class="number">1.3</span></span><br><span class="line"><span class="number">4</span>  <span class="number">5.0</span>  <span class="number">0.00</span>   -<span class="number">2.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：如果数据类型不一致，转换成 ndarray 后会是 python 对象的 ndarray :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">69</span>]: df3 = data.copy()</span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: df3[<span class="string">&#x27;strings&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: df3</span><br><span class="line">Out[<span class="number">71</span>]:</span><br><span class="line">   x0    x1    y strings</span><br><span class="line"><span class="number">0</span>   <span class="number">1</span>  <span class="number">0.01</span> -<span class="number">1.5</span>       a</span><br><span class="line"><span class="number">1</span>   <span class="number">2</span> -<span class="number">0.01</span>  <span class="number">0.0</span>       b</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span>  <span class="number">0.25</span>  <span class="number">3.6</span>       c</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span> -<span class="number">4.10</span>  <span class="number">1.3</span>       d</span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>  <span class="number">0.00</span> -<span class="number">2.0</span>       e</span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: df3.values</span><br><span class="line">Out[<span class="number">72</span>]:</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">0.01</span>, -<span class="number">1.5</span>, <span class="string">&#x27;a&#x27;</span>],</span><br><span class="line">       [<span class="number">2</span>, -<span class="number">0.01</span>, <span class="number">0.0</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">0.25</span>, <span class="number">3.6</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">       [<span class="number">4</span>, -<span class="number">4.1</span>, <span class="number">1.3</span>, <span class="string">&#x27;d&#x27;</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">0.0</span>, -<span class="number">2.0</span>, <span class="string">&#x27;e&#x27;</span>]], dtype=<span class="built_in">object</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="继续学习">继续学习</h2>
<p>前面讲的不细，没看。下面为作者推荐的 python 建模的书籍。</p>
<p><img src="36.png" alt="36"></p>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>基于芯片数据的亲子鉴定分析代码</title>
    <url>/posts/42752926/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本软件通过利用SNP信息根据孟德尔错误位点比例，对于系谱中均具有基因型的亲子对进行亲子鉴定，判断系谱是否正确。这里的孟德尔错误位点指个体和亲本之间具有相反的纯和子的位点（例如个体的基因型为AA，亲本的基因型为GG），依据孟德尔定律亲子间不应存在这种情况，但由于突变和分型错误等原因，真实的亲子对之间仍存在少量的孟德尔错误位点。当使用的位点数目较多时，通过设定一个合理的阈值可以明确判定系谱中正确的亲子关系和错误的亲子关系。</p>
<span id="more"></span>
<h1>使用软件</h1>
<h1>软件</h1>
<p>python 3.0 以上版本，事先安装 numpy 模块</p>
<h1>输入文件格式</h1>
<ul>
<li>
<p>raw 文件：通过 plink 软件对<strong>原始芯片数据</strong>（未填充）采用 <code>--recodeA</code> 选项生成的文件，后缀为 <code>.raw</code></p>
</li>
<li>
<p>映射文件： 两列，所有基因型个体的芯片号与个体号，空格或 tab分隔，无标题。</p>
</li>
<li>
<p>系谱文件：三列，个体号-父号-母号，空格或 tab分隔，无标题。</p>
</li>
</ul>
<h1>输出文件说明</h1>
<ul>
<li><code>check_pedigree.csv</code>: 五列，个体 - 原系谱中的父本 - 原系谱中的母本 -  父本判定信息 - 母本判定信息（ 三种判定信息，par_nogeno : 亲本没有基因型信息，Match : 亲本符合阈值要求， No-Match : 亲本不符合阈值要求 ）</li>
<li><code>check_paternity_prob.csv</code>: 七列，亲子对类型 - 个体 - 亲本 - 错误位点数 -  匹配的位点总数（剔除缺失位点）- 错误位点概率 - 判定信息</li>
</ul>
<h1>运行代码</h1>
<p>代码文件见：<a href="https://github.com/VincereZhou/code_backup/blob/master/paternity_check_1.0.py">paternity_check_1.0.py</a></p>
<p>将输入文件和本程序放在同一文件夹下，运行命令示范为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python paternity_check_1.0.py --raw test.raw --chipid test_id.txt --pedigree pedigree.txt --check-prob 0.005</span><br></pre></td></tr></table></figure>
<p><strong>可用参数说明：</strong></p>
<p><code>--raw</code> : 基因型文件名，必选。</p>
<p><code>--chipid</code> : 基因型个体映射文件名，必选。</p>
<p><code>--pedigree</code> : 系谱文件名，必选</p>
<p><code>--list</code> : 需要进行亲子鉴定的个体文件名，可选。如果提供该参数，则只对这个文件中的个体进行亲子鉴定；如果不提供该参数，则默认对所有基因型个体进行亲子鉴定。</p>
<p>-<code>-check-prob</code> : 亲子鉴定孟德尔错误率的阈值，可选，默认为0.005</p>
<p>-<code>-miss-snp</code> : SNP位点的基因分型缺失率阈值，可选，默认为0.2</p>
<p>-<code>-maf</code> : SNP 位点的最小等位基因频率阈值，可选，默认为0.01</p>
<p>-<code>-miss-sample</code> : 样本的基因分型缺失率阈值，可选，默认为0.5</p>
<h1>代码说明</h1>
<h2 id="读取文件">读取文件</h2>
<p>这里首先打印了一下 raw 文件中的样本数目，实质采用 linux 命令 <code>wc -l</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打印raw文件行数</span></span><br><span class="line">raw_lines = os.popen(<span class="string">&quot;wc -l &#123;&#125;&quot;</span>.<span class="built_in">format</span>(args.raw)).read().split()[<span class="number">0</span>]</span><br><span class="line">true_raw_lines = <span class="built_in">int</span>(raw_lines) -<span class="number">1</span> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of records in raw file: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(true_raw_lines))</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取文件</span></span><br><span class="line">raw_file = <span class="built_in">open</span>(args.raw,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">chipid_file = <span class="built_in">open</span>(args.chipid,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">pedigree_file = <span class="built_in">open</span>(args.pedigree,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#new_raw = open(&quot;newid.raw&quot;,&#x27;w+&#x27;)</span></span><br><span class="line"></span><br><span class="line">check_prob = <span class="built_in">open</span>(<span class="string">&quot;chek_paternity_prob.txt&quot;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">check_pedigree = <span class="built_in">open</span>(<span class="string">&quot;check_pedigree.txt&quot;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="映射与raw文件处理">映射与raw文件处理</h2>
<p>这里先对映射文件进行处理，过滤条件有两个：</p>
<ol>
<li>每一行的列数必须大于等于2</li>
<li>重复个体号会保留第一个</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set1=<span class="built_in">set</span>();dick=&#123;&#125;</span><br><span class="line">j=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> chipid_file:</span><br><span class="line">    f = i.split()</span><br><span class="line">    j+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(f) &gt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> set1: <span class="comment">#去除重复个体号</span></span><br><span class="line">            set1.add(f[<span class="number">1</span>])</span><br><span class="line">            dick[f[<span class="number">0</span>]] = f[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Warning: &#123;&#125; row in chipid file has less than 2 coloum\n&quot;</span>.<span class="built_in">format</span>(j))</span><br></pre></td></tr></table></figure>
<p>再对 raw 文件进行处理，提取在映射文件中的个体的基因型，生成基因型的二维数组（array1）。这里将缺失值NA替换为3。<code>gene_id_array</code> 是相应的个体号一维数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gene_list=[]</span><br><span class="line">raw_list=[]</span><br><span class="line">raw_file.readline() <span class="comment">#剔除标题</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> raw_file:</span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">in</span> dick:</span><br><span class="line">        gene_list.append(dick[f[<span class="number">1</span>]])</span><br><span class="line">        raw_list.append(<span class="string">&#x27;\t&#x27;</span>.join(f[<span class="number">6</span>:]))</span><br><span class="line">        <span class="comment">#new_raw.write(&#x27;\t&#x27;.join(f[6:])+&#x27;\n&#x27;)</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Warning: &#123;&#125; in raw file not in chpid file or is duplicated samples\n&quot;</span>.<span class="built_in">format</span>(f[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">gene_id_array = np.array(gene_list)</span><br><span class="line"></span><br><span class="line"><span class="comment">#new_raw.seek(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># snp 缺失值过滤，结果文件是 array2</span></span><br><span class="line"><span class="comment">#numpy 0/1 结果会显示为 nan</span></span><br><span class="line">array1 = np.genfromtxt(raw_list, dtype=np.int8, missing_values=<span class="string">&quot;NA&quot;</span>, filling_values=<span class="number">3</span>)</span><br><span class="line"><span class="comment">#array2 = array1.copy()</span></span><br><span class="line"></span><br><span class="line">sample_num = array1.shape[<span class="number">0</span>]</span><br><span class="line">snp_num = array1.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of SNPs in raw file: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(snp_num))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of records present in chipid file: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(sample_num))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="位点和样本质控">位点和样本质控</h2>
<h3 id="位点缺失率">位点缺失率</h3>
<p>这里统计每一列（SNP）中等于3（表示缺失）的比例，剔除缺失率高于阈值的SNP。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bool_array1 = array1==<span class="number">3</span></span><br><span class="line"></span><br><span class="line">total_miss = bool_array1.<span class="built_in">sum</span>()/(bool_array1.shape[<span class="number">0</span>] * bool_array1.shape[<span class="number">1</span>])</span><br><span class="line">toatl_callrate = <span class="number">1</span> - total_miss</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Total genotyping rate is &#123;:.3f&#125;\n&quot;</span>.<span class="built_in">format</span>(toatl_callrate))</span><br><span class="line"></span><br><span class="line">snp_missing_count = bool_array1.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">snp_missing_prob = snp_missing_count/sample_num</span><br><span class="line"></span><br><span class="line">snp_missing_min = snp_missing_prob.<span class="built_in">min</span>()</span><br><span class="line">snp_missing_mean = snp_missing_prob.mean()</span><br><span class="line">snp_missing_max = snp_missing_prob.<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印snp缺失值情况</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;SNP missing\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;  Min missing rate: &#123;:.3f&#125;\n&quot;</span>.<span class="built_in">format</span>(snp_missing_min))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;  AVG missing rate: &#123;:.3f&#125;\n&quot;</span>.<span class="built_in">format</span>(snp_missing_mean))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;  Max missing rate: &#123;:.3f&#125;\n&quot;</span>.<span class="built_in">format</span>(snp_missing_max))</span><br><span class="line"><span class="comment">#np.savetxt(&quot;snp_missing.txt&quot;,snp_missing_prob, fmt=&#x27;%.4f&#x27;)</span></span><br><span class="line"></span><br><span class="line">snp_missing_pick = snp_missing_prob &lt; <span class="built_in">float</span>(args.miss_snp)</span><br><span class="line">array2 = array1[:,snp_missing_pick]</span><br><span class="line">snp_miss_remove = array1.shape[<span class="number">1</span>] - array2.shape[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; snps removed due to missing genotype data\n&quot;</span>.<span class="built_in">format</span>(snp_miss_remove))</span><br><span class="line"><span class="keyword">del</span> array1</span><br><span class="line"><span class="keyword">del</span> bool_array1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="MAF-过滤">MAF 过滤</h3>
<p>统计每个SNP的最小等位基因频率（MAF），剔除低于阈值的位点。</p>
<p>这里的做法是先将缺失值替换为0，统计每一列的和作为分子，分母为该列非缺失样本数的两倍。这么做的原理是 plink 软件 在生成 raw 文件时是按照最小等位基因计数的（raw 文件中的 0 1 2 表示最小等位基因的数目），因此将缺失值替换为0，再求每列的和，便得到最小等位基因的总数，除以所有等位基因总数，便得到了最小等位基因频率。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># maf 过滤,结果文件是 array3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#计算array2每列的缺失值</span></span><br><span class="line">bool_array2 = array2==<span class="number">3</span></span><br><span class="line">snp_missing_count2 = bool_array2.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将array2 中的3替换为0，提取备份为 array2_copy</span></span><br><span class="line">array2_copy = array2.copy()</span><br><span class="line">array2[array2==<span class="number">3</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">maf_sum = array2.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment">#print(&quot;maf_sum[1:5] are &#123;&#125;&quot;.format(maf_sum[1:5]))</span></span><br><span class="line">maf_denominator = <span class="number">2</span>*(sample_num-snp_missing_count2)</span><br><span class="line"><span class="comment">#print(&quot;sample_num are &#123;&#125;&quot;.format(sample_num))</span></span><br><span class="line"><span class="comment">#print(&quot;maf_denominator[1:5] are &#123;&#125;&quot;.format(maf_denominator[1:5]))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">maf_prob = maf_sum/maf_denominator</span><br><span class="line"><span class="comment">#print(&quot;maf_prob[1:5] are &#123;&#125;&quot;.format(maf_prob[1:5]))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#maf_out = np.column_stack((maf_sum,maf_denominator,maf_prob))</span></span><br><span class="line"><span class="comment">#np.savetxt(&quot;maf_all.txt&quot;,maf_out)</span></span><br><span class="line"><span class="comment">#np.savetxt(&quot;maf.txt&quot;,maf_prob, fmt=&#x27;%.4f&#x27;)</span></span><br><span class="line"></span><br><span class="line">maf_min = maf_prob.<span class="built_in">min</span>()</span><br><span class="line">maf_mean = maf_prob.mean()</span><br><span class="line">maf_max = maf_prob.<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印MAF情况</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Minor alleles frequencies\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;  Min alleles frequencies: &#123;:.3f&#125;\n&quot;</span>.<span class="built_in">format</span>(maf_min))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;  AVG alleles frequencies: &#123;:.3f&#125;\n&quot;</span>.<span class="built_in">format</span>(maf_mean))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;  Max alleles frequencies: &#123;:.3f&#125;\n&quot;</span>.<span class="built_in">format</span>(maf_max))</span><br><span class="line"></span><br><span class="line">snp_maf_pick = maf_prob &gt; <span class="built_in">float</span>(args.maf)</span><br><span class="line">array3 = array2_copy[:,snp_maf_pick]</span><br><span class="line"></span><br><span class="line">snp_maf_remove = array2_copy.shape[<span class="number">1</span>] - array3.shape[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; snps removed due to minor allele threshold\n&quot;</span>.<span class="built_in">format</span>(snp_maf_remove))</span><br><span class="line"><span class="keyword">del</span> array2</span><br><span class="line"><span class="keyword">del</span> array2_copy</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="样本缺失率过滤">样本缺失率过滤</h3>
<p>先过滤SNP，再过滤样本，这和 plink 软件的逻辑一致，也符合实际需求。毕竟每个样本都是花了钱的，能不剔除就不剔除。</p>
<p>原理同SNP过滤，只不过列换成了行（每一列表示一个SNP，每一行表示一个样本）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sample_miss 过滤，结果为 array4</span></span><br><span class="line"></span><br><span class="line">sample_num3 = array3.shape[<span class="number">0</span>]</span><br><span class="line">snp_num3 = array3.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">bool_array3 = array3==<span class="number">3</span></span><br><span class="line"></span><br><span class="line">sample_missing_count = bool_array3.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">sample_missing_prob = sample_missing_count/snp_num3</span><br><span class="line"></span><br><span class="line">sample_missing_min = sample_missing_prob.<span class="built_in">min</span>()</span><br><span class="line">sample_missing_mean = sample_missing_prob.mean()</span><br><span class="line">sample_missing_max = sample_missing_prob.<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印sample缺失值情况</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sample missing\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;  Min missing rate: &#123;:.3f&#125;\n&quot;</span>.<span class="built_in">format</span>(sample_missing_min))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;  AVG missing rate: &#123;:.3f&#125;\n&quot;</span>.<span class="built_in">format</span>(sample_missing_mean))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;  Max missing rate: &#123;:.3f&#125;\n&quot;</span>.<span class="built_in">format</span>(sample_missing_max))</span><br><span class="line"></span><br><span class="line"><span class="comment">#np.savetxt(&quot;sample_missing.txt&quot;,sample_missing_prob, fmt=&#x27;%.4f&#x27;)</span></span><br><span class="line"></span><br><span class="line">sample_missing_pick = sample_missing_prob &lt; <span class="built_in">float</span>(args.miss_sample)</span><br><span class="line">array4 = array3[sample_missing_pick,:]</span><br><span class="line"></span><br><span class="line">gene_id_array_new = gene_id_array[sample_missing_pick] <span class="comment">#样本过滤后的基因个体号</span></span><br><span class="line"></span><br><span class="line">sample_miss_remove = array3.shape[<span class="number">0</span>] - array4.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; samples removed due to missing genotype data\n&quot;</span>.<span class="built_in">format</span>(sample_miss_remove))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; samples and &#123;&#125; snps pass QC finally\n&quot;</span>.<span class="built_in">format</span>(array4.shape[<span class="number">0</span>],array4.shape[<span class="number">1</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果剔除了样本，将样本和缺失率写入一个文件中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如果删除了样本，将删除的样本id和缺失率写入一个新文件</span></span><br><span class="line"><span class="keyword">if</span> sample_miss_remove &gt; <span class="number">0</span> :</span><br><span class="line">    filter_sample_file = <span class="built_in">open</span>(<span class="string">&#x27;sample_filted.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    sample_missing_fail = sample_missing_prob &gt;= <span class="built_in">float</span>(args.miss_sample)</span><br><span class="line">    gene_id_fail_array = gene_id_array[sample_missing_fail]</span><br><span class="line">    sample_missing_prob_array = sample_missing_prob[sample_missing_fail]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gene_id_fail_array.shape[<span class="number">0</span>]):</span><br><span class="line">        filter_sample_file.write(<span class="built_in">str</span>(gene_id_fail_array[i])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(<span class="string">&quot;&#123;:.4f&#125;&quot;</span>.<span class="built_in">format</span>(sample_missing_prob_array[i]))+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    filter_sample_file.close()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">del</span> array3</span><br><span class="line"><span class="keyword">del</span> bool_array3</span><br></pre></td></tr></table></figure>
<h2 id="亲子鉴定">亲子鉴定</h2>
<p>首先将基因型数组改为 1 2 3 0 ，对应之前的 0 1 2 3 。改完以后，0 就表示缺失，1 2 3 表示三种基因型。这样改方便之处在于：</p>
<ol>
<li>缺失值是0，0乘任何数还是0。</li>
<li>1,2,3 都是<strong>质数</strong>，这三个数之间任选两个数进行相乘得到的积是唯一的，比如如果乘积为2，那么只能是1和2相乘，3只能是1和3相乘……</li>
</ol>
<p>因此，这样我们在比对两个样本的基因型时，只需要将两个个体的基因型进行<strong>相乘</strong>，如果某个位点乘积为0，表示存在缺失（至少一个个体的基因型为缺失），无法比较；如果某个位点乘积为 3，表示在这个位点上存在孟德尔错误（两个个体为相反纯合子）。这样，我们统计两个个体的缺失位点和孟德尔错误位点非常方便。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#开始进行亲子鉴定</span><br><span class="line">#array4 改为 1 2 3 0(缺失)</span><br><span class="line">#这样两个array 的乘积的array为3的是错误位点，是0的是缺失位点。</span><br><span class="line"></span><br><span class="line">array4 +&#x3D; 1</span><br><span class="line">array4[array4&#x3D;&#x3D;4] &#x3D; 0</span><br><span class="line"></span><br><span class="line">snp_num4 &#x3D; array4.shape[1]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="清洗系谱">清洗系谱</h3>
<p>这里剔除了第一列个体没有基因型的行，因为个体没有基因型就不可能进行亲子鉴定 （如果提过了 --list 选项，那么只会提取需要亲子鉴定的个体的系谱）。</p>
<p>这里得到个体和亲本均有基因型的亲子对列表：<code>offspring_sire_list</code>  和  <code>offspring_dam_list</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#清洗系谱，剔除第一列个体没有基因型的行</span></span><br><span class="line"></span><br><span class="line">offspring_sire_list = []</span><br><span class="line">offspring_dam_list = []</span><br><span class="line">pedigree_list = []</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断 args.list 是否存在</span></span><br><span class="line">id_set = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">if</span> args.<span class="built_in">list</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> pedigree_file:</span><br><span class="line">        f = i.split()</span><br><span class="line">        id_set.add(f[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    list_file = <span class="built_in">open</span>(args.<span class="built_in">list</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> list_file:</span><br><span class="line">        f = i.split()</span><br><span class="line">        id_set.add(f[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">test_records=<span class="number">0</span></span><br><span class="line">sire_pairs=<span class="number">0</span></span><br><span class="line">dam_pairs=<span class="number">0</span></span><br><span class="line">pedigree_file.seek(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> pedigree_file:</span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> (f[<span class="number">0</span>] <span class="keyword">in</span> gene_id_array_new) <span class="keyword">and</span> (f[<span class="number">0</span>] <span class="keyword">in</span> id_set):</span><br><span class="line">        pedigree_list.append(f[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line">        test_records+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">in</span> gene_id_array_new:</span><br><span class="line">            sire_pairs+=<span class="number">1</span></span><br><span class="line">            offspring_sire_list.append([f[<span class="number">0</span>],f[<span class="number">1</span>]])</span><br><span class="line">        <span class="keyword">if</span> f[<span class="number">2</span>] <span class="keyword">in</span> gene_id_array_new:</span><br><span class="line">            dam_pairs+=<span class="number">1</span></span><br><span class="line">            offspring_dam_list.append([f[<span class="number">0</span>],f[<span class="number">2</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="亲子鉴定-2">亲子鉴定</h3>
<p>这里的思路很简单，就是上面提到了，计算两个个体基因型的乘积，统计乘积等于3的位点数目，除以位点总数（剔除缺失个体后），便得到了孟德尔错误率，再与给定的阈值进行比对。如果小于阈值，则认为是正确的亲子对，反之则认为错误。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">check_dick = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#np.savetxt(&quot;gene_id_array_new.txt&quot;,gene_id_array_new, fmt=&quot;%s&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#np.where 结果是一个元组，元组里是一个索引构成的数组，如(array([1, 2]),)</span></span><br><span class="line">conflict_sire_pairs=<span class="number">0</span></span><br><span class="line">conflict_dam_pairs=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> offspring_sire_list:</span><br><span class="line">    first_index = np.where(gene_id_array_new == i[<span class="number">0</span>])</span><br><span class="line">    second_index = np.where(gene_id_array_new == i[<span class="number">1</span>])</span><br><span class="line">    first_array = array4[first_index]</span><br><span class="line">    second_array = array4[second_index]</span><br><span class="line">    product_array = first_array * second_array</span><br><span class="line">    error_snp_nums = (product_array==<span class="number">3</span>).<span class="built_in">sum</span>()</span><br><span class="line">    miss_snp_nums =  (product_array==<span class="number">0</span>).<span class="built_in">sum</span>()</span><br><span class="line">    total_snp_nums = snp_num4 - miss_snp_nums</span><br><span class="line">    error_snp_prob = error_snp_nums/total_snp_nums</span><br><span class="line">    <span class="keyword">if</span> error_snp_prob &lt; <span class="built_in">float</span>(args.check_prob):</span><br><span class="line">        match_status = <span class="string">&quot;Match&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        match_status = <span class="string">&quot;No-Match&quot;</span></span><br><span class="line">        conflict_sire_pairs+=<span class="number">1</span></span><br><span class="line">    check_dick[<span class="built_in">tuple</span>(i)] = match_status</span><br><span class="line">    check_prob.write(<span class="string">&#x27;Offspring-Sire&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+i[<span class="number">0</span>]+<span class="string">&#x27;\t&#x27;</span>+i[<span class="number">1</span>]+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(error_snp_nums)+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(total_snp_nums)+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(error_snp_prob)+<span class="string">&#x27;\t&#x27;</span>+match_status+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> offspring_dam_list:</span><br><span class="line">    first_index = np.where(gene_id_array_new == i[<span class="number">0</span>])</span><br><span class="line">    second_index = np.where(gene_id_array_new == i[<span class="number">1</span>])</span><br><span class="line">    first_array = array4[first_index]</span><br><span class="line">    second_array = array4[second_index]</span><br><span class="line">    product_array = first_array * second_array</span><br><span class="line">    error_snp_nums = (product_array==<span class="number">3</span>).<span class="built_in">sum</span>()</span><br><span class="line">    miss_snp_nums =  (product_array==<span class="number">0</span>).<span class="built_in">sum</span>()</span><br><span class="line">    total_snp_nums = snp_num4 - miss_snp_nums</span><br><span class="line">    error_snp_prob = error_snp_nums/total_snp_nums</span><br><span class="line">    <span class="keyword">if</span> error_snp_prob &lt; <span class="built_in">float</span>(args.check_prob):</span><br><span class="line">        match_status = <span class="string">&quot;Match&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        match_status = <span class="string">&quot;No-Match&quot;</span></span><br><span class="line">        conflict_dam_pairs+=<span class="number">1</span></span><br><span class="line">    check_dick[<span class="built_in">tuple</span>(i)] = match_status</span><br><span class="line">    check_prob.write(<span class="string">&#x27;Offspring-Dam&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+i[<span class="number">0</span>]+<span class="string">&#x27;\t&#x27;</span>+i[<span class="number">1</span>]+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(error_snp_nums)+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(total_snp_nums)+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(<span class="string">&quot;&#123;:.4f&#125;&quot;</span>.<span class="built_in">format</span>(error_snp_prob))+<span class="string">&#x27;\t&#x27;</span>+match_status+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> pedigree_list:</span><br><span class="line">    offspring_sire = (i[<span class="number">0</span>],i[<span class="number">1</span>])</span><br><span class="line">    offspring_dam = (i[<span class="number">0</span>],i[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">if</span> offspring_sire <span class="keyword">in</span> check_dick:</span><br><span class="line">        sire_info = check_dick[offspring_sire]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sire_info = <span class="string">&quot;par_nogeno&quot;</span></span><br><span class="line">    <span class="keyword">if</span> offspring_dam <span class="keyword">in</span> check_dick:</span><br><span class="line">        dam_info = check_dick[offspring_dam]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dam_info = <span class="string">&quot;par_nogeno&quot;</span></span><br><span class="line">    check_pedigree.write(<span class="string">&#x27;\t&#x27;</span>.join(i)+<span class="string">&#x27;\t&#x27;</span>+sire_info+<span class="string">&#x27;\t&#x27;</span>+dam_info+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">raw_file.close()</span><br><span class="line">chipid_file.close()</span><br><span class="line">pedigree_file.close()</span><br><span class="line"><span class="comment">#new_raw.close()</span></span><br><span class="line">check_prob.close()</span><br><span class="line">check_pedigree.close()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Records tested: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(test_records))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;  Pair parent/progeny tested: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(sire_pairs+dam_pairs))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;  Pair with conflicts: &#123;&#125;\n\n&quot;</span>.<span class="built_in">format</span>(conflict_sire_pairs+conflict_dam_pairs))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sire-progeny tested: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(sire_pairs))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sire-progeny with conflicts: &#123;&#125;\n\n&quot;</span>.<span class="built_in">format</span>(conflict_sire_pairs))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Dam-progeny tested: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(dam_pairs))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Dam-progeny with conflicts: &#123;&#125;\n\n&quot;</span>.<span class="built_in">format</span>(conflict_dam_pairs))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;End paternity check\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">end_time = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nFinish time: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(end_time)) </span><br></pre></td></tr></table></figure>
<h1>不足</h1>
<ol>
<li>
<p>质控过程缺少了重复样本检验（基因型相同的样本）</p>
</li>
<li>
<p>亲子鉴定阈值需要通过经验给定，如果阈值设定不好，可能无法准确地将正确的亲子对和错误的亲子对分开，可能会造成错误鉴定。</p>
</li>
<li>
<p>后续可以对存在错误的个体查找真实亲本，方法就是对该个体遍历所有的候选亲本。</p>
</li>
<li>
<p>因为实际生产中可能存在采样错误（采的样本/基因型与标记的个体号不一致），因此本流程找到的错误系谱也有可能是由于采样错误导致的（例如这头个体本身系谱可能没错，但是可能采样采错了，不是采的这个个体，那么亲子鉴定肯定显示为错误）。也就是说，亲子鉴定找的错误实际由采样错误+系谱错误两部分组成。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>生物信息</tag>
      </tags>
  </entry>
  <entry>
    <title>shell编程</title>
    <url>/posts/e5954c2f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>如果真的有 python 基础（或者任何一门编程语言基础），就不可能会觉得 shell “难”。<br>
可以说几十分钟就能看完的。shell 虽然非常之恶劣，有很多的恶心人的大缺陷，有正经编程经验的人难以忍受。但是它作为胶水语言整合 CLI 程序还是无比强大的，比 python 原生，自然也更方便。</p>
<p>作者：绅士喵<br>
来源：知乎</p>
</blockquote>
<p>这段话有道理。</p>
<span id="more"></span>
<h2 id="资料来源">资料来源</h2>
<p><a href="http://c.biancheng.net/shell/">Shell脚本：Linux Shell脚本学习指南（超详细）</a></p>
<h2 id="shell-基础">shell 基础</h2>
<h3 id="Shell-是一种脚本语言">Shell 是一种脚本语言</h3>
<p>任何代码最终都要被“翻译”成二进制的形式才能在计算机中执行。</p>
<p>有的编程语言，如 C/C++、Pascal、Go语言、汇编等，必须在程序运行之前将所有代码都翻译成二进制形式，也就是生成可执行文件，用户拿到的是最终生成的可执行文件，看不到源码。</p>
<p>这个过程叫做编译（Compile），这样的编程语言叫做编译型语言，完成编译过程的软件叫做编译器（Compiler）。</p>
<p>而有的编程语言，如 Shell、<a href="http://c.biancheng.net/js/">JavaScript</a>、Python、<a href="http://c.biancheng.net/php/">PHP</a>等，需要一边执行一边翻译，不会生成任何可执行文件，用户必须拿到源码才能运行程序。程序运行后会即时翻译，翻译完一部分执行一部分，不用等到所有代码都翻译完。</p>
<p>这个过程叫做解释，这样的编程语言叫做解释型语言或者脚本语言（Script），完成解释过程的软件叫做解释器。</p>
<p>编译型语言的优点是执行速度快、对硬件要求低、保密性好，适合开发操作系统、大型应用程序、数据库等。</p>
<p>脚本语言的优点是使用灵活、部署容易、跨平台性好，非常适合 Web 开发以及小工具的制作。</p>
<p>Shell 就是一种脚本语言，我们编写完源码后不用编译，直接运行源码即可。</p>
<h3 id="执行-shell-脚本">执行 shell 脚本</h3>
<h4 id="在新进程中运行shell脚本">在新进程中运行shell脚本</h4>
<p>新进程就是说执行shell文件时，会开启一个新的进程，会有一个新的PID。</p>
<h5 id="1-将-Shell-脚本作为程序运行">1) 将 Shell 脚本作为程序运行</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd demo </span><br><span class="line">chmod +x .&#x2F;test.sh</span><br><span class="line">.&#x2F;test.sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第 3 行中，<code>./</code>表示当前目录，整条命令的意思是执行当前目录下的 <a href="http://test.sh">test.sh</a> 脚本。如果不写<code>./</code>，Linux 会到系统路径（由 PATH 环境变量指定）下查找 <a href="http://test.sh">test.sh</a>，而系统路径下显然不存在这个脚本，所以会执行失败。</p>
<p>通过这种方式运行脚本，脚本文件第一行的<code>#!/bin/bash</code>一定要写对，好让系统查找到正确的解释器。</p>
</blockquote>
<h5 id="2-将-Shell-脚本作为参数传递给-Bash-解释器">2) 将 Shell 脚本作为参数传递给 Bash 解释器</h5>
<p>直接运行bash 解释器，将脚本文件的名字作为参数传递给bash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd demo </span><br><span class="line">&#x2F;bin&#x2F;bash test.sh</span><br></pre></td></tr></table></figure>
<p>通过这种方式运行脚本，不需要在脚本文件的第一行指定解释器信息，写了也没用。</p>
<p>更加简洁的写法是运行 bash 命令。bash 是一个外部命令，Shell 会在 /bin 目录中找到对应的应用程序，也即 /bin/bash。</p>
<p>好像sh 和 bash 不是一码事，以后还是用bash吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd demo </span><br><span class="line">bash test.sh</span><br></pre></td></tr></table></figure>
<h3 id="在当前进程中运行-shell-脚本">在当前进程中运行 shell 脚本</h3>
<p>这里需要引入一个新的命令——source 命令。source 是 <a href="http://c.biancheng.net/view/1136.html">Shell 内置命令</a>的一种，它会读取脚本文件中的代码，并依次执行所有语句。你也可以理解为，source 命令会强制执行脚本文件中的全部命令，而忽略脚本文件的权限。</p>
<p>说白了，source命令就两点：</p>
<ul>
<li>PID不变</li>
<li>强制执行</li>
</ul>
<p>source命令可以写成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">. filename</span><br></pre></td></tr></table></figure>
<p>注意 . 和 文件名中间有一个空格。</p>
<p>使用 source 命令不用给脚本增加执行权限，并且写不写<code>./</code>都行</p>
<h2 id="shell-编程">shell 编程</h2>
<h3 id="shell-变量">shell 变量</h3>
<p><strong>在 Bash shell 中，每一个变量的值都是字符串，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储。</strong></p>
<p>这意味着，Bash shell 在默认情况下不会区分变量类型，即使你将整数和小数赋值给变量，它们也会被视为字符串，这一点和大部分的编程语言不同。例如在C语言或者 <a href="http://c.biancheng.net/cplus/">C++</a> 中，变量分为整数、小数、字符串、布尔等多种类型。</p>
<p>当然，如果有必要，你也可以使用 <a href="http://c.biancheng.net/view/2709.html">Shell declare</a> 关键字显式定义变量的类型，但在一般情况下没有这个需求，Shell 开发者在编写代码时自行注意值的类型即可。</p>
<h4 id="变量类型">变量类型</h4>
<ul>
<li><strong>局部变量</strong> - 局部变量是仅在某个脚本内部有效的变量。它们不能被其他的程序和脚本访问。</li>
<li><strong>环境变量</strong> - 环境变量是对当前 shell 会话内所有的程序或脚本都可见的变量。创建它们跟创建局部变量类似，但使用的是 <code>export</code> 关键字，shell 脚本也可以定义环境变量。</li>
</ul>
<p>一般说的都是局部变量。</p>
<h4 id="定义变量">定义变量</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">variable&#x3D;value</span><br><span class="line">variable&#x3D;&#39;value&#39;</span><br><span class="line">variable&#x3D;&quot;value&quot;</span><br></pre></td></tr></table></figure>
<p>variable 是变量名，value 是赋给变量的值。如果 value 不包含任何空白符（例如空格、Tab 缩进等），那么可以不使用引号；如果 value 包含了空白符，那么就必须使用引号包围起来。使用单引号和使用双引号也是有区别的，稍后我们会详细说明。</p>
<p>注意，赋值号<code>=</code>的周围不能有空格</p>
<p>Shell 变量的命名规范和大部分编程语言都一样：</p>
<ul>
<li>变量名由数字、字母、下划线组成；</li>
<li><strong>必须以字母或者下划线开头；</strong></li>
<li>不能使用 Shell 里的关键字（通过 help 命令可以查看保留关键字）。</li>
</ul>
<h4 id="使用变量">使用变量</h4>
<p>使用一个定义过的变量，只要在变量名前面加美元符号<code>$</code>即可，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">author&#x3D;&quot;严长生&quot;</span><br><span class="line">echo $author</span><br><span class="line">echo $&#123;author&#125;</span><br><span class="line">echo &quot;$&#123;author&#125;&quot; #用于多行或多个空字符</span><br></pre></td></tr></table></figure>
<p>变量名外面的花括号<code>&#123; &#125;</code>是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">skill&#x3D;&quot;Java&quot;</span><br><span class="line">echo &quot;I am good at $&#123;skill&#125;Script&quot;</span><br></pre></td></tr></table></figure>
<p>如果不给 skill 变量加花括号，写成<code>echo &quot;I am good at $skillScript&quot;</code>，解释器就会把 $skillScript 当成一个变量（其值为空），代码执行结果就不是我们期望的样子了 ( I am good at ) 。</p>
<p><strong>推荐给所有变量加上花括号<code>&#123; &#125;</code>，这是个良好的编程习惯。</strong></p>
<h5 id="单引号和双引号的区别">单引号和双引号的区别</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">url&#x3D;&quot;http:&#x2F;&#x2F;c.biancheng.net&quot;</span><br><span class="line">website1&#x3D;&#39;C语言中文网：$&#123;url&#125;&#39;</span><br><span class="line">website2&#x3D;&quot;C语言中文网：$&#123;url&#125;&quot;</span><br><span class="line">echo $website1</span><br><span class="line">echo $website2</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>
C语言中文网：${url}<br>
C语言中文网：<a href="http://c.biancheng.net">http://c.biancheng.net</a></p>
<p>以单引号<code>' '</code>包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出。这种方式比较适合定义显示纯字符串的情况，即不希望解析变量、命令等的场景。</p>
<p>以双引号<code>&quot; &quot;</code>包围变量的值时，输出时会先解析里面的变量和命令，而不是把双引号中的变量名和命令原样输出。这种方式比较适合字符串中附带有变量和命令并且想将其解析后再输出的变量定义。</p>
<p><strong>单引号原封不动，双引号解析变量</strong></p>
<p><strong>一般推荐使用双引号</strong></p>
<h4 id="将命令的结果赋值给变量">将命令的结果赋值给变量</h4>
<p>Shell 也支持将命令的执行结果赋值给变量，常见的有以下两种方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">variable&#x3D;&#96;command&#96;</span><br><span class="line">variable&#x3D;$(command)</span><br></pre></td></tr></table></figure>
<p>第一种方式把命令用反引号<code> </code>（位于 Esc 键的下方）包围起来，反引号和单引号非常相似，容易产生混淆，所以不推荐使用这种方式；第二种方式把命令用<code>$()</code>包围起来，区分更加明显，所以推荐使用这种方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd demo </span><br><span class="line">log&#x3D;$(cat log.txt)</span><br><span class="line">echo $log</span><br><span class="line">	严长生正在编写Shell教程，教程地址：http:&#x2F;&#x2F;c.biancheng.net&#x2F;shell&#x2F;</span><br></pre></td></tr></table></figure>
<p>另外 $() 支持嵌套，如下面的例子演示了使用计算 ls 命令列出的第一个文件的行数，这里使用了两层嵌套。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Fir_File_Lines&#x3D;$(wc -l $(ls | sed -n &#39;1p&#39;))</span><br><span class="line">echo &quot;$Fir_File_Lines&quot;</span><br><span class="line">	# 36 anaconda-ks.cfg</span><br></pre></td></tr></table></figure>
<p>要注意的是，$() 仅在 Bash Shell 中有效，而反引号可在多种 Shell 中使用。所以这两种命令替换的方式各有特点，究竟选用哪种方式全看个人需求。</p>
<p><strong>注意$() 和 ${} 的区别</strong></p>
<p>注意，如果被替换的命令的输出内容包括多行（也即有换行符），或者含有多个连续的空白符，那么在输出变量时应该将变量用双引号包围，否则系统会使用默认的空白符来填充，这会导致换行无效，以及连续的空白符被压缩成一个。请看下面的代码：</p>
<p>lsl=$(ls -l)<br>
echo $lsl</p>
<p>结果如下，可以看到没有正常换行</p>
<p><img src="1.png" alt="1"></p>
<p>echo ‘$lsl’</p>
<p>结果为 $lsl，可以看出单引号确实是原封不动。</p>
<p>echo “$lsl” 结果正常</p>
<p><img src="2.png" alt="1"></p>
<h4 id="只读变量">只读变量</h4>
<p>先赋值，再使用 readonly 命令将变量定义为只读变量，只读变量的值不能改变。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zhou&#x3D;&#39;zhouziwen&#39;</span><br><span class="line">readonly zhou</span><br></pre></td></tr></table></figure>
<h4 id="删除变量">删除变量</h4>
<p>使用unset命令可以删除变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unset variable_name</span><br></pre></td></tr></table></figure>
<p>变量被删除后不能再次使用；unset 命令不能删除只读变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myUrl&#x3D;&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;shell&#x2F;&quot;</span><br><span class="line">unset myUrl</span><br><span class="line">echo $myUrl</span><br></pre></td></tr></table></figure>
<h3 id="位置参数（命令行参数）">位置参数（命令行参数）</h3>
<p>运行 Shell 脚本文件时我们可以给它传递一些参数，这些参数在脚本文件内部可以使用<code>$n</code>的形式来接收，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。</p>
<p>同样，在调用函数时也可以传递参数。Shell 函数参数的传递和其它编程语言不同，没有所谓的形参和实参，在定义函数时也不用指明参数的名字和数目。换句话说，定义 Shell 函数时不能带参数，但是在调用函数时却可以传递参数，这些传递进来的参数，在函数内部就也使用<code>$n</code>的形式接收，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。</p>
<p>这种通过<code>$n</code>的形式来接收的参数，在 Shell 中称为位置参数。</p>
<p>在讲解<a href="http://c.biancheng.net/view/743.html">变量的命名</a>时，我们提到：变量的名字必须以字母或者下划线开头，不能以数字开头；但是位置参数却偏偏是数字，这和变量的命名规则是相悖的，所以我们将它们视为“特殊变量”。</p>
<p>除了 $n，Shell 中还有 <img src="https://math.now.sh?inline=%23%E3%80%81" style="display:inline-block;margin: 0;"/>*、<img src="https://math.now.sh?inline=%40%E3%80%81" style="display:inline-block;margin: 0;"/>?、$$ 几个特殊参数，我们将在下节讲解。</p>
<h4 id="1-给脚本文件传递位置参数">1) 给脚本文件传递位置参数</h4>
<p>请编写下面的代码，并命名为 <a href="http://test.sh">test.sh</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">echo &quot;Language: $1&quot;</span><br><span class="line">echo &quot;URL: $2&quot;</span><br></pre></td></tr></table></figure>
<p>运行 <a href="http://test.sh">test.sh</a>，并附带参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ cd demo</span><br><span class="line">[mozhiyan@localhost demo]$ . .&#x2F;test.sh Shell http:&#x2F;&#x2F;c.biancheng.net&#x2F;shell&#x2F;</span><br><span class="line">Language: Shell</span><br><span class="line">URL: http:&#x2F;&#x2F;c.biancheng.net&#x2F;shell&#x2F;</span><br></pre></td></tr></table></figure>
<p>其中<code>Shell</code>是第一个位置参数，<code>http://c.biancheng.net/shell/</code>是第二个位置参数，两者之间以空格分隔。</p>
<h4 id="2-给函数传递位置参数">2) 给函数传递位置参数</h4>
<p>请编写下面的代码，并命名为 <a href="http://test.sh">test.sh</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#定义函数</span><br><span class="line">function func()&#123;</span><br><span class="line">	echo &quot;Language: $1&quot;    </span><br><span class="line">	echo &quot;URL: $2&quot;</span><br><span class="line">&#125;</span><br><span class="line">#调用函数</span><br><span class="line">func C++ http:&#x2F;&#x2F;c.biancheng.net&#x2F;cplus&#x2F;</span><br></pre></td></tr></table></figure>
<p>运行 <a href="http://test.sh">test.sh</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ cd demo</span><br><span class="line">[mozhiyan@localhost demo]$ . .&#x2F;test.sh</span><br><span class="line">Language: C++</span><br><span class="line">URL: http:&#x2F;&#x2F;c.biancheng.net&#x2F;cplus&#x2F;</span><br></pre></td></tr></table></figure>
<h4 id="注意事项">注意事项</h4>
<p>如果参数个数太多，达到或者超过了 10 个，那么就得用<code>$&#123;n&#125;</code>的形式来接收了，例如 <img src="https://math.now.sh?inline=%7B10%7D%E3%80%81" style="display:inline-block;margin: 0;"/>{23}。<code>&#123; &#125;</code>的作用是为了帮助解释器识别参数的边界，这跟使用变量时加<code>&#123; &#125;</code>是一样的效果。</p>
<p><strong>$1 和 ${1} 是一样的</strong></p>
<h3 id="特殊变量：Shell-、-、-、-、">特殊变量：Shell <img src="https://math.now.sh?inline=%23%E3%80%81" style="display:inline-block;margin: 0;"/>*、<img src="https://math.now.sh?inline=%40%E3%80%81" style="display:inline-block;margin: 0;"/>?、$$</h3>
<table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>$0</td>
<td>当前脚本的文件名。</td>
</tr>
<tr>
<td>$n（n≥1）</td>
<td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是 $1，第二个参数是 $2。</td>
</tr>
<tr>
<td>$#</td>
<td>传递给脚本或函数的参数个数。</td>
</tr>
<tr>
<td>$*</td>
<td>传递给脚本或函数的所有参数。</td>
</tr>
<tr>
<td>$@</td>
<td>传递给脚本或函数的所有参数。当被双引号<code>&quot; &quot;</code>包含时，$@ 与 $* 稍有不同，我们将在《<a href="http://c.biancheng.net/view/vip_4559.html">Shell <img src="https://math.now.sh?inline=*%E5%92%8C" style="display:inline-block;margin: 0;"/>@的区别</a>》一节中详细讲解。</td>
</tr>
<tr>
<td>$?</td>
<td>上个命令的退出状态，或函数的返回值，我们将在《<a href="http://c.biancheng.net/view/808.html">Shell $?</a>》一节中详细讲解。</td>
</tr>
<tr>
<td>$$</td>
<td>当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。</td>
</tr>
</tbody>
</table>
<h3 id="：获取函数返回值或者上一个命令的退出状态">$?：获取函数返回值或者上一个命令的退出状态</h3>
<p>$? 是一个特殊变量，用来获取上一个命令的退出状态，或者上一个函数的返回值。</p>
<p>所谓退出状态，就是上一个命令执行后的返回结果。退出状态是一个数字，一般情况下，<strong>大部分命令执行成功会返回 0，失败返回 1</strong>，这和C语言的 main() 函数是类似的。</p>
<p>不过，也有一些命令返回其他值，表示不同类型的错误。</p>
<h4 id="1-获取上一个命令的退出状态">1) $? 获取上一个命令的退出状态</h4>
<p>编写下面的代码，并保存为 <a href="http://test.sh">test.sh</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">if [ &quot;$1&quot; &#x3D;&#x3D; 100 ]</span><br><span class="line">then</span><br><span class="line">	exit 0  #参数正确，退出状态为0</span><br><span class="line">else</span><br><span class="line">	exit 1  #参数错误，退出状态1fi</span><br></pre></td></tr></table></figure>
<p><code>exit</code>表示退出当前 Shell 进程，我们必须在新进程中运行 <a href="http://test.sh">test.sh</a>，否则当前 Shell 会话（终端窗口）会被关闭，我们就无法取得它的退出状态了。</p>
<p>例如，运行 <a href="http://test.sh">test.sh</a> 时传递参数 100：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ cd demo</span><br><span class="line">[mozhiyan@localhost demo]$ bash .&#x2F;test.sh 100  #作为一个新进程运行</span><br><span class="line">[mozhiyan@localhost demo]$ echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>再如，运行 <a href="http://test.sh">test.sh</a> 时传递参数 89：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mozhiyan@localhost demo]$ bash .&#x2F;test.sh 89  #作为一个新进程运行</span><br><span class="line">[mozhiyan@localhost demo]$ echo $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>这一部分可以用在两种场景下：</p>
<ul>
<li>判断上一个程序是否正常运行</li>
<li>分类运行程序。比如我的那个what_illumina.py就可以这样做。</li>
</ul>
<h4 id="2-获取函数的返回值">2) $? 获取函数的返回值</h4>
<p>编写下面的代码，并保存为 <a href="http://test.sh">test.sh</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#得到两个数相加的和</span><br><span class="line">function add()&#123; </span><br><span class="line">	return &#96;expr $1 + $2&#96;</span><br><span class="line">&#125;</span><br><span class="line">add 23 50  #调用函数</span><br><span class="line">echo $?  #获取函数返回值</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>
73</p>
<p><strong>严格来说，Shell 函数中的 return 关键字用来表示函数的退出状态，而不是函数的返回值</strong>；Shell 不像其它编程语言，没有专门处理返回值的关键字。</p>
<p><strong>return这个字段其实本身是用于判断函数运行状态的，必须为数值</strong></p>
<p><strong>shell 函数没有返回值的概念，可以通过修改全局变量的方式间接实现</strong>。</p>
<h2 id="字符串">字符串</h2>
<h3 id="字符串详解">字符串详解</h3>
<p>字符串（String）就是一系列字符的组合。字符串是 Shell 编程中最常用的数据类型之一（除了数字和字符串，也没有其他类型了）。</p>
<p>字符串可以由单引号<code>' '</code>包围，也可以由双引号<code>&quot; &quot;</code>包围，也可以不用引号。它们之间是有区别的，稍后我们会详解。</p>
<p>字符串举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str1&#x3D;c.biancheng.net</span><br><span class="line">str2&#x3D;&quot;shell script&quot;</span><br><span class="line">str3&#x3D;&#39;C语言中文网&#39;</span><br></pre></td></tr></table></figure>
<p>下面我们说一下三种形式的区别：</p>
<ol>
<li>由单引号<code>' '</code>包围的字符串：</li>
</ol>
<ul>
<li>任何字符都会原样输出，在其中使用变量是无效的。</li>
<li>字符串中不能出现单引号，即使对单引号进行转义也不行。</li>
</ul>
<ol start="2">
<li>由双引号<code>&quot; &quot;</code>包围的字符串：</li>
</ol>
<ul>
<li>如果其中包含了某个变量，那么该变量会被解析（得到该变量的值），而不是原样输出。</li>
<li>字符串中可以出现双引号，只要它被转义了就行。</li>
</ul>
<ol start="3">
<li>不被引号包围的字符串</li>
</ol>
<ul>
<li>不被引号包围的字符串中出现变量时也会被解析，这一点和双引号<code>&quot; &quot;</code>包围的字符串一样。</li>
<li>字符串中不能出现空格，否则空格后边的字符串会作为其他变量或者命令解析。</li>
</ul>
<p><strong>小结：用双引号包围，字符串里的双引号用\转义</strong></p>
<h4 id="获取字符串长度">获取字符串长度</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;#string_name&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串替换">字符串替换</h3>
<ul>
<li>${变量名/旧字符串/新字符串}  :  替换第一个</li>
<li>${变量名//旧字符串/新字符串}  :  替换全部</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(base) [zhouziwen@ny example]$ a=&quot;zhouziwenzi&quot;</span><br><span class="line">(base) [zhouziwen@ny example]$ b=$&#123;a/zi/zhi&#125;</span><br><span class="line">(base) [zhouziwen@ny example]$ echo $b</span><br><span class="line">zhouzhiwenzi</span><br><span class="line">(base) [zhouziwen@ny example]$ b=$&#123;a//zi/zhi&#125;</span><br><span class="line">(base) [zhouziwen@ny example]$ echo $b</span><br><span class="line">zhouzhiwenzhi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="字符串拼接（连接、合并）">字符串拼接（连接、合并）</h3>
<p>然而，在 Shell 中你不需要使用任何运算符，将两个字符串并排放在一起就能实现拼接，非常简单粗暴。请看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">name&#x3D;&quot;Shell&quot;</span><br><span class="line">url&#x3D;&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;shell&#x2F;&quot;</span><br><span class="line">str1&#x3D;$name$url  #中间不能有空格，碰到空格会认为字符串结束了</span><br><span class="line">str2&#x3D;&quot;$name $url&quot;  #如果被双引号包围，那么中间可以有空格</span><br><span class="line">str3&#x3D;$name&quot;: &quot;$url  #中间可以出现别的字符串</span><br><span class="line">str4&#x3D;&quot;$name: $url&quot;  #这样写也可以</span><br><span class="line">str5&#x3D;&quot;$&#123;name&#125;Script: $&#123;url&#125;index.html&quot;  #这个时候需要给变量名加上大括号</span><br><span class="line"></span><br><span class="line">echo $str1</span><br><span class="line">echo $str2</span><br><span class="line">echo $str3</span><br><span class="line">echo $str4</span><br><span class="line">echo $str5</span><br></pre></td></tr></table></figure>
<h3 id="字符串截取">字符串截取</h3>
<p>Shell 截取字符串通常有两种方式：从指定位置开始截取和从指定字符（子字符串）开始截取。</p>
<h4 id="从指定位置开始截取">从指定位置开始截取</h4>
<p>这种方式需要两个参数：除了指定起始位置，还需要截取长度，才能最终确定要截取的字符串。</p>
<p>既然需要指定起始位置，那么就涉及到计数方向的问题，到底是从字符串左边开始计数，还是从字符串右边开始计数。答案是 Shell 同时支持两种计数方式。</p>
<h5 id="1-从字符串左边开始计数">1) 从字符串左边开始计数</h5>
<p>如果想从字符串的左边开始计数，那么截取字符串的具体格式如下：</p>
<p>${string: start :length}</p>
<p>其中，string 是要截取的字符串，start 是起始位置（从左边开始，从 0 开始计数），length 是要截取的长度（省略的话表示直到字符串的末尾）。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url&#x3D;&quot;c.biancheng.net&quot;</span><br><span class="line">echo $&#123;url: 2: 9&#125;</span><br></pre></td></tr></table></figure>
<p>结果为<code>biancheng</code>。</p>
<p>再如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url&#x3D;&quot;c.biancheng.net&quot;</span><br><span class="line">echo $&#123;url: 2&#125;  #省略 length，截取到字符串末尾</span><br></pre></td></tr></table></figure>
<p>结果为<code>biancheng.net</code>。</p>
<h5 id="2-从右边开始计数">2) 从右边开始计数</h5>
<p>不需要</p>
<h4 id="从指定字符（子字符串）开始截取">从指定字符（子字符串）开始截取</h4>
<p>这种截取方式无法指定字符串长度，只能从指定字符（子字符串）截取到字符串末尾。Shell 可以截取指定字符（子字符串）右边的所有字符，也可以截取左边的所有字符。</p>
<h5 id="1-使用-号截取右边字符">1) 使用 # 号截取右边字符</h5>
<p>使用<code>#</code>号可以截取指定字符（或者子字符串）右边的所有字符，具体格式如下：</p>
<p>${string#*chars}</p>
<p>其中，string 表示要截取的字符，chars 是指定的字符（或者子字符串），<code>*</code>是通配符的一种，表示任意长度的字符串。<code>*chars</code>连起来使用的意思是：忽略左边的所有字符，直到遇见 chars（chars 不会被截取）。</p>
<p>请看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url&#x3D;&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;index.html&quot;</span><br><span class="line">echo $&#123;url#*:&#125;</span><br></pre></td></tr></table></figure>
<p>结果为<code>//c.biancheng.net/index.html</code>。</p>
<p>以下写法也可以得到同样的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $&#123;url#*p:&#125;</span><br><span class="line">echo $&#123;url#*ttp:&#125;</span><br></pre></td></tr></table></figure>
<p>注意，以上写法遇到第一个匹配的字符（子字符串）就结束了。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url&#x3D;&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;index.html&quot;</span><br><span class="line">echo $&#123;url#*&#x2F;&#125;</span><br></pre></td></tr></table></figure>
<p>结果为<code>/c.biancheng.net/index.html</code>。url 字符串中有三个<code>/</code>，输出结果表明，Shell 遇到第一个<code>/</code>就匹配结束了。</p>
<p>如果希望直到最后一个指定字符（子字符串）再匹配结束，那么可以使用<code>##</code>，具体格式为：</p>
<p>${string##*chars}</p>
<p>请看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">url&#x3D;&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;index.html&quot;</span><br><span class="line">echo $&#123;url#*&#x2F;&#125;    #结果为 &#x2F;c.biancheng.net&#x2F;index.html</span><br><span class="line">echo $&#123;url##*&#x2F;&#125;   #结果为 index.html</span><br><span class="line">str&#x3D;&quot;---aa+++aa@@@&quot;</span><br><span class="line">echo $&#123;str#*aa&#125;   #结果为 +++aa@@@</span><br><span class="line">echo $&#123;str##*aa&#125;  #结果为 @@@</span><br></pre></td></tr></table></figure>
<h5 id="2-使用-截取左边字符">2) 使用 % 截取左边字符</h5>
<p>使用<code>%</code>号可以截取指定字符（或者子字符串）左边的所有字符，具体格式如下：</p>
<p>${string%chars*}</p>
<p>请注意<code>*</code>的位置，因为要截取 chars 左边的字符，而忽略 chars 右边的字符，所以<code>*</code>应该位于 chars 的右侧。其他方面<code>%</code>和<code>#</code>的用法相同，这里不再赘述，仅举例说明：</p>
<p>默认截取右侧第一个匹配的字符，用%%匹配最左侧的字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">url&#x3D;&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;index.html&quot;</span><br><span class="line">echo $&#123;url%&#x2F;*&#125;  #结果为 http:&#x2F;&#x2F;c.biancheng.net</span><br><span class="line">echo $&#123;url%%&#x2F;*&#125;  #结果为 http:str&#x3D;&quot;---aa+++aa@@@&quot;</span><br><span class="line">echo $&#123;str%aa*&#125;  #结果为 ---aa+++</span><br><span class="line">echo $&#123;str%%aa*&#125;  #结果为 ---</span><br></pre></td></tr></table></figure>
<h4 id="总结">总结</h4>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>${string: start :length}</td>
<td>从 string 字符串的左边第 start 个字符开始，向右截取 length 个字符。</td>
</tr>
<tr>
<td>${string: start}</td>
<td>从 string 字符串的左边第 start 个字符开始截取，直到最后。</td>
</tr>
<tr>
<td>${string: 0-start :length}</td>
<td>从 string 字符串的右边第 start 个字符开始，向右截取 length 个字符。</td>
</tr>
<tr>
<td>${string: 0-start}</td>
<td>从 string 字符串的右边第 start 个字符向右开始截取，直到最后。</td>
</tr>
<tr>
<td>${string#*chars}</td>
<td>从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。</td>
</tr>
<tr>
<td>${string##*chars}</td>
<td>从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。</td>
</tr>
<tr>
<td>${string%*chars}</td>
<td>从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 左边的所有字符。</td>
</tr>
<tr>
<td>${string%%*chars}</td>
<td>从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 左边的所</td>
</tr>
</tbody>
</table>
<h3 id="数组">数组</h3>
<p>和其他编程语言一样，Shell 也支持数组。数组（Array）是若干数据的集合，其中的每一份数据都称为元素（Element）。</p>
<p>Shell 并且没有限制数组的大小，理论上可以存放无限量的数据。和 <a href="http://c.biancheng.net/cplus/">C++</a>、<a href="http://c.biancheng.net/java/">Java</a>、<a href="http://c.biancheng.net/csharp/">C#</a> 等类似，Shell 数组元素的下标也是从 0 开始计数。</p>
<p>获取数组中的元素要使用下标<code>[ ]</code>，下标可以是一个整数，也可以是一个结果为整数的表达式；当然，下标必须大于等于 0。</p>
<p>遗憾的是，常用的 Bash Shell 只支持一维数组，不支持多维数组。</p>
<h4 id="Shell-数组的定义">Shell 数组的定义</h4>
<p>在 Shell 中，用括号<code>( )</code>来表示数组，数组元素之间用空格来分隔。由此，定义数组的一般形式为：</p>
<p>array_name=(ele1  ele2  ele3 … elen)</p>
<p>注意，赋值号<code>=</code>两边不能有空格，必须紧挨着数组名和数组元素。</p>
<p>下面是一个定义数组的实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums&#x3D;(29 100 13 8 91 44)</span><br></pre></td></tr></table></figure>
<p>Shell 是弱类型的，它并不要求所有数组元素的类型必须相同，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr&#x3D;(20 56 &quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;shell&#x2F;&quot;)</span><br></pre></td></tr></table></figure>
<p>第三个元素就是一个“异类”，前面两个元素都是整数，而第三个元素是字符串。</p>
<p>Shell 数组的长度不是固定的，定义之后还可以增加元素。例如，对于上面的 nums 数组，它的长度是 6，使用下面的代码会在最后增加一个元素，使其长度扩展到 7：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums[6]&#x3D;88</span><br></pre></td></tr></table></figure>
<p>此外，你也无需逐个元素地给数组赋值，下面的代码就是只给特定元素赋值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ages&#x3D;([3]&#x3D;24 [5]&#x3D;19 [10]&#x3D;12)</span><br></pre></td></tr></table></figure>
<p>以上代码就只给第 3、5、10 个元素赋值，所以数组长度是 3。</p>
<p>不清楚原理，这样做[0] [1] [2] 打印出来全为空。</p>
<p>我懂了，下标只是一个标签，可以不连续。</p>
<h4 id="获取数组元素">获取数组元素</h4>
<p>获取数组元素的值，一般使用下面的格式：</p>
<p>${array_name[index]}</p>
<p>其中，array_name 是数组名，index 是下标。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n&#x3D;$&#123;nums[2]&#125;</span><br></pre></td></tr></table></figure>
<p>表示获取 nums 数组的第二个元素，然后赋值给变量 n。再如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $&#123;nums[3]&#125;</span><br></pre></td></tr></table></figure>
<p>表示输出 nums 数组的第 3 个元素。</p>
<p>使用<code>@</code>或<code>*</code>可以获取数组中的所有元素，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;nums[*]&#125;</span><br><span class="line">$&#123;nums[@]&#125;</span><br></pre></td></tr></table></figure>
<p>两者都可以得到 nums 数组的所有元素。</p>
<h4 id="获取数组长度">获取数组长度</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;#array_name[@]&#125;</span><br><span class="line">$&#123;#array_name[*]&#125;</span><br></pre></td></tr></table></figure>
<p>其中 array_name 表示数组名。两种形式是等价的，选择其一即可。</p>
<p>如果某个元素是字符串，还可以通过指定下标的方式获得该元素的长度，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;#arr[2]&#125;</span><br></pre></td></tr></table></figure>
<p>获取 arr 数组的第 2 个元素（假设它是字符串）的长度。</p>
<p>回忆字符串长度的获取</p>
<p>回想一下 Shell 是如何获取字符串长度的呢？其实和获取数组长度如出一辙，它的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;#string_name&#125;</span><br></pre></td></tr></table></figure>
<p>string_name 是字符串名。</p>
<h4 id="数组合并">数组合并</h4>
<p>所谓 Shell 数组拼接（数组合并），就是将两个数组连接成一个数组。</p>
<p>拼接数组的思路是：先利用<code>@</code>或<code>*</code>，将数组扩展成列表，然后再合并到一起。具体格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array_new&#x3D;($&#123;array1[@]&#125;  $&#123;array2[@]&#125;)</span><br><span class="line">array_new&#x3D;($&#123;array1[*]&#125;  $&#123;array2[*]&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="删除数组元素">删除数组元素</h4>
<p>在 Shell 中，使用 unset 关键字来删除数组元素，具体格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unset array_name[index]</span><br></pre></td></tr></table></figure>
<p>其中，array_name 表示数组名，index 表示数组下标。</p>
<p>如果不写下标，而是写成下面的形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unset array_name</span><br></pre></td></tr></table></figure>
<p>那么就是删除整个数组，所有元素都会消失。</p>
<h3 id="内建命令">内建命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:</td>
<td>扩展参数列表，执行重定向操作</td>
</tr>
<tr>
<td>.</td>
<td>读取并执行指定文件中的命令（在当前 shell 环境中）</td>
</tr>
<tr>
<td>alias</td>
<td>为指定命令定义一个别名</td>
</tr>
<tr>
<td>bg</td>
<td>将作业以后台模式运行</td>
</tr>
<tr>
<td>bind</td>
<td>将键盘序列绑定到一个 readline 函数或宏</td>
</tr>
<tr>
<td>break</td>
<td>退出 for、while、select 或 until 循环</td>
</tr>
<tr>
<td>builtin</td>
<td>执行指定的 shell 内建命令</td>
</tr>
<tr>
<td>caller</td>
<td>返回活动子函数调用的上下文</td>
</tr>
<tr>
<td>cd</td>
<td>将当前目录切换为指定的目录</td>
</tr>
<tr>
<td>command</td>
<td>执行指定的命令，无需进行通常的 shell 查找</td>
</tr>
<tr>
<td>compgen</td>
<td>为指定单词生成可能的补全匹配</td>
</tr>
<tr>
<td>complete</td>
<td>显示指定的单词是如何补全的</td>
</tr>
<tr>
<td>compopt</td>
<td>修改指定单词的补全选项</td>
</tr>
<tr>
<td>continue</td>
<td>继续执行 for、while、select 或 until 循环的下一次迭代</td>
</tr>
<tr>
<td>declare</td>
<td>声明一个变量或变量类型。</td>
</tr>
<tr>
<td>dirs</td>
<td>显示当前存储目录的列表</td>
</tr>
<tr>
<td>disown</td>
<td>从进程作业表中刪除指定的作业</td>
</tr>
<tr>
<td>echo</td>
<td>将指定字符串输出到 STDOUT</td>
</tr>
<tr>
<td>enable</td>
<td>启用或禁用指定的内建shell命令</td>
</tr>
<tr>
<td>eval</td>
<td>将指定的参数拼接成一个命令，然后执行该命令</td>
</tr>
<tr>
<td>exec</td>
<td>用指定命令替换 shell 进程</td>
</tr>
<tr>
<td>exit</td>
<td>强制 shell 以指定的退出状态码退出</td>
</tr>
<tr>
<td>export</td>
<td>设置子 shell 进程可用的变量</td>
</tr>
<tr>
<td>fc</td>
<td>从历史记录中选择命令列表</td>
</tr>
<tr>
<td>fg</td>
<td>将作业以前台模式运行</td>
</tr>
<tr>
<td>getopts</td>
<td>分析指定的位置参数</td>
</tr>
<tr>
<td>hash</td>
<td>查找并记住指定命令的全路径名</td>
</tr>
<tr>
<td>help</td>
<td>显示帮助文件</td>
</tr>
<tr>
<td>history</td>
<td>显示命令历史记录</td>
</tr>
<tr>
<td>jobs</td>
<td>列出活动作业</td>
</tr>
<tr>
<td>kill</td>
<td>向指定的进程 ID(PID) 发送一个系统信号</td>
</tr>
<tr>
<td>let</td>
<td>计算一个数学表达式中的每个参数</td>
</tr>
<tr>
<td>local</td>
<td>在函数中创建一个作用域受限的变量</td>
</tr>
<tr>
<td>logout</td>
<td>退出登录 shell</td>
</tr>
<tr>
<td>mapfile</td>
<td>从 STDIN 读取数据行，并将其加入索引数组</td>
</tr>
<tr>
<td>popd</td>
<td>从目录栈中删除记录</td>
</tr>
<tr>
<td>printf</td>
<td>使用格式化字符串显示文本</td>
</tr>
<tr>
<td>pushd</td>
<td>向目录栈添加一个目录</td>
</tr>
<tr>
<td>pwd</td>
<td>显示当前工作目录的路径名</td>
</tr>
<tr>
<td>read</td>
<td>从 STDIN 读取一行数据并将其赋给一个变量</td>
</tr>
<tr>
<td>readarray</td>
<td>从 STDIN 读取数据行并将其放入索引数组</td>
</tr>
<tr>
<td>readonly</td>
<td>从 STDIN 读取一行数据并将其赋给一个不可修改的变量</td>
</tr>
<tr>
<td>return</td>
<td>强制函数以某个值退出，这个值可以被调用脚本提取</td>
</tr>
<tr>
<td>set</td>
<td>设置并显示环境变量的值和 shell 属性</td>
</tr>
<tr>
<td>shift</td>
<td>将位置参数依次向下降一个位置</td>
</tr>
<tr>
<td>shopt</td>
<td>打开/关闭控制 shell 可选行为的变量值</td>
</tr>
<tr>
<td>source</td>
<td>读取并执行指定文件中的命令（在当前 shell 环境中）</td>
</tr>
<tr>
<td>suspend</td>
<td>暂停 Shell 的执行，直到收到一个 SIGCONT 信号</td>
</tr>
<tr>
<td>test</td>
<td>基于指定条件返回退出状态码 0 或 1</td>
</tr>
<tr>
<td>times</td>
<td>显示累计的用户和系统时间</td>
</tr>
<tr>
<td>trap</td>
<td>如果收到了指定的系统信号，执行指定的命令</td>
</tr>
<tr>
<td>type</td>
<td>显示指定的单词如果作为命令将会如何被解释</td>
</tr>
<tr>
<td>typeset</td>
<td>声明一个变量或变量类型。</td>
</tr>
<tr>
<td>ulimit</td>
<td>为系统用户设置指定的资源的上限</td>
</tr>
<tr>
<td>umask</td>
<td>为新建的文件和目录设置默认权限</td>
</tr>
<tr>
<td>unalias</td>
<td>刪除指定的别名</td>
</tr>
<tr>
<td>unset</td>
<td>刪除指定的环境变量或 shell 属性</td>
</tr>
<tr>
<td>wait</td>
<td>等待指定的进程完成，并返回退出状态码</td>
</tr>
</tbody>
</table>
<h4 id="echo">echo</h4>
<h5 id="不换行-n">不换行 -n</h5>
<h5 id="输出转义字符">输出转义字符</h5>
<p>默认情况下，echo 不会解析以反斜杠<code>\</code>开头的转义字符。比如，<code>\n</code>表示换行，echo 默认会将它作为普通字符对待。请看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# echo &quot;hello \nworld&quot;</span><br><span class="line">hello \nworld</span><br></pre></td></tr></table></figure>
<p>我们可以添加<code>-e</code>参数来让 echo 命令解析转义字符。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# echo -e &quot;hello \nworld&quot;</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>
<p><strong>\c 转义字符</strong></p>
<p>有了<code>-e</code>参数，我们也可以使用转义字符<code>\c</code>来强制 echo 命令不换行了。请看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">name&#x3D;&quot;Tom&quot;</span><br><span class="line">age&#x3D;20</span><br><span class="line">height&#x3D;175</span><br><span class="line">weight&#x3D;62</span><br><span class="line">echo -e &quot;$&#123;name&#125; is $&#123;age&#125; years old, \c&quot;</span><br><span class="line">echo -e &quot;$&#123;height&#125;cm in height \c&quot;</span><br><span class="line">echo &quot;and $&#123;weight&#125;kg in weight.&quot;</span><br><span class="line">echo &quot;Thank you!&quot;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tom is 20 years old, 175cm in height and 62kg in weight.</span><br><span class="line">Thank you!</span><br></pre></td></tr></table></figure>
<h4 id="exit">exit</h4>
<p>exit 是一个 <a href="http://c.biancheng.net/view/1136.html">Shell 内置命令</a>，用来退出当前 Shell 进程，并返回一个退出状态；使用<code>$?</code>可以接收这个退出状态，这一点已在《<a href="http://c.biancheng.net/view/808.html">Shell $?</a>》中进行了讲解。</p>
<p>exit 命令可以接受一个整数值作为参数，代表退出状态。如果不指定，默认状态值是 0。</p>
<p><strong>一般情况下，退出状态为 0 表示成功，退出状态为非 0 表示执行失败（出错）了。</strong></p>
<p>exit 退出状态只能是一个介于 0~255 之间的整数，其中只有 0 表示成功，其它值都表示失败。</p>
<p>Shell 进程执行出错时，可以根据退出状态来判断具体出现了什么错误，比如打开一个文件时，我们可以指定 1 表示文件不存在，2 表示文件没有读取权限，3 表示文件类型不对。</p>
<p>编写下面的脚本，并命名为 <a href="http://test.sh">test.sh</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">echo &quot;befor exit&quot;</span><br><span class="line">exit 8</span><br><span class="line">echo &quot;after exit&quot;</span><br></pre></td></tr></table></figure>
<p>运行该脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ bash .&#x2F;test.sh</span><br><span class="line">befor exit</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>&quot;after exit&quot;</code>并没有输出，这说明遇到 exit 命令后，<a href="http://test.sh">test.sh</a> 执行就结束了。</p>
<blockquote>
<p>注意，exit 表示退出当前 Shell 进程，我们必须在新进程中运行 <a href="http://test.sh">test.sh</a>，否则当前 Shell 会话（终端窗口）会被关闭，我们就无法看到输出结果了。</p>
</blockquote>
<p>我们可以紧接着使用<code>$?</code>来获取 <a href="http://test.sh">test.sh</a> 的退出状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ echo $?</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<h4 id="declare">declare</h4>
<p>设置变量的属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare [+&#x2F;-] [aAfFgilprtux] [变量名&#x3D;变量值]</span><br></pre></td></tr></table></figure>
<p>其中，<code>-</code>表示设置属性，<code>+</code>表示取消属性，<code>aAfFgilprtux</code>都是具体的选项，它们的含义如下表所示：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-f [name]</td>
<td>列出之前由用户在脚本中定义的函数名称和函数体。</td>
</tr>
<tr>
<td>-F [name]</td>
<td>仅列出自定义函数名称。</td>
</tr>
<tr>
<td>-g name</td>
<td>在 Shell 函数内部创建全局变量。</td>
</tr>
<tr>
<td>-p [name]</td>
<td>显示指定变量的属性和值。</td>
</tr>
<tr>
<td>-a name</td>
<td>声明变量为普通数组。</td>
</tr>
<tr>
<td>-A name</td>
<td>声明变量为关联数组（支持索引下标为字符串）。</td>
</tr>
<tr>
<td>-i name</td>
<td>将变量定义为整数型。</td>
</tr>
<tr>
<td>-r name[=value]</td>
<td>将变量定义为只读（不可修改和删除），等价于 readonly name。</td>
</tr>
<tr>
<td>-x name[=value]</td>
<td>将变量设置为环境变量，等价于 export name[=value]。</td>
</tr>
</tbody>
</table>
<p>【实例1】将变量声明为整数并进行计算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">declare -i m n ret  #将多个变量声明为整数</span><br><span class="line">m&#x3D;10</span><br><span class="line">n&#x3D;30</span><br><span class="line">ret&#x3D;$m+$n</span><br><span class="line">echo $ret</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>
40</p>
<p>【实例2】将变量定义为只读变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[c.biancheng.net]$ declare -r n&#x3D;10</span><br><span class="line">[c.biancheng.net]$ n&#x3D;20</span><br><span class="line">bash: n: 只读变量</span><br><span class="line">[c.biancheng.net]$ echo $n</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>【实例3】显示变量的属性和值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[c.biancheng.net]$ declare -r n&#x3D;10</span><br><span class="line">[c.biancheng.net]$ declare -p n</span><br><span class="line">declare -r n&#x3D;&quot;10&quot;</span><br></pre></td></tr></table></figure>
<h3 id="数学计算">数学计算</h3>
<p>如果要执行算术运算（数学计算），就离不开各种运算符号，和其他编程语言类似，Shell 也有很多算术运算符，下面就给大家介绍一下常见的 Shell 算术运算符，如下表所示。</p>
<table>
<thead>
<tr>
<th>算术运算符</th>
<th>说明/含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>+、-</td>
<td>加法（或正号）、减法（或负号）</td>
</tr>
<tr>
<td>*、/、%</td>
<td>乘法、除法、取余（取模）</td>
</tr>
<tr>
<td>**</td>
<td>幂运算</td>
</tr>
<tr>
<td>++、–</td>
<td>自增和自减，可以放在变量的前面也可以放在变量的后面</td>
</tr>
<tr>
<td>!、&amp;&amp;、||</td>
<td>逻辑非（取反）、逻辑与（and）、逻辑或（or）</td>
</tr>
<tr>
<td>&lt;、&lt;=、&gt;、&gt;=</td>
<td>比较符号（小于、小于等于、大于、大于等于）</td>
</tr>
<tr>
<td>==、!=、=</td>
<td>比较符号（相等、不相等；对于字符串，= 也可以表示相当于）</td>
</tr>
<tr>
<td>&lt;&lt;、&gt;&gt;</td>
<td>向左移位、向右移位</td>
</tr>
<tr>
<td>~、|、 &amp;、^</td>
<td>按位取反、按位或、按位与、按位异或</td>
</tr>
<tr>
<td>=、+=、-=、*=、/=、%=</td>
<td>赋值运算符，例如 a+=1 相当于 a=a+1，a-=1 相当于 a=a-1</td>
</tr>
</tbody>
</table>
<p>但是，Shell 和其它编程语言不同，Shell 不能直接进行算数运算，必须使用数学计算命令，这让初学者感觉很困惑，也让有经验的程序员感觉很奇葩。</p>
<p>下面我们先来看一个反面的例子：</p>
<p>[<a href="http://c.biancheng.net">c.biancheng.net</a>]$ echo 2+8<br>
2+8<br>
[<a href="http://c.biancheng.net">c.biancheng.net</a>]$ a=23<br>
[<a href="http://c.biancheng.net">c.biancheng.net</a>]$ b=<img src="https://math.now.sh?inline=a%2B55%0A%5Bc.biancheng.net%5D" style="display:inline-block;margin: 0;"/> echo <img src="https://math.now.sh?inline=b%0A23%2B55%0A%5Bc.biancheng.net%5D" style="display:inline-block;margin: 0;"/> b=90<br>
[<a href="http://c.biancheng.net">c.biancheng.net</a>]$ c=<img src="https://math.now.sh?inline=a%2B" style="display:inline-block;margin: 0;"/>b<br>
[<a href="http://c.biancheng.net">c.biancheng.net</a>]$ echo $c<br>
23+90</p>
<p>从上面的运算结果可以看出，默认情况下，Shell 不会直接进行算术运算，而是把<code>+</code>两边的数据（数值或者变量）当做字符串，把<code>+</code>当做字符串连接符，最终的结果是把两个字符串拼接在一起形成一个新的字符串。</p>
<p><strong>这是因为，在 Bash Shell 中，如果不特别指明，每一个变量的值都是字符串，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储。</strong></p>
<p>换句话说，Bash shell 在默认情况下不会区分变量类型，即使你将整数和小数赋值给变量，它们也会被视为字符串，这一点和大部分的编程语言不同。</p>
<h4 id="数学计算命令">数学计算命令</h4>
<table>
<thead>
<tr>
<th>运算操作符/运算命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://c.biancheng.net/view/2480.html">(( ))</a></td>
<td>用于整数运算，效率很高，<strong>推荐使用</strong>。</td>
</tr>
<tr>
<td><a href="http://c.biancheng.net/view/2504.html">let</a></td>
<td>用于整数运算，和 (()) 类似。</td>
</tr>
<tr>
<td>$[]</td>
<td>用于整数运算，不如 (()) 灵活。</td>
</tr>
<tr>
<td><a href="http://c.biancheng.net/view/vip_3236.html">expr</a></td>
<td>可用于整数运算，也可以处理字符串。比较麻烦，需要注意各种细节，不推荐使用。</td>
</tr>
<tr>
<td><a href="http://c.biancheng.net/view/vip_3237.html">bc</a></td>
<td>Linux下的一个计算器程序，可以处理整数和小数。Shell 本身只支持整数运算，想计算小数就得使用 bc 这个外部的计算器。</td>
</tr>
<tr>
<td><a href="http://c.biancheng.net/view/vip_3238.html">declare -i</a></td>
<td>将变量定义为整数，然后再进行数学运算时就不会被当做字符串了。功能有限，仅支持最基本的数学运算（加减乘除和取余），不支持逻辑运算、自增自减等，所以在实际开发中很少使用。</td>
</tr>
</tbody>
</table>
<h4 id="：整数运算">(()) ：整数运算</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">((表达式))</span><br></pre></td></tr></table></figure>
<p>通俗地讲，就是将数学运算表达式放在<code>((</code>和<code>))</code>之间。</p>
<p>表达式可以只有一个，也可以有多个，多个表达式之间以逗号<code>,</code>分隔。对于多个表达式的情况，以最后一个表达式的值作为整个 (( )) 命令的执行结果。</p>
<p>可以使用<code>$</code>获取 (( )) 命令的结果，这和使用<code>$</code>获得变量值是类似的。</p>
<table>
<thead>
<tr>
<th>运算操作符/运算命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>((a=10+66) ((b=a-15)) ((c=a+b))</td>
<td>这种写法可以在计算完成后给变量赋值。以 ((b=a-15)) 为例，即将 a-15 的运算结果赋值给变量 c。  注意，使用变量时不用加<code>$</code>前缀，(( )) 会自动解析变量名。</td>
</tr>
<tr>
<td>a=<img src="https://math.now.sh?inline=%28(10%2B66%29%20b%3D" style="display:inline-block;margin: 0;"/>((a-15)) c=$((a+b))</td>
<td>可以在 (( )) 前面加上<code>$</code>符号获取 (( )) 命令的执行结果，也即获取整个表达式的值。以 c=<img src="https://math.now.sh?inline=%28(a%2Bb%29)%20%E4%B8%BA%E4%BE%8B%EF%BC%8C%E5%8D%B3%E5%B0%86%20a%2Bb%20%E8%BF%99%E4%B8%AA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%BF%90%E7%AE%97%E7%BB%93%E6%9E%9C%E8%B5%8B%E5%80%BC%E7%BB%99%E5%8F%98%E9%87%8F%20c%E3%80%82%20%20%E6%B3%A8%E6%84%8F%EF%BC%8C%E7%B1%BB%E4%BC%BC%20c%3D((a%2Bb))%20%E8%BF%99%E6%A0%B7%E7%9A%84%E5%86%99%E6%B3%95%E6%98%AF%E9%94%99%E8%AF%AF%E7%9A%84%EF%BC%8C%E4%B8%8D%E5%8A%A0%60" style="display:inline-block;margin: 0;"/>`就不能取得表达式的结果。</td>
</tr>
<tr>
<td>((a&gt;7 &amp;&amp; b==c))</td>
<td>(( )) 也可以进行逻辑运算，在 if 语句中常会使用逻辑运算。<strong>逻辑运算为真，返回1；逻辑运算为假，返回0</strong></td>
</tr>
<tr>
<td>echo $((a+10))</td>
<td>需要立即输出表达式的运算结果时，可以在 (( )) 前面加<code>$</code>符号。</td>
</tr>
<tr>
<td>((a=3+5, b=a+10))</td>
<td>对多个表达式同时进行计算。</td>
</tr>
</tbody>
</table>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[c.biancheng.net]$ i&#x3D;5</span><br><span class="line">[c.biancheng.net]$ ((i&#x3D;i*2))  #可以简写为 ((i*&#x3D;2))。</span><br><span class="line">[c.biancheng.net]$ echo $i   #使用 echo 输出变量结果时要加 $。</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">[c.biancheng.net]$ ((a&#x3D;1+2**3-4%3))</span><br><span class="line">[c.biancheng.net]$ echo $a</span><br><span class="line">8</span><br><span class="line">[c.biancheng.net]$ b&#x3D;$((1+2**3-4%3)) #运算后将结果赋值给变量，变量放在了括号的外面。</span><br><span class="line">[c.biancheng.net]$ echo $b</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<p>逻辑运算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[c.biancheng.net]$ echo $((3&lt;8))  #3&lt;8 的结果是成立的，因此，输出了 1，1 表示真</span><br><span class="line">1</span><br><span class="line">[c.biancheng.net]$ echo $((8&lt;3))  #8&lt;3 的结果是不成立的，因此，输出了 0，0 表示假。</span><br><span class="line">0</span><br><span class="line">[c.biancheng.net]$ echo $((8&#x3D;&#x3D;8)) #判断是否相等。</span><br><span class="line">1</span><br><span class="line">[c.biancheng.net]$ if ((8&gt;7&amp;&amp;5&#x3D;&#x3D;5))</span><br><span class="line">&gt; then</span><br><span class="line">&gt; echo yes</span><br><span class="line">&gt; fi</span><br><span class="line">yes</span><br></pre></td></tr></table></figure>
<p>多个表达式计算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[c.biancheng.net]$ ((a&#x3D;3+5, b&#x3D;a+10))  #先计算第一个表达式，再计算第二个表达式</span><br><span class="line">[c.biancheng.net]$ echo $a $b</span><br><span class="line">8 18</span><br><span class="line">[c.biancheng.net]$ c&#x3D;$((4+8, a+b))  #以最后一个表达式的结果作为整个(())命令的执行结果</span><br><span class="line">[c.biancheng.net]$ echo $c</span><br><span class="line">26</span><br></pre></td></tr></table></figure>
<p>自增（++）和自减（–）运算</p>
<h5 id="前自增或后自增">前自增或后自增</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[c.biancheng.net]$ a&#x3D;10</span><br><span class="line">[c.biancheng.net]$ echo $((a++))  #如果++在a的后面，那么在输出整个表达式时，会输出a的值,因为a为10，所以表达式的值为10。</span><br><span class="line">10</span><br><span class="line">[c.biancheng.net]$ echo $a #执行上面的表达式后，因为有a++，因此a会自增1，因此输出a的值为11。</span><br><span class="line">11</span><br><span class="line">[c.biancheng.net]$ a&#x3D;11</span><br><span class="line">[c.biancheng.net]$ echo $((a--)) #如果--在a的后面，那么在输出整个表达式时，会输出a的值，因为a为11，所以表达式的值的为11。</span><br><span class="line">11</span><br><span class="line">[c.biancheng.net]$ echo $a #执行上面的表达式后，因为有a--，因此a会自动减1，因此a为10。</span><br><span class="line">10</span><br><span class="line">[c.biancheng.net]$ a&#x3D;10</span><br><span class="line">[c.biancheng.net]$ echo $((--a))  #如果--在a的前面，那么在输出整个表达式时，先进行自增或自减计算，因为a为10，且要自减，所以表达式的值为9。</span><br><span class="line">9</span><br><span class="line">[c.biancheng.net]$ echo $a #执行上面的表达式后，a自减1,因此a为9。</span><br><span class="line">9</span><br><span class="line">[c.biancheng.net]$ echo $((++a))  #如果++在a的前面，输出整个表达式时，先进行自增或自减计算，因为a为9，且要自增1，所以输出10。</span><br><span class="line">10</span><br><span class="line">[c.biancheng.net]$ echo $a  #执行上面的表达式后，a自增1,因此a为10。</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<ul>
<li>执行 echo $((a++)) 和 echo $((a–)) 命令输出整个表达式时，输出的值即为 a 的值，表达式执行完毕后，会再对 a 进行 ++、-- 的运算；</li>
<li>而执行 echo $((++a)) 和 echo $((–a)) 命令输出整个表达式时，会先对 a 进行 ++、-- 的运算，然后再输出表达式的值，即为 a 运算后的值。</li>
</ul>
<h3 id="if-语句">if 语句</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if  condition</span><br><span class="line">then</span><br><span class="line">    statement(s)</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if  condition</span><br><span class="line">then</span><br><span class="line">   statement1</span><br><span class="line">else</span><br><span class="line">   statement2</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if  condition1</span><br><span class="line">then</span><br><span class="line">   statement1</span><br><span class="line">elif condition2</span><br><span class="line">then</span><br><span class="line">    statement2</span><br><span class="line">elif condition3</span><br><span class="line">then</span><br><span class="line">    statement3</span><br><span class="line">……</span><br><span class="line">else</span><br><span class="line">   statementn</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h3 id="shell-退出状态">shell 退出状态</h3>
<p>每一条 Shell 命令，不管是 Bash 内置命令（例如 cd、echo），还是外部的 Linux 命令（例如 ls、awk），还是自定义的 Shell 函数，当它退出（运行结束）时，都会返回一个比较小的整数值给调用（使用）它的程序，这就是命令的<strong>退出状态（exit statu）</strong>。</p>
<p>if 语句的判断条件，从本质上讲，判断的就是命令的退出状态。</p>
<p><strong>按照惯例来说，退出状态为 0 表示“成功”；也就是说，程序执行完成并且没有遇到任何问题。除 0 以外的其它任何退出状态都为“失败”。</strong></p>
<p>之所以说这是“惯例”而非“规定”，是因为也会有例外，比如 diff 命令用来比较两个文件的不同，对于“没有差别”的文件返回 0，对于“找到差别”的文件返回 1，对无效文件名返回 2。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">read a</span><br><span class="line">read b</span><br><span class="line">(( $a &#x3D;&#x3D; $b ));</span><br><span class="line">echo &quot;退出状态：&quot;$?</span><br></pre></td></tr></table></figure>
<p>运行结果1：<br>
26<br>
26<br>
退出状态：0</p>
<p>运行结果2：<br>
17<br>
39<br>
退出状态：1</p>
<h4 id="退出状态和逻辑运算符的组合">退出状态和逻辑运算符的组合</h4>
<p>Shell if 语句的一个神奇之处是允许我们使用逻辑运算符将多个退出状态组合起来，这样就可以一次判断多个条件了。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>使用格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;&amp;</td>
<td>expression1 &amp;&amp; expression2</td>
<td>逻辑与运算符，当 expression1 和 expression2 同时成立时，整个表达式才成立。  如果检测到 expression1 的退出状态为 0，就不会再检测 expression2 了，因为不管 expression2 的退出状态是什么，整个表达式必然都是不成立的，检测了也是多此一举。</td>
</tr>
<tr>
<td>||</td>
<td>expression1 || expression2</td>
<td>逻辑或运算符，expression1 和 expression2 两个表达式中只要有一个成立，整个表达式就成立。  如果检测到 expression1 的退出状态为 1，就不会再检测 expression2 了，因为不管 expression2 的退出状态是什么，整个表达式必然都是成立的，检测了也是多此一举。</td>
</tr>
<tr>
<td>!</td>
<td>!expression</td>
<td>逻辑非运算符，相当于“取反”的效果。如果 expression 成立，那么整个表达式就不成立；如果 expression 不成立，那么整个表达式就成立。</td>
</tr>
</tbody>
</table>
<h3 id="test命令（Shell-）">test命令（Shell []）</h3>
<p>test 是 Shell 内置命令，用来检测某个条件是否成立。test 通常和 if 语句一起使用，并且大部分 if 语句都依赖 test。</p>
<p>test 命令有很多选项，可以进行数值、字符串和文件三个方面的检测。</p>
<p>Shell test 命令的用法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test expression</span><br></pre></td></tr></table></figure>
<p>当 test 判断 expression 成立时，退出状态为 0，否则为非 0 值。</p>
<p>test 命令也可以简写为<code>[]</code>，它的用法为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ expression ]</span><br></pre></td></tr></table></figure>
<p>注意<code>[]</code>和<code>expression</code>之间的空格，这两个空格是必须的，否则会导致语法错误。<code>[]</code>的写法更加简洁，比 test 使用频率高。</p>
<blockquote>
<p>test 和 [] 是等价的，后续我们会交替使用 test 和 []，以让读者尽快熟悉。</p>
</blockquote>
<p>在《<a href="http://c.biancheng.net/view/1262.html">Shell if else</a>》中，我们使用 (()) 进行数值比较，这节我们就来看一下如何使用 test 命令进行数值比较。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">read age</span><br><span class="line">if test $age -le 2; then</span><br><span class="line">    echo &quot;婴儿&quot;</span><br><span class="line">elif test $age -ge 3 &amp;&amp; test $age -le 8; then</span><br><span class="line">    echo &quot;幼儿&quot;</span><br><span class="line">elif [ $age -ge 9 ] &amp;&amp; [ $age -le 17 ]; then</span><br><span class="line">    echo &quot;少年&quot;</span><br><span class="line">elif [ $age -ge 18 ] &amp;&amp; [ $age -le 25 ]; then</span><br><span class="line">    echo &quot;成年&quot;</span><br><span class="line">elif test $age -ge 26 &amp;&amp; test $age -le 40; then</span><br><span class="line">    echo &quot;青年&quot;</span><br><span class="line">elif test $age -ge 41 &amp;&amp; [ $age -le 60 ]; then</span><br><span class="line">    echo &quot;中年&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;老年&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>其中，<code>-le</code>选项表示小于等于，<code>-ge</code>选项表示大于等于，<code>&amp;&amp;</code>是逻辑与运算符。</p>
<p>学习 test 命令，重点是学习它的各种选项，下面我们就逐一讲解。</p>
<h4 id="1-与文件检测相关的-test-选项">1) 与文件检测相关的 test 选项</h4>
<h5 id="文件类型判断">文件类型判断</h5>
<table>
<thead>
<tr>
<th>选 项</th>
<th>作 用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d filename</td>
<td>判断文件是否存在，并且是否为目录文件。</td>
</tr>
<tr>
<td>-e filename</td>
<td>判断文件是否存在。</td>
</tr>
<tr>
<td>-f filename</td>
<td>判断文件是否存在，井且是否为普通文件。</td>
</tr>
<tr>
<td>-L filename</td>
<td>判断文件是否存在，并且是否为符号链接文件。</td>
</tr>
<tr>
<td>-p filename</td>
<td>判断文件是否存在，并且是否为管道文件。</td>
</tr>
<tr>
<td>-s filename</td>
<td>判断文件是否存在，并且是否为非空。</td>
</tr>
</tbody>
</table>
<h5 id="文件权限判断"><strong>文件权限判断</strong></h5>
<table>
<thead>
<tr>
<th>选 项</th>
<th>作 用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-r filename</td>
<td>判断文件是否存在，并且是否拥有读权限。</td>
</tr>
<tr>
<td>-w filename</td>
<td>判断文件是否存在，并且是否拥有写权限。</td>
</tr>
<tr>
<td>-x filename</td>
<td>判断文件是否存在，并且是否拥有执行权限。</td>
</tr>
<tr>
<td>-u filename</td>
<td>判断文件是否存在，并且是否拥有 SUID 权限。</td>
</tr>
<tr>
<td>-g filename</td>
<td>判断文件是否存在，并且是否拥有 SGID 权限。</td>
</tr>
<tr>
<td>-k filename</td>
<td>判断该文件是否存在，并且是否拥有 SBIT 权限。</td>
</tr>
</tbody>
</table>
<h5 id="文件比较"><strong>文件比较</strong></h5>
<table>
<thead>
<tr>
<th>选 项</th>
<th>作 用</th>
</tr>
</thead>
<tbody>
<tr>
<td>filename1 -nt filename2</td>
<td>判断 filename1 的修改时间是否比 filename2 的新。</td>
</tr>
<tr>
<td>filename -ot filename2</td>
<td>判断 filename1 的修改时间是否比 filename2 的旧。</td>
</tr>
<tr>
<td>filename1 -ef filename2</td>
<td>判断 filename1 是否和 filename2 的 inode 号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法</td>
</tr>
</tbody>
</table>
<h4 id="2-与数值比较相关的-test-选项">2) 与数值比较相关的 test 选项</h4>
<table>
<thead>
<tr>
<th>选 项</th>
<th>作 用</th>
</tr>
</thead>
<tbody>
<tr>
<td>num1 -eq num2</td>
<td>判断 num1 是否和 num2 相等。</td>
</tr>
<tr>
<td>num1 -ne num2</td>
<td>判断 num1 是否和 num2 不相等。</td>
</tr>
<tr>
<td>num1 -gt num2</td>
<td>判断 num1 是否大于 num2 。</td>
</tr>
<tr>
<td>num1 -lt num2</td>
<td>判断 num1 是否小于 num2。</td>
</tr>
<tr>
<td>num1 -ge num2</td>
<td>判断 num1 是否大于等于 num2。</td>
</tr>
<tr>
<td>num1 -le num2</td>
<td>判断 num1 是否小于等于 num2。</td>
</tr>
</tbody>
</table>
<p><strong>注意，test 只能用来比较整数，小数相关的比较还得依赖 <a href="http://c.biancheng.net/view/vip_3237.html">bc 命令</a>。</strong></p>
<h4 id="3-与字符串判断相关的-test-选项">3) 与字符串判断相关的 test 选项</h4>
<table>
<thead>
<tr>
<th>选 项</th>
</tr>
</thead>
<tbody>
<tr>
<td>-z str</td>
</tr>
<tr>
<td>-n str</td>
</tr>
<tr>
<td>str1 = str2 str1 == str2</td>
</tr>
<tr>
<td>str1 != str2</td>
</tr>
<tr>
<td>str1 \&lt; str2</td>
</tr>
</tbody>
</table>
<p><s>有C语言、<a href="http://c.biancheng.net/cplus/">C++</a>、<a href="http://c.biancheng.net/python/">Python</a>、<a href="http://c.biancheng.net/java/">Java</a> 等编程经验的读者请注意，==、&gt;、&lt; 在大部分编程语言中都用来比较数字，而在 Shell 中，它们只能用来比较字符串，不能比较数字，这是非常奇葩的，大家要习惯。</s></p>
<p><strong>shell 不能使用 &gt; 这类符号进行比较，因为这和重定向符合冲突。</strong></p>
<p>Shell test 字符串比较举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">read str1</span><br><span class="line">read str2</span><br><span class="line">#检测字符串是否为空</span><br><span class="line">if [ -z &quot;$str1&quot; ] || [ -z &quot;$str2&quot; ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;字符串不能为空&quot;</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line">#比较字符串</span><br><span class="line">if [ $str1 &#x3D; $str2 ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;两个字符串相等&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;两个字符串不相等&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>
<a href="http://c.biancheng.net/">http://c.biancheng.net/</a><br>
<a href="http://c.biancheng.net/shell/">http://c.biancheng.net/shell/</a><br>
两个字符串不相等</p>
<p>细心的读者可能已经注意到，变量 $str1 和 $str2 都被双引号包围起来，这样做是为了防止 $str1 或者 $str2 是空字符串时出现错误，本文的后续部分将为你分析具体原因。</p>
<h4 id="4-与逻辑运算相关的-test-选项">4) 与逻辑运算相关的 test 选项</h4>
<table>
<thead>
<tr>
<th>选 项</th>
<th>作 用</th>
</tr>
</thead>
<tbody>
<tr>
<td>expression1 -a expression</td>
<td>逻辑与，表达式 expression1 和 expression2 都成立，最终的结果才是成立的。</td>
</tr>
<tr>
<td>expression1 -o expression2</td>
<td>逻辑或，表达式 expression1 和 expression2 有一个成立，最终的结果就成立。</td>
</tr>
<tr>
<td>!expression</td>
<td>逻辑非，对 expression 进行取反。</td>
</tr>
</tbody>
</table>
<p>这个和 &amp;&amp; 、|| 是一样的，我还是喜欢上一种写法。</p>
<h4 id="在-test-中使用变量建议用双引号包围起来">在 test 中使用变量建议用双引号包围起来</h4>
<p>test 和 [] 都是命令，一个命令本质上对应一个程序或者一个函数。即使是一个程序，它也有入口函数，例如C语言程序的入口函数是 main()，运行C语言程序就从 main() 函数开始，所以也可以将一个程序等效为一个函数，这样我们就不用再区分函数和程序了，直接将一个命令和一个函数对应起来即可。</p>
<p>有了以上认知，就很容易看透命令的本质了：使用一个命令其实就是调用一个函数，命令后面附带的选项和参数最终都会作为实参传递给函数。</p>
<p>假设 test 命令对应的函数是 func()，使用<code>test -z $str1</code>命令时，会先将变量 $str1 替换成字符串：</p>
<ul>
<li>如果 $str1 是一个正常的字符串，比如 abc123，那么替换后的效果就是<code>test -z abc123</code>，调用 func() 函数的形式就是<code>func(&quot;-z abc123&quot;)</code>。test 命令后面附带的所有选项和参数会被看成一个整体，并作为实参传递进函数。</li>
<li>如果 $str1 是一个空字符串，那么替换后的效果就是<code>test -z</code>，调用 func() 函数的形式就是<code>func(&quot;-z &quot;)</code>，这就比较奇怪了，因为<code>-z</code>选项没有和参数成对出现，func() 在分析时就会出错。</li>
</ul>
<p>如果我们给 $str1 变量加上双引号，当 <img src="https://math.now.sh?inline=str1%20%E6%98%AF%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%97%B6%EF%BC%8C%60test%20-z%20%22" style="display:inline-block;margin: 0;"/>str1&quot;<code>就会被替换为</code>test -z “”<code>，调用 func() 函数的形式就是</code>func(“-z “””)<code>，很显然，</code>-z<code>选项后面跟的是一个空字符串（</code>&quot;`表示转义字符），这样 func() 在分析时就不会出错了。</p>
<p><strong>所以，当你在 test 命令中使用变量时，我强烈建议将变量用双引号<code>&quot;&quot;</code>包围起来，这样能避免变量为空值时导致的很多奇葩问题。</strong></p>
<h4 id="总结-2">总结</h4>
<p>test 命令比较奇葩，&gt;、&lt;、== 只能用来比较字符串，不能用来比较数字，比较数字需要使用 -eq、-gt 等选项；不管是比较字符串还是数字，test 都不支持 &gt;= 和 &lt;=。有经验的程序员需要慢慢习惯 test 命令的这些奇葩用法。</p>
<p>对于整型数字的比较，我建议大家使用 (())，这在《<a href="http://c.biancheng.net/view/1262.html">Shell if else</a>》中已经进行了演示。(()) 支持各种运算符，写法也符合数学规则，用起来更加方便，何乐而不为呢？</p>
<h3 id="详解：检测某个条件是否成立">[[]]详解：检测某个条件是否成立</h3>
<p><code>[[ ]]</code>是 Shell 内置关键字，它和 <a href="http://c.biancheng.net/view/2742.html">test 命令</a>类似，也用来检测某个条件是否成立。</p>
<p>test 能做到的，[[ ]] 也能做到，而且 [[ ]] 做的更好；test 做不到的，[[ ]] 还能做到。可以认为 [[ ]] 是 test 的升级版，对细节进行了优化，并且扩展了一些功能。</p>
<p>[[ ]] 的用法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[ expression ]]</span><br></pre></td></tr></table></figure>
<p>当 [[ ]] 判断 expression 成立时，退出状态为 0，否则为非 0 值。注意<code>[[ ]]</code>和<code>expression</code>之间的空格，这两个空格是必须的，否则会导致语法错误。</p>
<h4 id="不需要注意某些细枝末节"><strong>[[ ]] 不需要注意某些细枝末节</strong></h4>
<p>[[ ]] 是 Shell 内置关键字，不是命令，在使用时没有给函数传递参数的过程，所以 test 命令的某些注意事项在 [[ ]] 中就不存在了，具体包括：</p>
<ul>
<li>不需要把变量名用双引号<code>&quot;&quot;</code>包围起来，即使变量是空值，也不会出错。</li>
<li>不需要、也不能对 &gt;、&lt; 进行转义，转义后会出错。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">read str1</span><br><span class="line">read str2</span><br><span class="line">if [[ -z $str1 ]] || [[ -z $str2 ]]  #不需要对变量名加双引号</span><br><span class="line">then</span><br><span class="line">    echo &quot;字符串不能为空&quot;</span><br><span class="line">elif [[ $str1 &lt; $str2 ]]  #不需要也不能对 &lt; 进行转义</span><br><span class="line">then</span><br><span class="line">    echo &quot;str1 &lt; str2&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;str1 &gt;&#x3D; str2&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>
<a href="http://c.biancheng.net/shell/">http://c.biancheng.net/shell/</a><br>
<a href="http://data.biancheng.net/">http://data.biancheng.net/</a><br>
str1 &lt; str2</p>
<h4 id="支持逻辑运算符">[[ ]] 支持逻辑运算符</h4>
<p>使用 [[ ]] 对[] 语进行改进：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[ -z $str1 || -z $str2 ]]</span><br></pre></td></tr></table></figure>
<p>注意，[[ ]] 剔除了 test 命令的<code>-o</code>和<code>-a</code>选项，你只能使用 || 和 &amp;&amp;。这意味着，你不能写成下面的形式：</p>
<p>当然，使用逻辑运算符将多个 [[ ]] 连接起来依然是可以的，因为这是 Shell 本身提供的功能，跟 [[ ]] 或者 test 没有关系，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[ -z $str1 ]] || [[ -z $str2 ]]</span><br></pre></td></tr></table></figure>
<h4 id="支持正则表达式">[[ ]] 支持正则表达式</h4>
<p>在 Shell [[ ]] 中，可以使用<code>=~</code>来检测字符串是否符合某个正则表达式，它的用法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[ str &#x3D;~ regex ]]</span><br></pre></td></tr></table></figure>
<p>str 表示字符串，regex 表示正则表达式。</p>
<p>下面的代码检测一个字符串是否是手机号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">read tel</span><br><span class="line">if [[ $tel &#x3D;~ ^1[0-9]&#123;10&#125;$ ]]</span><br><span class="line">then</span><br><span class="line">    echo &quot;你输入的是手机号码&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;你输入的不是手机号码&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果1：<br>
13203451100<br>
你输入的是手机号码</p>
<p>运行结果2：<br>
132034511009<br>
你输入的不是手机号码</p>
<p>对<code>^1[0-9]&#123;10&#125;$</code>的说明：</p>
<ul>
<li><code>^</code>匹配字符串的开头（一个位置）；</li>
<li><code>[0-9]&#123;10&#125;</code>匹配连续的十个数字；</li>
<li><code>$</code>匹配字符串的末尾（一个位置）。</li>
</ul>
<p>本文并不打算讲解正则表达式的语法，不了解的读者请猛击《<a href="http://deerchao.net/tutorials/regex/regex.htm">正则表达式30分钟入门教程</a>》。</p>
<h4 id="总结-–-基本无用">总结 – 基本无用</h4>
<h4 id="除非需要用正则表达式，不然不需要用">除非需要用正则表达式，不然不需要用 [[]]</h4>
<p>有了 [[ ]]，你还有什么理由使用 test 或者 [ ]，[[ ]] 完全可以替代之，而且更加方便，更加强大。</p>
<p>但是 [[ ]] 对数字的比较仍然不友好，所以我建议，以后大家使用 if 判断条件时，<strong>用 (()) 来处理整型数字，用 [[ ]] 来处理字符串或者文件</strong>。</p>
<h3 id="while-循环">while 循环</h3>
<p>while 循环是 Shell 脚本中最简单的一种循环，当条件满足时，while 重复地执行一组语句，当条件不满足时，就退出 while 循环。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    statements</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p><code>condition</code>表示判断条件，<code>statements</code>表示要执行的语句（可以只有一条，也可以有多条），<code>do</code>和<code>done</code>都是 Shell 中的关键字。</p>
<p>举例： 计算从 1 加到 100 的和。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">i&#x3D;1</span><br><span class="line">sum&#x3D;0</span><br><span class="line">while ((i &lt;&#x3D; 100))</span><br><span class="line">do</span><br><span class="line">    ((sum +&#x3D; i))</span><br><span class="line">    ((i++))</span><br><span class="line">done</span><br><span class="line">echo &quot;The sum is: $sum&quot;</span><br></pre></td></tr></table></figure>
<h3 id="for-循环">for 循环</h3>
<h4 id="C语言风格的for循环">C语言风格的for循环</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(( 初始化语句; 判断条件; 自增或自减 ))</span><br><span class="line">do</span><br><span class="line">    statements</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p><img src="3.png" alt="3"></p>
<p>举例而言,计算从 1 加到 100 的和。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">sum&#x3D;0</span><br><span class="line"></span><br><span class="line">for ((i&#x3D;1; i&lt;&#x3D;100; i++))</span><br><span class="line">do</span><br><span class="line">    ((sum +&#x3D; i))</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;The sum is: $sum&quot;</span><br></pre></td></tr></table></figure>
<p>代码分析：</p>
<ol>
<li>
<p>执行到 for 语句时，先给变量 i 赋值为 1，然后判断 i&lt;=100 是否成立；因为此时 i=1，所以 i&lt;=100 成立。接下来会执行循环体中的语句，等循环体执行结束后（sum 的值为1），再计算 i++。</p>
</li>
<li>
<p>第二次循环时，i 的值为2，i&lt;=100 成立，继续执行循环体。循环体执行结束后（sum的值为3），再计算 i++。</p>
</li>
<li>
<p>重复执行步骤 2)，直到第 101 次循环，此时 i 的值为 101，i&lt;=100 不再成立，所以结束循环。</p>
</li>
</ol>
<h4 id="python-风格的-for-in-循环">python 风格的 for in 循环</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for variable in value_list</span><br><span class="line">do</span><br><span class="line">    statements</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>举例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">sum&#x3D;0</span><br><span class="line">for n in 1 2 3 4 5 6</span><br><span class="line">do</span><br><span class="line">    echo $n</span><br><span class="line">     ((sum+&#x3D;n))</span><br><span class="line">done</span><br><span class="line">echo &quot;The sum is &quot;$sum</span><br></pre></td></tr></table></figure>
<h5 id="对-value-list-的说明">对 value_list 的说明</h5>
<p>取值列表 value_list 的形式有多种，你可以直接给出具体的值，也可以给出一个范围，还可以使用命令产生的结果，甚至使用通配符，下面我们一一讲解。</p>
<ol>
<li><strong>直接给出具体的值</strong></li>
</ol>
<p>可以在 in 关键字后面直接给出具体的值，多个值之间以空格分隔，比如<code>1 2 3 4 5</code>、<code>&quot;abc&quot; &quot;390&quot; &quot;tom&quot;</code>等。</p>
<p><strong>(ugly!)</strong></p>
<p><strong>2) 给出一个取值范围</strong></p>
<p>给出一个取值范围的具体格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;start..end&#125;</span><br></pre></td></tr></table></figure>
<p>start 表示起始值，end 表示终止值；注意中间用两个点号相连，而不是三个点号。<strong>根据笔者的实测，这种形式只支持数字和字母</strong>。</p>
<p>例如，计算从 1 加到 100 的和：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">sum&#x3D;0</span><br><span class="line">for n in &#123;1..100&#125;</span><br><span class="line">do</span><br><span class="line">    ((sum+&#x3D;n))</span><br><span class="line">done</span><br><span class="line">echo $sum</span><br></pre></td></tr></table></figure>
<p>再如，输出从 A 到 z 之间的所有字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">for c in &#123;A..z&#125;</span><br><span class="line">do</span><br><span class="line">    printf &quot;%c&quot; $c</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>3) 使用命令的执行结果</strong></p>
<p>例如，计算从 1 到 100 之间所有偶数的和：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">sum&#x3D;0</span><br><span class="line">for n in $(seq 2 2 100)</span><br><span class="line">do</span><br><span class="line">    ((sum+&#x3D;n))</span><br><span class="line">done</span><br><span class="line">echo $sum</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>seq 是一个 Linux 命令，用来产生某个范围内的整数，并且可以设置步长。<code>seq 2 2 100</code>表示从 2 开始，每次增加 2，到 100 结束（包括2和100）。</p>
<p><strong>4) 使用 Shell 通配符</strong></p>
<p>Shell 通配符可以认为是一种精简化的正则表达式，通常用来匹配目录或者文件，而不是文本，不了解的读者请猛击《<a href="https://www.linuxidc.com/Linux/2016-08/134192.htm">Linux Shell 通配符（glob 模式）</a>》。</p>
<p>有了 Shell 通配符，不使用 ls 命令也能显示当前目录下的所有脚本文件，请看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">for filename in *.sh</span><br><span class="line">do</span><br><span class="line">    echo $filename</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>
<a href="http://demo.sh">demo.sh</a><br>
<a href="http://test.sh">test.sh</a><br>
<a href="http://abc.sh">abc.sh</a></p>
<h5 id="for-filename-in-sh-可以替换find命令">for filename in *.sh 可以替换find命令</h5>
<p><strong>5) 使用特殊变量</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">function func()&#123;</span><br><span class="line">    for str in $@ # $@ 也可以用在函数中 </span><br><span class="line">    do</span><br><span class="line">        echo $str</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line">func C++ Java Python C#</span><br></pre></td></tr></table></figure>
<h3 id="break和continue跳出循环">break和continue跳出循环</h3>
<p>使用 while、until、for、select 循环时，如果想提前结束循环（在不满足结束条件的情况下结束循环），可以使用 break 或者 continue 关键字。</p>
<p>在C语言、<a href="http://c.biancheng.net/cplus/">C++</a>、<a href="http://c.biancheng.net/csharp/">C#</a>、<a href="http://c.biancheng.net/python/">Python</a>、<a href="http://c.biancheng.net/java/">Java</a> 等大部分编程语言中，break 和 continue 只能跳出当前层次的循环，内层循环中的 break 和 continue 对外层循环不起作用；但是 Shell 中的 break 和 continue 却能够跳出多层循环，也就是说，内层循环中的 break 和 continue 能够跳出外层循环。</p>
<p>在实际开发中，break 和 continue 一般只用来跳出当前层次的循环，很少有需要跳出多层循环的情况。</p>
<h4 id="break">break</h4>
<p>bread 是彻底跳出循环</p>
<p>Shell break 关键字的用法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">break n</span><br></pre></td></tr></table></figure>
<p>n 表示跳出循环的层数，如果省略 n，则表示跳出当前的整个循环。break 关键字通常和 if 语句一起使用，即满足条件时便跳出循环。</p>
<h4 id="continue">continue</h4>
<p>continue 是终止本次循环，继续下一次循环。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">continue n</span><br></pre></td></tr></table></figure>
<p>n 表示循环的层数：</p>
<ul>
<li>如果省略 n，则表示 continue 只对当前层次的循环语句有效，遇到 continue 会跳过本次循环，忽略本次循环的剩余代码，直接进入下一次循环。</li>
<li>如果带上 n，比如 n 的值为 2，那么 continue 对内层和外层循环语句都有效，不但内层会跳过本次循环，外层也会跳过本次循环，其效果相当于内层循环和外层循环<strong>同时</strong>执行了不带 n 的 continue。这么说可能有点难以理解，稍后我们通过代码来演示。</li>
</ul>
<p>不需要，我觉得我不会写跳出几层循环的代码（ugly）</p>
<h3 id="函数">函数</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function name() &#123;</span><br><span class="line">  statements</span><br><span class="line">  [return value]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对各个部分的说明：</p>
<ul>
<li><code>function</code>是 Shell 中的关键字，专门用来定义函数；</li>
<li><code>name</code>是函数名；</li>
<li><code>statements</code>是函数要执行的代码，也就是一组语句；</li>
<li><code>return value</code>表示函数的返回值，其中 return 是 Shell 关键字，专门用在函数中返回一个值；这一部分可以写也可以不写。</li>
</ul>
<p>由<code>&#123; &#125;</code>包围的部分称为函数体，调用一个函数，实际上就是执行函数体中的代码。</p>
<h4 id="函数调用">函数调用</h4>
<p>调用 Shell 函数时可以给它传递参数，也可以不传递。如果不传递参数，直接给出函数名字即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name</span><br></pre></td></tr></table></figure>
<p>如果传递参数，那么多个参数之间以空格分隔：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name param1 param2 param3</span><br></pre></td></tr></table></figure>
<p>不管是哪种形式，函数名字后面都不需要带括号。</p>
<p>和其它编程语言不同的是，<strong>Shell 函数在定义时不能指明参数</strong>，但是在调用时却可以传递参数，并且给它传递什么参数它就接收什么参数。</p>
<p>Shell 也不限制定义和调用的顺序，你可以将定义放在调用的前面，也可以反过来，将定义放在调用的后面。</p>
<p>举例， 定义一个函数，计算所有参数的和：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">function getsum()&#123;</span><br><span class="line">    local sum&#x3D;0</span><br><span class="line">    for n in $@</span><br><span class="line">    do</span><br><span class="line">         ((sum+&#x3D;n))</span><br><span class="line">    done</span><br><span class="line">    return $sum</span><br><span class="line">&#125;</span><br><span class="line">getsum 10 20 55 15  #调用函数并传递参数</span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>
100</p>
<p><strong>shell的函数定义时没有参数（即括号内为空），但是函数体内可以用$1, $2等位置参数使用参数</strong></p>
<h4 id="函数参数">函数参数</h4>
<p>函数参数是 <a href="http://c.biancheng.net/view/789.html">Shell 位置参数</a>的一种，在函数内部可以使用<code>$n</code>来接收，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。</p>
<p>除了<code>$n</code>，还有另外三个比较重要的变量：</p>
<ul>
<li><code>$#</code>可以获取传递的参数的个数；</li>
<li><code>$@</code>或者<code>$*</code>可以一次性获取所有的参数</li>
</ul>
<h3 id="重定向">重定向</h3>
<p>Linux Shell 重定向分为两种，一种输入重定向，一种是输出重定向；从字面上理解，输入输出重定向就是「改变输入与输出的方向」的意思。</p>
<p>那么，什么是输入输出方向呢？标准的输入输出方向又是什么呢？</p>
<p>一般情况下，我们都是从键盘读取用户输入的数据，然后再把数据拿到程序（C语言程序、Shell 脚本程序等）中使用；这就是标准的输入方向，也就是从键盘到程序。</p>
<p>反过来说，程序中也会产生数据，这些数据一般都是直接呈现到显示器上，这就是标准的输出方向，也就是从程序到显示器。</p>
<p>我们可以把观点提炼一下，其实输入输出方向就是数据的流动方向：</p>
<ul>
<li>输入方向就是数据从哪里流向程序。数据默认从键盘流向程序，如果改变了它的方向，数据就从其它地方流入，这就是输入重定向。</li>
<li>输出方向就是数据从程序流向哪里。数据默认从程序流向显示器，如果改变了它的方向，数据就流向其它地方，这就是输出重定向。</li>
</ul>
<h4 id="硬件设备和文件描述符">硬件设备和文件描述符</h4>
<p>计算机的硬件设备有很多，常见的输入设备有键盘、鼠标、麦克风、手写板等，输出设备有显示器、投影仪、打印机等。不过，在 Linux 中，标准输入设备指的是键盘，标准输出设备指的是显示器。</p>
<p>Linux 中一切皆文件，包括标准输入设备（键盘）和标准输出设备（显示器）在内的所有计算机硬件都是文件。</p>
<p>为了表示和区分已经打开的文件，Linux 会给每个文件分配一个 ID，这个 ID 就是一个整数，被称为文件描述符（File Descriptor）。</p>
<table>
<thead>
<tr>
<th>文件描述符</th>
<th>文件名</th>
<th>类型</th>
<th>硬件</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>stdin</td>
<td>标准输入文件</td>
<td>键盘</td>
</tr>
<tr>
<td>1</td>
<td>stdout</td>
<td>标准输出文件</td>
<td>显示器</td>
</tr>
<tr>
<td>2</td>
<td>stderr</td>
<td>标准错误输出文件</td>
<td>显示器</td>
</tr>
</tbody>
</table>
<p>Linux 程序在执行任何形式的 I/O 操作时，都是在读取或者写入一个文件描述符。一个文件描述符只是一个和打开的文件相关联的整数，它的背后可能是一个硬盘上的普通文件、FIFO、管道、终端、键盘、显示器，甚至是一个网络连接。</p>
<p>stdin、stdout、stderr 默认都是打开的，在重定向的过程中，0、1、2 这三个文件描述符可以直接使用。</p>
<h4 id="Linux-Shell-输出重定向">Linux Shell 输出重定向</h4>
<p>输出重定向是指命令的结果不再输出到显示器上，而是输出到其它地方，一般是文件中。这样做的最大好处就是把命令的结果保存起来，当我们需要的时候可以随时查询。Bash 支持的输出重定向符号如下表所示。</p>
<p>Bash 支持的输出重定向符号</p>
<table>
<thead>
<tr>
<th>类 型</th>
<th>符 号</th>
<th>作 用</th>
</tr>
</thead>
<tbody>
<tr>
<td>标准输出重定向</td>
<td>command &gt;file</td>
<td>以覆盖的方式，把 command 的正确输出结果输出到 file 文件中。</td>
</tr>
<tr>
<td>command &gt;&gt;file</td>
<td>以追加的方式，把 command 的正确输出结果输出到 file 文件中。</td>
<td></td>
</tr>
<tr>
<td>标准错误输出重定向</td>
<td>command 2&gt;file</td>
<td>以覆盖的方式，把 command 的错误信息输出到 file 文件中。</td>
</tr>
<tr>
<td>command 2&gt;&gt;file</td>
<td>以追加的方式，把 command 的错误信息输出到 file 文件中。</td>
<td></td>
</tr>
<tr>
<td>正确输出和错误信息同时保存</td>
<td>command &gt;file 2&gt;&amp;1</td>
<td>以覆盖的方式，把正确输出和错误信息同时保存到同一个文件（file）中。</td>
</tr>
<tr>
<td>command &gt;&gt;file 2&gt;&amp;1</td>
<td>以追加的方式，把正确输出和错误信息同时保存到同一个文件（file）中。</td>
<td></td>
</tr>
<tr>
<td>command &gt;file1 2&gt;file2</td>
<td>以覆盖的方式，把正确的输出结果输出到 file1 文件中，把错误信息输出到 file2 文件中。</td>
<td></td>
</tr>
<tr>
<td>command &gt;&gt;file1 2&gt;&gt;file2</td>
<td>以追加的方式，把正确的输出结果输出到 file1 文件中，把错误信息输出到 file2 文件中。</td>
<td></td>
</tr>
<tr>
<td>command &gt;file 2&gt;file</td>
<td>【<strong>不推荐</strong>】这两种写法会导致 file 被打开两次，引起资源竞争，所以 stdout 和 stderr 会互相覆盖，我们将在《<a href="http://c.biancheng.net/view/vip_3241.html">结合Linux文件描述符谈重定向，彻底理解重定向的本质</a>》一节中深入剖析。</td>
<td></td>
</tr>
<tr>
<td>command &gt;&gt;file 2&gt;&gt;file</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="">&amp;&gt;</h4>
<p>标准输出和标准错误输出到同一个文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;&gt;</span><br><span class="line">&amp;&gt;&gt; #追加</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>输出重定向的完整写法其实是<code>fd&gt;file</code>或者<code>fd&gt;&gt;file</code>，其中 fd 表示文件描述符，如果不写，默认为 1，也就是标准输出文件。</p>
<p>当文件描述符为 1 时，一般都省略不写，如上表所示；当然，如果你愿意，也可以将<code>command &gt;file</code>写作<code>command 1&gt;file</code>，但这样做是多此一举。</p>
<p>当文件描述符为大于 1 的值时，比如 2，就必须写上。</p>
<p>【实例1】把正确结果和错误信息都保存到一个文件中，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[c.biancheng.net]$ ls -l &gt;out.log 2&gt;&amp;1</span><br><span class="line">[c.biancheng.net]$ ls java &gt;&gt;out.log 2&gt;&amp;1</span><br><span class="line">[c.biancheng.net]$ cat out.log</span><br><span class="line">总用量 12</span><br><span class="line">drwxr-xr-x. 2 root     root      21 7月   1 2016 abc</span><br><span class="line">-rw-r--r--. 1 mozhiyan mozhiyan 399 3月  11 17:12 demo.sh</span><br><span class="line">-rw-rw-r--. 1 mozhiyan mozhiyan 278 3月  16 17:17 main.c</span><br><span class="line">-rw-rw-r--. 1 mozhiyan mozhiyan   0 3月  22 17:39 out.log</span><br><span class="line">-rwxr-xr-x. 1 mozhiyan mozhiyan 187 3月  22 17:16 test.sh</span><br><span class="line">ls: 无法访问java: 没有那个文件或目录</span><br></pre></td></tr></table></figure>
<p>out.log 的最后一行是错误信息，其它行都是正确的输出结果。</p>
<p>【实例2】上面的实例将正确结果和错误信息都写入同一个文件中，这样会导致视觉上的混乱，不利于以后的检索，所以我建议把正确结果和错误信息分开保存到不同的文件中，也即写成下面的形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -l &gt;&gt;out.log 2&gt;&gt;err.log</span><br></pre></td></tr></table></figure>
<p>这样一来，正确的输出结果会写入到 out.log，而错误的信息则会写入到 err.log。</p>
<h4 id="dev-null-文件">/dev/null 文件</h4>
<p>如果你既不想把命令的输出结果保存到文件，也不想把命令的输出结果显示到屏幕上，干扰命令的执行，那么可以把命令的所有结果重定向到 /dev/null 文件中。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -l &amp;&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure>
<p>大家可以把 /dev/null 当成 Linux 系统的垃圾箱，任何放入垃圾箱的数据都会被丢弃，不能恢复。</p>
<h4 id="Linux-Shell-输入重定向">Linux Shell 输入重定向</h4>
<p>输入重定向就是改变输入的方向，不再使用键盘作为命令输入的来源，而是使用文件作为命令的输入。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>command &lt;file</td>
<td>将 file 文件中的内容作为 command 的输入。</td>
</tr>
<tr>
<td>command &lt;&lt;END</td>
<td>从标准输入（键盘）中读取数据，直到遇见分界符 END 才停止（分界符可以是任意的字符串，用户自己定义）。</td>
</tr>
<tr>
<td>command <file1 >file2</td>
<td>将 file1 作为 command 的输入，并将 command 的处理结果输出到 file2。</td>
</tr>
</tbody>
</table>
<p>和输出重定向类似，输入重定向的完整写法是<code>fd&lt;file</code>，其中 fd 表示文件描述符，如果不写，默认为 0，也就是标准输入文件。</p>
<p><strong>输入重定向举例</strong></p>
<p>统计 readme.txt 文件中有多少行文本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[c.biancheng.net]$ cat readme.txt  #预览一下文件内容</span><br><span class="line">C语言中文网</span><br><span class="line">http:&#x2F;&#x2F;c.biancheng.net&#x2F;</span><br><span class="line">成立7年了</span><br><span class="line">日IP数万</span><br><span class="line">[c.biancheng.net]$ wc -l &lt;readme.txt  #输入重定向</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>【实例2】逐行读取文件内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">while read str; do</span><br><span class="line">    echo $str</span><br><span class="line">done &lt;readme.txt</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>
C语言中文网<br>
<a href="http://c.biancheng.net/">http://c.biancheng.net/</a><br>
成立7年了<br>
日IP数万</p>
<p>【实例3】统计用户在终端输入的文本的行数。</p>
<p>此处我们使用输入重定向符号<code>&lt;&lt;</code>，这个符号的作用是使用特定的分界符作为命令输入的结束标志，而不使用 Ctrl+D 键。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[c.biancheng.net]$ wc -l &lt;&lt;END</span><br><span class="line">&gt; 123</span><br><span class="line">&gt; 789</span><br><span class="line">&gt; abc</span><br><span class="line">&gt; xyz</span><br><span class="line">&gt; END</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>wc 命令会一直等待用输入，直到遇见分界符 END 才结束读取。</p>
<p><code>&lt;&lt;</code>之后的分界符可以自由定义，只要再碰到相同的分界符，两个分界符之间的内容将作为命令的输入（不包括分界符本身）。</p>
<h4 id="shell-程序返回值">shell 程序返回值</h4>
<ul>
<li>
<p>方式一：return , 只能返回 1-255  的整数，通常是返回程序运行状况，一般为0/1</p>
</li>
<li>
<p>方式二：echo，返回任何字符串结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo `command`	</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Linux-Shell管道详解">Linux Shell管道详解</h3>
<p>通过前面的学习，我们已经知道了怎样从文件重定向输入，以及重定向输出到文件。Shell 还有一种功能，就是可以将两个或者多个命令（程序或者进程）连接到一起，把一个命令的输出作为下一个命令的输入，以这种方式连接的两个或者多个命令就形成了<strong>管道（pipe）</strong>。</p>
<blockquote>
<p>这里需要注意，command1 必须有正确输出，而 command2 必须可以处理 command2 的输出结果；而且 command2 只能处理 command1 的正确输出结果，不能处理 command1 的错误信息。</p>
</blockquote>
<h3 id="shell-通配符-glob-模式-（找目录和文件）">shell 通配符 / glob 模式 （找目录和文件）</h3>
<p>glob 模式（globbing）也被称之为 shell 通配符，名字的起源来自于 Unix V6 中的 /etc/glob （详见 man 文档）。glob 是一种特殊的模式匹配，最常见的是通配符拓展，也可以将 glob 模式设为精简了的正则表达式，在最新的 <a href="http://www.linuxidc.com/topicnews.aspx?tid=14">CentOS</a> 7 中已经删除了 glob 的相关描述文档，删除的原因由于 glob 已经整合到了 shell 之中，然后就有了 shell 通配符。</p>
<p><strong>shell 通配符 / glob 模式通常用来匹配目录以及文件，而不是文本！！！</strong></p>
<h4 id="语法">语法</h4>
<table>
<thead>
<tr>
<th>字符</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配任意长度任意字符</td>
</tr>
<tr>
<td>?</td>
<td>匹配任意单个字符</td>
</tr>
<tr>
<td>[list]</td>
<td>匹配指定范围内（list）任意单个字符，也可以是单个字符组成的集合</td>
</tr>
<tr>
<td>[^list]</td>
<td>匹配指定范围外的任意单个字符或字符集合</td>
</tr>
<tr>
<td>[!list]</td>
<td>同上</td>
</tr>
<tr>
<td>{str1,str2,…}</td>
<td>匹配 srt1 或者 srt2 或者更多字符串，也可以是集合</td>
</tr>
</tbody>
</table>
<h5 id="与">[] 与 {}</h5>
<ul>
<li>
<p>[] 是指定的单个字符，而{}是字符串</p>
</li>
<li>
<p>[] 是只返回匹配得到的文件名，而{}是返回所有字符串的匹配结果，没有会报错。</p>
<p><img src="4.png" alt="4"></p>
<p>等等，{} 只是提示，但是如果重定向到文件中，和[]是一样的。</p>
<p>我懂了，这样重定向只是标准输出导入到文件了，报错还在屏幕上，如果加上2&gt;&amp;1，那么报错就也加入到文件中了。</p>
<p>那么 {} 的逻辑应该是这样的：对每个字符串进行操作，没有就报错。而[] 单个字符匹配不上不显示任何信息，只显示匹配得上的信息，<strong>如果都匹配不上，一样报错</strong>。</p>
<p><img src="5.png" alt="4"></p>
<p><img src="6.png" alt="4"></p>
<p>注意 [] 里的数字不能高于10，比如[10-13] 并不能匹配到10 11 12 13。</p>
</li>
</ul>
<p><strong>专用字符集</strong></p>
<table>
<thead>
<tr>
<th>字符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>[:alnum:]</td>
<td>任意数字或者字母</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>任意字母</td>
</tr>
<tr>
<td>[:space:]</td>
<td>空格</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>小写字母</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>任意数字</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>任意大写字母</td>
</tr>
<tr>
<td>[:cntrl:]</td>
<td>控制符</td>
</tr>
<tr>
<td>[:graph:]</td>
<td>图形</td>
</tr>
<tr>
<td>[:print:]</td>
<td>可打印字符</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>标点符号</td>
</tr>
<tr>
<td>[:xdigit:]</td>
<td>十六进制数</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>空白字符（未验证）</td>
</tr>
</tbody>
</table>
<h4 id="需要转义的元字符（感觉有点问题）">需要转义的元字符（感觉有点问题）</h4>
<table>
<thead>
<tr>
<th>IFS</th>
<th>由 &lt; space &gt; 或 &lt; tab &gt; 或 &lt; enter &gt; 三者之一组成</th>
</tr>
</thead>
<tbody>
<tr>
<td>CR</td>
<td>由 &lt; enter &gt; 产生</td>
</tr>
<tr>
<td>=</td>
<td>设定变量</td>
</tr>
<tr>
<td>$</td>
<td>作变量或运算替换</td>
</tr>
<tr>
<td>&gt;</td>
<td>重导向标准输出</td>
</tr>
<tr>
<td>&lt;</td>
<td>重导向标准输入</td>
</tr>
<tr>
<td>|</td>
<td></td>
</tr>
<tr>
<td>&amp;</td>
<td>重导向文件描述符，或将命令静默执行</td>
</tr>
<tr>
<td>( )</td>
<td>将其内的命令置于 nested subshell 执行，或用于运算或命令替换</td>
</tr>
<tr>
<td>{ }</td>
<td>将其内的命令置于 non-named function 中执行，或用在变量替换的界定范围</td>
</tr>
<tr>
<td>;</td>
<td>在前一个命令结束时，而忽略其返回值，继续执行下一个命令</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>在前一个命令结束时，若返回值为 true，继续执行下一个命令</td>
</tr>
<tr>
<td>\</td>
<td>\</td>
</tr>
<tr>
<td>!</td>
<td>执行 history 中的命令</td>
</tr>
</tbody>
</table>
<p><strong>示例</strong></p>
<p>这里使用 /etc 下的文件为例</p>
<p>匹配以 a开头，中间包含任意数量数字的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls a*[0-9]*</span><br><span class="line">#当然你是找不到的，因为通常情况下 &#x2F;etc 下没有以数字开头的文件</span><br></pre></td></tr></table></figure>
<p>匹配以任意小写字母开头，中间包含数字的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls [[:lower:]]*[0-9]*</span><br><span class="line">#相信你已经看到了一些文件，我们继续</span><br></pre></td></tr></table></figure>
<p>列出所有文件中以 init 开头，英文结尾的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls init*[a-z]</span><br></pre></td></tr></table></figure>
<p>列出以 au,b,c 开头的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls &#123;&quot;au&quot;,[bc]&#125;* </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据分析</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>词霸天下上</title>
    <url>/posts/e4032b5c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>看《词霸天下》背单词的笔记。前6节课应该是没做笔记。</p>
<span id="more"></span>
<h1>第7节课</h1>
<h2 id="via">via</h2>
<p>via 路，道路<br>
via prep. 途径；经由；取道<br>
obviate vt. 避免 ob 反<br>
obvious 明显的 （从挡路的引申而来）。<br>
previous 从前的<br>
trival 平凡的，琐细的<br>
tri 三 via 路 ——三岔路——市井<br>
nontrival<br>
trivially<br>
trivality<br>
trivality<br>
trivalization<br>
deviant n. 不正常的人 adj. 异常的<br>
de- 向下 离开<br>
deviate<br>
deviation<br>
deviationist<br>
devious adj. 偏离大道的，偏远的<br>
deviously<br>
deviance n.<br>
deviancy 同上<br>
deviated v.  过去式和过去分词<br>
viatic a. 道路的<br>
viameter n. 路程表<br>
-meter-测量<br>
viaduct n.高架桥<br>
-duct- 引导-开路-架桥<br>
voyage<br>
voyager<br>
voyageur n.<br>
-ar = -er = -or = -ur 名词后缀 表人<br>
convoy n. 护送 护航<br>
con- 强调 -voy- 路–送行–护送<br>
convey n. 传达；输送。与上面结构类似，含义不同。<br>
envoy n. 使者<br>
covey n. 一队，一群<br>
co- 在一起<br>
conveyor n.输送机<br>
-or 表物<br>
conveyer n.同上<br>
conveyance n.</p>
<p>way n. adv. adj<br>
away<br>
always<br>
al- = all<br>
hallway 走廊<br>
doorway 门口<br>
halfway<br>
driveway 私人车道<br>
subway<br>
runway 跑道<br>
runaway adj. n. 逃亡的 逃跑<br>
freeway<br>
pathway<br>
underway 进行中的<br>
sideways adj. adv.<br>
railway<br>
fairway 航路<br>
waterway 航路 水路<br>
walkway<br>
gateway<br>
stairway<br>
getaway  n 逃走<br>
get away<br>
roadway<br>
one-way<br>
two-way</p>
<h2 id="script-scrib-scrip-写，刻写">-script- = -scrib- = -scrip- 写，刻写</h2>
<pre><code>* 浊辅音结尾的词根一般用于动词
* 清辅音结尾的词根一般用于名词和形容词。
</code></pre>
<p>script n. 便条</p>
<blockquote>
<p>A <strong>script</strong> is a written version of a play or a movie. If you’re auditioning for a movie, you’ll get the <em>script</em> to practice a scene or two.</p>
<p><em>Script</em> comes from the Latin <em>scribere</em>, meaning “to write”, and all its meanings have to do with something written. Your handwriting is your script. The written version of what you’re supposed to say, whether for a wedding toast or a play, is a script. And if you were feeling old-fashioned you could call the grocery list you just wrote a script. It’s also a verb. You can script a play.</p>
<ol>
<li>something written by hand</li>
<li>a particular orthography or writing system</li>
<li>a written version of a play or other dramatic composition; used in preparing for a performance</li>
<li>write a script for</li>
</ol>
</blockquote>
<p>scrpting v. 写剧本<br>
写–写剧本<br>
scribe  n.  抄写员；作家<br>
-scrib- + -e 名词后缀<br>
scribal adj.<br>
-al 形容词后缀<br>
scriptorium n. 写字间<br>
script + -or + -i- + -um 名词后缀<br>
script n. 脚本<br>
scripted v.过去式和过去分词<br>
subscript adj. n 下标（的）<br>
unscripted<br>
scribble vt.&amp;vi n.<br>
scribe -le 表反复<br>
scribbled v 过去式<br>
scribbling n. 动名词后缀<br>
scribbler n<br>
-er 表人。<br>
scripture n. 手稿<br>
经文<br>
scriptural n. 圣经的<br>
scripturally<br>
scriptwriter n.<br>
rescript n. 法令； 布告<br>
re- 反复 --反复抄写–抄件–法令<br>
describe vt 描述<br>
de- 向下 写下来<br>
nondescript adj. 无明显特征的，难以形容的<br>
misdecribe<br>
descriptor n. 描述符<br>
described adj. 被看到的<br>
describer<br>
description<br>
descriptive<br>
descriptively<br>
describable<br>
indescribable<br>
indescribably<br>
redescription n. 描述<br>
= description<br>
subscription-based<br>
self-described<br>
prescribe vt. 指定，规定，开处方<br>
pre- 在前 + scribe 预先写好的–商定好的规则<br>
prescribed adj.<br>
prescribing v. 开药方<br>
prescription n. 处方<br>
prescription-drug<br>
prescriptive adj.<br>
manuscript<br>
manu- 手<br>
subscribe vt. 签署<br>
sub- 向下<br>
subscriber<br>
subscription<br>
transcribe vt. 转录；抄写<br>
transcribed v. 过去式<br>
transcriber<br>
transcrpt n 抄本；成绩单<br>
transcription<br>
transcriptional<br>
transcriptase n. [生化] 转录酶<br>
-ase 生化名词后缀<br>
inscribe v.<br>
in-向内 --刻写<br>
inscription<br>
reinscription n.<br>
re- 再次，重新<br>
circumscribe vt.  外切，外接<br>
-circum-圆<br>
circumsribed adj. 局限的<br>
circumscription n. 界限<br>
conscript n. 征召入伍者<br>
con-强调 --签署服兵役<br>
conscription<br>
'conscribe vt.<br>
ascribe vt. 归因于<br>
a??- 表强调。感觉都解释不通。<br>
ascribed adj.<br>
ascription<br>
ascriptive<br>
proscribe vt. 正式宣布某事物有危险<br>
pro-提前 -scrbe<br>
=prescrbe<br>
proscribed adj.<br>
proscription<br>
postscript n. 附言<br>
post- 后面<br>
typescript n. 打字文件<br>
superscript adj. n. 上标</p>
<h2 id="techn-o-技术，艺术">-techn(o)- 技术，艺术</h2>
<p>technic n. adj.<br>
technique n.<br>
technics n. 工艺学<br>
-ics 学术名词后缀<br>
technology<br>
-o- + -logy<br>
technological<br>
technologist<br>
technical<br>
technicality n 学术性； 专门性<br>
techicalize<br>
techicalization<br>
techician n. 技师<br>
technolatry n. 技术崇拜<br>
techn- -o- -latry 崇拜<br>
electrotechnics<br>
electr-电 + -o- + -<br>
biotechnology<br>
polytechnic adj.<br>
poly 全<br>
pyrotechnic adj.  烟火的<br>
pyr 火 词源同fire pyro-<br>
pyrotechnics n. 烟火制造术<br>
zymotechnics n. 发酵法<br>
zymo- 发酵<br>
nanotechnology n.<br>
nano 纳米<br>
technocrat n.<br>
-crat- 统治者<br>
technocratic adj.<br>
techno 高科技舞曲<br>
technicolor 彩色<br>
technologic adj. 技术的<br>
technophile n. 技术爱好者<br>
-phile- 爱好<br>
technetium n. 【化学】 ai<br>
-ium 金属<br>
technophobe n.<br>
-phobe- 恐惧<br>
technocracy n. 见上<br>
technology-orient adj. 技术导向<br>
vocational-technical adj. 职业技能的。</p>
<h1>第8节课</h1>
<h2 id="press-压-挤">press 压 挤</h2>
<p>press vt. vi. n.</p>
<blockquote>
<p>To <strong>press</strong> something is to push it, like if you <em>press</em> an elevator button or <em>press</em> your friend to tell you a secret. If you get that secret, don’t leak it to the <em>press</em>, which is another word for news media.</p>
<p><em>Press</em> is also a noun, meaning a machine that uses presssure, either to squeeze liquid out of something (like an apple cider press), or to stamp a design or text on something (like a printing press). There’s also a press of people, or a crowd of folks so close they press against each other; and “the press” , or the news media, which got the name because newspapers are printed using a press</p>
<p><strong>Primary Meaning of press</strong></p>
<ol>
<li>exert pressure or force to or upon</li>
<li>to be oppressive or burdensome</li>
<li>press and smooth with a heated iron</li>
<li>lift weights</li>
<li>exert oneself continuously, vigorously, obtrusively to gain an end or engage in a crusade for a certain cause or person; be an advocate for</li>
<li>the print media responsible  for gathering and publishing news in the form of newspapers or magazines</li>
<li>make strenuous pushing movements during birth to expel the baby</li>
<li>a tall piece of furniture that provides storage space for clothes; has a door and rails or hooks for hanging clothes</li>
</ol>
</blockquote>
<p>presser n. 压榨机； 压榨工<br>
pressed<br>
pressman n. 印刷工人，记者<br>
cold-pressed<br>
pressure n.<br>
-ure 名词后缀<br>
pressure-treated<br>
acrpressure n. 针压法<br>
-ac 尖<br>
pressurize<br>
pressurization<br>
pressure-sensitive<br>
bench-press n. 举重练习凳<br>
pressing n. adj.<br>
letterpress n. 凸版印刷<br>
pressure-cooker n.</p>
<p>impress vt. n<br>
im- 进入、使 + press 压、按–压进去的，引申为留下印象。<br>
impressed adj. 影响深刻的<br>
-ed 修饰人<br>
impressive adj. 令人影响深刻的。<br>
impression n.<br>
impressional adj.<br>
impressionism n. 印象主义<br>
post-impressionist<br>
-ist = -est 形容词或名词后缀<br>
impressionistic<br>
impressionable<br>
unimpressed<br>
impressionist n. 印象主义者<br>
impressively<br>
unimpressive<br>
misimpressive<br>
mis- 错误<br>
impressive-looking adj.<br>
looking adj. 有什么样子，外貌<br>
impressment n. 强行征用。<br>
express vt.表达 adj. 明确的，迅速的 n. 快车，快递。</p>
<blockquote>
<p>When something goes fast, it goes <strong>express</strong> – like a train that skipss many stops. You also <strong>express</strong> your feelings and thoughts.</p>
<p>When you want something sent quickly, send it by express mail. When you give your opinion, you’re expressing yourself. Writing music and poems are also examples of expressing yourself. Mathematical formulas <em>express</em> complex ideas. In genetics, a gene might be expressed by making you bald.(恶毒)</p>
<ol>
<li>
<p>give expression to</p>
</li>
<li>
<p>public transport consisting of a fast train or bus that makes only a few scheduled stops</p>
</li>
<li>
<p>obtain from a substance, as by mechanical action</p>
<blockquote>
<p>“<em>Italians <strong>express</strong> coffee rather than filter it</em>”</p>
</blockquote>
</li>
</ol>
</blockquote>
<p>expressive<br>
expression<br>
expressionism n. 表现主义<br>
expressionist<br>
self-expression<br>
self-expressive<br>
inexpressive<br>
in- 否定<br>
expresssivity n. 表达性<br>
expressively<br>
expressible<br>
expressly adv. 清楚地<br>
expressed v<br>
expressionless adj. 无表情的<br>
expressway n. 高速公路<br>
expressiveness<br>
inexpressible<br>
inexpressibly<br>
unexpressed<br>
expressionistic adj.表现主义的</p>
<p>depress v. 使沮丧<br>
de- 向下<br>
depressive adj<br>
depressing<br>
depressingly<br>
depressed adj<br>
depressor<br>
depressurize vt. 使减压<br>
de- 下，分 + pressure–分离压力-- 使减压±ize 动词后缀<br>
manic-depressive<br>
depressant n. 镇静剂 adj.<br>
-ant 名词和形容词后缀<br>
antidepressant n. adj.<br>
depressurt-era n.</p>
<p>compress vt. 压缩<br>
com- 在一起<br>
compression<br>
compressive<br>
compressor<br>
compressible<br>
incompressible<br>
compressibility n. 压缩性<br>
-ible + -ity = -ibility<br>
uncompressed<br>
decompress vt. vi. 使减压<br>
de- 分<br>
decompression n.<br>
oppress vt. 压迫，压抑<br>
op- 强调，反<br>
oppressed adj.<br>
oppression<br>
oppressive<br>
oppressiveness<br>
oppressively<br>
oppressor n. 压迫者</p>
<p>repress vt. 抑制；镇压<br>
re- 反–往回-- 往回压-- 按压</p>
<blockquote>
<p>Whether you’re <strong>repressing</strong> a feeling, an idea or even a revolution, you’re almost always going to be taking advantage of the <em>press</em> in <em>repress</em>*. To <em>repress</em> something is to “press it down” where it can’t be seen, heard or even recognized.</p>
<p>Psychologists often try to help people recover memories that they’ve <em>repressed</em> so that they can feel free of them once and for all. What makes <em>repress</em> different from <em>press</em> is that <em>repress</em> is almost always used when you’re talking about an idea, concept or something intangible. In other words, you repress, say, your emotions. You don’t repress olives to get olive oil. However, you can repress someone or some group by intimidating them – like repressing the protesters by sending out cops on horseback</p>
</blockquote>
<p>repressed adj.<br>
long-repressed<br>
repression<br>
repressive<br>
irrepressible<br>
ir- 否定</p>
<p>suppress vt. 抑制；镇压<br>
sup- 下</p>
<blockquote>
<p>To <strong>suppress</strong> something means to curb, inhibt, or even stop it. If the sound of boss moving in his chair sounds like gas, you’re going to have to learn how to <em>suppress</em>* your giggles.</p>
<p>In the strictest sense, <em>suppress</em> means to put an end to something by force, like a government that suppresses the right to free speech by shutting down the newspapers or the military suppressing an uprising by rebel forces. But we also use <em>suppress</em> in less serious terms to describe an attempt to muffle or stifle something, such as suppressing a sneeze in a quiet theater or suppressing your true emotions to not cause a teary scene.</p>
</blockquote>
<p>suppression<br>
suppressor<br>
suppressive<br>
suppressibe<br>
suppressed<br>
long-suppressed<br>
suppressant adj. n.</p>
<p>espresso n. 浓咖啡<br>
es- 强调<br>
vasopressin<br>
vaso- 激素 + -press- + -in 名词后缀<br>
immunosuppressive adj.<br>
-immun- 免疫</p>
<p>print n. vt. vi. 印刷<br>
-press- = -print-<br>
printer n. 打印机<br>
printed adj.<br>
printing n. 印刷<br>
printable adj.<br>
unprintable adj. 不宜印出的<br>
pre-printed adj. 预先印好的<br>
reprint vt.<br>
reprinting vt. 再版 n.<br>
misprint n. vt.<br>
imprint n. 印记；痕迹；特征；版本说明 vt. 加特征<br>
im- 使动 + -print- 按压 – 印记<br>
imprinted adj. 印花的<br>
imprinting n. 铭记<br>
printout n.  打印输出<br>
printhead n. 印字头<br>
printmaker n.<br>
printmaking n.<br>
fingerprint n. 指纹<br>
fingerprinting n.<br>
blueprint vt. n. 蓝图，设计图<br>
hoofprint n. 蹄印<br>
thumbprint n.<br>
floral-print n. 印花<br>
-flor- = flower<br>
flower-print n.<br>
leopard-print n. 豹纹<br>
animal-print n.<br>
screen-printed adj. 丝网印刷的<br>
large-print adj.<br>
out-of-print adj. 不再发行的<br>
reprimand n. 谴责 vt.<br>
re- 往回 + -prim- = -print- 压 + -and 名词<br>
imprimatur n. 出版许可，认可<br>
im- 使动 + -prim- 压 + ate + -ur</p>
<h1>第9节课</h1>
<h2 id="rect-正，直">rect 正，直</h2>
<p>##单音节词不拆##<br>
含有两个或两个以上的元音字母的单词都是多音节词<br>
但是，特殊情况排外</p>
<ul>
<li>连续的两个元音字母算一个，如 beat</li>
<li>结尾是e的单词，e 不算；large<br>
【前缀】<br>
con- =  com- = cor- = col- = co- 在一起，共同，强调<br>
un- = in- = im- 否定<br>
di- =de- = dis- =is- 分，分离，失去，否定，向下<br>
is- 分 + land = island<br>
mis- 错误<br>
multi- 多<br>
e- = ex- = e??- 向外，强调【问号为两个相同的辅音字母】<br>
re- 重复，再次，往回，强调<br>
sub- = sur- = sup- = sus- 下，留下<br>
in- 向内，使动<br>
en- = em- = in- 使动<br>
enrich<br>
super- 超级 超过 在上<br>
inter- = intel- = enter- 互相， 在……之间<br>
a??- 强调<br>
【后缀】<br>
-ly 形容词或副词后缀（一般地，接在名词后为形容词；接在形容词后为副词）<br>
friend + ly adj.<br>
correct + ly adv.<br>
-ion 名词后缀（极少动词后缀）<br>
-ness 名词后缀，表物，表学术，学科性等名词<br>
-ed 形容词后缀，修饰主语为人； 也表动词的过去式和过去分词<br>
-al = -el = -il = -ul 形容词或名词后缀<br>
-ive 形容词或名词后缀<br>
detective adj.侦探的 n. 侦探<br>
-ing 形容词后缀，表令……的，修饰物；动名词后缀<br>
-ar =-er =-ir =-or = -ur 名词后缀；形容词后缀（可能来自于比较级）<br>
-itude 名词后缀<br>
-able = -ible = -ile(-ble) 形容词后缀（能……的）<br>
-ary = -ery = -ory = -ury 名词或形容词后缀<br>
-ate = -ite = -ute 形容词或动词后缀<br>
-ate/-ite/-ute + -ion = -ation/ition/-ution<br>
-ess 女性名词后缀、<br>
waiter ; waitress<br>
-less 否定形容词后缀<br>
-ship 名词后缀，表抽象含义<br>
friendship 友谊<br>
-fy 动词后缀<br>
-fy 名词化 -i- + -fication = -ification 复合名词后缀<br>
-um = -im =(-em = -am) 名词后缀<br>
-ty = -(i)ty = -ety = -edy 名词后缀<br>
-ent = -ant = -and = -end 名词或形容词后缀；表名词时，一般表人。<br>
important<br>
-ance = -ence = -ancy = -ency 名词后缀，偶尔可以动词化。<br>
-id = -it 动词或名词后缀，极少时可以有形容词的含义<br>
-ize(美式单词结尾) = -ise（英）动词后缀<br>
-ous = -ious = -eous = -uous 形容词后缀<br>
-s = -es 名词后缀<br>
-ics 学术名词后缀<br>
-an = (-en) 表名词或形容词，名词表人<br>
correct v. adj.<br>
correctly<br>
correctness<br>
correction<br>
corrected<br>
correctional<br>
corrective<br>
correcting adj. n.<br>
corrector<br>
correctitude n.<br>
uncorrected<br>
correctable<br>
incorrect<br>
incorrectly</li>
</ul>
<p>direct vt. 指挥 adj. 直接的<br>
di- 分<br>
directed adj. 定向的；经指导的<br>
directness<br>
direction<br>
directive n. adj.<br>
directing<br>
directory n.<br>
directional<br>
director<br>
directorate n. 董事会<br>
directorial adj.<br>
co-director n. 主任<br>
co- 在一起<br>
directress n.<br>
-ess 女性名词后缀<br>
directly adv.<br>
indirect adj. 间接的<br>
directionless adj. 没有方向的<br>
self-directed<br>
misdirect<br>
indirection<br>
indirectly<br>
indirectorship n. 管理者的职位<br>
direct-mail<br>
undirected<br>
multidirectional adj. 多方向的</p>
<p>rectify v. 纠正<br>
rect- + -i- ±fy 动词后缀<br>
rectifier n.<br>
-fy 加新后缀时y通常变i，或者直接去掉<br>
rectification<br>
rectitude n. 正直<br>
rectilineal adj. 直线的<br>
rectangle n. 矩形<br>
rectal adj.【医学】直肠的<br>
rector n. 院长 ；校长；牧师<br>
rectory<br>
erect v. 直立<br>
e- 向外<br>
erectile adj.<br>
erection<br>
erective<br>
erector n. 树立者<br>
rectum n. 【医学】直肠<br>
-um 名词后缀<br>
resurrect vt. 使复活；复兴<br>
re- 再次 sur- 下 rect- 直 – 再次直立<br>
resurrection<br>
redirect vt. 使改方向<br>
redirection</p>
<h1>第10节课</h1>
<p>insurrection n. 暴乱<br>
in- 使动 +sur- 下 + -rect- 直–立起来–反抗</p>
<blockquote>
<p>Insurrection is an uprising against a larger force that’s in power. An <em>insurrection</em> can lead to revolution, but it is just as likely to be put down.</p>
<p>Other words for <em>insurrection</em> include rebellion, revolt and uprising, the last of which is the translation of insurrection’s Latin roots. The Bosten Tea Party is probably the most famous American act of insurrection. One who rises up in insurrection is called an insurgent by the force they are rising against. Like Paul Revere, insurgents are often called heroes by the people they are rising up to support.</p>
</blockquote>
<p>insurrectionist<br>
insurrectionary n. adj.<br>
colorectal adj. 结肠直肠的<br>
col- 强调 ±o- 连字符 + -rect- 直<br>
rectitude n. 公正；诚实<br>
bidirectional adj. 双向的。<br>
bi- 分–二 directional<br>
director-general n. 总干事<br>
unidirectional adj.<br>
-un- 整体，单一 ±i-<br>
misdirection n.<br>
misdirected vt.  过去式<br>
rectus n. 直肌<br>
-us 名词后缀<br>
writer-director<br>
goal-directed<br>
directionality n.<br>
direction + -al + -i- + -ty<br>
teacher-directed<br>
incorrectness<br>
recto n. 右页；纸张的正面<br>
-rect 正–正面<br>
non-directive adj. 不定向的<br>
state-directed adj.<br>
omnidirectional adj. 全方向的<br>
-omni- 全<br>
direct-marketing n. 直销<br>
direct-drive n. 直接激励<br>
direct-injection n. 直接注射<br>
producer-director n. 编导<br>
direct-view n. 直观<br>
direct-action<br>
endarterectomy n. 动脉内膜切除术<br>
-tom- 切。例 atom a-远离–否定+tom- 切-- 不可再切-- 不可再分割。<br>
en- 使动 + -darterec- 动脉<br>
student-directed<br>
consumer-directed<br>
direct-to-video<br>
nephrectomy n. 肾切除术<br>
-nephrec- 肾 -tom 切<br>
direct-response n.<br>
response = re- 往回 + -spons- 承诺<br>
direct-sales<br>
anorectal n. 肛门直肠的<br>
-ano- 肠道口 + -rect- 直</p>
<h2 id="flu-flux-流">-flu = -flux- 流</h2>
<p>flu n.<br>
fluent adj. 流动的<br>
流–流畅–流利</p>
<blockquote>
<p>To be <strong>fluent</strong> in something – like a language or an instrument – is to be able to use it smoothly and effortlessly.</p>
<p>It takes many years and lots of practice to become fluent in a second language. But when you’re finally fluent, you can understand it, speak it, and write it easily in it. One French class won’t make you fluent – gaining <em>fluency</em> takes years. You can also be fluent in other things that you’ve practiced and mastered, like cello or computer programming. If you’re doing something in a way that makes it look easy, you’re fluent.</p>
<ol>
<li>expressing yourself readily, clearly, effectively</li>
<li>smooth and unconstrained in movement</li>
</ol>
</blockquote>
<p>fluence n.<br>
influent adj. 流入的 n. 支流<br>
in- 向内</p>
<blockquote>
<p>flowing inward</p>
</blockquote>
<p>influencing<br>
influenza n. 流行性感冒<br>
-enza 名词后缀<br>
influence n. v.<br>
in- 向内 + -flu 流 --向内流 – 流进去 --作用，影响。</p>
<blockquote>
<p><strong>influence</strong> is the power to have an important effect on someone or something. If someone <em>influences</em> someone else, they are changing a person or thing in an indirect but important way.</p>
<p>Somethings a person who influences another doesn’t intend to have any effect, but sometimes they are using influence to benefit themselves. An example of a personal benefit or advantage would be the use of political influence. Influence is also a verb, from Latin <em>influere</em> to flow in.</p>
</blockquote>
<p>influenced adj. 受影响的<br>
-ed 形容词，又可表过去分词，即被动的<br>
influential adj.<br>
uninfluential<br>
confluent adj. 合流的<br>
con- 在一起 --流到一起<br>
confluence<br>
fluid adj. n. 流动的 液体<br>
fluidity n. 流动性<br>
fluid-filled adj.<br>
fluidly adv.<br>
fluidize vt. 使流动化，使液化<br>
fluidized adj. 液态化的<br>
superfluid n. 超流体<br>
superfluidity</p>
<p>refluent adj. 倒流的<br>
re- 往回<br>
refluence<br>
defluent adj. 往下流的<br>
circumfluent adj.<br>
-circum- = -circ- 圆<br>
effluent adj. 流出的，发出的<br>
interfluent adj. 交流的<br>
flux n. 流， 流出<br>
fluxion n.<br>
fluxional<br>
afflux n.<br>
a??- 强调</p>
<h1>第11节课</h1>
<p>reflux n. 回流<br>
re- 往回<br>
influx n. 流入<br>
flush n.奔流 拟声词</p>
<blockquote>
<p>When you empty something out with a liquid, you <strong>flush</strong> it. You might also be <em>flush</em> with cash, meaning you have a lot of it. Just don’t <em>flush</em> that cash down the toilet!</p>
<p>Your face can flush, and the sky can flush at sunset when it grows with shades of pink. You can also use <em>flush</em> as an adjective to mean “lined up” or “level”,  like when you hang a medicine cabinet in your bathroom, making sure it’s flush against the wall. Yet another meaning of a <em>flush</em> is a peak or boom – a professional poker player might describe her period of winning game after game as a flush.</p>
<ol>
<li>
<p>rinse, clean, or empty with a liquid</p>
</li>
<li>
<p>sudden brief sensation of heat (associated with menopause and some mental disorders)</p>
</li>
<li>
<p>of a surface exactly even with an adjoining one, forming the same plane</p>
<blockquote>
<p>“<em>a door <strong>flush</strong> with the wall</em>”</p>
<p>“<em>the bottom of the window is <strong>flush</strong> with the floor</em>”</p>
</blockquote>
</li>
<li>
<p>having an abundant supply of money or prefessions of value</p>
</li>
<li>
<p>a poker hand with all 5 cards in the same suit</p>
</li>
<li>
<p>squarely or solidly</p>
<blockquote>
<p>“<em>hit him <strong>flush</strong> in the face</em>”</p>
</blockquote>
</li>
</ol>
</blockquote>
<p>flash n. 闪电侠<br>
flush-mounted<br>
flushed<br>
flushing<br>
affluent adj. 流畅的 富裕的<br>
aff- 强调<br>
affluence<br>
flue n. 烟道； 暖气管<br>
flu-like adj. 类似感冒的<br>
flume n. 水道<br>
mellifluous adj. 流畅的<br>
-melt 融化<br>
fluvial adj. 河流的<br>
-flu ±vi 路<br>
influence-pedding<br>
microfluidic n. 微流体<br>
flue-cured adj. 熏制的<br>
fluoroscopy n. 【医学】荧光镜检查<br>
-scop- 镜</p>
<h2 id="st-sist-stat-stin-stem-立-站">-st- = -sist- = -stat- = -stin- = -stem- 立 站</h2>
<p>system n.<br>
-sy- =-sym- 一起 + -st- 站<br>
subsystem<br>
systemic adj. 系统的<br>
systemically<br>
systematic adj.<br>
-ate + -ic 形容词后缀<br>
systematics<br>
systematize<br>
systematization<br>
systematically<br>
operating-system<br>
operate -oper- 做<br>
system-wide<br>
ecosystem-based adj. 基于生态系统的<br>
eco- 经济 环境<br>
assist v.<br>
as- 强调 sist- 站<br>
assitant<br>
-ant 名词（表人）或形容词后缀<br>
assitance<br>
assisted adj.<br>
unassisted<br>
assisting v. 现在分词<br>
assistive adj. 辅助的<br>
assitantship n. 助教奖学金<br>
-ship  抽象名词<br>
assisted-suicide<br>
assisted-living<br>
resist v.<br>
re- 往回 + -sist- --往回站–阻止抵抗</p>
<blockquote>
<p>To <strong>resist</strong> something is to keep it at bay or to fend off its influence or advance. You might not be able to <em>resist</em> the temptation to sneak out the dance in spite of your parents’ objections.</p>
<p>The verb <em>resist</em> comes from the Latin word <em>resistere</em> , meaning “to take a stand,” or “withstand”. People who are able to put up a wall – be it mental, physical, philosophical, emotional, or otherwise - to defend themselves or their group against a threat can be said to resist. The Amish community is still able to resist the influence of technology. Many a child will resist the suggestion to use a napkin. You might resist a second helping of pie.(helping n. 食物的一份)</p>
</blockquote>
<p>resistor n. 【电】电阻器<br>
resister<br>
resistance<br>
resistant adj.抵抗的 n.抵抗者<br>
resistible adj. 可<br>
resistively adv. 抵抗地<br>
resistivity n. 【电】 电阻系数<br>
irresistible<br>
ir- 否定<br>
drought-resistant adj. 抗旱的<br>
resisting adj. 稳定的<br>
water-resistant<br>
drug-resistant<br>
corrosion-resistant<br>
disease-resistant<br>
fire-resistant<br>
heat-resistant<br>
rot-resistant<br>
weather-resistant<br>
pest-resistant adj. 抗害虫的<br>
stain-resistant<br>
herbicide-resistant<br>
herb- + -i- ±cid- 杀<br>
multidrug-resistant<br>
penicillin-resistant<br>
盘尼西林<br>
recession-resistant<br>
re-往回 + -cess- 走 --往回走–衰退<br>
abrasion-resistant<br>
ab-强调 + -ras- 磨损<br>
eraser e- 向外+ -ras- + -er 橡皮<br>
earthquake-resistant adj. 抗震的<br>
tamper-resistant<br>
consist v. 由…组成 在于 符合<br>
con - 在一起</p>
<blockquote>
<p>Almost always used with the proposition “of”, the verb <strong>consist</strong> means to be made up of , or composed of something. A heated conversation might <strong>consist of</strong> only two words: “yes” and “no”.</p>
</blockquote>
<p>consistent adj. 一致的</p>
<blockquote>
<p>If you get the same Donkey Kong score every time you play, you’re <strong>consistent</strong>. It’s <em>consistent</em> with video-game addiction, however, that you will continue to play in the hopes of beating that score.</p>
<p><em>Consistent</em> is related to the word <em>consist</em>, which refers to what something is made of – “bread dough consists of flour, water, and salt.” <em>Consistency</em> describes texture – a consistent consistency would be brownies as rock-hard in the center as they are at the edge – hopefully, next time you bake you’ll get inconsistent results.</p>
</blockquote>
<p>consistence n. 浓度 稠度<br>
consistently<br>
self-consistent adj.<br>
自我一致–首尾一致的<br>
inconsistent<br>
inconsistency<br>
inconsistently</p>
<p><strong>state</strong> n.国家 情形 vt.规定 声明 adj. 国家的 正式的<br>
stat- 站–建立–立国，周围的处境，宣讲</p>
<blockquote>
<p><strong>State</strong> can be a condition – like solid, liquid, or gas, or even sad or happy. It can also be a <strong>state</strong> as an Idaho or New York. To <strong>state</strong> is to say something.</p>
<p><em>State</em> comes from the Latin <em>status</em>, meaning “condition of a country.” Interestingly, even before the Revolutionary War, Britain called the American colonies states. The “States” still refers to America, but state can refer to any country’s civil government. The idea of <em>state</em> as a physical or emotional condition cames later. Depending on your state of mind, you can state that the state of your state is awesome. Unless it’s in a state of emergency, which is no good.</p>
<ol>
<li>the way something is with respect to its main attributes</li>
<li>a politically organizzed body of people under a single government</li>
<li>express in words</li>
</ol>
</blockquote>
<p>statistic adj. 统计的<br>
statistics n.<br>
statistician<br>
statistical<br>
statistically<br>
statewide<br>
interstate adj. 州际的<br>
statement<br>
state-of-the-art adj. 最先进的<br>
a of b 翻译为 b 的 a<br>
statesman n. 政治家<br>
politician<br>
-pol = -polit- 城邦 统治<br>
polite adj. 礼貌的<br>
police<br>
politic<br>
stateswoman<br>
apostate adj. 变节的 脱党的<br>
apo- 分–脱离</p>
<h1>第12节课</h1>
<p>prostate adj. 前列腺的 n. 前列腺<br>
pro- 向前<br>
estate n. 房地产；财产；身份<br>
财产与地位挂钩<br>
e- 发音 无义<br>
nation-state n. 单一民族国家<br>
overstate vt. 夸大；夸大的叙述<br>
stated adj. 规定的<br>
upstate adj. 北部的 n. 州的北部 adv.<br>
up- 上北下南<br>
reinstate vt. 使恢复<br>
re- 再次 + -in- 使动 + state 站立<br>
stately adj. 庄严的<br>
state + -ly 形容词后缀<br>
一般地，-ly 接在名词后表形容词，接在形容词后表副词<br>
state-owned adj.<br>
understate vt. 少说；保守地说<br>
understated<br>
understatement<br>
state-run adj. 国营的；州立的<br>
statehood n. 国家地位<br>
out-of-state n. 州外学生<br>
stateroom n. 政府公寓<br>
state-sponsored adj.<br>
-spons- = -spond- 回应，承担<br>
respond<br>
responsible<br>
responsibility<br>
in-state adv. 庄重地<br>
in- 使动<br>
city-state<br>
reinstatement<br>
overstatement<br>
church-state n. 宗教政治<br>
statehouse<br>
unstated<br>
substation n. 分局<br>
sub- 下–分<br>
state-controlled<br>
misstatement<br>
solid-state<br>
steady-state adj. 不变的<br>
-stead- 站–停驻–永久<br>
state-funded n.<br>
all-state adj. 州代表队的<br>
statecraft n. 政治才能<br>
statesmanship n. 政治才能<br>
state-by-state n. 各州；各国<br>
state-to-state n. 国与国<br>
two-state adj. 双态的<br>
stateless adj.<br>
state-mandated adj. 国家规定的<br>
non-state<br>
state-supported adj.<br>
prostatectomy n. 前列腺切除术<br>
-ctom- 切 + -y 名词后缀<br>
statesmanlike<br>
state-sanctioned adj. 国家批准的<br>
federal-state n.<br>
state-led adj. 国家领导的；国家机关为主导的<br>
led lead的过去分词<br>
superstate<br>
estate-planing n. 财产规划<br>
tri-state n. 三态<br>
state-chartered adj. 国家特许的<br>
state-imposed<br>
stater<br>
prostate-specific<br>
state-centered<br>
state-centric<br>
estate-tax<br>
state-issued<br>
state-federal<br>
state-building<br>
state-licensed<br>
state-operated<br>
state-subsidized<br>
multi-state<br>
state-certified<br>
overstated<br>
state-regulated<br>
state-financed<br>
pre-state adj. 前状态的<br>
state-appointed<br>
state-dominated<br>
oft-stated adj. 常说的<br>
oft- often的缩写<br>
red-state<br>
state-managed<br>
welfare-state<br>
state-enforced<br>
antistate<br>
state-record<br>
cross-state<br>
cross- 横跨<br>
instate vt. 任命<br>
in- 使动 + -stat- 站 – 确定 –<br>
ground-state<br>
party-state<br>
state-directed<br>
one-state<br>
stand vi.vt.n.</p>
<p>long-standing adj. 长期存在的<br>
understand<br>
under- 在……之间 + stand- 站<br>
understood adj. 被充分理解的<br>
understanding n. adj<br>
understandingly<br>
understandable<br>
misunderstand<br>
misunderstood adj.<br>
misunderstanding n. 误解<br>
bystander n. 旁观者<br>
by 路过<br>
standing adj. 长期的 直立的 n. 站立<br>
outstanding adj. 杰出的；未解决的，未偿付的<br>
standpoint n. 立场<br>
withstand vt. 抵挡；反抗 vi.<br>
with- 伴随 stand- 抵挡<br>
standoff n. 和局 僵持<br>
notwithstanding adv. 尽管<br>
standout n. 杰出的人</p>
<p>standard n. 标准<br>
standardize vt. 使标准化<br>
standardized<br>
stand-up adj.<br>
newsstand n. 报摊<br>
standardization n.<br>
standstill n. 提顿<br>
still 静止<br>
nightstand n. 床头几<br>
stand-alone<br>
standby n. 备用品<br>
free-standing<br>
substandard<br>
stand-in n. 替身<br>
grandstand n. 正面看台<br>
grandstanding<br>
upstanding adj. 良好的<br>
standards-based adj.<br>
self-understanding<br>
standard-bearer n. 旗手；领导人<br>
bearer n. 持票人<br>
standard-size<br>
industry-standard<br>
outstandingly adv.<br>
non-standard<br>
standardised vt<br>
standard + -ise 动词后缀<br>
nonstandardized adj.<br>
freestanding adj. 独立的<br>
kickstand n. 支架<br>
standard-sized<br>
double-standard n.<br>
stander n.<br>
gold-standard n. 金本位<br>
bedstand n. 试验台<br>
still-standing n.<br>
stand-down<br>
tree-stand n. 树架</p>
<h1>第13节课</h1>
<p><strong>still</strong> adv.adj.n.  静止 蒸馏</p>
<blockquote>
<p>If something is quiet and calm, it’s <strong>still</strong>. After the noise of the city, it’s peaceful to go camping in the woods where everything is <strong>still</strong>.</p>
<p>Things that are tranquil are <strong>still</strong>, like the calm surface of a lake or a sleeping baby. If you stand still, you freeze in place. Another meaning of <em>still</em> is an individual shot from a movie,  an unmoving snapshot of a single scene. When <em>still</em> is an adverb, it means even now, like when you say you still love an old song or you still remember the kidness of your kindergarten teacher.</p>
<ol>
<li>not in physical motion</li>
<li>used of pictures; of a single or static photograph not presented so as to create the illusion of motion; of representing  objects not capable of motion</li>
<li>marked by absence of sound</li>
<li>not sparkling</li>
<li>an apparatus used for the distillation of liquids; consists of a vessel in which a substance is vaporized by heat and a condenser where the vapor is condensed</li>
</ol>
</blockquote>
<p>stillness n. 静止；沉静<br>
stillborn<br>
instill vt. 徐徐滴入<br>
in- 向内 + still 蒸馏 --滴<br>
instillation<br>
distill vt. 提取<br>
di- 分<br>
distiller n. 蒸馏器 蒸馏酒者<br>
-er 表物或人<br>
distilled adj.<br>
distillation<br>
distillery n. 酿酒厂 蒸馏室<br>
-ery 名词后缀，此处表地点<br>
stock-still adj. adv. 静止的 静止地<br>
stock 库存 股票<br>
still-life n. 静物；静物画<br>
still-warm adj. 余温的<br>
still-living adj.<br>
still-hot adj.<br>
still-young</p>
<p>stay n. 停留 站立<br>
stayer n.<br>
staying n.<br>
overstay<br>
stage n. 阶段 舞台<br>
staging n.<br>
stagy n. 做作的，不自然的<br>
stage 戏剧–表演–做作<br>
stagey adj.<br>
= stagy<br>
stagflation n. [经济] 滞涨<br>
onstage  adj.<br>
backstage adv.<br>
offstage n. adj. adv.<br>
upstage vt. 抢镜头<br>
staged adj. 分期的<br>
stagecoach n. 公共马车<br>
coach n. 教练（马车夫）<br>
stagehand n. 舞台工作人员<br>
hand --人手<br>
soundstage<br>
multistage adj. 多阶段的<br>
restage v.<br>
stagecraft n. 编剧才能<br>
craft n. 工艺 手艺<br>
downstage adj. adv. 台前的<br>
down 就等于 downtown 市中心<br>
two-stage<br>
early-stage<br>
stage-managed vt. vi<br>
-ed 过去式与过去分词<br>
first-stage adj.<br>
stage-like n. 阶段</p>
<p>rest vt. n. 休息<br>
re- 强调 往回 + -st- 站 --停下来<br>
unrest n. 不安 动荡<br>
restless adj. 不安的<br>
restlessly adv.<br>
restful adj. 宁静的<br>
resting adj. 静止的；休眠的<br>
restive adj. 倔强的<br>
rest 站–宁死不屈–倔强 + -ive 形容词后缀<br>
rested adj. 休息得好的<br>
restitution n. 恢复 赔偿<br>
rest 休息–恢复原样–赔付 + -it- + -ution<br>
restlessness n.<br>
restroom n.<br>
rest 休息 + room 用于休息 方便的地方<br>
restaurant n.<br>
rest + -aur- + -ant 名词后缀<br>
restaurateur<br>
-ur 名词后缀表人<br>
underestimated vt. n.<br>
under- 下–未达到 + -estim- 计算 + -ate 动词后缀</p>
<p>arrset vt. 逮捕 吸引<br>
ar- 强调 re- 强调 + -st 站 – 使停止<br>
arrested adj.<br>
arresting adj. 醒目的，引人注意的</p>
<p>store n. 商店 储备</p>
<blockquote>
<p>As the sentence “This <strong>store</strong> <strong>stores</strong> a large <strong>store</strong> of rubber ducks” will tell you, <em>store</em> is a word with a lot of definitions. Among these are “a place that sells items,” “the act of keeping things for future use,” and “a supply of something.”</p>
<p>As a noun, <em>store</em> often refers to a place where things are sold, such as an electronics store. This meaning of the world likely sprang up from the orginal meaning, “a supply of something kept for future use.” As a verb, <em>store</em> refers to the act of putting things away for later. Chipmunks store nuts in their cheeks, people store their winter clothes when springtime arrives, and techies store information on backup drives.</p>
</blockquote>
<p>stored adj. 储存的<br>
storeroom<br>
storefont n. 店面<br>
store-bought adj. 店里买的<br>
storage n. 存储<br>
self-storage n.<br>
cold-storage n.<br>
storable adj.<br>
bookstore<br>
drugstore<br>
superstore<br>
restore vt vi 修复<br>
restoration<br>
restored adj. 精力恢复的<br>
restoring adj. 恢复的<br>
restorative n.[药] 恢复药 adj.<br>
restorer<br>
restorationist n.<br>
transistor  n. 晶体管</p>
<p>test n. 试验 检验</p>
<blockquote>
<p>If your boss tells you not to <strong>test</strong> her patience, she means doesn’t push her today, because she might just snap.</p>
<p>Surely you’re familiar with vocabulary tests? In this case, someone is giving you difficult questions to see how much you know. <em>Test</em> more generally means “trial”. If you test a soap on your skin, you use it on one small patch, to see if you’ll have an allergic reaction. A drug test looks for the presence of drugs in your system. A difficult time in life is sometimes called  “a test”, because it’s testing your strength to perserve.</p>
<p><strong>Primary Meanings of test</strong></p>
<ol>
<li>any standardized procedure for measuring sensitivity or memory or intelligence or aptitude or personality etc</li>
<li>a hard outer covering as of some amoebas and sea urchins</li>
</ol>
<p><strong>Full Definitions of test</strong></p>
<ol>
<li>
<p>any standardized procedure for measuring senstivity or memory or intelligence or  aptitude or personality etc</p>
<blockquote>
<p>“<em>the <strong>test</strong> was standardized on a large sample of students</em>”</p>
</blockquote>
</li>
<li>
<p>a set of questions or exercises evaluating skill or knowledge</p>
<blockquote>
<p>“<em>when the <strong>test</strong> was stolen the professor had to make a new set of questions</em>”</p>
</blockquote>
</li>
<li>
<p>the act of undergoing testing</p>
<blockquote>
<p>“<em>he survived the great <strong>test</strong> of battle</em>”</p>
</blockquote>
</li>
<li>
<p>the act of testing something</p>
</li>
<li>
<p>typing something to find out about it</p>
</li>
<li>
<p>examine someone’s knowledge of something</p>
</li>
<li>
<p>put to the test, as for its quality, or give experiment used to</p>
</li>
</ol>
</blockquote>
<p>testing n. 测试 adj. 试验的；棘手的<br>
testimony n. [法] 证词，证言；证据<br>
test + -i- + -mon- 警告 --证据，证言 + -y 名词后缀<br>
testify vt. vi<br>
tester n. 试验员； 检测器<br>
testament n. [法] 遗嘱 圣约<br>
subtest n.<br>
testimonial n. adj.<br>
testicle n. 睾丸<br>
test + -icle 名词后缀<br>
t-test<br>
untested<br>
test-retest adj.【心理学】两次测试的<br>
tested<br>
testicular adj. 睾丸的<br>
testable<br>
time-tested adj. 久经测试的<br>
test-taking n. 应试<br>
test-taker n.<br>
means-tested adj. 经过经济情况调查的<br>
means n. 手段；方法；财产<br>
testis n. 睾丸<br>
testicle的缩写 s 表复数<br>
test-score n.<br>
pre-tested adj.<br>
field-testing n.<br>
testbed n. 试验台<br>
test-fired vt. 试射<br>
protest vt. 抗议；断言<br>
pro - 往前 + test --站 – 向前站–抵抗，抗议<br>
protestor n. 抗议者<br>
protestation n.<br>
protester n.<br>
protesting n.<br>
protestant adj. 抗议的；新教的 n.<br>
-ant 名词或形容词后缀<br>
contest vt vi n. 竞争<br>
contestation<br>
no-contest<br>
contestant n.<br>
contested adj. 必争的<br>
uncontested  adj. 无争议的<br>
contesting n.<br>
contestable adj.<br>
incontestable<br>
detest vt. 厌恶<br>
de- 向下 + -test 见证 召唤上帝来见证仇恨<br>
detested<br>
detestable<br>
detestation<br>
attest vt. 证明；证实 vi<br>
at- 强调 + test<br>
attestation<br>
pretest n. 预备考试 vt.<br>
pre- 在前<br>
pre-testing n. 预先测试<br>
retest n. 再测试<br>
retesting n.<br>
testily adv. 暴躁地<br>
test 测试–触及–触犯–易怒<br>
untestable<br>
testamentary adj. 遗嘱地</p>
<h1>第14节课</h1>
<p>exist v.<br>
ex- 向外 ±sist – 站出来 – 出现 – 存在。<br>
当前缀词尾是x时，x包含s的发音，通常会顶替词根的首字母S。</p>
<blockquote>
<p>The verb <strong>exist</strong> means to live, to have reality. Dodes no longer <em>exist</em> because they were hunted to exitinction</p>
<p>It’s not only “live” thing that exist. The government exists, as does your fear of heights. Anything that can be acknowledged in the present, exists. Another meaning for the verb <em>exist</em> is to support oneself or survive. If someone doesn’t have a job, they may have to <strong>exist</strong> on unemployment benefits until they find one.</p>
<ol>
<li>
<p>have an existence, be extant</p>
</li>
<li>
<p>support oneself</p>
<blockquote>
<p>“<em>he could barely <strong>exist</strong> on such a low wage</em>”</p>
</blockquote>
</li>
</ol>
</blockquote>
<p>existent adj.<br>
nonexistent adj.<br>
existential adj. 存在主义的<br>
existentialist n.<br>
existence n. 存在，存在物<br>
there are no accidents. 存在即合理<br>
nonexistence<br>
existed<br>
existing<br>
coexist vi. 共存<br>
coexistent adj.<br>
coexistence<br>
coexisting adj.<br>
preexist vi vt. 先于…存在<br>
preexistent<br>
preexistence<br>
pre-existing adj. 先已存在的</p>
<p>steel n. 钢铁 vt. 钢化的 adj. 钢制的；坚强的<br>
steely adj. 钢铁般的；钢制的<br>
steeliness n. 钢制；冷酷，顽固<br>
±i-±ness<br>
steelhead n. 虹鳟<br>
steelworker<br>
steelmaker<br>
steelwork n.<br>
steel-gray adj.<br>
steel-toed<br>
steel-and-glass n.</p>
<p>station n. 根据地 基地；车站；地位 身份 vt. 驻扎 安置<br>
-stat- --固定地点–站点，</p>
<blockquote>
<p>A <strong>station</strong> is a regular stopping place, like a bus <em>station</em>, a train <em>station</em>, or even a radio <em>station</em>.</p>
<p>To understand all the jobs the word <em>station</em> has, check out its past – <em>station</em> comes from the Latin <em>stationem</em> for “a job or position”, via the word <em>stare</em> which means ”to stand&quot;.  A station can be where trains “stand”, or a police station where police do their job. Your station in life is your social place. It’s also a verb – like when the military stations troops to protect a border.</p>
<ol>
<li>
<p>a facility equipped with special equipment and personnel for a particular purpose</p>
<blockquote>
<p>“_he started looking for a gas <strong>station</strong>”</p>
<p>“<em>the train pulled into the <strong>station</strong></em>”</p>
</blockquote>
</li>
<li>
<p>the position where someone(as a guard or sentry) stands or is assigned to stand</p>
<blockquote>
<p>“_a sentry <strong>station</strong>”</p>
</blockquote>
</li>
<li>
<p>proper or designated social situation</p>
<blockquote>
<p>“<em>the responsibilities of a man in his <strong>station</strong></em>”</p>
<p>“<em>married above her <strong>station</strong></em>”</p>
</blockquote>
</li>
<li>
<p>the frequency assigned to a broadcasting station</p>
</li>
<li>
<p>(nautical) the location to which a ship or fleet is assigned for duty</p>
</li>
<li>
<p>assign to a station</p>
</li>
</ol>
</blockquote>
<p>stationary adj. 固定的 n. 驻军<br>
-ary 形容词或名词后缀<br>
stationery n. 文具 信纸<br>
-ery 名词后缀<br>
配置–用具<br>
stationer n. 文具店；文具商<br>
stationing n. 驻军<br>
molestation n. 干扰 妨害<br>
-mole- 坏–反<br>
child-molestation<br>
superstation n. 特大型发电站<br>
gas-station<br>
geostationary adj. 与地球同步的<br>
-geo- 大地–地球<br>
stationmaster n.火车站站长<br>
space-station<br>
stationhouse n. 消防队；派出所</p>
<p>distant adj. 遥远的；冷漠的<br>
di- 分+ -st 站 --分开站–产生距离–遥远 ±ant 形容词后缀<br>
distantly adv.<br>
distance n. 距离 远方 疏远<br>
distancing n. 距离<br>
distal adj. [解剖] 末梢的，末端的<br>
di-分 ±st- 站 --分离出去–位于末端<br>
distally<br>
distance-learning n. 远端教育<br>
distance-water adj. 远洋的<br>
far-distant adj.</p>
<p>stance n. 姿态，位置；立场<br>
-st- + -ance<br>
stanza n. 演出期；局；场<br>
st- 站–位置，节点 ±anza 名词后缀<br>
stanchion n. 支柱 vt.<br>
circumstance n. 环境<br>
-circum-圆<br>
circumstantial adj.<br>
circumstantially adv.<br>
instant adj. 立即的；紧急的<br>
in- 否定 + -st --不停–立刻 + -ant 形容词后缀</p>
<blockquote>
<p>An insistant is a very short time. In combinations like <em>instant</em> coffee and <em>instant</em> replay it means available right away without a wait.</p>
<p><em>Instant</em> and moment mean the same thing if you are talking about a particular time in the past like you remember the instant or moment you realize that you had won the lottery. However, the two words are very different when talking about time in the future . “I will be there in an instant” means you’re coming as quickly as possible, whereas if you say “I’ll be there in a moment”, someone is going to have to wait a bit for you.</p>
<ol>
<li>
<p>a very short time(as the time it takes the eye to blink or the heart to beat)</p>
</li>
<li>
<p>a particular point in time</p>
</li>
<li>
<p>occuring with no delay</p>
<blockquote>
<p>“<em>instant</em> gratification”</p>
</blockquote>
</li>
<li>
<p>demanding attention</p>
<blockquote>
<p>an **instant&quot; need&quot;</p>
</blockquote>
</li>
<li>
<p>in or of the present month</p>
</li>
</ol>
</blockquote>
<p>instantly adv.<br>
instancy n. 迫切<br>
instant + -ancy<br>
instance n. 实例；情况；建议 vt.举……为例<br>
in- 使动 + st --站立–做一个示范</p>
<blockquote>
<p>An <strong>instance</strong> is a specific example or case of something. One <em>instance</em> of being chased by a growling  dog can make s person spend his whole life being afraid of animals.</p>
<p>It’s common to find <em>instance</em> used in the expression “for <em>instance</em>”. Bright colors – for instance, pink, green, and blue – can cheer you up when you’re feeling sad. <em>instance</em> can also mean “occurrence”. Several <em>instances</em> of cheating might be reported after a math  test, for example. In the sixteenth century, the Medieval Latin word <em>instantia</em> meant “example to the contrary,” leading to an early definition of <em>instance</em> as “single objection.”</p>
<ol>
<li>an item of information that is  typical of a class or group</li>
<li>an occurence of something</li>
<li>clarify by giving an  example of</li>
</ol>
</blockquote>
<p>instantaneous adj. 瞬间的；即时的<br>
instant + -an + -e + -ous<br>
instantaneously<br>
instantiate vt. 举例说明<br>
instant-read<br>
substantiate vt. 证实；使实体化<br>
sub-下 + -st- 站立 – 示范  --举例<br>
substantiation n.<br>
substantiated adj.<br>
substantial adj. 大量的，实质的；内容充实的<br>
substantiality n. 实体；实质化；内容<br>
insubstantiated adj.未经证实的<br>
substance n. 物资；实质；资产；主旨<br>
站在下面–基础–实体，物质</p>
<blockquote>
<p>Any material that possesses physical properties is called a <strong>substance</strong>. The word also refers to the gist or main idea of something. If you remember the main point of a lesson, you’ve got the substance.</p>
<p>The meaning of the noun <strong>substance</strong> has evolved over time, yet it has always been related to something sound and solid – from the Latin root <em>substare</em> , which means “to stand firm”, to the Middle English definition as an “essential nature”. Nowadays, we use the word to define someone who possesses honesty and intelligence, or when we examine a message to find its essence. To be thought of as a “person of <em>substance</em>” is a good thing, but to be thought of a “<em>substance</em> abuser”(药物滥用者) is not so good.</p>
<ol>
<li>
<p>the real physical matter of which a person or thing consists</p>
<blockquote>
<p>“DNA is the <strong>substance</strong> of our genes”</p>
</blockquote>
</li>
<li>
<p>material of a particular kind or consistitution</p>
<blockquote>
<p>“the immune response recognizes invading <strong>substance</strong>”</p>
</blockquote>
</li>
<li>
<p>a particular kind or species of matter with uniform properties</p>
<blockquote>
<p>“shigella is one of the most toxic <strong>substances</strong> known to man”</p>
</blockquote>
</li>
<li>
<p>the choicest or most essential or most vital part of some idea or example</p>
</li>
<li>
<p>what a communication that is about something is about</p>
</li>
<li>
<p>the idea that is intended</p>
</li>
<li>
<p>considerable capital (wealth or income)</p>
</li>
</ol>
</blockquote>
<p>substance-use n.<br>
substantial adj. 大量的；实质的；内容充实的<br>
substantially adv.<br>
substantive adj.<br>
substantively adv. 实质上<br>
constant adj. 不变的；恒定的<br>
con- 强调 --强调站–不变</p>
<blockquote>
<p>Think of something or someone that does not change as <strong>constant</strong> . A classmate’s <em>constant</em> drumming on the table with his fingers could be a <em>constant</em> source of annoyance.</p>
<p><em>Constant</em> derives from Latin verb meaning “to stand with,” so something constant is continually standing with you and not wavering. You may be thankful for the <strong>constant</strong> companionship of your dog but not necessarily for your teacher’s constant homework assignmens. In math and science, a constant is a numver that is fixed and known, unlike a variable which changes with the context. That idea crosses over to real life. If a friend is a constant in your life. that means they have always been with you and there for you.</p>
<ol>
<li>
<p>uninterrupted in time and indefinitely long continuing</p>
<blockquote>
<p>“<em>in <strong>constant</strong> pain</em>”</p>
</blockquote>
</li>
<li>
<p>unvarying in nature</p>
<blockquote>
<p>“_maintained a <strong>constant</strong> temperature”</p>
</blockquote>
</li>
<li>
<p>steadfast in purpose or devotion or affection</p>
<blockquote>
<p>“<em>a man <strong>constant</strong> in adherence to his ideals</em>”</p>
<p>“<em>a <strong>constant</strong> lover</em>”</p>
<p>“<em><strong>constant</strong> as the northern star</em>”</p>
</blockquote>
</li>
<li>
<p>a quantity that does not vary</p>
</li>
<li>
<p>a number representing a quantity assumed to have a fixed value in a specified mathematical context</p>
</li>
</ol>
</blockquote>
<p>constantly adv. 实质上<br>
constancy n. 坚定不移；恒久不变<br>
-ancy 名词后缀<br>
-ant 形容词 – -ancy 名词后缀<br>
-ent 形容词 – -ency<br>
near-constant adj. 几乎不变的<br>
inconstant adj. 多变的<br>
inconstancy<br>
constable n. 治安官<br>
con- 强调 + st 站 --稳定 + -able --能保持一方稳定<br>
constabulary n. 警察 adj.<br>
-able + -ary = -abel + -ary = -abul + -ary = -abulary 名词或形容词后缀<br>
-ible + -ity = -ivel + -ity = -ibil + -ity = -ibility 名词后缀<br>
estancia n. 大牧场 大庄园<br>
e-向外 +—stance 站 – 场所–牧场 + -i- + -a 名词后缀<br>
happenstance n. 意外时间<br>
stance  事件</p>
<p>status n. 地位，身份；雕像；状态<br>
-stat- 站 + -us 名词后缀</p>
<pre><code>&gt; If someone wants to know the **status** of something, they want to know what condition it's in, where it is , or how much progress it's made. You've probaly checked the **status** of your flight to see if it's on time or delayed.
&gt;
&gt; Status doesn't only apply to the flights,projects, and traffic jams — it also can be used to refer to a person's social standing or rank. In fact, status was first used in reference to someone's height, and later, their legal standing. Someone with VIP status gets to fly first class and propably has a bunch of photographers following them. 
&gt;
&gt; 1. a state at a particular time
&gt;
&gt; &gt; &quot;the current status of  the arms negotiations&quot;
&gt;
&gt; 2. the relative position or standing of things or especially persons in society 
&gt;
&gt; &gt; &quot;he had the status of a minor &quot;
&gt;
&gt; &gt; &quot;the novel attained the status of a classic&quot;
</code></pre>
<p>statue n. 雕像 vt.<br>
stat- 站立–立像 + -u- + -e 名词或动词后缀<br>
stature n. 身高，身材，高度<br>
-stat-  + -ure<br>
statute n. 法律<br>
stat- + -ute 名词后缀<br>
statutory adj. 法定的<br>
statute 站立–立法–法定 + -ute- + -ory 形容词后缀<br>
statuette n. 小雕像<br>
statue + -ette = -et 名词后缀，小<br>
statuesque adj. 雕像般的<br>
-sque 形容词后缀，像……的<br>
statutorily adv. 根据法律<br>
serostatus n. 感染状况<br>
-sero- 生病，入侵–感染<br>
high-status adj.</p>
<p>insist v. 坚持<br>
in- 进入，使 + -sist- 站 – 使站立–坚持立场</p>
<pre><code>&gt; To **insist** on something is to demand or swear to it. You can **insist** that you didn't eat the last piece of cake, and then **insist** that your brother show your mom the bits of frosting on  his fingers.
&gt;
&gt; The verb insist comes from the Latin *insistere*, meaning &quot;persist&quot;, &quot;dwell upon&quot;, or &quot;stand on&quot;. To insist on something , like a room with view, is to say that you must have it. To insist that you never met that man before in your life -- even though there's a picture of the two of you to  together -- is to claim that you're telling the truth. To insist on tapping your foot on the chair leg is annoying 
&gt;
&gt; 1. be emphatic or resolute and refuse to budge 
&gt;
&gt; &gt; &quot;I must insist&quot;
&gt;
&gt; 2. assert to be true 
&gt; 3. beg persistently and urgently 
</code></pre>
<p>insistent adj.<br>
insistently<br>
insistency n.</p>
<p>persist v. 坚持<br>
per- 完全<br>
persistent adj.<br>
persistently<br>
persistence n.</p>
<h1>第15节课</h1>
<p>contrast vi. 对比，对照<br>
contra- 相反 + -st<br>
high-contrast<br>
contrasty adj.<br>
-y 形容词后缀<br>
contrasting adj.<br>
contrasted adj.<br>
contrastive adj. 对比的<br>
cost<br>
co- 强调 + -st 站 --站出来–承担</p>
<blockquote>
<p>The <strong>cost</strong> of something is how much money you need to spend on it. The high <strong>cost</strong> of a fancy coffee drink might surprise you.</p>
<p>A new car costs thousands of dollars, while in some places penny candy still costs a penny per piece. <strong>Cost</strong> also means “cause a loss,” as when a bad fumble costs your favorite football team the game, or your brother 's cheating on a test <strong>costs</strong> him the respect of his favorite teacher. The Old French <strong>cost</strong> meant “outlay, expenditure,hardship, or trouble” from the Latin root <em>constare</em>, “to stand at or  to cost.”</p>
<ol>
<li>be priced at</li>
<li>value measured by what must be given or done or undergone to obtain something</li>
</ol>
</blockquote>
<p>costless<br>
costume n. 服装；戏装<br>
cosplay<br>
costly adj.<br>
low-cost<br>
lower-cost<br>
cost-plus adj.</p>
<p>staff n. 职员 参谋 ；棒；支撑</p>
<blockquote>
<p><strong>Staff</strong> means everyone who works at a particular place. You might suspect that the town library’s not a vey fun place to work if its <em>staff</em> is always  incredibly cranky every time you visit.</p>
<p><em><strong>Staff</strong></em>  refers to all of the employees at a business, or especially a school, where the teachers a a group are called “the <em>staff</em>”. A completely different meaning of <em>staff</em> is a long wooden stick or rod,  particularly one that has a specific purpose – like a walking stick or a weapon. This is the original meaning of a <em>staff</em>, from the Old English stef(无法打出来). It wasn’t until the nineteenth century that the word <em>staff</em>  was used to mean “group of employees.”</p>
<p><strong>Primary Meaning of staff</strong></p>
<ol>
<li>a strong rod or stick with a specialized utilitarian purpose</li>
<li>personnel who assist their superior in carrying out an assigned task</li>
<li>building material consistiong of plaster and hair; used to cover external surfaces of temporary structure (as at an exposition) or for decoration</li>
</ol>
<p>Full Definitions of staff</p>
<ol>
<li>
<p>a strong rod or stick with a specialized utilitarian purpose</p>
<blockquote>
<p>“<em>he walked with the help of a wooden <strong>staff</strong></em>”</p>
</blockquote>
</li>
<li>
<p>a rod carried as a symbol</p>
</li>
<li>
<p>(music) the system of five horiontal lines on which the musical notes are written</p>
</li>
<li>
<p>personel who assist their superior in carrying out an assigned task</p>
<blockquote>
<p>“<em>the hospital has an excellent nursing <strong>staff</strong></em>”</p>
<p>“<em>the general relied on his <strong>staff</strong> to make routine decisions</em>”</p>
</blockquote>
</li>
<li>
<p>the body of teachers and administrators at a school</p>
<blockquote>
<p>“<em>the dean addressed the letter to the entire <strong>staff</strong> of the university</em>”</p>
</blockquote>
</li>
<li>
<p>serve on the staff of</p>
<blockquote>
<p>“_The two men <strong>staff</strong> the reception desk”</p>
</blockquote>
</li>
<li>
<p>provide with staff</p>
<blockquote>
<p>“<em>This position is not always **staffed</em>”</p>
</blockquote>
</li>
<li>
<p>building material consistiong of plaster and hair; used to cover external surfaces of temporary structure (as at an exposition) or for decoration</p>
</li>
</ol>
</blockquote>
<p>staffer n.<br>
staffing n. 安置职工<br>
understaffed adj.<br>
well-staffed adj.</p>
<p>stuff n. 东西；材料；填充物<br>
和-st-词根没关系<br>
stuffing n.<br>
overstuff vt.<br>
overstuffed adj.<br>
unstuffed adj.</p>
<p>stable adj. 稳定的；牢固的 n. 马厩<br>
-st- + -able 形容词后缀，表能……的<br>
unstable<br>
stably adv.<br>
stability n. 稳定性<br>
instability<br>
stabilize vt. 使稳定<br>
-ize 动词后缀<br>
stabilizer n. 稳定剂<br>
stabilizing n.<br>
stabilized adj<br>
stabilization n.<br>
stablemate n. 同一马主的马<br>
stable + mate n. 配对物<br>
stableman<br>
stableboy<br>
destabilize vt. 使动摇<br>
de- 分–否定<br>
destabilizing n.<br>
destabilized adj.<br>
destabilization n.<br>
rent-stabilized adj.<br>
metastable adj. [物；化学] 亚稳的<br>
meta- 在……后，改变，位于……上，超越<br>
establish vt. 建立<br>
e- 向外 + stable 能站<br>
establishment<br>
established adj. 已建立的<br>
disestablish vt. 废除<br>
disestablishment<br>
re-establish vt.<br>
reestablishment<br>
well-established adj.<br>
long-established<br>
anti-establishment n. 反建制 adj.<br>
词频越高，后缀使用可能不规范</p>
<p>institute vt. 开始；创立 n. 学会，学院<br>
in- 进入，使 + -stit- 站立 + -ute 动词后缀，后引申为名词后缀</p>
<blockquote>
<p>An <strong>institute</strong> is an organization or association designed to study or promote something. If you’re interested in politics, you might want to do an internship at one of Washington D.C.'s many political research <strong>institutes</strong>.</p>
<p>While you may have heard of an institute, whether it’s the National Institute for Art Advancement or the National Cancer Institute, you may not know <strong>institute</strong> in its verb form. To institute something means to establish or advance it. You might institute the hiring of Spanish-speakers at your company, or, if workers complain about being overworked, you might institute a new policy on taking breaks.</p>
<ol>
<li>set up or lay the groudwork for</li>
<li>advance or set forth in court</li>
<li>an association organized to promote art or science or education</li>
</ol>
</blockquote>
<p>institution n. 制度，建立，公共机构，习俗<br>
institutional adj.<br>
instistutionalize vt. 使制度化<br>
instistutionlism n.<br>
reinstitution n.<br>
anti-institutional adj.<br>
obstacle n. 障碍；干扰<br>
ob- 相对的，对着的 + -st- 站<br>
obstetric adj. 产科的<br>
obstetrics n. 产科学<br>
-ics 学科<br>
obstetrician n.<br>
obstinate adj. 顽固的<br>
obstinacy n.<br>
constitute vt. 组成，构成，建立<br>
con- 共同<br>
constitution n. 宪法，体制 章程<br>
constitutional adj. 本质的，体质上的，宪法的<br>
constitutionality n. 立宪<br>
constitutionally adv.<br>
constitutionalist n. 立宪主义者<br>
constitutionalism n. 立宪主义<br>
constituent n. 成分 选民 委托人 adj. 构成的 选举的<br>
-ent 形容词或名词后缀<br>
constituency n. 选民<br>
constitutive adj. 基本的 本质的<br>
unconstitutional adj. 违宪的<br>
unconstitutionality n.<br>
unconstitutionally adv. 违宪地；无意识地<br>
extra-constitutional adj. 宪法以外地<br>
anti-constitutional<br>
self-constitution n. 自我构建<br>
reconstitute vt.<br>
reconstituted adj.<br>
reconstitution n. 再生</p>
<p>consternation n. 惊愕<br>
con- 强调 + -stern- 固定 --呆住<br>
constipation n. [临床] 便秘<br>
con- 强调 + -stip- 僵硬<br>
stall n. 货摊；畜栏；托词 vi. vt. 拖延<br>
放置–货摊   停止–畜栏 停止–托词，拖延</p>
<blockquote>
<p><strong>Stall</strong> means to stop or delay. If your car <strong>stalls</strong>, it comes to a stop. When you want a horse to stop , you put him in a <strong>stall</strong>, or small enclosure inside a barn.</p>
<p>The word <strong>stall</strong> implies stopping something that will start again – a horse will leave the stall eventually and start moving, a stalled car can be restarted. Remember that when you’re thinking about <strong>stall</strong> in the sense of postpone or delay. You can stall your professor from giving an exam by talking about last night’s big game. Your little sister can stall going to bed by asking for one more story. If you want to delay an approaching army, you might steal their boots – they’ll still come but the “stall tactic” will buy you time.</p>
<p><strong>Primary Meanings of stall</strong></p>
<ol>
<li>small area set off by walls for special use</li>
<li>a tactic used to mislead or delay</li>
<li>come to a stop</li>
</ol>
<p>full Definitions of stall</p>
<ol>
<li>
<p>small area set off by walls for special use</p>
</li>
<li>
<p>a compartment in a stable where a single animal is confined and fed</p>
</li>
<li>
<p>a booth where articles are displayed for sale</p>
</li>
<li>
<p>seating in the forward part of the main level of a theater</p>
</li>
<li>
<p>small individual study area in a library</p>
</li>
<li>
<p>put into, or keep in, a stall</p>
<blockquote>
<p>“<em><strong>stall</strong> the horse</em>&quot;</p>
</blockquote>
</li>
<li>
<p>a tactic used to mislead or delay</p>
</li>
<li>
<p>postpone doing what one should be doing</p>
</li>
<li>
<p>deliberately delay an event or action</p>
<blockquote>
<p>“<em>she doesn’t want to write the report, so she is <strong>stalling</strong></em>”</p>
</blockquote>
</li>
<li>
<p>come to a stop</p>
<blockquote>
<p>“<em>The car <strong>stalled</strong> in the driveway</em>”</p>
</blockquote>
</li>
<li>
<p>cause an engine to stop</p>
<blockquote>
<p>“<em>The inexperienced driver kept <strong>stalling</strong> the car</em>”</p>
</blockquote>
</li>
<li>
<p>cause an airplain to go into a stall</p>
</li>
<li>
<p>experience a stall in flight, of airplains</p>
</li>
<li>
<p>a mulfunction in the flight of an aircraft in which there is a sudden loss of lift that results in a downward plunge</p>
</li>
</ol>
<p>mulfunction n. 失灵 mul- 坏</p>
<pre><code>&gt; &quot;_the plane went into a **stall** and I couldn't control it_&quot;
</code></pre>
</blockquote>
<p>stalled adj. 停滞的<br>
stallion n. 种马；成年公马<br>
long-stalled adj.</p>
<p>install vt. 安装 任命<br>
in- 使动 + -stall- 站<br>
installation n.<br>
installment n. 安装；就职；分期付款<br>
installer n.<br>
-er 表人或物<br>
installed adj.<br>
reinstall vt. 重新设置<br>
bookstall n. 书报摊<br>
uninstalled adj.</p>
<h1>第16节课</h1>
<p>substitute n. 代用品；代替者 vi. vt. 替代<br>
sub- 在下 + -stit- + -ute=-ate 动词后缀，偶尔表名词。站在下面的，随时准备站上去的，引申为替代<br>
substitution n.<br>
substituted adj. 取代的<br>
substitutive adj.<br>
substitutable adj. 可替换的<br>
substitutability<br>
substitutionary adj. 取代的<br>
import-substitution n. 进口替代<br>
import = im- 向内 + -port- 拿 – 拿进来 --进口<br>
substituting n. 取代<br>
import-substituting adj. 国产化<br>
替代进口片-- 国产化<br>
prostitute vt.使沦为妓女 adj. n. 妓女<br>
prostitution n. 卖淫；滥用；出卖灵魂<br>
pro- 向前 – 向前站 – 站街<br>
destine vt. 注定<br>
<strong>destiny</strong> n.</p>
<blockquote>
<p>Destiny is what’s meant to be, what’s written in the stars, your inescapable fate. You might think it’s your <em>destiny</em> to own a dog, but your sad goldfish survival rate should tell you that happy pets probably aren’t in your future.</p>
</blockquote>
<p>destined adj.<br>
destitute adj. 穷困的；无的；缺乏的 n. 赤贫者 vt. 使贫困<br>
-ute 形容词或动词后缀<br>
de- 否定 + -stit- 站 --不能站立-- 无立锥之地</p>
<p><strong>stead</strong> n. 代替 vt. 对……有利</p>
<blockquote>
<p>Someone’s <strong>stead</strong> is their position, or occupation. The eager understudy to starring role leapt at the chance to serve in the lead actor’s <em>stead</em> when he mysteriously got food poisoning.</p>
<p>Stead comes from the Germanic root for “place, town,” but we usually use it for a person’s place, and most frequently when someone is serving a a substitute. If you serve in someone’s stead, you’re doing their job for them while they’re not there. You probably intuitively know this word from the more common <em>instead</em> , which is just a shortening for “in the stead of.”</p>
</blockquote>
<p>steady adj. 稳定的 vi. vt. adv. n.<br>
steadily adv.<br>
steadiness n.<br>
steady + -ness 名词后缀<br>
unsteady<br>
unsteadily adv.<br>
unsteadiness n.<br>
homestead n. 宅地<br>
bedstead n. 床架<br>
steadfastly adv. 踏实地<br>
fast 紧的 稳固地<br>
instead adv. 代替；反而<br>
in- 否定 + stead 站<br>
<strong>sturdy</strong> adj. 坚定的</p>
<blockquote>
<p>Describe something that is firmly constructed or strongly made as <strong>sturdy</strong>. That house you built was not <em>sturdy</em> at all. It blew down in the last wind storm. Fortunately, it was only a dog house and the dog wasn’t in it.</p>
</blockquote>
<p>nest n. 窝 vt.筑巢 嵌套 vi.<br>
nested adj. 嵌套的 内装的<br>
nester n. 穴居的兽<br>
nestle vi<br>
nest + -le 动词后缀<br>
nesting n. 嵌套；造巢<br>
empty-nest n.</p>
<p>stadia n. 视距；视距仪（stadium的复数）<br>
stadium n. 体育场<br>
steer vt. 控制；驾驶 vi. n. 阉牛<br>
词源：<br>
1. 来自古英语steran, 驾驶，指导<br>
2. 来自古英语stero,阉公牛<br>
steering n.<br>
understeer n.<br>
under- 未达到–不足<br>
steering-wheel n. 方向盘</p>
<p><strong>stat</strong> n. 静；斯达（放射性强度单位）<br>
词根表单词<br>
static adj. 静态的 静电的 静力的 n. 静电<br>
stat- 站 – 静止-- 静态–静电 ±ic 形容词或名词后缀</p>
<blockquote>
<p><strong>Static</strong> means not moving or changing – it’s often used to describe abstract ideas that can’t be seen. “The troops were moving all over the country, engaged in skirmishes, but the army’s overall position remained <em>static</em>.”</p>
</blockquote>
<p>statics n. 静力学<br>
-ics 学术名词<br>
stator n. 固定片；定子<br>
statin n. 抑制素<br>
-in=-an 名词后缀<br>
statism n. 国家主义 中央集权<br>
-stat- 站-- 占据–以……为中心 – 中央集权<br>
-ism 名词后缀，表……主义，制度<br>
staticky adj. 带静电的<br>
statically adv. 静态的<br>
stative adj. 状态动词的<br>
hydrostatic adj. 流体静力学的<br>
-hydro- 水–流动<br>
prostatic adj. 前列腺的<br>
homeostatic adj. 自我平衡的<br>
-home- 自我 ±o- +static<br>
apostatize vi。 变节 脱党<br>
apo- 分–分出<br>
hemostat n. 止血剂<br>
-hemo- 血 + -stat- 站<br>
hemostatic n. adj.<br>
ecstasy n. 狂喜 入迷 忘形<br>
ec- 向外 + -st- 站 --站出–脱离思想–放空 + -asy 名词后缀<br>
ecstatic adj.<br>
ecstatically adv.<br>
thermostat n. 恒温器<br>
-therm- 热 热的<br>
metastatic adj. 转移性的；新陈代谢的<br>
-meta- = 改变–转移 + stat- 站立-- 转移位置 + -ic 形容词后缀</p>
<p>parastatal adj. 半国营的 n.<br>
para-辅助，准 --半占有 + state 州 国家 ±al<br>
prostatitis n. [泌尿] 前列腺炎<br>
±itis 名词后缀 医学类<br>
biostatistics n. 生物统计学<br>
biostatistician n.<br>
orchostatic adj. 【医学】 直立的<br>
-orcho- 正的 -hetero- 表示不正<br>
quasi-static adj. 准静态的<br>
quasi- 相似<br>
cryostat n. 低温恒温器<br>
-cryo- 冷<br>
anti-static adj. 抗静电的<br>
rheostat n. 变阻器<br>
-rhe- 流动 – 电流 + -stat-站–阻止–阻止电流–电阻<br>
photostat n. 直接复印机 v.<br>
phot- 光 + -o- ±stat- 站–打印<br>
hypostatic adj. 实体的 本质的<br>
hypo- 下–下面站–本质<br>
aerostat n. 航空器<br>
aero- 空气 stat- 站 平衡 空中平衡–航空器<br>
subsist vi. 存在 供养 vt.<br>
下面站<br>
subsistence n. 生存<br>
desist vi. 停止；断念<br>
de-向下 离开 + -sist- 站 不再坚持 停止<br>
superstition n. 迷信<br>
super- 超级，在上 + -stit-<br>
superstitious adj. 迷信的<br>
superstitiously adv.<br>
interstitial adj. 间质的；空隙的 n. 节间<br>
inter- 在……之间 + -stit-</p>
<p>stem n. 干；茎；血统 vt. 阻止；除去……的茎 vi. 阻止；起源于某事物<br>
stemmed adj. 去掉茎的；有茎的<br>
stemware n. 高脚器皿<br>
ware n. 器皿<br>
epistemic adj. 认知的<br>
epi- 在上 在中 + stem 站 ±ic 形容词后缀<br>
站在中间的，进行探索和认知的，参照understand<br>
epistemology n. 认识论<br>
-logy 名词后缀，表学术名词<br>
epistemological adj.<br>
stem-cell n.<br>
long-stemmed adj.<br>
stomp vt. 跺脚 踩踏 n.<br>
stomping v.<br>
stalk n. 茎 秆 vt. vi<br>
stalking n. 围捕<br>
stale adj. 陈腐的；不新鲜的vi vt.<br>
stal- 站–静止–腐朽 ±e 名词或动词后缀<br>
staleness n.<br>
stalemate n. 僵局；陷于困境 vt. vi.<br>
mate 杀，将军 ？<br>
stalwart adj. 坚定的；健壮的 n. 坚定分子<br>
oust vt. 驱逐<br>
ousting vt.</p>
<p>stiff adj. 呆板的；坚硬的 adv. n.<br>
stiffen vi vt. 使变硬<br>
stiffened adj. 加强的<br>
stub n. 存根；烟蒂；<br>
stubborn adj.<br>
stub(b) + -orn = -ern 形容词后缀<br>
stubbornness n.<br>
stamp n. 邮票<br>
stamped adj. 铭刻的；戳上邮票的；顿足的<br>
stampede n. 惊跑；人群的蜂拥；军队溃败 vi vt.<br>
stamping v 冲压 n.<br>
stern n. 船尾 adj. 严厉的；坚定的<br>
staple n. 订书钉；主要产品 adj. vt.<br>
stapler n. 订书机 主要商品批发商<br>
stoic n. 禁欲主义者 adj.<br>
stoically adv.<br>
stoicism n.<br>
stumble vi 踌躇，蹒跚 犯错 vt. 使……困惑<br>
stumbling adj.<br>
armistice n. 停战<br>
arm + -i- + st 站–停止 ±ice 名词后缀<br>
interstice n. [建] 裂隙；空隙<br>
stasis n. 【医学】 郁积，停滞<br>
st-站–停滞 + -asis 名词后缀，医学专用<br>
stet n. 保留，不删<br>
st- + -et<br>
cast vt. 投掷 n. vi.<br>
stool n. 凳子；粪便；厕所<br>
stow vt. 装载；收藏<br>
stamina n. 毅力；精力；活力；持久力<br>
stud n. 种马；大头针<br>
stilt n. 高跷；支柱，支撑物 vt.<br>
stilted adj. 不自然的 呆板的<br>
systole n. 心脏收缩<br>
systolic<br>
diastolic adj. 心脏舒张的<br>
dia- 分 + stolic<br>
stamen n. [植] 雄蕊<br>
abstinence n. 节制；节欲<br>
abs- 分离，脱离 ±tin- 握，持有 + -ence<br>
abstinent adj. n. 禁欲者</p>
<h1>第17节课</h1>
<h2 id="sit-sid-sed-sess-坐">-sit- = -sid- = -sed- = -sess- 坐</h2>
<p>sit vi. 坐，位于<br>
siting n. 选址；定位<br>
sitting n. 入席，就坐；开庭 adj. 坐着的<br>
sit(t) + -ing 动名词或形容词<br>
sitter n. 坐着的人<br>
site n. 场所；遗址<br>
sit + -e 名词后缀<br>
website n. 网站<br>
web 网<br>
situate vt. 使位于<br>
sit + -u- + -ate 动词后缀<br>
situated adj.<br>
situating vt. 使位于；使处于 adj. 位于……的<br>
situation n. 情况</p>
<blockquote>
<p>**Situation is related to the verb “situate”, which means to place. A building might be situated on the top of a hill – that’s its position or <em>situation</em></p>
</blockquote>
<p>situatedness n. 现场即席性；情境性<br>
situated 坐落于某处–身处其中–情景 ±ness<br>
situational adj. 情形的<br>
sitcom abbr. 情景喜剧 （situation comedy）<br>
abbr. = abbreviation = ab- 强调 + -brev- 短 --使变短<br>
baby-sit vi. vt.<br>
baby-sitting n.<br>
sit-up n. 仰卧起坐<br>
sit-down n. 静坐抗议；静坐罢工 adj.<br>
sit-in n. 静坐抗议；静坐罢工<br>
off-site n. 工地外<br>
worksite n. 工地<br>
homesite n.<br>
in-situ n. 原位；现场<br>
situ = situation<br>
sitting-room n. 起居室；客厅</p>
<p>consider vt. 考虑；认为 vi.<br>
considering prep. 考虑到 conj. 考虑到<br>
considered adj. 经过考虑的<br>
-ed 被……的<br>
unconsidered adj.<br>
considerate adj. 体贴的<br>
consider + -ate 形容词后缀<br>
inconsiderate adj.<br>
considerately adv. 体谅地<br>
consideration n. 考虑<br>
considerable adj. 相当大的；相当多的<br>
consider + -able<br>
considerably adv.<br>
inconsiderable adj.<br>
reconsider vt.<br>
reconsideration n.<br>
ill-considered adj.<br>
well-considered adj.<br>
preside vi. 主持 vt. 管理<br>
pre- 在前 + -sid- ±e 动词后缀</p>
<blockquote>
<p>When you <strong>preside</strong> over something, you’re acting as the leader or president. The captain of a club <em>presides</em> over the meetings.</p>
<p>Whether your title is <em>President</em> or not, when you preside, you’re acting as a president or another kind of a leader. A judge presides over a courtroom. The owner of a business presides over staff meetings. If you work in an office, your boss presides over the office. Presiding can mean rulling or just supervising something. If you preside over something, you’re in charge of it.</p>
</blockquote>
<p>presider n. 主席；主持人<br>
president n. 总统，主席<br>
pre-在前 + -sid- 坐<br>
presidential adj. 总统的<br>
unpresidential adj.<br>
presdentially adv.<br>
presidency n. 总统的职位；管辖<br>
co-president n. 共同会长<br>
vice-president n.<br>
vice-presidential adj.<br>
vice-presidency n.<br>
ex-president<br>
then-presdent n. 当时的总统<br>
post-presdent adj. 卸任总统的<br>
post 后–卸任<br>
presidium n. 主席团<br>
president + -i- + -um 名词后缀<br>
presiding adj. 首席的	<br>
presidio n. 要塞；流放地</p>
<p>reside vi. 住，居住<br>
re- 向后，往回</p>
<blockquote>
<p>The place where you live – whether house, hotel, or mobile home – is where you <strong>reside</strong>. The President of the United States <em>resides</em> at 1600 Pennsylvania Avenue, in a little shack called the Whited House.</p>
<p>You can also use <em>reside</em> to refer to the community where you make your home. You may <em>reside</em> in a particular neighborhood, town, or city. The verb <em>reside</em> can also mean to exist as an inherent quality. For example: “The ability to create laws <em>resides</em> in the legislative branch of the government – in this case, Congress.”</p>
</blockquote>
<p>resident n. 居民 adj.<br>
residence n.<br>
residency n. 住处<br>
residential adj.<br>
residentially adv. 居住地<br>
non-resident n. adj.<br>
nonresidential adj.<br>
artist-in-residence n.<br>
writer-in-residence n.<br>
residue n. 残渣<br>
re- 再次 + -sid- 坐 --再次坐–留下 + -u- + -e</p>
<blockquote>
<p><strong>Residue</strong> is anything that’s left over when a substance has been removed, like the grease left over on a frying pan. It can also mean, simply, “remainder”.</p>
<p>When <em>residue</em> refers to a liquid, it’s what’s left at the bottom of a bottle, a pot, or a can after the rest has been poured out. Legally, the residue is the remainder of the money in an estate, after bills and taxes have been paid. So if your millionaire aunt leaves you her estate, but didn’t pay any bills for the last ten years, you may not get much residue!</p>
</blockquote>
<p>residual n. adj.<br>
residuals n.<br>
-s 名词后缀，表复数<br>
residuum n. 残留物<br>
resid + -u- + -um</p>
<p>subside vi. 平息；沉淀<br>
sub- 在下，向下</p>
<blockquote>
<p>To <strong>subside</strong> is to die down or become less violent, like rough ocean waves after a storm has passed ( or your seasickness, if you happened to be sailing on that ocean).</p>
<p><em>Subside</em> comes from the Latin prefix <em>sub</em>- ( meaning “down”) and the Latin verb <em>sidere</em> ( meaning to “to settle”). <em>Subside</em> is often used when a negative situation has improved significantly. For example, violence, disease, and unemployment can call subside. here’s hoping that they do.</p>
</blockquote>
<p>subsidy n. 补贴；津贴</p>
<blockquote>
<p>A <strong>subsidy</strong> is a grant of financial assistance. Many school districts, for example, offer a <em>subsidy</em> to low-income families for book fees and lunch costs. The family pays a set amout and the district makes up the difference</p>
</blockquote>
<p>subsiding n. 下沉<br>
subsidence n.<br>
subsidize vt. 资助<br>
subsidized adj. 补贴的<br>
unsubsidized adj.<br>
subsidiary adj. 附属的；辅助的 n. 子公司<br>
subside + -i- + -ary<br>
subsidiarity n.<br>
subsidization n. 补贴<br>
government-subsidized adj. 国家助学<br>
state-subsudized adj.<br>
dissidence n. 意见不同<br>
dis- 分 + -sid- 坐 + -ence 名词后缀<br>
dissident adj.<br>
assiduous adj. 刻苦的<br>
as- 强调 + sid + -u- + -ous 形容词后缀 – 把冷板凳坐穿<br>
assiduously adv.</p>
<p>possess vt. 控制；使掌握；持有<br>
-pos- 能力，占有 ±sess- 坐</p>
<blockquote>
<p>To <strong>possess</strong> something is to have or own it. You can possess a physical object, you can possess a particular quality or skill, or you can <em>possess</em> control or influence over someone.</p>
</blockquote>
<p>possession n.<br>
possessive adj. 占有的<br>
possessively adv. 占有地<br>
possessiveness n.<br>
possessor n.<br>
possessory adj. 所有的<br>
possess + -ory<br>
possessed adj. 着魔的<br>
占有–比喻占据思想<br>
prepossess vt.<br>
pre 在前 + possess<br>
prepossessing adj.<br>
self-possessed adj. 有自制力的<br>
self-possession<br>
dispossess vt. 剥夺<br>
dis- 不，非，使相反<br>
dispossession n.<br>
repossess vt. 收回<br>
re- 再次<br>
repossession n.<br>
obsess vt. 迷住<br>
ob- 在上 表强调</p>
<blockquote>
<p>If you <strong>obsess</strong> about something, you constantly think about it, like kids who <em>obsess</em> about their grades so much, they get upset before every test.</p>
</blockquote>
<p>obssession<br>
obssessional adj.<br>
obssessive adj.<br>
obssessively adv.<br>
obssessiveness n.<br>
obssessed adj. 着迷的<br>
self-obsessed adj. 自恋的<br>
sex-obsessed adj. 性着迷的<br>
sex- 性</p>
<p>assess vt. 评估，定价<br>
assess 原来是个法律术语，意思为坐下来，<br>
as- 强调 + -sess- 坐 – 法官助手对当事人税务的评定</p>
<blockquote>
<p>Before you try to sell your car, you should ask an expert to <strong>assess</strong> its value – once you know what it’s worth, it’s easier to find a fair price. When you <em>assess</em> a matter, you make a judgement about it.</p>
</blockquote>
<p>assessor n.<br>
assessable adj.<br>
self-assessed adj. 自我评估的<br>
self-assessment n.<br>
reassess vt.<br>
reassessment<br>
preassessment n.<br>
pre- 在前–预先<br>
risk-assessment n.</p>
<p>session n. 集会；会议；开庭<br>
-sess- 坐 --聚会 会议 ……</p>
<blockquote>
<p>A <strong>session</strong> is a specific block of time didicated to something. Court may be in <em>session</em>, or school may be in <em>session</em>, or you just might find yourself enjoying a message therapy session.</p>
</blockquote>
<p>sessional adj.<br>
intersession n. （美）学期与学期之间的短假期<br>
inter- 在……之间<br>
supersede vt. 取代<br>
super 在上 + -sed 坐 --坐上去<br>
supersession n. 废弃；代替<br>
sediment n. 沉积<br>
sed + -i- + -ment<br>
sedimentary adj.<br>
sedimentation n. [矿] 沉淀<br>
sedate adj. 沉着的<br>
-sed- 坐 – 坐下去 --沉静下来<br>
sedately adv.<br>
sedative n. [药] 镇静剂 adj.<br>
sedation n.</p>
<p>sessile adj. 固着的<br>
-sess- 坐 – 能够坐 --粘连或固定住 + -ile=-ible<br>
sedentary adj. 久坐的<br>
-sed- 坐 + -ent + -ary 形容词后缀<br>
sedan n. 轿车；轿子<br>
sed- 坐–轿子–轿车</p>
<h1>第18节课</h1>
<h2 id="pear-par-生">-pear- = -par- 生</h2>
<p>appear vi. 出现<br>
ap- 强调 + -pear- 生 --强调生出来–出现<br>
appearance n.<br>
disappear vi.<br>
disappearance n.<br>
disappeared adj.<br>
reappear vi.<br>
reappearance n.</p>
<p>parent n. 父母<br>
-par- + -ent 名词后缀<br>
parental<br>
biparental adj.<br>
bi- 二，双<br>
stepparent n.<br>
step- 后<br>
grandparent<br>
grand 更高一级<br>
great-grandparent n. 曾祖父<br>
godparent<br>
parentage n. 出身<br>
parenting n. 父母对子女的养育<br>
one-parent adj. 单亲的<br>
two-parent<br>
single-parent n.<br>
parent-adolescent n. 亲子<br>
adolescent n. 青少年<br>
heir-apprent n. 法定继承人<br>
non-parent adj.<br>
non-否定<br>
parenthood n. 亲子关系<br>
-hood 名词后缀<br>
neighborhood<br>
childhood<br>
parent-child adj. 父子关系</p>
<p>apprent adj. 明显的<br>
ap- 强调 + par- 生 – 生出来 – 出现 – 显然 + -ent 形容词后缀<br>
apprently<br>
apparition n. 幽灵<br>
ap- + -par- --出现–幻影<br>
transparent adj. 透明的<br>
trans- 改变，通过 + par-生 说不通<br>
transparently<br>
transparentize vt.<br>
-ize<br>
transparence n. 透明 透明度<br>
transparency n. 透明 透明度 幻灯片<br>
semi-transparent adj. 半透明的<br>
semi- 半</p>
<p>primipara n. 初产妇<br>
-prim- 原始，第一 + -i- + -par + -a 名词后缀，表人<br>
premier adj. 第一的，最初的 n. 总理，首相<br>
primiparity n.<br>
primiparous adj. 初产的<br>
biparous adj. 一产双胎的<br>
bi- 二<br>
multiparous adj.<br>
fissiparous adj. 【生】分裂生殖的<br>
-fiss- 分裂</p>
<h2 id="mov-mob-mot-移动">-mov- = -mob- =-mot- 移动</h2>
<p>move n. vi. vt.<br>
moving adj. 感人的<br>
unmoving adj.<br>
movingly<br>
moved<br>
unmoved adj.<br>
mover n.<br>
movable adj.<br>
unmovable adj.<br>
immovable adj.<br>
earthmover n. 推土机<br>
countermove n. 对抗手段 vi vt.<br>
counter- 反<br>
move-in n. 移入<br>
slow-moving adj.<br>
fast-moving adj.<br>
quick-moving n.<br>
remove vt.<br>
re- 反复（感觉不如解释为强调）<br>
removal n.<br>
-al 名词后缀<br>
removed adj. 远离的<br>
removable adj.<br>
snow-removal n. 除雪</p>
<p>movie n. 电影<br>
-mov- + -i- + -e-<br>
moviegoer n.<br>
movie-going n.<br>
movie-theater<br>
movie-like adj. 像电影那样的<br>
b-movie n. 烂片<br>
horror-movie<br>
silent-movie n.</p>
<p>motive n. 动机<br>
motivic adj. 动机的<br>
-ic 形容词后缀<br>
motivate vt.<br>
motivated adj. 有动机的<br>
motivator n. 动力<br>
motivation n. 动力<br>
motivational adj.<br>
self-motivated adj.<br>
unmotivated adj.<br>
automotive adj. 自动的<br>
electro-motive adj.<br>
-electro-<br>
politically-motivated adj.</p>
<p>promote vt.<br>
pro- 向前（强调过程）+ -mov-<br>
pre- 在前（强调位置）<br>
promoted adj.<br>
promotion n.<br>
promotional adj.<br>
promoter n. 促进者，催化剂<br>
self-promotion<br>
health-promoting n.</p>
<p>demote vt. 使降级<br>
de- 向下<br>
demotion n.<br>
demotic adj. 通俗的,民众的<br>
locomote vt. 移动<br>
-loc- 地方 ±o- ±mov<br>
locomotive adj. 移动的 n. 火车头<br>
locomotion n.</p>
<p>motion n. 动作；移动 ；手势 vi. vt.<br>
motionless adj.<br>
motionlessly adv.<br>
motion-picture adj. 电影的<br>
slow-motion adj.<br>
full-motion adj.<br>
emote vi. 夸张地表现感情<br>
e- 向外<br>
emotion n. 情感<br>
emotional<br>
EQ = emotional quotient<br>
unemotional adj.<br>
emotionless adj.<br>
emotive adj.<br>
emotivism n. 情绪主义<br>
emotionally adv.<br>
emotionality n. 情绪性<br>
emotionalism n. 感情主义<br>
non-emotional adj.<br>
social-emotional adj.<br>
socioemotional n. 社会性情绪<br>
-soci- 陪伴 – 社会 ±o- +emotional</p>
<p>remote adj.<br>
re- 反复 + -mot- + -e 偶尔表形容词<br>
remotely adv.<br>
remoteness n.<br>
remote-control n.<br>
remote-controlled adj.</p>
<p>motor n. 发动机<br>
motoring n. 驾驶汽车<br>
motorist n.<br>
motoric adj. [生理]肌肉运动的<br>
motorized adj. 摩托化的<br>
non-motorized adj.<br>
motorbike n. 摩托车<br>
加了发动机的自行车<br>
motorway n. （英）高速公路<br>
motormouth n.<br>
比喻，上了发动机的嘴<br>
motorcade n. 车队<br>
motor + -cad- 盒子 – 移动的盒子<br>
motorcar n. (英) 汽车；（美） 电动车<br>
motorcoach n. 公共汽车<br>
coach n. 教练，马车<br>
motorsport n.<br>
motorcycle n. 摩托车<br>
motorcyclist n.<br>
motorcycling n. 摩托运动<br>
motorboat<br>
motorman n.<br>
motor-driven<br>
motor-vehicle<br>
motorhome<br>
servomotor</p>
<p>motel n. 汽车旅馆<br>
motor + hotel<br>
motile adj. （生物）能动的<br>
—ile = -ible</p>
<p>mob n. 暴徒 vt. vi<br>
mobster n. 暴徒<br>
mobile adj. 可移动的 n.</p>
<h1>第19节课</h1>
<p>mobility n. 移动性<br>
mobilize vt. 动员<br>
mobilized adj.<br>
mobilization n.<br>
demobilize vt. 遣散 使复员<br>
demobilization n.<br>
automobile n. vt.<br>
snowmobile n. 雪上汽车<br>
bookmobile n.<br>
mobile-phone<br>
mobile-home n. 拖车型活动房屋</p>
<p>immobile adj. 固定的<br>
im- 否定 + -mob-<br>
immobility n.<br>
immobilize vt. 使固定<br>
immobilized adj.<br>
immobilizaion n.</p>
<p>motif n. 主题；动机<br>
mot- 动–动机–意图，含义–主题，主旨 + -if 名词后缀<br>
believe belief<br>
-brev-短 brief adj. 简短的<br>
commotion n. 骚动，动乱<br>
com- 强调，在一起 + -mot- 动 – 一起动 --群体动乱<br>
motocross n. 摩托车越野赛</p>
<h2 id="cover-掩盖">-cover- 掩盖</h2>
<p>cover vt. n. vi.<br>
coverd adj. 覆盖的<br>
【任何动词都有其-ing和-ed的形式】<br>
covering adj. n.<br>
coverage n. 覆盖，覆盖范围和动名词后缀<br>
uncover vt. vi.<br>
uncovering adj.<br>
uncovered adj.<br>
undercover adj. 秘密的<br>
under- 在……下方<br>
cover-up n. 掩饰；隐蔽<br>
hardcover n. adj.<br>
softcover n.<br>
coveralls n. 衣裤相连的工作服<br>
cover+all --全覆盖 ±s 名词后缀<br>
coverlet n. 被单；床罩<br>
slipcover n. 沙发套；套子 vt.<br>
chocolate-coverd adj.<br>
groundcover n. 地被植物<br>
bedcover<br>
ivy-coverd adj.<br>
vine-covered<br>
leather-coverd<br>
pine-coverd<br>
lichen-coverd adj.<br>
foil-coverd adj. 包裹锡纸的<br>
soot-covered adj.煤灰覆盖的<br>
full-coverage<br>
velet-covered<br>
canvas-covered<br>
vinyl-covered<br>
well-covered adj. 胖的<br>
non-convered adj. 覆盖了的</p>
<p>discover vt. 发现<br>
dis-分 + -cover- 覆盖<br>
discovery<br>
discoverer<br>
discovered v.<br>
undiscovered adj.<br>
discoverable adj.<br>
co-discoverer n.<br>
e-discovery n.<br>
e- = electron 的缩写<br>
self-discovery<br>
rediscover vt. 再次发现<br>
rediscovery</p>
<p>recover vt. 恢复<br>
re-再次 + -cover- 覆盖<br>
recovered adj.<br>
recovery<br>
recoverable adj.<br>
unrecoverable adj.<br>
irrecoverable adj.<br>
recovered-memory n.<br>
covert n. 隐藏处 adj.<br>
covertly adv.</p>
<h2 id="plic-ply-pli-ple-plex-plo-to-fold-倍，重，折叠">-plic- = -ply- = -pli- = -ple- = -plex- = -plo- to fold 倍，重，折叠</h2>
<p>diploma n. 毕业证书，文书 vt.<br>
di- 二 + -plom- 折叠 --对折的铜片–证书 ±a 集合名词后缀，后面有动词的引申<br>
diplomacy n. 外交 外交手段<br>
diploma + -acy 名词后缀<br>
diplomat n. 外交家<br>
diplomate n. 学位证书持有者<br>
-ate 偶尔表名词<br>
diplomatic adj. 外交的<br>
diplomatically adv.<br>
undiplomatic adj. 无外交车辆的</p>
<p>complex adj. n.<br>
com- 强调 + -plex- 重叠，编织<br>
complexion n. 面容<br>
complexity n.<br>
complexly adv.<br>
B-complex n. 复合B族维生素<br>
dark-complexioned adj. 有……黑肤色的</p>
<p>employ vt. 使用<br>
em- 向内，使动 + -ploy- 折叠–折进去<br>
employment n. 雇佣<br>
employer<br>
employee n.<br>
-ee 名词后缀，表人，表被动<br>
employed adj.<br>
employable<br>
unemployed adj.<br>
unemployment<br>
unemplyable adj.<br>
underemployed adj. 未充分就业的<br>
under- 在……下–未达到<br>
ex-employee<br>
self-employed adj.<br>
pre-employment n.<br>
full-employment n. 充分就业<br>
employer-paid n. 雇主支付<br>
employee-owned adj.<br>
employment-based n.<br>
based 基于……的，此处指的是劳动力派遣<br>
employer-employee n. 劳资关系</p>
<p>complicate vt.<br>
com- 在一起 + -plic- -重叠在一起–复杂<br>
complication<br>
complicated<br>
uncomplicated adj. 简单的<br>
complication n. 使复杂化<br>
complicacy n. 复杂<br>
complicity n. 共谋<br>
complic + -ity 名词后缀<br>
complicit adj. 串通一气的<br>
complic + -it 形容词后缀<br>
complicitous adj.</p>
<p>explicate vt. 解释，说明<br>
ex- 向外 + -plic- --折出来–展开<br>
explication<br>
explicable adj. 可解释的<br>
explicatory adj. 解释的<br>
explicit adj. 明白的<br>
explicitly adv.<br>
explicitness n.<br>
inexplicable adj. 费解的<br>
inexplicably adv.</p>
<p>supplicate vt. vi. 恳求<br>
sup- 往下 + -plic- --往下折–（下跪）恳求 ±ate<br>
supplication n.<br>
supplicatory adj. 恳求的<br>
supplicant n. 恳求者</p>
<p>implicate vt. 使卷入；涉及<br>
im- 向内<br>
implication n.<br>
implicated adj. 有牵连的<br>
implicit adj. 暗示的；含蓄的<br>
implicitly adv.<br>
implicature n. 含意<br>
implicate ±ure</p>
<p>duplicate vt. 使成双，复制 adj. 二重的 n. 复制品<br>
du- 二 + -plic- 折 – 对折 --成双 ±ate 动词或形容词后缀<br>
duplication n. 成双，复制品<br>
duplicated adj.<br>
duplicator n.<br>
unduplicated adj.<br>
un- 否定<br>
duplicity n. 二重性，表里不一<br>
duplic + -ity<br>
duplicitous adj. 双重的；搞双面派的<br>
duplic + -it + -ous</p>
<p>apply vt. 申请；应用 vi.<br>
ap- 强调 + -ply- 折叠–卷入–使用。申请的含义应该来自diploma<br>
appliance n. 器具；器械；装置<br>
apply + -ance<br>
misapply vt.</p>
<p>reply vi. n. vt.<br>
re- 往回 + -ply- 折叠- -往回折叠–回应<br>
multiply vt. 乘法 繁殖<br>
multi- 多重的 + -ply- –<br>
multiplying n. 繁殖 adj.<br>
multiplicate adj. 多重的<br>
multiplication n.<br>
multiplicative adj. 乘法的<br>
multiplicity n. 多重性</p>
<h1>第20节课</h1>
<p>applicator n. 涂药器<br>
ap- + -plic- + -ate + -or<br>
applicant n. 申请人<br>
-ant 名词后缀，表人<br>
applicable adj. 可适用的<br>
applicability n.<br>
misapplication n. 误用<br>
inapplicable adj. 不适用的<br>
in- 否定<br>
mis- 错误<br>
reapplication</p>
<p>simple adj. n. 笨蛋<br>
sim-(-simil-)相似，相同 + -pl- 折叠 + -e 名词或形容词后缀<br>
simplify vt.<br>
simplicity n. 朴素；简易；天真；愚蠢<br>
同一个单词词性不同，甚至连褒贬都不同。<br>
所以，实际用的时候<strong>看语境（context)</strong></p>
<p>replica n. 复制品<br>
re- 重复 + -plic- + -a 集合名词后缀<br>
replicate vt. 复制；折叠 vi. adj.<br>
replication n. 复制<br>
replicator n. 复制基因<br>
replicated adj.<br>
self-replicating adj.</p>
<p>multiplex adj. 多重的<br>
multi- 多 + -plex- 折叠–倍数<br>
multiplier n. 乘数；倍增器<br>
multiplexer n. 多工器；多路器<br>
multiple adj.<br>
multiple-choice adj.</p>
<p>perplex vt. 使复杂化<br>
per- 完全，贯穿 + -plex- 重叠<br>
preplexing adj.<br>
perplexed adj.</p>
<p>supple adj. 柔软的，灵活的<br>
sup- 向下 + -ple- --往下折叠–柔软，灵活<br>
suppleness n. 柔软；易弯曲<br>
supplement vt. n. 补充<br>
supplementary adj. 补充的<br>
supple + -ment + -ary<br>
supplementaion n.</p>
<p>deploy vt. 配置；展开 vi. n.<br>
de- 不，非，使否定 + -ploy 卷，折叠<br>
deployable adj.<br>
deployment n.<br>
redeploy vt. vi.<br>
redeployment n.<br>
forward-deployed adj. 前沿部署</p>
<p>simplex adj. 单一的<br>
= simple<br>
duplex adj. 二重的<br>
du- 二<br>
duplexer n.<br>
triplex adj. 三重的<br>
tri- 三<br>
quadruplex adj. 四重的<br>
quadru- 四</p>
<p>triple adj. 三倍的<br>
tripling n. 群交<br>
triplicate n. 一式三份 adj.<br>
tri- + -plic- + -ate<br>
triply av.<br>
triple + -ly<br>
triploid adj. n.<br>
triple + -o- + -id 形容词或名词后缀<br>
triple-decker n.</p>
<p>polyploid adj. 多倍的<br>
poly- 多<br>
polyploidy n.<br>
pliant adj. 顺从的；易弯的<br>
pli- + -ant<br>
pliable adj.<br>
pliability n.</p>
<p>ply vt. 折，弯；从事 vi. n.<br>
imply vt. 意味；暗示；隐含<br>
im- 向内 + -ply- 折 –<br>
plywood n. 夹板<br>
ploy n. 活动；工作；策略 vt. vi.<br>
accomplice n. 同谋者<br>
ac- 强调 + com- 在一起 + -plic- 折叠在一起<br>
photomultiplier n. [电子]光电倍增管<br>
-phot- 光<br>
noncompliant n. 固执的人<br>
non-否定 + com-强调 + -pli- 折叠 --不能折叠的–比喻为固执<br>
plexus n. [解剖] 丛<br>
plex- + -u- + -s 名词后缀，表复数<br>
implemented adj. 应用的<br>
向内折叠–包含，应用<br>
diploid adj. 双倍的 n.二倍体<br>
di-分–二 + -plo-</p>
<h2 id="mus-音乐，娱乐">-mus- 音乐，娱乐</h2>
<pre><code>缪斯（Muses)
</code></pre>
<p>muse n. 沉思；冥想 vt. vi.<br>
-mus- 沉思，凝视<br>
musing adj.<br>
museun n.<br>
muse + -um 名词后缀，表地点<br>
museology n. 博物馆学<br>
amuse vt. 娱乐<br>
a-强调<br>
amusement n.<br>
amused adj.<br>
amusing adj.<br>
amusingly adv.<br>
unamused adj.<br>
amusement-park n. 游乐场</p>
<p>music n.<br>
musical adj. n.<br>
musicale n. 音乐会<br>
-e 名词后缀<br>
musically adv.<br>
musicality n. 音乐性<br>
musician n.<br>
music + -i- + -an<br>
musicianship n. 音乐才能<br>
musician + -ship 名词后缀<br>
musicology n. 音乐学；音乐理论<br>
±o- + -logy<br>
musicologist n.<br>
musicological adj.<br>
unmusical adj.<br>
extramusical adj.<br>
extra- = ex- 向外 + tra-(trans-) 通过–通到外面–额外的<br>
music-hall n.<br>
music-making n.<br>
musical-comedy n.<br>
pop-music n.<br>
folk-music n. 民俗音乐<br>
classical-music n.<br>
world-music<br>
chamber-music n. 室内音乐</p>
<p>bemuse vt. 使发呆<br>
be-否定 + muse 灵感<br>
bemused adj. 困惑的；发呆的<br>
bemusement n.</p>
<h2 id="erg-org-urg-做，工作">-erg- = - org- = -urg- 做，工作</h2>
<p>energy n. 能源<br>
en-使动 + -erg- 做–能做–能量<br>
energize vt.<br>
energy + -ize<br>
energized adj.<br>
energizer n.<br>
energetic adj.<br>
-et + -ic = -etic 复合形容词后缀<br>
energetics n. 能量学<br>
-et + -ics 学术名词后缀<br>
energetically adv.<br>
-ic 结尾的单词，变副词时，通常加-al + -ly<br>
=-ically<br>
energy-rich<br>
re-energize vt. 重新激励<br>
renewable-energy n.<br>
alternative-energy n.<br>
waste-to-energy adj. 浪费能源的</p>
<h1>第21节课</h1>
<p>synergy n. 协同作用<br>
-syn- 在一起 + -erg- 做 – 协同<br>
synergism n. 合作<br>
synergic adj. 合作的<br>
synergistic adj.<br>
synergistically adv.</p>
<p>allergy n. 过敏；反感<br>
allergic adj.<br>
allergist n. 过敏症专科医师<br>
allergen n. 过敏原<br>
allergy + -en 名词后缀<br>
allergenic adj. 过敏的<br>
non-allergic adj.</p>
<p>erg n. 【物】 尔格<br>
ergonomic adj. 人类环境改造学的<br>
-erg- 工作，工效–人工 + -nomy- 学说 + -ic 形容词后缀<br>
ergonomics n. 工效学<br>
-ics 学术名词后缀<br>
ergometer n. 测力计<br>
-erg- 功–力 + -o- + -meter- 测量</p>
<p>organ n. 器官；机构；管风琴<br>
-org- 做–组成 + -an  名词后缀，表物<br>
organize vt. 组织<br>
organizer n.<br>
organiser n.<br>
organized adj.<br>
organization n.<br>
organizational adj.<br>
organizationally adv.<br>
organizing n. adj.<br>
well-organized adj. 有序的<br>
unorganized adj.<br>
disorganize vt.<br>
disorganised adj.<br>
disorganization n.<br>
self-organization n.<br>
self-organized adj.<br>
self-organizing adj.<br>
co-organizer n.<br>
interorganizational adj. 跨组织的<br>
organization-wide adj.<br>
reorganize vt.<br>
reorganizaion n.<br>
reorganized adj.<br>
organic adj. [有机化学] 有机的；组织的<br>
organ 器官–组织 + -ic 形容词后缀<br>
organically adv. （发生、发展过程）自然地<br>
organism n. 有机体<br>
inorganic adj. 无机的<br>
non-organic adj. 无机的<br>
microorganism n. 微生物<br>
organist n. 风琴演奏者<br>
organismic adj.  生物的<br>
organismal adj.<br>
superorganism n.<br>
organelle n. 细胞器<br>
organ + -elle 名词后缀<br>
organophosphate n. 有机磷酸酯<br>
organochlorine n. 有机氯<br>
chlorine n. 氯</p>
<p>orgy n. 狂放；放荡<br>
-org- 做 – 放荡，出格的事 + -y 名词后缀<br>
orgasm n. [生理] 性高潮<br>
orgasmic adj.<br>
orgiastic adj. 狂欢的</p>
<p>urge vt. 推动；催促<br>
urg- 做–推动 ±e<br>
urging v.<br>
urgency n.<br>
urgent adj.<br>
urgently adv.<br>
non-urgent adj.</p>
<p>surgery n. 外科<br>
surgeon n. 外科医生<br>
telesurgery n. 远距离手术<br>
surgical adj. n.<br>
microsurgery n. [外科] 显微外科<br>
microsurgical adj.<br>
plastic-surgery n. 整形外科<br>
plastic 塑料–塑性</p>
<h2 id="lect-lig-leg-legis-采集，读，说，法律">-lect- = -lig- = -leg- = -legis- 采集，读，说，法律</h2>
<p>elect adj n. vt. 选举<br>
e- 向外 + -lect- 采集 – 向外采集 --选出<br>
elector n. 有选举权的人<br>
election n.<br>
elective adj. 选修的；选举的 n.<br>
unelected adj.<br>
election-year<br>
election-night<br>
elextoral adj. 选举人的<br>
electorally adv.<br>
unelectable adj. 不能当选的<br>
re-elect vt.<br>
re-election n. 重选<br>
post-election n. 选举后<br>
pre-election n.<br>
governor-elect n. 总监当选人<br>
democratically-elected adj. 民选的<br>
non-elected adj.<br>
by-election n. 递补候选</p>
<p>collect vt.<br>
col- 在一起 + -lect- 采集<br>
collection  n.<br>
collected adj.<br>
uncollected adj.<br>
collective adj. 集体的；共同的<br>
collectivist n. 集体主义者<br>
collectivistic adj.<br>
collectivism n. 集体主义<br>
collectivity n. 集体<br>
collectively adv.<br>
collector n.<br>
collectible adj.<br>
collectable adj. n.<br>
-able = -ible<br>
collectibles n.<br>
-s 表复数<br>
uncollectible adj.<br>
collectivize vt…<br>
collectivization n. 集体化<br>
data-collection n.<br>
recollect v. 回忆<br>
recollection n.<br>
recollected adj. 镇定的；回忆到的</p>
<p>select<br>
se-分<br>
selection<br>
selector<br>
selected adj.<br>
selective adj.<br>
selectivity n. 选择性<br>
selextively adj.<br>
unselected adj.<br>
self-selection n.<br>
pre-selected adj. 预选的<br>
selectman n. 行政委员<br>
deselect vt. 取消选定<br>
de- 分，可表否定<br>
selectee n.<br>
-ee 名词后缀，表被动<br>
non-selective adj. 非选择的</p>
<p>intelligent adj. 聪明的<br>
intel- 在……之间 + -lig- 选  + -ent<br>
unintelligent adj.<br>
intelligence n. 智力<br>
intelligently adv.<br>
intelligentsia n. 知识界<br>
intelligent + -s 复数名词后缀 + -i- + -a 集合名词后缀<br>
counterintelligence n. 反情报<br>
counter-反<br>
artificial-intelligence n. 人工智能<br>
intelligible adj. 可理解的<br>
intelligibly adv.<br>
intelligibility n. 可理解性<br>
unintelligibly adv.<br>
unintelligibility n.</p>
<p>intellect n. 智力<br>
intellct 可视为 intelligent 的变体<br>
intellectual adj. n. 知识分子<br>
intellectually adv.<br>
intellectulism n.<br>
anti-intellectual adj.<br>
anti-intellectualism n.<br>
intellectualize vt. 使理智<br>
intellectualized adj.<br>
intellectualization n.</p>
<p>neglect<br>
neg- 否定 + -lect-<br>
neglectful adj.<br>
neglected adj.<br>
long-neglected adj.</p>
<p>elegant adj.<br>
e- 向外 + -leg- 选 – 选美 --出众<br>
inelegant adj. 不雅的<br>
elegantly adv. 优美地<br>
inelegantly adj.<br>
elegance n.</p>
<h1>第22节课</h1>
<p>eligible adj. 合格的；符合条件的 n.<br>
e- + -lig-<br>
eligibility n.<br>
ineligible adj.<br>
ineligibility n.<br>
delegate vt. 委派……为代表 n. 代表<br>
de- 向下，离开 + -leg- 送出 – 派出<br>
delegator n.<br>
delegation n.<br>
delegitimation n. 合法性丧失<br>
de- 否定 	+ -legitim- = -leg- 法律<br>
negligence n. 疏忽<br>
neg- 否认 + -lig- 采集 --未采集–疏忽 + -ence 名词词尾<br>
negligent adj. 疏忽的<br>
negligently adv.<br>
negligible adj.可以忽略的<br>
negligee n. 随便的衣着 adj.<br>
neg- + -lig- + -ee 名词后缀，表被动，后引申出形容词含义</p>
<p>lecture n. vt. vi. 演讲；讲稿<br>
-lect- 读<br>
lecturer n.<br>
lectureship n. 讲师职务<br>
lector n. 读经者，讲师<br>
lectern n. 读经台；小讲台<br>
lect- + -ern 名词后缀<br>
eastern adj. n.</p>
<p>lectionary n. 经文选<br>
lect- + -ion + -ary<br>
dialect n. 方言<br>
dia- 穿过，相互<br>
dialectic n. 辩证法；逻辑论证 adj.<br>
dialectics n.<br>
-ics 学术名词后缀<br>
dialectician n. 辩论的能手<br>
dialectical adj. 辩证的 方言的<br>
dialectically adv.<br>
dialectology n. 方言学<br>
-logy 表……学<br>
dialectologist n. 方言学家<br>
dialectal adj. 方言的<br>
idiolect n. 个人习语<br>
-idlo- 个体–个人 + -lect- 说</p>
<p>legal adj.<br>
-leg- 法律 + -al<br>
legally adv.<br>
legality n.<br>
legalize vt.<br>
legalization n.<br>
legalist n.<br>
legalistic adj. 尊重法律的<br>
illegal adj.<br>
il- 否定<br>
illegally<br>
illegalize<br>
illegality<br>
legalese n. 法律用语<br>
-ese 名词后缀<br>
legalism n. 条文主义<br>
extralegal adj.<br>
extra- 外<br>
paralegal adj. 辅助律师业务的<br>
non-legal adj. 非法的<br>
medico-lega adj. 法医学的<br>
quasi-legal adj. 准法律的<br>
quasi- 近似<br>
legal-size adj.</p>
<p>priviledge n. 权利，特权<br>
-priv- 私有 + -i- + -leg- + -e 名词后缀 --私有的法律–特权。<br>
priviledged adj.<br>
underpriviledged adj.<br>
under- 下–否定<br>
legislate vt. 用立法规定 vi. 立法<br>
legislation n.<br>
legislator n.<br>
legislature n. 立法机关<br>
legislative adj. 立法的<br>
legislatively adv. 立地</p>
<p>legend n. 传奇；小说<br>
legendary adj. 传说中的<br>
legendarily adv. 传奇性地<br>
legendry n. 传奇，传说，传说集<br>
-ary=-ry<br>
legible adj. 清晰的；易读的<br>
legibly adv.<br>
legibility n. 可读性<br>
illegibility</p>
<p>college n. 大学；学院<br>
col- 在一起 + -leg- 说–学 + -e<br>
collegiate adj. 大学的<br>
college + -i- + -ate<br>
collegial adj.<br>
collegian n. 学院的学术<br>
collegium n. 执行管理委员会<br>
-um 地点名词<br>
intercollegiate adj. 大学间的<br>
college-bound n. 准大学生</p>
<p>allege vt. 【法律】宣称<br>
al- 强调<br>
alleged adj. 所谓的<br>
allegedly adv. 据称<br>
allegation n. 质控<br>
allegiance n. 效忠</p>
<p>allegory n. 寓言<br>
allegorize vt.<br>
allegorical adj. 讽喻的<br>
allegorically</p>
<p>diligent adj. 勤勉的<br>
diligently adv.<br>
diligence n. 勤奋<br>
di- 分开 + -lig- 选择</p>
<p>legitimate adj. 合法的<br>
legitimately adv.<br>
legitimize vt. 使……合法<br>
legitimization<br>
legitimation<br>
lgitimacy n.<br>
illegitimate adj.<br>
illegitimately<br>
illegitimacy</p>
<p>eclectic adj. 折衷的；选择的<br>
ec- 向外<br>
eclecticism n.<br>
relegate vt. 把降低到；归入；提交<br>
re- 往回 + -leg- 拿<br>
relegation n. 贬谪</p>
<p>legate n. 罗马教皇的使节；使者 vt.授予遗产<br>
leg- 选–使节<br>
legation n. 公使馆<br>
legatee n. 遗传受赠人</p>
<p>legion n. 军团；众多；军队 adj. 众多的<br>
legionary adj.<br>
legionnaire n. 军团的士兵</p>
<p>legacy n. 遗嘱，遗产<br>
-leg- 法律 – 合法的财产<br>
elegy n. 挽歌<br>
e- + -leg-<br>
elegiac adj.<br>
-ac = -ic 形容词后缀</p>
<p>sacrilege n. 亵渎<br>
-sacri- 牺牲–神圣 + -leg- 拿 – 拿走圣物<br>
sacrilegious adj. 该受天谴的<br>
predilection n. 偏爱，嗜好<br>
pre- 在前 + -di- 分开 + -lect- 采集</p>
<h1>第23节课</h1>
<h2 id="nerv-neur-神经–勇气，紧张">-nerv- = -neur- 神经–勇气，紧张</h2>
<p>nerve n. 神经；勇气；叶脉 vt.鼓起勇气<br>
古罗马人认为筋和肌腱是身体活力的来源<br>
【知道了正确的方法后，真正拉开差距的是努力的程度！】<br>
nervy adj. 有勇气的<br>
unnerve vt. 使失去勇气<br>
unnerving adj. 使人紧张不安的 n.<br>
nervous adj. 神经的；紧张不安的<br>
nervously adv.<br>
nerveless adj.[临床] 无力的；松懈的<br>
nervousness n. 神经质<br>
nervous-system n. 神经系统<br>
nerve-racking adj. 伤脑筋的<br>
rack vt. 折磨，榨取<br>
nerve-wracking adj.<br>
见上<br>
innervate vt. 使受神经支配；使神经分布于<br>
in- 入，向内<br>
innervation n.</p>
<p>enervate vt. 使衰落<br>
e-向外 + -nerv- --失去勇气，精力<br>
enervated adj.<br>
enervating adj. 使人衰落的</p>
<p>neural adj. 神经的；神经系统的<br>
-neur- 神经 + -al 形容词后缀<br>
neuron n. [解剖]神经元<br>
-neur- + -on 名词后缀<br>
neuronal adj.<br>
neurotic adj. 神经过敏的；神经病的 n. 神经病患者<br>
-neur- + -otic = -etic 形容词或名词后缀<br>
neurosis n.【心理】 神经症；神经衰弱症<br>
-neur- + -osis 【医学】名词后缀<br>
neurology n. 神经病学；神经性<br>
-neur- + -o- + -logy 名词后缀，表……学<br>
neurologist n.<br>
neurologic adj. 神经病学的<br>
neurological adj.<br>
同上<br>
neuralgia n. 【内科】 神经痛<br>
-neur- + -algi- 痛 + -a<br>
neuralgic adj.<br>
neuroscience n. 神经系统科学<br>
-neur- + -o- + science<br>
neuroscientist n.<br>
neurosurgeon n. 神经外科医生<br>
-neur- + -o- + surgeon<br>
neurosurgery n. 神经外科<br>
neurosurgical adj. 神经外科的</p>
<p>neuropathy n. 【内科】 神经病<br>
-neur- + -o- + -path- 病 + -y 名词后缀<br>
neuropathic adj.<br>
neuropsychology n. 神经心理学<br>
-neur- + -o- + psychology<br>
neuropsychologist<br>
neuropsychological adj.<br>
neuropsychiatry adj.神经精神病学<br>
psychiatry<br>
neuropsychiatric adj.<br>
neurobiology n. 神经生物学<br>
-neur- + -o- + biology<br>
neurobiologist<br>
neurobiological<br>
neurophysiology n. 神经生理学<br>
neur + -o- + physiology 生理 = -phys- 生理，物理，身体 + -logy<br>
physical adj. 物理的 身体的<br>
physics n. 物理学 = -phys- 生理–本质–物理 + -ics 学术名词<br>
neurophysiologist n.<br>
neurophysiological adj.<br>
neurotoxin n. 【生化】神经毒素<br>
-neuro- 神经 toxin 毒素<br>
neurotoxic adj.<br>
neurochemical  n. 影响神经系统的化学物质 adj. 神经化学的<br>
neurochemistry n. 神经化学<br>
neuroticism n. 神经质<br>
-neur- + -o- + -tic 敏锐 + -ism<br>
neurotically adv.<br>
neurofibroma n. 纤维神经瘤<br>
-fibro- 纤维 + -ma- 块，用来指纤维瘤<br>
neurofibromatosis n. 多发性纤维神经瘤<br>
-osis 医学名词后缀</p>
<p>neuroma n. 神经瘤<br>
-neur- 神经 + -o- + -ma 块，名词后缀<br>
规律拓展：后缀分两种<br>
* 单纯表词性，-ed, -ion, -ity, -ment<br>
* 除了表词性，还有含义拓展。-er = -ar , -less<br>
凡是表含义的后缀，其实早期都源于词根。<br>
neurotransmitter n. 神经递质<br>
-neur- + -o- + transmitter<br>
neuromuscular adj. 神经肌肉的<br>
neurodegenerative adj. 神经变性的<br>
-neur- + -o- + degenerative adj. 退化的<br>
de- 分–改变 + -gener- 生 --退化 + -ate + -ive 形容词后缀<br>
neuropeptide n. 神经肽<br>
peptide<br>
neurovascular adj. 神经与血管的<br>
neurogenic adj. 神经性的<br>
-gen-生<br>
neuroendocrine n. 神经内分泌的<br>
endo- 内 + -crine- 分开，分泌<br>
neurodevelopmental adj. 神经发育的<br>
neurobehavioral adj. n.<br>
neurasthenic n. 神经衰弱<br>
asthenic<br>
neurasthenia n.神经衰弱症<br>
neurotologic n. 神经耳科学<br>
-neur- + otologic<br>
otology n. 耳科<br>
neuroanatomy n. 神经解剖学<br>
anatomy n. 解剖<br>
ana- 向上，向后 + -tom- 砍，切  例如atom 不可切的 原子<br>
neuritis n. 神经炎<br>
sensorineural adj. 感觉神经的<br>
-sens-感觉 + -or 名词后缀，表物 + -i- + -neur- 神经 + -al<br>
psychoneuroimmunology n. 心理神经免疫学<br>
psych + -o- + -neur- + -o- + immun + -o- + -logy</p>
<h1>第24节课</h1>
<h2 id="path-pat-i-pass-i-pathy-to-feel-感受，to-suffer-受苦的">-path- = -pat(i)- = -pass(i)- = -pathy- to feel 感受，to suffer 受苦的</h2>
<p>patient adj. 有耐心的 n. 病人的<br>
pat- + -i- + -ent<br>
patiently adv.<br>
outpatient n. 门诊病人<br>
out- 外–门口<br>
impatient adj. 焦虑的<br>
impatiently adv.<br>
patience<br>
座右铭：Talent is enduring patience.<br>
天分就是持续不断的忍耐！<br>
impatience n.<br>
inpatient n.住院病人</p>
<p>compatible adj.兼容的；能共处的<br>
com-共同 + -pat- 忍受 – 相互忍受 – 兼容<br>
compatibly adv.<br>
compatibility n. 兼容性<br>
incompatible adj.<br>
incompatibly adv.<br>
incompatibility n.</p>
<p>pathetic adj. 可怜的<br>
-path- + -et + -ic = -etic 复合形容词后缀<br>
pathetically adv.<br>
antipathetic adj. 格格不入的，怀有反感的<br>
anti-反 + -path- 感觉 --反感<br>
antipathy n. 反感<br>
apathy n. 冷漠，无兴趣<br>
a- 远离 + -path- --没有感觉<br>
apathetic adj.</p>
<p>sympathy n. 同情<br>
-sym- 共同 + -path- 感受<br>
sympathize vi.<br>
sympathizer n. 同情者<br>
sympathetic adj. 同情的<br>
sympathetically adv.<br>
unsympathetic adj.<br>
parasympathetic adj. 副交感的 n.<br>
para- 旁边 – 副职</p>
<p>pathology n. 病理学<br>
path- 痛苦 + -o- + -logy 名词后缀，表……学科<br>
pathologist n.<br>
pathologic adj.<br>
pathological adj.<br>
pathologically adv.<br>
non-pathological adj.<br>
histopathology n. 组织病理学<br>
-hist- 组织 + -o-<br>
histopathologic adj.<br>
histopathological adj.<br>
psychopathology n. 精神病理学<br>
-psych-精神<br>
psychopathological adj.</p>
<p>passion n. 激情<br>
passional adj.<br>
passionless adj. 不热情的<br>
passionate adj. 热情的<br>
passionately adv.</p>
<p>compassion n. 同情<br>
com- 共同 + -pass- 痛苦 + -ion<br>
compassionate adj. 慈悲的 v.<br>
compassionately adv.</p>
<p>dispassion n. 冷静；公平<br>
dis- 不，使相反 + passion 激情 --没有激情–冷静–公平<br>
dispassionate adj. 不带感情的<br>
dispassionately adv.</p>
<p>impassible adj. 不觉得痛苦的<br>
im-否定 + -pass- 痛苦 + -ible 能……的<br>
impassion vt. 使激动<br>
im- 使动（这里不表否定）。<br>
特别提示：当前缀in- = im- = en- = em- 表使动，通常会改变原单词词性，改为动词<br>
impassioned adj.<br>
impassive adj. 冷漠的<br>
im- 否定<br>
impassively adv. 无感情的<br>
impassivity n. 平静</p>
<p>empathy n. 同感<br>
em- 进入，使动 + -path 感情<br>
empathic adj. 移情作用的<br>
empathize vt.<br>
empathetic adj.<br>
empathetically adv.</p>
<p>psychopath n. 精神病患者<br>
psych- 精神，心理 + -o- + -path- 疾病 – 精神疾病<br>
psychopathy n.精神病<br>
psychopathic adj. 精神病的</p>
<p>homeopath n. 同种疗法医师<br>
-home- 同心（圆） – 一致的<br>
homeopathy n. 同种疗法<br>
homeopathic adj.</p>
<p>telepath n. 心灵感应<br>
-tele- 远的 + -path-<br>
telepathy n. 心灵感应<br>
telepathic adj. 心灵感应术的<br>
telepathically adv.</p>
<p>pathogen n. 病原体<br>
pah- + -o- + -gen 产生，原，词源同antigen<br>
pathogenic adj. 病原的<br>
pathogenicity n. 致病性<br>
pathogenetic adj. 发病的<br>
pathogenesis n. 发病原理<br>
-esis = -asis 医学名词后缀</p>
<p>osteopath n. 整骨疗法家<br>
-osteo- 骨的 + -path- 病痛，治疗<br>
osteopathic adj.</p>
<p>naturopath n. 理疗家<br>
naturo 自然<br>
naturopathic adj.</p>
<p>sociopath n. 反社会的人<br>
-soci- 陪伴–群居–社会 + -o- +  -path 疾病<br>
sociopathic adj.</p>
<p>pathos n. 痛苦<br>
pathophysiology n. 病理生理学<br>
-path- 病 + -o- + physiology 生理学 = physi- 物质，身体–物理 + -o- + -logy<br>
pathognomonic adj. 特殊病征的 能确定诊断的<br>
gnomon 诊断<br>
encephalopathy n. 【内科】 脑病<br>
en- 进入 + -cephal- 头 + -o- + -path-<br>
lymphadenopathy n. 【内科】淋巴结病	<br>
lymphaden n. 淋巴结<br>
cardiomyopathy n. 心肌症<br>
-card- 心 + -io- + -my- 肌肉 + -o- + -path<br>
retinopathy n.视网膜病<br>
retin- 视网膜<br>
adenopathy n. 腺病<br>
aden- 腺<br>
nephropathy n. 肾病<br>
-nephr- 肾<br>
allelopathy n. 【植物】 植化相克 相互影响<br>
-allel- 植物<br>
allopathic adj. 对抗疗法的<br>
idiopathic adj. 先天的<br>
-idio- 自己，自发 – 先天 + -path- --先天疾病的</p>
<h2 id="strain-strict-stress-string-strang-to-draw-tight-拉紧">-strain- = -strict- = -stress- = string= = -strang- to draw tight 拉紧</h2>
<p>strict adj. 严格的<br>
strictly adv.<br>
stricture n. 苛责；非难<br>
strict + -ure<br>
strictness n.严格</p>
<p>restrict vt. 限制<br>
向后拉紧–限制<br>
restriction n. 限制<br>
restricted adj.<br>
unrestricted adj. 自由的<br>
restrictive adj.<br>
restrictively adv.<br>
restrictiveness n. 限制性</p>
<p>district n. 地区；行政区<br>
dis- 分–分开束缚–分开管理–行政区<br>
district-wide adj.<br>
district-based adj.<br>
district-level n.</p>
<p>redistrict vt. 重新划区<br>
redistricting n. 重新划区</p>
<p>constrict vt. 压缩，拉紧<br>
con- 强调<br>
constriction n.<br>
constrictor n. 括约肌 使压缩之物 大蟒<br>
constricted adj.<br>
constrictive adj. 紧缩的<br>
vasoconstriction n. 血管收缩<br>
-vaso- 血管<br>
vasoconstrictional adj.</p>
<h1>第25节课</h1>
<p>string n. 线<br>
stinger n.<br>
string + -er 表物或人<br>
stringy adj. 绳的<br>
stringent adj. 紧缩的，严格的<br>
stringently adv.<br>
stringency n. 严格<br>
stringed adj. 有弦的<br>
astringent adj. 收敛性的 止血的 严厉的<br>
a- 远离 + -string- 线 – 拖拽 --收敛<br>
hamstring n. 腿筋<br>
-ham- 腿<br>
shoestring n. 鞋带<br>
drawstring n. 细绳 拉带<br>
draw 拖拽<br>
bowstring n.<br>
bow 弓<br>
superstring n. 超弦<br>
no-strings adj. 不附带任何条件的<br>
string 限制–条件<br>
first-string adj. 第一流的</p>
<p>stress n. 压力 紧张 vt.<br>
stressful adj.<br>
stressor n. 紧张性刺激<br>
stressed adj.<br>
mistress n. 情妇 女主人<br>
反盗版 和stress 没有关系<br>
-mast- = -mist- 掌控 + -ress = -ess 名词后缀 表女性<br>
stressed-out adj. 不堪重负的<br>
stress-free adj. 无压力的<br>
high-stress n.<br>
seamstress n. 女裁缝师<br>
反盗版 seamster 裁缝<br>
-seam- 织布 缝纫 + -ster 名词后缀<br>
-er 改为 -ress<br>
songstress n. 女歌手<br>
songster n. 歌手<br>
overstress vt. 过分强调 过分拉紧<br>
unstressed adj. 不强调的<br>
low-stress n.</p>
<p>distress n. 危难 不幸 贫困 悲痛 vt.<br>
dis- 分开 + -stress- 拉，拉紧 – 分开来 --失去，分离，扯碎<br>
distressful adj.<br>
distressed adj.<br>
distressing adj. 使痛苦的<br>
distressingly adv.</p>
<p>strain n. 张力 拉紧 负担 vi. vt.<br>
strained adj. 紧张的<br>
straining n. 变形<br>
strainer n. 过滤器 松紧扣</p>
<p>constrain n. 约束<br>
con- 共同 + -strain- 束缚<br>
constrained adj.<br>
unconstrained adj.</p>
<p>restrain vt. 抑制，控制<br>
re- 往回 + -strain- – 往回拉 – 抑制<br>
restraint n. 抑制<br>
re- 往回 + -straint-<br>
restraining adj. 抑制的<br>
restrained ad.<br>
unrestrained adj.<br>
self-restraint n. 自制<br>
eyestrain n. 眼睛疲劳<br>
eye 眼睛 + strain 紧绷</p>
<p>strange adj. adv.<br>
strangely adv.<br>
stranger n.<br>
strangeness n. 陌生<br>
strangle  vt. 把……勒死<br>
strang- 拉，勒 + -le 动词后缀<br>
strangled adj. 卡住的<br>
strangler n. 压制者<br>
stranglehold n. 束缚；勒紧<br>
strangulation n. 【医学】 勒杀</p>
<p>estrange vt. 使疏远<br>
estranged adj.<br>
estrangement n. 疏远</p>
<h2 id="vac-vacu-van-void-vain-空">-vac- = -vacu- = -van- = -void- = -vain- 空</h2>
<p>vac n. 休假 真空吸尘器<br>
vac 是 vacation 的缩写、<br>
vacate vi. vt. 空出 搬出<br>
vacation n. 假期 搬出 vi. 休假，度假<br>
vacationist n. 度假者<br>
vacationer n.</p>
<p>vacuum n. 真空 空间 adj. 真空的<br>
-vacu- + -um 名词后缀<br>
vacuumize vt. 抽成真空；真空包装<br>
vacuuming n. 真空处理<br>
vacuum-packed adj.<br>
vacuum-sealed adj.<br>
evacuate vt. 撤退<br>
e- 出，向外 + -vacu- 空<br>
evacuation n.<br>
evacuated adj.<br>
evacuee n. 被疏散的人员</p>
<p>vacant adj. 空虚的<br>
vac- + -ant<br>
vacantly adv.<br>
vacancy n.<br>
vacuous adj.<br>
vacuity n.</p>
<p>vanity n. 空虚 虚荣心<br>
-van-空–虚假<br>
vanish vi. vt.消失<br>
vanishing adj.<br>
vanishingly adv.<br>
evanish vi. 消失<br>
e- 出，向外 + -van- 空 + -ish<br>
evanesce vi. 消散，逐渐看不见<br>
e- + -van- + -esce- 动词后缀<br>
evanescence n.<br>
evanescent adj.</p>
<p>void adj. 空的；无效的 n. vt.<br>
one often meets his destiney on the road he takes to avoid it<br>
子欲避之，反促遇之<br>
voided adj. 有空间的 废弃的<br>
avoid vt. 避免<br>
a- 远离 + -void- 空 – 避开<br>
avoidance n.<br>
avoidable adj.<br>
unavoidable adj.<br>
unavoidably adv.<br>
devoid adj. 缺乏的<br>
de- 分</p>
<p>vain adj. 徒劳的 自负的<br>
vainly adv. 徒劳地<br>
vainglorious adj. 虚荣心强的<br>
vain 虚无的 glory 荣耀</p>
<h2 id="ple-t-plet-pli-ply-plen-to-fill-full-装满的">-ple(t)- = -plet- = -pli- = -ply- = -plen-  to fill,full 装满的</h2>
<p>complete adj. 完整的；完全的 vt.完成<br>
com- 强调 + -plet- 满 + -e 动词后缀，此处也表形容词含义<br>
completely adv.<br>
completeness n.<br>
completed adj.<br>
completion n. 完成，结束<br>
completer adj. 更完备的<br>
incomplete adj.<br>
incompleteness n.<br>
incompletely adv.<br>
uncompleted adj.<br>
incompletion n.</p>
<p>deplete vt. 用光，耗尽<br>
de- 不，非，使相反<br>
depletion n.<br>
depleted adj.<br>
ozone-depleting adj.<br>
ozone n. 臭氧</p>
<p>replete adj. 充满的<br>
re- 再次<br>
expletive adj. 附加的<br>
ex- 向外的 + -plet- 满 --溢出–附加</p>
<p>accomplish vt. 实现<br>
ac- 强调 + com- 共同<br>
accomplished adj.<br>
accomplishment n.</p>
<p>compliment vt. 赞美，夸奖<br>
com- 强调 + -pli- 充满 + -ment --充满（敬意）<br>
complimentary adj.<br>
uncomplimentary<br>
compliant adj. 顺从的 服从的<br>
com-强调 + -pli- 满 + -ant<br>
nocompliance n. 不顺从</p>
<p>complement n. 补充 vt.<br>
complementary adj.</p>
<h2 id="第26节课">第26节课</h2>
<p>implement vt. 实施<br>
im- 进入，使 + -ple- 满的，<br>
implementation n.<br>
implementer n.</p>
<p>complement n. 补语；余角 vt.<br>
com- 强调<br>
complementary adj.<br>
complementarity n. 互补性 补充</p>
<p>supply n. 供给 vt. vi.<br>
sup- 下 + -ply- 充满<br>
supplement n.<br>
supplemental adj.</p>
<p>plenty n. adj.<br>
plen- + -ty 名词后缀。引申出形容词和副词的含义<br>
plentiful adj. 丰富的<br>
plentifully adv.<br>
aplenty adv. adj. n. 丰富的<br>
a- 强调</p>
<p>replenish vt. 补充，再装满<br>
replenishment n.<br>
replenished adj.</p>
<p>plenary adj. 充分的；全体出席的 n.<br>
plen- + -ary<br>
plenitude n.<br>
-plen- + -itude<br>
plenum n. 全体会议 充满<br>
-plen- + -um<br>
plena n. 满<br>
plen + -a 集合名词后缀<br>
comply vi. 遵守 顺从<br>
com- 强调 + -ply- 装满 – 满足 – 顺从，答应<br>
non-complying n.</p>
<p>plethora n. 过多</p>
<h2 id="medi-中间">-medi- 中间</h2>
<p>media n. 媒介 媒体<br>
multimedia n. 多媒体 adj.<br>
media-savvy adj. 对媒体熟悉的<br>
savvy n. 理解能力 vt. 理解<br>
mass-media n. 大众传媒</p>
<p>immediate adj. 立即的<br>
im- 不 + -medi- 中间 + -ate --没有中间环节的<br>
immediately adv.<br>
immediacy n.<br>
median n. 中位值 adj.<br>
medial adj. 中间的 平均的<br>
medially adv.<br>
mediacy n. 调解 中间状态</p>
<p>mediate vi vt. 调解 斡旋<br>
mediator n.<br>
mediation n.<br>
mediational adj.<br>
unmediated adj. 无中介的<br>
computer-mediated adj.</p>
<p>medium adj. 中间的 中等的 n. 方法 媒介<br>
medium-high adj. 中高的<br>
medium-size n.<br>
medium-sized adj.</p>
<p>mediate<br>
meditate vt. 考虑 vi. 冥想<br>
-medit- 思考 + -ate<br>
meditator n.<br>
meditation n.<br>
meditative adj. 冥想的 沉思的<br>
meditatively adv.<br>
premeditated adj. 预谋的<br>
pre- 在前<br>
premeditation n.<br>
unpremeditated adj.</p>
<p>medieval adj. 中世纪的<br>
medi- 中间 + -ev- 时期，年代 --中世纪<br>
medievalist n.<br>
medievalism n. 中世纪精神</p>
<p>mediterranean adj. 地中的 被陆地包围的<br>
medi-中间的 + -terr- 土地 + -anean 形容词后缀 = -an<br>
Mediterranean n. 地中海<br>
intermediate adj. 中级的 中等程度的<br>
inter- 在……之间<br>
intermediary adj.<br>
intermediation n.</p>
<p>mediocre adj. 普通的；平凡的；中等的<br>
-medi- + -ocre-<br>
mediocrity n. 平常 平庸之才<br>
meddle vi. 管闲事<br>
meddling n. 干预；瞎管<br>
mediastinal adj. 纵隔的<br>
-medi- 中间 + -a- + -stin- 站 --立于其中–间隔 + -al<br>
mediastinum n. 纵隔膜</p>
<p>medieval adj. 中世纪的<br>
hypermedia n. 超媒体<br>
hyper- = super-<br>
mixed-media n. 综合材料</p>
<h2 id="preci-prais-pric-priz-价值">-preci- = -prais- = -pric- = -priz- 价值</h2>
<p>precious adj.<br>
-preci- + -ous 形容词后缀，充满<br>
preciously adv.<br>
preciousness n.<br>
semiprecious adj. 次珍贵的<br>
semi- 半 – 未达到<br>
precious-metals n. 贵重金属</p>
<p>appreciate vt. 欣赏<br>
ap- 强调 + -preci- 价值 – 欣赏<br>
appreciator<br>
appreciation n.<br>
appreciative adj.<br>
appreciatively adv. 明显地<br>
unappreciative<br>
unappreciated adj.<br>
underappreciated adj. 未受到充分赏识的<br>
under-下 – 未达到<br>
depreciate vt. 使贬值 vi.<br>
de- 向下，减少 + -preci-<br>
depreciation n. 跌价<br>
depreciatory adj. 跌价的</p>
<p>praise n. 赞扬 vt.<br>
appraise vt. 票价<br>
ap- 强调<br>
appraiser n.<br>
appraisal n. 评估<br>
reappraise vt.<br>
reappraisal vt.<br>
praiseworthy adj. 值得称赞的<br>
much-praised adj. 倍受赞扬的</p>
<p>price n. 价格 价值 vt. 给……定价<br>
pricy adj. 价格高的<br>
pricey adj. 高价的<br>
priced adj. 有价格的<br>
pricing n. 定价<br>
priceless adj. 无价的 极贵重的<br>
price + -less 否定</p>
<p>overprice vt. 对……定价过高<br>
overpriced adj.<br>
underprice<br>
price-tag n.价格标签<br>
high-price n.<br>
high-priced adj.<br>
highest-price</p>
<p>price-fixing n. 价格规定<br>
bride-price n. 彩礼<br>
off-price adj. 价格优惠的<br>
share-price n. 股价</p>
<p>prize n. 奖品 vt. 珍视<br>
prized adj. 被看作最重要的<br>
prizefight n. 职业拳击赛<br>
prizefighter n.<br>
prize-winning adj. 获奖的</p>
<h2 id="miss-mit-投，送，发">-miss- = -mit- 投，送，发</h2>
<p>admit vt. vi.<br>
ad- 去，往 + -mit- 发送，送出 – 允许进出 – 同意，认可<br>
admitted adj. 公认的<br>
admittedly adv. 公认地<br>
admittance n. 进入；入场权<br>
admission n. 承认 入场费<br>
admissible adj. 可容许的<br>
admissibility n. 可容许<br>
inadmissible adj. 不许可的<br>
readmit vt. 重新接纳<br>
readmission n. 重新接纳<br>
self-admitted adj.</p>
<h1>第27节课</h1>
<p>commit vt. 犯罪，把……交托给<br>
com- 强调 + -mit- 发送 – 派遣<br>
commited adj. 坚定的 效忠的<br>
committee n. 委员会<br>
commit(t) 承担义务 + -ee 表被动 – 被委托<br>
commitment n.<br>
subcommittee n. 小组委员会<br>
uncommmitted adj. 不受约束的 犯罪未遂的<br>
committal n. 委托<br>
= commitment<br>
noncommittally adv. 不明确地<br>
committeeman n. 委员<br>
recommit vt. 再犯 再委托<br>
recommitment n. 再犯；再交付委员会审议<br>
commission n. 委员会，佣金 委任 vt.<br>
commissioner n. 理事 委员 行政长官<br>
commissioned adj. 受委任的 受任命的<br>
commissar n. 政委 委员 代表<br>
-ar 表人<br>
commissary n. 代表 杂货店<br>
commissioning n. 试车<br>
noncommissioned adj. 未经任命的<br>
decommission vt. 使……退役<br>
de- 分 – 去除<br>
decommissioning n. 退役<br>
decommissioned adj. 退役的<br>
commissariat n. 粮食 粮食补给<br>
commissar + -i- + -at 名词后缀<br>
sub-commission n. 委员会所属分会</p>
<p>permit n. 执照 许可证<br>
permittee n. 持证人<br>
permission n. 许可<br>
permitted adj. 被允许的<br>
permissible adj. 可允许的<br>
permissibility n. 允许；可容许性<br>
permissive adj. 许可的<br>
permission + -ive<br>
permissiveness n.<br>
impermissible adj.<br>
impermissibly adv.</p>
<p>dismiss vt. 解散<br>
dis- 分开 + -miss- 送出<br>
dismissed adj. 解雇的<br>
dismissal n. 解雇；免职<br>
dismission n. 开除<br>
dismissive adj. 解雇的 表示轻视的<br>
dismissively adv.</p>
<p>submit vt. 呈递 主张 使服从 vt. 提交 服从<br>
sub- 再下 + -mit- 送出<br>
submission n. 投降 提交（物） 服从 意见<br>
submissive adj. 顺从的<br>
submissiveness n. 柔顺 服从<br>
submissively adv.</p>
<p>missile n. 导弹 投射物 adj.<br>
-miss- 送 + -ile 名词后缀<br>
missive n. 公文 信件 adj. 送出的<br>
miss- 发送-- 发送的事物<br>
mission n. 使命，任务 代表团<br>
missionary adj. 传教的 传教士的 n. 传教士<br>
missionize vi. vt. 传教<br>
anti-missile adj.<br>
ballistic-missile n. 弹道导弹<br>
ball 此处翻译为子弹<br>
ball + -ist + -ic<br>
guided-missile n.</p>
<p>manumit vt. 解放 释放<br>
manu- 手 + -mit- 送<br>
manumission n. 释放</p>
<p>omit vt. 省略；遗漏<br>
o(b)- 离开 + -mit- 送，派 – 放走<br>
omitted adj. 省略了的<br>
omission n. 疏忽 省略<br>
transmit vt. 传输 传播 发射 vi. 传输<br>
trans- 横过 + -mit- 送，派 – 送过去 --传输<br>
transmission n. 传动转置 变速器 传递<br>
transmitter n. 传送者 发射机<br>
transmissible adj. 能传送的<br>
transmissibility n. 传递性<br>
transmitted adj. 透射的<br>
transmitting n. 传达<br>
transmittal n. 传输 传送<br>
-al 名词后缀<br>
transmittance n. 【光】透射比<br>
retransmit vt. 传播 再次发送<br>
re- 再次<br>
transmission-line n. 传输线</p>
<p>emit vt. 散发<br>
e- 向外<br>
emitted adj. 射出的<br>
emitter n. 发射器<br>
emission n. 发射<br>
emissary n. 使者 间谍<br>
-ary 名词或形容词<br>
emissive adj. 发射的 放射性的<br>
emissivity n. 【物】发射率<br>
emission-line n. 【光】 发射谱线</p>
<p>intermit vt. 使中断 vi. 中断<br>
inter- 在内，在中间，相互 + -mit- 送走<br>
intermission n.<br>
intermittent adj. 间歇的<br>
intermittently adv.<br>
intermittency n. 间歇性</p>
<p>remit vt. 宽恕 免除 减轻 传送<br>
re- 往回 + -mit- --发送回–送回–收回<br>
remittance n. 汇款<br>
remittee n. 收款人<br>
unremitting adj. 不懈的<br>
unremittingly adv.</p>
<p>immit vt. 引入，注入<br>
im- 向内<br>
immission n.</p>
<p>promise vt.<br>
pro- 往前<br>
promissory adj. 约定的；允诺的</p>
<p>compromise vt. 妥协<br>
共同承诺–妥协<br>
commissary n. 代表 杂货店<br>
com- 强调 + -miss- 发送 --送粮食</p>
<p>remiss adj. 怠慢的<br>
remit 的变体<br>
remission n. 宽恕<br>
resubmit vt. 重发<br>
submittal n. 提交 建议<br>
-al 名词后缀<br>
missal n. 弥撒书<br>
missiology n. 传教学<br>
-miss- 送–传教 + -io- + -logy<br>
near-miss n. 靠近弹</p>
<h1>第28节课</h1>
<h2 id="sci-知">-sci- 知</h2>
<p>scient adj. 有知识的<br>
science n.<br>
sciential adj. 知识的<br>
scientist n.<br>
scientism n. 科学态度；科学至上主义<br>
scient + -ism 名词后缀，表……主义<br>
scientific adj. 科学的<br>
scient + -i- + -fy- + -ic 形容词后缀<br>
scientifically adv.<br>
unscientific adj. 不科学的<br>
nonscientific adj. 非科学的<br>
sci-fi adj. 科幻的<br>
-sci- -fi- = -fict- 做–虚构 = fiction 虚构，小说<br>
geoscience n. 地球科学<br>
-geo- 大地 – 地球<br>
quasi-scientific adj. 准科学的；拟科学的<br>
quasi- 相似<br>
non-science n. 非科学<br>
political-science n. 政治学<br>
political adj. = -polit- 城市–管理–政治<br>
pre-scientific adj. 近代科学出现以前的<br>
anti-science n.<br>
anti-scientific adj.<br>
pseudoscience n. 假科学<br>
pseudo- 假<br>
pseudo-science</p>
<p>conscious adj. 意识到的<br>
con- 强调 + -sci-<br>
consciously<br>
consciousness n.<br>
unconscious adj.<br>
unconsciously adv.<br>
subconscious adj. 潜意识的<br>
subconsciously adv.</p>
<p>conscience n. 良心<br>
conscientious adj. 认真的；本着良心的<br>
consci- + -ent + -i- + -ous<br>
conscientiously adv.<br>
conscientiousness n. 尽责</p>
<p>conscienceless adj. 没良心的<br>
unconscionable adj. 不合理的 昧着良心的<br>
unconsciousness n. 无意识<br>
unconscionably adv. 不合理地<br>
consciousness-raising n. 增强自我意识感<br>
stream-of-consciousness adj. 意识流的<br>
self-conscious adj. 自觉地<br>
self-consciously adv.<br>
self- consciousness n.<br>
health-consicous adj. 重视健康的<br>
cost-conscious adj. 注重节省成本的<br>
semi-conscious adj. 半意识的<br>
unself-conscious adj. 不装腔作势的<br>
unselfconsciously adv.<br>
race-conscious adj.<br>
eco-conscious adj. 生态意识的<br>
non-conscious adj. 潜意识的 非意识的</p>
<p>omniscient adj. 全知的<br>
-omni- 全，总<br>
omniscience n.</p>
<p>prescience n. 预知<br>
prescient adj.<br>
presciently adv.</p>
<p>nescient adj. 无知的<br>
ne- = neg- 否定 + scient<br>
nescience n. 无知</p>
<h2 id="liter-文字">-liter- 文字</h2>
<p>【引申】 字母/文字/识字/有文化/文学</p>
<p>literate adj. 受过教育的 n. 学者<br>
liter- 文字 – 识字 – 受过教育 + -ate 形容词后缀<br>
illiterate adj. 文盲的<br>
literature n. 文学 文献<br>
literator n. 文学家 作家<br>
litera + -or<br>
writer<br>
author<br>
alliteration n. 头韵<br>
al- 强调 + -liter-<br>
alliterative adj.<br>
literati n. 文人 文学界<br>
literate + -i = -a 集合名词后缀<br>
semiliterate adj. 半识字的<br>
preliterate adj. 文字出现以前的<br>
pre- 在前<br>
non-literate adj. 无文字的<br>
obliterate vt. 消除<br>
ob- 反–去除<br>
obliteration n.<br>
literary adj. 文学的 书面的<br>
-liter- 文字–文学 + -ary<br>
literarily adv.<br>
literariness n. 文学性；文艺性</p>
<p>literacy n. 识字 有学问 有文化<br>
illiteracy n.<br>
literal adj. 文字的<br>
literally adv.<br>
literalism n. 彻底写实主义<br>
-ism 表……主义<br>
literalness n. 文字，字义上<br>
literalize vt. 拘泥于字句<br>
anti-illiteracy n.扫除文盲<br>
uniliteral adj. 单字母的<br>
-un- 单一 + -i- + -liter- 文字 – 单一个字母 + -al 形容词后缀<br>
biliteral adj. 两个字母（组成）的<br>
triliteral adj.<br>
transliteral n. 按照字母直译<br>
trans- 改变 + -liter- 文字 --翻译<br>
transliteration n. 按字母直译</p>
<h2 id="sum-sumpt-最高-总-拿">-sum- = -sumpt- 最高 总 拿</h2>
<p>sum n. vt. vi. 总结<br>
summa n. 总结 总结性论文<br>
summary adj. n.<br>
summarily adv.<br>
summation n. 和<br>
summative adj. 总结的<br>
summarize vt. 总结 概述 vi. 作总结<br>
summarization n.</p>
<p>consume vt. 消耗 vi.<br>
con- 强调 + -sum- 拿–消费 消耗<br>
consumer n.<br>
consuming n. 消费</p>
<h1>第29节课</h1>
<p>consumed adj. 充满的<br>
consumable adj. 可消耗的 n. 消费品<br>
consumerism n. 用户至上主义<br>
consummate adj. 至上的 完美的 vt.完成<br>
consum(m) + -ate 形容词或动词后缀<br>
consummation n. 圆满成功<br>
consummatory adj. 使完成的；完成性的<br>
consummately adv. 至上地 完成地<br>
unconsummated adj. 未实现地<br>
all-consuming adj. 全身心投入的<br>
pro-consumer adj. 维护消费者权益的<br>
pro- 往前 – 维护</p>
<p>consumption n. 消费<br>
consumptive adj. 消耗性的 浪费的<br>
overconsumption n.<br>
nonconsumptive adj. 不消耗自然资源的</p>
<p>presume vt. 假定；推测<br>
pre- 在前，早于，预先 + -sum- 承担，认为 – 预先认为 --假设 + -e 动词后缀<br>
presumed adj.<br>
presumable adj. 可推测的<br>
presumably adv. 大概地<br>
presumption n. 推测，放肆，傲慢<br>
认为–揣测–过度猜测–傲慢<br>
presumptive adj. 假定的<br>
presumptively adv.<br>
presumptuous adj. 放肆的</p>
<p>sumpter n. 拉货的马 赶车的人<br>
-sumpt- 承担 --运输 + -er<br>
sumptuary adj. 限制费用的 禁止奢侈的<br>
-sumpt- 拿 --阻止–禁止<br>
sumptuous adj. 华丽的<br>
-sumpt- 消耗–奢靡–华丽<br>
sumptuously adv.</p>
<p>subsume vt. 把……归入；把……包括在内<br>
sub- 在下，向上 + -sum- 承担 拿起  + -e 动词后缀<br>
subsumption n.</p>
<p>assume vi. 假定 设想 承担 采取 vt. 篡夺 侵占<br>
as- 强调 + -sum- 认为 -<br>
assumed adj.<br>
assumption n.<br>
unassuming adj. 谦逊的 不出风头的<br>
reassume vt. 再假定</p>
<p>resume n. 摘要 简历 vt. 重新开始 继续 恢复<br>
re- 再次 + -sum- 拿 – 摘选 – 摘要 总结 + -e 名词或动词<br>
一般地，动词或名词（形容词）一体化的单词，如果重读在前，则为名词或形容词含义，如果 	  重读在中间则为动词含义。<br>
resumption n.</p>
<p>summon vt. 召唤；召集；鼓起；振作<br>
sum- = sub- 在下 + -mon- 警告<br>
summons n. 召唤；传票 vt. 唤出；传到<br>
summoning n. 召唤<br>
summiteer n. 峰会参加者<br>
-sum- 拿 – 参与 + -mit- 出发 + -eer = -er<br>
summitry n. 最高级会议的举行<br>
zero-sum adj. 零和的<br>
lump-sum adj. 一次总付的<br>
lump n. 块</p>
<h2 id="spect-speci-spec-spi-spy-to-look-to-see-看">-spect- = -speci- = -spec- = -spi- = -spy- to look,to see 看</h2>
<p>前缀特别学习：<br>
ex- 向外； in- 向内； re- 再次，反复，多次；trans- 通过，改变<br>
变异：trans- = tra- / tro-</p>
<ol>
<li>ex- + tra- / tro- = extra-/extro- 向外【表抽象含义】</li>
<li>in- + tra- / tro- = intra-/intro- 向内【表抽象含义】</li>
<li>re- + tra- / tro- = retra-/retro- 往回【表抽象含义】</li>
</ol>
<p>respect vt. 尊重 n.<br>
re- 再 + -spect- 看 – 重视<br>
respecter  n. 尊重<br>
-er 名后缀<br>
respectable adj.<br>
respectability n.<br>
respectably adv. 体面地<br>
respectful adj.<br>
respected adj. 被动<br>
respecting prep. 鉴于<br>
respective adj. 分别的 各自的<br>
respectively adv.<br>
irrepective adj. 无关的<br>
ir-<br>
disrepect n.<br>
disrepected adj.<br>
disrepectful adj.<br>
disrepectfully<br>
self-respect n.<br>
well-respected adj.<br>
self-respecting adj.</p>
<p>retrospect n. 回顾，回看 vt. vi.<br>
retrospection n.<br>
retrospective adj.<br>
retrospectively adv. 回顾地</p>
<p>prospect n. 视野<br>
pro- 往前<br>
prospective adj. 盼望中的<br>
prospector n. 采矿者<br>
prospectus n. 内容说明书<br>
prospecting n. 探矿<br>
bioprospecting n. 生物勘探</p>
<p>suspect vt. 怀疑<br>
sus- 从下向上不信任地看<br>
特殊情况，特殊对待<br>
Desperate times,desperate measures<br>
de- 分–否定，无，失去 + -sper- 希望 + -ate 形容词后缀<br>
suspectable adj. 可疑的<br>
suspected adj. 被动<br>
unsuspected adj.<br>
unsuspecting adj. 不怀疑的 adv.<br>
suspicion n. 怀疑<br>
sus- + -spic- + -ion<br>
suspicious adj. 可疑的<br>
suspiciously<br>
suspiciousness n.<br>
suspicious-looking n. 形迹可疑</p>
<p>perspective adj. 透视的<br>
per- 完全，贯穿 + -spect- --看透–透视<br>
perspectival adj. 透视法的<br>
perspective-taking n.</p>
<p>inspect vt. 检查<br>
inspection n.<br>
inspector n.<br>
inspectorate n. 检察员<br>
-ate 名词后缀，可以将-ate 视为 -ation 的缩写形式<br>
introspect v. 内省【抽象】<br>
introspective adj.</p>
<p>expect vt. 期望，预料<br>
ex- 向外<br>
expectation n. 期望 【数学】 期望值<br>
expectancy n. 期待 期望的东西<br>
expectant adj. 期待的 n. 【数学】 期望值<br>
expectantly adv.<br>
expected adj. 期待中的<br>
expectedly adv.<br>
expectable adj.<br>
unexpected adj.<br>
unexpectedly adv.<br>
unexpectedness n. 出乎意料<br>
long-expected adj.<br>
expectancy-value n. 期望价值</p>
<p>aspect n. 方面；面貌；方位，方向；形势<br>
原本是一个天文学术语，表示星体的相对位置。</p>
<p>circumspect adj. 谨慎的<br>
-circum- 圈，周围 + spect-<br>
conspectus n. 一览表 大纲<br>
con- 在一起 --放在一起看 + -u- + -s 复数名词<br>
conspicuous adj. 明显的<br>
con- 强调<br>
inconspicuous adj.</p>
<p>spectate vi. 出席观看<br>
-spect- 看–观赏–观看 + -ate<br>
spectator n. 旁观者<br>
spectatorial adj. 能吸引观众的<br>
special adj. n.<br>
spec- 看 – 特别 – 多看一眼<br>
specially adv. 特别地<br>
speciality n. 特性<br>
specialness n. 专门，特殊<br>
specialist n.<br>
specialize vi. 专门从事<br>
specialization n. 专门化</p>
<p>especial adj. 特别的<br>
e- 向外 – 强调 + special<br>
especially adv.<br>
specialty n. 专业，专长；特点 adj. 特色的<br>
subspecialty n. 附属专业<br>
special-order n. 特别指令<br>
special-interest adj. 小众化的 特殊兴趣的<br>
extra-special adj. 特别号外的</p>
<p>specify vt. 指定 vi.<br>
-spec- 看 – 特指，特定，特别关注 + -i- + -fy 动词后缀<br>
specific adj. 明确的<br>
specificity n. 特异性<br>
specifically adv.<br>
specification n. 规格；说明书<br>
unspecific adj.<br>
unspecified adj.<br>
intraspecific adj. 【生物】 种内的<br>
intra- 向内 + specific<br>
specifiable adj. 可指明的<br>
non-specific adj. 不明确的<br>
site-specific n. 特定场地<br>
context-specific adj. 上下文特定的<br>
contry-specific adj.<br>
discipline-specific adj. 特定专业的；特定学科的<br>
discipline 纪律<br>
pre-specified adj. 预先设定的<br>
tissue-specific adj. 组织特异的</p>
<h1>第30节课</h1>
<p>spectacle n. 奇观，（复）眼镜<br>
-spect- 看–景观，景象 + -acle 名词后缀<br>
spectacled adj. 戴了眼镜的<br>
spectacular adj. 壮观的<br>
-acle + -ar = -acel + -ar = -acul + -ar = -acular<br>
spectacularly adv.<br>
unspectacular adj.<br>
bespectacled adj. 戴眼镜的</p>
<p>spec n. 投机；说明书；细则<br>
speculate vt. 思索 猜测 推测<br>
speculator n. 投机商人 思辩者<br>
speculative adj.<br>
speculatively adv.</p>
<p>speculum n. 金属镜；反射镜<br>
-spect- 看 – 镜子 + -ul + -um 名词后缀<br>
specular adj. 镜的；用窥器检查的</p>
<p>spcie n. 硬币<br>
-speci- 看–分类–种类–硬币 + -e 名词后缀<br>
species n. 物种 种类 adj. 物种上的<br>
-spec- 种 + -i- + -es<br>
speciate vi. 形成物种<br>
speciation n. 物种形成<br>
subspecies n. 亚种<br>
species-rich adj.<br>
cross-species n. 跨种<br>
endangered-species n.</p>
<p>spectrum n. 光谱 图谱</p>
<p>broad-spectrum adj.</p>
<p>spectre n. 幽灵<br>
-spect- 看 – 显现（幽灵） + -re = -er<br>
spectral adj. 光谱的 幽灵的<br>
centre + -al = central<br>
center + -al = central<br>
spectrometer n. 【光】 分光仪<br>
-meter- 测量<br>
spectroscopy n. 【光】 光谱学<br>
-scop- 镜<br>
telescope 望远镜 -tele- 远<br>
microscope<br>
spectroscope n. 分光镜<br>
spectroscopic adj.<br>
spectroscopist n. 光谱学家<br>
spectrograph n. 光谱仪<br>
-graph- 写 – 对光谱的记录<br>
spectrographic adj. 光谱的<br>
spectrometry n. 光谱测定法<br>
-metr- = -meter- + -y<br>
multispctral adj. 多谱线的<br>
spectrophotometer n. 分光光度计<br>
-spectr- 光 + -o- + -phot- 光 + -o- + -meter-</p>
<p>spite n. 不顾；恶意；怨恨 vt. 刁难<br>
de- 否定 + -spit- --低看，厌恶–恶意<br>
despite 的缩写。</p>
<h1>第31节课</h1>
<p>despite prep. 尽管 n. 轻视；憎恨<br>
despise vt. 轻视，鄙视<br>
de- 向下 否定<br>
despicable adj. 卑劣的<br>
可轻视的–卑劣的<br>
despised adj.</p>
<p>spice n. 香料 情趣 vt. 加香料于<br>
-spic- 看 --分别–区分–种类 + -e<br>
auspice n. 赞助 主办 吉兆<br>
au- = eu- 好 + -spic- 看 – 好的现象 – 吉兆 + -e<br>
auspicious adj. 吉兆的 好运的<br>
auspiciously<br>
inauspicious adj. 不祥的<br>
perspicacious adj. 有洞察力的<br>
per- 贯穿 + -spic- + -ac- 尖–眼尖 + -ous<br>
perspicacity n. 洞察力<br>
-ty<br>
perspicuity n. （语言）清晰；简明<br>
+ -u- + -ity<br>
perspiculous adj. 清晰的</p>
<p>conspecific ad. 同种的<br>
con- 在一起<br>
spy vt. 侦察；暗中监视 vi. n.<br>
spying n.<br>
spyware n. 间谍软件<br>
spyglass n. 小望远镜<br>
spymaster n.</p>
<p>espy vt. 看到；认出<br>
e- 向外 + -spy- 看  – 向外看 – 看到<br>
anti-spyware n.<br>
specious adj. 外表美丽的 华而不实的<br>
-speci- 看<br>
对英语单词的理解必须建立在实际应用的语境上。<br>
You deserve it! 这是你应得的！/ 你活该！【看语境】<br>
speciman n. 样品，样本，标本<br>
-speci- 种类 – 样本 + -men 名词<br>
respite n. 缓解 vt. 使缓解<br>
re- 再次 + -spit- 看 – 往回看 – 回顾 – 暂缓</p>
<h2 id="vis-vid-看">-vis- = -vid- 看</h2>
<p>visit vt. vi.<br>
-vis- 看 + -it- 走<br>
vistor n.<br>
visiting n. adj.<br>
visitable adj.<br>
visitation n. 访问<br>
revisit vt. 重游</p>
<p>advise vt. 通知，建议 vi.<br>
ad- 临近<br>
adviser n.<br>
advisor n.<br>
advisory adj.<br>
advisable adj. 明智的<br>
advised adj. 明智的<br>
advisedly adv. 经过考虑地<br>
inadvisable adj.<br>
advisability n. 明智；可劝性<br>
advisement n. 深思熟虑<br>
advisee n.<br>
-ee 名词后缀，表被动<br>
well-advised adj.<br>
ill-advised adj.<br>
advice n. 意见</p>
<p>revise vt. 修订 vi. n.<br>
re- 再 + -vis- 看见 – 反复看 – 校对<br>
revised adj.<br>
revision n.<br>
revisionist n. 修正主义者<br>
revisionism n. 修正主义<br>
revisionary adj. 修正的</p>
<p>visible adj.<br>
visibly adv.<br>
invisible adj.<br>
invisibly adv.<br>
visible-light n. 可见光</p>
<p>visual adj. 视觉的 看得见的 光学的 n. 画面 图像<br>
visuals n. 图形部分<br>
-s 名词后缀<br>
visually adv.<br>
visualize vt. 设想<br>
visualized adj.直观的<br>
visualization n. 形象化<br>
nonvisual adj. 非视觉的<br>
visuality n. 可视化<br>
audio-visual adj. 视听的</p>
<p>supervise vt. 监视<br>
super- 上，超过<br>
supervising n.<br>
supervised adj.<br>
supervisor n.<br>
supervision n.<br>
supervisory adj.</p>
<p>previse vt. 预见<br>
pre- 在前<br>
prevision n.</p>
<p>televise vt. 由电视播放<br>
-tele- 远 + -vis- 看见 – 远距离传输 + -e<br>
现代凡是电子通讯有关的单词，均由-tele- 远 构成<br>
television n. 电视<br>
televisual adj. 电视的</p>
<h1>第32节课</h1>
<p>provide vt. 提供，供给<br>
pro- 提前 + -vid- 看 – 提前看 – 预期，提前做好准别 + -e 动词后缀<br>
provider n.<br>
provided conj. 假如<br>
providing conj. 假如</p>
<pre><code>2级核心词：在1级核心词的基础上进行含义和语境的引申
</code></pre>
<p>proviso n. 附带条件<br>
pro- 提前 + -vis- 看 – 预先做好 – 条款 + -o 动词后缀<br>
provision n. 规定，条款<br>
provisional adj. 临时的<br>
provisionally adv.<br>
provisioning n. 准备金提取<br>
providence n. 天意；深谋远虑<br>
提前准备–深谋远虑<br>
provident adj. 有远见的；节俭的<br>
提前准备–有远见<br>
improvident adj.<br>
im- 否定<br>
providential adj. 幸运的</p>
<p>improvise vt. vi. 即兴创作<br>
im- 否定 – 未准备 – 即兴创作<br>
improviser n.<br>
improvised adj.<br>
improvisation n.<br>
improvisational adj.<br>
improvisatory adj.</p>
<p>evident adj. 明显的，明白的<br>
e- 出 + -vid- 看见 --能够看见的–明显的 + -ent 形容词后缀<br>
evidence n.<br>
evidently adv.<br>
evidential adj. 证据的<br>
evidentially adv.<br>
evidentiary adj. 证据的<br>
self-evident adj. 不言自喻的<br>
evidence-based adj.</p>
<p>video n. 磁带录像 vt. 录像 adj.<br>
-vid- + -eo 名词或动词后缀<br>
videophone n. 可视电话<br>
videocast n. 电视广播<br>
videotape n. 录像带<br>
videotaping n. 进行录像<br>
videocassette n.<br>
videodisc n. 影碟<br>
videocamera n.<br>
videocam n.<br>
缩写<br>
video-game n.<br>
video-based adj.<br>
home-video n.<br>
music-video n.</p>
<p>visa n. 签证 vt.<br>
-vis- 看 + -a 集合名词后缀<br>
vision n. 视力 视觉 vt.<br>
visionary adj. 空想的，幻想的，预见性的<br>
night-vision n.<br>
low-vision n.<br>
visage n. 外观<br>
-vis- 看 + -age 名词后缀，表地点（抽象）<br>
vista n. 远景；展望<br>
-vist- 看 – 展望 + -a 名词后缀<br>
visor n. 遮阳板;面甲<br>
-vis- 看–面罩（遮脸）+ -or<br>
visuospatial adj. 视觉空间的<br>
-vis- + -u- + -o- + -spat- = space 空间 + -i- + -al 形容词后缀<br>
invidious adj. 诽谤的 不公平的<br>
in- 否定 + -vid- 看 – 不能看 – 不忍直视<br>
invidiously adv. 惹人怨恨地<br>
envision vt. 想象</p>
<p>envisage vt. 正视，面对；想象<br>
en- 使动 + -vis- 看 – 正视<br>
view n. 看法；风景<br>
viewer n.<br>
viewing adj. 可见的 n.<br>
viewpoint n. 观点<br>
viewable adj.<br>
viewport n. 视口，观察孔<br>
-port- 拿，点 – 可看的点 – 观察孔<br>
viewfinder n. 取景器<br>
viewscreen n. 离心式扫雨器</p>
<p>interview vt. vi<br>
interviewer n.<br>
interviewee n.</p>
<p>review n. 复习；评论<br>
re- 反复 + view<br>
reviewer n. 评论者<br>
reviewing n.<br>
reviewable adj. 可回顾的<br>
well-reviewed adj. 充分复习的<br>
peer-review n. 同行评审</p>
<p>preview n. 预演 试映 预告片 vt.<br>
pre- 在前 + -view- 看<br>
overview n. 综述；概观<br>
worldview n. 世界观<br>
rearview n. 后视镜<br>
rear adj. 后面的<br>
purview n. 范围，权限<br>
pur-  = per- 完全 + view 看<br>
pay-per-view adj. 按次计费的<br>
point-of-view n. 观点<br>
side-view n.<br>
ocean-view adj. 面朝海的</p>
<p>survey n. 调查 测量 审视<br>
sur- = super- 上 + -vey- = -vid- 看 – 从上看-- 监督<br>
surveyor n.<br>
surveying n. 测量 考察<br>
purvey vi. vt. 供应<br>
pur- 完全<br>
purveyor n. 承包商<br>
resurvey n.<br>
surveillance n. 监督<br>
survey(y变i) + -ill + -ance</p>
<p>voyeur n. vi. 窥淫<br>
voyeurism n. 窥阴癖者<br>
voyeuristic adj.</p>
<p>clairvoyant n. 千里眼 adj. 透视的<br>
-clair- 清楚<br>
clairvoyance n.</p>
<h2 id="seri-重要">-seri- 重要</h2>
<p>serious adj.<br>
seriously<br>
seriousness<br>
unserious<br>
nonserious adj.<br>
half-serious adj.<br>
serious-minded adj.<br>
mind 思想 – 思想上严肃的–认真的<br>
serious-looking adj.&amp;n.<br>
severe adj. 艰难的,艰巨的</p>
<h2 id="lat-拿，持，带来，搬运，担负">-lat- 拿，持，带来，搬运，担负</h2>
<p>relate vt. 讲述  vi. 产生共鸣<br>
re- 反复 + -lat- 拿 – 反复拿 – 关联 –  联系 + -e 动词后缀</p>
<h1>第33节课</h1>
<p>related adj.<br>
unrelated ajd.<br>
relation n.<br>
relational adj.<br>
relationality n. 关联性<br>
relationship n.<br>
relative adj. 相关的 n. 亲属<br>
relativity n. 相关性，【物】相对论<br>
relativist n. 相对主义者</p>
<p>relatively adv. 相对地<br>
relativism n. 相对主义 相对论<br>
relativistic adj. 相对的<br>
relatedness n. 关联性<br>
relativize vt. 使相对化<br>
relatable adj. 有关系的<br>
relatedly adv.<br>
nonrelativistic adj. 非相对论性的<br>
relator n. 叙述者 原告</p>
<p>interrelate v. 相互关联<br>
inter- 在……之间，互相<br>
interrelation  n.<br>
interrelated adj.<br>
interrelationship n.<br>
interrelatedness n. 相互关联性</p>
<p>correlate vi. 关联 vt. 使有相互关系<br>
cor- 在一起<br>
correlation n.<br>
correlational adj.<br>
correlative adj. n. 关联词<br>
correlated adj. 有相互关系的<br>
uncorrelated adj.</p>
<p>autocorrelation n. 【数】 自相关<br>
intercorrelation n. 组间相关</p>
<p>collate vt. 核对 校对<br>
col- 在一起 + -lat- 拿 – 拿到一起 – 校对，比对 + -e<br>
collator n.<br>
-or 表人或物<br>
collation n. 校对;斋日的点心；牧师职务</p>
<p>translate vt. 翻译<br>
trans- 改变 + -lat- 拿 – 转变 – 翻译<br>
translator n.<br>
translation n.<br>
translational adj. 平移的<br>
translative adj. 翻译的；转移的<br>
translatable adj. 可翻译的<br>
untranslatable<br>
untranslated adj. 未翻译的<br>
mistranslation n.</p>
<p>illation n. 演绎<br>
il- 强调 + -lat- 拿 – 推导 – 推演<br>
illative adj.</p>
<p>ablate vt. 使脱落 切除<br>
ab- 远离 + -lat- 拿<br>
ablation n.<br>
ablative adj.</p>
<p>dilate vt. 使扩大；使膨胀 vi.<br>
dilator n. 扩张器<br>
di- 分 + -lat- 拿 – 分开拿 – 扩张<br>
dilated adj. 扩大的<br>
dilatory adj. 拖拉的；缓慢的<br>
dilitate adj. 膨胀的<br>
dilatation n. 扩张</p>
<p>vasodilation n. 血管舒张<br>
-vaso- 血管<br>
oblate adj. 扁圆的；扁平的；奉为神圣的<br>
ob- 强调 + -lat- 拿 – 奉献 – 献身<br>
oblation n. 祭品，奉献品</p>
<p>ventilate vt. 使通风；公开<br>
-vent-风 + -i- + -lat- 拿 – 通风 + -ate<br>
ventilation<br>
ventilator n. 通风设备 负责通风的人</p>
<p>superlative adj. 最高级的；过度的 n.<br>
super- 在上，超过 + -lat- 拿 – 上级，高级 + -ive<br>
prelate n. 高级教士<br>
pre- 在前</p>
<p>legislate vt. 立法<br>
-legis- 法 + -lat- 建立 + -e<br>
legislation n.<br>
legislative adj.<br>
legislature n. 立法机关<br>
legislator n.</p>
<p>sex-related adj.</p>
<h2 id="lax-松弛，放松">-lax- 松弛，放松</h2>
<p>lax n. 松元音 泻肚 adj. 松的 不严谨的<br>
laxity n.<br>
laxative n. 泻药 adj. 通便的<br>
relax v. 使放松<br>
re- 强调<br>
relaxed adj.<br>
relaxing adj.<br>
relaxer n.<br>
relaxant n. 松弛药 adj.<br>
relaxation n.</p>
<h2 id="sim-sem-simil-simul-sembl-相似">-sim- = -sem- = -simil- = -simul- = -sembl- 相似</h2>
<p>similar adj. 类似的 n.<br>
simil- + -ar<br>
similarly adv.<br>
simliarity n.<br>
dissimilar adj.<br>
dis- 否定<br>
dissimilarity n.<br>
dissimilate v. 使变得不同<br>
dis- 否定<br>
dissimilation n.<br>
dissimilitude n.</p>
<p>similitude n.<br>
simulate v.<br>
simulation n.<br>
simulator n.<br>
simulated adj. 模仿的<br>
dissimulate vi. vt. 掩饰 假装<br>
dis- 否定<br>
dissimulatin n.<br>
computer-simulated adj.</p>
<p>assimilate vi. vt. 理解，使吸收<br>
as- 强调 + similate – 使相似 – 同化，吸收<br>
assimilation n.<br>
assimilator n. 同化者，吸收者<br>
assimilative adj.</p>
<p>simultaneity n. 同时性，同时发生<br>
-simul- 相似 + -tane- = time<br>
simultaneous adj.<br>
simultaneously adv.</p>
<p>facsimile n. 副本，传真<br>
-fac- 做 + -simil- – 做一个相似的东西<br>
verisimilar adj. 似乎是真的<br>
-veri- 真<br>
verisimilitude n. 逼真</p>
<p>simple adj. n.<br>
-sim- 相似 + -ple- 折叠 – 相似的折叠 – 简化 – 简单<br>
simply adv. 简单地<br>
simplify vt. 简化<br>
simplified adj. 简化了的</p>
<p>simplist n. 主张过分简单化的人<br>
simple + -ist 名词后缀，含有形容词最高级的含义<br>
simplistic adj. 过分简单化的<br>
simplification n. 简单化<br>
simplistically adv. 过分简单化地<br>
oversimplify vt. 使……过分地单纯化<br>
simple-minded adj. 头脑简单的</p>
<p>resembel vt. 与……相似<br>
re- 再次–强调 + -sembl- 相似 + -e 动词后缀<br>
resemblance n. 类似<br>
resemblant adj. 相似的；摹仿的</p>
<p>seminar n. 讨论课<br>
-semin- = -semil- 相似 – 共同 --一起研究，讨论 + -ar 名词后缀<br>
semblable adj. 外表的 相似的 n. 类似<br>
-able 形容词后缀<br>
semblance n. 外貌；假装；类似<br>
-sembl- 相似 + -ance<br>
assemblage n. 装配；集合；聚集<br>
as- 强调 + -sembl- 相似 – 集合，聚集 – 装配 + -age 名词后缀<br>
dissemble vt. 掩饰，掩盖，假装 vi. 掩饰<br>
dis- 否定 + -sembl- 相似 – 去除相似的地方 – 掩饰 + -e 动词后缀<br>
dissembler n. 伪君子</p>
<p>assemble vt. 集合，聚集，装配 vi. 集合<br>
as- 强调 + -semle- 相似 – 共同 – 聚集 + -e<br>
assembly n. 装配<br>
assembled adj. 组合的；安装的<br>
assembler n. 汇编程序<br>
assembling n. 装配<br>
assemblyman n. 议员</p>
<h1>第34节课</h1>
<p>reassemble vi. vt. 重新装配<br>
re- 再次–重新 + assemble<br>
reassembly n. 重新组装</p>
<p>disassemble vt. 拆开<br>
dis- 分 – 拆分<br>
disassembled adj. 拆开的<br>
disassembly n.</p>
<p>subassembly n. 组件，部件<br>
unassembled adj. 未装配的<br>
pre-assembled adj. 预先安装的<br>
pre- 在前 – 提前<br>
self-assembly n. 自组装 adj.<br>
simile n. 明喻<br>
-simil- 相似 – 比喻<br>
simulcast v. 同时联播 n. 同时联播<br>
simulacrum n. 像；幻影<br>
-simul- 相似 + -acrum- 影 – 幻影<br>
ensemble n. 全体 adv. 同时<br>
en- 使动 + -sembl- 共同 --形成共同体 – 全体 + -e</p>
<p>symbol n. 象征；标志；符号 vt.<br>
-sym- 相似 + -bol- 扔，投掷<br>
symbolic adj. 象征性的<br>
symbolically adv.<br>
symbolist n. 象征主义者</p>
<p>symbolism n. 象征主义<br>
symbolize vt. 象征<br>
symbolization n. 象征<br>
symbology n. 象征学<br>
-logy 表……学</p>
<p>symphony n. 交响乐；交响曲<br>
-sym- 相似 – 共同+ -phon- 声音 + -y<br>
symphonic adj.</p>
<p>symptom n. 症状<br>
-sym- + -pt- 降落 – 出现的相似征兆 --症状 + -om = -um<br>
symptomless adj. 无症状的<br>
symptomatic adj. 有症状的<br>
asymptomatic adj. 无症状的<br>
a- 远离 – 否定<br>
symptomology n. 症候学<br>
symptomatology n.<br>
同上<br>
symptomatically adv. 有症状地<br>
symptom-free n. 无症状</p>
<p>symmetry n. 对称<br>
-sym- 一起 + -metry- = -meter-  测量 – 相等的测量 – 对称<br>
asymmetry n. 不对称<br>
a- 否定<br>
symmetrical adj. 匀称的<br>
asymmetrical adj.<br>
a- 否定<br>
symmetric adj.<br>
同上<br>
asymmetric adj.<br>
symmetrically adv.<br>
asymmetrically adv.</p>
<p>supersymmetry n. 【物理】超对称性<br>
supersymmetric adj.<br>
axisymmetric adj. 轴对称的<br>
-ax- 棍棒 – 轴承 + -i-</p>
<p>symbiote n.共生生物<br>
-sym- 共同 + -bi(o)- 生–生物 + -ote 名词后缀<br>
symbiont n. 【生态】 共生者；共生有机体<br>
-ont = -ant = -ent 名词后缀<br>
symbiosis n. 【生态】 共生；合作关系<br>
-osis = -asis 专有医学名词后缀<br>
symbiotic adj. 共生的<br>
-ote + -ic 形容词后缀<br>
symbiotically adv. 共生地</p>
<p>symposium n. 讨论会，座谈会，酒宴<br>
sym + posis (喝酒)<br>
古希腊人饭后 ，和朋友们一边喝酒，一边高谈阔论。<br>
synonym n. 同义词<br>
-syn- 相似 + -onym- 名字，含义，词源同 name,antonym。 --相同的名字<br>
sympatric adj. 在同一地区生存的<br>
sym + -patr- 父亲<br>
asympotic adj. 渐进的；渐进线的<br>
a-否定 + -sym- 相似 --接近 + -ptot- 坠落 – 无限靠近</p>
<h2 id="discip-法则">-discip- 法则</h2>
<p>disciple n. 门徒<br>
-discip- 法则，教学 – 被教育的人，守规矩的人 – 信徒，弟子<br>
discipline n. 纪律<br>
disciple 法则 + line 界限 – 法则的界限 – 纪律<br>
disciplinary adj. 规律的<br>
disciplined adj. 遵守纪律的</p>
<p>disciplinarian n. 厉行纪律的人<br>
discipleship n. 门徒的身份</p>
<p>indiscipline n. 无纪律<br>
interdisciplinary adj. 跨学科的<br>
inter- 在……之间<br>
multidisciplinary adj. 有关各种学问的<br>
undisciplined adj. 无训练的</p>
<p>transdisciplinary adj. 跨学科的 学科间的<br>
trans- 通过 – 跨<br>
discipline-based adj. 学科为基础<br>
self-discipline n. 自律<br>
self-disciplined adj.<br>
cross-disciplinary adj. 跨学科的<br>
well-disciplined adj. 训练有素的</p>
<h2 id="helic-旋">-helic- 旋</h2>
<p>helicopter n. 直升机、<br>
-helic- 螺旋 + -opter- 翼<br>
chop v. 切碎 【口语中：快点】<br>
chopper n. &lt;俚&gt; 直升机<br>
heliport n. 直升机飞机场<br>
-port- 拿 – 进出，起降<br>
helilift v. 用直升飞机运输<br>
lift v. 举起 n. 电梯<br>
helical adj. 螺旋状的<br>
helicity n. 螺旋性<br>
helicoid adj.<br>
同上<br>
helicoidal n. adj.<br>
helicograph n. 螺旋规<br>
-graph- 写，画<br>
helix n. 螺旋<br>
-helic- = -helix-</p>
<h2 id="cept-cap-capt-ceiv-ceit-cip-cup-拿，抓">-cept- = -cap- = -capt- = -ceiv- = -ceit- = -cip- = -cup- 拿，抓</h2>
<p>accept vt. vi. 承认，承担，承兑<br>
ac- 强调 + -cept- 拿 – 接受 – 承认，同意<br>
accpted adj.<br>
accptor n. 【金融】 承兑人<br>
acceptance n. 接受<br>
acceptable adj.<br>
acceptably adv.<br>
acceptability n. 可接受性<br>
unacceptable adj.<br>
unacceptably adv.<br>
unacceptability n.<br>
well-accepted adj.<br>
self-acceptance n.</p>
<p>except vt. 把……除外 prep. conj. 除非<br>
ex- 向外 + -cept-<br>
exception n. 例外；反对；【法律】反对<br>
exceptive adj.<br>
exceptional adj. 特殊的</p>
<h1>第35节课</h1>
<p>exceptionally adv.<br>
exceptionality n. 例外<br>
excepting prep. 除……之外 conj. 只是<br>
unexceptional adj.<br>
unexceptionable adj. 无懈可击的<br>
un- 否定 + exception + -able --没有例外的</p>
<p>concept n. 概念；观念<br>
con- 强调 + -cept- 抓住 – 理解<br>
conception n. 概念；开始；怀孕<br>
misconception n. 误解<br>
conceptual adj. 观念的<br>
conceptually adv.<br>
conceptualize vt. 使概念化<br>
conceptualization n. 概念化<br>
conceptualist n. 概念论者 adj. 概念论的<br>
-ist 名词后缀，表人；形容词含义来自最高级-ist<br>
conceptualism n. 概念论<br>
reconceptualization n. 概念论<br>
self-concept n. 自我概念<br>
preconception n. 偏见，先入之见<br>
pre- 在前 conception 概念–认知<br>
high-concept adj. 高级复杂的<br>
high 高的–高级–复杂 + concept<br>
proof-of-concept n. 概念证明阶段<br>
a of b 翻译成 b的a</p>
<p>recept n. 感受<br>
re-往回 + -cept- 拿 – 拿回来 – 接受–感觉<br>
reception n. 招待会<br>
receptionist n. 接待员<br>
receptor n. 受体，接收器<br>
receptive adj. 善于接受的；能容纳的<br>
unreceptive adj.<br>
receptivity n. 接受能力；【生理】感受性<br>
receptiveness n.<br>
同上<br>
receptacle n. 【植物】花托；容器<br>
recept + -acle 名词后缀<br>
photoreceptor n. 【生理】 光感受器<br>
-phot- 光</p>
<p>incept vt. 接受，摄取；开始 vi. 获得学位，就职<br>
in- 往里 + -cept- – 往里拿 – 植入<br>
inception n.</p>
<p>percept n. 认知，认知的对象<br>
per- 完全 + -cept- 拿–理解 – 完全认知<br>
perception n. 理解，认识<br>
perceptual adj. 感知的<br>
perceptually adv. 视觉上地<br>
perceptive adj. 感知的<br>
perceptively adv.<br>
perceptiveness n. 洞察力<br>
perceptible adj. 可察觉的<br>
perceptibly adv.<br>
imperceptible adj.<br>
imperceptibly adv.<br>
misperception n. 误解<br>
apperception n. 【心理】明觉<br>
ap- 强调<br>
self-perception n. 自我知觉</p>
<p>intercept vt. 拦截，拦住 n.<br>
inter 在……之间 + -cept- 拿 – 中间拿 – 截断，阻拦<br>
interception n.<br>
intercepter n. 截击机<br>
interceptor n.</p>
<p>deception n. 欺骗<br>
de- 向下，离开 + -cept- 拿 – 拿走 – 欺瞒，欺诈<br>
deceptive adj.<br>
deceptively adv.<br>
self-deception n. 自欺欺人<br>
self-deceptive adj.</p>
<p>precept n. 规则 格言 命令<br>
pre- 在前 + -cept- 拿，握 – 事先立好的规矩<br>
preceptor n. 校长；教师；指导医师</p>
<p>特别提示：下面三个单词很像-cept- ，但事实不是<br>
contracept vt. 使避孕<br>
contra- 相对，相反 + -ception- 孕育 – 避免孕育<br>
contraception n.<br>
contraceptive adj.  n. 避孕用品</p>
<p>proprioceptive adj. 本体感受的<br>
-proper- = -propr- 只有<br>
proprioception n.</p>
<p>capture vt. 捕获 n.<br>
-capt- = -cept- 拿 + -ure<br>
captor n.<br>
caption n. 标题 逮捕 vt.<br>
-capt- 抓–吸引眼球–标注，提示，说明<br>
-ion 名词后缀。但是有时候会名词动词化<br>
captive adj. 被俘虏的 被迷住的 n. 俘虏，迷恋者<br>
captivity n. 囚禁<br>
captivate vt. 迷住<br>
captivation n. 魅力 着迷<br>
captivator n. 有吸引力的人<br>
captivating adj. 迷人的</p>
<p>recapture vt. 夺回 n. 夺回<br>
re- 往回<br>
captive-bred n. 圈养繁殖<br>
captive-breeding n.</p>
<p>capable adj. 能干的<br>
-cap- 拿–夺取–承担，胜任–能干<br>
capanly adv.<br>
incapable adj.<br>
capacity n. 能力<br>
incapacity n.<br>
capacitive adj. 【电】 电容<br>
capability n. 才能，能力<br>
capacitor n.【电】 电容器，电容<br>
capacitance n. 【电】 电容<br>
capacious adj.广阔的，容积大的<br>
incapacitate vt. 使无能力<br>
incapacitated adj. 不能行动的<br>
incapacitating vt. 使无能力<br>
-ing 现在分词<br>
incapacitation n. 无能力<br>
high-capacity n. 高容量<br>
overcapacity n. 生产能力过剩<br>
nuclear-capable adj. 可携带核武器的<br>
large-capacity n. 大容量</p>
<h1>第36节课</h1>
<p>特解：<strong>语境的多少</strong>决定了单词对应中文含义的多少<br>
capsule n. 小容器 植物的荚 胶囊 太空舱 adj. 压缩的 vt. 压缩<br>
-cap- 拿，取 --caps 盒子 + -ule = -le 小<br>
capsular adj.<br>
encapsulate vt. 压缩；将……封入内部；将……装入胶囊 vi.<br>
en- 使动 + capsule + -ate<br>
encapsulation n.<br>
encapsulated adj.</p>
<p>perceive v. 意识到；察觉<br>
per- 完全 + -ceiv- 接受 + -e – 完全接受–感知<br>
perceivable adj. 可知觉的<br>
perceived adj. 感知到的<br>
perceiving n. 感知<br>
perceiver n. 感知者<br>
self-perceived adj. 自我感知的<br>
misperceive vt. 误解<br>
unperceived adj. 未被察觉的</p>
<p>conceive vt. 构思；以为；怀孕<br>
con- 强调 + -ceiv- 抓住 理解 --组合，构成 ±e<br>
conceivable adj. 可能的；想得到的<br>
conceivably adv. 令人信服地；可相信地；想得到地<br>
重要地事情说三遍<br>
1. 中文的单词只能说明这个英语单词可能出现的语境，并不能束缚单词的使用<br>
2. 中文的单词只能说明这个英语单词可能出现的语境，并不能束缚单词的使用<br>
3. 中文的单词只能说明这个英语单词可能出现的语境，并不能束缚单词的使用</p>
<p>inconceivable adj. 不可思议的<br>
inconceivably adv.<br>
misconceive vt. 误解 vi. 产生误解<br>
misconceived adj.<br>
preconceived adj. 预想的<br>
pre- 在前<br>
ill-conceived adj. 构想拙劣的<br>
well-conceived adj.</p>
<p>receive vt. 受理；欢迎；承受 vi. 接到，获得<br>
re-往回 + -ceiv- 拿–拿回来–接受，获得 + -e 动词后缀<br>
receiver  n.<br>
-er<br>
receiving adj. 接受的 n. 接受<br>
received adj. 被一般接受的；被认为标准的<br>
receivable adj. 可接受的；可信的 n. 应收账款<br>
receivership n. 【经管】破产管理<br>
well-received adj. 受到欢迎的</p>
<p>deceive v. 欺骗<br>
de- 向下 + -ceiv- 拿 + -e 动词后缀。<br>
deceiver n. 骗子<br>
deceived adj. 被欺骗的</p>
<p>emancipate vt. 解放；解脱（疑虑，偏见）<br>
e- 向外 + -man- 手 + -cip- 抓 – 用手拿出去–解脱<br>
emancipation n.<br>
emanciptator n.<br>
emancipatory adj.</p>
<p>cassette n. 盒式录影带<br>
-cap- + -cass- 盒 + -ette 小<br>
showcase n. 玻璃柜台，玻璃陈列柜<br>
-case- 盒</p>
<p>occupy vt. 占领，使用，住在……<br>
oc- 向前，朝向 + -cup- 抓 – 占有 + -y<br>
occupation n. 占有；职业<br>
occupational adj.<br>
occupant n. 居住者，占有者<br>
occupancy n. 占有<br>
occupier n. 居住人；占有者<br>
occupied adj.<br>
unoccupied adj. 空的<br>
reoccupy vt. 再占领，收复,使再从事<br>
reoccupation n.<br>
preoccupy vt. 迷住<br>
pre- 在前 + occupy 占领–占据注意力<br>
preoccupied adj.<br>
preoccupation n. 全神贯注</p>
<p>Israeli-occupied adj. 以色列占有的</p>
<p>recipe n. 食谱<br>
re- 强调<br>
recipient n. 容器，接收者 adj. 容易接受的</p>
<h1>第37节课</h1>
<p>recuperate vi. 恢复<br>
re- + -cup- 拿 – 重新拿到，重新获得 + -er + -ate<br>
recuperation n.<br>
recuperator n.<br>
recuperable adj. 可以复原的<br>
recuperative adj. 恢复的</p>
<p>sceptical adj. 怀疑的<br>
sceptic n. 怀疑论者</p>
<p>deceit n. 欺骗<br>
deceitful adj.</p>
<p>conceit n. 自负；幻想；思想 v.<br>
con- 强调，在一起 --拿在一起–构建，思想<br>
词源同conceive,concept。<br>
conceited adj. 自负的；幻想的</p>
<p>anticipate vt. 预期<br>
anti- 前 + -cip- 拿 – 提前拿到<br>
anti- = ante- 反；前<br>
anticipation<br>
anticipated adj.<br>
anticipatory adj.<br>
unanticipated adj.<br>
much-anticipated adj.</p>
<p>transceiver n.【通信】 收发器<br>
trans- 通过 + -ceiv- 拿 + -e<br>
municipal adj. 市政的<br>
-mun- 城市 + -i- + -cip- 拿 – 统治，管理 + -al 形容词后缀<br>
municipality n. 市民；市政当局<br>
municipally adv.</p>
<p>incipient adj. 初期的<br>
in-向内 + -cip- 拿，取 + -i- + -ent --最初引入–起初<br>
initial adj. 初始的<br>
in-向内 + -it- 走 --向内走–进入–初始 + -i- + -al</p>
<p>cupidity n. 贪心<br>
小爱神丘比特 （Cupid）<br>
cup- 拿–占有–贪婪</p>
<p>concupiscence n. 强烈的邪欲<br>
con- 强调 + -cup</p>
<h2 id="sert-放置，结合">-sert- 放置，结合</h2>
<p>desert n. 沙漠 adj.<br>
de- 分–分离–远离–遗弃 + -sert- 放置<br>
dessert n. 甜点<br>
desertification n. 沙漠化<br>
desert + -ification<br>
deserted adj.<br>
deserter n. 逃兵<br>
desertion n.<br>
desert-like adj. 荒凉的<br>
like 像……的</p>
<p>insert vt. 插入 n.<br>
in- 向内<br>
insertion n.<br>
inserted adj.<br>
reinsert vt. 重新插入<br>
reinsertion</p>
<p>assert vt. 维护，坚持；断言<br>
as- 强调 + -sert<br>
asserted adj. 宣称的<br>
assertion n.<br>
assertive adj. 肯定的；独断的<br>
assertiveness n. 魄力<br>
assertively adv. 独断地</p>
<p>self-assertion n. 自作主张<br>
self-assertive adj.</p>
<p>reassert<br>
reassertion n. 再主张</p>
<p>unassertive adj. 谦逊的<br>
non-assertive adj. 同上</p>
<p>dissertaion n. 论文，专题<br>
dis-分 + -sert- 放置 – 分置–专有–专题<br>
series n. 系列<br>
-seri- 连结 + -es<br>
exert vt. 运用，发挥<br>
ex- 向外 + sert</p>
<h2 id="duct-duc-引导">-duct- = -duc- 引导</h2>
<p>-duct- n. adj.<br>
-duc-  v.</p>
<p>produce vt. 制造，出示，引起  n. 产品，农产品<br>
pro- 向前 + -duc- 引导 – 向前引导–产生<br>
producer n.<br>
producing adj. 生产的 n.<br>
特别说明：如果-ing结尾的单词去除ing后是动词，那么在之后的情况下，-ing都可默认动词的现在分词或动名词形式。<br>
produced adj.</p>
<p>product n. 产品；结果；作品<br>
production n. 产量<br>
productive adj. 富有成效的<br>
productively adv.<br>
productivity n. 生产力，生成率</p>
<p>reproduce vt. 复制，重现，繁殖<br>
re- 再次 --再生产<br>
reproduction n.<br>
reproductive adj.<br>
reproducible adj. 可再生的；可繁殖的<br>
reproducibility n. 重复能力<br>
reproduced adj. 再生的<br>
reproducer n. 复制程序；扬声器<br>
nonreproductive adj. 无生殖力的<br>
counterproductive adj. 反生产的；使达不到预取目标的<br>
counter- 反<br>
preproduction n. 试验性生产<br>
pre- 在前<br>
unproductive adj. 非生产性的<br>
un- 否定<br>
overproduce vt.<br>
overproduction n. 生产过剩<br>
by-production n. 副产品<br>
by- 旁–副<br>
mass-produced adj. 大量生产的<br>
mass- 块<br>
co-producer n. 联合制片<br>
co-production n. 合作生产</p>
<p>oil-producing adj.<br>
non-productive adj. 非生产性的</p>
<p>new-product n.<br>
pre-preduction n. 前期制作</p>
<p>writer-producer n. 编剧兼制片人<br>
revenue-producing adj. 能产生收益的</p>
<p>post-production n. （电视或电影）后期制作<br>
limited-production n.<br>
self-produced adj. 自己生产的<br>
low-productivity<br>
energy-producing adj.<br>
end-product n.最终产品<br>
insulin-producing adj. 胰岛素分泌<br>
heat-producing adj.</p>
<p>conduct vi. 导电；带领 vt. 管理；引导；表现 n. 进行<br>
conductor n. 导体，指挥<br>
misconduct n. v.<br>
mis- 错误<br>
semiconductor n. 半导体<br>
semi- 半<br>
conduce vi. 导致；有益<br>
con- 强调 + -duc- 引导 – 导致 – 贡献<br>
conduction n. 传导<br>
conducive adj. 有益的<br>
conductive adj. 传导的<br>
conductivity n. 导电性；传导性<br>
conducting adj. 【物】传导的 n. 传导，指挥<br>
conductance n. 【电】电导；导率<br>
air-conduction n.<br>
superconductor n. 超导体<br>
superconducting adj.<br>
superconductive adj.<br>
superconductivity n. 超导电性</p>
<p>educate vt. 教育<br>
e- 向外 + -duc- 引导 – 向外引导 – 引出人的潜力 --教育 + -ate<br>
education n.<br>
educational adj.<br>
educationally adv.<br>
educable adj. 可教育的<br>
educator n. 教育家<br>
educated adj. 受过教育的<br>
-ed 最早就表示动词的过去式和过去分词，因为过去分词可表被动和完成的含义<br>
所以，-ed 本身就含有被动含义。<br>
uneducated adj.</p>
<h1>第38节课</h1>
<p>educative adj. 教育的<br>
educationist n.<br>
coeducation n. 男女同校<br>
co- 在一起<br>
coeducational<br>
well-educated adj.<br>
re-educate vt.<br>
re-education n.<br>
college-educated adj.<br>
special-education n.<br>
higher-education n.<br>
psychoeducational adj. 心理学教育的<br>
-psych- 精神，心理 + -o-<br>
undereducated adj. 受教育不足的<br>
teacher-education n. 师范教育<br>
miseducation n.<br>
self-educated adj. 自学的<br>
self-education n.<br>
paraeducator n. 助教<br>
para- 旁边<br>
less-educated adj.<br>
sex-education n.<br>
public-education n.<br>
physical-educaion n. 体育课<br>
-phys- 物质 物体 身体<br>
adult-education n.<br>
continuing-education n. 继续教育<br>
con- 在一起 + -tin- 拿 – 拿到一起–连接–继续<br>
over-educate vt.<br>
university-educated adj.<br>
general-education n.</p>
<p>reduce vt. 减少<br>
re- 往回 + -duc- 引导 – 往回引导 – 减少<br>
reducer n.<br>
reduction n.<br>
reductor n.<br>
reductive adj. 还原的；减少的 n. 还原剂<br>
reducing n.<br>
reduced adj.<br>
reducible adj.<br>
reducibly adv.<br>
irreducible adj. 不能减少的<br>
irreducibly adv.<br>
reduced-fat n. 减脂<br>
reductionism n. 还原论<br>
reductionist n. 还原论者 adj. 简化的<br>
reductionistic n. 还原论；还原论者</p>
<p>deficit-reduction n. 赤字减少<br>
deficit n. 不足额，赤字<br>
de- 分–否定 + -fic- 做 --没有做完或做好–不足–亏空<br>
reduced-price n.<br>
reductase n. 【生化】还原酶<br>
reduct + -ase 生化名词<br>
stress-reduction n.<br>
risk-reducing n.</p>
<p>introduce vt. 介绍；提出；引进<br>
intro- 向内 + -duc- 引导 – 向内引导 – 引进来–介绍</p>
<p>introduced adj. 引进的<br>
introduction n.<br>
introductory adj.<br>
reintroduce vt. 再引入<br>
reintroduction n.</p>
<p>deduce vt. 推断；演绎<br>
de- 下 + -duc- 引导<br>
deduct vt. 扣除，减去；演绎<br>
deduce 的变体<br>
deduction n. 推断；演绎<br>
deduce(-duc- = -duct-) + -ion<br>
deductive adj. 演绎的<br>
deductible adj. 可扣除的；可减免的<br>
deductibility n. 可扣除程度；可演绎<br>
tax-deductible adj. 可免税的<br>
non-deductible adj. 不可扣除的</p>
<p>abduct vt. 诱拐，绑架<br>
ab- 分 + -duct- 引导 – 引导–诱拐<br>
abduction n.<br>
abductor n. 拐子<br>
abductee n. 被绑架者</p>
<p>seduce vt. 诱惑<br>
se-分<br>
seducer n.<br>
seduction n.<br>
seductive adj. 有魅力的；性感的<br>
seductively adv.<br>
seductress n. 勾引男人的女人<br>
seducer(-duc- = -duct-) + -ess<br>
-er + -ess = -ress 名词后缀，表女性<br>
seductiveness n. 富有魅力</p>
<p>induct vt. 引导；感应；使……就职 征召入伍<br>
in- 强调，往里 + -duct- 引导 – 向内引导 – 就职，入伍<br>
induce vt. 引诱，诱导<br>
inducer n. 引诱者<br>
inducement n. 引诱<br>
inductance n. 电感；感应系数<br>
induction n. 【电磁】感应<br>
inductive adj. 归纳的，感应的<br>
induced adj.感应的<br>
inductee n. 应征入伍者<br>
drug-induced adj. 药物引起的</p>
<p>educe vt. 引出<br>
e- 向外<br>
educible adj. 可引出的</p>
<p>duct n. 输送管 vt.<br>
ductwork n. 管道系统<br>
ductal adj.<br>
ductile adj. 易延展的 易教导的<br>
duct-tape n. 牛皮胶布<br>
tape 胶带 duct 表示形状<br>
ductility n. 延展性 柔软性 顺从</p>
<p>adduce vt. 举出；引证<br>
ad- 强调 + duc – 强调引出 – 举例<br>
adductor n. 内收肌<br>
adduction n.</p>
<p>transduce vt. 将从一种形态改变为另一种<br>
trans- 改变<br>
transducer n. 传感器<br>
transduction n. 转导；转换</p>
<p>aqueduct n. 导水管，引水渠<br>
-aqu- 水 + -e- + duct<br>
viaduct n. 高架桥 栈道<br>
vi 路<br>
ventiduct n. 通风管<br>
-vent- = wind</p>
<h2 id="peri-pert-试验，尝试">-peri- = -pert- 试验，尝试</h2>
<p>experience n. 经验 vt.<br>
ex- 向外 + -peri- 尝试<br>
experienced adj.<br>
inexperience n. 缺乏经验<br>
inexperienced adj.<br>
experiential adj.<br>
experience + -ent + -i- + -al<br>
experiencer n.<br>
experience-based adj.<br>
less-experience adj.</p>
<p>experiment vi. n.<br>
experimenter n.<br>
experimentation n.<br>
experimental adj.<br>
experimentally adv.<br>
experimentalist n. 实验主义者<br>
quasi-experimental adj. 类实验性的<br>
quasi- 相似<br>
experimentalism n. 经验主义<br>
nonexperimental n.<br>
pre-experimental n. 前实验</p>
<p>expert adj. 内行的 n. 专家 vt.<br>
expertly adv. 熟练地<br>
expertise n. 专门知识 专家的意见<br>
inexpert n. 生手 adj.<br>
inexpertly adv.</p>
<p>peril n. 危险，冒险 vt.<br>
-per- 尝试-- 冒险尝试 + -il 名词后缀<br>
perilously adv.<br>
imperil vt. 危及，使陷于危险<br>
im- 使动</p>
<h1>第39节课</h1>
<h2 id="scen-设置">-scen- 设置</h2>
<p>scene n. 景色；风景<br>
-scen- 设置–布局–场景–风景<br>
scenery n. 风景；景色<br>
scenic adj. 风景优美的；舞台的 n. 风景胜地<br>
scene + -ic 形容词或名词后缀<br>
scenario n. 方案；情节；剧本<br>
-scen- + -ary(i)- + -o-<br>
on-scene n. 发生事情的地点 adj. 现场的<br>
scene-stealing vi. 抢镜头<br>
anti-obscenity adj. 反淫秽的<br>
anti- 反<br>
on-the-scene adj. 现场的<br>
scenography n. 透视绘画法<br>
obscene adj. 淫秽的<br>
ob- 否定 – 令人难以目睹的场景<br>
obscenity n.<br>
obscenely adv.</p>
<h2 id="journ-一天">-journ- 一天</h2>
<p>journey n. 旅程<br>
-journ- 一天 – 一天的行程 + -e- + -y<br>
journeyman n. 熟练工人<br>
journal n. 杂志；期刊<br>
一天-周期<br>
journaling n. 日志；注册；登记<br>
journalism n. 新闻业；新闻工作<br>
journalist n. 记者<br>
journalistic adj.<br>
journalistically adv.<br>
photojournalist n. 新闻摄影记者<br>
-phot- 光 + -o- + journalist<br>
photojournalism n. 摄影报道<br>
journalize vt. 写日记，记流水账<br>
一天–日记<br>
journalese n. 新闻文体<br>
journal + -ese 名词后缀，表学术词汇<br>
adjourn vi. 休会；延期；换地方 vt. 推迟；使中止<br>
ad- 远离 + -journ- 期限 – 推迟<br>
adjournment n.<br>
sojourn n. 逗留；旅居 vi.<br>
-so- = -sol- 独自，独处 + -journ- 一天–旅程<br>
sojourner n.</p>
<h2 id="circ-cycl-圆">-circ- = -cycl- 圆</h2>
<p>circus n. 马戏团<br>
circ 圆形–圆形的舞台 + -us 名词后缀<br>
circular adj. 圆形的<br>
circularity n. 圆形性，环形性<br>
circularly adv. 循环地；圆地<br>
circulatory adj. 循环的（血液）<br>
circulation n. 循环<br>
noncircular adj. 非圆形的<br>
semicircular adj. 半圆的<br>
semi- 半<br>
circulate <a href="http://vt.vi">vt.vi</a>. 使循环；流通；流传；散布<br>
circulating adj. 循环的<br>
circulator n.<br>
mass-circulation n. 大批量发行<br>
recirculation n. 再循环<br>
recirculating adj. 再循环的<br>
recirculated adj. 再循环的</p>
<p>circle n. 圆<br>
-cirl- + -le<br>
circling n.<br>
circled adj. 包围的<br>
semicircle n. 半圆<br>
encircle vt. 包围<br>
en- 使动<br>
encircled adj.<br>
encirclement n.<br>
circlet n. 小圈，小环<br>
circle + -et 名词后缀，表小</p>
<p>circuit n. 电路，线路；巡回，唤醒 vt.<br>
-circ- 圆–环形–环路 + -u- + -it- 走<br>
circuity n. 拐弯抹角<br>
-y 名词后缀<br>
circuitry n. 电路；电路系统<br>
circuit + -ry = -ary 名词后缀<br>
circuitous adj. 迂回的<br>
-ous<br>
closed-circuit adj.<br>
short-circuited adj. 发生短路的</p>
<p>circumvent vt. 包围；智取；绕行<br>
-circ- + -um = -circum- + -vent-来 – 形成圈子<br>
circumvention n. 规避；陷害；绕行<br>
circumference n. 圆周；周长<br>
circum + -fer- 拿–环绕 + -ence<br>
circumferential adj.<br>
circumcise vt. 割包皮<br>
-circum- 圆 + -cis- 切<br>
circumcision n.<br>
uncircumcised adj.</p>
<p>circumnavigate vt. 环航<br>
-circum- + navigate = -nav- 航行 + -ig- 做 + -ate<br>
circumnavigation</p>
<p>circumpolar adj. 极地附近的 n.<br>
circum 圆–周边 + polar 极地<br>
circumstellar adj. 环绕恒星的<br>
stellar = -stell- 星星（明亮） + -ar<br>
circumlocution n. 婉转的说法，累赘的陈述<br>
locution = -loc-(-log- 语言：dialogue) -ution = -ation<br>
circumstantial adj. 与环境相关的<br>
-circum- + st 站 – 立于四周<br>
circumstantially adv.<br>
circumflex adj. 弯曲的；有声调符号的 n. 抑扬符号<br>
circum + -flex- 折叠 – 弯成圆形<br>
circadian adj. 生理节奏的<br>
circ + -ad + i + -an</p>
<p>cycle n. 循环 vi. vt.<br>
-cycl- 圆–循环，轮子，周期–时代，时间 + -e<br>
cycling n. 骑自行车<br>
cyclist n. 骑自行车的人<br>
cyclo n. 三轮人力车<br>
epicycle n. 本轮，周转圆<br>
epi- 原来，原始 + cycle<br>
bicycle n. 自行车<br>
bi- 双<br>
bicyclist n.<br>
bicycling n.<br>
tricycle n. 三轮脚踏车<br>
tricyclic adj.</p>
<p>recycle vt.<br>
recycler n.<br>
recycling n.<br>
recyclable adj.<br>
recyclability n. 再循环能力</p>
<p>unicycle n. 独轮脚踏车<br>
uni- 单一，整体<br>
autocycle n. 摩托车<br>
auto- 自己，自动、<br>
=motorbike 自己动的自行车<br>
hemicycle n. 半圆形</p>
<p>cyclic adj. 周期的 循环的<br>
cyclical adj. 周期的<br>
cyclically adv.<br>
polycyclic adj. 多轮的<br>
poly- 多 + cyclic<br>
heterocyclic adj. 杂环的<br>
heter- 多–复合–复杂 + -o- + cyclic<br>
counter-cyclical adj. 反周期的</p>
<p>cyclone n. 气旋<br>
-cycl- 圆–环形的气流 + -one</p>
<h1>第40节课</h1>
<p>encyclical n. 罗马教皇的通谕 adj. 传阅的，通谕的<br>
en- 进入，使 + -cycl- 圈 – 范围 – 通传</p>
<p>encyclopedia n. 百科全书<br>
en- 使动 + cycl- 圆 – 圈定 + -o- + -ped- 孩子 – 对孩子早期的通才教育 + -i- + -a 集合名词后缀</p>
<p>encyclopedic adj.<br>
encyclopaedia n. 百科全书<br>
多了一个a，<br>
encyclopaedic adj.</p>
<p>cyclometer n. 圆弧测定器<br>
meter 测量<br>
cyclograph n. 圆弧规<br>
-graph- 写<br>
teracycline n. 四环素<br>
（-oxy- 氧） + tetra- 四 + -cycl- 圆–环 + -ine 化学名词后缀<br>
doxycyline n. 多西环素<br>
cyclamen n. 樱草属植物<br>
cyclorama n. 圆形幻画，大风景画幕<br>
-cycl- 圆–四周 + -o- + -rama- 风景<br>
cyclotron n. 回旋加速器<br>
-cycl- + -o- + -tron 电子名词后缀（electron）<br>
cyclops n. （希腊神话）独眼巨人<br>
cycl + -ops- = -opt- 眼睛<br>
cyclopean adj. 巨大的；巨石式的 n. 乱石堆<br>
cyclop + -e- + -an</p>
<h2 id="part-分，部分">-part- 分，部分</h2>
<p>part n.部分 vt. 分离<br>
partly adv.<br>
parting n. 分手 adj.<br>
subpart n. 子部件<br>
sub- 下 - 次一级<br>
parted adj.<br>
auto-parts n. 汽车配件<br>
auto- 自动–代指汽车<br>
spare-parts n. 备用配件<br>
two-part n. 三分之二<br>
four-part adj. 四声部的<br>
partible adj. 可分的<br>
impartible adj.</p>
<p>partial adj. 局部的<br>
partially adv.<br>
partiality n. 偏心；偏袒<br>
impartial adj.<br>
impartially adv.<br>
impartiality n. 公平<br>
part-time adj.<br>
part-timer n. 兼职者<br>
partial-birth n. 半生产式<br>
birth 来源于 born<br>
-born- = -bir-;-bir- 生 + -th 名词后缀<br>
young adj. – youth<br>
party n. 聚会 政党  vi.<br>
-part- 部分–参加–聚会 + -y<br>
intraparty adj. 政党内的<br>
counterparty n. 对手方<br>
single-party n. 单身派对<br>
stag party 单身派对<br>
stag 雄鹿<br>
用于告别单身得男女均可，但是stag 指男性的单身派对</p>
<p>party-line n. 共同线；汇流；多线组<br>
party 分组组合 + line<br>
after-party n.<br>
dinner-party<br>
major-party n. 主要政党，大政党<br>
cocktail-party n. 鸡尾酒晚宴<br>
party-building n. 党的建设<br>
one-party n. 【法】 一方当事人<br>
two-party adj. 两大政党的<br>
multi-party<br>
third-party adj. 第三方的</p>
<p>particular adj. 特别的<br>
-part- 部分 – 分出 – 突出，特别 + -ic + -ul + -ar<br>
particularity n.<br>
particularly adv.<br>
particularism n.<br>
particularist n. adj.<br>
particularistic adj. 特殊主义的<br>
particularize vt. 列举；使特殊 vi.</p>
<p>partner n. 合伙人<br>
part 部分–组合–合伙 + -ner 名词后缀，表人<br>
partnership n. 合作关系，伙伴关系<br>
co-partner n. 合伙人<br>
apart adj. 分离的；与众不同的<br>
apartment n. 公寓<br>
apartness n. 冷漠</p>
<p>depart vi. 离开；出发<br>
departed adj. 过去的；死去的 n. 死者<br>
departure n. 启程<br>
department n. 大学的科、系<br>
departmental adj. 部门的<br>
departmentalism n. 分成部门<br>
department-store n. 百货公司</p>
<p>apartheid n. 种族隔离制度<br>
apart + -heid- 种族<br>
apartheid-era n. 种族隔离时代</p>
<p>participant n. 参与者；参加者<br>
part 成为一部分 + -i- + -cip- 拿 – 参与 + -ant 名词后缀，表人<br>
participial adj. 分词的 n. 分词<br>
particip 谓语一部分–分<br>
participle n. 分词<br>
participate vi vt. 参与 分享<br>
participating adj.<br>
participation n.<br>
participative adj. 分担的<br>
participatory adj. 供人分享的；吸引参与的</p>
<p>compartment n. 隔间；区划；卧车上的小客房<br>
com- 在一起 + -part- 部分 – 组在一起 – 隔间 + -ment 名词后缀<br>
compartmentalize vt. 划分，区分<br>
compartmentalization n.<br>
compartmentalized adj.</p>
<p>partition n. 划分，分开 vt. 分割<br>
partitioning n.<br>
partitioned adj. 分割的；分区的</p>
<p>particle n. 颗粒；【物】质点；极小量<br>
-part- + -icle = -able<br>
antiparticle  n. 【高能】反粒子<br>
nanoparticle n. 纳米颗粒<br>
particleboard n. 木屑板</p>
<p>partisan adj. 党派的；效忠的；偏袒的 n. 党羽<br>
party, -part- + -i- + -s- + -an<br>
partisanship n. 党派性；党派偏见；对党派的忠诚<br>
bipartisan adj. 代表两党的<br>
bi- 二<br>
bipartisanship n.</p>
<h1>第41节课</h1>
<p>nonpartisan adj. 无党派的 n.<br>
nonpartisanship n.</p>
<p>【反盗版】<br>
parthenogenesis n. 单性生殖，孤雌生殖<br>
-pathen- 处女 + -o- + -gen- 生 – 生殖 + -esis 学术名词后缀<br>
parthenogenetic adj.</p>
<p>impart vt. 给与，传授；告知<br>
im- 进入，使 + -part- 部分 – 使成为一部分<br>
partake vi. 吃，喝；分享；参与<br>
part + take = partake 拿一部分<br>
repartee n. 机敏的回答<br>
re- 往后 + part 分开 比喻用法 即各个击破<br>
partita n. 组曲<br>
-part- 部分 – 组合 – 组曲 + -it + -a<br>
bipartite adj. 双边的；由两部分组成的<br>
bi + part + -ite<br>
tripartite adj.<br>
tri- 三<br>
counterpart n. 副本；配对物<br>
【防盗版】<br>
parturition n. 分泌<br>
parent par- 生 + -ent<br>
-partur- 生孩子 – 分娩 + -ition<br>
mouthpart n. 昆虫的口器<br>
mouth + part – 嘴的一部分</p>
<h2 id="ven-vent-走">-ven- = -vent- 走</h2>
<p>event n. 事件<br>
e- 向外 + -vent- 来 – 出现 – 大事<br>
eventual adj. 最终发生的<br>
eventually adv.<br>
eventful adj. 多事的，多变故的<br>
uneventful adj. 平静无事的<br>
uneventfully adv.<br>
eventuate vi. 结果为；发生<br>
non-event n. 大肆宣传却并未举办的事<br>
pre-event n. 活动前<br>
post-event n.</p>
<p>convence vt. 召集 集合 vi.<br>
con- 强调 + -ven 走<br>
convener n. 会议召集人<br>
covenant n. 契约，盟约 vi. vt. 订立盟约<br>
reconvene vi. vt. 再召集 再聚会 +<br>
convention n. 集会，会议，大会<br>
convene + -ion<br>
conventioneer n. 参加会议的人<br>
-eer 名词后缀，表被动的人<br>
conventional adj. 常规的 按惯例的<br>
convention + -al<br>
conventionally adv.<br>
unconventional adj. 非常规的<br>
unconventionally adv.<br>
conventionality n. 惯例<br>
unconventionality n.<br>
conventionalism n. 墨守成规；传统主义<br>
conventionalize vt. 使习俗化<br>
conventionalized adj.<br>
non-conventional adj. 非常规的<br>
pre-convention n. 大会前<br>
post-convention n. 大会之后<br>
convent n. 女修道院<br>
con- 在一起 + -vent- 来 – 一起修行（特指女子）</p>
<p>invent vt. 发明，创造<br>
in- 进入，使 + -vent- 来，来到<br>
inventor n.<br>
invention n.<br>
inventory n. 存货，存货清单；详细名单<br>
invent + -ory 名词后缀<br>
发明 – 虚构 – 构建，后引申为对事物的统计<br>
inventive adj. 发明的；有发明才能的<br>
inventively adv.<br>
invented adj.<br>
reinvent vt. 重复发明 彻底改造</p>
<p>intervene vi. 阻碍；出面<br>
inter- 在……之间 + -ven- 来<br>
intervener n. 干涉者<br>
intervenor n.<br>
intervening adj. 介于中间的<br>
intervention n. 干预<br>
interventional adj. 干预的<br>
intervenient adj. 干预的<br>
interventionist adj. 干涉主义的 n. 干涉主义者<br>
-ist 名词后缀，表人；后引申出形容词后缀<br>
interventionism n. 干涉主义<br>
non-intervention n. 不干涉<br>
post-intervention n. 干预后</p>
<p>prevent vt. 预防 阻拦<br>
pre- 在前<br>
preventer n.<br>
prevention n.<br>
preventive adj.<br>
preventively adv.<br>
preventable adj.<br>
preventative n. 预防法 adj. 预防性的<br>
crime-prevention n.<br>
disease-prevention n.<br>
hiv-prevention n.</p>
<p>circumvent vt. 包围 陷害<br>
circum + vent 来<br>
circumvention n. 包围 陷害<br>
circumventer n.</p>
<p>revenue n. （国家）税收 （个人机构）收入 收益<br>
re- 往回 + -ven- 来 – 拿回来 – 收入–税收 + -e 名词后缀<br>
revenuer n. 税收官员<br>
revenant adj. 归来的，亡魂的 n.<br>
revenue-sharing n. 收入分享<br>
non-revenue n. 非税款收入<br>
low-revenue n. 低收入</p>
<p>contravene vt. 违反，触犯，抵触<br>
contra- 反 + -ven- 来 – 反着来 – 触犯 + -e 动词后缀<br>
contravention n. 违反<br>
supervene vt. 意外发生<br>
super- 超级 + -ven- 来 – 引申出突然发生的事情</p>
<p>advent n. 基督降临<br>
ad- 强调 + -vent- 来<br>
adventure n. 冒险 vt.<br>
adventurer n.<br>
adventuress n.<br>
adventuresome adj. 冒险性的；爱冒险的<br>
-some 事物的<br>
misadventure n. 灾难<br>
mis- 错误<br>
adventurous adj. 爱冒险的<br>
adventurousness n.<br>
unadventurous adj.</p>
<p>adventist n. 基督复临论者<br>
adventurism n. 冒险主义<br>
adventitious adj. 外来的，偶然的<br>
advent 引申为突然发生–偶然</p>
<p>convenient adj. 方便的<br>
con- 在一起 + -ven- 来 – 聚在一起 – 便利生活<br>
convenience n.<br>
conveniently adv.<br>
inconvenient adj.<br>
inconvenience n.</p>
<p>venture vt. vi. 冒险 n.<br>
adventure 的缩写<br>
venturesome adj.<br>
venture-backed adj. 创投资金支持的</p>
<p>venue n. 集合地点，审判地；犯罪地点<br>
ven 来–聚集地<br>
avenue n. 道路，林荫道<br>
a- 远离 + -ven- 来 – 原指偏远的小路<br>
souvenir n. 纪念品，礼物 vt.<br>
sou- = sub- 下 + ven 来</p>
<p>provenance n. 出处，起源<br>
pro- 在前 + -ven- 来 – 之前来<br>
provenience n. 来源，原始<br>
同上<br>
subvention n. 津贴；补助金；援助</p>
<h2 id="haust-抽出">-haust- 抽出</h2>
<p>【谐音记忆】 耗死他</p>
<p>exhaust vt. vi. n. 排出 耗尽<br>
ex- 向外 + -haust- 抽出 – 耗尽<br>
exhausted adj. 耗尽的<br>
exhaustion n.<br>
exhaustive adj.<br>
exhausting adj.<br>
exhaustible adj. 可被耗尽的<br>
exhaustively adv. 耗尽一切地<br>
inexhaustible adj.<br>
inhaust vt. 吸；饮<br>
in-向内 -haust- 抽</p>
<h1>第42节课</h1>
<h2 id="tra-tract-treat-拖，拉，拽">-tra- = -tract- = -treat- 拖，拉，拽</h2>
<p>attract vt. 吸引<br>
at- 强调<br>
attraction n.<br>
attractive adj.<br>
attractively adv.<br>
attractor n.<br>
attracted adj.<br>
attracting n.<br>
attractant n. 具有吸引力的物质 adj.<br>
attractiveness n. 吸引力<br>
unattractive adj.<br>
unattractiveness n.<br>
contract vi. 收缩；订约 vt. 订约；使缩短 n. 合同<br>
con- 在一起 + -tract- 拖拽 – 拖到一起 – 签约，合同<br>
contraction n.<br>
contractionary adj.紧缩的<br>
contractive adj.紧缩的<br>
contractual adj. 契约的 合同的<br>
contractually adv.<br>
contracted adj. 收缩的<br>
contractile adj. 可收缩的<br>
contractible adj. 同上<br>
contracture n.<br>
contractor n.<br>
contracting adj.<br>
contractility n. 收缩性<br>
subcontract n. 分包合同<br>
subcontractor n. 转包商，分包者<br>
subcontracting n. 分包</p>
<p>extract vt. 提取 摘录<br>
ex- 向外<br>
extraction n.<br>
extractor n.<br>
extractive adj.  n. 提取物<br>
extracted adj.<br>
extractable adj.</p>
<p>distract vt. 转移 分心<br>
dis- 分 + -tract-<br>
distraction n.<br>
distracting adj.<br>
distracted adj.<br>
distractedly adv.<br>
distractor n. 错误选项<br>
distracter n.<br>
distractive</p>
<p>abstract n. 摘要；抽象 adj. 抽象的<br>
abs- 强调 + -tract- 拽 – 抽出 – 抽象 – 摘要<br>
abstraction n.<br>
abstractionist n. 抽象派艺术家<br>
abstractly adv.<br>
abstracted adj.<br>
abstractedly adv.<br>
abstractness n.</p>
<p>protract vt. 绘制；延长；伸展<br>
pro- 向前 + -tract- 拖拽 – 延长 – 伸展 – 勾画 – 绘制<br>
protraction n.<br>
protractor n.<br>
protractile adj.<br>
protracted adj.</p>
<p>retract vt. 缩回；缩进 vi.<br>
re- 往回<br>
retraction n.<br>
retractive adj. 缩进的<br>
retractable adj.<br>
retractor n.<br>
retracted adj.</p>
<p>tract n. 束；大片土地，地带；小册子<br>
词根直接做单词；引申义比较多；<br>
拖拽 – 对事物的束缚<br>
tractor n. 拖拉机<br>
traction n. 牵引<br>
tractive adj.<br>
tractate n. 论文；小册子<br>
tract 小册子 + -ate<br>
tractable adj. 易于管教的；<br>
-tract- 拖 – 束缚<br>
tractor-trailer n. 牵引式挂车<br>
traction-control n.<br>
urinary-tract n. 尿路</p>
<p>subtract vt. 减去<br>
sub- 下<br>
subtraction n.<br>
subtractive adj.<br>
subtrahend n. 减数<br>
sub- + -trah- = -tract-<br>
detract vt. 转移，使分心<br>
de- 分，下 + -tract- --分开拽–分散注意力<br>
detractor n.</p>
<p>track n. 轨道，踪迹；小道<br>
track 指的是拖拽事物留下的轨迹<br>
tracksuit n. 运动服<br>
track – 跑道</p>
<p>treat vt vi. 治疗；对待 n. 请客；款待<br>
treater n. 处理器；<br>
treatment n. 治疗<br>
treated adj. 治疗的<br>
untreated adj.<br>
treatable adj.<br>
untreatable adj. 无法医治的<br>
intractable adj. 棘手的<br>
in- 否定 + -tract-<br>
intractability n.</p>
<p>retreat vi. 撤退<br>
re- 往回 + -treat-<br>
treaty n. （国家或政府间的）条约，公约<br>
对待–应对，处置的规则–条约<br>
treatise n. 论述；论文；专著<br>
treat + -ise<br>
mistreat vt. 不公正地对待；虐待<br>
mis- 错误–虐<br>
mistreated adj.<br>
mistreatment n.<br>
retreating adj. 再处理的<br>
maltreat vt. 虐待<br>
maltreatment n. 虐待<br>
mal- 坏<br>
entreat vt. 恳求；请求 vi.<br>
en- 使动 + -treat-<br>
entreaty n.<br>
post-treatment n.<br>
trick-or-treat n.<br>
trick-or-treater n.<br>
trick-or-treating n.<br>
sewage-treatment n. 废水处理<br>
sewage<br>
intention-to-treat n. 意向性治疗<br>
no-treatment n.<br>
pro-treatment n.<br>
ill-treatment n.<br>
waste-treatment n.</p>
<p>portray vt. 描绘；扮演<br>
来自古法语portraire<br>
por- = -por 向前 + traire = -tract-<br>
portrait n.<br>
portraitist n.<br>
portraiture n. 肖像画<br>
self-portrait n. 自画像<br>
self-portraiture n.</p>
<p>trait n. 特性；少许<br>
trait 直接来自于中古法语 trait ,线条，轮廓–特征<br>
traitor n. 叛逃；卖国贼<br>
traitorous adj.</p>
<p>trail vt. 追踪；拖；蔓延 n. 小径；痕迹；尾部 vi.<br>
trailing adj. 拖尾的；牵引的；蔓延的 n. 拖尾<br>
trailhead n. 小道的起点<br>
contrail n. 凝结尾；航迹云<br>
con- 强调<br>
off-trail adj. 脱轨的<br>
semi-trailer n. 半拖车<br>
star-trail n. 星轨<br>
trailblazer n. 开拓者<br>
-trail- 拖拽 – 前行开路 + blazer<br>
trailblazing adj. 开拓性的 n. 开拓</p>
<p>trace vi. 追溯；沿路走 vt. n. 痕迹，踪迹</p>
<h1>第43节课</h1>
<p>tracer n.<br>
tracing n. 追踪<br>
traceable adj. 可追踪的<br>
retrace vt. 追溯</p>
<p>train n. 火车 v. 训练<br>
整体视为词根 -train- 拖拽–牵引，引申出火车–培养，训练<br>
training n.<br>
trainer n.<br>
trained adj.<br>
trainee n. 实习生<br>
well-trained adj.<br>
untrained adj.<br>
retrain vt.<br>
retraining n.<br>
drivetrain n. 动力传动系统<br>
entrain vt. 使乘火车<br>
trainload n. 列车载重<br>
job-training n.<br>
strength-training n.<br>
cross-training n. 交叉培训<br>
post-training n. 岗位培训<br>
-post- 放置–岗位<br>
pre-training n. 预锻炼</p>
<p>track n. 踪迹 轨道 vt. vi.<br>
词根表单词<br>
tracking n.<br>
tracker n. 纤夫<br>
tracked adj. 有履带的<br>
untracked adj. 无足迹的<br>
trackless adj.<br>
trackball n. 轨迹球<br>
tracksuit n. 运动服<br>
coatrack n. 衣帽架<br>
coat<br>
soundtrack n.<br>
racetrack n.<br>
backtrack vi. vt. 追踪<br>
backtracking n.<br>
sidetrack vt. 转变<br>
side 边<br>
tenure-track adj. 终身职位的<br>
tenure （-ten- 拿–占有 + -ure 名词后缀）<br>
trackside n. 轨道附近 adj.<br>
off-track adj. 偏远的；n. 偏离磁道<br>
half-track n. 半履带<br>
single-track adj.<br>
one-track adj.<br>
two-track adj.<br>
track-and-field n. 田径运动<br>
track 轨道（径） + filed (田)<br>
fast-track n.<br>
short-track n.<br>
on-track n. 走上正轨</p>
<p>distraught adj. 心烦意乱的<br>
dis- 分散 + -traught = -tract- 拖拽 – 分开拽</p>
<h2 id="loc-地方">-loc- 地方</h2>
<p>local n. adj.<br>
-al 名词或形容词后缀<br>
locally adv.<br>
localism n. 地方主义<br>
localize vt.<br>
localization n. 地方化<br>
-ise = -ize 完全没有区别<br>
localised adj. 局部的<br>
同上<br>
localized adj.<br>
locale n. 场所，现场<br>
local + -e<br>
locality n. 位置，地点<br>
virilocal adj. 以男方家庭为中心的<br>
-vir- 男人，男性 + -i-<br>
virtue n. 美德；优点 【-virt- 男性–男人的力量，勇气等】<br>
uxorilocal adj. 入赘的<br>
-uxor- 女性<br>
matrilocal adj. 入赘的<br>
-matr- 母亲，女性 + -i-<br>
non-local adj. 非局部的<br>
local-level n.</p>
<p>locate vt. 位于 vi. 定居<br>
loc + -ate<br>
locator n.<br>
located adj.<br>
location n.<br>
locational adj.<br>
locus n. 【数】轨迹；地点<br>
-loc- 位置 + -u- + -s 名词后缀<br>
on-location adj. 现场的<br>
dislocate vt. 使不在原来位置<br>
dis- 分 – 脱离<br>
dislocation n.<br>
dislocated adj.</p>
<p>collocate vt. 布置；排列<br>
col- 在一起<br>
collcocation</p>
<p>translocate vt. 改变位置<br>
translocation n.<br>
relocate vt.<br>
relocation<br>
relocated adj.</p>
<p>allocate vt. 分配<br>
al- 强调<br>
allocator n. 分配算符<br>
allocated adj.<br>
allocative adj.<br>
allocation n.<br>
misallocation n.<br>
reallocate v. 重新分配<br>
asset-allocation n.<br>
asset 资产 = as- 强调 + set 设定–固定–资产<br>
co-locate vt.<br>
co 共同</p>
<h2 id="urb-城市">-urb- 城市</h2>
<p>urban adj. 城市的<br>
urbanite n.<br>
-ite 名词，表人<br>
urbanity n.<br>
urbanist n. 城市规划专家<br>
urbanism n.<br>
urbanize vt.<br>
urbanized adj.<br>
urbanization n.<br>
urbanology  n. 城市学<br>
urbane adj. 文雅的<br>
inurbane adj.<br>
inurbanity n.<br>
semi-urban adj.<br>
semi- 半<br>
urban-planning n.<br>
rural-urban n.<br>
rural -rur- 村落 + -al</p>
<p>suburb n. 城郊；郊区<br>
sub- 次一级<br>
suburbia n.<br>
-i- + -a 名词后缀，表集合名词<br>
suburban adj.<br>
suburbanite n. 郊区居民<br>
suburbanize v.<br>
suburbanization n.</p>
<p>exurb n. 城市远郊地区<br>
ex- 向外 + -urb- 城市<br>
exurban adj.<br>
exurbanite n. 远郊居民</p>
<p>interurban adj.<br>
inter- 在……之间的<br>
conurbation n. 集合城市<br>
con- 在一起 – 聚集</p>
<h2 id="fortun-财富-运气">-fortun- 财富 运气</h2>
<p>Fortuna 是罗马神话中的幸运女神，所以财富与运气挂在一块</p>
<p>fortune n. 运气；命运；财富<br>
fortunate adj.<br>
fortunately adv.<br>
unfortunate adj.<br>
unfortunately adv.<br>
misfortune n.<br>
fortune-teller n. 算命者<br>
fortune-telling n.<br>
fortuitous adj. 偶然的；幸运的<br>
fortuitously adv.</p>
<h2 id="torn-tour-tourn-转，迂回">-torn- = -tour- = -tourn- 转，迂回</h2>
<p>tour vt. 巡回演出<br>
tourist n. 旅游者<br>
touristic adj.<br>
touristy adj. 适合游览的<br>
tourism n. 旅游业<br>
touring adj.<br>
tourer n.<br>
tour-de-force n. 绝技<br>
de 拉丁语中的俚语 tour 迂回–千转百折 + force 力量 --绝技<br>
tourist-oriented adj. 面向游客的<br>
ecotourism n.<br>
eco 环境，经济<br>
ecotourist n. 生态旅游</p>
<p>detour n. 绕路<br>
de- 下<br>
contour n. 画轮廓<br>
con- 强调<br>
contoured adj. 波状的</p>
<p>tournament n. 锦标赛<br>
-tourn- + -a- + -ment</p>
<p>tourniquet n. 止血带<br>
tourn 迂回–缠起来</p>
<p>war-torn adj. 遭受战争破坏的<br>
torn 转<br>
torn-up adj. 磨耗的<br>
strife-torn adj.<br>
strife n. 冲突<br>
tourney n. 锦标赛<br>
attorney n. 律师<br>
at- 强调 + -torn- 转-- 辩护<br>
attorney-general n. 司法部长<br>
tornado n. 龙卷风<br>
torn + -ado = -adu<br>
tornadic adj.<br>
entourage n. 随从 周围 环境<br>
en- 使动 + tour 迂回–跟随</p>
<h1>第44节课</h1>
<h2 id="not-nox-i-nui-nec-伤害">-not- = -nox(i)- = -nui- = -nec- 伤害</h2>
<p>nocent adj. 有害的<br>
-ent<br>
nocuous adj. 有害的<br>
-noc- 伤害<br>
innocent adj. 无罪的<br>
in- 否定 + nocent<br>
innocence n.<br>
innocuous adj. 无毒的<br>
innocuity n. 无毒<br>
innocent-looking adj.<br>
noxious adj. 有毒的<br>
noxiousness n.<br>
obnoxious adj. 讨厌的 可憎的<br>
ob- 强调 + noxious<br>
obnoxiously adv.<br>
nuisance n. 令人讨厌的人或事<br>
-nuis- 伤害 + -ance<br>
internecine adj. 两败俱伤的<br>
inter- 互相 + -nec- 伤害</p>
<h2 id="proach-proxim-接近">-proach- = -proxim- 接近</h2>
<p>approach n. 方法，途径 vt. 接近；着手处理<br>
ap- 强调 + -proach-<br>
approachable adj. 可接近的 亲切的<br>
approachability n.<br>
unapproachable adj.</p>
<p>reproach n. 责备；羞辱 vt.<br>
re- 往回(相反–特别指代与approach 的含义相反) + -proach-<br>
reproachful adj. 责备的<br>
reproachfully adv.<br>
self-reproach n.</p>
<p>irreproachable adj. 无过失的<br>
-ir 表否定</p>
<p>proximal adj. 最接近的，邻近的<br>
-proxim- + -al<br>
proximate adj. 近似的<br>
proximity n. 接近，邻近</p>
<p>approximate vt. 近似；使……接近 vi. adj.<br>
approximately adv.<br>
approximation n.</p>
<h2 id="gorg-吞咽">-gorg- 吞咽</h2>
<p>咽口水，比喻极其壮观或美丽的事物或人。</p>
<p>gorge n. 峡谷<br>
-gorg- 吞咽–凹陷<br>
gorgeous adj. 美丽的<br>
-gorg- 令人咽口水<br>
gorgeously adv.<br>
gorgeousness n.<br>
disgorge vt. 吐出；被迫交出<br>
dis- 分–分离–出来<br>
engorge vt. 大吃；使充血；狼吞虎咽 vi.<br>
en- 使动<br>
engorged adj. 过饱的<br>
engorgement n.</p>
<h2 id="arch-统治，起始">-arch- 统治，起始</h2>
<p>architect n. 建筑师<br>
-arch- 统治–主导 + -i- + -tect- = -text- 编织–建造<br>
architecture n. 建筑<br>
architectural adj.<br>
architecturally adv.<br>
architectonic adj. 建筑术的；组织的；知识体系的 n. 体系论；建筑学</p>
<p>archaean adj. 太古代的 n. 【地质】 太古<br>
-arch- 起始 – 古代<br>
archeology n. 考古学<br>
archaeology n. 考古学<br>
archeologist n.<br>
archeological adj.</p>
<p>archaeoastronomy n. 考古天文学<br>
-archae- 考古 + -o- + astronomy 天文学（-astr- 星星–天体 + -o- + -nom- 命名，意义）</p>
<p>archaic adj. 古代的；陈旧的；古体的<br>
-archa- + -ic 形容词后缀<br>
archaism n. 古语 古体<br>
-ism 抽象含义<br>
archaistic adj. 古风的<br>
archaize vi. 仿古，用古体</p>
<p>archive n. 档案馆；档案文件 vt. 把……存档<br>
-arch- 原始–曾经的记录–档案<br>
archivist n. 档案保管员<br>
archival adj. 档案的<br>
archived adj. 存档的<br>
archiving n. 归档</p>
<p>monarch n. 君王<br>
-mon- 单独 -arch- 统治 – 独裁 – 君主<br>
monarchy n. 君主政体<br>
-y 名词后缀<br>
monarchist n. 君主主义者<br>
monarchic adj. 君主政体的<br>
monarchical adj. 君主的</p>
<p>patriarch n. 家长；族长；创始人<br>
-patr- 父亲 + -i- + -arch- 统治<br>
patriarchy n. 父权制<br>
patriarchal adj. 家长的<br>
patriarchate n. 任期；宗主教区；主教的职位<br>
-ate 此处特指宗教的职位</p>
<p>matriarch n. 女家长<br>
-matr- 母亲<br>
matriarchy n. 母权制<br>
matriarchal adj.</p>
<p>oligarch n. 寡头政治执政者<br>
-olig- 少–寡 + -arch- 少数者统治<br>
oligarchy n. 寡头政治<br>
oligarchic adj.</p>
<p>anarchy n. 无政府状态；混乱；无秩序<br>
an- 否定 = un- + -arch- 统治<br>
anarchic adj. 无政府的<br>
anarchical adj.<br>
anarchist n. 无政府主义者<br>
anarchism n.<br>
anarchistic adj.</p>
<p>archetype n. 原型<br>
-arch- 原始 + -e- -type<br>
archetypal adj. 原型的<br>
archetypical adj. 典型的<br>
-arche- + typical adj. 典型的</p>
<p>archbishop n. 大主教<br>
-arch- 统治 + bishop n. 主教</p>
<p>archipelago n. 群岛<br>
-arch- 统治–主导 + -i- + -pelag- 海（爱琴海）–海中陆地 + -o （以o结尾的单词多来自意大利）</p>
<h1>第45节课</h1>
<p>archduke n. 太公，皇太子<br>
-arch- + duke 大公<br>
archenemy n. 主要敌人<br>
enemy<br>
archdeacon n. 领班神父<br>
deacon 来自希腊语 diakonos<br>
arch-nemesis n. 主要劲敌（非正式）<br>
nemesis 希腊神话中的复仇女神 n. 报应，天罚；主要敌人<br>
archangel n. 大天使<br>
archrival n. 主要竞争对手<br>
rival = -riv- 河流 + -al 名词后缀<br>
archdiocese n. 大主教之管区<br>
diocese 来自希腊语 管理<br>
overarching adj. 首要的<br>
over- 在上方<br>
archly adv. 主要地；狡猾地<br>
统治–主要，任性<br>
menarche n. 初潮<br>
-men- 月份 + -arche- 初始 – 月经初始</p>
<h2 id="fess-说，宣称">-fess- 说，宣称</h2>
<p>profess vt. 自称 公开表示 vi.<br>
pro- 向前<br>
professed adj.<br>
professor n. 教授<br>
professsorship n. 教授职位<br>
professorate n. 全体教授；教授任期；教授职务<br>
-ate 罕见的名词含义<br>
profession n. 职业<br>
professional adj.<br>
professionally adv.<br>
professionalism n. 专业主义<br>
professionalized adj.<br>
professionalization n.<br>
unprofessional adj.</p>
<p>paraprofessional adj. 辅助专职人员的 n.<br>
para- 旁边<br>
non-professional adj.<br>
non- 否定<br>
self-professed adj. 自称的<br>
semi-professional adj. 半职业的 n.<br>
semi- 半<br>
pre-professional adj. 为从事职业准备的<br>
professional-quality n. 专业素质<br>
professional-looking n. 专业外观<br>
professional-level n.</p>
<p>fess vt. 供认；坦白 vi.<br>
-fess- 说<br>
confess vt. 坦白 vi.<br>
con-强调<br>
confessor n. 忏悔者<br>
confession n.<br>
confessional adj.<br>
confessed adj.<br>
self-confessed adj. 公开承认的</p>
<h2 id="manu-man-手">-manu- = -man- 手</h2>
<p>manual adj. 手工的 n. 手册<br>
manually adv.<br>
non-manual adj. 非体力劳动的<br>
manual-shift n. 手动换挡</p>
<p>manner n. 方式 习惯 种类 规矩 风俗<br>
mannerly adj. 彬彬有礼的 adv.</p>
<p>mannered adj. 守规矩的<br>
mannerism n. 特殊习惯 矫揉造作 怪癖</p>
<p>mild-mannered adj. 温柔的</p>
<p>manage vt. 经营 管理<br>
-man- + -age 动词或名词后缀<br>
manager n.<br>
management n.<br>
managing adj.<br>
managed adj.<br>
unmanaged adj.<br>
managed-care n. 管理式医疗<br>
managerial adj. 管理的<br>
manageable adj. 易管理的<br>
mismanage vt. 处置失当<br>
mismanagement n.<br>
micromanage n. 微观管理<br>
co-manager n.<br>
self-managed adj.<br>
manageability n. 易办理 顺从<br>
management-consulting n. 企业管理咨询</p>
<p>manacle n. 束缚 手铐 vt.<br>
-man- + -acle<br>
manuscript n. 手稿<br>
manufacture n. 制造 产品 制造业 vt.<br>
manufacturer n.<br>
manufacturing n. adj.<br>
manufactured adj.<br>
manufactory n. 工厂<br>
manufacturable adj. 可制造的</p>
<p>manumit vt. 解放<br>
mit 发出–释放<br>
manumission n. （农奴，奴隶）解放</p>
<p>maintain vt. 维持；继续；维修<br>
-main- + -tain- 持 – 用手持有 – 保持<br>
maintainable adj.<br>
maintenance n. 维护，维修，保持<br>
maintain (-tain- = -ten- = -tin-)</p>
<p>manipulate vt. 操纵；操作<br>
-man- 手 + -i- + -pul- 推 – 用手推动 – 操纵 + -ate<br>
manipulation n.<br>
manipulative adj.<br>
manipulator n.<br>
manipulable adj.</p>
<p>manifest vt. 证明 表明 显示 vi. n. adj.<br>
man + -i- + -fest 做 – 动手做出来 – 显示，证明<br>
manifestation n.<br>
manifesto n. 宣言；声明<br>
manifestly adv. 显然地</p>
<p>emancipate vt. 解放<br>
e- 向外 + -man- + -cip- 拿<br>
emancipation n.<br>
emancipated adj. 被解放的<br>
emancipatory adj. 解放的<br>
emancipator n. 解放者</p>
<p>maneuver n. 【军事】 机动 演习 策略 调遣 vi. vt.<br>
-man- 手 + -euv- 移动 – 用手调用 – 引申出军事上的含义 + -er 动词后缀<br>
maneuvering n.<br>
maneuverable adj. 有机动性的<br>
maneuverability n.</p>
<p>outmaneuver vt. 以计谋胜过<br>
out- 超过，胜过<br>
manoeuvre vi. vt.</p>
<p>manure vt. 施肥于；耕种 n. 肥料<br>
-manu- 手 – 动手种地 + -re = -er</p>
<p>amanuensis n. 抄写员；文书助理<br>
a- 强调 + -manu- + -en- 使动 + -sis- = assist<br>
manus n. 手，前肢</p>
<p>emanation n. 发出<br>
manicure vt. 修剪，美甲 n.<br>
-man- 手 + -i- + -cur- 护理 + -e<br>
well-manicured adj.</p>
<h2 id="fasc-捆，束">-fasc- 捆，束</h2>
<p>fascine n. 柴捆<br>
-fasc- 捆 + -ine 名词后缀<br>
fascinate vt. 使着迷<br>
fascinator n. 迷人的人或物<br>
fascination n.<br>
fascinating adj. 迷人的<br>
fascinated adj.<br>
fascinatingly adv.</p>
<p>fasciate adj. 用带子束住的<br>
fasciation n. 【植保】 扁化；簇生</p>
<h1>第46节课</h1>
<p>fascicle n. 束；分册；一簇<br>
fasc + -icle = -acle 名词后缀<br>
fascicular adj. 丛生的；群生的</p>
<p>fascia n. 招牌；【医】 筋膜 绷带 饰带<br>
-fasc- 捆 – 绷带 + -i- + -a 集合名词后缀<br>
fascial adj. 筋膜的<br>
fasciitis n. 筋膜炎<br>
fasc + -i- + -itis 名词后缀</p>
<p>fascist n. 法西斯主义者 adj.<br>
fascistic adj.<br>
anti-fascist adj.<br>
fascism n. 法西斯主义<br>
neo-fascist n. 新法西斯主义者<br>
-neo- 新</p>
<h2 id="viv-vit-veg-活">-viv- = -vit- = -veg- 活</h2>
<p>survive vt. 幸存；生还 vi.<br>
survivor n.<br>
surviving adj.<br>
survival n. 幸存<br>
-al 名词后缀<br>
survivalist n. 活命主义者<br>
survivable adj.<br>
survivability n.</p>
<p>vivid adj. 生动的；逼真的<br>
vividly adv.<br>
vividness n.</p>
<p>vivfy vt. 使生动；使活跃<br>
vivacity n. 活泼<br>
vivacious adj. 活泼的</p>
<p>revive vi. vt. 复兴<br>
revivify vt. vi. 使复活<br>
revival adj.<br>
revived adj.<br>
reviving n. 振兴<br>
revivalist n. 领导宗教复兴运动的人<br>
revivalism n. 信仰复兴运动</p>
<p>convive n. 共桌用餐的人<br>
convivial adj. 欢乐的；酒宴的<br>
con- 强调 + -viv- 活 – 复苏精神 – 欢乐<br>
conviviality n.</p>
<p>vivarium n. 动物园<br>
-viv- 活 – 野生 + -ary（i） + -um 名词后缀</p>
<p>vivisect vt. 解剖<br>
-viv- + -i- + -sect- 切 – 解剖<br>
vivisection n.</p>
<p>vital adj. 生命的 有生命的 致命的 生命攸关的<br>
vitally adv.<br>
vitality n. 生命力，生气<br>
vitalize vt. 赋予……生命；激发；使有生气<br>
vitalism n. 活力论 生机说<br>
revitalize vt. 使再生 使恢复元气<br>
revitalization n. 复兴<br>
devitalize vt. 使失去生命 使伤元气<br>
de- 否定 – 失去</p>
<p>vitamin n. 维生素<br>
-vit- + -amin- = -anim- 生命 动物 + -e 名词后缀<br>
vitaminology  n. 维生素学<br>
avitaminosis n. 维生素缺乏症<br>
a- 远离 + vitamin + -osis = -asis 医学名词后缀<br>
devitaminize vt. 使失去维生素<br>
de- 分 – 否定<br>
multivitamin adj. 多种维生素的 n.</p>
<p>viva n. 口头测验 int. 万岁<br>
-viv- 活 – 鲜活 – 愉快<br>
vivo adj adv. 活泼的<br>
in-vivo  在活的有机体内<br>
viviparous adj. 胎生的<br>
-viv- 生 + -i- + -par- 生（出生） + -ous<br>
vita n. 生活 生命 个人简历<br>
-viv- 生 – 简介特指个人的经历</p>
<p>vegetal adj. 植物的 n.<br>
-veg- 生 – 生物 – 植物 + -et- + -al<br>
vegetable n. adj.<br>
-able 本为形容词后缀<br>
vegetate vi. 过单调呆板的生活<br>
-veget- 蔬菜 – 素食 – 单调（生活）-ate<br>
vegetated adj.<br>
vegetation n.<br>
vegetative adj. 植物的；无所作为的<br>
vegetarian n. 素食者 adj.<br>
-veget- + -ary(i) + -an<br>
vegetarianism n. 素食主义</p>
<p>veg n. 蔬菜 vi. 虚度<br>
veggie n. 素食者<br>
-veg(g)- + -i- + -e<br>
vegan n. 严格的素食主义者 adj.<br>
-veg- + -an</p>
<h2 id="tact-tang-tag-ting-tig-tast-接触">-tact- = -tang- = -tag- = -ting- = -tig- = -tast- 接触</h2>
<p>contact n. 接触 vt vi.<br>
non-contact n.<br>
pre-contact adj. 本地人与外地文化接触之前时期的<br>
eye-contact n. 目光接触<br>
contact-lens n. 隐形眼镜<br>
lens 晶状体<br>
tactual adj. 触觉的<br>
tactile adj. 触觉的<br>
-ile = -ible<br>
tactility n. 触觉</p>
<p>intact adj. 完好无损的<br>
in- 否定<br>
intactness n.</p>
<p>contagion n. 接触传染；传染病<br>
con- 在一起 + -tag- 接触 + -ion<br>
contagium n. 接触传染物<br>
contag + -i- + -um<br>
contagious adj.<br>
contagiosity n. 接触性传染<br>
anticontagious adj. 预防传染的<br>
anti- 反</p>
<p>contingency n. 偶然性 可能性<br>
con- 强调 + -ting- 接触–触及–触发事件–可能，偶然性的触发<br>
contingent adj.<br>
non-contingent n. 非偶然</p>
<p>entangle vt. 使纠缠 卷入 使混乱<br>
en- 使动 + -tang- 接触 – 卷入 + -le 动词后缀<br>
entangled adj.<br>
entanglement n.<br>
disentangle vi. vt. 解开<br>
dis- 分</p>
<p>tact n. 机智 老练<br>
-tact- 接触 – 预先探查 – 机智<br>
tactless adj.<br>
tactful adj.<br>
tactfully adv.<br>
tactic n. 策略 adj. 按顺序的<br>
tactical adj.<br>
tactically adv.<br>
tactician n. 谋士</p>
<p>syntactic adj. 语法的<br>
-syn- 一起 + tactic 接触 – 加入（语言法则）序列<br>
syntactical adj.<br>
syntactically adv.</p>
<p>stereotactic adj. 立体定位的；趋实体性<br>
stere 立体  = -ster- 站立</p>
<p>tang n. 特性；强烈的味道；柄脚 vt. vi.<br>
tang 接触 – 来自古英语tang, 指的是蛇信子 – 探查周围的事物，味道</p>
<h1>第47节课</h1>
<p>tangent adj. 切线的，相切的，接触的 n. 切线，正切<br>
tang 接触<br>
tangential adj. 切线的 n. 正切<br>
tangentially adv. 切线地 无关地<br>
tangible adj. 有形的 可接触的 切实的 n. 有形资产<br>
tabgibly adv. 可触知地<br>
intangible adj. 接触不到的 无形的 难以理解的<br>
intangibles n. 无形资产</p>
<p>tangle n. 纠纷；混乱状态 vt. 使纠缠；处于混乱状态 vi.<br>
-tang- 接触–冲突–纠纷<br>
tangled adj.<br>
untangle vt. 解开……纠结</p>
<p>tag n. 标签；名称 vt. 尾随，连接</p>
<p>tango n. 探戈舞 vi.<br>
tangy adj. 扑鼻的 有刺激性的<br>
-tang- + -y</p>
<p>contiguity n. 接触 邻近<br>
con- 在一起 + -tig- 接触 + -u- + -ity<br>
contiguous adj.</p>
<p>taste n. 味道 vt. 尝 vi.<br>
-tast- = -tang- 触及<br>
taster n.<br>
tasty adj. 美味的 n. 可口的东西<br>
tasting n.<br>
tasteful adj.<br>
tastefully adv.<br>
tasteless adj.<br>
tastelessness n. 无鉴赏力<br>
tastemaker n. 创造时髦风尚的人<br>
taste-bud n. 味蕾<br>
distaste n. 厌恶 vt. 厌恶<br>
distasteful adj. 令人不快的<br>
distastefully adv.</p>
<p>aftertaste n. 回味<br>
foretaste n.<br>
fore- 先</p>
<h2 id="liqu-液体">-liqu- 液体</h2>
<p>liquid adj. 液体的 n.<br>
liquidly adv.<br>
liquidate vt. 清算；偿付；消除<br>
liquid + -ate – 从液体引申出金融学含义指代流走，清算<br>
liquidated adj.<br>
liquidation n.<br>
liquidator n. 清算人<br>
liquidity n. 流动性 流动资产<br>
-ity<br>
semiliquid n. 半流体<br>
semi-<br>
illiquid adj. 无流动资金的<br>
il- 否定<br>
illiquidity n.<br>
liquid-crystal n. 液晶<br>
cystal n. 晶体</p>
<p>liquefy vt. 液化；溶解<br>
-liqu- + -e- + -fy<br>
liquefied adj.<br>
liquefaction n. 液化<br>
liquefiable adj. 液化的</p>
<p>liquesce vt. 使液化<br>
-liqu- 液体–液化 + -e- + -sce 动词后缀<br>
liquescent adj. 可液化的</p>
<p>deliquesce vi. 液化<br>
de- 分<br>
deliquescent adj.</p>
<p>liquate vt. 溶解 vi.<br>
-liqu- 液体 + -ate<br>
liquation n. 熔融</p>
<p>liqueur n. 白酒 烧酒<br>
-liqu- 液体 + -e- + -ur<br>
liquor n. 酒</p>
<h2 id="pand-pans-展开">-pand- = -pans- 展开</h2>
<p>expand vt. 扩张 vi.<br>
ex- 向外 + -pand-<br>
expandable adj.<br>
expanded adj.<br>
expander n.<br>
expanse n. 广阔的区域<br>
expansible adj. 能扩张的<br>
expansive adj. 广阔的<br>
expansively adv.<br>
expansiveness n.</p>
<p>expansion n.<br>
expansionism n. 扩张主义<br>
expansionist n.<br>
expansionary adj. 扩张性的<br>
expanding adj. 扩大的<br>
ever-expanding adj. 不断扩张的<br>
ever 一直，永恒</p>
<h2 id="mix-misc-mixt-混合，混杂">-mix- + -misc- = -mixt- 混合，混杂</h2>
<p>音变：x = sc</p>
<p>mix vt. vi. n.</p>
<p>mixer n.<br>
mixture n. 混合 混合物<br>
mixing n.<br>
mixed adj.<br>
unmixed adj.<br>
mix-up n. 混乱<br>
mixed-use n.<br>
mixed-race adj. 混血的</p>
<p>admix vt. 使混合 vi. 混合<br>
ad- 强调<br>
admixture n.<br>
intermix vt. 使……混合<br>
intermixture n. 混合</p>
<p>immix vt. 混合<br>
im- = -in 向内<br>
immixture n.</p>
<p>miscible adj. 【化学】 能混溶的<br>
miscibility n. 可混合性<br>
immiscible adj.<br>
im- 否定</p>
<p>commix vt. 使混合 vi.<br>
com- 在一起<br>
endomixis n. 内合<br>
endo- 内部 + -mix- 混合 + -i- + -s 名词后缀</p>
<p>miscegenation n. 种族混合<br>
misc + -e- + -gen- 生–种族 + -ation<br>
anti-miscegenation n.</p>
<p>promiscuity n. 乱交；混乱<br>
pro- 向前 + -misc- 混合 + -u- + -ity<br>
promiscuous adj.<br>
promiscuously adv.</p>
<p>miscellaneous adj. 混杂的 多方面的<br>
miscel-  + -aneous 形容词后缀<br>
remix vt.<br>
re- 再次<br>
mix-and-match n. 混合搭配<br>
mixed-income n.</p>
<p>premix n. 预混合料 vt.<br>
premixed adj.</p>
<h2 id="electr-电">-electr- 电</h2>
<p>electric adj. 电的； n.<br>
electricity n. 电力；电流<br>
electrical adj. 用电的<br>
electrically adj. 电力地<br>
electrician n. 电工</p>
<p>hydroelectric adj. 水力发电的<br>
-hydro- 水<br>
hydroelectricity n. 水力发电</p>
<p>electric-blue n. 钢青色<br>
electric-power n. 电力<br>
diesel-electric adj. 内燃电力传动的<br>
hybrid-electric adj. 混合电能的<br>
dielectric adj. 非传导性的<br>
di- 分–否定<br>
piezoelectric adj. 压电的<br>
pieze n. 压电<br>
photoelectric adj. 光电的<br>
thermoelectric adj. 热电的<br>
-therm- 热<br>
myoelectri adj. 肌电的</p>
<p>electron n. 电子<br>
electronic adj.<br>
electronica n. 电子乐<br>
-a 集合名词后缀<br>
electronics n. 电子学<br>
-ics 学术名词后缀<br>
electronically adv.<br>
microelectronic adj.<br>
microelectronics n.<br>
optoelectronic adj. 光电子的<br>
-opt- 眼 光<br>
electronystagmography n. 眼震电流描记法<br>
electrony 电子 + -stagm- 振动 + -o- + -gragh- 写 + -y<br>
consumer-electronics n. 消费性电子产品 家用电子产品<br>
non-electronic adj. 非电子的<br>
electron-beam n. 电子束<br>
electron-hole n. 电子空穴<br>
electron-positron n. 正负电子对撞<br>
positron n. 正电子</p>
<h1>第48节课</h1>
<p>electrify vt. 使电气化<br>
electrified adj.<br>
electrifying adj.<br>
electrification n.</p>
<p>electrophysiology n. 电生理学<br>
-elctr- + -o- + -phys(i)- 物质，身体 + -0- + -logy<br>
electrophysiologist n.<br>
electrophysiologic adj.<br>
electrophysiological adj.</p>
<p>electromagnet n. 电磁体<br>
-magn- 大–引力–吸引 + -et<br>
electromagnetic adj.<br>
electromagnetics n. 电磁学<br>
-ics 学术名词</p>
<p>electrolyte n. 电解液<br>
-electr- + -o- + -lyt- 展开 + -e<br>
analyze vt. 分析 = ana- 分 + -lyz (-lys = -lyt- 展开) + -e<br>
electrolytic adj.<br>
electrolysis n. 电解 电解作用<br>
-lys + -i- + -s<br>
electrocute vt. 以电椅处死<br>
-cut- 切，杀 + -e<br>
electrocution n.</p>
<p>electrode n. 电极；电焊条<br>
-ode = -ade = -ude 名词后缀<br>
electrodermal adj. 皮电活动的；皮电性质的<br>
-erm + -al<br>
electrodynamic adj. 电力学的<br>
+ -o- + -dynam- 力量，动力 + -ic<br>
electrodynamics n. 电动力学</p>
<p>electrocardiogram n. 心电图<br>
-card- = -cord- 心 + -io- + -gram- 画<br>
electrocardiogrphic adj.</p>
<p>electroshock n. 电击疗法</p>
<p>electrochemical adj. 电化学的</p>
<p>electromechanical adj. 电动机械的，机电的</p>
<p>electrophoresis n. 电泳<br>
pheoresis  = -phores- 运送 + -i- + -s<br>
electroencephalogram n. 脑电图<br>
+ en- 使动 + -cephal- 头 + -o- + -gram- 写–画<br>
electromyogrphy n. 肌电图学<br>
—my- 肌肉 muscle + -graph- + -y<br>
elctro-optical adj. 电光的<br>
-opt- 眼，光<br>
electrocautery n. 电烙器<br>
cautery<br>
electroplate vt. 电镀<br>
plate<br>
electroactive adj. 电活性<br>
electrochromic adj. 电致变色的<br>
chromic = -chrom- 颜色 + -ic</p>
<h2 id="clud-clus-clos-clois-claus-clot-关闭">-clud- = -clus- = -clos- = -clois- = -claus- = -clot- 关闭</h2>
<p>include vt.<br>
in- 向内<br>
inclusion n.<br>
inclusionary n. 包容性<br>
included adj.<br>
including prep. 包含<br>
inclusive adj.<br>
all-inclusive adj.<br>
inclusiveness n.<br>
inclusively adv. 包含地</p>
<p>exclude vt. 排除<br>
exclusive adj.<br>
exclusionism n.<br>
exclusiveness n.</p>
<p>conclude vt. 推断 决定 总结<br>
conclusory adj. 推断性的<br>
conclusive adj. 决定性的 最后的</p>
<p>seclude vt. 使隔离，孤立 隐居<br>
se- 分<br>
特别说明，必须通过使用汉语意思所代表的语境来理解并灵活运用英文单词的语境	<br>
seclusion n.<br>
seclusive adj.<br>
secluded adj.</p>
<p>recluse adj. 隐居的<br>
re- 往回<br>
reclusive adj.</p>
<p>occlude vt. 使堵塞<br>
oc- 反<br>
occlusive adj.<br>
occlusion n.</p>
<p>preclude vt. 阻止 预防<br>
pre- 在前<br>
preclusion n.<br>
preclusive adj.</p>
<p>close adj. vt. vi.<br>
closed adj.<br>
closeness n. 亲密<br>
closing adj.<br>
disclose vt. 公开<br>
undisclosed adj.</p>
<p>cloture vt. 结束辩论 n. 讨论终结</p>
<p>closure n. 关闭 结束 vt.</p>
<p>disclosure n. 披露 揭发<br>
self-disclosure n. 自我揭露</p>
<p>enclose vt. 围绕<br>
en- 使动<br>
enclosure n.<br>
enclosed adj.<br>
self-enclosed adj. 自闭合的</p>
<p>closet n. 壁橱 小房间 adj. vt.<br>
closeted adj. 私下密谈的</p>
<p>foreclose vt. 阻止；排除；取消抵押品赎回权<br>
foreclosure n.</p>
<p>cloister n. 隐居地；修道院 vt. 隐居<br>
-cloist- 关 – 闭关修炼 + -er<br>
cloistered adj.</p>
<p>clause n. 条款；子句<br>
-claus- 关闭 – 构成一个独立语法结构的句子 + -e<br>
claustrophobia n. 幽闭恐怖症<br>
-claustr- 关 – 幽闭 + -o- + -phob- 恐惧 + -i- + -a<br>
claustrophobic adj.</p>
<h1>第49节课</h1>
<p>close-up n. 特写镜头 小传<br>
close-knit adj. 紧密的 严谨的<br>
knit vt. 编织 knot vt. 打结<br>
close-cropped adj. 剪短的<br>
crop vt. 种植 修建<br>
close-set adj. （两眼之间）靠的近的</p>
<h2 id="ag-act-ig-驱使-做">-ag- = -act- = -ig- 驱使 做</h2>
<p>act vt. 扮演 举作 vi. n.<br>
actor n.<br>
actress n.<br>
acting adj. 代理的 临时的<br>
action n.<br>
actionable adj. 可控告的<br>
activate vt. 刺激 使活动 vi.<br>
activator n. 催化剂<br>
activation n. 激活</p>
<p>actinic adj. 化学线的</p>
<p>counteract vt. 抵消 中和<br>
counter- 反<br>
counteraction n.</p>
<p>retroact vi. 起反作用 有追溯力<br>
retroactive adj. 追溯的<br>
retroactively adv.<br>
retroactivity n. 追溯效力</p>
<p>proactive adj. 前摄的（前一活动中的因素对后一后动造成影响的）；有前瞻性的<br>
pro- 向前<br>
proactively adv.</p>
<p>hyperactive adj. 极度活跃的<br>
hyper- = super- 超级<br>
hyperactivity n.</p>
<p>deactivate vt. 使无效<br>
de- 否定<br>
deactivation n.</p>
<p>playact vi. 演戏</p>
<p>bioactive adj. 生物活性的</p>
<p>psychoactive adj. 影响心理状态的<br>
-psych- 心理</p>
<p>underactive adj.</p>
<p>one-act n. 一幕</p>
<p>bolt-action adj. 【军械】直动式机枪的</p>
<p>actual adj. 实际的<br>
act 做 – 事实 + -u- + -al<br>
actually adv.<br>
actuality n. 事实<br>
actualize vt. 实施<br>
actualization n.<br>
self-actualization n. 自我实现<br>
马斯洛需求理论<br>
自我实现<br>
尊重 Esteem<br>
爱和归属 love and belonging<br>
安全需求 safety needs<br>
生理需求 phyiological needs</p>
<p>actuate vt. 开动 促使<br>
actuator n. 执行机构 激励者 促动器<br>
actuation n.</p>
<p>actuary n. 保险计算员<br>
actuarial adj. 保险精算的</p>
<p>react vi 反应 影响 反抗 vt. 使发生相互作用<br>
re- 往回 + act 做–反动–反应<br>
reaction n. 反应<br>
reactor n.<br>
reactive adj. 反应的<br>
reactivity n.</p>
<p>reactivate vt. 使恢复活动<br>
reactivation n.<br>
reactionary adj. 保守的 反动的</p>
<p>overreact vi.<br>
overreaction n.<br>
nonreactive adj. 【化学】 不反应的<br>
reactant n. 反应物<br>
reactance n. 【电】 电抗<br>
biereactor n. 生物反应器</p>
<p>exact adj.精确的<br>
ex- 强调<br>
exaction n. 强求 勒索<br>
exactness n. 正确<br>
exacting adj. 苛刻的<br>
exactitude n. 正确<br>
-itude 名词后缀<br>
inexact adj.<br>
in- 否定</p>
<p>enact vt. 颁布 制定法律<br>
en- 使动<br>
enactment n.</p>
<p>re-enact vt.<br>
re- 再次<br>
re-enactor n.</p>
<p>re-enactment n.</p>
<p>interact vt. 互相影响；互相作用 vi.<br>
interacting n.<br>
interactive adj.<br>
interactively adv.<br>
interaction n.<br>
interactional adj. 相互作用的<br>
interactionism n. 身心交互影响说</p>
<p>radioactive adj. 放射性的<br>
-rad- 辐射 + -i- + -o 名词<br>
radioactivity n.<br>
radioactively adv. 放射性地</p>
<p>agent n. 代理人 vt. 由……作中介 adj. 代理的<br>
-ag- 做–做事的人 + -ent 名词后缀，表人<br>
agency n. 代理<br>
agential adj. 代理人的<br>
subagent n. 副代理人<br>
sub-<br>
coagent n.<br>
co-<br>
coagency n. 共事<br>
agenda n. 日程<br>
-ag- 做 – 做事 + -end = -ent + -a、<br>
agentry n. 代理人业务；代理人职责</p>
<h1>第50节课</h1>
<p>agile adj. 敏捷的<br>
agility n.<br>
agitate vt. 使……激动；骚动 vi. 煽动<br>
agitation n.<br>
agitator n. 搅拌器；鼓动者<br>
agitatress n.<br>
agitated adj. 激动的；焦虑的<br>
agitating adj.</p>
<p>counteragent n. 反作用剂；中和力<br>
transact vi. 交易，<br>
trans- 通过 + -act- 做 – 办理 – 交易，谈判<br>
transaction n.</p>
<p>exigent adj. 迫切的<br>
ex- 强调 + -ig- 做 – 强调要做的事情 – 迫切，紧急 + -ent 形容词后缀<br>
exigency n.<br>
exigence n. 同上</p>
<p>intransigent adj. 不妥协的<br>
in- 否定 + -trans- 通过 + -ig- 做–交易，谈判–不谈判 + -ent 形容词或名词后缀<br>
intransigence n. 不妥协</p>
<p>litigate vt. 在法庭相争；提出诉讼 vi.<br>
-lit- 争论 + -ig- 做 + -ate<br>
litigator n. 诉讼律师；诉讼人<br>
litigation n. 诉讼<br>
litigant n. 诉讼当事人 adj. 诉讼的<br>
litigious adj. 好争论的</p>
<p>navigate vt. 驾驶，操纵 vi. 航行<br>
-nav- 航海，航行 + -i- + -ig- 做 – 航行 + -ate<br>
navigator n. 航海家<br>
navigation n. 航行<br>
navigational adj.<br>
navigable adj. 可航行的</p>
<h2 id="order-ord-ordin-ordain-命令">-order- = -ord- = -ordin- = -ordain- 命令</h2>
<p>order n. 命令；顺序；规则；定单 vt. 命令；整理；定购<br>
orderly adj. 有秩序的 ；值班的 n. 勤务兵；传令兵；护理员 adv. 顺序地<br>
ordering n. 订购；排序<br>
ordered adj. 有序的<br>
unordered adj. 无序的<br>
orderlines n. 整洁，整齐；秩序井然<br>
order + line + ness<br>
disorder n. 混乱，失调<br>
disordered adj.<br>
disorderly adj. adv.</p>
<p>reorder vt. 再次订购 vi. n.<br>
reordering n. 重排序</p>
<p>ordinary adj. 普通的；平凡的 n.<br>
-ordin- 普遍–普通 + -ary<br>
ordinarily adv.<br>
ordinariness n. 平方<br>
ordinary-looking adj.<br>
extraordinary adj. 非凡的<br>
extraordinarily adv.</p>
<p>coordinate n. 坐标；同等的人或物 adj. 并列的 vt. 调整 vi. 协调<br>
co- 共同 + -ordin- 命令 – 共同的命令 – 目标 + -ate 形容词或动词后缀。名词是语境含义<br>
coordinator n. 协调者；协调器；同等的人或物<br>
coordination n. 协调，调和；对等，同等<br>
coordinated adj. 协调的<br>
coordinating adj. 协调的<br>
uncoordinated adj. 不协调的；不对等的<br>
color-coordinated n. 色彩搭配<br>
well-coordinated adj. 协调配合的</p>
<p>ordinate vt. 纵坐标<br>
ordinator n. 协调者<br>
ordination n. 分类；任命；神职授任<br>
-ordin- 命令<br>
inordinate adj. 过度的；无节制的<br>
in- 否定<br>
inordinately adv. 非常地；无度地<br>
superordinate adj. 上级的<br>
super- 在上 + -ordin- 等级</p>
<p>ordinance n. 条例，法令<br>
subordinate n. 下属 adj. 从属的；次要的 vt. 使……居下位<br>
sub- 下 – 下级 + -ordin- 命令–从属<br>
subordination n.<br>
subordinated adj.<br>
insubordinate adj. 不听话的；不顺从的<br>
insubordination n. 反抗，不服从</p>
<p>ordinal adj. 顺序的，依次的 n. 序数<br>
ordain vt. 任命某人为牧师；命令；注定 vi. 颁布命令<br>
preordain vt. 注定；预先决定<br>
pre- 在前<br>
preordained adj. 注定的；天命的<br>
ordnance n. 军火<br>
-ordn- 命令 – 军令 + -ance</p>
<h2 id="solv-solu-solut-解，松的">-solv- = -solu- = -solut- 解，松的</h2>
<p>solve vt. 解决；解答；溶解 vi.<br>
solver n.<br>
solvable adj. 可以解决的；可溶的<br>
solvent adj. 有偿付能力的；有溶解力的 n. 溶剂<br>
solvency n. 偿付能力<br>
solved adj.<br>
unsolved adj.<br>
absolve vt. 免除；赦免；宣告……无罪<br>
ab- 远离 – 否定 + solve<br>
insolvent n. 破产者；无力偿还者 adj. 破产的<br>
in- 否定<br>
insolvency n.<br>
unsolvable adj. 不能解决的<br>
solvent-based adj. 溶剂型的</p>
<p>dissolve vt. 使溶解；使分解；使液化 vi. 溶解<br>
dissolved adj. 溶解的<br>
dissolving adj. 消溶的；毁灭性的</p>
<p>resolve vt. 决定；溶解；使……分解；决心要做 vi. 解决；决心 n.<br>
re- 再次<br>
resolved adj. 下定决心的；已解决的；断然的<br>
resolvable adj. 可分解的；可解决的<br>
irresolvable adj.<br>
unresolved adj.<br>
unresolvable adj.<br>
solute n. 【化学】 溶质 adj. 溶解的<br>
-solut- 解 + -e<br>
solution n. 解答<br>
dissolute adj. 放荡的<br>
dis- 分<br>
dissolution n. 分解；（议会等）解散；（契约）解除；死亡<br>
absolute adj. 绝对的 n. 绝对<br>
absolutely adv.<br>
absolutist n. 绝对论者；专制主义者<br>
absolution n. 赦免<br>
absolutism n. 专制主义<br>
absoluteness n. 绝对</p>
<p>resolute adj. 坚决的；果断的<br>
resolution n. 决议;分辨率<br>
resolutely adv. 坚决地<br>
irresolute adj. 优柔寡断地<br>
resoluteness n. 坚决<br>
low-resolution n. 低分辨率<br>
conflict-resolution n. 冲突解决<br>
dispute-resolution n. 调解纠纷</p>
<p>soluble adj. 可溶解地<br>
-solu- + -ble = -able<br>
solubility n. 溶解度<br>
insoluble adj. 不能解决的；不能溶解的<br>
indissoluble adj. 不能分解的</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>Unsupervised Learning</title>
    <url>/posts/da92ff49/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>ISL 真是好书！</p>
<span id="more"></span> 
<h1>资料</h1>
<p><a href="https://www.statlearning.com/">An Introduction to Statistical Learning</a>，下文简称 <strong>ISL</strong></p>
<h1>概述</h1>
<p>无监督学习（<em>unsupervised learning</em> ）指只有特征 X<sub>1</sub>，X<sub>2</sub>, …… ,X<sub>p</sub> ，而没有反应变量的情况。这时候我们就是样本的特征之间的关系，最主要的作用就是对样本进行<strong>分组</strong>。这里主要关注两个无监督学习方法：<strong>主成分分析</strong>（<em>principal components analysis</em>）和 <strong>聚类分析</strong>（<em>clustering</em>）。</p>
<h1>The Challenge of Unsupervised Learning</h1>
<p>无监督学习的挑战在于比较主观，不像监督学习一样有一个真实值在那里，也没有简单的分析目的。无监督学习一般是用在<strong>探索性数据分析</strong>（<em>exploratory data analysis</em>）中。最后，我们也很难评价不同方法结果的优劣，因为无监督学习也不存在普遍承认的类似于交叉验证这样的验证方法。</p>
<p>无监督学习在很多领域都很重要。一个癌症研究者可能会得到100个乳腺癌患者的基因型表达水平数据集，他/她可能会想看一下这些样本能不能划分出子群体，或者这些基因能不能划分出子群体，从而对这个癌症有更好的认知。一个网购平台可能会想将相似的浏览历史和购买历史的顾客划分到一个子群体中，这就是所谓的市场细分，这样方便推送顾客可能会购买的商品广告。一个搜索引擎同样需要将不同的网页进行聚类。上面的这些例子都是通过无监督学习实现的。</p>
<h1>Principle Components Analysis</h1>
<p>当特征很多时，我们无法进行简单地可视化来查看样本之间的关系。如果我们能把原始数据转换成一个二维的数据 (p=2)，并且这两个新的特征能够捕获绝大多数信息，那么就可以根据这两个新的特征画散点图，描述观测值之间的关系。</p>
<p>主成分分析就可以做到这一点，主成分会创建包换尽可能多的变异的新特征，所有的主成分都是旧的p个特征的线性组合。例如，第一主成分表示为下式，第一主成分方差最大。</p>
<p style=""><img src="https://math.now.sh?from=Z_%7B1%7D%3D%5Cphi_%7B11%7D%20X_%7B1%7D%2B%5Cphi_%7B21%7D%20X_%7B2%7D%2B%5Cldots%2B%5Cphi_%7Bp%201%7D%20X_%7Bp%7D%0A" /></p><p>可能的参数需要满足下列条件：</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cphi_%7Bj%201%7D%5E%7B2%7D%3D1%0A" /></p><p>我们将这些参数称为第一主成分的 <em>loading</em> ， 这些 <em>loading</em> 组成了 <em>loading vector</em> 。</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft.%5Cphi_%7B1%7D%3D%5Cbegin%7Barray%7D%7Bcccc%7D%0A%28%5Cphi_%7B11%7D%20%26%20%5Cphi_%7B21%7D%20%26%20%5Cldots%20%26%20%5Cphi_%7Bp%201%7D%0A%5Cend%7Barray%7D%5Cright%29%5E%7BT%7D%0A" /></p><p>假设我们有一个 n × p 的数据集，我们如何计算第一主成分呢？因为我们需要计算方差，因此<strong>我们这里需要先对 X 进行中心化</strong>（使得X每列均值为0）。然后我们计算线性组合如下</p>
<p style=""><img src="https://math.now.sh?from=z_%7Bi%201%7D%3D%5Cphi_%7B11%7D%20x_%7Bi%201%7D%2B%5Cphi_%7B21%7D%20x_%7Bi%202%7D%2B%5Cldots%2B%5Cphi_%7Bp%201%7D%20x_%7Bi%20p%7D%0A" /></p><p>求解下式，即 Z<sub>i1</sub> 的方差需要最大化，这可以用线性代数中的特征值分解计算得到。这里由于所有特征均值为 0， 因此 Z<sub>i1</sub> 均值也为0。</p>
<p style=""><img src="https://math.now.sh?from=%5Cunderset%7B%5Cphi_%7B11%7D%2C%20%5Cldots%2C%20%5Cphi_%7Bp%201%7D%7D%7B%5Coperatorname%7Bmaximize%7D%7D%5Cleft%5C%7B%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cphi_%7Bj%201%7D%20x_%7Bi%20j%7D%5Cright%29%5E%7B2%7D%5Cright%5C%7D%20%5Ctext%20%7B%20subject%20to%20%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cphi_%7Bj%201%7D%5E%7B2%7D%3D1%0A" /></p><p>这里最终计算得到的 z<sub>11</sub>, …… , z<sub>n1</sub> 称为 <em>scores</em> 。</p>
<p>这里有一个对于第一主成分的几何学解释，第一主成分的 <em>loading vector</em> 其实构成了特征空间中的一个方向，再这个方向上数据 <em>vary the most</em> 。如果我们将这 n 个观测值投影到这个方向上，那么投影的值就是第一主成分的 <em>scores</em> ，即 z<sub>11</sub>, …… , z<sub>n1</sub> 。</p>
<p>下图为 p=2 的两个主成分的例子，其中的绿线便为第一组分的方向。</p>
<p><img src="1.png" alt="1"></p>
<p>我们计算得到第一主成分以后，我们就接着找第二主成分。第二主成分同样是p个特征的线性组合，是与第一主成分无关且方差最大的组合。</p>
<p>第二主成分的 scores 格式如下：</p>
<p style=""><img src="https://math.now.sh?from=z_%7Bi%202%7D%3D%5Cphi_%7B12%7D%20x_%7Bi%201%7D%2B%5Cphi_%7B22%7D%20x_%7Bi%202%7D%2B%5Cldots%2B%5Cphi_%7Bp%202%7D%20x_%7Bi%20p%7D%0A" /></p><p>第二主成分与第一主成分无关，等同于要求<strong>二者方向正交</strong>。在上图 6.14 中，由于 p=2，因此与第一主成分正交只有一种可能，因此一旦确定了第一主成分，那么第二主成分也随之确定了。</p>
<p>这里举个例子，数据为美国50个州的犯罪记录，特征包括三种犯罪 (Assault, Murder, Rape) 在 10万人中的逮捕人数，还包括了每个州城市化率 (UrbanPop），因此这里 n=50 ，p=4 。我们在进行PCA分析前，先对数据进行<strong>标准化</strong>（均值为0，标准差为1）。下图为前两个方差组分的结果，这里同时还体现了 <em>loading vectors</em> 的结果（第一主成分和第二主成分的loading 组成的方向），这种图一般称为 <em>biplot</em> 。</p>
<p><img src="2.png" alt="1"></p>
<p><em>loading vectors</em> 的值见下表。从这个表里，我们可以看到第一主成分在 UrbanPop 的权重较小，而第二主成分的主要权重则均在 UrbanPop  上。联立这个表和上面的图示，我们可以看出三种犯罪类型的变量彼此紧密关联，但是城市化率和这这三个变量相关较弱，这说明某一种犯罪较为猖狂的城市其他犯罪可能也比较严重。</p>
<p><img src="3.png" alt="1"></p>
<p>我们同样可以通过上图检验样本之间的差别。根据我们对 <em>loading vectors</em> 的讨论，我们发现第一主成分值很高的城市，比如  California, Nevada 和 Florida 可能有很高的犯罪率，而像North Dakota 这种第一主成分为负数的州可能犯罪率较低。同时 California 的第二主成分也很高，这说明它的城市化率可能较高。</p>
<h2 id="Another-Interpretation-of-Principal-Components">Another Interpretation of Principal Components</h2>
<p>下图为一个 p=3 的两个主成分的例子，我们看到两个 <em>loading vectors</em> 组成了一个平面，把观测值投射到这个平面上，方差最大。</p>
<p><img src="4.png" alt="1"></p>
<p>在前面，我们提到 <em>loading vectors</em>  是特征空间中数据变异最丰富的方向，而 <em>scores</em> 则是数据向 <em>loading vectors</em>  方向上的投射。我们还可以用另外一种方式进行解释：主成分生成了与观测点<strong>距离最近</strong>的低维线性平面。</p>
<p>第一主成分的 <em>loading vector</em> 很特别：它构成的直线是距离这 n 个观测点<strong>最近</strong>的直线。所谓最近指的是欧几里得距离。</p>
<p>我个人感觉<strong>变异最丰富</strong>和<strong>距离最近</strong>是两个性质，变异最丰富并不需要距离最近。例如 p =2 的情况下，变异最丰富其实可以画出无数的平行线，这些平行线都满足变异最丰富。因此上文对于参数的取值有一个限定条件，参数平方和为1，应该是加了这个限制条件才满足了距离最近这个性质。</p>
<p>通过这个解释，我们构建的前M个 <em>score vectors</em> 和 <em>loading vectors</em>  构成了观测值的最佳的 M维的近似值。</p>
<p>这可以写成下式（没看懂）。（假定初始的X是中心化的）</p>
<p style=""><img src="https://math.now.sh?from=x_%7Bi%20j%7D%20%5Capprox%20%5Csum_%7Bm%3D1%7D%5E%7BM%7D%20z_%7Bi%20m%7D%20%5Cphi_%7Bj%20m%7D%0A" /></p><p>这说明如果M较大的话，我们可以用PCA结果计算得到X的近似值。PCA分析 M 的最大值为 min(n-1, p) 。</p>
<h2 id="More-on-PCA">More on PCA</h2>
<h3 id="Scaling-the-Variables">Scaling the Variables</h3>
<p>上面提到过，进行PCA分析前，<strong>必须先对X进行中心化</strong>。另外 X 的方差也会对结果造成影响：</p>
<blockquote>
<p><em>the results obtained when we perform PCA will also depend on whether the variables have been individually scaled (each multiplied by a different constant)</em></p>
</blockquote>
<p>如果你对某个特征，乘以某个常数，这就会造成 <em>scale</em> 的变化，最终造成结果变化。不同的方法对于 <em>scale</em> 的影响不一样，比如线性回归压根不受到 <em>scale</em> 的影响（线性回归中如果对某个自变量乘以一个常数 c，那么最后估计的系数会乘以 1/c，最终的模型不会受到实质性影响）。</p>
<p>上面美国不同的州的犯罪率的例子中，我们事先对特征进行了标准化。原始数据4个特征的方差为 18.97, 87.73, 6945.16 和 209.5。因此，如果直接用原始数据 (<em>unscaled data</em>) 进行PCA分析，那么第一主成分会主要偏向于第3个特征，因为第3个特征的方差最高。事实上，第一主成分的所有权重基本都在第3个特征上。</p>
<p>下图为采用标准化的数据 (左) 和未标准化的数据 (右) 的两次PCA分析比对。我们可以看到对于原始数据，第一主成分基本沿着 Assault 的方向（第3个特征），第二主成分基本验证 UrbanPop 的方向。因此，<strong>是否进行方差标准化，会直接影响PCA结果</strong>。</p>
<p><img src="5.png" alt="1"></p>
<p><strong>如果不同的特征的单位不同，那么我们一般会在PCA分析前进行数据标准化</strong>。<strong>但是在某些情况下，如果所有特征的单位相同，我们可能不希望将所有的特征的方差调整为1</strong>。</p>
<h3 id="Uniqueness-of-the-Principal-Components">Uniqueness of the Principal Components</h3>
<p>不同软件计算的主成分的 <em>loading vector</em> 的数值都是相同，但是符号可能相反。比如(0.5, 0.5) 和 (-0.5, -0.5) ，数值相同，符号相反，但是其实还是在一条直线上。</p>
<h3 id="The-Proportion-of-Variance-Explained">The Proportion of Variance Explained</h3>
<p>做完PCA分析后，我们可能想知道每个主成分解释的方差比例 ( <em>proportion of variance explained</em>(PVE) )。</p>
<p>数据集中总的方差定义如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Coperatorname%7BVar%7D%5Cleft%28X_%7Bj%7D%5Cright%29%3D%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20x_%7Bi%20j%7D%5E%7B2%7D%0A" /></p><p>然后第 m 个主成分解释的方差为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20z_%7Bi%20m%7D%5E%7B2%7D%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cphi_%7Bj%20m%7D%20x_%7Bi%20j%7D%5Cright%29%5E%7B2%7D%0A" /></p><p>因此第m个主成分的PVE为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cphi_%7Bj%20m%7D%20x_%7Bi%20j%7D%5Cright%29%5E%7B2%7D%7D%7B%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20x_%7Bi%20j%7D%5E%7B2%7D%7D%0A" /></p><p>在上面的美国犯罪数据集中，第一个主成分解释了 62% 的方差，第二主成分解释了 24.7% 的方差。二者之和解释了 87% 的方差，而最后两个主成分只有 13% 的方差（总的主成分数目为 min(n-1,p) ）。这说明在这个数据中，只用两个主成分就已经很好地体现总体数据的情况。 每个主成分的PVE 和累计PVE 见下图，其中左图又称为 <em>scree plot</em> 。</p>
<p><img src="6.png" alt="1"></p>
<h3 id="Deciding-How-Many-Principal-Components-to-Use">Deciding How Many Principal Components to Use</h3>
<p>在实际的PCA分析中，我们一般只会用前几个主成分来进行可视化或解释数据，因此我们需要知道需要的主成分数目的<strong>最小值</strong>，才可以较好地把握整个数据集。或者说，我们到底需要几个主成分？</p>
<p>一般我们可以用上图左图（又称为 <em>scree plot</em> ）来决定，通过肉眼来看需要几个主成分，实际上这是一个比较主观的事情，这也是无监督学习的一个特点。</p>
<h3 id="Other-Uses-for-Principal-Components">Other Uses for Principal Components</h3>
<p>我们可以直接用主成分分析的 <em>score vectors</em> 作为新的特征，用于回归问题、分类问题和聚类问题。这种做法的优点是<strong>降低计算量</strong>和<strong>减少噪音的影响</strong>。减少计算量是由于特征数目减少了，而减少噪音的影响是由于<em>signal</em> ( 与 noise 相反) 往往会集中在前几个主成分当中。</p>
<h1>Clustering Methods</h1>
<p>聚类方法就是看能不能把观测值划分成不同的子群体，在同一个子群体内的个体具有相似的特征，而不同的子群体的个体之间则很不相同。这里我们首先要定义<strong>个体之间如何才叫相似或不同</strong>，这需要根据我们对数据集的认知进行特定地考虑。</p>
<p>假设我们有一个 n × p 的数据集，n 个观测值均来自于乳腺癌患者的样本，p 个特征是这些样本的测量值，包括一些临床指标，如肿瘤等级，又或者是基因表达量数据。我们怀疑这n个样本可能存在一定的异质性，比如乳腺癌可能还有一些不为人知的子类型，如何找出这些样本的结构，这就是一个无监督学习的任务。</p>
<p>聚类分析的另一个应用是<strong>市场细分</strong>。</p>
<p>总的来说，我们既可以通过观测值 (Y) 来对观测值进行聚类，也可以通过特征 (X) 进行聚类，二者仅仅是用的数据集不一样，方法相同。下面只考虑基于特征数据集的聚类。</p>
<h2 id="K-Means-Clustering">K-Means Clustering</h2>
<p>K-均值算法是一种将所有观测值划分为 K个不同的<strong>无重叠</strong>的子群体。执行这个算法前，我们需要事先指定子群体的数目K，然后所有的观测值就会被精确划分到某一个子群体中。下图为对 150×2 的数据集聚类的结果</p>
<p><img src="7.png" alt="1"></p>
<p>这里我们标记子群体为 C<sub>1</sub>, …… , C<sub>K</sub> 。一个好的分类是<strong>子群体内方差</strong> (<em>within-cluster variation</em>) 尽可能地小。针对C<sub>K</sub>子群体的子群体内方差标记为 W(C<sub>K</sub>)，适用于衡量这个子群体内的观测值之间的区别。</p>
<p>因此，这种算法需要解决的问题标记如下，即总的子群体内方差最小。</p>
<p style=""><img src="https://math.now.sh?from=%5Cunderset%7BC_%7B1%7D%2C%20%5Cldots%2C%20C_%7BK%7D%7D%7B%5Coperatorname%7Bminimize%7D%7D%5Cleft%5C%7B%5Csum_%7Bk%3D1%7D%5E%7BK%7D%20W%5Cleft%28C_%7Bk%7D%5Cright%29%5Cright%5C%7D%0A" /></p><p>这里我们还需要定义 W(C<sub>K</sub>) ，这个有多种方式，一般定义如下。</p>
<p style=""><img src="https://math.now.sh?from=W%5Cleft%28C_%7Bk%7D%5Cright%29%3D%5Cfrac%7B1%7D%7B%5Cleft%7CC_%7Bk%7D%5Cright%7C%7D%20%5Csum_%7Bi%2C%20i%5E%7B%5Cprime%7D%20%5Cin%20C_%7Bk%7D%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%5Cleft(x_%7Bi%20j%7D-x_%7Bi%5E%7B%5Cprime%7D%20j%7D%5Cright)%5E%7B2%7D%0A" /></p><p>这里 |C<sub>K</sub>| 指第K个子群体的观测值数目。这个公式的含义就是第K个子群体内所有配对的欧几里得距离的平方的均值。</p>
<p>结合上面上面两个式子，我们得到需要解决的问题为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cunderset%7BC_%7B1%7D%2C%20%5Cldots%2C%20C_%7BK%7D%7D%7B%5Coperatorname%7Bminimize%7D%7D%5Cleft%5C%7B%5Csum_%7Bk%3D1%7D%5E%7BK%7D%20%5Cfrac%7B1%7D%7B%5Cleft%7CC_%7Bk%7D%5Cright%7C%7D%20%5Csum_%7Bi%2C%20i%5E%7B%5Cprime%7D%20%5Cin%20C_%7Bk%7D%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%5Cleft%28x_%7Bi%20j%7D-x_%7Bi%5E%7B%5Cprime%7D%20j%7D%5Cright%29%5E%7B2%7D%5Cright%5C%7D%0A" /></p><p>因此，我们需要找到一个算法来解决这个问题。这其实是一个很难的问题，因为有很多潜在的聚类方式。如果我们要遍历所有可能的聚类方式，那么总的计算次数就可能是一个天文数字。幸运地是，我们有一个算法来计算得到一个局部最优解。算法描述如下：</p>
<p><img src="8.png" alt="1"></p>
<p>这个算法确保每一步迭代总的子群体内方差都会降低。为了理解这一点，我们需要理解下面的式子。</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B1%7D%7B%5Cleft%7CC_%7Bk%7D%5Cright%7C%7D%20%5Csum_%7Bi%2C%20i%5E%7B%5Cprime%7D%20%5Cin%20C_%7Bk%7D%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%5Cleft%28x_%7Bi%20j%7D-x_%7Bi%5E%7B%5Cprime%7D%20j%7D%5Cright%29%5E%7B2%7D%3D2%20%5Csum_%7Bi%20%5Cin%20C_%7Bk%7D%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%5Cleft(x_%7Bi%20j%7D-%5Cbar%7Bx%7D_%7Bk%20j%7D%5Cright)%5E%7B2%7D%0A" /></p><p>其中的 X<sub>kj</sub>  bar 是 C<sub>k</sub> 子群体内特征j 的均值，计算公式如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbar%7Bx%7D_%7Bk%20j%7D%3D%5Cfrac%7B1%7D%7B%5Cleft%7CC_%7Bk%7D%5Cright%7C%7D%20%5Csum_%7Bi%20%5Cin%20C_%7Bk%7D%7D%20x_%7Bi%20j%7D%0A" /></p><p>这里ISL 还是没有讲清楚为什么每一步迭代总的子群体内方差都只会降低，最终不再变化，形成一个局部最优解。下图为每一步迭代的图示效果。</p>
<p><img src="9.png" alt="1"></p>
<p>因为 K-均值算法得到的是<strong>局部</strong>最优解，而不是全局最优解，<strong>最终的聚类结果受到了算法第一步随机分类结果的影响</strong>。针对这个原因，我们需要用多个初始随机的配置来进行多次聚类，然后我们挑其中最好的结果（总的子群体内方差最低）。</p>
<p>下图为6次使用不同的初始配置的聚类结果，其中总的子群体内方差为 235.8 的聚类结果是我们最终选的结果。</p>
<p><img src="10.png" alt="1"></p>
<p>从这个图来看，我感觉聚类也只能是做<strong>探索性分析</strong>，受到的影响因素比较多，没法说两个个体没有聚到一类就一定差异很大。</p>
<h2 id="Hierarchical-Clustering">Hierarchical Clustering</h2>
<p>K-均值算法的一个潜在的缺点在于需要事先指定子群体数目K。层次聚类是一种不需要指定K的算法，它的优点是最终会以一个决策树的形式展示聚类结果，称为 <em>dendrogram</em> 。</p>
<h3 id="Interpreting-a-Dendrogram">Interpreting a Dendrogram</h3>
<p>这里我们用一个 45 × 2 的数据集，见下图。这个数据来自于3个子群体，在图上用不同的颜色进行标记了（也就是说，我们知道真实的聚类结果）。</p>
<p><img src="11.png" alt="1"></p>
<p>层次分析结果见下图中的左图。如何去看这个结果呢？从下往上看，决策树的每个叶子表示一个观测值，然后这些叶子会汇聚成一个分支，小分支又能汇聚成更大的分支，以此往复直到决策树的根部。小分支内的个体间的相似性高于大分支。</p>
<p>如何看两个个体的相似性呢？我们需要找到这两个个体第一次合并到成一个分支的节点，查看这个节点在纵坐标的位置，这个值越小说明关系越近。</p>
<p><img src="12.png" alt="1"></p>
<p>我们在解读这张图的时候容易出现一些误区。下图为 9 × 2 的数据集的聚类结果，我们可以认为1和6，5和7很相似，这没有问题，因为它们都在最低的水平。但是，你不能仅仅看着9和2很接近，就认为 9 和 2 很相似，这是错误的，事实上， 9和 2 8 5 7 这四个观测值的距离都差不多，如下图右图所示。</p>
<p>这个误区就是你不能根据横向位置来判断观测值之间的远近，而<strong>只能根据纵向位置判断</strong>。横向位置并不可靠，比如这里 1 和 6 可以互换位置，聚类结果其实没变；又或者 2 所在的左支和 8 5 7 所在的右枝互换位置，这个时候你就看着 9 和 2 的横向距离远了，但是聚类结果没变。</p>
<p><img src="13.png" alt="1"></p>
<p>通过在某个纵坐标上拉一道口子，画一条线，我们可以划分出任意 K 个 cluster ，比如上图10.9 的中间的图和右图分别划分出2个和3个 <em>clusters</em> 。</p>
<p>层次聚类的名称也来自于这一特性，纵坐标的低点划分的 clusters 一定包含在纵坐标的高点划分的 clusters 内，也就是存在嵌套关系。但是有时实际数据可能并不满足这种假设，例如假设我们有个数据集，里面男女各一半，然后又可以分为美国人、日本人和法国人。我们可以想象，如果我们要聚成2类，我们希望按照性别划分；如果要聚成3类，我们希望按照国籍划分。这种情况下，真实的分类并不是嵌套的，因此K=3的聚类并不包含K=2的结果内。因此这种情况下，层次聚类的结果可能会会比 K-均值聚类的效果更差。</p>
<h3 id="The-Hierarchical-Clustering-Algorithm">The Hierarchical Clustering Algorithm</h3>
<p>层次聚类算法很简单，我们首先要定义很来奶两个观测值之间的 <em>dissimilarity</em> 的指标。一帮我们会用欧几里得距离。算法具体描述如下：</p>
<p><img src="14.png" alt="1"></p>
<p>下图为图10.10 聚类的前几步图示。</p>
<p><img src="15.png" alt="1"></p>
<p>这个算法看上去很简单，但是还有一个问题没解决。例如上图右下图，我们如果决定 {5，7}  和 8 的不相似性呢？上面我们只提到了两个点之间的不相似性，我们如何两个 <em>cluster</em> 之间的不相似性呢？我们一半称两个 <em>cluster</em> 之间的不相似性称为 <em>linkage</em> 。下表描述了四种常见的 <em>linkage</em> ，一般我们会用 Average 和 complete 。</p>
<p><img src="16.png" alt="1"></p>
<p>层次聚类的结果受 <em>linkage</em> 的影响很大，见下图</p>
<p><img src="17.png" alt="1"></p>
<h3 id="Choice-of-Dissimilarity-Measure">Choice of Dissimilarity Measure</h3>
<p>一般来说，我们会用欧几里得距离作为 <em>dissimilarity</em> 的衡量指标，但是有时我们可能会想用别的指标。例如，我们可能会用两个观测值特征之间的相关系数作为评价指标，而不是距离。下图展示基于相关系数和欧几里得距离的层次聚类结果，观测值1和3的欧几里得距离很近，但是它们的相关很低；观测值1和2的欧几里得距离很远，但是相关程度很高。</p>
<p><img src="18.png" alt="1"></p>
<p><em>dissimilarity</em> 的衡量指标的选择非常重要，我们需要根据数据类型和目的进行确定。例如一个电商想要根据消费者的消费记录进行聚类。我们的目的是找到消费习惯相同的消费者，然后聚成不同的类，特定投放不同的广告。假设数据集的形式是每一行表示一个消费者，每一列表示一种商品，元素只能是0和1，0表示没买过，1表示买过。这里我们应该用什么衡量 <em>dissimilarity</em> 的指标呢？</p>
<p>如果我们用欧几里得距离，那么哪些买过商品的总数很少的顾客会被聚成一堆，这不是我们想要的结果。但是，如果我们用相关系数，那么有着相似的消费习惯的顾客会被聚成一堆（比如都买过A和B, 但是都没买过C和D的顾客），即便有些顾客的总的商品消费数目更高。因此在这种情况下，更适合使用相关系数。</p>
<p>除了 <em>dissimilarity</em> 的衡量指标，我们还需要考虑聚类前要不要进行<em><strong>scale</strong></em>，将所有特征的标准差均调整为1。为了说明这一点，我们还是用电商的例子，有些商品的购买次数可能会比较频繁，比如袜子；有些商品的购买次数会比较少，比如电脑。高频购买的商品可能在计算 <em>dissimilarity</em> 时比低频购买商品有更高的作用，最终在聚类结果中的作用也更大。如果我们事先将所有特征的标准差均调整为1，那么所有特征对于层次聚类的重要性均相同。最终要不要进行 <em>scale</em> 需要具体情况具体分析，在这个电商的例子中我们可能会选择进行 <em>scale</em> 。</p>
<p>下图是是否进行 <em>scale</em> 效果的图示，这一点对 K-均值聚类也有作用。左图为两种商品8个消费者的消费数目，中间的图为 <em>scale</em> 之后的效果，右图的纵坐标为换成消费金额的效果。</p>
<p><img src="19.png" alt="1"></p>
<h2 id="Practical-Issues-in-Clustering">Practical Issues in Clustering</h2>
<p>实际聚类时需要关注的问题。</p>
<h3 id="Small-Decisions-with-Big-Consequences">Small Decisions with Big Consequences</h3>
<p>聚类之前，我们需要先做一些决定。</p>
<ul>
<li>数据是否需要进行标准化（均值为0，标准差为1）</li>
<li>如果使用层次聚类
<ul>
<li>使用哪一种 <em>dissimilarity</em> 的衡量指标</li>
<li>使用哪一种 <em>linkage</em></li>
<li>我们最终在决策树上什么地方划一道水平线，来获得具体的 clusters</li>
</ul>
</li>
<li>如果使用 K-均值聚类，K值设定为多少</li>
</ul>
<p>这些决定影响很大，但是都是不存在一个唯一的真实答案的，都需要进行主观判断。我们一般可能会测试几次，然后挑一次结果。</p>
<h3 id="Validating-the-Clusters-Obtained">Validating the Clusters Obtained</h3>
<p>当我们聚类后，我们会想知道我们聚类的结果是不是就是真实的结果，还是仅仅是 <em>clustering the noise</em> 。比如，如果我们有一个独立的新的数据，那么这些数据能不能会被用同样的方式进行聚类？现在有一些新方法可以提供一个 p 值，来评价一个cluster 和我们完全随机分组相比的概率，但是目前还没有达到一个统一的共识。</p>
<h3 id="Other-Considerations-in-Clustering">Other Considerations in Clustering</h3>
<p>K-均值聚类和层次聚类都会将所有的观测值划分到某个子群体中。但是数据中可能会存在离群点，这些点不属于任何一个 cluster ，但是由于这两种聚类方法一定要把所有的观测点都放到某个子群体中，因此<strong>离群点会非常影响聚类结果</strong>。（那我能不能先用PCA分析找到离群点，剔除离群点之后再进行聚类呢？）</p>
<p>聚类方法还有一个缺点是不稳健。比如你用 n 个观测值聚类了一次，然后你随机地剔除了一小撮个体，再聚类一次，你可能会得到一个不一样的结果。</p>
<h3 id="A-Tempered-Approach-to-Interpreting-the-Results-of-Clustering">A Tempered Approach to Interpreting the Results of Clustering</h3>
<p>综合上述，你可能挑选不同的指标来做聚类的测试，最终挑选一个你觉得比较好的聚类结果。最后你可能还需要从原数据集中随机挑选一些子集，查看聚类结果的稳健性。最后的最后，你一定要注意解释聚类结果的方式，<strong>你绝对不能认为聚类结果是绝对的真实情况</strong>，你只能把聚类结果当成之后深入研究的起点（最好是用另一个独立的数据集进行进一步研究）。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Support Vector Machines</title>
    <url>/posts/4de29630/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>ISL 真是好书！</p>
<span id="more"></span> 
<h1>资料</h1>
<p><a href="https://www.statlearning.com/">An Introduction to Statistical Learning</a>，下文简称 <strong>ISL</strong></p>
<h1>Maximal Margin Classifier</h1>
<h2 id="What-Is-a-Hyperplane">What Is a Hyperplane?</h2>
<p>超平面 (<em>hyperplane</em>) 是指在 p 维空间中维度为 p-1 的子空间。例如，对于二维空间，超平面就是一条线；在三维空间，超平面就是一个二维的平面。</p>
<p>超平面的数学定义很简单，但与一个二维空间的超平面，定义如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20X_%7B1%7D%2B%5Cbeta_%7B2%7D%20X_%7B2%7D%3D0%0A" /></p><p>我们可以看到这就是一条直线的表达式。</p>
<p>因此，我们可以推断出 p 维空间的超平面的一般表达式如下：如果一个点满足下列式子，则在超平面上。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20X_%7B1%7D%2B%5Cbeta_%7B2%7D%20X_%7B2%7D%2B%5Cldots%2B%5Cbeta_%7Bp%7D%20X_%7Bp%7D%3D0%0A" /></p><p>如果一个点 X 不在超平面上，即上面的这个式子不为0（大于0 或 小于0），我们称这个点在超平面的一侧。因此，<strong>超平面将这个空间分为了两半</strong>，下图为二维空间超平面划分出的两个空间示意图。</p>
<p><img src="1.png" alt="1"></p>
<h2 id="Classification-Using-a-Separating-Hyperplane">Classification Using a Separating Hyperplane</h2>
<p>假设我们有一个 n×p 的数据集 X，包好 n 条观测值 和 p 个特征。这些观测值只有两个水平，-1 和 1。我们同时还有一个验证集。我们的目的是通过训练集构建一个 classfier，可以正确地对验证集进行分类。这里我们有很多方法可以用，经典地方法有线性判别分析和逻辑回归，决策树方法有分类树、bagging、boosting 。现在我们剔除一个基于 <em>separating hyperplane</em> 概念的新方法。</p>
<p>假设我们可以构建一个超平面，可以完美地区分训练集中不同的观测值，例如下图的左图就显示了3种  <em>separating hyperplane</em>  的例子。</p>
<p><img src="2.png" alt="1"></p>
<p>左图划分的公式如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20x_%7Bi%201%7D%2B%5Cbeta_%7B2%7D%20x_%7Bi%202%7D%2B%5Cldots%2B%5Cbeta_%7Bp%7D%20x_%7Bi%20p%7D%3E0%20%5Ctext%20%7B%20if%20%7D%20y_%7Bi%7D%3D1%20%5Ctext%20%7B%20%2C%20%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20x_%7Bi%201%7D%2B%5Cbeta_%7B2%7D%20x_%7Bi%202%7D%2B%5Cldots%2B%5Cbeta_%7Bp%7D%20x_%7Bi%20p%7D%3C0%20%5Ctext%20%7B%20if%20%7D%20y_%7Bi%7D%3D-1%0A" /></p><p>因此，这里的一个 <em>separating hyperplane</em> 均具有下面的属性：</p>
<p style=""><img src="https://math.now.sh?from=y_%7Bi%7D%5Cleft%28%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20x_%7Bi%201%7D%2B%5Cbeta_%7B2%7D%20x_%7Bi%202%7D%2B%5Cldots%2B%5Cbeta_%7Bp%7D%20x_%7Bi%20p%7D%5Cright%29%3E0%0A" /></p><p>如果我们能构建一个 <em>separating hyperplane</em>，我们就可以用它作为一个 <em>classifier</em> ，直接用在验证集中，效果如上图9.2 右图，预测值取决于上面的式子的符号，大于0则预测为1，小于0则预测为-1。我们同时可以利用上面式子的大小，越大说明预测值越可信。</p>
<p>通过这个例子，我们可以看到，通过 <em>separating hyperplane</em> 这种思想，我们最终构建的是一个<strong>线性决策线</strong>。</p>
<h2 id="The-Maximal-Margin-Classifier">The Maximal Margin Classifier</h2>
<p>一般来说，如果我们可以通过一个超平面来<strong>完美</strong>地划分我们的数据，那么实际上存在无数条这样的可能的超平面。如果需要通过 <em>separating hyperplane</em> 方法来构建一个 classfier ，那么我们需要决定使用哪一个 <em>separating hyperplane</em> 。</p>
<p>一个自然的方法是 <em>the maximal margin classifier</em> ，也称为 <em>optimal separating hyperplane</em> ，即选择与训练集所有的观测点距离最远的 <em>separating hyperplane</em> 。我们可以计算所有观测点到一个给定的 <em>separating hyperplane</em> 的直线距离，所有点的直线距离的最小值称为 <em>margin</em> 。<em>the maximal margin classifier</em> 是 <em>margin</em> 最大的超平面（即所有点的最小直线距离 <em>margin</em> 最大）。虽然这种方法一般很成功，但是当p很大，可能会造成 <em><strong>overfitting</strong></em>。</p>
<p>下图展示了用上图9.2训练集数据计算的最大边际分类器的结果。<em>margin</em> 体现为虚线和实线的直线距离，我们可以看到有3个点与分类器的距离最小，这三个点一般也被称为 <em>support vectors</em> ，因为它们是 p 维空间的向量，而且它们 “support” 我们的最大边际分类器的结果，如果我们把这些点稍微移动了一些位置，那么我们最终的分类器结果也会跟着改变。<strong>其实，最大边际分类器的构建仅取决于这几个点，和其他点毫不相关。</strong></p>
<p><img src="3.png" alt="1"></p>
<h2 id="Construction-of-the-Maximal-Margin-Classifier">Construction of the Maximal Margin Classifier</h2>
<p>简单地说，对于n × p 的训练集，反应变量只有两个水平 -1 和 1，最大边际超平面就是下面问题的解。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cunderset%7B%5Cbeta_%7B0%7D%2C%20%5Cbeta_%7B1%7D%2C%20%5Cldots%2C%20%5Cbeta_%7Bp%7D%2C%20M%7D%7B%5Coperatorname%7Bmaximiize%7D%7D%20M%20%5C%5C%0A%26%5Ctext%20%7B%20subject%20to%20%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%5E%7B2%7D%3D1%2C%20%5C%5C%0A%26y_%7Bi%7D%5Cleft%28%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20x_%7Bi%201%7D%2B%5Cbeta_%7B2%7D%20x_%7Bi%202%7D%2B%5Cldots%2B%5Cbeta_%7Bp%7D%20%20x_%7Bi%20p%7D%5Cright%29%20%5Cgeq%20M%20%5Cquad%20%5Cforall%20i%3D1%2C%20%5Cldots%2C%20n%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>首先假定 M 大于0，那个式子就保证了训练集中所有的观测值均会正确地分类。基于上式第二行的条件，可以推断出，点到超平面的直线距离就是下式。（未证明）</p>
<p style=""><img src="https://math.now.sh?from=y_%7Bi%7D%5Cleft%28%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20x_%7Bi%201%7D%2B%5Cbeta_%7B2%7D%20x_%7Bi%202%7D%2B%5Cldots%2B%5Cbeta_%7Bp%7D%20x_%7Bi%20p%7D%5Cright%29%0A" /></p><p>因此，这个式子确保了所有观测值均被正确分类了，并且与超平面的距离至少为 M，即 M 就是 <em>margin</em> 。然后，我们需要挑出一组 β ，使得 M 的值最大。</p>
<h2 id="The-Non-separable-Case">The Non-separable Case</h2>
<p>上面的方法有一个缺点，有些时候根本不存在  <em>separating hyperplane</em> ，所以也就不存在最大边际超平面。带入上式即为，找不到 M &gt; 0 的解，下图为一个例子。</p>
<p><img src="4.png" alt="1"></p>
<p>我们可以把这个思路扩展一下，改成找到一个能正确分类大多数观测点的超平面，这个方法称为 <em>support vector classifier</em> 。</p>
<h1>Support Vector Classifier</h1>
<p>如上图所示，有些时候我们无法找到一个能把所有观测值正确分开的超平面。事实上，即便真的存在 <em>separating hyperplane</em> ，有时这个超平面构建成的分类器可能也不理想。由于要将所有观测值均要正确分开，因此 <em>separating hyperplane</em> 会对于个体观测值非常敏感。下图为一个例子，右图中仅仅是新增了一个观测值就导致最大边际超平面发生了很大的改变，新的超平面其实并不理想，比如说这个超平面的 <em>margin</em> 非常小。</p>
<p><img src="5.png" alt="1"></p>
<p>由于最大边际超平面对于单个观测值的变化非常敏感，因此非常容易造成过拟合的现象。</p>
<p>因此这种情况下，我们可能更希望想要一个<strong>不是完美分类</strong>的分类器，优点在于更加稳健，不容易受到个别极端值的影响。也就是说，训练集中一小撮的观测值被错误分类是允许的，这是为了让剩下的大部分观测值的预测更加稳定。</p>
<p>上述思想一般就称为 <em>support vector classifier</em> ，有时也称为 <em>soft margin classifier</em> ，效果见下图。左图我们可以看到大部分点在划分的margin 线以外，有几个点在划分的 margin 线以内；右图甚至有几个点直接判别错误（在超平面的另一边），如 11 和 12 。</p>
<p><img src="6.png" alt="1"></p>
<h2 id="Details-of-the-Support-Vector-Classifier">Details of the Support Vector Classifier</h2>
<p><em>support vector classifier</em> 方法的数学式子如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cunderset%7B%5Cbeta_%7B0%7D%2C%20%5Cbeta_%7B1%7D%2C%20%5Cldots%2C%20%5Cbeta_%7Bp%7D%2C%20%5Cepsilon_%7B1%7D%2C%20%5Cldots%2C%20%5Cepsilon_%7Bn%7D%2C%20M%7D%7B%5Coperatorname%7Bmaximize%7D%7D%20M%20%5C%5C%0A%26%5Ctext%20%7B%20subject%20to%20%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%5E%7B2%7D%3D1%2C%20%5C%5C%0A%26y_%7Bi%7D%5Cleft%28%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20x_%7Bi%201%7D%2B%5Cbeta_%7B2%7D%20x_%7Bi%202%7D%2B%5Cldots%2B%5Cbeta_%7Bp%7D%20x_%7Bi%20p%7D%5Cright%29%20%5Cgeq%20M%5Cleft(1-%5Cepsilon_%7Bi%7D%5Cright)%2C%20%5C%5C%0A%26%5Cepsilon_%7Bi%7D%20%5Cgeq%200%2C%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Cepsilon_%7Bi%7D%20%5Cleq%20C%0A%5Cend%7Baligned%7D%0A" /></p><p>这里的 C 是一个调整参数。同上，M 表示 margin ，需要寻找最大值。ε<sub>i</sub> 为松弛变量，使得有些个体可以在错误的margin 甚至是错误的 hyperplane 上；如果 ε<sub>i</sub> 等于0，那么这个观测值就在正确的 margin 一侧；如果 ε<sub>i</sub>  &gt; 0 ，那么这个观测值就在 错误的 margin 一侧；如果 ε<sub>i</sub> &gt; 1 ，那么这个观测值就在错误的 超平面一侧。</p>
<p>这里的 C 限制了 ε<sub>i</sub> 之和，因此这个参数表示我们能允许多少观测值被错误分类。如果 C = 0, 那么这就是最大边际超平面。C 的范围在 0 ~ n 之间，下图为不同 C 值的结果，左上图C值最大，之后不断减少。</p>
<p><img src="7.png" alt="1"></p>
<p>在实际情况中，我们一般用交叉验证来决定 C 值的大小。</p>
<p><em>support vector classifier</em> 有一个特性：<strong>只有在 margin 线上或在错误的margin线一侧的点才会影响 <em>support vector classifier</em> 结果</strong>；对于那些处于正确的 margin 线一侧的点，移动这些点的位置不会影响分类器。</p>
<p>因此在 margin 线上或在错误的margin线一侧的点称为 <em><strong>support vectors</strong></em> 。这和我们说 C 值控制 bias-variance trade-off 也是一致的，当 C 值很大时，存在很多观测值在错误的 margin 线一侧，即<em>support vectors</em> 很多，即构建分类器用到的点很多，所以 variance 较低（由于用到了很多的 <em>support vectors</em> ），但是可能 bias 很高，如上图左上图。当 C 值很小时，构建分类器用到的点较少，因此 variance 较高，但是 bias 较低，如右图右下图，这里其实只有 8 个 <em>support vectors</em> 。</p>
<p>这种分类器几乎不受到离超平面很远的点的影响，这个性质和其他分类方法不太一样，比如前面提到的线性判别方法 (LDA 方法需要计算每个水平所有观测值的均值，以及使用所有观测值计算水平内的方差矩阵) 。与之相反，逻辑回归对于远离决策线的观测值的敏感性很低。</p>
<h1>Support Vector Machines</h1>
<p>我们之前提到过如何将一个线性的分类器转为非线性的分类器。这里 <em>support vector machines</em> 实现了同样的效果。</p>
<h2 id="Classification-with-Non-linear-Decision-Boundaries">Classification with Non-linear Decision Boundaries</h2>
<p>有时我们会面临非线性的决策线，如下图。此时，<em>support vector classifier</em>  结果基本毫无用处。</p>
<p><img src="8.png" alt="1"></p>
<p>类似于线性模型的作法，这里我们也可以加入<strong>多项式</strong>来解决这个问题，比如对 p 个特征都添加二次型。</p>
<p style=""><img src="https://math.now.sh?from=X_%7B1%7D%2C%20X_%7B1%7D%5E%7B2%7D%2C%20X_%7B2%7D%2C%20X_%7B2%7D%5E%7B2%7D%2C%20%5Cldots%2C%20X_%7Bp%7D%2C%20X_%7Bp%7D%5E%7B2%7D%0A" /></p><p>此时的分类器算法变为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cunderset%7B%5Cbeta_%7B0%7D%2C%20%5Cbeta_%7B11%7D%2C%20%5Cbeta_%7B12%7D%20%5Cldots%2C%20%5Cbeta_%7Bp%201%7D%2C%20%5Cbeta_%7Bp%202%7D%2C%20%5Cepsilon_%7B1%7D%2C%20%5Cldots%2C%20%5Cepsilon_%7Bn%7D%2C%20M%7D%7B%5Coperatorname%7Bmaximize%7D%7D%20M%20%5C%5C%0A%26%5Ctext%20%7B%20subject%20to%20%7D%20y_%7Bi%7D%5Cleft%28%5Cbeta_%7B0%7D%2B%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%201%7D%20x_%7Bi%20j%7D%2B%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%202%7D%20x_%7Bi%20j%7D%5E%7B2%7D%5Cright%29%20%5Cgeq%20M%5Cleft(1-%5Cepsilon_%7Bi%7D%5Cright)%2C%20%5C%5C%0A%26%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Cepsilon_%7Bi%7D%20%5Cleq%20C%2C%20%5Cquad%20%5Cepsilon_%7Bi%7D%20%5Cgeq%200%2C%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Csum_%7Bk%3D1%7D%5E%7B2%7D%20%5Cbeta_%7Bj%20k%7D%5E%7B2%7D%3D1%0A%5Cend%7Baligned%7D%0A" /></p><p>这里我们可以加入更高的项，或者加入互作效应（X<sub>i</sub>X<sub>j</sub>）等。我们可能会添加了太多的变量，导致计算量失控。<em>support vector machines</em> 方法可以有效管控这一点。</p>
<h2 id="The-Support-Vector-Machine">The Support Vector Machine</h2>
<p>SVM 方法是上面 <em>support vector classifier</em> 方法的拓展，使用 <em>kernels</em> 方法来拓展变量空间。思路见上，但是 <em>kernels</em> 方法是一个有效的实现这个思路的计算方法。ISL 这里没有详细介绍 SVM 的算法。</p>
<p>下面这些论断全没有证明。</p>
<p><em>support vector classifier</em> 求解需要用到内积 (结果为一个标量)， 标量公式如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Clangle%20a%2C%20b%5Crangle%3D%5Csum_%7Bi%3D1%7D%5E%7Br%7D%20a_%7Bi%7D%20b_%7Bi%7D%0A" /></p><p>因此两个观测值x<sub>i</sub> ，x<sub>i’</sub> 的内积为</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5Clangle%20x_%7Bi%7D%2C%20x_%7Bi%5E%7B%5Cprime%7D%7D%5Cright%5Crangle%3D%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20x_%7Bi%20j%7D%20x_%7Bi%5E%7B%5Cprime%7D%20j%7D%0A" /></p><p><em>support vector classifier</em> 可以表示为下式。这里有n 个参数 α<sub>i</sub>  ，每个观测值一个参数。为了估计 f(x) ，我们需要计算新点 x 和训练集中所有的点 x<sub>i</sub> 的内积。</p>
<p style=""><img src="https://math.now.sh?from=f%28x%29%3D%5Cbeta_%7B0%7D%2B%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Calpha_%7Bi%7D%5Cleft%5Clangle%20x%2C%20x_%7Bi%7D%5Cright%5Crangle%0A" /></p><p>为了估计参数 α<sub>1</sub>, …… ，α<sub>n</sub> 和 β<sub>0</sub> ，我们需要计算训练集中所有观测值之间可能的配对的内积（需要计算 C<sup>2</sup><sub>n</sub> 次）</p>
<p>实际上，大多数点的 α<sub>i</sub> 都是0，只有 <em>support vector</em> 的 α<sub>i</sub> 不为0 。因此，假定 <em>S</em> 是所有这些 <em>support points</em> 的索引的集合，我们可以将上面的解函数写成</p>
<p style=""><img src="https://math.now.sh?from=f%28x%29%3D%5Cbeta_%7B0%7D%2B%5Csum_%7Bi%20%5Cin%20%5Cmathcal%7BS%7D%7D%20%5Calpha_%7Bi%7D%5Cleft%5Clangle%20x%2C%20x_%7Bi%7D%5Cright%5Crangle%0A" /></p><p>总结一下，<em>support vector classifier</em>  方法中估计参数和求解，都是用了求<strong>内积</strong>的方法。这里我们可以把所有求内积的地方改为一个一般化的形式：</p>
<p style=""><img src="https://math.now.sh?from=K%5Cleft%28x_%7Bi%7D%2C%20x_%7Bi%5E%7B%5Cprime%7D%7D%5Cright%29%2C%0A" /></p><p>这里的 K 指某种函数，一般称为 <em>kernel</em> 。<strong><em>kernel</em> 函数是一个度量两个观测值之间的相似性的指标</strong>。例如，我们可以使用下式，这就是内积的公式，一般也称为 <em>linear kernel</em> ，因为 <em>support vector classifier</em> 方法是线性的。 <em>linear kernel</em>  实际是采用皮尔逊相关的方法来衡量观测值之间的相似性。</p>
<p style=""><img src="https://math.now.sh?from=K%5Cleft%28x_%7Bi%7D%2C%20x_%7Bi%5E%7B%5Cprime%7D%7D%5Cright%29%3D%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20x_%7Bi%20j%7D%20x_%7Bi%5E%7B%5Cprime%7D%20j%7D%0A" /></p><p>我们可以换别的 <em>kernel</em> ，例如下式，这一般称为 <em>polynomial kernel of degree d</em> ，这里 d 是一个正整数。这时候构建的决策线就不再是线性的。</p>
<p style=""><img src="https://math.now.sh?from=K%5Cleft%28x_%7Bi%7D%2C%20x_%7Bi%5E%7B%5Cprime%7D%7D%5Cright%29%3D%5Cleft(1%2B%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20x_%7Bi%20j%7D%20x_%7Bi%5E%7B%5Cprime%7D%20j%7D%5Cright)%5E%7Bd%7D%0A" /></p><p>当采用非线性的 <em>kernel</em> 时，这时便称为 <em>support vector machine</em> 。预测函数如下：</p>
<p style=""><img src="https://math.now.sh?from=f%20%28%20x%20%29%20%3D%20%5Cbeta%20_%20%7B%200%20%7D%20%2B%20%5Csum%20_%20%7B%20i%20%5Cin%20S%20%7D%20%5Calpha%20_%20%7B%20i%20%7D%20K%20(%20x%20%2C%20x%20_%20%7B%20i%20%7D%20)%0A" /></p><p>下图中的左图显示了SVM采用多项式 kernel 的效果。</p>
<p><img src="9.png" alt="1"></p>
<p>多项式 <em>kernel</em> 仅仅是其中的一个例子，另一个可选的 <em>kernel</em> 为 <em>radial kernel</em> ，形式如下。其中的 γ 为一个正数。上图中的右图就是使用了 <em>radial kernel</em> 的效果。</p>
<p style=""><img src="https://math.now.sh?from=K%20%28%20x%20_%20%7B%20i%20%7D%20%2C%20x%20_%20%7B%20i%20%5E%20%7B%20%5Cprime%20%7D%20%7D%20%29%20%3D%20%5Coperatorname%20%7B%20exp%20%7D%20(%20-%20%5Cgamma%20%5Csum%20_%20%7B%20j%20%3D%201%20%7D%20%5E%20%7B%20p%20%7D%20(%20x%20_%20%7B%20i%20j%20%7D%20-%20x%20_%20%7B%20i%20%5E%20%7B%20%5Cprime%20%7D%20j%20%7D%20)%20%5E%20%7B%202%20%7D%20)%20.%0A" /></p><p><em>radial kernel</em> 如何工作的呢？假设我们有一个验证集观测值 x<sup>*</sup> ，这个点与一个训练集的点 x<sub>i</sub>  距离很远，那么经过一个简单的数学推理，我们知道这两个点配对的 <em>radial kernel</em>  非常小，接近于0，因此这个训练集的点对这个验证集的预测几乎没有作用。</p>
<p>使用不同的 kernel 函数，相较于使用旧的特征往特征空间中添加新的特征（比如加入二次项），优势在哪里呢？一个主要的优势就是计算量的优势。</p>
<h2 id="An-Application-to-the-Heart-Disease-Data">An Application to the Heart Disease Data</h2>
<h2 id="ROC-curve">ROC curve</h2>
<p>对于一个二分类的反应变量，预测结果和真实结果比对统计如下：</p>
<p><img src="10.png" alt="1"></p>
<p><abbr title="receiver operating characteristics">ROC</abbr>  曲线是用来展现不同的阈值下两种错误的错误概率的变化。下图就是 ROC 图 ，纵坐标是 <em>sensitivity</em> /power/ 1- Type Ⅱ error，就是零假设被正确拒绝的概率（真实值为1的个体中预测值也为1的概率，结合上表为 <strong>TP/P</strong>）；横坐标为 Type Ⅰ error / <em>1-specificity</em> ，为零假设被错误拒绝的概率，即假阳性概率（真实值为0的个体中预测值为1的概率，计算公式为 <strong>FP/N</strong>）。</p>
<p><strong>ROC 可以比较预测二分类变量的不同方法的预测效果</strong>。ROC 曲线越接近左上侧越好，或者说 ROC 曲线下方的面积越大越好。</p>
<p>这里我们采用13个特征预测个体是否有心脏疾病，总共297个样本，随机挑选207个样本作为训练集，90个样本作为验证集。下图中的左图为采用 LDA 和 support vector classifier 方法的效果，二者差不多，support vector classifier 方法略有优势；右图为与采用 <em>radial kernel</em> 的 SVM 方法的比较，这里随着 γ 的增加，决策线越曲折，ROC 曲线越好。但是看清楚，这里的图是<strong>训练集的效果</strong>，会有误导作用，我们要看验证集的效果。</p>
<p><img src="11.png" alt="1"></p>
<p>下图为验证集的效果，我们左图差不多，右图 γ = 0.1 在训练集上效果最好，但是在验证集上效果最差，再一次证明模型并不是越灵活越好。</p>
<p><img src="12.png" alt="1"></p>
<h1>SVMs with More than Two Classes</h1>
<p>上面的讨论都只是针对二分类的反应变量，那么我们能不能将 SVMs 方法应用到有更多的水平的反应变量上呢？事实上 SVMs 方法基于的 <em>separating hyperplanes</em> 理念本身并不能自动地推导到多个水平的分析。目前也有很多方法将 SVMs 方法拓展到多水平反应变量的分析，最著名的两个就是 <em>one-versus-one</em> 和 <em>one-versus-all</em> 方法。</p>
<h2 id="One-Versus-One-Classification">One-Versus-One Classification</h2>
<p>假设反应变量是 K 个水平，那么我们构建 C<sub>K</sub><sup>2</sup>  次 SVMs ，每一次包含一对水平。预测的时候，我们会计算这 C<sub>K</sub><sup>2</sup> 次的预测值，然后将所有预测结果中出现频率最频繁的水平作为最终的预测值。</p>
<h2 id="One-Versus-All-Classification">One-Versus-All Classification</h2>
<p>这个方法我们拟合 K 次 SVMs，每一次比对其中一个水平（设为1）和剩下的 K-1 个水平（设为-1）。预测时，我们分配所有 SVMs 中下式最大的 SVM 的水平，因为这个式子越大，说明这个观测值属于这个水平的可行程度越高。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbeta%20_%20%7B%200%20k%20%7D%20%2B%20%5Cbeta%20_%20%7B%201%20k%20%7D%20x%20_%20%7B%201%20%7D%20%5E%20%7B%20*%20%7D%20%2B%20%5Cbeta%20_%20%7B%202%20k%20%7D%20x%20_%20%7B%202%20%7D%20%5E%20%7B%20*%20%7D%20%2B%20%5Cldots%20%2B%5Cbeta%20_%20%7B%20p%20k%20%7D%20x%20_%20%7B%20p%20%7D%20%5E%20%7B%20*%20%7D%0A" /></p><h1>Relationship to Logistic Regression</h1>
<p><em>support vector classifier</em> 的拟合条件可以重新写为</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%20%7B%20minimize%20%7D%20_%20%7B%20%5Cbeta%20_%20%7B%200%20%7D%20%2C%20%5Cbeta%20_%20%7B%201%20%7D%20%2C%20%5Cldots%20%2C%20%5Cbeta%20_%20%7B%20p%20%7D%20%7D%20%5C%7B%20%5Csum%20_%20%7B%20i%20%3D%201%20%7D%20%5E%20%7B%20n%20%7D%20%5Coperatorname%20%7B%20max%20%7D%20%5B%200%2C1%20-%20y%20_%20%7B%20i%20%7D%20f%20%28%20x%20_%20%7B%20i%20%7D%20%29%20%5D%20%2B%20%5Clambda%20%5Csum%20_%20%7B%20j%20%3D%201%20%7D%20%5E%20%7B%20p%20%7D%20%5Cbeta%20_%20%7B%20j%20%7D%20%5E%20%7B%202%20%7D%20%5C%7D%0A" /></p><p>其中 λ 是一个非负数，后面的式子就类似于岭回归的惩罚项。总的式子就是 “Loss + Penalty&quot; 的形式。这里的 Loss 项拓展开来如下：</p>
<p style=""><img src="https://math.now.sh?from=L%20%28%20X%20%2C%20y%20%2C%20%5Cbeta%20%29%20%3D%20%5Csum%20_%20%7B%20i%20%3D%201%20%7D%20%5E%20%7B%20n%20%7D%20%5Coperatorname%20%7B%20max%20%7D%20%5B%200%2C1%20-%20y%20_%20%7B%20i%20%7D%20(%20%5Cbeta%20_%20%7B%200%20%7D%20%2B%20%5Cbeta%20_%20%7B%201%20%7D%20x%20_%20%7B%20i%201%20%7D%20%2B%20%5Cldots%20%2B%20%5Cbeta%20_%20%7B%20p%20%7D%20x%20_%20%7B%20i%20p%20%7D%20)%20%5D%0A" /></p><p>这也称为 <em>hinge loss</em> 。如下图所示，SVM 的 Loss 项和逻辑回归相关程度很高。SVM 的 Loss 项还有一个特点，对于处于正确的margin 一侧的点对模型结果没有影响，这体现在下式如果大于1，那么 Loss 项就正好是 0 。但是，逻辑回归不会正好是 0 ，会是一个很小的值，同样见下图。</p>
<p style=""><img src="https://math.now.sh?from=y%20_%20%7B%20i%20%7D%20%28%20%5Cbeta%20_%20%7B%200%20%7D%20%2B%20%5Cbeta%20_%20%7B%201%20%7D%20x%20_%20%7B%20i%201%20%7D%20%2B%20%5Cldots%20%2B%20%5Cbeta%20_%20%7B%20p%20%7D%20x%20_%20%7B%20i%20p%20%7D%20%29%0A" /></p><p><img src="13.png" alt="1"></p>
<p>因此 <em>support vector classifier</em> 和 逻辑回归的结果很相似，当两个水平之间分得较开，<em>support vector classifier</em> 结果更好一点；如果两个水平之间重叠区域较多，那么逻辑回归效果更好。</p>
<p>因此在描述线性关系的过程中，SVM 和逻辑回归等经典方法是高度相关的。那么是否在描述非线性关系时 SVM 采用特殊的 <em>kernels</em> 的做法就是独一无二的呢？答案也是否定的，我们同样可以对逻辑回归或者其他经典的分类方法采用非线性的 <em>kernels</em> 。但是由于历史原因，一般 <em>non-linear kernels</em> 用于SVMs 方法比经典的逻辑回归等方法更加广泛。</p>
<p>SVM 方法的思路同样可以用于回归问题中，称为 <em><strong>support vector regression</strong></em> ，这里的 Loss 项是超过某个常数的<strong>残差绝对值</strong>之和，低于给定常数的残差绝对值则直接忽略。</p>
<h1>R代码</h1>
<p>略</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Tree Based Methods</title>
    <url>/posts/7532e592/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>ISL 真是好书！</p>
<span id="more"></span> 
<h1>资料</h1>
<p><a href="https://www.statlearning.com/">An Introduction to Statistical Learning</a>，下文简称 <strong>ISL</strong></p>
<h1>概述</h1>
<p>决策树的方法对于 <em>interpretation</em> 很有用，但是它们在预测准确性上效果不是特别好。</p>
<p>决策树可以同时用于回归变量与分类变量的问题。我们先考虑回归问题，</p>
<h2 id="Regression-Trees">Regression Trees</h2>
<h3 id="Predicting-Baseball-Players’Salaries-Using-Regression-Trees">Predicting Baseball Players’Salaries Using Regression Trees</h3>
<p>我们先看一个简单的例子，我们通过回归树来预测足球运动员的收入，这里的特征是 Year (踢球的年限) 和 Hits (上一年度射中球门的数目) 。 我们先移除收入缺失的行，然后对 <em>Salary</em> 变量进行 log 转换（底为 e），使得它的分布更类似于正态分布。</p>
<p>下图表示了一个回归树的结果，它从树的根部出发。第一个分支条件使 Year &lt; 4.5 ，满足这个条件分到了左枝，这里的 5.11 是所有满足 Year &lt; 4.5 的运动员的薪资均值。以此类推。</p>
<p><img src="1.png" alt="1"></p>
<p>这里最终是把所有的运动员分成了3个子群体，如下图所示：</p>
<p><img src="2.png" alt="1"></p>
<p>我们如果用决策树的术语，这里的三个子区域 R<sub>1</sub> , R<sub>2</sub> , R<sub>3</sub> 称为 <em>terminal nodes</em> 或 <em>terminal leaves</em> 。 自变量空间被划分的那个节点称为 <em>internal nodes</em> 。在图 8.1 中，总共有2个  <em>internal nodes</em> ，Years &lt; 4.5 和 Hits &lt; 117.5 。我们把决策树上连接  <em>internal nodes</em> 的片段称为 <em>branches</em> 。</p>
<p>我们一般会这么解释图 8.1 的回归树：Years 是最重要的区分 Salary 性状的因子，年限短的运动员挣的钱少，年限长的运动员挣的钱多；如果一个远动员年限短，那么他上一年进球数对他的薪资几乎没有影响。但是如果一个运动员年限长（&gt;4.5年），那么他上一年进球数会对他的薪资造成影响，上一年进球数越多薪资越高。</p>
<p>这种回归树的图是对 Hits ,Years, Salary 三者之间关系的简化，但是它对于其他回归模型有优势，因为它容易解释，而且有可视化效果。</p>
<h3 id="Prediction-via-Stratification-of-the-Feature-Space">Prediction via Stratification of the Feature Space</h3>
<p>我们现在讨论一下构建一个回归树的过程。简单地讲，总共有两步：</p>
<ol>
<li>我们首先切分 <em>predictor space</em> — 将所有可能的值 X<sub>1</sub> , X<sub>2</sub> ，…… , X<sub>p</sub> 分成 J 个互不重叠的区域， R<sub>1</sub>,  R<sub>2</sub> , ……，R<sub>J</sub> 。</li>
<li>对于落在同一区域的观测值，我们会做相同的预测，即这个区域内所有观测值的<strong>均值</strong>。</li>
</ol>
<p>我们先看第一步，我们要如何去划分区域呢？一般我们会将各个区域划分成高维矩形，或者称为 <em>boxes</em> ，这样解释结果更简单。我们划分的目标是，找到一组 <em>boxes</em> R<sub>1</sub>,  R<sub>2</sub> , ……，R<sub>J</sub> ，使得 RSS 最小，RSS 计算见下式</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bj%3D1%7D%5E%7BJ%7D%20%5Csum_%7Bi%20%5Cin%20R_%7Bj%7D%7D%5Cleft%28y_%7Bi%7D-%5Chat%7By%7D_%7BR_%7Bj%7D%7D%5Cright%29%5E%7B2%7D%0A" /></p><p>下式为 R<sub>j</sub>  中所有观测值的均值。</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7By%7D_%7BR_%7Bj%7D%7D%0A" /></p><p>但是，我们不可能穷尽所有的划分方式，找到这个最佳的划分方法。因此我们采取一种称为 <em>recursive binary splitting</em> 的方法。这是一种 <em>top-down</em> 并且是 <em>greedy</em> 的方法，<em>top-down</em> 指从决策树的一开始的节点一直向下切分，每次生成两条新枝；<em>greedy</em> 指在每一步的切分中，所谓的最好的切分方式的决策都仅针对当前这一步，它不会往前看，面向未来，找会使得将来几步最好的切分。</p>
<p><em>recursive binary splitting</em>  方法的第一步，是选取一个特征 X<sub>j</sub> 和相应的一个断点 s ，然后将个预测因子空间切分为两部分，<strong>从而使得 RSS 减少得最多</strong>。两个子空间如下：</p>
<p style=""><img src="https://math.now.sh?from=R_%7B1%7D%28j%2C%20s%29%3D%5Cleft%5C%7BX%20%5Cmid%20X_%7Bj%7D%3Cs%5Cright%5C%7D%20%5Ctext%20%7B%20and%20%7D%20R_%7B2%7D(j%2C%20s)%3D%5Cleft%5C%7BX%20%5Cmid%20X_%7Bj%7D%20%5Cgeq%20s%5Cright%5C%7D%0A" /></p><p>这就要求需要考虑所有得预测因子  X<sub>1</sub> , X<sub>2</sub> ，…… , X<sub>p</sub>  ，以及每个预测因子上所有可能的断点，然后挑 RSS 最低的组合。RSS 计算方式如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bi%3A%20x_%7Bi%7D%20%5Cin%20R_%7B1%7D%28j%2C%20s%29%7D%5Cleft(y_%7Bi%7D-%5Chat%7By%7D_%7BR_%7B1%7D%7D%5Cright)%5E%7B2%7D%2B%5Csum_%7Bi%3A%20x_%7Bi%7D%20%5Cin%20R_%7B2%7D(j%2C%20s)%7D%5Cleft(y_%7Bi%7D-%5Chat%7By%7D_%7BR_%7B2%7D%7D%5Cright)%5E%7B2%7D%0A" /></p><p>之后我们会重复这一步，，但是这次就不是对整个预测因子空间进行切分，而是对上面的两个子空间的一个进行切分，然后我们就有了3个区域。之后我们会再找一个子空间进行切分，这个过程会一直持续，以至于满足了一个停止条件，例如直到所有区域包含不超过 5 个观测值。</p>
<p>一旦我们创建好了所有子区域，我们就可以通过计算子区域内所有观测值的均值，作为这个子区域的预测值。下图为一个 5个子区域划分的例子。</p>
<p><img src="3.png" alt="1"></p>
<h3 id="Tree-Pruning">Tree Pruning</h3>
<p>上面的划分过程可能会造成 <em>overfitting</em> ，因为划分得到的决策树过于复杂了。一个简单一些的决策树的 variance 更低，解释效果更好，但是 bias 会略有增加。<strong>一个可能的解决办法是每次切分过程 RSS 降低量必须超过某个阈值</strong>。但是这个策略的问题是短视，因为一个看上去没有意义的切分可能会带来后面的一个很好的切分，即在它后面的一个切分可能RSS降低很多。</p>
<p>因此，一个更好的策略是先生成一个非常大的决策树 T<sub>0</sub> ，然后进行删减得到一个 <em>subtree</em> 。我们如何进行删减分支呢？从目标上，我们的目的是选择一个 <em>test error rate</em> 最低的 <em>subtree</em> 。如果给定一个 <em>subtree</em>， 我们可以通过交叉验证来验证 <em>test error</em> 。但是，对于每一个可能的 <em>subtree</em> 如果都进行交叉验证，计算量就太大了。因此，我们需要一种方式事先挑出少数的一些 <em>subtree</em> 备选。</p>
<p>我们可以通过 <em>Cost complexity pruning</em> 或者称为 <em>weakest link pruning</em> 方法来实现这一点。我们通过指定参数 α 来挑出一部分 <em>trees</em> 。</p>
<p>对于每个给定的 α  值，都存在一个 <em>subtree</em> T ⊂T<sub>0</sub> ，使得下式尽可能小。</p>
<p><img src="4.png" alt="1"></p>
<p>这里的 |T| 表示 决策树 T 的 <em>terminal leaf</em> 的数量 , R<sub>m</sub> 是相应于第 m 个  <em>terminal leaf</em>  的子空间。这里就是增加了一个惩罚项，越复杂的 <em>subtree</em> 惩罚越严重，通过调控 α 来控制调控比例。我们可以先通过交叉验证得到一个合适的 α 值，然后根据这个 α 值得到相应的最佳的 <em>subtree</em> 。 这个流程如下图：</p>
<p>首先对所有训练集的个体先得到 T<sub>0</sub> 和 <em>best subtree</em>  与 α 的函数。</p>
<p>然后进行交叉验证结果选择最好的 α 值，最后根据 α 值返回第二步找到相应的 <em>best subtree</em> 。</p>
<p><img src="5.png" alt="1"></p>
<p>效果如下图，我们可以看到交叉验证结果很好地估计了 Test data error ，交叉验证最佳的  <em>terminal leaf</em>  的数目为3， 使用 test data 的结果的最佳数目为9，但是在<em>terminal leaf</em> 为3的地方有一个明显的下降。</p>
<p><img src="6.png" alt="1"></p>
<h2 id="Classification-Trees">Classification Trees</h2>
<p><em>classification trees</em> 和上面的 <em>regression trees</em> 很相似，仅仅是用于预测分类变量，将每个子空间的预测值改为出现概率最大的那个水平。</p>
<p>创建一个分类树的过程和创建回归树的过程类似。我们先用 <em>recursive binary splitting</em> 方法来创建一个分类树，但是这里不能再用 RSS 作为指标了，一般用 <em>classification error rate</em> ，即观测值和预测值（子空间中最大可能的水平）不一致的比例，公式如下：</p>
<p style=""><img src="https://math.now.sh?from=E%3D1-%5Cmax%20_%7Bk%7D%5Cleft%28%5Chat%7Bp%7D_%7Bm%20k%7D%5Cright%29%0A" /></p><p>下式为 训练集第m个子空间中属于k 水平的比例。</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7Bp%7D_%7Bm%20k%7D%0A" /></p><p>这里，E 就是这个子空间内所有观测值中不是最大可能观测值的比例。但是实际证明这个指标在划分决策树时不够敏感，因为实际我们一般会用另外两个指标。</p>
<p>第一个就是 <em>Gini index</em>,  定义为如下式，可以视为 K 个水平的总方差的衡量公式。只看查看这个式子我们不难发现，如果 p<sup>^</sup> <sub>mk</sub>  越接近于0或1，那么这个式子就越小，因此这个式子也可以视为 <em>node purity</em> 的衡量指标 - 值越小说明这个子空间的预测值越纯。</p>
<p style=""><img src="https://math.now.sh?from=G%3D%5Csum_%7Bk%3D1%7D%5E%7BK%7D%20%5Chat%7Bp%7D_%7Bm%20k%7D%5Cleft%281-%5Chat%7Bp%7D_%7Bm%20k%7D%5Cright%29%0A" /></p><p>另外一个指标就是 <em>entropy</em> ， 计算方法如下：</p>
<p style=""><img src="https://math.now.sh?from=D%3D-%5Csum_%7Bk%3D1%7D%5E%7BK%7D%20%5Chat%7Bp%7D_%7Bm%20k%7D%20%5Clog%20%5Chat%7Bp%7D_%7Bm%20k%7D%0A" /></p><p>同样地， 当  p<sup>^</sup> <sub>mk</sub>  越接近于0或1，那么这个式子就越小。实际证明这两个式子效果差不多。</p>
<p>因此创建分类树时，我们一般会用  <em>Gini index</em> 或  <em>entropy</em> 作为划分新枝的衡量标准。当我们在 <em>pruning</em> 分枝时，我们可能会不用这两个指标，而是用一开始的 <em>classfication error rate</em> ，因为最终我们的目标还是预测准确性。</p>
<p>在创建新枝的过程中，属于分类变量的特征也可以用于划分新枝，只用把其中的一些水平划给一个分支，把剩下的所有水平划给另外一个分支即可。下图即为一个分类树结果，比如这里的 Thal:a 就表示左边为 Thal 的第一个水平的观测值，右边为其他水平的观测值。</p>
<p><img src="7.png" alt="1"></p>
<h2 id="Trees-Versus-Linear-Models">Trees Versus Linear Models</h2>
<p>如果反应变量与特征之间存在明显的线性关系，那么线性回归会很合适。但是，如果反应变量与特征之间存在<strong>非线性的复杂关系</strong>，那么决策树会比那些经典方法更合适。下图就是一个很好的例子，这是一个p=2的分类问题，上方的行表示真实的决策线是线性的，不同的颜色表示不同的水平，这里明显可以看出线性模型效果更好；下方的行中真实决策线是非线性的，这里线性模型的方法无法准确预测，而决策树效果很好。</p>
<p><img src="8.png" alt="1"></p>
<h2 id="Advantages-and-Disadvantages-of-Trees">Advantages and Disadvantages of Trees</h2>
<p>决策树的优点如下：</p>
<ul>
<li>结果容易解释</li>
<li>更符合人的做决定的方式</li>
<li>可视化，不言自明</li>
<li>可以直接处理分类变量，而不用像线性模型那样转变为哑变量。</li>
</ul>
<p>缺点如下：</p>
<ul>
<li>预测准确性没有经典方法高</li>
<li>有时不够稳健，换句话说，数据稍有改变，可能最终的决策树就有一个大的改变。</li>
</ul>
<p>但是，通过使用 bagging, random forests, and boosting ，我们可以提高决策树的预测准确性。</p>
<h1>Bagging, Random Forests,  Boosting</h1>
<p>这三种方法都是使用决策树作为 <em>blocks</em>，来创建更加强大的预测模型。</p>
<h2 id="Bagging">Bagging</h2>
<p>自助法是一种强大的思路，可以计算很难计算或无法计算的因子估计值的标准误。这里我们同样可以用自助法的思想，来提高决策树的效果。</p>
<p>上面我们讨论过，决策树具有 <em>high variance</em> 的缺点，这表明如果我们随机将训练集拆分成两部分，然后对每一部分拟合决策树，我们可能会得到两个完全不同的结果。<em>Bootstrap aggregation</em>，或称为 <em>bagging</em> 方法是一种通用的降低统计方法方差的流程，它对决策树非常有用。</p>
<p>假设我们有一个 n 个独立的观测值的数据集 Z<sub>1</sub>,……, Z<sub>n</sub> ，观测值的方差为 σ<sup>2</sup> ，那么观测值均值的方差为 σ<sup>2</sup> / n 。也就是所，对多个数据集求均值可以降低方差。因此一个降低方差，提高预测准确性的方法就是<strong>用多个训练集</strong>单独进行模型拟合，最终对所有模型的预测值求均值。比如我们得到了 B 个单独的拟合模型，最终模型的预测值如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7Bf%7D_%7B%5Ctext%20%7Bavg%20%7D%7D%28x%29%3D%5Cfrac%7B1%7D%7BB%7D%20%5Csum_%7Bb%3D1%7D%5E%7BB%7D%20%5Chat%7Bf%7D%5E%7Bb%7D(x)%0A" /></p><p>但是，这在实际中并不可行，因为我们不可能得到很多个训练集。因此，我们可以使用自助法作为替代方法，从一个训练集中有返回地重复抽样，最终生成B个不同的自助法的训练集。代入上式，得到最终的统计模型。这种方法称为 <em>bagging</em>。</p>
<p><em>Bagging</em> 方法可以显著提高很多回归方法的预测效果，它同样对于决策树也很有用。我们可以用这 B 个自助法训练集来创建 B 个决策树，这些决策树是最深的，没有进行删减。因此这些决策树偏差很小，方差很高。我们通过对这 B 个决策树进行求均值，可以降低方差。</p>
<p>对于反应变量是质量性状的情况，我们可以对这B个决策树的预测结果取 <em>majority vote</em> （占比最高的水平）。</p>
<p>下图中的横坐标为自助法抽样次数，纵坐标为 test error ，这里的黑线就是自助法的结果，黑色虚线是原始结果，我们可以看到自助法没有随着抽样次数的增加出现 <em>overfitting</em> 的问题。实际上，这里 B = 100 就已经够用了。</p>
<p><img src="9.png" alt="1"></p>
<h3 id="自助法究竟是如何用到决策树上？">自助法究竟是如何用到决策树上？</h3>
<p>自助法的思路用到线性回归上，这个流程很容易理解，就是把 B 次估计的系数求均值，就得到了最终使用的模型。推导如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Chat%7Bf%7D_%7B%5Ctext%20%7Bavg%20%7D%7D%28x%29%20%26%3D%20%5Cfrac%7B%5Csum_%7Bk%3D1%7D%5E%7BK%7D%20(a_%7Bk%7Dx%2Bb_%7Bk%7D)%7D%7Bn%7D%20%5C%5C%0A%26%3D%20%5Cfrac%7B(%5Csum_%7Bk%3D1%7D%5E%7BK%7Da_%7Bk%7D)%7D%7Bn%7Dx%20%2B%20%5Cfrac%7B(%5Csum_%7Bk%3D1%7D%5E%7BK%7Db_%7Bk%7D)%7D%7Bn%7D%20%5C%5C%0A%26%3D%20%5Cbar%7Ba%7Dx%2B%5Cbar%7Bb%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>但是决策树不是每一次分枝情况都不一样吗？这个最终的模型到底是如何构建的呢？没有说清楚。</p>
<h3 id="Out-of-Bag-Error-Estimation">Out-of-Bag Error Estimation</h3>
<p><em>Bagging</em> 方法有一个直接的估计 test error 的方式，不需要使用交叉验证或者验证集方法。 每个自助集的决策树平均只用了 2/3 的观测值。剩下的没有用到的 1/3 的观测值称为 <em>out-of-bag</em> (OOB) observations。我们可以用当这个观测值为OOB的决策树来预测这个观测值的结果，因此针对某个观测值，我们可以得到差不多 B/3 个预测值。为了获得一个单独的预测值，我们可以对这接近B/3 个预测值求均值，这样每一个观测值都可以得到一个 OOB 预测值，然后我们就可以计算 OOB MSE (反应变量为连续变量) 或者 claffication error (反应变量为分类变量)。实际证明，OOB error 是一个有效地估计 test error 的统计量。如果 K 足够大，那么OOB error 其实就接近于 LOOCV error 。</p>
<h3 id="Variable-Importance-Measures">Variable Importance Measures</h3>
<p>bagging 方法可以增加预测准确性，但是缺点在于<strong>最终的统计模型难以解释</strong>。然而决策树的优势就在于可视化和易于解释。但是 bagging 的结果最终无法显示为一个决策树的可视化结果，也无法显示哪些特征很重要，哪些特征无关紧要。因此，<strong>bagging 方法提高了预测准确性，其代价就是降低了模型解释性</strong>。</p>
<p>但是我们可以通过 RSS 或 Gini index 来或者所有特征的重要性。例如针对一个 bagging regression trees，我们可以获取所有B个决策树中因为基于某个特征的切分造成的 RSS 的下降值，并求均值。如果这个值很大，说明这个特征很重要。下图为特征重要性的可视化，我们把最重要的特征视为100%，然后其他特征与最重要的特征进行比较。</p>
<p><img src="10.png" alt="1"></p>
<h2 id="Random-Forests">Random Forests</h2>
<p>随机森林对于 bagging 方法做了一些调整，实现了 <em>decorrelates the trees</em> （降低多次抽样的决策树之间的相关性）。就像 bagging 方法，随机森林方法同样会用自助法的思想，创建出多个训练集，然后拟合多个决策树。仅仅是在拟合决策树的过程中，随机森林方法不再使用所有 p 个特征，而是随机抽样挑选 m 个特征用于拟合决策树。一般来说，m 一般设定为约等于  √p 。</p>
<p>举个例子，加入在数据集中有一个效果非常强的特征，其他特征只有中等效果。因此，在 bagging 方法创建的众多决策树中，大部分或所有的决策树都会用这个最重要的特征作为第一次切分的特征。因此，所有的决策树看上去都很像。不幸地是，<strong>对高度相关的连续变量求均值无法起到大幅度降低方差的作用</strong>。因此，这到这 bagging 方法降低方差的作用可能不是很大。</p>
<p>随机森林方法通过每次都只用一小部分特征来构建决策树克服了这个问题，例如这个例子中，我们大概有 (p-m)/p  的比例的决策树中没有这个最重要的特征，因此其他的特征可以有机会体现作用。我们可以认为这个过程降低了决策树之间的相关，因此对这些决策树求均值的方差更低，结果更可靠。</p>
<p>因此，bagging 和 随机森林的最大区别在于如何选择 m 的大下。如果随机森林选择 m = p，那么这时就是 bagging 方法。上图8.8中显示，随机森林方法相较于bagging方法，test error 和 OOB error 均更低，说明随机森林方法更佳。</p>
<p>当我们有<strong>数目很多的</strong>并且<strong>彼此存在相关的</strong>特征时，随机森林方法提升效果更好。这里举个例子，假如我们有 349个个体的 4718 个基因的表达量。在这个数据集中，反应变量是一个15个水平的分类变量：要么是正常，要么就是 1-14 种不同类型的癌症。我们随机将数据分为训练集和验证集，然后挑出训练集中方差最大的 500 个基因，我们的目的是用随机森林的方法使用这500个基因预测个体的癌症类型，其中我们采用了三个不同的 m 值。下图为结果显示，其中一次决策树的 test error rate 是 45.7% 。我们可以看到 m = √p 的效果比 bagging （m=p）效果略好。类似于 bagging，随着 B 的增加，随机森林不会出现 overfit 的情况，因此实际情况中，挑选的B值 只要使得 test error 稳定下来即可。</p>
<p><img src="11.png" alt="1"></p>
<h2 id="Boosting">Boosting</h2>
<p><em>Boosting</em> 方法类似于 <em>Bagging</em> 方法，是一种可以应用在多种统计学习模型中的一般方法。这里仅讨论 <em>Boosting</em> 方法在决策树上的应用。</p>
<p><em>Boosting</em> 方法也是创建多个决策树，最终综合所有决策树的结果。但是这里不再使用自助法生成训练集，而是<strong>相继</strong>创建训练集：每一个决策树都会用到上一个决策树的数据。</p>
<p>传统的决策树容易 <em>fitting the data hard</em> ，从而造成 <em>overfitting</em> 。但是 <em>Boosting</em> 方法 <em>learns slowly</em> 。除了第一次创建决策树，之后创建决策树的过程都是使用上一步的<strong>残差</strong>。算法过程如下：</p>
<p><img src="12.png" alt="1"></p>
<p>d 决定每一次决策树的 <em>teminal nodes</em> 的数目；λ 参数用于降低学习速度。一般来说，<em>learn slowly</em> 的统计学习模型效果更好。</p>
<p>对于反应变量是分类变量的流程，ISL 没讲。</p>
<p><em>Boosting</em> 方法有3个参数：</p>
<ul>
<li>The number of trees B.  这里不像 bagging 和 random forests 方法，当 B 很大时，boosting 方法可能会出现 <em>overfitting</em> 现象（虽然过拟合增加的效果很缓慢），所以一般会通过交叉验证选择一个合适的 B 值。</li>
<li>The shrinkage parameter λ. 这是一个很小的正数，控制每一步学习的速度。一般会采用 0.01 或 0.001 。 λ 值越小，B 要求越大。</li>
<li>The number d of splits in each tree. 这控制每一步的决策树的复杂度。一般选择 d=1，因此这样每个决策树只有一次切分。最终的模型是可加的，因为每一步的决策树都只包含了一个特征。</li>
</ul>
<p>下图为 15个水平的癌症基因表达量数据集使用 boosting 的效果。我们可以 d=1 的效果比 d=2 和随机森林的效果都好。一般来说，d=1 效果就可以了，唯一问题在于可能需要增加B的数目，但是在对模型的解释性上很好，因为最终的模型是一个加性模型。</p>
<p><img src="13.png" alt="1"></p>
<h1>R 代码</h1>
<p>略</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Generalized Additive Models</title>
    <url>/posts/c49e8948/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>ISL 真是好书！</p>
<span id="more"></span> 
<h1>资料</h1>
<p><a href="https://www.statlearning.com/">An Introduction to Statistical Learning</a>，下文简称 <strong>ISL</strong></p>
<h1>概述</h1>
<p>标准的线性回归模型，最大的问题在于线性的假设。实际情况中，这个假设可能不被满足。</p>
<p>这一章节是描述非线性关系的模型。</p>
<h1>Polynomial Regression</h1>
<p>多项式回归模型如下：</p>
<p style=""><img src="https://math.now.sh?from=y_%7Bi%7D%3D%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20x_%7Bi%7D%2B%5Cbeta_%7B2%7D%20x_%7Bi%7D%5E%7B2%7D%2B%5Cbeta_%7B3%7D%20x_%7Bi%7D%5E%7B3%7D%2B%5Cldots%2B%5Cbeta_%7Bd%7D%20x_%7Bi%7D%5E%7Bd%7D%2B%5Cepsilon_%7Bi%7D%0A" /></p><p>一半来说，最高项一般设置为3或4，因为如果项数太高，那么可能会得到非常奇怪的图形。</p>
<p>下图中的左图为项数为4的多项式回归。</p>
<p><img src="1.png" alt="1"></p>
<p>虚线为两个标准误差曲线，或者说置信区间的上下限。这是如何得到的呢？假设我们计算得到某个点 x<sub>0</sub> 的预测值，如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7Bf%7D%5Cleft%28x_%7B0%7D%5Cright%29%3D%5Chat%7B%5Cbeta%7D_%7B0%7D%2B%5Chat%7B%5Cbeta%7D_%7B1%7D%20x_%7B0%7D%2B%5Chat%7B%5Cbeta%7D_%7B2%7D%20x_%7B0%7D%5E%7B2%7D%2B%5Chat%7B%5Cbeta%7D_%7B3%7D%20x_%7B0%7D%5E%7B3%7D%2B%5Chat%7B%5Cbeta%7D_%7B4%7D%20x_%7B0%7D%5E%7B4%7D%20%5Ctext%20%7B%20.%20%7D%0A" /></p><p>那么这个点的预测值的方差等于多少呢？我们通过最小二乘法可以得到所有估计系数的估计方差，我们可以根据这个计算预测值的估计方差，计算方式如下图（ISL 的引用，没说清楚，没有证明）。</p>
<p><img src="2.png" alt="1"></p>
<p>我们可以通过这种方法以<strong>逐点</strong>地方式得到所有点的预测方差（开方即可得到标准误估计值），所有点的预测值 + 两倍的标准误即为上方的误差曲线，所有点的预测值 - 两倍的标准误即为下方的误差曲线（2倍的标准误范围正好是95%的置信区间，实际是1.96，差不多）。</p>
<p>从上面左图可以看出，Wage 这个性状似乎分成了截然分开的两个群体，一部分人的薪资超过了 250,000 美元/年；然后其他人就是低收入群体。因此，Wage 其实可以变成一个二分类的分类变量。这里我们用多项式逻辑回归用于预测薪资大于 250,000 美元/年 的概率。预测结果见上面右图，我们可以看到右侧的置信区间非常大。虽然这里总的样本量很大（n=3000），但是这里其实只有 79个 高收入者，这导致系数估计的方差很高，最终预测结果的置信区间也很大。</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BPr%7D%5Cleft%28y_%7Bi%7D%3E250%20%5Cmid%20x_%7Bi%7D%5Cright%29%3D%5Cfrac%7B%5Cexp%20%5Cleft(%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20x_%7Bi%7D%2B%5Cbeta_%7B2%7D%20x_%7Bi%7D%5E%7B2%7D%2B%5Cldots%2B%5Cbeta_%7Bd%7D%20x_%7Bi%7D%5E%7Bd%7D%5Cright)%7D%7B1%2B%5Cexp%20%5Cleft(%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20x_%7Bi%7D%2B%5Cbeta_%7B2%7D%20x_%7Bi%7D%5E%7B2%7D%2B%5Cldots%2B%5Cbeta_%7Bd%7D%20x_%7Bi%7D%5E%7Bd%7D%5Cright)%7D%0A" /></p><h1>Step Functions</h1>
<p>上面的多项式回归是对整个定义域进行拟合，我们可以用 <em>step functions</em> 来把整个定义域分段，对于每一段进行单独的估计，这就将一个连续自变量转变成了一个 <em>ordered categorical variable</em> 。</p>
<p>更详细地说，我们会在整个定义域创建 K 个断点 (c<sub>1</sub> , c<sub>2</sub> , …… ， c<sub>k</sub>) ，创建 K+1 个新的变量。其中 <code>I()</code> 函数满足条件则为1，不满足条件则为0，因此这 K+1 个新变量中永远只有一个变量的值为1，其他均为0，一般也称为 <strong>哑变量</strong>。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AC_%7B0%7D%28X%29%20%26%3DI%5Cleft(X%3Cc_%7B1%7D%5Cright)%20%5C%5C%0AC_%7B1%7D(X)%20%26%3DI%5Cleft(c_%7B1%7D%20%5Cleq%20X%3Cc_%7B2%7D%5Cright)%2C%20%5C%5C%0AC_%7B2%7D(X)%20%26%3DI%5Cleft(c_%7B2%7D%20%5Cleq%20X%3Cc_%7B3%7D%5Cright)%2C%20%5C%5C%0A%26%20%5Cvdots%20%5C%5C%0AC_%7BK-1%7D(X)%20%26%3DI%5Cleft(c_%7BK-1%7D%20%5Cleq%20X%3Cc_%7BK%7D%5Cright)%2C%20%5C%5C%0AC_%7BK%7D(X)%20%26%3DI%5Cleft(c_%7BK%7D%20%5Cleq%20X%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>我们可以用后面 k个哑变量作为预测因子，拟合回归模型</p>
<p style=""><img src="https://math.now.sh?from=y_%7Bi%7D%3D%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20C_%7B1%7D%5Cleft%28x_%7Bi%7D%5Cright%29%2B%5Cbeta_%7B2%7D%20C_%7B2%7D%5Cleft(x_%7Bi%7D%5Cright)%2B%5Cldots%2B%5Cbeta_%7BK%7D%20C_%7BK%7D%5Cleft(x_%7Bi%7D%5Cright)%2B%5Cepsilon_%7Bi%7D%0A" /></p><p>对于某个特定的自变量 x，这k个哑变量最多只有一个不为0。比如如果 x &lt; c<sub>1</sub> ，那么所有的预测因子全是0，因此预测值就是 β<sub>0</sub> 。其他 x 值依次类推。</p>
<p>同样，我们可以使用 <em>step functions</em> 进行逻辑回归</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BPr%7D%5Cleft%28y_%7Bi%7D%3E250%20%5Cmid%20x_%7Bi%7D%5Cright%29%3D%5Cfrac%7B%5Cexp%20%5Cleft(%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20C_%7B1%7D%5Cleft(x_%7Bi%7D%5Cright)%2B%5Cldots%2B%5Cbeta_%7BK%7D%20C_%7BK%7D%5Cleft(x_%7Bi%7D%5Cright)%5Cright)%7D%7B1%2B%5Cexp%20%5Cleft(%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20C_%7B1%7D%5Cleft(x_%7Bi%7D%5Cright)%2B%5Cldots%2B%5Cbeta_%7BK%7D%20C_%7BK%7D%5Cleft(x_%7Bi%7D%5Cright)%5Cright)%7D%0A" /></p><p>下图左边是线性回归的 <em>step functions</em> 效果，右边为逻辑回归的效果。</p>
<p><img src="3.png" alt="1"></p>
<p>**不幸的是，除非因变量X本身存在自然断点，<em>step function</em> 效果一般不好。**举例而言，上图左图一开始的区间没有体现出wage 随 age 递增的趋势。</p>
<h1>Basis Functions</h1>
<p>多项式回归与分段回归其实都是 <em>basis function</em> 方法的特例。<em>basis function</em> 的思路是通过一些熟悉的函数/转换应用到自变量 X 上：b<sub>1</sub>(X), b<sub>2</sub>(X), …… ，b<sub>k</sub>(X) 。</p>
<p>因此，我们用下面的模型，替换正常的包含X变量的线性模型：</p>
<p style=""><img src="https://math.now.sh?from=y_%7Bi%7D%3D%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20b_%7B1%7D%5Cleft%28x_%7Bi%7D%5Cright%29%2B%5Cbeta_%7B2%7D%20b_%7B2%7D%5Cleft(x_%7Bi%7D%5Cright)%2B%5Cbeta_%7B3%7D%20b_%7B3%7D%5Cleft(x_%7Bi%7D%5Cright)%2B%5Cldots%2B%5Cbeta_%7BK%7D%20b_%7BK%7D%5Cleft(x_%7Bi%7D%5Cright)%2B%5Cepsilon_%7Bi%7D%0A" /></p><p>这里的 <em>basis function</em> 除了多项式和分段函数外，还有其他选择，比如下面的 <em>regression splines</em> 。</p>
<h1>Regression Splines</h1>
<h2 id="Piecewise-Polynomials">Piecewise Polynomials</h2>
<p>分段多项式回归对不同的自变量X的区段进行拟合。例如一个分段三次项回归的模型如下：</p>
<p style=""><img src="https://math.now.sh?from=y_%7Bi%7D%3D%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20x_%7Bi%7D%2B%5Cbeta_%7B2%7D%20x_%7Bi%7D%5E%7B2%7D%2B%5Cbeta_%7B3%7D%20x_%7Bi%7D%5E%7B3%7D%2B%5Cepsilon_%7Bi%7D%0A" /></p><p>这里不同区段会拟合得到不同的 β<sub>0</sub> 等系数。系数发生改变的点称为 <em>knots</em>。例如只有一个断点 c 的分段多项式回归模型如下：</p>
<p style=""><img src="https://math.now.sh?from=y_%7Bi%7D%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cbeta_%7B01%7D%2B%5Cbeta_%7B11%7D%20x_%7Bi%7D%2B%5Cbeta_%7B21%7D%20x_%7Bi%7D%5E%7B2%7D%2B%5Cbeta_%7B31%7D%20x_%7Bi%7D%5E%7B3%7D%2B%5Cepsilon_%7Bi%7D%20%26%20%5Ctext%20%7B%20if%20%7D%20x_%7Bi%7D%3Cc%20%5C%5C%0A%5Cbeta_%7B02%7D%2B%5Cbeta_%7B12%7D%20x_%7Bi%7D%2B%5Cbeta_%7B22%7D%20x_%7Bi%7D%5E%7B2%7D%2B%5Cbeta_%7B32%7D%20x_%7Bi%7D%5E%7B3%7D%2B%5Cepsilon_%7Bi%7D%20%26%20%5Ctext%20%7B%20if%20%7D%20x_%7Bi%7D%20%5Cgeq%20c%0A%5Cend%7Barray%7D%5Cright.%0A" /></p><p>如果 <em>knots</em> 很多，整个模型的 <em>flexibility</em> 会很高，这时候对于每个区段，我们可能不用多项式回归，而是直接用线性回归。例如，上面的 <em>step function</em>s 其实就是这里 自由度为 0 的一个特例。</p>
<p>下图 7.3 中左上角的图就是一个 <em>knot</em> 的分段三次项回归结果，我们看到有一个问题，整个函数不是连续的（两个分段的模型在断点的预测值不同）。由于每个分段的模型有 4 个参数，因此这里我们整个模型有8个参数，自由度为 8 。</p>
<p><img src="4.png" alt="1"></p>
<h2 id="Constrains-and-Splines">Constrains and Splines</h2>
<p>为了避免上面这个问题，我们可以加一个限制条件，就是最终拟合的函数必须是连续的，即两个分段函数在断点的值是相同的。上图 7.3 右上方就是加了这个限制条件的结果，效果更好了，但是总的函数在断点处呈现 v 字型，这看上去不自然。在左下图中又加了两个限制条件，断点两侧两个函数的<strong>一级导数</strong>和<strong>二级导数</strong>是连续的，因此整个函数更加 <em>smooth</em> 。我们每增加一个限制条件，就会减少一个自由度。因此左下方拟合函数的自由度为 5 （3个限制条件，8-3=5），一般也称为 <em><strong>cubic spline</strong></em> 。一般来说，K 个断点的 <em>cubic spline</em> 的总体自由度为 4+K 。</p>
<p>图 7.3 的右下图是 <em>linear spline</em> 的结果，它在断点是连续的。一般来说 <em>degree-d spline</em> 定义为分段的 自由度为d 的 多项式回归（最高项为 d），并且在每个断点追到到 d-1 自由度的导数都是连续的。因此，<em>linear spline</em> 只要求断点是连续的。</p>
<h2 id="The-Spline-Basis-Representation">The Spline Basis Representation</h2>
<p>上面讨论的 <em>regression splines</em> 看上去有点复杂，我们还是可以通过 <em>basis functions</em> 来带入模型，将上面的 <em>cubic splines</em> 表示为</p>
<p style=""><img src="https://math.now.sh?from=y_%7Bi%7D%3D%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20b_%7B1%7D%5Cleft%28x_%7Bi%7D%5Cright%29%2B%5Cbeta_%7B2%7D%20b_%7B2%7D%5Cleft(x_%7Bi%7D%5Cright)%2B%5Ccdots%2B%5Cbeta_%7BK%2B3%7D%20b_%7BK%2B3%7D%5Cleft(x_%7Bi%7D%5Cright)%2B%5Cepsilon_%7Bi%7D%2C%0A" /></p><p>这里可以有多种 <em>basis functions</em> 来描述 <em>cubic splines</em> ，最直接的方法就是从基础的三次型多项式出发 - x, x<sup>2</sup>, x<sup>3</sup>， 然后对于每个 <em>knot</em> 增加一个 <em>truncated power basis function</em> 。</p>
<p><em>truncated power basis function</em> 定义如下：</p>
<p style=""><img src="https://math.now.sh?from=h%28x%2C%20%5Cxi%29%3D(x-%5Cxi)_%7B%2B%7D%5E%7B3%7D%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bcl%7D%0A(x-%5Cxi)%5E%7B3%7D%20%26%20%5Ctext%20%7B%20if%20%7D%20x%3E%5Cxi%20%5C%5C%0A0%20%26%20%5Ctext%20%7B%20otherwise%20%7D%0A%5Cend%7Barray%7D%5Cright.%0A" /></p><p>这里的 ξ 就是 knot 。新增这一项只会导致三级导数不连续（一级导数和二级导数左右两侧都是0，而三级导数左侧是0，右侧是6）</p>
<p>换句话说，对于一个有 K 个 <em>knots</em> 的 <em>cubic spline</em> ，我们的回归模型中除了截距外，还有 K+3 个自变量，分别为</p>
<p style=""><img src="https://math.now.sh?from=X%2CX%5E%7B2%7D%2CX%5E%7B3%7D%2C%20h%5Cleft%28X%2C%20%5Cxi_%7B1%7D%5Cright%29%2C%20h%5Cleft(X%2C%20%5Cxi_%7B2%7D%5Cright)%E2%80%A6%E2%80%A6%20h%5Cleft(X%2C%20%5Cxi_%7Bk%7D%5Cright)%2C%0A" /></p><p>因此，总共需要估计的参数是 K+4 个（加截距），因此总的自由度为 K+4 。</p>
<p>不幸地是，<em>splines</em> 针对外围的预测值（X 值很小或很大）会有很高的 variance 。下图显示了 3 个 <em>knots</em> 的结果，我们可以看到两个边界的置信区间明显更大。</p>
<p>下图中的 <em>natural spline</em> 是含有额外的 <em>boundary constraints</em> （函数要求在 boundary 处是线性的（boundary 指比最小的knot还要小，或比最大的 knot 还要大的区域））的 regression spline 。 <em>natural spline</em> 显示为红线。</p>
<p><img src="5.png" alt="1"></p>
<h2 id="Choosing-the-Number-and-Locations-of-the-Knots">Choosing the Number and Locations of the Knots</h2>
<p>当我们执行 spline 算法时，我们应该在哪里安置 <em>knots</em> 呢？一般来说，变化大的区域安放的 <em>knots</em> 更多，变化小的区域放得少比较合理，但是实际情况一般是，先获取需要安放的 <em>knots</em> 数目，然后按照自变量的百分位点进行选取 <em>knots</em> 。</p>
<p>下图展示了一个例子，使用 <em>natural cubic spline</em> 进行拟合数据，<em>knots</em> 的位置在 age 自变量的 25th, 50th, 75th 分位点。这里总共有4个自由度[^1]。</p>
<p><img src="6.png" alt="1"></p>
<p>那么我们需要使用多少个 knots 呢？或者说我们的 spline 中的自由度应该是多少呢？一个选项是变量不同数目的 knots，然后看哪一种生成的拟合曲线最好。一个更客观的方法是使用交叉验证，计算所有test sets 的 test RSS 均值。下图显示为10倍交叉验证的结果，左边为 <em>natural splines</em> ，右图为 <em>cubic splines</em> ，可以看到这两种方法结果差不多。</p>
<p><img src="7.png" alt="1"></p>
<p>[^1]: 这里包括两个边界点，其实总共是 5 个 <em>knots</em> 。正常的 cubic spline 的自由度为 5+4 =9，但是由于 natural cubic spline 在两个边界处有线性限制，因此自由度为 9-4 = 5。下面怎么从5个自由度视为4个自由度没看懂，原话为：Since this includes a constant, which is absorbed in the intercept,we count it as four degrees of freedom.</p>
<h2 id="Comparison-to-Polynomial-Regression">Comparison to Polynomial Regression</h2>
<p>Regression spines 通常效果比普通的多项式回归更好。因为多项式回归是通过增加最高项的次数来增加模型的复杂性（例如，X<sup>15</sup>），但是 splines 则是通过增加 <em>knots</em> 的数目来实现这一点，一般来说 splines 结果更稳定。下图为自由度同样为15 的 <em>natural cubic spline</em> 和 多项式回归的结果，可以看出多项式回归在边界处的结果比较诡异。</p>
<p><img src="8.png" alt="1"></p>
<h1>Smoothing Splines</h1>
<p>上面提到的 <em>regression splines</em> 是通过创建 <em>knots</em> 的方式，通过 <em>basis functions</em> ，最终可以应用最小二乘回归来计算系数。这里介绍一种不一样的创建曲线的方式。</p>
<p>在对一个数据集拟合成一条平滑曲线的过程中，我们实际想要做的是，找到某个函数，比如说是 g(x)，可以有效地拟合训练集的数据：即 RSS 很小。但是存在一个问题在于，如果对于 g(x) 不加任何限制，我们最终一定可以选择一个 g(x) 函数，使得RSS 等于 0 ，这就会出现 overfitting ，这个函数也会非常地 <em>flexible</em> 。</p>
<p>所以，我们真正想要地函数是，既满足 RSS 很小，同时很<strong>平滑</strong>（<em>smooth</em>）。</p>
<p>那么我们如何确保 g() 函数是平滑的呢？这里有很多方法可以实现这一点。一个自然的方法是找到一个 g() 函数，使得下式最小：</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28y_%7Bi%7D-g%5Cleft(x_%7Bi%7D%5Cright%29%5Cright)%5E%7B2%7D%2B%5Clambda%20%5Cint%20g%5E%7B%5Cprime%20%5Cprime%7D(t)%5E%7B2%7D%20d%20t%0A" /></p><p>这里 λ 是一个非负的调整参数。满足这个条件的 g() 函数一般称为 <em>smoothing spline</em> 。</p>
<p>这个式子其实是 “Loss + Penalty&quot; 的形式，就和 lasso/ 岭回归一样。这里的惩罚项时二阶导数的积分。粗略地说，一个函数的二阶导数衡量了函数的 <em>roughness</em> ：二阶导数越大， g(t) 在接近 t 的波动越大，反之则相反（直线的二阶导数是0，因此认为是 <em>perfectly smooth</em> ）。惩罚项是二阶导数的积分，也就是整个定义域内一阶导数的总的变化大小。如果 g() 函数非常平滑，那么这个惩罚项会很小，反而如果 g() 函数是 <em>jumpy  and variable</em> , 那么 g’(t) 变化会很显著，惩罚项会很大。</p>
<p>当 λ = 0，那么就没有惩罚效应，因此 g() 函数会非常曲折，可以完美解释 training set 中所有的观测值。如果 λ → ∞ ，那么 g() 函数会非常平滑，就是一条直线，实际上这时候 g() 函数就是最小二乘回归直线。</p>
<p>通过这种方法得到的 g(x) 函数有下面的特性：它是分段三项式回归，其中的 knots 式所有的 x 值 (x<sub>1</sub>, ……, x<sub>n</sub>)，而且每个 knot 的一阶导数和二阶导数都是连续的。另外，g(x) 是一个 <em>natural cubic spline</em> ，但是这里的 <em>natural</em> 是一种 <em>shrunken version</em> ，这里通过调整 λ 值来控制 shrinkage 的水平。</p>
<h2 id="Choosing-the-Smoothing-Parameter-λ">Choosing the Smoothing Parameter λ</h2>
<p>由于这里得到的曲线的 knots 是所有的数据点。因此这里不需要考虑挑 <em>knots</em> 的问题，只需要考虑选一个合适的 λ 值。我们很容易想到的方法就是交叉验证。结果证明<strong>留一法</strong>交叉验证（LOOCV）在这里的计算效率很高，就和只拟合一次模型的计算量差不多大，使用公式如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BRSS%7D_%7Bc%20v%7D%28%5Clambda%29%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(y_%7Bi%7D-%5Chat%7Bg%7D_%7B%5Clambda%7D%5E%7B(-i)%7D%5Cleft(x_%7Bi%7D%5Cright)%5Cright)%5E%7B2%7D%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%5B%5Cfrac%7By_%7Bi%7D-%5Chat%7Bg%7D_%7B%5Clambda%7D%5Cleft(x_%7Bi%7D%5Cright)%7D%7B1-%5Cleft%5C%7B%5Cmathbf%7BS%7D_%7B%5Clambda%7D%5Cright%5C%7D_%7Bi%20i%7D%7D%5Cright%5D%5E%7B2%7D%0A" /></p><p>这里其实是用所有数据拟合模型的预测值代替了留一法拟合模型的预测值，因此不再需要拟合 n 次模型。前面也有提到了最小二乘回归的留一法也有一个类似的公式，如下（分母多了 leverage）。这可以用于 <em>regression splines</em> 中。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BCV%7D_%7B%28n%29%7D%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(%5Cfrac%7By_%7Bi%7D-%5Chat%7By%7D_%7Bi%7D%7D%7B1-h_%7Bi%7D%7D%5Cright)%5E%7B2%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=h_%7Bi%7D%3D%5Cfrac%7B1%7D%7Bn%7D%2B%5Cfrac%7B%5Cleft%28x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright%29%5E%7B2%7D%7D%7B%5Csum_%7Bi%5E%7B%5Cprime%7D%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%5E%7B%5Cprime%7D%7D-%5Cbar%7Bx%7D%5Cright)%5E%7B2%7D%7D%0A" /></p><p>下图显示了 <em>smoothing spline</em> 的结果：红线的自由度为16 的结果，蓝线为 LOOCV 挑出的最佳自由度（6.8）的结果。我们可以从预测结果来看，二者相差不大，但是蓝线更平滑，而且效果差不多时我们一般会使用更简单的模型。</p>
<p><img src="9.png" alt="1"></p>
<h1>Local Regression</h1>
<p><strong>局部线性回归</strong>是另外一种拟合非线性关系的方法，这种方法仅仅是目标值 x<sub>0</sub> 附近的点来拟合模型。下图指出了两个点的拟合情况，其中蓝线为生成这些数据的整数函数，橘色线是局部线性回归得到的函数。</p>
<p><img src="10.png" alt="1"></p>
<p>每一个点的拟合过程算法如下。</p>
<p><img src="11.png" alt="1"></p>
<p>在第3步中，不同 x 值的权重 K<sub>i0</sub> 都是不一样的。因此，每一个点的加权最小二乘回归模型都是不一样的，因为用到的点和权重都不一样。局部线性回归有时又称为 <em>memory-based</em> procedure ，因为就像 KNN 算法一样，预测每个点时我们都需要用到全部训练集的数据。</p>
<p>在执行局部线性回归的过程中，我们需要做很多决定，比如如何定义权重函数 K ？是拟合成直线、常数还是二次项回归？还有一个最重要的，如何决定 <em>span</em> s ?  这里 span 的作用就像 smoothing splines 中的 λ 值，它控制着拟合的 <em>flexibility</em> ，这里我们同样可以用交叉验证来决定 s 的大小。下图展示了 s = 0.7 和 0.2 的拟合效果，我们可以看到 s = 0.7 拟合的曲线更加平滑。</p>
<p><img src="12.png" alt="1"></p>
<p>局部线性回归的思路可以推广到别的地方。比如在有多个自变量的数据集中，一个有用的思路是拟合一个多重线性回归模型，其中一些变量是全局的，一些则是局部的。</p>
<h1>Generalized Additive Models</h1>
<p>在前面提到的方法中，我们都是针对一个自变量 X 对 因变量 Y 的预测，可以视为简单线性回归的拓展。这里我们探索多个预测因子的非线性问题，可以视为多重线性回归的拓展。</p>
<p><em>Generalized additive models</em> (GAMs) 扩展了标准的线性模型，可以允许非线性函数，但是仍保留 <em>additivity</em> 。就像线性模型一样，GAMs 既可以用于数量性状的反应变量，也可以用于质量性状的反应变量。</p>
<h2 id="GAMs-for-Regression-Porblems">GAMs for Regression Porblems</h2>
<p>一个标准的多重线性模型如下：</p>
<p style=""><img src="https://math.now.sh?from=y_%7Bi%7D%3D%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20x_%7Bi%201%7D%2B%5Cbeta_%7B2%7D%20x_%7Bi%202%7D%2B%5Ccdots%2B%5Cbeta_%7Bp%7D%20x_%7Bi%20p%7D%2B%5Cepsilon_%7Bi%7D%0A" /></p><p>为了可以允许自变量之间，自变量与因变量之间的非线性关系，我们可以将这里的 β<sub>j</sub>x<sub>ij</sub> 替换为一个非线性函数 <em>f<sub>j</sub></em> (x<sub>ij</sub>) 。即将模型改为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ay_%7Bi%7D%20%26%3D%5Cbeta_%7B0%7D%2B%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20f_%7Bj%7D%5Cleft%28x_%7Bi%20j%7D%5Cright%29%2B%5Cepsilon_%7Bi%7D%20%5C%5C%0A%26%3D%5Cbeta_%7B0%7D%2Bf_%7B1%7D%5Cleft(x_%7Bi%201%7D%5Cright)%2Bf_%7B2%7D%5Cleft(x_%7Bi%202%7D%5Cright)%2B%5Ccdots%2Bf_%7Bp%7D%5Cleft(x_%7Bi%20p%7D%5Cright)%2B%5Cepsilon_%7Bi%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>这个其中一个 GAM 的例子，这种模型称为一个<strong>加性模型</strong>的原因是因为，我们对每个 X<sub>j</sub> 分别计算一个单独 的 f<sub>j</sub>  值，然后把所有自变量的影响累加到一块。</p>
<p>在上面的部分中，我们讨论了很多拟合一个自变量的方法。GAMs 的优点在于我们可以利用上面这些方法来创建 <em>blocks</em> 来拟合一个加性模型。但是这个过程会非常繁琐。例如，以 <em>natural splines</em> 为例，拟合模型如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Ctext%20%7B%20wage%20%7D%3D%5Cbeta_%7B0%7D%2Bf_%7B1%7D%28%5Ctext%20%7B%20year%20%7D%29%2Bf_%7B2%7D(%5Ctext%20%7B%20age%20%7D)%2Bf_%7B3%7D(%5Ctext%20%7B%20education%20%7D)%2B%5Cepsilon%0A" /></p><p>这里，year 和 age 是连续变量，而 education 是分类变量（总共5个水平）。我们对前两个性状使用 <em>natural splines</em> 方法；我们对第三个变量的每个水平估计为一个单独的常数，即采用哑变量。</p>
<p>下图体现了使用最小二乘方法拟合模型的结果，因为 <em>natural splines</em> 可以用一系列 <em>basis functions</em> 来构建。因此整个模型是基于 <em>spline basis functions</em> 和 <em>dummy variables</em> 的 回归模型。左图表示<strong>如果固定 age 和 education</strong>,  wage 倾向于随着 year 的增加而增加。中间的图表示，<strong>如果固定education 和 year</strong>，wage 会随着age 先增加，后降低。右图表示，<strong>如果固定 year 和 age</strong>, wage 会随着学历的提高而提高。</p>
<p><img src="13.png" alt="1"></p>
<p>下图中 f<sub>1</sub> 和 f<sub>2</sub> 采用了 <em>smoothing splines</em> 方法。这种情况下更加复杂，因为  <em>smoothing splines</em> 方法无法采用最小二乘方法。但是，像 R 中的 gam() 函数可以用  <em>smoothing splines</em>  方法来拟合 GAMs 。方法就是不停预测某个特征的参数时，在先固定其他特征的值的前提下（没太搞懂）。</p>
<p><img src="14.png" alt="1"></p>
<p>这个效果和上面差不多，一般来说使用  <em>natural splines</em>  和   <em>smoothing splines</em> 的 GAMs 结果差距很小。</p>
<p>我们也可以不通用 splines 来创建 GAMs 的 blocks ：我们也可以用 local regression , polynomial regression 等方法来创建 。</p>
<h2 id="Pros-and-Cons-of-GAMs">Pros and Cons of GAMs</h2>
<p>我们这里总结一下 GAM 的优缺点。</p>
<p>优点如下：</p>
<ul>
<li>GAM 允许拟合反应变量与某个特征的非线性关系。</li>
<li>因为模型是加性的，因此我们可以检验每一个特征的效应（固定其他特征的值不变），因此很适合 <em>inference</em> （哪些特征有作用，作用的大小）。（例如多重线性回归，多重线性回归得到的某个特征的斜率的解释是，<strong>在其他特征不变的前提下</strong>每新增一个单位的X，反应变量的变化期望值。）</li>
</ul>
<p>缺点如下：</p>
<ul>
<li>GAMs 的最大缺点在于它只限制为<strong>加性</strong>模型。如果存在很多变量，那么可能会忽视<strong>重要的互作效应</strong>。但是，就是线性回归一样，我们可以手动添加互作效应（X<sub>j</sub> × X<sub>k</sub>）。</li>
</ul>
<p>GAMs 是线性模型和完全非参数模型之间的一个很好的过度方法。</p>
<h2 id="GAMs-for-Classification-Problems">GAMs for Classification Problems</h2>
<p>GAM 也可以用于反应变量为分类变量的情况。这里处于简化，假设 Y 只取 0 和 1 两个值。设定求 Y = 1 的概率。</p>
<p style=""><img src="https://math.now.sh?from=p%28x%29%20%3D%20Pr(Y%3D1%7CX)%0A" /></p><p>我们记得逻辑回归的公式如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Clog%20%5Cleft%28%5Cfrac%7Bp(X%29%7D%7B1-p(X)%7D%5Cright)%3D%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20X_%7B1%7D%2B%5Cbeta_%7B2%7D%20X_%7B2%7D%2B%5Ccdots%2B%5Cbeta_%7Bp%7D%20X_%7Bp%7D%0A" /></p><p>我们可以很自然地把它拓展成允许非线性关系的模型</p>
<p style=""><img src="https://math.now.sh?from=%5Clog%20%5Cleft%28%5Cfrac%7Bp(X%29%7D%7B1-p(X)%7D%5Cright)%3D%5Cbeta_%7B0%7D%2Bf_%7B1%7D%5Cleft(X_%7B1%7D%5Cright)%2Bf_%7B2%7D%5Cleft(X_%7B2%7D%5Cright)%2B%5Ccdots%2Bf_%7Bp%7D%5Cleft(X_%7Bp%7D%5Cright)%0A" /></p><p>这就是逻辑回归的 GAM 格式，它同样有上面提到的回归分析的GAM的优缺点。</p>
<p>还是用上面的 wage 数据集，我们预测薪资超过 $250,000 的概率。GAM 模型如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Clog%20%5Cleft%28%5Cfrac%7Bp(X%29%7D%7B1-p(X)%7D%5Cright)%3D%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20%5Ctimes%20%5Ctext%20%7B%20year%20%7D%2Bf_%7B2%7D(%5Ctext%20%7B%20age%20%7D)%2Bf_%7B3%7D(%5Ctext%20%7B%20education%20%7D)%0A" /></p><p style=""><img src="https://math.now.sh?from=p%28X%29%3D%5Coperatorname%7BPr%7D(%5Ctext%20%7B%20wage%20%7D%3E250%20%5Cmid%20%5Ctext%20%7B%20year%2C%20age%2C%20education%20%7D)%0A" /></p><p>这里 f<sub>2</sub> 采用 <em>smoothing spline</em> 算法，f<sub>3</sub> 采用 step function ，通过创建哑变量实现。结果如下图，右图看上去很奇怪，教育水平&lt; HS 的置信区间特别宽：事实上，这个水平没有值，即没有一个学历低于高中的人的薪水超过  $250,000 。</p>
<p><img src="15.png" alt="1"></p>
<p>因此，我们剔除了学历低于高中的个体的数据，然后重新拟合了模型，我们看到 age 和 education 对于成为高收入者的影响很大，而 year 影响很小。（剔除个体对 education 这个变量的作用这么大？）</p>
<p><img src="16.png" alt="1"></p>
<h1>R 代码</h1>
<p>略</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Bias Variance Trade-Off</title>
    <url>/posts/8a41a048/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>模型创建的思想，很大程度上取决于 <em><strong>Bias-Variance Trade-off</strong></em> 。</p>
<span id="more"></span>
<h1>资料</h1>
<p><a href="https://www.statlearning.com/">An Introduction to Statistical Learning</a>，下文简称 <strong>ISL</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/38853908">https://zhuanlan.zhihu.com/p/38853908</a></p>
<p><a href="http://scott.fortmann-roe.com/docs/BiasVariance.html">http://scott.fortmann-roe.com/docs/BiasVariance.html</a></p>
<h1>Split Test Error</h1>
<p>对于一个特定的 x<sub>0</sub> 值，它的 test MSE 期望值可以拆分为三部分：方差(the variance) , 偏差（bias）平方 ，和随机残差。</p>
<p style=""><img src="https://math.now.sh?from=E%5Cleft%28y_%7B0%7D-%5Chat%7Bf%7D%5Cleft(x_%7B0%7D%5Cright%29%5Cright)%5E%7B2%7D%3D%5Coperatorname%7BVar%7D%5Cleft(%5Chat%7Bf%7D%5Cleft(x_%7B0%7D%5Cright)%5Cright)%2B%5Cleft%5B%5Coperatorname%7BBias%7D%5Cleft(%5Chat%7Bf%7D%5Cleft(x_%7B0%7D%5Cright)%5Cright)%5Cright%5D%5E%7B2%7D%2B%5Coperatorname%7BVar%7D(%5Cepsilon)%0A" /></p><p>test MSE 期望值的意思是，如果我们不停地从很多的训练集中拟合模型，然后每次都计算 x0 的 test MSE 的均值。</p>
<p>上面的公式中，随机残差项是不可减少的，为了最小化 <em>expected test error</em> ，我们需要同时做到 <em>low variance</em> 和 <em>low bias</em> 。</p>
<h1>Variance</h1>
<p>方差指的是如果用了一个不一样的 training set ，拟合出来的模型的变化幅度。因为使用的 training set 不同，拟合出来的模型参数肯定不同，但是理想情况下差距不会很大。</p>
<h1>Bias</h1>
<blockquote>
<p><strong>Bias</strong>是用<strong>所有可能的训练数据集</strong>训练出的<strong>所有模型</strong>的输出的<strong>平均值</strong>与<strong>真实模型</strong>的输出值之间的差异。</p>
</blockquote>
<p>就是说，如果我们不停地拟合模型，所有拟合模型的均值和真实模型的差异。公式如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Bbias%7D%28%5Cboldsymbol%7Bx%7D%29%3D%5Cbar%7Bf%7D(%5Cboldsymbol%7Bx%7D)-y%0A" /></p><p>举个例子，如果我们用 1000 个 training set 拟合 1000 次线性模型。对这1000次模型的参数求均值，得到一个最终的模型，然后预测 test data 中 x 的预测值，减去真值，这个差值就可以视为 bias。</p>
<p>这1000次拟合的模型参数的方差，就是方差 variance 。</p>
<h1>用图形来解释</h1>
<p><img src="1.png" alt="1"></p>
<p>假设红色的靶心区域是学习算法完美的正确预测值，蓝色点为训练数据集所训练出的模型对样本的预测值，当我们从靶心逐渐往外移动时，预测效果逐渐变差。</p>
<p>bias 就是预测值均值与靶心的举例，variance 就是预测值的离散程度。</p>
<p>上图的个人解释：左上图是理想情况，右上图是过拟合（模型过于复杂，比如采用KNN算法），左下图是欠拟合（比如采用线性模型预测非线性关系），右下图是完全失败的模型（都很差）。</p>
<h1>Variance-Bias Trade-off</h1>
<p>模型越复杂，bias 会越来越小，variance 会越来越大。但是模型过于复杂，可能发生过拟合现象（bias 很小，但是 variance，拟合出来的模型对于其他数据的预测效果很差）。</p>
<p>然后总的 test error 会随着模型复杂度呈现一个 U 字型的变化。这就说明选择一个合适复杂度的模型很重要。</p>
<p><img src="2.png" alt="1"></p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>线性模型选择与正则化</title>
    <url>/posts/eb9174d6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>ISL 真是好书！</p>
<span id="more"></span> 
<h1>资料</h1>
<p><a href="https://www.statlearning.com/">An Introduction to Statistical Learning</a>，下文简称 <strong>ISL</strong></p>
<h1>概述</h1>
<p>标准的线性模型如下：</p>
<p style=""><img src="https://math.now.sh?from=Y%3D%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20X_%7B1%7D%2B%5Ccdots%2B%5Cbeta_%7Bp%7D%20X_%7Bp%7D%2B%5Cepsilon%0A" /></p><p>线性模型在接近实际问题中依然富有竞争力，通过使用别的拟合过程替换最小二乘法，可以改善线性模型的效果（<em>prediction accuracy</em> 和 <em>model interpretability</em> ）。</p>
<ul>
<li><em>Prediction Accuracy</em> :  假设因变量与自变量之间的真实关系就是几乎线性的，那么使用最小二乘法得到的估计值的 bias 会很低。 如果 n &gt;&gt; p ，也就说观测值数目远大于自变量数目，那么最小二乘估计值的 variance 也会很低。因此，如果满足这两个条件，最小二乘方法表现会很好。然而，如果 n 不是远大于 p， 那么最小二乘拟合结果的 variance 很高，容易造成 overfitting，然后在预测新的样本时结果很差。如果 p &gt; n ，那么根本无法得到一个唯一的最小二乘参数估计值，最小二乘法根本无法使用。如果此时我们人为地降低因变量的个数，那么我们的代价就是在降低了 variance 的同时 提高了 bias。</li>
<li><em>Model Interpretability</em> :  很多情况下，多重回归的一些自变量其实压根和因变量没关系。将这些无关变量添加到模型中会使得模型增加不必要的复杂度。通过移除这些变量 （即将它们的系数估计值设为0），我们可以得到一个更容易解释的模型。但是，使用最小二乘法估计参数是不可能得到正好是0的参数的（可以接近0，但不是0）。</li>
</ul>
<p>ISL 这里提到了三类替代最小二乘的方法</p>
<ul>
<li><em>Subset Selection</em> : 这种方法包括确认我们认为与因变量有关的一组自变量（从总共 p 个自变量中挑子集），然后我们用减少了变量个数的这组自变量预测因变量。</li>
<li><em>Shrinkage</em> :  这个方法同时使用所有的 p 个变量来拟合模型。但是，所有的最小二乘预测值均向0收缩（称为 <em>regularization</em>）。这种方法可以减少 variance ，有一些系数可能会正好估计为0，从而降低了自变量个数，可以实现变量选择。</li>
<li><em>Dimension Reduction</em> : 这个方法包含了将 p 个自变量投射到 (<em>projecting</em>) 一个M维的子空间中，其中 M &lt; p 。</li>
</ul>
<h1>Subset Selection</h1>
<h2 id="Best-Subset-Selection">Best Subset Selection</h2>
<p>为了找到 best subset， 我们需要使用 p 的自变量的所有组合来进行一个个单独的最小二乘拟合。因此我们需要进行p次包含一个变量的模型拟合，进行 p(p-1)/2 次包含两个变量的模型拟合，以此类推（总共 2<sup>p</sup> 次）。然后我们查看所有模型拟合的结果，找出我们认为是最好的模型。</p>
<p>这个过程的算法表述如下：这里我们挑出所有固定因子数目时的最佳组合，然后最后在比较不同因子数目中的最佳模型。</p>
<p><img src="1.png" alt="1"></p>
<p><strong>但是，这里需要注意一点, RSS是会随着变量数目的增加而递减的，无论增加的自变量有没有用。</strong></p>
<p>**因此，如果你使用 RSS 或 R<sup>2</sup> 作为评价指标，最终最好的模型一定是包含了所有自变量的模型。**如下图所示</p>
<p><img src="2.png" alt="1"></p>
<p>这里的问题在于，这里计算得到的 RSS 和 R<sup>2</sup> 实际衡量地是 <strong>training error</strong> ，但是我们要的模型应该是需要 <strong>test error</strong> 最低（training error 倾向于比 test error 更低，trainging error 很低无法保证 test error 很低）。因此在上图中的第三步，我们需要使用交叉验证的预测误差,  C<sub>p</sub>  ,  BIC , adjusted R<sup>2</sup> 来选择后 M<sub>0</sub> ,  M<sub>1</sub> ,  ……， M<sub>p</sub> 。</p>
<p>我们这里提到的思路虽然是用在最小二乘回归中，其他模型也是可以这么做的，比如逻辑回归。不过逻辑回归用的不是 RSS， 而是 <em><strong>deviance</strong></em> 。deviance 等于 -2 times <em>maximized log-likelihood</em> 。值越小，说明拟合程度越好。</p>
<p>虽然 <em>best subset seleciton</em> 方法很简单，逻辑也很清晰，但是它的问题就在于<strong>计算量</strong>太大。如果 p 大于40，这个算法就基本无法实现了。</p>
<h2 id="Stepwise-Selection">Stepwise Selection</h2>
<p>出于计算量的原因， 当 p 很大时，<em>best subset selection</em> 无法实现；除此之外，当 p 很大时这个方法还有其他问题。当 p 很大时，很大概率容易出现过拟合现象（模型仅适用于训练集，对于其他数据不适用，参见维度诅咒）</p>
<p>处于上面的原因，逐步回归是一个很好的备选方法。</p>
<h3 id="Forward-Stepwise-Selection">Forward Stepwise Selection</h3>
<p>向前逐步回归指模型从没有自变量出发，然后每次新增一个自变量，至到所有的自变量都加入到模型中。在实际中，每一步拟合到模型中的变量是 <em>gives the greatest additional improvement</em> 的变量。这个算法具体过程如下：</p>
<p><img src="3.png" alt="1"></p>
<p>这个算法比上面的 best subset 方法计算量小很多。虽然一般来说向前逐步回归效果很好，但是这种方法并不能保证一定能找到所有组合的最优组合。</p>
<p>例如，加入一个p=3的数据集，最好的一个变量的模型包含 X<sub>1</sub>，最好的两个变量的模型包含 X<sub>2</sub> 和 X<sub>3</sub> 。那么向前逐步回归在第二步找最优的二变量模型程序会失败，因为 M<sub>1</sub> 包含 X<sub>1</sub> ，因此 M<sub>2</sub> 必须包括 X<sub>1</sub> 。</p>
<p>这里举了个例子，比对 best subset 方法 和 forward stepwise 方法， 在四变量的时候，best subset 将 rating 替换为了 cards，而 forward stepwise 方法必须要包含 rating 。</p>
<p><img src="4.png" alt="1"></p>
<h3 id="Backward-Stepwise-Selection">Backward Stepwise Selection</h3>
<p>与向前迭代回归相反，向后迭代回归从包含所有的变量开始，然后每次剔除一个最没有用的变量。具体算法见下：</p>
<p><img src="5.png" alt="1"></p>
<p>同样类似于向前迭代，向后迭代同样不保证能够挑出最好的模型。但是向后迭代要求 n &gt; p 。如果 p 很大，只能使用向前迭代。</p>
<h3 id="Hybrid-Approaches">Hybrid Approaches</h3>
<p>我们可以同时杂合使用向前迭代和向后迭代。我们先按照类似于向前迭代回归的方法来添加因子，但是当我们添加了一个新的变量后，这个方法会剔除不能使得这个模型拟合更好的变量（就是走一步，再退一步）。这种方法最接近于 best subset selection ，并且同时利用了向前迭代回归和向后迭代回归的优势。</p>
<p>其实意思就是说，基本用的方法是向前迭代，但是向前迭代是一种贪婪算法，之前的变量会一直保留。但是在不断新增变量的过程中，可能发生一种现象，那就是最开始加入的变量变得不重要了（变量之间的相关性），这个时候剔除不显著的初始变量更为合理。因此这种混合迭代的方法，每新增一个变量，就会看看旧的变量有没有无用变量，有的话就剔除。这种做法更加合理。</p>
<h2 id="Choosing-the-Optimal-Model">Choosing the Optimal Model</h2>
<p><strong>上面的这些方法都会构建很多模型，我们需要一种方法来决定哪个模型是最优的</strong>。就像我们提到的，R<sup>2</sup> 和 RSS 会随着自变量数目的增加而降低，因此不能作为决定自变量数目不同的模型之间比较的指标。这里我们需要能估计 test error 的指标作为评判标准。这里有两种方法：</p>
<ol>
<li>我们可以i通过对 training error 做出调整，间接估计 test error</li>
<li>我们可以通过对 validation set 或使用交叉验证方法，直接估计 test error</li>
</ol>
<p>下面会详细介绍这两种方法</p>
<h3 id="C-sub-p-sub-AIC-BIC-and-Adjusted-R-sup-2-sup">C<sub>p</sub>, AIC, BIC, and Adjusted R<sup>2</sup></h3>
<p>这些参数都是通过调整 training error 来估计  test error ，主要是避免了自变量数目会降低training error 的影响。这里主要考虑四种方法：<strong>C<sub>p</sub>, <abbr title="Akaike information criterion">AIC</abbr>, <abbr title="Bayesian information criterion">BIC</abbr>, and Adjusted R<sup>2</sup></strong> 。下图显示了 best subset selection 方法的四个参数的值的变化。</p>
<p><img src="6.png" alt="1"></p>
<p>对于包含了 d 个因子的最小二乘模型， 使用 C<sub>p</sub> 估计 test MSE 的公式如下（下面是MSE的估计公式）：</p>
<p style=""><img src="https://math.now.sh?from=C_%7Bp%7D%3D%5Cfrac%7B1%7D%7Bn%7D%5Cleft%28%5Cmathrm%7BRSS%7D%2B2%20d%20%5Chat%7B%5Csigma%7D%5E%7B2%7D%5Cright%29%0A" /></p><p style=""><img src="https://math.now.sh?from=%7BEsetimated%7D%20%5Coperatorname%20%7B%20training%20%7D%20%5Coperatorname%20%7Berror%7D%3D%5Cfrac%7B1%7D%7Bn%7D%5Cleft%28%5Cmathrm%7BRSS%7D%5Cright%29%0A" /></p><p>这里 σ_hat<sup>2</sup>  是对因变量预测的残差方差的估计值。</p>
<p style=""><img src="https://math.now.sh?from=%5Ctext%20%7B%20training%20%7D%20%5Coperatorname%7BRSS%7D%0A" /></p><p>我们可以 C<sub>p</sub> 添加了一个惩罚项，如下式，来调整 training error 容易低估 test error 的趋势。而且这个惩罚项会随着自变量数目的增加而增加（含有d），从而趋于弥补 training RSS 随着变量增加而降低的趋势。</p>
<p style=""><img src="https://math.now.sh?from=2%20d%20%5Chat%7B%5Csigma%7D%5E%7B2%7D%0A" /></p><p>由于 σ_hat<sup>2</sup> 是 σ<sup>2</sup> 的无偏估计值，因此  C<sub>p</sub> 是 test MSE 的一个无偏估计值（?）。</p>
<p><strong>AIC</strong> 应用在使用最大似然法来拟合参数的模型中，但是在线性模型中，最大似然法和最小二乘是一回事。在这种情况下，AIC 计算公式如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BAIC%7D%3D%5Cfrac%7B1%7D%7Bn%20%5Chat%7B%5Csigma%7D%5E%7B2%7D%7D%5Cleft%28%5Cmathrm%7BRSS%7D%2B2%20d%20%5Chat%7B%5Csigma%7D%5E%7B2%7D%5Cright%29%0A" /></p><p>我们可以看到 AIC 和  C<sub>p</sub>  是一个比例关系，AIC 乘以  σ_hat<sup>2</sup> 就得到了  C<sub>p</sub> ，因此这两个是等价的，所以在上图中只显示了  C<sub>p</sub> 的结果。</p>
<p>BIC 来源于贝叶斯的观点，但是最终的公式和 AIC/ C<sub>p</sub> 差不多，对于最小二乘模型，公式如下，这里相比较 AIC ，就是把 2 改为了 log(n) （这里其实应该写成 ln(n) , 底为 e,  只要 n &gt; 7, ln(n) 就大于2 ），因此 <strong>BIC 对自变量数目很多的模型的惩罚效应更重</strong>。因此上面的图中 BIC 的最佳变量数目为 4，而 AIC/ C<sub>p</sub>是 6 ，其实在图中我们看到变量数目为4后面的曲线就很平了，变量数为4还是6没啥区别。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BBIC%7D%3D%5Cfrac%7B1%7D%7Bn%20%5Chat%7B%5Csigma%7D%5E%7B2%7D%7D%5Cleft%28%5Cmathrm%7BRSS%7D%2B%5Clog%20(n%29%20d%20%5Chat%7B%5Csigma%7D%5E%7B2%7D%5Cright)%0A" /></p><p>校正R2 公式如下，也是会对变量数目过多有惩罚效应</p>
<p style=""><img src="https://math.now.sh?from=%5Ctext%20%7B%20Adjusted%20%7D%20R%5E%7B2%7D%3D1-%5Cfrac%7B%5Coperatorname%7BRSS%7D%20%2F%28n-d-1%29%7D%7B%5Coperatorname%7BTSS%7D%20%2F(n-1)%7D%0A" /></p><p>这四种方法均有严谨的理论证明，但是ISL没讲，它们的证明均有一定的前提或<strong>假设</strong>（如 n 非常大）。<strong>虽然校正R<sup>2</sup> 很流行，但是从理论上校正R<sup>2</sup> 的效果不如另外三种方法</strong>。</p>
<h3 id="Validation-and-Cross-Validation">Validation and Cross-Validation</h3>
<p>除了通过校正 training error 间接估计 test error ，我们也可以通过验证集或交叉验证直接估计 test error ，好处就是需要满足的假设更少，而且可以应用在非常广泛的模型选择任务中（不一定是线性模型）。</p>
<p>在过去，由于执行交叉验证需要很大的计算量无法实现，从而导致 AIC ，BIC 等方法更加流行。但是如今随着计算机算力的增加，交叉验证的计算量已经不再是问题了，因此交叉验证成为了模型选择更好的方法。</p>
<p>下图展示了 BIC， validation set errors , CV （k=10）三种方法的结果，我们可以看后面两种方法的最佳变量数目均是6，但是我们看到 变量数是4 还是 6 差不多。validation set errors 是通过随机挑选3/4的个体作为训练集，剩下的个体就作为验证集。</p>
<p><img src="7.png" alt="1"></p>
<p>其实我们可以看到，变量数为 3到11之间的差距很多，如果计算 valiation set errors 时换一种区分参考集和验证集的方式，或者 CV 方法换一个 k 值，那么可能找到的最佳的变量数目会变化。其实，实际我们选模型的方式是 <em><strong>one-standard-error rule</strong></em> ：我们需要同时计算 test MSE 估计值的标准误，然后<strong>挑 test MSE 最低点 的 一倍标准误内的最简单的模型。</strong> 后面的逻辑就是：<strong>如果有很多模型效果差不多好，那么我们应该挑最简单的模型</strong>。 在上面的例子中，我们最终挑选的模型就是 3个变量的模型。</p>
<h1>Shrinkage Methods</h1>
<p>上面提到的那些方法是用来挑选变量的方法。作为另外一种备选方法，我们可以同时将 p 个预测因子均包含在模型中，然后 <em>constrain</em> 或者说是 <em>regularize</em> 系数估计值，或者说是，<em>shrinks</em> the coefficient estimates towards zero。</p>
<p>在这当中，最出名的两个方法就是 <em>ridge  regression</em> 和 <em>lasso</em> 。</p>
<h2 id="Ridge-Regression">Ridge Regression</h2>
<p>一般的线性模型估计参数的标准是，使得RSS最小，公式如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BRSS%7D%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28y_%7Bi%7D-%5Cbeta_%7B0%7D-%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%20x_%7Bi%20j%7D%5Cright%29%5E%7B2%7D%0A" /></p><p>岭回归（Ridge regression）类似于最小二乘，但是它拟合参数用的需要最小化的指标不同，公式如下，其中 λ ≥ 0 ， 称之为 <em>tuning parameter</em> 。每设置一个不同的 λ ，就能得到一套不同的模型参数。因此，<strong>选择一个合适的 λ 是至关重要的</strong>。</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28y_%7Bi%7D-%5Cbeta_%7B0%7D-%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%20x_%7Bi%20j%7D%5Cright%29%5E%7B2%7D%2B%5Clambda%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%5E%7B2%7D%3D%5Cmathrm%7BRSS%7D%2B%5Clambda%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%5E%7B2%7D%0A" /></p><p>其实就是新增了一部分，称为 <em>shrinkage penalty</em> ， 作用是将所有的参数尽量往0压缩。</p>
<p style=""><img src="https://math.now.sh?from=%5Clambda%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%5E%7B2%7D%0A" /></p><p>注意到， <em>shrinkage penalty</em>  仅仅针对 β<sub>1</sub>, …… ， β<sub>p</sub> ， 但是不会针对截距 β<sub>0</sub> ，理由显而易见。</p>
<p>岭回归的效果如下图，左边是估计系数随着 λ 的变化的趋势，可以看到随着 λ 的增加，所有因变量的系数均趋向于 0。</p>
<p><img src="8.png" alt="1"></p>
<p>右图的横坐标改了，分子/分母的计算方式如下：</p>
<p style=""><img src="https://math.now.sh?from=%5C%7C%5Cbeta%5C%7C_%7B2%7D%3D%5Csqrt%7B%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%7B%20%7D%5E%7B2%7D%7D%0A" /></p><p>因此当 λ = 0，岭回就是普通的线性回归，右图横坐标为1；当 λ 趋于 ∞ 时， 右图横坐标趋于0。</p>
<p>标准的线性回归的系数估计值是 <em>scale equivariant</em> ：如果将自变量 X<sub>j</sub> 乘以一个常数 c ，那么这个自变量的系数的估计值就会乘以常数 1/c 。用另外一句话说，无论自变量的值如何缩放，下面这个式子的值永远不变。</p>
<p style=""><img src="https://math.now.sh?from=X_%7Bj%7D%20%5Chat%7B%5Cbeta%7D_%7Bj%7D%0A" /></p><p>但是，与之相反，<strong>岭回归</strong>的系数估计值会随着<strong>自变量系数乘以一个常数</strong>发生<strong>实质性变化</strong>。例如工资这个变量，单位是美元，如果单位换成千美元，那么标准的线性回归的系数估计就会缩小1000倍。这个时候由于岭回归的代价函数中含有系数估计值的平方项，岭回归系数就不会是正好缩小1000倍。换句话说，下式不仅仅取决于 λ 的大小，而且也取决于自变量的缩放比例，甚至还会受到其他自变量缩放比例的影响。</p>
<p style=""><img src="https://math.now.sh?from=X_%7Bj%7D%20%5Chat%7B%5Cbeta%7D_%7Bj%2C%20%5Clambda%7D%5E%7BR%7D%0A" /></p><p>因此，<strong>在进行岭回归前，需要对自变量进行标准化</strong>。公式如下，分母为估计的标准差。这样所有的自变量有相同 的 <em>scale</em>（不知道啥叫 scale） 。经过下面这个公式，所有自变量均拥有值为1的标准差。</p>
<p style=""><img src="https://math.now.sh?from=%5Ctilde%7Bx%7D_%7Bi%20j%7D%3D%5Cfrac%7Bx_%7Bi%20j%7D%7D%7B%5Csqrt%7B%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28x_%7Bi%20j%7D-%5Cbar%7Bx%7D_%7Bj%7D%5Cright%29%5E%7B2%7D%7D%7D%0A" /></p><p>所以上图6.4 的横坐标是  <strong>standardized ridge regression coefficient estimates</strong>, 也就是说自变量已经经过标准化了。</p>
<h3 id="为什么岭回归比最小二乘更好">为什么岭回归比最小二乘更好</h3>
<p>这还是来自于 <em>bias-variance trade-off</em> 。随着 λ 增加，岭回归的 <em>flexibility</em> 会降低，导致 variance 降低，但是 bias 增加。如下图所示，当 λ = 0 时， variance 很高，但是没有bias；最佳的 λ 值接近于30 。</p>
<p><img src="9.png" alt="1"></p>
<p>一般来说，当因变量与 p个自变量之间的真实关系接近线性关系，那么最小二乘估计值拥有很低的 bias ，但是 variance 很高。这意味着只要 training data 发生一个很小的变化，参数估计值就会发生很大的变化。在实际情况中，如果 p 非常大，接近于 n，那么最小二乘估计的参数会是 <em>extremely variable</em> 。 <strong>如果当 p &gt; n， 最小二乘甚至无法给出一个唯一解</strong>。这个时候岭回归依然可以发挥作用，仅仅会增加一点 bias，但是会极大地降低 variance 。因此，<strong>岭回归适用于 p 很大的情况（最小二乘的 variance 很高）</strong>。</p>
<h2 id="The-Lasso">The Lasso</h2>
<p><strong>岭回归的一个明显的缺点是，它最终的模型中会包含所有p个自变量</strong>。虽然它会将所有的系数向0压缩，但是它不会真的把某些系数设置为0，仅仅是接近0。这对于预测没有影响，但是对于模型解释很有影响。</p>
<p>lasso 方法是岭回归的一个替代方法，它克服了上面的这个劣势。lasso 的 代价函数如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28y_%7Bi%7D-%5Cbeta_%7B0%7D-%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%20x_%7Bi%20j%7D%5Cright%29%5E%7B2%7D%2B%5Clambda%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%5Cleft%7C%5Cbeta_%7Bj%7D%5Cright%7C%3D%5Cmathrm%7BRSS%7D%2B%5Clambda%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%5Cleft%7C%5Cbeta_%7Bj%7D%5Cright%7C%0A" /></p><p>我们可以看到， lasso 和 岭回归公式相似，仅仅是把系数估计值平方改为绝对值。同样，类似于岭回归，lasso 也同样将系数估计值 <em>shrinks towards zero</em> 。但是，<strong>lasso 可以使得某些系数估计值正好是0</strong>。因此，类似于 best subset selection 方法， lasso 方法同时可以实现变量选择的目的。我们一般说，<em>the lasso yields <strong>sparse</strong> models</em> ，也就是说模型仅包含部分向量。同样地，选择一个合适的 λ 值对 lasso 方法也很重要。</p>
<p>下图为 lasso 方法的效果，我们可以只要选择不同的λ值，就可以得到不同的因子数目的模型。</p>
<p><img src="10.png" alt="1"></p>
<h3 id="岭回归和-lasso-方法的另一种理解">岭回归和 lasso 方法的另一种理解</h3>
<p>我们认为 lasso 和 岭回归的系数估计过程，可以视为接近下面这两个问题</p>
<p style=""><img src="https://math.now.sh?from=%5Cunderset%7B%5Cbeta%7D%7B%5Coperatorname%7Bminimize%7D%7D%5Cleft%5C%7B%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28y_%7Bi%7D-%5Cbeta_%7B0%7D-%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%20x_%7Bi%20j%7D%5Cright%29%5E%7B2%7D%5Cright%5C%7D%20%5Cquad%20subject%20%5Cquad%20to%20%5Cquad%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%5Cleft%7C%5Cbeta_%7Bj%7D%5Cright%7C%20%5Cleq%20s%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cunderset%7B%5Cbeta%7D%7B%5Coperatorname%7Bminimize%7D%7D%5Cleft%5C%7B%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28y_%7Bi%7D-%5Cbeta_%7B0%7D-%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%20x_%7Bi%20j%7D%5Cright%29%5E%7B2%7D%5Cright%5C%7D%20%5Cquad%20subject%20%5Cquad%20to%20%5Cquad%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%5E%7B2%7D%20%5Cleq%20s%0A" /></p><p>也就是说，对于任意一个 λ 值，都会有有一个 s 值作为系数估计值绝对值/平方和的最大值，在满足小于 s 的前提下，RSS 最小的系数就是估计的系数。</p>
<p>best subset selection 可以理解为下式，也就是说条件是系数数目要低于 s 。</p>
<p style=""><img src="https://math.now.sh?from=%5Cunderset%7B%5Cbeta%7D%7B%5Coperatorname%7Bminimize%7D%7D%5Cleft%5C%7B%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28y_%7Bi%7D-%5Cbeta_%7B0%7D-%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%20x_%7Bi%20j%7D%5Cright%29%5E%7B2%7D%5Cright%5C%7D%20%5Cquad%20subject%20%5Cquad%20to%20%5Cquad%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20I%5Cleft(%5Cbeta_%7Bj%7D%20%5Cneq%200%5Cright)%20%5Cleq%20s%0A" /></p><p><strong>当 p 很大时，best subset selection 方法不可用，这时候必须用岭回归或者 lasso 方法。</strong></p>
<h3 id="为什么lasso可以实现变量选择？">为什么lasso可以实现变量选择？</h3>
<p>下图为p=2时一个解释说明， 红色的圈为RSS等高线，中间的黑点为最小二乘估计值；蓝色图形为 lasso/ 岭回归限制条件的区域，lasso 是一个菱形，岭回归是一个圆形。如果 s 很大，那么lasso/岭回归的限制条件区域就可能包含最小二乘估计值，那么此时解就等于最小二乘估计值。但是我们图中的限制条件区域并不大，左图为 lasso 结果，估计值为RSS等高线与菱形限制区域外边缘刚刚好接触的那个交点，岭回归同理。由于岭回归的限制区域是一个圆形，没有突出点，因此这个交点很难正好在某个轴上；而 lasso 的四个突出点均在轴上，因此交点很有可能就是轴上的突出点，如图中所示。</p>
<p>在更高的维度上，可能就会有很多的系数估计值都是0。</p>
<p><img src="11.png" alt="1"></p>
<h3 id="比较-lasso-和-岭回归">比较 lasso 和 岭回归</h3>
<p>我们很容易看到 lasso 方法相比于岭回归有很大的优势，产生的模型更容易解释，但是哪种方法的预测准确性更好呢？下图中右图为比较岭回归和lasso的结果，横坐标均为 training data 的 R<sup>2</sup> ，这是一种很好的比较不同的正则方法的方式。我们可以岭回归和 lasso 的 bias 差不多，但是岭回归的 variance 更低。这个图是由于所有的45个自变量都和因变量有关系，所以岭回归效果更好。</p>
<p><img src="12.png" alt="1"></p>
<p>如果我们用的模拟数据，因变量只和45个变量中的2个变量有关系，这时我们可以从下图看到，lasso 预测效果更好。</p>
<p><img src="13.png" alt="1"></p>
<p>这说明**这两种方法之间在预测准确性上没有绝对的优劣之分。**如果因变量实际与大量的预测因子均有关系，那么岭回归效果更好。但是，<strong>与因变量有关的因子数目在实际项目中是一个未知数</strong>，但是我们可以通过交叉验证来决定哪种方法更好。</p>
<h3 id="一个说明岭回归和lasso的简单例子">一个说明岭回归和lasso的简单例子</h3>
<p>为了更好地理解岭回归和 lasso 的特性，我们考虑一个特殊的例子，其中 n = p， 然后 X 是一个单位矩阵。为了进一步简化问题，假设我们正在执行没有截距的回归。根据上面这些假设，最小二乘问题简化为寻找使得下式最小的一组系数</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%5Cleft%28y_%7Bj%7D-%5Cbeta_%7Bj%7D%5Cright%29%5E%7B2%7D%0A" /></p><p>在这个例子中，最小二乘解为</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cbeta%7D_%7Bj%7D%3Dy_%7Bj%7D%0A" /></p><p>在这种情况下，岭回归的解为下式最小的一组系数估计值</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%5Cleft%28y_%7Bj%7D-%5Cbeta_%7Bj%7D%5Cright%29%5E%7B2%7D%2B%5Clambda%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%5E%7B2%7D%0A" /></p><p>lasso 的公式如下</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%5Cleft%28y_%7Bj%7D-%5Cbeta_%7Bj%7D%5Cright%29%5E%7B2%7D%2B%5Clambda%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%5Cleft%7C%5Cbeta_%7Bj%7D%5Cright%7C%0A" /></p><p>岭回归的解为</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cbeta%7D_%7Bj%7D%5E%7BR%7D%3Dy_%7Bj%7D%20%2F%281%2B%5Clambda%29%0A" /></p><p>lasso 的解为</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cbeta%7D_%7Bj%7D%5E%7BL%7D%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bll%7Dy_%7Bj%7D-%5Clambda%20%2F%202%20%26%20%5Ctext%20%7B%20if%20%7D%20y_%7Bj%7D%3E%5Clambda%20%2F%202%20%5C%5C%20y_%7Bj%7D%2B%5Clambda%20%2F%202%20%26%20%5Ctext%20%7B%20if%20%7D%20y_%7Bj%7D%3C-%5Clambda%20%2F%202%20%5C%5C%200%20%26%20%5Ctext%20%7B%20if%20%7D%5Cleft%7Cy_%7Bj%7D%5Cright%7C%20%5Cleq%20%5Clambda%20%2F%202%5Cend%7Barray%7D%5Cright.%0A" /></p><p>下图展示了这种情况。我们可以看到 岭回归和 lasso 的 <em>shrink</em> 策略不一样。在岭回归中，所有的系数的压缩比例都是相同的；与之相反，lasso  将正负 λ/2 之间的系数都直接压缩为0，其他范围的系数压缩比例相同。</p>
<p><img src="14.png" alt="1"></p>
<h3 id="岭回归和-lasso-的贝叶斯解释">岭回归和 lasso 的贝叶斯解释</h3>
<p>我们现在可以用一个 贝叶斯方法的视角来重新审视岭回归和 lasso 。从贝叶斯方法的角度出发，首先我们需要知道回归系数的先验分布，我们称为 <em>p(β)</em>  。 数据的似然性可以写作 f(Y|X, β) 。 先验分布乘以似然值 ，我们就得到了后验分布，形式如下（?）</p>
<p style=""><img src="https://math.now.sh?from=p%28%5Cbeta%20%5Cmid%20X%2C%20Y%29%20%5Cpropto%20f(Y%20%5Cmid%20X%2C%20%5Cbeta)%20p(%5Cbeta%20%5Cmid%20X)%3Df(Y%20%5Cmid%20X%2C%20%5Cbeta)%20p(%5Cbeta)%0A" /></p><p>一般的线性模型如下：</p>
<p style=""><img src="https://math.now.sh?from=Y%3D%5Cbeta_%7B0%7D%2BX_%7B1%7D%20%5Cbeta_%7B1%7D%2B%5Cldots%2BX_%7Bp%7D%20%5Cbeta_%7Bp%7D%2B%5Cepsilon%0A" /></p><p>我们假设残差之间是独立的，而且来自于一个相同的正态分布。还有，我们假设下式成立，其中g() 为一个密度函数，岭回归和 lasso 服从两个特殊的密度分布。</p>
<p style=""><img src="https://math.now.sh?from=p%28%5Cbeta%29%3D%5Cprod_%7Bj%3D1%7D%5E%7Bp%7D%20g%5Cleft(%5Cbeta_%7Bj%7D%5Cright)%0A" /></p><p>我们可以发现岭回归和 lasso 服从两个不同的 g() 函数。</p>
<ul>
<li>如果 g 是一个均值为0，标准差为 λ 函数的正态分布，那么 β 的 <em>posterior mode</em> （基于给定数据的最可能的 β值）就是岭回归的解。换句话说，岭回归的解就是这个时候的后验分布的均值。</li>
<li>如果 g 是 一个 双指数分布 (<em>double-exponential</em>)  (也叫<a href="https://zh.wikipedia.org/wiki/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%88%86%E5%B8%83">拉普拉斯分布</a>) ， 均值为0，<em>scale parameter</em>  是 λ 的函数，那么这时的 <em>posterior mode</em> 就是 lasso 的解。</li>
</ul>
<p>这两种分布如下图所示。</p>
<p><img src="15.png" alt="1"></p>
<h3 id="选择-λ-的值">选择 λ 的值</h3>
<p>岭回归和 lasso 均需要选择一个合适的值。交叉验证提供一个简单的解决办法，通过计算不同的 λ 的 CV errors ，来选择一个 CV errors 最低的 λ 值，如下图所示，左图为不同的λ值计算得到的 CV errors，右图为不同的 λ 值计算得到的岭回归标准化系数。我们通过左图可以看到，最佳的 λ 值的 CV error 降低幅度并不明显，左图的左半边基本都是平的，<strong>这种情况一般我们会直接用最小二乘法</strong>，而不用岭回归/lasso。</p>
<p><img src="16.png" alt="1"></p>
<p>下图为 lasso 的十倍交叉验证与系数估计结果。左图为交叉验证结果；右图为系数估计结果，两根有颜色的线为与因变量有关的因子（<em>signal variables</em>），灰线表示无关变量（<em>noise variables</em>）。这里我们发现最佳的 λ 值比较大，而且最佳 λ 值只保留了两个显著变量，因此证明了交叉验证的结果很好地给出了一个合适的 λ 值，这很有挑战，因为这个例子中有 p=45 个因子，但是只有 n=50 个观测值。作为比较，最小二乘结果（右图横坐标为1）仅仅给一个显著变量分配了一个较大的系数（红线）。</p>
<p><img src="17.png" alt="1"></p>
<h1>Dimension Reduction Methods</h1>
<p>上面提到的两种方法，subset selection 和 shrinkage methods ，都还是使用的原来的预测因子，X<sub>1</sub> , X<sub>2</sub> …… X<sub>p</sub> 。 下面会提到如何 <em>transform the predictors</em> ，然后将转换后的预测因子用于最小二乘模型。我们一般将这些方法称为 <em>dimension reduction methods</em>。</p>
<p>我们假设  Z<sub>1</sub> , Z<sub>2</sub> …… Z<sub>M</sub> 表示 M 个原来 p 个预测因子的线性组合 (<em>linear combinations</em>) ，其中 M &lt; p 。即：</p>
<p style=""><img src="https://math.now.sh?from=Z_%7Bm%7D%3D%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cphi_%7Bj%20m%7D%20X_%7Bj%7D%0A" /></p><p>其中 <em>Φ<sub>jm</sub></em> 为常数。</p>
<p>把上面转换后的预测因子，带入到线性回归模型中，如下</p>
<p style=""><img src="https://math.now.sh?from=y_%7Bi%7D%3D%5Ctheta_%7B0%7D%2B%5Csum_%7Bm%3D1%7D%5E%7BM%7D%20%5Ctheta_%7Bm%7D%20z_%7Bi%20m%7D%2B%5Cepsilon_%7Bi%7D%2C%20%5Cquad%20i%3D1%2C%20%5Cldots%2C%20n%0A" /></p><p>这样就从估计 <em>p+1</em> 个系数降低至估计 <em>M+1</em> 个系数。根据上面的公式进行推导得到</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bm%3D1%7D%5E%7BM%7D%20%5Ctheta_%7Bm%7D%20z_%7Bi%20m%7D%3D%5Csum_%7Bm%3D1%7D%5E%7BM%7D%20%5Ctheta_%7Bm%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cphi_%7Bj%20m%7D%20x_%7Bi%20j%7D%3D%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Csum_%7Bm%3D1%7D%5E%7BM%7D%20%5Ctheta_%7Bm%7D%20%5Cphi_%7Bj%20m%7D%20x_%7Bi%20j%7D%3D%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%20x_%7Bi%20j%7D%0A" /></p><p>因此，</p>
<p style=""><img src="https://math.now.sh?from=%5Cbeta_%7Bj%7D%3D%5Csum_%7Bm%3D1%7D%5E%7BM%7D%20%5Ctheta_%7Bm%7D%20%5Cphi_%7Bj%20m%7D%0A" /></p><p>通过降维的方法可能会增加系数估计的 bias，但是当相比对 n 而言，p 很大时，通过降维的方法可以显著降低 variance 。</p>
<p>所有的降维方法均分为两步。第一步，获得   Z<sub>1</sub> , Z<sub>2</sub> …… Z<sub>M</sub>  这些新的预测因子；第二步，通过这些 M 个因子来拟合模型。但是如何获取新的预测因子，或者说如何得到这些 <em>Φ<sub>jm</sub></em> 的值，这存在很多方法。这里只考虑两个主要的方法：<em>principal components</em> (主成分)  和 <em>partial least squares</em> 。</p>
<h2 id="Principal-Components-Regression">Principal Components Regression</h2>
<p>主成分分析 (<em>principal components analysis</em>, PCA) 是一个流行的降维方法。这里只讨论 PCA 在回归分析中的作用。第一主成分是指观测值在这个成分上的变异最丰富的成分。例如下图为两个因子的散点图，横坐标为城市的人口数量，纵坐标为某个特定公司的广告费用，这里总共是100个城市的结果。绿色实线表示第一主成分方向 (<em>first principal component direction</em>)，我们可以如果把所有的点均投影到这条线上，投影到第一主成分上得到的点的方差是最大的。如果我们把这些点投射到别的直线上，得到的变异均会更低。</p>
<p><img src="18.png" alt="1"></p>
<p>第一主成分的公式如下，即  <em>Φ<sub>11</sub></em> = 0.839 和  <em>Φ<sub>21</sub></em> = 0.544 。(  <em>Φ<sub>11</sub></em> 等称为 <em>principal component loadings</em> ) （<strong>我不太清楚上面的直线和这个公式之间有什么关系</strong>）</p>
<p style=""><img src="https://math.now.sh?from=Z_%7B1%7D%3D0.839%20%5Ctimes%28%5Cmathrm%7Bpop%7D-%5Coverline%7B%5Cmathrm%7Bpop%7D%7D%29%2B0.544%20%5Ctimes(%5Cmathrm%7Bad%7D-%5Coverline%7B%5Cmathrm%7Bad%7D%7D)%0A" /></p><p>我大致把 Z1 的三维图片画了出来，是一个平面，代码如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages(<span class="string">&quot;barsurf&quot;</span>)</span><br><span class="line">library(<span class="string">&quot;barsurf&quot;</span>)</span><br><span class="line"></span><br><span class="line">install.packages(<span class="string">&quot;plotrix&quot;</span>)</span><br><span class="line">library(<span class="string">&quot;plotrix&quot;</span>)</span><br><span class="line"></span><br><span class="line">install.packages(<span class="string">&quot;scatterplot3d&quot;</span>)</span><br><span class="line">library(<span class="string">&quot;scatterplot3d&quot;</span>)</span><br><span class="line"></span><br><span class="line">install.packages(<span class="string">&quot;plot3D&quot;</span>)</span><br><span class="line">library(<span class="string">&quot;plot3D&quot;</span>)</span><br><span class="line"></span><br><span class="line">install.packages(<span class="string">&quot;MBA&quot;</span>)</span><br><span class="line">library(<span class="string">&quot;MBA&quot;</span>)</span><br><span class="line"></span><br><span class="line">x &lt;- seq(<span class="number">10</span>, <span class="number">70</span>)</span><br><span class="line">y &lt;- seq(<span class="number">0</span>,<span class="number">35</span>)</span><br><span class="line">f &lt;- <span class="keyword">function</span>(x, y) &#123;</span><br><span class="line">  r &lt;- 0.839*(x-<span class="number">40</span>) + <span class="number">0.544</span>*(y-<span class="number">15</span>)</span><br><span class="line">  <span class="built_in">return</span>(r)</span><br><span class="line">&#125;</span><br><span class="line">z &lt;- outer(x, y, f)</span><br><span class="line">op &lt;- par(bg = <span class="string">&quot;white&quot;</span>)</span><br><span class="line">nrz &lt;- nrow(z)</span><br><span class="line">ncz &lt;- ncol(z)</span><br><span class="line">jet.colors &lt;- colorRampPalette(<span class="built_in">c</span>(<span class="string">&quot;gray80&quot;</span>, <span class="string">&quot;gray10&quot;</span>))</span><br><span class="line">nbcol &lt;- 100</span><br><span class="line">color &lt;- jet.colors(nbcol)</span><br><span class="line">zfacet &lt;- z[-<span class="number">1</span>, -<span class="number">1</span>] + z[-<span class="number">1</span>, -ncz] + z[-nrz, -<span class="number">1</span>] + z[-nrz, -ncz]</span><br><span class="line">facetcol &lt;- cut(zfacet, nbcol)</span><br><span class="line"></span><br><span class="line">persp(x, y, z,</span><br><span class="line">  theta = <span class="number">30</span>, phi = <span class="number">30</span>,</span><br><span class="line">  expand = <span class="number">0.5</span>, col = color[facetcol]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>图片如下：</p>
<p><img src="20.png" alt="1"></p>
<p>在所有的可能的线性组合中（满足条件， <em>Φ<sub>11</sub><sup>2</sup></em> +  <em>Φ<sub>21</sub><sup>2</sup></em> = 1 ），只有上面的这种线性组合可以产生最高的方差（<strong>Var(Z<sub>1</sub>) 最大</strong>）。</p>
<p>这里 pop 和 ad 都是长度为100的向量，那么 Z<sub>1</sub> 也是一个长度为100的向量。例如，对于第 i 个样本，公式如下</p>
<p style=""><img src="https://math.now.sh?from=z_%7Bi%201%7D%3D0.839%20%5Ctimes%5Cleft%28%5Cmathrm%7Bpop%7D_%7Bi%7D-%5Coverline%7B%5Cmathrm%7Bpop%7D%7D%5Cright%29%2B0.544%20%5Ctimes%5Cleft(%5Cmathrm%7Bad%7D_%7Bi%7D-%5Coverline%7B%5Cmathrm%7Bad%7D%7D%5Cright)%0A" /></p><p>这些值 Z<sub>11</sub>, …… , Z<sub>n1</sub> 称为 <em>principal component scores</em> 。</p>
<p>我们对于 PCA 还有另外一种解释：第一主成分定义的直线是和数据<strong>越近越好</strong>。如下图的左图，数据与第一主成分的距离为直线距离，体现为黑色虚线，<strong>直线距离平方和最小的直线为第一主成分直线</strong>（这不就是最小二乘回归嘛）。右图为将左图向右下方旋转，旋转到第一主成分和横坐标方向一致。</p>
<p><img src="19.png" alt="1"></p>
<p>第二主成分 Z<sub>2</sub> 需要和 Z<sub>1</sub> <strong>无关</strong>，如图 6.14 所示（<strong>两条线垂直</strong>）。 第二主成分公式如下：</p>
<p style=""><img src="https://math.now.sh?from=Z_%7B2%7D%3D0.544%20%5Ctimes%28%5Cmathrm%7Bpop%7D-%5Coverline%7B%5Cmathrm%7Bpop%7D%7D%29-0.839%20%5Ctimes(%5Cmathrm%7Bad%7D-%5Coverline%7B%5Cmathrm%7Bad%7D%7D)%0A" /></p><p>因为这里我们只有两个预测因子，因此前两个主成分就包含了全部信息。但是，这里第一主成分包含了最多的信息。图 6.15 右图看出，<em>second principal component scores</em> 几乎为0，表示第二主成分几乎没有什么信息了。</p>
<p>下图为第一主成分与第二主成分与两个性状的相关。</p>
<p><img src="21.png" alt="1"></p>
<p><img src="22.png" alt="1"></p>
<h3 id="The-Principal-Components-Regression-Approach">The Principal Components Regression Approach</h3>
<p>主成分回归 (PCR) 包括创建前 M 个主成分 Z<sub>1</sub> , Z<sub>2</sub> …… Z<sub>M</sub> ，然后用这些主成分作为预测因子加入到回归模型中。这么做的基础是，我们认为<strong>少数的几个主成分，可以体现预测因子的大部分变异</strong>，最终体现在与反应变量的关系上。</p>
<p>下图显示了两次模拟数据中主成分回归中使用的主成分数量的影响。模拟数据中 n=50, p=45，左图中的模拟数据设置所有预测因子都有影响，右图中的模拟数据只有2个预测因子有作用。我们看主成分回归确实有作用。</p>
<p><img src="23.png" alt="1"></p>
<p>但是，同时比对 PCR，岭回归，lasso 三种方法。我们可以看到 PCR 方法相比于另外两种方法并没有优势。</p>
<p><img src="24.png" alt="1"></p>
<p>一般来说，仅在当只有<strong>少数几个</strong>主成分可以捕获自变量的绝大部分变异（同时可以捕获因变量的绝大部分变异）时，PCR 分析效果才比较好。比如图 6.19 的情况，前5个主成分的 bias 就降低至0，这种情况下 PCR 分析更加合适。</p>
<p>我们需要注意地是，虽然 PCR 降低了估计参数的数目，但是它不是<strong>feature selection method</strong> ，主成分回归分析还是用到了所有的 p 个自变量。因此，PCR 分析从原理上更接近于岭回归，而不是 lasso。</p>
<p>在实际的主成分回归分析中，M 的值通常通过 CV 获得。Credit 数据的PCR分析结果如下图，我们可以看到最佳的M = 10，这就相当于没有进行什么降维，因为 p=11。</p>
<p><img src="25.png" alt="1"></p>
<p>当我们进行 PCR 分析时，我们一般建议对预测因子进行 <em>standardizing</em></p>
<p style=""><img src="https://math.now.sh?from=%5Ctilde%7Bx%7D_%7Bi%20j%7D%3D%5Cfrac%7Bx_%7Bi%20j%7D%7D%7B%5Csqrt%7B%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28x_%7Bi%20j%7D-%5Cbar%7Bx%7D_%7Bj%7D%5Cright%29%5E%7B2%7D%7D%7D%0A" /></p><p>如果不进行标准化，那么 <em>high-variance</em> 的变量会在主成分分析中倾向于占据更重要的地位，会对最终的模型结果产生影响。但是，如果所有的变量均采用相同的单位，那么你也可能不选择进行标准化这一步。</p>
<h2 id="Partial-Least-Squares">Partial Least Squares</h2>
<p>PCR 分析中需要确认线性组合Z<sub>1</sub> , Z<sub>2</sub> …… Z<sub>M</sub>  ，来表示这些预测因子 。这个过程我们认为是 <em>unsupervised</em> ，因为这个过程因变量 Y 不会参与，或者说不会 <em>supervise</em> the identification of the principal components 。因此，PCR 分析有一个问题，<strong>可以很好地解释自变量变异的主成分不见得可以很好地预测因变量</strong>。</p>
<p>我们这里推出，<abbr title="Partial least squares regression, PLS">偏最小二乘回归</abbr> , 一种替代 PCR 分析的 监督方法。PLS 方法创建新变量的过程时会利用因变量 Y 的值。粗略地说，PLS 方法倾向于找到同时可以解释自变量和因变量的新变量。</p>
<p>PLS 首先将 p 个自变量和因变量进行标准化。然后PLS 的第一主成分的 <em>Φ<sub>j1</sub></em>  设置为 Y ~ X<sub>j</sub> 的简单线性回归的系数（公式如下）。因此，第一主成分的主要权重给了与因变量高度相关的变量。</p>
<p style=""><img src="https://math.now.sh?from=Z_%7B1%7D%3D%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cphi_%7Bj%201%7D%20X_%7Bj%7D%0A" /></p><p>下图显示了 p=2 的 PLS 与 PCR 的第一主成分的直线，绿色实线为 PLS 的第一主成分，虚线为 PCR 的第一主成分。PLS 的方向添加了 pop 的权重，降低了ad 的权重，表明 pop 与因变量的关系更强。</p>
<p><img src="26.png" alt="1"></p>
<p>PLS 在 <em>chemometrics</em> (化学计量学) 上很流行。实际上，PLS 的效果不见得比 岭回归或 PCR 方法更好。虽然 PLS 可以减少 bias ，但是它可能会增加 variance ，</p>
<h1>Considerations in High Dimensions</h1>
<h2 id="High-Dimensional-Data">High-Dimensional Data</h2>
<p><strong>大部分传统的统计方法都是适用于 <em>low_dimensional</em> 的情况，即 n &gt;&gt; p 。</strong> 因为以前的计算任务都是这种情况的，因此发展起来的统计方法也是仅适用于这种情况的。</p>
<p>在过去的20年中，新技术改变了数据收集的方式，因此 p 非常大的情况也就出现了，但是由于收集数据是有成本的，因此 n 一般是有限的。ISL 书中举了两个例子</p>
<ol>
<li>我们可能会通过50万个 SNP 来预测血压性状，这里 n ≈ 200，p ≈ 500,000</li>
<li>一个市场调研公司对客户的上网购物模式感兴趣，可能会把用户在搜索引擎上的所有搜索过的词汇当作特征 (features) 。对于某个特定用户，任何一个 <em>search term</em>  会被标记为 present (0)  和 absent (1) ，会创建一个非常大的二变量的 feature vector 。这里 n ≈ 1000，但是 p 非常大。</li>
</ol>
<p><em><strong>p&gt;n</strong></em> (或 p≈n )的数据集一般称为 <em>high-dimensional</em> 。传统方法并不适合用于分析这些数据，例如最小二乘线性回归，原因来自于 bias-variance trade-off 和 overfitting 。</p>
<h2 id="What-Goes-Wrong-in-High-Dimensions">What Goes Wrong in High Dimensions?</h2>
<p>这里我们用最小二乘回归举例。当 p  和 n 一样大时，最小二乘回归无法实现。理由很简单，无论因变量与自变量的真实关系如何，最小二乘法的结果都会<strong>完美拟合</strong>训练集，以至于残差均为0。</p>
<p>下图为 p=1 的两种情况，左边 n =20，右边 n=2，可以看到右边完美拟合了这两个点（无论这两个点是什么情况）。这就是 <strong>overfitting</strong> ，如果在 test data 里这个拟合结果就会很差。</p>
<p><img src="27.png" alt="1"></p>
<p>下图进一步说明了p很大时最小二乘分析的风险，其中 n = 20，  p 从 1-20 之间变化，所有的自变量均和因变量完全没有关系。如图，随着变量数目的增加，R<sup>2</sup> 逐渐趋于1，而 Training MSE 趋于0。由于所有的自变量都是噪音变量，随着自变量的提高， Test MSE 也是逐渐提高的。</p>
<p>如果分析人员很粗心，只看 training data 的情况，那么很容易得到包含所有变量的模型最好的结论。如果 p 很大，C<sub>p</sub> , AIC , BIC 方法也不合适，因为估计的残差方差是有问题的，这里就是0。校正R<sup>2</sup> 也有问题，由于 RSS 是0，校正R<sup>2</sup>  就会是1。</p>
<p><img src="28.png" alt="1"></p>
<h2 id="Regression-in-High-Dimensions">Regression in High Dimensions</h2>
<p>在 ISL 书中其实提到了很多应用于 p 很大 时的回归方法，例如 forward stepwise selection， 岭回归， lasso， 主成分回归。这些都可以用，都可以避免 overfitting 。</p>
<p>下图说明了 lasso 的表型。这里 p =20, 50, 2000 ，其中只有20个自变量是有效的， n=100 。然后通过一个无关的 test set 来评估效果。下面三个图，横坐标用的是自由度（系数个数，包括截距），不用 λ , 便于理解；纵坐标为 test MSE。</p>
<p>从下图我们可以得到三点：</p>
<ol>
<li>lasso 有作用</li>
<li>合适的λ值很重要</li>
<li>随着 p 的增加， test error 倾向于增加，除非新增的因子和反应变量真的有关系。</li>
</ol>
<p>第三点实际上是高维数据分析的一个重要的原则，称之为<abbr title="curse of dimensionality">维度陷阱</abbr> 。<strong>我们可能会本能地认为随着自变量数目的增加，模型拟合的效果会越好。</strong> 但是，比对下图地最左图与最右图结果，我们发现情况相反，p=2000的 test error 几乎是 p=20 的两倍。</p>
<p><img src="29.png" alt="1"></p>
<p>一般来说，<strong>新增 signal features 会增加模型拟合效果；但是新增 noise features 会降低模型拟合效果</strong>。因为新增 noise features 会增加维度，使得 overfitting 的风险剧增。</p>
<p>因此，可以收集成千上万 features 的新技术是一把双刃剑：如果这些 features 都和关心的问题有关，那么就可以改善模型；但是如果这些 features 是噪音变量，那么把这些 features 加入到模型中就可能带来负优化。</p>
<h2 id="Intercepting-Results-in-High-Dimensions">Intercepting Results in High Dimensions</h2>
<p>当我们对 high-dimensional setting 执行岭回归，lasso 等分析时，<strong>在解释结果时需要小心</strong>。在前面，我们提到了 <em>multicollinearity</em> ，意思是自变量之间的相关关系。在高维数据中， <em>multicollinearity</em> 的问题更加极端：所有的自变量都可以写成其他自变量的线性组合。这意味着，我们永远不知道哪些变量是真的与因变量有关，哪些仅仅是由于与signal features 相关导致与因变量相关。</p>
<p>例如，假设我们想要通过 50万个SNP来预测血压，forward stepwise selection 方法选择了 17个 SNP 加入到预测模型中。我们可能很容易错误地推断出这17个 SNP 预测血压地效果比其他 SNP 更有效。实际上，可能你可以选出很多个 17 SNPs sets，预测效果都和你选的模型一样。如果我们采用一个不同的 training data，我们可能会得到一个完全不同的 SNP 集合，这并不是说我们之前得到的模型是错的或无效的，事实上可能之前的模型非常有效，仅仅是我们不要过分解读我们获得的结果，要认识到我们仅仅是得到了 <em>one of many possible models</em> for predicting blood pressure , 而且需要后期更多数据的验证。</p>
<p>另外，在评价高维数据的模拟拟合效果的时候，需要注意之前的所有的训练集的统计量已经全部失效了。因此，很重要地是，我们需要采用 test set 的结果，或 cross-validation errors。</p>
<h1>R代码</h1>
<h2 id="Subset-Selection-Methods">Subset Selection Methods</h2>
<h3 id="Best-Subset-Selection-2">Best Subset Selection</h3>
<p>查看数据，清除缺失值</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; library(ISLR)</span><br><span class="line">Warning message:</span><br><span class="line">程辑包‘ISLR’是用R版本<span class="number">4.0</span>.5 来建造的 </span><br><span class="line">&gt; fix(Hitters)</span><br><span class="line">&gt; <span class="built_in">names</span>(Hitters)</span><br><span class="line"> [<span class="number">1</span>] <span class="string">&quot;AtBat&quot;</span>     <span class="string">&quot;Hits&quot;</span>      <span class="string">&quot;HmRun&quot;</span>     <span class="string">&quot;Runs&quot;</span>      <span class="string">&quot;RBI&quot;</span>       <span class="string">&quot;Walks&quot;</span>     <span class="string">&quot;Years&quot;</span>    </span><br><span class="line"> [<span class="number">8</span>] <span class="string">&quot;CAtBat&quot;</span>    <span class="string">&quot;CHits&quot;</span>     <span class="string">&quot;CHmRun&quot;</span>    <span class="string">&quot;CRuns&quot;</span>     <span class="string">&quot;CRBI&quot;</span>      <span class="string">&quot;CWalks&quot;</span>    <span class="string">&quot;League&quot;</span>   </span><br><span class="line">[<span class="number">15</span>] <span class="string">&quot;Division&quot;</span>  <span class="string">&quot;PutOuts&quot;</span>   <span class="string">&quot;Assists&quot;</span>   <span class="string">&quot;Errors&quot;</span>    <span class="string">&quot;Salary&quot;</span>    <span class="string">&quot;NewLeague&quot;</span></span><br><span class="line">&gt; <span class="built_in">dim</span>(Hitters)</span><br><span class="line">[<span class="number">1</span>] <span class="number">322</span>  <span class="number">20</span></span><br><span class="line">&gt; <span class="built_in">sum</span>(<span class="built_in">is.na</span>(Hitters$Salary))</span><br><span class="line">[<span class="number">1</span>] <span class="number">59</span></span><br><span class="line">&gt; Hitters = na.omit(Hitters)</span><br><span class="line">&gt; <span class="built_in">dim</span>(Hitters)</span><br><span class="line">[<span class="number">1</span>] <span class="number">263</span>  <span class="number">20</span></span><br><span class="line">&gt; <span class="built_in">sum</span>(<span class="built_in">is.na</span>(Hitters))</span><br><span class="line">[<span class="number">1</span>] <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>leaps 包 的 regsubsets() 函数可以执行 best subset selction，每个因子数目下，最好的模型通过 RSS 确定（regsubsets()  默认的最大因子数目为8，可以通过nvmax 设定）。最终结果可以通过 summary() 查看</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; library(leaps)</span><br><span class="line">Warning message:</span><br><span class="line">程辑包‘leaps’是用R版本<span class="number">4.0</span>.5 来建造的 </span><br><span class="line">&gt; regfit.full = regsubsets(Salary ~ ., Hitters)</span><br><span class="line">&gt; <span class="comment"># 默认最大8个因子</span></span><br><span class="line">&gt; summary(regfit.full)</span><br><span class="line">Subset selection object</span><br><span class="line">Call: regsubsets.formula(Salary ~ ., Hitters)</span><br><span class="line">19 Variables  (and intercept)</span><br><span class="line">           Forced <span class="keyword">in</span> Forced out</span><br><span class="line">AtBat          <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">Hits           <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">HmRun          <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">Runs           <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">RBI            <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">Walks          <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">Years          <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">CAtBat         <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">CHits          <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">CHmRun         <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">CRuns          <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">CRBI           <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">CWalks         <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">LeagueN        <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">DivisionW      <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">PutOuts        <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">Assists        <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">Errors         <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">NewLeagueN     <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">1 subsets of each size up to <span class="number">8</span></span><br><span class="line">Selection Algorithm: exhaustive</span><br><span class="line">         AtBat Hits HmRun Runs RBI Walks Years CAtBat CHits CHmRun CRuns CRBI CWalks</span><br><span class="line">1  ( <span class="number">1</span> ) <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>  <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>  <span class="string">&quot; &quot;</span> <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   </span><br><span class="line">2  ( <span class="number">1</span> ) <span class="string">&quot; &quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>  <span class="string">&quot; &quot;</span> <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   </span><br><span class="line">3  ( <span class="number">1</span> ) <span class="string">&quot; &quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>  <span class="string">&quot; &quot;</span> <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   </span><br><span class="line">4  ( <span class="number">1</span> ) <span class="string">&quot; &quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>  <span class="string">&quot; &quot;</span> <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   </span><br><span class="line">5  ( <span class="number">1</span> ) <span class="string">&quot;*&quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>  <span class="string">&quot; &quot;</span> <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   </span><br><span class="line">6  ( <span class="number">1</span> ) <span class="string">&quot;*&quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>  <span class="string">&quot; &quot;</span> <span class="string">&quot;*&quot;</span>   <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   </span><br><span class="line">7  ( <span class="number">1</span> ) <span class="string">&quot; &quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>  <span class="string">&quot; &quot;</span> <span class="string">&quot;*&quot;</span>   <span class="string">&quot; &quot;</span>   <span class="string">&quot;*&quot;</span>    <span class="string">&quot;*&quot;</span>   <span class="string">&quot;*&quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>  <span class="string">&quot; &quot;</span>   </span><br><span class="line">8  ( <span class="number">1</span> ) <span class="string">&quot;*&quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>  <span class="string">&quot; &quot;</span> <span class="string">&quot;*&quot;</span>   <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot;*&quot;</span>    <span class="string">&quot;*&quot;</span>   <span class="string">&quot; &quot;</span>  <span class="string">&quot;*&quot;</span>   </span><br><span class="line">         LeagueN DivisionW PutOuts Assists Errors NewLeagueN</span><br><span class="line">1  ( <span class="number">1</span> ) <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>       <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>       </span><br><span class="line">2  ( <span class="number">1</span> ) <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>       <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>       </span><br><span class="line">3  ( <span class="number">1</span> ) <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>       <span class="string">&quot;*&quot;</span>     <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>       </span><br><span class="line">4  ( <span class="number">1</span> ) <span class="string">&quot; &quot;</span>     <span class="string">&quot;*&quot;</span>       <span class="string">&quot;*&quot;</span>     <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>       </span><br><span class="line">5  ( <span class="number">1</span> ) <span class="string">&quot; &quot;</span>     <span class="string">&quot;*&quot;</span>       <span class="string">&quot;*&quot;</span>     <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>       </span><br><span class="line">6  ( <span class="number">1</span> ) <span class="string">&quot; &quot;</span>     <span class="string">&quot;*&quot;</span>       <span class="string">&quot;*&quot;</span>     <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>       </span><br><span class="line">7  ( <span class="number">1</span> ) <span class="string">&quot; &quot;</span>     <span class="string">&quot;*&quot;</span>       <span class="string">&quot;*&quot;</span>     <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>       </span><br><span class="line">8  ( <span class="number">1</span> ) <span class="string">&quot; &quot;</span>     <span class="string">&quot;*&quot;</span>       <span class="string">&quot;*&quot;</span>     <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>       </span><br><span class="line">&gt; <span class="comment"># 给定最大因子数</span></span><br><span class="line">&gt; regfit.full = regsubsets(Salary ~., data=Hitters, nvmax=<span class="number">19</span>)</span><br><span class="line">&gt; reg.summary = summary(regfit.full)</span><br></pre></td></tr></table></figure>
<p>summary() 也可以返回 R<sup>2</sup>  ,  校正R<sup>2</sup>  ，C<sub>p</sub> 等结果，我们可以根据这些统计量挑选最终的模型。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">names</span>(reg.summary)</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;which&quot;</span>  <span class="string">&quot;rsq&quot;</span>    <span class="string">&quot;rss&quot;</span>    <span class="string">&quot;adjr2&quot;</span>  <span class="string">&quot;cp&quot;</span>     <span class="string">&quot;bic&quot;</span>    <span class="string">&quot;outmat&quot;</span> <span class="string">&quot;obj&quot;</span>   </span><br><span class="line">&gt; <span class="comment">#查看 R2 结果</span></span><br><span class="line">&gt; <span class="comment">#可以看到随着因子数量增加，R2无脑增加</span></span><br><span class="line">&gt; reg.summary$rsq</span><br><span class="line"> [<span class="number">1</span>] <span class="number">0.3214501</span> <span class="number">0.4252237</span> <span class="number">0.4514294</span> <span class="number">0.4754067</span> <span class="number">0.4908036</span> <span class="number">0.5087146</span> <span class="number">0.5141227</span> <span class="number">0.5285569</span> <span class="number">0.5346124</span> <span class="number">0.5404950</span> <span class="number">0.5426153</span> <span class="number">0.5436302</span></span><br><span class="line">[<span class="number">13</span>] <span class="number">0.5444570</span> <span class="number">0.5452164</span> <span class="number">0.5454692</span> <span class="number">0.5457656</span> <span class="number">0.5459518</span> <span class="number">0.5460945</span> <span class="number">0.5461159</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将所有统计量画在一张图上</span></span><br><span class="line">par(mfrow=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">plot(<span class="number">1</span>:<span class="number">19</span>,reg.summary$rss, xlab = <span class="string">&quot;NUmber of Variables&quot;</span>,ylab = <span class="string">&quot;RSS&quot;</span>, type = <span class="string">&quot;l&quot;</span>)</span><br><span class="line">plot(<span class="number">1</span>:<span class="number">19</span>,reg.summary$adjr2, xlab = <span class="string">&quot;NUmber of Variables&quot;</span>,ylab = <span class="string">&quot;Adjusted RSq&quot;</span>, type = <span class="string">&quot;l&quot;</span>)</span><br><span class="line">which.max(reg.summary$adjr2)</span><br><span class="line">points(<span class="number">11</span>,reg.summary$adjr2[<span class="number">11</span>], col=<span class="string">&quot;red&quot;</span>, cex=<span class="number">2</span>,pch=<span class="number">20</span>)</span><br><span class="line">plot(<span class="number">1</span>:<span class="number">19</span>,reg.summary$cp, xlab = <span class="string">&quot;NUmber of Variables&quot;</span>,ylab = <span class="string">&quot;Cp&quot;</span>, type = <span class="string">&quot;l&quot;</span>)</span><br><span class="line">points(which.min(reg.summary$cp), reg.summary$cp[which.min(reg.summary$cp)], col=<span class="string">&quot;red&quot;</span>, cex=<span class="number">2</span>, pch=<span class="number">20</span>)</span><br><span class="line">plot(<span class="number">1</span>:<span class="number">19</span>,reg.summary$bic, xlab = <span class="string">&quot;NUmber of Variables&quot;</span>,ylab = <span class="string">&quot;BIC&quot;</span>, type = <span class="string">&quot;l&quot;</span>)</span><br><span class="line">points(which.min(reg.summary$bic), reg.summary$bic[which.min(reg.summary$bic)], col=<span class="string">&quot;red&quot;</span>, cex=<span class="number">2</span>, pch=<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p>手动画图结果如下：</p>
<p><img src="30.png" alt="1"></p>
<p>regsubsets() 函数本身有一个内建函数 plot() ，也可以画图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># regsubsets() 内建函数</span><br><span class="line">plot(regfit.full, scale&#x3D;&quot;r2&quot;)</span><br><span class="line">plot(regfit.full, scale&#x3D;&quot;adjr2&quot;)</span><br><span class="line">plot(regfit.full, scale&#x3D;&quot;Cp&quot;)</span><br><span class="line">plot(regfit.full, scale&#x3D;&quot;bic&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是画出的图看不懂</p>
<p><img src="31.png" alt="1"></p>
<h3 id="Forward-and-Backward-Stepwise-Selection">Forward and Backward Stepwise Selection</h3>
<p>我们也可以用 regsubsets() 执行这两种算法，只要新增一个参数 method</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 向前/后</span></span><br><span class="line">regfit.fwd = regsubsets(Salary~., data=Hitters, nvmax=<span class="number">19</span>, method=<span class="string">&#x27;forward&#x27;</span>)</span><br><span class="line">summary(regfit.fwd)</span><br><span class="line">regfit.bwd = regsubsets(Salary~., data=Hitters, nvmax=<span class="number">19</span>, method=<span class="string">&#x27;backward&#x27;</span>)</span><br><span class="line">summary(regfit.bwd)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Choosing-Among-Models-Using-the-Validation-Set-Approach-and-Cross-Validation">Choosing Among Models Using the Validation Set Approach and Cross-Validation</h3>
<p>上面是通过 C<sub>p</sub> , BIC, adjusted R<sup>2</sup> 这三个统计量来选择模型，这里是用验证集或交叉验证来实现。</p>
<p>这两种方法的思路都是，<strong>先找到最佳因子数目</strong>，然后用全部数据和 best subset 方法，找最佳因子数目下的模型。</p>
<p>为了适用验证集检验的方式，我们首先要把总数据拆分成训练集和验证集。首先根据训练集找到每个因子数量下的最好模型，再用不同因子数量的模型预测 test data， 计算 test MSE，找 test MSE 最小的因子数量。<strong>最后需要用全部数据使用 best subset 重新估计最佳因子数目的模型</strong>，因为用的数据越多，估计的参数越准，前面训练集估计参数只用了一部分数据（有可能最后一次找到的因子和前面训练集的因子不一样）。</p>
<p>10倍交叉验证的方法：首先随机分成10分，每一次随机挑出一份作为验证集，另外九份作为训练集。每一次计算出所有因子水平的 test MSE，最终结果是一个 10×19 的矩阵，其中元素 (i, j) 是第i 个 fold 的 j 个因子水平下最好模型的 test MSE。计算每一列的均值，查找最小值，即为最好的因子数目。最后需要用全部数据使用 best subset 重新估计最佳因子数目的模型，比如这里交叉验证得到的最佳因子数目为 11， 然后得到最终模型的代码如下：</p>
<p><img src="32.png" alt="1"></p>
<h2 id="Ridge-Regression-and-the-Lasso">Ridge Regression and the Lasso</h2>
<p>这里我们用 glmnet 包来实现岭回归和 lasso 算法。</p>
<p>model.matrix() 创建因子矩阵特别好用，会自动将分类变量转化为哑变量。glmnet() 只接受哑变量和连续变量。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成因子与因变量</span></span><br><span class="line"></span><br><span class="line">x = model.matrix(Salary~., Hitters)[,-<span class="number">1</span>]</span><br><span class="line">y = Hitters$Salary</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Ridge-Regression-2">Ridge Regression</h3>
<p>glmnet() 有一个 alpha 参数可以指定模型，如果 alpha=0 ，那么就是岭回归；如果 alpha=1，那么就是 lasso。</p>
<p>我们先看岭回归</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 岭回归</span></span><br><span class="line">library(glmnet)</span><br><span class="line">grid = <span class="number">10</span>^seq(<span class="number">10</span>,-<span class="number">2</span>,<span class="built_in">length</span>=<span class="number">100</span>)</span><br><span class="line">ridge.mod = glmnet(x,y,alpha=<span class="number">0</span>,lambda=grid)</span><br></pre></td></tr></table></figure>
<p>glmnet() 函数一般会指定选择 λ 值的范围。这里是想指定λ的范围为 10<sup>10</sup> 到 10<sup>-2</sup> ，覆盖了从只包含截距到普通的最小二乘回归的所有范围。glmnet() 默认会对所有变量进行标准化，如果想要关闭这一点，可以使用 standardize=FALSE 。</p>
<p>每一个λ值都会有相应的岭回归系数，可以通过coef() 查看，这里是20×100的矩阵，20 是因子数（包括截距），100 是 λ 值的数目。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">dim</span>(coef(ridge.mod))</span><br><span class="line">[<span class="number">1</span>]  <span class="number">20</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>查看某一个λ值的结果</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; ridge.mod$lambda[<span class="number">50</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">11497.57</span></span><br><span class="line">&gt; coef(ridge.mod)[,<span class="number">50</span>]</span><br><span class="line">  (Intercept)         AtBat          Hits         HmRun          Runs           RBI </span><br><span class="line">407.356050200   <span class="number">0.036957182</span>   <span class="number">0.138180344</span>   <span class="number">0.524629976</span>   <span class="number">0.230701523</span>   <span class="number">0.239841459</span> </span><br><span class="line">        Walks         Years        CAtBat         CHits        CHmRun         CRuns </span><br><span class="line">  <span class="number">0.289618741</span>   <span class="number">1.107702929</span>   <span class="number">0.003131815</span>   <span class="number">0.011653637</span>   <span class="number">0.087545670</span>   <span class="number">0.023379882</span> </span><br><span class="line">         CRBI        CWalks       LeagueN     DivisionW       PutOuts       Assists </span><br><span class="line">  <span class="number">0.024138320</span>   <span class="number">0.025015421</span>   <span class="number">0.085028114</span>  -<span class="number">6.215440973</span>   <span class="number">0.016482577</span>   <span class="number">0.002612988</span> </span><br><span class="line">       Errors    NewLeagueN </span><br><span class="line"> -<span class="number">0.020502690</span>   <span class="number">0.301433531</span> </span><br><span class="line">&gt; <span class="comment">#计算岭回归的惩罚项</span></span><br><span class="line">&gt; <span class="built_in">sqrt</span>(<span class="built_in">sum</span>(coef(ridge.mod)[-<span class="number">1</span>,<span class="number">50</span>]^<span class="number">2</span>))</span><br><span class="line">[<span class="number">1</span>] <span class="number">6.360612</span></span><br></pre></td></tr></table></figure>
<p>我们可以用交叉验证的方式来选择 λ 值，我们可以用 cv.glmnet() 函数，这个函数默认采取十倍的交叉验证，可以通过 nfolds 参数修改。这里我们通过 set.seed() 函数使我们的结果可重复，因为 CV 中参验群体的划分是随机的。通过交叉验证找到了最佳的的 λ 值后，我们需要使用全部数据，使用最佳的λ值来估计模型系数。</p>
<p>代码略</p>
<h3 id="The-Lasso-2">The Lasso</h3>
<p>lassso 算法，只要改成 alpha = 1 即可。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>重复抽样方法</title>
    <url>/posts/c54c0f20/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>ISL 真是好书！</p>
<span id="more"></span> 
<h1>资料</h1>
<p><a href="https://www.statlearning.com/">An Introduction to Statistical Learning</a>，下文简称 <strong>ISL</strong></p>
<h1>概述</h1>
<p>重复抽样方法 (<em>Resampling methods</em>) 是统计中的一个常用工具。通过对一个训练集不断地提取子集，然后用同一个模型进行拟合，来获取这个模型的更多的信息，比如 <em>variance</em> 。</p>
<p>重复抽样方法最常用的是 <strong>交叉验证</strong>(<em>cross-validation</em>) 和 <strong>自助法</strong>(<em>bootstrap</em>) 。这两种方法都很重要，比如交叉验证方法可以用来估计模型的 <em>test error</em> ，从而用来评价模型/方法的表现。这种评估模型表现的过程称为 <em>model assessment</em> ，而选择一个模型的自由度（<em>level of flexibility</em>）称为 <em>model selection</em> 。自助法一般用于评估参数估计的准确性。</p>
<h1>交叉验证</h1>
<p>在 ISL 前面的章节里提过了 <em>test error rate</em> 和 <em>trainging error rate</em> 。一般我们评价模型的好坏会用 <em>test error rate</em> ，但是这就要求除了有<em>training data set</em> 外，还需要有 <em>test data set</em> 。但是实际情况里，我们可能会没有一个比较大的 <em>test data</em> 来估计 <em>test error rate</em> ，也就是说我们只有一个群体的数据。通过交叉验证方法，我们可以人为的从训练集中提取一个子集来计算 <em>test error rate</em> 。</p>
<h2 id="The-Validation-Set-Approach">The Validation Set Approach</h2>
<p>这个方法的思路就是将所有观测值分为两部分，训练集和验证集。训练集用于拟合模拟，然后将得到的模型用于验证集，计算 <em>test error rate</em> ，数量性状一般就是计算 <strong>均方误差(MSE)</strong>。</p>
<p>在 ISL 的书中提到了一个例子，在 Auto 数据集中，mpg 和 horsepower 之间存在非线性关系，然后用 horsepower 和 horsepower<sup>2</sup> 的模型效果更好。<strong>我们很容易想到如果继续添加立方项或者更多的项，效果会不会更好？</strong> 这在前面的例子中是通过查看立方项和更高的项的 P 值来确定的，但是我们也可以用交叉验证来回答。我们可以随机将 392 个观测值随机分为两个集合，一半作为训练集，一半作为验证集；对于相同的训练集，采用不同的模型进行拟合，然后用于同样的验证集计算MSE。效果如下，左边为一次结果，右边为重复十次结果。十次重复结果各不相同，均方误差最小值的项均不相同，我们只能说简单线性回归不是最优解，然后高于2项的回归即便有提升，提升幅度一般也比较小。</p>
<p><img src="1.png" alt="1"></p>
<p><strong>The validation set approach</strong> 这种方法思路非常简单，易于使用，但是又两个潜在的缺点：</p>
<ol>
<li>就像上面右图的结果，多次抽样的结果差异较大，取决于你把哪些个体放在训练集，把哪些个体放在验证集。</li>
<li>这个方法，仅仅只使用了一部分个体（划定为训练集的个体）用于拟合模型。一般来说，样本量越少，样本拟合效果越差，因此这里计算得到的 test error rate 比实际情况要高。</li>
</ol>
<h2 id="Leave-One-Out-Cross-Validation">Leave-One-Out Cross-Validation</h2>
<p><em>Leave-One-Out Cross-Validation</em> (LOOCV) 接近于上面的 <em>validation set approach</em> ，但是这种方法尝试来弥补上面这种方法的缺点。</p>
<p>LOOCV 也是把观测值分为两个群体，但区别在于它只将一个个体划定给验证集，将其他的 n-1 个个体划定给训练集，用于拟合模型，然后预测留出来的一个个体的，计算MSE。由于只有一个个体, MSE 的公式变为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BMSE%7D_%7B1%7D%3D%5Cleft%28y_%7B1%7D-%5Chat%7By%7D_%7B1%7D%5Cright%29%5E%7B2%7D%0A" /></p><p>虽然MSE<sub>1</sub> 是无偏的，但是它是一个很糟糕的估计值，因为变异太大。</p>
<p>我们可以重复这个过程，让所有个体都做一次验证个体，也就是总共重复n次。图示如下：</p>
<p><img src="2.png" alt="1"></p>
<p>然后我们计算这n次的平均MSE</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BCV%7D_%7B%28n%29%7D%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Cmathrm%7BMSE%7D_%7Bi%7D%0A" /></p><p>LOOCV 方法相比于上面的 validation set 方法又很多优势。首先，LOOCV 方法有更小的 bias，因为 LOOCV 方法用了接近所有个体来拟合模型，而 validation set 只用了一半。因此，LOOCV 方法不会高估 <em>test error rate</em> 。其次，validation set 随机划分群体使得多次重复结果的差异较大，而多次重复 LOOCV 也只会产生一个相同的结果，LOOCV 方法根本没有训练集和验证集划分的随意性问题。</p>
<p>我们对 Auto 数据集采用 LOOCV 方法进行计算，结果如下图左图（右图为9次单独的 10-fold CV结果，每次均随机地将群体分成10份。从这里可以看出 10-fold CV 多次结果之间的差异较小）</p>
<p><img src="3.png" alt="1"></p>
<p>LOOCV 的计算量比较大，毕竟需要计算 n 次。如果 n 比较大，那么 可能会非常耗时。<strong>在最小二乘的线性回归或二项式回归分析中</strong>，存在一个简化可以使得 LOOCV 的计算量与单次模型拟合差不多，公式如下。这个式子看上去类似于普通的 MSE 的计算公式，除了分母部分增加了 一个 (1-h<sub>i</sub>)</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BCV%7D_%7B%28n%29%7D%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(%5Cfrac%7By_%7Bi%7D-%5Chat%7By%7D_%7Bi%7D%7D%7B1-h_%7Bi%7D%7D%5Cright)%5E%7B2%7D%0A" /></p><p>这里预测值 y_hat 是采用原始的最小二乘拟合的结果， <em>h<sub>i</sub></em>  是 leverage ，值在1/n 与 1 之间，表示一个观测值对模型拟合的影响程度。因此，对于 high-leverage 的点，1-  <em>h<sub>i</sub></em>  越低，这里相当于放大了残差。</p>
<p style=""><img src="https://math.now.sh?from=h_%7Bi%7D%3D%5Cfrac%7B1%7D%7Bn%7D%2B%5Cfrac%7B%5Cleft%28x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright%29%5E%7B2%7D%7D%7B%5Csum_%7Bi%5E%7B%5Cprime%7D%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%5E%7B%5Cprime%7D%7D-%5Cbar%7Bx%7D%5Cright)%5E%7B2%7D%7D%0A" /></p><p>LOOCV 是一个一般方法，可以用于各种各样的模型，比如用于逻辑回归或LDA分析。</p>
<h2 id="k-fold-Cross-Validation">k-fold Cross-Validation</h2>
<p>LOOCV 方法的一个备选方法是 k-fold CV 方法。这种方法将所有个体随机分成相同大小的 k groups ，或者说是 k folds。将第一个 fold 视为验证集，然后用其他folds拟合模型，计算得到 MSE<sub>1</sub>。这个过程重复 k 次，每次均拿出一个fold 视为验证集，其他视为训练集，得到多个 MSE。</p>
<p>然后通过下面这个式子计算平均MSE</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BCV%7D_%7B%28k%29%7D%3D%5Cfrac%7B1%7D%7Bk%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bk%7D%20%5Cmathrm%7BMSE%7D_%7Bi%7D%0A" /></p><p>下图便反映了这个过程</p>
<p><img src="4.png" alt="1"></p>
<p>我们很容易看到，LOOCV 方法是 k-fold CV 方法的一个特例，即 k = n。在实际中，一般k会设为5或10，那么k设为5/10 相比于 设为n 的优势在哪里呢？首先最明显的就是<strong>计算量</strong>，因为 LOOCV 需要拟合模型 n 次（通过最小二乘法估计的线性模型除外），而 k-fold CV 只需要拟合 5次或10次。</p>
<p>但我们使用真实数据时，由于我们不知道真实的 test MSE ，因此我们很难决定CV估计的准确性。但是，如果我们使用模拟数据，我们计算得到真实的 test MSE，因此可以评价CV结果。下图中，我们画出了CV得到的 test error rate 估计值 和 真实的 test error rate，这里蓝线是真实值，黑色虚线是LOOCV估计值，红色线是 10-fold CV 估计值。我们可以看到 10-fold CV 和 LOOCV 结果差不多。</p>
<p><img src="5.png" alt="1"></p>
<p>但我执行交叉验证时，我们的目的可能是看一个统计模型应用在一个与训练集独立的数据中的效果，也就是说， 我们感兴趣地是 test MSE 的 估计值。但是有时候，我们仅仅是对 <em>estimated test MSE</em> 曲线的最小值，比如比较一系列统计方法/模型的优劣，一种模型但是使用不同水平的 <em>flexibility</em> 的比较，为了得到最佳的模型，或者最佳的 <em>flexibility</em> 。这种情况下，test MSE 的最小值的位置是最重要的，但是实际test MSE的大小不重要。根据上面的图(5.6)，我们可以看到 CV 的MSE估计值可能是低估的，但是通过CV曲线来查找最佳的 <em>flexibility</em> 水平基本和真实情况差不多。</p>
<h2 id="Bias-Variance-Trade-Off-for-k-fold-CV">Bias-Variance Trade-Off for k-fold CV</h2>
<p>前面起到 k-fold CV 相比于 LOOCV 的优点是减少计算量，其实 k-fold CV 相比于 LOOCV 还有一个优点，就是 <strong><em>test error rate</em> 估计更准确</strong>。这和 bias-variance trade-off 有关。</p>
<p>前面提到过 validation set 方法估计得到的 test error rate 会比真实值高，因为只用了一半数据来拟合模型。通过这个逻辑，LOOCV 方法会给出一个接近无偏的 test error ，因为几乎用了全部的数据来拟合模型。然后 k-fold CV 方法的 bias 会介于这二者之间。</p>
<p>但是我们知道，bias 并不是我们关心的估计过程的唯一指标，我们还关心 variance ，结果表明 LOOCV 比 k-fold CV 有更高的 variance 。为什么是这样呢？当我们执行 LOOCV 方法时，我们拟合的n个模型，几乎都是使用相同的数据；因此，这些模型的拟合结果之间具有高度的相关性。但是当我们执行 k-fold CV 时，k 个拟合的模型之间相关较弱，因为训练集数据之间的重合程度较小。因为很多高度相关的数量性状的均值比相关程度较低的数量性状均值的 variance 更小，因此 LOOCV 方法得到的 test error 估计值通常比 k-fold CV 方法有更高的 variance。</p>
<p>总结一下，综合考虑 bias 和 variance ，我们容易得到 k=5 或 k=10 的 k-fold CV 得到的 test error estimates 最佳，既不会有很高的 bias ，也不会有很高的 variance。</p>
<h2 id="Cross-Validation-on-Classification-problems">Cross-Validation on Classification problems</h2>
<p>上面提高的交叉验证的使用均是基于<strong>数量性状</strong>，因此都是用 MSE 来衡量 test error 。但是交叉验证同样可以用于质量性状的分析上，其实大同小异，只是用 test error rate 替换 MSE 来衡量 test error。例如， LOOCV 的公式如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BCV%7D_%7B%28n%29%7D%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Cmathrm%7BErr%7D_%7Bi%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BErr%7D_%7Bi%7D%3DI%5Cleft%28y_%7Bi%7D%20%5Cneq%20%5Chat%7By%7D_%7Bi%7D%5Cright%29%0A" /></p><p>下图为一个模拟数据的逻辑回归结果，p=2，通过多项式回归不断增加自由度。</p>
<p><img src="6.png" alt="1"></p>
<p>但是在真实的数据中，真实的决策线和 test error rate 均是未知的。因此我们需要决定上面的四种逻辑回归哪一种比较好。我们可以通过交叉验证来实现这一点。下图的左图显示了十倍交叉验证的结果（黑线），真实的 test error 是棕线，十倍交叉验证的结果很好的预测了真实结果（略低估了真实结果）。右图显示了KNN的结果，我们可以随着 flexibility 的增加，traing error rate 迅速下降，而 test error rate 呈U字型变化，这再次说明了不能用 training error rate 来说明模型的好坏。</p>
<p><img src="7.png" alt="1"></p>
<h1>自助法</h1>
<p>自助法可以衡量一个给定估计值或方法的不确定性。作为一个简单的例子，自助法可以用来估计线性回归拟合参数的标准误，这并不是很实用，因为R在做回归分析的时候会自动给出标准误。但是像一些复杂的统计方法，或者软件不能自动给出的不确定性，自助法就有用了。</p>
<p>如果我们使用模拟数据，计算一个参数估计的标准误，可以直接通过多次抽样直接计算多次参数估计的标准差即可。但是实际情况里，我们没法这么做，自助法则是通过一个数据集，生成多个数据集（比如1000个），然后计算所有生成的数据集中估计参数的标准差，做为估计参数标准误的估计值。</p>
<p>生成数据集的过程如下，加入原始数据是3条数据，生成的数据集也都是3条数据，生成的数据集的每条数据都是<strong>可重复地</strong>从原始数据集中进行随机抽样的结果。</p>
<p><img src="8.png" alt="1"></p>
<p>自助法效果如下，左图为多次创建数据集的结果，中图为使用一个数据集采用自助法的结果，右图为二者比较，我们可以看到自助法与真实结果很接近。</p>
<p><img src="9.png" alt="1"></p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑回归及其他分类变量分析方法</title>
    <url>/posts/749a327e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>ISL 真是好书！</p>
<span id="more"></span> 
<h1>资料</h1>
<p><a href="https://www.statlearning.com/">An Introduction to Statistical Learning</a>，下文简称 <strong>ISL</strong></p>
<h1>概述</h1>
<p><strong>线性回归的因变量都是连续变量</strong>（例如人的身高），但是生活中我们也有很多因变量是分类变量的情况。比如：</p>
<ol>
<li>一位来到急诊室的病人，具有很多的临床症状，这些症状可能是由三种疾病导致的，那么到底这个病人是患上了什么疾病呢？</li>
<li>邮箱区分哪些邮件是垃圾邮件，哪些邮件不是垃圾邮件</li>
<li>全基因组关联分析：确定哪些基因突变与疾病有关联</li>
</ol>
<p>在 ISL 书中，分析的例子是基于一个人的年收入和每月信用卡余额来预测这个人是否会拖欠信用卡付款。数据如下图所示</p>
<p><img src="1.png" alt="1"></p>
<h1>为什么不用线性回归？</h1>
<p>假设我们想要基于一个急诊室的病人的症状来预测他/她患了什么病。在这个简化的例子中，假设我们有三个可能的疾病：stroke, drug overdose, epileptic seizure 。 我们可以将这些重编码为数字，如下：</p>
<p><img src="2.png" alt="1"></p>
<p>如果这里我们用最小二乘的方式来预测 Y，并且我们认为这三者之间的差异是相同的。<strong>实际上我们这么重编码数字是没有道理的</strong>。比如，有些人还可能用另外一种编码方式：</p>
<p><img src="3.png" alt="1"></p>
<p><strong>如果换了一种重编码方式，那么这三者之间的关系就完全变了。</strong></p>
<p>如果反应变量的值是有序的，例如 <em>mild</em>, <em>moderate</em>, <em>severe</em> ，这样我们把这几个变量编码为1,2,3 还有一点道理。但是这么做还不是一种自然的方式。</p>
<p>对于一个<strong>二变量</strong>的分类性状，情况就好一点。比如如果病人的病症只有两种情况：stroke 和 drug overdose 。 我们可以将这两个变量转换为哑变量。</p>
<p><img src="4.png" alt="1"></p>
<p>我们可以对这个二变量进行线性回归，如果预测值大于0.5， 我们认为是 drug overdose；反之我们认为 stroke 。在这种情况，<strong>即使颠倒了重编码方法，预测结果还是一样的</strong>。这种情况下，线性回归是有意义的，我们得到的预测值可以理解为 <em>drug overdose</em> 的<strong>可能性</strong>，但是<strong>线性回归的预测值可能会超出 [0,1] 区间</strong>，使得这个结果难以解释。</p>
<h1>衡量分类变量模型的准确性</h1>
<p><em><strong>training error rate</strong></em> :  公式如下，其中 <code>I()</code> 为哑变量，如果预测值和真实值不同则为1，相同则为0。这个式子其实就是计算 traing data 有多少比例的预测值预测错了。</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20I%5Cleft%28y_%7Bi%7D%20%5Cneq%20%5Chat%7By%7D_%7Bi%7D%5Cright%29%0A" /></p><p>但是，实际上我们更关心的是 <em>test data</em> 的结果，同样的我们计算 <em><strong>test error rate</strong></em> 。一个好的模型，我们得到的  <em><strong>test error rate</strong></em> 应该是很低的。</p>
<h1>逻辑回归</h1>
<p>逻辑回归（logistic 回归）采用的因变量是<strong>某一个水平的概率</strong>。</p>
<p>线性回归与逻辑回归比对的结果如下：</p>
<p><img src="5.png" alt="1"></p>
<p>对于 ISL 的 Default 数据集（信用卡是否违约）， 逻辑回归会预测违约的概率。例如，基于 balance 因子的预测可以写成</p>
<p><img src="6.png" alt="1"></p>
<p>简写为 p(balance)，如果这个值大于0.5，我们可能预测会违约（这个阈值也可以调整）。</p>
<h2 id="逻辑回归模型">逻辑回归模型</h2>
<p>常规的线性模型如下：</p>
<p><img src="7.png" alt="1"></p>
<p>线性模型的问题在于预测值会超出[0,1]区间，这是不合理的。为了避免预测值超出[0,1]区间，我们设定逻辑回归的预测函数为：</p>
<p><img src="8.png" alt="1"></p>
<p>个人理解：β0+β1X 就是原来的线性模型的预测函数，范围是负无穷到正无穷。因此，e<sup>β0+β1X</sup> 的范围就是 (0,+∞] 。整个 p(X) 在这个范围内是递增函数（由求导得到，易知导数永远大于0），整个p(x) 的两个极值在自变量的两个端点取得，范围为 (0,1)</p>
<p>为了求解这个预测函数，我们需要用到<strong>最大似然法</strong>。</p>
<p>对上面的函数进行变换，我们得到下面这个式子。这个式子 p(x)/[1-p(x)] 称为 <em>odds</em> ，这个式子的值的范围为 (0, ∞)</p>
<p><img src="9.png" alt="1"></p>
<p>如果我们对左右两边取对数，我们可以得到下面这个式子：下式中左侧称之为 <em>log-odds</em> 或者 <em>logit</em> 。我们可以看到 <em>logit</em> 是符合线性模型的。</p>
<p><img src="10.png" alt="1"></p>
<p>我们这里估计得到的 β1 的值虽然和 p(x) 不是线性相关，但是<strong>如果β1 是正数，说明增加 X 的值，会提高 p(x)</strong>。</p>
<h2 id="估计回归系数">估计回归系数</h2>
<p>逻辑回归中的 β0 和 β1 是未知的，必须通过已有的 training data 来进行估计。在线性模型中，我们采用最小二乘法来估计线性回归的系数。虽然这里我们也可以用最小二乘来拟合模型，当我们偏向采用更一般的方式 - <strong>最大似然法</strong>。最大似然法用于拟合逻辑回归的基本思路是：<strong>我们想寻找一组 β0 β1 的值，使得每个个体p(x) 的预测值和观测值尽可能的接近</strong>。在这个例子中，也就是对于存在违约的个体的预测值要接近1，对于不存在违约的个体的预测值要接近于0。</p>
<p>我们可以把上面这个思路用一个 <abbr title="likelihood function">似然函数</abbr> 来表示，如下图所示：</p>
<p><img src="11.png" alt="1"></p>
<p>使得这个似然函数<strong>最大</strong>的一组 β0 和 β1 的值就是我们选中的估计值。</p>
<p>在ISL书中，最大似然法是一种估计<strong>非线性模型</strong>参数的一种普遍的方法。<strong>在线性模型中，最小二乘法实际是最大似然法的一个特例</strong>（理由呢？）。</p>
<p>回到信用卡的例子，如果我们采用逻辑回归，结果如下图。我们可以看到 β1 的估计值为正数，说明 随着 balance 的增加，违约的概率在增加。</p>
<p><img src="12.png" alt="1"></p>
<h2 id="预测">预测</h2>
<p>一旦我们得到了系数的估计值，我们就可以带入逻辑回归的公式进行预测。例如，加入我们要预测 balance 为 1000 时的违约概率：</p>
<p><img src="13.png" alt="1"></p>
<p>如果自变量是分类变量也是可以的，不过需要先转变为<strong>哑变量</strong>。比如下面是“是否是学生” 的分析结果，我们可以看到学生违约的风险高于非学生群体。</p>
<p><img src="16.png" alt=""></p>
<p>预测值如下</p>
<p><img src="17.png" alt="1"></p>
<h2 id="多重逻辑回归">多重逻辑回归</h2>
<p>如果我们多个自变量，我们可以将逻辑函数扩展如下：</p>
<p><img src="14.png" alt="1"></p>
<p><img src="15.png" alt="1"></p>
<p>之后我们还是采用最大似然法来估计这些系数。</p>
<p>比如，我们用三个自变量去预测信用卡违约，结果如下，我们可以看到 balance 和 student[Yes] 的 P 值都很小，说明这这两个自变量都是显著的。但是<strong>stdent[Yes] 的系数是负数</strong>，说明学生违约的概率更小，这和上面的简单逻辑回归的结论相反。</p>
<p><img src="18.png" alt="1"></p>
<p>下图就说明了这个矛盾的结论：左图说明了，如果固定了 Balance 因子，既在相同的 Balance 水平下，学生的违约风险更低；右图中是不管Balance 和 income 水平，计算所有的学生和非学生的结果，可以看到学生的违约风险更高。这对于信用卡发放的决策者而言这是一个重要的区别，<strong>如果不知道balance信息，学生的违约风险比非学生更高； 但是如果在相同的balance水平下，学生比非学术的违约风险要低。</strong></p>
<p><img src="19.png" alt="1"></p>
<p>发生这种矛盾的原因还是<strong>自变量之间的相关</strong>，这种现象称之为 <em>confounding</em> 。是否是学生 与  balance 绝对是存在相关关系的，或者说学生的balance 的 分布 和 非学生的 balance 分布是不一样的。</p>
<p>我这里可以通过画图来看一下，代码和图片结果如下。我们可以看到学生和非学生的 balance 的分布基本还是类似于正态分布，但是学生的均值更高，而且右侧的尾巴更肥。我们可以通过这个图简单地总结一下，就是学生群体balance的值倾向于比非学生群体更高。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(ggplot2)</span><br><span class="line">ggplot(Default, aes(x=balance, fill=student)) + geom_histogram(position = <span class="string">&#x27;identity&#x27;</span>, alpha = <span class="number">0.4</span>, bins=<span class="number">60</span>)</span><br></pre></td></tr></table></figure>
<p><img src="20.png" alt="1"></p>
<h2 id="大于2个水平的因变量">大于2个水平的因变量</h2>
<p>如果有多个水平的话，一般就不用逻辑回归了。我们会用 <abbr title="discriminant analysis"><strong>判别分析</strong></abbr>  方法。</p>
<h1><abbr title="Linear Discriminant Analysis, LDA">线性判别分析</abbr></h1>
<p>对于大于2个水平（K&gt;2）的因变量，我们假定我们获取因变量的<strong>先验分布</strong>（即一个随机挑选的观察值来自于其中某个水平的概率），记为下面的符号。</p>
<p style=""><img src="https://math.now.sh?from=%5Cpi_%7Bk%7D%0A" /></p><p>另外一个式子就是基于某个因变量水平的自变量分布，见下式。如果这个值很高，说明当Y=k时，X=x 的概率很大。</p>
<p style=""><img src="https://math.now.sh?from=f_%7Bk%7D%28x%29%20%5Cequiv%20%5Coperatorname%7BPr%7D(X%3Dx%20%5Cmid%20Y%3Dk)%0A" /></p><p>我们通过<strong>贝叶斯定理</strong>，就可以得到基于某个X的Y的条件概率，即<strong>后验概率</strong>，我们用 <em><strong>p<sub>k</sub>(x)</strong></em>  来表示</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BPr%7D%28Y%3Dk%20%5Cmid%20X%3Dx%29%3D%5Cfrac%7B%5Cpi_%7Bk%7D%20f_%7Bk%7D(x)%7D%7B%5Csum_%7Bl%3D1%7D%5E%7BK%7D%20%5Cpi_%7Bl%7D%20f_%7Bl%7D(x)%7D%0A" /></p><p>在这个公式里，因变量的先验分布比较容易获得，我们先对总体进行随机抽样，之后算一下每个水平的比例即可。但是 f<sub>k</sub>(x) 就不是很容易获得。<strong>如果我们可以估计  f<sub>k</sub>(x)</strong> ，我们就可以计算不同因变量水平的<strong>后验概率</strong>，我们认为后验概率最大的水平就是预测值。</p>
<h2 id="p-1的线性判别分析">p=1的线性判别分析</h2>
<p>如果只有一个自变量，我们需要首先估计  f<sub>k</sub>(x) ，我们需要先做一些假设。</p>
<p>我们假设  <strong>f<sub>k</sub>(x) 是符合正态分布的</strong> （假设1），在一个自变量的情况下，即符合下面这个式子：</p>
<p style=""><img src="https://math.now.sh?from=f_%7Bk%7D%28x%29%3D%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%7D%20%5Csigma_%7Bk%7D%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B1%7D%7B2%20%5Csigma_%7Bk%7D%5E%7B2%7D%7D%5Cleft(x-%5Cmu_%7Bk%7D%5Cright)%5E%7B2%7D%5Cright)%0A" /></p><p>其中 u<sub>k</sub> 和 σ<sup>2</sup><sub>k</sub>  分别为第K个水平的均值和方差。我们进一步假设<strong>所有的水平的方差均相同</strong>（假设2），即如下式，可以简化为 σ<sup>2</sup> 。</p>
<p style=""><img src="https://math.now.sh?from=%5Csigma_%7B1%7D%5E%7B2%7D%3D%5Cldots%3D%5Csigma_%7BK%7D%5E%7B2%7D%0A" /></p><p>将这个式子带入到上面计算  <em><strong>p<sub>k</sub>(x)</strong></em> 的式子中，得到</p>
<p style=""><img src="https://math.now.sh?from=p_%7Bk%7D%28x%29%3D%5Cfrac%7B%5Cpi_%7Bk%7D%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%7D%20%5Csigma%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B1%7D%7B2%20%5Csigma%5E%7B2%7D%7D%5Cleft(x-%5Cmu_%7Bk%7D%5Cright)%5E%7B2%7D%5Cright)%7D%7B%5Csum_%7Bl%3D1%7D%5E%7BK%7D%20%5Cpi_%7Bl%7D%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%7D%20%5Csigma%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B1%7D%7B2%20%5Csigma%5E%7B2%7D%7D%5Cleft(x-%5Cmu_%7Bl%7D%5Cright)%5E%7B2%7D%5Cright)%7D%0A" /></p><p>计算所有水平的后验概率，选择<strong>后验概率最大</strong>的水平。我们可以看到对所有的水平，分母部分都是一样的，因此我们只需要关注分子部分，只要找对分子最大的水平。对分子部分采用 log 函数，剔除常数部分，我们得到下面这个式子。这个式子值最大的水平，就是后验概率最大的水平</p>
<p style=""><img src="https://math.now.sh?from=%5Cdelta_%7Bk%7D%28x%29%3Dx%20%5Ccdot%20%5Cfrac%7B%5Cmu_%7Bk%7D%7D%7B%5Csigma%5E%7B2%7D%7D-%5Cfrac%7B%5Cmu_%7Bk%7D%5E%7B2%7D%7D%7B2%20%5Csigma%5E%7B2%7D%7D%2B%5Clog%20%5Cleft(%5Cpi_%7Bk%7D%5Cright)%0A" /></p><p>假设 K=2，并且 π<sub>1</sub> = π<sub>2</sub> 。那么如果满足下面这个式子，则最终分配为水平1；否则则为水平2</p>
<p style=""><img src="https://math.now.sh?from=2%20x%5Cleft%28%5Cmu_%7B1%7D-%5Cmu_%7B2%7D%5Cright%29%3E%5Cmu_%7B1%7D%5E%7B2%7D-%5Cmu_%7B2%7D%5E%7B2%7D%0A" /></p><p>在这种情况下，<abbr title="Bayes decision boundary">贝叶斯决策线</abbr> 为</p>
<p style=""><img src="https://math.now.sh?from=x%3D%5Cfrac%7B%5Cmu_%7B1%7D%5E%7B2%7D-%5Cmu_%7B2%7D%5E%7B2%7D%7D%7B2%5Cleft%28%5Cmu_%7B1%7D-%5Cmu_%7B2%7D%5Cright%29%7D%3D%5Cfrac%7B%5Cmu_%7B1%7D%2B%5Cmu_%7B2%7D%7D%7B2%7D%20%5Ctext%20%7B%20.%20%7D%0A" /></p><p>但是在实际中， π<sub>k</sub> , μ<sub>k</sub> ， σ<sup>2</sup>  这些参数都是未知的，我们需要先估计这些常数，再估计 <em>p<sub>k</sub>(x)</em></p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Chat%7B%5Cmu%7D_%7Bk%7D%20%26%3D%5Cfrac%7B1%7D%7Bn_%7Bk%7D%7D%20%5Csum_%7Bi%3A%20y_%7Bi%7D%3Dk%7D%20x_%7Bi%7D%20%5C%5C%0A%5Chat%7B%5Csigma%7D%5E%7B2%7D%20%26%3D%5Cfrac%7B1%7D%7Bn-K%7D%20%5Csum_%7Bk%3D1%7D%5E%7BK%7D%20%5Csum_%7Bi%3A%20y_%7Bi%7D%3Dk%7D%5Cleft%28x_%7Bi%7D-%5Chat%7B%5Cmu%7D_%7Bk%7D%5Cright%29%5E%7B2%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>这里 n 是所有的观测值数目，n<sub>k</sub> 是观测值为水平k 时的数目。至于 π<sub>k</sub> ，有先验就用，没有就从 training data 计算一下</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cpi%7D_%7Bk%7D%3Dn_%7Bk%7D%20%2F%20n%0A" /></p><p>将上面的参数估计值带入下式，计算得到值最大的水平</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cdelta%7D_%7Bk%7D%28x%29%3Dx%20%5Ccdot%20%5Cfrac%7B%5Chat%7B%5Cmu%7D_%7Bk%7D%7D%7B%5Chat%7B%5Csigma%7D%5E%7B2%7D%7D-%5Cfrac%7B%5Chat%7B%5Cmu%7D_%7Bk%7D%5E%7B2%7D%7D%7B2%20%5Chat%7B%5Csigma%7D%5E%7B2%7D%7D%2B%5Clog%20%5Cleft(%5Chat%7B%5Cpi%7D_%7Bk%7D%5Cright)%0A" /></p><p>为什么判别分析称为<strong>线性</strong>判别分析呢？因为 <em>discriminant functions</em> δ<sub>k</sub>(x) 是 x 的线性函数。</p>
<h2 id="p-1的线性判别分析-2">p&gt;1的线性判别分析</h2>
<p>我们现在看多个自变量的情况，并且这些自变量服从<strong>多元正态分布</strong>（每个变量均服从一维正态分布）， 下图为两个变量时服从多元正态分布的概率密度图。</p>
<p><img src="21.png" alt="1"></p>
<p>为了表示 p维的随机变量X 服从多元正态分布，我们写作</p>
<p style=""><img src="https://math.now.sh?from=X%20%5Csim%20N%28%5Cmu%2C%20%5Cboldsymbol%7B%5CSigma%7D%29%0A" /></p><p>其中，<em>μ</em> 为均值，是一个p维的向量。</p>
<p style=""><img src="https://math.now.sh?from=E%28X%29%3D%5Cmu%0A" /></p><p>方差分布为 Σ , 为 <em>p × p</em> 的矩阵。</p>
<p>最后，多元正态分布定义为</p>
<p style=""><img src="https://math.now.sh?from=f%28x%29%3D%5Cfrac%7B1%7D%7B(2%20%5Cpi)%5E%7Bp%20%2F%202%7D%7C%5CSigma%7C%5E%7B1%20%2F%202%7D%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B1%7D%7B2%7D(x-%5Cmu)%5E%7BT%7D%20%5Cmathbf%7B%5CSigma%7D%5E%7B-1%7D(x-%5Cmu)%5Cright)%0A" /></p><p>类似于p=1的判别分析，这里假定因变量所有水平的观测值均服从<strong>方差相同的</strong>多元正态分布。</p>
<p>p&gt;1的判别函数如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cdelta_%7Bk%7D%28x%29%3Dx%5E%7BT%7D%20%5Cboldsymbol%7B%5CSigma%7D%5E%7B-1%7D%20%5Cmu_%7Bk%7D-%5Cfrac%7B1%7D%7B2%7D%20%5Cmu_%7Bk%7D%5E%7BT%7D%20%5Cboldsymbol%7B%5CSigma%7D%5E%7B-1%7D%20%5Cmu_%7Bk%7D%2B%5Clog%20%5Cpi_%7Bk%7D%0A" /></p><p>以下图为例，作图是三种水平所有观测值结果，圆圈为95%的概率的范围，虚线为画出的贝叶斯决策线；右图为各随机抽取了20个样本的结果，实线为抽样结果的贝叶斯决策线。</p>
<p>个人理解：这张图给了我一个提示，<strong>分类变量的每个水平必须是能几乎截然分开的</strong>，才能进行分析。不然对于判别分析，无法画出决策线。所以我感觉进行分析前有必要先进行一下可视化，看一下分类变量的各个水平的设置是否合理，有没有两个水平实际是差不多同一个水平的情况。</p>
<p><img src="22.png" alt="1"></p>
<p>这里我们同样需要估计这些参数，类似于p=1的情况</p>
<p>从判别函数的形式看，判别函数依然是 X 的线性转换，这就是线性判别分析中线性的由来。</p>
<p>如果对信用卡违约的数据进行判别分析，因变量是<strong>是否违约</strong>，自变量是 <em>credit card balance</em> 和 <em>student status</em> ，通过对 10,000 个 traing samples 进行建模，我们得到的 <em>training error rate</em> 的结果是 2.75% 。这个结果看上去很好，但是有两个注意事项：</p>
<ol>
<li>首先，<em>training error rate</em>  通常会低于 <em>test error rate</em>，也就是说 test data 的结果通常会更差一点，这是因为我们是根据 <em>training data</em> 来拟合的模型参数。如果参数 p 除以 样本 n 的比例越高，我们可能越可能遇到<strong>过拟合</strong>问题。</li>
<li>其次，由于 <em>training data</em> 中只有3.33%的个体违约，因此一个最简单的 <em>classifier</em> 可以将所有个体都预测为不会违约，无论这个人的 credit card balance 和 student status 是什么情况，这个 <em>classifier</em> 的 <em>trainging error rate</em> 就是 3.33%。这种情况下仅仅比上面的 2.75% 略高。</li>
</ol>
<p>在实际情况中，一个二分类的 <em>classifier</em> 会产生两种错误：它可能将一个不违约的个体判定为违约，或者将违约的个体判定为不违约。这两种错误发生的原因，通常是需要关注的地方。我们一般会通过 <em><strong>confusion matrix</strong></em> 来查看一下，我们可以看到在真实为NO的个体中（9667），总共有23个个体是错误预测的，这看上去错误概率很低。但是，在总共333个违约个体中，总共有252（75.7%）的个体被错误预测为No。因此，<strong>虽然总的 <em>training error rate</em>  很低，但是针对违约的个体的<em>error rate</em> 很高</strong>。由于信用卡公司做预测的目的是为了确定高风险可能违约的用户，这种预测情况肯定是无法接受的。</p>
<p><img src="23.png" alt="1"></p>
<h3 id="sensitivity-和-specificity">sensitivity 和 specificity</h3>
<p>有两个概念可以说明一个 <em>classifier</em> 的表现， <em><strong>sensitivity</strong></em> 和 <em><strong>specificity</strong></em> 。在这个例子中，<em>sensitivity</em> 就是违约者被正确预测的概率，这里是24.3%；<em>specificity</em> 就是非违约者被正确预测的概率，这里是 99.8%。</p>
<p>为什么判别分析在违约个体的表现如此糟糕呢？或者说，为什么 <em>sensitivity</em> 如此低？如我们所见，判别分析会采用贝叶斯方法，会含有最低的 <em>total error rate</em> ，也就是说会产生最少的总的错误分类的数目，无论这些错误分类原本来自于哪个分类。但是基于信用卡公司的角度，肯定是希望尽量避免将会违约的个体判定为不会违约的错误，相比之下，将不会违约的个体判定为违约问题则没有那么严重。因此我们需要需改这个方法，来新建一个 <em>classifier</em> 来更好地符合信用卡公司的需求。</p>
<p>判别分析会将个体判定为<strong>后验概率最大</strong>的分类。在只有两种分类的情况下，一个观测值会判定为违约的公式如下（后验概率大于0.5）</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BPr%7D%28%5Ctext%20%7B%20default%20%7D%3D%5Coperatorname%7BYes%7D%20%5Cmid%20X%3Dx%29%3E0.5%0A" /></p><p>这里默认阈值就是0.5，但是，如果我们特别关心将违约个体预测为非违约的情况，那么我们就可以降低这个阈值。例如如果后验概率超过0.2，我们就判定为违约，公式如下</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BPr%7D%28%5Ctext%20%7B%20default%20%7D%3D%5Coperatorname%7BYes%7D%20%5Cmid%20X%3Dx%29%3E0.2%0A" /></p><p>修改阈值后，预测结果如下，我们可以看到相比于上面的结果，违约个体预测错误下降，但是非违约个体的预测错误上升。总的预测错误轻微上升至3.73%。</p>
<p><img src="24.png" alt="1"></p>
<p>下图说明了修改违约后验概率阈值的 trade-off 结果。如果阈值设定为0.5，那么总的错误概率是最低的，如下图的黑线，但是违约个体的错误概率却是最高的，如蓝色虚线所示。</p>
<p><img src="25.png" alt="1"></p>
<p><abbr title="receiver operating characteristics">ROC</abbr>  曲线是用来展现不同的阈值下两种错误的错误概率的变化。下图就是 ROC 图 ，纵坐标是 <em>sensitivity</em> ，就是违约者被正确预测的概率；横坐标为 <em>1-specificity</em> ，为非违约者被错误预测的概率。这幅图不显示阈值。</p>
<p><img src="26.png" alt="1"></p>
<h3 id="一型错误和二型错误">一型错误和二型错误</h3>
<p>我们把上面的表格进行一般化，用 - 或 Null 表示零假设（本例为不违约），+ 或 Non-null 表示备择假设（本例为违约）。</p>
<p><img src="27.png" alt="1"></p>
<p>根据上面的表格，我们得到一些重要的统计量。</p>
<p><img src="28.png" alt="1"></p>
<h1><abbr title="Quadratic Discriminant Analysis,  QDA">二次判别分析</abbr></h1>
<p>线性判别分析假设所有水平的观测值均假设服从一个<strong>方差矩阵</strong>相同的<strong>多元正态分布</strong>。二次判别分析则假设所有水平的观测值均服从一个正态分布，但是不像线性判别分析，二次判别分析假设<strong>所有水平的方差矩阵各不相同</strong>。即对第k个水平的观测值的分布为：</p>
<p style=""><img src="https://math.now.sh?from=X%20%5Csim%20N%5Cleft%28%5Cmu_%7Bk%7D%2C%20%5CSigma_%7Bk%7D%5Cright%29%0A" /></p><p>在这个假设下，判别函数如下。这个函数是 x 的二次函数，这就是二次判别分析名字的来源。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cdelta_%7Bk%7D%28x%29%20%26%3D-%5Cfrac%7B1%7D%7B2%7D%5Cleft(x-%5Cmu_%7Bk%7D%5Cright)%5E%7BT%7D%20%5CSigma_%7Bk%7D%5E%7B-1%7D%5Cleft(x-%5Cmu_%7Bk%7D%5Cright)-%5Cfrac%7B1%7D%7B2%7D%20%5Clog%20%5Cleft%7C%5CSigma_%7Bk%7D%5Cright%7C%2B%5Clog%20%5Cpi_%7Bk%7D%20%5C%5C%0A%26%3D-%5Cfrac%7B1%7D%7B2%7D%20x%5E%7BT%7D%20%5CSigma_%7Bk%7D%5E%7B-1%7D%20x%2Bx%5E%7BT%7D%20%5CSigma_%7Bk%7D%5E%7B-1%7D%20%5Cmu_%7Bk%7D-%5Cfrac%7B1%7D%7B2%7D%20%5Cmu_%7Bk%7D%5E%7BT%7D%20%5CSigma_%7Bk%7D%5E%7B-1%7D%20%5Cmu_%7Bk%7D-%5Cfrac%7B1%7D%7B2%7D%20%5Clog%20%5Cleft%7C%5CSigma_%7Bk%7D%5Cright%7C%2B%5Clog%20%5Cpi_%7Bk%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>我们应该在什么情况下采用线性判别分析，什么情况下采用二次判别分析呢？这个答案在 <code>bias-variance trade-off</code> 中。二次判别分析需要估计的参数比线性判别分析多得多，如果我们有 p 个预测因子，那么估计线性分析的方差矩阵需要 <em>p(p+1)/2</em> 个参数；而二次判别分析需要对每个水平均要估计一个单独的方差矩阵，则总共需要 <em>Kp(p+1)/2</em> 个参数。因此二次判别分析更灵活，bias 比较低，但 variance 比较高。<strong>一般来说，当样本数量比较少时，推荐使用线性判别分析来降低 variance；如果样本数量非常大或者严重偏理所有水平同方差的假设，更推荐使用二次判别分析。</strong></p>
<p>下图说明了线性判别分析和二次判别分析在两种情况下的表现。</p>
<p><img src="29.png" alt="1"></p>
<h1>不同方法的比较</h1>
<p>逻辑回归和线性判别分析虽然思路不同，但却是紧密相关的。在线性判别分析的框架里，<em>log odds</em> 计算公式可简化如下（就是两个判别函数相减）：</p>
<p style=""><img src="https://math.now.sh?from=%5Clog%20%5Cleft%28%5Cfrac%7Bp_%7B1%7D(x%29%7D%7B1-p_%7B1%7D(x)%7D%5Cright)%3D%5Clog%20%5Cleft(%5Cfrac%7Bp_%7B1%7D(x)%7D%7Bp_%7B2%7D(x)%7D%5Cright)%3Dc_%7B0%7D%2Bc_%7B1%7D%20x%0A" /></p><p>根据逻辑回归公式，<em>log odd</em> 可写为：</p>
<p style=""><img src="https://math.now.sh?from=%5Clog%20%5Cleft%28%5Cfrac%7Bp_%7B1%7D%7D%7B1-p_%7B1%7D%7D%5Cright%29%3D%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20x%0A" /></p><p>这两种方法得到的 <em>log odd</em> 都是 x 的线性函数，因此这两种方法的决策边界均为直线。这两种方法唯一的区别在于 β0 和 β1 是通过最大似然得到的，而 c<sub>0</sub>  和 c<sub>1</sub> 是通过估计正态分布的均值和方差得到的。</p>
<p>由于这两种方法仅仅是拟合参数的过程有区别，因此这两种方法的结果往往是非常相似的，但偶尔可能情况不一样。线性判别分析由于存在<strong>同方差正态分布</strong>的假设，因此<strong>如果数据符合这个假设，那么结果可能比较好。相反，如果数据不符合这个假设，那么逻辑回归的结果会更好。</strong></p>
<p>而 KNN 方法但预测 X = x 的值时，会提取x附近的多个观测值，然后分配X为大多数观测值的结果。因此 KNN 方法是一种完全的非参数方法，没有对决策界限的任何假设。因此，如果只有当决策线是高度非线性的情况下，KNN 方法才可能由于线性判别方法和逻辑回归方法。另一方面，KNN 方面没有告诉我们哪些预测是重要的，哪些是不重要的。</p>
<p>最后，二次判别分析是 KNN 方法 和 LDA/逻辑回归方法 之间的折中方法，它的决策线是二次函数。</p>
<p>为了说明这四种方法的表型，ISL 书中模拟了六种情况，在前三种情况下，真实的决策线就是线性的，另外三种情况则是非线性的。对于每种情况下，均随机生成 100 个训练集，我们在每个训练集中拟合模型，然后计算一个很大的 <em>test data</em> 数据集的 <em>test error rate</em> 。</p>
<p>真实决策线是直线的三种情况画图如下：</p>
<p><img src="30.png" alt="1"></p>
<p>真实决策线不是直线的三种情况画图如下：</p>
<p><img src="31.png" alt="1"></p>
<p>其中，KNN 方法做了两次，一次 K = 1，一次 K 值通过 <em>cross validation</em> 获得。在所有的情况中，p 均等于2。</p>
<p>我们可以看到，如果真实的预测线是线性的，那么 LDA和逻辑回归方法较好；如果是非线性的，那么 QDA 方法更好。最后，对于非常复杂的预测线，那么非参方法，例如KNN方法更好，但是需要慎重选择平滑度。</p>
<p>最后，在线性回归中，我们可以通过对预测因子进行转换，来实现对非线性关系的模拟。我们同样可以在分类变量的分析中采用相同的操作，例如采用 X<sup>2</sup> , X<sup>3</sup>  等加入到逻辑回归 和 LDA分析中，这样可以实现类似与 QDA 的效果。</p>
<h1>R代码</h1>
<p>ISl 使用的数据是股票数据，Smarket data ，来自于 ISLR 包。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(ISLR)</span><br><span class="line"><span class="built_in">names</span>(Smarket)</span><br><span class="line"><span class="built_in">dim</span>(Smarket)</span><br><span class="line">summary(Smarket)</span><br></pre></td></tr></table></figure>
<p>使用 cor() 函数可以计算所有数据集的相关矩阵，所有变量必须为连续变量。</p>
<p>我们可以看到这里只有 Year 和 Volume 这两个变量之间存在实质相关。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; cor(Smarket)</span><br><span class="line">Error <span class="keyword">in</span> cor(Smarket) : <span class="string">&#x27;x&#x27;</span>必需为数值</span><br><span class="line">&gt; cor(Smarket[,-<span class="number">9</span>])</span><br><span class="line">             Year         Lag1         Lag2         Lag3         Lag4         Lag5      Volume</span><br><span class="line">Year   <span class="number">1.00000000</span>  <span class="number">0.029699649</span>  <span class="number">0.030596422</span>  <span class="number">0.033194581</span>  <span class="number">0.035688718</span>  <span class="number">0.029787995</span>  <span class="number">0.53900647</span></span><br><span class="line">Lag1   <span class="number">0.02969965</span>  <span class="number">1.000000000</span> -<span class="number">0.026294328</span> -<span class="number">0.010803402</span> -<span class="number">0.002985911</span> -<span class="number">0.005674606</span>  <span class="number">0.04090991</span></span><br><span class="line">Lag2   <span class="number">0.03059642</span> -<span class="number">0.026294328</span>  <span class="number">1.000000000</span> -<span class="number">0.025896670</span> -<span class="number">0.010853533</span> -<span class="number">0.003557949</span> -<span class="number">0.04338321</span></span><br><span class="line">Lag3   <span class="number">0.03319458</span> -<span class="number">0.010803402</span> -<span class="number">0.025896670</span>  <span class="number">1.000000000</span> -<span class="number">0.024051036</span> -<span class="number">0.018808338</span> -<span class="number">0.04182369</span></span><br><span class="line">Lag4   <span class="number">0.03568872</span> -<span class="number">0.002985911</span> -<span class="number">0.010853533</span> -<span class="number">0.024051036</span>  <span class="number">1.000000000</span> -<span class="number">0.027083641</span> -<span class="number">0.04841425</span></span><br><span class="line">Lag5   <span class="number">0.02978799</span> -<span class="number">0.005674606</span> -<span class="number">0.003557949</span> -<span class="number">0.018808338</span> -<span class="number">0.027083641</span>  <span class="number">1.000000000</span> -<span class="number">0.02200231</span></span><br><span class="line">Volume <span class="number">0.53900647</span>  <span class="number">0.040909908</span> -<span class="number">0.043383215</span> -<span class="number">0.041823686</span> -<span class="number">0.048414246</span> -<span class="number">0.022002315</span>  <span class="number">1.00000000</span></span><br><span class="line">Today  <span class="number">0.03009523</span> -<span class="number">0.026155045</span> -<span class="number">0.010250033</span> -<span class="number">0.002447647</span> -<span class="number">0.006899527</span> -<span class="number">0.034860083</span>  <span class="number">0.01459182</span></span><br><span class="line">              Today</span><br><span class="line">Year    <span class="number">0.030095229</span></span><br><span class="line">Lag1   -<span class="number">0.026155045</span></span><br><span class="line">Lag2   -<span class="number">0.010250033</span></span><br><span class="line">Lag3   -<span class="number">0.002447647</span></span><br><span class="line">Lag4   -<span class="number">0.006899527</span></span><br><span class="line">Lag5   -<span class="number">0.034860083</span></span><br><span class="line">Volume  <span class="number">0.014591823</span></span><br><span class="line">Today   <span class="number">1.000000000</span></span><br></pre></td></tr></table></figure>
<h2 id="逻辑回归">逻辑回归</h2>
<p><code>glm()</code> 函数使用广义线性模型，包括一系列模型，其中就有逻辑回归。这里我们通过指定 <code>family = binomial</code> 来指定使用逻辑回归。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; glm.fit = glm(Direction ~ Lag1+Lag2+Lag3+Lag4+Lag5+Volume, data=Smarket, family=binomial)</span><br><span class="line">&gt; summary(glm.fit)</span><br><span class="line"></span><br><span class="line">Call:</span><br><span class="line">glm(formula = Direction ~ Lag1 + Lag2 + Lag3 + Lag4 + Lag5 + </span><br><span class="line">    Volume, family = binomial, data = Smarket)</span><br><span class="line"></span><br><span class="line">Deviance Residuals: </span><br><span class="line">   Min      <span class="number">1</span>Q  Median      <span class="number">3</span>Q     Max  </span><br><span class="line">-<span class="number">1.446</span>  -<span class="number">1.203</span>   <span class="number">1.065</span>   <span class="number">1.145</span>   <span class="number">1.326</span>  </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">             Estimate Std. Error z value Pr(&gt;|z|)</span><br><span class="line">(Intercept) -<span class="number">0.126000</span>   <span class="number">0.240736</span>  -<span class="number">0.523</span>    <span class="number">0.601</span></span><br><span class="line">Lag1        -<span class="number">0.073074</span>   <span class="number">0.050167</span>  -<span class="number">1.457</span>    <span class="number">0.145</span></span><br><span class="line">Lag2        -<span class="number">0.042301</span>   <span class="number">0.050086</span>  -<span class="number">0.845</span>    <span class="number">0.398</span></span><br><span class="line">Lag3         <span class="number">0.011085</span>   <span class="number">0.049939</span>   <span class="number">0.222</span>    <span class="number">0.824</span></span><br><span class="line">Lag4         <span class="number">0.009359</span>   <span class="number">0.049974</span>   <span class="number">0.187</span>    <span class="number">0.851</span></span><br><span class="line">Lag5         <span class="number">0.010313</span>   <span class="number">0.049511</span>   <span class="number">0.208</span>    <span class="number">0.835</span></span><br><span class="line">Volume       <span class="number">0.135441</span>   <span class="number">0.158360</span>   <span class="number">0.855</span>    <span class="number">0.392</span></span><br><span class="line"></span><br><span class="line">(Dispersion parameter <span class="keyword">for</span> binomial family taken to be <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    Null deviance: <span class="number">1731.2</span>  on <span class="number">1249</span>  degrees of freedom</span><br><span class="line">Residual deviance: <span class="number">1727.6</span>  on <span class="number">1243</span>  degrees of freedom</span><br><span class="line">AIC: <span class="number">1741.6</span></span><br><span class="line"></span><br><span class="line">Number of Fisher Scoring iterations: <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看系数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; coef(glm.fit)</span><br><span class="line"> (Intercept)         Lag1         Lag2         Lag3         Lag4         Lag5       Volume </span><br><span class="line">-<span class="number">0.126000257</span> -<span class="number">0.073073746</span> -<span class="number">0.042301344</span>  <span class="number">0.011085108</span>  <span class="number">0.009358938</span>  <span class="number">0.010313068</span>  <span class="number">0.135440659</span></span><br><span class="line">&gt; summary(glm.fit)$coef</span><br><span class="line">                Estimate Std. Error    z value  Pr(&gt;|z|)</span><br><span class="line">(Intercept) -<span class="number">0.126000257</span> <span class="number">0.24073574</span> -<span class="number">0.5233966</span> <span class="number">0.6006983</span></span><br><span class="line">Lag1        -<span class="number">0.073073746</span> <span class="number">0.05016739</span> -<span class="number">1.4565986</span> <span class="number">0.1452272</span></span><br><span class="line">Lag2        -<span class="number">0.042301344</span> <span class="number">0.05008605</span> -<span class="number">0.8445733</span> <span class="number">0.3983491</span></span><br><span class="line">Lag3         <span class="number">0.011085108</span> <span class="number">0.04993854</span>  <span class="number">0.2219750</span> <span class="number">0.8243333</span></span><br><span class="line">Lag4         <span class="number">0.009358938</span> <span class="number">0.04997413</span>  <span class="number">0.1872757</span> <span class="number">0.8514445</span></span><br><span class="line">Lag5         <span class="number">0.010313068</span> <span class="number">0.04951146</span>  <span class="number">0.2082966</span> <span class="number">0.8349974</span></span><br><span class="line">Volume       <span class="number">0.135440659</span> <span class="number">0.15835970</span>  <span class="number">0.8552723</span> <span class="number">0.3924004</span></span><br></pre></td></tr></table></figure>
<h2 id="线性判别分析">线性判别分析</h2>
<p>我们可以用 MASS 包的 lda() 函数进行LDA分析。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; library(MASS)</span><br><span class="line">&gt; lda.fit = lda(Direction ~ Lag1 + Lag2, data=Smarket)</span><br><span class="line">&gt; lda.fit</span><br><span class="line">Call:</span><br><span class="line">lda(Direction ~ Lag1 + Lag2, data = Smarket)</span><br><span class="line"></span><br><span class="line">Prior probabilities of groups:</span><br><span class="line">  Down     Up </span><br><span class="line">0.4816 <span class="number">0.5184</span> </span><br><span class="line"></span><br><span class="line">Group means:</span><br><span class="line">            Lag1        Lag2</span><br><span class="line">Down  <span class="number">0.05068605</span>  <span class="number">0.03229734</span></span><br><span class="line">Up   -<span class="number">0.03969136</span> -<span class="number">0.02244444</span></span><br><span class="line"></span><br><span class="line">Coefficients of linear discriminants:</span><br><span class="line">            LD1</span><br><span class="line">Lag1 -<span class="number">0.7567605</span></span><br><span class="line">Lag2 -<span class="number">0.4707872</span></span><br></pre></td></tr></table></figure>
<p>这里提供了先验概率的估计值，每个水平均值的估计值。最后的 <em>Coefficients of linear discriminants</em> 提供了两个因子的线性组合，用于形成决策线。在本例中，就是下式</p>
<p style=""><img src="https://math.now.sh?from=-0.642%20%5Ctimes%20%5Coperatorname%7BLag%7D%201-0.514%20%5Ctimes%20%5Ctext%20%7B%20Lag%20%7D%202%0A" /></p><p>如果这个式子很大，那么就会预测为 Up，否则就预测为 down 。</p>
<h2 id="二次判别分析">二次判别分析</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; library(MASS)</span><br><span class="line">&gt; qda.fit &#x3D; qda(Direction ~ Lag1 + Lag2, data&#x3D;Smarket)</span><br><span class="line">&gt; qda.fit</span><br><span class="line">Call:</span><br><span class="line">qda(Direction ~ Lag1 + Lag2, data &#x3D; Smarket)</span><br><span class="line"></span><br><span class="line">Prior probabilities of groups:</span><br><span class="line">  Down     Up </span><br><span class="line">0.4816 0.5184 </span><br><span class="line"></span><br><span class="line">Group means:</span><br><span class="line">            Lag1        Lag2</span><br><span class="line">Down  0.05068605  0.03229734</span><br><span class="line">Up   -0.03969136 -0.02244444</span><br></pre></td></tr></table></figure>
<p>这里没有提供系数。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>《Bioinformatics Data Skills》读书笔记</title>
    <url>/posts/a96a52e9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这本书确实是强力推荐，作者的数据分析技巧和编程技巧均很高超，而且无论是务实还是务虚的部分（道和术）都总结得特别好。我读过一遍以后，刷新了我对很多东西的认知。</p>
<p>这本书分了三大章，第一章介绍数据分析和生信分析的“道”，建议认真阅读；第二章介绍基础技能，我印象最深刻的是讲 Git 的部分，讲解很清楚；第三章才是实际生物信息分析的部分，涉及到很多格式的文件的处理，比如FASTA文件啥的，对我这种生信小白很有帮助。</p>
<p>据说作者是在读硕士的时候写的这本书，真是令人汗颜！这本书的电子版可以在 <a href="http://libgen.rs/">libgen</a> 找到。</p>
<p>最后，最后附有<code>(好)</code> 字样的标题是我读的时候觉得办案叫绝的章节。</p>
<span id="more"></span>
<h1>第1部分 Ideology: Data Skills for Robust and Reproducible Bioinformatics</h1>
<h2 id="1-1-How-to-Learn-Bioinformatics">1.1 How to Learn Bioinformatics</h2>
<p>测序价格极速下降，导致测序数据数量激增。因此，做生信急需数据分析能力。</p>
<p>生信分析的软件众多，但面临两个问题：第一，没有校准（我的理解适合一个物种的软件，不见得适合另一种物种）；第二，可能有bug。因此，<strong>你需要做测试，能够看懂结果，并具有分析结果是否正确的能力</strong></p>
<h2 id="1-2-Reproducible-Research">1.2 Reproducible Research</h2>
<p>生信的东西很多时候难以重现，第一是测序太贵，不可能重复测序；第二是相同的数据，由于方法太多，步骤太大，参考基因组和软件、网站啥的又不断更新，因此也很难重现。</p>
<p>这里作者举了个例子，他和同事同时做一个RNA-seq的分析，发现找到的表达基因完全不同，找了半天也没找到原因，最后发现是<strong>使用R包的版本不同</strong>。</p>
<blockquote>
<p>he lesson here is that often replication, by either you in the  future  or  someone  else,  relies  on  not  just  data  and  code  but  details  like  software versions  and  when  data  was  downloaded  and  what  version  it  is.  This  metadata,  or data about data, is a crucial detail in ensuring reproducibility.</p>
</blockquote>
<p>在教授生物信息时，作者给出的黄金法则是</p>
<blockquote>
<p>Never ever trust your tools (or data)</p>
</blockquote>
<p>保持怀疑，保持验证。</p>
<h3 id="1-2-1-Adopting-Robust-and-Reproducible-Practices-Will-Make-Your-Life-Easier-Too">1.2.1 Adopting Robust and Reproducible Practices Will Make Your Life Easier, Too</h3>
<p>做生信分析，我保证你会经历下面两件事：</p>
<ul>
<li>rerun an analysis more than once，这可能是由于数据有变化、发现bug，想要更新流程等等</li>
<li>当你或别人回过头看你之前做的东西，会发现有些地方很怪。这时候你唯一可辩护的地方是拿出你当时做的每一步的文档。如果你没有记录一些重要的事实，你肯定会忘记。</li>
</ul>
<p>这要求两点：</p>
<ol>
<li>使用脚本处理</li>
<li><strong>步骤记录</strong></li>
</ol>
<h2 id="1-3-Recommendations-for-Robust-Research">1.3 Recommendations for Robust Research</h2>
<h3 id="1-3-1-Pay-Attention-to-Experimental-Design">1.3.1 Pay Attention to Experimental Design</h3>
<h3 id="1-3-2-Write-Code-for-Humans-Write-Data-for-Computers">1.3.2 Write Code for Humans, Write Data for Computers</h3>
<p>调试代码比写代码更难，因为需要人去调试代码，因此代码要具有可读性。</p>
<p>为什么代码可读性很重要：</p>
<blockquote>
<p>First, readable  code  makes  projects  more  reproducible,  as  others  can  more  easily  understand what scripts do and how they work. Second, it’s much easier to find and correct software bugs in readable, well-commented code than messy code. Third, revisiting code in  the  future  is  always  easier  when  the  code  is  well  commented  and  clearly  written.</p>
</blockquote>
<h3 id="1-3-3-Make-Assertions-and-Be-Loud-in-Code-and-in-Your-Methods">1.3.3 Make Assertions and Be Loud, in Code and in Your Methods</h3>
<p>通常来说，我们对拿到的数据有一些潜在的假设。比如基因的起始位置要小于结束位置、物理位置不能为负值。这些假设影响了我们写代码，在我们写的代码中我们可能从没想过如果不满足这些假设该怎么处理（说白了，就是我们写代码可能没有考虑这些假设，如果不满足这些假设，实际上是不能运行的）。不幸的是，这会导致致命的<strong>silent error</strong>：  our  code  or  programs  receive  values  outside  our  expected  values,  behave improperly,  and  yet  still  return  output  without  warning.</p>
<p>一个最好的办法就是使用 assert 功能 判断数据是否符合这些假设（Python’s assert() and R’s stopifnot()）</p>
<p>不同的语言都有自己的assert 函数，而且功能都相同：如果判断为false，那么程序会停止运行，抛出一个error。</p>
<blockquote>
<p>Early  in  my  career,  a  mentor motivated me to adopt the habit of using asserts quite liberally—even when it seems like there is absolutely no way the statement could ever be false—and yet I’m continually  surprised  at  how  many  times  these  have  caught  a  subtle  error.</p>
<p><strong>In  bioinformatics (and  all  fields),  it’s  crucial  that  we  do  as  much  as  possible  to  turn  the  dreaded  silent error into loud errors.</strong></p>
</blockquote>
<h3 id="1-3-4-Test-Code-or-Better-Yet-Let-Code-Test-Code">1.3.4 Test Code, or Better Yet, Let Code Test Code</h3>
<p>就是说为了检验一段代码，编写另一段代码去检验它，而不是自己亲自动手检验</p>
<p>In  practice,  this  means  if  we  have  a  function  called  add(),  we  write  an  additional function (usually in separate file) called test_add(). This test_add() function would  call  the  add()  function  with  certain  input,  and  test  that  the  output  is  as expected. In Python, this may look like:</p>
<p><img src="1.png" alt=""></p>
<h4 id="当你写代码时，需要考虑下面三个问题">当你写代码时，需要考虑下面三个问题</h4>
<ul>
<li>这段代码被其他代码引用的次数有多高？</li>
<li>如果这段代码有误，对最终结果的影响有多大</li>
<li>如果错误发生，错误提示有多明显？</li>
</ul>
<p>前两个问题决定了测试这段代码的重要性；第三个问题决定测试的比例（如果报错很明显，也不用去测试）。</p>
<h3 id="1-3-5-Use-Existing-Libraries-Whenever-Possible">1.3.5 Use Existing Libraries Whenever Possible</h3>
<p>Existing open source libraries have two advantages over libraries you write yourself: a</p>
<p>longer history and a wider audience. Both of these advantages translate to fewer bugs.</p>
<p>自己写的代码存在两个问题：</p>
<ol>
<li>没有其他人帮你找bug</li>
<li>你可能没有考虑到所有可能的情况。</li>
</ol>
<h3 id="1-3-6-Treat-Data-as-Read-Only-（好）">1.3.6 Treat Data as Read-Only （好）</h3>
<p>**很多科学家用Excel，很可能不小心改变了一个单元格的数值，然后保存了。**作者强烈不建议在Excel 中修改数据。<strong>相反，应该把所有的数据均视为只读数据，只允许用代码读取数据，然后创造新的结果文件。</strong></p>
<p>为什么这么做？首先，直接修改数据可以会导致不好的结果。比如，你写了一个代码，直接修改源文件，但是在运行过程中，出现错误程序崩了。由于初始文件已经改变了，这就造成了不可逆的结果，没法再用了（除非你有备份）</p>
<p>其次，<strong>当我们原地修改一个文件时，我们很容易忘记当时是怎么修改的</strong>（确实是这样，特别是在excel里）。不像在使用代码的流程中，每一步都有input file 和 output file。原地修改文件后，重新打开文件，我们不知道我们改了啥，这种改变是<strong>不能再现的</strong>。</p>
<p>很棒的想法。我之前在excel 整理表型数据，看来是错了。</p>
<blockquote>
<p>Treating data as read-only may seem counterintuitive to scientists familiar with working extensively in Excel, but it’s essential to robust research (and prevents catastrophe, and  helps  reproducibility).  The  initial  difficulty  is  well  worth  it;  in  addition  to  safe-guarding  data  from  corruption  and  incorrect  changes,  it  also  fosters  reproducibility. Additionally,  any  step  of  the  analysis  can  easily  be  redone,  as  the  input  data  is unchanged by the program.</p>
</blockquote>
<h3 id="1-3-7-Spend-Time-Developing-Frequently-Used-Scripts-into-Tools">1.3.7 Spend Time Developing Frequently Used Scripts into Tools</h3>
<p>对于经常使用的脚本，建议写成 tools 。作者对 tool 的定义是： They are well documented,  have  explicit  versioning,  have  understandable  command-line  arguments,  and  are  kept  in  a  shared  version  control  repository。</p>
<p>说白了，就是要robust 、 要有足够的文档解释、用户友好。</p>
<h3 id="1-3-8-Let-Data-Prove-That-It’s-High-Quality">1.3.8 Let Data Prove That It’s High Quality</h3>
<p>exploratory  data  analysis (探索性数据分析)</p>
<h2 id="1-4-Recommendations-for-Reproducible-Research">1.4 Recommendations for Reproducible Research</h2>
<p>可重复是说<strong>当你做完一项工作很久之后，你可能都忘了细节，这时如果你还需要重新跑一遍时的难易程度</strong>（这个定义比较好）</p>
<h3 id="1-4-1-Release-your-code-and-data">1.4.1 Release your code and data</h3>
<h3 id="1-4-2-Document-everything（好）">1.4.2 Document everything（好）</h3>
<p>**当一个新人进入实验室，他们被告知的第一件事就是保留一个实验记录本。**当很可惜的是，这个好的习惯在数据计算领域被抛弃了。给出代码和数据是结果重现的必要条件，但是足够的记录也是结果可重现的重要成分。为了完整的重现一个研究，分析的每一步都必须足够详细的描述（甚至要超过学术论文的描述）</p>
<p>一个好的习惯是把你的每一步操作都记录在一个<strong>README</strong>的文本文件中，就像一个详细的实验记录本一样，包括了有哪些准备文件，来自哪里，有哪些内容。这个文本文件中还要包括每个软件执行时的参数，软件版本，然后怎么运行的（对我而言，就是命令+软件版本）。</p>
<h3 id="1-4-3-Make-Figures-and-Statistics-the-Results-of-Scripts-（好）">1.4.3 Make Figures and Statistics the Results of Scripts （好）</h3>
<blockquote>
<p>Ensuring that a scientific project is reproducible involves more than just replicability of  the  key  statistical  tests  important  for  findings—supporting  elements  of  a  paper (e.g.,  figures  and  tables)  should  also  be  reproducible.  The  best  way  to  ensure  these components are reproducible is to have each image or table be the output of a script (or scripts).</p>
</blockquote>
<p>这段话的意思是，为了真正的重现每一步，图片和表格也应该是用代码生成的（而不是手动生成的）。</p>
<p><strong>用代码生成图片或者表格可能比在 R 或 excel 里互动地生成这些东西更加耗时</strong>。但是如果你体验需要重新手动生成很多图片时（改了前面的某个步骤），你就会知道这样做的好处。如果你用代码生成图片和代码，可以很轻松地重新跑，节约时间。</p>
<h3 id="1-4-4-Use-Code-as-Documentation">1.4.4 Use Code as Documentation</h3>
<p>对于复杂流程，可能最好的说明文档就是<strong>well-documented code</strong>。</p>
<p>这里就是说一个总的程序（比如sh程序），把所有用到的步骤都串起来，但是要有足够多的注释。</p>
<h1>第2部分 Prerequisites: Essential Skills for Getting Started with a Bioinformatics Project</h1>
<h2 id="2-1-Project-Directories-and-Directory-Structures">2.1 Project Directories and Directory Structures</h2>
<p><strong>一个管理良好的目录结构是生信项目可重复的基础</strong>。</p>
<p>首先，把一个项目的所有文件都放在一个文件夹中。</p>
<p><strong>个人感觉，文件夹深度最好不要超过两层。</strong></p>
<h3 id="2-1-1-What’s-in-a-Name">2.1.1 What’s in a Name?</h3>
<p>给文件或文件夹起名这件事很重要。比如有些人起名时存在空格，这在linux系统内绝对不允许，因为linux是通过空格分隔参数的。</p>
<p>在项目中，代码中经常需要引用其他文件（如数据），如果需要引用其他文件夹的文件，如果你的文件管理很规范，那么<strong>尽量使用相对路径，而不是绝对路径</strong>，因为<strong>绝对路径和你的账户名和目录结构有关</strong>，使得你的工作移植性变差。</p>
<h2 id="2-2-Project-Documentation">2.2 Project Documentation</h2>
<p>除了良好的目录结构外，你还需要良好的记录。记录的方法如下</p>
<ol>
<li>
<p>记录下你的所有方法和workflows</p>
<p><strong>需要把所有的在shell中运行的命令行复制粘贴到文档中</strong>。记录下所有的步骤和参数。</p>
</li>
<li>
<p>记录下你项目中所有数据的来源</p>
<p>不仅仅是实验数据，还包括别人发你的数据，参考基因组等。如果是从网上下载的，需要附上链接。</p>
</li>
<li>
<p>记录下你下载数据的时间</p>
<p>当你从晚上或服务器下载数据时，这个链接的数据将来可能会改变。</p>
</li>
<li>
<p>记录下数据版本信息</p>
</li>
<li>
<p>记录下你下载数据的方式</p>
</li>
<li>
<p>记录下你使用软件的版本（重要）</p>
<p>很多软件通过命令行就能查询版本。如果没有版本，记录下<strong>发行日期，软件链接，下载日期</strong>。</p>
</li>
</ol>
<p>所有的这些信息最好都存储在一个文本格式的README文件。文本文件没有格式，这样在复制命令并重新运行的时候不会出问题。<strong>不要使用word这种带有格式的文件</strong>。</p>
<p>README文件最好放在项目的主文件夹中。下面的描述我感觉真的是<strong>人间真实</strong>。</p>
<blockquote>
<p>These README files don’t necessarily need  to  be  lengthy,  but  they  should  at  the  very  least  explain  what’s  in  this  directory and how it got there. Even this small effort can save someone exploring your project directory a lot of time and prevent confusion. This someone could be your advisor or a  collaborator,  a  colleague  trying  to  reproduce  your  work  after  you’ve  moved  onto  a different lab, or even yourself six months from now when you’ve completely forgotten what you’ve done (this happens to everyone!)</p>
</blockquote>
<p>即使你觉得你能记住所有的数据信息，把所有的信息直接丢到README文件中更简单（当其他人看你做的东西，也不需要给你打电话或发邮件）。</p>
<h2 id="2-3-Use-Directories-to-Divide-Up-Your-Project-into-Subprojects">2.3 Use Directories to Divide Up Your Project into Subprojects</h2>
<h2 id="2-4-Organizing-Data-to-Automate-File-Processing-Tasks">2.4 Organizing Data to Automate File Processing Tasks</h2>
<p>文件命名要规律，方便使用程序自动化运行。</p>
<p>比如有三个玉米样本，A，B，C，各有两个read，可以这么命名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ touch seqs&#x2F;zmays&#123;A,B,C&#125;_R&#123;1,2&#125;.fastq</span><br><span class="line">$ ls</span><br><span class="line">zmaysA_R1.fastq zmaysB_R1.fastq zmaysC_R1.fastq</span><br><span class="line">zmaysA_R2.fastq zmaysB_R2.fastq zmaysC_R2.fastq</span><br><span class="line">#如果你要查找B样本的所有数据，可以使用通配符</span><br><span class="line">$ ls zmaysB*</span><br></pre></td></tr></table></figure>
<p>使用通配符查找文件，这个功能非常强大。</p>
<p>但是如果你的文件命名不一致，通配符就无用了。比如zmays sampleA - 1.fastq, zmays_sampleA-2.fastq,  sampleB1.fastq, sample-B2.fastq。</p>
<h3 id="2-4-1-Leading-Zeros-and-Sorting-文件命名补0-（好）">2.4.1 Leading Zeros and Sorting (文件命名补0)（好）</h3>
<p>如果你的文件名为gene-1.txt, gene-2.txt, ……， gene-14.txt，查找和排序顺序就会是下面这种</p>
<p><img src="2.png" alt="2"></p>
<p>一个有效的方法是开头补0（比如 001 002 014），这样文件就会按正确的顺序排序。</p>
<p>这种方法不仅仅是对于文件命名有用，对于命名基因等也很有用，比如<strong>Ensembl就用这种方式命名基因</strong>（如 ENSG00000164256 ）</p>
<p><img src="3.png" alt="2"></p>
<h2 id="2-5-Markdown-for-Project-Notebooks">2.5 Markdown for Project Notebooks</h2>
<p>项目笔记里要包括计算步骤、为什么这么做的详细信息。</p>
<h3 id="2-5-1-Markdown-Formatting-Basics">2.5.1 Markdown Formatting Basics</h3>
<h3 id="2-5-2-Using-Pandoc-to-Render-Markdown-to-HTML">2.5.2 Using Pandoc to Render Markdown to HTML</h3>
<p>把markdown 转化为html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pandoc --from markdown --to html notebook.md &gt; output.html</span><br></pre></td></tr></table></figure>
<h1>3 Remedial Unix Shell</h1>
<h2 id="3-1-Why-Do-We-Use-Unix-in-Bioinformatics-Modularity-and-the-Unix-Philosophy">3.1 Why Do We Use Unix in Bioinformatics? Modularity and the Unix Philosophy</h2>
<h3 id="Unix-哲学">Unix 哲学</h3>
<p>即模块化开发。Unix 还有一个好处就是兼容各种语言和工具。</p>
<blockquote>
<p>This  is  the  Unix  philosophy:  Write  programs  that  do  one  thing  and  do  it  well.  Write programs  to  work  together.  Write  programs  to  handle  text  streams,  because  that  is  a universal interface.</p>
<p>​																									                                                 —Doug McIlory</p>
</blockquote>
<blockquote>
<p>Unix  was  not  designed  to  stop  its  users  from  doing  stupid  things,  as  that  would  also stop them from doing clever things.</p>
<p>​																																				     —Doug Gwyn</p>
</blockquote>
<h4 id="tail-f">tail -f</h4>
<p>监视重定向的<strong>标准错误文件</strong>。</p>
<p>-f 选项 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。</p>
<h4 id="管道（pipe）">管道（pipe）</h4>
<p>上一个文件的标准输出是下一个文件的标准输入，但是<strong>标准错误还是打印在屏幕上</strong>。管道符不会处理标准错误信息</p>
<p>为什么通过管道符来连接两个程序？而不是把上一个程序的结果写入到一个文件中，然后再由另一个程序读取呢？在很多情况下，生成中间文件有利于debug。</p>
<p>管道符的优点在于计算效率上：<strong>读取和写入文件很耗时</strong>。使用管道符，一直是在内存中读取数据，<strong>而内存读取的速度远快于磁盘</strong>。</p>
<p><strong>实践中，写入和读取数据通常是数据处理的瓶颈</strong>。</p>
<blockquote>
<p>In  practice,  writing  or  reading  from  a  disk  (e.g.,  during  redirection  of standard  output  to  a  file)  is  often  a  bottleneck  in  data  processing.  For  large  next-generation sequencing  data,  this  can  slow  things  down  quite  considerably.  If  you  implement  a clever algorithm that’s twice as fast as an older version, you may not even notice the difference if the true bottleneck is reading or writing to the disk. Additionally, unnecessarily  redirecting  output  to  a  file  uses  up  disk  space.  With  large  next-generation data and potentially many experimental samples, this can be quite a problem.</p>
</blockquote>
<blockquote>
<p>Pipes allow us to build larger, more complex tools from smaller modular parts. It  doesn’t  matter  what  language  a  program  is  written  in,  either;  pipes  will  work between  anything  as  long  as  both  programs  understand  the  data  passed  between them</p>
</blockquote>
<h5 id="实践">实践</h5>
<p>需求：在 FASTA 文件中存在非ATGC的字符，找到这些字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -v &quot;^&gt;&quot; tb1.fasta | \</span><br><span class="line">grep --color -i &quot;[^ATCG]&quot;  </span><br></pre></td></tr></table></figure>
<p>第一句找出不是以 &gt; 开头的行（-v 反转）</p>
<p>\ <strong>反斜杠断行，提高可读性</strong></p>
<p>第二句找出存在非ATGC的行，-i 忽视大小写 --color 用颜色标记匹配上的字符</p>
<p><strong>grep中的查找部分最好加上双引号</strong>，这样能与其他部分区分。</p>
<h4 id="合并管道符和重定向-好">合并管道符和重定向 (好)</h4>
<p>假如我们有两个程序，program1 和 program2 ，program 2 使用 program1 的结果文件作为输入文件，但是这两个程序的标准错误文件都会打印到屏幕上，这会导致屏幕上的信息非常乱。我们可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">program1 input.txt 2&gt; program1.stderr  | \      </span><br><span class="line">program2 2&gt; program2.stderr &gt; results.txt </span><br></pre></td></tr></table></figure>
<h4 id="管道符生成中间文件-tee">管道符生成中间文件 - tee</h4>
<p>管道符本身是不生成中间文件的。但是有时候需要生成中间文件，一是为了 debug ；二是为了 存储耗时比较长的步骤的中间文件（说白了，就是避免报错后完全从头开始）</p>
<p>使用 tee 命令可以做到（翻译成中文是三通管），就像是水管的三通管（T形管）一样，tee 命令一方面将结果传给标准输出，一方面备份生成中间文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">program1 input.txt | tee intermediate-file.txt | program2 &gt; results.txt</span><br></pre></td></tr></table></figure>
<h4 id="后台程序">后台程序</h4>
<h4 id="">&amp;</h4>
<p>这个会打印出来一个 process ID (PID)，这个问题是<strong>如果终端关闭，这个程序也会关闭</strong>。</p>
<blockquote>
<p>Whenever  our  terminal  window  closes,  it  sends  a  hangup signal. Hangup  signals  (also  know  as  SIGHUP)  are  from  the  era  in  which network  connections  were  much  less  reliable.  A  dropped  connection  could  prevent  a  user  from  stopping  an  aberrant,  resource-hungry  process.  To  address  this,  the  hangup  signal  is  sent  to  all processes started from closed terminal. Nearly all Unix command-line programs stop running as soon as they receive this signal. So beware—running a process in the background does not guarantee that it won’t die when your terminal closes. To prevent this, we need to use the tool  nohup or run it from within Tmux.</p>
</blockquote>
<p>这段没看懂，大概是说终端关闭时，会发送一个挂起信号（hangup）。所有的程序接到这个信号就会关闭。</p>
<p>nohup 原来就是不挂起的意思</p>
<h4 id="前台转后台">前台转后台</h4>
<p>第一步先暂停（suspend , 使用快捷键 ctrl + z），第二步使用 bg 命令（background）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ program1 input.txt &gt; results.txt # forgot to append ampersand</span><br><span class="line">$ # enter control-z</span><br><span class="line">[1]+  Stopped                  program1 input.txt &gt; results.txt</span><br><span class="line">$ bg</span><br><span class="line">[1]+ program1 input.txt &gt; results.txt</span><br></pre></td></tr></table></figure>
<h4 id="退出状态">退出状态</h4>
<p>程序退出状态的好处在于运行下一个程序前可以先检查上一个程序的退出状态，如果正常，再进行下一步。</p>
<p>&amp;&amp; 符号 只有前面的程序退出状态是0时，才执行下一步的程序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ program1 input.txt &gt; intermediate-results.txt &amp;&amp; \    </span><br><span class="line">	program2 intermediate-results.txt &gt; results.txt</span><br></pre></td></tr></table></figure>
<p>|| 符号 只有前面的程序运行失败时，才运行下一步，这个用于提示警告信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ program1 input.txt &gt; intermediate-results.txt || \    </span><br><span class="line">	echo &quot;warning: an error occurred&quot;</span><br></pre></td></tr></table></figure>
<p>我觉得这两个都用不上。反正我没有这个习惯，毕竟报错了下一步肯定也运行不下去。这里感觉可读性也不好。</p>
<h4 id="命令替换">命令替换 $()</h4>
<p>这里其实是替换为 $() 中程序运行的结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep -c &#39;^&gt;&#39; input.fasta </span><br><span class="line">416</span><br><span class="line">$ echo &quot;There are $(grep -c &#39;^&gt;&#39; input.fasta) entries in my FASTA file.&quot;</span><br><span class="line">There are 416 entries in my FASTA file</span><br></pre></td></tr></table></figure>
<h5 id="date-创建文件夹">$() + date 创建文件夹</h5>
<p>有一个妙用是按日期创建文件夹（正好满足规范命名的要求，而且 ls 会按日期顺序排列）</p>
<p>这个我可以用 “项目号+日期” 来命名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir results-$(date +%F)</span><br><span class="line">$ ls results-2015-04-13</span><br></pre></td></tr></table></figure>
<h5 id="存储别名（不好）">存储别名（不好）</h5>
<p>你可以将常用的命令用 alias 命令设置个别名，然后把这条命令放在 ~/.bashrc 文件中。</p>
<p>比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alias mkpr&#x3D;&quot;mkdir -p &#123;data&#x2F;seqs,scripts,analysis&#125;&quot;</span><br><span class="line"></span><br><span class="line">alias today&#x3D;&quot;date +%F&quot;</span><br><span class="line"># mkdir results-$(today) </span><br></pre></td></tr></table></figure>
<p>但是，这种做法不要用在脚本中，因为不可移植。</p>
<h1>4 Working with Remote Machines</h1>
<h2 id="4-1-Connecting-to-Remote-Machines-with-SSH">4.1 Connecting to Remote Machines with SSH</h2>
<p>连接远方的服务器最常见的方法是通过 secure shell (SSH)。ssh 首先是安全，其次是在每个UNIX 系统都存在。</p>
<p>第一次使用ssh连接远方的主机时，我们使用如下命令：你需要输入你远方主机账号的密码</p>
<p>ssh 直接输入 ip地址，比如 192.169.237.42；如果你的服务器使用的端口不同（默认22），可以通过 -p 选项修改；如果你远方服务器使用的账号名称和你本地的账号名称不一样，你需要指定账号名称。如果你连接不上远方服务器，你可以使用 -v (冗长信息)选项</p>
<p><img src="12.png" alt=""></p>
<p><img src="13.png" alt=""></p>
<h3 id="4-1-1-Storing-Your-Frequent-SSH-Hosts-好">4.1.1 Storing Your Frequent SSH Hosts (好)</h3>
<p>经常输入IP地址啥的，让人很烦。你可以使用 SSH config file 来储存常用的 host 信息。（这个文件还可以用于 scp 和 rsync 命令）</p>
<p>首先创建文件 ~/.ssh/config</p>
<p>每个目录按照下面这种形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host bio_serv</span><br><span class="line">	 HostName 192.168.237.42     </span><br><span class="line">	 User cdarwin     </span><br><span class="line">	 Port 50453</span><br></pre></td></tr></table></figure>
<p>之后你就可以不用指定port 和 user 。直接使用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh bio_serv</span><br></pre></td></tr></table></figure>
<p>如果你连上了很多个服务器，你可能想知道 hostname ，来确认现在在哪个服务器中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hostname </span><br><span class="line">hostname -i #ip地址</span><br></pre></td></tr></table></figure>
<p>hostname 和 IP地址的区别</p>
<blockquote>
<p>hostname是主机名，用于在系统上标bai识一台机器； IP地址是在tcp/ip网络中du唯一标志一台机器。zhi联系到实际生活。主机dao名相当于你家的主人名，如张三家；而IP地址相当于小区内你家的门牌号，如30号楼2单元302。</p>
</blockquote>
<h2 id="4-2-Quick-Authentication-with-SSH-Keys">4.2 Quick Authentication with SSH Keys</h2>
<p>每次登录远方的账户都要输入密码，这很麻烦，而且可能不安全（可能有人看到你敲键盘，然后记住了）（大神真是严谨！）</p>
<p>一个更安全更快的方式是使用 <strong>SSH public key</strong>。这个好像和密码学有关系。</p>
<p>首先我们需要通过 <strong>ssh-keygen</strong> 命令 创建一个 public/private key pair 。公钥和私钥的区别在于你可以把公钥分享给其他的servers，但是私钥是不能分享的。</p>
<p>这个命令可以不加任何参数，直接加一个-o选项（提高安全性，描述的意思是降低了暴力破解的难度）</p>
<p>然后就会在 ~/.ssh 目录下生成 id_rsa （私钥）和 id_rsa.pub （公钥）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -o</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-o      Causes ssh-keygen to save private keys using the new OpenSSH format<br>
rather than the more compatible PEM format.  The new format has<br>
increased resistance to brute-force password cracking but is not sup‐<br>
ported by versions of OpenSSH prior to 6.5.  Ed25519 keys always use<br>
the new private key format.</p>
<pre><code>  														-- man ssh-keygen
</code></pre>
</blockquote>
<p>为了可以登录你的远方账号而不输入密码，第一步先正常输入密码登录你的远方账号，然后切换目录到 ~/.ssh，然后把你本地目录下的公钥的内容（id_rsa.pub）<strong>追加到</strong> 远方账号的~/.ssh/authorized_keys 文件中（这个文件不存在怎么办？）。</p>
<blockquote>
<p>Again,  be  sure  you’re  using  your  public  key,  and  not  the  private  key.  If  your  private key  ever  is  accidentally  distributed,  this  compromises  the  security  of  the  machines you’ve  set  up  key-based  authentication  on.  The   ~/.ssh/id_rsa private  key  has  read/write  permissions  only  for  the  creator,  and  these  restrictive  permissions  should  be kept this way</p>
</blockquote>
<p>最后一步看不懂，不知道啥意思。这一步完了，之后就不用输入密码了。</p>
<p><img src="14.png" alt=""></p>
<h2 id="4-3-Maintaining-Long-Running-Jobs-with-nohup-and-tmux">4.3 Maintaining Long-Running Jobs with nohup and tmux</h2>
<p>SSH 的方式应该是通过网络的方法连接到服务器，如果网断了，就连不上了，正在跑的程序也中断了（这个时候要用nohup）</p>
<p>使用nohup 的时候<strong>最好把标准输出和标准错误都重定向</strong>（默认是标准输出和标准错误均<strong>追加</strong>到nohup.out，如果重复运行这个程序，nohup.out 会比较乱）。第二，是记录下PID（这是终端关闭后唯一能找到程序的办法）</p>
<p>jobs -l 只能看到当前终端生效的，关闭终端后，在另一个终端jobs已经无法看到后台跑得程序了，此时利用ps（进程查看命令）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -aux|grep chat.js</span><br><span class="line">ps -aux|grep chat.js| grep -v grep</span><br><span class="line">ps -aux|grep chat.js| grep -v grep | awk &#39;&#123;print $2&#125;&#39;</span><br></pre></td></tr></table></figure>
<h2 id="4-4-Working-with-Remote-Machines-Through-Tmux">4.4 Working with Remote Machines Through Tmux</h2>
<p>nohup 的一个替代方法是使用 <strong>terminal multiplexer</strong>。这里我们使用的是 Tmux，但是更流行的是 GNU Screen。这个适合用于远程服务器，所有打开的窗口都是persistent，无论断网或者你自己关闭窗口，都不会影响程序的运行。</p>
<p>之后再看。</p>
<h3 id="4-4-1-Installing-and-Configuring-Tmux">4.4.1 Installing and Configuring Tmux</h3>
<h3 id="4-4-2-Creating-Detaching-and-Attaching-Tmux-Sessions">4.4.2 Creating, Detaching, and Attaching Tmux Sessions</h3>
<h3 id="4-4-3-Working-with-Tmux-Windows">4.4.3 Working with Tmux Windows</h3>
<h1>5 Git for Scientists</h1>
<h2 id="5-1-Basic-Git-Creating-Repositories-Tracking-Files-and-Staging-and-Committing-Changes">5.1 Basic Git: Creating Repositories, Tracking Files, and Staging and Committing Changes</h2>
<p>首先告诉GIT 你是谁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;Sewall Wright&quot;</span><br><span class="line">$ git config --global user.email &quot;swright@adaptivelandscape.org&quot;</span><br></pre></td></tr></table></figure>
<p>GIT 可以通过颜色显示变化（例如红色表示删除，绿色表示新增或修改）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global color.ui true</span><br></pre></td></tr></table></figure>
<h3 id="5-1-1-git-init-and-git-clone-Creating-Repositories">5.1.1 git init and git clone: Creating Repositories</h3>
<p>为了开始使用git，我们需要新建一个文件夹（git repository）。一个 repository 就是一个处于版本控制下的目录，包括当前的文件和过去某个时间节点的快照。这些快照用行话来说就是<strong>commits</strong>。</p>
<blockquote>
<p>With Git, there are two primary ways to create a repository: by initializing one from an  existing  directory,  or  cloning  a  repository  that  exists  elsewhere.  Either  way,  the result is a directory that Git treats as a repository. Git only manages the files and subdirectories  inside  the  repository  directory—it  cannot  manage  files  outside  of  your repository.</p>
</blockquote>
<p><strong>git init</strong></p>
<pre><code>1.  先cd到需要的位置
2.  git init
</code></pre>
<p><strong>git clone</strong></p>
<p>github 是固定格式 <em>user/repository</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git:&#x2F;&#x2F;github.com&#x2F;user&#x2F;repository.git</span><br></pre></td></tr></table></figure>
<h3 id="5-1-2-Tracking-Files-in-Git-git-add-and-git-status-Part-I">5.1.2 Tracking Files in Git: git add and git status Part I</h3>
<p>虽然你创建了repository ，但git并不会跟踪所有的文件（必须手动 git add）。<strong>这一点在生信项目中很有用，生信项目中有很多我们不想追踪的文件，包括数据文件、中间结果文件等</strong>。</p>
<p>在追踪文件中，我们先通过命令<code>git status</code>来查看repo（个人之后用repo作为repository的简写）的状态</p>
<p><img src="4.png" alt=""></p>
<p>然后使用 git add 加入需要追踪的文件（一行可以添加多个文件）</p>
<h3 id="5-1-3-Staging-Files-in-Git-git-add-and-git-status-Part-II">5.1.3 Staging Files in Git: git add and git status Part II</h3>
<p>这里的stage file 的意思是之前使用git add 追踪的文件，如果修改git不会自动获取，还需要进行git add，这就叫做 staging (应该就是暂存的意思)</p>
<blockquote>
<p>Part of the confusion lies in the fact that <strong>git add</strong> both tracks new files and stages the changes made to tracked files.</p>
</blockquote>
<p><img src="5.png" alt=""></p>
<p>如果我们更改了跟踪的文件，而没有进行<code>git add</code>，使用 <code>git status</code>查看结果如下：</p>
<p>提示 README 文件当前状态是 <strong>“Changes not staged for commit”</strong></p>
<p>如果这个时候进行 <code>git commit</code>提交的就是旧的 README 文件，而不是新的文件。</p>
<p><img src="6.png" alt=""></p>
<p>这个给我的提示就是常用<code>git status</code>命令。</p>
<blockquote>
<p>It’s  important  to  be  aware  that  any  modifications  made  to  a  file  since  the  last  time  it was  staged  will  not  be  included  in  the  next  commit  unless  they  are  staged  with  git add.  This  extra  step  may  seem  like  an  inconvenience  but  actually  has  many  benefits.</p>
<p>Suppose  you’ve  made  changes  to  many  files  in  a  project.  Two  of  these  files’  changes are  complete,  but  everything  else  isn’t  quite  ready.  Using  Git’s  staging,  you  can  stage and commit only these two complete files and keep other incomplete files out of your commit.  Through  planned  staging,  your  commits  can  reflect  meaningful  points  in development  rather  than  random  snapshots  of  your  entire  project  directory  (which would likely include many files in a state of disarray). When we learn about committing in the next section, we’ll see a shortcut to stage and commit all modified files</p>
</blockquote>
<h3 id="5-1-4-git-commit-Taking-a-Snapshot-of-Your-Project">5.1.4 git commit: Taking a Snapshot of Your Project</h3>
<p>如果只有一行说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;&quot;</span><br></pre></td></tr></table></figure>
<p>如果有多行说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit</span><br><span class="line">#会弹出界面，然后写入即可</span><br><span class="line">#修改默认编辑器，这里改成emacs</span><br><span class="line">git config --global core.editor emacs</span><br></pre></td></tr></table></figure>
<p>最好不要稍微有些改动就commit，这样会使得你在回顾log文件时很迷惑，整个开发流程不清晰。因此每次commit的版本要有非常清晰的改动和变化，比如添加了某个功能，修改了某个bug。</p>
<p><strong>-a <strong>选项可以将所有已跟踪文件中的执行修改或删除操作的文件都提交到本地仓库（也就是可以跳过 git add），但是</strong>新加的文件（即没有被git系统管理的文件）是不能被提交到本地仓库的。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -a -m “”</span><br></pre></td></tr></table></figure>
<p><strong>我们需要将所有的改变都记录在commit中，并且要有一个清晰的脉络（git commit的注释要足够清晰），方便我们自己看或别人看</strong>。</p>
<h3 id="5-1-5-Seeing-File-Differences-git-diff">5.1.5 Seeing File Differences: git diff</h3>
<p><code>git diff</code>会告诉你工作目录和暂存区（stage）文件的差别。具体提示信息不太懂</p>
<p>如果你修改文件后进行<code>git add</code>，那么<code>git diff</code>不会显示任何不同。</p>
<p><img src="7.png" alt=""></p>
<p>如果你想看暂存和上次commit之间的区别（ compare  what’s  been  staged  to  our  last  commit  ），可以使用<code>git diff --staged</code> 选项。</p>
<h3 id="5-1-6-Seeing-Your-Commit-History-git-log">5.1.6 Seeing Your Commit History: git log</h3>
<p>commits 像一条链状图，每个commit 都指向 它的上一版本</p>
<p><img src="8.png" alt=""></p>
<h3 id="5-1-7-Moving-and-Removing-Files-git-mv-and-git-rm">5.1.7 Moving and Removing Files: git mv and git rm</h3>
<p>对于追踪的文件，GIT希望绝对掌控，因此不能使用默认的mv 和 rm 命令，需要使用 git mv 和 git rm 命令。</p>
<p>比如我们把之前建的 README 添加后缀为 <a href="http://README.md">README.md</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git mv README README.md</span><br><span class="line">$ git mv data&#x2F;README data&#x2F;README.md</span><br></pre></td></tr></table></figure>
<p>使用 git status，我们看到这个重命名已经staged，等待 committed。这里不需要<code>git add</code>,<code>git add</code> 只适用于修改内容的情况.</p>
<p><img src="9.png" alt=""></p>
<blockquote>
<p>Note  that  even  if  you  change  or  remove  a  file  and  commit  it,  it  still  exists  in  past snapshots. Git does its best to make everything recoverable. We’ll see how to recover files later on in this chapter.</p>
</blockquote>
<h3 id="5-1-8-Telling-Git-What-to-Ignore-git-ignore">5.1.8 Telling Git What to Ignore: .git ignore</h3>
<p><code>git status</code> 会告诉你哪些文件是 not tracked。如果不被追踪的文件数目过多，也会造成负担。</p>
<p>如果你想要忽视所有的FASTQ文件（后缀为.fastq），你可以新建一个.gitignore文件，然后在文件中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data&#x2F;seqs&#x2F;*.fastq</span><br></pre></td></tr></table></figure>
<p>最好的办法是将.gitignore文件 上传到版本库</p>
<p>哪些文件应该放进.gitignore文件呢？</p>
<ul>
<li>
<p>大文件</p>
<p>GIT 不适合追踪大文件，貌似忽视后 git clone 就不会复制数据文件了</p>
</li>
<li>
<p>中间文件</p>
</li>
</ul>
<p>global.gitignore 文件可以忽视所有项目中的指定文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global core.excludesfile ~&#x2F;.gitignore_global</span><br></pre></td></tr></table></figure>
<blockquote>
<p>A repository should store everything required to replicate a project except large datasets  and  external  programs.  This  includes  all  scripts,  documentation,  analysis,  and possibly even a final manuscript. Organizing your repository this way means that all of  your  project’s  dependencies  are  in  one  place  and  are  managed  by  Git. In  the  long run, it’s far easier to have Git keep track of your project’s files, than try to keep track of them yourself.</p>
</blockquote>
<p>这段话很有意思。他是说一个分析中，所有文件（除了大的数据和外部程序）都要放在repo中，甚至包括<strong>文章手稿</strong>。这样会形成一个清晰的脉络，你可以清楚地清晰轨迹。</p>
<h3 id="5-1-9-Undoing-a-Stage-git-reset">5.1.9 Undoing a Stage: git reset</h3>
<p>如果你修改了文件，并且使用<code>git add</code>了。这时候你后悔了，想要unstage （这里不回退工作目录的文件），使用如下命令</p>
<p>HEAD 是当前分支的上一个 commit ，这里使用上一个commit 替代了 staging area （index） 的内容</p>
<p>**注意 staging area 也称为 index **</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD README.md</span><br></pre></td></tr></table></figure>
<p><strong>使用 --hard 选项可以一并回滚工作目录的文件</strong></p>
<h2 id="5-2-Collaborating-with-Git-Git-Remotes-git-push-and-git-pull">5.2 Collaborating with Git: Git Remotes, git push, and git pull</h2>
<p>使用git进行合作开发要求我们有一个本地的版本库和一个remote repositories。</p>
<blockquote>
<p>Then, we can retrieve commits from a remote repository (a  pull) and send commits to a remote repository (a push).</p>
</blockquote>
<p>假如你已经在本地提交了几个commits，然后你打算和你的同事分享你的进度，这个工作流程是这样的：</p>
<p><img src="10.png" alt=""></p>
<p><img src="11.png" alt=""></p>
<p>这个过程可以重复，你和你的同事各自独立在自己的本地的repo工作，然后需要共享的时候，push them to the central repository。在大部分情况下，你和你的同事 work on different files or different sections of the same file，Git can automatically figure out how best to merge these changes. 这样你和你的同事可以同事做同一个项目。</p>
<p>注意 <strong>merge conflict</strong>：如果你和同事同时改变了同一个文件的同一部分，那么合并时会产生错误，这个错误只能手动处理。</p>
<h3 id="5-2-1-Creating-a-Shared-Central-Repository-with-GitHub">5.2.1 Creating a Shared Central Repository with GitHub</h3>
<p>上面提到的 central repository 这里主要是用 GitHub</p>
<p>Authenticating with Git Remotes</p>
<h3 id="5-2-2-Authenticating-with-Git-Remotes">5.2.2 Authenticating with Git Remotes</h3>
<p>GitHub 用 SSH keys 来确认你的身份。SSH keys 避免你每次push or pull 都要输入一个密码。</p>
<p>生成公钥的命令见4.2章节，之后复制~/.ssh/id_rsa.pub 的内容，登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容</p>
<h3 id="5-2-3-Connecting-with-Git-Remotes-git-remote">5.2.3 Connecting with Git Remotes: git remote</h3>
<p>现在我们使用 <code>git remote add</code>命令将我们的本地库和github的库连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:username&#x2F;zmays-snps.git</span><br></pre></td></tr></table></figure>
<p>这里 origin 是我们起的github库的名称（貌似惯例都是这个名称）。</p>
<p>实际上你可以连接多个 remote repositories（起不同的名称就行，那么我猜测origin 应该是最重要的remote repos）</p>
<p>如果你要删除一个不用的 remote repository ,你可以使用下面的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote rm &lt;repository-name&gt;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-4-Pushing-Commits-to-a-Remote-Repository-with-git-push">5.2.4 Pushing Commits to a Remote Repository with git push</h3>
<p>你可以不停地和remote repos 分享commits (但是记住，你只做你该做的部分，避免merge conflict)</p>
<p>我们可以把我们的本地 repo <strong>push</strong> 到远方的服务器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push &lt;remote-name&gt; &lt;branch&gt; </span><br><span class="line">#默认是 git push origin master</span><br></pre></td></tr></table></figure>
<h3 id="5-2-5-Pulling-Commits-from-a-Remote-Repository-with-git-pull">5.2.5 Pulling Commits from a Remote Repository with git pull</h3>
<p>你push 了之后，由于 remote repos 更新了，其他人本地的 repos 过时了，他就需要从 remote repos <strong>pull</strong> 到他自己本地的 repos。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull &lt;remote-name&gt; &lt;branch&gt; </span><br><span class="line">#默认是 git pull origin master</span><br></pre></td></tr></table></figure>
<h3 id="5-2-6-Working-with-Your-Collaborators-Pushing-and-Pulling">5.2.6 Working with Your Collaborators: Pushing and Pulling</h3>
<blockquote>
<p>once  you  grow  a  bit  more  acquainted  with  pushing  and  pulling  commits,  it  will become second nature.</p>
</blockquote>
<p>注意事项：</p>
<ol>
<li><strong>pull 前 先 commit 你的本地 repos</strong>，不然会报错，也避免丢失你的工作</li>
<li><strong>pull often</strong>: 也就是不停更新你的本地 repos，使你的工作一直是建立你的同事的最新版本之上。</li>
</ol>
<h3 id="5-2-7-Merge-Conflicts">5.2.7 Merge Conflicts</h3>
<p>作者建议遇到了再看，那就恭敬不如从命了</p>
<h3 id="5-2-8-More-GitHub-Workflows-Forking-and-Pull-Requests">5.2.8 More GitHub Workflows: Forking and Pull Requests</h3>
<p>这里提到的使用一个共享的 central repository 不是 Github推荐的工作流。github的惯用做法是，你先fork别人的repo到自己的账户，修改后再发出一个 <strong>pull request</strong> 请求合并。</p>
<p>这样做的好处是使得<strong>核心管理员</strong>可以决定哪些commits 可以加入到项目中。不像本书提到的流程，每个人都能自由地向 central repos 提交commit，这可能会造成bug。</p>
<h2 id="5-3-Using-Git-to-Make-Life-Easier-Working-with-Past-Commits">5.3 Using Git to Make Life Easier: Working with Past Commits</h2>
<p>我们的 commit history 可以做更多的事：比如比对不同版本文件的区别，回退到旧版本，给某些commits 添加 tag。</p>
<h3 id="5-3-1-Getting-Files-from-the-Past-git-checkout">5.3.1 Getting Files from the Past: git checkout</h3>
<p>git 只要是 commit 之后的任何文件都可以轻易恢复。</p>
<p>比如你不小心重写了 <a href="http://README.md">README.md</a> 的文件内容（通过使用 &gt; ，而不是 &gt;&gt; ）。</p>
<p>但是我们可以通过查询上一个commit 中的文件版本来恢复这个文件，命令如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/piglite/article/details/55328665">https://blog.csdn.net/piglite/article/details/55328665</a></p>
<p>git checkout – filename的作用是把filename文件在工作区的修改撤销到最近一次git add 或 git commit时的内容</p>
<blockquote>
<p>But beware: restoring a file this way erases all changes made to that file since the last commit!  If  you’re  curious,  the  cryptic   –  indicates  to  Git  that  you’re  checking  out  a file, not a branch ( git checkout is also used to check out branches; commands with multiple uses are common in Git)</p>
</blockquote>
<p>这条命令默认是回归到上一次的版本（HEAD）。其实 <code>git checkout</code>可以回退到任何一个版本。</p>
<p>首先通过git log 查看版本号，-n 选项表示查看最近的几条commit</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log -n 3</span><br></pre></td></tr></table></figure>
<p>查到我们想要回退的commit ID之后，可以使用下列命令回退到该版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout 08ccd3b -- README.md</span><br></pre></td></tr></table></figure>
<p>回退之后还可以恢复，只要 commit ID  用最新的就行，比如下面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout 20041ab -- README.md</span><br></pre></td></tr></table></figure>
<p>恢复后使用 <code>git status</code>可以发现没有任何改变</p>
<h4 id="个人理解">个人理解</h4>
<p>这种回退单个文件的方式，我感觉更符合实际。不像那种直接回退整个工作区的文件，过于暴力！</p>
<h3 id="5-3-2-Stashing-Your-Changes-git-stash">5.3.2 Stashing Your Changes: git stash</h3>
<p>git stash 可以保存工作目录下与上次commit 有所改变的文件。</p>
<p>适用的情况是：如果你在这个目录下代码写到一半，突然要去干别的事情，你又不想提交完成一半或者不完善的代码，你就可以使用<code>git stash</code>就可以将你当前未提交到本地（和服务器）的代码推入到Git的栈中，这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修Bug，等到修完Bug，提交到服务器上后，再使用<code>git stash apply</code>将以前一半的工作应用回来。</p>
<p>注意：修改的文件也要保存。</p>
<p>首先，使用 git stash 保存当前目录的已改变的文件（工作目录此时和上一次的commit一致）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>
<p>之后，使用 git stash pop 恢复（貌似这里和 apply 一样）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash pop</span><br><span class="line">git stash apply</span><br></pre></td></tr></table></figure>
<h3 id="5-3-3-More-git-diff-Comparing-Commits-and-Files">5.3.3 More git diff: Comparing Commits and Files</h3>
<p><code>git diff</code>的一个应用使查看任意两个commit之间的区别。比如我们想比较当前commit（HEAD）与 commit <em>dafce75</em> 的区别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff dafce75</span><br></pre></td></tr></table></figure>
<p>可以使用 HEAD^ 这种形式， ^ 表示上一级commit</p>
<p>使用<code>git diff</code>，我们还可以只看某个文件的改变。命令如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff 46f0781 269aa09 README.md</span><br></pre></td></tr></table></figure>
<h3 id="5-3-4-Undoing-and-Editing-Commits-git-commit-amend">5.3.4 Undoing and Editing Commits: git commit --amend</h3>
<p>算了，这个没看懂</p>
<p>如果你上一次的commit的注释打错了，你可以通过下面的命令修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>
<h2 id="5-4-Working-with-Branches">5.4 Working with Branches</h2>
<p>最后一章是Git最伟大的功能：分支。</p>
<p>Git 的 分支是<strong>虚拟</strong>的，也就是创建一个分支不需要真的复制你repos中的文件。分支可以在下面几点帮助你：</p>
<ul>
<li>分支可以让你做<strong>测试</strong>，而不影响主要的分支，master。这种测试我感觉主要是一个临时的想法，比如你想尝试一下那么做，如果结果好就merge到主要分支中；如果不好，就算了，重新切换回master</li>
<li>如果你在开发软件，你可以创建分支来<strong>开发新功能</strong>和<strong>debug</strong></li>
<li><strong>共同开发</strong>：不同的人可以工作在他们各自的分支中，如果他们写的东西过关了，可以merge到 主要的分支</li>
</ul>
<p>这个有点像是</p>
<h3 id="5-4-1-Creating-and-Working-with-Branches-git-branch-and-git-checkout">5.4.1 Creating and Working with Branches: git branch and git checkout</h3>
<p>创建分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch &lt;branchname&gt;</span><br></pre></td></tr></table></figure>
<p>查看当前分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch</span><br><span class="line">git branch --all #查看全部分支（包括 remote branch，比如github）</span><br></pre></td></tr></table></figure>
<p>切换分支（我觉得用git switch更好）(切换前保证工作台干净)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git switch &lt;branchname&gt;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-2-Merging-Branches-git-merge">5.4.2 Merging Branches: git merge</h3>
<p>当我们的两个分支 diverged，我们现在想要合并这两个分支。首先，我们用<code>git switch</code>来回到我们想要合并其他的分支的主分支中（比如 master）。然后，我们使用 git merge <otherbranch> 来合并其他分支的内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git switch master</span><br><span class="line">git merge &lt;otherbranch&gt; </span><br></pre></td></tr></table></figure>
<p>之后我们可以通过 <code>git log</code> 的 --branches 选项来查看所有分支的可视化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --abbrev-commit --pretty&#x3D;oneline --graph --branches -n 2</span><br></pre></td></tr></table></figure>
<h3 id="5-4-3-Branches-and-Remotes">5.4.3 Branches and Remotes</h3>
<p>有点复杂，没看懂，或者说没仔细看，不知道说了啥</p>
<h2 id="5-5-Continuing-Your-Git-Education">5.5 Continuing Your Git Education</h2>
<h1>6 Bioinformatics Data</h1>
<p>生信数据的挑战：</p>
<ul>
<li>检索数据</li>
<li>确保数据的完整性：通过网络下载的数据可能会存在下载中断，在分析前需要先确保数据是完整的</li>
<li>压缩文件操作：由于生信的数据太大了，因此如果处理压缩数据是必备技能</li>
</ul>
<h2 id="6-1-Retrieving-Bioinformatics-Data">6.1 Retrieving Bioinformatics Data</h2>
<p>假如你的测序项目已经完成，你需要下载。通过浏览器下载并不现实，而且你是需要下载到服务器上，而不是本地的电脑上。</p>
<h3 id="6-1-1-Downloading-Data-with-wget-and-curl">6.1.1 Downloading Data with wget and curl</h3>
<p>最通用的两个从网络下载东西的命令是 wegt 和 curl。</p>
<p><strong>wget</strong></p>
<p>wget 的一个好处是可以递归下载（–recursive or -r），wget 甚至会跟踪网页连接会下载文件。默认情况下，wget 只追 5 层 links deep （–level or -l）</p>
<p>这种情况可以下载一个页面的所有文件或者某种类型的文件，比如说你想下载某个页面所有的 GTF 文件，可以使用下面命令</p>
<p><img src=".%5CBioinformatics_Data_Skills%5C15.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget --accept &quot;*.gtf&quot; --no-directories --recursive --no-parent \ </span><br><span class="line">http:&#x2F;&#x2F;genomics.someuniversity.edu&#x2F;labsite&#x2F;annotation.html</span><br></pre></td></tr></table></figure>
<p>貌似，所有的程序都是用反斜杠**\**续行</p>
<p>但是需要注意的是，wegt 的 递归下载十分贪婪，如果不限制，它会下载它能抵达的深度的所有东西。</p>
<p>在这个例子，我们通过两种方式限制它的下载量，–no-parent 阻止 wget 下载更深的页面的文件；-- accept “*.gtf” 只下载后缀为 gtf 的文件</p>
<p>注意，如果用远程服务器的话，下载速度太快可能会被禁，这个时候可以通过 --limit-rate 限制最大速度。</p>
<p><img src=".%5CBioinformatics_Data_Skills%5C16.png" alt=""></p>
<p><strong>Curl</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;[...]&#x2F;goldenPath&#x2F;hg19&#x2F;chromosomes&#x2F;chr22.fa.gz &gt; chr22.fa.gz</span><br></pre></td></tr></table></figure>
<p>这个命令相比于 wget ，就是可以支持更多的协议，比如 SFTP 和 SCP</p>
<h3 id="6-1-2-Rsync-and-Secure-Copy-scp">6.1.2 Rsync and Secure Copy (scp) (?)</h3>
<p>这两个命令应该都是用于<strong>不同服务器之间传输数据</strong>。</p>
<p>Rsync 命令的好处在于它只传输两个文件版本的差异部分，它能在传播时比较文件差异。</p>
<p>基本语法为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rsync source destination </span><br><span class="line">#两个路径都可以使用下面的表达方式 user@host:&#x2F;path&#x2F;to&#x2F;directory&#x2F;.</span><br></pre></td></tr></table></figure>
<p>假如你要将你在 <em>zea_mays/data</em> 中的数据复制到你同事的*/home/deborah/zea_mays/data* 目录下（IP 地址为 <em>192.168.237.42</em> ）</p>
<p>rsync 复制整个文件夹常用的组合选项是 <strong>-avz</strong>，- a 选项 应该允许递归，-z 选项是传输时使用压缩文件，- v (verbose) 打印详细信息。 因为我们是通过 ssh 连接的远程服务器，还要使用一个选项 -e ssh。整条命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rsync -avz -e ssh zea_mays&#x2F;data&#x2F; vinceb@[...]:&#x2F;home&#x2F;deborah&#x2F;zea_mays&#x2F;data</span><br></pre></td></tr></table></figure>
<p>需要注释的是，路径最后的斜杠是有意义的（比如 data/ 和 data）,有斜杠是复制这个文件夹的所有<strong>内容</strong>，而没有斜杠是表示直接复制这个文件夹本身。因为在我们这个例子中，我们是想复制这个文件夹的所有内容，因此要加上最后的斜杠。</p>
<p>但是有的时候，我们只是想复制一个单独的文件（通过SSH），这个时候 Secure copy (scp) 可以比较方便的做到。scp 和 cp 命令一致，但是目的路径要加上HOST 和 PATH</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp Zea_mays.AGPv3.20.gtf 192.168.237.42:&#x2F;home&#x2F;deborah&#x2F;zea_mays&#x2F;data&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-Data-Integrity">6.2 Data Integrity</h2>
<p>下载数据是进行分析的第一步，虽然不太可能，但是下载数据或传输数据的时候可能会出现问题。你可以使用 <em>checksums</em> 来检查传输数据的完整性。<em>checksums</em> 是对数据的总结，哪怕数据只有一丁点的改变，<em>checksums</em> 也会不一样。</p>
<p>数据完整性检查也使用数据版本的跟踪。</p>
<h3 id="6-2-1-SHA-and-MD5-Checksums">6.2.1 SHA and MD5 Checksums</h3>
<p>现在最常用的两种 checksum 算法 就是 MD5 和 SHA-1。Git 的 commit id 就是使用的 SHA-1 算法。 <strong>MD5 是较老的算法，但是使用更加流行</strong></p>
<p>让我们开始用 SHA-1 算法熟悉 checksums。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;bioinformatics is fun&quot; | shasum</span><br></pre></td></tr></table></figure>
<p>我这要使用 <strong>sha1sum</strong></p>
<p>Checksums 是完全确定的（只要输入内容一致）</p>
<p>额，我的电脑同样的内容都是一致的，但是我的checksums 和 教程上显示的不一致（算法不一样？）</p>
<p>求文件的shasum</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sha1sum &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>这样就可以检查传输前后的大文件的checksum是否一致。（速度很快，可行）</p>
<p>如果下载了很多文件，每个文件都挨个检查很繁琐。shasum 提供了一个便捷的方法–它可以创建和验证包含 checksums的文件。我们可以创建 data/ 目录下所有 FASTQ文件的 checksums  ，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sha1sum data&#x2F;*fastq &gt; fastq_checksums.sha</span><br></pre></td></tr></table></figure>
<p>然后可以使用 -c 选项 检查下载的文件 是否和原来的版本一致</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sha1sum -c fastq_checksums.sha</span><br></pre></td></tr></table></figure>
<p><img src=".%5CBioinformatics_Data_Skills%5C17.png" alt=""></p>
<h2 id="6-3-Looking-at-Differences-Between-Data">6.3 Looking at Differences Between Data</h2>
<p>由于你用checksums 发现两个文件不一致，你会想找出两个文件具体不一致在哪。</p>
<p>可以使用 unix 的 diff 命令（但是大文件慎用，因为会很费时间）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">diff -u &lt;file1&gt; &lt;file2&gt;</span><br></pre></td></tr></table></figure>
<p>-u 选项 表示输出格式 为 <em>unified diff format</em>，这种格式最接近 git diff。</p>
<p>具体输出的内容没看懂（说明文字也没太看懂）</p>
<p><img src=".%5CBioinformatics_Data_Skills%5C18.png" alt=""></p>
<p><img src=".%5CBioinformatics_Data_Skills%5C19.png" alt=""></p>
<h2 id="6-4-Compressing-Data-and-Working-with-Compressed-Data">6.4 Compressing Data and Working with Compressed Data</h2>
<p>文件压缩是生信的不可或缺的技术。</p>
<p>压缩比率 = 未压缩的文件大小/压缩文件大小</p>
<p><strong>大部分写好的生信工具都可以直接使用压缩文件作为输入文件，而不需要解压缩。</strong> unix 工具如 cat,grep,less 都有对应的使用压缩文件的变体。<strong>python 的 gzip 模块使得我们可以直接在python读写压缩文件</strong>。</p>
<p>因此当我们分析大规模数据时，使用压缩工具直接处理压缩文件，make lives easier</p>
<h3 id="6-4-1-gzip">6.4.1 gzip</h3>
<p>最常见的压缩命令时 gzip 和 bzip2。<strong>gzip 压缩和解压缩更快；但是 bzip2 压缩比例更高</strong>。一般来说，gzip 用于正常情况下的压缩，而 bzip2用于长期存档的数据。</p>
<p>gzip 有几种使用方式，首先它可以压缩标准输出（也就是原本是打印到屏幕的）。假如我们有一个程序 trimmer ，可以移除 FASTQ 中的 low-quality bases，这个程序可以处理 gzipped 输入文件，但是会将没压缩的内容标准输出到屏幕。使用 gzip 命令，我们可以压缩 它的输出为压缩文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">trimmer in.fastq.gz | gzip &gt; out.fastq.gz</span><br></pre></td></tr></table></figure>
<p>gzip 也可以直接压缩文件（默认原位压缩）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip &lt;filename&gt; #原位压缩</span><br><span class="line">gunzip &lt;filename.zip&gt; #原位解压缩</span><br></pre></td></tr></table></figure>
<p>如果想保留原文件，加 -c 选项（标准输出）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -c &lt;filename&gt; &gt; &lt;filename.zip&gt;</span><br><span class="line">gunzip -c &lt;filename.zip&gt; &gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>gzip 还有一个特征是，你可以将压缩内容直接合并到一个已存在的 gzip 文件中。如果我们想把 <em>in2.fastq</em> 文件的内容压缩之后，追加到 <em>in.fastq.gz</em> 文件中。我们不会先解压 <em>in.fastq.gz</em> 文件，合并两个文件内容，再压缩合并文件，相反我们会这么做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -c in2.fastq &gt;&gt; in.fastq.gz</span><br></pre></td></tr></table></figure>
<p>注意：这里是 &gt;&gt; ，如果误写成 &gt; ，就会覆盖原文件的内容。（使用重定向的时候永远要当心，确保你使用了正确的符号，而且<strong>一定要有文件备份</strong>）。</p>
<h3 id="6-4-2-Working-with-Gzipped-Compressed-Files">6.4.2 Working with Gzipped Compressed Files</h3>
<p>有很多命令和工具可以直接处理压缩文件，比如 zgrep, zcat, zless, zdiff……。</p>
<p><strong>如果有的程序不能处理压缩文件，你可以使用 zcat 打印出来，然后使用管道符处理。</strong></p>
<p>使用z系列的结果和正常一样，但是就是稍微费一点CPU而已（实际过程还是要先解压）。</p>
<h2 id="6-5-Case-Study-Reproducibly-Downloading-Data">6.5 Case Study: Reproducibly Downloading Data</h2>
<p>当我们通过网络下载一些基因组数据（测序数据、注释数据等），这个网页的内容将来可能会有变化（数据可能会更新）。</p>
<p>为了能够完整复现，我们要记录所有的东西。</p>
<p><strong>记录你的下载时间，下载了什么东西，命令，还有文件的checksums</strong></p>
<p>这个要养成习惯，有点难度</p>
<h1>第3部分 Practice: Bioinformatics Data Skills</h1>
<h1>7 Unix Data Tools</h1>
<h2 id="7-1-Unix-Data-Tools-and-the-Unix-One-Liner-Approach-Lessons-from-Programming-Pearls">7.1 Unix Data Tools and the Unix One-Liner Approach: Lessons from Programming Pearls</h2>
<h2 id="7-2-When-to-Use-the-Unix-Pipeline-Approach-and-How-to-Use-It-Safely">7.2 When to Use the Unix Pipeline Approach and How to Use It Safely</h2>
<p>有些工作适合使用linux的one-liner （管道符连接的多个linux命令），有些适合自己写脚本完成。</p>
<blockquote>
<p>As with most tasks in bioinformatics, choosing the most suitable approach can</p>
<p>be half the battle.</p>
</blockquote>
<p>unix 管道符命令适用于探索数据，转换格式，检查错误等。</p>
<blockquote>
<p>Many  tasks  in  bioinformatics  are  of  this  nature:  we  want  to  get  a  quick  answer  and keep moving forward with our project. We could write a custom script, but for simple tasks  this  might  be  overkill  and  would  take  more  time  than  necessary.  As  we’ll  see later  in  this  chapter,  building  Unix  pipelines  is  fast:  we  can  iteratively  assemble  and test Unix pipelines directly in the shell.</p>
<p>For larger, more complex tasks it’s often preferable to write a custom script in a language  like  Python  (or  R  if  the  work  involves  lots  of  data  analysis).  While  shell approaches (whether a one-liner or a shell script) are useful, these don’t allow for the same  level  of  flexibility  in  checking  input  data,  structuring  programs,  use  of  data structures,  code  documentation,  and  adding  assert  statements  and  tests  as  languages like Python and R. In  contrast,  lengthy  Unix  pipelines can be fragile and less robust than a custom script.</p>
</blockquote>
<p>one-liner 还有一个问题是，由于我们直接在shell中敲命令，然后容易丢失记录，影响 reproducibility。把 piplines 写入脚本是一种好方法，可以rerun。</p>
<h2 id="7-3-Inspecting-and-Manipulating-Text-Data-with-Unix-Tools">7.3 Inspecting and Manipulating Text Data with Unix Tools</h2>
<p>常见的文本文件很多是 tab 分隔的，因为很多linux 命令，比如 cut 和 awk 都是默认将 tab 视为分隔符的。（blupf90 是个怪胎！）。</p>
<p>文本文件有三种格式：<strong>tab分隔、逗号分隔、空格分隔。</strong></p>
<p>tab 分隔最常用：例如  BED,  GTF/GFF,  SAM,  tabular  BLAST  output,  and  VCF。tab分隔的文件每个字段之间只有一个tab符号（\t）。</p>
<p>逗号分隔的文件（comma-separated values CSV）是另一种格式。</p>
<p>最后是以空格分隔的文件。一些顽固的生信程序使用<strong>可变数量的空格</strong>来分隔列。<strong>一般来说，使用tab或逗号分隔，比使用空格分隔要好，因为文件内容中可能会包含空格</strong>。</p>
<h3 id="7-3-1-Inspecting-Data-with-Head-and-Tail">7.3.1 Inspecting Data with Head and Tail</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">head &lt;filename&gt;</span><br><span class="line">head -n 3 &lt;filename&gt;</span><br><span class="line"></span><br><span class="line">tail -n 3 &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>tail 命令还可以用来去除标题行，如果 -n 选项后面的数字含有 + 号，tail 就会从第n 行开始。</p>
<p>比如，剔除第一行（标题），可以使用以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -n +2 &lt;filename&gt; </span><br></pre></td></tr></table></figure>
<p>**head 还可以用在检查以下 pipeline 的结果是否正常。**比如我们先从 gtf 文件查找包含某个基因的行，然后再做下一步处理前，我们想先看一下输出结果，确保正常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &#39;gene_id &quot;ENSMUSG00000025907&quot;&#39; Mus_musculus.GRCm38.75_chr1.gtf | head -n 1</span><br></pre></td></tr></table></figure>
<p>在打印了前几行数据后，the head process exits。</p>
<blockquote>
<p>when <em>head</em> exits, your shell catches this and stops the <em>entire</em> pipe, including the <em>grep</em> process too. Under the hood, your shell sends a signal to other programs in the pipe called SIGPIPE – much like the signal that’s sent when you press Control-c (that signal is SIGINT).</p>
</blockquote>
<p>当你使用很大的数据集，很复杂的pipeline ，这尤其重要。例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &quot;some_string&quot; huge_file.txt | program1 | program2 | head -n 5</span><br></pre></td></tr></table></figure>
<p>当打印前五行之后，grep 不再运行，program1 program2 也停止运行。</p>
<h3 id="7-3-2-less">7.3.2 less</h3>
<p>实用的</p>
<ul>
<li>g 返回首行</li>
<li>/   查找字符
<ul>
<li>n 下一个查找结果</li>
<li>N 上一个查找结果</li>
</ul>
</li>
</ul>
<p><img src=".%5CBioinformatics_Data_Skills%5C20.png" alt=""></p>
<p>less 还可以用来 <strong>debug</strong> 你的 pipelines ，或者构建 pipelines</p>
<p>这样做的好处是，当less 能够展示一个全屏的结果时，<strong>整个流程会暂停</strong>。这样我们不用担心会占用过多的电脑性能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">step1 input.txt | less</span><br><span class="line">step1 input.txt | step2 | less</span><br><span class="line">step1 input.txt | step2 | step3 | less</span><br></pre></td></tr></table></figure>
<h3 id="7-3-3-Plain-Text-Data-Summary-Information-with-wc-ls-and-awk（好）">7.3.3 Plain-Text Data Summary Information with wc, ls, and awk（好）</h3>
<p>查看文件大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -lh # -h 以人类的方式显示大小</span><br></pre></td></tr></table></figure>
<p><code>wc -l</code>统计的行数包括末尾的空行，但是最后一行如果没有换行符，也是不统计的。</p>
<p>比如下面这个文件，最后一行没有换行符，在notpad++里显示为12行，但是<code>wc -l</code>显示为11行，<strong>即没有换行符的行不视为一行</strong>。</p>
<p>**notpad++ 显示的行数 = linux 行数 + 1 **</p>
<p><img src=".%5CBioinformatics_Data_Skills%5C21.png" alt=""></p>
<p>如果我增加几行空行，<code>wc-l</code> 显示为 13行</p>
<p><img src=".%5CBioinformatics_Data_Skills%5C23.png" alt=""></p>
<p>如果要显示<strong>非空行</strong>的行数 （里面的正则没看懂）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -c &quot;[^ \\n\\t]&quot; &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>显示字段数目，下面这个命令只打印第一行的字段数，这里指定了分隔符为tab。</p>
<p>但是由于这个文件有注释，这条命令没有作用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk -F &quot;\t&quot; &#39;&#123;print NF; exit&#125;&#39; Mus_musculus.GRCm38.75_chr1.bed</span><br></pre></td></tr></table></figure>
<p>首先我们要去除前面的注释部分，再使用 awk 来做：</p>
<p><img src=".%5CBioinformatics_Data_Skills%5C24.png" alt=""></p>
<p>但是这种方式很脆弱，因为不同文件的注释行数目不同，我们可以通过 grep 命令，可以剔除以#号开头的行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -v &quot;^#&quot; Mus_musculus.GRCm38.75_chr1.gtf | head -n 3</span><br></pre></td></tr></table></figure>
<h3 id="7-3-4-Working-with-Column-Data-with-cut-and-Columns">7.3.4 Working with Column Data with cut and Columns</h3>
<p>有些时候我们只想看某些列的内容，这个时候我们可以使用cut命令（默认分隔符为tab）(其实awk也可以)，例如只看第二列（-f 指定字段，也可以指定字段的区域，<strong>例如 -f 3-8 （首尾都包括）  或 -f 3,5,8</strong> 但是只能按照文件中的顺序提取，例如 -f 6,5,4,3 并不起作用，如果要打乱顺序提取，需要使用 awk）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cut -f 2 Mus_musculus.GRCm38.75_chr1.bed | head -n 3</span><br></pre></td></tr></table></figure>
<p>通过联合使用 grep 和 cut 命令，可以提取GTF文件中的染色体、起始位置、终止位置三列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -v &quot;^#&quot; Mus_musculus.GRCm38.75_chr1.gtf | cut -f1,4,5 | head -n 3</span><br></pre></td></tr></table></figure>
<p>cut 可以通过 -d 指定分隔符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cut -d, -f2,3 Mus_musculus.GRCm38.75_chr1_bed.csv | head -n 3</span><br></pre></td></tr></table></figure>
<h4 id="cut-切割空格分隔的文件">cut 切割空格分隔的文件</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cut -d &#x27; &#x27; -f 1 filename</span><br></pre></td></tr></table></figure>
<p>但是 cut 只允许间隔符是一个字符，如果间隔符是多个空格，就不能这么做了。需要用 sed 先把多个空格替换为一个空格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -r &#39;s&#x2F;\s+&#x2F; &#x2F;g&#39; filename | cut -d &#39; &#39; -f 1</span><br></pre></td></tr></table></figure>
<h4 id="cut-提取连续多列">cut 提取连续多列</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cut -d &#x27; &#x27; -f2,7- filename</span><br></pre></td></tr></table></figure>
<p><code>7-</code> 表示从第7列到最后一列，如果是<code>-7</code> ，则表示前7列。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cut -d &#x27; &#x27; -f 3-5 filename</span><br></pre></td></tr></table></figure>
<p>提取第3列，第4列，第5列。</p>
<h3 id="7-3-5-Formatting-Tabular-Data-with-column">7.3.5 Formatting Tabular Data with column</h3>
<p>当我们处理tab分隔的文件时，有的时候不好看某个元素属于第几列（就是每一列的元素不对齐）。</p>
<p><img src=".%5CBioinformatics_Data_Skills%5C25.png" alt=""></p>
<p>这里有一个解决办法是 <code>column -t</code> (-t 选项告诉 column 将数据视为表格)，之后数据每一列看上去就对齐了（注意：这只能用于可视化，而不能真的用于改变数据格式，不然影响了电脑对数据的可读性）(write code for human , write data for computers )</p>
<blockquote>
<p>这让我想到了最近处理一些excel表，里面有各种格式（合并单元格，居中……），用程序处理很麻烦，这就是违背了<strong>write data for computers</strong>的原则，相反是 write data for human 。</p>
</blockquote>
<p><img src=".%5CBioinformatics_Data_Skills%5C26.png" alt=""></p>
<p>column 默认分隔符也是 \t，可以通过 -s 选项更改分隔符。</p>
<h3 id="7-3-6-The-All-Powerful-Grep">7.3.6 The All-Powerful Grep</h3>
<p>grep 速度很快，如果你想要查找文件中某种 pattern ，grep 会比你写的所有python脚本都要快。对比4种查找文件内容的命令或程序中（grep,sed,awk,Python script）, grep 速度最快，比第二名还要快5倍。</p>
<p>这是由于 grep 是<strong>专门化</strong>的查找文件内容的命令。这提示我们，如果你要提高速度，unix 的专门处理这个需求的命令一般来说速度是最快的</p>
<p><img src=".%5CBioinformatics_Data_Skills%5C27.png" alt=""></p>
<p>grep 的基本用法：grep 需要两个参数，<strong>pattern</strong>（需要查找的字符或正则表达式），<strong>文件名称</strong>。最简单的用法如下，pattern 的引号是非必须的，但建议还是加上双引号，更加安全。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &quot;Olfr418-ps1&quot; Mus_musculus.GRCm38.75_chr1_genes.txt</span><br></pre></td></tr></table></figure>
<p>grep 的一个常用选项是 <code>--color=auto</code>，这个选项可以让终端中匹配的部分显示颜色（我现在的服务器默认就有）</p>
<p>如果我们想查找 包含”Olfr” ，但是不包含 “Olfr1413” 的行，我们可以使用以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep Olfr Mus_musculus.GRCm38.75_chr1_genes.txt | grep -v Olfr1413</span><br></pre></td></tr></table></figure>
<p>但是这个命令可能会出问题，因为 <strong>grep 是部分匹配</strong>，这里我们只想剔除 “Olfr1413” 的行，但是这个命令也会一并剔除像 “Olfr1413a” 和  “Olfr14130“ 这种名称的基因。</p>
<p><strong>我们可以使用 -w 来匹配全词（两边都是空格）</strong>。这个说法不准确，应该是 非单词构成字符（除字母、数字、下划线的其他字符），<code>man grep</code> 官方文档见下</p>
<blockquote>
<p>-w, --word-regexp<br>
Select only those lines containing matches that form whole words.  The test is that the matching substring must either be at the beginning of the line, or preceded  by  a  non-word  constituent character.   Similarly,  it  must  be  either  at  the end of the line or followed by a non-word constituent character.  Word-constituent characters are letters, digits, and the underscore.</p>
</blockquote>
<p><img src=".%5CBioinformatics_Data_Skills%5C28.png" alt=""></p>
<p>一般情况下，我们都要加 -w 选项来限制匹配，来避免错误的部分匹配。</p>
<p>grep 支持正则表达式（POSIX Basic Regular Expressions (BRE)）,这种匹配方式貌似是阉割版。但在一些简单的应用中可以完美工作。</p>
<p>举例，你想查找 Ensembl gene id 是  “Olfr1413”  或者  “Olfr1411”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &quot;Olfr141[13]&quot; Mus_musculus.GRCm38.75_chr1_genes.txt</span><br></pre></td></tr></table></figure>
<p>如果你想查找 “Olfr218”  and  “Olfr1416” ，上面这种就没办法了，你可以使用</p>
<p>POSIX Extended Regular Expressions （ERE），具体方式是 使用 -E 选项 （或 egrep）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -E &quot;(Olfr1413|Olfr1411)&quot; Mus_musculus.GRCm38.75_chr1_genes.txt</span><br></pre></td></tr></table></figure>
<p>grep 有一个选项 -c ，用于统计匹配到 pattern 的行数</p>
<p>这个选项很实用，比如我们想看一个gtf文件里有多少 small nuclear RNA</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -c &#39;gene_biotype &quot;snRNA&quot;&#39; Mus_musculus.GRCm38.75_chr1.gtf</span><br></pre></td></tr></table></figure>
<p>grep 默认是打印存在pattern的整行，有时我们需要只打印匹配上的字段，这个时候我们就可以使用 -o 选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep -o &quot;Olfr.*&quot; Mus_musculus.GRCm38.75_chr1_genes.txt | head -n 3</span><br><span class="line">0lfr1416</span><br><span class="line">Olfr1415</span><br><span class="line">0lfr1414</span><br></pre></td></tr></table></figure>
<p>假如我们想挑出某个gtf文件的所有基因：这里 -E 采用拓展正则， -o 只打印匹配字符，\w 表示[a-z A-Z 0-9 _]， 注意这里\w+ 有引号，所以匹配的字符是有引号的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep -E -o &#39;gene_id &quot;\w+&quot;&#39; Mus_musculus.GRCm38.75_chr1.gtf | head -n 5</span><br><span class="line"># 这里查找的字符内有双引号，外面只能用单引号，用双引号不行（老shell了）</span><br><span class="line">gene_id &quot;ENSMUSG00000090025&quot;</span><br><span class="line">gene_id &quot;ENSMUSG00000090025&quot;</span><br><span class="line">gene_id &quot;ENSMUSG00000090025&quot;</span><br><span class="line">gene_id &quot;ENSMUSG00000064842&quot;</span><br><span class="line">gene_id &quot;ENSMUSG00000064842&quot;</span><br></pre></td></tr></table></figure>
<p>但是gtf中有很多功能区域会匹配到同一基因 (基因，外显子，起始密码子)，下面这个pipeline 就是处理找到的基因结果，去重排序（妙啊）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep -E -o &#39;gene_id &quot;(\w+)&quot;&#39; Mus_musculus.GRCm38.75_chr1.gtf | \</span><br><span class="line">	cut -f2 -d&quot; &quot; | \</span><br><span class="line">    sed &#39;s&#x2F;&quot;&#x2F;&#x2F;g&#39; | \</span><br><span class="line">    sort | \</span><br><span class="line">    uniq &gt; mm_gene_id.txt</span><br></pre></td></tr></table></figure>
<h4 id="grep-选项小结">grep 选项小结</h4>
<ul>
<li>-v 反向查找</li>
<li>-w 全词匹配（前后必须为空格或tab）</li>
<li>-c 打印匹配行数</li>
<li>-o 打印匹配字符</li>
<li>-r 文件夹内递归搜索</li>
</ul>
<h3 id="7-3-7-Decoding-Plain-Text-Data-hexdump">7.3.7 Decoding Plain-Text Data: hexdump</h3>
<p>查看文件编码：<code>file</code></p>
<p>注意：由于UTF-8 编码包含了ASCII码，因此如果UTF-8文件中不包含特殊字符（比如中文），<code>file</code>命令会将文件解释为 ASCII 编码。</p>
<h3 id="7-3-8-Sorting-Plain-Text-Data-with-Sort">7.3.8 Sorting Plain-Text Data with Sort</h3>
<p>sort 不加参数，是<strong>按每一行的ASCII码顺序排列</strong>，比如下面的例子，每一行一个字符字符的比较。</p>
<p><img src="29.png" alt="29"></p>
<p>不同的分隔符，比如CSV文件，使用 <code>-t&quot;,&quot;</code></p>
<p>这里可以看到，第二列的顺序是乱的，可以使用-k 选项；下面这两种格式都可以，第一种方式的-k 后面的1,1 表示初始列和最终列。但是两种方式不能混用（老shell了）</p>
<p>但是 -n 放在最前面表示所有列均按照数字大小排序，放在 -k2,2n 表示只有第二列按数字大小排列。</p>
<p><strong>第一种更全，以后固定使用第一种</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort -k1,1 -k2,2n example.bed</span><br><span class="line">$ sort -n -k 1 -k 2 example.bed</span><br></pre></td></tr></table></figure>
<p>sort 过程可能十分耗时，可以通过 -c 选项检查文件是否已按要求排序完毕。应该没有输出表示为排序好的文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort -k1,1 -k2,2n -c example_sorted.bed </span><br><span class="line">$ echo $?</span><br><span class="line">0</span><br><span class="line">$ sort -k1,1 -k2,2n -c example.bed </span><br><span class="line">sort: example.bed:4: disorder: chr1     40      49</span><br><span class="line">$ echo $?1</span><br></pre></td></tr></table></figure>
<p>可以通过 -r 选项逆序排列（正常时从小到大，递增）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort -k1,1 -k2,2n -r example.bed</span><br></pre></td></tr></table></figure>
<p>如果只想某一列逆序，可以只将 r 选项加到那一列中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort -k1,1 -k2,2nr example.bed</span><br></pre></td></tr></table></figure>
<p>但是，对于既有字符又有数字的列，刚刚的排序方式可能就不一样了，下面的染色体超过了10，可以看到染色体排序是不对的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort -k1,1 -k2,2n example2.bed</span><br><span class="line">chr1    34      49</span><br><span class="line">chr10   30      42</span><br><span class="line">chr10   31      47</span><br><span class="line">chr11   6       16</span><br><span class="line">chr2    15      19</span><br><span class="line">chr2    17      22</span><br><span class="line">chr2    27      46</span><br><span class="line">chr22   32      46</span><br></pre></td></tr></table></figure>
<p>也不能使用 -n 选项，使用 -n 选项如下图，彻底是乱的，完全没逻辑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort -k1,1n -k2,2n example2.bed</span><br><span class="line">chr11   6       16</span><br><span class="line">chr2    15      19</span><br><span class="line">chr2    17      22</span><br><span class="line">chr2    27      46</span><br><span class="line">chr10   30      42</span><br><span class="line">chr10   31      47</span><br><span class="line">chr22   32      46</span><br><span class="line">chr1    34      49</span><br></pre></td></tr></table></figure>
<p>这时，需要使用 <code>-V</code> 选项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort -k1,1V -k2,2n example2.bed</span><br><span class="line">chr1    34      49</span><br><span class="line">chr2    15      19</span><br><span class="line">chr2    17      22</span><br><span class="line">chr2    27      46</span><br><span class="line">chr10   30      42</span><br><span class="line">chr10   31      47</span><br><span class="line">chr11   6       16</span><br><span class="line">chr22   32      46</span><br></pre></td></tr></table></figure>
<p>linux 的 sort 命令可以很好的用于中等大小的数据。sort 命令的一个特征时如果文件太大，超过内存，那么sort 命令会将中间文件存储在磁盘中。对于大数据而言，对磁盘中的中间文件的读写操作会是一个瓶颈（磁盘的速度很慢）。我们可以通过<strong>设置sort使用的内存大小</strong>来提高sort命令的内存占用量，避免它把数据存储为中间文件。例如，下式，-S 选项就是设置内存大小的，它能够获知后缀，比如 K、G，这里设置为2G，也可以设置为所有内存的百分比（-S 50%）</p>
<p>sort 还有一个选项支持并发计算。下式中就使用了4核。</p>
<p>但是小数据的话不需要额外设置，因为实际上并发计算存在一个固定的成本，因此如果运行小数据速度可能更慢。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort -k1,1 -k4,4n -S2G Mus_musculus.GRCm38.75_chr1_random.gtf</span><br><span class="line">$ sort -k1,1 -k4,4n --parallel 4 Mus_musculus.GRCm38.75_chr1_random.gtf</span><br></pre></td></tr></table></figure>
<h4 id="Sorting-Stability">Sorting Stability</h4>
<p>当存在所有的sort keys 都相同的行，sort 仍会按照它们整行的顺序排列这些行的顺序。如果你想让这些行之间的顺序与源文件的顺序一致（即不要改变），可以使用 -s 选项。</p>
<h4 id="sort-遇到科学计数法结果不可靠">sort 遇到科学计数法结果不可靠</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -n +2 maf.frq | sort -k5,5nr | less -S</span><br></pre></td></tr></table></figure>
<p>我想按第5列，从大到小排列。</p>
<p>但是结果跑出来一开始是非常小的数，然后才是从大到小排列。但是用<strong>python</strong> 就没问题。</p>
<p><img src="40.png" alt="29"></p>
<h3 id="7-3-9-Finding-Unique-Values-in-Uniq">7.3.9 Finding Unique Values in Uniq</h3>
<p>uniq 会移除连续的重复行（保留一个）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat letters.txt</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">C</span><br><span class="line">C</span><br><span class="line">$ uniq letters.txt</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure>
<p>因此，如果需要真正去重，需要先sort。</p>
<p>使用 -c 选项可以查看每一行出现的次数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort letters.txt | uniq -c   </span><br><span class="line">2 A   </span><br><span class="line">2 B   </span><br><span class="line">4 C</span><br></pre></td></tr></table></figure>
<p>通过与 grep、cut 命令合用，uniq 命令可以用来查来某一列所有水平的重复次数（分类数据）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep -v &quot;^#&quot; Mus_musculus.GRCm38.75_chr1.gtf | cut -f3 | sort | uniq -c</span><br><span class="line">25901 CDS</span><br><span class="line">7588 UTR</span><br><span class="line">36128 exon</span><br><span class="line">2027 gene</span><br><span class="line">2290 start_codon</span><br><span class="line">2299 stop_codon</span><br><span class="line">4993 transcript</span><br></pre></td></tr></table></figure>
<p>因为 sort 和 uniq 都是行处理的命令，<strong>我们可以人为创造新的行</strong>，作为sort 和 cut 的输入（比如 通过 cut）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep -v &quot;^#&quot; Mus_musculus.GRCm38.75_chr1.gtf | cut -f3,7 | sort | uniq -c</span><br><span class="line">12891  CDS          +</span><br><span class="line">13010  CDS          -</span><br><span class="line">3754   UTR          +</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>uniq 还可以通过 -d 选项 来检查文件是否存在重复。-d 会打印存在重复的行，之后再通过 <code>wc -l</code> 就可以查看是否有重复行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort letters.txt | uniq -d</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">$ sort letters.txt | uniq -d | wc -l</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="7-3-10-Join">7.3.10 Join</h3>
<p>join 命令可以通过一个相同的列合并不同的文件。比如存在下面两个文件，我们想把第二个文件的内容合并到第一个文件里（相同的字段是染色体；结果文件是一个tab分隔的文件）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat example.bed</span><br><span class="line">chr1    26      39</span><br><span class="line">chr1    32      47</span><br><span class="line">chr3    11      28</span><br><span class="line">chr1    40      49</span><br><span class="line">chr3    16      27</span><br><span class="line">chr1    9       28</span><br><span class="line">chr2    35      54</span><br><span class="line">chr1    10      19</span><br><span class="line">$ cat example_lengths.txt</span><br><span class="line">chr1    58352</span><br><span class="line">chr2    39521</span><br><span class="line">chr3    24859</span><br></pre></td></tr></table></figure>
<p>首先，我们要对两个文件按照染色体进行 sort，join命令没法处理没有排序的文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort -k1,1 example.bed &gt; example_sorted.bed</span><br><span class="line">$ sort -c -k1,1 example_lengths.txt # verifies is already sorte</span><br></pre></td></tr></table></figure>
<p>然后，我们就可以使用<code>join</code>命令了，基本语法如下，字段表示为列数。输出的字段顺序与给定的文件顺序一致。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">join -1 &lt;file_1_field&gt; -2 &lt;file_2_field&gt; &lt;file_1&gt; &lt;file_2&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ join -1 1 -2 1 example_sorted.bed example_lengths.txt</span><br><span class="line">chr1 10 19 58352</span><br><span class="line">chr1 26 39 58352</span><br><span class="line">chr1 32 47 58352</span><br><span class="line">chr1 40 49 58352</span><br><span class="line">chr1 9 28 58352</span><br><span class="line">chr2 35 54 39521</span><br><span class="line">chr3 11 28 24859</span><br><span class="line">chr3 16 27 24859</span><br><span class="line"></span><br><span class="line">$ join -1 1 -2 1 example_lengths.txt example_sorted.bed</span><br><span class="line">chr1 58352 10 19</span><br><span class="line">chr1 58352 26 39</span><br><span class="line">chr1 58352 32 47</span><br><span class="line">chr1 58352 40 49</span><br><span class="line">chr1 58352 9 28</span><br><span class="line">chr2 39521 35 54</span><br><span class="line">chr3 24859 11 28</span><br><span class="line">chr3 24859 16 27</span><br></pre></td></tr></table></figure>
<p>但是如果第二个文件没有 chr3 怎么办呢，可以看到 <code>join</code> 实行内连接，剔除了 chr3 的行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ head -n2 example_lengths.txt &gt; example_lengths_alt.txt # truncate file</span><br><span class="line">$ join -1 1 -2 1 example_sorted.bed example_lengths_alt.txt</span><br><span class="line">chr1 10 19 58352</span><br><span class="line">chr1 26 39 58352</span><br><span class="line">chr1 32 47 58352</span><br><span class="line">chr1 40 49 58352</span><br><span class="line">chr1 9 28 58352</span><br><span class="line">chr2 35 54 39521</span><br><span class="line">$ join -1 1 -2 1 example_sorted.bed example_lengths_alt.txt | wc -l</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<p>我们可以通过 -a 选项（需要指定哪个文件可以包含没有匹配的行）来包括没有匹配的行（左连接或右连接）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ join -1 1 -2 1 -a 1 example_sorted.bed example_lengths_alt.txt # GNU join only</span><br><span class="line">chr1  10  19  58352</span><br><span class="line">chr1  26  39  58352</span><br><span class="line">chr1  32  47  58352</span><br><span class="line">chr1  40  49  58352</span><br><span class="line">chr1  9   28  58352</span><br><span class="line">chr2  35  54  39521</span><br><span class="line">chr3  11  28</span><br><span class="line">chr3  16  27</span><br></pre></td></tr></table></figure>
<h3 id="7-3-11-Text-Processing-with-Awk">7.3.11 Text Processing with Awk</h3>
<p>格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;&#125; /search pattern/&#123;action&#125; END&#123;&#125;&#x27; file </span><br></pre></td></tr></table></figure>
<p>工作原理：</p>
<ol>
<li>
<p>运行 BEGIN</p>
</li>
<li>
<p>每次输入一行，赋给内部变量 $0</p>
</li>
<li>
<p>按 <strong>空格/制表符</strong> 将每一行分解为字段，赋给 <img src="https://math.now.sh?inline=1-" style="display:inline-block;margin: 0;"/>n</p>
</li>
<li>
<p>search pattern 和 action 必选其一</p>
<p>如果没有 search pattern ， 则对所有行均执行 action 操作</p>
<p>如果没有 action，则默认打印改行</p>
</li>
</ol>
<p>行数：NR (row) ,  列数：NF (<strong>field</strong>)</p>
<p>简单匹配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;&#123; print $0 &#125;&#39; example.bed</span><br><span class="line">$ awk &#39;&#123; print $2 &quot;\t&quot; $3 &#125;&#39; example.bed</span><br></pre></td></tr></table></figure>
<p>simple pattern matching</p>
<p>假设我们想打印结束位置与起始位置大于18的行，awk 支持算术运算符 <strong>+ - * / % ^</strong> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39; $3 - $2 &gt; 18&#39; example.bed</span><br><span class="line">chr1    9       28</span><br><span class="line">chr2    35      54</span><br></pre></td></tr></table></figure>
<p>awk 的 比较和逻辑运算符</p>
<p><img src="30.png" alt=""></p>
<p>我们可以通过 &amp;&amp; || ！来连接多个运算符。</p>
<p>如果我们想要在1号染色体 并且 长度大于10的功能区域。第一个pattern，采用了正则表达式，正则表达式在斜杠中，~ 表示 匹配 （不匹配 表示 !~），这里就仅仅是表示 $1 匹配 chr1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;$1 ~ &#x2F;chr1&#x2F; &amp;&amp; $3 - $2 &gt; 10&#39; example.bed</span><br><span class="line">chr1    26      39</span><br><span class="line">chr1    32      47</span><br><span class="line">chr1    9       28</span><br></pre></td></tr></table></figure>
<p>这个还可以更复杂，比如我们想挑出 chr2/chr3 的行，并且在最后增加一列长度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;$1 ~ &#x2F;chr2|chr3&#x2F; &#123; print $0 &quot;\t&quot; $3 - $2 &#125;&#39; example.bed</span><br><span class="line">chr3    11      28      17</span><br><span class="line">chr3    16      27      11</span><br><span class="line">chr2    35      54      19</span><br></pre></td></tr></table></figure>
<p>到目前为止，我们发现 awk 可以很方便的做两件事：</p>
<ul>
<li>按正则表达式/四则运算 提出需要的行</li>
<li>打印需要的字段或重排</li>
</ul>
<p>awk 还有 BEGIN 和 END ，BEGIN 一般用于新建变量，END 一般用于打印数据总结。</p>
<p>比如我们想看所有功能区域的平均长度。<strong>NR 是当前记录的行号，因此最后一行的行号就是总共的数据行数。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;BEGIN&#123; s &#x3D; 0 &#125;; &#123; s +&#x3D; ($3-$2) &#125;; END&#123; print &quot;mean: &quot; s&#x2F;NR &#125;;&#39; example.bed</span><br><span class="line">mean: 14</span><br></pre></td></tr></table></figure>
<p>对于使用其他字段分割的文件，比如 CSV 文件，我们可以使用 -F 选项，比如 <code>awk -F&quot;,&quot;</code></p>
<p>我们可以使用 NR 来挑某些行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;NR &gt;&#x3D; 3 &amp;&amp; NR &lt;&#x3D; 5&#39; example.bed</span><br><span class="line">chr3    11      28</span><br><span class="line">chr1    40      49</span><br><span class="line">chr3    16      27</span><br></pre></td></tr></table></figure>
<p>awk 使得生信数据之间的转换更加方便，比如 BED 和 GTF 文件。注意，这里的起始位置减1，来转变为 BED 数据（具体啥叫BED格式不知道）。这是由于BED的索引从0开始，而GTF的索引从1开始。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;!&#x2F;^#&#x2F; &#123; print $1 &quot;\t&quot; $4-1 &quot;\t&quot; $5 &#125;&#39; Mus_musculus.GRCm38.75_chr1.gtf | head -n 3</span><br><span class="line">1       3054232 3054733</span><br><span class="line">1       3054232 3054733</span><br><span class="line">1       3054232 3054733</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>awk 还有一个很有用的数据结构，称为关联数组，类似于python里面的字典，存在key和value。比如我们想计算 属于 基因 ”Lypla1&quot; 的 features 的 重复数目，我们可以按照以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;&#x2F;Lypla1&#x2F; &#123; feature[$3] +&#x3D; 1 &#125;; \</span><br><span class="line">    END &#123; for (k in feature)          \    </span><br><span class="line">    print k &quot;\t&quot; feature[k] &#125;&#39; Mus_musculus.GRCm38.75_chr1.gtf</span><br><span class="line">exon    69</span><br><span class="line">CDS     56</span><br><span class="line">UTR     24</span><br><span class="line">gene    1</span><br><span class="line">start_codon     5</span><br><span class="line">stop_codon      5</span><br><span class="line">transcript      9</span><br></pre></td></tr></table></figure>
<p>从这我们可以看出，awk 是一门真正的编程语言，可以使用 if for while 等循环。</p>
<p>但是，如果 awk 语句 变得复杂或者需要占据多行，我通常更推荐转向python。python 可以更加轻松地完成复杂的任务。（知己）</p>
<p>我们可以通过 unix 的管道符来完成这项任务。但是如果你需要对数据进行过滤，此时使用这种方式会很麻烦；而使用awk命令会很简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep &quot;Lypla1&quot; Mus_musculus.GRCm38.75_chr1.gtf | cut -f 3 | sort | uniq -c</span><br><span class="line">     56 CDS</span><br><span class="line">     69 exon</span><br><span class="line">      1 gene</span><br><span class="line">      5 start_codon</span><br><span class="line">      5 stop_codon</span><br><span class="line">      9 transcript</span><br><span class="line">     24 UTR</span><br></pre></td></tr></table></figure>
<h4 id="awk-分隔符设置">awk 分隔符设置</h4>
<p><a href="https://www.zsythink.net/archives/1357">https://www.zsythink.net/archives/1357</a></p>
<p>输入输出（设置每一个参数值均需要使用 <code>-v</code> 参数）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk -v FS&#x3D;&quot;&quot; -v OFS&#x3D;&quot;&quot; &#39;&#123;&#125;&#39;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-12-Bioawk-An-Awk-for-Biological-Formats">7.3.12 Bioawk: An Awk for Biological Formats</h3>
<p>Bioawk 是将 awk 扩展到处理一些常见的生信格式上，如FASTA/FASTQ, GTF/GFF, BED, SAM, VCF。其实没有特别大的变动，就是给每一列一个具有意义的名称而已。</p>
<p>直接用conda 安装（有一说一，conda 真好用）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install bioawk</span><br></pre></td></tr></table></figure>
<p>安装完之后，通过以下命令查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bioawk -c help</span><br></pre></td></tr></table></figure>
<h3 id="7-3-13-Stream-Editing-with-Sed">7.3.13 Stream Editing with Sed</h3>
<p>在前面，我们提到了为什么 Unix pipes 速度快，因为Unix pipes 直接在内存中处理数据（而不是将数据写入磁盘中再读取），除此之外，Unix pipes 不是一次性将所有数据放到内存中，而是<strong>每次只操作一行数据</strong>。</p>
<p>通常我们使用 Unix 命令处理数据需要好几个命令，但是 sed (The stream editor) 允许你直接做。类似于 ask 和 grep ，你应该只用 sed 命令做比较简单的事情（最主要是<strong>替换</strong>）。</p>
<p>sed 也是每次读取一行进行处理（流编辑，stream editing）。举例，假如我们将一个文件的“chrom&quot; 均改为 ”chr&quot;，这用到了sed 的替换命令（substitute, sed 的最常用的用法）。</p>
<p>使用 <code>s/pattern/replacement/</code> 默认只替换第一次出现的值；有时我们需要替换所有匹配的值，我们可以在最后一个斜杠后添加 一个 global flag g ，也就是<code>s/pattern/replacement/g</code></p>
<p>如果 我们需要匹配时忽视大小写，我们可以添加一个 flag i （<code>s/pattern/replacement/i</code>）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ head -n 3 chroms.txt</span><br><span class="line">chrom1  3214482 3216968</span><br><span class="line">chrom1  3216025 3216968</span><br><span class="line">chrom1  3216022 3216024</span><br><span class="line"></span><br><span class="line">$ sed &#39;s&#x2F;chrom&#x2F;chr&#x2F;&#39; chroms.txt | head -n 3</span><br><span class="line">chr1    3214482 3216968</span><br><span class="line">chr1    3216025 3216968</span><br><span class="line">chr1    3216022 3216024</span><br></pre></td></tr></table></figure>
<p>默认情况下，sed 使用 POSIX  Basic  Regular  Expressions  (BRE)，就像时 grep 命令一样，我们可以使用 <code>-E</code> 来使用拓展的正则表达式。</p>
<p>下面有三种办法实现同一功能，第二种方式采用了管道符的方法，可能更符合复杂情况；第三种方式采用 <code>tr</code> 函数（translate），同样是实现替换功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &quot;chr1:28427874-28425431&quot; | sed &#39;s&#x2F;[:-]&#x2F;\t&#x2F;g&#39;</span><br><span class="line">chr1    28427874        28425431</span><br><span class="line"></span><br><span class="line">$ echo &quot;chr1:28427874-28425431&quot; | sed &#39;s&#x2F;:&#x2F;\t&#x2F;&#39; | sed &#39;s&#x2F;-&#x2F;\t&#x2F;&#39;</span><br><span class="line">chr1    28427874        28425431</span><br><span class="line"></span><br><span class="line">$  echo &quot;chr1:28427874-28425431&quot; | tr &#39;:-&#39; &#39;\t&#39;</span><br><span class="line">chr1    28427874        28425431</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当某些行，sed 没有找到匹配的pattern 时，sed 会打印出整行，可以使用 <code>-n</code> 选项，避免 sed 打印没找到 pattern 的行。</p>
<p>如果采用 <code>.*</code> 方式采用的<strong>贪婪算法</strong>，如下面的例子，采用 <code>[^&quot;]</code> 是匹配非引号的字符，因此是非贪婪的。</p>
<blockquote>
<p><a href="https://blog.csdn.net/Jasonliujintao/article/details/53509732">https://blog.csdn.net/Jasonliujintao/article/details/53509732</a></p>
<p>sed 第二个斜杠和第三个斜杠的 <code>\1</code>  表示被匹配到的第一个模式，sed 一共可以记录9个模式 （\1 - \9）。模式就是用（）括起来的正则表达式的内容。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &#39;transcript_id &quot;ENSMUST00000160944&quot;; gene_name &quot;Gm16088&quot;&#39; &gt; greedy_example.txt</span><br><span class="line"></span><br><span class="line">$ sed -E &#39;s&#x2F;transcript_id &quot;(.*)&quot;.*&#x2F;\1&#x2F;&#39; greedy_example.txt</span><br><span class="line">ENSMUST00000160944&quot;; gene_name &quot;Gm16088</span><br><span class="line"></span><br><span class="line">$ sed -E &#39;s&#x2F;transcript_id &quot;([^&quot;]+)&quot;.*&#x2F;\1&#x2F;&#39; greedy_example.txt</span><br><span class="line">ENSMUST00000160944</span><br></pre></td></tr></table></figure>
<p>sed 还可以打印某些特定范围的行，比如 前10行，20行至50行（首尾都包括，从1开始）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sed -n &#39;1,10p&#39; Mus_musculus.GRCm38.75_chr1.gtf</span><br><span class="line">$ sed -n &#39;20,50p&#39; Mus_musculus.GRCm38.75_chr1.gtf</span><br></pre></td></tr></table></figure>
<h2 id="7-4-Advanced-Shell-Tricks">7.4 Advanced Shell Tricks</h2>
<h3 id="7-4-1-Subshells">7.4.1 Subshells</h3>
<p>首先 分清楚 <em>sequential</em> commands (不同的命令采用 &amp;&amp; 或者 ；) 和 <em>piped</em> commands (采用管道符 | 连接) 。sequential commands 只是一个接一个运行而已，但是彼此之间没有关系。但是 piped command ，前一个命令的输出是下一个命令的输入。</p>
<p>采用 &amp;&amp; 和  ；的区别在于他们的退出状态，如果我们采用 <code>command1 ; command2</code> 的方式，无论 command1 退出状态是否正常，command2 都会运行。但是如果我们使用 <code>command1 &amp;&amp; command2</code>，那么<strong>只有command1 运行成功后才会运行 command2</strong>。但是 <strong>在 pipelines 不方便检查退出状态</strong>。</p>
<p>我们可以将多个命令打包放在一起，他们的输出结果会形成一个数据流。举例而言，第一条命令将<code>echo &quot;this command&quot;</code>  和 <code>echo &quot;that command&quot; | sed 's/command/step/'</code> 视为两条命令，因此 <code>this command</code> 没有变化。</p>
<p>第二条命令通过 （） 将前面的两条命令打包一块输出。（这里所谓的subshell 就是用括号将sequential commands 括起来）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &quot;this command&quot;; echo &quot;that command&quot; | sed &#39;s&#x2F;command&#x2F;step&#x2F;&#39;</span><br><span class="line">this command</span><br><span class="line">that step</span><br><span class="line"></span><br><span class="line">$ (echo &quot;this command&quot;; echo &quot;that command&quot;) | sed &#39;s&#x2F;command&#x2F;step&#x2F;&#39;</span><br><span class="line">this step</span><br><span class="line">that step</span><br></pre></td></tr></table></figure>
<p>假如我们想对一个 GTF 文件进行排序，但是由于GTF 文件具有注释行，我们希望是注释行不动，对数据部分进行排序。</p>
<p>我们就可以用 subshell 来解决这个问题。因为用了 （）里面的两条命令的结果输出为一个总的数据流，实现了<strong>不动表头，对数据进行排序</strong>的需求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ (zgrep &quot;^#&quot; Mus_musculus.GRCm38.75_chr1.gtf.gz; \</span><br><span class="line">zgrep -v &quot;^#&quot; Mus_musculus.GRCm38.75_chr1.gtf.gz | \</span><br><span class="line">sort -k1,1 -k4,4n) | less</span><br></pre></td></tr></table></figure>
<p>我们也可以使用 <code>&gt;</code> 重定向到一个文件中，但是最好是<code>gzip</code> 压缩一下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ (zgrep &quot;^#&quot; Mus_musculus.GRCm38.75_chr1.gtf.gz; \</span><br><span class="line">zgrep -v &quot;^#&quot; Mus_musculus.GRCm38.75_chr1.gtf.gz | \</span><br><span class="line">sort -k1,1 -k4,4n) | gzip &gt; Mus_musculus.GRCm38.75_chr1_sorted.gtf.gz</span><br></pre></td></tr></table></figure>
<p>这个subshell 可以使用python 来写代码完成，但是问题是更复杂了，而且不能直接处理压缩文件。</p>
<h3 id="7-4-2-Named-Pipes-and-Process-Substitution">7.4.2 Named Pipes and Process Substitution</h3>
<p>到目前为止，我们已经使用 pipes 来连接不同的命令行工具来创建定制的数据处理 pipelines。<strong>但是，有些软件不能和 unix pipes 连接上</strong>。比如有一些生信工具读写多个文件形式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ processing_tool --in1 in1.fq --in2 in2.fq --out1 out2.fq --out2.fq</span><br></pre></td></tr></table></figure>
<p>因为这里需要多个输入文件，因此我们将pipeline 前一步的输出结果作为这里的输入。相似的，这个软件生成了两个结果文件，这也没办法将它的输出作为另一个程序的标准输入。</p>
<p>除了不能使用 Unix pipe 将 processing_tool 与其他程序互相协作外，这里还有一个更严重的问题：<strong>使用这个程序我们需要从磁盘读取4个中间文件</strong>。如果这个程序在整个pipeline的中间步骤，那么很有可能会造成一个显著的计算瓶颈。</p>
<p>幸运的是，Unix 提供了一个解决办法：<em>named pipes</em>，也称之为 FIFO (First In First Out) 。</p>
<p>常见的pipeline 没有名称，而且只有运行的时候才存在于内存中。命令的pipes 就像文件一样，会一直存在你的文件系统中。采用 <code>mkfifo</code> 可以实现命名的pipe</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkfifo fqin</span><br><span class="line">$ ls -l fqin</span><br><span class="line">prw-rw-r-- 1 zhouziwen zhouziwen 0 Sep 15 10:41 fqin</span><br></pre></td></tr></table></figure>
<p>这个实际上就是一个特殊形式的文件：p 表示 pipe。举个简单的例子，我们可以使用 <code>echo</code> 来重定向一些文本到一个 named pipe 中，然后使用<code>cat</code> 打印内容。</p>
<p>注意：<strong>这个named pipe ，就像标准的pipe 一样，读取过的数据就不复存在了。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &quot;hello, named pipes&quot; &gt; fqin </span><br><span class="line">[1] 1536</span><br><span class="line">$ cat fqin</span><br><span class="line">hello, named pipes</span><br><span class="line">$ rm fqin</span><br><span class="line"></span><br><span class="line">$ cat fqin #再次读取，失败。</span><br><span class="line">cat: fqin: No such file or directory</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然这个语法很像是重定向到一个文件中，但是<strong>我们实际上没有向磁盘写入任何东西</strong>。因此 processing_tool 这种软件的输入输出均可以使用 named pipe 替代。</p>
<p>但是，创建和销毁这些 file-like named pipes 有一些枯燥无聊。这里有一种方式使用 named pipe 时 可以不用特地创建它们，称之为 <em>process substitution</em>, 或者 anonymous named pipes。举例如下 <code>&lt;(echo &quot;hello, process substitution&quot;)</code>  将里面的命令输出给一个 anonymous named pipe。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$  cat &lt;(echo &quot;hello, process substitution&quot;)</span><br><span class="line">hello, process substitution</span><br></pre></td></tr></table></figure>
<p>举例，上面的program 需要两个输入文件，这里没法用简单的 unix pipeline 。我们需要使用  <code>mkfifo</code> 创建两个 named pipes，也可以使用 process substitution。比如我们假设存在一个软件<code>makein</code> 可以创建输入文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">program --in1 &lt;(makein raw1.txt) --in2 &lt;(makein raw2.txt) \</span><br><span class="line">	--out1 out1.txt --out2 out2.txt</span><br></pre></td></tr></table></figure>
<p>process substitution 还可以用于<strong>输出文件中</strong>，这通常是用于大数据文件在写入磁盘前<strong>压缩</strong>（先写入磁盘，再压缩，会读写两个大文件，多花时间）。还是以上面的文件为例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">program --in1 in1.txt --in2 in2.txt \</span><br><span class="line">	--out1 &gt;(gzip &gt; out1.txt.gz) --out2 &gt;(gzip &gt; out2.txt.gz)</span><br></pre></td></tr></table></figure>
<h2 id="7-5-The-Unix-Philosophy-Revisited">7.5 The Unix Philosophy Revisited</h2>
<p>通读本章，Unix 哲学 – 采用 Unix pipe 来组合多个小的程序。 不仅仅是因为 Unix piped workflows 容易创建、容易 debug，而已<strong>unix pipe 通常也是计算效率最高的解决办法</strong>。</p>
<h1>8 A Rapid Introduction to the R Language</h1>
<p>这里主要是侧重 R语言在 <em>exploratory data analysis (EDA)</em> 方面的应用。</p>
<p>EDA 是一种互动式的对数据的探索。EDA 在整个的生信数据分析中都很重要。这些分析本身并不复杂或者很细致，但是可以满足我们想看一眼数据的需求。</p>
<p>在很多情况下，EDA ，特别是可视化，可以发现生信数据的模式（pattern），而这可能会被统计模型或假设检验忽视。我们的大脑是最精巧的 pattern-finding 工具，而 EDA 就是将数据用不同的方式展示给我们的大脑看，并让我们的大脑去寻找 pattern，从而可以找到有趣的生物信号或者展示出潜在的问题。相比于我们的大脑，统计检验是一个迟钝的工具，而且当处理复杂的多维度的数据时就更加迟钝，比如生信数据。</p>
<p>虽然这一章节强调 EDA 的重要性，但统计检验同样也很重要。</p>
<h2 id="8-1-Getting-Started-with-R-and-RStudio">8.1 Getting Started with R and RStudio</h2>
<h2 id="8-2-R-Language-Basics">8.2 R Language Basics</h2>
<h3 id="8-2-1-Simple-Calculations-in-R-Calling-Functions-and-Getting-Help-in-R">8.2.1 Simple Calculations in R, Calling Functions, and Getting Help in R</h3>
<p>R 参数要输入参数名称，虽然R支持不输入参数名称，但是这会影响代码的可读性。（受教了）</p>
<blockquote>
<p>First,  values  are  matched  to  arguments  by  name.  Technically,  R  also  allows  partial matching of argument names but I would discourage this, as it decreases code readability.  Second,  values  are  matched  based  on  position  within  the  argument  list.  For functions  that  have  many  arguments  with  default  values  such  as   foo(x, a=3, b=4, c=5), it’s easier to set an argument later in the function by specifying it by name.</p>
</blockquote>
<h3 id="8-2-2-Variables-and-Assignment">8.2.2 Variables and Assignment</h3>
<p>R 中的赋值符号除了 使用 <code>&lt;-</code>，还可以使用 <code>=</code>，但是 <code>&lt;-</code>是更加传统的做法。（感觉用=更好，与其他语言一致）。</p>
<p>通过 <code>ls()</code> 可以查看所有的 global environment 。当 R 需要查找一个变量名称时，它有一个查找路径和顺序。我们可以通过<code>search()</code> 函数查看 R 的查找路径（包括全局环境变量、打开的R包等）。</p>
<h3 id="8-2-3-Vectors-Vectorization-and-Indexing">8.2.3 Vectors, Vectorization, and Indexing</h3>
<p>R 语言最重要的特征就是它的向量。不像其他语言，R 没有<strong>标量</strong>的概念（a single value），这些值在R中实际上是长度为1的向量。</p>
<p>R的向量是R中一个最重要的特征的基础：<strong>向量化</strong>。**向量化支持我们去 loop over 向量元素，而不需要写一个具体的循环。**举例而言：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x &lt;- <span class="built_in">c</span>(<span class="number">56</span>, <span class="number">95.3</span>, <span class="number">0.4</span>)</span><br><span class="line">&gt; y &lt;- <span class="built_in">c</span>(<span class="number">3.2</span>, <span class="number">1.1</span>, <span class="number">0.2</span>)</span><br><span class="line">&gt; x + y</span><br><span class="line">[<span class="number">1</span>] <span class="number">59.2</span> <span class="number">96.4</span>  <span class="number">0.6</span></span><br><span class="line">&gt; x - y</span><br><span class="line">[<span class="number">1</span>] <span class="number">52.8</span> <span class="number">94.2</span>  <span class="number">0.2</span></span><br><span class="line">&gt; x/y</span><br><span class="line">[<span class="number">1</span>] <span class="number">17.50000</span> <span class="number">86.63636</span>  <span class="number">2.00000</span></span><br></pre></td></tr></table></figure>
<p>创建整数序列</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; seq(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">&gt; <span class="number">1</span>:<span class="number">5</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>对两个向量进行向量化操作时，如果两个向量长度不一致，那么R会循环使用短的向量的值。这时一种默认的行为，一般R不会给提示，<strong>除非长向量的长度不是短向量的整数倍</strong>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x</span><br><span class="line">[<span class="number">1</span>] <span class="number">56.0</span> <span class="number">95.3</span>  <span class="number">0.4</span></span><br><span class="line">&gt; x - <span class="number">3</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">53.0</span> <span class="number">92.3</span> -<span class="number">2.6</span></span><br></pre></td></tr></table></figure>
<p>当两个向量的长度不是整数倍的关系时，R会给出<strong>Warning</strong>提示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">c</span>(<span class="number">1</span>, <span class="number">2</span>) + <span class="built_in">c</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line">&gt; <span class="built_in">c</span>(<span class="number">1</span>, <span class="number">2</span>) + <span class="built_in">c</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line">Warning message:</span><br><span class="line">In <span class="built_in">c</span>(<span class="number">1</span>, <span class="number">2</span>) + <span class="built_in">c</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) : 长的对象长度不是短的对象长度的整倍数</span><br></pre></td></tr></table></figure>
<p>这种向量化操作不仅仅时更加清晰，计算效率也更快。因为这个特性，R语言支持<strong>完全放弃for循环</strong>。</p>
<p>R 的索引从1开始。（不像python，从0开始）。<strong>如果索引超出了实际范围，R会返回NA值（“not available”）。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; x &lt;- c(56, 95.3, 0.4)</span><br><span class="line">&gt; x[2] </span><br><span class="line">[1] 95.3</span><br><span class="line">&gt; x[1]</span><br><span class="line">[1] 56</span><br><span class="line">&gt; x[4] </span><br><span class="line">[1] NA</span><br><span class="line">&gt; x[3] &lt;- 0.5</span><br><span class="line">&gt; x</span><br><span class="line">[1] 56.0 95.3  0.5</span><br></pre></td></tr></table></figure>
<p>向量也可以有名称（通过<code>names()</code>函数设定）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; b &lt;- c(a&#x3D;3.4, b&#x3D;5.4, c&#x3D;0.4)</span><br><span class="line">&gt; b</span><br><span class="line">a   b   c</span><br><span class="line">3.4 5.4 0.4</span><br><span class="line">&gt; names(b)</span><br><span class="line">[1] &quot;a&quot; &quot;b&quot; &quot;c&quot;</span><br><span class="line">&gt; names(b) &lt;- c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;) # change these names</span><br><span class="line">&gt; b</span><br><span class="line">  x   y   z </span><br><span class="line">3.4 5.4 0.4 </span><br><span class="line">&gt; b[&#39;x&#39;]</span><br><span class="line">  x </span><br><span class="line">3.4 </span><br></pre></td></tr></table></figure>
<p>也可以一次提取多个值，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; x[c(2,3)]</span><br><span class="line">[1] 95.3  0.4</span><br></pre></td></tr></table></figure>
<p>当使用索引提取子向量，出现NA值时，可能有两个原因：1，向量中这个值本身就是NA，即缺失；2，索引超出范围，返回NA。</p>
<p>R 支持使用负数来剔除某些索引</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x[-<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">95.3</span>  <span class="number">0.4</span></span><br><span class="line">&gt; y=<span class="number">1</span>:<span class="number">10</span></span><br><span class="line">&gt; y[-(<span class="number">2</span>:<span class="number">4</span>)]</span><br><span class="line">[<span class="number">1</span>]  <span class="number">1</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>我们也可以打乱索引，重排顺序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; z &lt;- c(3.4, 2.2, 0.4, -0.4, 1.2)</span><br><span class="line">&gt; z[5:1][1]  1.2 -0.4  0.4  2.2  3.4</span><br></pre></td></tr></table></figure>
<p>相似地，我们可以通过 R函数来给我们创造索引。比如，order() 函数能够返回一个索引向量，这个索引向量默认是按照元素递增的顺序。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; order(z)</span><br><span class="line">[<span class="number">1</span>] <span class="number">4</span> <span class="number">3</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line">&gt; z[order(z)]</span><br><span class="line">[<span class="number">1</span>] -<span class="number">0.4</span>  <span class="number">0.4</span>  <span class="number">1.2</span>  <span class="number">2.2</span>  <span class="number">3.4</span></span><br><span class="line">&gt; z[order(z, decreasing = <span class="literal">TRUE</span>)]</span><br><span class="line">[<span class="number">1</span>]  <span class="number">3.4</span>  <span class="number">2.2</span>  <span class="number">1.2</span>  <span class="number">0.4</span> -<span class="number">0.4</span></span><br></pre></td></tr></table></figure>
<p>就像我们采用一些函数生成索引向量，我们可以使用逻辑运算符来创建逻辑向量（<em>logical vectors</em>, 只包含TRUE 和 FALSE），比如 ==, !=, &gt;, &lt; 等等。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; v &lt;- <span class="built_in">c</span>(<span class="number">2.3</span>, <span class="number">6</span>, -<span class="number">3</span>, <span class="number">3.8</span>, <span class="number">2</span>, -<span class="number">1.1</span>)</span><br><span class="line">&gt; v == <span class="number">6</span></span><br><span class="line">[<span class="number">1</span>] <span class="literal">FALSE</span>  <span class="literal">TRUE</span> <span class="literal">FALSE</span> <span class="literal">FALSE</span> <span class="literal">FALSE</span> <span class="literal">FALSE</span></span><br><span class="line">&gt; v &lt;= -<span class="number">3</span></span><br><span class="line">[<span class="number">1</span>] <span class="literal">FALSE</span> <span class="literal">FALSE</span>  <span class="literal">TRUE</span> <span class="literal">FALSE</span> <span class="literal">FALSE</span> <span class="literal">FALSE</span></span><br><span class="line">&gt; <span class="built_in">abs</span>(v) &gt; <span class="number">5</span></span><br><span class="line">[<span class="number">1</span>] <span class="literal">FALSE</span>  <span class="literal">TRUE</span> <span class="literal">FALSE</span> <span class="literal">FALSE</span> <span class="literal">FALSE</span> <span class="literal">FALSE</span></span><br></pre></td></tr></table></figure>
<p><strong>逻辑向量很有用，因为他们可以直接用做索引向量</strong>。比如</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; v[<span class="built_in">c</span>(<span class="literal">TRUE</span>, <span class="literal">TRUE</span>, <span class="literal">FALSE</span>, <span class="literal">TRUE</span>, <span class="literal">FALSE</span>, <span class="literal">FALSE</span>)]</span><br><span class="line">[<span class="number">1</span>] <span class="number">2.3</span> <span class="number">6.0</span> <span class="number">3.8</span></span><br></pre></td></tr></table></figure>
<p>但是自己创建 由 TRUE和FALSE组成的逻辑向量很枯燥，因此可以直接使用比较运算符在索引中，比如下式</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; v[v &gt; <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">2.3</span> <span class="number">6.0</span> <span class="number">3.8</span></span><br></pre></td></tr></table></figure>
<p>向量类型</p>
<ul>
<li><strong>Numeric</strong> : 实数，R所有的数字<strong>默认是 numeric vector</strong>, 哪怕所有数字都是整数。</li>
<li><strong>Integer</strong> ：整数</li>
<li><strong>Character</strong>：字符串（<em>strings</em>）, r 和 其他语言一样，可以包括一些特殊字符，如 <code>\n</code>，<code>\t</code></li>
<li><strong>Logical</strong> :  TRUE FALSE （作者建议不要使用T F缩写，因为影响可读性，而且T F可能在代码中重定义了，比如 T &lt;- 0）</li>
</ul>
<p>R 中的特殊值</p>
<ul>
<li>
<p><strong>NA</strong> : 缺失值，对NA 值的任何操作都会返回一个NA值（比如 2+NA ）。通过 <code>is.na()</code> 查看所有的缺失值</p>
</li>
<li>
<p><strong>NULL</strong> :  NULL 表示没有一个值（NA 表示有一个值，但是缺失）（没看懂）</p>
<blockquote>
<p>NULL represents  not  having  a  value  (which  is  different  than  having  a  value  that’s missing).</p>
</blockquote>
</li>
<li>
<p><strong>-Inf, Inf</strong> ：negative infinite 和 positive infinite values。</p>
</li>
<li>
<p><strong>NaN</strong> ：”not a number&quot; , 这会发生在一些不返回值的计算中，比如 0/0</p>
</li>
</ul>
<p>R中的<strong>向量</strong>所有的元素必须是<strong>相同的数据类型</strong>。R 会 silently 强制使所有的元素具有相同的数据类型。</p>
<p>另一种你会碰到的向量类型是<strong>因子</strong>（factors）。因子存储分类变量。通过 <code>levels()</code> 查看因子型向量的所有水平。可以通过 <code>table()</code> 查看每个水平的重复数。</p>
<h2 id="8-3-WRorking-with-and-Visualizing-Data-in-R">8.3 WRorking with and Visualizing Data in R</h2>
<h3 id="8-3-1-Loading-Data-into-R">8.3.1 Loading Data into R</h3>
<p>对于一些大的基因组数据，仅仅在R中读取就很困难，会消耗大量内存，或者你的电脑没有足够的内存读入所有数据。在很多情况下，最好的策略是使用某种方式降低你的数据量：比如删除不需要的列，文件切分（比如每次只跑一条染色体），或者随机抽取一个子数据集。</p>
<p>如果你的内存够用，在R中加载数据可能也很慢。使用 read.csv() 等方式时，可以通过 <code>colClasses</code> 参数注明每一列的类型，这可以节约一半时间 （麻烦）。</p>
<p>使用 <code>data.table</code> 包的 <code>fread() </code> 函数是最快的方式。但是fread() 读取的不是 data.frame() 格式，而是 data.table() 格式 （暂时不清楚区别）。</p>
<p>使用 <code>data.frame()</code> 函数可以合并多个向量，创建新的数据集，而且可以设置列的名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; x &lt;- sample(1:50, 300, replace&#x3D;TRUE)</span><br><span class="line">&gt; y &lt;- 3.2*x + rnorm(300, 0, 40)</span><br><span class="line">&gt; d_sim &lt;- data.frame(y&#x3D;y, x&#x3D;x)</span><br></pre></td></tr></table></figure>
<h3 id="8-3-2-Exploring-and-Transforming-Dataframes">8.3.2 Exploring and Transforming Dataframes</h3>
<p>创建子集</p>
<ol>
<li>
<p><code>d$depth</code> : 索取一列</p>
</li>
<li>
<p>使用 [] 符号</p>
 <figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; d[ , <span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">&gt; d[ , <span class="built_in">c</span>(<span class="string">&quot;start&quot;</span>,<span class="string">&quot;end&quot;</span>)]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>作者建议不要使用这种方式截取特定的行，因为则可能会导致错误。相似地，提取列信息地最好的方式是<strong>使用列名</strong>，而不是位置，同样是面临可能取错列的问题，而且这样做可以<strong>提高代码的可读性</strong>。</p>
<p>当只提取数据集中的一列时，R默认返回一个向量——而不是一个单列的数据集。如果下游需要索取一个数据集时，这可能会导致错误。为了避免这种行为，我们可以通过设置 <code>drop = FALSE</code> 来避免</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; d[, &quot;start&quot;, drop&#x3D;FALSE]</span><br></pre></td></tr></table></figure>
<p>假如我们需要新增一列，这一列表示位点是否在25 ,800,000 to 29,700,000 的区间内。<code>&amp;</code> 是向量化操作的逻辑运算符。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; d$cent &lt;- (d$start &gt;= <span class="number">25800000</span> &amp; d$end &lt;= <span class="number">29700000</span>)</span><br></pre></td></tr></table></figure>
<h3 id="8-3-3-Exploring-Data-Through-Slicing-and-Dicing-Subsetting-Dataframes">8.3.3 Exploring Data Through Slicing and Dicing: Subsetting Dataframes</h3>
<p>挑出特定的行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; d[d$total.SNPs &gt;&#x3D; 85, ]</span><br></pre></td></tr></table></figure>
<p>使用 <code>which</code> 函数返回符合条件的索引值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; which(d$Pi &gt; 3)</span><br><span class="line">[1]  2  4  5  6  7 10 [...]</span><br></pre></td></tr></table></figure>
<p>因此， <code>d[d$Pi &gt; 3, ]</code> 和 <code>d[which(d$Pi &gt; 3), ]</code> 是等价的。</p>
<p><code>which</code> 还有两个相关的函数，返回<strong>第一个</strong>最大值和最小值的索引（也就是说，有重复的值也只返回第一个）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; d[which.min(d$total.Bases),]</span><br><span class="line">&gt; d[which.max(d$depth),]</span><br></pre></td></tr></table></figure>
<p>还可以使用 <code>subset</code> 函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; subset(d, Pi &gt; 16 &amp; percent.GC &gt; 80)</span><br></pre></td></tr></table></figure>
<h3 id="8-3-4-Exploring-Data-Visually-with-ggplot2-I-Scatterplots-and-Densities">8.3.4 Exploring Data Visually with ggplot2 I: Scatterplots and Densities</h3>
<p><strong>探索性数据分析</strong>强调<strong>可视化</strong> 是理解和探索数据的最好的工具。这里只介绍 ggplot2 的使用</p>
<p>一个简单的例子，这里由两块组成，ggplot() 函数 指定了使用的数据集；geom_point() 指定添加的图层，其中 aes() 函数英文为 aesthetics （美学）。aes() 函数同样可以放在ggplot() 函数中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ggplot(d) + geom_point(aes(x&#x3D;position, y&#x3D;diversity))</span><br><span class="line">ggplot(d, aes(x&#x3D;position, y&#x3D;diversity)) + geom_point()</span><br><span class="line">ggplot(d) + geom_point(aes(x&#x3D;position, y&#x3D;diversity, color&#x3D;cent))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过设置透明度，来避免点之间的重叠。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ggplot(d) + geom_point(aes(x&#x3D;position, y&#x3D;diversity), alpha&#x3D;0.01)</span><br></pre></td></tr></table></figure>
<p>通过密度图看分布。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ggplot(d) + geom_density(aes(x&#x3D;diversity), fill&#x3D;&quot;black&quot;)</span><br></pre></td></tr></table></figure>
<p>密度图可以分类，为了能够看到二者重叠的部分，需要设置透明度。</p>
<p>通过将额外的 aesthetic 属性 分配给别的分类变量，可以揭示分类变量不同水平的差别。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ggplot(d) + geom_density(aes(x&#x3D;diversity, fill&#x3D;cent), alpha&#x3D;0.4)</span><br></pre></td></tr></table></figure>
<h3 id="8-3-5-Exploring-Data-Visually-with-ggplot2-II-Smoothing">8.3.5 Exploring Data Visually with ggplot2 II: Smoothing</h3>
<p>上面提到使用散点图中的<strong>重叠</strong>现象会掩盖数据的真实的分布，我们可以通过设置透明度来避免；还有另外一种方法是通过 <code>geom_smooth()</code> 函数 来添加一个平滑曲线，来查看趋势。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ggplot(d, aes(x&#x3D;depth, y&#x3D;total.SNPs)) + geom_point() + geom_smooth()</span><br></pre></td></tr></table></figure>
<p>默认情况下，但是数据集超过1000行时，ggplot2 使用 <code>generalized additive models</code>(GAM) 来拟合曲线。</p>
<p>从图像中可以看到，当测序深度越高时，能够发现的SNP越多。</p>
<p>另外，GC 含量会影响测序质量（PCR 不能有效复制这些区域）。从加了拟合曲线的散点图可以看出，GC 含量确实对数据的测序深度有影响。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ggplot(d, aes(x&#x3D;X.GC, y&#x3D;depth)) + geom_point() + geom_smooth()</span><br></pre></td></tr></table></figure>
<h3 id="8-3-6-Binning-Data-with-cut-and-Bar-Plots-with-ggplot2">8.3.6 Binning Data with cut() and Bar Plots with ggplot2</h3>
<p>我们可以将连续变量进行分组，划分到不同的组里（binning），这个功能可以使用 <code>cut()</code> 函数实现，第二个参数是划分成几个组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; d$GC.binned &lt;- cut(d$percent.GC, 5)</span><br><span class="line">&gt; d$GC.binned</span><br><span class="line">&gt; table(d$GC.binned)</span><br><span class="line">(0.716,17.7]  (17.7,34.7]  (34.7,51.6]  (51.6,68.5] </span><br><span class="line">           6         4976        45784         8122 </span><br><span class="line"> (68.5,85.6] </span><br><span class="line">         252 </span><br></pre></td></tr></table></figure>
<p>也可以自己划分组，但是如果手动划分的组不能包括所有的值，那么组外的值会返回NA。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; cut(d$percent.GC, c(0, 25, 50, 75, 100))</span><br></pre></td></tr></table></figure>
<p>通过 <code>cut()</code> 函数生成的 bins 的可视化的最好办法是条形图。如果 <code>geom_bar()</code> 给定的aes 中是一个分类变量，会根据计数创造条形图；如果给定的 aes 中是一个连续变量，那么 <code>geom_bar()</code> 会自动分组，然后创造一个直方图。（<strong>条形图和直方图的区别在于分类变量和连续变量</strong>）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt;  ggplot(d) + geom_bar(aes(x=GC.binned))</span><br><span class="line">&gt;  ggplot(d) + geom_bar(aes(x=percent.GC))</span><br></pre></td></tr></table></figure>
<p>查看某一分类变量对密度图的影响（根本分不清楚）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; ggplot(d) + geom_density(aes(x&#x3D;depth, linetype&#x3D;GC.binned), alpha&#x3D;0.5)</span><br></pre></td></tr></table></figure>
<h3 id="8-3-7-Merging-and-Combining-Data-Matching-Vectors">8.3.7 Merging and Combining Data: Matching Vectors</h3>
<h3 id="and-Merging-Dataframes">and Merging Dataframes</h3>
<p>在生信分析，我们需要用到多个数据集，因此如何合并使用不同的数据集是一个重要的能力。</p>
<p>最简单的匹配两个向量的操作就是使用 <code>%in%</code> 函数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">c</span>(<span class="number">3</span>, <span class="number">4</span>, -<span class="number">1</span>) %in% <span class="built_in">c</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>)</span><br><span class="line">[<span class="number">1</span>]  <span class="literal">TRUE</span>  <span class="literal">TRUE</span> <span class="literal">FALSE</span></span><br></pre></td></tr></table></figure>
<p>我去，<code>read.delim()</code>  或 <code>read.table()</code> 可以直接读取压缩文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reps &lt;- read.delim(&quot;chrX_rmsk.txt.gz&quot;, header&#x3D;TRUE)</span><br><span class="line">#reps2 &lt;- read.table(&quot;chrX_rmsk.txt.gz&quot;, header&#x3D;TRUE)</span><br><span class="line"></span><br><span class="line">head(reps2,3)</span><br></pre></td></tr></table></figure>
<p>假如我们要挑某一列中某些水平的行，可以使用 <code>%in%</code> 这么写（而不是使用多个判断）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">common_repclass &lt;- c(&quot;SINE&quot;, &quot;LINE&quot;, &quot;LTR&quot;, &quot;DNA&quot;, &quot;Simple_repeat&quot;)</span><br><span class="line">reps[reps$repClass %in% common_repclass, ]</span><br></pre></td></tr></table></figure>
<p><code>%in%</code> 是 <code>match()</code> 函数的简化版本。<code>%in%</code>  对每一个 x 的值返回 TRUE/FALSE。而 <code>match(x,y)</code> 返回 每一个 x 的值在y 中第一次出现的位置，如果没有匹配到，会返回一个 NA 值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; match(c(&quot;A&quot;, &quot;C&quot;, &quot;E&quot;, &quot;A&quot;), c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;E&quot;))</span><br><span class="line">[1]  1 NA  4  1</span><br></pre></td></tr></table></figure>
<p>match 函数 可以通过一个共同的列合并两个数据集。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; mtfs &lt;- read.delim(&quot;motif_recombrates.txt&quot;, header&#x3D;TRUE)</span><br><span class="line">&gt; head(mtfs, 3)</span><br><span class="line">&gt; rpts &lt;- read.delim(&quot;motif_repeats.txt&quot;, header&#x3D;TRUE)</span><br><span class="line">&gt; head(rpts, 3)</span><br></pre></td></tr></table></figure>
<p>合并两列内容，形成一个两个文件均有的新列，这个 pos 列可以作为两个文件共有的列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; mtfs$pos &lt;- paste(mtfs$chr, mtfs$motif_start, sep&#x3D;&quot;-&quot;)</span><br><span class="line">&gt; rpts$pos &lt;- paste(rpts$chr, rpts$motif_start, sep&#x3D;&quot;-&quot;)</span><br></pre></td></tr></table></figure>
<p>合并前，你需要知道两个文件确实共同拥有一列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; table(mtfs$pos %in% rpts$pos)</span><br><span class="line">FALSE  TRUE </span><br><span class="line">10832  9218 </span><br></pre></td></tr></table></figure>
<p>但是注意：这里方向很重要，如果反过来就不能说明问题了。（因为 mtfs 数据量小）</p>
<blockquote>
<p>you don’t go looking for a haystack in a needle !</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; table(rpts$pos %in% mtfs$pos)</span><br><span class="line"></span><br><span class="line">TRUE </span><br><span class="line"> 317 </span><br></pre></td></tr></table></figure>
<p>现在我们可以通过 <code>match</code> 函数 来找出哪些行是共同的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; i &lt;- match(mtfs$pos, rpts$pos)</span><br></pre></td></tr></table></figure>
<p>这里如果没有匹配上就会返回 NA。</p>
<p>然后我们就可以挑出 rpts$name 列中相应的元素，然后合并到 mtfs 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; mtfs$repeat_name &lt;- rpts$name[i]</span><br></pre></td></tr></table></figure>
<p>当然也可以一步到位</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; mtfs$repeat_name &lt;- rpts$name[match(mtfs$pos, rpts$pos)]</span><br></pre></td></tr></table></figure>
<p>合并数据后的最后一步是：验证、验证、验证。从上面可以看到，使用merge() 函数合并不同的数据集的信息，这样做是很挑巧的，这很容易犯错。因此需要外部验证，找几个数据来看一下</p>
<p>事实上，R 中 有一个更加用户友好的合并参数 ：merge() 。 相同的列后面会添加列名称（这里是 .x .y）。默认 merge() 函数 采用内连接，可以通过 <code>all.x = TRUE</code>，设置为左连接；同样的，通过 <code>all.y = TRUE</code>，设置为左连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; recm &lt;- merge(mtfs, rpts, by.x&#x3D;&quot;pos&quot;, by.y&#x3D;&quot;pos&quot;)</span><br><span class="line">&gt; head(recm, 2)</span><br></pre></td></tr></table></figure>
<h3 id="8-3-8-Using-ggplot2-Facets">8.3.8 Using ggplot2 Facets</h3>
<p>这里使用分面来进行数据的可视化，首先看一下数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; p &lt;- ggplot(mtfs, aes(x&#x3D;dist, y&#x3D;recom)) + geom_point(size&#x3D;1)</span><br><span class="line">&gt; p &lt;- p + geom_smooth(method&#x3D;&quot;loess&quot;, se&#x3D;FALSE, span&#x3D;1&#x2F;10)</span><br><span class="line">&gt; print(p)</span><br></pre></td></tr></table></figure>
<p>分面：ggplot2 有两个分面函数：<code>facet_wrap()</code> 和 <code>facet_grid()</code> 。<code>facet_wrap()</code> 需要一个因子变量，然后对其中的每一个水平均创建一个 panel。<code>facet_grid()</code> 可以设置地更加细腻，来划分哪列用于垂直分面，哪列用于水平分列。</p>
<p>这里用到的 ~ 符号是用来指定 R中的模型的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; p &lt;- ggplot(mtfs, aes(x&#x3D;dist, y&#x3D;recom)) + geom_point(size&#x3D;1, color&#x3D;&quot;grey&quot;)</span><br><span class="line">&gt; p &lt;- p + geom_smooth(method&#x3D;&#39;loess&#39;, se&#x3D;FALSE, span&#x3D;1&#x2F;10)</span><br><span class="line">&gt; p &lt;- p + facet_wrap(~ motif)</span><br><span class="line">&gt; print(p)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; p &lt;- ggplot(mtfs, aes(x&#x3D;dist, y&#x3D;recom)) + geom_point(size&#x3D;1, color&#x3D;&quot;grey&quot;)</span><br><span class="line">&gt; p &lt;- p + geom_smooth(method&#x3D;&#39;loess&#39;, se&#x3D;FALSE, span&#x3D;1&#x2F;10)</span><br><span class="line">&gt; p &lt;- p + facet_grid(repeat_name ~ motif)</span><br><span class="line">&gt; print(p)</span><br></pre></td></tr></table></figure>
<h3 id="8-3-9-More-R-Data-Structures-Lists">8.3.9 More R Data Structures: Lists</h3>
<p>R 中 的列表 可以包括不同类型的元素；每个元素可以是任何对象（其他列表，数据库，矩阵，向量等）。</p>
<p>其实你在不知不觉中已经在使用 list 了，之前使用的数据集其实就是 list 。</p>
<p>创建 list</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; adh &lt;- list(chr&#x3D;&quot;2L&quot;, start&#x3D;14615555L, end&#x3D;14618902L, name&#x3D;&quot;Adh&quot;)</span><br><span class="line">&gt; adh</span><br></pre></td></tr></table></figure>
<p>列表取子集，由于列表中包换多种类型的数据，因此取子集默认还是一个列表，还有一种方式可以提取列表中的某个元素，就是使用两个方括号（这样得到的就不是一个列表了）。采用 <code>$</code> 符号也可以提取元素，这和数据集（dataframe）操作相同，这并不是巧合，而是因为数据集本身就是从列表中来的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adh[1:2]</span><br><span class="line">adh[[1]]</span><br><span class="line">adh$chr #返回元素</span><br><span class="line">adh[&quot;chr&quot;] #返回列表</span><br></pre></td></tr></table></figure>
<p>由于 列表结构可能非常复杂，我们可以使用 <code>str()</code> 函数查看列表结构。</p>
<p>更改列表的值</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; adh$id &lt;- <span class="string">&quot;FBgn0000055&quot;</span></span><br><span class="line">&gt; adh$id &lt;- <span class="literal">NULL</span> <span class="comment">#删除某个值</span></span><br></pre></td></tr></table></figure>
<h3 id="8-3-10-Writing-and-Applying-Functions-to-Lists-with-lapply-and-sapply">8.3.10 Writing and Applying Functions to Lists with lapply() and sapply()</h3>
<p>使用 <code>lapply</code></p>
<p>假设我们有以下的列表数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; ll &lt;- list(a&#x3D;rnorm(6, mean&#x3D;1), b&#x3D;rnorm(6, mean&#x3D;4), c&#x3D;rnorm(6, mean&#x3D;6))</span><br></pre></td></tr></table></figure>
<p>我们如何获得列表中每个向量的均值呢？首先，我们可以使用 for 循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll_means &lt;- numeric(length(ll))</span><br><span class="line"></span><br><span class="line"># loop over each list element and calculate mean</span><br><span class="line">for (i in seq_along(ll)) &#123;</span><br><span class="line">	ll_means[i] &lt;- mean(ll[[i]])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，这并不符合R的语言习惯，一个更好的方式是采用一个 apply 函数，对 list 的每一个元素采用相同的函数。这里 我们使用 <code>lapply()</code> 函数（第一个 l 表示 list），但是同样会返回一个list</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; lapply(ll, mean)</span><br></pre></td></tr></table></figure>
<p>使用 <code>lapply()</code> 函数的好处在于：代码苏更少，更清晰，某些情况下甚至比 for 循环更快。</p>
<p>使用 <code>lapply()</code> 函数的一个重要特征是可以<strong>平行计算</strong>。R 中的 parallel 包存在一个 lapply() 函数的平行计算版本 <code>mclapply()</code>（mc 表示 multicore）。</p>
<p>这个函数会使用你在 options() 函数设置的核心数（如果不设置，会使用两个核心。）（注意，lapply 和 mclapply  接的函数只有名称，没有括号和参数）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; library(parallel)</span><br><span class="line">&gt; results &lt;- mclapply(my_samples, slowFunction)</span><br><span class="line">&gt; options(cores&#x3D;3)</span><br><span class="line">&gt; getOption(&#39;cores&#39;)</span><br></pre></td></tr></table></figure>
<p>对于列表中有NA的，lapply ()  还需要添加的参数。一般来说传递参数的时候需要写参数名，一方面提高代码的可读性，一方面避免用错了参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; ll$a[3] &lt;- NA</span><br><span class="line">&gt; lapply(ll, mean)</span><br><span class="line">$a</span><br><span class="line">[1] NA</span><br><span class="line">$b</span><br><span class="line">[1] 4.19003</span><br><span class="line">$c</span><br><span class="line">[1] 5.53541</span><br><span class="line">&gt; lapply(ll, mean, na.rm&#x3D;TRUE)</span><br><span class="line">$a</span><br><span class="line">[1] 1.216768</span><br><span class="line">$b</span><br><span class="line">[1] 4.19003</span><br><span class="line">$c</span><br><span class="line">[1] 5.53541</span><br></pre></td></tr></table></figure>
<p>你可以把 <code>mean()</code> 包装到另外一个函数中，这样就能添加额外的参数了。R 中函数的 <code>return</code> 是可选的，默认会见最后一行表达式返给 <code>return</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">meanRemoveNA &lt;- <span class="keyword">function</span>(x)&#123;</span><br><span class="line">  mean(x,na.rm = <span class="literal">TRUE</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lapply(ll,meanRemoveNA)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于我们需要经常使用的函数，我们需要打磨这些函数，可以让函数的文档输出功能更完善，也可以增加一些额外的功能。比如下面这一版的函数会提醒用户，移除了一些缺失值（这个功能可以通过设置 <code>warn=FALSE</code> 关闭）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">meanRemoveNAVerbose &lt;- <span class="keyword">function</span>(x, warn=<span class="literal">TRUE</span>) &#123;</span><br><span class="line">	<span class="comment"># A function that removes missing values when calculating the mean</span></span><br><span class="line">	<span class="comment"># and warns us about it.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">any</span>(<span class="built_in">is.na</span>(x)) &amp;&amp; warn) &#123;</span><br><span class="line">		warning(<span class="string">&quot;removing some missing values!&quot;</span>)</span><br><span class="line">		&#125;  </span><br><span class="line">     mean(x, na.rm=<span class="literal">TRUE</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数中定义的变量是<strong>局部变量</strong>，不会影响同名的全局变量。</p>
<p>函数的优点是<strong>可重复利用</strong>，缺点<strong>难以debug</strong>。但是，在R中，存在很多Debug的函数，比如 <code>browser()</code> 函数，可以中断函数。运行后输入 n (执行下一行) ， c (继续执行这一行) ， Q（退出）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">foo &lt;- <span class="keyword">function</span>(x) &#123;</span><br><span class="line">  a &lt;- 2  </span><br><span class="line">  <span class="built_in">browser</span>()  </span><br><span class="line">  y &lt;- x + a</span><br><span class="line">  <span class="built_in">return</span>(y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; foo(<span class="number">1</span>)</span><br><span class="line">Called from: foo(<span class="number">1</span>)</span><br><span class="line">Browse[<span class="number">1</span>]&gt;</span><br><span class="line">Browse[<span class="number">1</span>]&gt; n</span><br><span class="line">debug at <span class="comment">#4: y &lt;- x + a</span></span><br><span class="line">Browse[<span class="number">2</span>]&gt; n</span><br><span class="line">debug at <span class="comment">#5: return(y)</span></span><br><span class="line">Browse[<span class="number">2</span>]&gt; y</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="8-3-11-Working-with-the-Split-Apply-Combine-Pattern">8.3.11 Working with the Split-Apply-Combine Pattern</h3>
<p>一种常见的数据分析方法是<strong>先将需要分析的数据分组，对每组数据应用一个函数，然后合并结果</strong>，称之为 <em>split-apply-combine</em>。</p>
<p>首先我们先使用 <code>split()</code> 函数通过 d<img src="https://math.now.sh?inline=GC.binned%20%EF%BC%88factor%EF%BC%89%E5%B0%86%20d" style="display:inline-block;margin: 0;"/>depth 切分为一个列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; d_split &lt;- split(d$depth, d$GC.binned)</span><br><span class="line">&gt; str(d_split)</span><br><span class="line">List of 5</span><br><span class="line"> $ (0.716,17.7]: num [1:6] 4.57 1.12 6.95 2.66 3.69 3.87</span><br><span class="line"> $ (17.7,34.7] : num [1:4976] 8 8.38 9.02 10.31 12.09 ...</span><br><span class="line"> $ (34.7,51.6] : num [1:45784] 6.68 9.06 10.26 8.06 7.05 ...</span><br><span class="line"> $ (51.6,68.5] : num [1:8122] 3.41 7 6.63 7.15 6.97 4.77 5.18 6.6 6.62 5.05 ...</span><br><span class="line"> $ (68.5,85.6] : num [1:252] 8.04 1.96 3.71 1.97 4.82 4.22 3.76 3.84 1.85 1.05 ...</span><br></pre></td></tr></table></figure>
<p>之后我们可以通过 <code>lapply()</code> 函数对每组数据采用相同的函数处理</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; lapply(d_split, mean)</span><br><span class="line">$`(0.716,17.7]`</span><br><span class="line">[<span class="number">1</span>] <span class="number">3.8</span></span><br><span class="line"></span><br><span class="line">$`(17.7,34.7]`</span><br><span class="line">[<span class="number">1</span>] <span class="number">8.8</span></span><br><span class="line"></span><br><span class="line">$`(34.7,51.6]`</span><br><span class="line">[<span class="number">1</span>] <span class="number">8.3</span></span><br><span class="line"></span><br><span class="line">$`(51.6,68.5]`</span><br><span class="line">[<span class="number">1</span>] <span class="number">7.3</span></span><br><span class="line"></span><br><span class="line">$`(68.5,85.6]`</span><br><span class="line">[<span class="number">1</span>] <span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后，我们需要整合结果（这里结果就是我们想要的），比如我们可以使用<code>unlist()</code> 函数将结果的列表形式转化为向量（ following  R’s  coercion  rules）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; unlist(lapply(d_split, mean))</span><br><span class="line">(<span class="number">0.716</span>,<span class="number">17.7</span>]  (<span class="number">17.7</span>,<span class="number">34.7</span>]  (<span class="number">34.7</span>,<span class="number">51.6</span>]  (<span class="number">51.6</span>,<span class="number">68.5</span>] </span><br><span class="line">         <span class="number">3.8</span>          <span class="number">8.8</span>          <span class="number">8.3</span>          <span class="number">7.3</span> </span><br><span class="line"> (<span class="number">68.5</span>,<span class="number">85.6</span>] </span><br><span class="line">         <span class="number">4.0</span> </span><br></pre></td></tr></table></figure>
<p>对于一个列表中每个元素中具有多个值的情况，可以联合使用 <code>do.call()</code> 函数和<code>rbind()</code>函数将列表其转化为一个矩阵。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; do.call(rbind, lapply(split(d$depth, d$GC.binned), summary))</span><br><span class="line">             Min. <span class="number">1</span>st Qu. Median Mean <span class="number">3</span>rd Qu. Max.</span><br><span class="line">(<span class="number">0.716</span>,<span class="number">17.7</span>]  <span class="number">1.1</span>     <span class="number">2.9</span>    <span class="number">3.8</span>  <span class="number">3.8</span>     <span class="number">4.4</span>  <span class="number">7.0</span></span><br><span class="line">(<span class="number">17.7</span>,<span class="number">34.7</span>]   <span class="number">1.0</span>     <span class="number">7.7</span>    <span class="number">8.7</span>  <span class="number">8.8</span>     <span class="number">9.8</span> <span class="number">17.8</span></span><br><span class="line">(<span class="number">34.7</span>,<span class="number">51.6</span>]   <span class="number">1.0</span>     <span class="number">7.1</span>    <span class="number">8.3</span>  <span class="number">8.3</span>     <span class="number">9.5</span> <span class="number">21.9</span></span><br><span class="line">(<span class="number">51.6</span>,<span class="number">68.5</span>]   <span class="number">1.0</span>     <span class="number">6.0</span>    <span class="number">7.2</span>  <span class="number">7.3</span>     <span class="number">8.5</span> <span class="number">21.2</span></span><br><span class="line">(<span class="number">68.5</span>,<span class="number">85.6</span>]   <span class="number">1.0</span>     <span class="number">2.7</span>    <span class="number">4.0</span>  <span class="number">4.0</span>     <span class="number">5.2</span>  <span class="number">9.7</span></span><br></pre></td></tr></table></figure>
<p>R 本身还有一些比较方便的函数，比如 <code>tapply()</code> 和 <code>aggregate()</code>可以一步到位实现上面的功能。</p>
<p>那为什么还要像上面那样使用 <code>split()</code> <code>lapply()</code>  <code>do.call()</code> 函数一步一步去做呢？第一，一步一步做可以让你很灵活，中间可以改；第二，使用 dplyr 包 可以更方便地实现这个功能。</p>
<p><img src="31.png" alt="31"></p>
<h4 id="Understanding-do-call">Understanding do.call()</h4>
<p>在R中，运行函数需要写明函数名和参数名，比如 <code>func(arg1, arg2, arg3)</code>，func 是函数名， arg1、arg2 、arg3 是参数名。</p>
<p>do.call() 可以让你通过使用一个函数名和 <strong>一个参数的列表</strong>  来使用函数。比如 <code>func(arg1, arg2, arg3)</code>  等价于 <code>do.call(func, list(arg1, arg2, arg3))</code> 。如果传递给 do.call() 函数的列表的元素都有名称，这些元素的名称会匹配函数的参数名称。比如，对于 <code>rnorm()</code> 函数，可以这么写：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; do.call(rnorm, <span class="built_in">list</span>(n=<span class="number">4</span>, mean=<span class="number">3.3</span>, sd=<span class="number">4</span>))</span><br><span class="line">[<span class="number">1</span>] <span class="number">8.351817</span> <span class="number">1.995067</span> <span class="number">8.619197</span> <span class="number">8.389717</span></span><br></pre></td></tr></table></figure>
<p><code>do.call()</code> 看上去复杂，但是当函数需要使用的参数都在一个<strong>list</strong>里，这种传参方法就很实用，比如这里使用<code>cbind()</code> 或 <code>rbind()</code> 函数整合结果。</p>
<h3 id="8-3-12-Exploring-Dataframes-with-dplyr">8.3.12 Exploring Dataframes with dplyr</h3>
<p>在 R 中的数据操作都与<strong>数据框</strong>有关。dplyr 巩固和简化了很多设计数据框的操作，而且 dplyr 速度很快，它的核心函数是用 C++写的。</p>
<p>dplyr 有5个操作数据框的基本函数：arrange(), filter(), mutate(), select(), summarize()。这些你都可以用R 的基础函数实现，但是 dplyr 的优势在于稳定、速度快并且用途广。</p>
<p>通常数据框的行数和列数都很多，无法全部在屏幕上打印出来，<code>dplyr</code> 使用一个 函数 <code>tbl_df</code> 可以折叠数据框，这样 print 的时候不会铺满全屏（相当于 head()）(到这里都感觉没什么用)</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; install.packages(<span class="string">&quot;dplyr&quot;</span>) <span class="comment"># install dplyr if it&#x27;s not already installed</span></span><br><span class="line">&gt; library(dplyr)</span><br><span class="line">&gt; d_df &lt;- tbl_df(d)</span><br><span class="line">&gt; d_df</span><br><span class="line"><span class="comment"># A tibble: 59,140 x 20</span></span><br><span class="line">   start   end total.SNPs total.Bases depth unique.SNPs</span><br><span class="line">   &lt;int&gt; &lt;int&gt;      &lt;int&gt;       &lt;int&gt; &lt;dbl&gt;       &lt;int&gt;</span><br><span class="line"> <span class="number">1</span> <span class="number">55001</span> <span class="number">56000</span>          <span class="number">0</span>        <span class="number">1894</span>  <span class="number">3.41</span>           <span class="number">0</span></span><br><span class="line"> <span class="number">2</span> <span class="number">56001</span> <span class="number">57000</span>          <span class="number">5</span>        <span class="number">6683</span>  <span class="number">6.68</span>           <span class="number">2</span></span><br><span class="line"> <span class="number">3</span> <span class="number">57001</span> <span class="number">58000</span>          <span class="number">1</span>        <span class="number">9063</span>  <span class="number">9.06</span>           <span class="number">1</span></span><br><span class="line"> <span class="number">4</span> <span class="number">58001</span> <span class="number">59000</span>          <span class="number">7</span>       <span class="number">10256</span> <span class="number">10.3</span>            <span class="number">3</span></span><br><span class="line"> <span class="number">5</span> <span class="number">59001</span> <span class="number">60000</span>          <span class="number">4</span>        <span class="number">8057</span>  <span class="number">8.06</span>           <span class="number">4</span></span><br><span class="line"> <span class="number">6</span> <span class="number">60001</span> <span class="number">61000</span>          <span class="number">6</span>        <span class="number">7051</span>  <span class="number">7.05</span>           <span class="number">2</span></span><br><span class="line"> <span class="number">7</span> <span class="number">61001</span> <span class="number">62000</span>          <span class="number">7</span>        <span class="number">6950</span>  <span class="number">6.95</span>           <span class="number">2</span></span><br><span class="line"> <span class="number">8</span> <span class="number">62001</span> <span class="number">63000</span>          <span class="number">1</span>        <span class="number">8834</span>  <span class="number">8.83</span>           <span class="number">1</span></span><br><span class="line"> <span class="number">9</span> <span class="number">63001</span> <span class="number">64000</span>          <span class="number">1</span>        <span class="number">9629</span>  <span class="number">9.63</span>           <span class="number">1</span></span><br><span class="line">10 <span class="number">64001</span> <span class="number">65000</span>          <span class="number">3</span>        <span class="number">7999</span>  <span class="number">8</span>              <span class="number">1</span></span><br><span class="line"><span class="comment"># ... with 59,130 more rows, and 14 more variables:</span></span><br><span class="line"><span class="comment">#   dhSNPs &lt;int&gt;, reference.Bases &lt;int&gt;, Theta &lt;dbl&gt;,</span></span><br><span class="line"><span class="comment">#   Pi &lt;dbl&gt;, Heterozygosity &lt;dbl&gt;, X.GC &lt;dbl&gt;,</span></span><br><span class="line"><span class="comment">#   Recombination &lt;dbl&gt;, Divergence &lt;dbl&gt;, Constraint &lt;int&gt;,</span></span><br><span class="line"><span class="comment">#   SNPs &lt;int&gt;, position &lt;dbl&gt;, diversity &lt;dbl&gt;, cent &lt;lgl&gt;,</span></span><br><span class="line"><span class="comment">#   GC.binned &lt;fct&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们可以使用 <code>select()</code> 函数挑选某些列</p>
<p>这和 <code>d[, c(&quot;start&quot;, &quot;end&quot;, &quot;Pi&quot;, &quot;Recombination&quot;, &quot;depth&quot;)]</code> 是等价的，但是 select 可以省略双引号。<code>select()</code> 可以写一个列的范围，比如 <code>select(d_df, start:total.Bases)</code> ，而且你可以通过在范围前面加一个负号，来剔除某些列。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; select(d_df, start, end, Pi, Recombination, depth)</span><br><span class="line"> start   end    Pi Recombination depth</span><br><span class="line">   &lt;int&gt; &lt;int&gt; &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;</span><br><span class="line"> <span class="number">1</span> <span class="number">55001</span> <span class="number">56000</span>  <span class="number">0</span>          <span class="number">0.00960</span>  <span class="number">3.41</span></span><br><span class="line"> <span class="number">2</span> <span class="number">56001</span> <span class="number">57000</span> <span class="number">10.4</span>        <span class="number">0.00960</span>  <span class="number">6.68</span></span><br><span class="line"> <span class="number">3</span> <span class="number">57001</span> <span class="number">58000</span>  <span class="number">1.99</span>       <span class="number">0.00960</span>  <span class="number">9.06</span></span><br><span class="line"> <span class="number">4</span> <span class="number">58001</span> <span class="number">59000</span>  <span class="number">9.56</span>       <span class="number">0.00960</span> <span class="number">10.3</span> </span><br><span class="line"> <span class="number">5</span> <span class="number">59001</span> <span class="number">60000</span>  <span class="number">8.51</span>       <span class="number">0.00960</span>  <span class="number">8.06</span></span><br><span class="line"> <span class="number">6</span> <span class="number">60001</span> <span class="number">61000</span>  <span class="number">9.12</span>       <span class="number">0.00960</span>  <span class="number">7.05</span></span><br><span class="line"> <span class="number">7</span> <span class="number">61001</span> <span class="number">62000</span>  <span class="number">8.06</span>       <span class="number">0.00960</span>  <span class="number">6.95</span></span><br><span class="line"> <span class="number">8</span> <span class="number">62001</span> <span class="number">63000</span>  <span class="number">2.06</span>       <span class="number">0.00960</span>  <span class="number">8.83</span></span><br><span class="line"> <span class="number">9</span> <span class="number">63001</span> <span class="number">64000</span>  <span class="number">1.88</span>       <span class="number">0.00960</span>  <span class="number">9.63</span></span><br><span class="line">10 <span class="number">64001</span> <span class="number">65000</span>  <span class="number">5.41</span>       <span class="number">0.00958</span>  <span class="number">8</span>   </span><br><span class="line"><span class="comment"># ... with 59,130 more rows</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; select(d_df, -(start:cent))</span><br><span class="line">  GC.binned  </span><br><span class="line">   &lt;fct&gt;      </span><br><span class="line"> <span class="number">1</span> (<span class="number">51.6</span>,<span class="number">68.5</span>]</span><br><span class="line"> <span class="number">2</span> (<span class="number">34.7</span>,<span class="number">51.6</span>]</span><br><span class="line"> <span class="number">3</span> (<span class="number">34.7</span>,<span class="number">51.6</span>]</span><br><span class="line"> <span class="number">4</span> (<span class="number">34.7</span>,<span class="number">51.6</span>]</span><br><span class="line"> <span class="number">5</span> (<span class="number">34.7</span>,<span class="number">51.6</span>]</span><br><span class="line"> <span class="number">6</span> (<span class="number">34.7</span>,<span class="number">51.6</span>]</span><br><span class="line"> <span class="number">7</span> (<span class="number">34.7</span>,<span class="number">51.6</span>]</span><br><span class="line"> <span class="number">8</span> (<span class="number">34.7</span>,<span class="number">51.6</span>]</span><br><span class="line"> <span class="number">9</span> (<span class="number">34.7</span>,<span class="number">51.6</span>]</span><br><span class="line">10 (<span class="number">17.7</span>,<span class="number">34.7</span>]</span><br><span class="line"><span class="comment"># ... with 59,130 more rows</span></span><br></pre></td></tr></table></figure>
<p>你可以使用 filter() 函数取子集，比如 <code>d[d$Pi  &gt;  16  &amp;  d$percent.GC  &gt;  80,  ]</code>， 在 <code>filter()</code> 函数中 多个条件使用逗号 <code>,</code> 分隔</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; filter(d_df, Pi &gt; <span class="number">16</span>, X.GC &gt; <span class="number">80</span>)</span><br><span class="line"> start    end total.SNPs total.Bases depth unique.SNPs</span><br><span class="line">   &lt;int&gt;  &lt;int&gt;      &lt;int&gt;       &lt;int&gt; &lt;dbl&gt;       &lt;int&gt;</span><br><span class="line">1 <span class="number">6.31e7</span> <span class="number">6.31e7</span>          <span class="number">5</span>         <span class="number">947</span>  <span class="number">2.39</span>           <span class="number">2</span></span><br><span class="line">2 <span class="number">6.32e7</span> <span class="number">6.32e7</span>          <span class="number">2</span>        <span class="number">1623</span>  <span class="number">3.21</span>           <span class="number">2</span></span><br><span class="line">3 <span class="number">6.32e7</span> <span class="number">6.32e7</span>          <span class="number">5</span>        <span class="number">1395</span>  <span class="number">1.89</span>           <span class="number">3</span></span><br><span class="line"><span class="comment"># ... with 14 more variables: dhSNPs &lt;int&gt;,</span></span><br><span class="line"><span class="comment">#   reference.Bases &lt;int&gt;, Theta &lt;dbl&gt;, Pi &lt;dbl&gt;,</span></span><br><span class="line"><span class="comment">#   Heterozygosity &lt;dbl&gt;, X.GC &lt;dbl&gt;, Recombination &lt;dbl&gt;,</span></span><br><span class="line"><span class="comment">#   Divergence &lt;dbl&gt;, Constraint &lt;int&gt;, SNPs &lt;int&gt;,</span></span><br><span class="line"><span class="comment">#   position &lt;dbl&gt;, diversity &lt;dbl&gt;, cent &lt;lgl&gt;,</span></span><br><span class="line"><span class="comment">#   GC.binned &lt;fct&gt;</span></span><br></pre></td></tr></table></figure>
<p>你可以使用 <code>arrange()</code> 来简化排序的操作，比如 <code>d[order(d$X.GC), ]</code></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; arrange(d_df, depth)</span><br><span class="line"><span class="comment"># A tibble: 59,140 x 20</span></span><br><span class="line">    start    end total.SNPs total.Bases depth unique.SNPs</span><br><span class="line">    &lt;int&gt;  &lt;int&gt;      &lt;int&gt;       &lt;int&gt; &lt;dbl&gt;       &lt;int&gt;</span><br><span class="line"> <span class="number">1</span> <span class="number">1.23e6</span> <span class="number">1.24e6</span>          <span class="number">0</span>         <span class="number">444</span>     <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"> <span class="number">2</span> <span class="number">1.58e6</span> <span class="number">1.58e6</span>          <span class="number">0</span>         <span class="number">716</span>     <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"> <span class="number">3</span> <span class="number">2.80e6</span> <span class="number">2.80e6</span>          <span class="number">0</span>         <span class="number">277</span>     <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"> <span class="number">4</span> <span class="number">2.80e6</span> <span class="number">2.80e6</span>          <span class="number">0</span>         <span class="number">115</span>     <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"> <span class="number">5</span> <span class="number">7.09e6</span> <span class="number">7.09e6</span>          <span class="number">0</span>         <span class="number">519</span>     <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"> <span class="number">6</span> <span class="number">7.09e6</span> <span class="number">7.09e6</span>          <span class="number">2</span>         <span class="number">686</span>     <span class="number">1</span>           <span class="number">2</span></span><br><span class="line"> <span class="number">7</span> <span class="number">1.16e7</span> <span class="number">1.16e7</span>          <span class="number">1</span>         <span class="number">429</span>     <span class="number">1</span>           <span class="number">1</span></span><br><span class="line"> <span class="number">8</span> <span class="number">1.28e7</span> <span class="number">1.28e7</span>          <span class="number">0</span>         <span class="number">165</span>     <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"> <span class="number">9</span> <span class="number">2.58e7</span> <span class="number">2.58e7</span>          <span class="number">0</span>         <span class="number">221</span>     <span class="number">1</span>           <span class="number">0</span></span><br><span class="line">10 <span class="number">2.58e7</span> <span class="number">2.58e7</span>          <span class="number">0</span>         <span class="number">172</span>     <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"><span class="comment"># ... with 59,130 more rows, and 14 more variables:</span></span><br><span class="line"><span class="comment">#   dhSNPs &lt;int&gt;, reference.Bases &lt;int&gt;, Theta &lt;dbl&gt;,</span></span><br><span class="line"><span class="comment">#   Pi &lt;dbl&gt;, Heterozygosity &lt;dbl&gt;, X.GC &lt;dbl&gt;,</span></span><br><span class="line"><span class="comment">#   Recombination &lt;dbl&gt;, Divergence &lt;dbl&gt;, Constraint &lt;int&gt;,</span></span><br><span class="line"><span class="comment">#   SNPs &lt;int&gt;, position &lt;dbl&gt;, diversity &lt;dbl&gt;, cent &lt;lgl&gt;,</span></span><br><span class="line"><span class="comment">#   GC.binned &lt;fct&gt;</span></span><br></pre></td></tr></table></figure>
<p>你可以在 arrange() 中使用 <code>desc()</code> 函数来逆序排列</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; arrange(d_df, desc(total.SNPs), desc(depth))</span><br><span class="line"><span class="comment"># A tibble: 59,140 x 20</span></span><br><span class="line">    start    end total.SNPs total.Bases depth unique.SNPs</span><br><span class="line">    &lt;int&gt;  &lt;int&gt;      &lt;int&gt;       &lt;int&gt; &lt;dbl&gt;       &lt;int&gt;</span><br><span class="line"> <span class="number">1</span> <span class="number">2.62e6</span> <span class="number">2.62e6</span>         <span class="number">93</span>       <span class="number">11337</span> <span class="number">11.3</span>           <span class="number">13</span></span><br><span class="line"> <span class="number">2</span> <span class="number">1.30e7</span> <span class="number">1.30e7</span>         <span class="number">88</span>       <span class="number">11784</span> <span class="number">11.8</span>           <span class="number">11</span></span><br><span class="line"> <span class="number">3</span> <span class="number">4.74e7</span> <span class="number">4.74e7</span>         <span class="number">87</span>       <span class="number">12505</span> <span class="number">12.5</span>            <span class="number">9</span></span><br><span class="line"> <span class="number">4</span> <span class="number">6.00e7</span> <span class="number">6.00e7</span>         <span class="number">84</span>       <span class="number">11553</span> <span class="number">11.6</span>           <span class="number">15</span></span><br><span class="line"> <span class="number">5</span> <span class="number">8.77e6</span> <span class="number">8.77e6</span>         <span class="number">83</span>       <span class="number">10253</span> <span class="number">10.2</span>           <span class="number">12</span></span><br><span class="line"> <span class="number">6</span> <span class="number">1.78e7</span> <span class="number">1.78e7</span>         <span class="number">81</span>       <span class="number">13347</span> <span class="number">13.4</span>           <span class="number">11</span></span><br><span class="line"> <span class="number">7</span> <span class="number">4.74e7</span> <span class="number">4.74e7</span>         <span class="number">80</span>       <span class="number">14218</span> <span class="number">14.2</span>            <span class="number">8</span></span><br><span class="line"> <span class="number">8</span> <span class="number">4.59e7</span> <span class="number">4.59e7</span>         <span class="number">80</span>        <span class="number">9820</span>  <span class="number">9.82</span>          <span class="number">11</span></span><br><span class="line"> <span class="number">9</span> <span class="number">2.49e7</span> <span class="number">2.49e7</span>         <span class="number">78</span>       <span class="number">11206</span> <span class="number">11.2</span>           <span class="number">16</span></span><br><span class="line">10 <span class="number">5.45e7</span> <span class="number">5.45e7</span>         <span class="number">76</span>        <span class="number">9691</span>  <span class="number">9.69</span>          <span class="number">12</span></span><br><span class="line"><span class="comment"># ... with 59,130 more rows, and 14 more variables:</span></span><br><span class="line"><span class="comment">#   dhSNPs &lt;int&gt;, reference.Bases &lt;int&gt;, Theta &lt;dbl&gt;,</span></span><br><span class="line"><span class="comment">#   Pi &lt;dbl&gt;, Heterozygosity &lt;dbl&gt;, X.GC &lt;dbl&gt;,</span></span><br><span class="line"><span class="comment">#   Recombination &lt;dbl&gt;, Divergence &lt;dbl&gt;, Constraint &lt;int&gt;,</span></span><br><span class="line"><span class="comment">#   SNPs &lt;int&gt;, position &lt;dbl&gt;, diversity &lt;dbl&gt;, cent &lt;lgl&gt;,</span></span><br><span class="line"><span class="comment">#   GC.binned &lt;fct&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过使用 <code>mutate()</code> 函数可以增加新列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; d_df &lt;- select(d_df, -diversity) # remove our earlier diversity column</span><br><span class="line">&gt; d_df &lt;- mutate(d_df, diversity &#x3D; Pi&#x2F;(10*1000))</span><br><span class="line">&gt; d_df</span><br></pre></td></tr></table></figure>
<p>通过 <code>%&gt;%</code> 可以创建 <code>dplyr</code> 的 pipeline， <code>%&gt;%</code> 会<strong>将左边的变量视为右边函数的第一个参数</strong>，比如：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt;  d_df %&gt;% mutate(GC.scaled = scale(percent.GC)) %&gt;% </span><br><span class="line">	        filter(GC.scaled &gt; <span class="number">4</span>, depth &gt; <span class="number">4</span>) %&gt;% </span><br><span class="line">            select(start, end, depth, GC.scaled, percent.GC) %&gt;%  </span><br><span class="line">            arrange(desc(depth))</span><br></pre></td></tr></table></figure>
<p><code>dplyr</code> 包的一个原始功能是可以处理分组和数据的描述统计</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; mtfs_df &lt;- tbl_df(mtfs)</span><br><span class="line">&gt; mtfs_df %&gt;% group_by(chr)</span><br></pre></td></tr></table></figure>
<p>汇总分组统计，我们可以一样使用dplyr 的 summarize() 函数去汇总，可以按照每一列去汇总。这里的 n() 函数返回每组观测值的数目。<code>n_distinct()</code> 返回每组观测值去重后的数目。first()  last()  nth()  返回第一个、最后一个和第n个观测值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;  mtfs_df %&gt;%</span><br><span class="line">	group_by(chr) %&gt;%</span><br><span class="line">    summarize(max_recom &#x3D; max(recom), mean_recom &#x3D; mean(recom), num&#x3D;n())</span><br></pre></td></tr></table></figure>
<p>结果再排序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;  mtfs_df %&gt;%</span><br><span class="line">	group_by(chr) %&gt;%</span><br><span class="line">    summarize(max_recom &#x3D; max(recom), mean_recom &#x3D; mean(recom), num&#x3D;n()) %&gt;%     </span><br><span class="line">    arrange(desc(max_recom))</span><br></pre></td></tr></table></figure>
<h3 id="8-3-13-Working-with-Strings">8.3.13 Working with Strings</h3>
<p>R 语言并不是处理大多数生信文本处理的最佳语言。首先，R 处理数据前会将所有数据都存储在内存中；很多生信文本任务，更适合采用<strong>流处理</strong>的方式。其次，R处理字符串的方式，相比于python更加笨拙。</p>
<p>虽然有这些局限，但是有些时候我们还是需要用R来处理字符串。比如探索性数据分析。</p>
<p>如果你想要知道字符串的长度，使用 <code>nchar()</code> 函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; nchar(c(&quot;AGCTAG&quot;, &quot;ATA&quot;, &quot;GATCTGAG&quot;, &quot;&quot;))</span><br><span class="line">[1] 6 3 8 0</span><br></pre></td></tr></table></figure>
<p>我们可以通过 <code>grep()</code> 或 <code>regexpr()</code> 来查找符合某种pattern 的字符串向量的子集。</p>
<p><code>grep(pattern,x)</code>  返回匹配的字符的<strong>位置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; re_sites &lt;- c(&quot;CTGCAG&quot;, &quot;CGATCG&quot;, &quot;CAGCTG&quot;, &quot;CCCACA&quot;)</span><br><span class="line">&gt; grep(&quot;CAG&quot;, re_sites)</span><br></pre></td></tr></table></figure>
<p><code>grep()</code> 函数默认使用   POSIX  extended  regular  expressions，因此我们可以采用更加复杂的 patterns</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; grep(&quot;CT[CG]&quot;, re_sites)</span><br><span class="line">[1] 1 3</span><br></pre></td></tr></table></figure>
<p>你可以通过设置 <code>perl=TRUE</code> 来采用 Perl Compatible Regular Expressions (PCRE)  语法；你也可以通过 <code>fixed=TRUE</code> 来设置不使用正则表达式（特殊字符也视为一般字符）。</p>
<p>比如，下式中你打算匹配6号染色体，但是不能直接使用 grep(“6”, chrs) ，因为这会匹配到 16。</p>
<p>下式中 \d 表示数字，整个匹配模式改为6前面不能是数字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; chrs &lt;- c(&quot;chrom6&quot;, &quot;chr2&quot;, &quot;chr6&quot;, &quot;chr4&quot;, &quot;chr1&quot;, &quot;chr16&quot;, &quot; chrom8&quot;)</span><br><span class="line">&gt; grep(&quot;[^\\d]6&quot;, chrs, perl&#x3D;TRUE)</span><br><span class="line">[1] 1 3</span><br><span class="line">&gt; chrs[grep(&quot;[^\\d]6&quot;, chrs, perl&#x3D;TRUE)]</span><br><span class="line">[1] &quot;chrom6&quot; &quot;chr6&quot;</span><br></pre></td></tr></table></figure>
<p>与 grep 不一样， <code>regexpr()</code> 每个元素都会返回一个值，如果不匹配会返回 -1。（这个函数没搞懂，不用）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; regexpr(<span class="string">&quot;[^\\d]6&quot;</span>, chrs, perl=<span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure>
<p>我们可以用 <code>sub()</code> 函数来替换字符串。我们先开始一个简单的例子。 sub(pattern , replacement, x) ，会替换 x 向量中每个元素的 <strong>第一个</strong> 出现的pattern ，替换为 replacement。 <code>sub()</code> 函数 通过支持 perl=TRUE 和  fixed=TRUE。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; sub(pattern&#x3D;&quot;Watson&quot;, replacement&#x3D;&quot;Watson, Franklin,&quot;,      </span><br><span class="line">	x&#x3D;&quot;Watson and Crick discovered DNA&#39;s structure.&quot;)</span><br><span class="line">[1] &quot;Watson, Franklin, and Crick discovered DNA&#39;s structure.&quot;</span><br></pre></td></tr></table></figure>
<p>替换功能除了可以替换，还可以用于<strong>提取信息</strong>。这样做是通过正则表达式 <em>capturing groups</em>（捕获组）。这个功能会提取<strong>括号内的内容</strong>。</p>
<p>下面是几个例子，使用正则的时候一定要小心 <strong>silent error</strong>，比如下面第三个例子，得到的结果就是错的，这里是由于<code>.*</code> 是贪婪的。</p>
<p><img src="32.png" alt="32"></p>
<p><code>strsplit(x, split)</code> 将字符串分开，按照 split 将 x 分开。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; region &lt;- &quot;chr10:158395-172881&quot;</span><br><span class="line">&gt; chunks &lt;- sub(&quot;(chr[\\d+MYX]+):(\\d+)-(\\d+)&quot;,</span><br><span class="line">				&quot;\\1;;\\2;;\\3&quot;,</span><br><span class="line">                region, perl&#x3D;TRUE)</span><br><span class="line">&gt; strsplit(chunks, &quot;;;&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="8-4-Developing-Workflows-with-R-Scripts">8.4 Developing Workflows with R Scripts</h2>
<h3 id="8-4-1-Control-Flow-if-for-and-while">8.4.1 Control Flow: if, for, and while</h3>
<p>R本身通过 apply() 家族来避免使用循环，但有时仍需要使用循环。</p>
<p>if、for、while 循环基本语法如下</p>
<p><img src="33.png" alt=""></p>
<h3 id="8-4-2-Working-with-R-Scripts">8.4.2 Working with R Scripts</h3>
<p>第一种 在R中，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; source(&quot;my_analysis.R&quot;)</span><br></pre></td></tr></table></figure>
<p>第二种，在linux 中，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Rscript --vanilla my_analysis.R</span><br></pre></td></tr></table></figure>
<p>推荐加上参数 <strong>–vanilla</strong>，因为默认情况下 Rscript 可以存储所有过去保存的环境和现在的环境（environment），即便执行结束了。（这段话没看懂，但是作者建议加上，那还是加上吧）</p>
<p><img src="34.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--vanilla</span><br><span class="line">       Combine --no-save, --no-restore, --no-site-file --no-init-file and --no-environ</span><br></pre></td></tr></table></figure>
<p>R代码加参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">args &lt;- commandArgs(trailingOnly&#x3D;TRUE)</span><br></pre></td></tr></table></figure>
<h3 id="8-4-3-Workflows-for-Loading-and-Combining-Multiple-Files">8.4.3 Workflows for Loading and Combining Multiple Files</h3>
<p>当你需要同时读取多个文件时，比如多条染色体的文件。第一步，获取这些文件的文件名，<code>list.files()</code> 可以做到，而且支持正则表达式（尽量严格）, 这里需要用两个反斜杠来一般化这里的<code>.</code> 。通过设置 <code>full.names=TRUE</code> ，结果会给出相对路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; list.files(&quot;hotspots&quot;, pattern&#x3D;&quot;hotspots.*\\.bed&quot;)</span><br><span class="line"> [1] &quot;hotspots_chr1.bed&quot;  &quot;hotspots_chr10.bed&quot; &quot;hotspots_chr11.bed&quot;</span><br><span class="line"> [4] &quot;hotspots_chr12.bed&quot; &quot;hotspots_chr13.bed&quot; &quot;hotspots_chr14.bed&quot;</span><br><span class="line"> [...]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; hs_files &lt;- list.files(&quot;hotspots&quot;, pattern&#x3D;&quot;hotspots.*\\.bed&quot;, full.names&#x3D;TRUE)</span><br></pre></td></tr></table></figure>
<p>之后你就可以使用 lapply() 对每个文件采用相同的函数，之后可以可以再采用 do.call() 合并多个文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; bedcols &lt;- c(&quot;chr&quot;, &quot;start&quot;, &quot;end&quot;)</span><br><span class="line">&gt; loadFile &lt;- function(x) read.delim(x, header&#x3D;FALSE, col.names&#x3D;bedcols)</span><br><span class="line">&gt; hs &lt;- lapply(hs_files, loadFile)</span><br><span class="line">&gt; head(hs[[1]])</span><br><span class="line">&gt; hsd &lt;- do.call(rbind, hs)</span><br></pre></td></tr></table></figure>
<p>可以不用先合并文件，使用 lapply() 循环处理每个文件即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loadAndSummarizeFile &lt;- function(x) &#123;</span><br><span class="line">	df &lt;- read.table(x, header&#x3D;FALSE, col.names&#x3D;bedcols)</span><br><span class="line">	data.frame(chr&#x3D;unique(df$chr), n&#x3D;nrow(df), mean_len&#x3D;mean(df$end - df$start))</span><br><span class="line">&#125;</span><br><span class="line">&gt; chr_hs_summaries &lt;- lapply(hs_files, loadAndSummarizeFile)</span><br><span class="line">&gt; chr_hs_summaries[1:2]</span><br></pre></td></tr></table></figure>
<h3 id="8-4-4-Exporting-Data">8.4.4 Exporting Data</h3>
<p><code>write.table()</code> 有一些不太好的地方，需要手动设置，比如<code>quote</code>, <code>row.names</code> 等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; write.table(mtfs, file&#x3D;&quot;hotspot_motifs.txt&quot;, quote&#x3D;FALSE,              </span><br><span class="line">              sep&#x3D;&quot;\t&quot;, row.names&#x3D;FALSE, col.names&#x3D;TRUE)</span><br></pre></td></tr></table></figure>
<p>R 也可以输出为压缩文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; hs_gzf &lt;- gzfile(&quot;hotspot_motifs.txt.gz&quot;)</span><br><span class="line">&gt; write.table(mtfs, file&#x3D;hs_gzf, quote&#x3D;FALSE, sep&#x3D;&quot;\t&quot;, row.names&#x3D;FALSE, </span><br><span class="line">              col.names&#x3D;TRUE)</span><br></pre></td></tr></table></figure>
<p>文本文件很好，但是R中的一些对象无法有效地转换为文本文件，比如列表，这个时候最好的办法是  save R objects as R objects 。</p>
<p><img src="35.png" alt=""></p>
<p>save() 函数还有一个类似的函数 save.image() ，这个函数可以保存工作路径下的所有对象。</p>
<h2 id="8-5-Further-R-Directions-and-Resources">8.5 Further R Directions and Resources</h2>
<h1>9 Working with Range Data</h1>
<h2 id="9-1-A-Crash-Course-in-Genomic-Ranges-and-Coordinate-Systems">9.1 A Crash Course in Genomic Ranges and Coordinate Systems</h2>
<p>range 表示一段序列的子序列（比如染色体的一段序列）。为了确定基因组上的区域或位置，我们需要以下信息：</p>
<ul>
<li>染色体名称 ：也称之为 <em>sequence name</em> （有些片段可能没有分配到染色体上）。但是令人头疼的是，<strong>染色体名称没有固定规范</strong>，比如 ”7,”  “22,”  “chrX,”  “Y,”  “MT”</li>
<li>范围：比如114,414,997  to  114,693,772</li>
<li>strand ：因为 DNA 是双链，因此需要指明是哪条链。forward (positive) or reverse(negative)。</li>
<li>参考基因组版本</li>
</ul>
<p>这三个组成部分形成了一个 <em>genomic range</em> (or <em>genomic interval</em> ) ，由于参考基因组是range 的坐标系， <em>ranges are completely linked to a specific genome version</em>. 换句话说，基因组位置都是相对于参考基因组来说的，因此当我们说 range 时 还需要<strong>指定参考基因组版本</strong>。</p>
<p>range 有两种表示方式。在 0-based 中，一个 sequence （比如染色体）的第一个位置标记为0，在这个参考系中，我们使用半闭半开区间 [start,end)，这和 python 的语法一致。在 1-based 中，第一个位置标记为1，区间为全闭区间 [start,end]，如同R中的语法。</p>
<ul>
<li>0-based coordinate system, with  half-closed, half-open intervals.</li>
<li>1-based coordinate system, with closed intervals.</li>
</ul>
<p>两种方式各有利弊，比如如果我们想看range 长度，对于 0-based，直接就是 end - start；而对于 1-based，则是  end - start +1 。0-based 还有一个优点在于可以表示长度是0的range （第二条没看懂，267页）</p>
<p><img src="37.png" alt=""></p>
<p>还有一个需要考虑的细节是 strand，但是一般不用管，<strong>因为除了 BLAST 格式外，所有 range 格式都是 forward 链</strong>。</p>
<p>但是有时你需要知道，因为 有些 features 只有在某条链的信息才有生物学功能。比如编码蛋白的基因，如果这个基因在 forward 链上，那么 forward 链上的序列和 mRNA 是一样的；反过来，如果这个基因型在 reverse 链上，那么必须把forward 链上的序列 <em>reverse complement</em> ，才能获得 mRNA 上的信息。</p>
<h3 id="参考基因组版本">参考基因组版本</h3>
<p><strong>同一片段在不同参考基因组版本中的位置不同</strong>。</p>
<p>有时你需要从旧版本升级到新版本，这个工作很繁琐，但是目前有些工具可以帮助你完成</p>
<p><img src="36.png" alt=""></p>
<h2 id="9-2-An-Inter-active-Introduction-to-Range-Data-with-GenomicRanges">9.2 An Inter active Introduction to Range Data with GenomicRanges</h2>
<h3 id="9-2-1-Installing-and-Working-with-Bioconductor-Packages">9.2.1 Installing and Working with Bioconductor Packages</h3>
<p>这里我们用到了几个 Bioconductor 的包。</p>
<ul>
<li>GenomicRanges : 处理 genomic ranges</li>
<li>GenomicFeatures: 处理genomic features （有功能的 genomic ranges，比如genes, exons）</li>
<li>Biostrings and  BSgenome ：处理 genomic sequence data</li>
<li>rtracklayer ：读取生信格式的文件，比如 BED，GTF/GFF，WIG</li>
</ul>
<p>Bioconductor 包不同于 CRAN 的包，它会严格地一年更新两次，来跟上R版本的更新。</p>
<p>安装包的方式（这个是旧的，没法用了，需要提前安装 BiocInstaller ）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; source(&quot;http:&#x2F;&#x2F;bioconductor.org&#x2F;biocLite.R&quot;)</span><br><span class="line">&gt; biocLite()</span><br><span class="line">&gt; biocLite(&quot;GenomicRanges&quot;)</span><br></pre></td></tr></table></figure>
<p>现在的安装方式是采用 BiocManager 包</p>
<h4 id="BiocManager">BiocManager</h4>
<p><a href="https://bioconductor.org/install/">https://bioconductor.org/install/</a></p>
<p>安装核心安装包：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!requireNamespace(<span class="string">&quot;BiocManager&quot;</span>, quietly = <span class="literal">TRUE</span>))</span><br><span class="line">    install.packages(<span class="string">&quot;BiocManager&quot;</span>)</span><br><span class="line">BiocManager::install()</span><br></pre></td></tr></table></figure>
<p>安装特定的包</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">BiocManager::install(<span class="built_in">c</span>(<span class="string">&quot;GenomicFeatures&quot;</span>, <span class="string">&quot;AnnotationDbi&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>查找包，比如输入“^org” ，查找所有可用的  organism annotation 包。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">BiocManager::available()</span><br></pre></td></tr></table></figure>
<p>更新安装的包</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">BiocManager::install()</span><br></pre></td></tr></table></figure>
<h3 id="9-2-2-Storing-Generic-Ranges-with-IRanges">9.2.2 Storing Generic Ranges with IRanges</h3>
<p>通过 IRanges 函数包可以创建 IRanges 对象，包含两个元素：一个起始位置和结束位置，也可以设置长度。（注意，这里是 1-based 对象）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">library(IRanges)</span><br><span class="line">rng &lt;- IRanges(start &#x3D; 4, end &#x3D; 13)</span><br><span class="line">rng</span><br><span class="line">IRanges(start&#x3D;4, width&#x3D;3)</span><br></pre></td></tr></table></figure>
<p>也可以创建包含多个ranges的对象，并且可以给每个range命名</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x = IRanges(start = <span class="built_in">c</span>(<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">20</span>), end = <span class="built_in">c</span>(<span class="number">13</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">23</span>))</span><br><span class="line">x</span><br><span class="line"><span class="built_in">names</span>(x) &lt;- <span class="built_in">letters</span>[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">x</span><br><span class="line">start(x)</span><br><span class="line">end(x)</span><br><span class="line">width(x)</span><br><span class="line">end(x) = end(x) + <span class="number">4</span> <span class="comment">#延长ranges</span></span><br><span class="line">x</span><br><span class="line"><span class="built_in">range</span>(x) <span class="comment">#返回所有range的最大值和最小值</span></span><br></pre></td></tr></table></figure>
<p>取子集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x[2:3]</span><br><span class="line">start(x) &lt; 5 </span><br><span class="line">x[start(x) &lt;5]</span><br><span class="line">x[start(x) &gt;8]</span><br><span class="line">x[&#39;a&#39;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="9-2-3-Basic-Range-Operations-Arithmetic-Transformations-and-Set-Operations">9.2.3 Basic Range Operations: Arithmetic, Transformations, and Set Operations</h3>
<p>我们可以对range对象很方便地进行简单运算（+ - *，除法不行）。这里后面的 L 不知道有什么用，加不加都一样。</p>
<p>乘法一般用不上，乘以一个正数，缩小范围；乘以一个负数，扩大范围。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x &lt;- IRanges(start=<span class="built_in">c</span>(<span class="number">40</span>, <span class="number">80</span>), end=<span class="built_in">c</span>(<span class="number">67</span>, <span class="number">114</span>))</span><br><span class="line">&gt; x + <span class="number">4L</span></span><br><span class="line">IRanges object with <span class="number">2</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]        <span class="number">36</span>        <span class="number">71</span>        <span class="number">36</span></span><br><span class="line">  [<span class="number">2</span>]        <span class="number">76</span>       <span class="number">118</span>        <span class="number">43</span></span><br><span class="line"></span><br><span class="line">&gt; x - <span class="number">10L</span></span><br><span class="line">IRanges object with <span class="number">2</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]        <span class="number">50</span>        <span class="number">57</span>         <span class="number">8</span></span><br><span class="line">  [<span class="number">2</span>]        <span class="number">90</span>       <span class="number">104</span>        <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>有的时候我们需要指定某个区间内的片段，可以使用restrict() 函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y &#x3D; IRanges(start &#x3D; c(4,6,10,12),width&#x3D;13)</span><br><span class="line">y</span><br><span class="line">restrict(y,5,10)</span><br></pre></td></tr></table></figure>
<p><img src="38.png" alt="38"></p>
<p>另一种转换方法是 flank() ，返回 range 中 上游/下游的片段。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x</span><br><span class="line">IRanges object with <span class="number">2</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]        <span class="number">40</span>        <span class="number">67</span>        <span class="number">28</span></span><br><span class="line">  [<span class="number">2</span>]        <span class="number">80</span>       <span class="number">114</span>        <span class="number">35</span></span><br><span class="line">&gt; flank(x, width=<span class="number">7</span>)</span><br><span class="line">IRanges object with <span class="number">2</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]        <span class="number">33</span>        <span class="number">39</span>         <span class="number">7</span></span><br><span class="line">  [<span class="number">2</span>]        <span class="number">73</span>        <span class="number">79</span>         <span class="number">7</span></span><br><span class="line"></span><br><span class="line">&gt; flank(x, width=<span class="number">7</span>, start = <span class="literal">FALSE</span>)</span><br><span class="line">IRanges object with <span class="number">2</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]        <span class="number">68</span>        <span class="number">74</span>         <span class="number">7</span></span><br><span class="line">  [<span class="number">2</span>]       <span class="number">115</span>       <span class="number">121</span>         <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>另一个常用的函数是 reduce() ，将有交叉的 ranges 划分为没有交叉的 ranges（有重叠的ranges 会合并为一个大的 range）。这个函数用于我们想看序列上有哪些位置是覆盖的。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; set.seed(<span class="number">0</span>)</span><br><span class="line">&gt; alns &lt;- IRanges(start=sample(<span class="built_in">seq_len</span>(<span class="number">50</span>),<span class="number">20</span>), width=<span class="number">5</span>)</span><br><span class="line">&gt; head(alns,<span class="number">4</span>)</span><br><span class="line">IRanges object with <span class="number">4</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]        <span class="number">14</span>        <span class="number">18</span>         <span class="number">5</span></span><br><span class="line">  [<span class="number">2</span>]         <span class="number">4</span>         <span class="number">8</span>         <span class="number">5</span></span><br><span class="line">  [<span class="number">3</span>]        <span class="number">39</span>        <span class="number">43</span>         <span class="number">5</span></span><br><span class="line">  [<span class="number">4</span>]         <span class="number">1</span>         <span class="number">5</span>         <span class="number">5</span></span><br><span class="line">&gt; reduce(alns)</span><br><span class="line">IRanges object with <span class="number">2</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]         <span class="number">1</span>        <span class="number">29</span>        <span class="number">29</span></span><br><span class="line">  [<span class="number">2</span>]        <span class="number">33</span>        <span class="number">54</span>        <span class="number">22</span></span><br></pre></td></tr></table></figure>
<p>相似的函数是 gaps() ，这个会返回哪些位置是没有覆盖的。</p>
<p>默认情况下，只会考虑 ranges 之间的gap，不会显示距离起始位置/终止位置的gap。这样做是因为 gaps 不知道起始位置和终止位置在哪，如果你要显示的话，需要指定，比如（<code>gaps(alns, start=1, end=60)</code>）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; gaps(alns)</span><br><span class="line">IRanges object with 1 range and 0 metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [1]        30        32         3</span><br></pre></td></tr></table></figure>
<p>另一套有用的函数是 set 操作。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; a &lt;- IRanges(start = <span class="number">4</span>, end = <span class="number">13</span>)</span><br><span class="line">&gt; b &lt;- IRanges(start = <span class="number">12</span>, end = <span class="number">17</span>)</span><br><span class="line">&gt; intersect(a,b)</span><br><span class="line">IRanges object with <span class="number">1</span> <span class="built_in">range</span> and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]        <span class="number">12</span>        <span class="number">13</span>         <span class="number">2</span></span><br><span class="line">&gt; setdiff(a,b)</span><br><span class="line">IRanges object with <span class="number">1</span> <span class="built_in">range</span> and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]         <span class="number">4</span>        <span class="number">11</span>         <span class="number">8</span></span><br><span class="line">&gt; union(a,b)</span><br><span class="line">IRanges object with <span class="number">1</span> <span class="built_in">range</span> and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]         <span class="number">4</span>        <span class="number">17</span>        <span class="number">14</span></span><br><span class="line">&gt; union(b,a)</span><br><span class="line">IRanges object with <span class="number">1</span> <span class="built_in">range</span> and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]         <span class="number">4</span>        <span class="number">17</span>        <span class="number">14</span></span><br></pre></td></tr></table></figure>
<h3 id="9-2-4-Finding-Overlapping-Ranges">9.2.4 Finding Overlapping Ranges</h3>
<p>查找重叠的ranges很重要，如何查找重叠区域有不同的方法，需要视情况选用。</p>
<p><code>findOverlaps() </code> 函数是将第一个ranges 中所有range 与第二个的所有range 进行匹配，存在overlap 就显示在结果中（仅为索引）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qry &lt;- IRanges(start = <span class="built_in">c</span>(<span class="number">1</span>,<span class="number">26</span>,<span class="number">19</span>,<span class="number">11</span>,<span class="number">21</span>,<span class="number">7</span>), end=<span class="built_in">c</span>(<span class="number">16</span>,<span class="number">30</span>,<span class="number">19</span>,<span class="number">15</span>,<span class="number">24</span>,<span class="number">8</span>),<span class="built_in">names</span>=<span class="built_in">letters</span>[<span class="number">1</span>:<span class="number">6</span>])</span><br><span class="line">sbj &lt;- IRanges(start = <span class="built_in">c</span>(<span class="number">1</span>,<span class="number">19</span>,<span class="number">10</span>), end=<span class="built_in">c</span>(<span class="number">5</span>,<span class="number">29</span>,<span class="number">16</span>), <span class="built_in">names</span>=<span class="built_in">letters</span>[<span class="number">24</span>:<span class="number">26</span>])</span><br><span class="line">qry</span><br><span class="line">sbj</span><br><span class="line">hts &lt;- findOverlaps(qry,sbj)</span><br><span class="line">hts</span><br><span class="line"></span><br><span class="line">&gt; hts</span><br><span class="line">Hits object with <span class="number">6</span> hits and <span class="number">0</span> metadata columns:</span><br><span class="line">      queryHits subjectHits</span><br><span class="line">      &lt;integer&gt;   &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]         <span class="number">1</span>           <span class="number">1</span></span><br><span class="line">  [<span class="number">2</span>]         <span class="number">1</span>           <span class="number">3</span></span><br><span class="line">  [<span class="number">3</span>]         <span class="number">2</span>           <span class="number">2</span></span><br><span class="line">  [<span class="number">4</span>]         <span class="number">3</span>           <span class="number">2</span></span><br><span class="line">  [<span class="number">5</span>]         <span class="number">4</span>           <span class="number">3</span></span><br><span class="line">  [<span class="number">6</span>]         <span class="number">5</span>           <span class="number">2</span></span><br><span class="line">  -------</span><br><span class="line">  queryLength: <span class="number">6</span> / subjectLength: <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>默认情况下只有任意存在overlapping，就会显示在结果中（ type = “any”）。</p>
<p>可以更改这个参数，比如 改为 “within”，第一个参数的range 必须包含在第二个参数的range 中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hts_within &lt;- findOverlaps(qry, sbj, type&#x3D;&quot;within&quot;)</span><br><span class="line">hts_within</span><br></pre></td></tr></table></figure>
<p><img src="39.png" alt="38"></p>
<p>另一个需要考虑的参数是 <code>select</code>，这决定当一个 query 与多个 subject ranges 具有重叠时如何处理。“all” 会返回所有的配对，“first” “last” “arbitrary” 只返回一个配对（没有返回NA），选择这三个选项会返回一个整数的向量，每个元素表示 每个 query range 的匹配结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; findOverlaps(qry, sbj, select&#x3D;&quot;first&quot;)</span><br><span class="line">[1]  1  2  2  3  2 NA</span><br><span class="line">&gt; findOverlaps(qry, sbj, select&#x3D;&quot;last&quot;)</span><br><span class="line">[1]  3  2  2  3  2 NA</span><br><span class="line">&gt; findOverlaps(qry, sbj, select&#x3D;&quot;arbitrary&quot;)</span><br><span class="line">[1]  1  2  2  3  2 NA</span><br></pre></td></tr></table></figure>
<p>如果query 的 ranges 很多，那么如果还要逐次配对，那么计算量很大。我们可以通过对subject序列排序（构建 interval trees ）降低配对数目。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sbj_it &lt;- IntervalTree(sbj) #现在没用了</span><br></pre></td></tr></table></figure>
<p>其他方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; as.matrix(hts)</span><br><span class="line">     queryHits subjectHits</span><br><span class="line">[1,]         1           1</span><br><span class="line">[2,]         1           3</span><br><span class="line">[3,]         2           2</span><br><span class="line">[4,]         3           2</span><br><span class="line">[5,]         4           3</span><br><span class="line">[6,]         5           2</span><br><span class="line">&gt; setNames(countQueryHits(hts),names(qry))</span><br><span class="line">a b c d e f </span><br><span class="line">2 1 1 1 1 0 </span><br><span class="line">&gt; countSubjectHits(hts)</span><br><span class="line">[1] 1 3 2</span><br><span class="line">&gt; setNames(countSubjectHits(hts),names(sbj))</span><br><span class="line">x y z </span><br><span class="line">1 3 2 </span><br><span class="line">&gt; ranges(hts, qry, sbj) #显示重叠区域</span><br><span class="line">Error in (function (classes, fdef, mtable)  : </span><br><span class="line">  unable to find an inherited method for function ‘ranges’ for signature ‘&quot;SortedByQueryHits&quot;’</span><br></pre></td></tr></table></figure>
<h3 id="9-2-5-Finding-Nearest-Ranges-and-Calculating-Distance">9.2.5 Finding Nearest Ranges and Calculating Distance</h3>
<p>查找与 query 序列临近的 subject 序列。IRanges 有三个函数可以实现：nearest()  precede() follow()。 nearest() 返回最近的序列，不管时上游还是下游；precede() follow() 分别返回 query precede subject 和  query follow subject 最近的序列。</p>
<p>但是 nearest() 和 precede() follow() 还有一点不一样，nearest() 即使重叠也会考虑。<strong>这些细节说明在进行这些操作前需要仔细阅读文档</strong>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; qry &lt;- IRanges(start=<span class="number">6</span>, end=<span class="number">13</span>, name=<span class="string">&#x27;query&#x27;</span>)</span><br><span class="line">&gt; sbj &lt;- IRanges(start=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">4</span>,<span class="number">18</span>,<span class="number">19</span>), end=<span class="built_in">c</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">21</span>,<span class="number">24</span>), <span class="built_in">names</span>=<span class="number">1</span>:<span class="number">4</span>)</span><br><span class="line">&gt; qry</span><br><span class="line">IRanges object with <span class="number">1</span> <span class="built_in">range</span> and <span class="number">0</span> metadata columns:</span><br><span class="line">            start       end     width</span><br><span class="line">        &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  query         <span class="number">6</span>        <span class="number">13</span>         <span class="number">8</span></span><br><span class="line">&gt; sbj</span><br><span class="line">IRanges object with <span class="number">4</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">        start       end     width</span><br><span class="line">    &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  <span class="number">1</span>         <span class="number">2</span>         <span class="number">4</span>         <span class="number">3</span></span><br><span class="line">  <span class="number">2</span>         <span class="number">4</span>         <span class="number">5</span>         <span class="number">2</span></span><br><span class="line">  <span class="number">3</span>        <span class="number">18</span>        <span class="number">21</span>         <span class="number">4</span></span><br><span class="line">  <span class="number">4</span>        <span class="number">19</span>        <span class="number">24</span>         <span class="number">6</span></span><br><span class="line">&gt; nearest(qry,sbj)</span><br><span class="line">[<span class="number">1</span>] <span class="number">2</span></span><br><span class="line">&gt; precede(qry,sbj)</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span></span><br><span class="line">&gt; follow(qry,sbj)</span><br><span class="line">[<span class="number">1</span>] <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>可以通过 <code>distanceToNearest()</code> 和 <code>distance()</code> ，返回离最近的range的距离，和两边的最近的距离。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; qry &lt;- IRanges(sample(<span class="built_in">seq_len</span>(<span class="number">1000</span>), <span class="number">5</span>), width=<span class="number">10</span>)</span><br><span class="line">&gt; sbj &lt;- IRanges(sample(<span class="built_in">seq_len</span>(<span class="number">1000</span>), <span class="number">5</span>), width=<span class="number">10</span>)</span><br><span class="line">&gt; qry</span><br><span class="line">IRanges object with <span class="number">5</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]       <span class="number">677</span>       <span class="number">686</span>        <span class="number">10</span></span><br><span class="line">  [<span class="number">2</span>]       <span class="number">802</span>       <span class="number">811</span>        <span class="number">10</span></span><br><span class="line">  [<span class="number">3</span>]       <span class="number">874</span>       <span class="number">883</span>        <span class="number">10</span></span><br><span class="line">  [<span class="number">4</span>]       <span class="number">382</span>       <span class="number">391</span>        <span class="number">10</span></span><br><span class="line">  [<span class="number">5</span>]       <span class="number">601</span>       <span class="number">610</span>        <span class="number">10</span></span><br><span class="line">&gt; sbj</span><br><span class="line">IRanges object with <span class="number">5</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]       <span class="number">940</span>       <span class="number">949</span>        <span class="number">10</span></span><br><span class="line">  [<span class="number">2</span>]       <span class="number">975</span>       <span class="number">984</span>        <span class="number">10</span></span><br><span class="line">  [<span class="number">3</span>]       <span class="number">801</span>       <span class="number">810</span>        <span class="number">10</span></span><br><span class="line">  [<span class="number">4</span>]       <span class="number">852</span>       <span class="number">861</span>        <span class="number">10</span></span><br><span class="line">  [<span class="number">5</span>]       <span class="number">931</span>       <span class="number">940</span>        <span class="number">10</span></span><br><span class="line">&gt; distanceToNearest(qry, sbj)</span><br><span class="line">Hits object with <span class="number">5</span> hits and <span class="number">1</span> metadata column:</span><br><span class="line">      queryHits subjectHits |  distance</span><br><span class="line">      &lt;integer&gt;   &lt;integer&gt; | &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]         <span class="number">1</span>           <span class="number">3</span> |       <span class="number">114</span></span><br><span class="line">  [<span class="number">2</span>]         <span class="number">2</span>           <span class="number">3</span> |         <span class="number">0</span></span><br><span class="line">  [<span class="number">3</span>]         <span class="number">3</span>           <span class="number">4</span> |        <span class="number">12</span></span><br><span class="line">  [<span class="number">4</span>]         <span class="number">4</span>           <span class="number">3</span> |       <span class="number">409</span></span><br><span class="line">  [<span class="number">5</span>]         <span class="number">5</span>           <span class="number">3</span> |       <span class="number">190</span></span><br><span class="line">  -------</span><br><span class="line">  queryLength: <span class="number">5</span> / subjectLength: <span class="number">5</span></span><br><span class="line">&gt; distance(qry, sbj)</span><br><span class="line">[<span class="number">1</span>] <span class="number">253</span> <span class="number">163</span>  <span class="number">63</span> <span class="number">460</span> <span class="number">320</span></span><br></pre></td></tr></table></figure>
<h3 id="9-2-6-Run-Length-Encoding-and-Views">9.2.6 Run Length Encoding and Views</h3>
<p>看不懂，先看下一章。</p>
<h3 id="9-2-7-Storing-Genomic-Ranges-with-GenomicRanges">9.2.7 Storing Genomic Ranges with GenomicRanges</h3>
<p>GenomicRanges 可以创建 GRanges 来存放 genomic ranges，这个来源于 IRanges，但是可以存在额外的两条信息（sequence name, strand）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; library(GenomicRanges)</span><br><span class="line">载入需要的程辑包：GenomeInfoDb</span><br><span class="line">&gt; gr &lt;- GRanges(seqnames = <span class="built_in">c</span>(<span class="string">&quot;chr1&quot;</span>,<span class="string">&quot;chr1&quot;</span>,<span class="string">&quot;chr2&quot;</span>,<span class="string">&quot;chr3&quot;</span>), </span><br><span class="line">+               ranges=IRanges(start=<span class="number">5</span>:<span class="number">8</span>, width=<span class="number">10</span>),</span><br><span class="line">+               strand=<span class="built_in">c</span>(<span class="string">&quot;+&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;+&quot;</span>))</span><br><span class="line">&gt; gr</span><br><span class="line">GRanges object with <span class="number">4</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">      seqnames    ranges strand</span><br><span class="line">         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;</span><br><span class="line">  [<span class="number">1</span>]     chr1      <span class="number">5</span>-<span class="number">14</span>      +</span><br><span class="line">  [<span class="number">2</span>]     chr1      <span class="number">6</span>-<span class="number">15</span>      -</span><br><span class="line">  [<span class="number">3</span>]     chr2      <span class="number">7</span>-<span class="number">16</span>      -</span><br><span class="line">  [<span class="number">4</span>]     chr3      <span class="number">8</span>-<span class="number">17</span>      +</span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">3</span> sequences from an unspecified genome; no seqlengths</span><br><span class="line">&gt; ?runif </span><br><span class="line">&gt; gr &lt;- GRanges(seqnames = <span class="built_in">c</span>(<span class="string">&quot;chr1&quot;</span>,<span class="string">&quot;chr1&quot;</span>,<span class="string">&quot;chr2&quot;</span>,<span class="string">&quot;chr3&quot;</span>), </span><br><span class="line">+               ranges=IRanges(start=<span class="number">5</span>:<span class="number">8</span>, width=<span class="number">10</span>),</span><br><span class="line">+               strand=<span class="built_in">c</span>(<span class="string">&quot;+&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;+&quot;</span>), gc=<span class="built_in">round</span>(runif(<span class="number">4</span>), <span class="number">3</span>))</span><br><span class="line">&gt; gr</span><br><span class="line">GRanges object with <span class="number">4</span> ranges and <span class="number">1</span> metadata column:</span><br><span class="line">      seqnames    ranges strand |        gc</span><br><span class="line">         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;numeric&gt;</span><br><span class="line">  [<span class="number">1</span>]     chr1      <span class="number">5</span>-<span class="number">14</span>      + |     <span class="number">0.724</span></span><br><span class="line">  [<span class="number">2</span>]     chr1      <span class="number">6</span>-<span class="number">15</span>      - |     <span class="number">0.411</span></span><br><span class="line">  [<span class="number">3</span>]     chr2      <span class="number">7</span>-<span class="number">16</span>      - |     <span class="number">0.821</span></span><br><span class="line">  [<span class="number">4</span>]     chr3      <span class="number">8</span>-<span class="number">17</span>      + |     <span class="number">0.647</span></span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">3</span> sequences from an unspecified genome; no seqlengths</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于测序数据都有参考基因组，因此我们可以实现知道每个 sequence 的长度，这样才可以判断 coverage 和 gap。我们可以在创建GRanges 时说明，也可以在创建后指明长度。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">seqlens &lt;- <span class="built_in">c</span>(chr1=<span class="number">152</span>, chr2=<span class="number">432</span>, chr3=<span class="number">903</span>)</span><br><span class="line">gr &lt;- GRanges(seqnames = <span class="built_in">c</span>(<span class="string">&quot;chr1&quot;</span>,<span class="string">&quot;chr1&quot;</span>,<span class="string">&quot;chr2&quot;</span>,<span class="string">&quot;chr3&quot;</span>), </span><br><span class="line">               ranges=IRanges(start=<span class="number">5</span>:<span class="number">8</span>, width=<span class="number">10</span>),</span><br><span class="line">               strand=<span class="built_in">c</span>(<span class="string">&quot;+&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;+&quot;</span>), </span><br><span class="line">               gc=<span class="built_in">round</span>(runif(<span class="number">4</span>), <span class="number">3</span>),</span><br><span class="line">               seqlengths = seqlens )</span><br><span class="line">gr</span><br><span class="line">seqlengths(gr) &lt;- seqlens  <span class="comment"># 另一种方式</span></span><br><span class="line">gr</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; start(gr)</span><br><span class="line">[<span class="number">1</span>] <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line">&gt; end(gr)</span><br><span class="line">[<span class="number">1</span>] <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span></span><br><span class="line">&gt; width(gr)</span><br><span class="line">[<span class="number">1</span>] <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">length</span>(gr)</span><br><span class="line">[<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">&gt; <span class="built_in">names</span>(gr) = <span class="built_in">letters</span>[<span class="number">1</span>:<span class="built_in">length</span>(gr)]</span><br><span class="line">&gt; gr</span><br><span class="line">GRanges object with <span class="number">4</span> ranges and <span class="number">1</span> metadata column:</span><br><span class="line">    seqnames    ranges strand |        gc</span><br><span class="line">       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;numeric&gt;</span><br><span class="line">  a     chr1      <span class="number">5</span>-<span class="number">14</span>      + |     <span class="number">0.783</span></span><br><span class="line">  b     chr1      <span class="number">6</span>-<span class="number">15</span>      - |     <span class="number">0.553</span></span><br><span class="line">  <span class="built_in">c</span>     chr2      <span class="number">7</span>-<span class="number">16</span>      - |     <span class="number">0.530</span></span><br><span class="line">  d     chr3      <span class="number">8</span>-<span class="number">17</span>      + |     <span class="number">0.789</span></span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">3</span> sequences from an unspecified genome</span><br></pre></td></tr></table></figure>
<p>GRanges 的一个优点是你可以取子集。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt; start(gr) &gt; <span class="number">7</span></span><br><span class="line">[<span class="number">1</span>] FALSE FALSE FALSE  TRUE</span><br><span class="line">&gt; gr[start(gr) &gt; <span class="number">7</span>]</span><br><span class="line">GRanges object with <span class="number">1</span> range <span class="keyword">and</span> <span class="number">1</span> metadata <span class="symbol">column:</span></span><br><span class="line">    seqnames    ranges strand <span class="params">|        gc</span></span><br><span class="line"><span class="params">       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; |</span> &lt;numeric&gt;</span><br><span class="line">  d     chr3      <span class="number">8</span>-<span class="number">17</span>      + <span class="params">|     0.789</span></span><br><span class="line"><span class="params">  -------</span></span><br><span class="line"><span class="params">  seqinfo: 3 sequences from an unspecified genome</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; table(seqnames(gr))</span><br><span class="line"></span><br><span class="line">chr1 chr2 chr3 </span><br><span class="line">   <span class="number">2</span>    <span class="number">1</span>    <span class="number">1</span> </span><br><span class="line">&gt; gr[seqnames(gr) == <span class="string">&quot;chr1&quot;</span>]</span><br><span class="line">GRanges object with <span class="number">2</span> ranges and <span class="number">1</span> metadata column:</span><br><span class="line">    seqnames    ranges strand |        gc</span><br><span class="line">       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;numeric&gt;</span><br><span class="line">  a     chr1      <span class="number">5</span>-<span class="number">14</span>      + |     <span class="number">0.783</span></span><br><span class="line">  b     chr1      <span class="number">6</span>-<span class="number">15</span>      - |     <span class="number">0.553</span></span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">3</span> sequences from an unspecified genome</span><br></pre></td></tr></table></figure>
<p>取某一列</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; gr$gc</span><br><span class="line">[<span class="number">1</span>] <span class="number">0.783</span> <span class="number">0.553</span> <span class="number">0.530</span> <span class="number">0.789</span></span><br></pre></td></tr></table></figure>
<h3 id="9-2-8-Grouping-Data-with-GRangesList">9.2.8 Grouping Data with GRangesList</h3>
<p>GRanges 对象也有相应的列表，称之为 GRangesList。</p>
<p>我们可以手动创建一个 GRangesList</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(GenomicRanges)</span><br><span class="line">gr1 &lt;- GRanges(<span class="built_in">c</span>(<span class="string">&quot;chr1&quot;</span>,<span class="string">&quot;chr2&quot;</span>), IRanges(start=<span class="built_in">c</span>(<span class="number">32</span>,<span class="number">95</span>), width=<span class="built_in">c</span>(<span class="number">24</span>,<span class="number">123</span>)))</span><br><span class="line">gr2 &lt;- GRanges(<span class="built_in">c</span>(<span class="string">&quot;chr8&quot;</span>,<span class="string">&quot;chr2&quot;</span>), IRanges(start=<span class="built_in">c</span>(<span class="number">27</span>,<span class="number">12</span>), width=<span class="built_in">c</span>(<span class="number">42</span>,<span class="number">34</span>)))</span><br><span class="line">grl &lt;- GRangesList(gr1,gr2)</span><br><span class="line">grl</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>GRangesList 同样有普通列表的功能</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">unlist(grl) #把GRangesList转换为GRanges 对象</span><br><span class="line">doubled_grl = c(grl,grl) #合并list</span><br><span class="line">length(doubled_grl)</span><br><span class="line">doubled_grl</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>切片同样如此，一个方括号仍然返回一个 GRangesList 对象，两个方括号返回GRanges 对象</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">doubled_grl[<span class="number">2</span>]</span><br><span class="line">doubled_grl[[<span class="number">2</span>]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>GRangesList  还有一些特殊的函数（seqnames(), start(), end(), width(), ranges(), strand(), 等）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">seqnames(grl)</span><br><span class="line">start(grl)</span><br></pre></td></tr></table></figure>
<p>除了通过 <code>GRangesList()</code> 手动创建 GRanges 对象外，还可以通过 <code>split()</code> 函数处理 GRanges 对象。比如将一个 GRanges 对象 按照 sequence name （染色体）切分开，创建几个子对象。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">chrs &lt;- <span class="built_in">c</span>(<span class="string">&quot;chr3&quot;</span>, <span class="string">&quot;chr1&quot;</span>, <span class="string">&quot;chr2&quot;</span>, <span class="string">&quot;chr2&quot;</span>, <span class="string">&quot;chr3&quot;</span>, <span class="string">&quot;chr1&quot;</span>)</span><br><span class="line">gr &lt;- GRanges(chrs, IRanges(sample(<span class="number">1</span>:<span class="number">100</span>, <span class="number">6</span>, replace=<span class="literal">TRUE</span>), width=sample(<span class="number">3</span>:<span class="number">30</span>, <span class="number">6</span>, replace=<span class="literal">TRUE</span>)))</span><br><span class="line">head(gr)</span><br><span class="line">gr_split &lt;- split(gr, seqnames(gr))</span><br><span class="line">gr_split[[<span class="number">1</span>]]</span><br><span class="line"><span class="built_in">names</span>(gr_split)</span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; gr_split[[<span class="number">1</span>]]</span><br><span class="line">GRanges object with <span class="number">2</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">      seqnames    ranges strand</span><br><span class="line">         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;</span><br><span class="line">  [<span class="number">1</span>]     chr3     <span class="number">31</span>-<span class="number">40</span>      *</span><br><span class="line">  [<span class="number">2</span>]     chr3     <span class="number">16</span>-<span class="number">24</span>      *</span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">3</span> sequences from an unspecified genome; no seqlengths</span><br><span class="line">&gt; <span class="built_in">names</span>(gr_split)</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;chr3&quot;</span> <span class="string">&quot;chr1&quot;</span> <span class="string">&quot;chr2&quot;</span></span><br></pre></td></tr></table></figure>
<p>还可以通过 unsplit() 反向操作。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">unsplit(gr_split,seqnames(gr))</span><br></pre></td></tr></table></figure>
<p>数据分组是 split-apply-combine 模式（239页）的基础。通过R的基本数据格式-列表，我们可以通过 lapply() 和 sapply() 来对所有的元素进行迭代。这两个函数也可以应用于 GRangesLists 对象。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; lapply(gr_split, <span class="keyword">function</span>(x) order(width(x)))</span><br><span class="line">$chr3</span><br><span class="line">[<span class="number">1</span>] <span class="number">2</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">$chr1</span><br><span class="line">[<span class="number">1</span>] <span class="number">2</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">$chr2</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">&gt; sapply(gr_split, <span class="keyword">function</span>(x) <span class="built_in">min</span>(start(x)))</span><br><span class="line">chr3 chr1 chr2 </span><br><span class="line">  <span class="number">16</span>   <span class="number">26</span>   <span class="number">48</span> </span><br><span class="line">&gt; sapply(gr_split, <span class="built_in">length</span>)</span><br><span class="line">chr3 chr1 chr2 </span><br><span class="line">   <span class="number">2</span>    <span class="number">2</span>    <span class="number">2</span> </span><br><span class="line">&gt; elementLengths(gr_split)</span><br><span class="line">Error <span class="keyword">in</span> elementLengths(gr_split) : 没有<span class="string">&quot;elementLengths&quot;</span>这个函数</span><br></pre></td></tr></table></figure>
<p>最后一个函数运行报错，不知道这个函数是哪个包的。</p>
<p>之前的 overlap 操作的函数都可以直接使用（我已经忘了，下面的结果我都看不懂）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; reduce(gr_split)</span><br><span class="line">GRangesList object of <span class="built_in">length</span> <span class="number">3</span>:</span><br><span class="line">$chr3</span><br><span class="line">GRanges object with <span class="number">2</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">      seqnames    ranges strand</span><br><span class="line">         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;</span><br><span class="line">  [<span class="number">1</span>]     chr3     <span class="number">16</span>-<span class="number">24</span>      *</span><br><span class="line">  [<span class="number">2</span>]     chr3     <span class="number">31</span>-<span class="number">40</span>      *</span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">3</span> sequences from an unspecified genome; no seqlengths</span><br><span class="line"></span><br><span class="line">$chr1</span><br><span class="line">GRanges object with <span class="number">1</span> <span class="built_in">range</span> and <span class="number">0</span> metadata columns:</span><br><span class="line">      seqnames    ranges strand</span><br><span class="line">         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;</span><br><span class="line">  [<span class="number">1</span>]     chr1     <span class="number">26</span>-<span class="number">60</span>      *</span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">3</span> sequences from an unspecified genome; no seqlengths</span><br><span class="line"></span><br><span class="line">$chr2</span><br><span class="line">GRanges object with <span class="number">2</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">      seqnames    ranges strand</span><br><span class="line">         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;</span><br><span class="line">  [<span class="number">1</span>]     chr2     <span class="number">48</span>-<span class="number">73</span>      *</span><br><span class="line">  [<span class="number">2</span>]     chr2     <span class="number">77</span>-<span class="number">79</span>      *</span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">3</span> sequences from an unspecified genome; no seqlengths</span><br></pre></td></tr></table></figure>
<h3 id="9-2-9-Working-with-Annotation-Data-GenomicFeatures-and-rtracklayer">9.2.9 Working with Annotation Data: GenomicFeatures and rtracklayer</h3>
<p>上面提到的 GenomicRanges 包适用于<strong>互作式运行命令</strong>和<strong>中等</strong>大小数据。这里我们学习两个 Bioconductor 包来导入和处理外部数据。这两个包有不同的目的。第一个包，GenomicFeatures 应用于基于转录的基因组注释。第二个包，rtracklayer ，可以采用不同的方式导入和导出注释数据。</p>
<p>GenomicFeatures  可以创建和处理 TranscriptDb 对象，这种对象可以允许 genomic features （genes, transcripts, exons, coding sequences），可以用一种特定的方式提取出来。在这一章节中，我们会使用一个提取写好的 TranscriptDb 对象。</p>
<p>首先，我们安装一下 GenomicFeatures 包。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!requireNamespace(<span class="string">&quot;BiocManager&quot;</span>, quietly = <span class="literal">TRUE</span>))</span><br><span class="line">  install.packages(<span class="string">&quot;BiocManager&quot;</span>)</span><br><span class="line"></span><br><span class="line">BiocManager::install(<span class="string">&quot;GenomicFeatures&quot;</span>)</span><br><span class="line"></span><br><span class="line">library(<span class="string">&quot;GenomicFeatures&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我们安装一个小鼠的转录注释包（包含了注释数据），所有的注释数据包都有相同格式的名称，</p>
<p>TxDb.<organism>.<annotation-source>.<annotation-version>.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">BiocManager::install(<span class="string">&quot;TxDb.Mmusculus.UCSC.mm10.ensGene&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>使用注释数据</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(TxDb.Mmusculus.UCSC.mm10.ensGene)</span><br><span class="line">txdb &lt;- TxDb.Mmusculus.UCSC.mm10.ensGene</span><br><span class="line">txdb</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> class(txdb)</span></span><br><span class="line">[1] &quot;TxDb&quot;</span><br><span class="line">attr(,&quot;package&quot;)</span><br><span class="line">[1] &quot;GenomicFeatures&quot;</span><br></pre></td></tr></table></figure>
<p>首先，假如我们想看注释文件中素有的基因区域。GenomicFeatures 有一个方便的函数，genes()</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; mm_genes &lt;- genes(txdb)</span><br><span class="line">&gt; head(mm_genes)</span><br><span class="line">GRanges object with <span class="number">6</span> ranges and <span class="number">1</span> metadata column:</span><br><span class="line">                     seqnames              ranges strand |            gene_id</span><br><span class="line">                        &lt;Rle&gt;           &lt;IRanges&gt;  &lt;Rle&gt; |        &lt;character&gt;</span><br><span class="line">  ENSMUSG00000000001     chr3 <span class="number">108107280</span>-<span class="number">108146146</span>      - | ENSMUSG00000000001</span><br><span class="line">  ENSMUSG00000000003     chrX   <span class="number">77837901</span>-<span class="number">77853623</span>      - | ENSMUSG00000000003</span><br><span class="line">  ENSMUSG00000000028    chr16   <span class="number">18780447</span>-<span class="number">18811987</span>      - | ENSMUSG00000000028</span><br><span class="line">  ENSMUSG00000000031     chr7 <span class="number">142575529</span>-<span class="number">142578143</span>      - | ENSMUSG00000000031</span><br><span class="line">  ENSMUSG00000000037     chrX <span class="number">161117193</span>-<span class="number">161258213</span>      + | ENSMUSG00000000037</span><br><span class="line">  ENSMUSG00000000049    chr11 <span class="number">108343354</span>-<span class="number">108414396</span>      + | ENSMUSG00000000049</span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">66</span> sequences (<span class="number">1</span> circular) from mm10 genome</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">length</span>(mm_genes)</span><br><span class="line">[<span class="number">1</span>] <span class="number">39017</span></span><br></pre></td></tr></table></figure>
<p>同样的，GenomicFeatures 还可以通过 transcripts(), exons(), cds(), promoters() 来检索转录区域，外显子，coding sequence, 启动子。</p>
<p>很多情况下我们可以像根据某种 features 来分组统计计算。比如，我们可能回根据转录区域或基因来检索所有的外显子。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; mm_exons_by_tx &lt;- exonsBy(txdb, by=<span class="string">&quot;tx&quot;</span>) <span class="comment">#根据转录区域划分外显子</span></span><br><span class="line">&gt; mm_exons_by_gn &lt;- exonsBy(txdb, by=<span class="string">&quot;gene&quot;</span>)</span><br><span class="line">&gt; <span class="built_in">length</span>(mm_exons_by_tx)</span><br><span class="line">[<span class="number">1</span>] <span class="number">94647</span></span><br><span class="line">&gt; <span class="built_in">length</span>(mm_exons_by_gn)</span><br><span class="line">[<span class="number">1</span>] <span class="number">39017</span></span><br></pre></td></tr></table></figure>
<p>还有其他的类似的函数，transcriptsBy(), exonsBy(), cdsBy(), intronsBy(), fiveUTRsByTranscript()</p>
<p>, threeUTRsByTranscript()。</p>
<p>GenomicFeatures 还可以根据重叠一个特定的染色体或范围，提取某种 features 的子集。比如指定某条染色体。（下面的命令没看懂）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">seqlevels(txdb) &lt;- <span class="string">&quot;chr1&quot;</span></span><br><span class="line">chr1_exons &lt;- exonsBy(txdb, <span class="string">&quot;tx&quot;</span>)</span><br><span class="line"><span class="built_in">all</span>(unlist(seqnames(chr1_exons)) == <span class="string">&quot;chr1&quot;</span>)</span><br><span class="line">txdb &lt;- restoreSeqlevels(txdb)</span><br></pre></td></tr></table></figure>
<p>为了提取与某个区域重叠的feature，可以使用下面这个家族的函数：transcriptsByOverlaps()， exonsByOverlaps()， cdsByOverlaps() （通过 help(transcriptByOverlaps() 查看更多信息 ）。举个例子，假如一个QTL研究在8号染色体某个区域找到了一个 QTL，从 123,260,562  到  123,557,264。但是我们仅仅是得到了一个粗略的范围，所以我们增加了 10kb 范围。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qtl_region &lt;- GRanges(<span class="string">&quot;chr8&quot;</span>, IRanges(<span class="number">123260562</span>, <span class="number">123557264</span>))</span><br><span class="line">qtl_region_expanded &lt;- qtl_region + <span class="number">10e3</span></span><br><span class="line">transcriptsByOverlaps(txdb, qtl_region_expanded)</span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; transcriptsByOverlaps(txdb, qtl_region_expanded)</span><br><span class="line">GRanges object with <span class="number">73</span> ranges and <span class="number">2</span> metadata columns:</span><br><span class="line">       seqnames              ranges strand |     tx_id            tx_name</span><br><span class="line">          &lt;Rle&gt;           &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt;        &lt;character&gt;</span><br><span class="line">   [<span class="number">1</span>]     chr8 <span class="number">119910841</span>-<span class="number">124345722</span>      + |     <span class="number">47374</span> ENSMUST00000127664</span><br><span class="line">   [<span class="number">2</span>]     chr8 <span class="number">123254195</span>-<span class="number">123269745</span>      + |     <span class="number">47530</span> ENSMUST00000001092</span><br><span class="line">   [<span class="number">3</span>]     chr8 <span class="number">123254271</span>-<span class="number">123257636</span>      + |     <span class="number">47531</span> ENSMUST00000150356</span><br><span class="line">   [<span class="number">4</span>]     chr8 <span class="number">123254284</span>-<span class="number">123269743</span>      + |     <span class="number">47532</span> ENSMUST00000156896</span><br><span class="line">   [<span class="number">5</span>]     chr8 <span class="number">123254686</span>-<span class="number">123265070</span>      + |     <span class="number">47533</span> ENSMUST00000154450</span><br><span class="line">   ...      ...                 ...    ... .       ...                ...</span><br><span class="line">  [<span class="number">69</span>]     chr8 <span class="number">123559201</span>-<span class="number">123559319</span>      - |     <span class="number">49320</span> ENSMUST00000178208</span><br><span class="line">  [<span class="number">70</span>]     chr8 <span class="number">123560888</span>-<span class="number">123561006</span>      - |     <span class="number">49321</span> ENSMUST00000179143</span><br><span class="line">  [<span class="number">71</span>]     chr8 <span class="number">123562595</span>-<span class="number">123562713</span>      - |     <span class="number">49322</span> ENSMUST00000178297</span><br><span class="line">  [<span class="number">72</span>]     chr8 <span class="number">123564286</span>-<span class="number">123564404</span>      - |     <span class="number">49323</span> ENSMUST00000179019</span><br><span class="line">  [<span class="number">73</span>]     chr8 <span class="number">123565969</span>-<span class="number">123566087</span>      - |     <span class="number">49324</span> ENSMUST00000179081</span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">66</span> sequences (<span class="number">1</span> circular) from mm10 genome</span><br></pre></td></tr></table></figure>
<p>通过 rtracklayer 导入注释数据</p>
<p>import 函数回通过后缀自动判定文件类型，然后将数据导入为一个GRanges 对象。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(rtracklayer)</span><br><span class="line">setwd(<span class="string">&quot;D:/Desktop/下载文献/生信入门/bds-files-master/chapter-09-working-with-range-data&quot;</span>)</span><br><span class="line">mm_gtf &lt;- import(<span class="string">&#x27;Mus_musculus.GRCm38.75_chr1.gtf.gz&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>rtracklayer 包也提供不同的导出方式，可以保存为很多种类的 range formats。例如，假如我们想将 5个随机的 pseudogenes 写入到一个 GTF 文件。我们可以使用</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">set.seed(<span class="number">0</span>)</span><br><span class="line">pseudogene_i &lt;- which(mm_gtf$gene_biotype == <span class="string">&quot;pseudogene&quot;</span> &amp; mm_gtf$type == <span class="string">&quot;gene&quot;</span>)</span><br><span class="line">pseudogene_sample &lt;- sample(pseudogene_i, <span class="number">5</span>)</span><br><span class="line">export(mm_gtf[pseudogene_sample], con=<span class="string">&quot;five_random_pseudogene.gtf&quot;</span>,  format=<span class="string">&quot;GTF&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还可以存储为 BED 文件格式</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">bed_data &lt;- mm_gtf[pseudogene_sample]</span><br><span class="line">mcols(bed_data) &lt;- <span class="literal">NULL</span><span class="comment"># clear out metadata columns</span></span><br><span class="line">export(bed_data, con=<span class="string">&quot;five_random_pseudogene.bed&quot;</span>, format=<span class="string">&quot;BED&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="9-2-10-Retrieving-Promoter-Regions-Flank-and-Promoters">9.2.10 Retrieving Promoter Regions: Flank and Promoters</h3>
<p>现在，我们看这些 range operation 如何解决实际问题。我们先从上面导入的 GTF 注释文件中<strong>提取1号染色体上的所有蛋白质编码基因的启动子区域</strong>（长难句）。</p>
<p>首先，我们要找到我们感兴趣的基因的子集，也就是编码蛋白质的基因。</p>
<p>查看基因的类型</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; table(mm_gtf$gene_biotype)</span><br><span class="line"></span><br><span class="line">             antisense                lincRNA                  miRNA </span><br><span class="line">                   <span class="number">480</span>                    <span class="number">551</span>                    <span class="number">354</span> </span><br><span class="line">              misc_RNA polymorphic_pseudogene   processed_transcript </span><br><span class="line">                    <span class="number">93</span>                     <span class="number">61</span>                    <span class="number">400</span> </span><br><span class="line">        protein_coding             pseudogene                   rRNA </span><br><span class="line">                 <span class="number">77603</span>                    <span class="number">978</span>                     <span class="number">69</span> </span><br><span class="line">        sense_intronic      sense_overlapping                 snoRNA </span><br><span class="line">                    <span class="number">21</span>                      <span class="number">4</span>                    <span class="number">297</span> </span><br><span class="line">                 snRNA </span><br><span class="line">                   <span class="number">315</span> </span><br></pre></td></tr></table></figure>
<p>提取想要的基因，并统计</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; chr1_pcg &lt;- mm_gtf[mm_gtf$type == <span class="string">&quot;gene&quot;</span> &amp; mm_gtf$gene_biotype == <span class="string">&quot;protein_coding&quot;</span>]</span><br><span class="line">&gt; summary(width(chr1_pcg))</span><br><span class="line">   Min. <span class="number">1</span>st Qu.  Median    Mean <span class="number">3</span>rd Qu.    Max. </span><br><span class="line">     <span class="number">78</span>    <span class="number">9429</span>   <span class="number">25754</span>   <span class="number">60640</span>   <span class="number">62423</span> <span class="number">1075874</span> </span><br><span class="line">&gt; <span class="built_in">length</span>(chr1_pcg)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1240</span></span><br></pre></td></tr></table></figure>
<p>然后我们用 flank 函数 来抓取每个基因的 3K 上游区域。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">chr1_pcg_3kb_up &lt;- flank(chr1_pcg, width=<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>
<p>GenomociRanges 还有一个简单的函数可以实现上述操作，promoters() （自动提取每个区域 3K 的上游区域，还有 200 bp 的下游区域）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; chr1_pcg_3kb_up2 &lt;- promoters(chr1_pcg, upstream=<span class="number">3000</span>, downstream=<span class="number">0</span>)</span><br><span class="line">&gt; identical(chr1_pcg_3kb_up, chr1_pcg_3kb_up2)</span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure>
<h3 id="9-2-11-Retrieving-Promoter-Sequence-Connection-GenomicRanges-with-Sequence-Data">9.2.11 Retrieving Promoter Sequence: Connection GenomicRanges with Sequence Data</h3>
<p>一旦我们确定了启动子的范围，我们就可以从一个基因组序列中提取启动的序列。这里存在两种不同的方式可以实现这一点。</p>
<ul>
<li>通过 Bioconductor 的包来实现</li>
<li>通过将 GenomicRanges 对象导出为一个 range file，例如 BED，然后通过一个命令行工具实现，比如 BEDTools</li>
</ul>
<p>这两种都可以，但是第一种方式需要实现将基因组序列信息保存为一个特殊的R包（类似于上面的注释包）。如果你研究的物种没有这样一个 genome package ，第二种方式可能更快。</p>
<p>由于我们研究的物种是小鼠，事先已经有了 genome package，供我们下载及使用。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">BiocManager::install(<span class="string">&quot;BSgenome&quot;</span>)</span><br><span class="line">library(BSgenome)</span><br><span class="line">BiocManager::install(<span class="string">&quot;BSgenome.Mmusculus.UCSC.mm10&quot;</span>)</span><br><span class="line">library(BSgenome.Mmusculus.UCSC.mm10)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以查看一些基本信息</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; mm_gm &lt;- BSgenome.Mmusculus.UCSC.mm10</span><br><span class="line">&gt; organism(mm_gm)</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;Mus musculus&quot;</span></span><br><span class="line">&gt; providerVersion(mm_gm)</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;mm10&quot;</span></span><br><span class="line">&gt; provider(mm_gm)</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;UCSC&quot;</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过 seqinfo() 查看序列信息。BSgenome  packages 包括了每条染色体的序列，存储在一个类似列表的结构中，我们可以通过索引提取某条染色体的信息。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; seqinfo(mm_gm)</span><br><span class="line">Seqinfo object with <span class="number">66</span> sequences (<span class="number">1</span> circular) from mm10 genome:</span><br><span class="line">  seqnames       seqlengths isCircular genome</span><br><span class="line">  chr1            <span class="number">195471971</span>      <span class="literal">FALSE</span>   mm10</span><br><span class="line">  chr2            <span class="number">182113224</span>      <span class="literal">FALSE</span>   mm10</span><br><span class="line">  chr3            <span class="number">160039680</span>      <span class="literal">FALSE</span>   mm10</span><br><span class="line">  chr4            <span class="number">156508116</span>      <span class="literal">FALSE</span>   mm10</span><br><span class="line">  chr5            <span class="number">151834684</span>      <span class="literal">FALSE</span>   mm10</span><br><span class="line">  ...                   ...        ...    ...</span><br><span class="line">  chrUn_GL456392      <span class="number">23629</span>      <span class="literal">FALSE</span>   mm10</span><br><span class="line">  chrUn_GL456393      <span class="number">55711</span>      <span class="literal">FALSE</span>   mm10</span><br><span class="line">  chrUn_GL456394      <span class="number">24323</span>      <span class="literal">FALSE</span>   mm10</span><br><span class="line">  chrUn_GL456396      <span class="number">21240</span>      <span class="literal">FALSE</span>   mm10</span><br><span class="line">  chrUn_JH584304     <span class="number">114452</span>      <span class="literal">FALSE</span>   mm10</span><br><span class="line">&gt; mm_gm$chrM</span><br><span class="line">16299-letter DNAString object</span><br><span class="line">seq: GTTAATGTAGCTTAATAACAAAGCAAAGCACTGAAAATGCTTAGATGGATAATTGTATCCCATAAACACAA...AAATTTTACAAAATCATGTTCCGTGAACCAAAACTCTAATCATACTCTATTACGCAATAAACATTAACAA</span><br><span class="line">&gt; mm_gm[[<span class="number">22</span>]]</span><br><span class="line">16299-letter DNAString object</span><br><span class="line">seq: GTTAATGTAGCTTAATAACAAAGCAAAGCACTGAAAATGCTTAGATGGATAATTGTATCCCATAAACACAA...AAATTTTACAAAATCATGTTCCGTGAACCAAAACTCTAATCATACTCTATTACGCAATAAACATTAACAA</span><br></pre></td></tr></table></figure>
<p>另外， BSgenome objects 还可以通过字符配对 和 alignment functions（？）来搜索序列。比如</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; library(Biostrings)</span><br><span class="line">&gt; matchPattern(<span class="string">&quot;GGCGCGCC&quot;</span>, mm_gm$chr1)</span><br><span class="line">Views on a <span class="number">195471971</span>-letter DNAString subject</span><br><span class="line">subject: NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN...NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN</span><br><span class="line">views:</span><br><span class="line">            start       end width</span><br><span class="line">    [<span class="number">1</span>]   <span class="number">4557138</span>   <span class="number">4557145</span>     <span class="number">8</span> [GGCGCGCC]</span><br><span class="line">    [<span class="number">2</span>]   <span class="number">4567326</span>   <span class="number">4567333</span>     <span class="number">8</span> [GGCGCGCC]</span><br><span class="line">    [<span class="number">3</span>]   <span class="number">6960128</span>   <span class="number">6960135</span>     <span class="number">8</span> [GGCGCGCC]</span><br><span class="line">    [<span class="number">4</span>]   <span class="number">7397441</span>   <span class="number">7397448</span>     <span class="number">8</span> [GGCGCGCC]</span><br><span class="line">    [<span class="number">5</span>]   <span class="number">7398352</span>   <span class="number">7398359</span>     <span class="number">8</span> [GGCGCGCC]</span><br><span class="line">    ...       ...       ...   ... ...</span><br><span class="line">  [<span class="number">144</span>] <span class="number">191907520</span> <span class="number">191907527</span>     <span class="number">8</span> [GGCGCGCC]</span><br><span class="line">  [<span class="number">145</span>] <span class="number">191934164</span> <span class="number">191934171</span>     <span class="number">8</span> [GGCGCGCC]</span><br><span class="line">  [<span class="number">146</span>] <span class="number">191942448</span> <span class="number">191942455</span>     <span class="number">8</span> [GGCGCGCC]</span><br><span class="line">  [<span class="number">147</span>] <span class="number">192834335</span> <span class="number">192834342</span>     <span class="number">8</span> [GGCGCGCC]</span><br><span class="line">  [<span class="number">148</span>] <span class="number">193589224</span> <span class="number">193589231</span>     <span class="number">8</span> [GGCGCGCC]</span><br></pre></td></tr></table></figure>
<p>之前的染色体编号是数字，这里是 chr1、chr2 ，首先我们需要先统一染色体编号。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">all</span>(seqlevels(chr1_pcg_3kb_up) %in% seqlevels(mm_gm))</span><br><span class="line">[<span class="number">1</span>] <span class="literal">FALSE</span></span><br><span class="line">&gt; gr &lt;- GRanges(<span class="built_in">c</span>(<span class="string">&quot;chr1&quot;</span>, <span class="string">&quot;chr2&quot;</span>), IRanges(start=<span class="built_in">c</span>(<span class="number">3</span>, <span class="number">4</span>), width=<span class="number">10</span>)) <span class="comment">#测试</span></span><br><span class="line">&gt; seqlevels(gr)</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;chr1&quot;</span> <span class="string">&quot;chr2&quot;</span></span><br><span class="line">&gt; seqlevels(gr) &lt;- <span class="built_in">c</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>) <span class="comment">#按照相同的顺序重编码</span></span><br><span class="line">&gt; seqlevels(gr)</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;1&quot;</span> <span class="string">&quot;2&quot;</span></span><br><span class="line">&gt; seqlevelsStyle(chr1_pcg_3kb_up)</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;NCBI&quot;</span>    <span class="string">&quot;Ensembl&quot;</span> <span class="string">&quot;MSU6&quot;</span>    <span class="string">&quot;AGPvF&quot;</span>  </span><br><span class="line">&gt; seqlevelsStyle(mm_gm)</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;UCSC&quot;</span></span><br><span class="line">&gt; seqlevelsStyle(chr1_pcg_3kb_up) &lt;- <span class="string">&quot;UCSC&quot;</span> <span class="comment">#转化为UCSC格式</span></span><br><span class="line">&gt; <span class="built_in">all</span>(seqlevels(chr1_pcg_3kb_up) %in% seqlevels(mm_gm))</span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure>
<p>统一了二者格式之后，可以轻松提取 GRanges 对象中特定区域的序列</p>
<p>getSeq() 函数需要两个参数，第一个为 BSgenome 对象，第二个是  GRanges 对象，最终回返回每个range的序列信息。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; chr1_3kb_seqs &lt;- getSeq(mm_gm, chr1_pcg_3kb_up)</span><br><span class="line">&gt; chr1_3kb_seqs</span><br><span class="line">DNAStringSet object of <span class="built_in">length</span> <span class="number">1240</span>:</span><br><span class="line">       width seq</span><br><span class="line">   [<span class="number">1</span>]  <span class="number">3000</span> ATTCTGAGATGTGGTTACTAGATCAATGGGATTAGAGACTATTGAGAGCAGTATTGCACACAAAGCC...CAGCCAGGCGGCGCTCCTGCGGGTCCCGAGCGTGCGGCTAGCCGGGCCCAGCGCCCAGCCCCGCGG</span><br><span class="line">   [<span class="number">2</span>]  <span class="number">3000</span> GAAGTGGTATATCTGCCTAGTCTAGGTGTGCAGCTTATAAATAGTATAATTCAGTTGTGTGTTCTTT...TGGAGATTAACATCACCTTGGATTAAATTAATTGGCTGTACTTAATCTGTGAGCACACATGCTAGT</span><br><span class="line">   [<span class="number">3</span>]  <span class="number">3000</span> CTTAAAAACCTAGATATTCTATTTTTTTTTTTTCTGAGACAGGGTTTTTCTGTGTAGCCCTGGCTGT...TGTTTGCTTCTTTACTTGTGGCATTTGTGGCTGGCTTTGATAACGTCGTGAGCTCGGCTTCCAACA</span><br><span class="line">   [<span class="number">4</span>]  <span class="number">3000</span> GAATTGGCACAGTTTCACATGATTGGTCCATTTAAACATTAGCAGACTGTCAGAAGGGCGGGAGATA...TGCGGTCGCTCTGCAGCACGACAGGGGCGGGGCAGTACGGCCGCTGCAGCGCGACAGGGGCCGGGC</span><br><span class="line">   [<span class="number">5</span>]  <span class="number">3000</span> AAATATAAAGTTAACATACAAAAACTAGTCGCATTGATATACACTCACAACTATCAGAAAGGGAAAT...GGAAGGCTCACTATGACGCGCACGCGCGGCCGAATCGGGGCGCGAGCTCGGGGCCGAACGCGAGGA</span><br><span class="line">   ...   ... ...</span><br><span class="line">[<span class="number">1236</span>]  <span class="number">3000</span> CAACATGGGTAGTAGTGGGGGAGCTTTAGTTCCAAAGTATGAAACTGAAAAAATAGAAATGAAAAAA...TGACACACGGTTAAAAGTGAAGTAGGAACTACGAGAGGGGCTGGCCTCACCAAGACGCAACAGGGA</span><br><span class="line">[<span class="number">1237</span>]  <span class="number">3000</span> AGGTGTGTTATATAATAATTGGTTTGACACTGCCCTGGTTAGTTTTATGTCAGTTTGACATAAGATA...TTTAGTTTCAGGATTGTTGCGTCTGTTCACCTATCTTAAAACTTGCTCTCTGGCTTCCTGGCGCCC</span><br><span class="line">[<span class="number">1238</span>]  <span class="number">3000</span> TTGGCCAGGTGATTGATCTTGTCCAACTGGAATATTAGTCATCTATACAGGCCAGGTATTTTAATTT...GGTTAGGCTCCACCCTTGCAGATTTTTAAAAGGAGTAAGGCCGGGCTATATGCAAACCGAGTTCCC</span><br><span class="line">[<span class="number">1239</span>]  <span class="number">3000</span> GGCATTCCCCTATACTGGGGCATAGAACCTTCTCAAGACCAAGGGCCTCTCTTCCCATTGATGGCCG...TCAGTACCCAGCGCCACCGCGCGGAGCCGATGCTATTTAAGGGTCTGCTCCCCACTGCTTACAGCC</span><br><span class="line">[<span class="number">1240</span>]  <span class="number">3000</span> GTAAATTTTCAGGTATATTTCTTTCTACTCTTGTAGGGTTTCACAAAGTGGTACTTTTTGTCTAGAT...AAAAGAGAAGCAGAGAAACTTTAGCTTTTCTCAGCTTTGATATTTCTGTGGTCCTTATTTCTAGGT</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>
<p>我们还可以把这些序列信息写入到一个 FASTA 文件</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">writeXStringSet(chr1_3kb_seqs, file=<span class="string">&quot;mm10_chr1_3kb_promoters.fasta&quot;</span>,  format=<span class="string">&quot;fasta&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="9-2-12-Getting-Intergenic-and-Intronic-Regions-Gaps-Reduce-and-Setdiffs-in-Practice">9.2.12 Getting Intergenic and Intronic Regions: Gaps, Reduce, and  Setdiffs in Practice</h3>
<p>作为一个例子，我们来看 gaps() 函数如何作用于 GRanges 对象。</p>
<p>由于考虑了 strands  （+ - *, * 表示不确定的链），结果变得很复杂。 gaps 是覆盖整条染色体得到的结果。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; gr2 &lt;- GRanges(<span class="built_in">c</span>(<span class="string">&quot;chr1&quot;</span>, <span class="string">&quot;chr2&quot;</span>), IRanges(start=<span class="built_in">c</span>(<span class="number">4</span>, <span class="number">12</span>), width=<span class="number">6</span>), strand=<span class="built_in">c</span>(<span class="string">&quot;+&quot;</span>, <span class="string">&quot;-&quot;</span>), seqlengths=<span class="built_in">c</span>(chr1=<span class="number">21</span>, chr2=<span class="number">41</span>))</span><br><span class="line">&gt; gr2</span><br><span class="line">GRanges object with <span class="number">2</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">      seqnames    ranges strand</span><br><span class="line">         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;</span><br><span class="line">  [<span class="number">1</span>]     chr1       <span class="number">4</span>-<span class="number">9</span>      +</span><br><span class="line">  [<span class="number">2</span>]     chr2     <span class="number">12</span>-<span class="number">17</span>      -</span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">2</span> sequences from an unspecified genome</span><br><span class="line">&gt; gaps(gr2)</span><br><span class="line">GRanges object with <span class="number">8</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">      seqnames    ranges strand</span><br><span class="line">         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;</span><br><span class="line">  [<span class="number">1</span>]     chr1       <span class="number">1</span>-<span class="number">3</span>      +</span><br><span class="line">  [<span class="number">2</span>]     chr1     <span class="number">10</span>-<span class="number">21</span>      +</span><br><span class="line">  [<span class="number">3</span>]     chr1      <span class="number">1</span>-<span class="number">21</span>      -</span><br><span class="line">  [<span class="number">4</span>]     chr1      <span class="number">1</span>-<span class="number">21</span>      *</span><br><span class="line">  [<span class="number">5</span>]     chr2      <span class="number">1</span>-<span class="number">41</span>      +</span><br><span class="line">  [<span class="number">6</span>]     chr2      <span class="number">1</span>-<span class="number">11</span>      -</span><br><span class="line">  [<span class="number">7</span>]     chr2     <span class="number">18</span>-<span class="number">41</span>      -</span><br><span class="line">  [<span class="number">8</span>]     chr2      <span class="number">1</span>-<span class="number">41</span>      *</span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">2</span> sequences from an unspecified genome</span><br></pre></td></tr></table></figure>
<p>如果我们不关心 strands，我们可以按照以下命令操作（通常我们都不关心 strand信息，我们区域是一个 range，哪些区域是一个 gap）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; gr3 &lt;- gr2</span><br><span class="line">&gt; strand(gr3) &lt;- <span class="string">&quot;*&quot;</span> <span class="comment">#strand信息均改为 *</span></span><br><span class="line">&gt; gaps(gr3)[strand(gaps(gr3)) == <span class="string">&quot;*&quot;</span>]</span><br><span class="line">GRanges object with <span class="number">4</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">      seqnames    ranges strand</span><br><span class="line">         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;</span><br><span class="line">  [<span class="number">1</span>]     chr1       <span class="number">1</span>-<span class="number">3</span>      *</span><br><span class="line">  [<span class="number">2</span>]     chr1     <span class="number">10</span>-<span class="number">21</span>      *</span><br><span class="line">  [<span class="number">3</span>]     chr2      <span class="number">1</span>-<span class="number">11</span>      *</span><br><span class="line">  [<span class="number">4</span>]     chr2     <span class="number">18</span>-<span class="number">41</span>      *</span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">2</span> sequences from an unspecified genome</span><br></pre></td></tr></table></figure>
<p>另外一个创建 gaps 的方式是利用 set operations。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">chrom_grngs &lt;- as(seqinfo(txdb), <span class="string">&quot;GRanges&quot;</span>)</span><br><span class="line"><span class="comment">#使用 as() 函数强行转化为 GRanges 对象</span></span><br><span class="line">head(chrom_grngs, <span class="number">2</span>)</span><br><span class="line">collapsed_tx &lt;- reduce(transcripts(txdb))</span><br><span class="line"><span class="comment">#提取Transcripts对象，并通过 reduce() 将重叠的序列合并为1个</span></span><br><span class="line"></span><br><span class="line">strand(collapsed_tx) &lt;- <span class="string">&quot;*&quot;</span></span><br><span class="line"><span class="comment">#将 strand 信息均设置为*，即之后不考虑strand</span></span><br><span class="line">intergenic &lt;- setdiff(chrom_grngs, collapsed_tx)</span><br><span class="line"><span class="comment">#重整个染色体中提取不转录的gap序列</span></span><br></pre></td></tr></table></figure>
<p>现在我们看看如果创建表示内含子的 GRanges 对象。我们可以通过两种方式实现：第一种，使用一个简单的函数 intronsByTranscripts() ，这种方法很快。第二种方法，自己手动操作，利用 range set operations, 这样之后你可以自己解决很多其他的序列问题。</p>
<p>首先，看第一种方法</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; mm_introns &lt;- intronsByTranscript(txdb)</span><br><span class="line">&gt; head(mm_introns[[<span class="string">&#x27;18880&#x27;</span>]], <span class="number">2</span>) </span><br><span class="line">GRanges object with <span class="number">2</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">      seqnames              ranges strand</span><br><span class="line">         &lt;Rle&gt;           &lt;IRanges&gt;  &lt;Rle&gt;</span><br><span class="line">  [<span class="number">1</span>]     chr3 <span class="number">113556174</span>-<span class="number">113558092</span>      -</span><br><span class="line">  [<span class="number">2</span>]     chr3 <span class="number">113558219</span>-<span class="number">113558321</span>      -</span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">66</span> sequences (<span class="number">1</span> circular) from mm10 genome</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>
<p>现在我们看第二种方法，通过 range set operations。这种比较难。</p>
<p>首先我们通过一个简单的例子，提取单个基因（amylase 1，在Ensembl 的编号为 ENSMUSG00000074264）的内含子序列。我们提取内含子序列的原理是用<strong>transcripts range - exons’ ranges</strong>。我们先拿到整个转录序列</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; amy1 &lt;- transcriptsBy(txdb, <span class="string">&#x27;gene&#x27;</span>)$ENSMUSG00000074264</span><br><span class="line">&gt; </span><br><span class="line">&gt; amy1</span><br><span class="line">GRanges object with <span class="number">5</span> ranges and <span class="number">2</span> metadata columns:</span><br><span class="line">      seqnames              ranges strand |     tx_id            tx_name</span><br><span class="line">         &lt;Rle&gt;           &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt;        &lt;character&gt;</span><br><span class="line">  [<span class="number">1</span>]     chr3 <span class="number">113555710</span>-<span class="number">113577830</span>      - |     <span class="number">18879</span> ENSMUST00000067980</span><br><span class="line">  [<span class="number">2</span>]     chr3 <span class="number">113555953</span>-<span class="number">113574762</span>      - |     <span class="number">18880</span> ENSMUST00000106540</span><br><span class="line">  [<span class="number">3</span>]     chr3 <span class="number">113556149</span>-<span class="number">113562018</span>      - |     <span class="number">18881</span> ENSMUST00000172885</span><br><span class="line">  [<span class="number">4</span>]     chr3 <span class="number">113562690</span>-<span class="number">113574272</span>      - |     <span class="number">18882</span> ENSMUST00000142505</span><br><span class="line">  [<span class="number">5</span>]     chr3 <span class="number">113564987</span>-<span class="number">113606699</span>      - |     <span class="number">18883</span> ENSMUST00000174147</span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">66</span> sequences (<span class="number">1</span> circular) from mm10 genome</span><br></pre></td></tr></table></figure>
<p>在 amylase 1 基因上存在 5 个 transcripts （每一个都要计算内含子区域）（为什么一个基因会有5个转录区域？）。我们可以先提取所有的外显子区域，然后提取我们需要的子集。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mm_exons &lt;- exonsBy(txdb, <span class="string">&quot;tx&quot;</span>)</span><br><span class="line">mm_exons[[<span class="number">18881</span>]] <span class="comment">#举例</span></span><br></pre></td></tr></table></figure>
<p>由于生成的 mm_exons 是一个以transcript names 为元素名称的 GRangesList 对象。因此我们可以对transcript GRangesList 和 exon GRangesList 进行匹配 （采用 match() 函数）</p>
<p>首先，我们需要把转录序列也转变成以transcript names 为元素名称的 GRangesList 对象</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">amy1_tx &lt;- split(amy1, amy1$tx_id)</span><br></pre></td></tr></table></figure>
<p>然后，配对，获得这个基因的外显子区域序列</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">amy1_exons &lt;- mm_exons[match(<span class="built_in">names</span>(amy1_tx), <span class="built_in">names</span>(mm_exons))]</span><br><span class="line">amy1_exons</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后通过 pairwise set difference 操作（psetdiff() 函数），得到每个 transcript 的内含子区域。（报错了）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">all</span>(<span class="built_in">names</span>(amy1_tx) == <span class="built_in">names</span>(amy1_exons))  <span class="comment"># check everything&#x27;s matched up</span></span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line">&gt; amy1_introns &lt;- psetdiff(amy1_tx, amy1_exons)</span><br><span class="line">Error <span class="keyword">in</span> (<span class="keyword">function</span> (classes, fdef, mtable)  : </span><br><span class="line">  unable to find an inherited method <span class="keyword">for</span> <span class="keyword">function</span> ‘psetdiff’ <span class="keyword">for</span> signature ‘<span class="string">&quot;CompressedGRangesList&quot;</span>, <span class="string">&quot;CompressedGRangesList&quot;</span>’</span><br></pre></td></tr></table></figure>
<h3 id="9-2-13-Finding-and-Working-with-Overlapping-Ranges">9.2.13 Finding and Working with Overlapping Ranges</h3>
<p>发现和计算 overlaps 可能是最重要的操作。</p>
<p>为了说明 findoverlaps() 能够用于 GRanges 对象，我们会加载一个 dpSNP（除了SNP，dpSNP 还包括   insertions/deletions,   short   tandem   repeats,   multinucleotide  polymorphisms)） 的 BED 文件（染色体1）。这个文件在GitHub的库中。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; library(rtracklayer)</span><br><span class="line">&gt; dbsnp137 &lt;- import(<span class="string">&quot;D:/Desktop/下载文献/生信入门/bds-files-master/chapter-09-working-with-range-data/mm10_snp137_chr1_trunc.bed.gz&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>假设我们想要找出多少个 variants 在外显子区域中，然后多少个 variants 不在外显子区域。</p>
<p>首先，我们提取1号染色体上的所有外显子区域</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">collapsed_exons &lt;- reduce(exons(txdb), ignore.strand=<span class="literal">TRUE</span>)</span><br><span class="line">chr1_collapsed_exons &lt;- collapsed_exons[seqnames(collapsed_exons) == <span class="string">&quot;chr1&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以参看 variants 的分布，最大的序列长度是732，有点太大了（作者估计是存在大范围的插入/缺失 insertion/deletion）。但是最多的还是一个长度的，这种估计就是SNP或者一个位点长度的indel 位点。</p>
<p>然后还有长度是0的位点，这种是参考基因组没有，突变型是插入碱基的情况。长度是0的variant，不会和其他 feature 存在 overlap。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; summary(width(dbsnp137))</span><br><span class="line">   Min. <span class="number">1</span>st Qu.  Median    Mean <span class="number">3</span>rd Qu.    Max. </span><br><span class="line">  <span class="number">0.000</span>   <span class="number">1.000</span>   <span class="number">1.000</span>   <span class="number">1.142</span>   <span class="number">1.000</span> <span class="number">732.000</span> </span><br><span class="line">&gt; dbsnp137$name[which.max(width(dbsnp137))]</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;rs232497063&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>To count these zero-width features too, we’ll resize using the  resize() function :</p>
</blockquote>
<p>不知道 resize 函数是做什么的。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dbsnp137_resized &lt;- dbsnp137</span><br><span class="line">zw_i &lt;- width(dbsnp137_resized) == <span class="number">0</span></span><br><span class="line">dbsnp137_resized[zw_i] &lt;- resize(dbsnp137_resized[zw_i], width=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>现在我们可以查看有多少 variants 在1号染色体的外显子中（忽略 strand）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; hits &lt;- findOverlaps(dbsnp137_resized, chr1_collapsed_exons,  ignore.strand=<span class="literal">TRUE</span>)</span><br><span class="line">&gt; hits</span><br><span class="line">Hits object with <span class="number">57624</span> hits and <span class="number">0</span> metadata columns:</span><br><span class="line">          queryHits subjectHits</span><br><span class="line">          &lt;integer&gt;   &lt;integer&gt;</span><br><span class="line">      [<span class="number">1</span>]        <span class="number">89</span>        <span class="number">2336</span></span><br><span class="line">      [<span class="number">2</span>]       <span class="number">190</span>        <span class="number">1731</span></span><br><span class="line">      [<span class="number">3</span>]       <span class="number">266</span>        <span class="number">9170</span></span><br><span class="line">      [<span class="number">4</span>]       <span class="number">356</span>       <span class="number">11652</span></span><br><span class="line">      [<span class="number">5</span>]       <span class="number">426</span>        <span class="number">5986</span></span><br><span class="line">      ...       ...         ...</span><br><span class="line">  [<span class="number">57620</span>]   <span class="number">2699766</span>       <span class="number">14422</span></span><br><span class="line">  [<span class="number">57621</span>]   <span class="number">2699875</span>        <span class="number">9548</span></span><br><span class="line">  [<span class="number">57622</span>]   <span class="number">2699961</span>        <span class="number">8735</span></span><br><span class="line">  [<span class="number">57623</span>]   <span class="number">2699985</span>        <span class="number">7981</span></span><br><span class="line">  [<span class="number">57624</span>]   <span class="number">2699987</span>        <span class="number">7691</span></span><br><span class="line">  -------</span><br><span class="line">  queryLength: <span class="number">2700000</span> / subjectLength: <span class="number">15048</span></span><br><span class="line">&gt; <span class="built_in">length</span>(unique(queryHits(hits)))</span><br><span class="line">[<span class="number">1</span>] <span class="number">57623</span></span><br><span class="line">&gt; <span class="built_in">length</span>(unique(queryHits(hits)))/<span class="built_in">length</span>(dbsnp137_resized)</span><br><span class="line">[<span class="number">1</span>] <span class="number">0.02134185</span></span><br></pre></td></tr></table></figure>
<p>假设我们想要查看这些与1号染色体的外显子重叠的variants，我们可以用 subsetByOverlaps() 函数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; subsetByOverlaps(dbsnp137_resized, chr1_collapsed_exons, ignore.strand=<span class="literal">TRUE</span>)</span><br><span class="line">GRanges object with <span class="number">57623</span> ranges and <span class="number">2</span> metadata columns:</span><br><span class="line">          seqnames            ranges strand |        name     score</span><br><span class="line">             &lt;Rle&gt;         &lt;IRanges&gt;  &lt;Rle&gt; | &lt;character&gt; &lt;numeric&gt;</span><br><span class="line">      [<span class="number">1</span>]     chr1          <span class="number">43032144</span>      + | rs250123171         <span class="number">0</span></span><br><span class="line">      [<span class="number">2</span>]     chr1          <span class="number">36713805</span>      + |  rs50487270         <span class="number">0</span></span><br><span class="line">      [<span class="number">3</span>]     chr1         <span class="number">132567494</span>      + | rs247294715         <span class="number">0</span></span><br><span class="line">      [<span class="number">4</span>]     chr1         <span class="number">160995431</span>      + |  rs47617081         <span class="number">0</span></span><br><span class="line">      [<span class="number">5</span>]     chr1 <span class="number">84036552</span>-<span class="number">84036553</span>      + | rs216202117         <span class="number">0</span></span><br><span class="line">      ...      ...               ...    ... .         ...       ...</span><br></pre></td></tr></table></figure>
<p>GenomicRanges 还有一个函数  countOverlaps()，可以分组统计重叠数目。比如我们想基于外显子区域统计重叠的variants 数目。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; var_counts &lt;- countOverlaps(chr1_collapsed_exons, dbsnp137_resized,  ignore.strand=<span class="literal">TRUE</span>)</span><br><span class="line">&gt; head(var_counts)</span><br><span class="line">[<span class="number">1</span>]  <span class="number">1</span>  <span class="number">0</span> <span class="number">17</span> <span class="number">21</span>  <span class="number">1</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="9-2-14-Calculating-Coverage-of-GRanges-Objects">9.2.14 Calculating Coverage of GRanges Objects</h3>
<p>让我们基于19号染色体随机生成一些150bp的 reads，然后根据经验计算 coverage。我们的目标是5乘的 coverage。采用著名的 Lander-Waterman coverage equation （C = LN/G，C 是乘数，L 是 read length，N 是 the number of reads ，G 是 sequence length ）（很简单啊）</p>
<p>根据这个式子，如果采用 150bp 的read，对于一个长度为 61,431,566bp 的染色体，达到5乘的深度需要 5*61,431,566/150 = 2,047,719 reads。我们通过sample() 函数实现这一点</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">set.seed(<span class="number">0</span>)</span><br><span class="line">chr19_len &lt;- seqlengths(txdb)[<span class="string">&#x27;chr19&#x27;</span>]</span><br><span class="line">chr19_len</span><br><span class="line">start_pos &lt;- sample(<span class="number">1</span>:(chr19_len-<span class="number">150</span>), <span class="number">2047719</span>, replace=<span class="literal">TRUE</span>)</span><br><span class="line">reads &lt;- GRanges(<span class="string">&quot;chr19&quot;</span>, IRanges(start=start_pos, width=<span class="number">150</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，我们可以用  GenomicRanges 包中的 coverage() 函数计算这些reads的测序深度。</p>
<p>coverage() 是基于染色体计算的</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; cov_reads &lt;- coverage(reads)</span><br><span class="line">&gt; mean(cov_reads)</span><br><span class="line">   chr19 </span><br><span class="line">5.000001 </span><br></pre></td></tr></table></figure>
<p>通过这个函数我们也可以轻松计算，在这条染色体上有多少地方是没有reads覆盖的（这会发生在 shotgun sequencing）。这个也可以通过两种方式计算</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; table(cov_reads == <span class="number">0</span>)</span><br><span class="line">         <span class="literal">FALSE</span>     <span class="literal">TRUE</span></span><br><span class="line">chr19 <span class="number">61016613</span>   <span class="number">414942</span></span><br></pre></td></tr></table></figure>
<p>第二种，使用 run-length encoding tricks （速度更快）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">sum</span>(runLength(cov_reads)[runValue(cov_reads) == <span class="number">0</span>])</span><br><span class="line"> chr19 </span><br><span class="line">414942 </span><br><span class="line">&gt; <span class="number">406487</span>/chr19_len</span><br><span class="line">      chr19 </span><br><span class="line">0.006616908 </span><br></pre></td></tr></table></figure>
<p>可以看出，我们通过随机抽样的结果是仍然有0.6%的地方没有覆盖。</p>
<h2 id="9-3-Working-with-Ranges-Data-on-the-Command-Line-with-BEDTools">9.3 Working with Ranges Data on the Command Line with BEDTools</h2>
<p>前面提到的 GenomicRanges 包需要一次性将数据储存到内存中。</p>
<p>BEDTools suite 是一系列处理 range file （例如 BED, GTF, GFF）的 命令行工具。</p>
<p>本章节用到的数据:</p>
<ul>
<li>
<p>ranges_qry.bed ： 包含6个 ranges 的 BED文件。</p>
<blockquote>
<p>These  are  the  queryranges used in the GenomicRangesfindOverlaps examples (except, because theseare in BED format, they are 0-indexed).</p>
</blockquote>
</li>
<li>
<p>ranges_sbj.bed :  没看懂</p>
</li>
<li>
<p>Mus_musculus.GRCm38.75_chr1.gtf.gz ：1号染色体上的 features</p>
</li>
<li>
<p>Mus_musculus.GRCm38_genome.txt ： 染色体名称和长度</p>
</li>
</ul>
<h3 id="9-3-1-Computing-Overlaps-with-BEDTools-Intersect">9.3.1 Computing Overlaps with BEDTools Intersect</h3>
<p>BEDTools 的 intersect 子命令计算两个ranges集之间的overlaps。</p>
<p>最终返回第一个文件中二者的共同部分。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(base) [zhouziwen@ny 20210107]$ cat ranges-qry.bed</span><br><span class="line">chr1    0       15      a</span><br><span class="line">chr1    25      29      b</span><br><span class="line">chr1    18      18      c</span><br><span class="line">chr1    10      14      d</span><br><span class="line">chr1    20      23      e</span><br><span class="line">chr1    6       7       f</span><br><span class="line">(base) [zhouziwen@ny 20210107]$ cat ranges-sbj.bed</span><br><span class="line">chr1    0       4       x</span><br><span class="line">chr1    18      28      y</span><br><span class="line">chr1    9       15      z</span><br><span class="line">(base) [zhouziwen@ny 20210107]$ bedtools intersect -a ranges-qry.bed -b ranges-sbj.bed</span><br><span class="line">chr1    0       4       a</span><br><span class="line">chr1    9       15      a</span><br><span class="line">chr1    25      28      b</span><br><span class="line">chr1    18      18      c</span><br><span class="line">chr1    10      14      d</span><br><span class="line">chr1    20      23      e</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有时我们只想返回 overlap B 序列的A序列，需要使用 -wa 选项</p>
<p>这里a 返回了两次，是因为 a 与另一个文件重叠了两次（x 和 z），如果你不想这些重复行，你可以使用 -u 选项（unique）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(base) [zhouziwen@ny 20210107]$ bedtools intersect -a ranges-qry.bed -b ranges-sbj.bed -wa</span><br><span class="line">chr1    0       15      a</span><br><span class="line">chr1    0       15      a</span><br><span class="line">chr1    25      29      b</span><br><span class="line">chr1    18      18      c</span><br><span class="line">chr1    10      14      d</span><br><span class="line">chr1    20      23      e</span><br></pre></td></tr></table></figure>
<p>类似地，还有 -wb 选项，这条命令会在 -wa 的基础上显示第二个文件重叠的序列。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(base) [zhouziwen@ny 20210107]$ bedtools intersect -a ranges-qry.bed -b ranges-sbj.bed -wb</span><br><span class="line">chr1    0       4       a       chr1    0       4       x</span><br><span class="line">chr1    9       15      a       chr1    9       15      z</span><br><span class="line">chr1    25      28      b       chr1    18      28      y</span><br><span class="line">chr1    18      18      c       chr1    18      28      y</span><br><span class="line">chr1    10      14      d       chr1    9       15      z</span><br><span class="line">chr1    20      23      e       chr1    18      28      y</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对两个大的文件进行 intersect 操作可能会占用很多内存。<strong>对于大文件，先对两个文件按照染色体和物理位置排序，再计算intersect，效率会更高</strong>。<code>bedtools intersect</code> 可以添加一个 --sorted 选项来处理排序好的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bedtools intersect -a query-sorted.bed -b subject-sorted.bed --sorted</span><br></pre></td></tr></table></figure>
<p>bedtools intersect 还有其他的功能，例如通过 -wo 选项返回 重叠的bases 数目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(base) [zhouziwen@ny 20210107]$ bedtools intersect -a ranges-qry.bed -b ranges-sbj.bed -wo</span><br><span class="line">chr1    0       15      a       chr1    0       4       x       4</span><br><span class="line">chr1    0       15      a       chr1    9       15      z       6</span><br><span class="line">chr1    25      29      b       chr1    18      28      y       3</span><br><span class="line">chr1    18      18      c       chr1    18      28      y       0</span><br><span class="line">chr1    10      14      d       chr1    9       15      z       4</span><br><span class="line">chr1    20      23      e       chr1    18      28      y       3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>类似于 grep 的 -v 选项，bedtools intersect 也有一个 -v 选项，这会返回所有的非重叠的片段。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(base) [zhouziwen@ny 20210107]$ bedtools intersect -a ranges-qry.bed -b ranges-sbj.bed -v</span><br><span class="line">chr1    6       7       f</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们用到的数据没有包含 strand 信息，但是真实数据是要考虑 strand 信息的。bedtools intersect 默认不考虑 strand 信息，因此如果你想要只看同一个 strand 的 intersects ，你可以通过 -s 选项指定</p>
<h3 id="9-3-2-BEDTools-Slop-and-Flank">9.3.2 BEDTools Slop and Flank</h3>
<p>bedtools slop 通过 -i 选项指定输入 range file，除此之外，还需要提供一个tab分隔的genome file，说明每条染色体的长度（bedtools 用于确保 ranges 不会超出染色体的长度范围）。</p>
<p>实际项目中，我们可以通过 bioawk 生成</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bioawk -c fastx &#x27;&#123;print $name&quot;\t&quot;length($seq)&#125;&#x27; your_genome.fastq &gt; genome.txt</span><br></pre></td></tr></table></figure>
<p>但是在这里，我们用 echo 创建一个假的 genome.txt。</p>
<p>从下面的结果来看，相比于原来的数据，<code>-b 4</code> 表示每个起始位置和终止位置均拓展了4个bp（起始位置-4；终止位置+4；如果超出染色体范围则采用染色体的极值，就像 a 的起始位置还是0）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -e <span class="string">&quot;chr1\t100&quot;</span> &gt; genome.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bedtools slop -i ranges-qry.bed -g genome.txt -b 4</span></span><br><span class="line">chr1    0       19      a</span><br><span class="line">chr1    21      33      b</span><br><span class="line">chr1    14      22      c</span><br><span class="line">chr1    6       18      d</span><br><span class="line">chr1    16      27      e</span><br><span class="line">chr1    2       11      f</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你也可以具体地指定左边界（-l）和右边界（-r）扩展的bp数目。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">$ bedtools slop -i ranges-qry.bed -g genome.txt -l <span class="number">3</span> -r <span class="number">5</span></span><br><span class="line">chr1    <span class="number">0</span>       <span class="number">20</span>      a</span><br><span class="line">chr1    <span class="number">22</span>      <span class="number">34</span>      b</span><br><span class="line">chr1    <span class="number">15</span>      <span class="number">23</span>      <span class="built_in">c</span></span><br><span class="line">chr1    <span class="number">7</span>       <span class="number">19</span>      d</span><br><span class="line">chr1    <span class="number">17</span>      <span class="number">28</span>      e</span><br><span class="line">chr1    <span class="number">3</span>       <span class="number">12</span>      f</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>bedtools flank 命令可以用于提取 promoter sequences。flank 命令也需要一个 genome file。让我们用 bedtools flank 来提取基因的一些promoter regions。我们用 Mus_musculus.GRCm38.75_chr1.gtf.gz 文件。</p>
<p>但是，这个文件里包括了所有种类的 features ： exons, transcripts, CDS, noncoding regions 等等。如果我们只想看编码蛋白质的基因的启动子，我们可以用uniq命令提取这些区域：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bioawk -cgff &#x27;&#123;if ($feature == &quot;gene&quot;) print $0&#125;&#x27; Mus_musculus.GRCm38.75_chr1.gtf.gz | grep &#x27;gene_biotype &quot;protein_coding&quot;;&#x27; &gt; mm_GRCm38.75_protein_coding_genes.gtf</span><br></pre></td></tr></table></figure>
<p>现在，我们可以用这些编码蛋白质的 gene feature 和 genome file ，来提取每个range 前面 3Kbp 的区域。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bedtools flank -i mm_GRCm38.75_protein_coding_genes.gtf -g Mus_musculus.GRCm38_genome.txt  -l 3000 -r 0 &gt; mm_GRCm38_3kb_promoters.gtf</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cut -f1,4,5,7 mm_GRCm38.75_protein_coding_genes.gtf | head -n 3</span></span><br><span class="line">1       3205901 3671498 -</span><br><span class="line">1       4343507 4360314 -</span><br><span class="line">1       4490928 4496413 -</span><br><span class="line"><span class="meta">$</span><span class="bash"> cut -f1,4,5,7 mm_GRCm38_3kb_promoters.gtf | head -n 3</span></span><br><span class="line">1       3202901 3205900 -</span><br><span class="line">1       4340507 4343506 -</span><br><span class="line">1       4487928 4490927 -</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，上述操作成立建立在 strand 都是 - 号的前提。</p>
<p>我们可以通过 bedtools getfasta 来提取给定 range set 的 sequence 信息。比如，我们可以提取上面得到的promoter ranges 的序列信息。</p>
<p>由于整个基因组的序列信息太大了，我们这里只使用 1号染色体的序列信息，首先需要先解压</p>
<ul>
<li>-fi : 总的序列文件</li>
<li>-bed :  输入的 bed 文件（range 信息）</li>
<li>-fo : 输出的序列文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gunzip Mus_musculus.GRCm38.75.dna_rm.toplevel_chr1.fa.gz</span><br><span class="line">bedtools getfasta -fi Mus_musculus.GRCm38.75.dna_rm.toplevel_chr1.fa -bed mm_GRCm38_3kb_promoters.gtf -fo mm_GRCm38_3kb_promoters.fasta</span><br></pre></td></tr></table></figure>
<h3 id="9-3-3-Coverage-with-BEDTools">9.3.3 Coverage with BEDTools</h3>
<p>bedtools genomecov 根据染色体统计 features 的 coverage。默认情况下，它会将每个染色体的coverage情况生成直方图。举例而言。</p>
<p>最终结果中，第二列是测序深度，第三列是在这个测序深度的碱基有多少个，第四列四整个染色体的碱基数目，最后一列为比例。比如第一行显示在1号染色体共有23%的位点没有覆盖到。</p>
<p>最后的 genome 行是整个基因组的统计信息。</p>
<p>这个命令要求<strong>使用的 bed 文件需要按照染色体的顺序排序</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat ranges-cov.bed</span></span><br><span class="line">chr1    4       9</span><br><span class="line">chr1    1       6</span><br><span class="line">chr1    8       19</span><br><span class="line">chr1    25      30</span><br><span class="line">chr2    0       20</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat cov.txt</span></span><br><span class="line">chr1    30</span><br><span class="line">chr2    20</span><br><span class="line"><span class="meta">$</span><span class="bash"> bedtools genomecov -i ranges-cov.bed -g cov.txt</span></span><br><span class="line">chr1    0       7       30      0.233333</span><br><span class="line">chr1    1       20      30      0.666667</span><br><span class="line">chr1    2       3       30      0.1</span><br><span class="line">chr2    1       20      20      1</span><br><span class="line">genome  0       7       50      0.14</span><br><span class="line">genome  1       40      50      0.8</span><br><span class="line">genome  2       3       50      0.06</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 bedtools genomecov ，也可以得到每个碱基的 coverage</p>
<p>这里的三列分别是 染色体 - 物理位置 - 这个物理位置的 coverage。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bedtools genomecov -i ranges-cov.bed -g cov.txt -d  | head -n5</span></span><br><span class="line">chr1    1       0</span><br><span class="line">chr1    2       1</span><br><span class="line">chr1    3       1</span><br><span class="line">chr1    4       1</span><br><span class="line">chr1    5       2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="9-3-4-Other-BEDTools-Subcommands-and-pybedtools">9.3.4 Other BEDTools Subcommands and pybedtools</h3>
<p>其他有用的命令</p>
<h1>10 Working with Sequence Data</h1>
<h2 id="10-1-The-FASTA-Format">10.1 The FASTA Format</h2>
<p>FASTA 可以存储任何的序列数据，比如参考基因组文件，蛋白质序列，coding DNA sequence (CDS) , 转录序列等。</p>
<p>FASTA 文件的每条记录包含两个部分：一个是描述部分（&gt; 开始，包含序列名称和其他信息），一个是序列数据部分（第二行直至到描述行，<strong>可占据多行</strong>）。</p>
<p>FASTA 文件的灵活性导致它的结构定义很宽泛，结构不严谨，运行程序可能会遭遇未知的错误。</p>
<p>因此，作者建议用什么   FASTA/FASTQ  parsing libraries，而不是直接用你自己的文件，因为上面的那个库里的文件是已经经过审查的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ head -10  egfr_flank.fasta</span><br><span class="line">&gt;ENSMUSG00000020122|ENSMUST00000138518</span><br><span class="line">CCCTCCTATCATGCTGTCAGTGTATCTCTAAATAGCACTCTCAACCCCCGTGAACTTGGT</span><br><span class="line">TATTAAAAACATGCCCAAAGTCTGGGAGCCAGGGCTGCAGGGAAATACCACAGCCTCAGT</span><br><span class="line">TCATCAAAACAGTTCATTGCCCAAAATGTTCTCAGCTGCAGCTTTCATGAGGTAACTCCA</span><br><span class="line">GGGCCCACCTGTTCTCTGGT</span><br><span class="line">&gt;ENSMUSG00000020122|ENSMUST00000125984</span><br><span class="line">GAGTCAGGTTGAAGCTGCCCTGAACACTACAGAGAAGAGAGGCCTTGGTGTCCTGTTGTC</span><br><span class="line">TCCAGAACCCCAATATGTCTTGTGAAGGGCACACAACCCCTCAAAGGGGTGTCACTTCTT</span><br><span class="line">CTGATCACTTTTGTTACTGTTTACTAACTGATCCTATGAATCACTGTGTCTTCTCAGAGG</span><br><span class="line">CCGTGAACCACGTCTGCAAT</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>困扰 FASTA 格式文件的最大的问题，在于描述行中序列名称的格式没有明确的定义。比如下面这些行是不是表示同一个序列呢？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">ENSMUSG00000020122|ENSMUST00000138518</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ENSMUSG00000020122|ENSMUST00000125984</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ENSMUSG00000020122|ENSMUST00000125984|epidermal growth factor receptor</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ENSMUSG00000020122|ENSMUST00000125984|Egfr</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ENSMUSG00000020122|ENSMUST00000125984|11|ENSFM00410000138465</span></span><br></pre></td></tr></table></figure>
<p>没有一个统计的规范，我们就不能通过<strong>精确匹配</strong>能确认一个FASTA存不存在某个序列。事实上，我们只能是进行<strong>模糊匹配</strong>。这就让情况变得复杂了：我们的匹配规则的严格程度怎么控制？可不可能匹配到错误的序列？基本上说，模糊匹配是一种很脆弱的策略。</p>
<p>事实上，存在一个更简单的解决办法，就是确保数据是严格符合规范的。如果是拿到了陌生的数据，需要进行数据规范检验，来确保这个数据是否符合要求。这个检验规则不用太复杂，比如检验是否有重复名称，检查&gt; 和序列名称之间是否存在空格等。</p>
<p>如果你需要整理外来的数据，记得<strong>一定要备份原始数据</strong>。</p>
<p>一个命名惯例是将描述行通过一个空格分开两部分：序列名和其他描述。举例如下，序列名称是gene_00284728， 然后 length=231;type=dna 是其他描述部分。</p>
<p>在这种命名规则下，查找特定的序列是很轻松的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">gene_00284728 length=231;<span class="built_in">type</span>=dna</span></span><br><span class="line">GAGAACTGATTCTGTTACCGCAGGGCATTCGGATGTGCTAAGGTAGTAATCCATTATAAGTAACATGCGCGGAATATCCGGAGGTCATAGTCGTAATGCATAATTATTCC</span><br><span class="line">CTCCCTCAGAAGGACTCCCTTGCGAGACGCCAATACCAAAGACTTTCGTAGCTGGAACGATTGGACGGCCCAACCGGGGGGAGTCGGCTATACGTCTGATTGCTACGCCT</span><br><span class="line">GGACTTCTCTT</span><br></pre></td></tr></table></figure>
<h2 id="10-2-The-FASTQ-Format">10.2 The FASTQ Format</h2>
<p>FASTQ 格式是对 FASTA 格式的拓展，对于序列的每个碱基添加了一个 quality score。FASTQ 广泛应用于 <strong>高通量测序数据</strong>，通过显示每个碱基的quality score 来表示每个碱基 call 的置信度。不像 FASTA，FASTQ 有各种变体和陷阱。</p>
<p>FASTQ 格式如下：</p>
<p>第一行是描述行，以@开头，包括序列码名和其他信息</p>
<p>之后是序列数据，可以是一行或多行</p>
<p>以 + 开头的行，表示序列的末尾。在老的 FASTQ文件，这一行后面通常会重复一遍描述行，这造成了不必要的冗余。</p>
<p>第四行是 quality data，可以占据一行或多行，但是必须和序列长度一致。它的quality score 是通过一种特殊的方式显示为字母。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@DJB775P1:248:D0MDGACXX:7:1202:12362:49613</span><br><span class="line">TGCTTACTCTGCGTTGATACCACTGCTTAGATCGGAAGAGCACACGTCTGAA </span><br><span class="line">+ </span><br><span class="line">JJJJJIIJJJJJJHIHHHGHFFFFFFCEEEEEDBD?DDDDDDBDDDABDDCA </span><br><span class="line">@DJB775P1:248:D0MDGACXX:7:1202:12782:49716</span><br><span class="line">CTCTGCGTTGATACCACTGCTTACTCTGCGTTGATACCACTGCTTAGATCGG</span><br><span class="line">+</span><br><span class="line">IIIIIIIIIIIIIIIHHHHHHFFFFFFEECCCCBCECCCCCCCCCCCCCCCC</span><br></pre></td></tr></table></figure>
<p>类似于FASTA，FASTQ的一个惯例是通过第一个空格分为两部分，序列名和其他描述部分。</p>
<p>FASTQ 文件很难正确解析，一个通常的陷阱是将以@开头的行视为一个描述行。然而，@也是一个有效的 quality character。但是，我们可以通过序列行和质量行长度相等来解析数据。</p>
<h3 id="查询-FASTA-FASTQ-记录数">查询 FASTA/FASTQ 记录数</h3>
<p>查看 FASTA 记录数比较简单</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -c &quot;^&gt;&quot; egfr_flank.fasta</span><br></pre></td></tr></table></figure>
<p>我们一开始想到一个同样简单的办法来查找 FASTQ 文件，如下，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">  grep -c <span class="string">&quot;^@&quot;</span> untreated1_chr4.fq</span></span><br><span class="line">208779</span><br></pre></td></tr></table></figure>
<p>但是，细看这个文件结构，我们发现它都是4行一个记录，通过查找文件行数，再除以4，应该是204355 个记录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wc -l untreated1_chr4.fq</span></span><br><span class="line">817420 untreated1_chr4.fq</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="number">817420</span>/<span class="number">4</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">204355</span></span><br></pre></td></tr></table></figure>
<p>这里就是上面提到的，存在质量行以@开头。可以通过以下命令查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">&quot;^@&quot;</span> untreated1_chr4.fq | less</span></span><br><span class="line">@SRR031729.5549475</span><br><span class="line">@SRR031729.10518513</span><br><span class="line">@SRR031729.2324257</span><br><span class="line">@AAB@?A2AA?AAA=???=;A9&gt;:1==3A4=8119=0&gt;1;4A=9,25A11603=;&gt;;411;/0493#########</span><br><span class="line">@SRR031729.7021582</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种情况下，最保险的措施是采用 bioawk</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bioawk -cfastx &#39;END&#123;print NR&#125;&#39; untreated1_chr4.fq</span><br><span class="line">204355</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="10-3-Nucleotide-Codes">10.3 Nucleotide Codes</h2>
<p>The  International  Union  of  Pure  and Applied Chemistry (IUPAC) 设定的碱基编码规则如下</p>
<p><img src="41.png" alt="41"></p>
<p><img src="42.png" alt="41"></p>
<h2 id="10-4-Base-Qualities">10.4 Base Qualities</h2>
<p>quality 编码为 ASCII 字符。 ASCII 码用0-127来表示，但是并不是所有的 ASCII 字符都是可以打印的字符。quality score 只使用可打印的ASCII 字符，从33到126.</p>
<p>所有的编程语言都有转化字符和它的ASCII码的函数。比如python，就存在函数 ord() 和 chr() 。我们试一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>qual = <span class="string">&quot;JJJJJJJJJJJJGJJJJJIIJJJJJIGJJJJJIJJJJJJJIJIJJJJHHHHHFFFDFCCC&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="built_in">ord</span>(b) <span class="keyword">for</span> b <span class="keyword">in</span> qual]</span><br><span class="line">[<span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">71</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">73</span>, <span class="number">73</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">73</span>, <span class="number">71</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">73</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">73</span>, <span class="number">74</span>, <span class="number">73</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">72</span>, <span class="number">72</span>, <span class="number">72</span>, <span class="number">72</span>, <span class="number">72</span>, <span class="number">70</span>, <span class="number">70</span>, <span class="number">70</span>, <span class="number">68</span>, <span class="number">70</span>, <span class="number">67</span>, <span class="number">67</span>, <span class="number">67</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>很不幸的是，如果相把表示quality 的字符重新转化为有含义的 quality scores ，这是非常困难的。因为这里存在三种不同的quality schemes: sanger, solexa, illumina 。见下图，但是现在好像都统一成了 sanger scheme。</p>
<p><img src="43.png" alt="41"></p>
<p>这里只看 sanger scheme，首先我们需要从质量的字符对应的ASCII码 减去一个 offset (33)，得到了一个 PHRED quality score。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>phred = [<span class="built_in">ord</span>(b)-<span class="number">33</span> <span class="keyword">for</span> b <span class="keyword">in</span> qual]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>phred</span><br><span class="line">[<span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">38</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">40</span>, <span class="number">38</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">39</span>, <span class="number">39</span>, <span class="number">39</span>, <span class="number">39</span>, <span class="number">39</span>, <span class="number">37</span>, <span class="number">37</span>, <span class="number">37</span>, <span class="number">35</span>, <span class="number">37</span>, <span class="number">34</span>, <span class="number">34</span>, <span class="number">34</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之后我们可以根据下面这个式子，见quality score 转化为这个碱基 call 的估计准确性</p>
<p>（疑问：如果是这个公式，Q越大，P越小。如果 P代表准确性，那么就是说quality score 数值越小，准确性越高。但好像从后面的表述看，不是这样，quality score 数值是越大越好）</p>
<p><a href="https://www.jianshu.com/p/1726696e54e5">https://www.jianshu.com/p/1726696e54e5</a></p>
<p>（解答：根据上面的内容，这个P值指<strong>检测错误的概率</strong>，所以 <strong>quality score 越大越好</strong>）</p>
<p><img src="44.png" alt="41"></p>
<p>根据这个公式计算出碱基call的估计准确性（这个结果和pdf不一样）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">10</span>**(-q/<span class="number">10</span>) <span class="keyword">for</span> q <span class="keyword">in</span> phred]</span><br><span class="line">[<span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">0.00015848931924611142</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">0.0001</span>, <span class="number">0.0001</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">0.0001</span>, <span class="number">0.00015848931924611142</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">0.0001</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">0.0001</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">0.0001</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">0.00012589254117941674</span>, <span class="number">0.00012589254117941674</span>, <span class="number">0.00012589254117941674</span>, <span class="number">0.00012589254117941674</span>, <span class="number">0.00012589254117941674</span>, <span class="number">0.00019952623149688788</span>, <span class="number">0.00019952623149688788</span>, <span class="number">0.00019952623149688788</span>, <span class="number">0.00031622776601683794</span>, <span class="number">0.00019952623149688788</span>, <span class="number">0.00039810717055349735</span>, <span class="number">0.00039810717055349735</span>, <span class="number">0.00039810717055349735</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="10-5-Example-Inspecting-and-Trimming-Low-Quality-Bases">10.5 Example: Inspecting and Trimming Low-Quality Bases</h2>
<p>如果你想把所有reads 的quality score 可视化，你可以用 java 软件 FastQC。如果你想用R统计，你可以使用一个 Bioconducter 包 qrqc  。这里用qrqc包举例</p>
<p>之后，我们按照两个软件包来删掉低质量的碱基：sickle 和 seqtk 。</p>
<p>sickle 软件过滤低质量位点的命令为（用conda安装后运行说没找到程序）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sickle se -f untreated1_chr4.fq -t sanger -o untreated1_chr4_sickle.fq</span><br></pre></td></tr></table></figure>
<p>seqtk 的相应命令为（conda安装运行成功）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">seqtk trimfq untreated1_chr4.fq &gt; untreated1_chr4_trimfq.fq</span><br></pre></td></tr></table></figure>
<p>查看行数，发现没有变化。那我猜，这个命令是把每个read中的低质量碱基剔除了，比如说原来是200bp，现在只有160bp。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wc -l untreated1_chr4.fq</span></span><br><span class="line">817420 untreated1_chr4.fq</span><br><span class="line"><span class="meta">$</span><span class="bash"> wc -l untreated1_chr4_trimfq.fq</span></span><br><span class="line">817420 untreated1_chr4_trimfq.fq</span><br></pre></td></tr></table></figure>
<p>使用 qrqc 进行 quality score 的可视化（由于sickle没装好，剔除了它的文件）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(qrqc)</span><br><span class="line">fqfiles &lt;- <span class="built_in">c</span>(none=<span class="string">&quot;untreated1_chr4.fq&quot;</span>, trimfq=<span class="string">&quot;untreated1_chr4_trimfq.fq&quot;</span>)</span><br><span class="line"><span class="comment"># Load each file in, using qrqc&#x27;s readSeqFile</span></span><br><span class="line"><span class="comment"># We only need qualities, so we turn off some of</span></span><br><span class="line"><span class="comment"># readSeqFile&#x27;s other features.</span></span><br><span class="line">seq_info &lt;- lapply(fqfiles, <span class="keyword">function</span>(file) &#123;readSeqFile(file, hash=<span class="literal">FALSE</span>, kmer=<span class="literal">FALSE</span>)&#125;)</span><br><span class="line"><span class="comment"># Extract the qualities as dataframe, and append</span></span><br><span class="line"><span class="comment"># a column of which trimmer (or none) was used. This</span></span><br><span class="line"><span class="comment"># is used in later plots.</span></span><br><span class="line">quals &lt;- mapply(<span class="keyword">function</span>(sfq, name) &#123;</span><br><span class="line">                qs &lt;- getQual(sfq)</span><br><span class="line">                qs$trimmer &lt;- name                </span><br><span class="line">                qs</span><br><span class="line">                &#125;, seq_info, <span class="built_in">names</span>(fqfiles), SIMPLIFY=<span class="literal">FALSE</span>)</span><br><span class="line"><span class="comment"># Combine separate dataframes in a list into single dataframe</span></span><br><span class="line">d &lt;- do.call(rbind, quals)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Visualize qualities</span></span><br><span class="line">library(ggplot2)</span><br><span class="line">p1 &lt;- ggplot(d) + geom_line(aes(x=position, y=mean, linetype=trimmer))</span><br><span class="line">p1 &lt;- p1 + ylab(<span class="string">&quot;mean quality (sanger)&quot;</span>) + theme_bw()</span><br><span class="line">ggsave(<span class="string">&quot;mean_quality.png&quot;</span>,plot=p1)</span><br><span class="line"><span class="comment"># Use qrqc&#x27;s qualPlot with list produces panel plots</span></span><br><span class="line"><span class="comment"># Only shows 10% to 90% quantiles and lowess curve</span></span><br><span class="line">p2 &lt;- qualPlot(seq_info, quartile.color=<span class="literal">NULL</span>, mean.color=<span class="literal">NULL</span>) + theme_bw()</span><br><span class="line">p2 &lt;- p2 + scale_y_continuous(<span class="string">&quot;quality (sanger)&quot;</span>)</span><br><span class="line">ggsave(<span class="string">&quot;quality.png&quot;</span>,plot=p2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每个位置的平均quality score</p>
<p><img src="mean_quality.png" alt="mean_quality"></p>
<p>每个位点的quality score 的分布（上下限为90%和10%分位点）。从这里还可以看到，一条read上的位点的测序质量随着长度的延申而下降。</p>
<p><img src="quality.png" alt="quality"></p>
<p>清楚低质量位点并不难，一行命令解决。但是<strong>更重要的步骤是对数据清洗前后使用可视化进行对比</strong>，来检查这些软件如何作用于我们的数据，而不是单纯地相应软件。（<strong>黄金守则：不要相信你的工具</strong>）。</p>
<p>一个谨慎的生信操作流程应该是这样的：运行一个程序，比对原始数据，运行一个程序，比对原始数据，循环往复……</p>
<h2 id="10-6-A-FASTA-FASTQ-Parsing-Example-Counting-Nucleotides">10.6 A FASTA/FASTQ Parsing Example: Counting Nucleotides</h2>
<p>你可以自己写一个处理 FASTQ/FASTQ 的流程，这是一个很好的编程训练。但是当处理实际数据时，最好还是用现有的可靠的库。<strong>great programmers know when to reuse code</strong>。有很多开源的包，它们也调试到了尽可能的高效。</p>
<p>这里我们会用 Heng Li 写的 readfq 软件，因为它可以同时处理 FASTA 和 FASTQ 文件。其他可选的软件由 Biopython 和 BioPerl。</p>
<p>我们会用到 readfq 的 python 版本 <a href="http://reafq.py">reafq.py</a> 。可以当成一个库文件，使用 <code>from readfq import readfq</code>；或者更方便的是，直接复制到你自己的脚本里（这里举例用第一种，我用第二种）。</p>
<p>（有一个问题是，这个python脚本是用 python2 写的，需要修改，就是print 加上括号）</p>
<p>这个 readfq() 函数用起来很简单，需要一个文件对象（已经用open()打开的），然后数生成 FASTQ/FASTQ 的 entris 直至文件末尾。 每个 FASTQ/FASTA entry 会返回成一个元组（包括entry’s description, sequence, quality）。如果 readfq 是读取一个 FASTA 文件，那么 quality line 会是 None。</p>
<p>如果你仔细看 readfq() 的代码，你会发现存在 yield 部分。这说明 readfq() 是一个 generator function 。</p>
<p>让我们写一个简单的程序，来计算一个文件的碱基数目。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># nuccount.py -- tally nucleotides in a file</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="comment">#Counter函数是字典的子类，可以计数可哈希对象。</span></span><br><span class="line"><span class="comment">#它是一个集合，元素像字典键(key)一样存储，它们的计数存储为值。计数可以是任何整数值，包括0和负数。</span></span><br><span class="line"><span class="keyword">from</span> readfq <span class="keyword">import</span> readfq</span><br><span class="line"></span><br><span class="line"><span class="comment">#IUPAC固定的碱基编码</span></span><br><span class="line">IUPAC_BASES = <span class="string">&quot;ACGTRYSWKMBDHVN-.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># intialize counter</span></span><br><span class="line">counts = Counter()</span><br><span class="line"></span><br><span class="line"><span class="comment">#sys.stdin 从标准输入中获取数据，这样可以实用linux的pipeline了</span></span><br><span class="line"><span class="keyword">for</span> name, seq, qual <span class="keyword">in</span> readfq(sys.stdin):</span><br><span class="line">    <span class="comment"># for each sequence entry, add all its bases to the counter</span></span><br><span class="line">    counts.update(seq.upper())</span><br><span class="line"></span><br><span class="line"><span class="comment"># print the results</span></span><br><span class="line"><span class="keyword">for</span> base <span class="keyword">in</span> IUPAC_BASES:</span><br><span class="line">    <span class="built_in">print</span>(base + <span class="string">&quot;\t&quot;</span> + <span class="built_in">str</span>(counts[base]))</span><br></pre></td></tr></table></figure>
<p>运行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat contam.fastq | python nuccount.py</span></span><br><span class="line">A       103</span><br><span class="line">C       110</span><br><span class="line">G       94</span><br><span class="line">T       109</span><br><span class="line">R       0</span><br><span class="line">Y       0</span><br><span class="line">S       0</span><br><span class="line">W       0</span><br><span class="line">K       0</span><br><span class="line">M       0</span><br><span class="line">B       0</span><br><span class="line">D       0</span><br><span class="line">H       0</span><br><span class="line">V       0</span><br><span class="line">N       0</span><br><span class="line">-       0</span><br><span class="line">.       0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后，作者又赞美了 reuse code</p>
<blockquote>
<p>Reusing software isn’t cheating—it’s how the experts program</p>
</blockquote>
<h3 id="generator-生成器-python">generator 生成器 - python</h3>
<p><a href="https://www.liaoxuefeng.com/wiki/897692888725344/923029685138624">https://www.liaoxuefeng.com/wiki/897692888725344/923029685138624</a></p>
<p>主要应用于大数据：直接读取会占用过多内存，使用 generator 和循环，每次只读取一个元素。</p>
<p>举例，斐波那契数列写成 generator function。函数中用 yield 代替print 即可。每次调用函数的时候，遇到 yield 语句就会返回，再次执行时从上次返回的 yield 语句处继续执行（这里是 a, b = b, a + b）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> fib(<span class="number">6</span>):</span><br><span class="line">	<span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure>
<h3 id="多个元素同时赋值-python">多个元素同时赋值 - python</h3>
<p>最近越来越多地看到这种多个元素同时赋值的代码，比如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = <span class="number">1</span>,<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>确实是可以运行，但是上面这种我觉得没有必要，影响了可读性。</p>
<p>下面这种比较实用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i,j,k <span class="keyword">in</span> a:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i,j,k)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i,j,k <span class="keyword">in</span> a:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i,j,k)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="10-7-Indexed-FASTA-Files">10.7 Indexed FASTA Files</h2>
<p>有时我们需要提取 FASTA 文件地某些子序列，如果只做一次，可以直接遍历FASTA的所有序列，但是这不是一个有效的方式，尤其是对于大文件。比如果我们想提取在8号染色体（23,407,082 to 123,410,742）的序列，这种方式还会和其他染色体的序列进行比对，而且从硬盘中把整个基因组文件读取进来也是非常低效的。</p>
<p>一个通常的计算策略是 <strong>indexing</strong> the file 。 这里为了举例，只用8号染色体的基因组数据。</p>
<p>这里要先解压FASTA文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gunzip Mus_musculus.GRCm38.75.dna.chromosome.8.fa.gz</span><br></pre></td></tr></table></figure>
<p>然后，使用 samtools 软件 index 这个 FASTA 文件，生成文件 Mus_musculus.GRCm38.75.dna.chromosome.8.fa.fai 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">samtools faidx Mus_musculus.GRCm38.75.dna.chromosome.8.fa</span><br></pre></td></tr></table></figure>
<p><strong>提取子序列</strong>的代码为如下，其中 <region> 要是chromosome:start-end 格式。（注意染色体是 chr8 还是 8 格式）。之后屏幕上就会打印出需要提取的序列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">faidx &lt;in.fa&gt; &lt;region&gt;</span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools faidx Mus_musculus.GRCm38.75.dna.chromosome.8.fa 8:123407082-123410744</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">8:123407082-123410744</span></span><br><span class="line">GAGAAAAGCTCCCTTCTTCTCCAGAGTCCCGTCTACCCTGGCTTGGCGAGGGAAAGGAAC</span><br><span class="line">CAGACATATATCAGAGGCAAGTAACCAAGAAGTCTGGAGGTGTTGAGTTTAGGCATGTCT</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>samtools 支持同时提取多个序列。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools faidx Mus_musculus.GRCm38.75.dna.chromosome.8.fa \</span></span><br><span class="line"><span class="bash">8:123407082-123410744 8:123518835-123536649</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">8:123407082-123410744</span></span><br><span class="line">GAGAAAAGCTCCCTTCTTCTCCAGAGTCCCGTCTACCCTGGCTTGGCGAGGGAAAGGAAC</span><br><span class="line">CAGACATATATCAGAGGCAAGTAACCAAGAAGTCTGGAGGTGTTGAGTTTAGGCATGTCT</span><br><span class="line">[...]</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">8:123518835-123536649</span></span><br><span class="line">TCTCGCGAGGATTTGAGAACCAGCACGGGATCTAGTCGGAGTTGCCAGGAGACCGCGCAG</span><br><span class="line">CCTCCTCTGACCAGCGCCCATCCCGGATTAGTGGAAGTGCTGGACTGCTGGCACCATGGT</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<h3 id="为什么index使得检索更快">为什么index使得检索更快</h3>
<p>首先，之前那么做速度慢，主要是因为从硬盘中读写数据非常耗时。</p>
<p>通过 index ，我们记录下来了每个序列在文件开始的地方。这样检索的时候，就不用读取整个文件，而是直接跳到我们想要的序列的位置。</p>
<p>说白了，这就是像是做了一本书的目录一样，想找东西，看目录，然后跳到指定的页码。</p>
<h1>11 Working with Alignment Data</h1>
<p>the Sequence Alignment Mapping (SAM) 格式 （二进制格式为BAM）。</p>
<blockquote>
<p>The  SAM and BAM formats are the standard formats for storing sequencing reads mapped to a reference.</p>
</blockquote>
<h2 id="11-1-Getting-to-Know-Alignment-Formats-SAM-and-BAM">11.1 Getting to Know Alignment Formats: SAM and BAM</h2>
<h3 id="11-1-1-The-SAM-Header">11.1.1 The SAM Header</h3>
<p><img src="45.png" alt="45"></p>
<p>表头以 @ 符号开始，后面跟着两个字符。再后面就是tab分隔的 key-value pairs （KEY:VALUE）。</p>
<ul>
<li>
<p>@SQ 行存储着参考基因组序列的信息。必需的键值对为 SN， 存储着 sequence name （比如 染色体 1）；还有 LN，存储序列长度。参考基因组的所有分开的序列都会占据一行。</p>
</li>
<li>
<p>@RG 包含重要的 read group 和 sample metadata。(没看懂)</p>
<blockquote>
<p>This ID value contains information about the origin of a set of reads.<br>
Some software relies on read groups toindicate  a  technical  groups<br>
of  reads,  to  account  for  batch  effects  (undesirabletechnical artifacts  in  data).  Consequently, it’s  beneficial  to  create  read  groupsrelated to the specific sequencing run  (e.g., ID could be related to the name of thesequencing run and lane)</p>
</blockquote>
<p>样本信息存放在 SM 字段中（(e.g.,  individual,  treatment  group,  replicate,  etc.）</p>
<p>可能地话，还会有检测平台 PL (platform) ，比如 ILLUMINA, PACBIO,。</p>
</li>
<li>
<p>@PG 包含创建和处理 SAM/BAM 文件使用的软件。 软件版本（VN），命令行（CL）。</p>
</li>
</ul>
<p>但是标准的处理 SAM/BAM 文件是通过 SAMtools 命令行。</p>
<p>查看 headline 使用以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools view -H celegans.sam</span></span><br><span class="line">@SQ     SN:I    LN:15072434</span><br><span class="line">@SQ     SN:II   LN:15279421</span><br><span class="line">@SQ     SN:III  LN:13783801</span><br><span class="line">@SQ     SN:IV   LN:17493829</span><br><span class="line">@SQ     SN:MtDNA        LN:13794</span><br><span class="line">@SQ     SN:V    LN:20924180</span><br><span class="line">@SQ     SN:X    LN:17718942</span><br><span class="line">@RG     ID:VB00023_L001 SM:celegans-01</span><br><span class="line">@PG     ID:bwa  PN:bwa  VN:0.7.10-r789  CL:bwa mem -R @RG\tID:VB00023_L001\tSM:celegans-01 Caenorhabditis_elegans.WBcel235.dna.toplevel.fa celegans-1.fq celegans-2.fq</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同样可以用于 BAM 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools view -H celegans.bam</span></span><br><span class="line">@SQ     SN:I    LN:15072434</span><br><span class="line">@SQ     SN:II   LN:15279421</span><br><span class="line">@SQ     SN:III  LN:13783801</span><br><span class="line">@SQ     SN:IV   LN:17493829</span><br><span class="line">@SQ     SN:MtDNA        LN:13794</span><br><span class="line">@SQ     SN:V    LN:20924180</span><br><span class="line">@SQ     SN:X    LN:17718942</span><br><span class="line">@RG     ID:VB00023_L001 SM:celegans-01</span><br><span class="line">@PG     ID:bwa  PN:bwa  VN:0.7.10-r789  CL:bwa mem -R @RG\tID:VB00023_L001\tSM:celegans-01 Caenorhabditis_elegans.WBcel235.dna.toplevel.fa celegans-1.fq celegans-2.fq</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果不加 -H 选项，默认返回没有标题的数据部分</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools view celegans.sam | head -n 1</span></span><br><span class="line">I_2011868_2012306_0:0:0_0:0:0_2489      83      I       2012257 40      50M     =       2011868 -439    CAAAAAATTTTGAAAAAAAAAATTGAATAAAAATTCACGGATTTCTGGCT       22222222222222222222222222222222222222222222222222      NM:i:0  MD:Z:50 AS:i:50 XS:i:50  RG:Z:VB00023_L001       XA:Z:I,-2021713,50M,0;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="SAM-更多资料">SAM 更多资料</h4>
<p><a href="http://samtools.github.io/hts-specs/">http://samtools.github.io/hts-specs/</a></p>
<h3 id="11-1-2-The-SAM-Alignment-Section">11.1.2 The SAM Alignment Section</h3>
<p><img src="46.png" alt="45"></p>
<ol>
<li>
<p>QNAME， the query name (e.g., a sequence read’s name)</p>
</li>
<li>
<p>FLAG, the  bitwise  flag,  which  contains  information  about  the  alignment.  (?)</p>
</li>
<li>
<p>RNAME,  the  reference  name  (比如 “chr1&quot;)</p>
</li>
<li>
<p>POS, 参考序列中第一个与 query sequence 匹配上的碱基位置（1-based indexing）.如果没有比对上，这个数值会是0。</p>
</li>
<li>
<p>MAPQ 是 mapping quality ，衡量 read 确实是起源于它比对上的位置的可能性。这个是由软件估计得到。很多软件会自动过滤掉 mapping quality 很低的 read。</p>
</li>
<li>
<p>CIGAR : 描述 alignment 的特殊格式（matching bases,  insertions/deletions, clipping）</p>
</li>
<li>
<p>RNEXT （reference name, * 表示未知， = 表示和 RNAME 相同） and  PNEXT  (下一行，position，未知是0)</p>
</li>
<li>
<p>TLEN 是 <code>template length for paired-end reads</code></p>
</li>
<li>
<p>SEQ 是原始的 read 序列。</p>
<blockquote>
<p>This sequence will always be in the orienta‐tion  it  aligned  in  (and  this  may  be  the  reverse  complement  of  the  original  readsequence). Thus, if your read aligned to the reverse strand (which is informationkept in the bitwise flag field), this sequence will be the reverse complement.</p>
</blockquote>
</li>
<li>
<p>QUAL 存储原始的  quality</p>
</li>
</ol>
<h3 id="11-1-3-Bitwise-Flags">11.1.3 Bitwise Flags</h3>
<p>通过 <code>samtools flags</code> 查看所有可用的 flags</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools flags</span></span><br><span class="line"></span><br><span class="line">About: Convert between textual and numeric flag representation</span><br><span class="line">Usage: samtools flags INT|STR[,...]</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">        0x1     PAIRED        .. paired-end (or multiple-segment) sequencing technology</span><br><span class="line">        0x2     PROPER_PAIR   .. each segment properly aligned according to the aligner</span><br><span class="line">        0x4     UNMAP         .. segment unmapped</span><br><span class="line">        0x8     MUNMAP        .. next segment in the template unmapped</span><br><span class="line">        0x10    REVERSE       .. SEQ is reverse complemented</span><br><span class="line">        0x20    MREVERSE      .. SEQ of the next segment in the template is reversed</span><br><span class="line">        0x40    READ1         .. the first segment in the template</span><br><span class="line">        0x80    READ2         .. the last segment in the template</span><br><span class="line">        0x100   SECONDARY     .. secondary alignment</span><br><span class="line">        0x200   QCFAIL        .. not passing quality controls</span><br><span class="line">        0x400   DUP           .. PCR or optical duplicate</span><br><span class="line">        0x800   SUPPLEMENTARY .. supplementary alignment</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里设计到二进制，十进制和十六进制的转化。</p>
<p>比如你遇到了一个 bitflag 是147 （转化位十六进制是 93），第一步先转化为二进制，是 1001 0011 ，其中是1的位数是第一、第二、第五和第八位（位数是从右往左数）。参照上面的 flags 的顺序，分别对应着 0x1 0x2 0x10 和 0x80 。</p>
<p>你可以直接通过 samtools 完成上述的对应过程，既可以用十进制，也可以用十六进制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools flags 147</span></span><br><span class="line">0x93    147     PAIRED,PROPER_PAIR,REVERSE,READ2</span><br><span class="line"><span class="meta">$</span><span class="bash"> samtools flags 0x93</span></span><br><span class="line">0x93    147     PAIRED,PROPER_PAIR,REVERSE,READ2</span><br></pre></td></tr></table></figure>
<p>也可以反过来</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools flags paired,read1,qcfail</span></span><br><span class="line">0x241   577     PAIRED,READ1,QCFAIL</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="11-1-4-CIGAR-Strings">11.1.4 CIGAR Strings</h3>
<p>类似于 bitwise flags， CIGAR 字段也有一种特殊的方式来编码信息。CIGAR 存储着关于比对文件中的哪些碱基是Matches/misMatches, insertions, deletions, soft or hard clipped。</p>
<p>soft clipping 是指当只有一部分 query sequence 比对上了参考序列，其他部分无法比对上。这种情况发生在当匹配一个 read 与一个位置时，要么头部要么尾部无法匹配上。hard clipping 类似，但是hard-clipped 区域不会出现 SEQ 字段的序列中。</p>
<p>一个基本的 CIGAR 字段包含合并的整数和字符。比如一个51个碱基的read完全匹配上 了，没有插入和缺失，会有一个 CIGAR 字段包含一个单独的 length/operation pair : <strong>51M</strong>。注意，这里M 表示能配对上，而不是说所有的碱基和参考基因组是一样的。</p>
<p><img src="47.png" alt="45"></p>
<p><img src="48.png" alt="45"></p>
<p>让我们看一个复杂一点的例子：<strong>43S6M1I26M</strong>。首先我们把它分解成 43S, 6M, 1I, 26M ，利用上面的表格，这是说 开始的43个碱基 是 soft-clipped， 之后的6个碱基是 matched， 然后是 1 个插入，最后是26 个碱基 match。</p>
<p>注意，这些数字加起来必需等于 read sequence 的长度。</p>
<h3 id="11-1-5-Mapping-Qualities">11.1.5 Mapping Qualities</h3>
<p>比对后的所有下游操作均基于<strong>可靠</strong>的比对结果（ SNP calling and genotyping, RNA-seq）。Mapping qualities 是衡量比对的可靠性的指标。类似于 base quality ， mapping quality 也是一个log probability ，见下式，其中 P 是<strong>错误比对的概率</strong>。</p>
<p><img src="49.png" alt="45"></p>
<p>比对质量和另一个概念也是相关的，比对唯一性（mapping uniqueness）。这通常定义为 一条read 的第二好的比对结果比第一好的比对结果有更多地的 mismatches。然而，比对唯一性的概念并不能解释 mismatches 的碱基质量，也就是说一个mismatch 究竟是 base calling error 还是 一个真实的变异。</p>
<p>我们可以通过 mapping qualities 来过滤掉可能是错误的比对，找出哪些区域比对结果很差。</p>
<h2 id="11-2-Command-Line-Tools-for-Working-with-Alignments-in-the-SAM-Format">11.2 Command-Line Tools for Working with Alignments in the SAM Format</h2>
<h3 id="11-2-1-Using-samtools-view-to-Convert-between-SAM-and-BAM">11.2.1 Using samtools view to Convert between SAM and BAM</h3>
<p>samtools 的很多子命令都要求输入文件是 BAM 格式。因此我们经常需要在 SAM 和 BAM 两种格式中切换。 samtools view 可以做到这一点。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">samtools view -b celegans.sam &gt; celegans_copy.bam</span><br><span class="line">samtools view celegans.bam &gt; celegans_copy.sam</span><br></pre></td></tr></table></figure>
<p>但是，samtools view 生成的 SAM 文件不会包括 SAM header 。这种格式无法再转化位 BAM 文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools view -b celegans_copy.sam &gt; celegans_copy.bam</span></span><br><span class="line">[E::sam_parse1] missing SAM header</span><br><span class="line">[W::sam_read1] Parse error at line 1</span><br><span class="line">[main_samview] truncated file.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以通过 添加 -h 来保留表头。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">samtools view -h celegans.bam &gt; celegans_copy.sam</span><br><span class="line">samtools view -b celegans_copy.sam &gt; celegans_copy.bam #now we can convert back</span><br></pre></td></tr></table></figure>
<p>通常来说，我们将 BAM 转化为 SAM，一般仅仅是为了看一下数据。一般情况下，使用 BAM 格式更好，因为更节省空间，符合 samtools 输入文件要求，处理速度也更快。</p>
<h4 id="The-CRAM-Format">The CRAM Format</h4>
<p>samtools 现在支持一个新的，高度压缩的文件格式， CRAM，相比于 BAM 文件能够进一步压缩10%-30%的空间。CRAM 是一种 reference-based 压缩系统，即只有当aligned sequence 和参考基因组序列不同时才会被记录。这大幅度地压缩了文件大小，因为很多的比对序列和参考基因组只有很少的不同。因此对于这种格式而言，<strong>参考序列是必要的，而且不能改变</strong>。由于参考序列对于这种格式特别重要，CRAM 文件还包含了一个参考序列文件的 MD5 校验码。</p>
<h3 id="11-2-2-Samtools-Sort-and-Index">11.2.2 Samtools Sort and Index</h3>
<p>类似于 FASTA 格式， BAM 文件也可以 sort 和 index ，方便查找某个区域的比对的reads。</p>
<p>首先我们可以通过 samtools sort 来进行排序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">samtools sort celegans_unsorted.bam -o celegans_sorted.bam</span><br></pre></td></tr></table></figure>
<p>如果对一个大的文件进行排序计算量会很大，因此 samtools sort 存在选项来让你提高内存和线程数。通常情况下，对于一个很大的 BAM 文件，可能无法完全放进内存中，因此samtools sort 会将文件切分成几个部分，对每个部分进行排序，写入到临时文件中，最后合并所有的临时文件（和我的填充策略一样）。用计算机科学的术语来说，samtools sort 使用了一个 merge sort 。</p>
<p>提高内存，可以减少samtools sort 分割文件的数量，这样速度更快（？）。由于切分文件后，对每个部分进行排序的步骤彼此之间是独立的，因此这一步可以平行处理。我们可以通过 -m 来增加内存( K, M, G)，-@ 来增加线程数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">samtools sort -m 4G -@ 2 celegans_unsorted.bam -o celegans_sorted.bam</span><br></pre></td></tr></table></figure>
<p>很多时候，我们想提取基因组上某个区域的 alignments。这时就需要index（只能针对 sorted BAM文件）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">samtools index celegans_sorted.bam</span><br></pre></td></tr></table></figure>
<p>这个时候就生成了一个新文件，<code>celegans_sorted.bam.bai</code> 。</p>
<h3 id="11-2-3-Extracting-and-Filtering-Alignments-with-samtools-view">11.2.3 Extracting and Filtering Alignments with samtools view</h3>
<p>为了模拟提取部分区域的 alignments ，我们使用了千人基因组的数据的子集。</p>
<p>首先，我们对bam文件进行 index。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools index NA12891_CEU_sample.bam</span></span><br></pre></td></tr></table></figure>
<p>然后，我们看一下位于1号染色体 215,906,469-215,906,652 区域的 alignments</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools view NA12891_CEU_sample.bam 1:215906469-215906652 | head -n 3</span></span><br><span class="line">SRR003212.5855757   147  1  215906433  60  33S43M  =  215906402 [...]</span><br><span class="line">SRR003206.18432241  163  1  215906434  60  43M8S   =  215906468 [...]</span><br><span class="line">SRR014595.5642583   16   1  215906435  37  8S43M   *  0 [...]</span><br></pre></td></tr></table></figure>
<p>也可以写入一个新的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools view -b NA12891_CEU_sample.bam 1:215906469-215906652 &gt;  USH2A_sample_alns.bam</span></span><br></pre></td></tr></table></figure>
<p>如果你有很多区域存放在 BED 文件中，你可以直接通过 -L 选项使用 BED 文件提取区域。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools view -L USH2A_exons.bed NA12891_CEU_sample.bam  | head -n 3</span></span><br></pre></td></tr></table></figure>
<h4 id="Filtering-alignments-with-samtools-view">Filtering alignments with samtools view</h4>
<p>samtools view 也可以根据 bitwise flags, mapping quality, read group 等过滤 alignments。</p>
<p>你可以通过直接输入 <code>samtools view</code> 命令查看说明。</p>
<p>让我们先看如何根据 bitwise flags 过滤。总共有两个选项可用：-f , 只输出具有特定flag 的reads； -F, 相反会输出没有特定flag 的 reads。让我们通过一个例子来说明，我们用  samtools flags 来找出我们需要的 flags。假设你想要输出所有unmapped 的 reads。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools flags unmap</span></span><br><span class="line">0x4     4       UNMAP</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之后我们通过 <code>samtools view -f 4</code> 来输出符合这个flag 的 reads</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools view -f 4 NA12891_CEU_sample.bam | head -n 3</span></span><br><span class="line">SRR003208.1496374       69      1       215623168       0       35M16S  =       215623168    0TTTGTAGGTCCAAAAAAAGAGAGGGANGAAGTGCTCCGTATAATCATAGTA     &gt;@&gt;=&lt;5&lt;;#&gt;&gt;:28-813;$&lt;.;$0/!:%%&lt;%9$3%3.41&quot;#&quot;$0$/&quot;%%#   XC:i:35 RG:Z:SRR003208  OQ:Z:=D@B6-EC#=:.)+&amp;+&#x27;(2$4&amp;4$(&amp;!,%%0%)$&amp;%(*(&#x27;&quot;#&quot;$&amp;$&#x27;&quot;%%#</span><br><span class="line">SRR002141.16953736      181     1       215623191       0       40M11S  =       215623191    0AATATCCACTACACCAACCATAAACTTAATTGTCTCTATTTTTTTTCCTGT     $$7;$%&lt;&lt;$$&gt;%&lt;9?B&gt;:@B;@&lt;??&gt;&lt;???&gt;:4=02@%?;&gt;%?==&lt;)A@,&lt;   XC:i:40 RG:Z:SRR002141  OQ:Z:$$(+$%).$$,%6+II+EII+&lt;,2C.04D51,*&gt;()I%:0:%CI6&lt;&amp;AF&amp;8</span><br><span class="line">SRR002143.2512308       181     1       215623216       0       *       =       215623216    0GTTCACAAATAACAGTATATTTATAACAACCATAAACTTAATTGGCACTAT     +4$&quot;$#&quot;$&quot;$#$#%4041&quot;%244&quot;&lt;1&gt;A::9?=A@8=/&lt;A&gt;6==;24&lt;;?;   RG:Z:SRR002143  OQ:Z:I&amp;$&quot;$#&quot;$&quot;$#$#%&amp;&amp;&amp;&amp;&quot;%&amp;(&#x27;&quot;+&amp;85+4-29&lt;7+B&#x27;5H4,765++&lt;756</span><br></pre></td></tr></table></figure>
<p>我们可以通过 samtools flags 来证实这些reads 都是 unmapped</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools flags 69</span></span><br><span class="line">0x45    69      PAIRED,UNMAP,READ1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们也可以同时指定多个 flag。我们先找到相应的十进制的数字。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools flags READ1,PROPER_PAIR</span></span><br><span class="line">0x42    66      PROPER_PAIR,READ1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之后，再提取符合条件的 reads</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools view -f 66 NA12891_CEU_sample.bam | head -n 3</span></span><br><span class="line">SRR005672.8895  99      1       215622850       60      51M     =       215623041       227  GGAATAAATATAGGAAATGTATAATATATAGGAAATATATATATATAGTAA      ;=&lt;&gt;=&lt;&gt;&lt;9&lt;=&lt;9:&lt;=?&gt;&lt;=&gt;?&gt;@?&gt;&gt;9&gt;&gt;&gt;=&gt;@A@?@?@??7??==:19;   XT:A:U  NM:i:1  SM:i:37 AM:i:37 X0:i:1  X1:i:0  XM:i:1  XO:i:0  XG:i:0  MD:Z:48G2     RG:Z:SRR005672  OQ:Z:IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII?114I</span><br><span class="line">SRR005674.4317449       99      1       215622863       37      51M     =       215622987    175      GAAATGTATAATATATAGGAAATATATATATATAGGAAATATATAATATAT     ;=&gt;&gt;=&lt;;&lt;=&lt;&gt;=:&gt;=:==&lt;&lt;@@?:&gt;?&lt;?;&gt;&gt;&gt;?&gt;;44@@?&gt;?&gt;&gt;&gt;/:&gt;;=9   XT:A:U  NM:i:0  SM:i:37 AM:i:37 X0:i:1  X1:i:0  XM:i:0  XO:i:0  XG:i:0MD:Z:51 RG:Z:SRR005674  OQ:Z:IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII&lt;2+IIIIIIII&amp;GIICI</span><br><span class="line">SRR010927.10846964      83      1       215622892       60      51M     =       215622860    -83      ATATAGAAAATATATAATATATGTTAGGAATATATTAAGGCACCAGCTGTG     9596?$$===&lt;&gt;=&gt;;&gt;?&lt;?;??4?=@34&gt;=&lt;=;??;?@?===:=?=&lt;==@?   XT:A:U  NM:i:1  SM:i:37 AM:i:37 X0:i:1  X1:i:0  XM:i:1  XO:i:0  XG:i:0MD:Z:6G44       RG:Z:SRR010927  OQ:Z:G,I.F$$III=ICI7IICI8II-IEI-/IIIIIIGBIIIIIIIIIIIIIII</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以使用 -F 反向过滤（提取不符合条件的 reads）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools flags UNMAP</span></span><br><span class="line">0x4     4       UNMAP</span><br><span class="line"><span class="meta">$</span><span class="bash"> samtools view -F 4 NA12891_CEU_sample.bam | head -n 3</span></span><br><span class="line">SRR005672.8895  99      1       215622850       60      51M     =       215623041       227  GGAATAAATATAGGAAATGTATAATATATAGGAAATATATATATATAGTAA      ;=&lt;&gt;=&lt;&gt;&lt;9&lt;=&lt;9:&lt;=?&gt;&lt;=&gt;?&gt;@?&gt;&gt;9&gt;&gt;&gt;=&gt;@A@?@?@??7??==:19;   XT:A:U  NM:i:1  SM:i:37 AM:i:37 X0:i:1  X1:i:0  XM:i:1  XO:i:0  XG:i:0  MD:Z:48G2     RG:Z:SRR005672  OQ:Z:IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII?114I</span><br><span class="line">SRR010927.10846964      163     1       215622860       60      35M16S  =       215622892    83       TAGGAAATGTATAATATATAGGAAATATATATATATAGGAAATATATAATA     ;9=;&lt;???&gt;&gt;&lt;@?@@?@?A??==AA@&gt;@?@&gt;@8?69&lt;$2%&lt;::6:395%3,   XC:i:35 XT:A:U  NM:i:0  SM:i:37 AM:i:37 X0:i:1  X1:i:0  XM:i:0  XO:i:0XG:i:0  MD:Z:35 RG:Z:SRR010927  OQ:Z:IEIIIIIIIIEIIGIIIHIIII37:?3&gt;6E/&gt;*&gt;(.-$&#x27;%+*4+4&#x27;3)%,(</span><br><span class="line">SRR005674.4317449       99      1       215622863       37      51M     =       215622987    175      GAAATGTATAATATATAGGAAATATATATATATAGGAAATATATAATATAT     ;=&gt;&gt;=&lt;;&lt;=&lt;&gt;=:&gt;=:==&lt;&lt;@@?:&gt;?&lt;?;&gt;&gt;&gt;?&gt;;44@@?&gt;?&gt;&gt;&gt;/:&gt;;=9   XT:A:U  NM:i:0  SM:i:37 AM:i:37 X0:i:1  X1:i:0  XM:i:0  XO:i:0  XG:i:0MD:Z:51 RG:Z:SRR005674  OQ:Z:IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII&lt;2+IIIIIIII&amp;GIICI</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="SAM-Bitwise-Flags-and-SAM-Fields">SAM Bitwise Flags and SAM Fields</h4>
<p>这段话的意思大概是说不同flag 之间是有优先顺序的，应先满足底层的 flag。比如判断一个 read 是否比对上了，唯一的标准只有 unmapped flag，如果这个flag为真，哪怕其他字段有值，其实都是错的。</p>
<blockquote>
<p>It’s  vital  to  consider  how  some  bitflags  may  affect  other  bitflags(technically speaking, some bitflags are non-orthogonal). Similarly,if some bitflags are set, certain SAM fields may no longer apply.For  example,  0x4  (unmapped)  is  the  only  reliable  way  to  tell  if  analignment is unaligned. In other words, one cannot tell if a read isaligned  by  looking  at  fields  such  as  mapped  position  (POS  and  ref‐erence  RNAME);  the  SAM  format  specification  does  not  limit  thesefields’ values if a read is unaligned. If the 0x4 bit is set (meaning theread  is  unmapped),  the  fields  regarding  alignment  including  posi‐tion,  CIGAR  string,  mapping  quality,  and  reference  name  are  notrelevant and their values cannot be relied upon. Similarly, if the 0x4bit is set, bits that only apply to mapped reads such as 0x2 (properpair), 0x10 (aligned to reverse strand), and others cannot be reliedupon. The primary lesson is you should carefully consider all flagsthat  may  apply  when  working  with  SAM  entries,  and  start  withlow-level attributes (whether it’s aligned, paired). See the SAM for‐mat specification for more detail on bitflags.</p>
</blockquote>
<p>然后 ，<code>we want to make sure the unmapped (0x4) and proper paired bits are unset(so the read is aligned and paired), and the paired end bit is set (so the read is not in aproper pair). We do this by combining bits:</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools flags paired</span></span><br><span class="line">0x1     1       PAIRED</span><br><span class="line"><span class="meta">$</span><span class="bash"> samtools flags unmap,proper_pair</span></span><br><span class="line">0x6     6       PROPER_PAIR,UNMAP</span><br><span class="line"><span class="meta">$</span><span class="bash"> samtools view -F 6 -f 1 NA12891_CEU_sample.bam | head -n 3</span></span><br><span class="line">SRR003208.1496374       137     1       215623168       0       35M16S  =       215623168    0AAATAGTGCCAATTACGTTTATGGTTGTTATAATGATACTGTTTGTTCTTT     ;/,&gt;);5&lt;;&lt;2+?=,%34??.&lt;&lt;97@&lt;#.&quot;5$4%#&quot;#&quot;&quot;2%%%&quot;#%+&quot;$$&quot;   XC:i:35 XT:A:R  NM:i:1  SM:i:0  AM:i:0  X0:i:2  X1:i:0  XM:i:1  XO:i:0  XG:i:0MD:Z:15A19      RG:Z:SRR003208  OQ:Z:7(&#x27;@&amp;?,84I(&amp;42&amp;%0(55&amp;,.3(4-#&amp;&quot;&#x27;$&amp;%#&quot;#&quot;&quot;&amp;%%%&quot;#%&amp;&quot;$$&quot;</span><br><span class="line">ERR002297.5178166       177     1       215623174       0       36M     =       215582813    -40361   TGCCAATTAAGTTTATGGTTGTTATAATGATACTGT    4:*?4,1;?6:/&lt;0?@==@@=@&gt;@&gt;@?@&gt;@&gt;??A&gt;=    XT:A:RNM:i:0  SM:i:0  AM:i:0  X0:i:2  X1:i:0  XM:i:0  XO:i:0  XG:i:0  MD:Z:36 RG:Z:ERR002297  OQ:Z:3&lt;4&lt;74.&lt;&gt;-&lt;6&lt;/&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">SRR002141.16953736      121     1       215623191       0       7S44M   =       215623191    0GTTTATTGTTGTTATAATGATACTGTTGGTGCTGAACACATGTTTACTAAC     &quot;55%50%%::.&lt;9?&lt;@@=&gt;A=&gt;;?4&lt;=&gt;&lt;&gt;=;&gt;.B@&gt;@?C?:==?@=?BA?   XC:i:44 XT:A:R  NM:i:0  SM:i:0  AM:i:0  X0:i:2  X1:i:0  XM:i:0  XO:i:0  XG:i:0MD:Z:44 RG:Z:SRR002141  OQ:Z:&quot;2/%,(%%:7&amp;:EI:II=+IGIID&#x27;II2-I4II&amp;IIIIIII0IIIIIIIII</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一个检查结果的方式是查看函数。<code> In  this  case,  our  total  number  of  readsthat  are  mapped  and  paired  should  be  equal  to  the  sum  of  the  number  of  reads  thatare  mapped,  paired,  and  properly  paired,  and  the  number  of  reads  that  are  mapped,paired, and not properly paired:</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools view -F 6 NA12891_CEU_sample.bam | wc -l  <span class="comment"># total mapped and paired</span></span></span><br><span class="line">233628</span><br><span class="line"><span class="meta">$</span><span class="bash"> samtools view -F 7 NA12891_CEU_sample.bam | wc -l  <span class="comment"># total mapped, paired,</span></span></span><br><span class="line">201101                                               # proper paired</span><br><span class="line"><span class="meta">$</span><span class="bash"> samtools view -F 6 -f 1 NA12891_CEU_sample.bam | wc -l <span class="comment"># total mapped, paired,</span></span></span><br><span class="line">32527                                                    # and not proper paired</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;201101 + 32527&quot;</span> | bc</span></span><br><span class="line">233628</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="11-3-Visualizing-Alignments-with-samtools-tview-and-the-Integrated-Genomics-Viewer">11.3 Visualizing Alignments with samtools tview and the Integrated Genomics Viewer</h2>
<p><code>samtools tview</code> 要求 sorted 和 indexed BAM 文件。<code>samtools tview</code>  也可以导入参考基因组的序列文件。这里<code>NA12891_CEU_sample.bam </code> 文件的参考基因组为 <code> human_g1k_v37.fasta</code>，这个文件太大了，无法放在GitHub 文件夹下，但是下载方式在 <a href="http://README.md">README.md</a> 文件中（这里我没有下）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools tview NA12891_CEU_sample.bam human_g1k_v37.fasta</span></span><br></pre></td></tr></table></figure>
<p>我们也可以选定特定区域</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools tview -p 1:215906469-215906652 NA12891_CEU_sample.bam human_g1k_v37.fasta</span></span><br></pre></td></tr></table></figure>
<p>如果你需要花更多的时间查看 alignments, variants, insertions/deletions ，你可以用 Integrated Genomic Viewer (IGV)，这是一个图形界面的软件。</p>
<p>图片中带有颜色的字母表示 mismatching bases，可能的原因包括分型错误，比对错误，errors in library preparation, 或者是一个 SNP。</p>
<p>比对错误的原因可能是由于序列相似，共源序列。这种类型的比对错误是假阳性的variant call 的主要原因。还有一个可能的原因是 low-complexity sequence ，比如 <code>GGCGGGGGGGCGGGGGGCGGG</code>。这种如果实际是产生了一个 indel 突变，但是软件一般会判定为一个 SNP。</p>
<p><img src="50.png" alt="45"></p>
<h3 id="11-3-1-Pileups-with-samtools-pileup-Variant-Calling-and-Base-Alignment-Quality">11.3.1 Pileups with samtools pileup, Variant Calling, and Base Alignment Quality</h3>
<p>pileup fromat 是之后call SNP的基础，让我们先看一个简单的流程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools mpileup --no-BAQ --region 1:215906528-215906567  --fasta-ref human_g1k_v37.fasta NA12891_CEU_sample.bam</span></span><br></pre></td></tr></table></figure>
<ul>
<li>–no-BAQ : disable  Base Alignment Quality (BAQ)</li>
</ul>
<p>使用 -v 选项生成 VCF 文件，或者使用 -g 选项生成 BCF 文件，这里默认是生成压缩格式的vcf，可以使用 -u 生成未压缩的vcf格式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools mpileup -v --no-BAQ --region 1:215906528-215906567  --fasta-ref human_g1k_v37.fasta NA12891_CEU_sample.bam &gt; NA12891_CEU_sample.vcf.gz</span></span><br></pre></td></tr></table></figure>
<p>通过 <code>bcftools call</code> ，来推断哪些位点是真的变异，然后每个个体的基因型是什么。</p>
<p>-m 选项采用  multiallelic caller； -v  选项只输出 variant sites</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bcftools call -v -m NA12891_CEU_sample.vcf.gz &gt; NA12891_CEU_sample_calls.vcf.gz</span></span><br></pre></td></tr></table></figure>
<p>生成的结果文件如图</p>
<p><img src="51.png" alt="45"></p>
<p>我们可以看到位点 215,906,548 不再显示为一个SNP，这和IGV的可视化结果一致，因为它有20 reference (G)，只有 4 个 C alleles，很难相信它是一个真实的变异。</p>
<p>除此之外，<code>bcftools call</code> 估计了一个 quality score (即 QUAL 字段)，每个 ALT 基因均有一个 quality score 值。 <code>These  quality  scores  are  Phred-scaled  values </code> 。这个数值越高，说明置信度越高。</p>
<p>如果 ALT 是 <code>.</code> （表示没有变异），那么 quality score 反映这个位点真的有一个变异的可能性。</p>
<p><strong>对于 low-complexity regions 发生的错误比对（通常是由于 indels 解释为 mismatches）是错误的 SNP calls 的主要原因。</strong> 为了避免这一点，samtools mpileup 可以采用 <code> Base Alignment Quality (BAQ)</code> , 来矫正碱基质量，不仅反映不正确的 SNP call, 而且反映 a particular base being misaligned。之前我们没用，现在我们用一下看看，我们发现215,906,547 和 215,906,548 不再视为是SNP了。</p>
<p><img src="52.png" alt="45"></p>
<h2 id="11-4-Creating-Your-Own-SAM-BAM-Processing-Tools-with-Pysam">11.4 Creating Your Own SAM/BAM Processing Tools with Pysam</h2>
<p>在这一部分，我们会学习 Pysam 的基本至少，它是一个应用程序编程接口（通常称为API）.</p>
<p>我们先下载这个包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install pysam</span><br></pre></td></tr></table></figure>
<h3 id="11-4-1-Opening-BAM-Files-Fetching-Alignments-from-a-Region-and-Iterating-Across-Reads">11.4.1 Opening BAM Files, Fetching Alignments from a Region, and Iterating Across Reads</h3>
<p>这里由于是读取二进制文件，采用 “rb”</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>importpysam</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fname = <span class="string">&quot;NA12891_CEU_sample.bam&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bamfile = pysam.AlignmentFile(filename=fname, mode=<span class="string">&quot;rb&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(bamfile)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;pysam.calignmentfile.AlignmentFile&#x27;</span></span><br><span class="line">&gt;&gt;&gt;&gt; <span class="built_in">dir</span>(bamfile)</span><br><span class="line">[<span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, ..., <span class="string">&#x27;close&#x27;</span>, <span class="string">&#x27;count&#x27;</span>, <span class="string">&#x27;fetch&#x27;</span>, <span class="string">&#x27;filename&#x27;</span>,<span class="string">&#x27;getrname&#x27;</span>, <span class="string">&#x27;gettid&#x27;</span>, <span class="string">&#x27;head&#x27;</span>, <span class="string">&#x27;header&#x27;</span>, <span class="string">&#x27;lengths&#x27;</span>, <span class="string">&#x27;mapped&#x27;</span>, <span class="string">&#x27;mate&#x27;</span>,<span class="string">&#x27;next&#x27;</span>, <span class="string">&#x27;nocoordinate&#x27;</span>, <span class="string">&#x27;nreferences&#x27;</span>, <span class="string">&#x27;pileup&#x27;</span>, <span class="string">&#x27;references&#x27;</span>, <span class="string">&#x27;reset&#x27;</span>,<span class="string">&#x27;seek&#x27;</span>, <span class="string">&#x27;tell&#x27;</span>, <span class="string">&#x27;text&#x27;</span>, <span class="string">&#x27;unmapped&#x27;</span>, <span class="string">&#x27;write&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>我们可以采用 <code>pysam.AlignmentFile.fetch() </code> 来提取一个 indexed 的 BAM 文件的区域。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> read <span class="keyword">in</span> bamfile.fetch(<span class="string">&#x27;1&#x27;</span>, start=<span class="number">215906528</span>, end=<span class="number">215906567</span>):</span><br><span class="line"><span class="meta">... </span>  <span class="built_in">print</span>(read.qname, <span class="string">&quot;aligned at position&quot;</span>,read.pos)</span><br><span class="line">...</span><br><span class="line">SRR005672<span class="number">.5788073</span> aligned at position <span class="number">215906479</span></span><br><span class="line">SRR005666<span class="number">.5830972</span> aligned at position <span class="number">215906486</span></span><br><span class="line">ERR002294<span class="number">.5383813</span> aligned at position <span class="number">215906495</span></span><br><span class="line">[...]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们也可以遍历所有的 reads</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bamfile = pysam.AlignmentFile(filename=fname, mode=<span class="string">&quot;rb&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> read <span class="keyword">in</span> bamfile:</span><br><span class="line"><span class="meta">... </span>  status = <span class="string">&quot;unaligned&quot;</span><span class="keyword">if</span> read.is_unmappedelse <span class="string">&quot;aligned&quot;</span></span><br><span class="line"><span class="meta">... </span>  <span class="built_in">print</span>(read.qname, <span class="string">&quot;is&quot;</span>, status)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>遍历一遍之后，如果想再遍历一遍，需要采用reset() 函数（类似于seek()）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bamfile.reset()</span><br></pre></td></tr></table></figure>
<p>文件用完之后需要关闭</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bamfile.close()</span><br></pre></td></tr></table></figure>
<h3 id="11-4-2-Extracting-SAM-BAM-Header-Information-from-an-AlignmentFile-Object">11.4.2 Extracting SAM/BAM Header Information from an AlignmentFile Object</h3>
<p>所有的SAM/BAM文件的表头均存放在一个python 字典中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bamfile.header.keys()</span><br><span class="line">odict_keys([<span class="string">&#x27;HD&#x27;</span>, <span class="string">&#x27;SQ&#x27;</span>, <span class="string">&#x27;RG&#x27;</span>, <span class="string">&#x27;PG&#x27;</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bamfile.header[<span class="string">&#x27;RG&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">&#123;<span class="string">&#x27;ID&#x27;</span>: <span class="string">&#x27;ERR001776&#x27;</span>, <span class="string">&#x27;PL&#x27;</span>: <span class="string">&#x27;ILLUMINA&#x27;</span>, <span class="string">&#x27;LB&#x27;</span>: <span class="string">&#x27;g1k-sc-NA12891-CEU-1&#x27;</span>, <span class="string">&#x27;PI&#x27;</span>: <span class="string">&#x27;200&#x27;</span>, <span class="string">&#x27;DS&#x27;</span>: <span class="string">&#x27;SRP000032&#x27;</span>, <span class="string">&#x27;SM&#x27;</span>: <span class="string">&#x27;NA12891&#x27;</span>, <span class="string">&#x27;CN&#x27;</span>: <span class="string">&#x27;SC&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bamfile.header[<span class="string">&#x27;SQ&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">&#123;<span class="string">&#x27;SN&#x27;</span>: <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;LN&#x27;</span>: <span class="number">249250621</span>, <span class="string">&#x27;AS&#x27;</span>: <span class="string">&#x27;NCBI37&#x27;</span>, <span class="string">&#x27;UR&#x27;</span>: <span class="string">&#x27;file:/lustre/scratch102/projects/g1k/ref/main_project/human_g1k_v37.fasta&#x27;</span>, <span class="string">&#x27;M5&#x27;</span>: <span class="string">&#x27;1b22b98cdeb4a9304cb5d48026a85128&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bamfile.references</span><br><span class="line">(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;13&#x27;</span>, <span class="string">&#x27;14&#x27;</span>, <span class="string">&#x27;15&#x27;</span>, <span class="string">&#x27;16&#x27;</span>, <span class="string">&#x27;17&#x27;</span>, <span class="string">&#x27;18&#x27;</span>, <span class="string">&#x27;19&#x27;</span>, <span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;22&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;MT&#x27;</span>, <span class="string">&#x27;GL000207.1&#x27;</span>, <span class="string">&#x27;GL000226.1&#x27;</span>, <span class="string">&#x27;GL000229.1&#x27;</span>, <span class="string">&#x27;GL000231.1&#x27;</span>, <span class="string">&#x27;GL000210.1&#x27;</span>, <span class="string">&#x27;GL000239.1&#x27;</span>, <span class="string">&#x27;GL000235.1&#x27;</span>, <span class="string">&#x27;GL000201.1&#x27;</span>, <span class="string">&#x27;GL000247.1&#x27;</span>, <span class="string">&#x27;GL000245.1&#x27;</span>, <span class="string">&#x27;GL000197.1&#x27;</span>, <span class="string">&#x27;GL000203.1&#x27;</span>, <span class="string">&#x27;GL000246.1&#x27;</span>, <span class="string">&#x27;GL000249.1&#x27;</span>, <span class="string">&#x27;GL000196.1&#x27;</span>, <span class="string">&#x27;GL000248.1&#x27;</span>, <span class="string">&#x27;GL000244.1&#x27;</span>, <span class="string">&#x27;GL000238.1&#x27;</span>, <span class="string">&#x27;GL000202.1&#x27;</span>, <span class="string">&#x27;GL000234.1&#x27;</span>, <span class="string">&#x27;GL000232.1&#x27;</span>, <span class="string">&#x27;GL000206.1&#x27;</span>, <span class="string">&#x27;GL000240.1&#x27;</span>, <span class="string">&#x27;GL000236.1&#x27;</span>, <span class="string">&#x27;GL000241.1&#x27;</span>, <span class="string">&#x27;GL000243.1&#x27;</span>, <span class="string">&#x27;GL000242.1&#x27;</span>, <span class="string">&#x27;GL000230.1&#x27;</span>, <span class="string">&#x27;GL000237.1&#x27;</span>, <span class="string">&#x27;GL000233.1&#x27;</span>, <span class="string">&#x27;GL000204.1&#x27;</span>, <span class="string">&#x27;GL000198.1&#x27;</span>, <span class="string">&#x27;GL000208.1&#x27;</span>, <span class="string">&#x27;GL000191.1&#x27;</span>, <span class="string">&#x27;GL000227.1&#x27;</span>, <span class="string">&#x27;GL000228.1&#x27;</span>, <span class="string">&#x27;GL000214.1&#x27;</span>, <span class="string">&#x27;GL000221.1&#x27;</span>, <span class="string">&#x27;GL000209.1&#x27;</span>, <span class="string">&#x27;GL000218.1&#x27;</span>, <span class="string">&#x27;GL000220.1&#x27;</span>, <span class="string">&#x27;GL000213.1&#x27;</span>, <span class="string">&#x27;GL000211.1&#x27;</span>, <span class="string">&#x27;GL000199.1&#x27;</span>, <span class="string">&#x27;GL000217.1&#x27;</span>, <span class="string">&#x27;GL000216.1&#x27;</span>, <span class="string">&#x27;GL000215.1&#x27;</span>, <span class="string">&#x27;GL000205.1&#x27;</span>, <span class="string">&#x27;GL000219.1&#x27;</span>, <span class="string">&#x27;GL000224.1&#x27;</span>, <span class="string">&#x27;GL000223.1&#x27;</span>, <span class="string">&#x27;GL000195.1&#x27;</span>, <span class="string">&#x27;GL000212.1&#x27;</span>, <span class="string">&#x27;GL000222.1&#x27;</span>, <span class="string">&#x27;GL000200.1&#x27;</span>, <span class="string">&#x27;GL000193.1&#x27;</span>, <span class="string">&#x27;GL000194.1&#x27;</span>, <span class="string">&#x27;GL000225.1&#x27;</span>, <span class="string">&#x27;GL000192.1&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bamfile.lengths</span><br><span class="line">(<span class="number">249250621</span>, <span class="number">243199373</span>, <span class="number">198022430</span>, <span class="number">191154276</span>, <span class="number">180915260</span>, <span class="number">171115067</span>, <span class="number">159138663</span>, <span class="number">146364022</span>, <span class="number">141213431</span>, <span class="number">135534747</span>, <span class="number">135006516</span>, <span class="number">133851895</span>, <span class="number">115169878</span>, <span class="number">107349540</span>, <span class="number">102531392</span>, <span class="number">90354753</span>, <span class="number">81195210</span>, <span class="number">78077248</span>, <span class="number">59128983</span>, <span class="number">63025520</span>, <span class="number">48129895</span>, <span class="number">51304566</span>, <span class="number">155270560</span>, <span class="number">59373566</span>, <span class="number">16569</span>, <span class="number">4262</span>, <span class="number">15008</span>, <span class="number">19913</span>, <span class="number">27386</span>, <span class="number">27682</span>, <span class="number">33824</span>, <span class="number">34474</span>, <span class="number">36148</span>, <span class="number">36422</span>, <span class="number">36651</span>, <span class="number">37175</span>, <span class="number">37498</span>, <span class="number">38154</span>, <span class="number">38502</span>, <span class="number">38914</span>, <span class="number">39786</span>, <span class="number">39929</span>, <span class="number">39939</span>, <span class="number">40103</span>, <span class="number">40531</span>, <span class="number">40652</span>, <span class="number">41001</span>, <span class="number">41933</span>, <span class="number">41934</span>, <span class="number">42152</span>, <span class="number">43341</span>, <span class="number">43523</span>, <span class="number">43691</span>, <span class="number">45867</span>, <span class="number">45941</span>, <span class="number">81310</span>, <span class="number">90085</span>, <span class="number">92689</span>, <span class="number">106433</span>, <span class="number">128374</span>, <span class="number">129120</span>, <span class="number">137718</span>, <span class="number">155397</span>, <span class="number">159169</span>, <span class="number">161147</span>, <span class="number">161802</span>, <span class="number">164239</span>, <span class="number">166566</span>, <span class="number">169874</span>, <span class="number">172149</span>, <span class="number">172294</span>, <span class="number">172545</span>, <span class="number">174588</span>, <span class="number">179198</span>, <span class="number">179693</span>, <span class="number">180455</span>, <span class="number">182896</span>, <span class="number">186858</span>, <span class="number">186861</span>, <span class="number">187035</span>, <span class="number">189789</span>, <span class="number">191469</span>, <span class="number">211173</span>, <span class="number">547496</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>后面都没看</p>
<h3 id="11-4-3-Working-with-AlignedSegment-Objects">11.4.3 Working with AlignedSegment Objects</h3>
<h3 id="11-4-4-Writing-a-Program-to-Record-Alignment-Statistics">11.4.4 Writing a Program to Record Alignment Statistics</h3>
<h3 id="11-4-5-Additional-Pysam-Features-and-Other-SAM-BAM-APIs">11.4.5 Additional Pysam Features and Other SAM/BAM APIs</h3>
<h1>12 Bioinformatics Shell Scripting, WritingPipelines, and Parallelizing Tasks</h1>
<h2 id="12-1-Basic-Bash-Scripting">12.1 Basic Bash Scripting</h2>
<h3 id="12-1-1-Writing-and-Running-Robust-Bash-Scripts">12.1.1 Writing and Running Robust Bash Scripts</h3>
<p>每次你写 bash 脚本时，你都需要使用下面的脚本表头，让你的程序更稳健。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">set -e</span><br><span class="line">set -u</span><br><span class="line">set -o pipefail</span><br></pre></td></tr></table></figure>
<p>第一行指定解释器（shebang）</p>
<blockquote>
<h1>Shebang[[编辑](<a href="https://zh.wikipedia.org/w/index.php?title=Shebang&amp;action=edit&amp;section=0&amp;summary=/*">https://zh.wikipedia.org/w/index.php?title=Shebang&amp;action=edit&amp;section=0&amp;summary=/*</a> top */ )]</h1>
<p>维基百科，自由的百科全书</p>
<p><a href="https://zh.wikipedia.org/wiki/Shebang#mw-head">跳到导航</a><a href="https://zh.wikipedia.org/wiki/Shebang#searchInput">跳到搜索</a></p>
<p>在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97">计算</a>领域中，<strong>Shebang</strong>（也称为<strong>Hashbang</strong>）是一个由<a href="https://zh.wikipedia.org/wiki/%E4%BA%95%E8%99%9F">井号</a>和<a href="https://zh.wikipedia.org/wiki/%E5%8F%B9%E5%8F%B7">叹号</a>构成的字符序列*<code>#!</code>*，其出现在文本文件的第一行的前两个字符。 在文件中存在Shebang的情况下，<a href="https://zh.wikipedia.org/wiki/%E7%B1%BBUnix%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">类Unix操作系统</a>的<a href="https://zh.wikipedia.org/w/index.php?title=%E7%A8%8B%E5%BA%8F%E8%BD%BD%E5%85%A5%E5%99%A8&amp;action=edit&amp;redlink=1">程序载入器</a>会分析Shebang后的内容，将这些内容作为解释器指令，并调用该指令，并将载有Shebang的文件路径作为该解释器的参数[<a href="https://zh.wikipedia.org/wiki/Shebang#cite_note-absg_shabang-1">1]</a>[<a href="https://zh.wikipedia.org/wiki/Shebang#cite_note-2">2]</a>。</p>
<p>例如，以指令<code>#!/bin/sh</code>开头的文件在执行时会实际调用*/bin/sh*程序（通常是<a href="https://zh.wikipedia.org/wiki/Bourne_shell">Bourne shell</a>或兼容的<a href="https://zh.wikipedia.org/wiki/Unix_shell">shell</a>，例如<a href="https://zh.wikipedia.org/wiki/Bash">bash</a>、<a href="https://zh.wikipedia.org/wiki/Debian_Almquist_shell">dash</a>等）来执行。这行内容也是<a href="https://zh.wikipedia.org/wiki/Shell%E8%84%9A%E6%9C%AC">shell脚本</a>的标准起始行。</p>
</blockquote>
<p>第二行：默认情况下，一个shell 脚本如果报错（exit status 不为0），不会导致整个shell脚本退出（?）, shell 脚本会继续执行下一行命令。这不是我们想要的运行方式，我们通常都想看到 errors to be loud and noticeable. <code>set -e</code> 阻止了这一做法，如果脚本中的任何命令退出码不为0，整个脚本的运行便会中止。但是，有些时候退出码不为0，并不表示报错，而是 false。比如使用 <code>test -d file.txt</code> 来判断是否为文件夹，就会返回一个非0的退出码（非文件夹），但是这并不是一个错误。因此，<code>set -e</code> 会忽视在 if 的条件语句中的非0的退出码。同样地，<code>set -e</code> 会忽视Unix 管道命令中除了最后一个管道之外的所有退出状态。</p>
<p>第三行：<code>set -u</code> 修改了另一个默认行为： 包含对<strong>未设置的变量名称的引用</strong>的任何命令仍将运行。举一个可怕的例子，假设有个命令：<code>rm -rf $TEMP_DIR/*</code> ，如果 $TEMP_DIR 没有设置，BASH 会实际会执行下列语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf &#x2F;*</span><br></pre></td></tr></table></figure>
<p>通过 <code>set -u</code>  来阻止这种类型的错误。如果变量名未设置，这条命令不会执行。</p>
<p>第四行：前面提到了 <code>set -e</code>  有一些例外情况，其中一种情况就是如果在一个 Unix pipe 中没有运行成功，除非错误出现在最后一个命令，不然 <code>set -e</code>  不会让程序中止。 通过添加 <code>set -o pipefail</code> 可以阻止这种行为 - <strong>在管道命令中的任何一个命令返回一个非0的退出码，都会导致整个pipe 返回一个非0的退出码</strong>。再加上 <code>set -e</code> 选项，就会让这个shell 脚本运行中止。</p>
<p>上面这三个选项时避免 Bash scripts 出现 silent errors 和 unsafe behavior 的第一层防护。<strong>不幸的是，Bash 是一个脆弱的语言</strong>。我们需要注意一些其他事项才能使得它能够安全运行。</p>
<h3 id="12-1-2-Variables-and-Command-Arguments">12.1.2 Variables and Command Arguments</h3>
<p>引用变量：最规范的是第三种</p>
<ol>
<li>使用 <code>$&#123;&#125;</code> 确定变量边界</li>
<li>整个引用外层使用引号，避免因为中间出现空格或其他特殊字符，导致出错。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir $sample_aln/</span><br><span class="line">mkdir $&#123;sample&#125;_aln/</span><br><span class="line">mkdir &quot;$&#123;sample&#125;_aln/&quot;</span><br></pre></td></tr></table></figure>
<h3 id="12-1-3-Conditionals-in-a-Bash-Script-if-Statements">12.1.3 Conditionals in a Bash Script: if Statements</h3>
<p>shell 中的 if 语句和其他语言不同的地方在于：shell 中判断是看<strong>退出码</strong>，退出码为0运行then之后的语句，退出码是其他值则运行else之后的值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [commands]</span><br><span class="line">then</span><br><span class="line">	do sth</span><br><span class="line">else</span><br><span class="line">	do sth</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>举个简单的例子，假如我们想看一个文件中是否包含某字符串。由于 grep 函数如果匹配到了会 return 0；如果没有匹配到会 return 1。我们就可以这么写</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if grep &quot;pattern&quot; some_file.txt &gt; /dev/null</span><br><span class="line">then </span><br><span class="line">	echo &quot;found &#x27;pattern&#x27; in &#x27;some_file.txt&#x27;&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>if 做判断时可以使用 <strong><code>&amp;&amp;</code></strong> (and) 和 <strong><code>||</code></strong>(not) ，例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if grep &quot;pattern&quot; file_1.txt &gt; /dev/null &amp;&amp;</span><br><span class="line">   grep &quot;pattern&quot; file_2.txt &gt; /dev/null</span><br><span class="line">then </span><br><span class="line">	echo &quot;found &#x27;pattern&#x27; in &#x27;file_1.txt&#x27; and &#x27;file_2.txt&#x27; &quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>还有 <strong>！</strong> （取反）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if ! grep &quot;pattern&quot; some_file.txt &gt; /dev/null</span><br><span class="line">then </span><br><span class="line">	echo &quot;did not found &#x27;pattern&#x27; in &#x27;some_file.txt&#x27;&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>if 语句也可以使用 pipeline，但是这取决于你用不用<code>set -o pipefail</code> 。如果你设置了 pipefail ，那么pipe 中任何一个命令的退出码非0，就会跳过这个 if statement ，直接运行 else 的语句（如果有的话）。但是你如果没有设置 pipeline，那么只会看最后一个命令的退出码。设置pipefail 是更加合理的。</p>
<p>最后，我们来看 <strong>test</strong> 命令。test 命令用于检查某个条件是否成立，同样返回 0和1。</p>
<p>test 支持三种比较，<strong>字符串</strong>、<strong>整数</strong>（浮点数没法弄）、<strong>文件和文件夹</strong>。具体见shell 编程。</p>
<p>注意 shell 编程有一点错了或者不规范，shell 编程里是不能用**&gt;<strong>这种符号来比较数字或字符串的，因为和</strong>重定向符合重复了**。</p>
<p>test 语句可以写成 <strong>[ “$#” -ne 1 ]<strong>这种格式，但是注意</strong>[ 后 ] 前必须有一个空格</strong>。</p>
<p>test 语句 支持 -a -o ! （and,or,or）来连接多个条件，但是我觉得不如使用多个test 语句，然后用 &amp;&amp; || ! 连接更清晰，用书上的例子，可以改写一下（可读性明显增加了）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ &quot;$#&quot; -ne 1 -o ! -r &quot;$1&quot; ]</span><br><span class="line">if [ &quot;$#&quot; -ne 1 ] || [ ! -r &quot;$1&quot; ]</span><br></pre></td></tr></table></figure>
<h3 id="12-1-4-Processing-Files-with-Bash-Using-for-Loops-and-Globbing">12.1.4 Processing Files with Bash Using for Loops and Globbing</h3>
<p>在很多生信分析中，数据可以会切分成多个文件。因此需要使用 for 循环遍历所有的文件。遍历过程分为三步：</p>
<ol>
<li>挑选哪些文件需要处理</li>
<li>对需要处理的文件应用同一套命令</li>
<li>按照输入文件名称命名输出文件。</li>
</ol>
<p>让我们先看第一步，挑选需要处理的文件。假设存在一个包含了文件基础信息的文件(samples.txt)，包括样本名，链名和文件路径。如下</p>
<p>前两列又称之为 <em>metadata</em> (<strong>data about data</strong>，这个data about data有意思) ，包含了文件的重要信息。我们这里注意到文件的文件名也包含了 metadata，这对我们提取文件很有用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat samples.txt</span></span><br><span class="line">zmaysA  R1      seq/zmaysA_R1.fastq</span><br><span class="line">zmaysA  R2      seq/zmaysA_R2.fastq</span><br><span class="line">zmaysB  R1      seq/zmaysB_R1.fastq</span><br><span class="line">zmaysB  R2      seq/zmaysB_R2.fastq</span><br><span class="line">zmaysC  R1      seq/zmaysC_R1.fastq</span><br><span class="line">zmaysC  R2      seq/zmaysC_R2.fastq</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假如说我们先收集每个文件的 quality statistics （使用假想的程序 fastq_stat），然后将这些信息保存到一个输出文件中。这里我们用到了 Bash 中的<strong>数组</strong>，<strong>basename</strong>。</p>
<p>首先，我们先将文件名导入到一个数组中，用于后面的循环。手动创建如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sample_names=(zmaysA zmaysB zmaysC)</span></span><br></pre></td></tr></table></figure>
<p>可以通过索引提取（0-indexed）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;sample_names[0]&#125;</span></span></span><br><span class="line">zmaysA</span><br></pre></td></tr></table></figure>
<p>提取所有元素</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;sample_names[@]&#125;</span></span></span><br><span class="line">zmaysA zmaysB zmaysC</span><br></pre></td></tr></table></figure>
<p>查看元素个数，每个元素的索引</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;#sample_names[@]&#125;</span></span></span><br><span class="line">3</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;!sample_names[@]&#125;</span></span></span><br><span class="line">0 1 2</span><br></pre></td></tr></table></figure>
<p>但是，手动创建数组是无聊而又任意出错的工作，特别使当我们已经有了一个文件。我们可以通过 shell 的 <em>command substitution</em> 来创建数组（这么做存在风险）。</p>
<p>我们可以用 cut -f 3 来提取文件名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sample_files=($(cut -f 3 samples.txt))</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;sample_files[@]&#125;</span></span></span><br><span class="line">seq/zmaysA_R1.fastq seq/zmaysA_R2.fastq seq/zmaysB_R1.fastq seq/zmaysB_R2.fastq seq/zmaysC_R1.fastq seq/zmaysC_R2.fastq</span><br></pre></td></tr></table></figure>
<p>这么做的前提是你事先确保你的文件名是<strong>规范的</strong> — 只有字母、数字、<code>_</code>  和 <code>-</code> 构成。如果在文件名中存在空格，制表符，换行符，又或者类似<code>*</code>的特殊字符，上面这种做法会出错。</p>
<p><strong>The Internal Field Separator, Word Splitting, and Filenames</strong></p>
<p>当我们通过 <em>command substitution</em> 来创建数组时，Bash 采用 <em>word spliting</em> 来分割出字段作为数组的元素，使用的规则是 <em>Internal Field Separator</em> (IFS) 。IFS 的值存储在 IFS 变量中，默认为<strong>空格、制表位和换行符</strong>。你可以这么查看 IFS 的值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">printf</span> %q <span class="string">&quot;<span class="variable">$IFS</span>&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="string">&#x27; \t\n&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>由于空格包含在IFS中，因此如果文件名包含空格，它会被切分为两部分。</p>
<p>获取了文件名之后，我们需要去除路径和后缀，只提取基本的文件名，用于命名结果文件。我们可以使用 basename 命令来完成这一步</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> basename seqs/zmaysA_R1.fastq</span></span><br><span class="line">zmaysA_R1.fastq</span><br></pre></td></tr></table></figure>
<p>可以进一步剔除后缀</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> basename seqs/zmaysA_R1.fastq .fastq</span></span><br><span class="line">zmaysA_R1</span><br><span class="line"><span class="meta">$</span><span class="bash"> basename -s .fastq seqs/zmaysA_R1.fastq</span></span><br><span class="line">zmaysA_R1</span><br></pre></td></tr></table></figure>
<p>现在，所有的步骤均已完备，可以搭建流程了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">set -e</span><br><span class="line">set -u</span><br><span class="line">set -o pipefail</span><br><span class="line"><span class="meta">#</span><span class="bash"> specify the input samples file, <span class="built_in">where</span> the third</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> column is the path to each sample FASTQ file</span></span><br><span class="line">sample_info=samples.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> create a Bash array from the third column of <span class="variable">$sample_info</span></span></span><br><span class="line">sample_files=($(cut -f 3 &quot;$sample_info&quot;))</span><br><span class="line"> </span><br><span class="line">for fastq_file in $&#123;sample_files[@]&#125;</span><br><span class="line">do</span><br><span class="line">    # strip .fastq from each FASTQ file, and add suffix</span><br><span class="line">    # &quot;-stats.txt&quot; to create an output filename for each FASTQ file    </span><br><span class="line">    results_file=&quot;$(basename $fastq_file .fastq)-stats.txt&quot;</span><br><span class="line">    # run fastq_stat on a file, writing results to the filename we&#x27;ve</span><br><span class="line">    # above    </span><br><span class="line">    fastq_stat $fastq_file &gt; stats/$results_file</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>上面这个流程是一个简单的流程，但是在生信分析中，我们经常需要合并两个或多个输入文件的信息，生成一个输出文件。比对的reads数据就是一个例子：很多软件要求输入两个 FASTQ 文件，最终返回一个 alignment 文件。当我们进行比对时，我们不能像上面那样循环。相反，每个样本是一个处理单元（?）。我们的比对步骤要求输入一个样本的两个 FASTQ 文件，然后返回这个样本的一个alignment 文件。因此，我们需要通过唯一的文件名进行迭代，然后利用文件名来 re-create 输入的 FASTQ 文件。</p>
<p>我们用个例子来说明：假设我们使用比对软件 BWA ，并且我们的参考基因组是 zmays_AGPv3.20.fa</p>
<p><img src="53.png" alt="53"></p>
<p>很多时候，直接对文件进行循环可能更加方便。</p>
<p>下面这个例子是简单地查找 fastq 文件中有多少条记录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">set -e</span><br><span class="line">set -u</span><br><span class="line">set -o pipefail</span><br><span class="line"></span><br><span class="line">for file in *.fastq</span><br><span class="line">do</span><br><span class="line">	echo &quot;$file: &quot; $(bioawk -c fastx &#x27;END &#123;print NR&#125;&#x27; $file)</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>Bash 的循环可以很方便地遍历多个文件，但是存在一些缺点。首先相比于上面那种方式，使用find命令更加强大。然后，Bash 的循环命令无法 parallelize 。下一节我们会看到更加强大的文件处理命令。</p>
<h2 id="12-2-Automating-File-Processing-with-find-and-xargs">12.2 Automating File-Processing with find and xargs</h2>
<p>find 和 xargs 组合使用，能够创建强大的Unix-based 文件处理流程。</p>
<h3 id="12-2-1-Using-find-and-xargs">12.2.1 Using find and xargs</h3>
<p>我们先举个例子，假设你有个程序 process_fq 可以从标准输入接收多个文件名并进行处理。如果你想对所有后缀为 .fq 的文件进行处理，你可能会这样运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls *.fq</span></span><br><span class="line">treatment-01.fq treatment 02.fq treatment-03.fq</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls *.fq | process_fq</span></span><br></pre></td></tr></table></figure>
<p>这里使用了 ls 和 通配符来实现，但是这个方案是很脆弱的。假设你存在一个文件 treatment 02.fq 。在这种情况下，由于每个文件名之间是通过空格分隔的，因此这个文件名就会切分成两部分，导致程序报错。</p>
<p>如果你直接用 file globbing 作为参数，上面的这种情况不会发生，它会自动会忽略 reatment  02.fq 中的空格（? 没搞懂）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> process_fq *.fq</span></span><br></pre></td></tr></table></figure>
<p>那为什么不用这种方式呢？因为这种方式对文件数目有限制。举例，假如你在 tmp/ 目录下存在成千上万个文件，你想先把这个目录下的所有文件删除，你可以会采用下述命令，但是会面临报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm tmp/*</span></span><br><span class="line">/bin/rm: cannot execute [Argument list too long]</span><br></pre></td></tr></table></figure>
<p>新手经常会面临上面这个文件。解决办法就是利用 find 和 xargs</p>
<h3 id="12-2-2-Finding-Files-with-find">12.2.2 Finding Files with find</h3>
<p>不像 ls，find 命令是递归的（它会遍历当前目录的子目录，子目录的子目录……）。如果你有多层目录嵌套的话，find 命令尤其有用。</p>
<p>事实上，对一个目录简单地采用 find 命令（不加任何参数）是参看<strong>目录结构</strong>的一个快捷方式。 例如</p>
<p><img src="54.png" alt="53"></p>
<p>通过 -maxdepth 可以限制目录深度，比如你只想查找当前目录下的所有文件，使用 <code>-maxdepth 1</code>。</p>
<p>find 的 基本语法是 <code>find path expression</code> 。这里 path 指 find 用于查找的文件夹。</p>
<p>最简单的就是 -name，下面的命令和 <code>ls zmaysB*fastq</code> 结果一样，区别在于find的结果每个文件占一行，而且find命令是递归的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find data/seqs -name <span class="string">&quot;zmaysB*fastq&quot;</span></span></span><br><span class="line">data/seqs/zmaysB_R1.fastq</span><br><span class="line">data/seqs/zmaysB_R2.fastq</span><br></pre></td></tr></table></figure>
<h3 id="12-2-3-find’s-Expressions">12.2.3 find’s Expressions</h3>
<p>在上面的例子中，文件夹也可能会匹配上。因为我们只想返回 FASTQ 文件，我们可能需要通过 -type 来限制结果的类型（常用类型 f : 文件 d : 目录 l : 链接）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find data/seqs -name <span class="string">&quot;zmaysB*fastq&quot;</span> -<span class="built_in">type</span> f</span></span><br><span class="line">data/seqs/zmaysB_R1.fastq</span><br><span class="line">data/seqs/zmaysB_R2.fastq</span><br></pre></td></tr></table></figure>
<p>默认情况下，find 会通过 AND 逻辑来连接不同的expression，也就是说上面的例子找出的结果是既符合&quot;zmaysB*fastq&quot; 又是文件。上面的例子等同于</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find data/seqs -name <span class="string">&quot;zmaysB*fastq&quot;</span> -and -<span class="built_in">type</span> f</span></span><br><span class="line">data/seqs/zmaysB_R1.fastq</span><br><span class="line">data/seqs/zmaysB_R2.fastq</span><br></pre></td></tr></table></figure>
<p>我们可能想要找到样本A 或 样本C 的所有的FASTQ文件。在这个例子中，我们可能得用 -or 选项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find data/seqs -name <span class="string">&quot;zmaysA*fastq&quot;</span> -or -name <span class="string">&quot;zmaysC*fastq&quot;</span> -<span class="built_in">type</span> f</span></span><br><span class="line">data/seqs/zmaysA_R1.fastq</span><br><span class="line">data/seqs/zmaysA_R2.fastq</span><br><span class="line">data/seqs/zmaysC_R1.fastq</span><br><span class="line">data/seqs/zmaysC_R2.fastq</span><br></pre></td></tr></table></figure>
<p>还有一个操作就是<strong>取反</strong>：比如提取除了样本C之外的 FASTQ 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find seqs -<span class="built_in">type</span> f <span class="string">&quot;!&quot;</span> -name <span class="string">&quot;zmaysC*fastq&quot;</span></span></span><br><span class="line">seqs/zmaysA_R1.fastq</span><br><span class="line">seqs/zmaysA_R2.fastq</span><br><span class="line">seqs/zmaysB_R1.fastq</span><br><span class="line">seqs/zmaysB_R2.fastq</span><br></pre></td></tr></table></figure>
<p>让我们看一个更高级的例子：假如你有一个messy的同事，创建一个名为zmaysB_R1-temp.fastq 的文件，然后你通过 find 发现了这个文件</p>
<p><img src="55.png" alt="53"></p>
<p>你不想删除或者重命名这个文件，因为你的同事可能需要用到这个文件。因此，最好的办法就是改变你的 find命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find seqs -<span class="built_in">type</span> f <span class="string">&quot;!&quot;</span> -name <span class="string">&quot;zmaysC*fastq&quot;</span> -and <span class="string">&quot;!&quot;</span> -name <span class="string">&quot;*-temp*&quot;</span></span></span><br><span class="line">seqs/zmaysA_R1.fastq</span><br><span class="line">seqs/zmaysA_R2.fastq</span><br><span class="line">seqs/zmaysB_R1.fastq</span><br><span class="line">seqs/zmaysB_R2.fastq</span><br></pre></td></tr></table></figure>
<p>注意到在find中，<strong>!</strong> 和 括号必须用引号。</p>
<h3 id="12-2-4-find’s-exec-Running-Commands-on-find’s-Results">12.2.4 find’s -exec: Running Commands on find’s Results</h3>
<p>我们通过 find 来定位文件，通常都是需要对文件进行处理。这一步也可以通过 -exec 选项来实现。</p>
<p>让我们通过一个简单的例子来理解 -exec 如何工作。继续之前的例子，假设一个 messy 的同事创建很多的临时文件。我们试着模拟一下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch zmays&#123;A,C&#125;_R&#123;1,2&#125;-temp.fastq</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">zmaysA_R1.fastq       zmaysA_R2_temp.fastq  zmaysB_R2.fastq       zmaysC_R1_temp.fastq</span><br><span class="line">zmaysA_R1_temp.fastq  zmaysB_R1.fastq       zmaysB_R2_temp.fastq  zmaysC_R2.fastq</span><br><span class="line">zmaysA_R2.fastq       zmaysB_R1_temp.fastq  zmaysC_R1.fastq       zmaysC_R2_temp.fastq</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设你的同事允许你删除这些临时文件。一种方式是 <code>rm *-temp.fastq</code>，但是在重要的文件夹中使用通配符来删除文件风险很大。如果你一不小心在 <code>*</code>和 -temp.fastq 之间放了一个空格，由于使用通配符<code>*</code> ，这个文件夹的所有文件均会被删除（可怕）。</p>
<p>我们通过 find 的 -exec 命令更加安全。如果使用 -exec 命令，那么在命令结束的部分添加一个分号是必需的。比如，我们这里我们可以用 find -exec 和 <code>rm -i</code> 来删除中间文件。 <code>rm -i</code> 表示 interactive 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;*_temp.fastq&quot;</span> -<span class="built_in">exec</span> rm -i &#123;&#125; \;</span></span><br><span class="line">rm: remove regular empty file ‘./zmaysA_R1_temp.fastq’? y</span><br><span class="line">rm: remove regular empty file ‘./zmaysA_R2_temp.fastq’? y</span><br><span class="line">rm: remove regular empty file ‘./zmaysC_R1_temp.fastq’? y</span><br><span class="line">rm: remove regular empty file ‘./zmaysC_R2_temp.fastq’? y</span><br><span class="line">rm: remove regular empty file ‘./zmaysB_R1_temp.fastq’? y</span><br><span class="line">rm: remove regular empty file ‘./zmaysB_R2_temp.fastq’? y</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通常而言，-exec 选项只用于简单的命令，比如删除文件，更改权限等。对于复杂的任务，xargs 是更好的选择。</p>
<h3 id="12-2-5-xargs-A-Unix-Powertool">12.2.5 xargs: A Unix Powertool</h3>
<p><code>xargs</code> 从标准输入中获取值（以<strong>空格，制表符或换行符</strong>分隔），然后将其作为下一个程序的参数。</p>
<p>让我们重建上面的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch zmays&#123;A,C&#125;_R&#123;1,2&#125;-temp.fastq</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">zmaysA_R1.fastq       zmaysA_R2.fastq       zmaysB_R1.fastq  zmaysC_R1.fastq       zmaysC_R2.fastq</span><br><span class="line">zmaysA_R1-temp.fastq  zmaysA_R2-temp.fastq  zmaysB_R2.fastq  zmaysC_R1-temp.fastq  zmaysC_R2-temp.fastq</span><br></pre></td></tr></table></figure>
<p>这里我们可以模拟上面删除文件的操作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;*-temp.fastq&quot;</span></span></span><br><span class="line">./zmaysA_R1-temp.fastq</span><br><span class="line">./zmaysA_R2-temp.fastq</span><br><span class="line">./zmaysC_R1-temp.fastq</span><br><span class="line">./zmaysC_R2-temp.fastq</span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;*-temp.fastq&quot;</span> | xargs rm</span></span><br></pre></td></tr></table></figure>
<p>我测试了一下，这里 rm 不能用 -i 选项（提示了信息，但是不能互动，结果也没有删除文件）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;*-temp.fastq&quot;</span> | xargs rm -i</span></span><br><span class="line">rm: remove regular empty file ‘./zmaysA_R1-temp.fastq’? rm: remove regular empty file ‘./zmaysA_R2-temp.fastq’? rm: remove regular empty file ‘./zmaysC_R1-temp.fastq’? rm: remove regular empty file ‘./zmaysC_R2-temp.fastq’? </span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">zmaysA_R1.fastq       zmaysA_R2.fastq       zmaysB_R1.fastq  zmaysC_R1.fastq       zmaysC_R2.fastq</span><br><span class="line">zmaysA_R1-temp.fastq  zmaysA_R2-temp.fastq  zmaysB_R2.fastq  zmaysC_R1-temp.fastq  zmaysC_R2-temp.fastq</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实际上，后面的 xargs 选项是将find找到的所有文件切分为参数，然后执行下面命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm ./zmaysA_R1-temp.fastq ./zmaysA_R2-temp.fa ./zmaysC_R1-temp.fastq ./zmaysC_R2-temp.fa</span></span><br></pre></td></tr></table></figure>
<p>像这种将所有文件直接当成n个参数传给后面的命令，适合像rm, touch, mkdir 这种可以处理多个参数的命令。</p>
<p>但是，很多命令一次只能接受一个参数。我们可以通过 xargs 的 -n 选项来设置一次传递几个参数。例如，我们可以运行 rm 命令 4 次（一个文件一次），命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;*-temp.fastq&quot;</span> | xargs -n 1 rm</span></span><br></pre></td></tr></table></figure>
<p>如果我们想在删除文件前，查看find 找到的文件名。我们可以这么写：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;*-temp.fastq&quot;</span> &gt; files-to-delete.tx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat files-to-delete.tx</span></span><br><span class="line">./zmaysA_R1-temp.fastq</span><br><span class="line">./zmaysA_R2-temp.fastq</span><br><span class="line">./zmaysC_R1-temp.fastq</span><br><span class="line">./zmaysC_R2-temp.fastq</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat files-to-delete.txt | xargs rm</span></span><br></pre></td></tr></table></figure>
<p>另一个使用 xargs 的技巧在于将最终用到的命令行写入一个Bash 脚本中。比如上面的例子中，我们我们使用 echo 命令。例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;*-temp.fastq&quot;</span> | xargs -n 1 <span class="built_in">echo</span> <span class="string">&quot;rm -i&quot;</span> &gt; delete-temp.s</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat delete-temp.s</span></span><br><span class="line">rm -i ./zmaysA_R1-temp.fastq</span><br><span class="line">rm -i ./zmaysA_R2-temp.fastq</span><br><span class="line">rm -i ./zmaysC_R1-temp.fastq</span><br><span class="line">rm -i ./zmaysC_R2-temp.fastq</span><br></pre></td></tr></table></figure>
<p>这种方式让我们可以互动式地删除文件（之前试过了直接用xargs不行），我们可以运行上面生产的脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bash delete-temp.sh</span></span><br><span class="line">remove ./zmaysA_R1-temp.fastq? y</span><br><span class="line">remove ./zmaysA_R2-temp.fastq? y</span><br><span class="line">remove ./zmaysC_R1-temp.fastq? y</span><br><span class="line">remove ./zmaysC_R2-temp.fastq? y</span><br></pre></td></tr></table></figure>
<h4 id="playing-it-safe-with-find-and-xargs">playing it safe with find and xargs</h4>
<p>由于xargs 也会将空格视为分隔符，因此如果<strong>文件名中包含空格</strong>，这个文件名就会被xargs视为两个文件，造成错误。</p>
<p>避免办法：</p>
<ol>
<li>文件命名一定要规范</li>
<li>find 可以通过 -print0 选项，配合 xargs 的 -0 选项，使得文件之间不再以换行符隔开，而是以<strong>空字符</strong>隔开，这样即便文件名不规范，也可以正常运行</li>
</ol>
<blockquote>
<p>-print0<br>
True; print the full file name on the standard output, followed by a null character (instead of the newline character that -print uses).  This allows file names that contain newlines or other types of white space to be correctly interpreted by programs that process the find output.  This option corresponds to the -0 option of xargs.</p>
</blockquote>
<p>例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;samples [AB].txt&quot;</span> -print0 | xargs -0 r</span></span><br></pre></td></tr></table></figure>
<p>作者建议所有的 find - xargs 都加上这两个选项，我倒觉得没必要，文件名就应该规范，报错并不是坏事。</p>
<h3 id="12-2-6-Using-xargs-with-Replacement-Strings-to-Apply-Commands-to-Files">12.2.6 Using xargs with Replacement Strings to Apply Commands to Files</h3>
<p>有些软件通过选项来传参，类似于 <code>program --in file.txt --out-file out.txt</code>；其他一些软件可能通过位置参数来传参，类似于 <code>program arg1 arg2</code> 。xargs 的 <code>-I</code> 选项可以实现这一点，默认使用 {} 代替参数，但是注意<strong>只能传入一个参数</strong>。</p>
<p>让我们先看一个例子，假设我们有一个假想的程序 fastq_stat ，它需要一个输入文件通过选项 --in 传入，然后会收集 FASTQ的统计信息，最后写入 --out 指定的输出文件，输出文件名称由输入文件确定。我们可以通过 find, xargs 和 basename 来实现这一点。第一步通过 find 找到你需要处理的文件，然后利用 xargs 和 basename 来提取文件名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;*.fastq&quot;</span> | xargs basename -s <span class="string">&quot;.fastq&quot;</span></span></span><br><span class="line">zmaysA_R1</span><br><span class="line">zmaysA_R2</span><br><span class="line">zmaysB_R1</span><br><span class="line">zmaysB_R2</span><br><span class="line">zmaysC_R1</span><br><span class="line">zmaysC_R2</span><br></pre></td></tr></table></figure>
<p>然后我们想运行 <code>fastq_stat  --in  file.fastq  --out  ../summaries/file.txt</code> ，不过要将 file 替换为上面提取的 basename。我们的做法是后面再接一个 xargs 命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;*.fastq&quot;</span> | xargs basename -s <span class="string">&quot;.fastq&quot;</span> | xargs -I&#123;&#125; fastq_stat --<span class="keyword">in</span> &#123;&#125;.fastq --out ../summaries/&#123;&#125;.txt</span></span><br></pre></td></tr></table></figure>
<p>这种将 xargs 和 basename 联合使用的方法是一种很强大的范式，用于传参，并使得输出文件的名称根据输入文件确定。</p>
<h3 id="12-2-7-xargs-and-Parallelization">12.2.7 xargs and Parallelization</h3>
<p>xargs 可以创建<strong>有限</strong>数目的<strong>进程</strong>（processes），用于平行计算。这里强调有限数目，是说相对于bash的 for 循环，xargs 具有优势。我们可以通过 Bash 的 for 循环发起无数个后台进程，例如下面的语句，有多少个FASTQ 文件，就发起了多少个后台进程，这会占用很多的服务器资源。即便你是服务器唯一的使用者，但所有程序都可以从硬盘中进行读写，也可能发生 瓶颈。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for filename in *.fastq; do</span><br><span class="line">	program &quot;$filename&quot; &amp;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>因此，我们想要限制同时运行的进程数目。xargs 可以 通过 <code>-P num</code> 来设定进程数目。</p>
<p>让我们看一个简单的例子，上面运行我们的假想软件 fastq_stat ，现在我们采用6个进程同时计算。这里不需要对第一个xargs采用多进程，因为这一步非常快。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;*.fastq&quot;</span> | xargs basename -s <span class="string">&quot;.fastq&quot;</span> | xargs -P 6 -I&#123;&#125; fastq_stat --<span class="keyword">in</span> &#123;&#125;.fastq --out ../summaries/&#123;&#125;.txt</span></span><br></pre></td></tr></table></figure>
<h4 id="xargs-Pipes-and-Redirects">xargs, Pipes, and Redirects</h4>
<p>下面这段话没看懂，貌似大概的意思是说 xargs 没法直接使用重定向。</p>
<blockquote>
<p>One  stumbling  block  beginners  frequently  encounter  is  trying  touse  pipes  and  redirects  with  xargs.  This  won’t  work,  as  the  shell process  that  reads  your  xargs  command  will  interpret  pipes  and redirects as what to do with xarg’s output, not as part of the command  run  by  xargs.</p>
</blockquote>
<p>一个简单的解决办法是创建一个一次处理一个文件的简单的Bash 脚本，然后使用 xargs 运行这个脚本。</p>
<p>比如，我们先写一个简单的脚本，命名为 <a href="http://script.sh">script.sh</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">set -e</span><br><span class="line">set -u</span><br><span class="line">set -o pipefail</span><br><span class="line">sample_name=$(basename -s &quot;.fastq&quot; &quot;$1&quot;)</span><br><span class="line">some_program $&#123;sample_name&#125;.fastq | another_program &gt;  $&#123;sample_name&#125;-results.txt</span><br></pre></td></tr></table></figure>
<p>然后，运行下面的命令。通过 <code>-n 1</code> 限定每次传递一个参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;*.fastq&quot;</span> | xargs -n 1 -P 4 bash script.sh</span></span><br></pre></td></tr></table></figure>
<p>xargs 适合比较简单的命令。如果命令比较复杂，可以使用 <a href="http://www.gnu.org/software/parallel/">GNU Parallel</a>。 它可以说是 xargs 的扩展版，解决了 xargs 的一些局限。例如，GNU Parallel 可以使用重定向，可以通过一个简写（{/.}）来提取 basename (这个估计是去除了后缀的)。我们可以通过 GNU Parallel 写出一个简短而又强大的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;*.fastq&quot;</span> | parallel --max-procs=6 <span class="string">&#x27;program &#123;/.&#125; &gt; &#123;/.&#125;-out.txt&#x27;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="12-3-Make-and-Makefiles-Another-Option-for-Pipelines">12.3 Make and Makefiles: Another Option for Pipelines</h2>
<p>Make 用于生成 <em>makefilies</em> (采用他们自己的 makefile 语言)。Make 适用于编译（compile）软件，这是一个很复杂的过程，因为编译一个文件需要确保这个文件的所有附属文件已被编译或可用。就像 SQL ，</p>
<p>makefile language 是陈述性的（declarative）— 不像是 Bash scripts，makefiles 不会按顺序从头跑到尾。相反，makefiles 是按照一系列规则构建的，每个规则都有三部分：the target, the prerequisites, the recipe。每个  recipe 是用于 build a target 的一系列命令……（看不懂）</p>
<blockquote>
<p>The  amazing  ingenuity  of  Make  is  that  the  program  figures  outhow to use all rules to build files for you from the prerequisites and targets.</p>
</blockquote>
<p>让我们看一个简单的例子 ，我们先写一个简单的流程，从网上下载文件然后汇总信息。</p>
<p><img src="56.png" alt="56"></p>
<ol>
<li>我们像Bash 脚本中一样定义了一个变量。</li>
</ol>
<p>后面都没太看懂，不过好像这里的格式是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">target:  prerequisites</span><br><span class="line">recipe</span><br></pre></td></tr></table></figure>
<ul>
<li>target : 目标文件</li>
<li>prerequisites ：附属文件</li>
<li>recipe : 生成target 文件的命令行</li>
</ul>
<p>我们通过<strong>make命令运行上面生成的Makefile</strong>（这里文件名定死了，只能是Makefile）。像上面的生成的文件，我们可以运行命令 <code>make all</code> ，这里 <code>all</code> 参数指定 make 应该首先从 all target 开始。然后，make 命令会首先在当前目录查找文件名为 <strong>Makefile</strong> 的文件，加载这个文件，然后从 target all 开始运行。</p>
<p>实际运行逻辑如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make all</span></span><br><span class="line">curl -L http://bit.ly/egfr_flank &gt; egfr_flank.fa #第一步</span><br><span class="line">seqtk comp egfr_flank.fa &gt; egfr_comp.txt #第二步</span><br></pre></td></tr></table></figure>
<p>我的理解是：从all 开始（3），根据附属文件跳到（5）, (5) 的附属文件是（4），（4）没有附属文件，那就先跑 （4），顺序就是 (4) - (5) - (3) 。</p>
<p>make 的一个特别有用的功能是，它只会生成没有附属文件/附属文件已<strong>修改</strong>的目标文件。这很有用：如果你有一个很长很复杂的makefile文件，你修改了一个文件，重跑 make 命令只会重新运行附属文件是这个修改的文件的target 的命令行。</p>
<p>比如，你现在重新再跑一遍make all，因为所有的文件均未改变，所以这里啥也没做。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make all</span></span><br><span class="line">make: Nothing to be done for `all&#x27;.</span><br></pre></td></tr></table></figure>
<p>现在我们创建一个新的 FASTQ 文件。因为 egfr_flank.fa 是 egfr_comp.txt 的附属文件，因此它的语句会重新运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch egfr_flank.fa</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make all</span></span><br><span class="line">seqtk comp egfr_flank.fa &gt; egfr_comp.txt</span><br></pre></td></tr></table></figure>
<p>Make 语句如果写复杂了，会很晦涩难懂。但是还是可以用于简单的任务。（那问题来了，简单的任务我用得着写Make语句吗？）</p>
<h1>13 Out-of-Memory Approaches:Tabix and SQLite</h1>
<p>当数据量超出<strong>内存的上限</strong>时，有两个工具可以用：Tabix 和 SQLite databases。</p>
<h2 id="13-1-Fast-Access-to-Indexed-Tab-Delimited-Fileswith-BGZF-and-Tabix">13.1 Fast Access to Indexed Tab-Delimited Fileswith BGZF and Tabix</h2>
<p>BGZF 和 Tabix 解决了处理基因组数据的重要问题。</p>
<p>下面的话没看懂。大概意思是说，如果想要获取基因组上某个范围的数据，首先由于基因组数据太大，可能不能全部放进内存中，还有一部分数据可能要从速度很慢的磁盘中读取；第二，基本是使用关系型数据库，如果检索三百万条条目，速度也是很慢的。这里即将提到的工具，是专门用于处理这个问题的，可以对tab分隔的基因组数据进行快速查找。</p>
<p>在基因组比对的章节，我们看到了如何排序和 indexed BAM 文件，可以快速找到某个特定区域的比对结果，基于一种特定的压缩格式，称为 BGZF （Blocked GUN Zip Format），使用了gzip 来压缩。但是，gzip 一般是直接压缩整个文件，BGZF 文件是分区块压缩的。这些区块提供一个新的特征：我们可以直接解压我们想要的区块，而不用解压整个文件。</p>
<p>联合使用 Block compression  和 indexing 使得我们可以通过 samtools view 快速检索 alignments。</p>
<p>在这一章节，我们会用到 BGZF 压缩，还有一个命令行工具 Tabix，来提供对很多 tab 分隔的基因组格式数据的快速检索，包括 GFF, BED, VCF。</p>
<p>为了使用 Tabix 来检索与某个 query region 重叠的行，我们首先准备包含了基因组区域的文件，通常包括以下步骤：</p>
<ol>
<li>通过染色体和物理位置进行排序</li>
<li>使用 bgzip 命令来使用 BGZF 压缩</li>
<li>使用 tabix 来 index file。</li>
</ol>
<p>bgzip 和 tabix 都是 <strong>Samtools</strong> 中的命令。</p>
<h3 id="13-1-1-Compressing-Files-for-Tabix-with-Bgzip">13.1.1 Compressing Files for Tabix with Bgzip</h3>
<p>以 <em>Mus_musculus.GRCm38.75.gtf.gz</em> 为例，我们需要先解压，然后排序，再用 bgzip 压缩。我们可以通过一个pipeline 完成这些操作。</p>
<p>但是有一点需要注意，由于 GTF 文件中含有 metadata, 不能直接使用sort</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> zcat Mus_musculus.GRCm38.75.gtf.gz | head -n5</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!genome-build GRCm38.p2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!genome-version GRCm38</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!genome-date 2012-01</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!genome-build-accession NCBI:GCA_000001635.4</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!genebuild-last-updated 2013-09</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里他说可以用到 169页教的 subshell 技巧（好吧，我已经忘了）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> (zgrep <span class="string">&quot;^#&quot;</span> Mus_musculus.GRCm38.75.gtf.gz; zgrep -v <span class="string">&quot;^#&quot;</span> Mus_musculus.GRCm38.75.gtf.gz | sort -k1,1 -k4,4n) | bgzip &gt; Mus_musculus.GRCm38.75.gtf.bgz</span></span><br></pre></td></tr></table></figure>
<h3 id="13-1-2-Indexing-Files-with-Tabix">13.1.2 Indexing Files with Tabix</h3>
<p>完成了 BGZF 压缩后，我们可以使用 tabix 命令行工具来进行 index。使用 tabix 来 indexing 标准的生信格式是很简单的，tabix 有对于 GTF/GFF, SAM, VCF, PSL 等格式的选项。我们能通过 -p 参数来index 上述格式的数据。因此，我们可以对上面生成给的 BGZF 文件进行 index</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tabix -p gff Mus_musculus.GRCm38.75.gtf.bgz</span></span><br></pre></td></tr></table></figure>
<p>我们注意到，tabix 会生成一个后缀为 tbi 的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls *tbi</span></span><br><span class="line">Mus_musculus.GRCm38.75.gtf.bgz.tbi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="13-1-3-Using-Tabix">13.1.3 Using Tabix</h3>
<p>一旦我们的 tab 分隔的文件采用 Tabix 进行index 了，我们就可以使用 tabix 命令来进行检索。例如，我们想查找在 16号染色体 23,146,536  to 23,158,028 区间的 features。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tabix Mus_musculus.GRCm38.75.gtf.bgz 16:23146536-23158028 | head -n3</span></span><br><span class="line">16      protein_coding  exon    23146536        23146641        .       +       .       gene_id &quot;ENSMUSG00000022878&quot;; transcript_id &quot;ENSMUST00000023593&quot;; exon_number &quot;1&quot;; gene_name &quot;Adipoq&quot;; gene_source &quot;ensembl_havana&quot;; gene_biotype &quot;protein_coding&quot;; transcript_name &quot;Adipoq-001&quot;; transcript_source &quot;ensembl_havana&quot;; tag &quot;CCDS&quot;; ccds_id &quot;CCDS28075&quot;; exon_id &quot;ENSMUSE00000131550&quot;;</span><br><span class="line">16      protein_coding  gene    23146536        23158028        .       +       .       gene_id &quot;ENSMUSG00000022878&quot;; gene_name &quot;Adipoq&quot;; gene_source &quot;ensembl_havana&quot;; gene_biotype &quot;protein_coding&quot;;</span><br><span class="line">16      protein_coding  transcript      23146536        23158028        .       +       .       gene_id &quot;ENSMUSG00000022878&quot;; transcript_id &quot;ENSMUST00000023593&quot;; gene_name &quot;Adipoq&quot;; gene_source &quot;ensembl_havana&quot;; gene_biotype &quot;protein_coding&quot;; transcript_name &quot;Adipoq-001&quot;; transcript_source &quot;ensembl_havana&quot;; tag &quot;CCDS&quot;; ccds_id &quot;CCDS28075&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以重定向到一个文件中，或者后面接别的命令。例如我们可以用 awk 来提取含有 “exon&quot; 字段的 feature （？这个我也不知道，还是忘了）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tabix Mus_musculus.GRCm38.75.gtf.bgz 16:23146536-23158028  | awk <span class="string">&#x27;$3 ~ /exon/ &#123;print&#125;&#x27;</span></span></span><br><span class="line">16      protein_coding  exon    23146536        23146641        .       +       .       gene_id &quot;ENSMUSG00000022878&quot;; transcript_id &quot;ENSMUST00000023593&quot;; exon_number &quot;1&quot;; gene_name &quot;Adipoq&quot;; gene_source &quot;ensembl_havana&quot;; gene_biotype &quot;protein_coding&quot;; transcript_name &quot;Adipoq-001&quot;; transcript_source &quot;ensembl_havana&quot;; tag &quot;CCDS&quot;; ccds_id &quot;CCDS28075&quot;; exon_id &quot;ENSMUSE00000131550&quot;;</span><br><span class="line">16      protein_coding  exon    23146646        23146734        .       +       .       gene_id &quot;ENSMUSG00000022878&quot;; transcript_id &quot;ENSMUST00000171309&quot;; exon_number &quot;1&quot;; gene_name &quot;Adipoq&quot;; gene_source &quot;ensembl_havana&quot;; gene_biotype &quot;protein_coding&quot;; transcript_name &quot;Adipoq-002&quot;; transcript_source &quot;havana&quot;; exon_id &quot;ENSMUSE00000875966&quot;; tag &quot;cds_end_NF&quot;; tag &quot;mRNA_end_NF&quot;;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h2 id="13-2-Introducing-Relational-Databases-Through-SQLite">13.2 Introducing Relational Databases Through SQLite</h2>
<p>很多标准的生信数据格式（GTF/GFF, BED, VCF/BCF, SAM/BAM）其实都是将表格式的数据存储在文本文件中。而普通文本文件内部没有结果，和其他表格内容也没有关联。当我们能使用 unix’s join 命令，还有 R’s match() 和 merge() 函数来合并多个表格的内容，这些文件本身却无法建立表格之间的联系。</p>
<p>这里可以采用关系型数据库。在这一章节中，我们可以学习一个关系型数据库管理系统，称为 SQLite。</p>
<p>这里使用 SQLite 的理由是，它不需要任何启动 ，你可以用最快的时间进行检索，花最少的时间用在 configuring 和 administrating database。与之相对，其他的数据库系统，比如 MySQL 和  PostgreSQL 仅仅是启动和运行就需要很多的配置工作。虽然 SQLite 没有大型数据库系统强大，但是它对于GB级别的数据库运行良好。</p>
<p>如果想在生信分析中，建立一个关系型数据库管理系统，SQLite 就够了。</p>
<h3 id="13-2-1-When-to-Use-Relational-Databases-in-Bioinformatics">13.2.1 When to Use Relational Databases in Bioinformatics</h3>
<p>事实上，你需要和数据库打交道的需求并不高，理由有两个。第一，很多大型生信数据库提供了用户友好的图形化界面，用于获取数据。第二，对于很多生信任务，采用关系型数据库并不是一个最佳方案。</p>
<p><strong>关系型数据库是设计用来存储和管理多个表中的记录，通过用户需要添加/更新新记录，并进行检索。</strong></p>
<p>为了让你知道什么时候适合使用关系型数据，我们可以比较处理两种不同类型的数据的情况：一套 gene models ，一套测序的 alignment data</p>
<h4 id="Adding-and-Merging-Data">Adding and Merging Data</h4>
<p>假设我们需要合并一个新的 gene models (这是啥?) 进入到现存的 gene models 的数据库中。简单地合并是不合适地，因为我们可以会导致 exons, gene identifiers, gene names 等出现重复。这种数据库合并前需要判断重复。</p>
<p>相反，当我们合并两个 alignment files，我们可以直接合并，不用关心数据结构和一致性。因为每个比对结果都是特定的某个实验结果。也就是说，alignment data 的特性使它没有采用特殊的merge命令的需求。</p>
<h4 id="Updating-Data">Updating Data</h4>
<p>假设你的一个同事运行了一个新版本的 gene finding software。处理了一些数据后，你生成不同于之前的 gene models。经过了仔细的检查后，你发现新的 gene models 更好，然后你想将所有原来的 gene models 更新为 new models’ coordinates。就像是 merging data, 这种更新操作在数据库中更简单。</p>
<p>整个没看懂</p>
<h4 id="Querying-data">Querying data</h4>
<blockquote>
<p>irst,  SQL  acts  as  a  language  you  can  use  to  specify  anytype of query. Second, unlike Python and R, SQL is a declarative language, mean‐ing  you  state  what  you  want,  not  how  to  get  it  (the  RDBMS  implements  this)</p>
</blockquote>
<p>但是通过 samtools view 对 indexed BAM file 进行检索很快，比你先把数据导入到数据库中，再使用SQL 检索快得多。</p>
<p>我感觉，作者的意思大概就是说在这里，数据库的操作基本用不上。数据库适用于<strong>数据量较小</strong>，<strong>整理好</strong>（refined）的数据。</p>
<h3 id="13-2-2-Installing-SQLite">13.2.2 Installing SQLite</h3>
<h3 id="13-2-3-Exploring-SQLite-Databases-with-the-Command-Line-Interface">13.2.3 Exploring SQLite Databases with the Command-Line Interface</h3>
<p>我们先以 <em>gwascat.db</em> 作为一个例子数据库。这是一个 SQLite 数据库，包括了GWAS的东西。</p>
<p>可以通过下面的命令互动式操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; .tables #查看表</span><br><span class="line">gwascat</span><br><span class="line"></span><br><span class="line">sqlite&gt; .schema #查看表和表结构</span><br><span class="line">CREATE TABLE gwascat(</span><br><span class="line">id integer PRIMARY KEY NOT NULL,</span><br><span class="line">dbdate text,</span><br><span class="line">pubmedid integer,</span><br><span class="line">author text,</span><br><span class="line">date text,</span><br><span class="line">journal text,</span><br><span class="line"></span><br><span class="line">sqlite&gt; .exit #退出</span><br></pre></td></tr></table></figure>
<p><img src="57.png" alt="57"></p>
<p>sqlite 每一列允许有多种数据类型，但是会有一个推荐的数据类型，而且会像R语言一样尽可能地转成推荐的数据类型。</p>
<p>总共有5种数据类型：</p>
<ul>
<li>text</li>
<li>integer</li>
<li>real</li>
<li>NULL，used for missing data, or no value</li>
<li>BLOB, which stands for binary large object, and stores any type of object as bytes</li>
</ul>
<h3 id="13-2-4-Querying-Out-Data-The-Almighty-SELECT-Command">13.2.4 Querying Out Data: The Almighty SELECT Command</h3>
<p>SELECT 最简单的用法，所有语句必须以<strong>分号</strong>结束。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT * FROM gwascat;</span></span><br></pre></td></tr></table></figure>
<p>如果你输入命令的时候输入错误，你不能用 ctrl+c，可以用 ctrl + u 清空输入的所有代码。但是如果已经开始运行了，你可以输入一个错误的指定（以分号结束）让它报错（测试过了，直接输入一个分号就行）。</p>
<p>你也可以直接使用命令行的方式，可以通过 -separator 指定输出的分隔符（“,” for CSV , “\t” ）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sqlite3 gwascat.db <span class="string">&quot;SELECT * FROM gwascat&quot;</span> &gt; results.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> head -n 1 results.txt</span></span><br><span class="line">1|2014-08-02|24388013|Ferreira MA|2013-12-30|J Allergy Clin Immunol|http://www.ncbi.nlm.nih.gov/pubmed/24388013|Genome-wide association analysis identifies 11 </span><br></pre></td></tr></table></figure>
<h4 id="Limiting-results-with-LIMIT">Limiting results with LIMIT</h4>
<p>LIMIT 限制输出的行数。</p>
<p>但是，不像存储在文件中顺序是固定的，但是<strong>数据库里的行的顺序是不固定的</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT * FROM gwascatLIMIT 2;</span></span><br><span class="line">id|dbdate|pubmedid|author|date|journal| [...]</span><br><span class="line">1|08/02/2014|24388013|Ferreira MA|12/30/2013|J Allergy Clin Immunol| [...]</span><br><span class="line">2|08/02/2014|24388013|Ferreira MA|12/30/2013|J Allergy Clin Immunol| [...]</span><br></pre></td></tr></table></figure>
<h4 id="Selecting-columns-with-SELECT">Selecting columns with SELECT</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT trait, chrom, position, strongest_risk_snp, pvalue FROM gwascat LIMIT 5</span></span><br><span class="line">   ...&gt; ;</span><br><span class="line">Asthma and hay fever|6|32658824|rs9273373|4.0e-14</span><br><span class="line">Asthma and hay fever|4|38798089|rs4833095|5.0e-12</span><br><span class="line">Asthma and hay fever|5|111131801|rs1438673|3.0e-11</span><br><span class="line">Asthma and hay fever|2|102350089|rs10197862|4.0e-11</span><br><span class="line">Asthma and hay fever|17|39966427|rs7212938|4.0e-10</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>改一下设置，显示更清晰</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> .header on</span></span><br><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> .mode column</span></span><br><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT trait, chrom, position, strongest_risk_snp, pvalue FROM gwascat LIMIT 5;</span></span><br><span class="line">trait                 chrom  position   strongest_risk_snp  pvalue</span><br><span class="line">--------------------  -----  ---------  ------------------  -------</span><br><span class="line">Asthma and hay fever  6      32658824   rs9273373           4.0e-14</span><br><span class="line">Asthma and hay fever  4      38798089   rs4833095           5.0e-12</span><br><span class="line">Asthma and hay fever  5      111131801  rs1438673           3.0e-11</span><br><span class="line">Asthma and hay fever  2      102350089  rs10197862          4.0e-11</span><br><span class="line">Asthma and hay fever  17     39966427   rs7212938           4.0e-10</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Ordering-rows-with-ORDER-BY">Ordering rows with ORDER BY</h4>
<p>上面得到的结果顺序是不定的，可以通过 ORDER BY 排好序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT author, trait, journal FROM gwascat ORDER BY author LIMIT 5;</span><br><span class="line">author   trait                                                            journal</span><br><span class="line">-------  ---------------------------------------------------------------  ------------------</span><br><span class="line">Aberg K  Antipsychotic-induced QTc interval prolongation                  Pharmacogenomics J</span><br><span class="line">Aberg K  Antipsychotic-induced QTc interval prolongation                  Pharmacogenomics J</span><br><span class="line">Aberg K  Antipsychotic-induced QTc interval prolongation                  Pharmacogenomics J</span><br><span class="line">Aberg K  Response to antipsychotic therapy (extrapyramidal side effects)  Biol Psychiatry</span><br><span class="line">Aberg K  Response to antipsychotic therapy (extrapyramidal side effects)  Biol Psychiatry</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果以<strong>降序</strong>排列，增加 DESC</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT author, trait, journal FROM gwascat ORDER BY author DESC LIMIT 5;</span></span><br><span class="line">author             trait                                        journal</span><br><span class="line">-----------------  -------------------------------------------  ----------------------</span><br><span class="line">van der Zanden LF  Hypospadias                                  Nat Genet</span><br><span class="line">van der Valk RJ    Fractional exhaled nitric oxide (childhood)  J Allergy Clin Immunol</span><br><span class="line">van der Valk RJ    Fractional exhaled nitric oxide (childhood)  J Allergy Clin Immunol</span><br><span class="line">van der Valk RJ    Fractional exhaled nitric oxide (childhood)  J Allergy Clin Immunol</span><br><span class="line">van der Valk RJ    Fractional exhaled nitric oxide (childhood)  J Allergy Clin Immunol</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为 sqlite 的列没有固定数据类型，因此使用 ORDER BY 遇到混合格式会按照下面的顺序排序：<strong>NULL values, integer and real values, text values, blob values</strong>。需要特别注意的是，NULL 永远排在前面，无论是顺序还是逆序，我们可以通过以p-value 排序看一下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT trait, chrom, position, strongest_risk_snp, pvalue FROM gwascat ORDER BY pvalue LIMIT 5;</span></span><br><span class="line">trait          chrom  position  strongest_risk_snp  pvalue</span><br><span class="line">-------------  -----  --------  ------------------  ------</span><br><span class="line">Brain imaging                   rs10932886</span><br><span class="line">Brain imaging                   rs429358</span><br><span class="line">Brain imaging                   rs7610017</span><br><span class="line">Brain imaging                   rs6463843</span><br><span class="line">Brain imaging                   rs2075650</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下一章节，我们会讲到如何使用 WHICH 语句来剔除 NULL 行。</p>
<p>我们可以 ORDER BY 来查看异常值，比如 p-value 应该是在0和1之间，我们按逆序排序，查看有没有超过1的。发现有两个错误（估计是 9e-7 ，误写成了9e7）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT trait, strongest_risk_snp, pvalue FROM gwascat ORDER BY pvalue DESC LIMIT 5;</span></span><br><span class="line">trait                                       strongest_risk_snp  pvalue</span><br><span class="line">------------------------------------------  ------------------  ----------</span><br><span class="line">Serum protein levels (sST2)                 rs206548            90000000.0</span><br><span class="line">Periodontitis (Mean PAL)                    rs12050161          4000000.0</span><br><span class="line">Coronary artery disease or ischemic stroke  rs964184            2.0e-05</span><br><span class="line">Lipid traits                                rs10158897          9.0e-06</span><br><span class="line">Rheumatoid arthritis                        rs8032939           9.0e-06</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Filtering-which-rows-with-WHERE">Filtering which rows with WHERE</h4>
<p>这里 = 和 == 都可以。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT chrom, position, trait, strongest_risk_snp, pvalue FROM gwascat WHERE strongest_risk_snp = <span class="string">&quot;rs429358&quot;</span>;</span></span><br><span class="line">chrom  position  trait                           strongest_risk_snp  pvalue</span><br><span class="line">-----  --------  ------------------------------  ------------------  -------</span><br><span class="line">19     44908684  Alzheimer&#x27;s disease biomarkers  rs429358            5.0e-14</span><br><span class="line">19     44908684  Alzheimer&#x27;s disease biomarkers  rs429358            1.0e-06</span><br><span class="line">                 Brain imaging                   rs429358</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意大小写问题，比如你可以用 lower() 函数先都转为小写 (more robust)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT chrom, position, trait, strongest_risk_snp, pvalue FROM gwascat WHERE lower(strongest_risk_snp) = <span class="string">&quot;rs429358&quot;</span>;</span></span><br><span class="line">chrom  position  trait                           strongest_risk_snp  pvalue</span><br><span class="line">-----  --------  ------------------------------  ------------------  -------</span><br><span class="line">19     44908684  Alzheimer&#x27;s disease biomarkers  rs429358            5.0e-14</span><br><span class="line">19     44908684  Alzheimer&#x27;s disease biomarkers  rs429358            1.0e-06</span><br><span class="line">                 Brain imaging                   rs429358</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其他比较符号，下面的图漏了一个 + （positive）</p>
<p><img src="58.png" alt="57"></p>
<p>比如，我们可以通过 AND OR 创建更复杂的表达式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT chrom, position, trait, strongest_risk_snp, pvalue</span></span><br><span class="line">   ...&gt; FROM gwascat WHERE chrom = &quot;22&quot; AND pvalue &lt; 10e-15;</span><br><span class="line">chrom  position  trait                                             strongest_risk_snp  pvalue</span><br><span class="line">-----  --------  ------------------------------------------------  ------------------  --------</span><br><span class="line">22     39351666  Rheumatoid arthritis                              rs909685            1.0e-16</span><br><span class="line">22     21577779  HDL cholesterol                                   rs181362            4.0e-18</span><br><span class="line">22     39146287  Multiple myeloma                                  rs877529            8.0e-16</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要指出的是，通过设定 colname = NULL 没用，这里需要用 IS 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT chrom, position, trait, strongest_risk_snp, pvalue</span></span><br><span class="line">   ...&gt; FROM gwascat ORDER BY pvalue LIMIT 5;</span><br><span class="line">chrom  position  trait          strongest_risk_snp  pvalue</span><br><span class="line">-----  --------  -------------  ------------------  ------</span><br><span class="line">                 Brain imaging  rs10932886</span><br><span class="line">                 Brain imaging  rs429358</span><br><span class="line">                 Brain imaging  rs7610017</span><br><span class="line">                 Brain imaging  rs6463843</span><br><span class="line">                 Brain imaging  rs2075650</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过 WHERE pvalue IS NOT NULL 来剔除空值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT chrom, position, trait, strongest_risk_snp, pvalue</span></span><br><span class="line">   ...&gt; FROM gwascat WHERE pvalue IS NOT NULL ORDER BY pvalue LIMIT 5;</span><br><span class="line">chrom  position   trait                                      strongest_risk_snp  pvalue</span><br><span class="line">-----  ---------  -----------------------------------------  ------------------  ------</span><br><span class="line">16     56959412   HDL cholesterol                            rs3764261           0.0</span><br><span class="line">10     122454932  Age-related macular degeneration           rs10490924          0.0</span><br><span class="line">1      196710325  Age-related macular degeneration           rs10737680          0.0</span><br><span class="line">4      9942428    Urate levels                               rs12498742          0.0</span><br><span class="line">6      43957789   Vascular endothelial growth factor levels  rs4513773           0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>OR 语句</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT chrom, position, strongest_risk_snp, pvalue FROM gwascat</span></span><br><span class="line">   ...&gt; WHERE (chrom = &quot;1&quot; OR chrom = &quot;2&quot; OR chrom = &quot;3&quot;)</span><br><span class="line">   ...&gt; AND pvalue &lt; 10e-11 ORDER BY pvalue LIMIT 5;</span><br><span class="line">chrom  position   strongest_risk_snp  pvalue</span><br><span class="line">-----  ---------  ------------------  ---------------------</span><br><span class="line">1      196710325  rs10737680          0.0</span><br><span class="line">2      233763993  rs6742078           4.94065645841247e-324</span><br><span class="line">3      165773492  rs1803274           6.0e-262</span><br><span class="line">1      196690107  rs1061170           1.0e-261</span><br><span class="line">2      73591809   rs13391552          5.0e-252</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更简单的方式是用 IN (NOT IN)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT chrom, position, strongest_risk_snp, pvalue FROM gwascat</span><br><span class="line">   ...&gt; WHERE chrom IN (&quot;1&quot;, &quot;2&quot;, &quot;3&quot;) AND pvalue &lt; 10e-11</span><br><span class="line">   ...&gt; ORDER BY pvalue LIMIT 5;</span><br><span class="line">chrom  position   strongest_risk_snp  pvalue</span><br><span class="line">-----  ---------  ------------------  ---------------------</span><br><span class="line">1      196710325  rs10737680          0.0</span><br><span class="line">2      233763993  rs6742078           4.94065645841247e-324</span><br><span class="line">3      165773492  rs1803274           6.0e-262</span><br><span class="line">1      196690107  rs1061170           1.0e-261</span><br><span class="line">2      73591809   rs13391552          5.0e-252</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BETWEEN AND 语句 类似于 X &gt;= AND X &lt;=</p>
<p>但是这种方式没有别的方法效率高，比如 Tabix, BedTools，GenomicRanges。如果你在速度上遇到了瓶颈，你可以用上面的那些工具。</p>
<p>另外一个选项是应用 <em>binning</em> scheme，这会将 features 分配到特定的 bins 中。为了查看某个区域的 features，可以先计算这些features 可能会包括在哪些 bins 中。UCSC Genome Browser 就是采用了这种系统。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT chrom, position, strongest_risk_snp, pvalue</span><br><span class="line">   ...&gt; FROM gwascat WHERE chrom &#x3D; &quot;22&quot;</span><br><span class="line">   ...&gt; AND position BETWEEN 24000000 AND 25000000</span><br><span class="line">   ...&gt; AND pvalue IS NOT NULL ORDER BY pvalue LIMIT 5;</span><br><span class="line">chrom  position  strongest_risk_snp  pvalue</span><br><span class="line">-----  --------  ------------------  --------</span><br><span class="line">22     24603137  rs2073398           1.0e-109</span><br><span class="line">22     24594246  rs4820599           7.0e-53</span><br><span class="line">22     24600663  rs5751902           8.0e-20</span><br><span class="line">22     24594246  rs4820599           4.0e-11</span><br><span class="line">22     24186073  rs8141797           2.0e-09</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="13-2-5-SQLite-Functions">13.2.5 SQLite Functions</h3>
<p>有时我们需要从现有的列中创建新列。我们采用 SQLite functions 和 operators 来实现这一点，然后使用 AS 给新列起名。</p>
<p>这里 <code>||</code> 是连接符，连接两个字符串。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT lower(trait) AS trait,</span></span><br><span class="line">   ...&gt; &quot;chr&quot; || chrom || &quot;:&quot; || position AS region FROM gwascat LIMIT 5;</span><br><span class="line">trait                 region</span><br><span class="line">--------------------  --------------</span><br><span class="line">asthma and hay fever  chr6:32658824</span><br><span class="line">asthma and hay fever  chr4:38798089</span><br><span class="line">asthma and hay fever  chr5:111131801</span><br><span class="line">asthma and hay fever  chr2:102350089</span><br><span class="line">asthma and hay fever  chr17:39966427</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设我们面临另一个需求，是将空值转化为NA（输出到R中）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT ifnull(chrom, <span class="string">&quot;NA&quot;</span>) AS chrom, ifnull(position, <span class="string">&quot;NA&quot;</span>) AS position,</span></span><br><span class="line">   ...&gt; strongest_risk_snp, ifnull(pvalue, &quot;NA&quot;) AS pvalue FROM gwascat</span><br><span class="line">   ...&gt; WHERE strongest_risk_snp = &quot;rs429358&quot;;</span><br><span class="line">chrom  position  strongest_risk_snp  pvalue</span><br><span class="line">-----  --------  ------------------  -------</span><br><span class="line">19     44908684  rs429358            5.0e-14</span><br><span class="line">19     44908684  rs429358            1.0e-06</span><br><span class="line">NA     NA        rs429358            NA</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面我们会简单接触到如果与R互作（会自动将NULL转化为NA）。</p>
<p>下面是一些有用的函数</p>
<p><img src="59.png" alt="57"></p>
<p><img src="60.png" alt="57"></p>
<h3 id="13-2-6-SQLite-Aggregate-Functions">13.2.6 SQLite Aggregate Functions</h3>
<p>另一种函数将查询得到的结果作为输入，然后返回一个单独的值。比如 count() (某个字段非空的记录数)</p>
<p>count(*) 统计数据库行数（不考虑NULL）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT count(*) FROM gwascat;</span></span><br><span class="line">count(*)</span><br><span class="line">--------</span><br><span class="line">17290</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>count(colname) 剔除 NULL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT count(pvalue) FROM gwascat;</span><br><span class="line">count(pvalue)</span><br><span class="line">-------------</span><br><span class="line">17279</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT count(*) - count(pvalue) AS number_of_null_pvalues FROM gwascat;</span><br><span class="line">number_of_null_pvalues</span><br><span class="line">----------------------</span><br><span class="line">11</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select &quot;2007&quot; AS year, count(*) AS number_entries</span><br><span class="line">   ...&gt; from gwascat WHERE date BETWEEN &quot;2007-01-01&quot; AND &quot;2008-01-01&quot;;</span><br><span class="line">year  number_entries</span><br><span class="line">----  --------------</span><br><span class="line">2007  435</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>常见的统计命令</p>
<p><img src="61.png" alt="57"></p>
<p>下面这段话没看懂</p>
<p><img src="62.png" alt="57"></p>
<p>aggregate function 的一个好处是允许事先剔除重复值（通过 DISTINCT）。比如，假如我们要统计去重后的 rs 号的数目。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT count(DISTINCT strongest_risk_snp) AS unique_rs FROM gwascat;</span><br><span class="line">unique_rs</span><br><span class="line">---------</span><br><span class="line">13619</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Grouping-rows-with-GROUP-BY">Grouping rows with GROUP BY</h4>
<p>很多的数据库操作和R语句很相似。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT chrom, count(*) FROM gwascat GROUP BY chrom;</span><br><span class="line">chrom  count(*)</span><br><span class="line">-----  --------</span><br><span class="line">       70</span><br><span class="line">1      1458</span><br><span class="line">10     930</span><br><span class="line">11     988</span><br><span class="line">12     858</span><br><span class="line">13     432</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>按出现次数从多到少</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT chrom, count(*) as nhits FROM gwascat GROUP BY chrom</span><br><span class="line">   ...&gt; ORDER BY nhits DESC;</span><br><span class="line">chrom  nhits</span><br><span class="line">-----  -----</span><br><span class="line">6      1658</span><br><span class="line">1      1458</span><br><span class="line">2      1432</span><br><span class="line">3      1033</span><br><span class="line">11     988</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> select strongest_risk_snp, count(*) AS count</span></span><br><span class="line">   ...&gt; FROM gwascat GROUP BY strongest_risk_snp</span><br><span class="line">   ...&gt; ORDER BY count DESC LIMIT 5;</span><br><span class="line">strongest_risk_snp  count</span><br><span class="line">------------------  -----</span><br><span class="line">rs1260326           36</span><br><span class="line">rs4420638           30</span><br><span class="line">rs1800562           28</span><br><span class="line">rs7903146           27</span><br><span class="line">rs964184            25</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select strongest_risk_snp, strongest_risk_allele, count(*) AS count</span><br><span class="line">   ...&gt; FROM gwascat GROUP BY strongest_risk_snp, strongest_risk_allele</span><br><span class="line">   ...&gt; ORDER BY count DESC LIMIT 10;</span><br><span class="line">strongest_risk_snp  strongest_risk_allele  count</span><br><span class="line">------------------  ---------------------  -----</span><br><span class="line">rs1260326           T                      22</span><br><span class="line">rs2186369           G                      22</span><br><span class="line">rs1800562           A                      20</span><br><span class="line">rs909674            C                      20</span><br><span class="line">rs11710456          G                      19</span><br><span class="line">rs7903146           T                      19</span><br><span class="line">rs4420638           G                      18</span><br><span class="line">rs964184            G                      15</span><br><span class="line">rs11847263          G                      14</span><br><span class="line">rs3184504           T                      12</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假如我们想按照年份排序，首先我们用substr() 提取日期的前4位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT substr(date, 1, 4) AS year FROM gwascat GROUP BY year;</span><br><span class="line">year</span><br><span class="line">----</span><br><span class="line">2005</span><br><span class="line">2006</span><br><span class="line">2007</span><br><span class="line">2008</span><br><span class="line">2009</span><br><span class="line">2010</span><br><span class="line">2011</span><br><span class="line">2012</span><br><span class="line">2013</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT substr(date, 1, 4) AS year,</span></span><br><span class="line">   ...&gt; round(avg(pvalue_mlog), 4) AS mean_log_pvalue,</span><br><span class="line">   ...&gt; count(pvalue_mlog) AS n</span><br><span class="line">   ...&gt; FROM gwascat GROUP BY year;</span><br><span class="line">year  mean_log_pvalue  n</span><br><span class="line">----  ---------------  ----</span><br><span class="line">2005  6.2474           2</span><br><span class="line">2006  7.234            8</span><br><span class="line">2007  11.0973          434</span><br><span class="line">2008  11.5054          971</span><br><span class="line">2009  12.6279          1323</span><br><span class="line">2010  13.0641          2528</span><br><span class="line">2011  13.3437          2349</span><br><span class="line">2012  9.6976           4197</span><br><span class="line">2013  10.3643          5406</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>很重要的一点在于 where 语句运行早于 grouping，如果你想过滤 groups，你可以使用 having 语句。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT substr(date, 1, 4) AS year,</span></span><br><span class="line">   ...&gt; round(avg(pvalue_mlog), 4) AS mean_log_pvalue,</span><br><span class="line">   ...&gt; count(pvalue_mlog) AS n</span><br><span class="line">   ...&gt; FROM gwascat GROUP BY year</span><br><span class="line">   ...&gt; HAVING count(pvalue_mlog) &gt; 10;</span><br><span class="line">year  mean_log_pvalue  n</span><br><span class="line">----  ---------------  ----</span><br><span class="line">2007  11.0973          434</span><br><span class="line">2008  11.5054          971</span><br><span class="line">2009  12.6279          1323</span><br><span class="line">2010  13.0641          2528</span><br><span class="line">2011  13.3437          2349</span><br><span class="line">2012  9.6976           4197</span><br><span class="line">2013  10.3643          5406</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="13-2-7-Subqueries">13.2.7 Subqueries</h3>
<p>如果我们想查找每个研究找到的显著位点的数目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT substr(date, 1, 4) AS year, author, pubmedid,</span><br><span class="line">   ...&gt; count(*) AS num_assoc FROM gwascat GROUP BY pubmedid</span><br><span class="line">   ...&gt; LIMIT 5;</span><br><span class="line">year  author         pubmedid  num_assoc</span><br><span class="line">----  -------------  --------  ---------</span><br><span class="line">2005  Klein RJ       15761122  1</span><br><span class="line">2005  Maraganore DM  16252231  1</span><br><span class="line">2006  Arking DE      16648850  1</span><br><span class="line">2006  Fung HC        17052657  3</span><br><span class="line">2006  Dewan A        17053108  1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果我们做得深一点，我们想看每个期刊每年找到的显著位点的平均数。在 SQL 的行话中，这就是说我们需要用到之前的结果，再进一步按年份分组，然后使用 avg() 计算均值（开始套娃）。这种嵌套式的query 称为 <em>subqueries</em>。我们可以通过<strong>括号</strong>来将前面的语句括起来，然后通过 FROM 语句将其视为一个数据库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT year, avg(num_assoc)</span></span><br><span class="line">   ...&gt; FROM (SELECT substr(date, 1, 4) AS year,</span><br><span class="line">   ...&gt;     author,</span><br><span class="line">   ...&gt;     count(*) AS num_assoc</span><br><span class="line">   ...&gt;     FROM gwascat GROUP BY pubmedid)</span><br><span class="line">   ...&gt; GROUP BY year;</span><br><span class="line">year  avg(num_assoc)</span><br><span class="line">----  ----------------</span><br><span class="line">2005  1.0</span><br><span class="line">2006  1.6</span><br><span class="line">2007  5.87837837837838</span><br><span class="line">2008  7.64566929133858</span><br><span class="line">2009  6.90625</span><br><span class="line">2010  9.21660649819495</span><br><span class="line">2011  7.4968152866242</span><br><span class="line">2012  13.4536741214058</span><br><span class="line">2013  16.605504587156</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="13-2-8-Organizing-Relational-Databases-and-Joins">13.2.8 Organizing Relational Databases and Joins</h3>
<p>如果你仔细看 gwascat 表格，你会发现有很多的冗余。一个研究（看pubmedid）可能会找到多个显著的SNP，一个SNP占据一行，这些行除了SNP名称不一样，其他列都是重复的。如下图</p>
<p><img src="63.png" alt="63"></p>
<p>当你直接从表格中复制数据时，这种冗余是很常见的。对于很大的数据库，这种冗余会占据很多的额外空间。</p>
<p>在我们提及如何联合使用多个表的信息前，我们先要理解关系型数据库<strong>管理数据的哲学</strong>，来避免上面的这种情况（<em>spreadsheet syndrome</em>）。这个哲学就是 <em>database normalization</em>。</p>
<p>首先<strong>每个字段只能存储一个值</strong>。下面这个assocs 表就破坏了这个规则。这种情况下，比如你想检索 rs4833095 在不在这个表里，你不能再用 SQL 语法如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> assoc <span class="keyword">WHERE</span> strongest_risk_snp <span class="operator">=</span> &quot;rs4833095&quot;</span><br></pre></td></tr></table></figure>
<p><img src="64.png" alt="63"></p>
<p>我们可以把多个切断切分成多行，如下图</p>
<p><img src="66.png" alt=""></p>
<p>但是，这又造成了重复冗余，我们可以看懂 pubmedid, year, journal 是重复的。这种重复是可以避免的，而且year 和 journal 字段是依赖于 pubmedid 字段的。</p>
<p>一个更好的管理数据的方式是，将这个表格切分为两个表格（一个是GWAS结果，一个是study信息）（ trait 还有冗余，可以把 trait 也放到 studies 表中，但是逻辑就不是很清晰了。因此从逻辑上讲，GWAS 表中应该要注明是哪个性状）</p>
<p><img src="67.png" alt=""></p>
<p>现在我们有两个表了，我们可以同时查询两个表格的信息。</p>
<h4 id="Inner-joins">Inner joins</h4>
<p>这里已经把这两个表放在 joins.db 中了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sqlite3 joins.db</span><br><span class="line">SQLite version 3.33.0 2020-08-14 13:23:32</span><br><span class="line">Enter &quot;.help&quot; for usage hints.</span><br><span class="line">sqlite&gt; .mode columns</span><br><span class="line">sqlite&gt; .header on</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>先查看一下两个表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT * FROM assocs;</span><br><span class="line">id  study_id  trait              strongest_risk_snp</span><br><span class="line">--  --------  -----------------  ------------------</span><br><span class="line">1   1         Asthma, hay fever  rs9273373</span><br><span class="line">2   1         Asthma, hay fever  rs4833095</span><br><span class="line">3   1         Asthma, hay fever  rs1438673</span><br><span class="line">4   2         Hypertension       rs2820037</span><br><span class="line">5   2         Crohn&#39;s disease    rs6596075</span><br><span class="line">6             Urate levels       rs12498742</span><br><span class="line"></span><br><span class="line">sqlite&gt; SELECT * FROM studies;</span><br><span class="line">id  pubmedid  year  journal</span><br><span class="line">--  --------  ----  --------------</span><br><span class="line">1   24388013  2013  J Allergy</span><br><span class="line">2   17554300  2007  Nature</span><br><span class="line">3   16252231  2005  Am J Hum Genet</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们最常用的连接方式就是内连接。</p>
<p>连接条件采用 <strong>on</strong> 选项</p>
<p>由于两个表中可能含有相同名称的列名，提取列一律采用<strong>表名.列名</strong> 的方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT * FROM assocs INNER JOIN studies ON assocs.study_id &#x3D; studies.id;</span><br><span class="line">id  study_id  trait              strongest_risk_snp  id  pubmedid  year  journal</span><br><span class="line">--  --------  -----------------  ------------------  --  --------  ----  ---------</span><br><span class="line">1   1         Asthma, hay fever  rs9273373           1   24388013  2013  J Allergy</span><br><span class="line">2   1         Asthma, hay fever  rs4833095           1   24388013  2013  J Allergy</span><br><span class="line">3   1         Asthma, hay fever  rs1438673           1   24388013  2013  J Allergy</span><br><span class="line">4   2         Hypertension       rs2820037           2   17554300  2007  Nature</span><br><span class="line">5   2         Crohn&#39;s disease    rs6596075           2   17554300  2007  Nature</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>提取部分列（使用 AS 重命名）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT studies.id AS study_id, assocs.id AS assoc_id, trait, year</span><br><span class="line">   ...&gt; FROM assocs INNER JOIN studies ON assocs.study_id &#x3D; studies.id;</span><br><span class="line">study_id  assoc_id  trait              year</span><br><span class="line">--------  --------  -----------------  ----</span><br><span class="line">1         1         Asthma, hay fever  2013</span><br><span class="line">1         2         Asthma, hay fever  2013</span><br><span class="line">1         3         Asthma, hay fever  2013</span><br><span class="line">2         4         Hypertension       2007</span><br><span class="line">2         5         Crohn&#39;s disease    2007</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看 assocs 表中的 study_id 不在 studies 表中的 id 列的行（这里用到了 subqueries）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT * FROM assocs WHERE study_id NOT IN (SELECT id FROM studies);</span><br><span class="line">id  study_id  trait         strongest_risk_snp</span><br><span class="line">--  --------  ------------  ------------------</span><br><span class="line">6             Urate levels  rs12498742</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Left-outer-joins">Left outer joins</h4>
<p>保留左边表的所有行，如果匹配不上右边的表，则右边表的字段均设置为 <strong>NULL</strong>。</p>
<p>s<strong>qlite 仅支持 left outer joins</strong>，但是其实 outer joins 还有两种类型，right outer joins （右连接，和左连接一样）和 full outer joins （全外连接返回两个表格合并的所有行）。</p>
<p>假如我们想保留 assocs 表的所有字段，无论它在不在 studies 表中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT * FROM assocs LEFT OUTER JOIN studies</span><br><span class="line">   ...&gt; ON assocs.study_id &#x3D; studies.id;</span><br><span class="line">id  study_id  trait              strongest_risk_snp  id  pubmedid  year  journal</span><br><span class="line">--  --------  -----------------  ------------------  --  --------  ----  ---------</span><br><span class="line">1   1         Asthma, hay fever  rs9273373           1   24388013  2013  J Allergy</span><br><span class="line">2   1         Asthma, hay fever  rs4833095           1   24388013  2013  J Allergy</span><br><span class="line">3   1         Asthma, hay fever  rs1438673           1   24388013  2013  J Allergy</span><br><span class="line">4   2         Hypertension       rs2820037           2   17554300  2007  Nature</span><br><span class="line">5   2         Crohn&#39;s disease    rs6596075           2   17554300  2007  Nature</span><br><span class="line">6             Urate levels       rs12498742</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="13-2-9-Writing-to-Databases">13.2.9 Writing to Databases</h3>
<p>由于我们通常都是一次性地将数据导入到生信数据库中，因此这里不将常见地修改和删除命令。</p>
<h4 id="Creating-tables">Creating tables</h4>
<p>在 gwas‐cat2table.db 中创建 study 表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sqlite3   gwas‐cat2table.db</span><br><span class="line">SQLite version 3.33.0 2020-08-14 13:23:32</span><br><span class="line">Enter &quot;.help&quot; for usage hints.</span><br><span class="line">sqlite&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建表格的基本语法是，每个字段均要设置一个偏好的数据类型（不填是 none）。</p>
<p>第一个字段通常都设置为 <code>id integer primary key</code>。每个表格均要设置一个主键，主键不能重复。</p>
<p>主键是表格的条件之一，其他还有 UNIQUE, NOT NULL, CHECK, FOREIGN KEY。</p>
<p>如果你想要创建一个复制的数据库，作者建议你看完这一章节之后，再专门看一下 SQL 的书籍。</p>
<blockquote>
<p>Thoughtfulness and planning definitely pay off when it comes to organizing a database.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tablename(</span><br><span class="line">	id integer primary key,</span><br><span class="line">	column1 column1_type,</span><br><span class="line">	column2 column2_type,  </span><br><span class="line">	...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>让我们创建一个简单的数据库，然后创建一个表格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sqlite3 practice.db</span><br><span class="line">SQLite version 3.33.0 2020-08-14 13:23:32</span><br><span class="line">Enter &quot;.help&quot; for usage hints.</span><br><span class="line">sqlite&gt; CREATE TABLE variants(</span><br><span class="line">   ...&gt;     id integerprimarykey,</span><br><span class="line">   ...&gt;     chrom text,</span><br><span class="line">   ...&gt;     start integer,</span><br><span class="line">   ...&gt;     end integer,</span><br><span class="line">   ...&gt;     strand text,</span><br><span class="line">   ...&gt;     name text);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我们可以查看到这个表格已存在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; .tables</span><br><span class="line">variants</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Inserting-records-into-tables">Inserting records into tables</h4>
<p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERTINTO tablename(column1, column2) VALUES (value1, value2);</span><br></pre></td></tr></table></figure>
<p>也可以忽略字段名（column1, column2），但是作者不建议这么做，指定字段名称更加清楚，提高<strong>可读性</strong>。</p>
<p>在之前的章节中，我们提高了主键。如果在插入的数据中，主键的值为NULL，那么数据库会自动创建一个主键（之前的主键+1，前提是主键是数字）。</p>
<p>我们可以试一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; INSERT INTO variants(id, chrom, start, end, strand, name)</span><br><span class="line">   ...&gt;  VALUES(NULL, &quot;16&quot;, 48224287, 48224287, &quot;+&quot;, &quot;rs17822931&quot;);</span><br></pre></td></tr></table></figure>
<p>查看所有记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT * FROM variants;</span><br><span class="line">id  chrom  start     end       strand  name</span><br><span class="line">--  -----  --------  --------  ------  ----------</span><br><span class="line">    16     48224287  48224287  +       rs17822931</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>额，打脸了，id 列还是空的。作者给的 id 是 1</p>
<p><img src="68.png" alt=""></p>
<h4 id="Indexing">Indexing</h4>
<p>在简单的数据库里查询很快，但是复杂的数据库里查询很慢。这种情况下，sqlite 需要遍历所有的记录。这里有一个技巧，index a column of a table。</p>
<p>数据库索引会包含一个排好序的某一列的所有元素，还有对应的行。由于索引列的元素已经排好序了，查找起来更快（就像在书的目录中找一个词 VS 在整本书里找一个词）。</p>
<p>indexs 也有缺陷，就像书添加索引会占据额外的页数，表格的索引也会占据硬盘空间。</p>
<p>创建索引很简单。这里我们给 gwascat2table.db 数据库的 assocs 表格 的 strongest_risk_snp 字段填上索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; CREATE INDEX snp_idx ON assocs(strongest_risk_snp);</span><br></pre></td></tr></table></figure>
<p>可以查看索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; .indices</span><br><span class="line">snp_idx       study_id_idx</span><br></pre></td></tr></table></figure>
<p>当你更新/插入数据，<strong>索引会自动更新</strong>。</p>
<p>你需要对外键创建索引，来提高 JOIN 速度。（这里是之前建过了）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; CREATE INDEX study_id_idx ON assocs(study_id);</span><br><span class="line">Error: index study_id_idx already exists</span><br><span class="line">sqlite&gt; .indices</span><br><span class="line">snp_idx       study_id_idx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你想要删除索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; DROP INDEX snp_idx;</span><br><span class="line">sqlite&gt; .indices</span><br><span class="line">study_id_idx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="13-2-10-Dropping-Tables-and-Deleting-Databases">13.2.10 Dropping Tables and Deleting Databases</h3>
<p>删除表格的语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE table_name</span><br></pre></td></tr></table></figure>
<p>删除数据库的方式是直接删除 db 文件</p>
<h3 id="13-2-11-Interacting-with-SQLite-from-Python">13.2.11 Interacting with SQLite from Python</h3>
<p>通常我们直接使用sqlite 进行操作。但是如果你需要将 N 多个记录导入到数据库中，或者执行非常复杂的检索操作。你可以通过 API 互动操作。这里可以查看 python 的一个API</p>
<h4 id="Connecting-to-SQLite-databases-and-creating-tables-from-Python">Connecting to SQLite databases and creating tables from Python</h4>
<p>这里我们用到了一个python的标准库，sqlite3。</p>
<p>通过python 将大块数据插入到 SQLite 数据库中很方便。下面是一个简单的例子，如果连接到一个SQL数据库，并且创立新表</p>
<p><img src="69.png" alt=""></p>
<ol>
<li>使用 connect() 方法连接上数据库。</li>
<li>当我们想和sqlite 数据库使用python的接口进行交互，我们使用一个 Cursor 对象。通过创建 Cursor 对象，我们可以直接从数据库中调取数据。</li>
<li>创建表格的sql命令</li>
<li>执行命令</li>
<li>commit 会将变化写入到数据库中。</li>
<li>停止和数据库的连接。</li>
</ol>
<p>运行命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python create_table.py</span><br></pre></td></tr></table></figure>
<p>运行后新建了一个数据库 <em>variants.db</em> 。我们可以查看一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sqlite3 variants.db</span><br><span class="line">SQLite version 3.33.0 2020-08-14 13:23:32</span><br><span class="line">Enter &quot;.help&quot; for usage hints.</span><br><span class="line">sqlite&gt; .table</span><br><span class="line">variants</span><br><span class="line">sqlite&gt; .schema</span><br><span class="line">CREATE TABLE variants(</span><br><span class="line">        id integer primary key,</span><br><span class="line">        chrom test,</span><br><span class="line">        start integer,</span><br><span class="line">        end integer,</span><br><span class="line">        strand text,</span><br><span class="line">        rsid text);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Loading-data-into-a-table-from-Python">Loading data into a table from Python</h4>
<p>下一步我们需要将一些数据导入到 variants 表格中。在这个目录中，我们已经有了一个 tab分隔的文件 variants.txt</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat variants.txt</span></span><br><span class="line">chr10   114808901       114808902       +       rs12255372</span><br><span class="line">chr9    22125502        22125503        +       rs1333049</span><br><span class="line">chr3    46414946        46414978        +       rs333</span><br><span class="line">chr2    136608645       136608646       -       rs4988235</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>导入数据的时候，有几个需要注意的地方。首先，确保<code>data loaded into the database is clean</code> 。也就说每列都有正确的数据类型，并且缺失值转化为了 NULL （在pyhon中是None）。虽然sqlite 允许多种数据类型，但还是要做到每个字段的数据类型一致。</p>
<p>现在我们把 variants.txt 的内容导入到新建的表中。一个简单的代码如下：</p>
<p><img src="70.png" alt="70"></p>
<p><img src="71.png" alt="70"></p>
<ol>
<li>
<p>首先，我们用orderdict 来存储表格中的每个字段，并且使用 str() / int() 强制数据类型。</p>
</li>
<li>
<p>通过zip函数，将列名和值组合起来。</p>
</li>
<li>
<p>没看懂，我懂了，这里的 orderdict  应该类似于下面的 dick，就是强制转换格式的。</p>
<p>下面的 <code>dick['chrom']</code>  就是 <code>str()</code> 函数</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dick=&#123;<span class="string">&#x27;chrom&#x27;</span>:<span class="built_in">str</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dick</span><br><span class="line">&#123;<span class="string">&#x27;chrom&#x27;</span>: &lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dick[<span class="string">&#x27;chrom&#x27;</span>]</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dick[<span class="string">&#x27;chrom&#x27;</span>](<span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dick[<span class="string">&#x27;chrom&#x27;</span>](<span class="number">2019</span>)</span><br><span class="line"><span class="string">&#x27;2019&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里没有提到缺失值的处理。建议看 GitHub 的 readme</p>
</li>
<li>
<p>又没看懂<img src="72.png" alt="70"></p>
</li>
</ol>
<p>最后，我们执行一下程序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python load_variants.py variants.txt</span><br></pre></td></tr></table></figure>
<p>查看一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select * from variants;</span><br><span class="line">id  chrom  start      end        strand  rsid</span><br><span class="line">--  -----  ---------  ---------  ------  ----------</span><br><span class="line">1   chr10  114808901  114808902  +       rs12255372</span><br><span class="line">2   chr9   22125502   22125503   +       rs1333049</span><br><span class="line">3   chr3   46414946   46414978   +       rs333</span><br><span class="line">4   chr2   136608645  136608646  -       rs4988235</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里有一个问题，这里再for循环结束后，才进行 commit。 这在小的数据库里不是问题，对于超出内存的数据就是一个问题。但是如果每经过一次for循环一次，就commit 一次，就会很低效。为了解决这个问题， python 的 sqlite3 Cursor 对象有一个 exectutemany() 方法，…… （后面没看懂）</p>
<p>最后我们看看python 如何提取数据库的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn = sqlite3.connect(<span class="string">&quot;variants.db&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = conn.cursor()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>statement = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>SELECT chrom, start, end FROM variants WHERE rsid IN (&#x27;rs12255372&#x27;, &#x27;rs333&#x27;)</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.execute(statement)</span><br><span class="line">&lt;sqlite3.Cursor <span class="built_in">object</span> at <span class="number">0x2b13e8423810</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我们可以通过 c.fetchone() 来查看一行数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.fetchone()</span><br><span class="line">(<span class="string">u&#x27;chr10&#x27;</span>, <span class="number">114808901</span>, <span class="number">114808902</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.fetchone()</span><br><span class="line">(<span class="string">u&#x27;chr3&#x27;</span>, <span class="number">46414946</span>, <span class="number">46414978</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.fetchone()</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="R’s-RSQLite-Package">R’s RSQLite Package</h4>
<p>R 和 sqlite 数据库互作的包为 ：RSQLite</p>
<h3 id="13-2-12-Dumping-Databases">13.2.12 Dumping Databases</h3>
<p>sqlite 复制数据库直接复制db文件就行（这在其他数据库做不到，比附MySQL, PostgreSQL）。</p>
<p>命令行的操作方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sqlite3 variants.db &quot;.dump&quot;</span><br><span class="line">PRAGMA foreign_keys&#x3D;OFF;</span><br><span class="line">BEGIN TRANSACTION;</span><br><span class="line">CREATE TABLE variants(</span><br><span class="line">        id integer primary key,</span><br><span class="line">        chrom test,</span><br><span class="line">        start integer,</span><br><span class="line">        end integer,</span><br><span class="line">        strand text,</span><br><span class="line">        rsid text);</span><br><span class="line">INSERT INTO variants VALUES(1,&#39;chr10&#39;,114808901,114808902,&#39;+&#39;,&#39;rs12255372&#39;);</span><br><span class="line">INSERT INTO variants VALUES(2,&#39;chr9&#39;,22125502,22125503,&#39;+&#39;,&#39;rs1333049&#39;);</span><br><span class="line">INSERT INTO variants VALUES(3,&#39;chr3&#39;,46414946,46414978,&#39;+&#39;,&#39;rs333&#39;);</span><br><span class="line">INSERT INTO variants VALUES(4,&#39;chr2&#39;,136608645,136608646,&#39;-&#39;,&#39;rs4988235&#39;);</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以复制为一个新的数据库。下面这个命令将 variants.db 的所有表格他 dumps to a SQL file，然后再将这个 SQL file 的内容复制到一个新的数据库 variants-duplicate.db</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sqlite3 variants.db <span class="string">&quot;.dump&quot;</span> &gt; dump.sql</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sqlite3 variants-duplicate.db &lt; dump.sql</span></span><br></pre></td></tr></table></figure>
<p>我没看懂 dump 到底是啥。这里复制db文件就可以了啊</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cp variants.db variants-duplicate2.db</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sqlite3 variants-duplicate2.db</span></span><br><span class="line">SQLite version 3.33.0 2020-08-14 13:23:32</span><br><span class="line">Enter &quot;.help&quot; for usage hints.</span><br><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> .table</span></span><br><span class="line">variants</span><br><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> select * from variants;</span></span><br><span class="line">1|chr10|114808901|114808902|+|rs12255372</span><br><span class="line">2|chr9|22125502|22125503|+|rs1333049</span><br><span class="line">3|chr3|46414946|46414978|+|rs333</span><br><span class="line">4|chr2|136608645|136608646|-|rs4988235</span><br></pre></td></tr></table></figure>
<h1>14  Conclusion</h1>
<blockquote>
<p>while we can’t be certain what future sequencing technology will allow us to do, we can be confident that Unix, Python, and R will continue to be the foundation of modern bioinformatics.</p>
</blockquote>
<blockquote>
<p><em>Bioinformatics  Data  Skills</em>  focuses  on  a  <strong>robust  and  reproducible</strong>  approach because  this  is  the  best  context  in  which  to  develop  your  bioinformatics  skills.  <strong>Distrust  of  one’s  tools  and  data</strong>  and  awareness  of  the  numerous  pitfalls  that  can  occur during  analysis  is  one  of  the  most  important  skills  to  develop.  However,  you’ll  only fully  develop  these  skills  when  you’ve  encountered  and  been  surprised  by  serious issues in your own research</p>
</blockquote>
<h2 id="14-1-Where-to-Go-From-Here">14.1 Where to Go From Here?</h2>
<blockquote>
<p>First,  I’d  recommend  you  learn  more  <em>statistics</em>  and  <em>probability</em>.</p>
</blockquote>
<blockquote>
<p>Second,  I  would  recommend  learning  some  basic  topics  in  computer  science—especially <em>algorithms</em> and <em>data structures</em>.</p>
<p>All  too  often  researchers  reach  for  more  computational power  to  parallelize  code  that  could  easily  run  on  their  desktop  machines  if  it  were written more efficiently. (我感觉这是在说我……)</p>
</blockquote>
<blockquote>
<p>For more direction into these topics, see this chapter’s README file on GitHub. I’ve included my favorite books on these subjects there—and will continue to add others as I discover them. （一定要看readme）</p>
</blockquote>
<blockquote>
<p>Finally, the last piece of advice I can give you in your path toward becoming  a  skilled  bioinformatician  is  to  <em>use  the  source</em>.  In  other  words,  read  code,and  read  lots  of  code—(especially  from  programmers  who  are  more  skilled  than you).  Developing  programming  skills  is  90%  about  experience—writing,  debugging,and  wrestling  with  code  for  years  and  years.  But  reading  and  learning  from  others’ code is like a secret shortcut in this process.（看别人的代码）</p>
</blockquote>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>生物信息</tag>
      </tags>
  </entry>
  <entry>
    <title>Fortran95程序设计基础学习笔记</title>
    <url>/posts/f06ad5f5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>很多人都说，彭国伦老师的这本书是很经典的Fortran基础书籍。我看完了，感觉确实深入浅出，除了让我对Fortran语言有一定的了解，而且让我对一些计算机方面的基础概念更加清晰了。</p>
<p>但是如果仅仅针对 Fortran 而言，我可能以后不会考虑用Fortran写代码。我的理由很肤浅，Fortran 代码的可读性太差了，更别提之前版本的 goto 语法。如果让我看一个别人写的很长的 Fortran 代码，我觉得这是一种谋杀。</p>
<span id="more"></span>
<h1>准备工作</h1>
<p>运行fortran 需要编译器。我这里用的gfortran，在 linux 系统下运行，而且免费。</p>
<h2 id="安装gfortran">安装gfortran</h2>
<p><a href="https://blog.csdn.net/yangle4695/article/details/51533770">https://blog.csdn.net/yangle4695/article/details/51533770</a></p>
<p>显示下面这条信息就说明安装好了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(base) [zhouziwen@ny ~]$ which gfortran</span><br><span class="line">/usr/bin/gfortran</span><br><span class="line">(base) [zhouziwen@ny ~]$ gfortran -v</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gfortran</span><br><span class="line">COLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/lto-wrapper</span><br><span class="line">Target: x86_64-redhat-linux</span><br><span class="line">Configured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzil                                                                                                                                la.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-                                                                                                                                zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-link                                                                                                                                er-hash-style=gnu --enable-languages=c,c++,objc,obj-c++,java,fortran,ada,go,lto --enable-plugin --enable-initfini-array -                                                                                                                                -disable-libgcj --with-isl=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/isl-install --with-cloog=/bui                                                                                                                                lddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/cloog-install --enable-gnu-indirect-function --with-tune=gen                                                                                                                                eric --with-arch_32=x86-64 --build=x86_64-redhat-linux</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>redhat 安装命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install gcc-gfortran</span><br></pre></td></tr></table></figure>
<h2 id="编译和链接">编译和链接</h2>
<p><a href="https://www.bilibili.com/video/BV1tx411u7o4?p=2">https://www.bilibili.com/video/BV1tx411u7o4?p=2</a></p>
<p>编译文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gfortran -c hello.f90 -o fcode</span><br></pre></td></tr></table></figure>
<ul>
<li>-c 需要编译的文件</li>
<li>-o 结果文件（不提供，则生成 hello.o）</li>
</ul>
<p>链接（生成一个可执行文件）：拼接各代码的过程，是编译器检查代码完整性的过程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gfortran 1.o 2.o 3.o -o 3body</span><br></pre></td></tr></table></figure>
<p>貌似这个命令能把三个绑在一起。</p>
<p><strong>编译和链接可以放在一起</strong></p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">gfortran main.f90 sub.f90 func.f90 -o <span class="number">3</span>body</span><br></pre></td></tr></table></figure>
<h1>Fortran95 程序设计基础</h1>
<h1>3 Fortran 程序设计基础</h1>
<h2 id="3-1-字符集">3-1 字符集</h2>
<p>编写Fortran 程序时所能使用的所有字符和符号</p>
<ul>
<li>英文 26个字母：不分大小写</li>
<li>数字：0-9</li>
<li>特殊符号：22个<code>:=+-*/(),.'!&quot;%&amp;;&lt;&gt;?$_&quot;</code>  ，还有一个空格</li>
</ul>
<p>注意，<strong>Fortran 大小写不分</strong>，INTEGER 和 integer 是一样的</p>
<h2 id="3-2-书面格式">3-2 书面格式</h2>
<p>Fortran 有两种编写格式：Fixed Format 是旧的，不建议使用；建议全部使用 Free Format 格式。</p>
<h3 id="3-2-1-Fixed-Format">3-2-1 Fixed Format</h3>
<p>规定了程序代码每一行中每个字段的意义。第 7 - 72 个字符是可以编写程序的字段。每一行的前5个字符只能是空格或数字，数字用来作为”行代码“。每一行的第6个字符只能是空格或”0“以外的字符。</p>
<h3 id="3-2-2-Free-Format">3-2-2 Free Format</h3>
<p>不需要在每一行的开头预留空格。</p>
<p>注意事项</p>
<ol>
<li>叹号 ！后面都是注释</li>
<li>每一行可以编写 132 个字符</li>
<li>行号放在每行程序的最前面（这个我感觉不是必须的）</li>
<li>一行程序代码的最后符合如果是 &amp; ，代表下一行程序会和这一行连接。如果一行代码开头是 &amp; ，表示它会和上一行连接。</li>
</ol>
<h2 id="3-3-数据类型">3-3 数据类型</h2>
<h3 id="整数（integeral）">整数（integeral）</h3>
<p>又分为长整型（4个字节）和短整型（2个字节）</p>
<h3 id="浮点数（real）">浮点数（real）</h3>
<p>单精度（4个字节），双精度（8个字节）</p>
<h3 id="复数（complex）">复数（complex）</h3>
<h3 id="字符（character）">字符（character）</h3>
<h3 id="逻辑判断（logical）">逻辑判断（logical）</h3>
<p>true 和 false</p>
<h2 id="3-4-数学表达式">3-4 数学表达式</h2>
<blockquote>
<p>+  - * /</p>
<p>** :  幂运算</p>
<p>( ) : 优先计算</p>
</blockquote>
<p>注意事项:</p>
<ul>
<li>乘法不能省略: 不能写AB, 必须写 A*B</li>
</ul>
<h1>4 输入输出及声明</h1>
<h2 id="4-1-输入-write-输出-print-命令">4-1 输入(write)输出(print)命令</h2>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0401</span><br><span class="line">wirte(*,*) <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="keyword">stop</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Fortran 程序通常以 program 开头,后面接一个自定义的程序名称, 可以用文件名, 如果想不出来, 可以用 main 。</p>
<p>write 表示的作用就是显示后面双引号所包含的字符串。后面的两个星号都有各自的意义，第一个星号表示输出的位置使用默认值，也就是屏幕；第二个星号则表示不特别设置输出格式。</p>
<p>有两点注意：</p>
<ol>
<li>write 后会自动换行</li>
<li>如果要打印双引号，那么要写两次双引号。</li>
</ol>
<p><strong>Fortran90 可以使用双引号或单引号来封装字符串</strong></p>
<p>stop 是终止程序，可以出现在程序的任意一个位置。但是除非必要，不要把STOP使用在主程序结束之外的其他地方。因为有太多的终止点，容易出错。</p>
<p>其实这里不需要 stop，因为主程序已经运行完毕了。</p>
<p>end 是用来封装程序代码使用的，说明程序代码已经编写完毕。</p>
<p>print 也可以打印，下面这一句和 write 一样。</p>
<p>print 不接括号，且只有一个星号，表示不限定输出格式。print 只能打印到屏幕上。作者建议<strong>只使用write</strong>，因为之后如果想输出转移到文件中，write 改起来更方便。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print *,&quot;Hello&quot;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-声明">4-2 声明</h2>
<p>声明是指：在程序代码中，程序员向编译器要求预留一些存放数据的内存空间。</p>
<h3 id="4-2-1-整数类型（integeral）">4-2-1 整数类型（integeral）</h3>
<p>声明一个整型变量的描述如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a</span><br></pre></td></tr></table></figure>
<p>但是，因为 a 定义为整型变量，因此如果计算结果有小数部分，都会被自动舍去</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">A = <span class="number">3</span>/<span class="number">2</span> <span class="comment">!A=1</span></span><br><span class="line">A = <span class="number">1</span>/<span class="number">2</span> <span class="comment">!A=0</span></span><br></pre></td></tr></table></figure>
<p>赋值为长整型和短整型的声明方法如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>(<span class="keyword">kind</span>=<span class="number">4</span>) <span class="comment">!4个字节</span></span><br><span class="line"><span class="keyword">integer</span>(<span class="keyword">kind</span>=<span class="number">2</span>) <span class="comment">!2个字节</span></span><br></pre></td></tr></table></figure>
<p>如果想同时声明多个相同数据类型的变量可以写在一行，用逗号分隔</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a,b,c</span><br></pre></td></tr></table></figure>
<p>命名规则：</p>
<ol>
<li>英文名称开头</li>
<li>不要和执行命令，主程序的名称，已声明的变量同名。</li>
</ol>
<p>Fortran90 在声明变量时，后面先写两个冒号</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a</span><br></pre></td></tr></table></figure>
<h3 id="4-2-2-浮点数（real">4-2-2 浮点数（real)</h3>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">real</span> a</span><br></pre></td></tr></table></figure>
<p>不加任何形容词时，通常会声明占用4个字节的 单精度浮点数。可以进一步准确声明，双精度更准确，但是会占用更多内存。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">4</span>) a</span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">8</span>) a</span><br></pre></td></tr></table></figure>
<p>改写上面的程序</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0407</span><br><span class="line">    <span class="keyword">real</span> :: a</span><br><span class="line">    a = <span class="number">2.5</span>+<span class="number">3.0</span>/<span class="number">2.0</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;2.5+3.0/2.0&quot;</span>,a</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里把 3 和 2 分别写成了 3.0 和 2.0 ，这是必要的操作，确保计算机在计算的时候按照”浮点数“来计算。</p>
<p>如果这里写成 <code>a=2.5+3/2</code> ，结果就会变成 3.5 。因为 3/2 会按照整型计算规则计算。</p>
<p>“有效位数“ 的 概念</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0408</span><br><span class="line">    <span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">4</span>) :: a,b</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">0.1</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a,<span class="string">&quot;+&quot;</span>,b,<span class="string">&quot;=&quot;</span>,a+b</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>我的输出结果如下（很奇怪，0.1最后为什么还有一个数字）</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1.00000000</span>     +  <span class="number">0.100000001</span>     =   <span class="number">1.10000002</span></span><br></pre></td></tr></table></figure>
<p>如果改成 a = 1000000 , b= 0.1</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1000000.00</span>     +  <span class="number">0.100000001</span>     =   <span class="number">1000000.12</span></span><br></pre></td></tr></table></figure>
<p>和教科书不一样。</p>
<p>教科书上写单精度的有效数字是6-7位。为了避免有效数字带来的误差，可以使用双精度。</p>
<p><strong>双精度有高达15位的有效数字</strong>。</p>
<p>对单精度设定很大的数时，可以采用 <strong>1E10</strong>, <strong>2.5E23</strong> 这种格式。</p>
<p>对双精度设定很大的数时，可以采用 <strong>1D10</strong>, <strong>2.5D23</strong> 这种格式。</p>
<p>应用 Fortran 数学函数库</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0409</span><br><span class="line">    <span class="keyword">real</span> :: a</span><br><span class="line">    a = <span class="number">3.14159</span>/<span class="number">2.0</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;sin(&quot;</span>,a,<span class="string">&quot;)=&quot;</span>,<span class="built_in">sin</span>(a)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Fortran 中计算平方根，可以用乘幂得到；或者调用数学函数 SQRT完成</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a=<span class="number">4.0</span>**<span class="number">0.5</span></span><br><span class="line">a=<span class="built_in">sqrt</span>(<span class="number">4.0</span>)</span><br></pre></td></tr></table></figure>
<p>开立方</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a=<span class="number">8.0</span>**(<span class="number">1.0</span>/<span class="number">3.0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="4-2-3-复数（complex）">4-2-3 复数（complex）</h3>
<h3 id="4-2-4-字符及字符串（character）">4-2-4 字符及字符串（character）</h3>
<p>声明一个字符</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">character</span> a</span><br></pre></td></tr></table></figure>
<p>声明一个字符串，同时注明最大长度</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">character</span>(len=<span class="number">10</span>) a</span><br></pre></td></tr></table></figure>
<p>字符串赋值</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a=<span class="string">&quot;hello&quot;</span></span><br><span class="line">a=<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">a=<span class="string">&quot;That&#x27;s right&quot;</span> <span class="comment">!用双引号封装时，里面任意使用单引号</span></span><br><span class="line">a=<span class="string">&#x27;That&#x27;</span><span class="string">&#x27;s right&#x27;</span> <span class="comment">!用单引号封装时，输出单引号时要连续使用两个单引号</span></span><br><span class="line">a=<span class="string">&quot;That&#x27;s &quot;</span><span class="string">&quot;right&quot;</span><span class="string">&quot;.&quot;</span> <span class="comment">!用双引号封装时，输出双引号也要连用两个双引号</span></span><br></pre></td></tr></table></figure>
<p>注意，Fortran 是变量名不区分大小写，但是字符串里的字符大小写是区分的，因为这是数据。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0412</span><br><span class="line">    <span class="keyword">character</span> a</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">10</span>) b</span><br><span class="line">    a = <span class="string">&#x27;H&#x27;</span></span><br><span class="line">    b = <span class="string">&#x27;ello&#x27;</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a,b</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello</span><br></pre></td></tr></table></figure>
<p>字符串可以一次只改变其中的几个字符（报错，我估计不能修改）</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0413</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) string</span><br><span class="line">    string = <span class="string">&quot;Good morning.&quot;</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) string</span><br><span class="line">    string(<span class="number">6</span>) = <span class="string">&quot;evening.&quot;</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) string</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">EX0413.F90:<span class="number">6.21</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(*,*) string(<span class="number">6</span>)</span><br><span class="line">                     <span class="number">1</span></span><br><span class="line">Error: Syntax error <span class="keyword">in</span> <span class="built_in">WRITE</span> statement at (<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>切片可以</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">write</span>(*,*) string(<span class="number">1</span>:<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>拼接字符串</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0414</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">6</span>) first</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">10</span>) second</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) add</span><br><span class="line">    first = <span class="string">&quot;Happy&quot;</span></span><br><span class="line">    second = <span class="string">&quot;Birthday&quot;</span></span><br><span class="line">    add = first//second <span class="comment">!两个连续的/表示拼接</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) add</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Happy Birthday</span><br></pre></td></tr></table></figure>
<p>其他函数</p>
<table>
<thead>
<tr>
<th>char(num)</th>
<th>返回ASCII表上数字num表示的字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>ichar(num)</td>
<td>返回字符在ASCII表上的编号</td>
</tr>
<tr>
<td>len(string)</td>
<td>返回输入字符串的<strong>声明</strong>长度</td>
</tr>
<tr>
<td>len_trim(string)</td>
<td>返回字符串去除尾端空格后的实际空格长度</td>
</tr>
<tr>
<td>index(string, key)</td>
<td>返回 key 子字符串在string中第一次出现的位置（索引应该是从1开始）</td>
</tr>
<tr>
<td>trim(string)</td>
<td>返回把string 字符串尾端多余空格清除过后的字符串</td>
</tr>
</tbody>
</table>
<h3 id="4-2-5-逻辑变量（logical">4-2-5 逻辑变量（logical)</h3>
<p>声明变量</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">logical</span> a</span><br><span class="line">a = .true. <span class="comment">!前后有两个点</span></span><br><span class="line">a = .false. </span><br></pre></td></tr></table></figure>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0416</span><br><span class="line">    <span class="keyword">logical</span> a,b</span><br><span class="line">    a = .true.</span><br><span class="line">    b = .false.</span><br><span class="line">    <span class="built_in">write</span>(*,*) a,b</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果只打印 T F</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T F</span><br></pre></td></tr></table></figure>
<h2 id="4-3-输入命令（read）">4-3 输入命令（read）</h2>
<p>通过键盘输入</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0417</span><br><span class="line">    <span class="keyword">integer</span> a </span><br><span class="line">    read(*,*) a</span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>read 命令中第一个*号表示使用默认的设备（键盘），第二个*号表示不指定输入格式。</p>
<p>同一行输入多个值（以空格或逗号分隔，或者每输入一个数按一次enter）</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0418</span><br><span class="line">    <span class="keyword">real</span> a,b,c</span><br><span class="line">    read(*,*) a,b,c</span><br><span class="line">    <span class="built_in">write</span>(*,*) a+b+c</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>如果需要输入字符串，字符串中间如果有空格，会被截断，视为两个字符串</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0419</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) a</span><br><span class="line">    read(*,*) a</span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">(base) [zhouziwen@ny gfortran]$ ./ex0419</span><br><span class="line">Happy Birthday <span class="comment">!输入</span></span><br><span class="line"> Happy <span class="comment">!输出</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解决办法是不要用默认的格式读取数据，这是需要格式化输入输出的原因之一。</p>
<h2 id="4-4-格式化输入输出（format）">4-4 格式化输入输出（format）</h2>
<p>格式化输入输出的用处</p>
<ol>
<li>美观</li>
<li>有时读取数据必须要格式化输入</li>
</ol>
<h3 id="4-4-1-格式化输出概论">4-4-1 格式化输出概论</h3>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0420</span><br><span class="line">    <span class="keyword">integer</span> a</span><br><span class="line">    a = <span class="number">100</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="number">100</span>) a <span class="comment">!使用行代码100的地方设置的格式来输出变量a</span></span><br><span class="line">    <span class="number">100</span> <span class="keyword">format</span>(I4) <span class="comment">!最前面的100是行代码</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面这个程序只会使用4个字符宽来输出整数。</p>
<p>通过使用相同的行代码，第四行的数字会通过第五行的格式输出，其中 I4 是说用4列来显示整数a的数值。</p>
<p>fortran 90 只要在每一行的开头设置一个数字，就能取一个行代码。</p>
<p>下面是格式化输出的例子， 1X 应该是输出右跳过1个位置（就是说从第二个位置输出，默认前面存在一个空格）</p>
<p>这种就不需要用什么行代码了，相比之下我也喜欢这种方式。</p>
<p>好处有：</p>
<ol>
<li>减少行数</li>
<li>提高代码可读性。不用向上面那样还要找format语句行。</li>
<li>避免在程序中使用行号</li>
</ol>
<p>缺点是</p>
<ol>
<li>输出格式很麻烦时，编写复杂</li>
<li>在不同的地方使用相同的输出格式时，程序代码会重复（这个我不觉得是缺点，相比于代码重复，可读性更重要）</li>
</ol>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0421</span><br><span class="line">    <span class="keyword">integer</span> a </span><br><span class="line">    <span class="keyword">real</span> b</span><br><span class="line">    <span class="keyword">complex</span> c</span><br><span class="line">    <span class="keyword">logical</span> d</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) e</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    b = <span class="number">12.34</span></span><br><span class="line">    c = (<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    d = .true.</span><br><span class="line">    e = <span class="string">&quot;Fortran&quot;</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(1X,I5)&quot;</span>) a <span class="comment">!用I来格式化整数</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(1X,F5.2)&quot;</span>) b <span class="comment">!用F来格式化浮点数</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(1X,F4.1,F4.1)&quot;</span>) c <span class="comment">!complex</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(1X,L3)&quot;</span>) d <span class="comment">!用L来输出logical</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(1X,A10)&quot;</span>) e <span class="comment">!用A来输出字符串</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(1x,a10)&quot;</span>) e <span class="comment">!a也可以</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有些时候，用 Format 也有好处，只是位置不能乱放，不然代码会很难阅读，要&quot;跳跃式阅读&quot;。（这个我在python中也感觉到了，有些人封装一堆函数，在阅读代码主体的时候，时不时就要去上面翻函数的内容）</p>
<h3 id="4-4-2-详述格式化输出">4-4-2 详述格式化输出</h3>
<p>常用的格式化输出的控制字符有5个</p>
<p>整数格式化：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0422</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(i5)&quot;</span>) <span class="number">100</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(i3)&quot;</span>) <span class="number">10000</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(i5.3)&quot;</span>) <span class="number">10</span> <span class="comment">!固定使用5个字符，至少输出3个数字</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">  <span class="number">100</span></span><br><span class="line">***     <span class="comment">!设置的长度低于真实字符长度，输出星号作为警告</span></span><br><span class="line">  <span class="number">010</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>格式化浮点数</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0422_2</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(f9.3)&quot;</span>) <span class="number">123.45</span> <span class="comment">!总共9个字符宽(不足左边补空格)，其中小数部分占3个字符宽（不足补0）</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(e15.7)&quot;</span>) <span class="number">123.45</span> <span class="comment">!用科学计数法，使用15个字符宽，其中小数部分占7个字符宽</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(e9.2e3)&quot;</span>) <span class="number">12.34</span> <span class="comment">!指数部分有3位数字</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">  <span class="number">123.450</span> <span class="comment">!不足9位，补三个空格</span></span><br><span class="line">  <span class="number">0.1234500E+03</span> <span class="comment">!总字符长度（包括后面的E+03）不足15位补空格，小数部分不足7位补0</span></span><br><span class="line"><span class="number">0.12E+002</span> <span class="comment">!指数部分不足补0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>字符串格式化</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0422_3</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(a10)&quot;</span>) <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(a3)&quot;</span>) <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">     Hello</span><br><span class="line">Hel <span class="comment">!如果设定的长度低于真实长度，会自动截取</span></span><br></pre></td></tr></table></figure>
<p>输出的位置向右移动</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0422_4</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(5x,i3)&quot;</span>) <span class="number">100</span> <span class="comment">!向右移动5位</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>换行输出 /</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0422_4</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(i3//i3)&quot;</span>) <span class="number">10</span>,<span class="number">10</span> <span class="comment">!中间两个空行</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>输出结果只有一个空行，和书上不一样</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重复地以相同的格式输出数据</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0423</span><br><span class="line">    <span class="keyword">real</span> a,b,c</span><br><span class="line">    a = <span class="number">1.0</span></span><br><span class="line">    b = <span class="number">2.0</span></span><br><span class="line">    c = <span class="number">3.0</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(3(1xf5.2))&quot;</span>) a,b,c</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1.00</span>  <span class="number">2.00</span>  <span class="number">3.00</span>、</span><br></pre></td></tr></table></figure>
<p>格式设置的字符串中，还可以放进固定要输出的字符串。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0424</span><br><span class="line">	<span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;3+4=&#x27;,i1)&quot;</span>) <span class="number">3</span>+<span class="number">4</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>+<span class="number">4</span>=<span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>另外，也可以把输出格式单独提取出来，放在一个字符串变量中。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0425</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">10</span>) fmtstring</span><br><span class="line">    fmtstring = <span class="string">&quot;(i2)&quot;</span></span><br><span class="line">    <span class="built_in">write</span>(*,fmtstring) <span class="number">3</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>这种方法的好处是，可以动态地改变输出格式。</p>
<p>输入数据一般不需要设置输入格式，除非输入数据<strong>存在空格</strong>。下面的程序可以读入长度在80字符内，包含任何字符（包括空格和逗号）的字符串。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0426</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) string</span><br><span class="line">    read(*,<span class="string">&quot;(a80)&quot;</span>) string</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(a80)&quot;</span>) string</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-5-声明的其他事项">4-5 声明的其他事项</h2>
<h3 id="4-5-1-变量名称的取名策略">4-5-1 变量名称的取名策略</h3>
<p>英文开头，下划线连接（这个应该所有语言通用）</p>
<h3 id="4-5-2-implicit-命令">4-5-2 implicit 命令</h3>
<p>Fortran 标准中有一项不好的功能，它的变量不一定要经过程序的声明才能使用，编译器会根据变量名称的第一个字母来自动决定这个变量的类型。来看一个实例。</p>
<p>下面这两个数字 fa, fb 没有经过定义就直接用了。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0427</span><br><span class="line">    read(*,*) fa, fb</span><br><span class="line">    <span class="built_in">write</span>(*,*) fa+fb</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>建议不要这么做，理由如下：</p>
<ol>
<li>先定义变量再使用，才能明白地了解程序执行时的内存使用情况。</li>
<li>变量如果不经声明就使用，很容易发生“人为错误”。</li>
</ol>
<p>举一个错误的实例</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0428</span><br><span class="line">    i = <span class="number">123</span> +<span class="number">321</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;123+321=&#x27;, i4)&quot;</span>) j</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">123</span>+<span class="number">321</span>=   <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这里本来要输出 i，但是由于<strong>打错字</strong>，写成了 j 。由于 j 没有设定任何数值，所以会输出0来。</p>
<p>作者建议，在声明前，都加上 <code>implicit none</code> 这个描述（这个命令要放在program 一行的后面，也就是第二行）</p>
<p>implicit 命令的功能是用来设置“默认类型”（即Fortran 不经过声明，由第一个字母来决定变量类型）。</p>
<p>修改 ex0428</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0428</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    i = <span class="number">123</span> +<span class="number">321</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;123+321=&#x27;, i4)&quot;</span>) j</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译报错</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">EX0428.F90:<span class="number">3.5</span>:</span><br><span class="line"></span><br><span class="line">    i = <span class="number">123</span> +<span class="number">321</span></span><br><span class="line">     <span class="number">1</span></span><br><span class="line">Error: Symbol <span class="string">&#x27;i&#x27;</span> at (<span class="number">1</span>) has no <span class="keyword">IMPLICIT</span> <span class="keyword">type</span></span><br><span class="line">EX0428.F90:<span class="number">4.34</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;123+321=&#x27;, i4)&quot;</span>) j</span><br><span class="line">                                  <span class="number">1</span></span><br><span class="line">Error: Symbol <span class="string">&#x27;j&#x27;</span> at (<span class="number">1</span>) has no <span class="keyword">IMPLICIT</span> <span class="keyword">type</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-5-3-常数的声明方法（parameter）">4-5-3 常数的声明方法（parameter）</h3>
<p>常数：固定不变的数</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0429</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> pi</span><br><span class="line">    <span class="keyword">parameter</span>(pi=<span class="number">3.14159</span>)</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(f4.2)&quot;</span>) <span class="built_in">sin</span>(pi/<span class="number">6</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">0.50</span></span><br></pre></td></tr></table></figure>
<p>设定为 parameter 后，不能再更改，不然会报错。</p>
<p>事实上，声明不声明常量，对结果没有影响。但是声明常量还是有他的价值。</p>
<ol>
<li>设置后常数后，再更改会报错，因此会降低错误发生的机会。</li>
<li>把不会改变内容的变量都设置成常数，可以增加程序执行的速度。</li>
</ol>
<p>fortran90 上面两行可以合并</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: pi=<span class="number">3.14159</span> </span><br></pre></td></tr></table></figure>
<h3 id="4-5-4-设置变量的初值">4-5-4 设置变量的初值</h3>
<p>Fortran90 可以在声明变量时直接设置初值，注意不能省略中间的两个冒号。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0430</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">real</span> :: b = <span class="number">2.0</span></span><br><span class="line">    <span class="keyword">complex</span> :: c = (<span class="number">1.0</span>, <span class="number">2.0</span>)</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: str = <span class="string">&quot;Fortran 90&quot;</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a,b,c,str</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-5-5-等价声明（equivalence）">4-5-5 等价声明（equivalence）</h3>
<p>把两个以上的变量，声明它们使用同一个内存地址，就是“等价声明”。使用同一个内存位置的变量，只要改变其中的一个变量，就会同时改变其他变量的数值，因为它们都占用同一块内存。</p>
<p>等价声明的方法如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a,b</span><br><span class="line"><span class="keyword">equivalence</span>(a,b)</span><br></pre></td></tr></table></figure>
<p>用处：</p>
<ol>
<li>节省内存</li>
<li>精简代码（相当于起了一个短的别名）</li>
</ol>
<h3 id="4-5-6-声明在程序中的结构">4-5-6 声明在程序中的结构</h3>
<p>变量需要先声明，才能赋值处理</p>
<h2 id="4-6-混合运算">4-6 混合运算</h2>
<p>“混合运算” 指的是比如一个整数加一个浮点数。因此需要先进行类型转换。</p>
<p>编译器会自动做一些类型转换的工作，但不一定对。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0431</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">integer</span> :: b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">real</span> :: c</span><br><span class="line">    c = a/b <span class="comment">!这里由于a,b是整数 a/b = 0</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(f5.2)&quot;</span>) c</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">0.00</span></span><br></pre></td></tr></table></figure>
<p>本来 c = 1/2 ，应该得到结果是 0.5。如果要获得正确答案，改写如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0432</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a=<span class="number">1</span></span><br><span class="line">    <span class="keyword">integer</span> :: b=<span class="number">2</span></span><br><span class="line">    <span class="keyword">real</span> :: c</span><br><span class="line">    c = <span class="keyword">real</span>(a)/<span class="keyword">real</span>(b) <span class="comment">!先进行类型转换</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(f5.2)&quot;</span>) c</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">0.50</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过 int() 函数将浮点数转化为整数，但是一般这个编译器可以自动地正确地进行类型转换。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0433</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a=<span class="number">1</span></span><br><span class="line">    <span class="keyword">real</span> :: b=<span class="number">2</span></span><br><span class="line">    <span class="keyword">real</span> :: c </span><br><span class="line">    c = a <span class="comment">!整数设置给浮点数地操作会自动转型</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(f5.2)&quot;</span>) c</span><br><span class="line">    c=a/b <span class="comment">!除数和被除数类型不同，结果会以浮点数来表示</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(f5.2)&quot;</span>) c</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1.00</span></span><br><span class="line"><span class="number">0.50</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里编译器自动转换是对的，但是为了确保不发生意外，最好是自己手动转换。</p>
<h2 id="4-7-Fortran90-的自定义数据类型">4-7 Fortran90 的自定义数据类型</h2>
<p>我们可以把多个基本数据来创建一个自定义数据类型。</p>
<p>比如我们把一个人的姓名，年龄，身高等信息合并到一起，组成一个 “person” 的数据类型。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0434</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="comment">!开始创建 person 这个类型</span></span><br><span class="line"><span class="keyword">type</span> :: person</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">30</span>) :: <span class="keyword">name</span> </span><br><span class="line">    <span class="keyword">integer</span> :: age</span><br><span class="line">    <span class="keyword">integer</span> :: height</span><br><span class="line">    <span class="keyword">integer</span> :: weight </span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) :: address</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span> person</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>(person) :: a <span class="comment">!声明一个person变量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;name:&quot;</span></span><br><span class="line">read(*,*) a%<span class="keyword">name</span> <span class="comment">!变量和元素以%分隔</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;age:&quot;</span></span><br><span class="line">read(*,*) a%age</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;height:&quot;</span></span><br><span class="line">read(*,*) a%height</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;weight:&quot;</span></span><br><span class="line">read(*,*) a%weight</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;address:&quot;</span></span><br><span class="line">read(*,<span class="string">&quot;(a80)&quot;</span>) a%address</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="number">100</span>) a%<span class="keyword">name</span>, a%age, a%height, a%weight</span><br><span class="line"><span class="number">100</span> <span class="keyword">format</span>(/,<span class="string">&quot;Name:&quot;</span>, a10/, <span class="string">&quot;age:&quot;</span>, i3/, <span class="string">&quot;height:&quot;</span>, i3/, <span class="string">&quot;weight:&quot;</span>, i3, <span class="string">&quot;address:&quot;</span>, a50 )</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">name</span>:</span><br><span class="line">zhouziwen</span><br><span class="line"> age:</span><br><span class="line"><span class="number">18</span></span><br><span class="line"> height:</span><br><span class="line"><span class="number">175</span></span><br><span class="line"> weight:</span><br><span class="line"><span class="number">50</span></span><br><span class="line"> address:</span><br><span class="line">jx</span><br><span class="line"></span><br><span class="line"><span class="keyword">Name</span>:zhouziwen</span><br><span class="line">age: <span class="number">18</span></span><br><span class="line">height:<span class="number">175</span></span><br><span class="line">weight: <span class="number">50</span>address:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以一次设置所有元素</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a = person(<span class="string">&quot;peter&quot;</span>, <span class="number">20</span>, <span class="number">170</span>, <span class="number">60</span>,<span class="string">&quot;Taiwan&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="4-8-kind-的使用">4-8 kind 的使用</h2>
<p>kind 是声明变量所占用的内存大小，主要是根据计算时所要使用到的有效位数以及值域范围。各类变量所保存的值域范围如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>(<span class="keyword">kind</span>=<span class="number">1</span>)  -<span class="number">128</span> ~ <span class="number">127</span></span><br><span class="line"><span class="keyword">integer</span>(<span class="keyword">kind</span>=<span class="number">2</span>)  -<span class="number">32768</span> ~ <span class="number">32767</span></span><br><span class="line"><span class="keyword">integer</span>(<span class="keyword">kind</span>=<span class="number">4</span>)  -<span class="number">2147483648</span> ~ <span class="number">2147483647</span></span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">4</span>)     ±<span class="number">1.18</span>*<span class="number">10</span>^-<span class="number">38</span> ~ ±<span class="number">3.40</span>*<span class="number">10</span>^<span class="number">38</span></span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">8</span>)     ±<span class="number">2.23</span>*<span class="number">10</span>^-<span class="number">308</span> ~ ±<span class="number">1.79</span>*<span class="number">10</span>^<span class="number">308</span></span><br></pre></td></tr></table></figure>
<p>根据取值范围判断需要的kind值（感觉没啥用）</p>
<p>哦哦，果然，作者解释了。主要原因是想在不同的机器上保存同样位数的数值，所使用的 kind 值不一定相同。而且不同的机器所能保存的值域范围也可能不太一样。这里所指的不同机器，是指“等级不同” 的机器，例如工作站和个人计算机之间。</p>
<p>说白了，就是方便程序在不同机器之间移植（目前感觉不到）。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0435</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="comment">!判断可以记录9个位数的整数kind值</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: long_int = <span class="built_in">selected_int_kind</span>(<span class="number">9</span>)</span><br><span class="line"><span class="comment">!判断可以记录3个位数的整数kind值</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: short_int = <span class="built_in">selected_int_kind</span>(<span class="number">3</span>)</span><br><span class="line"><span class="comment">!判断可以有10个有效位数，指数可以记录到50的浮点数kind值</span></span><br><span class="line"><span class="comment">!第一个数字表示需要的最大的十进制位数（10的多少次方），第二个数字表示最小的有效数字</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: long_real = <span class="built_in">selected_real_kind</span>(<span class="number">10</span>,<span class="number">50</span>)</span><br><span class="line"><span class="comment">!判断可以有3个有效位数，指数可以记录到3的浮点数kind值</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: short_real = <span class="built_in">selected_real_kind</span>(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">integer</span>(<span class="keyword">kind</span>=long_int) :: a = <span class="number">12345678</span></span><br><span class="line"><span class="keyword">integer</span>(<span class="keyword">kind</span>=short_int) :: b = <span class="number">12</span></span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=long_real) :: c = <span class="number">1.23456789D45</span></span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=short_real) :: d = <span class="number">1230</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(i3,1x,i10)&quot;</span>) long_int, a</span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(i3,1x,i10)&quot;</span>) short_int, b</span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(i3,1x,e10.5)&quot;</span>) long_real, c</span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(i3,1x,e10.5)&quot;</span>) short_real, d</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>   <span class="number">12345678</span></span><br><span class="line"><span class="number">2</span>         <span class="number">12</span></span><br><span class="line"><span class="number">8</span> <span class="number">.12346E+46</span></span><br><span class="line"><span class="number">4</span> <span class="number">.12300E+04</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>除了在声明的时候指定字符宽度，设置数值时同样可以赋值数字所使用的 KIND 值类型，但这不常用，例子如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0436</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">4</span>) :: a</span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">8</span>) :: b</span><br><span class="line">a = <span class="number">1.0_4</span> <span class="comment">!确保使用单精度</span></span><br><span class="line">b = <span class="number">1.0_8</span> <span class="comment">!确保使用双精度</span></span><br><span class="line"><span class="built_in">write</span>(*,*) a,b</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1.00000000</span>       <span class="number">1.0000000000000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-9-习题">4-9 习题</h2>
<p>1 输出字符串</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0437</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Have a good time&quot;</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;That&#x27;s not bad&quot;</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot; &quot;</span><span class="string">&quot;Mary&quot;</span><span class="string">&quot; isn&#x27;t my name.&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">Have a good time</span><br><span class="line">That<span class="string">&#x27;s not bad</span></span><br><span class="line"><span class="string"> &quot;Mary&quot; isn&#x27;</span>t my <span class="keyword">name</span>.</span><br></pre></td></tr></table></figure>
<p>2 计算圆的面积</p>
<p>下面这种，把parameter 放在 read 后面会报错。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0438</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> radius,area</span><br><span class="line">    <span class="keyword">real</span> pi</span><br><span class="line">    read(*,*) radius</span><br><span class="line">    <span class="keyword">parameter</span>(pi=<span class="number">3.14159</span>)</span><br><span class="line">    area = pi*(radius**<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(f9.3)&quot;</span>) area</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>报错如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">EX0438.F90:<span class="number">6.25</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span>(pi=<span class="number">3.14159</span>)</span><br><span class="line">                         <span class="number">1</span></span><br><span class="line">Error: Unexpected <span class="keyword">PARAMETER</span> statement at (<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>调整顺序后如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0438</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> radius,area,pi</span><br><span class="line">    <span class="keyword">parameter</span>(pi=<span class="number">3.14159</span>)</span><br><span class="line">    read(*,*) radius</span><br><span class="line">    area = pi*(radius**<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(f9.3)&quot;</span>) area</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line">   <span class="number">12.566</span></span><br></pre></td></tr></table></figure>
<p>3 调整成绩，对输入值平方后乘以10</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0438</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> old_num, new_num</span><br><span class="line">    read(*,*) old_num</span><br><span class="line">    new_num = <span class="number">10</span>*(old_num**<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(f9.3)&quot;</span>) new_num</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line">   <span class="number">40.000</span></span><br></pre></td></tr></table></figure>
<p>4 请问下面程序的输出结果是什么</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0440</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> a,b</span><br><span class="line"><span class="keyword">real</span> ra,rb</span><br><span class="line">a=<span class="number">2</span></span><br><span class="line">b=<span class="number">3</span></span><br><span class="line">ra=<span class="number">2.0</span></span><br><span class="line">rb=<span class="number">3.0</span></span><br><span class="line"><span class="built_in">write</span>(*,*) b/a</span><br><span class="line"><span class="built_in">write</span>(*,*) rb/ra</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>应该是 1 1.5</p>
<p>输出结果如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">        <span class="number">1</span></span><br><span class="line"><span class="number">1.50000000</span></span><br></pre></td></tr></table></figure>
<p>5 自定义类型，定义一个新的类型 distance 。有 3个浮点数的元素，分别以米、厘米、英寸为单位来记录同一段长度。请编写一个程序，程序会以米为单位来读入一段长度，并自动计算其他单位的数值。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0441</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="comment">!创建distance这个类型</span></span><br><span class="line"><span class="keyword">type</span> :: distance</span><br><span class="line">    <span class="keyword">real</span> :: meter</span><br><span class="line">    <span class="keyword">real</span> :: centimeter</span><br><span class="line">    <span class="keyword">real</span> :: inch</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span> distance</span><br><span class="line"><span class="comment">!声明一个distance变量</span></span><br><span class="line"><span class="keyword">type</span>(distance) :: a</span><br><span class="line"><span class="comment">!输入米</span></span><br><span class="line"><span class="keyword">real</span> b</span><br><span class="line">read(*,*) b</span><br><span class="line"></span><br><span class="line">a%meter = b</span><br><span class="line">a%centimeter = <span class="number">100</span>*b</span><br><span class="line">a%inch = <span class="number">100</span>*b/<span class="number">2.54</span></span><br><span class="line"><span class="built_in">write</span>(*,*) a</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">   <span class="number">1.00000000</span>       <span class="number">100.000000</span>       <span class="number">39.3700790</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>5 流程控制与逻辑运算</h1>
<h2 id="5-1-if-语句">5-1 if 语句</h2>
<p>基本语句</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (逻辑判断式) <span class="keyword">then</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ……</span><br><span class="line">    ……</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br></pre></td></tr></table></figure>
<p>用 if 来试着写一个警告车速过快的程序。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0501</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">4</span>) :: speed</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;speed:&quot;</span> </span><br><span class="line">read(*,*) speed</span><br><span class="line"><span class="keyword">if</span> ( speed &gt; <span class="number">100.0</span> ) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Slow down.&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> speed:</span><br><span class="line"><span class="number">120</span></span><br><span class="line"> Slow down.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>写一个小程序，如果一个人的体重大于身高减去100后得到的数值，代表这个人超重。</p>
<p>注意，一样需要有缩进，不然难以阅读。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0502</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">4</span>) :: height </span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">4</span>) :: weight</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;height:&quot;</span></span><br><span class="line">read(*,*) height</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;weight:&quot;</span></span><br><span class="line">read(*,*) weight</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( weight &gt; height - <span class="number">100</span> ) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Too fat&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Under control&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> height:</span><br><span class="line"><span class="number">170</span></span><br><span class="line"> weight:</span><br><span class="line"><span class="number">50</span></span><br><span class="line"> Under control</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-1-2-逻辑运算">5-1-2 逻辑运算</h3>
<p>Fortran90 的逻辑运算符共有以下几种：</p>
<ul>
<li><code>==</code> :  是否相等</li>
<li><code>/=</code> :  是否不相等</li>
<li><code>&gt;</code></li>
<li><code>&gt;=</code></li>
<li><code>&lt;</code></li>
<li><code>&lt;=</code></li>
</ul>
<p>相互关系之间的集合运算符号</p>
<ul>
<li><code>.and.</code>  : 两个表达式均成立</li>
<li><code>.or.</code></li>
<li><code>.not.</code></li>
<li><code>.eqv.</code> ： 两边表达式的逻辑运算结果相同时，整个表达式就成立</li>
<li><code>.neqv.</code>： 两边表达式的逻辑运算结果不同时，整个表达式就成立</li>
</ul>
<p>大于小于等式的运算符号优先级高于集合运算符号，例子如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((a&gt;=<span class="number">80</span>) .and. (a&lt;<span class="number">90</span>)) <span class="keyword">then</span></span><br></pre></td></tr></table></figure>
<p>判断如果风势超过10级或是降雨量超过500厘米，就停止上班上课</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0503</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span> </span><br><span class="line"><span class="keyword">integer</span> rain, windspeed</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Rain:&quot;</span></span><br><span class="line">read(*,*) rain</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Wind:&quot;</span></span><br><span class="line">read(*,*) windspeed</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( rain&gt;=<span class="number">500</span> .or. windspeed &gt;=<span class="number">10</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;停止上班上课&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;照常上班上课&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> Rain:</span><br><span class="line"><span class="number">100</span></span><br><span class="line"> Wind:</span><br><span class="line"><span class="number">8</span></span><br><span class="line"> 照常上班上课</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 if 时，可以先把逻辑运算的结果存放在逻辑变量中，再利用逻辑变量来做条件判断。利用这个方法把程序 ex0503 改写如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0504</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> rain, windspeed</span><br><span class="line"><span class="keyword">logical</span> r,w</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Rain:&quot;</span></span><br><span class="line">read(*,*) rain</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Wind:&quot;</span></span><br><span class="line">read(*,*) windspeed</span><br><span class="line"></span><br><span class="line">r = (rain &gt;= <span class="number">500</span>)</span><br><span class="line">w = (windspeed &gt;= <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r .or. w) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;停止上班上课&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;照常上班上课&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> Rain:</span><br><span class="line"><span class="number">100</span></span><br><span class="line"> Wind:</span><br><span class="line"><span class="number">8</span></span><br><span class="line"> 照常上班上课</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-1-3-多重判断-if-else-if">5-1-3 多重判断 if - else if</h3>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件<span class="number">2</span>) <span class="keyword">then</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br></pre></td></tr></table></figure>
<p>举例，90-100 分为A级，80-89 分为B级，70-79分为C级， 60-69分为D级，60分以下为E级。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0505</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> score</span><br><span class="line"><span class="keyword">character</span> grade</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Score:&quot;</span></span><br><span class="line">read(*,*) score</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( score &gt;= <span class="number">90</span> .and. score &lt;= <span class="number">100</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">80</span> .and. score &lt; <span class="number">90</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">70</span> .and. score &lt; <span class="number">80</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;C&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">60</span> .and. score &lt; <span class="number">70</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;D&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">0</span> .and. score &lt; <span class="number">60</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;E&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    grade = <span class="string">&#x27;?&#x27;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;Grade:&#x27;,A1)&quot;</span>) grade</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> Score:</span><br><span class="line"><span class="number">85</span></span><br><span class="line">Grade:B</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于多重判断，只有上一个条件不满足才会判断下一个条件，因此上一个程序可以简化如下（但是我觉得这样写不好，虽然提高了一点效率，但是降低了可读性）</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0505</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> score</span><br><span class="line"><span class="keyword">character</span> grade</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Score:&quot;</span></span><br><span class="line">read(*,*) score</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( score &gt; <span class="number">100</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;?&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">90</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">80</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">70</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;C&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">60</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;D&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">0</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;E&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    grade = <span class="string">&#x27;?&#x27;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;Grade:&#x27;,A1)&quot;</span>) grade</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-1-4-嵌套if语句">5-1-4 嵌套if语句</h3>
<p>多个if 语句嵌套</p>
<p>举例</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0508</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> x,y </span><br><span class="line"><span class="keyword">integer</span> ans</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Imput (x,y)&quot;</span></span><br><span class="line">read(*,*) x,y</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x&gt;<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> (y&gt;<span class="number">0</span>) <span class="keyword">then</span> </span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (y&lt;<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        ans = <span class="number">4</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> (y&gt;<span class="number">0</span>) <span class="keyword">then</span> </span><br><span class="line">        ans = <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (y&lt;<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        ans = <span class="number">3</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ans/=<span class="number">0</span> ) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;第&#x27;,i1,&#x27;象限&#x27;)&quot;</span>) ans</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;落在轴上&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p>输入输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> Imput (x,y)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line">第<span class="number">1</span>象限</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-2-浮点数及字符的逻辑运算">5-2 浮点数及字符的逻辑运算</h2>
<h3 id="5-2-1-浮点数的逻辑判断">5-2-1 浮点数的逻辑判断</h3>
<p>使用浮点数来做逻辑运算时，要避免使用“等于”的判断。因为使用浮点数做计算时，有效位数是有限的，难免会出现计算上的误差，理想中的等号不一定会成立。要使用浮点数来做“等于”的逻辑判断时，最好用其他方法来取代。来看看下面的例子</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0509</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> :: a</span><br><span class="line"><span class="keyword">real</span> :: b = <span class="number">3.0</span></span><br><span class="line"></span><br><span class="line">a = <span class="built_in">sqrt</span>(b)**<span class="number">2</span> -b</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">0.0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;a 等于0&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;a不等于0&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然理论上 a = (根号b)^2^  - b = 0。但是用程序执行出来的结果却不见得是0，因为这里求根号时，得到的结果是保留了有效数字的，因此一开始就有误差。</p>
<p>浮点数的计算误差经常发生，所以在判断式中，要给误差预留一点空间。改写上面的例子</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0509</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> :: a</span><br><span class="line"><span class="keyword">real</span> :: b = <span class="number">3.0</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: e = <span class="number">0.0001</span> <span class="comment">!设置误差范围</span></span><br><span class="line"></span><br><span class="line">a = <span class="built_in">sqrt</span>(b)**<span class="number">2</span> -b</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(a-<span class="number">0.0</span>) &lt;= e) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;a 等于0&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;a不等于0&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-2-2-字符的逻辑判断">5-2-2 字符的逻辑判断</h3>
<p>除了数字可以比大小，字符也可以比大小（实际是比ASCII码）</p>
<p>用一个程序读取两个字符串来做比较</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0511</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">character</span>(len=<span class="number">20</span>) :: str1,str2</span><br><span class="line"><span class="keyword">character</span> relation</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;String 1:&quot;</span></span><br><span class="line">read(*,<span class="string">&quot;(a20)&quot;</span>) str1</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;String 2:&quot;</span></span><br><span class="line">read(*,<span class="string">&quot;(a20)&quot;</span>) str2</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str1 &gt; str2) <span class="keyword">then</span></span><br><span class="line">    relation = <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (str1 == str2) <span class="keyword">then</span></span><br><span class="line">    relation = <span class="string">&#x27;=&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    relation = <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;string1&#x27;,a1,&#x27;string2&#x27;)&quot;</span>) relation</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> String <span class="number">1</span>:</span><br><span class="line">zh</span><br><span class="line"> String <span class="number">2</span>:</span><br><span class="line">zi</span><br><span class="line">string1&lt;string2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-3-select-case-语句">5-3 select case 语句</h2>
<p>除了if 外，多重判断的另一种方法（我不喜欢用这个）</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0512</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> score</span><br><span class="line"><span class="keyword">character</span> grade</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Score:&quot;</span></span><br><span class="line">read(*,*) score</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">case</span>(score)</span><br><span class="line"><span class="keyword">case</span>(<span class="number">90</span>:<span class="number">100</span>)</span><br><span class="line">    grade = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">case</span>(<span class="number">80</span>:<span class="number">89</span>)</span><br><span class="line">    grade = <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">case</span>(<span class="number">70</span>:<span class="number">79</span>)</span><br><span class="line">    grade = <span class="string">&#x27;C&#x27;</span></span><br><span class="line"><span class="keyword">case</span>(<span class="number">60</span>:<span class="number">69</span>)</span><br><span class="line">    grade = <span class="string">&#x27;D&#x27;</span></span><br><span class="line"><span class="keyword">case</span>(<span class="number">0</span>:<span class="number">59</span>)</span><br><span class="line">    grade = <span class="string">&#x27;E&#x27;</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">default</span> <span class="comment">!其他情况</span></span><br><span class="line">    grade = <span class="string">&#x27;?&#x27;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">select</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;Grade:&#x27;,a1)&quot;</span>) grade</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>事实上，select case 中的判断经常不是判断是否落在一个数值范围内，而是判断是否等于某个数值。</p>
<p>语法如下：其中 case default 语句不是必需的。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">case</span>(变量)</span><br><span class="line"><span class="keyword">case</span> (数值<span class="number">1</span>)</span><br><span class="line">……</span><br><span class="line"><span class="keyword">case</span> (数值<span class="number">2</span>)</span><br><span class="line">……</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">default</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">select</span></span><br></pre></td></tr></table></figure>
<p>case 详细解释如下</p>
<blockquote>
<p>case(1)  变量=1</p>
<p>case(1:5)  1&lt;=变量&lt;=5</p>
<p>case(1: )   1&lt;=变量</p>
<p>case( :5)   变量 &lt;= 5</p>
<p>case(1,3,5)  变量等于1或3或5</p>
</blockquote>
<p>使用 selct case ，相比于 if ，看上去更加整洁。不过使用 select case 有一些限制：</p>
<ol>
<li>只能使用整数，字符，及逻辑变量，<strong>不能使用浮点数</strong>和复数。</li>
<li>每个 case 中所使用的数值必须是<strong>固定的常量</strong>（parameter），不能使用变量。</li>
</ol>
<h2 id="5-4-其他流程控制">5-4 其他流程控制</h2>
<h3 id="5-4-1-goto">5-4-1 goto</h3>
<p>fortran77 的老语句，不建议使用。</p>
<h3 id="5-4-3-pause-continue-stop">5-4-3 pause, continue, stop</h3>
<p>pause 的功能是当程序执行到 pause 时，会暂停执行，直到用户按下 enter 键才会继续执行。（目前我不知哪里需要用到这个）</p>
<p>continue 没有实际用途，就是放那和不放一样，用不到</p>
<p>stop 结束程序执行，小心使用（貌似类似于shell 的 exit）。</p>
<h2 id="5-5-习题">5-5 习题</h2>
<p>1 判断个人所得税</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0513</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> wage</span><br><span class="line"><span class="keyword">real</span> tax</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;wage:&quot;</span></span><br><span class="line">read(*,*) wage</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (wage &gt; <span class="number">0</span> .and. wage &lt; <span class="number">1000</span>) <span class="keyword">then</span></span><br><span class="line">    tax = <span class="number">0.03</span> * wage</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (wage &gt;=<span class="number">1000</span> .and. wage &lt; <span class="number">5000</span>) <span class="keyword">then</span></span><br><span class="line">    tax = <span class="number">0.1</span> * wage</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (wage &gt;= <span class="number">5000</span>) <span class="keyword">then</span></span><br><span class="line">    tax = <span class="number">0.15</span> * wage</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Error: wage must be a positive number&quot;</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;wage:&#x27;,f9.2,&#x27; tax:&#x27;,f9.2)&quot;</span>) wage,tax</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> wage:</span><br><span class="line"><span class="number">6000</span></span><br><span class="line">wage:  <span class="number">6000.00</span> tax:   <span class="number">900.00</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>输入星期几查询当晚的电视节目</li>
</ol>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0514</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> day</span><br><span class="line"><span class="keyword">character</span> tv</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Today is:&quot;</span></span><br><span class="line">read(*,*) day</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((day == <span class="number">1</span>) .or. (day ==<span class="number">4</span>)) <span class="keyword">then</span></span><br><span class="line">    tv = <span class="string">&#x27;新闻&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((day == <span class="number">2</span>) .or. (day ==<span class="number">5</span>)) <span class="keyword">then</span></span><br><span class="line">    tv = <span class="string">&#x27;电视剧&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((day == <span class="number">3</span>) .or. (day ==<span class="number">6</span>)) <span class="keyword">then</span></span><br><span class="line">    tv = <span class="string">&#x27;卡通片&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">7</span>) <span class="keyword">then</span></span><br><span class="line">    tv = <span class="string">&#x27;电影&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Error: day must be 1 to 7&quot;</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;tv is&#x27;,a3)&quot;</span>) tv</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码没错，但是中文显示不出来</p>
<p>错了，错了。</p>
<p>注意下面这两句的区别。上面只是设置为一个单个字符，下面才是字符串</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">character</span> tv</span><br><span class="line"><span class="keyword">character</span>(len=<span class="number">10</span>) tv</span><br></pre></td></tr></table></figure>
<p>3 个人所得税根据年纪和收入计算</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0515</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> year</span><br><span class="line"><span class="keyword">real</span> wage_year,wage,tax</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;how old are you?&quot;</span></span><br><span class="line">read(*,*) year</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Wage in a year:&quot;</span></span><br><span class="line">read(*,*) wage_year</span><br><span class="line"></span><br><span class="line">wage = wage_year/<span class="number">12</span> <span class="comment">!月收入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (year &lt; <span class="number">50</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> (wage &lt; <span class="number">1000</span>) <span class="keyword">then</span></span><br><span class="line">        tax = wage_year * <span class="number">0.03</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wage &lt; <span class="number">5000</span>) <span class="keyword">then</span></span><br><span class="line">        tax = wage_year * <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tax = wage_year * <span class="number">0.15</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (wage &lt; <span class="number">1000</span>) <span class="keyword">then</span></span><br><span class="line">        tax = wage_year * <span class="number">0.05</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wage &lt; <span class="number">5000</span>) <span class="keyword">then</span></span><br><span class="line">        tax = wage_year * <span class="number">0.07</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tax = wage_year * <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(f9.2)&quot;</span>) tax</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> how old are you?</span><br><span class="line"><span class="number">25</span></span><br><span class="line"> Wage <span class="keyword">in</span> a year:</span><br><span class="line"><span class="number">120000</span></span><br><span class="line"> <span class="number">18000.00</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4 输入年份，判断天数（老题目了）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">program ex0516</span><br><span class="line">implicit none</span><br><span class="line">integer year,days</span><br><span class="line"></span><br><span class="line">write(*,*) &quot;Year:&quot;</span><br><span class="line">read(*,*) year</span><br><span class="line"></span><br><span class="line">if (mod(year,100) &#x3D;&#x3D; 0) then !被100整除</span><br><span class="line">    if (mod(year,400) &#x3D;&#x3D; 0) then !又被400整除</span><br><span class="line">        days &#x3D; 366</span><br><span class="line">    else</span><br><span class="line">        days &#x3D; 365</span><br><span class="line">    end if </span><br><span class="line">else !不能被100整除</span><br><span class="line">    if (mod(year,4) &#x3D;&#x3D; 0) then !被4整除</span><br><span class="line">        days &#x3D; 366</span><br><span class="line">    else</span><br><span class="line">        days &#x3D; 365</span><br><span class="line">    end if </span><br><span class="line">end if </span><br><span class="line"></span><br><span class="line">write(*, &quot;(&#39;days of year &#39;,i4,&#39; is &#39;,i3)&quot;) year,days</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> Year:</span><br><span class="line"><span class="number">2000</span></span><br><span class="line">days of <span class="number">2000</span> is <span class="number">366</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>6 循环</h1>
<p>循环可以用来自动重复执行某一段程序代码，善用循环可以让程序代码变得很精简。</p>
<p>循环又两种执行格式，第一种格式会固定重复程序代码 n 次。另一种格式着是不固定重复几次，一直执行到出现跳出循环的命令为止。</p>
<h2 id="6-1-do">6-1 do</h2>
<p>说 10 次 happy birthday</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0601</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> counter</span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: lines = <span class="number">10</span></span><br><span class="line"><span class="comment">! counter &lt;= lines 会一直循环，每执行一次循环 counter 加 1</span></span><br><span class="line"><span class="comment">! counter 称之为 计数器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> counter=<span class="number">1</span>,lines,<span class="number">1</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Happy Birthday&quot;</span>, counter</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">Happy Birthday           <span class="number">1</span></span><br><span class="line">Happy Birthday           <span class="number">2</span></span><br><span class="line">Happy Birthday           <span class="number">3</span></span><br><span class="line">Happy Birthday           <span class="number">4</span></span><br><span class="line">Happy Birthday           <span class="number">5</span></span><br><span class="line">Happy Birthday           <span class="number">6</span></span><br><span class="line">Happy Birthday           <span class="number">7</span></span><br><span class="line">Happy Birthday           <span class="number">8</span></span><br><span class="line">Happy Birthday           <span class="number">9</span></span><br><span class="line">Happy Birthday          <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再看一个例子，使用循环计算 2+4+……+10</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0602</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: limit = <span class="number">10</span></span><br><span class="line"><span class="keyword">integer</span> counter</span><br><span class="line"><span class="keyword">integer</span> :: ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> counter=<span class="number">2</span>,limit,<span class="number">2</span></span><br><span class="line">    ans = ans + counter</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>增值（我叫步长）也可以设置为负值。</p>
<p>嵌套循环</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0603</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> i,j</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">3</span></span><br><span class="line">    <span class="keyword">do</span> j=<span class="number">1</span>,<span class="number">3</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(i2,i2)&quot;</span>) i,j</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;another cycle&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line">another <span class="keyword">cycle</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line">another <span class="keyword">cycle</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line">another <span class="keyword">cycle</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-2-do-while-循环">6-2 do while 循环</h2>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> <span class="keyword">while</span> (逻辑运算) <span class="comment">!成立就一直重复执行</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>以这个方法改写 2+4+……10</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0604</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: limit = <span class="number">10</span> </span><br><span class="line"><span class="keyword">integer</span> counter</span><br><span class="line"><span class="keyword">integer</span> :: ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">counter = <span class="number">2</span> </span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span> (counter &lt;= limit)</span><br><span class="line">    ans = ans + counter</span><br><span class="line">    counter = counter + <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) ans</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是 do while 一般不是处理这种任务的，do while 处理的任务一般是不知道要循环几次的。</p>
<p>蔡小姐把她的体重视为秘密，不过这里有个程序可以让大家猜她的体重。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0605</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: weight = <span class="number">45.0</span> <span class="comment">!答案</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: e = <span class="number">0.001</span> <span class="comment">!误差</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">real</span> :: guess = <span class="number">0.0</span> <span class="comment">!猜测值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span> ( <span class="built_in">abs</span>(guess - weight) &gt; e )</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;weight:&quot;</span></span><br><span class="line">    read(*,*) guess</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;You&#x27;re right&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-3-循环的流程控制">6-3 循环的流程控制</h2>
<h3 id="6-3-1-cycle">6-3-1 cycle</h3>
<p>等同于 python 的 continue</p>
<p>假设百货公司共有9层楼，但电梯在4层不停，显示电梯灯号显示情况</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0606</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: dest = <span class="number">9</span></span><br><span class="line"><span class="keyword">integer</span> <span class="built_in">floor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> <span class="built_in">floor</span>=<span class="number">1</span>, dest</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">floor</span> == <span class="number">4</span>) <span class="keyword">cycle</span> <span class="comment">!if 就一行可以这么写</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="built_in">floor</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出如下，跳过了 4</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="6-3-2-exit">6-3-2 exit</h3>
<p>相当于 python 的 break</p>
<p>改写前面的猜体重的程序</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0607</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: weight = <span class="number">45.0</span> <span class="comment">!答案</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: e = <span class="number">0.001</span> <span class="comment">!误差</span></span><br><span class="line"><span class="keyword">real</span> :: guess </span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span> (.true.)</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;weight:&quot;</span></span><br><span class="line">    read(*,*) guess</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(guess - weight) &lt; e) <span class="keyword">exit</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;You&#x27;re right&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里用到了死循环，必须要用 exit</p>
<h3 id="6-3-3-署名的循环">6-3-3 署名的循环</h3>
<p>给循环取名字，避免多层循环弄错</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0608</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> i,j</span><br><span class="line"></span><br><span class="line">outter: <span class="keyword">do</span> i = <span class="number">1</span>,<span class="number">3</span> <span class="comment">!循环取名为outter</span></span><br><span class="line">    inner: <span class="keyword">do</span> j = <span class="number">1</span>,<span class="number">3</span> <span class="comment">!循环取名为inner</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;(&#x27;,i2,&#x27;,&#x27;,i2,&#x27;)&#x27;)&quot;</span>) i,j</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> inner</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span> outter </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">( <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">( <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">( <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">( <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">( <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">( <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">( <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">( <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">( <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>起名字的循环，还可以使用 cycle exit 在内层直接挑出外层的循环，例子如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0609</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> i,j</span><br><span class="line"></span><br><span class="line">loop1: <span class="keyword">do</span> i = <span class="number">1</span>,<span class="number">3</span> </span><br><span class="line">    loop2: <span class="keyword">do</span> j = <span class="number">1</span>,<span class="number">3</span> </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">3</span>) <span class="keyword">exit</span> loop1 <span class="comment">!跳离 loop1</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">2</span>) <span class="keyword">cycle</span> loop2 <span class="comment">!重做 loop2</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;(&#x27;,i2,&#x27;,&#x27;,i2,&#x27;)&#x27;)&quot;</span>) i,j</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> loop2</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span> loop1</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">( <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">( <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">( <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">( <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-4-循环的应用">6-4 循环的应用</h2>
<p>实例1 求等差数列1+2+……100</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0610</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> counter</span><br><span class="line"><span class="keyword">integer</span> :: ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">do</span> counter=<span class="number">1</span>,<span class="number">100</span>,<span class="number">1</span></span><br><span class="line">    ans = ans + counter</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">write</span>(*,*) ans</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">5050</span></span><br></pre></td></tr></table></figure>
<p>实例2 列举费氏数列前10个数字</p>
<p>f0 = 0, f1 =1, fn = fn-1 + fn-2</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0611</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: counter </span><br><span class="line"><span class="keyword">integer</span> :: fn_1 = <span class="number">1</span></span><br><span class="line"><span class="keyword">integer</span> :: fn_2 = <span class="number">0</span></span><br><span class="line"><span class="keyword">integer</span> :: fn = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) fn_2</span><br><span class="line"><span class="built_in">write</span>(*,*) fn_1</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> counter = <span class="number">2</span>,<span class="number">9</span></span><br><span class="line">    fn = fn_2 + fn_1</span><br><span class="line">    <span class="built_in">write</span>(*,*) fn</span><br><span class="line">    fn_2 = fn_1</span><br><span class="line">    fn_1 = fn</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"> <span class="number">1</span></span><br><span class="line"> <span class="number">1</span></span><br><span class="line"> <span class="number">2</span></span><br><span class="line"> <span class="number">3</span></span><br><span class="line"> <span class="number">5</span></span><br><span class="line"> <span class="number">8</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实例三，做简单的密码加密、解密程序。加密方法很简单，把每个英文字母在ASCII表中的编号加2作为密码来传输，解密就是还原</p>
<p>加密程序</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0612</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> i </span><br><span class="line"><span class="keyword">integer</span> strlen</span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: key = <span class="number">2</span></span><br><span class="line"><span class="keyword">character</span>(len=<span class="number">20</span>) :: string</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;String:&quot;</span></span><br><span class="line">read(*,*) string</span><br><span class="line"></span><br><span class="line">strlen = <span class="built_in">len_trim</span>(string) <span class="comment">!字符串实际长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i = <span class="number">1</span>,strlen</span><br><span class="line">    string(i:i) = <span class="built_in">char</span>( <span class="built_in">ichar</span>(string(i:i)) + key )</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;encoded:&#x27;,a20)&quot;</span>) string</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> String:</span><br><span class="line">attack now</span><br><span class="line">encoded:cvvcem</span><br></pre></td></tr></table></figure>
<p>解密程序 ，就是把 + key 变成了  - key</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0613</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> i </span><br><span class="line"><span class="keyword">integer</span> strlen</span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: key = <span class="number">2</span></span><br><span class="line"><span class="keyword">character</span>(len=<span class="number">20</span>) :: string</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;String:&quot;</span></span><br><span class="line">read(*,*) string</span><br><span class="line"></span><br><span class="line">strlen = <span class="built_in">len_trim</span>(string) <span class="comment">!字符串实际长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i = <span class="number">1</span>,strlen</span><br><span class="line">    string(i:i) = <span class="built_in">char</span>( <span class="built_in">ichar</span>(string(i:i)) - key )</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;encoded:&#x27;,a20)&quot;</span>) string</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> String:</span><br><span class="line">cvvcem</span><br><span class="line">encoded:attack</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个代码有一个问题，输入由于没有格式化，“attack now” 实际只输入了 “attack” 。假如真的是军事命令，比如是 “attack tomorrow&quot; ，就会变成 “attack&quot; ，从明天发起攻击变成了现在就攻击，呕吼。</p>
<p>实例4，写一个小的计算程序，用户输入两个数字和计算符号来进行一次运算。运算结束后，让用户来决定要再做新的计算或结束程序</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0614</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> a,b,ans</span><br><span class="line"><span class="keyword">character</span> :: key = <span class="string">&#x27;y&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span> (key == <span class="string">&#x27;y&#x27;</span> .or. key == <span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">    read(*,*) a</span><br><span class="line">    read(*, <span class="string">&quot;(a1)&quot;</span>) key</span><br><span class="line">    read(*,*) b</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">case</span>(key)</span><br><span class="line">    <span class="keyword">case</span>(<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        ans = a+b</span><br><span class="line">    <span class="keyword">case</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        ans = a-b</span><br><span class="line">    <span class="keyword">case</span>(<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        ans = a*b</span><br><span class="line">    <span class="keyword">case</span>(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        ans = a/b</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">default</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Unknown operater &#x27;,a1)&quot;</span>) key</span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">select</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(f6.2,a1,f6.2,&#x27;=&#x27;,f6.2)&quot;</span>) a,key,b,ans</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;(Y/y) to do again. (other) to exit.&quot;</span></span><br><span class="line">    read(*,<span class="string">&quot;(a1)&quot;</span>) key</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p>输入输出如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line">*</span><br><span class="line"><span class="number">5</span></span><br><span class="line">  <span class="number">3.00</span>*  <span class="number">5.00</span>= <span class="number">15.00</span></span><br><span class="line"> (Y/y) to <span class="keyword">do</span> again. (other) to <span class="keyword">exit</span>.</span><br><span class="line">n</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-5-习题">6-5 习题</h2>
<p>1 显示相同的字符串</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0615</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> counter</span><br><span class="line"><span class="keyword">do</span> counter=<span class="number">1</span>,<span class="number">5</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Fortran&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2 计算等差数列 1+3+……99</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0616</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> counter</span><br><span class="line"><span class="keyword">integer</span> :: ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">do</span> counter=<span class="number">1</span>,<span class="number">99</span>,<span class="number">2</span></span><br><span class="line">    ans = ans + counter</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) ans</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>输出结果 2500</p>
<p>3 改变一下猜体重的程序，最多猜5次，最后要告诉用户猜没猜对。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0605</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: weight = <span class="number">45.0</span> <span class="comment">!答案</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: e = <span class="number">0.001</span> <span class="comment">!误差</span></span><br><span class="line"><span class="keyword">real</span> :: guess = <span class="number">0.0</span> <span class="comment">!猜测值</span></span><br><span class="line"><span class="keyword">integer</span> :: counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> counter=<span class="number">1</span>,<span class="number">5</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;weight:&quot;</span></span><br><span class="line">    read(*,*) guess</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(guess - weight) &lt; e) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;You&#x27;re right&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;You&#x27;re wrong&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> weight:</span><br><span class="line"><span class="number">46</span></span><br><span class="line"> weight:</span><br><span class="line"><span class="number">45</span></span><br><span class="line"> You<span class="string">&#x27;re right</span></span><br><span class="line"><span class="string"> You&#x27;</span>re wrong</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我想实现的效果是，如果猜对了，用 stop 直接退出程序，这样就不会打印 ”You’re wrong“ 了。</p>
<p>但是这里 用stop 没有直接退出程序，仅仅是退出了循环。（不清楚什么原因）</p>
<p>重写</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0605</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: weight = <span class="number">45.0</span> <span class="comment">!答案</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: e = <span class="number">0.001</span> <span class="comment">!误差</span></span><br><span class="line"><span class="keyword">real</span> :: guess = <span class="number">0.0</span> <span class="comment">!猜测值</span></span><br><span class="line"><span class="keyword">integer</span> :: counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> counter=<span class="number">1</span>,<span class="number">5</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;weight:&quot;</span></span><br><span class="line">    read(*,*) guess</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(guess - weight) &lt; e) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">exit</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(guess - weight) &lt; e) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;You&#x27;re right&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;You&#x27;re wrong&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>逻辑是这样的，如果五次都没有猜对，最后的判断肯定还是不对的。如果有一次猜对了，退出循环，guess 就是正确的值，最后的判断就是对的。</p>
<p>4 以循环来计算 1/1！+ …… 1/10！</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0618</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> counter1,counter2</span><br><span class="line"><span class="keyword">integer</span> :: ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">integer</span> :: a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> counter1=<span class="number">1</span>,<span class="number">10</span></span><br><span class="line">    <span class="keyword">do</span> counter2=<span class="number">1</span>,counter1</span><br><span class="line">        a = a * counter2</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    ans = ans + <span class="number">1.0</span>/<span class="keyword">real</span>(a) <span class="comment">!必须进行类型转换，整数改为浮点数</span></span><br><span class="line">    a = <span class="number">1</span> <span class="comment">!a重新调整为1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">write</span>(*,*) ans</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为 1</p>
<p>这个结果错了，错的地方在于 ans 的数据格式，不是整数，而是浮点数</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0618</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> counter1,counter2</span><br><span class="line"><span class="keyword">real</span> :: ans = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">integer</span> :: a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> counter1=<span class="number">1</span>,<span class="number">10</span></span><br><span class="line">    <span class="keyword">do</span> counter2=<span class="number">1</span>,counter1</span><br><span class="line">        a = a * counter2</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    ans = ans + <span class="number">1.0</span>/<span class="keyword">real</span>(a) <span class="comment">!必须进行类型转换，整数改为浮点数</span></span><br><span class="line">    a = <span class="number">1</span> <span class="comment">!a重新调整为1</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) ans</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>输出结果为：1.71828163</p>
<p>5 消除字符串的空格（<strong>?</strong>）</p>
<p>这个我只能实现到，把所有非空格的字符打印出来。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0619</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">character</span>(len=<span class="number">30</span>) string</span><br><span class="line"><span class="keyword">integer</span> length</span><br><span class="line"><span class="keyword">integer</span> counter</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;char:&quot;</span></span><br><span class="line">read(*,<span class="string">&quot;(a30)&quot;</span>) string</span><br><span class="line"></span><br><span class="line">length = <span class="built_in">len_trim</span>(string)</span><br><span class="line"><span class="keyword">do</span> counter=<span class="number">1</span>,length</span><br><span class="line">    <span class="keyword">if</span> (string(counter:counter) /= <span class="string">&quot; &quot;</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,<span class="string">&quot;(a1)&quot;</span>) string(counter:counter)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>7 数组</h1>
<h2 id="7-1-基本使用">7-1 基本使用</h2>
<h3 id="7-1-1-一维数组">7-1-1 一维数组</h3>
<p>写一个程序来记录全班5位同学的数学成绩，并提供由座号来查询成绩的功能。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0701</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: students = <span class="number">5</span></span><br><span class="line"><span class="keyword">integer</span> :: student(students)</span><br><span class="line"><span class="keyword">integer</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i = <span class="number">1</span>,students</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Number&#x27;,i2)&quot;</span>) i</span><br><span class="line">    read(*,*) student(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Query:&quot;</span></span><br><span class="line">    read(*,*) i</span><br><span class="line">    <span class="keyword">if</span> (i&lt;=<span class="number">0</span> .or. i&gt;students) <span class="keyword">exit</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) student(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Number</span> <span class="number">1</span></span><br><span class="line"><span class="number">80</span></span><br><span class="line"><span class="keyword">Number</span> <span class="number">2</span></span><br><span class="line"><span class="number">85</span></span><br><span class="line"><span class="keyword">Number</span> <span class="number">3</span></span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="keyword">Number</span> <span class="number">4</span></span><br><span class="line"><span class="number">75</span></span><br><span class="line"><span class="keyword">Number</span> <span class="number">5</span></span><br><span class="line"><span class="number">95</span></span><br><span class="line"> Query:</span><br><span class="line"><span class="number">13</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>数组的声明方法如下（相比于正常的类型，就是加了一个括号而已）</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">datatype <span class="keyword">name</span>(<span class="built_in">size</span>)</span><br></pre></td></tr></table></figure>
<p>注意：这里的size 必须为<strong>常量</strong>（直接填入数字或者是使用声明为 parameter 的常数）</p>
<p>数组取值</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">student(<span class="number">1</span>) = <span class="number">89</span> <span class="comment">!第一个元素设置为89</span></span><br></pre></td></tr></table></figure>
<p>数组的索引值不需要是常量，也可以是变量。</p>
<p>使用数组时超出范围是很危险的，绝对要避免发生这种情况。</p>
<p>如果不使用数组，这个程序会这样写，非常繁琐（如果是50个人，500个人，这样写是不可能的）：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0702</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: student1,student2,student3,student4,student5</span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Number 1&quot;</span></span><br><span class="line">read(*,*) student1</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Number 2&quot;</span></span><br><span class="line">read(*,*) student2</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Number 3&quot;</span></span><br><span class="line">read(*,*) student3</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Number 4&quot;</span></span><br><span class="line">read(*,*) student4</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Number 5&quot;</span></span><br><span class="line">read(*,*) student5</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>(.true.) </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Query:&quot;</span></span><br><span class="line">    read(*,*) i</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">case</span>(i)</span><br><span class="line">    <span class="keyword">case</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">write</span>(*,*) student1</span><br><span class="line">    <span class="keyword">case</span>(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">write</span>(*,*) student2</span><br><span class="line">    <span class="keyword">case</span>(<span class="number">3</span>)</span><br><span class="line">        <span class="built_in">write</span>(*,*) student3</span><br><span class="line">    <span class="keyword">case</span>(<span class="number">4</span>)</span><br><span class="line">        <span class="built_in">write</span>(*,*) student4</span><br><span class="line">    <span class="keyword">case</span>(<span class="number">5</span>)</span><br><span class="line">        <span class="built_in">write</span>(*,*) student5</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">default</span></span><br><span class="line">        <span class="keyword">exit</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">select</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p>最后再强调一点，数组除了可以使用基本的4种类型之外，还可以使用自定义类型。</p>
<h3 id="7-1-2-二维数组">7-1-2 二维数组</h3>
<p>声明数组大小，如果使用两个数字，它就变成二维数组。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">3</span>,<span class="number">3</span>) <span class="comment">!数组a是3×3的二维数组</span></span><br><span class="line">a(<span class="number">1</span>,<span class="number">1</span>) = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>保存整个年级5个班级，每班5个同学的数学考试成绩</p>
<p>这个程序和ex0701 很类似，差别这个是记录了几个班的学生成绩</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0703</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: classes = <span class="number">5</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: students = <span class="number">5</span></span><br><span class="line"><span class="keyword">integer</span> :: student(students, classes)</span><br><span class="line"><span class="keyword">integer</span> s <span class="comment">!用于赋值学生号码</span></span><br><span class="line"><span class="keyword">integer</span> c <span class="comment">!用于赋值班级号码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> c=<span class="number">1</span>,classes</span><br><span class="line">    <span class="keyword">do</span> s=<span class="number">1</span>,students</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Number &#x27;,i2, &#x27; of class &#x27;,i2)&quot;</span>) s,c</span><br><span class="line">        read(*,*) student(s,c)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;class:&quot;</span></span><br><span class="line">    read(*,*) c</span><br><span class="line">    <span class="keyword">if</span> (c&lt;=<span class="number">0</span> .or. c&gt;classes) <span class="keyword">exit</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;student:&quot;</span></span><br><span class="line">    read(*,*) s</span><br><span class="line">    <span class="keyword">if</span> (s&lt;=<span class="number">0</span> .or. s&gt;students) <span class="keyword">exit</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;score:&#x27;,i3)&quot;</span>) student(s,c) </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再看一个二维数组的例子，二维数组经常被拿来当作矩阵使用。</p>
<p>下面的例子可以让用户输入两个2×2矩阵的值，再把这两个矩阵相加。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0704</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: row = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: col = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span> :: matrixA(row,col)</span><br><span class="line"><span class="keyword">integer</span> :: matrixB(row,col)</span><br><span class="line"><span class="keyword">integer</span> :: matrixC(row,col)</span><br><span class="line"><span class="keyword">integer</span> r</span><br><span class="line"><span class="keyword">integer</span> c</span><br><span class="line"></span><br><span class="line"><span class="comment">!读入矩阵A的内容</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Matrix A&quot;</span></span><br><span class="line"><span class="keyword">do</span> r=<span class="number">1</span>,row</span><br><span class="line">    <span class="keyword">do</span> c=<span class="number">1</span>,col</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;A(&#x27;,i1,&#x27;,&#x27;,i1,&#x27;)=&#x27;)&quot;</span>) r,c</span><br><span class="line">        read(*,*) matrixA(r,c)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!读入矩阵B的内容</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Matrix B&quot;</span></span><br><span class="line"><span class="keyword">do</span> r=<span class="number">1</span>,row</span><br><span class="line">    <span class="keyword">do</span> c=<span class="number">1</span>,col</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;B(&#x27;,i1,&#x27;,&#x27;,i1,&#x27;)=&#x27;)&quot;</span>) r,c</span><br><span class="line">        read(*,*) matrixB(r,c)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!把矩阵A, B相加并输出结果</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Matrix A+B=&quot;</span></span><br><span class="line"><span class="keyword">do</span> r=<span class="number">1</span>,row</span><br><span class="line">    <span class="keyword">do</span> c=<span class="number">1</span>,col</span><br><span class="line">        matrixC(r,c) = matrixA(r,c) + matrixB(r,c)</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;(&#x27;,i1,&#x27;,&#x27;,i1,&#x27;)=&#x27;,i3)&quot;</span>) r,c,matrixC(r,c)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> Matrix A</span><br><span class="line">A(<span class="number">1</span>,<span class="number">1</span>)=</span><br><span class="line"><span class="number">1</span></span><br><span class="line">A(<span class="number">1</span>,<span class="number">2</span>)=</span><br><span class="line"><span class="number">1</span></span><br><span class="line">A(<span class="number">2</span>,<span class="number">1</span>)=</span><br><span class="line"><span class="number">1</span></span><br><span class="line">A(<span class="number">2</span>,<span class="number">2</span>)=</span><br><span class="line"><span class="number">1</span></span><br><span class="line"> Matrix B</span><br><span class="line">B(<span class="number">1</span>,<span class="number">1</span>)=</span><br><span class="line"><span class="number">2</span></span><br><span class="line">B(<span class="number">1</span>,<span class="number">2</span>)=</span><br><span class="line"><span class="number">2</span></span><br><span class="line">B(<span class="number">2</span>,<span class="number">1</span>)=</span><br><span class="line"><span class="number">2</span></span><br><span class="line">B(<span class="number">2</span>,<span class="number">2</span>)=</span><br><span class="line"><span class="number">2</span></span><br><span class="line"> Matrix A+B=</span><br><span class="line">(<span class="number">1</span>,<span class="number">1</span>)=  <span class="number">3</span></span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>)=  <span class="number">3</span></span><br><span class="line">(<span class="number">2</span>,<span class="number">1</span>)=  <span class="number">3</span></span><br><span class="line">(<span class="number">2</span>,<span class="number">2</span>)=  <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-1-3-多维数组">7-1-3 多维数组</h3>
<p>fortran 最高可以声明高达7维的数组。</p>
<p>看一个三维数组的实例，把上面那个矩阵相加的程序使用三维数组来改写。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0705</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: row = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: col = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span> :: matrix(row,col,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">integer</span> m</span><br><span class="line"><span class="keyword">integer</span> r</span><br><span class="line"><span class="keyword">integer</span> c</span><br><span class="line"></span><br><span class="line"><span class="comment">!读入矩阵的内容</span></span><br><span class="line"><span class="keyword">do</span> m=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Matrix &#x27;,i1)&quot;</span>) m</span><br><span class="line">    <span class="keyword">do</span> r=<span class="number">1</span>,row</span><br><span class="line">        <span class="keyword">do</span> c=<span class="number">1</span>,col</span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;(&#x27;,i1,&#x27;,&#x27;,i1,&#x27;)=&#x27;)&quot;</span>) r,c</span><br><span class="line">            read(*,*) matrix(r,c,m)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!把第1，2个矩阵相加</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Matrix 1 + Matrix 2 = &quot;</span></span><br><span class="line"><span class="keyword">do</span> r=<span class="number">1</span>,row</span><br><span class="line">    <span class="keyword">do</span> c=<span class="number">1</span>,col</span><br><span class="line">        matrix(r,c,<span class="number">3</span>) = matrix(r,c,<span class="number">1</span>) + matrix(r,c,<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;(&#x27;,i1,&#x27;,&#x27;,i1,&#x27;)=&#x27;,i3)&quot;</span>) r,c,matrix(r,c,<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-1-4-另类的数组声明">7-1-4 另类的数组声明</h3>
<p>在没有特别赋值的前提下，数组的索引值都是从1开始，例如：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">5</span>) <span class="comment">!共5个元素 a(1)-a(5)</span></span><br></pre></td></tr></table></figure>
<p>可以经过特别声明的办法来改变这个默认的规则，在声明时，可以特别赋值数组的坐标值使用范围，例如：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">0</span>:<span class="number">5</span>) </span><br><span class="line"><span class="comment">! 这个数组可以使用 a(0),a(1)……a(5) 这6个元素</span></span><br></pre></td></tr></table></figure>
<p>其他范围也是可以的。多维数组也是一样的道理。</p>
<h2 id="7-2-数组内容的设置">7-2 数组内容的设置</h2>
<p>数组也可以先设定初值</p>
<h3 id="7-2-1-赋初值">7-2-1 赋初值</h3>
<p>数组也可以像一般变量一样使用DATA 来设置数组的初值。例子如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">data</span> a /<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>/</span><br><span class="line"><span class="comment">!这样会把a的初始值设置为1-5</span></span><br></pre></td></tr></table></figure>
<p>data 的数据区还可以使用星号* 来表示数据重复</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">data</span> a /<span class="number">5</span>*<span class="number">3</span>/ <span class="comment">!5*3 在此指有5个3</span></span><br><span class="line"><span class="comment">! a(1) = a(2) = …… a(5) = 3</span></span><br></pre></td></tr></table></figure>
<p>另外有一种”隐含式“ 循环的功能可以用来设置数组的初值</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">integer</span> i</span><br><span class="line"><span class="keyword">data</span>(a(i), i=<span class="number">2</span>, <span class="number">4</span>)/<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>/</span><br><span class="line"><span class="comment">!这就是一个”隐含式”循环，i 会从2增加到4， 依照顺序到后面取数字，初值设定结果为a(2)=2,a(3)=3,</span></span><br><span class="line"><span class="comment">!a(4)=4, a(1)和a(5)没有设置</span></span><br></pre></td></tr></table></figure>
<p>“隐含” 的循环省略了 DO 的描述， 除了应用在声明的初值设置， 还可以应用在其他的程序代码中，像用来输出数组的内容</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">write</span>(*,*) (a(i), i=<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">!显示a(2),a(3),a(4)的值</span></span><br></pre></td></tr></table></figure>
<p>“隐含” 循环，只要在最后面再多加一个数字，同样可以改变计数器的累加数值，默认值为1。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">(A(i), i=<span class="number">2</span>,<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">!循环执行5次，分别为2 4 6 8 10</span></span><br></pre></td></tr></table></figure>
<p>隐含式循环也可以是多层嵌套的，所以也可以应用在多维数组上：（个人不建议）</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">integer</span> i,j</span><br><span class="line"><span class="keyword">data</span>((a(i,j), i=<span class="number">1</span>,<span class="number">2</span>),j=<span class="number">1</span>,<span class="number">2</span>) /<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>/</span><br><span class="line"><span class="comment">!里面括号的循环会先执行，设置结果为</span></span><br><span class="line">！a(<span class="number">1</span>,<span class="number">1</span>) =<span class="number">1</span> a(<span class="number">2</span>,<span class="number">1</span>)=<span class="number">2</span> a(<span class="number">1</span>,<span class="number">2</span>)=<span class="number">3</span> a(<span class="number">2</span>,<span class="number">2</span>)=<span class="number">4</span> 这个乱了</span><br></pre></td></tr></table></figure>
<p>Fortran90 中，可以省略DATA描述，直接设置初值</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>) =(/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /) <span class="comment">!注意括号和除号间不能有空格</span></span><br></pre></td></tr></table></figure>
<p>这种方式，数组的所有元素都必须给定一个初值。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>) = (/ <span class="number">1</span>,(<span class="number">2</span>,i=<span class="number">2</span>,<span class="number">4</span>),<span class="number">5</span> /)</span><br><span class="line"><span class="comment">!a(1)=1</span></span><br><span class="line"><span class="comment">!a(2)=a(3)=a(4)=2</span></span><br><span class="line"><span class="comment">!a(5)=5</span></span><br></pre></td></tr></table></figure>
<p>Fortran90 隐含式循环的功能可以更强大，例如</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>) = (/ (i,i=<span class="number">1</span>,<span class="number">5</span>) /)</span><br><span class="line"><span class="comment">! a(1)=1, a(2)=2, a(3)=3 ……</span></span><br></pre></td></tr></table></figure>
<p>把查询成绩的程序改写，学生成绩直接写在代码中</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0706</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: students = <span class="number">5</span></span><br><span class="line"><span class="keyword">integer</span> :: student(<span class="number">5</span>) = (/ <span class="number">80</span>,<span class="number">90</span>,<span class="number">85</span>,<span class="number">75</span>,<span class="number">95</span> /)</span><br><span class="line"><span class="keyword">integer</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Query:&quot;</span></span><br><span class="line">    read(*,*) i</span><br><span class="line">    <span class="keyword">if</span> (i&lt;=<span class="number">0</span> .or. i&gt;students) <span class="keyword">exit</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) student(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> Query:</span><br><span class="line"><span class="number">1</span></span><br><span class="line">          <span class="number">80</span></span><br><span class="line"> Query:</span><br><span class="line"><span class="number">2</span></span><br><span class="line">          <span class="number">90</span></span><br><span class="line"> Query:</span><br><span class="line"><span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>设置二维数组的内容，再输出到屏幕上。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0707</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: row = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: col = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span> :: m(row,col)</span><br><span class="line"><span class="keyword">integer</span> r</span><br><span class="line"><span class="keyword">integer</span> c</span><br><span class="line"><span class="keyword">data</span>((m(r,c), r=<span class="number">1</span>,<span class="number">2</span>), c=<span class="number">1</span>,<span class="number">2</span>) /<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>/</span><br><span class="line"></span><br><span class="line"><span class="comment">!按顺序输出m(1,1), m(2,1), m(1,2), m(2,2) 这4个数字</span></span><br><span class="line"><span class="comment">!在write中，用/换行</span></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(i3,i3,/,i3,i3)&quot;</span>) ((m(r,c),c=<span class="number">1</span>,<span class="number">2</span>),r=<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Fortran90 中，可以把所有数组元素都设置为一个相同的数值。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>) = <span class="number">5</span></span><br><span class="line"><span class="comment">!a(1) = a(2) = …… = a(5) =5</span></span><br></pre></td></tr></table></figure>
<h3 id="7-2-2-对整个数组的操作">7-2-2 对整个数组的操作</h3>
<p>Fortran 有一些方便的命名，可以直接操作整个数组。比如：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>这个命令将 a 的每个元素的值都设置为5。以一维的情况来看，这个命令相当于下面的程序代码：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,N</span><br><span class="line">	a(i) = <span class="number">5</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>下面这个命令设置为，a(1) =1， a(2) =2, a(3) =3，注意，这里等号右边所提供的数字数目必须跟数组a的大小一样。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> /)</span><br></pre></td></tr></table></figure>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a = b <span class="comment">!将a的元素设置和b相同</span></span><br><span class="line">a = b+c <span class="comment">!+-*/</span></span><br><span class="line">a = <span class="built_in">sin</span>(b)</span><br></pre></td></tr></table></figure>
<p>改写矩阵相加的程序。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0708</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: row = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: col = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span> :: ma(row,col) = <span class="number">1</span></span><br><span class="line"><span class="keyword">integer</span> :: mb(row,col) = <span class="number">4</span></span><br><span class="line"><span class="keyword">integer</span> :: mc(row,col)</span><br><span class="line"><span class="keyword">integer</span> :: i,j</span><br><span class="line"></span><br><span class="line">mc = ma + mb</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(i3,i3,/,i3,i3)&quot;</span>) ((mc(i,j),i=<span class="number">1</span>,<span class="number">2</span>),j=<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>  <span class="number">5</span></span><br><span class="line"><span class="number">5</span>  <span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再介绍一个特别的用法，这个需要和 where 命令搭配</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a = b &gt; c</span><br></pre></td></tr></table></figure>
<h3 id="7-2-3-对部分数组的操作">7-2-3 对部分数组的操作</h3>
<p>举例如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a(<span class="number">3</span>:<span class="number">5</span>) = <span class="number">5</span> <span class="comment">!把a(3) a(4) a(5) 内容设置为5</span></span><br><span class="line">a(<span class="number">3</span>:) =<span class="number">5</span> <span class="comment">!把a(3) 及之后的元素设置为5</span></span><br><span class="line">a(<span class="number">3</span>:<span class="number">5</span>) = (/ <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /)</span><br><span class="line">a(<span class="number">1</span>:<span class="number">3</span>) = b(<span class="number">4</span>:<span class="number">6</span>)</span><br><span class="line">a(<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>) = <span class="number">3</span> <span class="comment">!a(1)=a(3)=a(5)=3</span></span><br><span class="line">a(<span class="number">1</span>:<span class="number">10</span>) = a(<span class="number">10</span>:<span class="number">1</span>:-<span class="number">1</span>) <span class="comment">!反转</span></span><br><span class="line">a(:) = b(:, <span class="number">2</span>) <span class="comment">!a的元素设置为b的第二列</span></span><br></pre></td></tr></table></figure>
<p>要拿数组中一部分内容来使用时，只要把握两个原则就可以：</p>
<ol>
<li>
<p>等号两边所使用的数组元素数目要一样多</p>
</li>
<li>
<p>同时使用多个隐含式循环时，较低维的循环可以想象成是内层的循环。用一个实例来说明这个原则：</p>
</li>
</ol>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">2</span>,<span class="number">2</span>), b(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">b = a(<span class="number">2</span>:<span class="number">1</span>:-<span class="number">1</span>, <span class="number">2</span>:<span class="number">1</span>:-<span class="number">1</span>)</span><br><span class="line"><span class="comment">!b没特别赋值时，等于b(1:2:1, 1:2:1)</span></span><br><span class="line"><span class="comment">!低维的是内层循环，会先执行，所以这个命令结果为</span></span><br><span class="line"><span class="comment">!这个顺序和python的顺序是相反的</span></span><br><span class="line"><span class="comment">!b(1,1) = a(2,2)</span></span><br><span class="line"><span class="comment">!b(2,1) = a(1,2)</span></span><br><span class="line"><span class="comment">!b(1,2) = a(2,1)</span></span><br><span class="line"><span class="comment">!b(2,2) = a(1,1)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面用一个实例来简单示范一下本节的功能</p>
<p>源代码如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0709</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: row = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: col = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">2</span>,<span class="number">2</span>)  = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> /)</span><br><span class="line"><span class="comment">! a(1,1)=1,a(2,1)=2,a(1,2)=3,a(2,2)=4</span></span><br><span class="line"><span class="keyword">integer</span> :: b(<span class="number">4</span>) = (/ <span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> /)</span><br><span class="line"><span class="keyword">integer</span> :: c(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) a</span><br><span class="line"><span class="built_in">write</span>(*,*) a(:,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">c = a(:,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">write</span>(*,*) c</span><br><span class="line"></span><br><span class="line">c = a(<span class="number">2</span>,:)</span><br><span class="line"><span class="built_in">write</span>(*,*) c</span><br><span class="line"><span class="built_in">write</span>(*,*) c(<span class="number">2</span>:<span class="number">1</span>:-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">c = b(<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>)</span><br><span class="line"><span class="built_in">write</span>(*,*) c</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>报错了，因为下面这句话，a 是一个二维数组，却赋值给了一个一维数组的值。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">2</span>,<span class="number">2</span>)  = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> /)</span><br></pre></td></tr></table></figure>
<p>改写成如下，另外这里这里声明的 row 和 col 没有用到，可以删掉。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">integer</span> i,j</span><br><span class="line"><span class="keyword">data</span>((a(i,j),i=<span class="number">1</span>,<span class="number">2</span>),j=<span class="number">1</span>,<span class="number">2</span>) /<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>/</span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>           <span class="number">2</span>           <span class="number">3</span>           <span class="number">4</span></span><br><span class="line"><span class="number">1</span>           <span class="number">2</span></span><br><span class="line"><span class="number">1</span>           <span class="number">2</span></span><br><span class="line"><span class="number">2</span>           <span class="number">4</span></span><br><span class="line"><span class="number">4</span>           <span class="number">2</span></span><br><span class="line"><span class="number">5</span>           <span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意 <code>write(*,*) a</code> ，相当于 <code>write(1:2:1,1:2:1) a</code> ，低维的是内层循环，会先进行，所以会按照 a(1,1)  a(2,1) a(1,2)  a(2,2)  的顺序读取。</p>
<h3 id="7-2-4-where">7-2-4 where</h3>
<p>where 是 Fortran95 添加的功能。看一个实例</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0710 </span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>) = (/ (i,i=<span class="number">1</span>,<span class="number">5</span>) /)</span><br><span class="line"><span class="keyword">integer</span> :: b(<span class="number">5</span>) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!把a中小于3的元素设置给b</span></span><br><span class="line"><span class="keyword">where</span>(a&lt;<span class="number">3</span>)</span><br><span class="line">    b = a</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(5(i3,1x))&quot;</span>) b</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="number">2</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这里的 where 相当于</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">5</span></span><br><span class="line">	<span class="keyword">if</span>(a(i) &lt; <span class="number">3</span>) b(i) = a(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>虽然执行结果相同，但是使用 where 更简便，速度更快。</p>
<p>where 描述与 if 有点类似，如果程序模块只有一行命令时，同样可以把这一行命令写在where 后面，并且省略 end where。这个程序的9-11行可以改写为：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">where</span>(a&lt;<span class="number">3</span>) b=a</span><br></pre></td></tr></table></figure>
<p>where 只用于数组，而且用到的所有数组变量，都必须是<strong>同样维数和大小的数组</strong>。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>) = <span class="number">1</span></span><br><span class="line"><span class="keyword">integer</span> :: c(<span class="number">3</span>) = <span class="number">2</span></span><br><span class="line"><span class="keyword">where</span>(a/=<span class="number">0</span>) c=a</span><br><span class="line"><span class="comment">!上一行错误，维数不同</span></span><br><span class="line"><span class="keyword">where</span>(a(<span class="number">1</span>:<span class="number">3</span>)/=<span class="number">0</span>) c=a</span><br><span class="line"><span class="comment">!正确</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>where 还可以配合 elsewhere 来处理逻辑不成立的情况。来看下面的例子。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0711</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>) = (/ (i,i=<span class="number">1</span>,<span class="number">5</span>) /)</span><br><span class="line"><span class="keyword">integer</span> :: b(<span class="number">5</span>) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> (a&lt;<span class="number">3</span>)</span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line"><span class="keyword">elsewhere</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(5(i3,1x))&quot;</span>) b</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">2</span>   <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>where 还可以做多重判断，只要在 elsewhere 后面接上逻辑判断就行了</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">where</span>(a&lt;<span class="number">2</span>)</span><br><span class="line">	b=<span class="number">1</span></span><br><span class="line"><span class="keyword">elsewhere</span>(a&gt;<span class="number">5</span>)</span><br><span class="line">	b=<span class="number">2</span></span><br><span class="line"><span class="keyword">elsewhere</span> <span class="comment">!剩下2&lt;a(i)&lt;5的部分</span></span><br><span class="line">	b=<span class="number">3</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">where</span></span><br></pre></td></tr></table></figure>
<p>where 也可以嵌套，也可以起名字，不过取名的where 描述在结束时 end where 后面一定要接上名字。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">name</span>: <span class="keyword">where</span>(a&lt;<span class="number">5</span>) </span><br><span class="line">	b = a</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">where</span> <span class="keyword">name</span></span><br></pre></td></tr></table></figure>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">where</span>(a&lt;<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">where</span>(a/=<span class="number">2</span>)</span><br><span class="line">		b=<span class="number">3</span></span><br><span class="line">    <span class="keyword">elsewhere</span></span><br><span class="line">    	b=<span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">where</span></span><br><span class="line"><span class="keyword">elsewhere</span></span><br><span class="line">	b = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">where</span></span><br></pre></td></tr></table></figure>
<p>最后再看一个实例，计算10个人的所得税金额</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0712</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"><span class="keyword">real</span> :: income(<span class="number">10</span>) = (/ <span class="number">25000</span>,<span class="number">30000</span>,<span class="number">50000</span>,<span class="number">40000</span>,<span class="number">35000</span>,&amp;</span><br><span class="line">                        <span class="number">60000</span>,<span class="number">27000</span>,<span class="number">45000</span>,<span class="number">20000</span>,<span class="number">70000</span> /)</span><br><span class="line"><span class="keyword">real</span> :: tax(<span class="number">10</span>) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span>(income &lt; <span class="number">30000.0</span>)</span><br><span class="line">    tax = income*<span class="number">0.10</span></span><br><span class="line"><span class="keyword">elsewhere</span>(income &lt; <span class="number">50000.0</span>)</span><br><span class="line">    tax = income*<span class="number">0.12</span></span><br><span class="line"><span class="keyword">elsewhere</span></span><br><span class="line">    tax = income*<span class="number">0.15</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(10(f8.1,1x))&quot;</span>) tax</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">2500.0</span>   <span class="number">3600.0</span>   <span class="number">7500.0</span>   <span class="number">4800.0</span>   <span class="number">4200.0</span>   <span class="number">9000.0</span>   <span class="number">2700.0</span>   <span class="number">5400.0</span>   <span class="number">2000.0</span>  <span class="number">10500.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-2-5-forall">7-2-5 forall</h3>
<p>forall 是 Fortran95 添加的功能。它也可以看成是一种使用隐含式循环来使用数组的方式。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0713</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> i</span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">    a(i) = <span class="number">5</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line"><span class="comment">!a(1)=……=a(5)=5</span></span><br><span class="line"><span class="built_in">write</span>(*,*) a</span><br><span class="line"></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">    a(i) = i</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line"><span class="built_in">write</span>(*,*) a</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>           <span class="number">5</span>           <span class="number">5</span>           <span class="number">5</span>           <span class="number">5</span></span><br><span class="line"><span class="number">1</span>           <span class="number">2</span>           <span class="number">3</span>           <span class="number">4</span>           <span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第一段相当于</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">5</span></span><br><span class="line">	a(i) = <span class="number">5</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a(<span class="number">1</span>:<span class="number">5</span>) = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>forall 的 详细语法为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">forall</span> (triplet1[, triplet2[, triplet3……]], mask)</span><br></pre></td></tr></table></figure>
<p>triplet 是用来赋值数组坐标范围的值。</p>
<p>forall 中可以赋值好几个 triplet，数组最多有几维就可以赋值多少个。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">2</span>:<span class="number">10</span>:<span class="number">2</span>, j=<span class="number">1</span>:<span class="number">5</span>) <span class="comment">!二维数组可以用两个数字</span></span><br><span class="line">	a(i,j) = i+j</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br></pre></td></tr></table></figure>
<p>mask 是用来做条件判断，跟 where 命令中使用的条件判断类似，它可以用来限定 forall 程序模块中，只作用于数组中符合条件的元素。还可以做其他的条件限制，直接来看几个例子：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">integer</span> :: i,j</span><br><span class="line"></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>,j=<span class="number">1</span>:<span class="number">5</span>,a(i,j)&lt;<span class="number">10</span>) <span class="comment">!只处理数组a中小于10的元素</span></span><br><span class="line">	a(i,j) = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>,j=<span class="number">1</span>:<span class="number">5</span>,i==j)</span><br><span class="line"><span class="comment">!只做i==j的情况</span></span><br><span class="line">	a(i,j) = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>,j=<span class="number">1</span>:<span class="number">5</span>,((i&gt;j) .and. a(i,j) &gt; <span class="number">0</span>))</span><br><span class="line"><span class="comment">!多个判断条件</span></span><br><span class="line">	a(i,j) = <span class="number">1</span>/a(i,j)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>forall 描述中的程序模块如果只有一行程序代码时，也可以省略 end forall ， 把程序模块跟forall 写在同一行，就跟 if 及 where 的情况相同。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>, j=<span class="number">1</span>:<span class="number">5</span>, a(i,j) /= <span class="number">0</span>) a(i,j) = <span class="number">1</span>/a(i,j) </span><br></pre></td></tr></table></figure>
<p>再看一个实例，声明一个二维数组作为二维矩阵使用。它使用 forall 命令把矩阵的上半部设置为1， 对角线部分设置为2， 下半部设置为3。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0714</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> i,j</span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: <span class="built_in">size</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="built_in">size</span>,<span class="built_in">size</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="built_in">size</span>,j=<span class="number">1</span>:<span class="built_in">size</span>,i&gt;j) a(i,j) = <span class="number">1</span> <span class="comment">!上半部</span></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="built_in">size</span>,j=<span class="number">1</span>:<span class="built_in">size</span>,i==j) a(i,j) = <span class="number">2</span> <span class="comment">!对角线</span></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="built_in">size</span>,j=<span class="number">1</span>:<span class="built_in">size</span>,i&lt;j) a(i,j) = <span class="number">3</span> <span class="comment">!下半部</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(5(5i5,/))&quot;</span>) a</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>    <span class="number">1</span>    <span class="number">1</span>    <span class="number">1</span>    <span class="number">1</span></span><br><span class="line"><span class="number">3</span>    <span class="number">2</span>    <span class="number">1</span>    <span class="number">1</span>    <span class="number">1</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span>    <span class="number">2</span>    <span class="number">1</span>    <span class="number">1</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span>    <span class="number">3</span>    <span class="number">2</span>    <span class="number">1</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span>    <span class="number">3</span>    <span class="number">3</span>    <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>forall 可以写成多层的嵌套结构。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">forall</span>(j=<span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">		a(i,j) = <span class="number">2</span></span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line">	<span class="keyword">forall</span>(j=<span class="number">6</span>:<span class="number">10</span>)</span><br><span class="line">		a(i,j) = <span class="number">2</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br></pre></td></tr></table></figure>
<p>forall 中还可以嵌套 where。不过 where 当中不能使用 forall。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">where</span>(a(:,i)/=<span class="number">0</span>) </span><br><span class="line">		a(:,i) = <span class="number">1.0</span>/a(:,i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">where</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br></pre></td></tr></table></figure>
<h2 id="7-3-数组的保存规则">7-3 数组的保存规则</h2>
<p>一个数组不管是声明成什么“形状”（指维数和大小），它的所有元素都是分布再计算机内存的同一个连续模块当中。一维数组是最简单的，它的元素在内存中的排列位置刚好就依照元素的顺序。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">5</span>)</span><br><span class="line"><span class="comment">!元素在内存连续模块中的排列顺序为</span></span><br><span class="line"><span class="comment">!a(1) → a(2) → a(3) →  a(4) → a(5)</span></span><br></pre></td></tr></table></figure>
<p>多维数组的元素，在内存中的排列情况按照 “Column Major” 的方法来排列。先使用二维数组来解释，会先放入 column 中 每个 row 的元素， 第一个 column 放完了再放第二个 column。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">!a(1,1) → a(2,1) → a(3,1) (先放入第1个column中的元素)</span></span><br><span class="line"><span class="comment">!a(1,2) → a(2,2) → a(3,2) (再放入第2个column中的元素)</span></span><br><span class="line"><span class="comment">!a(1,3) → a(2,3) → a(3,3) (最后放入第3个column中的元素)</span></span><br></pre></td></tr></table></figure>
<p>引申到多维数组，会先放入较低维的元素，再放入较高维的元素。来看一个三维数组的实例</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">!a(1,1,1) → a(2,1,1) (先放入第1维)</span></span><br><span class="line"><span class="comment">!a(1,2,1) → a(2,2,1) (接着放入第2维)</span></span><br><span class="line"><span class="comment">!a(1,1,2) → a(2,1,2) (接着放入第3维)</span></span><br><span class="line"><span class="comment">!a(1,2,2) → a(2,2,2) </span></span><br></pre></td></tr></table></figure>
<p>用循环依照内存顺序读出这个数组的方法为：</p>
<p>这个有点难看懂，首先do 是内层先循环，这里维数越小的放在内层，也就是维数越小的先循环。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">	<span class="keyword">do</span> j=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">		<span class="keyword">do</span> k=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">			<span class="comment">!维越小的使用越内层的循环</span></span><br><span class="line">			<span class="built_in">write</span>(*,*) a(k,j,i)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>计算机原理：如果读取的数据比较近，速度会比较快。</p>
<p>因此，下面这种是比较不好的写法：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">	<span class="keyword">do</span> j=<span class="number">1</span>,m</span><br><span class="line">		a(i,j) = </span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>因为 a(i,j) 和 a(i,j+1) 在内存中的位置并不是连续的。下面的写法会比较好一点：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">	<span class="keyword">do</span> j=<span class="number">1</span>,m</span><br><span class="line">		a(j,i) = </span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>只要简单地把 i, j 的使用位置交换，就可以得到比较好的效率。因为 a(j,i) 和 a(j+1,i) 在内存中的位置是连续的。</p>
<p>解释过数组在内存的排列方法后，再回忆设置初值的部分，现在可以理解下面的程序为什么会有那样子的结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">2</span>,<span class="number">2</span>) = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> /)</span><br><span class="line"><span class="comment">!a(1,1)=1, a(2,1)=2, a(1,2)=3, a(2,2)=4</span></span><br><span class="line"><span class="comment">!正好是根据内存的排列顺序来设置数值</span></span><br></pre></td></tr></table></figure>
<h2 id="7-4-可变大小的数组">7-4 可变大小的数组</h2>
<p>某些情况下，要等程序执行之后，才会知道所需要使用的数组大小。</p>
<p>如果数组大小不能改变，只能这么编写程序：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0715</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: <span class="built_in">max</span> = <span class="number">1000</span></span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="built_in">max</span>) <span class="comment">!先声明一个超级大的数组</span></span><br><span class="line"><span class="keyword">integer</span> :: students</span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;How many students:&quot;</span></span><br><span class="line">read(*,*) students <span class="comment">!输入的数值不能超过 max</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!输入成绩</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,students</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Number &#x27;,i3)&quot;</span>) i</span><br><span class="line">    read(*,*) a(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> How many students:</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="keyword">Number</span>   <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">Number</span>   <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个做法是无可奈何的做法，首先声明一个超大的数组，然后再来使用数组的一小部分。</p>
<p>Fortran90 的数组则可以等到程序执行后，根据需求来实时决定它的大小。来看看下面的写法</p>
<p>这里用一个 ：表示 a是一维数组</p>
<p>分配内存空间的值可以使用变量，不像在声明一般数组时需要使用常量。</p>
<p>deallocate 可以释放内存。使用这两个命令可以用来重新设置数组大小。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0716</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: students</span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">allocatable</span> :: a(:) <span class="comment">!声明一个可变大小的一维数组</span></span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;How many students:&quot;</span></span><br><span class="line">read(*,*) students</span><br><span class="line"><span class="built_in">allocate</span>(a(students)) <span class="comment">!配置内存空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!输入成绩</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,students</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Number &#x27;,i3)&quot;</span>) i</span><br><span class="line">    read(*,*) a(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么，我在想，可不可以等知道需要多大的时候，再声明数组。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0716_2</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: students</span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;How many students:&quot;</span></span><br><span class="line">read(*,*) students</span><br><span class="line"></span><br><span class="line"><span class="keyword">integer</span> :: a(students)</span><br><span class="line"></span><br><span class="line"><span class="comment">!输入成绩</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,students</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Number &#x27;,i3)&quot;</span>) i</span><br><span class="line">    read(*,*) a(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不行，报错，貌似声明变量只能放在最前面</p>
<p>Fortran 报错应该也是看第一个报错。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">EX0716_2.F90:<span class="number">9.22</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">integer</span> :: a(students)</span><br><span class="line">                      <span class="number">1</span></span><br><span class="line">Error: Unexpected <span class="keyword">data</span> declaration statement at (<span class="number">1</span>)</span><br><span class="line">EX0716_2.F90:<span class="number">14.15</span>:</span><br><span class="line"></span><br><span class="line">    read(*,*) a(i)</span><br><span class="line">               <span class="number">1</span></span><br><span class="line">Error: Syntax error <span class="keyword">in</span> READ statement at (<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于内存空间有限，当然也就不能无限地要求空间。加一个 stat 的文本来判断内存配置是否成功。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">allocate</span>(a(<span class="number">100</span>),stat = error) <span class="comment">!如果error=0 表示分配成功；其他值表示分配失败</span></span><br></pre></td></tr></table></figure>
<p>声明其他维度的数组</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>,<span class="keyword">allocatable</span> :: a2(:,:) <span class="comment">!二维数组</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">allocatable</span> :: a3(:,:,:) <span class="comment">!三维数组</span></span><br><span class="line"><span class="built_in">allocate</span>(a2(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line"><span class="built_in">allocate</span>(a3(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<p>和 allocate 相关的函数还有 allocated ，用于检查一个可变大小的矩阵是否已经分配内存来使用，它会返回一个逻辑值。例如</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(.not. <span class="built_in">allocated</span>(a)) <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">allocate</span>(a(<span class="number">5</span>))</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="comment">!检查数组a是否分配内存，没有则分配5个</span></span><br></pre></td></tr></table></figure>
<h2 id="7-5-数组的应用">7-5 数组的应用</h2>
<p>首先看一个实用的问题，数组的排序。</p>
<p>先示范一个最简单的排序方法，叫做选择排序法</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0718</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: <span class="built_in">size</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="built_in">size</span>) = (/ <span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">10</span> /)</span><br><span class="line"><span class="keyword">integer</span> :: i,j</span><br><span class="line"><span class="keyword">integer</span> :: t</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="built_in">size</span>-<span class="number">1</span></span><br><span class="line">    <span class="keyword">do</span> j=i+<span class="number">1</span>,<span class="built_in">size</span></span><br><span class="line">        <span class="keyword">if</span>(a(i) &gt; a(j)) <span class="keyword">then</span> <span class="comment">!a(i)跟a(j) 交换</span></span><br><span class="line">            t = a(i) </span><br><span class="line">            a(i) = a(j)</span><br><span class="line">            a(j) = t</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(10i4)&quot;</span>) a</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>这个排序方法很简单，先说明它的步骤：</p>
<ol>
<li>把全部10个数字中，最小的那个找出来，跟 a(1) 交换位置。</li>
<li>把a(2~10)中，最小的那个找出来，跟 a(2) 交换位置。</li>
</ol>
<p>​    ……</p>
<ol start="9">
<li>把a(9~10)中，最小的那个找出来，跟 a(9) 交换位置，排序完成。</li>
</ol>
<p>具体看交换位置的内容</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">t = a(i) <span class="comment">!先把a(i)存起来</span></span><br><span class="line">a(i) = a(j) <span class="comment">!a(i) 设置成 a(j) 的值</span></span><br><span class="line">a(j) = t <span class="comment">!a(j) 设置成 a(i) 的值</span></span><br></pre></td></tr></table></figure>
<p>这里需要有一个中间变量。如果只用两个变量，会出错</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a(i) = a(j) <span class="comment">!a(i) 设置成 a(j) 的值</span></span><br><span class="line">a(j) = a(i) </span><br><span class="line"><span class="comment">!这里a(j)设置成a(i)的值，不过由于上一行a(i)已经设置成a(j)了。</span></span><br><span class="line"><span class="comment">!所以这一行白做工，啥也没干</span></span><br></pre></td></tr></table></figure>
<p>再看一个实例，做一个矩阵相乘的程序。</p>
<p>假设现在有两个二维矩阵 A, B，其中 A 的大小为 L*M ， B的大小为 M*N。现在要计算 C = A*B，它的大小一定为 L*N</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0719</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: l=<span class="number">3</span>,m=<span class="number">4</span>,n=<span class="number">2</span></span><br><span class="line"><span class="keyword">real</span> :: a(l,m)</span><br><span class="line"><span class="keyword">real</span> :: b(m,n)</span><br><span class="line"><span class="keyword">real</span> :: c(l,n)</span><br><span class="line"><span class="keyword">integer</span> :: i,j,k</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span>((a(i,j),i=<span class="number">1</span>,l),j=<span class="number">1</span>,m) / <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span> /</span><br><span class="line"><span class="keyword">data</span>((b(i,j),i=<span class="number">1</span>,m),j=<span class="number">1</span>,n) / <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> /</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i = <span class="number">1</span>,l</span><br><span class="line">    <span class="keyword">do</span> j = <span class="number">1</span>,n</span><br><span class="line">        c(i,j) = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">do</span> k=<span class="number">1</span>,m</span><br><span class="line">            c(i,j) = c(i,j) + a(i,k)*b(k,j)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,l</span><br><span class="line">    <span class="built_in">write</span>(*,*) c(i,:)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">70.0000000</span>       <span class="number">158.000000</span></span><br><span class="line"><span class="number">80.0000000</span>       <span class="number">184.000000</span></span><br><span class="line"><span class="number">90.0000000</span>       <span class="number">210.000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先要搞清楚，多层循环，内层先循环。这里也就是 i 和 j 不变，k 先循环一遍。得到的累加的结果就是 c(i,j) 的值。</p>
<p>事实上Fortran 90 库存函数就有提供 matmul 函数来做矩阵乘法。不过还是有必要学会作矩阵乘法的程序方法。</p>
<p>如果用函数，就一句解决</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">c = <span class="built_in">matmul</span>(a,b)</span><br></pre></td></tr></table></figure>
<h2 id="7-6-习题">7-6 习题</h2>
<p>1 声明一个大小为 10 的一维数组，初值为 a(i) = 2i ，并计算均值</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0720 </span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"><span class="keyword">integer</span> :: sum_a = <span class="number">0</span></span><br><span class="line"><span class="keyword">real</span> :: mean_a</span><br><span class="line"></span><br><span class="line"><span class="comment">!分配值</span></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">10</span>)</span><br><span class="line">    a(i) = <span class="number">2</span>*i <span class="comment">!开始少了*</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!求和</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">10</span></span><br><span class="line">    sum_a = sum_a + a(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">mean_a = <span class="keyword">real</span>(sum_a)/<span class="number">10.0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(f6.2)&quot;</span>) mean_a</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">11.00</span></span><br></pre></td></tr></table></figure>
<p>3 编写一个程序来计算前10个费氏数列，并保存在一个一维数组中。</p>
<p>费氏数列的规则</p>
<p>f(0) = 0</p>
<p>f(1) = 1</p>
<p>当 n &gt; 1, f(n) = f(n-1) + f(n-2)</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0721</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">0</span>:<span class="number">9</span>) <span class="comment">!注意这里的索引从0开始</span></span><br><span class="line"><span class="keyword">integer</span> :: i,j</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">0</span>,<span class="number">9</span></span><br><span class="line">    <span class="keyword">if</span> (i==<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        a(i) = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">        a(i) = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a(i) = a(i-<span class="number">1</span>) + a(i-<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(10i4)&quot;</span>) a</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>   <span class="number">1</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">5</span>   <span class="number">8</span>  <span class="number">13</span>  <span class="number">21</span>  <span class="number">34</span></span><br></pre></td></tr></table></figure>
<p>4 把排序程序 ex0718 改为从大排到小</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0718</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: <span class="built_in">size</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="built_in">size</span>) = (/ <span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">10</span> /)</span><br><span class="line"><span class="keyword">integer</span> :: i,j</span><br><span class="line"><span class="keyword">integer</span> :: t</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="built_in">size</span>-<span class="number">1</span></span><br><span class="line">    <span class="keyword">do</span> j=i+<span class="number">1</span>,<span class="built_in">size</span></span><br><span class="line">        <span class="keyword">if</span>(a(i) &lt; a(j)) <span class="keyword">then</span> <span class="comment">!a(i)跟a(j) 交换</span></span><br><span class="line">            t = a(i) </span><br><span class="line">            a(i) = a(j)</span><br><span class="line">            a(j) = t</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(10i4)&quot;</span>) a</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>就是改一个符号</p>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>   <span class="number">9</span>   <span class="number">8</span>   <span class="number">7</span>   <span class="number">6</span>   <span class="number">5</span>   <span class="number">4</span>   <span class="number">3</span>   <span class="number">2</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1>8 函数</h1>
<p>函数是自定义函数和子程序的统称。</p>
<p>字符 →  Token  → 语句  →  程序单元  → 模块（module）  → 程序</p>
<p>程序单元： 执行某一特定任务的具有一定独立性的代码区域。包括<strong>主程序</strong>，<strong>子程序</strong>，<strong>函数</strong>。</p>
<blockquote>
<p>子程序 是没有返回值的函数</p>
<p>主程序只是默认被系统首次调用的，具有程序入口点作用的函数</p>
<p>程序单元的存在，是为了提高代码<strong>重复利用率</strong>。因此，各程序代码越“独立”，越能体现重复利用的作用。</p>
<p>一组程序单元及一组相关联的变量，可组成模块（module）</p>
</blockquote>
<blockquote>
<p>程序单元间的变量，一般是互相不通的！</p>
<p>implicit none 应该写在每一个程序单元</p>
</blockquote>
<h2 id="8-1-子程序（subroutine）的使用">8-1 子程序（subroutine）的使用</h2>
<p>写程序时，可以把某一段常常被使用、具有特定功能的程序代码独立出来，封装成子程序，以后只要经过调用的 call 命令就可以执行这一段程序代码。</p>
<p>先看一个例子</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0801</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">call</span> message() <span class="comment">!调用子程序 message</span></span><br><span class="line"><span class="keyword">call</span> message() <span class="comment">!再调用一次</span></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!子程序message</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> message()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Hello.&quot;</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>子程序里可以包含所有命令，甚至包括调用其他子程序。</p>
<p>子程序和主程序的最大不同处在于：“主程序的程序代码，在程序一开始就自动会被执行，而子程序则不会自动执行，它需要被别人‘调用’ 才会执行。”</p>
<p>子程序以 subroutine 开头，同样要取一个名字，以end 或 end subroutine 结束（这个觉得更好）。严格地讲， end subroutine 后还可以接子程序的名字。</p>
<p>一个包含子程序的 Fortran 程序在结构上的模样大致如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> main <span class="comment">!主程序</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub1() <span class="comment">!第一个子程序</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> sub1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub2() <span class="comment">!第二个子程序</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> sub2</span><br></pre></td></tr></table></figure>
<p>其中，对主程序和子程序的安放顺序不作要求。</p>
<p>子程序最后一个命令通常是 “return&quot; ，表示程序要”返回“ 原来调用它的地方来继续执行程序（不写也可以，程序会自动返回）。<strong>return 可以使用在子程序中的任何地方，让子程序提早返回</strong>。</p>
<p>子程序除了可以让主程序调用之外，子程序之间也可以互相调用。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0802 </span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">call</span> sub1()</span><br><span class="line"><span class="keyword">call</span> sub2()</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> ex0802</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub1()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span> </span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;This is sub1&quot;</span></span><br><span class="line"><span class="keyword">call</span> sub2()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> sub1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub2()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;This is sub2&quot;</span></span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> sub2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">This is sub1 <span class="comment">!调用sub1</span></span><br><span class="line">This is sub2 <span class="comment">!调用sub1, sub1中又调用sub2</span></span><br><span class="line">This is sub2 <span class="comment">!调用sub2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>子程序可以在程序的任何地方被别人调用，甚至可以自己调用自己。这个操作称为”递归“。</p>
<p>关于子程序还有一个重要的概念，就是 ”子程序独立地拥有属于自己的变量声明”。也就是说，在主程序和其他的子程序之间，所声明出来的变量彼此是不相干的，假设在主程序与其他的子程序中使用了相同的变量名称，它们也是没有关系的不同变量。（说白了，就是变量空间呗）</p>
<p>来看一个实例</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0803</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a = <span class="number">1</span></span><br><span class="line"><span class="keyword">call</span> sub1()</span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;a=&#x27;,i2)&quot;</span>) a</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> ex0803</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub1()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a = <span class="number">2</span></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;a=&#x27;,i2)&quot;</span>) a</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> sub1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a= <span class="number">2</span> <span class="comment">!子程序</span></span><br><span class="line">a= <span class="number">1</span> <span class="comment">!主程序</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>除了变量独立以外，子程序也独立地拥有自己的“行代码”。</p>
<p>不过，有时候，调用子程序时，可以同时传递一些变量数据过去让它处理，这个操作叫做 ”传递参数“。</p>
<p>来看一个实例。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0804</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a = <span class="number">1</span></span><br><span class="line"><span class="keyword">integer</span> :: b = <span class="number">2</span></span><br><span class="line"><span class="keyword">call</span> add(a,b)</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> ex0804</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> add(first,second)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: first,second <span class="comment">!内容从 call中得到</span></span><br><span class="line"><span class="built_in">write</span>(*,*) first+second</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> add</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Fortran 在传递参数时使用的是传址调用（call by address/call by reference），这个意思是说所传递的参数，和子程序接收的参数，它们会使用相同的内存地址来记录数据（使用同一块内存来记录，可以视为同一个变量）。</p>
<p>比如，这里 first 和 a 会使用相同的内存地址来存储数值，所以 first 的值会等于 a，而<strong>如果修改first 的值，a 的内容也会跟着修改</strong>。</p>
<p>再来看一个实例。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0805</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a = <span class="number">1</span></span><br><span class="line"><span class="keyword">integer</span> :: b = <span class="number">2</span></span><br><span class="line"><span class="built_in">write</span>(*,*) a,b</span><br><span class="line"><span class="keyword">call</span> add(a)</span><br><span class="line"><span class="keyword">call</span> add(b)</span><br><span class="line"><span class="built_in">write</span>(*,*) a,b</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> ex0805</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> add(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: num</span><br><span class="line">num = num + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> add</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>           <span class="number">2</span></span><br><span class="line"><span class="number">2</span>           <span class="number">3</span> <span class="comment">!调用子程序后，修改了a,b</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有的程序语言会使用 “传值调用” （call by value）来传递参数，像C语言就使用传值调用。使用传值调用的程序语言，在子程序中改变参数内容，不会影响到调用处的变量内容。混合使用这两种语言时要注意这一点。（python 是只能调用，不能改变值的大小）</p>
<p>了解子程序的使用规则后，现在写一些比较有用途的东西。假设在一场田径赛的标枪选项中，有5位选手的投掷标枪的情况如下：</p>
<blockquote>
<p>1号选手：以30度角，每秒25米的速度掷出标枪。</p>
<p>2号选手：以45度角，每秒20米的速度掷出标枪。</p>
<p>3号选手：以35度角，每秒21米的速度掷出标枪。</p>
<p>4号选手：以50度角，每秒27米的速度掷出标枪。</p>
<p>5号选手：以40度角，每秒22米的速度掷出标枪。</p>
</blockquote>
<p>假设忽略空气阻力以及身高等等的因素，请写一个程序来计算选手们的投射距离。（自由投射物体的抛物线距离）。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0806</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: players = <span class="number">5</span></span><br><span class="line"><span class="keyword">real</span> :: angle(players) = (/ <span class="number">30.0</span>,<span class="number">45.0</span>,<span class="number">35.0</span>,<span class="number">50.0</span>,<span class="number">40.0</span> /)</span><br><span class="line"><span class="keyword">real</span> :: speed(players) = (/ <span class="number">25.0</span>,<span class="number">20.0</span>,<span class="number">21.0</span>,<span class="number">27.0</span>,<span class="number">22.0</span> /)</span><br><span class="line"><span class="keyword">real</span> :: distance(players)</span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,players</span><br><span class="line">    <span class="keyword">call</span> get_distance(angle(i),speed(i),distance(i))</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Player &#x27;,i1,&#x27; =&#x27;,f8.2)&quot;</span>) i,distance(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> ex0806</span><br><span class="line"></span><br><span class="line"><span class="comment">!把0-360的角度转换成弧度</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> angle_to_rad(angle,rad)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> angle,rad</span><br><span class="line"><span class="keyword">real</span>,<span class="keyword">parameter</span> :: pi = <span class="number">3.14159</span></span><br><span class="line">rad = angle*pi/<span class="number">180.0</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> angle_to_rad</span><br><span class="line"></span><br><span class="line"><span class="comment">!由角度、切线速度来计算投射距离</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> get_distance(angle,speed,distance)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> angle,speed <span class="comment">!输入的参数</span></span><br><span class="line"><span class="keyword">real</span> distance  <span class="comment">!返回结果</span></span><br><span class="line"><span class="keyword">real</span> rad,vx,time <span class="comment">!内部使用</span></span><br><span class="line"><span class="keyword">real</span>,<span class="keyword">parameter</span> :: g=<span class="number">9.81</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> angle_to_rad(angle,rad) <span class="comment">!单位转换</span></span><br><span class="line">vx = speed*<span class="built_in">cos</span>(rad) <span class="comment">!水平方向速度</span></span><br><span class="line">time = <span class="number">2.0</span>*speed*<span class="built_in">sin</span>(rad)/g <span class="comment">!在空中飞行时间</span></span><br><span class="line">distance = vx*time <span class="comment">!距离</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> get_distance</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">Player <span class="number">1</span> =   <span class="number">55.17</span></span><br><span class="line">Player <span class="number">2</span> =   <span class="number">40.77</span></span><br><span class="line">Player <span class="number">3</span> =   <span class="number">42.24</span></span><br><span class="line">Player <span class="number">4</span> =   <span class="number">73.18</span></span><br><span class="line">Player <span class="number">5</span> =   <span class="number">48.59</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>感觉函数和子程序最好还是用<strong>大小写混合</strong>，和一般变量区分开。</p>
<p>这种比较长的程序，需要有一个相应的说明书，写明每个子程序输入的参数、参数类型以及调用的功能。规范如下</p>
<blockquote>
<p><em>subroutine Get_Distance (angle, speed, distance)</em></p>
<p>功能：</p>
<p>计算投掷距离，只要输入速度（speed）及角度（angle），就可以由 distance 返回值中得到投掷距离。</p>
<p>参数：</p>
<p>real angle  输入投掷出去的角度</p>
<p>real speed 输入投掷出去的速度</p>
<p>real distance 返回计算得到的投掷距离</p>
<p><em>subroutine Angle_To_Rad (angle, rad)</em></p>
<p>功能：</p>
<p>把”角度“ 值转换成 ”弧度“， 输入一个角度就可以由 rad 得到转换出来的弧度。</p>
<p>参数：</p>
<p>real angle 输入所有转换的角度值</p>
<p>real rad     返回所对应的弧度值</p>
</blockquote>
<p>知道每一个子程序的功能后，可以直接阅读主程序来了解这个程序的运行。</p>
<h2 id="8-2-自定义函数（function">8-2 自定义函数（function)</h2>
<p>函数和子程序只有两点不同：</p>
<ol>
<li>调用自定义函数前要先声明。</li>
<li>自定义函数执行后会返回一个数值。</li>
</ol>
<p>先来看一个简单的实例</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0807</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> :: a = <span class="number">1</span></span><br><span class="line"><span class="keyword">real</span> :: b = <span class="number">2</span></span><br><span class="line"><span class="keyword">real</span>,<span class="keyword">external</span> :: Add <span class="comment">!声明 add是一个函数而不是变量</span></span><br><span class="line"><span class="comment">!调用函数add，调用函数不必使用call命令</span></span><br><span class="line"><span class="built_in">write</span>(*,*) Add(a,b)</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span></span> Add(a,b)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> :: a,b</span><br><span class="line"><span class="keyword">real</span> :: add</span><br><span class="line"><span class="comment">!add和函数名称一样，这里不是用来声明变量</span></span><br><span class="line"><span class="comment">!是声明这个函数会返回的数值类型</span></span><br><span class="line">add = a+b</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">3.00000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第14行是声明函数返回值的类型，这句可以合并在 function 的行</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> add(a,b) </span><br></pre></td></tr></table></figure>
<p>使用函数时有一个**”不成文规定“** ：”<strong>传递给函数的参数，只准读取，不要改变它的数值</strong>。</p>
<p>如果想要改变输入的参数时，最好使用子程序，而不是使用函数来完成这个工作。</p>
<p>上一节计算投标枪的程序很适合使用函数来编写，来看看改写后的结果：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0808</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: players = <span class="number">5</span></span><br><span class="line"><span class="keyword">real</span> :: angle(players) = (/ <span class="number">30.0</span>,<span class="number">45.0</span>,<span class="number">35.0</span>,<span class="number">50.0</span>,<span class="number">40.0</span> /)</span><br><span class="line"><span class="keyword">real</span> :: speed(players) = (/ <span class="number">25.0</span>,<span class="number">20.0</span>,<span class="number">21.0</span>,<span class="number">27.0</span>,<span class="number">22.0</span> /)</span><br><span class="line"><span class="keyword">real</span> :: distance(players)</span><br><span class="line"><span class="keyword">real</span>,<span class="keyword">external</span> :: Get_Distance <span class="comment">!声明Get_Distance 是个函数</span></span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,players</span><br><span class="line">    distance(i) =  Get_Distance(angle(i),speed(i))</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Player &#x27;,i1,&#x27; =&#x27;,f8.2)&quot;</span>) i,distance(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> ex0808</span><br><span class="line"></span><br><span class="line"><span class="comment">!把0-360的角度转换成弧度</span></span><br><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Angle_To_Rad(angle)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> angle</span><br><span class="line"><span class="keyword">real</span>,<span class="keyword">parameter</span> :: pi = <span class="number">3.14159</span></span><br><span class="line">Angle_To_Rad = angle*pi/<span class="number">180.0</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!由角度、切线速度来计算投射距离</span></span><br><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Get_Distance(angle,speed)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> angle,speed <span class="comment">!输入的参数</span></span><br><span class="line"><span class="keyword">real</span> rad,vx,time <span class="comment">!内部使用</span></span><br><span class="line"><span class="keyword">real</span>,<span class="keyword">external</span> :: Angle_To_Rad <span class="comment">!声明Angle_To_Rad是个函数</span></span><br><span class="line"><span class="keyword">real</span>,<span class="keyword">parameter</span> :: g=<span class="number">9.81</span></span><br><span class="line"></span><br><span class="line">rad = Angle_To_Rad(angle) <span class="comment">!单位转换</span></span><br><span class="line">vx = speed*<span class="built_in">cos</span>(rad) <span class="comment">!水平方向速度</span></span><br><span class="line">time = <span class="number">2.0</span>*speed*<span class="built_in">sin</span>(rad)/g <span class="comment">!在空中飞行时间</span></span><br><span class="line">Get_Distance = vx*time <span class="comment">!距离</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用函数来改写后，可以比原来的程序少输入一个参数。因为计算结果值直接由函数返回去，不需要另外使用变量来返回结果。</p>
<h2 id="8-3-全局变量（common）">8-3 全局变量（common）</h2>
<p>不同的程序（不同的函数，主程序和函数）之间，除了可以通过传递参数的方法来共享内存，还可以通过“全局变量” 来让不同程序中声明出来的变量使用相同的内存位置。</p>
<h3 id="8-3-1-common-的使用">8-3-1 common 的使用</h3>
<p>来可以一个实例</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0810</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a,b</span><br><span class="line"><span class="keyword">common</span> a,b <span class="comment">!定义a,b是全局变量中的第1及第2个变量</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="keyword">call</span> ShowCommon()</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowCommon()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: num1,num2</span><br><span class="line"><span class="keyword">common</span> num1,num2 <span class="comment">!定义num1,num2是全局变量中的第1个及第2个变量</span></span><br><span class="line"><span class="built_in">write</span>(*,*) num1,num2</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>           <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>取用全局变量时，是根据它们声明时的<strong>相对位置</strong>关系来作对应，而不是使用变量名称。因此这里的 a 和 num1 都是指向第一个全局变量，b 和 num2 都是指向第二个全局变量。</p>
<p>如果在程序的任何一个地方改变了全局变量的值，因为全局变量都使用相同的内存位置，所以程序中的每一个函数中都可以觉察到这个变动。</p>
<p>由于全局变量是使用“地址对应”的方法共享数据，因此如果你只想调出第6个全局变量，也得宣告出前5个全局变量在前面垫着。</p>
<p>这种麻烦在全局变量多的情况之下更为惊人。有一种方法可以减少这个麻烦，就是可以把变量归类，放在彼此独立的 common 区间中。</p>
<p>来看下面这个程序</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0811</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a,b</span><br><span class="line"><span class="keyword">common</span> /group1/ a <span class="comment">!变量a 放在group1中</span></span><br><span class="line"><span class="keyword">common</span> /group2/ b</span><br><span class="line">a=<span class="number">1</span></span><br><span class="line">b=<span class="number">2</span></span><br><span class="line"><span class="keyword">call</span> Show_Group1()</span><br><span class="line"><span class="keyword">call</span> Show_Group2()</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Show_Group1()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: num1</span><br><span class="line"><span class="keyword">common</span> /group1/ num1</span><br><span class="line"><span class="built_in">write</span>(*,*) num1</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Show_Group2()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: num2</span><br><span class="line"><span class="keyword">common</span> /group2/ num2</span><br><span class="line"><span class="built_in">write</span>(*,*) num2</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么，什么时候该使用参数，什么时候该使用全局变量呢？</p>
<p>简单地说，当需要共享的变量不多，而且只有少数几个程序需要使用这些数据时，那就使用参数。需要共享大笔数据，或是有很多个不同程序都需要使用这些数据时，就使用全局变量。</p>
<h3 id="8-3-2-block-data">8-3-2 block data</h3>
<p>关于全局变量，还有一点要介绍的就是设置初值的方法，common 变量不能直接在子程序或主程序中使用 data 来设置初值，要在 block data 程序模块中使用 data 命令来设置初值，直接看一个程序。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0812</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a,b</span><br><span class="line"><span class="keyword">common</span> a,b</span><br><span class="line"><span class="keyword">integer</span> :: c,d</span><br><span class="line"><span class="keyword">common</span> /group1/ c,d</span><br><span class="line"><span class="keyword">integer</span> :: e,f</span><br><span class="line"><span class="keyword">common</span> /group2/ e,f</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(6i4)&quot;</span>) a,b,c,d,e,f</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">block</span> <span class="keyword">data</span></span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> a,b</span><br><span class="line"><span class="keyword">common</span> a,b </span><br><span class="line"><span class="keyword">data</span> a,b /<span class="number">1</span>,<span class="number">2</span>/</span><br><span class="line"><span class="keyword">integer</span> :: c,d</span><br><span class="line"><span class="keyword">common</span> /group1/ c,d</span><br><span class="line"><span class="keyword">data</span> c,d /<span class="number">3</span>,<span class="number">4</span>/</span><br><span class="line"><span class="keyword">integer</span> :: e,f</span><br><span class="line"><span class="keyword">common</span> /group2/ e,f</span><br><span class="line"><span class="keyword">data</span> e,f /<span class="number">5</span>,<span class="number">6</span>/</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">block</span> <span class="keyword">data</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>block data 会自己执行，事实上这一段程序会在主程序执行前就会生效，不过只能设置初值（那有球用）。还有一点，全局变量不能设置为常数，所以block data中不能出现 parameter。</p>
<h3 id="8-3-3-注意事项">8-3-3 注意事项</h3>
<p>使用 common 时要注意两点：</p>
<ol>
<li>变量的类型</li>
<li>变量的位置</li>
</ol>
<p>来看一个例子</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0813</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> a</span><br><span class="line"><span class="keyword">common</span> a <span class="comment">!把浮点数a放在全局变量中</span></span><br><span class="line">a = <span class="number">1.0</span></span><br><span class="line"><span class="keyword">call</span> Show_Common()</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Show_Common()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> a</span><br><span class="line"><span class="keyword">common</span> a</span><br><span class="line"><span class="built_in">write</span>(*,*) a <span class="comment">!把整数a放在全局变量中</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行后输出一个很奇怪的数值</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1065353216</span></span><br></pre></td></tr></table></figure>
<p>主程序把全局变量设置为 1.0 , 但是在子程序中却声明成整数。这是存入数据的时候按照浮点数的规则，读取数据的时候又按照整数的规则。但是浮点数和整数保存规则不同。</p>
<p>使用 common 时还有一些技巧，来看下一个例子。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0814</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> a,b</span><br><span class="line"><span class="keyword">common</span> a,b <span class="comment">!把浮点数a,b加入全局变量中</span></span><br><span class="line">a = <span class="number">1.0</span></span><br><span class="line">b = <span class="number">2.0</span></span><br><span class="line"><span class="keyword">call</span> Show_Common()</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Show_Common()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> a(<span class="number">2</span>) </span><br><span class="line"><span class="keyword">common</span> a <span class="comment">!把数组a放入到全局变量中</span></span><br><span class="line"><span class="built_in">write</span>(*,*) a(<span class="number">1</span>),a(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1.00000000</span>       <span class="number">2.00000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里使用全局变量时，把握了它们会使用相同内存空间的策略。主程序中在全局变量中放了两个变量a和b，子程序也放入了两个变量，不过它放的是一个大小为2 的数组。所以数组的第1个值就等于主程序中的变量a，第2个值等于主程序中的变量b。</p>
<p>使用 COMMON 时，编译器并不会帮忙做类型检查的工作，这个责任要由程序员自行负责。有一点很麻烦的是，如果要修改 COMMON 的数据类型，要改的地方可能会很多。</p>
<p>Fortran90 有另一种方法来使用全局变量，它可以避免这两个问题。</p>
<h2 id="8-4-函数中的变量">8-4 函数中的变量</h2>
<h3 id="8-4-1-传递参数的注意事项">8-4-1 传递参数的注意事项</h3>
<p>传递参数给函数时，最重要的一点是：”类型要正确“。</p>
<p>如果类型不同，可以会得到难以预料的结果（因为Fortran实际是传递内存地址，”加密“ ”解密“ 方式不同肯定会出问题）。</p>
<p>这里来做一个实验</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0815</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> :: a=<span class="number">1.0</span></span><br><span class="line">    <span class="keyword">call</span> ShowInteger(a)</span><br><span class="line">    <span class="keyword">call</span> ShowReal(a)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowInteger(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: num </span><br><span class="line">    <span class="built_in">write</span>(*,*) num</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowReal(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> :: num</span><br><span class="line">    <span class="built_in">write</span>(*,*) num</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1065353216</span><br><span class="line">  1.00000000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>传递参数也可以直接传递常量，但是记得输入正确的数据类型，区分整数和浮点数；另外，函数中不能修改参数的值，因为常量不能被修改。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> ShowInteger(<span class="number">1</span>) </span><br><span class="line"><span class="keyword">call</span> ShowReal(<span class="number">1.0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="8-4-2-数组参数">8-4-2 数组参数</h3>
<p>数组惠占据一块内存中的连续空间。在传递数组参数时，实际上是传递数组元素当中的某一个内存地址。</p>
<p>举个例子。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0816</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a(<span class="number">5</span>)=(/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /)</span><br><span class="line">    <span class="keyword">call</span> ShowOne(a) <span class="comment">!输入a, 就是输入数组a第一个元素的内存地址</span></span><br><span class="line">    <span class="keyword">call</span> ShowArray5(a)</span><br><span class="line">    <span class="keyword">call</span> ShowArray3(a)</span><br><span class="line">    <span class="keyword">call</span> ShowArray3(a(<span class="number">2</span>)) <span class="comment">!输入a(2), 就是输入数组a第2个元素的内存地址</span></span><br><span class="line">    <span class="keyword">call</span> ShowArray2X2(a)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowOne(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: num <span class="comment">!只取出参数地址中的第1个数字</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) num</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowArray5(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: num(<span class="number">5</span>) <span class="comment">!只取出参数地址中的前5个数字， 当成数组来使用</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) num</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowArray3(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: num(<span class="number">3</span>) <span class="comment">!只取出参数地址中的前3个数字， 当成数组来使用</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) num</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowArray2X2(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: num(<span class="number">2</span>,<span class="number">2</span>) <span class="comment">!只取出参数地址中的前4个数字， 当成2X2数组来使用</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) num(<span class="number">2</span>,<span class="number">1</span>),num(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译时有 warning</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gfortran EX0816.F90</span></span><br><span class="line">EX0816.F90:4.17:</span><br><span class="line"></span><br><span class="line">    call ShowOne(a) !\xE8\xBE\x93\xE5\x85\xA5a, \xE5\xB0\xB1\xE6\x98\xAF\xE8\xBE</span><br><span class="line">                 1</span><br><span class="line">Warning: Rank mismatch in argument &#x27;num&#x27; at (1) (scalar and rank-1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果如下</p>
<p>先看第一个结果， call ShowOne(a) 会将传入的参数作为一个整数接收，这里传进来的是数组a，也就是 a(1) 的地址。</p>
<p>第二个结果，call showArray5(a) 正好将传入的参数作为一个大小为5的一维数组。第三个结果截取了前三个元素。</p>
<p>第四个个结果输入a(2) ，因此返回的数组的起始位置会等于 a(2)。</p>
<p>第五个结果会将参数当作2×2的数组使用。根据数组的内存排列原则，num(1,1) = a(1) , num(2,1) = a(2), num(1,2) = a(3), num(2,2) = a(4)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1           2           3           4           5</span><br><span class="line">1           2           3</span><br><span class="line">2           3           4</span><br><span class="line">2           4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>数组在定义的时候需要使用常量来赋值它的大小。不过在函数中，如果数组是接收用的参数时，可以例外。这个时候可以用变量来赋值它的大小，甚至可以不去赋值大小，来看下面的例子。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0817</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">parameter</span> :: <span class="built_in">size</span> = <span class="number">5</span></span><br><span class="line">    <span class="keyword">integer</span> :: s = <span class="built_in">size</span></span><br><span class="line">    <span class="keyword">integer</span> :: a(<span class="built_in">size</span>) = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /)</span><br><span class="line">    <span class="keyword">call</span> UseArray1(a,<span class="built_in">size</span>) <span class="comment">!把常量size输入做数组大小</span></span><br><span class="line">    <span class="keyword">call</span> UseArray1(a,s) <span class="comment">!把一般变量s输入做数组大小</span></span><br><span class="line">    <span class="keyword">call</span> UseArray2(a) <span class="comment">!不输入数组大小</span></span><br><span class="line">    <span class="keyword">call</span> UseArray3(a) </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> UseArray1(num,<span class="built_in">size</span>)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: <span class="built_in">size</span></span><br><span class="line">    <span class="keyword">integer</span> :: num(<span class="built_in">size</span>) <span class="comment">!输入数组的大小可用变量来赋值</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) num</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> UseArray2(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: num(*) <span class="comment">!不赋值数组大小</span></span><br><span class="line">    <span class="keyword">integer</span> :: i </span><br><span class="line">    <span class="built_in">write</span>(*,*) (num(i),i=<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line">    <span class="comment">!如果输入的数组大于小于5，write在执行时会出现错误</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> UseArray3(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: num(-<span class="number">2</span>:<span class="number">2</span>) <span class="comment">!重新定义数组坐标范围</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) num(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果如下。其中 UseArray1 中使用输入的变量来设置数组的大小，UseArray2 则在设置大小时使用一个星号，代表不指定大小的意思。UseArray3 则重新定义了数组坐标值范围。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1           2           3           4           5</span><br><span class="line">1           2           3           4           5</span><br><span class="line">1           2           3           4           5</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为什么在函数中不用赋值数组大小呢？因为在主程序中已经创建好了数组，在进入到子程序前数组就已经配置到内存空间了。函数不会额外配置新的内存空间，在函数中赋值数组大小只是用来方便检查，不会去重新配置内存，所以可以省略。</p>
<p>子程序 UseArray3 是比较特殊的用法，它定义数组 num 坐标范围为 -2~2, 所以 num(-2) = a(1), num(-1)=a(0) ……。</p>
<p>函数中只要注意使用数组参数时，<strong>不要超过它的实际范围</strong>就行了。其他方面要如何使用都没有关系。如果超出了实际范围，编译时不会出现错误，在执行时会出现奇怪的结果，甚至死机。</p>
<p>顺便提一点，传递字符串变量时，也可以不特别赋值它的长度。原因相同，因为它的长度早就设置好了。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">character</span>(len=*) string</span><br></pre></td></tr></table></figure>
<p>举例</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0818</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: str=<span class="string">&quot;Hello, Fortran 95.&quot;</span></span><br><span class="line">    <span class="keyword">call</span> ShowString(str) <span class="comment">!输入字符串开头地址</span></span><br><span class="line">    <span class="keyword">call</span> ShowString(str(<span class="number">8</span>:)) <span class="comment">!输入字符串第8个字符的地址</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowString(str)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=*) :: str</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="built_in">len_trim</span>(str)</span><br><span class="line">    <span class="built_in">write</span>(*,*) str</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         18</span><br><span class="line">Hello, Fortran 95.</span><br><span class="line">         11</span><br><span class="line">Fortran 95.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>子程序如果赋值字符串长度，不能超过实际长度。</p>
<p>再回到数组的部分，多维数组在传递时，只有最后一维可以不赋值大小，其他维都必须赋值大小，来看一个实例。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0819</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">parameter</span> :: dim1 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">parameter</span> :: dim2 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">parameter</span> :: dim3 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">integer</span> :: a(dim1,dim2,dim3)</span><br><span class="line">    a(:,:,<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">    a(:,:,<span class="number">2</span>) = <span class="number">2</span></span><br><span class="line">    <span class="keyword">call</span> GetArray1(a(:,:,<span class="number">1</span>),dim1,dim2)</span><br><span class="line">    <span class="keyword">call</span> GetArray2(a(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>),dim1)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> GetArray1(a,dim1,dim2)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: dim1,dim2</span><br><span class="line">    <span class="keyword">integer</span> :: a(dim1,dim2)</span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> GetArray2(a,dim1)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: dim1,dim2</span><br><span class="line">    <span class="keyword">integer</span> :: a(dim1,*) <span class="comment">!最后一维可以不赋值数组大小</span></span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="built_in">write</span>(*,*) (a(:,i),i=<span class="number">1</span>,<span class="number">2</span>) <span class="comment">! 必须指定输出哪几维</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1           1           1           1</span><br><span class="line">2           2           2           2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序示范了两个东西，第一是把三维数组传递到子程序中变成二维数组的方法，第二是示范了多维数组的最后一个维度可以不赋值大小。程序第9行是用来输入部分数组。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> GetArray1(a(:,:,<span class="number">1</span>),dim1,dim2)</span><br></pre></td></tr></table></figure>
<p>因为数组 a(1~2, 1~2, 1) 这4个元素在内存中是连续存放的，这里<strong>参数放入a(:,:,1) 就等于放入a(1,1,1) 的地址</strong>。子程序接收时改用二维数组来使用这块内存，所以这里等于是把原来容量为 dim1×dim2×dim3 的 三维数组中拿出当中一小块当成容量为 dim1×dim2 的 二维数组。</p>
<p>第10行是同样的用法，只是它换了一个写法，而且放入的是另一块空间。但是它没有赋值第二维的大小，这是合理的语法。</p>
<p>不过用这个方法后，输出数组a的时候要指定它的范围。因为声明时没说明它的第二维有多大。（—这不是脱裤子××嘛，那就直接指定好范围就行了呗）</p>
<p>你看，后面又建议。</p>
<blockquote>
<p>笔者建议还是不要偷懒，把数组实际声明大小全部都传递出去是比较好的做法。</p>
</blockquote>
<h3 id="8-4-3-变量的生存周期">8-4-3 变量的生存周期</h3>
<p>函数中的变量（不含所输入的参数）有它们的 “生存周期”。它们所能够生存的时间，只有在这个子程序被调用执行的这一段时间中。子程序结束后，它们就“死亡” 了，所保存的数据也会跟着被埋没掉。</p>
<p>在声明中加入 SAVE 可以拯救这些变量。这些变量可以在程序执行中永久记忆住上一次函数调用时所被设置的数值，来看看这一个实例：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0820</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">call</span> sub()</span><br><span class="line">    <span class="keyword">call</span> sub()</span><br><span class="line">    <span class="keyword">call</span> sub()</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub()</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: <span class="built_in">count</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">save</span> <span class="built_in">count</span> <span class="comment">!赋值count变量会永久活着，不会忘记它的内容</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="built_in">count</span></span><br><span class="line">    <span class="built_in">count</span> = <span class="built_in">count</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在 save 命令后面的变量的生存周期将不只局限在子程序的执行过程中，会延申到整个程序的执行时间一样长。<strong>注意，变量的初值只会设置一次</strong>。所以第11行设置 count 初值的操作只会执行一次，并不是每次调用 sub 时，count 都会重新设置为1。</p>
<p>在 Fortran 90 中，可以把 save 和 声明写在同一行，如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>,<span class="keyword">save</span> :: <span class="built_in">count</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>有些编译器不管有没有指明 save，都会记住数值</strong>。我这里做了一次，gfortran 就是这样，注释掉 save 行，输出结果不变。（我感觉这一点不好，我可能会重复运行一个函数，中间的临时变量我肯定希望重置，现在默认都记住了，不知道怎么弄）</p>
<h3 id="8-4-4-传递函数">8-4-4 传递函数</h3>
<p>传递参数时，除了传递数字、字符串等数据外，还可以把一个函数名称传递过去。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0821</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: func <span class="comment">!声明 func 是个自定义函数</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">intrinsic</span> :: <span class="built_in">sin</span> <span class="comment">!声明sin是一个库函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">call</span> ExecFunc(func) <span class="comment">!输入自定义函数 func</span></span><br><span class="line">    <span class="keyword">call</span> ExecFunc(<span class="built_in">sin</span>) <span class="comment">!输入库函数 sin</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ExecFunc(f)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: f <span class="comment">!声明参数f是个函数</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) f(<span class="number">1.0</span>) </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> func(num)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> :: num</span><br><span class="line">    func = num*<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 2.00000000</span><br><span class="line">0.841470957</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第三行的声明中使用了 EXTERNAL,  前面曾介绍过这是用来表明所声明的是一个自定义函数的名称。第四行的声明中使用了一个新的关键字 INTRINSIC, 用来表明所声明的 sin 是 Fortran 的 库存函数，而不是一个变量。在这个程序中 EXTERNAL 和 INTRINSIC 这两个字都不能省略，因为在这里要把函数名称当成参数传递出去。如果纯粹把函数拿来计算使用，不把它当成参数传递出去，声明 func 时可以省略 EXTERNAL，声明 sin 的这一整行则可以完全省略。</p>
<p>第6、7行执行调用了两次子程序 ExecFunc ，分别把自定义函数 func 函数和库函数 sin 输入。</p>
<p>除了函数可以当成参数来传递之外，子程序也可以拿来作为参数传递出去。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0822</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">external</span> sub1,sub2 <span class="comment">!声明sub1 sub2 是子程序名称</span></span><br><span class="line">    <span class="keyword">call</span> sub(sub1) <span class="comment">!把子程序当参数传出去</span></span><br><span class="line">    <span class="keyword">call</span> sub(sub2)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub(sub_name)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">external</span> sub_name <span class="comment">!声明 sub_name 是个子程序</span></span><br><span class="line">    <span class="keyword">call</span> sub_name() <span class="comment">!调用输入的子程序 sub_name</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub1()</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;sub1&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub2()</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;sub2&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub1</span><br><span class="line">sub2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>8-5 特殊参数的使用方法</h1>
<p>Fortran 90 中，可以赋值参数的属性，设置某些参数是只读不能改变的。它还可以输入不定个数的参数，还可以不按照顺序来传递参数。</p>
<h3 id="8-5-1-参数属性">8-5-1 参数属性</h3>
<p>Fortran 中，参数传递出去后可能在函数中被改变。有的时候程序员会希望某些参数是只读的，它的数值不能在函数中被改变。Fortran 90 的 INTENT 命令可以用来设置函数属性，先来看一个简单的实例：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0823</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a=<span class="number">4</span></span><br><span class="line">    <span class="keyword">integer</span> b</span><br><span class="line">    <span class="keyword">call</span> div(a,b)</span><br><span class="line">    <span class="built_in">write</span>(*,*) a,b</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> div(a,b)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>)::a <span class="comment">!指定a是只读</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">intent</span>(<span class="keyword">out</span>)::b <span class="comment">!指定b在子程序中应该重新设置数值</span></span><br><span class="line">    b=a/<span class="number">2</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里 intent(in) 表示只读， intent(out) 表示指定为应该重新设置数值。</p>
<p>事实上，不指定参数属性并不会影响程序执行结果，加上这两行只是用来避免编写程序时不小心出错。设置成只读的变量，在函数中如果重新设置数值，编译过程中会出现错误。而设置成要输出的变量，如果在函数中没有重新设置一个数值给它，编译过程中会出现警告信息。</p>
<p>在计算丢标枪的实例程序 EX0809 中的两个函数 Angle_To_Rad 及 Get_Distance 都不会去改变参数，这两个函数的参数都是可读的。这个程序严格的写法会变成下面的样子。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0824</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">parameter</span> :: players = <span class="number">5</span></span><br><span class="line">    <span class="keyword">real</span> :: angle(players) = (/<span class="number">30.0</span>,<span class="number">45.0</span>,<span class="number">35.0</span>,<span class="number">50.0</span>,<span class="number">40.0</span>/)</span><br><span class="line">    <span class="keyword">real</span> :: speed(players) = (/<span class="number">25.0</span>,<span class="number">20.0</span>,<span class="number">21.0</span>,<span class="number">27.0</span>,<span class="number">22.0</span>/)</span><br><span class="line">    <span class="keyword">real</span> :: distance(players)</span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: Get_Distance <span class="comment">!声明Get_Distance 是个函数</span></span><br><span class="line">    <span class="keyword">integer</span> :: I</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> I=<span class="number">1</span>,players</span><br><span class="line">        distance(i)=Get_Distance(angle(i),speed(i))</span><br><span class="line">        <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;player &#x27;,I1,&#x27; =&#x27;,F8.2)&quot;</span>) I,distance(i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">!把0~360的角度转换成弧度</span></span><br><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Angle_TO_Rad(angle)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>) :: angle</span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">parameter</span> :: pi = <span class="number">3.14159</span></span><br><span class="line">    Angle_TO_Rad = angle*pi/<span class="number">180.0</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">!由角度，切线速度来计算投射距离</span></span><br><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Get_Distance(angle,speed)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>) :: angle,speed <span class="comment">!输入的参数</span></span><br><span class="line">    <span class="keyword">real</span> rad,Vx,time <span class="comment">!内部使用</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: Angle_TO_Rad <span class="comment">!声明是个函数</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">parameter</span> :: G = <span class="number">9.81</span></span><br><span class="line">    </span><br><span class="line">    rad = Angle_TO_Rad(angle) <span class="comment">!单位转换</span></span><br><span class="line">    Vx = speed*<span class="built_in">cos</span>(rad) <span class="comment">!水平方向速度</span></span><br><span class="line">    time = <span class="number">2.0</span>*speed*<span class="built_in">sin</span>(rad)/G <span class="comment">!在空中飞行时间</span></span><br><span class="line">    Get_Distance = Vx * time <span class="comment">!距离 = 水平方向速度 * 飞行时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>这个程序和原来的程序只有两行的差别，第20，30行。在这里把输入的参数都指定成只读的属性。</p>
<h3 id="8-5-2-函数的使用接口（INTERFACE）">8-5-2 函数的使用接口（INTERFACE）</h3>
<p>INTERFACE 是一段程序模块，用来清楚说明所要调用函数的参数类型及返回值类型等等的”使用接口“。在一般情况下，使用函数时不需要特别说明它们的”使用接口“，不过在下面这些情况下是必要的”</p>
<blockquote>
<ol>
<li>函数返回值为数组时</li>
<li>指定参数位置来传递参数时</li>
<li>所调用的函数参数数目不固定时</li>
<li>输入指标参数时</li>
<li>函数返回值为指针时</li>
</ol>
</blockquote>
<p>第1点很容易理解，目前为止举例中的函数都只返回一个数值，函数的返回值也可以是一个数组，来看下面的实例。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0825</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="comment">!定义函数func的使用接口</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span></span> random10(<span class="built_in">lbound</span>,<span class="built_in">ubound</span>)</span><br><span class="line">            <span class="keyword">implicit</span> <span class="keyword">none</span> </span><br><span class="line">            <span class="keyword">real</span> :: <span class="built_in">lbound</span>,<span class="built_in">ubound</span></span><br><span class="line">            <span class="keyword">real</span> :: random10(<span class="number">10</span>) <span class="comment">!返回值是个数组</span></span><br><span class="line">        <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">real</span> :: a(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">call</span> <span class="built_in">random_seed</span>() <span class="comment">!库存子程序，使用随机数前调用</span></span><br><span class="line">    a = random10(<span class="number">1.0</span>,<span class="number">10.0</span>) <span class="comment">!生成10个1.0~10.0之间的随机数</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(10F6.2)&quot;</span>) a <span class="comment">!输出数组a的内容</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">! random10 会返回10个范围在 lbound 和 ubound 之间的随机数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span></span> random10(<span class="built_in">lbound</span>,<span class="built_in">ubound</span>)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> :: <span class="built_in">lbound</span>,<span class="built_in">ubound</span></span><br><span class="line">    <span class="keyword">real</span> :: len</span><br><span class="line">    <span class="keyword">real</span> :: random10(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">real</span> t</span><br><span class="line">    <span class="keyword">integer</span> i</span><br><span class="line">    len = <span class="built_in">ubound</span> - <span class="built_in">lbound</span> <span class="comment">!计算范围大小</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">10</span></span><br><span class="line">        <span class="keyword">call</span> <span class="built_in">random_number</span>(t) <span class="comment">!t是0~1之间的随机数</span></span><br><span class="line">        random10(i) = <span class="built_in">lbound</span> + len*t <span class="comment">!把t转换成 lbound~ubound 间的随机数</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序会输出10个1~10之间随机生成的随机数，每次执行出来的结果应该均不相同（错了，我重复了两次，结果一样）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(base) [zhouziwen@ny gfortran]$ gfortran EX0825.F90</span><br><span class="line">(base) [zhouziwen@ny gfortran]$ ./a.out</span><br><span class="line">  9.98  6.10  9.69  7.73  4.31  5.33  1.66  1.05  4.12  4.08</span><br><span class="line">(base) [zhouziwen@ny gfortran]$ gfortran EX0825.F90</span><br><span class="line">(base) [zhouziwen@ny gfortran]$ ./a.out</span><br><span class="line">  9.98  6.10  9.69  7.73  4.31  5.33  1.66  1.05  4.12  4.08</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里先说明随机数的使用方法，在写程序的时候，常常会需要使用类似丢铜板的情况，以随机的方法来决定下一步要怎么做，这时候就要使用随机数。使用随机数前要先调用 random_seed 这个子程序来启动随机数生成器，启动之后就可以通过调用 random_number 来得到一个 0~1 之间的随机数。</p>
<p>这个实例中的函数 random10, 会通过输入的两个参数来决定随机数的值域范围，生成10个随机数，放在一维数组中作为返回值。这里示例了函数返回数组的方法，主程序中要用 interface 来说明函数的使用接口，使用接口包括参数类型及返回值类型。</p>
<p>一般情况并不需要使用 interface, 只有本小节最前面提到的那些情况才需要使用 interface 。声明使用接口，对程序员来说，是一个很麻烦的工作。尤其是在需要调用多个函数时，整个程序代码看起来会很烦杂。以这个例子来说，如果有另一个子程序也要调用 random10, 那在这个子程序中也需要再写清楚函数 random10 的 interface 才行。使用 module 可以减少这个麻烦，下面的章节会介绍 module 的使用。</p>
<p>interface 的编写结构很简单，它一次可以放入好几个函数的使用接口声明：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="comment">!开始写作 interface</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span></span> func_name <span class="comment">!开始定义函数 func_name</span></span><br><span class="line">		<span class="keyword">implicit</span> <span class="keyword">none</span> </span><br><span class="line">		<span class="keyword">real</span> ……  <span class="comment">!这里只能说明参数或传回值类型</span></span><br><span class="line">		<span class="keyword">integer</span> ……</span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span> <span class="comment">!定义函数结束</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> sub_name <span class="comment">!可以再定义另一个子函数/程序</span></span><br><span class="line">    	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    	<span class="keyword">integer</span> ……</span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">interface</span></span><br></pre></td></tr></table></figure>
<h3 id="8-5-3-不定个数的参数传递">8-5-3 不定个数的参数传递</h3>
<p>Fortran 90 当中，可以用 OPTIONAL 命令来表示某些参数是&quot;可以省略的&quot;。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0826</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">interface</span></span><br><span class="line">        <span class="function"><span class="keyword">subroutine</span></span> sub(a,b) <span class="comment">!定义子程序 sub 的使用接口</span></span><br><span class="line">            <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">            <span class="keyword">integer</span> :: a</span><br><span class="line">            <span class="keyword">integer</span>,<span class="keyword">optional</span> :: b</span><br><span class="line">        <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    <span class="comment">!开始编写命令</span></span><br><span class="line">    <span class="keyword">call</span> sub(<span class="number">1</span>) <span class="comment">!使用1个参数</span></span><br><span class="line">    <span class="keyword">call</span> sub(<span class="number">2</span>,<span class="number">3</span>) <span class="comment">!使用2个参数</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub(a,b)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a</span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">optional</span> :: b</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">present</span>(b)) <span class="keyword">then</span><span class="comment">!有输入b时</span></span><br><span class="line">        <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;a=&#x27;,i3,&#x27; b=&#x27;,i3)&quot;</span>) a,b</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;a=&#x27;,i3,&#x27; b=unknown&#x27;)&quot;</span>) a</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;  1 b&#x3D;unknown</span><br><span class="line">a&#x3D;  2 b&#x3D;  3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在子程序sub 及主程序的 interface 声明中，声明第二个参数时可以忽略的。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">optional</span> :: b</span><br></pre></td></tr></table></figure>
<p>函数 present 可以检查一个参数是否传递进来，函数 present 的返回值是布尔变量，如果想要检查的参数传递进来，会返回.true.，没有则返回.false.</p>
<p>注意，调用不定参数时，一定要先声明出函数的 interface，使用 module 时可以省略。</p>
<h3 id="8-5-4-改变参数传递位置的方法">8-5-4 改变参数传递位置的方法</h3>
<p>Fortran 90 中，甚至可以不用按照参数的顺序来传递参数。例如有一个子程序如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub(a,b,c)</span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br></pre></td></tr></table></figure>
<p>调用这个子程序时，可以直接代入子程序的变量名称来做”变换参数位置“的调用，例如：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> sub(b=<span class="number">2</span>,c=<span class="number">3</span>,a=<span class="number">1</span>) <span class="comment">!根据变量名称来传递参数</span></span><br></pre></td></tr></table></figure>
<p>编写程序的时候也可以让某些参数有<strong>默认值</strong>，不输入这些参数时就使用默认值。来看下面的例子，这个例子会编写一个函数来计算 F(X) = A*X^2^ + B*X + C 的值，一定要输入X来计算，A,B,C 没有输入的画默认值为0.</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0827</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">interface</span></span><br><span class="line">        <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> func(x,a,b,c) <span class="comment">!定义子程序func的使用接口</span></span><br><span class="line">            <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">            <span class="keyword">real</span> x</span><br><span class="line">            <span class="keyword">real</span>,<span class="keyword">optional</span> :: a,b,c</span><br><span class="line">        <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    <span class="comment">!开始编写命令</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) func(<span class="number">2.0</span>,c=<span class="number">1.0</span>) <span class="comment">!F(2)=0*2^2 + 0*2 + 1 = 1</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) func(<span class="number">2.0</span>,a=<span class="number">2.0</span>,b=<span class="number">1.0</span>) <span class="comment">!F(2)=2*2^2 + 1*2 + 0 = 10</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">!计算func(X)=A*X^2+B*X+C</span></span><br><span class="line"><span class="comment">!A,B,C不输入的话为0</span></span><br><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> func(x,a,b,c)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> x </span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">optional</span> :: a,b,c <span class="comment">!a,b,c可以不输入</span></span><br><span class="line">    <span class="keyword">real</span> ra,rb,rc <span class="comment">!实际计算的数字</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">present</span>(a)) <span class="keyword">then</span></span><br><span class="line">        ra=a</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ra=<span class="number">0.0</span> <span class="comment">!默认值为0</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">present</span>(b)) <span class="keyword">then</span></span><br><span class="line">        rb=b</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rb=<span class="number">0.0</span> <span class="comment">!默认值为0</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">present</span>(c)) <span class="keyword">then</span></span><br><span class="line">        rc=c</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rc=<span class="number">0.0</span> <span class="comment">!默认值为0</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    func = ra*x**<span class="number">2</span> + rb*x + rc</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.00000000</span><br><span class="line">10.0000000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="8-6-特殊的函数类型">8-6 特殊的函数类型</h2>
<p>Fortran 90 的函数，除了一般正常使用的类型外，还可以特别指定成 RECURSIVE, PURE, ELEMENTAL 这三种类型之一。 RECURSIVE 是让函数可以自己调用自己，即递归。PURE 及 ELEMENTAL 是用来做并行处理时及设置数组时使用。</p>
<h3 id="8-6-1-递归">8-6-1 递归</h3>
<p>函数除了可以让别人调用，自己也可以调用自己来执行，这叫做”递归“。能够”递归“执行的函数有一个必要条件，那就是递归函数每次被调用执行时，函数中所声明的局部变量（指那些不是传递进来的参数，及没有SAVE的变量）都会使用不同的内容地址。简单地说，函数中的局部变量在每次调用时都是独立存在的。</p>
<p>下面的实例程序会使用”递归“的方式来编写计算阶乘的子程序。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0828</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: n</span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">external</span> :: fact</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;N=&quot;</span></span><br><span class="line">    read(*,*) n</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(i2,&#x27;! = &#x27;,i8)&quot;</span>) n,fact(n)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">recursive</span> <span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> fact(n) reasut(ans)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>) :: n</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">then</span> <span class="comment">!不合理的输入</span></span><br><span class="line">        ans = -<span class="number">1</span> <span class="comment">!随便设置一个值</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line">    <span class="comment">!下面表示 n&gt;1 的情况，利用n*(n-1)! 来计算 n!</span></span><br><span class="line">    ans = n * fact(n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> N&#x3D;</span><br><span class="line">5</span><br><span class="line"> 5! &#x3D;      120</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数fact 一开头就以 recursive 开头，表示这个子程序可以递归使用。 result() 表示在函数中使用另外一个名字来设置函数的返回值，这里用 ans 来代替原来的 fact</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">recursive</span> <span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> fact(n) result(ans)</span><br></pre></td></tr></table></figure>
<p>Fortran 90 标准中，递归函数一定要使用 RESULT 来改名。</p>
<p>使用递归要有很清楚的逻辑概念，先分析一下阶乘的计算过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n! &#x3D; n*(n-1)*(n-2)*……*3*2*1</span><br></pre></td></tr></table></figure>
<p>因为 n! = n*(n-1)! ，所以调用函数 fact 来计算 n! 时，又可以再调用一次 fact 函数（自身）。</p>
<p>**递归调用时，需要确定一个明确的”终点“，用于停止递归。**不然会造成函数不断地调用自己来执行，可能会导致程序死机。</p>
<p>这里一开始就加入了两个判断：</p>
<ol>
<li>如果 n &lt; 0，则 n 值不合理，不做计算</li>
<li>若n &lt;= 1，根据数学定义 0! = 1! = 1，这是已知的数值。</li>
</ol>
<p>因此，如果用户一开始输入了一个负值，函数 fact 不做计算，直接 return 。 第二个条件是用来做递归的结束条件，当n减到1时，就不再递归下去。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">then</span> <span class="comment">!不合理的输入</span></span><br><span class="line">    ans = -<span class="number">1</span> <span class="comment">!随便设置一个值</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    ans = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br></pre></td></tr></table></figure>
<p>下面详细列出了整个阶乘计算的运行流程，请记住每一次调用 fact 时，它的局部变量都是独立存在的。</p>
<blockquote>
<p>N=4</p>
<p>主程序读入n值</p>
<p>fact(n) = fact(4)</p>
<p>在主程序中第一次调用函数fact来计算 4!</p>
<p>ans = n * fact(n-1) = 4*fact(3)</p>
<p>第1次执行fact时n=4，因为n&gt;1，所以还要调用 fact(n-1)</p>
<p>ans = n * fact(n-1) = 3*fact(2)</p>
<p>第2次执行fact时n=3，因为n&gt;1，所以还要调用 fact(n-1)</p>
<p>ans = n * fact(n-1) = 2*fact(1)</p>
<p>第3次执行fact时n=2，因为n&gt;1，所以还要调用 fact(n-1)</p>
<p>ans = 1</p>
<p>第4次执行fact时会到达递归调用的终点。因为n = 1，所以 ans = 1。函数会开始一个接着一个 return，先返回第3次执行 fact 的地方继续执行。</p>
<p>n*fact(n-1) = 2*fact(1) = 2*1 = 2 = 2!</p>
<p>第3次执行 fact 时 n = 2</p>
<p>n*fact(n-1) = 3*fact(2) = 3*2 = 6 = 3!</p>
<p>第2次执行 fact 时 n = 3</p>
<p>n*fact(n-1) = 4*fact(3) = 4*6 = 24 = 4!</p>
<p>第1次执行 fact 时 n = 4。这个时候计算结束，返回主程序。</p>
<p>fact(4) = 24</p>
</blockquote>
<p>递归调用的思维就在于把难得问题简化，以这个实例来说，因为计算n的阶乘比较难，可以一步步分解来计算。</p>
<p>把这个程序加入一些额外的信息，再重新看一次：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> N&#x3D;</span><br><span class="line">4</span><br><span class="line"> 4! &#x3D;  1th enter,n&#x3D; 4</span><br><span class="line"> 2th enter,n&#x3D; 3</span><br><span class="line"> 3th enter,n&#x3D; 2</span><br><span class="line"> 4th enter,n&#x3D; 1</span><br><span class="line"> 4th exit,n&#x3D; 1 ans&#x3D;       1</span><br><span class="line"> 3th exit,n&#x3D; 2 ans&#x3D;       2</span><br><span class="line"> 2th exit,n&#x3D; 3 ans&#x3D;       6</span><br><span class="line"> 1th exit,n&#x3D; 4 ans&#x3D;      24</span><br><span class="line">      24</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里多加了一些额外信息来显示出程序进行的流程，可以发现函数 fact 会一层一层地深入，再一层一层慢慢 return 回来。第n次调用fact执行完，会回到第 n-1 次调用fact中。</p>
<p>函数 fact 的局部变量 localcount 及 temp 是独立存在于每一次的调用当中，第 n-1 次调用 fact 时的localcount 跟第n次调用 fact 时的localcount 会存放不同的内存中，它们会是两个不同的变量。</p>
<p>用递归的方式计算阶乘， 并不会比使用循环来得好。事实上在这里使用递归程序执行效率会比较差，这里只是为了要示范递归的使用方法而已。不过，在处理某些问题时，使用递归可以大幅精简程序代码。</p>
<h3 id="8-6-2-内部函数">8-6-2 内部函数</h3>
<p>Fortran 90 还可以把函数做一个“归属”，定义出某些函数只能再某些特定的函数中被调用，写法如：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> main 或 <span class="function"><span class="keyword">subroutine</span></span> sub 或 <span class="function"><span class="keyword">function</span></span> func</span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">contains</span> <span class="comment">!contains 后面开始写作局部函数</span></span><br><span class="line">		<span class="function"><span class="keyword">subroutine</span></span> localsub</span><br><span class="line">		……</span><br><span class="line">		<span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span>/<span class="function"><span class="keyword">subroutine</span></span>/<span class="function"><span class="keyword">function</span></span></span><br></pre></td></tr></table></figure>
<p>这个方法，可以用来设计一个函数中的“内部运行”，因为内部运行是不希望被别人所使用的。来看一个实例。</p>
<p>这个程序只是 ex0828 改写后的结果，把函数放在主程序中，这样<strong>函数fact 只能在主程序中被调用，其它函数不能调用它</strong>。还有一点就是在这里<strong>主程序不需要声明就可以直接调用到函数fact</strong>。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0831</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: n</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;N=&#x27;</span></span><br><span class="line">    read(*,*) n</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(i2,&#x27;! = &#x27;,i8)&quot;</span>) n,fact(n)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">contains</span></span><br><span class="line">        <span class="keyword">recursive</span> <span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> fact(n) result(ans)</span><br><span class="line">            <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">            <span class="keyword">integer</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>) :: n</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">then</span> <span class="comment">!不合理的输入</span></span><br><span class="line">                ans = -<span class="number">1</span> <span class="comment">!随便设置一个值</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">                ans = <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line">            <span class="comment">!下面表示 n&gt;1 的情况，利用n*(n-1)! 来计算 n!</span></span><br><span class="line">            ans = n * fact(n-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="8-6-3-PURE函数">8-6-3 PURE函数</h3>
<p>在 function/subroutine 前面加上 pure 就可以使用pure函数。一般情况下不需要使用pure函数，它只是用来配合<strong>并行计算</strong>使用。使用pure函数有很多限制：</p>
<blockquote>
<ol>
<li>pure 函数的参数必须都是只读 intent(in)</li>
<li>pure 子程序的每个参数都要赋值属性</li>
<li>pure 函数中不能使用 save</li>
<li>pure 函数中所包含的内部函数也都必须是 pure 类型函数。</li>
<li>pure 函数中不能使用 stop，print 及跟输出入相关的命令。（如read, write, open, close, backspace,endfile, rewind, inquire）</li>
<li>pure 函数中只能读取，不能改变全局变量的值</li>
</ol>
</blockquote>
<p>这些限制是为了配合并行计算。并行计算可以让程序中，不同部分的程序代码在同时间执行，加快执行速度。如果不对并行计算进行限制，会出现一些问题。例如假设现在同时正在执行函数A和函数B，而这两个函数都可以在屏幕上输出一些信息，假设函数A正好要输出a=1, 函数B正好要输出 b=2，不过由于它们是同时在执行，但是屏幕只有一个，所以有可能会显示 a=b=21, ab==12, b=a1=2 等等的结果。因为 a = 1 跟 b = 2 这两段文本都抢着要输出到屏幕上，结果会导致这两段文本混在一起显示出来。</p>
<p>上面的6项限制，都是为了避免在并行计算时，出现奇怪的执行结果而指定的。</p>
<p>下面我们来看一个实例。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0832</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">external</span> :: func</span><br><span class="line">    <span class="built_in">write</span>(*,*) func(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pure</span> <span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> func(a,b)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>) :: a,b</span><br><span class="line">    func = a+b</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个实例纯粹是示范PURE函数的语法，计算机不具备并行运算能力时，不需要使用PURE函数。</p>
<h3 id="8-6-4-ELEMENTAL-函数">8-6-4 ELEMENTAL 函数</h3>
<p>这个函数也是用于并行计算，它同样有上一个小节中的那6项限制。不过它多了一个功能，可以用来做数组的设置，不过它也多了一个限制，就是它的参数不能是数组。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">10</span>)</span><br><span class="line">a=func(a)</span><br><span class="line"><span class="comment">!如果func 是elemental 函数，这段程序代码执行结果跟下面的循环相同。</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">10</span></span><br><span class="line">a(i) = func(a(i))</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>elemental 函数主要是用来配合 Fortran 90 可以对整个数组操作的语法来设置数组内容。下面是一个实例。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0833</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">interface</span> <span class="comment">!说明函数func的使用接口</span></span><br><span class="line">        <span class="keyword">elemental</span> <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> func(num)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>) :: num </span><br><span class="line">        <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">integer</span> i</span><br><span class="line">    <span class="keyword">real</span> :: a(<span class="number">10</span>) = (/ (i,i=<span class="number">1</span>,<span class="number">10</span>) /)</span><br><span class="line">    <span class="keyword">real</span> :: b(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(10F6.2)&quot;</span>) a</span><br><span class="line">    a = func(a)</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(10F6.2)&quot;</span>) a</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elemental</span> <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> func(num)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>) :: num</span><br><span class="line">    func = <span class="built_in">sin</span>(num) + <span class="built_in">cos</span>(num)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.00  2.00  3.00  4.00  5.00  6.00  7.00  8.00  9.00 10.00</span><br><span class="line">1.38  0.49 -0.85 -1.41 -0.68  0.68  1.41  0.84 -0.50 -1.38</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 elemental 函数时要先说明它的使用接口，主程序才会正确地设置数组地调用。程序的第16行表明上看数据类型并不对，等号左边是个数组，等号右边返回的却只是一个浮点数。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a = func(a)</span><br></pre></td></tr></table></figure>
<p>因为函数 func 是 elemental 类型，这一行会自动变成类似使用循环来执行 a(i) = func(a(i)) 的情况，数组中的每一个数值都会重新设置。不管几维数组都可以使用这个方法来设置数值。</p>
<h2 id="8-7-MODULE">8-7 MODULE</h2>
<p>MODULE 可以用来封装程序模块，通常是用来把程序中，具备相关功能的函数及变量封装在一起。</p>
<h3 id="8-7-1-MODULE-中的变量">8-7-1 MODULE 中的变量</h3>
<p>举例来说，需要使用全局变量时，可以把全局变量都声明在MODULE中，需要使用这些变量的函数只要 USE 这个 MODULE 就可以使用它们。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> a,b</span><br><span class="line">    <span class="keyword">common</span> a,b</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0834</span><br><span class="line">    <span class="keyword">use</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">call</span> sub()</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub()</span><br><span class="line">    <span class="keyword">use</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a,b</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1           2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主程序和子程序都没有声明a,b这两个变量，不过主程序和子程序中都有 use global 这一行描述。变量 a, b 都是声明在 module global 当中，所以只要使用了 global 这个程序单元，就可以看到 a, b 这两个变量。</p>
<p>MODULE 的语法如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> module_name</span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">end</span> [<span class="keyword">module</span> [module_name]]</span><br></pre></td></tr></table></figure>
<p>在函数中使用MODULE时，要在开始声明之前就使用 use module_name 的描述来使用某一个 MODULE。这个实例中，如果不使用 MODULE 的话，主程序和子程序中都要编写重复的程序代码来声明全局变量。还有一点，MODULE的程序代码需要编写在前面，这个程序在主程序和子程序中都使用 module global，所以 module global 要编写在最前面。</p>
<p>MODULE 中的变量如果不是声明成全局变量，这些变量被函数使用时，只会是函数中的局部变量。如果想让函数之间通过MODULE中的变量来传递数据，要把这些变量声明成全局变量。或者是在声明变量时加上 SAVE, 在 MODULE 声明中指定要 SAVE 的变量，功能上也等同于全局变量。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">save</span> :: a</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0835</span><br><span class="line">    <span class="keyword">use</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    <span class="keyword">call</span> sub()</span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub()</span><br><span class="line">    <span class="keyword">use</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    a = <span class="number">20</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">20</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="8-7-2-MODULE-中的自定义类型-TYPE">8-7-2 MODULE 中的自定义类型 TYPE</h3>
<p>在第4章第一次介绍自定义类型TYPE 后，就一直没有再使用它。事实上 TYPE 是个很好用的语法，编写大程序时，会把程序分区成很多函数，使用这些函数有时候会需要传递很多参数，使用自定义类型可以减少参数的数目。</p>
<p>就以本章一开始的射标枪程序为例，如果我们考虑更多的因素，比如风速、阻力等，需要传递的参数就不再只是角度和速度而已。传递多个参数时会很容易发生错误，程序员不可能永远记得每个参数的意义，可能会把参数位置弄反，铸成大错。</p>
<p>如果添加一个自定义类型，把这些数值都封装在这个新的类型中，传递参数时只要传递一个变量过去就行了，来看一个实例。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> constant</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">parameter</span> :: PI = <span class="number">3.14159</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">parameter</span> :: G = <span class="number">9.81</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> player</span><br><span class="line">        <span class="keyword">real</span> :: angle</span><br><span class="line">        <span class="keyword">real</span> :: speed</span><br><span class="line">        <span class="keyword">real</span> :: distance</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0836</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">parameter</span> :: players = <span class="number">5</span></span><br><span class="line">    <span class="keyword">type</span>(player) :: people(players) = (/ player(<span class="number">30.0</span>,<span class="number">25.0</span>,<span class="number">0.0</span>),&amp;</span><br><span class="line">                                        player(<span class="number">45.0</span>,<span class="number">20.0</span>,<span class="number">0.0</span>),&amp;</span><br><span class="line">                                        player(<span class="number">35.0</span>,<span class="number">21.0</span>,<span class="number">0.0</span>),&amp;</span><br><span class="line">                                        player(<span class="number">50.0</span>,<span class="number">27.0</span>,<span class="number">0.0</span>),&amp;</span><br><span class="line">                                        player(<span class="number">40.0</span>,<span class="number">22.0</span>,<span class="number">0.0</span>)&amp;</span><br><span class="line">                                    /)</span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: Get_Distance <span class="comment">!声明Get_Distance 是一个函数。  </span></span><br><span class="line">    <span class="keyword">integer</span> :: I</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> I=<span class="number">1</span>,players</span><br><span class="line">        <span class="keyword">call</span> Get_Distance(people(I))</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Player &#x27;,i1,&#x27; =&#x27;,f8.2)&quot;</span>) I,people(I)%distance</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">!把0~360的角度转换成0~2PI的弧度</span></span><br><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Angle_TO_Rad(angle)</span><br><span class="line">    <span class="keyword">use</span> constant</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> angle</span><br><span class="line">    Angle_TO_Rad = angle*pi/<span class="number">180.0</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">!由角度、切线速度来计算投掷距离</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Get_Distance(person)</span><br><span class="line">    <span class="keyword">use</span> constant</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(player) :: person</span><br><span class="line">    <span class="keyword">real</span> rad,Vx,time</span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: Angle_TO_Rad <span class="comment">!声明Angle_TO_Rad 是个函数</span></span><br><span class="line">    </span><br><span class="line">    rad = Angle_TO_Rad(person%angle) <span class="comment">!单位转换</span></span><br><span class="line">    Vx = person%speed * <span class="built_in">cos</span>(rad) <span class="comment">!水平方向速度</span></span><br><span class="line">    time = <span class="number">2.0</span> * person%speed * <span class="built_in">sin</span>(rad)/G <span class="comment">!在空中飞行时间</span></span><br><span class="line">    person%distance = Vx * time </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>报错了，是下面这一行代码编译出错</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">real</span>,<span class="keyword">external</span> :: Get_Distance <span class="comment">!声明Get_Distance 是一个函数。</span></span><br></pre></td></tr></table></figure>
<p>报错的理由好像是说，这一句应该是用在函数上，但是这里 Get_Distance 是一个子程序，不匹配。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">EX0836.F90:<span class="number">26.33</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: Get_Distance</span><br><span class="line">                                 <span class="number">1</span></span><br><span class="line">Error: <span class="function"><span class="keyword">FUNCTION</span></span> attribute conflicts with <span class="function"><span class="keyword">SUBROUTINE</span></span> attribute <span class="keyword">in</span> <span class="string">&#x27;get_distance&#x27;</span> at (<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用自定义数据类型封装后，一次只要提交一个变量即可。这里主程序和子程序都要用到 player 类型，如果不使用 MODULE，需要在主程序和子程序中都分别声明一次 player 类型才行，这样会让程序代码显得很罗嗦。把自定义类型 player 写在 MODULE 中，只要在函数中 USE 这个 MODULE 就可以认得 player 类型。</p>
<h3 id="8-7-3-MODULE-中的函数">8-7-3 MODULE 中的函数</h3>
<p>MODULE 中还可以容纳函数，编写结构如下。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> module_name</span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">contains</span> <span class="comment">!从contains后开始写作函数</span></span><br><span class="line">	<span class="function"><span class="keyword">subroutine</span></span> sub_name</span><br><span class="line">		……</span><br><span class="line">		……</span><br><span class="line">	<span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br></pre></td></tr></table></figure>
<p>通常会把功能上相关的函数放在同一个 MODULE 模块中。而程序想要调用 MODULE 中的函数时，也要先通过 use module_name 的命令，才能够调用到它们。这个做法比较符合模块化概念，编写大程序时，可以把程序中属于绘图功能的部分放在 module Graphics 中， 把数值计算的部分放在 module Numerical 中。</p>
<p>Visual Fortran 中所提供的一些扩充函数库就用这个方法归类，像是数值函数库 IMSL 就放在 module IMSL，3D 绘图程序库 OpenGL 的函数就放在 module OpenGL 中。使用它们之前都要先 use IMSL, use OpenGL。</p>
<p>在同一个 MODULE 中的变量及函数间还有一个重要的关系，那就是函数可以直接使用同一个 MODULE 里所声明的变量，说明如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> tool</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">	<span class="keyword">integer</span> :: a <span class="comment">!先声明一个变量a</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">contains</span></span><br><span class="line">		<span class="function"><span class="keyword">subroutine</span></span> add()</span><br><span class="line">		<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">		a = a + <span class="number">1</span> <span class="comment">!module 中的子程序可以使用module中声明的变量</span></span><br><span class="line">		……</span><br><span class="line">		</span><br></pre></td></tr></table></figure>
<p>现在我们看看一个把函数编写在MODULE 中的实例程序，改写 ex0836 如下：</p>
<p>这个程序比前一个多了 module shoot .</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> constant</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">parameter</span> :: PI = <span class="number">3.14159</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">parameter</span> :: G = <span class="number">9.81</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> player</span><br><span class="line">        <span class="keyword">real</span> :: angle</span><br><span class="line">        <span class="keyword">real</span> :: speed</span><br><span class="line">        <span class="keyword">real</span> :: distance</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> shoot </span><br><span class="line">    <span class="keyword">use</span> constant</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">!把0~360的角度转换成0~2PI的弧度</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Angle_TO_Rad(angle)</span><br><span class="line">        <span class="keyword">use</span> constant</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> angle</span><br><span class="line">        Angle_TO_Rad = angle*pi/<span class="number">180.0</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">!由角度、切线速度来计算投掷距离</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Get_Distance(person)</span><br><span class="line">        <span class="keyword">use</span> constant</span><br><span class="line">        <span class="keyword">use</span> typedef</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(player) :: person</span><br><span class="line">        <span class="keyword">real</span> rad,Vx,time</span><br><span class="line">        <span class="keyword">real</span>,<span class="keyword">external</span> :: Angle_TO_Rad <span class="comment">!声明Angle_TO_Rad 是个函数</span></span><br><span class="line">        </span><br><span class="line">        rad = Angle_TO_Rad(person%angle) <span class="comment">!单位转换</span></span><br><span class="line">        Vx = person%speed * <span class="built_in">cos</span>(rad) <span class="comment">!水平方向速度</span></span><br><span class="line">        time = <span class="number">2.0</span> * person%speed * <span class="built_in">sin</span>(rad)/G <span class="comment">!在空中飞行时间</span></span><br><span class="line">        person%distance = Vx * time </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0837</span><br><span class="line">    <span class="keyword">use</span> shoot</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">parameter</span> :: players = <span class="number">5</span></span><br><span class="line">    <span class="keyword">type</span>(player) :: people(players) = (/ player(<span class="number">30.0</span>,<span class="number">25.0</span>,<span class="number">0.0</span>),&amp;</span><br><span class="line">                                        player(<span class="number">45.0</span>,<span class="number">20.0</span>,<span class="number">0.0</span>),&amp;</span><br><span class="line">                                        player(<span class="number">35.0</span>,<span class="number">21.0</span>,<span class="number">0.0</span>),&amp;</span><br><span class="line">                                        player(<span class="number">50.0</span>,<span class="number">27.0</span>,<span class="number">0.0</span>),&amp;</span><br><span class="line">                                        player(<span class="number">40.0</span>,<span class="number">22.0</span>,<span class="number">0.0</span>)&amp;</span><br><span class="line">                                    /)</span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: Get_Distance <span class="comment">!声明Get_Distance 是一个函数。  </span></span><br><span class="line">    <span class="keyword">integer</span> :: I</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> I=<span class="number">1</span>,players</span><br><span class="line">        <span class="keyword">call</span> Get_Distance(people(I))</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Player &#x27;,i1,&#x27; =&#x27;,f8.2)&quot;</span>) I,people(I)%distance</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="8-8-一些少用的功能">8-8 一些少用的功能</h2>
<h3 id="8-8-1-ENTRY">8-8-1 ENTRY</h3>
<p>ENTRY 用来在函数中创建一个新的“入口”，调用这个入口时，会跳过进入点之前的程序代码来执行函数，直接用一个实例来说明：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0838</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">call</span> sub()</span><br><span class="line">    <span class="keyword">call</span> mid()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub()</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Hello.&quot;</span></span><br><span class="line">    <span class="built_in">entry</span> mid() <span class="comment">!另一个进入点mid</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Good morning.&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello.</span><br><span class="line">Good morning.</span><br><span class="line">Good morning.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>前两行输出是调用子程序 sub 时所得到的，第3行输出是调用子程序中的另一个进入点 mid 得到的。 entry 在子程序 sub 建立了一个新的调用进入点 mid。主程序调用 mid 时，会从子程序 sub 中， entry mid() 这一行来执行程序。</p>
<h3 id="8-8-2-特别的-return">8-8-2 <s>特别的 return</s></h3>
<p>从函数中 return 返回调用处时，通常会直接返回调用处来继续执行程序。关于这一点也是可以改变的，调用函数时可以额外指定其他的折返点，这里有一个实例：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0839</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a</span><br><span class="line">    </span><br><span class="line">    read(*,*) a</span><br><span class="line">    <span class="keyword">call</span> sub(a,*<span class="number">100</span>,*<span class="number">200</span>)</span><br><span class="line">    <span class="comment">!特别另外指定两个折返点，分别时行代码100及200这两个地方</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Default&quot;</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line">    <span class="number">100</span> <span class="built_in">write</span>(*,*) <span class="string">&quot;Return 1&quot;</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line">    <span class="number">200</span> <span class="built_in">write</span>(*,*) <span class="string">&quot;Return 2&quot;</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub(a,*,*)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a</span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">0</span>) tehn</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">!返回默认的折返点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="comment">!返回特别指定的第1个折返点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> <span class="comment">!返回特别指定的第2个折返点</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序执行后会要求输入一个整数，输入值小于等于0时，调用子程序 sub 会返回默认折返点。输入值为1时，会返回特定指定的第1个折返点。输入其他值会返回特别指定的第2个折返点。</p>
<p>程序第6行输入的最后两个参数时程序代码中的行代码，要加上星号来做识别，不然会被当成普通的整数，它们用来指定折返点的位置</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> sub(a,*<span class="number">100</span>,*<span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<p>子程序sub接收最后两个参数时只要使用星号就行了，不需要再声明变量去接收。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub(a,*,*)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我一看到行代码，就知道这个我用不上。</p>
</blockquote>
<h2 id="8-9-使用多个文件">8-9 使用多个文件</h2>
<p>程序员通常会把一些具有相关功能的函数，独立编写在不同的文件中，编译器可以分别编译这些程序文件，最后再把它们链接到同一个执行文件中。把程序代码分散在不同的文件中有几个好处：</p>
<ol>
<li>独立文件的函数，可以再拿给其他程序使用</li>
<li>可以加快编译速度，修改其中一个文件时，编译器只需要重新编译这个文件就行了。</li>
</ol>
<p>这个小节会教读者如何把程序代码分散到不同文件中。</p>
<h3 id="8-9-1-include">8-9-1 include</h3>
<p>include 命令用在程序代码中，插入另一个文件中的内容。这是在 Fortran 中使用多个文件的最简单方法，下面的实例包含两个文件，读者要先确定这两个文件都放在同一个目录下再来做编译。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0840m</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">call</span> sub() <span class="comment">!子程序sub写在另一个文件中</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;EX0840S.F90&#x27;</span> <span class="comment">!在这里插入 EX0840S.F90 这个文件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第二个程序 EX0840S.F90</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub()</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Hello.&quot;</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于采用了 include 命令将第二个文件的内容插入了进来，直接编码运行第一个程序即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gfortran EX0840M.F90</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./a.out</span></span><br><span class="line"> Hello.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个实例把主程序和子程序写在两个不同文件中，然后采用 include 合并在一块。</p>
<p>include 命令可以写在任何地方，它只是单纯地用来插入一个文件的内容。有时候也会应用在声明全局变量，先把声明全局变量的程序代码编写在某个文件中，需要使用全局变量的时候再去include这个文件（这种情况用 module 不香嘛，作者也说了 module 更香）。</p>
<h3 id="8-9-4-程序库">8-9-4 程序库</h3>
<p>具有特殊功能的一组函数，可以编译成*.LIB 程序库来给其他人使用。*.LIB 的文件内容经过编译，无法从这个文件中读到初始程序代码。<strong>如果程序员想保留自己的独门技巧不被外人偷学，可以把程序代码编译成程序库之后，再交给其他人使用。</strong></p>
<p>市面上也有一些公司专门开发程序库，著名的有数值运算的 IMSL 等。使用程序库可以减轻程序员的负担。</p>
<h2 id="8-10-函数的应用">8-10 函数的应用</h2>
<h2 id="8-11-习题">8-11 习题</h2>
<h3 id="8-11-1-通过子程序计算圆面积">8-11-1 通过子程序计算圆面积</h3>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">parameter</span> :: pi = <span class="number">3.14159</span></span><br><span class="line">    <span class="keyword">real</span> r,s</span><br><span class="line">    <span class="keyword">common</span> r,s</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0841</span><br><span class="line">    <span class="keyword">use</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;radius is&quot;</span></span><br><span class="line">    read(*,*) r</span><br><span class="line">    <span class="keyword">call</span> Circle_Area()</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Circle_Area()</span><br><span class="line">    <span class="keyword">use</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    s = pi*r**<span class="number">2</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;area is &#x27;,f8.2)&quot;</span>) s</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>输入输出为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> radius is</span><br><span class="line">2</span><br><span class="line">area is    12.57</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="8-11-2-通过函数计算圆面积">8-11-2 通过函数计算圆面积</h3>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0841</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> r,s</span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: Circle_Area <span class="comment">!声明Circle_Area是一个函数</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;radius is&quot;</span></span><br><span class="line">    read(*,*) r</span><br><span class="line">    s = Circle_Area(r)</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;area is &#x27;,f8.2)&quot;</span>) s</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Circle_Area(r)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">parameter</span> :: pi = <span class="number">3.14159</span></span><br><span class="line">    <span class="keyword">real</span> r</span><br><span class="line">    Circle_Area = pi*r**<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数这里不好用 module 来事先指定参数的类型（除非是固定参数，比如这里的pi），比如这里的函数的参数r，好像必须要在函数中指定。</p>
<h3 id="8-11-3-画长条图">8-11-3 画长条图</h3>
<p>pass</p>
<h3 id="8-11-4-计算等差数列1-2-3-……-100的结果">8-11-4 计算等差数列1+2+3+……+100的结果</h3>
<p>直接套用之前阶乘的程序。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0828</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: n</span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">external</span> :: fact</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;N=&quot;</span></span><br><span class="line">    read(*,*) n</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(i2,&#x27;! = &#x27;,i8)&quot;</span>) n,fact(n)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">recursive</span> <span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> fact(n) result(ans)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>) :: n</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">then</span> <span class="comment">!不合理的输入</span></span><br><span class="line">        ans = -<span class="number">1</span> <span class="comment">!随便设置一个值</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line">    <span class="comment">!下面表示 n&gt;1 的情况，利用n*(n-1)! 来计算 n!</span></span><br><span class="line">    ans = n + fact(n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="8-11-5-计算两个整数的最大公因子">8-11-5 计算两个整数的最大公因子</h3>
<p>一开始没想到怎么做，后来想到用<strong>递归</strong>来做，按较小的整数，每次自减1，看能不能被原来的两个整数整除。</p>
<p>先留个伪代码在这。我还不清楚fortran怎么判断整除，但有了这个思路了，写起来也很简单。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0. 先判断两个整数是不是符合要求，必须为正数。</span><br><span class="line">1. 先看两个整数能否直接整除，如果能，最大公因子就是较小的整数。</span><br><span class="line">2. 如果不能，以较小的数为基本，每次自减1，看能否被两个整数整除。递归的终点是1。</span><br></pre></td></tr></table></figure>
<h1>9 文件</h1>
<p>文件是很实用的功能，使用文件才能永远记录程序的执行结果。</p>
<h2 id="9-1-文件读取的概念">9-1 文件读取的概念</h2>
<p>在 Fortran 语言中，读取文件的操作可以有“顺序读取”及“直接读取” 两种方式。</p>
<p>所谓的“顺序读取”，是指读写一个文件时，只能从头开始，一步步地向下来读取数据，就像听录音带一样。想要略过数据、或是重新读取时，同样要先“快转” 或是 “倒带”。这是最简单地文件运行方式，不过已经足以应付许多的状况。</p>
<p>而“直接读取” 是指在读写文件时，可以任意跳跃到文件的任何一个位置来读写。</p>
<p>另外在文件的“保存格式” 上，也有两种方法：分别是“文本文件” 以及 “二进制文件”。使用二进制文件无法看到内容，它的好处是：一是<strong>读取速度比较快</strong>，因为它的保存格式和数据在内存中的保存方法相同，不像“文本文件”需要经过转换。另一个优点是<strong>较省空间</strong>。</p>
<h2 id="9-2-文件的操作">9-2 文件的操作</h2>
<p>在 Fortran 中，跟文件有关的操作命令非常丰富，不过有很多命令根本就不常用，只需要先浏览一遍。</p>
<h3 id="9-2-1-open-的使用">9-2-1 open 的使用</h3>
<p>前面使用 READ, WRITE 命令时，括号的第一栏都是放一个星号，表示输入/出的位置使用默认值，也就是从键盘输入以及从屏幕输出。使用open命令打开文件之后，就可以对文件进行输入/出，来看看下面这个实例：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0901</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    open(<span class="keyword">unit</span>=<span class="number">10</span>, <span class="keyword">file</span> = <span class="string">&#x27;hello.txt&#x27;</span>)</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">10</span>,*) <span class="string">&quot;hello&quot;</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行后生成了一个文件，程序第3行使用 open 命令来打开文件，open的第1个参数用来给文件指定一个代码（避开1,2,5,6，因为2,6 是默认的输出位置，也就是屏幕。1,5 是默认的输入位置，也就是键盘 ），第二个参数是文件名称（最好不要使用中文名称）。文件打开之后，程序中都会以这个代码来使用 hello.txt 这个文件。</p>
<p>文件打开之后，使用 read, write 命令时，把输入/出的位置指定成某个文件代码，就可以读写文件。</p>
<p>open的具体参数</p>
<blockquote>
<p>open(unit=number, file=filename, form=…, status=…, access=…, recl=length, err=label, iostat=iostat, blank=…, position=…, action=action, pad=…, delim=…,)</p>
<ul>
<li>
<p>form = ‘formatted’ (表示文件使用“文本文件”格式保存) or ‘unformatted’ (“二进制文件”格式保存)</p>
</li>
<li>
<p>status = ‘new’ /  ‘old’ / ‘scratch’ / ‘unkown’</p>
<p>‘new’ : 表示这个文件原本不存在，是第一次打开</p>
<p>’old’ : 表示这个文件原本已经存在</p>
<p>‘replace’ : 文件若已经存在，会重新创建一次，原本的内容会消失。文件若不存在，会创建新文件。</p>
<p>’scratch’ : 表示要打开一个暂存盘，这个时候可以不需要指定文件名称，也就是 FILE 这一栏可以忽略。因为程序本身会自动取一个文件名，至于文件名是什么也不重要，因为暂存盘会在程序结束后自动删除。</p>
<p>‘unknown’ : 由各编译器自定义。通常会同 replace 的效果</p>
<p>这一栏不给定时，默认为 unkonwn</p>
</li>
<li>
<p>access = ‘sequential’ / ‘direct’</p>
<p>设置读写文件的方法。</p>
<p>‘sequential’ ：顺序读取，默认值</p>
<p>‘direct’ ：直接读取，读写文件可以任意指定位置。</p>
</li>
<li>
<p>recl = length</p>
<p>在顺序读取文件中，recl 字段用来设置一次可以读写多大容量的数据。</p>
<p>在打开“直接读取文件”时，recl = length 的 length 值是用来设置文件中的每一个模块单元的区分长度。</p>
</li>
<li>
<p>err = label</p>
<p>这个字段用来设置当文件打开发生错误时，程序会跳跃到 label 所指的行代码处来继续执行程序。</p>
</li>
<li>
<p>iostat = var</p>
<p>这个字段会设置一个整数值给后面的整型变量，这是用来说明文件打开的状态，数值会有三种情况。</p>
<p>var &gt; 0    表示读取操作发生错误</p>
<p>var = 0    表示读取操作正常</p>
<p>var &lt; 0     表示文件终了</p>
</li>
<li>
<p>blank = ‘null’ / ‘zero’</p>
<p>这用来设置文件输入数字时，当所设置的格式字段中有空格存在时所代表的意义。‘null’ 说明空格代表没有东西；’zero’ ，空格部分会自动以0代入。</p>
</li>
</ul>
</blockquote>
<p>以下为 Fortran 90 添加功能</p>
<blockquote>
<ul>
<li>
<p>position = ‘asis’ / ‘rewind’ / ‘append’</p>
<p>‘asis’ :  表示文件打开时的读取位置，不特别指定，通常就是在文件开头。这是默认值。</p>
<p>‘rewind’ ： 表示文件打开时的读取位置移到文件的开头</p>
<p>‘append’ ：表示文件打开时的读取位置移到文件的末尾</p>
</li>
<li>
<p>action = ‘read’ / ‘write’ / ‘readwrite’</p>
<p>‘readwrite’ :  可读可写，默认值</p>
<p>’read’ : 只读</p>
<p>‘write’ : 只写</p>
</li>
<li>
<p>pad = ‘yes’ / ‘no’</p>
<p>‘yes’ :  在格式化输出时，最前面的不足字段会自动以空格填满，默认值</p>
<p>‘no’ :  不会自动以空格填满</p>
</li>
<li>
<p>delim = ‘apostrophe’ / ‘quote’ / ‘none’</p>
<p>‘none’ : 纯粹输出字符串内容</p>
<p>‘quote’ :  输出字符串加上双引号</p>
<p>‘apostrophe’ : 输出字符串加上单引号</p>
</li>
</ul>
</blockquote>
<h3 id="9-2-2-write-read-的使用">9-2-2 write, read 的使用</h3>
<p>先看一个实例</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0902</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: string</span><br><span class="line">    </span><br><span class="line">    open(<span class="keyword">unit</span>=<span class="number">10</span>, <span class="keyword">file</span> = <span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">10</span>,<span class="string">&quot;(a20)&quot;</span>) <span class="string">&quot;Good morning.&quot;</span> <span class="comment">!写到文件中</span></span><br><span class="line">    rewind(<span class="number">10</span>)</span><br><span class="line">    read(<span class="number">10</span>,<span class="string">&quot;(a20)&quot;</span>) string <span class="comment">!从文件中读出来</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(a20)&quot;</span>) string <span class="comment">!写到屏幕上</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>这里通过 <code>rewind(10)</code> 把文件的读写位置移回文件最前面。</p>
<p>现在来详细介绍 read, write 命令的所有功能，这两个命令的设置字段都很类似，所以可以一起介绍：</p>
<blockquote>
<p>write/read(unit=number, fmt=format, nml=namelist, rec=record, iostat=stat, err=errlabel, end=endlabel, advance=advance, size=size)</p>
<ul>
<li>
<p>unit</p>
</li>
<li>
<p>fmt : 指定输入输出格式</p>
</li>
<li>
<p>nml = namelist</p>
<p>指定读写某个 namelist 的内容。</p>
</li>
<li>
<p>rec = record</p>
<p>在直接读取文件中，设置所要读写的文件模块位置</p>
</li>
<li>
<p>iostat,err ： 同上</p>
</li>
<li>
<p>end = endlabel</p>
<p>指定在读写到文件末尾时，要转移到某个行代码来继续执行程序。</p>
</li>
</ul>
</blockquote>
<p>以下是 Fortran 90 添加功能</p>
<blockquote>
<ul>
<li>
<p>advance = ‘yes’ / ‘no’ : 设置在文本格式下的顺序文件中，每一次的 read, write 命令完成后，读写位置会不会自动向下移动一行。</p>
</li>
<li>
<p>size = count</p>
<p>当 advance = ‘no’ 时，才可以用这个字段。它会把这一次输出入的字符数目设置给后面的整型变量</p>
</li>
</ul>
</blockquote>
<h3 id="9-2-3-查询文件的状态">9-2-3 查询文件的状态</h3>
<p>在使用 open 命令打开文件的前后，都可以通过 inquire 命令来查询文件目前的情况，inquire 命令中的每个字段和第一个小节open的字段很类似。先来看一小段程序，编写一个检查某个文件是否存在的程序：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0903</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: filename = <span class="string">&quot;EX0903.F90&quot;</span></span><br><span class="line">    <span class="keyword">logical</span> alive</span><br><span class="line">    </span><br><span class="line">    inquire(<span class="keyword">file</span>=filename, <span class="keyword">exist</span>=alive)</span><br><span class="line">    <span class="keyword">if</span>(alive) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) filename, <span class="string">&quot; exist.&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) filename, <span class="string">&quot; doesn&#x27;t exist&quot;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里通过 inquire 命令来查询字符串 filename 中记录的文件是否存在。文件存在时 alive 会被设为 .true. ， 不存在则会被设为 .false.</p>
<p>下面详细介绍 inquire 的使用方法:</p>
<blockquote>
<p>inquire(unit=number, file=filename, iostat=stat, err=label, exist=exist, opened=opened, number=number, named=named, access=access, sequential=sequential, direct=direct, form=form, formatted=formatted, unformatted=unformatted, recl=recl)</p>
<ul>
<li>
<p>exist = exist</p>
<p>检查文件是否存在，会返回一个布尔向量给后面的逻辑变量。</p>
</li>
<li>
<p>opened = opened</p>
<p>检查文件是否已经使用 open 命令来打开，会返回一个布尔变量给后面的逻辑变量。</p>
</li>
<li>
<p>number = number</p>
<p>由文件名来查询这个文件所给定的代码。</p>
</li>
<li>
<p>named = named</p>
<p>查询文件是否取了名字，也就是检查文件是否为临时保存盘。</p>
</li>
<li>
<p>access = access</p>
<p>检查文件的读取格式，会返回一个字符串，字符串值可以是：</p>
<p>‘sequential’ : 代表文件使用顺序读取格式</p>
<p>‘direct’ : 代表文件使用直接读取格式</p>
<p>‘undefined’ : 代表没有定义</p>
</li>
<li>
<p>sequential = sequential</p>
<p>查看文件是否使用顺序格式，会返回一个字符串，字符串值可以是：</p>
<p>‘yes’ / ‘no’ / ‘unknown’</p>
</li>
<li>
<p>direct = direct</p>
<p>查看文件是否使用直接格式，会返回一个字符串，字符串值可以是：</p>
<p>‘yes’ / ‘no’ / ‘unknown’</p>
</li>
<li>
<p>form = form</p>
<p>查看文件的保存方法，会返回一个字符串，字符串值可以是：</p>
<p>‘formatted’ : 打开的是文本文件</p>
<p>‘unformatted’ : 打开的是二进制文件</p>
<p>‘undefined’ : 没有定义</p>
</li>
<li>
<p>formatted = fmt</p>
<p>查看文件是否是文本文件，会返回一个字符串，字符串值可以是：</p>
<p>‘yes’ / ‘no’ / ‘unknown’</p>
</li>
<li>
<p>recl = length</p>
<p>返回 open 文件时 recl 栏的设置值</p>
</li>
<li>
<p>nextrec = nr</p>
<p>返回下一次文件读写的位置</p>
</li>
<li>
<p>blank = blank</p>
<p>返回值是字符串，用来查看open文件时的blank参数所给定的字符串值。</p>
</li>
</ul>
</blockquote>
<p>以下为 Fortran 90 添加功能</p>
<blockquote>
<ul>
<li>
<p>position=position</p>
<p>返回打开文件时 position 字段所给定的字符串。</p>
</li>
<li>
<p>action=action</p>
<p>返回打开文件时 action 字段所赋值的字符串</p>
</li>
<li>
<p>delim=delim</p>
<p>返回打开文件时 delim 字段所设置的字符串</p>
</li>
<li>
<p>pad=pad</p>
<p>返回打开文件时 pad 字段所设置的字符串</p>
</li>
</ul>
</blockquote>
<p>其他文件运行命令</p>
<blockquote>
<ul>
<li>
<p>backspace(unit=number, err=errlabel, iostat=iostat)</p>
<p>把文件的读写位置退回一步，其他字段参考上一节</p>
</li>
<li>
<p>endfile(unit=number, err=errlabel, iostat=iostat)</p>
<p>把文件的读写位置变成文件的结尾</p>
</li>
<li>
<p>rewind(unit=number, err=errlabel, iostat=iostat)</p>
<p>把文件的读写位置倒回文件开头。</p>
</li>
<li>
<p>close(unit=number, status=string, err=errlabel, iostat=iostat)</p>
<p>把文件关闭，不再进行读写操作</p>
<p>status=‘keep’ 会在文件关闭后，保留住这个文件。默认值</p>
<p>status=‘delete’ 会在文件关闭后，消除这个文件。</p>
</li>
</ul>
</blockquote>
<p>前面示例过 rewind 的 用法，这里来举例编写一个删除文件的程序：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0904</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">logical</span> alive</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: filename;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*)  <span class="string">&quot;filename:&quot;</span></span><br><span class="line">    read(*,<span class="string">&quot;(a20)&quot;</span>) filename</span><br><span class="line">    </span><br><span class="line">    inquire(<span class="keyword">file</span>=filename, <span class="keyword">exist</span>=alive)</span><br><span class="line">    <span class="keyword">if</span> (alive) <span class="keyword">then</span></span><br><span class="line">        open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename)</span><br><span class="line">        close(fileid, <span class="keyword">status</span>=<span class="string">&quot;delete&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="built_in">trim</span>(filename),<span class="string">&quot; doesn&#x27;t exist.&quot;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序执行后会要求输入一个文件名称，如果存在则删除，如果不存在则会输出错误信息。</p>
<p>删除文件的方法很简单，先用 open 打开，再用 close 关闭文件，close 时赋值不保留这个文件就会把它删除。</p>
<h2 id="9-3-顺序文件的操作">9-3 顺序文件的操作</h2>
<p>顺序文件就好像使用录音带、录像带一样，只能慢慢地播放带子。想要略过一些片段时，要使用快进来跳过它们。</p>
<p>在 windows 的命令窗口下，type 命令可以用来在屏幕上快速浏览一个文本文件内容。下面的实例程序有同样的功能。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0905</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">79</span>) :: filename</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">79</span>) :: buffer</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">integer</span> :: <span class="keyword">status</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">logical</span> alive</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Filename:&quot;</span></span><br><span class="line">    read(*, <span class="string">&quot;(a79)&quot;</span>) filename</span><br><span class="line">    inquire(<span class="keyword">file</span>=filename, <span class="keyword">exist</span>=alive)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(alive) <span class="keyword">then</span></span><br><span class="line">        open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename, &amp;</span><br><span class="line">            <span class="keyword">access</span>=<span class="string">&quot;sequential&quot;</span>, <span class="keyword">status</span>=<span class="string">&quot;old&quot;</span>)</span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">            read(<span class="keyword">unit</span>=fileid, <span class="keyword">fmt</span>=<span class="string">&quot;(a79)&quot;</span>, <span class="keyword">iostat</span>=<span class="keyword">status</span>) buffer</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">status</span>/=<span class="number">0</span>) <span class="keyword">exit</span> <span class="comment">!没有数据就跳出循环</span></span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(a79)&quot;</span>) buffer</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="built_in">trim</span>(filename),<span class="string">&quot; doesn&#x27;t exist.&quot;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序运行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> Filename:</span><br><span class="line">hello.txt</span><br><span class="line"> hello</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序会先要求用户输入所要阅读的文件名，输入完毕后，再使用 inquire 命令来检查文件是否存在。如果文件存在，就会开始读取文件：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename, &amp;</span><br><span class="line">            <span class="keyword">access</span>=<span class="string">&quot;sequential&quot;</span>, <span class="keyword">status</span>=<span class="string">&quot;old&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这里 status 默认值是 unknown ，一般编译的做法是若文件已存在，它会被改写，如果不存在，就会打开一个新的文件。这里由于已经确认这个文件已存在，所以这里 status 设置为 old。</p>
<p>文件打开之后，就使用循环来一行一行地读出文件内容。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">	read(<span class="keyword">unit</span>=fileid, <span class="keyword">fmt</span>=<span class="string">&quot;(a79)&quot;</span>, <span class="keyword">iostat</span>=<span class="keyword">status</span>) buffer</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">status</span>/=<span class="number">0</span>) <span class="keyword">exit</span> <span class="comment">!没有数据就跳出循环</span></span><br><span class="line">	<span class="built_in">write</span>(*, <span class="string">&quot;(a79)&quot;</span>) buffer</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>这个循环的工作是：“每次读入一行后，就把这一行的文本写到屏幕上”。 read 命令每读一次，会自动把读取位置移动到下一行。所以这里每一次 read 命令都会读入一行新的文本。不过在读取字符串时，限定输入格式，限定它一次读入每一行的前79个字符，因为在标准的 DOS 及 windows 命令行窗口中，一次也只能显示 80 个字符，所以读太多字符没有意义。如果刚好输出 80 个字符，有的编译器所编译的程序会发生断行的现象。</p>
<p>因为没有办法事先就知道文件会有几行文本，也就不会事先知道应该执行几次循环。这里循环的终止条件是当变量 status 不为0的时候。</p>
<p>上一个程序只是单纯地读取文件而已，现在来看看一个需要写入文件的程序。下面的实例程序可以用来记录全班同学的中文、英文及数学的考试成绩：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">type</span> student</span><br><span class="line">        <span class="keyword">integer</span> Chinese, English, Math</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0906</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: students</span><br><span class="line">    <span class="keyword">type</span>(student), <span class="keyword">allocatable</span> :: s(:)</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) :: filename = <span class="string">&quot;data.txt&quot;</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;班上有多少学术&quot;</span></span><br><span class="line">    read(*,*) students</span><br><span class="line">    <span class="built_in">allocate</span>(s(students), stat=i)</span><br><span class="line">    <span class="keyword">if</span>(i/=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;Allocate buffer fail.&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    open(fileid, <span class="keyword">file</span>=filename)</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>, students</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;请输入&#x27;i2&#x27;号同学的中文、英文及数学成绩&#x27;&quot;</span>) i</span><br><span class="line">        read(*,*) s(i)%Chinese, s(i)%English, s(i)%Math</span><br><span class="line">        <span class="built_in">write</span>(fileid, <span class="string">&quot;(&#x27;site:&#x27;i2/&#x27;Chinese:&#x27;i3&#x27; English:&#x27;i3&#x27; Math:&#x27;i3)&quot;</span>) i,s(i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    close(fileid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译报错，报错的地方在这一句</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">write</span>(fileid, <span class="string">&quot;(&#x27;site:&#x27;i2/&#x27;Chinese:&#x27;i3&#x27; English:&#x27;i3&#x27; Math:&#x27;i3)&quot;</span>) i,s(i)</span><br></pre></td></tr></table></figure>
<p>报错信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Error: Unexpected end of format string in format string at (1)</span><br></pre></td></tr></table></figure>
<p>暂时还不清楚原因。</p>
<p>如果运行成功，data.txt 文件的格式应该如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">座号：1</span><br><span class="line">中文：82 英文：90 数学：95</span><br></pre></td></tr></table></figure>
<p>这里将文件的代码赋值给了一个常数（fileid）, 这个方法可以避免在写大程序时，同时打开多个文件却忘记文件代码，毕竟使用变量名称会比硬记数字容易。（确实好一点，可以和 python 一致）</p>
<p>打开这个文件时并没有赋值 status 字段，没有说明文件是“新的”或是“旧的”。这个方法在第1次执行程序时会创造出新文件，第2次执行后则会重新覆盖掉文件上一次的记录。</p>
<p>循环执行结束后，用 close(fileid) 把文件关闭，程序结束。如果省略关闭文件的操作，在程序结束时其实也会自动关闭文件。不过最好还是养成自己来关闭文件的习惯比较好。</p>
<p>这个程序只是示范了如何把成绩写到文件中，如何把成绩从文件中读出来是另外一个问题。读取成绩时要注意格式，要懂得略过一些没有必要的数据。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">type</span> student</span><br><span class="line">        <span class="keyword">integer</span> Chinese, English, Math</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0907</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(student) :: s</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) :: filename = <span class="string">&quot;data.txt&quot;</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">logical</span> alive </span><br><span class="line">    <span class="keyword">integer</span> :: error</span><br><span class="line">    <span class="keyword">integer</span> :: no</span><br><span class="line">    </span><br><span class="line">    inquire(<span class="keyword">file</span>=filename, <span class="keyword">exist</span>=alive)</span><br><span class="line">    <span class="keyword">if</span>(.not. alive)<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="built_in">trim</span>(filename),<span class="string">&quot; doesn&#x27;t exist.&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    open(fileid, <span class="keyword">file</span>=filename)</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        read(fileid, <span class="string">&quot;(5xi2,/,5xi3,6xi3,6xi3)&quot;</span>, <span class="keyword">iostat</span>=error) no,s</span><br><span class="line">        <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(i2,&#x27;号 中文:&#x27;i3&#x27; 英文:&#x27;i3&#x27; 数学:&#x27;i3)&quot;</span>) no,s</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    close(fileid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于每一位学生的数据都占两行，先保存座号再保存成绩，而且使用的字段是固定的。要读取数据也要用相同的格式及字段来读取数据，下面会把输出跟输入部分的程序代码列出来做比较，读者可以发现输出时的文本部分，在输入时都使用 nX 来跳过它们。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!输出</span></span><br><span class="line"><span class="built_in">write</span>(fileid, <span class="string">&quot;(&#x27;座号:&#x27;i2/&#x27;中文:&#x27;i3&#x27; 英文:&#x27;i3&#x27; 数学:&#x27;i3)&quot;</span>) i,s(i)</span><br><span class="line"><span class="comment">!输入</span></span><br><span class="line">read(fileid, <span class="string">&quot;(5xi2,/,5xi3,6xi3,6xi3)&quot;</span>, <span class="keyword">iostat</span>=error) no,s</span><br></pre></td></tr></table></figure>
<p>输入时，文本中的一些文本，例如”座号:“ 等字符对程序来说都没有意义，程序只要读取它们后面的数字就行了，这些文本可以跳过去不管它。输入格式中的 nX 都是用来跳过这些文本，<strong>请注意一个中文字占的宽度正好是两个英文字母的宽度，所以”座号:“ 会占用5个英文字母的位置。</strong>（一个中文两个字节）。</p>
<p>上一个实例中，因为学生数据的保存格式是固定的。先保存座号，再根据顺序保存中文、英文、数学成绩。所以程序可以直接略过说明字符串。如果每一条数据的位置不固定，读取数据时会很麻烦。</p>
<p>现在来尝试读取一个版面格式比较自由的文件，这个文件记录了好几位篮球员的姓名、身高、体重、平均得分等等数据，每位球员的第一条数据都固定是姓名，其他数据就不固定顺序。每位球员的数据之间可以有任意数目的空行，这个文件（EX0908DAT.TXT）的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">姓名 王天才</span><br><span class="line">体重 80.5 </span><br><span class="line">身高 195.2</span><br><span class="line">得分 15.8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">姓名 李天才</span><br><span class="line">身高 190.3 </span><br><span class="line">体重 85.1</span><br><span class="line">得分 10.8</span><br><span class="line"></span><br><span class="line">姓名 洪天才</span><br><span class="line">体重 90.8</span><br><span class="line">身高 201.3</span><br><span class="line">得分 19.8</span><br><span class="line"></span><br><span class="line">姓名 彭天才</span><br><span class="line">体重 70.2</span><br><span class="line">得分 22.2 </span><br><span class="line">身高 185.0</span><br><span class="line"></span><br><span class="line">姓名 黄天才</span><br><span class="line">得分 20.1</span><br><span class="line">体重 85.0</span><br><span class="line">身高 190.3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在需要一个程序来读入所有选手的数据，并挑选出平均每场可以得分20分以上的球员来显示他们的数据。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">type</span> player</span><br><span class="line">        <span class="keyword">character</span>(len=<span class="number">80</span>) :: <span class="keyword">name</span></span><br><span class="line">        <span class="keyword">real</span> weight, height</span><br><span class="line">        <span class="keyword">real</span> score</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0908</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: filename = <span class="string">&quot;EX0908DAT.TXT&quot;</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">20</span></span><br><span class="line">    <span class="keyword">logical</span> :: alive <span class="comment">!检查文件是否存在</span></span><br><span class="line">    <span class="keyword">type</span>(player) :: p <span class="comment">!读取选手数据</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">10</span>) :: title <span class="comment">!读取数据项</span></span><br><span class="line">    <span class="keyword">real</span> tempnum <span class="comment">!读取数据</span></span><br><span class="line">    <span class="keyword">logical</span>, <span class="keyword">external</span> :: GetNextPlayer <span class="comment">!找出下一位球员的函数</span></span><br><span class="line">    <span class="keyword">integer</span> i <span class="comment">!循环记数器</span></span><br><span class="line">    <span class="keyword">integer</span> error <span class="comment">!检查文件读取是否正常</span></span><br><span class="line">    </span><br><span class="line">    inquire(<span class="keyword">file</span>=filename, <span class="keyword">exist</span>=alive)</span><br><span class="line">    <span class="keyword">if</span>(.not. alive) <span class="keyword">then</span> <span class="comment">!文件不存在就结束程序</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="built_in">trim</span>(filename),<span class="string">&quot; doesn&#x27;t exist&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename)</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="keyword">if</span>(GetNextPlayer(fileid, p%<span class="keyword">name</span>)) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">3</span></span><br><span class="line">                read(fileid, <span class="string">&quot;(a4,1x,f3.2)&quot;</span>, <span class="keyword">iostat</span>=error) title, tempnum</span><br><span class="line">                <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">                    <span class="built_in">write</span>(*,*) <span class="string">&quot;文件读取错误&quot;</span></span><br><span class="line">                    <span class="keyword">stop</span></span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">                <span class="comment">!要经过每一行最前面两个中文来判断读入的是什么数据</span></span><br><span class="line">                <span class="keyword">select</span> <span class="keyword">case</span>(title)</span><br><span class="line">                <span class="keyword">case</span>(<span class="string">&quot;身高&quot;</span>)</span><br><span class="line">                    p%height = tempnum</span><br><span class="line">                <span class="keyword">case</span>(<span class="string">&quot;体重&quot;</span>)</span><br><span class="line">                    p%weight = tempnum</span><br><span class="line">                <span class="keyword">case</span>(<span class="string">&quot;得分&quot;</span>)</span><br><span class="line">                    p%score = tempnum</span><br><span class="line">                <span class="keyword">case</span> <span class="keyword">default</span></span><br><span class="line">                    <span class="built_in">write</span>(*,*) <span class="string">&quot;出现不正确的数据&quot;</span></span><br><span class="line">                    <span class="keyword">stop</span></span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">select</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">exit</span> <span class="comment">!没有数据了，离开循环</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p%score &gt; <span class="number">20.0</span>) <span class="keyword">then</span> <span class="comment">!显示得分高于20分的选手数据</span></span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;姓名:&#x27;a8/,&#x27;身高:&#x27;f5.1,&#x27; 体重:&#x27;f5.1,&#x27; 得分:&#x27;f4.1)&quot;</span>) p</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">!GetNextPlayer 函数会从文件中找出下一位球员的数据位置</span></span><br><span class="line"><span class="comment">!如果文件中还有数据需要读取，返回.true.</span></span><br><span class="line"><span class="comment">!入股文件中没有数据需要读取，返回.false.</span></span><br><span class="line"><span class="keyword">logical</span> <span class="function"><span class="keyword">function</span></span> GetNextPlayer(fileid, <span class="keyword">name</span>)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">intent</span>(<span class="keyword">in</span>):: fileid</span><br><span class="line">    <span class="keyword">character</span>(len=*), <span class="keyword">intent</span>(<span class="keyword">out</span>) :: <span class="keyword">name</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) title</span><br><span class="line">    <span class="keyword">integer</span> error</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        read(fileid, <span class="string">&quot;(a80)&quot;</span>,<span class="keyword">iostat</span>=error) title</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">then</span> <span class="comment">!文件中已经没有数据了</span></span><br><span class="line">            GetNextPlayer = .false.</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(title(<span class="number">1</span>:<span class="number">4</span>)==<span class="string">&quot;姓名&quot;</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">name</span> = title(<span class="number">6</span>:)</span><br><span class="line">            GetNextPlayer = .true.</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结束之后，啥也没有，这不对啊。应该是打印出来得分高于20的个体信息。</p>
<p>程序代码长了一点，把它分为几部分来说明。第28行之前的程序代码是声明和检查的部分，跟前几个实例差不多，不需要再多做介绍。需要介绍的只有 29~57 行的循环部分和函数 GetNextPlayer。</p>
<p>循环第1行会调用函数 GetNextPlayer，函数 GetNextPlayer 会去寻找文件中保存“姓名”这个字符串的位置，并且读出球员姓名。读取方法是使用循环一次读入一行字符串，检查字符串最前面是否为“姓名”这两个中文字，如果是就取出字符串后半部的球员姓名，并返回主程序；如果不是就再读入下一行。一个中文字会使用 两个character来保存，所以第79行要检查字符串最前面的两个中文字时，等于要检查最前面的4个Character 。下面是函数 GetNextPlayer 的核心部分：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">      read(fileid, <span class="string">&quot;(a80)&quot;</span>,<span class="keyword">iostat</span>=error) title</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">then</span> <span class="comment">!文件中已经没有数据了</span></span><br><span class="line">          GetNextPlayer = .false.</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(title(<span class="number">1</span>:<span class="number">4</span>)==<span class="string">&quot;姓名&quot;</span>) <span class="keyword">then</span></span><br><span class="line">          <span class="keyword">name</span> = title(<span class="number">6</span>:)</span><br><span class="line">          GetNextPlayer = .true.</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">do</span> </span><br></pre></td></tr></table></figure>
<p>文件的代码在整个程序中是共享的，不同的函数可以使用相同的代码来读写同一个文件，函数不会独立拥有自己的文件代码。所以在这边，函数 GetNextPlayer 从参数中得到的文件代码，会和主程序使用相同的文件。</p>
<p>再回到主程序的部分，因为在文件中，每位球员的4项数据都是连续4行写在一起，而调用 GetNextPlayer 时会读入第一行的姓名部分，接下来需要再读入3项数据。第31~49 行是一个固定执行3次的循环，它会连续读入3行数据。不过这3项数据的顺序并不固定，所以要检查每一行最前面的文本才能判断它是什么数据。</p>
<p>读取一位球员的数据后，检查他的平均得分是否超过20分，是就输出这位球员的个人数据。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p%score &gt; <span class="number">20.0</span>) <span class="keyword">then</span> <span class="comment">!显示得分高于20分的选手数据</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;姓名:&#x27;a8/,&#x27;身高:&#x27;f5.1,&#x27; 体重:&#x27;f5.1,&#x27; 得分:&#x27;f4.1)&quot;</span>) p</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br></pre></td></tr></table></figure>
<p>从这可以发现，如果版面格式太过自由，读取数据时会很麻烦。</p>
<p>前面的实例都是单纯的读入数据或是输出文件，现在来示例一个同时读写文件的程序。编写一个程序来把文本文件的内容的最前面加上行号后，输出到另一个文件中。例如文件A的内容为：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">	<span class="keyword">integer</span> a</span><br><span class="line">	……</span><br></pre></td></tr></table></figure>
<p>输出到文件B后，每一行最前面会按照顺序补上行号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.program main</span><br><span class="line">2.	implicit none</span><br><span class="line">3.	integer a</span><br><span class="line">  	……</span><br></pre></td></tr></table></figure>
<p>程序如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0909</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: inputfileid = <span class="number">10</span>, outputfileid = <span class="number">11</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: maxbuffer = <span class="number">200</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) :: inputfile, outputfile</span><br><span class="line">    <span class="keyword">character</span>(len=maxbuffer) buffer</span><br><span class="line">    <span class="keyword">integer</span> <span class="built_in">count</span></span><br><span class="line">    <span class="keyword">integer</span> error</span><br><span class="line">    <span class="keyword">logical</span> alive</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Input Filename:&quot;</span></span><br><span class="line">    read(*, <span class="string">&quot;(a80)&quot;</span>) inputfile</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Output Filename:&quot;</span></span><br><span class="line">    read(*, <span class="string">&quot;(a80)&quot;</span>) outputfile</span><br><span class="line">    </span><br><span class="line">    inquire(<span class="keyword">file</span>=inputfile, <span class="keyword">exist</span>=alive)</span><br><span class="line">    <span class="keyword">if</span>(.not. alive) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="built_in">trim</span>(inputfile), <span class="string">&quot; doesn&#x27;t exist.&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    open(<span class="keyword">unit</span>=inputfileid, <span class="keyword">file</span>=inputfile, <span class="keyword">status</span>=<span class="string">&quot;old&quot;</span>)</span><br><span class="line">    open(<span class="keyword">unit</span>=outputfileid, <span class="keyword">file</span>=outputfile, <span class="keyword">status</span>=<span class="string">&quot;replace&quot;</span>)</span><br><span class="line">    <span class="built_in">count</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="comment">!读入一整行的数据</span></span><br><span class="line">        read(inputfileid, <span class="string">&quot;(a200)&quot;</span>, <span class="keyword">iostat</span>=error) buffer</span><br><span class="line">        <span class="keyword">if</span>(error/=<span class="number">0</span>) eixt <span class="comment">!没有数据了 离开循环</span></span><br><span class="line">        <span class="comment">!在最前面加上行号再输出到另一个文件中</span></span><br><span class="line">        <span class="built_in">write</span>(outputfileid, <span class="string">&quot;(i3,&#x27;.&#x27;,A)&quot;</span>) <span class="built_in">count</span>,<span class="built_in">trim</span>(buffer)</span><br><span class="line">        <span class="built_in">count</span> = <span class="built_in">count</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    close(inputfileid)</span><br><span class="line">    close(outputfileid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> Input Filename:</span><br><span class="line">EX0909.F90</span><br><span class="line"> Output Filename:</span><br><span class="line">EX0909_test.F90</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行完后打开输出文件，确实每一行都添加了行号。</p>
<p>这个程序很简单，基本上就是利用循环一行一行地把文件内容当作字符串读进来。读入字符串后，把这个字符串前面加上行号，再输出到另一个文件中。下面就是这个程序的核心部分。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">    <span class="comment">!读入一整行的数据</span></span><br><span class="line">    read(inputfileid, <span class="string">&quot;(a200)&quot;</span>, <span class="keyword">iostat</span>=error) buffer</span><br><span class="line">    <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">exit</span> <span class="comment">!没有数据了 离开循环</span></span><br><span class="line">    <span class="comment">!在最前面加上行号再输出到另一个文件中</span></span><br><span class="line">    <span class="built_in">write</span>(outputfileid, <span class="string">&quot;(i3,&#x27;.&#x27;,A)&quot;</span>) <span class="built_in">count</span>,<span class="built_in">trim</span>(buffer)</span><br><span class="line">    <span class="built_in">count</span> = <span class="built_in">count</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>这个程序示例了一次打开两个文件的办法，程序只要在OPEN, READ, WRITE 时使用不同的 UNIT 值，就可以同时使用多个文件。</p>
<h2 id="9-4-直接访问文件的操作">9-4 直接访问文件的操作</h2>
<p>直接访问文件的意义是：“把文件的空间、内容事先分区成好几个同样大小的小模块，这些模块会自动按顺序编号。读写文件时，要先赋值文件读写位置在第几个模块，再来进行读写的工作”。直接访问文件可以任意到文件的任何一个地方来读写，就像欣赏镭射唱片、影盘片时一样，可以任意跳跃到我们所想要欣赏的片段。</p>
<p>来看一段实例，文件 list.txt 中，按照棒次顺序记录了“熊帝队”选手的打击率：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.12</span><br><span class="line">2.98</span><br><span class="line">3.34</span><br><span class="line">3.45</span><br><span class="line">2.86</span><br><span class="line">2.54</span><br><span class="line">2.78</span><br><span class="line">2.23</span><br><span class="line">2.56</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编写一个可以经过棒次来查询选手打击率的程序。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0910</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: filename = <span class="string">&quot;list.txt&quot;</span></span><br><span class="line">    <span class="keyword">integer</span> player</span><br><span class="line">    <span class="keyword">real</span> hit</span><br><span class="line">    <span class="keyword">integer</span> error</span><br><span class="line">    <span class="keyword">logical</span> alive</span><br><span class="line">    </span><br><span class="line">    inquire(<span class="keyword">file</span>=filename, <span class="keyword">exist</span>=alive)</span><br><span class="line">    <span class="keyword">if</span>(.not. alive) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="built_in">trim</span>(filename), <span class="string">&quot; doesn&#x27;t exist.&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename, <span class="keyword">access</span>=<span class="string">&quot;direct&quot;</span>,&amp;</span><br><span class="line">        <span class="keyword">form</span>=<span class="string">&quot;formatted&quot;</span>, <span class="keyword">recl</span>=<span class="number">6</span>, <span class="keyword">status</span>=<span class="string">&quot;old&quot;</span>)</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;查询第几棒？&#x27;)&quot;</span>)</span><br><span class="line">        read(*,*) player</span><br><span class="line">        read(fileid, <span class="keyword">fmt</span>=<span class="string">&quot;(f4.2)&quot;</span>, <span class="keyword">rec</span>=player, <span class="keyword">iostat</span>=error) hit</span><br><span class="line">        <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;打击率:&#x27;f4.2)&quot;</span>) hit</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    close(fileid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查询第几棒？</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>没有显示结果啊，应该后面一行跟着打击率结果。</p>
<p>程序使用下面的open命令打开了一个直接读取文件：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename, <span class="keyword">access</span>=<span class="string">&quot;direct&quot;</span>,&amp;</span><br><span class="line">    <span class="keyword">form</span>=<span class="string">&quot;formatted&quot;</span>, <span class="keyword">recl</span>=<span class="number">6</span>, <span class="keyword">status</span>=<span class="string">&quot;old&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>打开直接读取文件时，open命令中的 access = “direct” 及定义模块大小的 recl 字段不能省略。access = ‘direct’ 时，form 的默认值是 “unformatted” （二进制文件），所以要打开直接读取的文本文件时，要记得加上 form=“formatted” 这一参数描述。</p>
<p>文件打开后，使用循环来读取用户所要查询的棒次号码。当用户输入一个不存在的棒次时，会挑出循环。循环的主要工作就是从键盘读取棒次，并且从文件中读出打击率。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">read(fileid, <span class="keyword">fmt</span>=<span class="string">&quot;(f4.2)&quot;</span>, <span class="keyword">rec</span>=player, <span class="keyword">iostat</span>=error) hit</span><br></pre></td></tr></table></figure>
<p>这里的 read 命令，rec 字段填入的 player 值，就是用户所输入的棒次号码，也就是所要去读取的文件位置。这一行命令会从文件中的 第 player 笔数据读出打击率给变量 hit。</p>
<p>关于这个程序，读者可能还有一些疑问，就是在 open 文件时，为什么要把 recl 设为6？来看看文件list 的内容。可以发现 list.txt 文件中每一行刚好有4个字符，而上场打击的棒次有九人，所以文件中有9行。<strong>而在window的操作系统中，文本文件每一行的末尾都有两个看不见的符号用来代表一行文本的结束。所以一行文本的长度是 “这一行文本的字符数量再加上2”。</strong></p>
<p>在文本文件格式中，recl 字段设置的值代表一个模块会使用几个字符。</p>
<p>由于这个程序是给用户自行输入所要查询的棒次号码，所以读取数据时常常会在文件中任意跳跃。使用直接读取文件才能任意赋值文件的读取位置。</p>
<p>事实上这个程序的最好的编写方法是声明数组，并打开一个顺序文件来把数据读入数组中。用户查询数据时，直接在数组中读取就好了。**因为数组的数据是在内存中，查询数据的速度远快于硬盘中读取。**这个程序中使用直接访问文件纯粹是为了范例。</p>
<p>来看看一个写入直接访问文件的实例，假如现在需要一个输入选手打击率的程序，这个程序能够自由让用户决定现在要输入哪一位打击者的打击率。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0911</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: filename = <span class="string">&quot;ex0911dat.txt&quot;</span></span><br><span class="line">    <span class="keyword">integer</span> player</span><br><span class="line">    <span class="keyword">real</span> hit</span><br><span class="line">    <span class="keyword">integer</span> error</span><br><span class="line">    </span><br><span class="line">    open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename, <span class="keyword">access</span>=<span class="string">&quot;direct&quot;</span>,&amp;</span><br><span class="line">        <span class="keyword">form</span>=<span class="string">&quot;formatted&quot;</span>, <span class="keyword">recl</span>=<span class="number">6</span>, <span class="keyword">status</span>=<span class="string">&quot;replace&quot;</span>)</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;第几棒?&#x27;)&quot;</span>)</span><br><span class="line">        read(*,*) player</span><br><span class="line">        <span class="keyword">if</span>(player&lt;<span class="number">1</span> .or. player&gt;<span class="number">9</span>) <span class="keyword">exit</span> </span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;打击率?&#x27;)&quot;</span>)</span><br><span class="line">        read(*,*) hit</span><br><span class="line">        <span class="built_in">write</span>(fileid, <span class="keyword">fmt</span>= <span class="string">&quot;(f5.2)&quot;</span>, <span class="keyword">rec</span>=player, <span class="keyword">iostat</span>=error) hit</span><br><span class="line">        <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    close(fileid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">第几棒?</span><br><span class="line"><span class="number">3</span></span><br><span class="line">打击率?</span><br><span class="line"><span class="number">3.2</span></span><br><span class="line">第几棒?</span><br><span class="line"><span class="number">5</span></span><br><span class="line">打击率?</span><br><span class="line"><span class="number">2.8</span></span><br><span class="line">第几棒?</span><br><span class="line"><span class="number">9</span></span><br><span class="line">打击率?</span><br><span class="line"><span class="number">2.3</span></span><br><span class="line">第几棒?</span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入的数据在 ex0911dat.txt 当中。因为只输入了3个棒次的数据，所以其他选手的位置都是空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.20        2.80                    2.30 </span><br></pre></td></tr></table></figure>
<p>这个实例程序和上一个实例程序差不多，只是在把 read 改成 write 而已。</p>
<p>这个程序只是很简单地做写入文件的范例。通常使用直接格式时，不会使用文本格式而会使用二进制格式来保存数据。</p>
<p>使用直接访问文件时，要小心使用 endfile 命令。使用这个命令时，会把目前所在的文件位置之后的数据都清除掉。</p>
<h2 id="9-5-二进制文件的操作">9-5 二进制文件的操作</h2>
<p>文本文件的内容都是用肉眼就可以明白辨认的，现在来试试看“二进制文件”。使用二进制文件来做直接读取时，open 命令中的 recl 字段所设置的整数 n 值所代表的大小会随着编译器不同而改变。有的编译器会视为 n bytes，有的编译器会视为 n*4 bytes。</p>
<p>把输入棒球选手打击率的程序，改成使用二进制文件来记录：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0912</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: filename = <span class="string">&quot;list.bin&quot;</span></span><br><span class="line">    <span class="keyword">integer</span> player</span><br><span class="line">    <span class="keyword">real</span> :: hit(<span class="number">9</span>) = (/ <span class="number">3.12</span>, <span class="number">2.98</span>, <span class="number">3.34</span>, <span class="number">3.45</span>, <span class="number">2.86</span>, <span class="number">2.54</span>, <span class="number">2.78</span>, <span class="number">2.23</span>, <span class="number">2.56</span> /)</span><br><span class="line">    open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename, <span class="keyword">access</span>=<span class="string">&quot;direct&quot;</span>,&amp;</span><br><span class="line">        <span class="keyword">form</span>=<span class="string">&quot;unformatted&quot;</span>, <span class="keyword">recl</span>=<span class="number">1</span>, <span class="keyword">status</span>=<span class="string">&quot;replace&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> player = <span class="number">1</span>,<span class="number">9</span></span><br><span class="line">        <span class="built_in">write</span>(fileid, <span class="keyword">rec</span>=player) hit(player)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    close(fileid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出报错</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">At line <span class="number">11</span> of <span class="keyword">file</span> EX0912.F90 (<span class="keyword">unit</span> = <span class="number">10</span>, <span class="keyword">file</span> = <span class="string">&#x27;list.bin&#x27;</span>)</span><br><span class="line">Fortran runtime error: <span class="built_in">Write</span> exceeds length of <span class="keyword">DIRECT</span> <span class="keyword">access</span> record</span><br></pre></td></tr></table></figure>
<p>把 open 语句中的 recl 改成 4 ，就好了。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename, <span class="keyword">access</span>=<span class="string">&quot;direct&quot;</span>,&amp;</span><br><span class="line">    <span class="keyword">form</span>=<span class="string">&quot;unformatted&quot;</span>, <span class="keyword">recl</span>=<span class="number">4</span>, <span class="keyword">status</span>=<span class="string">&quot;replace&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>生成的文件 list.bin 放在文本编辑器中看起来会很奇怪。必须另外编写程序才能从 list.bin 中查询数据。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0913</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: filename = <span class="string">&quot;list.bin&quot;</span></span><br><span class="line">    <span class="keyword">integer</span> player</span><br><span class="line">    <span class="keyword">real</span> hit</span><br><span class="line">    <span class="keyword">integer</span> error</span><br><span class="line">    <span class="keyword">logical</span> alive</span><br><span class="line">    </span><br><span class="line">    inquire(<span class="keyword">file</span>=filename, <span class="keyword">exist</span>=alive)</span><br><span class="line">    <span class="keyword">if</span>(.not. alive) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="built_in">trim</span>(filename), <span class="string">&quot; doesn&#x27;t exist.&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename, <span class="keyword">access</span>=<span class="string">&quot;direct&quot;</span>,&amp;</span><br><span class="line">        <span class="keyword">form</span>=<span class="string">&quot;unformatted&quot;</span>, <span class="keyword">recl</span>=<span class="number">4</span>, <span class="keyword">status</span>=<span class="string">&quot;old&quot;</span>)</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;查询第几棒？&#x27;)&quot;</span>)</span><br><span class="line">        read(*,*) player</span><br><span class="line">        read(fileid,  <span class="keyword">rec</span>=player, <span class="keyword">iostat</span>=error) hit</span><br><span class="line">        <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;打击率:&#x27;f5.2)&quot;</span>) hit</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    close(fileid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查询第几棒？</span><br><span class="line">2</span><br><span class="line">打击率: 2.98</span><br><span class="line">查询第几棒？</span><br><span class="line">3</span><br><span class="line">打击率: 3.34</span><br><span class="line">查询第几棒？</span><br><span class="line">0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序和 ex0910 差不多，只是差在常量 recl 字段的值及在 open 中的 form 设为 unformatted ，其实可以省略这一栏，因为打开直接访问文件时 form 的默认值就是 unformatted 。</p>
<p>在这边把 recl 字段设为1（有些编译器必须设为4），ex0910 中把 recl 设置成6是因为输出数据的格式为 f4.2，占4个字段。不过如果两笔数据间没有用空格来区分，在文件中会出现一连串紧密的数字。RECL 设置为6之后，每一条数据都会固定输出6个字符。但是这个程序使用的是二进制文件，就没有必要在数据之间用区分符号来增加文件的可读性，因为二进制文件本来就没有可读性可言。</p>
<p>在这一节的实例程序中，对文件读写时都没有使用任何的输入/出格式。二进制文件是直接把在内存中的二进制数据写入文件，就没有所谓的格式化输入/出存在。</p>
<p>二进制文件可以节省空间，不过在这个例子中还不是很明显。假如要记录 1000 个格式为 f8.3 的浮点数，使用文本文件时，所需要的文件长度理论上最少为 1000*8 = 8000 bytes。但事实上一定还要再数据间加上空格符合来区分数据、方便阅读。所以文件最小长度为 1000*9 = 9000 bytes。</p>
<p>用文本文件保存数字，很可能会造成部分数据流失，因为格式 f8.3 只允许存放3位小数，第3位以下的小数都会被舍去，解决办法是多保存几位数字，不过这样会使用更多的空间。</p>
<p><strong>使用二进制文件时，所需要的文件最少长度为 1000*4 = 4000 bytes，而且不会有任何的数据流失。从这里可以知道，要存放 “精确” 及 “大量” 的数据时，使用二进制文件是较好的选择。</strong> （这里我还是不太理解）</p>
<p>重新看这本书的28-30页，Fortran 的数据类型章节，就大概理解了。</p>
<p>首先根据下面这段话，不同的数据格式会按照不同的规则存储为二进制编码</p>
<blockquote>
<p>程序代码中要清除地指定每种数据所要存储的格式。不同种类的数据需要经过转换才能互通，因为它们可能是使用不同方法来存储的。就以整数和浮点数来说，整数是很单纯地以二进制来存储数字。浮点数和整数的不同在于浮点数可以存储带有小数的实数，浮点数会把数字转换成二进制的指数方法来表示，并把数字分为指数部分和小数部分来做记录。</p>
<p>0.5 = 5.0 * 10 ^-1^ = 1.0 * 2^-1^ 。0.5 这个数值会被分成二进制的数值部分1.0，和指数部分 -1 来记录。</p>
<p>读者不需要实际了解每个数值真正会被记录的格式，只需要知道上面所介绍的整数、浮点数、字符、逻辑这4种数据会使用不同的方法来记录就行了。</p>
</blockquote>
<p>下面这段话就介绍了同样一个数字，以文本格式保存和以数字格式保存的区别。</p>
<blockquote>
<p>假如现在需要记录 15243 这个数字，使用整数来记录的话，会把 15243 转换成二进制的 101111110011 保存在内存。它可以使用短整型（2 bytes）或长整型（4 bytes）来记录。使用字符串来记录的话，需要分别去记录“1”，“5”，“2”，“4”，“3”，这5个字符，需要5 bytes 来记录。</p>
</blockquote>
<p>这里就说的很清楚了， 15243 如果视为一个数字，直接可以转为一个二进制代码。如果视为字符串，那么要视为5个字符，每个字符均需要用一个bytes存储。而且使用字符串来记录数字时，不能直接把它们拿来进行加减乘除的运算，要把字符串先转换成整数或浮点数等等的数值类型才能拿来计算。</p>
<h2 id="9-6-Internal-File（内部文件）">9-6 Internal File（内部文件）</h2>
<p>在前面介绍过把数据写入文本文件的方法，现在再介绍一个类似的新概念——“内部文件”。</p>
<p>“内部文件” 是直接从英文原文翻译成中文的名词，其实如果把它叫做“字符串变量文件”会比较切合原义。因为它是使用写入文件的方法，把数据写到一个字符串变量中，来看一个实例：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0914</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a=<span class="number">2</span></span><br><span class="line">    <span class="keyword">integer</span> :: b=<span class="number">3</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: string</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(<span class="keyword">unit</span>=string, <span class="keyword">fmt</span>= <span class="string">&quot;(i2,&#x27;+&#x27;,i2,&#x27;=&#x27;,i2)&quot;</span>) a,b,a+b</span><br><span class="line">    <span class="built_in">write</span>(*,*) string</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序的重点在第7行，write 命令除了可以赋值一个整数值来作为输出位置之外，还可以赋值一个字符串变量来当做输出的目的。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">write</span>(<span class="keyword">unit</span>=string, <span class="keyword">fmt</span>= <span class="string">&quot;(i2,&#x27;+&#x27;,i2,&#x27;=&#x27;,i2)&quot;</span>) a,b,a+b</span><br></pre></td></tr></table></figure>
<p>字符串 string 的内容，会按照赋值的格式得到 “2+3=5” 的值。除了可以把数据经过 write 写入字符串之外，还可以把数据经过 read 命令从字符串中读入数据。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0915</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: string = <span class="string">&quot;123&quot;</span></span><br><span class="line">    </span><br><span class="line">    read(string, *) a</span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行后变量 a 的值被设置成 123，设置的操作是发生在第6行的read命令。read命令可以把输入的来源设置到一个字符串变量中，在这里字符串 string 的内容为 “123” , 所以变量a 会被赋值为123。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">read(string, *) a</span><br></pre></td></tr></table></figure>
<p>在某些情况下，需要使用内部文件来设置数据。</p>
<p>使用 read 命令从键盘输入数据时，如果用户输入错误的数据，会导致程序死机。例如需要输入整数时却输入英文字母，就可以会死机。比较好的处理方法是，程序先把数据当成字符串读入，检查字符串中是否含有不合理的字符，如果字符串中都是0-9的数字字符，就把字符串转换成整数，不然就请用户再输入一次。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0916</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> i</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">external</span> :: GetInteger</span><br><span class="line">    i = GetInteger()</span><br><span class="line">    <span class="built_in">write</span>(*,*) i</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> GetIntger()</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) :: string</span><br><span class="line">    <span class="keyword">logical</span> :: invalid</span><br><span class="line">    <span class="keyword">integer</span> i, code</span><br><span class="line">    </span><br><span class="line">    invalid = .true.</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(invalid)</span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;请输入正整数&quot;</span></span><br><span class="line">        read(*, <span class="string">&quot;(a80)&quot;</span>) string</span><br><span class="line">        invalid = .false.</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>, <span class="built_in">len_trim</span>(string)</span><br><span class="line">            <span class="comment">!检查输入的字符是否包含&#x27;0&#x27;~&#x27;9&#x27;以外的字符</span></span><br><span class="line">            code = <span class="built_in">ichar</span>(string(i:i))</span><br><span class="line">            <span class="keyword">if</span>(code &lt; <span class="built_in">ichar</span>(<span class="string">&#x27;0&#x27;</span>) .or. code &gt; <span class="built_in">ichar</span>(<span class="string">&#x27;9&#x27;</span>)) <span class="keyword">then</span></span><br><span class="line">                invalid = .true.</span><br><span class="line">                <span class="keyword">exit</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    read(string, *) GetInteger</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 请输入正整数</span><br><span class="line">2.a</span><br><span class="line"> 请输入正整数</span><br><span class="line">2</span><br><span class="line">           2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>读取数据的程序代码是在函数 GetInteger 中，它会暂时先把数据以字符串方法读入，用循环检查每个字符是否为数字字符，如果发现了不是数字的字符，就会要求重新输入数据。</p>
<p>检查是否为数字字符的方法，是从字符的ASCII 值来看，数字字符0~9在ASCII 中是连号排列，0的ASCII 值最小，9最大。所以只要字符串中有任何一个字符的 ASCII 值小于 0 的ASCII 值，或是大于9的ASCII 值，字符串中就包含非数字的字符。</p>
<p>得到合理的输入后，再使用 read 命令把字符串中的数字读出来。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">read(string, *) GetInteger</span><br></pre></td></tr></table></figure>
<p>内部文件还可以应用在动态改变输出格式，输出格式可以事先存放在字符串中，程序进行中，动态改变字符串内容就可以<strong>改变输出格式</strong>（比如整数格式改为字符串），下面是一个实例：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0917</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> a,b</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">30</span>) :: fmtstring = <span class="string">&quot;(i??,&#x27;+&#x27;,i??,&#x27;=&#x27;,i??)&quot;</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">external</span> :: GetInteger</span><br><span class="line">    </span><br><span class="line">    a = GetInteger()</span><br><span class="line">    b = GetInteger()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(fmtstring(<span class="number">3</span>:<span class="number">4</span>), <span class="string">&quot;(i2.2)&quot;</span>) <span class="built_in">int</span>(<span class="built_in">log10</span>(<span class="keyword">real</span>(a))+<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">write</span>(fmtstring(<span class="number">11</span>:<span class="number">12</span>), <span class="string">&quot;(i2.2)&quot;</span>) <span class="built_in">int</span>(<span class="built_in">log10</span>(<span class="keyword">real</span>(b))+<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">write</span>(fmtstring(<span class="number">19</span>:<span class="number">20</span>), <span class="string">&quot;(i2.2)&quot;</span>) <span class="built_in">int</span>(<span class="built_in">log10</span>(<span class="keyword">real</span>(a+b))+<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">write</span>(*,fmtstring) a,b,a+b</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> GetInteger()</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) :: string</span><br><span class="line">    <span class="keyword">logical</span> :: invalid</span><br><span class="line">    <span class="keyword">integer</span> i, code</span><br><span class="line">    </span><br><span class="line">    invalid = .true.</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(invalid)</span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;请输入正整数&quot;</span></span><br><span class="line">        read(*, <span class="string">&quot;(a80)&quot;</span>) string</span><br><span class="line">        invalid = .false.</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>, <span class="built_in">len_trim</span>(string)</span><br><span class="line">            <span class="comment">!检查输入的字符是否包含&#x27;0&#x27;~&#x27;9&#x27;以外的字符</span></span><br><span class="line">            code = <span class="built_in">ichar</span>(string(i:i))</span><br><span class="line">            <span class="keyword">if</span>(code &lt; <span class="built_in">ichar</span>(<span class="string">&#x27;0&#x27;</span>) .or. code &gt; <span class="built_in">ichar</span>(<span class="string">&#x27;9&#x27;</span>)) <span class="keyword">then</span></span><br><span class="line">                invalid = .true.</span><br><span class="line">                <span class="keyword">exit</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    read(string, *) GetInteger</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 请输入正整数</span><br><span class="line">100</span><br><span class="line"> 请输入正整数</span><br><span class="line">1</span><br><span class="line">100+1&#x3D;101</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序的重点在于最后一行的输出，在这里希望能够把数字都很紧密地输出到屏幕上，所以需要知道输入的两个数字占用几个位数，再根据它们的值来决定输出格式。程序10-12行才会计算出这些数字占用几个位数。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">write</span>(fmtstring(<span class="number">3</span>:<span class="number">4</span>), <span class="string">&quot;(i2.2)&quot;</span>) <span class="built_in">int</span>(<span class="built_in">log10</span>(<span class="keyword">real</span>(a))+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>从 log10(a) + 1 可以得到变量 a 占用几个位数。因为 0&lt;a&lt;10 时 log10(a)&lt;1, 10&lt;a&lt;100时 log10(a) &lt; 2 …… ，把 log10(a)+1 转化为整数后就是数字 a 所占用的位数。<strong>如果不动态计算数字的位数大小，输出格式一定是固定的，不管数字的大小是多少，都会占用同样的字段宽度来做输出。</strong></p>
<h2 id="9-7-namelist">9-7 namelist</h2>
<p>namelist 也是很特殊的输入/出方法，它可以把一组相关变量封装在一起，输入/出这一组变量时，只要在 write/read 的 nml 字段赋值要使用哪一个 namelist 就行了，下面是一个实例：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0918</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span></span><br><span class="line">    <span class="keyword">namelist</span> /na/ a,b,c</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="keyword">nml</span>=na)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;NA</span><br><span class="line"> A&#x3D;          1,</span><br><span class="line"> B&#x3D;          2,</span><br><span class="line"> C&#x3D;          3,</span><br><span class="line"> &#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序的第4行，把a,b,c 这3个变量放在名字叫做 na 的 namelist 中。namelist 也算是声明的一部分，必须编写在程序执行命令的前面。 namelist 的语法很类似 common ， 不过使用 namelist 时一定要取名字。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namelist</span> /nl_name/ var1,var2,……</span><br></pre></td></tr></table></figure>
<p>封装好 namelist 后，在 write 的 nml 字段中指明要输出哪一个 namelist ，就可以把在 namelist 中的变量全部输出。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">write</span>(*,<span class="keyword">nml</span>=na)</span><br></pre></td></tr></table></figure>
<p>输出namelist 时不能赋值输出格式，Fortran 90 标准中规定输出 namelist 时首先会输出符合&amp;，后面紧接着这个namelist 的名字。接着会根据顺序输出变量的名称、等号及内容，变量之间用空格或逗号来做分隔，最后使用除号来作结束。</p>
<p>至于每个数字内容会用什么格式来输出，就由编译器自行决定。（gfortran 的显示结果就和书上不太一样）</p>
<p>namelist 也可以用来输入数据。不过通常都会用来读取文件，不会用在键盘输入，先来看一个键盘输入的实例：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0919</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a,b,c</span><br><span class="line">    <span class="keyword">namelist</span> /na/ a,b,c</span><br><span class="line">    read(*, <span class="keyword">nml</span>=na)</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="keyword">nml</span>=na)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;na a&#x3D;1 b&#x3D;2 c&#x3D;3 &#x2F;</span><br><span class="line">&amp;NA</span><br><span class="line"> A&#x3D;          1,</span><br><span class="line"> B&#x3D;          2,</span><br><span class="line"> C&#x3D;          3,</span><br><span class="line"> &#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里输入必须要按照上面介绍的格式来输入，先输入符号&amp;，紧接namelist 的名字，再输入变量名称、等号及内容，要结束时还要加上除号。</p>
<p>读取namelist 时，可以不填入所有变量的值，只要以&amp;na开始输入，给一个除号就可以结束输入。变量可以不按照顺序输入，程序会自动按照变量名称来设置数值。变量设置可以重复输入，不过变量会得到最后一次设置的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;na a&#x3D;1 a&#x3D;2 &#x2F; (重复设置a两次，变量a最后会等于2)</span><br></pre></td></tr></table></figure>
<p>从这个例子可以发现，使用键盘来输入namelist 的内容会非常麻烦。namelist 通常使用再文本文件的输入/出中，使用 read 从文件中读取数据时，会自动从目前的位置向下寻找存放 namelist 的地方。来看下一个实例：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0920</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">namelist</span> /na/ a</span><br><span class="line">    </span><br><span class="line">    open(<span class="number">10</span>,<span class="keyword">file</span>=<span class="string">&quot;ex0920.txt&quot;</span>)</span><br><span class="line">    read(<span class="number">10</span>,<span class="keyword">nml</span>=na)</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(3i2)&quot;</span>) a</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中 ex0920.txt 的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">happy birthday</span><br><span class="line">&amp;na a&#x3D;1,2,3 &#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序打开时，读写位置在文件的开头。读者可以发现文件开头的内容是字符串 happy birthday ，第7行的read命令会自动向下寻找 na 这个 namelist 的存放位置来读取数据。这边看到了namelist 处理数组的方法，它会在等号后面根据序号显示数组内容。</p>
<h2 id="9-8-文件的应用">9-8 文件的应用</h2>
<p>光盘中 \program\chap09\grades.txt 的文件是一张成绩单，记录了全班 20 位学生的某一次阶段考试成绩。</p>
<p>编写程序来读取成绩单，计算每位同学的总分，及各科的全部平均分，以下面的程序重新输出成绩单的内容：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">type</span> student</span><br><span class="line">        <span class="keyword">integer</span> :: Chinese, English, Math, Natural, Social</span><br><span class="line">        <span class="keyword">integer</span> :: total</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0921</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: students = <span class="number">20</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) :: tempstr</span><br><span class="line">    <span class="keyword">type</span>(student) :: s(students) <span class="comment">!保存学生成绩</span></span><br><span class="line">    <span class="keyword">type</span>(student) :: total <span class="comment">!保存平均分数</span></span><br><span class="line">    <span class="keyword">integer</span> i, num, error</span><br><span class="line">    </span><br><span class="line">    open(fileid, <span class="keyword">file</span>=<span class="string">&quot;grades.txt&quot;</span>, <span class="keyword">status</span>=<span class="string">&quot;old&quot;</span>, <span class="keyword">iostat</span>=error)</span><br><span class="line">    <span class="keyword">if</span> (error/=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;open grades.txt fail&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    read(fileid, <span class="string">&quot;(a80)&quot;</span>) tempstr <span class="comment">!读入第一行文本</span></span><br><span class="line">    total = student(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="comment">!用循环读入每位同学的成绩</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,students</span><br><span class="line">        read(fileid, *) num, s(i)%Chinese, s(i)%English, &amp;</span><br><span class="line">                        s(i)%Math, s(i)%Natural, s(i)%Social</span><br><span class="line">        <span class="comment">!计算总分</span></span><br><span class="line">        s(i)%Total = s(i)%Chinese + s(i)%English + &amp;</span><br><span class="line">                    s(i)%Math + s(i)%Natural + s(i)%Social</span><br><span class="line">        <span class="comment">!累加上各科的分数，计算各科平均时使用</span></span><br><span class="line">        total%Chinese = total%Chinese + s(i)%Chinese</span><br><span class="line">        total%English = total%English + s(i)%English</span><br><span class="line">        total%Math = total%Math + s(i)%Math</span><br><span class="line">        total%Natural = total%Natural + s(i)%Natural</span><br><span class="line">        total%Social = total%Social + s(i)%Social</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">!重新输出每位学生成绩</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(7a7)&quot;</span>) <span class="string">&quot;座号&quot;</span>,<span class="string">&quot;中文&quot;</span>,<span class="string">&quot;英文&quot;</span>,<span class="string">&quot;数学&quot;</span>,<span class="string">&quot;自然&quot;</span>,<span class="string">&quot;社会&quot;</span>,<span class="string">&quot;总分&quot;</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,students</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(7i7)&quot;</span>) i,s(i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">!计算并输出平均分数</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(a7,6f7,1)&quot;</span>) <span class="string">&quot;平均&quot;</span>,&amp;</span><br><span class="line">        <span class="keyword">real</span>(total%Chinese)/<span class="keyword">real</span>(students),&amp;</span><br><span class="line">        <span class="keyword">real</span>(total%English)/<span class="keyword">real</span>(students),&amp;</span><br><span class="line">        <span class="keyword">real</span>(total%Math)/<span class="keyword">real</span>(students),&amp;</span><br><span class="line">        <span class="keyword">real</span>(total%Natural)/<span class="keyword">real</span>(students),&amp;</span><br><span class="line">        <span class="keyword">real</span>(total%Social)/<span class="keyword">real</span>(students),&amp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序使用另一个方法来判断 grades.txt 是否存在，第18行的open 命令中，iostat 字段会把文件打开是否成功的结果放在变量 error 中。 error 的值若不为零代表找不到这个文件。</p>
<p>读入文件时，有几个地方的数据是可以直接跳过去不处理的，像第一行的表头字符串及每一行最前面的学生座号。表头字符串只是用来说明这个位置存放的是哪个科目的成绩，而每一行最前面的学生座号是按照顺序排列下来的。这些固定的数据不需要再处理，把它们读进来之后就可以不再理会它们。程序中的变量 tempstr 和 num 从文件中得到数据后就没有再去使用。</p>
<p>第24行的 read 命令需要赋值输入格式，如果不赋值这里要一口气读入80个字符长度的字符串，读取数据时，grade.txt 中第一行会被当成 6 个小字符串。<strong>使用默认输入格式时，遇到空格符会当成分隔符</strong>。</p>
<p>第28行的 read 命令可以不赋值输入格式，在文本文件格式下，两笔数据之间如果只用空格来做分隔，不特别赋值输入格式就可以正确得到内容。文件 grades.txt 中，从第2行开始，每一行都是连续的 6 个整数，数字之间用空格来分隔，所以从第2行之后，不需要赋值输入格式，每一行都读入6个整数就行了。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">read(fileid, *) num, s(i)%Chinese, s(i)%English, &amp;</span><br><span class="line">                s(i)%Math, s(i)%Natural, s(i)%Social</span><br></pre></td></tr></table></figure>
<p>这个实例没有做成绩排名，这部分留到习题给读者练习。在这里使用自定义类型来记录每位学生的成绩，如果不用自定义类型时，分别需要对每个科目都声明一个数组来记录成绩，在做排序时交换数据会变得很麻烦。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!使用自定义类型时，s(j)及s(i) 中就包含了一位学生的全部数据</span></span><br><span class="line">temp = s(j)</span><br><span class="line">s(j) = s(i)</span><br><span class="line">s(i) = temp</span><br><span class="line"></span><br><span class="line"><span class="comment">!不使用自定义类型时，要对每个科目声明一个数组来记录成绩</span></span><br><span class="line"><span class="comment">!需要交换两位学生数据时，要交换5个数组的数据，非常麻烦</span></span><br><span class="line">temp=Chinese(j)</span><br><span class="line">Chinese(j)=Chinese(i)</span><br><span class="line">Chinese(i)=temp</span><br><span class="line">temp=English(j)</span><br><span class="line">English(j)=English(i)</span><br><span class="line">English(i)=temp</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h1>10 指针</h1>
<p>指针是一个很有趣的东西，它最简单的应用可以用来保存变量，或者是动态使用内存。更进一层则可以应用在特别的“数据结构”上，例如创建“串行结构”、“树状结构”等等。</p>
<h2 id="10-1-指针基本概念">10-1 指针基本概念</h2>
<p>简单地说，指针是一种“间接使用数据”的方法。指针变量用来保存一个“内存地址”。当程序要读写指针变量时，实际上会经过两个步骤：</p>
<ol>
<li>取出指针所保存的内存位置。</li>
<li>到这个内存位置读写数据</li>
</ol>
<p>指针变量中所保存的内存地址来源可以有两种：</p>
<ol>
<li>记录其他非指针变量的内存位置。</li>
<li>程序执行中动态配置一块内存。</li>
</ol>
<p>最基本的指针运行，是指指针变量拿来记录另外一个目标变量的地址，再经过指针来读写数据，来看看这个实例：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex1001</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">target</span> :: a=<span class="number">1</span> <span class="comment">!声明一个可以当成目标的变量</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p <span class="comment">!声明一个可以指向整数的指针</span></span><br><span class="line">    p=&gt;a <span class="comment">!把指针p指到变量a</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) p</span><br><span class="line">    a = <span class="number">2</span> <span class="comment">!改变a的值</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) p</span><br><span class="line">    p = <span class="number">3</span> <span class="comment">!改变指针p所指向的内存内容</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 </span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序的第3行出现新的声明方法，第3行的声明中出现新的形容词 target 。声明中加上 target 的变量，在使用上并不会有任何不同，只不过这种变量可以把它的内存地址赋值给指针变量。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">target</span> :: a = <span class="number">1</span> </span><br></pre></td></tr></table></figure>
<p>第4行也出现了新的声明方法，声明中使用了 pointer, 表示这里要声明的是指针变量。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p <span class="comment">!声明一个可以指向整数的指针</span></span><br></pre></td></tr></table></figure>
<p>有了指针之后，程序第5行会把指针p指向变量a。也就是把向量a的内存地址记录在指针p中。请注意在这边使用了类似箭头&quot;=&gt;&quot;的符号来作指针的指向设置，而不是使用等号。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">p=&gt;a</span><br></pre></td></tr></table></figure>
<p>指针设置后内存指向位置后，就可以把它当成一般变量来使用。程序会自动取出指针中所记录的内存地址，再对这个内存地址来做读写。第6行输出指针p时，内容为1，正是变量a这个时候的值。</p>
<p>程序第7行把变量a的值重新设置为2，第8行再试着输出指针p的内容，理所当然地可以发现这个时候输出的值为2。使用指针p，就等于使用变量a。</p>
<p>程序第9行会把指针p所指向的内存中的数值设置为3，也就等于把变量a设置成3。</p>
<p>这个程序很简单地示例了指针的使用方法，只要把指针赋值到一个目标变量上，使用指针与使用这个变量会变成没有差别，这是第1种使用方法。下面来看看第2种使用方法，动态配置内存。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex1002</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p <span class="comment">!声明一个可以指向整数的指针</span></span><br><span class="line">    <span class="built_in">allocate</span>(p) <span class="comment">!配置一块可以存放integer 的内存空间给指针p</span></span><br><span class="line">    p=<span class="number">100</span> <span class="comment">!得到内存后指针p可以像一般整数一样来使用</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) p</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure>
<p>这个程序示范了第2种使用指针的方法。函数 allocate 在第7章中曾经介绍过，那个时候是用来配置内存空间给可变大小的矩阵使用，它也可以用来配置一块内存空间给指针使用。程序第4行会把配置到的内存地址存放在指针p中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allocate(p) </span><br></pre></td></tr></table></figure>
<p>如果指针指向变量，指针可以随时重新设置它的指向。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">target</span> :: a = <span class="number">1</span>, b = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p</span><br><span class="line">p=&gt;a <span class="comment">!把p指向a</span></span><br><span class="line"><span class="built_in">write</span>(*,*) p <span class="comment">!会输出1</span></span><br><span class="line">p=&gt;b <span class="comment">!把p指向b</span></span><br><span class="line"><span class="built_in">write</span>(*,*) p <span class="comment">!会输出2</span></span><br></pre></td></tr></table></figure>
<p>不过如果指针中所指向的通过 allocate 所配置的内存，重新改变指向前要对这个内存地址做一些处理，看是把它交给其他指针，或是把内存空间经过 deallocate 释放都行，不然会在计算机中形成一块已经配置、却被丢弃的内存。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">target</span> :: a=<span class="number">1</span>, b=<span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p</span><br><span class="line"><span class="built_in">allocate</span>(p) <span class="comment">!配置内存</span></span><br><span class="line">p=<span class="number">1</span></span><br><span class="line"><span class="built_in">write</span>(*,*) p</span><br><span class="line"><span class="built_in">deallocate</span>(p) <span class="comment">!释放内存</span></span><br><span class="line">p=&gt;a <span class="comment">!再改变指针p的指向</span></span><br></pre></td></tr></table></figure>
<p>上面这段代码中，如果指针在指向变量a之前，没有先把配置得到的内存释放回去，那这块内存空间会变得无人认领。经过函数allocate 得到的内存空间，再经过 dellocate 释放回去，或是程序结束之前，操作系统仍然会认定这块空间是安排给这个程序使用的。如果不先 deallocate，就重新设置指针p的指向，会导致内存空间白白浪费。</p>
<p>使用指针之前，一定要先设置好指针的目标。不然在程序执行时，会发生意想不到的情况。因为使用指针是使用它所记录的内存地址。还没设置指向的指针，不会知道哪里有内存可以使用。在这个时候使用指针，会出现内存使用错误的信息。在 windows 系统下可能会显示一堆内存地址，显示内存读写不正常的信息，然后中断程序。在 Unix 系统下可能会出现 Segmentation fault 的错误信息。</p>
<p>Fortran 提供 associated 函数，用来检查指针是否已经设置指向。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">associated</span>(<span class="keyword">pointer</span>,[<span class="keyword">target</span>])</span><br><span class="line">检查指针是否设置指向，返回值为布尔变量。如果只放入第<span class="number">1</span>个指针参数，会检查这个指针是否已经赋值好”方向“。</span><br><span class="line">如果放入<span class="number">2</span>个变量，则会检查第<span class="number">1</span>个指针变量是否指向第<span class="number">2</span>个变量。</span><br></pre></td></tr></table></figure>
<p>一般来说，判断指针有没有赋值好方向，是检查它的指向是否指到了不可能拿来使用的内存地址。函数 null() 会返回一个不能使用的内存地址，它可以用来把指针初值指向一个不能使用的内存地址，确保 associated 函数可以正确判断出这个指针还没有给定指向</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p =&gt; null() <span class="comment">!把指针初值指向一个不能使用的内存地址</span></span><br></pre></td></tr></table></figure>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">NUll()</span><br><span class="line">Fortran <span class="number">95</span> 添加的函数。会返回一个不能使用的内存地址，在指针还没有指向前设置成这个值，</span><br><span class="line">可以让<span class="built_in">associated</span> 函数判断不会出错。</span><br></pre></td></tr></table></figure>
<p>除了函数NULL 之外，还可以使用 nullify 命令来把指针设置成不能使用的内存地址。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nullify</span>(pointer1,[pointer2,...])</span><br><span class="line">用来将指针设置成还没有指向任何内存地址。Fortran <span class="number">90</span> 只能使用 <span class="built_in">nullify</span> 而不能使用 null 函数来设置指针</span><br></pre></td></tr></table></figure>
<p>来看一个实验性质的程序：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex1003</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: a=&gt;null()</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">target</span> :: b=<span class="number">1</span>,c=<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="built_in">associated</span>(a) <span class="comment">!false，指针a尚未赋值</span></span><br><span class="line">    a=&gt;c</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="built_in">associated</span>(a) <span class="comment">!true，指针a已赋值</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="built_in">associated</span>(a,c) <span class="comment">!true，指针a指向c</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="built_in">associated</span>(a,b) <span class="comment">!false，指针a不指向b</span></span><br><span class="line">    <span class="built_in">nullify</span>(a) <span class="comment">!把指针a设为没有指向</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="built_in">associated</span>(a) <span class="comment">!false，指针a尚未赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F</span><br><span class="line">T</span><br><span class="line">T</span><br><span class="line">F</span><br><span class="line">F</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>指针可以声明成任何数据类型，甚至是使用 type 来自定义的数据类型。有一个概念很重要，那就是不管指针是用来指向哪一种数据类型，不论是integer, real, character, complex 或是自定义类型，每一种指针变量都占用相同的内存空间。因为指针变量实际上是用来记录内存地址，以现在的32位计算机来说，记录一个内存地址，固定需要使用32 bits = 4 bytes 的空间。</p>
<h2 id="10-2-指针数组">10-2 指针数组</h2>
<p>指针也可以声明成数组，声明成数组的指针同样可以有两种使用方法：</p>
<ol>
<li>把指针指到其他数组。</li>
<li>配置内存空间来所用。</li>
</ol>
<p>先来看第一种使用方法：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex1004</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: a(:)</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">target</span> :: b(<span class="number">5</span>)  = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /)</span><br><span class="line">    <span class="comment">!把指针数组a指向数组b</span></span><br><span class="line">    a=&gt;b</span><br><span class="line">    <span class="comment">!a(1~5) =&gt; b(1~5)</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    a=&gt;b(<span class="number">1</span>:<span class="number">3</span>)</span><br><span class="line">    <span class="comment">!a(1)=&gt;b(1),a(2)=&gt;b(2),a(3)=&gt;b(3)</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    a =&gt; b(<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>)</span><br><span class="line">    <span class="comment">!a(1)=&gt;b(1),a(3)=&gt;b(3),a(5)=&gt;b(5)</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    a =&gt; b(<span class="number">5</span>:<span class="number">1</span>:-<span class="number">1</span>)</span><br><span class="line">    <span class="comment">!a(1)=&gt;b(5),a(2)=&gt;b(4),a(3)=&gt;b(3),a(4)=&gt;b(2),a(5)=&gt;b(1)</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1           2           3           4           5</span><br><span class="line">1           2           3</span><br><span class="line">1           3           5</span><br><span class="line">5           4           3           2           1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序实例是指针数组的第一种使用方法，指针数组在声明时只需要说明它的维数就行了，不需要说明它的大小。这一点类似可变大小数组。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">pointer</span> :: a(:) <span class="comment">!声明一维的指针数组</span></span><br></pre></td></tr></table></figure>
<p>被当成目标给指针使用的数组，在声明时同样要加上 target 这个形容词。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">target</span> :: b(<span class="number">5</span>) = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /) <span class="comment">!这个数组可以给指针使用</span></span><br></pre></td></tr></table></figure>
<p>把指针数组指向一个数组可以有很多设置方法，最简单的方法就是直接指过去，就像程序中第6行的做法一样。这种做法会让指针a成为数组b的分身，使用指针a就跟使用数组b完全一样。输出结果的第1行可以证明指针数组a所指到的内容与数组b是完全相同的。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a=&gt;b</span><br></pre></td></tr></table></figure>
<p>指针数组可以只选择目标数组中的一小部分来使用，第9行只取出数组b中的前3个变量来使用。这个时候指针数组a的大小为3，使用a等于使用b的前3个变量。输出结果的第2行可以证明这个事实。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a=&gt;b(<span class="number">1</span>:<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>除了可以把指针数组拿来指向某个目标数组之外，还可以使用 allocate 来分配一块内存来给它使用，所以指针数组也可以拿来当作可变大小的数组使用。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex1005</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: a(:) <span class="comment">!定义a是一维的指针数组</span></span><br><span class="line">    <span class="built_in">allocate</span>(a(<span class="number">5</span>)) <span class="comment">!配置5个整数的空间给指针a</span></span><br><span class="line">    a = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /)</span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    <span class="built_in">deallocate</span>(a) <span class="comment">!allocate 得到的内存要记得归还</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1           2           3           4           5</span><br></pre></td></tr></table></figure>
<p>在这边还是要提醒一点，allocate 得到的内存，在不需要使用时，要记得用 deallocate 释放回去。</p>
<p>看完了一维指针数组的例子，现在来看看多维指针数组的使用方法：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex1006</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: a(:,:) <span class="comment">!定义a是二维的指针数组</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">target</span> :: b(<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">integer</span> i</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">3</span>)</span><br><span class="line">        b(:,i,<span class="number">1</span>) = i</span><br><span class="line">        b(:,i,<span class="number">2</span>) = <span class="number">2</span>*i</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line">    </span><br><span class="line">    a =&gt; b(:,:,<span class="number">1</span>)</span><br><span class="line">    <span class="comment">! a(i,j) =&gt; b(i,j,1)</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(9i2)&quot;</span>) a</span><br><span class="line">    a =&gt; b(<span class="number">1</span>:<span class="number">3</span>:<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="comment">! a(1,1)=&gt;b(1,1,2), a(2,1)=&gt;b(3,1,2)</span></span><br><span class="line">    <span class="comment">! a(1,2)=&gt;b(1,2,2), a(2,1)=&gt;b(3,2,2)</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(4i2)&quot;</span>) a</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 1 1 2 2 2 3 3 3</span><br><span class="line">2 2 4 4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在程序中需要常常使用数组的一小部分时，声明一个指针来使用这一部分的数组，使用起来会比较方便。</p>
<p>最后说明一个概念，既然指针也可以拿来作为可变大小的数组，那它和第7章中介绍的可变大小数组有什么不同？</p>
<p>声明成 allocatable 的 数组有它的生存周期，它只存在于声明它的函数中，函数结束后数组会自动 deallocate 释放内存空间。如果声明成指针，在函数结束时，不会自动去 deallocate 指针所指到的内存，在程序进行中要程序员自行使用 deallocate 才会释放内存。不然要等到程序结束，让操作系统来回收这一块内存。</p>
<h2 id="10-3-指针与函数">10-3 指针与函数</h2>
<p>指针变量一样可以作为参数在函数之间传递，也可以作为函数的返回值。使用时有下面几种策略：</p>
<ol>
<li>要把指针传递给函数时，要声明这个函数的参数使用接口 interface</li>
<li>指针参数声明时不需要 intent 这个形容词</li>
<li>函数返回值若为指针时，需要定义函数的 interface</li>
</ol>
<p>来看一个实例</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex1007</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">target</span> :: a(<span class="number">8</span>) = (/ <span class="number">10</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">25</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">17</span>, <span class="number">19</span> /)</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p(:)</span><br><span class="line">    <span class="keyword">interface</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span></span> GetMin(p)</span><br><span class="line">            <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p(:)</span><br><span class="line">            <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: getmin</span><br><span class="line">        <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    </span><br><span class="line">    p =&gt; a(<span class="number">1</span>:<span class="number">8</span>:<span class="number">2</span>)</span><br><span class="line">    <span class="comment">! p(1) =&gt; a(1), p(2) =&gt; a(3), p(3) =&gt; a(5), p(4) =&gt; a(7)</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) GetMin(p)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span></span> GetMin(p)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p(:)</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: GetMin</span><br><span class="line">    <span class="keyword">integer</span> i,s</span><br><span class="line">    <span class="keyword">integer</span> <span class="built_in">min</span></span><br><span class="line">    </span><br><span class="line">    s=<span class="built_in">size</span>(p,<span class="number">1</span>) <span class="comment">!查询数组的大小</span></span><br><span class="line">    <span class="built_in">min</span> = <span class="number">2</span>**<span class="number">30</span> <span class="comment">!先把min设置为一个很大的值</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,s</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">min</span>&gt;p(i)) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">min</span>=p(i)</span><br><span class="line">            GetMin=&gt;p(i)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<p>这个程序示例了传递指针给函数，以及从函数中返回指针的方法。函数 GetMin 会把输入的数组值中，最小的数值找出来。函数 GetMin 的参数类型及返回值都是指针，所以在调用前要说明它的使用接口 interface 。没有编写 interface 时，编译过程当中并不一定会出现错误信息，不过在程序执行时会不正确，参数不会正确地传递出去。</p>
<p>程序第12行先设置指针 p 的指向，它指到数组 a中的一部分，再把指针 p 当成参数传给函数 GetMin 使用。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">p =&gt; a(<span class="number">1</span>:<span class="number">8</span>:<span class="number">2</span>)</span><br><span class="line"><span class="comment">! p(1) =&gt; a(1), p(2) =&gt; a(3), p(3) =&gt; a(5), p(4) =&gt; a(7)</span></span><br></pre></td></tr></table></figure>
<p>找到最小值的地方，是使用循环来一个一个检查数组中的数值。min 变量在进入循环前先设置成一个很大的数值，在数组中发现比它小的数值时，就重新设置 min 的值。循环执行完后，min 值就会是数组中最小的数值。</p>
<p>编写 interface 是一件麻烦的工作，不过如果函数是封装在 module 中，就等于已经编写好使用接口。来看看这个程序写成 module 的版本。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> func</span><br><span class="line"></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line"><span class="function"><span class="keyword">function</span></span> GetMin(p)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p(:)</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: GetMin</span><br><span class="line">    <span class="keyword">integer</span> i,s</span><br><span class="line">    <span class="keyword">integer</span> <span class="built_in">min</span></span><br><span class="line">    </span><br><span class="line">    s=<span class="built_in">size</span>(p,<span class="number">1</span>) <span class="comment">!查询数组的大小</span></span><br><span class="line">    <span class="built_in">min</span> = <span class="number">2</span>**<span class="number">30</span> <span class="comment">!先把min设置为一个很大的值</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,s</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">min</span>&gt;p(i)) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">min</span>=p(i)</span><br><span class="line">            GetMin=&gt;p(i)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1008</span><br><span class="line">    <span class="keyword">use</span> func</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">target</span> :: a(<span class="number">8</span>) = (/ <span class="number">10</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">25</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">17</span>, <span class="number">19</span> /)</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p(:)</span><br><span class="line">    </span><br><span class="line">    p =&gt; a(<span class="number">1</span>:<span class="number">8</span>:<span class="number">2</span>)</span><br><span class="line">    <span class="comment">! p(1) =&gt; a(1), p(2) =&gt; a(3), p(3) =&gt; a(5), p(4) =&gt; a(7)</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) GetMin(p)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="10-4-基本的指针应用">10-4 基本的指针应用</h2>
<p>读者看过上一节对指针使用的介绍后，大概还是会对指针存在的必要性感到怀疑。究竟这种”间接读写数据“的数据类型有什么作用？</p>
<p>方便使用高维数组中的某一部分元素。</p>
<p>不管指针是用来指向什么类型，它都占用相同的内存空间（在PC上为 4 bytes）。指向自定义类型时，指针可以很快速地交换数据。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">target</span> :: a(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">pointer</span> :: b</span><br><span class="line">b =&gt; a(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">!假如经常要使用 a(2,2,2)的值，就可以通过指针来使用它，程序代码中只要用b就可以代替a(2,2,2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">target</span> :: matrix(<span class="number">100</span>,<span class="number">100</span>)</span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p(:,:)</span><br><span class="line">p =&gt; matrix(<span class="number">10</span>:<span class="number">20</span>,<span class="number">10</span>:<span class="number">20</span>)</span><br><span class="line"><span class="comment">!用这个方法就可以把100×100的矩阵中里面的一块10×10矩阵拿出来使用。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person</span><br><span class="line">	<span class="keyword">character</span>(len=<span class="number">20</span>) <span class="keyword">name</span></span><br><span class="line">	<span class="keyword">real</span> :: weight, height</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!一个type(person)类型至少占用28 bytes</span></span><br><span class="line"><span class="comment">!因为它里面有20个字符及2个浮点数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>(person) :: a,b,temp</span><br><span class="line"><span class="comment">!指向 type(person) 的指针，在PC中每个变量只占4 bytes</span></span><br><span class="line"><span class="keyword">type</span>(person), <span class="keyword">pointer</span> :: pa,pb,pt</span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"><span class="comment">!要交换 type(person) 类型时，最少需要移动 28*3=84 bytes 的空间</span></span><br><span class="line">temp = a</span><br><span class="line">a = b</span><br><span class="line">b = temp</span><br><span class="line"></span><br><span class="line">pa=&gt;a</span><br><span class="line">pb=&gt;b</span><br><span class="line"><span class="comment">!如果拿指针来交换，以PC来说，只需要移动 4*3=12 bytes 的空间</span></span><br><span class="line">pt =&gt; pa</span><br><span class="line">pa =&gt; pb</span><br><span class="line">pb =&gt; pt</span><br></pre></td></tr></table></figure>
<p>来看一个以自定义类型数据来做排序的实例，排序程序常常会需要把两条数据交换，如果不使用指针，交换数据时需要移动很大块的内存空间。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> func</span><br><span class="line"><span class="comment">! person类型至少占用18 bytes</span></span><br><span class="line"><span class="comment">! 因为它有10个字符及2个浮点数</span></span><br><span class="line"><span class="keyword">type</span> person</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">10</span>) :: <span class="keyword">name</span></span><br><span class="line">    <span class="keyword">real</span> :: height, weight</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="comment">! pperson 类型通常占用 4 bytes </span></span><br><span class="line"><span class="comment">! 因为它里面只有一个指针，指针在PC中固定使用 4 bytes</span></span><br><span class="line"><span class="keyword">type</span> pperson</span><br><span class="line">    <span class="keyword">type</span>(person), <span class="keyword">pointer</span> :: p</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sort(p)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(pperson) :: p(:)</span><br><span class="line">    <span class="keyword">type</span>(pperson) :: temp</span><br><span class="line">    <span class="keyword">integer</span> i,j,s</span><br><span class="line">    </span><br><span class="line">    s = <span class="built_in">size</span>(p,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,s-<span class="number">1</span></span><br><span class="line">        <span class="keyword">do</span> j=i+<span class="number">1</span>, s</span><br><span class="line">            <span class="keyword">if</span>(p(j)%p%height &lt; p(i)%p%height) <span class="keyword">then</span></span><br><span class="line">                temp = p(i)</span><br><span class="line">                p(i) = p(j)</span><br><span class="line">                p(j) = temp</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1008</span><br><span class="line">    <span class="keyword">use</span> func</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(person), <span class="keyword">target</span> :: p(<span class="number">5</span>)=(/ person(<span class="string">&quot;陈同学&quot;</span>, <span class="number">180.0</span>, <span class="number">75.0</span>), &amp;</span><br><span class="line">                                person(<span class="string">&quot;黄同学&quot;</span>, <span class="number">170.0</span>,<span class="number">65.0</span>), &amp;</span><br><span class="line">                                person(<span class="string">&quot;刘同学&quot;</span>, <span class="number">175.0</span>,<span class="number">80.0</span>), &amp;</span><br><span class="line">                                person(<span class="string">&quot;蔡同学&quot;</span>, <span class="number">182.0</span>,<span class="number">78.0</span>), &amp;</span><br><span class="line">                                person(<span class="string">&quot;许同学&quot;</span>, <span class="number">178.0</span>,<span class="number">70.0</span>)&amp;</span><br><span class="line">                                                                /)</span><br><span class="line">    <span class="keyword">type</span>(pperson) :: pt(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">integer</span> i</span><br><span class="line">    <span class="comment">! 把pt数组中的指针全部指向数组p</span></span><br><span class="line">    <span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">        pt(i)%p =&gt; p(i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line">    <span class="comment">! 按照身高从小到大排序</span></span><br><span class="line">    <span class="keyword">call</span> sort(pt)</span><br><span class="line">    <span class="comment">! 输出排序的结果</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(5(a10,f6.1,f5.1/))&quot;</span>) (pt(i)%p, i=<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line">    <span class="comment">! 这里书上是 a8, 应该改成 a10，不然输出不完整</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">黄同学  <span class="number">170.0</span> <span class="number">65.0</span></span><br><span class="line">刘同学  <span class="number">175.0</span> <span class="number">80.0</span></span><br><span class="line">许同学  <span class="number">178.0</span> <span class="number">70.0</span></span><br><span class="line">陈同学  <span class="number">180.0</span> <span class="number">75.0</span></span><br><span class="line">蔡同学  <span class="number">182.0</span> <span class="number">78.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行过程中发现了一个现象，书上输出语句上是 a8 (字符串指定为8个字符)，而 person 自定义类型声明的时候字符长度是10，导致<strong>字符输出不完整</strong>。如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">黄同▒ 170.0 65.0</span><br><span class="line">刘同▒ 175.0 80.0</span><br><span class="line">许同▒ 178.0 70.0</span><br><span class="line">陈同▒ 180.0 75.0</span><br><span class="line">蔡同▒ 182.0 78.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里程序中使用了两个自定义类型 person 及 pperson 。person 类型可以用来记录人名、身高、体重等数据，pperson 类型中只有一个指向 person 类型的指针。数组p是 type(person) 类型，声明时同时设置了它的初值，数组 pt 则是 type(pperson) 类型。数组 p 最少会使用 28×5=140 bytes 的内存空间，而数组 pt 在目前的 PC 中只需要使用 4×5=20 bytes 的内存空间。</p>
<p>程序第49~51 行用来把数组 pt 中的指针指到数组 p 中。请注意 pt(i) 并不是指针，它是 type(pperson) 类型的变量，数组中的 pt(i)%p 元素才是指针。设置好指针之后，使用  pt(i)%p 就等于使用 pt(i)%p 就等于使用 p(i).</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">! 把pt数组中的指针全部指向数组p</span></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">    pt(i)%p =&gt; p(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br></pre></td></tr></table></figure>
<p>函数 sort 使用的算法是第7章介绍过的选择排序法，他会根据每个人的身高信息来排序。这个程序中，排序程序在做数据交换时只需要交换两条数据的内存地址，不需要去移动两条数据的内存。当自定义数据中的数据量很大时，执行效率可以有明显地提升。</p>
<h2 id="10-5-指针的高级应用">10-5 指针的高级应用</h2>
<p>指针除了可以间接地使用变量，以及当成可变大小数组来使用之外，还有一个很重要的用途，它可以创建各种的”串行结构“ 以及 ” 树状结构“ 等等。</p>
<p>使用指针来创建 ”串行结构“ 可以有很多应用，其中最重要的一项应用是用来动态使用内存。在写程序时常常会遇到无法事先估计数据数目的情况，这个问题最传统的解决方法，是声明一个”超级巨大“的数据来保存数据。而所声明的数组，在使用时大部分的空间都是闲置的。要是空间不够时，那就麻烦大了，所以一开始就尽可能地把数组加大。</p>
<p>使用”串行结构“来解决这一类的问题时，可以配合需要向内存要求刚好的空间。只有一条数据时就要求一条数据的空间，有一千条数据时，就要求一千条数据的空间。这个方法可以非常有效率地来使用内存。</p>
<h3 id="10-5-1-单向串行">10-5-1 单向串行</h3>
<p>如何节省内存，在程序设计中一直是非常重要的课题。很早的时候，节省内存是屈就于现实，因为当时计算机的内存容量都很小，所以程序一定要短小精干才行。虽然现在内存越来越便宜，内存越来越大，节省内存仍然有其必要的价值。<strong>因为无论计算机配备多少的内存，都永远无法满足贪得无厌的人类。</strong></p>
<p>现代的操作系统都号称是”多任务“的操作系统，所谓多任务的操作系统，是指计算机可以同时执行多个程序。而能够执行几个程序就取决于计算机的内存大小，以及程序所占据的内存空间。所以，如果单个程序所占用的内存越少，就可以同时执行更多的程序，或是在执行程序时得到更高的效率。</p>
<p>前面已经介绍过可变大小数组，这个功能已经可以有效率地使用内存。这个做法虽然已经有相当程度的灵活性，但是在某些情况之下仍然不足。要是数组声明好大小以后，却发现不够用了，那该怎么办？先 deallocate 再重新 allocate 吗？ 那原来在数组中已经存放的数据要怎么办？必须另外找地方把它们先保存起来，不然 deallocate 时数据会流失。</p>
<p>还有就是如果想要在数组中 ”插入“ 一个数值，必须要把数组中的数据一个个向后移动。这个方法的执行效率很差，需要做很多次的内存移动。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> j=i+<span class="number">1</span>, size_of_A-<span class="number">1</span></span><br><span class="line">	A(j)=A(j-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">A(i)=n</span><br><span class="line"><span class="comment">!要在数组A(I)插入数值时，必须使用类似上面的方法</span></span><br><span class="line"><span class="comment">!数组A(I)后面的元素必须先一个一个向后移动，再把数值插入A(I)</span></span><br></pre></td></tr></table></figure>
<p>串行结构可以解决这些问题，来看一个最简单的单行串行结构：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef </span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> :: datalink</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1010</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">target</span> :: node1,node2,node3</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    </span><br><span class="line">    node1%i=<span class="number">1</span></span><br><span class="line">    node1%next =&gt; node2</span><br><span class="line">    node2%i=<span class="number">2</span></span><br><span class="line">    node2%next =&gt; node3</span><br><span class="line">    node3%i=<span class="number">3</span></span><br><span class="line">    <span class="built_in">nullify</span>(node3%next)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) node1%i</span><br><span class="line">    <span class="built_in">write</span>(*,*) node1%next%i</span><br><span class="line">    <span class="built_in">write</span>(*,*) node1%next%next%i</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> 2</span><br><span class="line"> 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序在 module typedef 中定义了一个自定义类型 datalink 。这个类型最少占用 8 bytes，因为它里面有一个整数及一个指针。指针 next 还没设置指向谁，是不能使用的。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> :: datalink</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span></span><br></pre></td></tr></table></figure>
<p>读者可能觉得第5行的声明在逻辑上有点奇怪。在这边只要把握一个策略，指针是用来记录内存地址，所以事实上任何类型指针所记录的内容都一样。声明指针时，它的类型只是用来说明指针所记录的内存地址，存放的是什么东西。（这句话是不是所指针的数据类型只是给人看的，电脑并不在乎）</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next</span><br><span class="line"><span class="comment">!在type datalink 声明中，又出现一个 type(datalink)的类型。在这里是合理的，因为变量 next</span></span><br><span class="line"><span class="comment">!是指针，在这儿就不合理。</span></span><br></pre></td></tr></table></figure>
<p>如果 type(datalink) 可以声明成下面的类型，会出现一个问题，那就是这个类型所声明出来的变量 d，所占用的内存空间无法计算。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> :: datalink</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="keyword">type</span>(datalink) :: next <span class="comment">! 错误的声明</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span></span><br></pre></td></tr></table></figure>
<p>如果上面的程序代码是合理的，那变量 d 中可以使用的元素有无限多个，因为按照语法，下面这些变量应该都可以使用。这会导致不管多少内存都不够给变量 d 使用。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">d%i</span><br><span class="line">d%next%i</span><br><span class="line">d%next%next%i</span><br><span class="line">d%next%next%next%i</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>把 next 设置成指针就没有这个问题。因为 next 指针本身并不会记录 type(datalink) 类型的内容，它只记录在内存中哪里有 type(datalink) 类型的数据可以使用。在 next 还没设置方向之前，d%next%i 是不存在的。</p>
<p>程序的第15~20行在从事串行的创建。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">node1%i=<span class="number">1</span></span><br><span class="line">node1%next =&gt; node2</span><br><span class="line">node2%i=<span class="number">2</span></span><br><span class="line">node2%next =&gt; node3</span><br><span class="line">node3%i=<span class="number">3</span></span><br><span class="line"><span class="built_in">nullify</span>(node3%next)</span><br></pre></td></tr></table></figure>
<p>串行创建好了之后，可以出现很有趣的使用方法，来看看程序第22~24行的内容：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">write</span>(*,*) node1%i</span><br><span class="line"><span class="built_in">write</span>(*,*) node1%next%i</span><br><span class="line"><span class="built_in">write</span>(*,*) node1%next%next%i</span><br></pre></td></tr></table></figure>
<p>程序第16行做了 node1%next =&gt; node2 的设置，所以现在可以使用 node1%next, 使用它就等于使用 node2。第23行使用 node1%next%i，就等于在使用 node2%i</p>
<p>……</p>
<p>程序第20行做了 nullify(node3%next)，这个命令会确保 node3%next 不能使用，也就是所 node1%next%next%next 是不能使用的。</p>
<p>用循环来改写这个程序，看起来会更有趣。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef </span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> :: datalink</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1010</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">target</span> :: node1,node2,node3</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: p</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    </span><br><span class="line">    p=&gt;node1</span><br><span class="line">    node1%i=<span class="number">1</span></span><br><span class="line">    node1%next =&gt; node2</span><br><span class="line">    node2%i=<span class="number">2</span></span><br><span class="line">    node2%next =&gt; node3</span><br><span class="line">    node3%i=<span class="number">3</span></span><br><span class="line">    <span class="built_in">nullify</span>(node3%next)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*,*) p%i</span><br><span class="line">        <span class="keyword">if</span>(.not. <span class="built_in">associated</span>(p%next)) <span class="keyword">exit</span></span><br><span class="line">        p =&gt; p%next <span class="comment">! 把p向后移动，从node(n)移到node(n+1)</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>这个程序和改写前的 ex1011.f90 大同小异，只多使用了一个指针 p。另外在输出串行时，改用循环来输出。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">    <span class="built_in">write</span>(*,*) p%i</span><br><span class="line">    <span class="keyword">if</span>(.not. <span class="built_in">associated</span>(p%next)) <span class="keyword">exit</span></span><br><span class="line">    p =&gt; p%next <span class="comment">! 把p向后移动，从node(n)移到node(n+1)</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>来看看这一段程序为什么可以这样做。因为 p 在一开始做了 p=&gt;node1 的设置，所以刚开始进入循环时，使用p等于使用 node1。</p>
<p>循环中会输出 p%i 的内容，再检查 p%next 有没有设置。如果有设置，就重新设置指针 p 的指向，把它指向 p%next 。如果没设置，就离开循环。</p>
<p>事实上，真正的串行是不会使用本程序的方法来创建的，本程序只是用来给读者一个基础的概念。下面的实例程序才是典型的创建串行方法：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> :: datalink</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1012</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: p, head</span><br><span class="line">    <span class="keyword">integer</span> :: i,n,err</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;Input N:&#x27;</span></span><br><span class="line">    read(*,*) n</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">allocate</span>(head)</span><br><span class="line">    head%i = <span class="number">1</span></span><br><span class="line">    <span class="built_in">nullify</span>(head%next)</span><br><span class="line">    </span><br><span class="line">    p=&gt;head</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">2</span>,n</span><br><span class="line">        <span class="built_in">allocate</span>(p%next, stat=err)</span><br><span class="line">        <span class="keyword">if</span>(err /= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&#x27;Out of memory!&#x27;</span></span><br><span class="line">            <span class="keyword">stop</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        p=&gt;p%next</span><br><span class="line">        p%i=i</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">nullify</span>(p%next)</span><br><span class="line">    </span><br><span class="line">    p=&gt;head</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(i5)&quot;</span>) p%i</span><br><span class="line">        <span class="keyword">if</span>(.not. <span class="built_in">associated</span>(p%next)) <span class="keyword">exit</span></span><br><span class="line">        p =&gt; p%next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> Input N:</span><br><span class="line">5</span><br><span class="line">    1</span><br><span class="line">    2</span><br><span class="line">    3</span><br><span class="line">    4</span><br><span class="line">    5</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序把实例 ex1011.f90 中创建串行的过程，由手动一个一个衔接起来，改成使用循环自动生成。用户可以输入任意长度，由循环来生成串行。</p>
<p>第12行中声明的指针 head 会用来作为串行的”头“，也就是串行的第一条数据。指针p则用来当临时保存变量，在串行中移动。</p>
<p>第18行会配置串行中第一行数据的内存空间，第19、20行则会设置第一行数据的内容。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">allocate</span>(head)</span><br><span class="line">head%i = <span class="number">1</span></span><br><span class="line"><span class="built_in">nullify</span>(head%next)</span><br></pre></td></tr></table></figure>
<p>第22~32 行是创建串行的程序代码，进入循环之前，先把指针p指到串行的头。在循环中会一节一节添加出每个串行，再把它接上去。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">p=&gt;head</span><br><span class="line"><span class="keyword">do</span> i=<span class="number">2</span>,n</span><br><span class="line">    <span class="built_in">allocate</span>(p%next, stat=err)</span><br><span class="line">    <span class="keyword">if</span>(err /= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&#x27;Out of memory!&#x27;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    p=&gt;p%next</span><br><span class="line">    p%i=i</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">nullify</span>(p%next) <span class="comment">!出了循环，p就是串行的最后，要设置它后面没东西</span></span><br></pre></td></tr></table></figure>
<h3 id="10-5-2-双向串行、环状串行">10-5-2 双向串行、环状串行</h3>
<p>上一个小节所创建的串行结构，都只能沿着一个方向走。程序只能按照顺序，一条接着一条数据向下读取，没有办法往回走。需要往回走时，要使用双向串行。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> :: datalink</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: prev <span class="comment">!指向上一条数据</span></span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next <span class="comment">!指向下一条数据</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1013</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">target</span> :: node1,node2,node3</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: p</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    </span><br><span class="line">    node1 = datalink(<span class="number">1</span>, null(), node2)</span><br><span class="line">    node2 = datalink(<span class="number">2</span>, node1, node3)</span><br><span class="line">    node3 = datalink(<span class="number">3</span>, node2, null())</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;照顺序输出&quot;</span></span><br><span class="line">    p=&gt;node1</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*,*) p%i</span><br><span class="line">        <span class="keyword">if</span>(.not. <span class="built_in">associated</span>(p%next)) <span class="keyword">exit</span></span><br><span class="line">        p=&gt;p%next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;反过来输出&quot;</span></span><br><span class="line">    p=&gt;node3</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*,*) p%i</span><br><span class="line">        <span class="keyword">if</span>(.not. <span class="built_in">associated</span>(p%prev)) <span class="keyword">exit</span></span><br><span class="line">        p=p%prev</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">照顺序输出</span><br><span class="line">          1</span><br><span class="line">          2</span><br><span class="line">          3</span><br><span class="line">反过来输出</span><br><span class="line">          3</span><br><span class="line">          2</span><br><span class="line">          1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序把前面使用过的自定义类型 datalink 做了一点修改，增加了 prev 这个指针用来指向上一条数据。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> :: datalink</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: prev <span class="comment">!指向上一条数据</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next <span class="comment">!指向下一条数据</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span></span><br></pre></td></tr></table></figure>
<p>创建双向串行的时候，要赋值清楚上一条数据和下一条数据的位置。程序的第17-19行会创建下面的信息。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">node1 = datalink(<span class="number">1</span>, null(), node2)</span><br><span class="line">node2 = datalink(<span class="number">2</span>, node1, node3)</span><br><span class="line">node3 = datalink(<span class="number">3</span>, node2, null())</span><br></pre></td></tr></table></figure>
<p>在这里使用另一种语法来设置数据，程序第17行命令的效果，和下面三行代码相同。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">node1%i = <span class="number">1</span></span><br><span class="line">node1%prev =&gt; null()</span><br><span class="line">node1%next =&gt; node2</span><br></pre></td></tr></table></figure>
<p>这个程序会使用两种方法来输出串行数据，第1种方法和上一节的方法一样。不过这里由于使用了双向串行，既可以从前向后输出，也可以从后向前输出。</p>
<p>这个实例程序使用手动方法创建串行，实际应用时，应该都是使用自动创建串行的方式。</p>
<p>目前为止所介绍的串行结构都是有头有尾的结构，串行结构还有另外一种类型，叫做环状串行。环状串行简单地说，就是把串行的头跟尾接起来，变成一个圈圈。上一个实例程序中，只要把node1%prev 指向 node3, node3%next 指向 node1 就变成了环状串行。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> :: datalink</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: prev <span class="comment">!指向上一条数据</span></span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next <span class="comment">!指向下一条数据</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1014</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">target</span> :: node1,node2,node3</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: p</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: s=<span class="number">6</span></span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    </span><br><span class="line">    node1 = datalink(<span class="number">1</span>, node3, node2)</span><br><span class="line">    node2 = datalink(<span class="number">2</span>, node1, node3)</span><br><span class="line">    node3 = datalink(<span class="number">3</span>, node2, node1)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;照顺序输出&quot;</span></span><br><span class="line">    p=&gt;node1</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,s</span><br><span class="line">        <span class="built_in">write</span>(*,*) p%i</span><br><span class="line">        <span class="keyword">if</span>(.not. <span class="built_in">associated</span>(p%next)) <span class="keyword">exit</span></span><br><span class="line">        p=&gt;p%next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;反过来输出&quot;</span></span><br><span class="line">    p=&gt;node3</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,s</span><br><span class="line">        <span class="built_in">write</span>(*,*) p%i</span><br><span class="line">        <span class="keyword">if</span>(.not. <span class="built_in">associated</span>(p%prev)) <span class="keyword">exit</span></span><br><span class="line">        p=p%prev</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">照顺序输出</span><br><span class="line">          1</span><br><span class="line">          2</span><br><span class="line">          3</span><br><span class="line">          1</span><br><span class="line">          2</span><br><span class="line">          3</span><br><span class="line">反过来输出</span><br><span class="line">          3</span><br><span class="line">          2</span><br><span class="line">          1</span><br><span class="line">          1</span><br><span class="line">          1</span><br><span class="line">          1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>读者可以发现，在环状串行中，可以一直向后或是向前抓取数据，数据永远不会有结束的时候。</p>
<h3 id="10-5-3-插入及删除">10-5-3 插入及删除</h3>
<p>前面两个小节中介绍了创建串行的方法，不过关于串行的操作还有很多内容要学习。学会创建串行之后，还要学习在串行中插入数据及删除数据的方法。</p>
<p>使用串行的好处是，串行可以很快速地插入或删除一条数据。先来看看在数组中如果想在A(n) 中插入数据，要怎么做</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!先把a(n)之后的数据都向后移动一个位置</span></span><br><span class="line"><span class="keyword">do</span> i=size_ofA, n,-<span class="number">1</span></span><br><span class="line">	A(I+<span class="number">1</span>) = A(I)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="comment">!再把需要插入的数值放入A(N)中</span></span><br><span class="line">A(n) = <span class="keyword">value</span></span><br></pre></td></tr></table></figure>
<p>当数组A的大小很大时，循环会执行很久。再来看看如果想把A(n)删除，要怎么做</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!把a(n)之后的数据都向前移动一个位置</span></span><br><span class="line"><span class="keyword">do</span> i=n, size_of_A</span><br><span class="line">	A(i) = A(i+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>想要再数组中插入或删除数据，都非常麻烦，而且数组越大时会越没有效率。在串行中插入或删除数据就没有这个问题，不管这个串行总共有多长，都可以迅速地插入或删除数据。</p>
<p>下面是插入数据的方法：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!添加一条数据来插入</span></span><br><span class="line"><span class="built_in">allocate</span>(item)</span><br><span class="line"><span class="comment">!把item插入到目前串行位置p的后面</span></span><br><span class="line">item%next =&gt; p%next</span><br><span class="line">item%prev =&gt; p</span><br><span class="line">p%next%prev =&gt; item </span><br><span class="line">p%next =&gt; item</span><br></pre></td></tr></table></figure>
<p>下面是删除数据的方法</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!把串行目前位置指针p删除</span></span><br><span class="line">p%prev%next =&gt; p%next</span><br><span class="line">p%next%prev =&gt; p%prev</span><br><span class="line"><span class="built_in">deallocate</span>(p)</span><br></pre></td></tr></table></figure>
<p>下面是一个实际的实例程序，插入数据跟删除数据的程序代码，都独立写成两个函数：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> linklist</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> :: datalink</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: prev <span class="comment">! 指向上一条数据</span></span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next <span class="comment">! 指向下一条数据</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> OutputList(list)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: list,p</span><br><span class="line">    p=&gt;list</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(<span class="built_in">associated</span>(p))</span><br><span class="line">        <span class="built_in">write</span>(*,*) p%i</span><br><span class="line">        p =&gt; p%next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="comment">! 把指针所指到的串行位置释放</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> DelItem(item)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: item</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: prev, next</span><br><span class="line">    </span><br><span class="line">    prev =&gt; item%prev <span class="comment">! 记录item上一条数据的位置</span></span><br><span class="line">    next =&gt; item%next <span class="comment">! 记录item下一条数据的位置</span></span><br><span class="line">    <span class="built_in">deallocate</span>(item) <span class="comment">!释放item所占用内存</span></span><br><span class="line">    <span class="comment">!重新设置prev%next, 原本 prev%next=&gt;item, 不过item已经删除了</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">associated</span>(prev)) prev%next =&gt; next</span><br><span class="line">    <span class="comment">!重新设置next%prev, 原本 next%prev=&gt;item, 不过item已经删除了</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">associated</span>(next)) next%prev =&gt; prev</span><br><span class="line">    item =&gt; next</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="comment">! 在pos指针所指到的串行位置中插入 item</span></span><br><span class="line"><span class="comment">! after=.true. 时，item 插在 pos 之后</span></span><br><span class="line"><span class="comment">! after=.false. 时，item 插在 pos 之前</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> InsItem(pos,item, after)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: pos,item</span><br><span class="line">    <span class="keyword">logical</span> :: after</span><br><span class="line">    <span class="keyword">if</span>(after) <span class="keyword">then</span></span><br><span class="line">        <span class="comment">! item 插在 pos 的后面</span></span><br><span class="line">        item%next =&gt; pos%next</span><br><span class="line">        item%prev =&gt; pos</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">associated</span>(pos%next)) <span class="keyword">then</span></span><br><span class="line">            pos%next%prev =&gt; item</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        pos%prev =&gt; item</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1015</span><br><span class="line">    <span class="keyword">use</span> linklist</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: head</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: item, p</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: s=<span class="number">5</span></span><br><span class="line">    <span class="keyword">integer</span> :: i,n,error</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">allocate</span>(head)</span><br><span class="line">    head = datalink(<span class="number">1</span>, null(), null())</span><br><span class="line">    <span class="comment">!创建串行</span></span><br><span class="line">    p=&gt;head</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">2</span>,s</span><br><span class="line">        <span class="built_in">allocate</span>(p%next, stat=error)</span><br><span class="line">        <span class="keyword">if</span>(error /= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;Out of memory&quot;</span></span><br><span class="line">            <span class="keyword">stop</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        p%next = datalink(i,p,null())</span><br><span class="line">        p=&gt;p%next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;拿掉第3条数据&quot;</span></span><br><span class="line">    <span class="keyword">call</span> DelItem(head%next%next)</span><br><span class="line">    <span class="keyword">call</span> OutputList(head)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;插入新的第3条数据&quot;</span></span><br><span class="line">    <span class="built_in">allocate</span>(item)</span><br><span class="line">    item%i = <span class="number">30</span></span><br><span class="line">    <span class="keyword">call</span> InsItem(head%next, item, .true.)</span><br><span class="line">    <span class="keyword">call</span> OutputList(head)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">拿掉第3条数据</span><br><span class="line">          1</span><br><span class="line">          2</span><br><span class="line">          4</span><br><span class="line">          5</span><br><span class="line">插入新的第3条数据</span><br><span class="line">          1</span><br><span class="line">          2</span><br><span class="line">         30</span><br><span class="line">          4</span><br><span class="line">          5</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序的重点在 delitem 和 insitem 这两个子程序。delitem 用来删除串行中的一条数据，insitem 用来插入一条数据。先来看看如何删除数据：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">subroutine</span></span> DelItem(item)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: item</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: prev, next</span><br><span class="line">    </span><br><span class="line">    prev =&gt; item%prev <span class="comment">! 记录item上一条数据的位置</span></span><br><span class="line">    next =&gt; item%next <span class="comment">! 记录item下一条数据的位置</span></span><br><span class="line">    <span class="built_in">deallocate</span>(item) <span class="comment">!释放item所占用内存</span></span><br><span class="line">    <span class="comment">!重新设置prev%next, 原本 prev%next=&gt;item, 不过item已经删除了</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">associated</span>(prev)) prev%next =&gt; next</span><br><span class="line">    <span class="comment">!重新设置next%prev, 原本 next%prev=&gt;item, 不过item已经删除了</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">associated</span>(next)) next%prev =&gt; prev</span><br><span class="line">    item =&gt; next</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br></pre></td></tr></table></figure>
<p>删除数据时，要先记录一些必要的信息。释放item 指针所使用的内存之前，要把item 前后两条数据连接起来，不能让串行因为删除数据而从中间断掉。</p>
<p>数据删除后，还要重新连接串行。把原本 item 指针的上一条数据中的 next 指向原本在 item 中的下一行数据（第31行），还要把原来 item 的下一条数据中的 prev 指向原来在 item 中的上一条数据（第33行）</p>
<p>在重新链接时，要注意两点：</p>
<ol>
<li>如果要删除的 item 是串行中的第1条数据，那它就不会有上一条数据， prev%next 不存在，不需要重接</li>
<li>如果要删除的 item 是串行中的最后1条数据，那它就不会有下一条数据， next%prev 不存在，不需要重接</li>
</ol>
<p>所以，这里用到了 IF 判断。</p>
<p>再来看看插入数据的子程序 insitem 。它需要3个参数，pos 用来赋值数据要插入串行中的哪一个位置，item 是用来插入的数据，after 用来赋值 item 是要拿来插在指针 pos 的前面还是后面。</p>
<p>这个子程序允许用户把数据插入在赋值前面或是后面，所以插入数据的程序会分成两种情况处理。</p>
<p>先来看把数据插在后面的部分：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">item%next =&gt; pos%next</span><br><span class="line">item%prev =&gt; pos</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">associated</span>(pos%next)) <span class="keyword">then</span></span><br><span class="line">    pos%next%prev =&gt; item</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">pos%next =&gt; item</span><br></pre></td></tr></table></figure>
<p>先把新插入的 item 中的 next 及 prev 指针指好位置，再重新设置 pos 中 next 指针及原来在 pos 后面数据中 prev 指针的位置。这两个指针都要重新指向新插入的item。</p>
<p>另一种情况也类似。</p>
<p>这一节的实例程序示例了使用串行的方法，不过目前为止，经过 allocate 所得到的串行数据，在程序代码中都没有使用 deallocate 函数来释放。实际编写程序时最好不要省略这一步。下面列出一段可以释放整个串行的程序代码，只要把串行开头的指针输入，就可以释放整个串行所使用的内存。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">subroutine</span></span> deletelist(list)</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">	<span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: list, next</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">do</span> <span class="keyword">while</span>(<span class="built_in">associated</span>(list))</span><br><span class="line">		next =&gt; list%next</span><br><span class="line">		<span class="built_in">deallocate</span>(list)</span><br><span class="line">		list =&gt; next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br></pre></td></tr></table></figure>
<p>请记住只有通过 allocate 函数所配置到的内存才要使用 deallocate 来释放。所以用变量所创建出来的串行，就不需要，也不可以使用 deallocate 来释放内存。</p>
<h3 id="10-5-4-串行的应用">10-5-4 串行的应用</h3>
<p>串行比数组好用的地方，在于串行可以比较灵活地使用内存。使用串行时可以不用考虑这个串行需要记录多少条数据，反正串行可以很快速的增减数据。</p>
<p>来看一个读取文件的例子。假如我们事先不确定文件中会有多少数据，就不能使用数组来读取数据，因为不知道数组该声明成多大。一定要使用数组的话，就必须把数组设置成很大、一定够用的数量。这个方法会造成内存的浪费，因为很可能这个数组中，实际只用了很小的一部分。</p>
<p>光盘中 program\chap10\data1. txt 及 data2.txt 是两个班级的段考成绩单，两班的人数不同，请编写一个可以读取成绩的程序，让用户输入文件名来决定读取哪一个文件，还要提供给用户通过座号来查询成绩的功能。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> linklist</span><br><span class="line">    <span class="keyword">type</span> student</span><br><span class="line">        <span class="keyword">integer</span> :: num</span><br><span class="line">        <span class="keyword">integer</span> :: Chinese, English, Math, Science, Social</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">type</span> datalink</span><br><span class="line">        <span class="keyword">type</span>(student) :: item</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span></span> SearchList(num, head)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: num</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: head, p</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: SearchList</span><br><span class="line">        </span><br><span class="line">        p=&gt;head</span><br><span class="line">        <span class="built_in">nullify</span>(SearchList)</span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(<span class="built_in">associated</span>(p))</span><br><span class="line">            <span class="keyword">if</span>(p%item%num==num) <span class="keyword">then</span></span><br><span class="line">                SearchList =&gt; p</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">            p=&gt;p%next</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1016</span><br><span class="line">    <span class="keyword">use</span> linklist</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: filename</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) :: tempstr</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: head</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: p</span><br><span class="line">    <span class="keyword">integer</span> i,error,<span class="built_in">size</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;filename: &quot;</span></span><br><span class="line">    read(*,*) filename</span><br><span class="line">    open(<span class="number">10</span>, <span class="keyword">file</span>=filename, <span class="keyword">status</span>=<span class="string">&quot;old&quot;</span>, <span class="keyword">iostat</span>=error)</span><br><span class="line">    <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;Open file fail!&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">allocate</span>(head)</span><br><span class="line">    <span class="built_in">nullify</span>(head%next)</span><br><span class="line">    p=&gt;head</span><br><span class="line">    <span class="built_in">size</span>=<span class="number">0</span></span><br><span class="line">    read(<span class="number">10</span>, <span class="string">&quot;(a80)&quot;</span>) tempstr <span class="comment">!读入第一行字符串，不需要处理它</span></span><br><span class="line">    <span class="comment">! 读入每一位学生的成绩</span></span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        read(<span class="number">10</span>, <span class="keyword">fmt</span>=*, <span class="keyword">iostat</span>=error) p%item</span><br><span class="line">        <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        <span class="built_in">size</span> = <span class="built_in">size</span>+<span class="number">1</span></span><br><span class="line">        <span class="built_in">allocate</span>(p%next, stat=error) <span class="comment">! 添加下一条数据</span></span><br><span class="line">        <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;Out of memory&quot;</span></span><br><span class="line">            <span class="keyword">stop</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        p =&gt; p%next <span class="comment">!移动到串行的下一条数据</span></span><br><span class="line">        <span class="built_in">nullify</span>(p%next)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;总共有&#x27;,i3,&#x27;位学生&#x27;)&quot;</span>) <span class="built_in">size</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;要查询几号同学的成绩？&quot;</span></span><br><span class="line">        read(*,*) i</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">1</span> .or. i&gt;<span class="built_in">size</span>) <span class="keyword">exit</span> <span class="comment">!输入不合理的座号</span></span><br><span class="line">        p =&gt; SearchList(i,head)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">associated</span>(p)) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(5(a6,i3))&quot;</span>) <span class="string">&quot;中文&quot;</span>, p%item%Chinese, &amp;</span><br><span class="line">                                <span class="string">&quot;英文&quot;</span>, p%item%English, &amp;</span><br><span class="line">                                <span class="string">&quot;数学&quot;</span>, p%item%Math, &amp;</span><br><span class="line">                                <span class="string">&quot;自然&quot;</span>, p%item%Science, &amp;</span><br><span class="line">                                <span class="string">&quot;社会&quot;</span>, p%item%Social</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">exit</span> <span class="comment">! 找不到数据，离开循环</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;座号&#x27;,i3,&#x27;不存在，程序结束.&#x27;)&quot;</span>) i</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序使用单向串行来记录学生数据。使用串行的缺点是，不能够很快速地随机使用串行中地第n行数据。串行只适合用来顺序读取数据，不适合做随机读取。函数 SearchList 会根据输入的学生座号，在串行中找出数据的所在位置。</p>
<p>事实上函数 SearchList 可以不需要写得如此麻烦。因为在这里是根据座号来查询成绩，创建串行是，是根据座号一条数据一条数据接起来的。所以第n号学生，也就是串行的第n条数据，在这里可以使用循环来定位出第n条数据的位置。在这个程序中，用下面的 GetN 函数可以做到与 SearchList 相同的效果。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> GetN(num, head)</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">	<span class="keyword">integer</span> :: num</span><br><span class="line">	<span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: head, p</span><br><span class="line">	<span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: GetN</span><br><span class="line">	<span class="keyword">integer</span> i</span><br><span class="line">	p =&gt; head</span><br><span class="line">	<span class="keyword">do</span> i=<span class="number">2</span>,num</span><br><span class="line">		p=&gt;head%next</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">	GetN =&gt; p</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br></pre></td></tr></table></figure>
<p>比较好的编写方法，应该是先使用串行来读取文件。读完文件之后，就会指到学生数目，这时候就可以使用另一个可变大小数组来复制串行中的学生成绩。接着再把串行全部删除，查询成绩时直接使用数组来查询就行了。</p>
<h2 id="11-module-及面向对象">11 module 及面向对象</h2>
<p>第8章并没有完全说明 module 的作用，在这一章会详细解释它的功能。</p>
<h2 id="11-1-结构化与面向对象">11-1 结构化与面向对象</h2>
<h3 id="11-1-1-结构化程序设计概念">11-1-1 结构化程序设计概念</h3>
<p>现在的程序语言，都可以算是”结构化“ 程序语言。结构化程序的特点在于”层次分明“， 检查程序代码时，可以把它们分成不同的程序模块。</p>
<p>结构化的程序代码，可以做出 “层次的分析”。在没有遇到循环、流程控制时，程序代码都属于同一个层次；进入循环、流程控制时，程序代码则会归类成下一个层次。相同层次的程序代码，可以把它们视为相同的程序模块。</p>
<p>同一个模块的程序代码，执行顺序都是由上而下，一行行地来进行。遇到循环时，也是以模块为单位来重复执行程序代码。编写程序时，最好把不同层次的程序模块做不同的画面处理，例如每多一个层次，就多使用两个空格来向后错位，这个习惯可以提高程序代码的可读性。（一直在这么做）。结构化的意义，就在于程序代码是由井然有序的模块结构所创建起来的。</p>
<p>读者应该记得之前介绍过一个很有威力的 goto 命令，但是并不建议读者使用它。因为使用 goto 命令的程序，执行时常常会在程序代码中忽前忽后地跳转，这样会很容易破坏程序结构。</p>
<h3 id="11-1-2-面向对象程序设计概论">11-1-2 面向对象程序设计概论</h3>
<p>新一代地程序语言，出了具有原来地结构化程序设计方法外，还加入了“面向对象”概念。简单地说，面向对象是在做程序代码封装地操作。封装过后的程序代码，在使用上会比较安全。</p>
<p>举个例子，上银行领钱时，一定要通过银行的出纳员或是自动提款机的帮忙，才能领出户头里的钱。为了安全理由，银行不可能直接把金库开放，让客户自行取出属于自己的金钱。要是让每个人都自己去金库领钱，那一定会天下大乱。</p>
<p>为了安全起见，每个人到银行领款，一定要通过出纳员或是提款机的服务才能拿到钱。读者可以把出纳员和提款机想象成是银行对外界服务的接口，这个接口隐含了背后的实际工作情况。</p>
<p>面向对象中很重要的一项工作，就是数据封装。数据经过封装之后可以分为两种数据，一种是可以直接让大家使用的数据，另一种是只能在内部使用的数据。函数也可以拿来做封装，分开公开使用和内部使用的函数。以银行的例子来说，银行里的钱，就算是银行的内部数据，不能直接让外人使用，只有银行内部的员工才能直接接触它们。</p>
<p>出了数据封装外，面向对象的另一个重点是程序代码的重复使用。重复使用程序代码最简单的方法，就是使用函数。面向对象提供另外一种思考方法来重复使用程序代码。</p>
<p>有句俗话说：“老鼠生的儿子会打洞”，这里面有遗传的概念，它假设儿女可以继承父母亲所拥有的能力。虽然在现实生活中，继承的现象不一定会发生，不过在编写程序时，程序员可以强迫它发生，使用 module 可以用类似继承的方法来重复使用程序代码。</p>
<p>简单地说，面向对象给程序员两个新的思考方向：</p>
<ol>
<li>为了安全起见，有些数据不应该让外界使用。</li>
<li>经过继承来重复使用程序代码。</li>
</ol>
<h2 id="11-2-再论-module">11-2 再论 module</h2>
<p>module 是 fortran 90 中很重要的一项添加功能，它不单纯只是一个添加的功能，它还带来了很多新的概念，这一节会把 module 的用法做一个总结。</p>
<h3 id="11-2-1-module-的结构及功能">11-2-1 module 的结构及功能</h3>
<p>第8章已经介绍过 module 的部分功能，再来回顾一下这些内容：</p>
<ol>
<li>module 里面可以声明变量，经常用来声明程序中所需要的常量、或是用来存放全局变量。</li>
<li>module 里面可以定义自定义类型，再经过 use 的命令让程序的每一个函数都能使用这个类型。</li>
<li>module 里面可以编写函数，通常会把功能相关的函数放在同一个 module 中。在 module 外面调用这些函数时，同样要使用 use 命令</li>
<li>module 里面的函数，可以直接使用同一个 module 中所声明的变量。所以 module 里面的函数，可以经过 module 里面的变量来互相传递数据。</li>
</ol>
<h3 id="11-2-2-public-private">11-2-2 public, private</h3>
<p>module 里面的数据和函数，可以通过 public 或 private 命令，来区分成公开使用及私下使用，这里用一个实例程序来模拟到银行领钱的例子。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> bank </span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">private</span> money</span><br><span class="line">    <span class="keyword">public</span> LoadMoney, SaveMoney, Report</span><br><span class="line">    <span class="keyword">integer</span> :: money = <span class="number">1000000</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> LoadMoney(num)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: num</span><br><span class="line">        money = money - num</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> SaveMoney(num)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: num</span><br><span class="line">        money = money + num</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Report()</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;银行目前库存&#x27;,i8,&#x27;元&#x27;)&quot;</span>) money</span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1101</span><br><span class="line">    <span class="keyword">use</span> bank</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">call</span> LoadMoney(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">call</span> SaveMoney(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">call</span> Report()</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">银行目前库存 1000900元</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序执行结果并不重要，这个程序的重点在于 module bank 中把 money 变量限制为私下使用。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> money</span><br></pre></td></tr></table></figure>
<p><strong>经过这个声明，变量 money 只能在 module bank 中使用，所以主程序中不能使用 money 变量。</strong></p>
<p>除了变量，函数也可以经过 private 或 public 来定义它是否能对外公开。 程序第4行定义了几个可以对外界公开使用的接口：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> LoadMoney, SaveMoney, Report</span><br></pre></td></tr></table></figure>
<p>没有特别经过 private 或 public 来赋值时，<strong>默认的状态为 public</strong>。</p>
<p>变量 money 代表银行中目前的库存现金数量。只有银行的出纳员才能直接动用这些现金，所以变量 money 定义为 private 的状态。读者如果试着在主程序中去使用变量 money ，编译时会发生错误。如果外界可以直接使用变量 money ，很可能会发生 “抢银行” 的事件。</p>
<p>上一个实例不太实用，函数 LoadMoney 和 SaveMoney 只是单纯地重新计算银行的库存现金。实际上在提款和存款时，银行一定都会留下记录，下面是比较完整的实例程序。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> bank </span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: money = <span class="number">1000000</span></span><br><span class="line">    <span class="keyword">integer</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">private</span> money, fileid <span class="comment">! 这两个变量不对外公开</span></span><br><span class="line">    <span class="keyword">private</span> TimeLog <span class="comment">!这个函数不对外公开</span></span><br><span class="line">    <span class="comment">! public LoadMoney, SaveMoney, Report</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> TimeLog() <span class="comment">! 在log 文件中写入现在的时间</span></span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: num</span><br><span class="line">        <span class="keyword">character</span>(len=<span class="number">20</span>) :: date, time</span><br><span class="line">        <span class="keyword">call</span> <span class="built_in">Date_And_Time</span>(date,time)</span><br><span class="line">        <span class="built_in">write</span>(fileid, <span class="string">&quot;(&#x27;Date:&#x27;,a8,&#x27; Time:&#x27;,a2,&#x27;:&#x27;,a2,&#x27;:&#x27;,a2)&quot;</span>) &amp;</span><br><span class="line">            date, time(<span class="number">1</span>:<span class="number">2</span>), time(<span class="number">3</span>:<span class="number">4</span>), time(<span class="number">5</span>:<span class="number">6</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> LoadMoney(<span class="keyword">name</span>,num)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">character</span>(len=*) :: <span class="keyword">name</span></span><br><span class="line">        <span class="keyword">integer</span> :: num</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(num&lt;=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;不合理的金额&quot;</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        </span><br><span class="line">        open(fileid, <span class="keyword">file</span>=<span class="string">&quot;log.txt&quot;</span>, <span class="keyword">position</span> = <span class="string">&quot;append&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span>(money &gt;= num) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">call</span> TimeLog() <span class="comment">! 写下时间</span></span><br><span class="line">            <span class="built_in">write</span>(fileid, <span class="string">&quot;(a10, &#x27; 领取&#x27;,i5,&#x27;元&#x27;)&quot;</span>) <span class="keyword">name</span>, num <span class="comment">!提款记录</span></span><br><span class="line">            money = money - num</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">write</span>(fileid, *) <span class="string">&quot;银行目前现金不足&quot;</span></span><br><span class="line">            <span class="built_in">write</span>(*, *) <span class="string">&quot;银行目前现金不足&quot;</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        close(fileid)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> SaveMoney(<span class="keyword">name</span>,num)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">character</span>(len=*) :: <span class="keyword">name</span></span><br><span class="line">        <span class="keyword">integer</span> :: num</span><br><span class="line">        <span class="keyword">if</span>(num&lt;=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;不合理的金额&quot;</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        open(fileid, <span class="keyword">file</span>=<span class="string">&quot;log.txt&quot;</span>, <span class="keyword">position</span>=<span class="string">&quot;append&quot;</span>)</span><br><span class="line">        <span class="keyword">call</span> TimeLog() <span class="comment">! 写下时间</span></span><br><span class="line">        <span class="built_in">write</span>(fileid, <span class="string">&quot;(a10,&#x27; 存入&#x27;,i5,&#x27;元&#x27;)&quot;</span>) <span class="keyword">name</span>, num <span class="comment">! 存款记录</span></span><br><span class="line">        close(fileid)</span><br><span class="line">        money = money + num</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1102</span><br><span class="line">    <span class="keyword">use</span> bank</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">call</span> LoadMoney(<span class="string">&quot;彭先生&quot;</span>,<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">call</span> SaveMoney(<span class="string">&quot;陈先生&quot;</span>,<span class="number">1000</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行后生成 log.txt 文件，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Date:20210310 Time:10:35:56</span><br><span class="line"> 彭先生 领取  100元</span><br><span class="line">Date:20210310 Time:10:35:56</span><br><span class="line"> 陈先生 存入 1000元</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序把原本很不实用的 module bank 做了很多修改，像调用 LoadMoney 来进行提款之前，会判断提款金额是否合理，还会判断银行是否有足够的库存现金来支付。调用 SaveMoney 来进行存款前，会先判断存款金额是否合理。最重要的是在调用 LoadMoney 及 SaveMoney 来提款或存款时，都会在文件 log.txt 中留下记录。</p>
<p>程序中已经调用 Fortran 90 的库存函数 date_and_time，这个函数会用字符串来返回目前的日期和时间。</p>
<p>这个实例程序的 LoadMoney 函数比上一个版本合理，因为它不再只是单纯地重新设置变量 money 的值，他会检查变量 money 的数值，不让 money 变成负值。面向对象中，经过使用接口来操作内部数据，主要时为了避免不正常使用数据，并减少错误发生的机会。</p>
<p>private 和 public 命令也可以通过下面的方法来使用：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="comment">!定义这个module中，没有特别赋值的东西都不对外公开</span></span><br><span class="line"><span class="keyword">public</span> c <span class="comment">!定义变量c可以对外公开</span></span><br></pre></td></tr></table></figure>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="comment">!定义这个module中，没有特别赋值的东西都对外公开</span></span><br><span class="line"><span class="keyword">private</span> c <span class="comment">!定义变量c不对外公开</span></span><br></pre></td></tr></table></figure>
<h3 id="11-2-3-use">11-2-3 use</h3>
<p>第8章已经介绍过 use 命令的使用，编写好 module 之后，要使用 use 命令才能让 module 外的函数使用 module 里面的东西。在 module 中也可以使用另外一个 module。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> A</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">	<span class="keyword">integer</span> :: a,b</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> B</span><br><span class="line">	<span class="keyword">use</span> A <span class="comment">! module中可以使用另外一个 module</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub()</span><br><span class="line">	<span class="keyword">use</span> B <span class="comment">! 函数中要经过 use 才能使用编写好的 module</span></span><br><span class="line">	……</span><br></pre></td></tr></table></figure>
<p>使用 module 的数量并没有限制，可以同时使用好几个 module，只要多写几个 use 就行了。同时使用多个 module 时，可能会遇到变量名称或是函数名称重复的问题。use 命令后面，可以临时把 module 里面的变量或函数名称改名。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> A</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">	<span class="keyword">integer</span> va</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> B</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">	<span class="keyword">integer</span> va</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">	<span class="keyword">use</span> A, aa=&gt;va <span class="comment">!把 module A 的变量va改名为aa来使用</span></span><br><span class="line">	<span class="keyword">use</span> B</span><br><span class="line">	……</span><br></pre></td></tr></table></figure>
<p>上面的例子中，module A 和 module B 都同时拥有名称为 va 的变量。在主程序中同时使用这两个 module 时，会出现呢变量名称重复的问题。所以在主程序中必须临时把 module A 中的变量 va 改成另外一个名字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use A, aa&#x3D;&gt;va !把 module A 的变量va改名为aa来使用</span><br></pre></td></tr></table></figure>
<p>改名是解决名称重复的方法，而如果两个 module 中重复的名称太多时，把每个名字都改掉也很麻烦。如果不需要用到两个 module 中的所有东西，可以只选择 module 里某一些东西来使用。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> A, <span class="keyword">only</span> : vc <span class="comment">! 只用 module A 中的变量 vc</span></span><br></pre></td></tr></table></figure>
<p>使用 only 时，同时也可以做临时改名的操作。和前面一样，只要再加上符合 “=&gt;“ 就行了。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> A, <span class="keyword">only</span> : c =&gt; vc <span class="comment">! 只用 module A 中的变量 vc, 并改名为c</span></span><br></pre></td></tr></table></figure>
<p>在 module A 中使用 module B，可以想象是 module A 继承了 module B 的数据和函数。<strong>不过继承的东西只限制在 module B 中对外公开的变量及函数，module B 所私下使用的东西不会被继承。</strong></p>
<p>来看一个例子</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> MA</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> a,b</span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> getx()</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;x=&#x27;,f5.2)&quot;</span>) -b/a</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> MB</span><br><span class="line">    <span class="keyword">use</span> MA</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> c</span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> getx2()</span><br><span class="line">        <span class="keyword">real</span> a2, d, sqrt_d</span><br><span class="line">        a2 = <span class="number">2</span>*a</span><br><span class="line">        d = b*b-<span class="number">4</span>*a*c</span><br><span class="line">        <span class="keyword">if</span>(d&gt;=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            sqrt_d = <span class="built_in">sqrt</span>(d)</span><br><span class="line">            <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;x=&#x27;,f5.2,&#x27;,&#x27;,f5.2)&quot;</span>) (-b+sqrt_d)/a2, (-b-sqrt_d)/a2</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;无实数解&quot;</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub1()</span><br><span class="line">    <span class="keyword">use</span> MA</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    a = <span class="number">2.0</span></span><br><span class="line">    b = <span class="number">3.0</span></span><br><span class="line">    <span class="keyword">call</span> getx()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub2()</span><br><span class="line">    <span class="keyword">use</span> MB</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    a = <span class="number">1.0</span></span><br><span class="line">    b = <span class="number">4.0</span></span><br><span class="line">    c = <span class="number">4.0</span></span><br><span class="line">    <span class="keyword">call</span> getx2()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">call</span> sub1()</span><br><span class="line">    <span class="keyword">call</span> sub2()</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x&#x3D;-1.50</span><br><span class="line">x&#x3D;-2.00,-2.00</span><br></pre></td></tr></table></figure>
<p>这个程序中的 module MA 可以用来解 ax+b=0 的 x值，module MB 则可以用来解 ax+b=0 的 x 值及 ax^2^ + bx + c=0 的 x 值。module MB 中只实现了第2部分的功能，第1部分的功能是从 module MA 中继承来的。</p>
<p>不过有一个地方需要特别介绍一下，程序的第22行使用<code>(-b±sqrt(b^2-4ac))/2a</code> 这个公式来计算两个解。</p>
<p>为了避免重复不必要的计算，程序先把 2a 和 sqrt(b^2-4ac) 的计算结果保存至变量 a2 和 sqrt_d 中，计算 x 值则用下面两个式子来做计算：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">x0 = (-b+sqrt_d)/a2</span><br><span class="line">x1 = (-b-sqrt_d)/a2</span><br></pre></td></tr></table></figure>
<p>如果不事先计算 2a 和 sqrt(b^2-4ac)  的结果，计算 x 值时需要用下面这两个算式来计算：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">x0 = (-b+<span class="built_in">sqrt</span>(b*b-<span class="number">4</span>*a*c))/(<span class="number">2</span>*a)</span><br><span class="line">x1 = (-b-<span class="built_in">sqrt</span>(b*b-<span class="number">4</span>*a*c))/(<span class="number">2</span>*a)</span><br></pre></td></tr></table></figure>
<p>第2个方法效率比较差，因为这两个算式会重复计算  2a 和 sqrt(b^2-4ac)   的值。在大程序中，这种多余的计算会明显地影响执行效率。</p>
<blockquote>
<p>我不太懂这里的意思，在目前这个程序中，x0 x1均只计算一次，所以 2a 和 sqrt(b^2-4ac) 这两个值事先计算还是放在公式里，都是只算一次啊，哪来的重复计算影响效率。</p>
<p>估计是作者说错了，除非这里用到了循环，事先计算才能提高效率。</p>
</blockquote>
<p>这个实例程序中，module MB 里面使用 getx2 来计算 ax^2^ + bx + c = 0 的 x 值。封装成链接库时，用户要记得 getx 和 getx2 的差别。如果能把所有的名称都统一成 getx 也许会是一个好方法。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> MB</span><br><span class="line">    <span class="keyword">use</span> MA, getx1 =&gt; getx <span class="comment">!MA中的 getx 改为 getx1</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> c</span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> getx() <span class="comment">!MB 中的 getx2 改为 getx</span></span><br><span class="line">        <span class="keyword">real</span> a2, d, sqrt_d</span><br><span class="line">        a2 = <span class="number">2</span>*a</span><br><span class="line">        d = b*b-<span class="number">4</span>*a*c</span><br><span class="line">        <span class="keyword">if</span>(d&gt;=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            sqrt_d = <span class="built_in">sqrt</span>(d)</span><br><span class="line">            <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;x=&#x27;,f5.2,&#x27;,&#x27;,f5.2)&quot;</span>) (-b+sqrt_d)/a2, (-b-sqrt_d)/a2</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;无实数解&quot;</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br></pre></td></tr></table></figure>
<p>把 module MB 经过上面的方法来改写后，使用 module MB 时，可以经过 getx 函数来计算 ax^2^ + bx + c = 0 的 x 值，因为在 module MB 中，继承来的 getx 函数被改名成 getx1，所以可以在 module MB 中显示新的 getx。不过要计算 ax+b=0时，变成要调用 getx1，所以这个方法并不能算是很好的方法，下一节会介绍一个更好的解决方法。</p>
<h2 id="11-3-再论-interface">11-3 再论 interface</h2>
<p>在第8章中，interface 是用来说明函数的参数及返回值类型。不过<strong>当函数封装在 module 里面时，就不需要再使用 interface 来做这些说明</strong>。事实上 interface 的功能不只是这些，它还有其他很强大的功能可以使用。</p>
<h3 id="11-3-1-同名函数的重载（overload）">11-3-1 同名函数的重载（overload）</h3>
<p>overload 的意义是：”在程序代码中可以同时拥有多个名称相同，但是参数类型、数目不同的函数，程序会自动根据输入的参数，来决定要调用哪一个函数“。</p>
<p>Fortran 90 编写函数重载的方法和C++不太一样，在module中使用 interface，可以用来定义一个虚拟的函数名称，来看下面的实例：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> MA</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">interface</span> show <span class="comment">! 虚拟的函数名称 show</span></span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> show_int <span class="comment">!等待选择的函数show_int</span></span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> show_character <span class="comment">!等待选择的函数show_character</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> show_int(n)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span>, <span class="keyword">intent</span>(<span class="keyword">in</span>) :: n</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;n=&#x27;,i3)&quot;</span>) n</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> show_character(str)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">character</span>(len=*), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: str</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;str=&#x27;,a)&quot;</span>) str</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> MA</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">call</span> show_int(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">! 输入的参数是整数，会自动选择调用 show_int</span></span><br><span class="line">    <span class="keyword">call</span> show(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">call</span> show_character(<span class="string">&quot;Fortran 95&quot;</span>)</span><br><span class="line">    <span class="comment">! 输入的参数是字符串，会自动选择调用 show_character</span></span><br><span class="line">    <span class="keyword">call</span> show(<span class="string">&quot;Fortran 95&quot;</span>)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n&#x3D;  1</span><br><span class="line">n&#x3D;  1</span><br><span class="line">str&#x3D;Fortran 95</span><br><span class="line">str&#x3D;Fortran 95</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个实例程序的第4~7行，在 module MA 中使用 interface 定义出虚拟的函数 show。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> show <span class="comment">! 虚拟的函数名称 show</span></span><br><span class="line">    <span class="keyword">module</span> <span class="keyword">procedure</span> show_int <span class="comment">!等待选择的函数show_int</span></span><br><span class="line">    <span class="keyword">module</span> <span class="keyword">procedure</span> show_character <span class="comment">!等待选择的函数show_character</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">interface</span></span><br></pre></td></tr></table></figure>
<p>在 interface show 中，定义的两个函数可以被冒名顶替。在程序进行中调用 show 时，实际上会从这两个函数中挑出一个出来执行，挑选的根据在于调用 show 时所输入的参数。输入一个整数时，会调用 show_int ；输入一个字符串时，会调用 show_character。</p>
<p>因此我们可以改写一下之前计算 ax+b=0 ; ax^2^ + bx +c =0 的程序</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> MA</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">interface</span> getx</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> getx1</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> getx2</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> getx1(a,b)</span><br><span class="line">        <span class="keyword">real</span> a,b</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;x=&#x27;,f5.2)&quot;</span>) -b/a</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> getx2(a,b,c)</span><br><span class="line">        <span class="keyword">real</span> a, b, c</span><br><span class="line">        <span class="keyword">real</span> a2, d, sqrt_d</span><br><span class="line">        a2 = <span class="number">2</span>*a</span><br><span class="line">        d = b*b-<span class="number">4</span>*a*c</span><br><span class="line">        <span class="keyword">if</span>(d&gt;=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            sqrt_d = <span class="built_in">sqrt</span>(d)</span><br><span class="line">            <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;x=&#x27;,f5.2,&#x27;,&#x27;,f5.2)&quot;</span>) (-b+sqrt_d)/a2, (-b-sqrt_d)/a2</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;无实数解&quot;</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> MA</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">call</span> getx(<span class="number">1.0</span>,<span class="number">2.0</span>) <span class="comment">!实际上会调用 getx1</span></span><br><span class="line">    <span class="keyword">call</span> getx(<span class="number">1.0</span>,<span class="number">3.0</span>,<span class="number">2.0</span>) <span class="comment">!实际上会调用 getx2</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x&#x3D;-2.00</span><br><span class="line">x&#x3D;-1.00,-2.00</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序统一调用 getx ，通过参数个数来判断调用哪个函数。</p>
<h3 id="11-3-2-自定义操作符">11-3-2 自定义操作符</h3>
<p>Fortran 基本数值的数据类型，主要有 integer, real 这两种。使用这两种类型所声明出来的变量，除了可以用来保存数值外，还可以拿来做+,-,*,/ 数学计算及 &lt;, &lt;=, &gt;, &gt;=, ==, /= 等等的逻辑判断。而使用 type 所声明的自定义类型，默认时不能拿来做这些运算。不过通过 interface 的帮忙，可以虚拟出上述的运算符号。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> operator(+)</span><br><span class="line">	<span class="comment">!在程序代码中，使用a+b时，若a和b的参数符合下面任何函数中的</span></span><br><span class="line">	<span class="comment">!两个参数类型，会调用其中一个函数来执行</span></span><br><span class="line">	<span class="keyword">module</span> <span class="keyword">procedure</span> add1</span><br><span class="line">	<span class="keyword">module</span> <span class="keyword">procedure</span> add2</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">interface</span></span><br></pre></td></tr></table></figure>
<p>来看一个简单的例子：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> MA</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">	<span class="keyword">type</span> ta</span><br><span class="line">		<span class="keyword">integer</span> a</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line">    <span class="keyword">interface</span> operator(+) <span class="comment">!这个interface让 type(ta) 类型变量也能相加</span></span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> add</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> add(a,b)</span><br><span class="line">        <span class="keyword">type</span>(ta), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: a,b</span><br><span class="line">        add = a%a+b%a</span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1106</span><br><span class="line">    <span class="keyword">use</span> MA</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(ta) :: a,b</span><br><span class="line">    <span class="keyword">integer</span> :: c</span><br><span class="line">    a%a = <span class="number">1</span></span><br><span class="line">    b%a = <span class="number">2</span></span><br><span class="line">    c = a+b <span class="comment">!会调用add(a,b)来执行</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) c</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<p>这正是 a%a + b%b 的结果。这个程序主要是用来示例自定义操作符的方法，在module MA中定义了一个特别的 interface，它把加法 ”+“ 符号也拿来当成虚拟函数的名称。所以主程序中出现加法时，如果相加的两个变量都是 type(ta) 类型，会自动转换成调用函数 add 来执行。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> operator(+) <span class="comment">!这个interface让 type(ta) 类型变量也能相加</span></span><br><span class="line">    <span class="keyword">module</span> <span class="keyword">procedure</span> add</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">interface</span></span><br></pre></td></tr></table></figure>
<p>请注意，要把运算符号拿来当成虚拟函数名称时， interface 后面要先接上 operator 这个字，再用括号把运算符号括起来。另外在 interface 中等待候选的函数，必须明确显示每一个参数属性 intent。</p>
<p>来看一个比较实用的实例：黄先生在这个月的5日 及 20日分别和许律师约谈了1个小时45分，2小时18分。请问黄先生这个月花了多少时间和他的律师讨论有关他的遗产分配问题？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module time_util</span><br><span class="line">    implicit none</span><br><span class="line">    type :: time</span><br><span class="line">        integer :: hour, minute</span><br><span class="line">    end type time</span><br><span class="line">    interface operator(+) ! 让type(time)类型变量能够相加</span><br><span class="line">        module procedure add</span><br><span class="line">    end interface</span><br><span class="line">    </span><br><span class="line">contains</span><br><span class="line">    function add(a,b)</span><br><span class="line">        implicit none</span><br><span class="line">        type(time),intent(in) :: a,b</span><br><span class="line">        type(time) :: add</span><br><span class="line">        integer :: minutes, carry</span><br><span class="line">        minutes &#x3D; a%minute + b%minute</span><br><span class="line">        carry &#x3D; minutes&#x2F;60</span><br><span class="line">        add%minute &#x3D; mod(minutes,60) !取余数</span><br><span class="line">        add%hour &#x3D; a%hour + b%hour + carry</span><br><span class="line">        return</span><br><span class="line">    end function</span><br><span class="line">    </span><br><span class="line">    subroutine output(t)</span><br><span class="line">        type(time), intent(in) :: t</span><br><span class="line">        write(*, &quot;(i2,&#39;:&#39;,i2.2)&quot;) t%hour, t%minute</span><br><span class="line">        return</span><br><span class="line">    end subroutine</span><br><span class="line"></span><br><span class="line">end module</span><br><span class="line"></span><br><span class="line">program ex1107</span><br><span class="line">    use time_util</span><br><span class="line">    implicit none</span><br><span class="line">    type(time) :: a,b,c</span><br><span class="line">    a &#x3D; time(1,45)</span><br><span class="line">    b &#x3D; time(2,18)</span><br><span class="line">    c&#x3D;a+b !实际上会调用函数add(a,b)</span><br><span class="line">    call output(c)</span><br><span class="line">    </span><br><span class="line">    stop</span><br><span class="line">end program</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>程序执行后会计算出1小时45分加上2小时18分的时间长度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4:03</span><br></pre></td></tr></table></figure>
<p>这里的 interface 里面，只有一个”候选“的函数。在这里的候选函数只能是函数，不能是子程序。因为数学计算 a+b 一定要返回一个结果。在主程序中执行 c = a+b 时，实际上执行的是 c=add(a,b) 。经过 interface 的封装，可以让程序代码中使用直观的运算符号来调用这个函数。</p>
<p>使用 interface operator() 来自定义操作符时，还有一点很有趣，程序员可以任意制作出 Fortran 标准中不存在的操作符。</p>
<p>例如在制作”向量类型“时，可能会需要用到 dot，不过Fortran 中并没有 dot 这个操作符，但是可以使用 interface operator(.dot.) 来创造这个操作符。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a = b .dot. c <span class="comment">!新定义的操作符 dot</span></span><br></pre></td></tr></table></figure>
<p>最后再来看一个比较完整的实例程序，上一个实例程序只定义了 type(time) 类型变量的加法。下面的实例程序会定义出 type(time)+real, real +type(time), 小于的判断及两种等号 type(time)=real, real=type(time) 操作。</p>
<p>代码略。</p>
<p>这里一个加法有三种不同的函数，之所以可行是因为这三种函数的参数的类型不同。如果存在参数个数和类型均相同的两个函数，这里估计会报错。</p>
<h2 id="11-4-实际应用">11-4 实际应用</h2>
<p>这一节会实际示范继承 module 来增强功能的方法，以及比较完整的自定义类型运算。</p>
<h3 id="11-4-1-继承module">11-4-1 继承module</h3>
<h3 id="11-4-2-自定义操作符的应用">11-4-2 自定义操作符的应用</h3>
<p>Fortran 中并没有提供”分数“类型，不过在现实世界中，常常会使用这个类型。分数可以保存更为精确的数值，例如 2/3。因为2/3转换成实数后，会变成循环小数，小数的位数高达无限多个。使用浮点数来记录2/3时，因为有效位数的限制，没有办法正确保存循环小数的值。</p>
<p>下面这个程序实现了分数和分数间的加减乘除。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> rational_util</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span></span><br><span class="line">    <span class="keyword">public</span> :: rational, &amp;</span><br><span class="line">            operator(+),operator(-),operator(*),&amp;</span><br><span class="line">            operator(/),assignment(=),&amp;</span><br><span class="line">            output</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">type</span> :: rational</span><br><span class="line">        <span class="keyword">integer</span> :: num <span class="comment">! 分子</span></span><br><span class="line">        <span class="keyword">integer</span> :: denum <span class="comment">! 分母</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 加法</span></span><br><span class="line">    <span class="keyword">interface</span> operator(+)</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> rat_plus_rat</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    <span class="comment">! 减法</span></span><br><span class="line">    <span class="keyword">interface</span> operator(-)</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> rat_minus_rat</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    <span class="comment">! 乘法</span></span><br><span class="line">    <span class="keyword">interface</span> operator(*)</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> rat_times_rat</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    <span class="comment">! 除法</span></span><br><span class="line">    <span class="keyword">interface</span> operator(/)</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> rat_div_rat</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    <span class="comment">! 等号</span></span><br><span class="line">    <span class="keyword">interface</span> assignment(=)</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> int_eq_rat</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> real_eq_rat</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">!整数=分数</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> int_eq_rat(<span class="built_in">int</span>, rat)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span>, <span class="keyword">intent</span>(<span class="keyword">out</span>) :: <span class="built_in">int</span></span><br><span class="line">        <span class="keyword">type</span>(rational), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: rat</span><br><span class="line">        <span class="comment">!分子除以分母来转换成整数</span></span><br><span class="line">        <span class="built_in">int</span> = rat%num / rat%denum</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!浮点数=分数</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> real_eq_rat(<span class="built_in">float</span>, rat)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">intent</span>(<span class="keyword">out</span>) :: <span class="built_in">float</span></span><br><span class="line">        <span class="keyword">type</span>(rational), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: rat</span><br><span class="line">        <span class="comment">!分子除以分母</span></span><br><span class="line">        <span class="built_in">float</span> = <span class="keyword">real</span>(rat%num) / <span class="keyword">real</span>(rat%denum) <span class="comment">!分子分母先转化为实数类型</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!化简分数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span></span> reduse(a)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(rational), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: a</span><br><span class="line">        <span class="keyword">type</span>(rational) :: temp</span><br><span class="line">        <span class="keyword">integer</span> :: b</span><br><span class="line">        <span class="keyword">integer</span> :: <span class="built_in">sign</span></span><br><span class="line">        <span class="keyword">type</span>(rational) :: reduse</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a%num*a%denum &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">sign</span> = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">sign</span> = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        </span><br><span class="line">        temp%num = <span class="built_in">abs</span>(a%num)</span><br><span class="line">        temp%denum = <span class="built_in">abs</span>(a%denum)</span><br><span class="line">        b=gcv(temp%num, temp%denum) <span class="comment">!找出分子与分母的最大公因子</span></span><br><span class="line">        <span class="comment">!把分子，分母同时除以最大公因子</span></span><br><span class="line">        reduse%num = temp%num / b * <span class="built_in">sign</span></span><br><span class="line">        reduse%denum = temp%denum / b</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="comment">!用辗转相除法找最大公因子</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span></span> gcv(a,b)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span>, <span class="keyword">intent</span>(<span class="keyword">in</span>) :: a,b</span><br><span class="line">        <span class="keyword">integer</span> :: big,small</span><br><span class="line">        <span class="keyword">integer</span> :: temp</span><br><span class="line">        <span class="keyword">integer</span> :: gcv</span><br><span class="line">        </span><br><span class="line">        big = <span class="built_in">max</span>(a,b)</span><br><span class="line">        small = <span class="built_in">min</span>(a,b)</span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(small&gt;<span class="number">1</span>)</span><br><span class="line">            temp=<span class="built_in">mod</span>(big,small)</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">            big = small</span><br><span class="line">            small = temp</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">        gcv = small</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span> gcv</span><br><span class="line">   </span><br><span class="line">    <span class="comment">!分数相加</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span></span> rat_plus_rat(rat1,rat2)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(rational) :: rat_plus_rat</span><br><span class="line">        <span class="keyword">type</span>(rational), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: rat1, rat2</span><br><span class="line">        <span class="keyword">type</span>(rational) :: act</span><br><span class="line">        <span class="comment">! b/a+d/c=(b*c+d*a)/(a*c)</span></span><br><span class="line">        act%denum = rat1%denum * rat2%denum <span class="comment">!a*c</span></span><br><span class="line">        act%num = rat1%num*rat2%denum + rat2%num*rat1%denum <span class="comment">!(b*c+d*a)</span></span><br><span class="line">        rat_plus_rat = reduse(act) <span class="comment">!约分</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="comment">!分数相减</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span></span> rat_minus_rat(rat1,rat2)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(rational) :: rat_minus_rat</span><br><span class="line">        <span class="keyword">type</span>(rational), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: rat1, rat2</span><br><span class="line">        <span class="keyword">type</span>(rational) :: act</span><br><span class="line">        <span class="comment">! b/a-d/c=(b*c-d*a)/(a*c)</span></span><br><span class="line">        act%denum = rat1%denum * rat2%denum <span class="comment">!a*c</span></span><br><span class="line">        act%num = rat1%num*rat2%denum - rat2%num*rat1%denum <span class="comment">!(b*c-d*a)</span></span><br><span class="line">        rat_minus_rat = reduse(act) <span class="comment">!约分</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="comment">!分数相乘</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span></span> rat_times_rat(rat1,rat2)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(rational) :: rat_times_rat</span><br><span class="line">        <span class="keyword">type</span>(rational), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: rat1, rat2</span><br><span class="line">        <span class="keyword">type</span>(rational) :: act</span><br><span class="line">        <span class="comment">! b/a*d/c=(b*d)/(a*c)</span></span><br><span class="line">        act%denum = rat1%denum * rat2%denum <span class="comment">!a*c</span></span><br><span class="line">        act%num = rat1%num*rat2%num <span class="comment">!b*d</span></span><br><span class="line">        rat_times_rat = reduse(act) <span class="comment">!约分</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="comment">!分数相除</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span></span> rat_div_rat(rat1,rat2)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(rational) :: rat_div_rat</span><br><span class="line">        <span class="keyword">type</span>(rational), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: rat1, rat2</span><br><span class="line">        <span class="keyword">type</span>(rational) :: act</span><br><span class="line">        <span class="comment">! (b/a) / (d/c)=(b*c)/(a*d)</span></span><br><span class="line">        act%denum = rat1%denum * rat2%num <span class="comment">!a*d</span></span><br><span class="line">        act%num = rat1%num*rat2%denum <span class="comment">!b*c</span></span><br><span class="line">        rat_div_rat = reduse(act) <span class="comment">!约分</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="comment">!输出</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> output(a)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(rational), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: a</span><br><span class="line">        <span class="keyword">if</span>(a%denum /= <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(1x,&#x27;(&#x27;,i3,&#x27;/&#x27;,i3,&#x27;)&#x27;)&quot;</span>) a%num, a%denum</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(1x,i3)&quot;</span>) a%num</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!主程序</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1110</span><br><span class="line">    <span class="keyword">use</span> rational_util</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(rational) :: a,b,c</span><br><span class="line">    <span class="keyword">real</span> :: f</span><br><span class="line">    </span><br><span class="line">    a=rational(<span class="number">1.0</span>,<span class="number">3.0</span>)</span><br><span class="line">    b=rational(<span class="number">2.0</span>,<span class="number">3.0</span>)</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a4)&quot;</span>,<span class="keyword">advance</span>=<span class="string">&quot;no&quot;</span>) <span class="string">&#x27;a=&#x27;</span></span><br><span class="line">    <span class="keyword">call</span> output(a)</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a4)&quot;</span>,<span class="keyword">advance</span>=<span class="string">&quot;no&quot;</span>) <span class="string">&#x27;b=&#x27;</span></span><br><span class="line">    <span class="keyword">call</span> output(b)</span><br><span class="line">    c=a+b</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a4)&quot;</span>,<span class="keyword">advance</span>=<span class="string">&quot;no&quot;</span>) <span class="string">&#x27;a+b=&#x27;</span></span><br><span class="line">    <span class="keyword">call</span> output(c)</span><br><span class="line">    c=a-b</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a4)&quot;</span>,<span class="keyword">advance</span>=<span class="string">&quot;no&quot;</span>) <span class="string">&#x27;a-b=&#x27;</span></span><br><span class="line">    <span class="keyword">call</span> output(c)</span><br><span class="line">    c=a*b</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a4)&quot;</span>,<span class="keyword">advance</span>=<span class="string">&quot;no&quot;</span>) <span class="string">&#x27;a*b=&#x27;</span></span><br><span class="line">    <span class="keyword">call</span> output(c)</span><br><span class="line">    c=a/b</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a4)&quot;</span>,<span class="keyword">advance</span>=<span class="string">&quot;no&quot;</span>) <span class="string">&#x27;a/b=&#x27;</span></span><br><span class="line">    <span class="keyword">call</span> output(c)</span><br><span class="line">    f=c</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(f6.2)&quot;</span>) f</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  a&#x3D; (  1&#x2F;  3)</span><br><span class="line">  b&#x3D; (  2&#x2F;  3)</span><br><span class="line">a+b&#x3D;   1</span><br><span class="line">a-b&#x3D; ( -1&#x2F;  3)</span><br><span class="line">a*b&#x3D; (  2&#x2F;  9)</span><br><span class="line">a&#x2F;b&#x3D; (  1&#x2F;  2)</span><br><span class="line"> 0.50</span><br></pre></td></tr></table></figure>
<p>这个程序虽然长，但是不难。就是有一点有意思，就是他这里提到的”辗转相除法“ 求余数有点意思，之前没学过。</p>
<p>他这个原理很简单，就是两个数求最大公约数，通过两个数求余不断缩小这两个数，直至一个数为0，此时另一个数就是最大公约数。这样做效率很高。</p>
<p>我自己也简单地证明了一下，假设这两个数是 m n（m比n大），这两个数的最大公约数是k</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">m = ak</span><br><span class="line">n = bk</span><br><span class="line">m % n = ak % bk #求余，这里余数设为p</span><br><span class="line">p = m % n = ak - x*bk (x为整除数) = (a-xb)k</span><br><span class="line">#证明余数 p 仍可以整除k</span><br></pre></td></tr></table></figure>
<p>体现在fortran 中的代码为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!用辗转相除法找最大公因子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span></span> gcv(a,b)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">intent</span>(<span class="keyword">in</span>) :: a,b</span><br><span class="line">    <span class="keyword">integer</span> :: big,small</span><br><span class="line">    <span class="keyword">integer</span> :: temp</span><br><span class="line">    <span class="keyword">integer</span> :: gcv</span><br><span class="line">    </span><br><span class="line">    big = <span class="built_in">max</span>(a,b)</span><br><span class="line">    small = <span class="built_in">min</span>(a,b)</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(small&gt;<span class="number">1</span>)</span><br><span class="line">        temp=<span class="built_in">mod</span>(big,small)</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        big = small <span class="comment">!此时较大的数改为原来较小的数</span></span><br><span class="line">        small = temp <span class="comment">!此时较小的数改为余数</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    gcv = small</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span> gcv</span><br></pre></td></tr></table></figure>
<p>关于 Fortran 语法的介绍，到这一章算是完全结束。下一章会开始进入 Fortran 应用的部分，都是各自独立的不同应用，可以跳着看。</p>
<h2 id="12-编译器的高级使用">12 编译器的高级使用</h2>
<p>这一章要再次说明编译器的使用。第2章示例过编译程序的方法，整套编译器所提供的功能不只是单纯的编译程序而已，善用编译器所提供的工具，对于开发程序有很大帮助。</p>
<p>除了介绍编译器的使用，这一章还会示例 Fortran 与其他语言的互相链接。还有很重要的一个课题： 如何对程序进行优化。</p>
<h2 id="12-1-编译器的完整功能">12-1 编译器的完整功能</h2>
<p>一般来说，编译器所提供的工具，大概有以下这几大类：</p>
<blockquote>
<ol>
<li>
<p>编译器 (Compiler)</p>
<p>用来把程序代码转换成目的文件（.obj）或执行文件（.exe）的工具，是编译工具的主角。Compiler 在编译时有很多选项可以设置，要如何使用这些设置也是一门学科。不同的设置会编译出不同的机器码。</p>
<p>最常见的选项格式有两种，Release 格式和 Debug 格式。Release 格式所编译出来的执行文件执行效率比较好，Debug 格式所编译出来的文件执行效率比较差，不过可以配合Debug 工具来进行调试。</p>
</li>
<li>
<p>链接器（Link）</p>
<p>用来把 Compiler 所生成的目的文件（.obj）链接成最后的可执行文件（.exe），或是链接库（.lib, .dll）。有的编译器执行后会自动调用Link来生成执行文件，所以很多用户不会发现Link的存在。经过目的文件来生成执行文件有几项好处：</p>
<ol>
<li>可以把大程序拆解成许多小文件来编写。</li>
<li>可以把不同语言程序代码所生成的OBJ文件链接成一个执行文件。</li>
</ol>
</li>
<li>
<p>链接库（Library）</p>
<p>编写 Fortran 程序所使用的库存函数，都是事先写好放在.lib 的链接库中。通常各家编译器会自行额外提供扩充函数，像Visual Fortran 专业版中已经提供 IMSL。</p>
</li>
<li>
<p>说明文件（Help)</p>
</li>
<li>
<p>调试工具（Debug）</p>
<p>调试工具是很重要的一项功能，它的重要性仅次于 Compiler。好的调试工具可以让程序员快速找到程序代码的错误。调试格式下，可以对程序代码设置断点，程序执行到断点会暂停执行。这个时候程序员可以查看变量内容，看看它们是否和预期相同。还可以一行一行来执行程序，检查程序执行流程是否正确。</p>
</li>
<li>
<p>分析工具（Profile）</p>
<p>用于分析程序代码中各个函数所花费的执行时间，可以用来找出程序代码中执行效率最差的部分，程序员可以针对这部分程序代码来作修正。</p>
</li>
</ol>
</blockquote>
<p>这一章以 MS Developer Studio 的使用环境做模板。</p>
<h2 id="12-4-优化">12-4 优化</h2>
<p>在信息界广泛流传这样的一句话：”有90%的程序执行时间是花在10%的程序代码里“。换句话说，假如程序代码总共有1000行的话，可能有900行的程序只花了0.1秒就执行完，但是却有100行程序会花掉0.9秒来执行。</p>
<h3 id="12-4-2-程序代码优化">12-4-2 程序代码优化</h3>
<p>要如何写程序来解决问题，一向没有标准答案。解决同样的问题，可以编写出好几种不同的程序。程序的好坏通常取决于两个方面：</p>
<ol>
<li>执行速度</li>
<li>内存使用量。</li>
</ol>
<p>这个小节会强调执行速度的问题，介绍如何让程序代码拥有更好的执行效率，也就是所谓的程序优化。程序代码优化处理，大致上有下面几个方向。</p>
<ol>
<li>
<p>使用好的算法。</p>
<p>算法是指用来解决某个问题的特定程序方法。以数据排序为例子，前面已经介绍过选择排序法（Selection Sort），一般来说它并不算是个好方法，在排序问题中有一个称为快速排序（Quick sort）的算法，在一般情况下执行效率最高。</p>
<p>再以计算等差数列的和来说，要计算 1+2+3+……+n 的值，用循环累加跟使用梯型公式比较起来，当然是用梯形公式比较快。</p>
</li>
<li>
<p>避免重复的计算</p>
<p>做计算的时候经常会重复使用某一个计算结果。这个时候就应该把这个计算结果事先保存起来，再让其他算式使用。例如要计算 ax^2 + bx + c =0 的解，如果直接根据公式计算，写成代码是</p>
 <figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">x1=(-b+<span class="built_in">sqrt</span>(b*b-<span class="number">4</span>*a*c))/(<span class="number">2.0</span>*a)</span><br><span class="line">x1=(-b-<span class="built_in">sqrt</span>(b*b-<span class="number">4</span>*a*c))/(<span class="number">2.0</span>*a)</span><br></pre></td></tr></table></figure>
<p>用这个写法， <code>sqrt(b*b-4*a*c)</code> 和 <code>2.0*a</code> 会重复计算两次。比较好的方法应该是先把这两个值算出来，再计算 x1, x2 的值。</p>
<blockquote>
<p>ok，我现在知道为什么要这么做了，这也太严谨了。</p>
</blockquote>
<p>在循环中很容易会不自觉地出现重复计算，循环里地计算式，如果没有必要写在循环里，就应该把它移到循环外面。</p>
 <figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">10</span></span><br><span class="line">	a(i) = <span class="keyword">real</span>(i)/(b+c)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>上面的循环中，b+c 的值没有必要在循环里计算，因为不管 i 是多少，b + c 的值都不会改变，没有必要在循环中算10次，应该把它移到循环外面来做。（严谨！但是似乎有一点点影响可读性）</p>
 <figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">d = b+c <span class="comment">! 把b+c的结果记录在变量d中</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">10</span></span><br><span class="line">	a(i) = <span class="keyword">real</span>(i)/d</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>表达式的选择</p>
<p>数学算式中，使用不同的式子可以得到同样的结果，下面是几个例子。</p>
 <figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>*A = A+A</span><br><span class="line">A**<span class="number">2</span> = A*A</span><br><span class="line">X**<span class="number">2</span>+<span class="number">2</span>*X+<span class="number">3</span> = ((X=<span class="number">2</span>)*X)+<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>这3个例子中，等号右边的写法都会比等号左边的写法来得迅速。计算机运算时，做加减法会比做乘除法快，乘法又会比乘幂快。所以计算2A时，用 A+A 会比用 2*A 来得快；同理计算 A*A 会比 计算 A**2 来得快。至于第3个式子，左边的方法会使用1个乘幂，1个乘法，2个加法；右边的方法则会使用1个乘法跟2个加法，很明显的是右边的方法会比较快。</p>
<blockquote>
<p>这有一点吹毛求疵，而且影响了可读性了。我最多接受将乘幂写成乘法，即 A**2 改成 A*A</p>
</blockquote>
</li>
<li>
<p>整数与浮点数的选择</p>
<p>计算机的整数运算比浮点数运算快，能够使用整数时，就应该尽量多使用整数。</p>
<p>在混合使用整数和浮点数的算式中，应该要尽量把整数集合在一起。</p>
<p><strong>使用浮点数时，双精度和单精度的计算速度相同，差别在于内存使用量</strong>。</p>
<p>（为什么？百度百科说CPU处理单精度更快，<a href="https://baike.baidu.com/item/%E5%8F%8C%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0%EF%BC%89">https://baike.baidu.com/item/双精度浮点数）</a></p>
</li>
<li>
<p>访问速度</p>
<p>不同的变量类型，在使用时会有不同的访问速度。例如声明成 parameter 的常量，使用时会比一般变量快。因为使用常量不用再到内存中取出数据，数字可以直接写在程序代码中。使用常量来做计算时，在编译过程中就会计算完毕，不需要在执行过程中计算。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;b&#x2F;2.0</span><br><span class="line">a&#x3D;b&#x2F;c</span><br></pre></td></tr></table></figure>
<p>使用数组的访问速度比变量慢，而且越高维的数组访问速度越慢。因为使用数组时，要先计算出坐标在数组中的内存位置，越高维的数组需要计算的式子会越长。</p>
 <figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">b=a(i)+a(j)</span><br><span class="line">b=e+f <span class="comment">! 假设 e=a(i), f=a(j)</span></span><br></pre></td></tr></table></figure>
<p>使用指针也会比使用变量慢上一点点，因为使用指针要经过两个步骤，先取出指针所保存的内存地址，再去使用这个内存。直接使用变量时不需要第1个操作，使用变量时马上就可以知道它使用哪一块内存。</p>
</li>
<li>
<p>利用 cache</p>
<p>程序执行时，如果能尽量避免跳转式使用内存，会得到比较好的执行效率。使用数组时最需要注意这一点。</p>
 <figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,n1</span><br><span class="line">	<span class="keyword">do</span> j =<span class="number">1</span>,n2</span><br><span class="line">		<span class="keyword">do</span> k=<span class="number">1</span>,n3</span><br><span class="line">			<span class="comment">! s=s+a(i,j,k) !不好的写法</span></span><br><span class="line">			s=s+a(k,j,i) <span class="comment">!比较好的写法</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>上面这两种写法，第2种写法会比较好，因为它会依照内存的排列顺序来使用数组；第1种方法则会跳转式地在内存中访问。</p>
<p>关于计算机的存储知识见：<a href="https://zhuanlan.zhihu.com/p/71956210">https://zhuanlan.zhihu.com/p/71956210</a></p>
<blockquote>
<p><strong>计算机的存储系统可以看成一个金字塔形结构（也称为 memory hierarchy）</strong>，越是上层的存储设备容量越小、速度越快、价格也越贵，而越是下层的存储设备容量越大、速度越慢、价格也越便宜。</p>
<p>寄存器（Regs）- 一级缓存（L1 cache）- 二级缓存 - 三级缓存 - 内存（Main memory）- 本地磁盘（Local disks）- 网络存储（Network storage）</p>
</blockquote>
<p>下面这段话解释了计算机时如何查找和访问数据的。</p>
<blockquote>
<p>通常来讲，越是上层的存储设备 block size 越小（例如几个字节），而越到下层 block size 越大（例如整个文件）。当我们要读取某个数据的时候，我们沿着金字塔从上往下看。由于越是上层的存储设备访问速度越快，如果该数据在上一层已经被缓存了（称作 cache hit），那么皆大欢喜，我们可以直接读出数据。如果该数据在上一层没有被缓存（称作 cache miss），那么我们只能从下一层取出包含该数据的 block 放到上一层。</p>
<p>**要是上一层的缓存已经全部装满了怎么办？**那我们只能替换掉一个别的 block 了。替换的策略有很多种，最简单的方法当然可以随机选一个倒霉的 block 扔掉，不过这不一定是最好的办法。</p>
<p>由于时间局部性告诉我们，越是最近访问过的数据越应该被缓存，因此另一个常用的策略 LRU (least recently used) 干的事情就是把最久没有访问过的 block 扔掉。</p>
</blockquote>
<p>简单地说，就是按照计算机存储系统从上往下一级一级地查找，找到了就把包含该数据的 block 放到上一层。（注意，这里的一个 block 指的是一段连续的数据，也就是除了要找的数据外它附近的数据也调到上层了，比如你只是查找数组中的某一个元素，那么可能整个数组都会被放到上一层，这样如果你之后查找数组中的其他元素，速度也很快）</p>
<p>如果上一层的缓存已经全部装满，那就将最久没有访问过的 block 扔掉。（因此相关的数据，代码最好放在一块，不要东一块西一块的）</p>
</li>
<li>
<p>减少程序代码的跳转、转向</p>
<p>使用流程控制命令 if, select case, 及 do 循环、调用函数时，都会导致程序执行做出跳转和转向的操作。执行程序和开车一样，在笔直的路上开车是最快的，遇到转弯甚至回转时就需要减速。执行程序时也是相同的，照顺序直线执行的程序会比较快。</p>
 <figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!比较好的写法</span></span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">20</span>) <span class="keyword">then</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a &gt; <span class="number">10</span>)</span><br><span class="line">……</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!比较不好的写法</span></span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">20</span>) <span class="keyword">then</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">10</span> .and. a&lt;=<span class="number">20</span>) <span class="keyword">then</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">if</span>(a&lt;=<span class="number">10</span>) <span class="keyword">then</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br></pre></td></tr></table></figure>
<p>上面这两种代码效果相同，不过第1种写法比较好，第2种写法固定要做3次if 判断。第1种写法则不一定会做几次if判断，不过最多只会做2次。</p>
 <figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">	read(<span class="number">10</span>, *) a(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>, n</span><br><span class="line">	s = s*a(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,n <span class="comment">!把上面两个循环合并起来</span></span><br><span class="line">	read(<span class="number">10</span>, *) a(i)</span><br><span class="line">	s = s*a(i) </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>上面这两个循环第2种写法比较好，因为这两个循环本来就可以合并，减少一次循环次数。</p>
</li>
</ol>
<p>上面介绍了几个程序优化的策略，<strong>使用这些策略不需要矫枉过正</strong>。</p>
<p>编写程序时，不需要把每个部分都做优化处理。如果某个函数只会调用一次，那就可以不太注意它的执行效率。前面已经提到，通常最花时间的程序代码大概都只会集中在少部分程序中。一般来说，只要把循环中的程序代码，跟经常会调用使用的函数做优化处理，整个程序就可以有不错的执行效率。</p>
<blockquote>
<p>我一直在想，这些优化策略对代码<strong>可读性</strong>的影响。然后我又看了一下 Fortran 代码，Fortran 代码<strong>有个毛线的可读性</strong>，他们正常写的代码都没什么可读性可言。</p>
</blockquote>
<h1>14 数值方法</h1>
<p>数值计算是 Fortran 语言最主要的应用领域，现在就来进入这个课题。本书把数值方法分成两个章节来介绍，这一章会示例如何自行编写程序来求解最基本的几个数值方法问题，第16章会示例如何使用 IMSL 链接库来做数值计算。</p>
<h2 id="14-1-求解非线性函数">14-1 求解非线性函数</h2>
<p>这一节是要示例如何计算函数 f(x) =0 的解。</p>
<h3 id="14-1-1-二分法-Bisection">14-1-1 二分法 Bisection</h3>
<p>二分法是最简单的解法，这个算法只有很简单的几个步骤。</p>
<ol>
<li>先猜两个值a,b，是的 f(a)*f(b) 小于0。</li>
<li>令 c=(a+b)/2 ，如果 f© = 0 ，就找到了一个正解，工作完成。</li>
<li>f© 不为0时，如果f(a), f© 异号，则以a,c 为新的起点。f(b) f© 同理。</li>
</ol>
<p>程序实现如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">! 二分法求解</span></span><br><span class="line"><span class="comment">! by pon 1997/9/2</span></span><br><span class="line"><span class="keyword">module</span> Numerical</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>, <span class="keyword">parameter</span> :: zero = <span class="number">0.00001</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> bisect(a,b)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> a,b <span class="comment">! 输入的猜值</span></span><br><span class="line">        <span class="keyword">real</span> c   <span class="comment">! 用来计算 (a+b)/2</span></span><br><span class="line">        <span class="keyword">real</span> fa  <span class="comment">! 记录f(a)</span></span><br><span class="line">        <span class="keyword">real</span> fb  <span class="comment">! 记录f(b)</span></span><br><span class="line">        <span class="keyword">real</span> fc  <span class="comment">! 记录f(c)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">!先求c,f(c)的值</span></span><br><span class="line">        c = (a+b)/<span class="number">2.0</span></span><br><span class="line">        fc = func(c)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">!abs(f(c)) 小于 zero 时，就视 f(c) = 0，结束循环</span></span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(<span class="built_in">abs</span>(fc)&gt;zero)</span><br><span class="line">            fa = func(a)</span><br><span class="line">            fb = func(b)</span><br><span class="line">            <span class="keyword">if</span> (fa*fc &lt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">                <span class="comment">!以 a,c 值为新的区间</span></span><br><span class="line">                b=c</span><br><span class="line">                c=(a+b)/<span class="number">2.0</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">!不然就是以 b,c 值为新的区间</span></span><br><span class="line">                a=c</span><br><span class="line">                c=(a+b)/<span class="number">2.0</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">            <span class="comment">!求出新的 fc 值</span></span><br><span class="line">            fc = func(c)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        bisect = c</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">!求解用的函数</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> func(x)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> x</span><br><span class="line">        func = (x+<span class="number">3</span>)*(x-<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> numerical</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> a,b <span class="comment">!两个猜值</span></span><br><span class="line">    <span class="keyword">real</span> ans <span class="comment">!算出的值</span></span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;输入两个猜测值&quot;</span></span><br><span class="line">        read(*,*) a,b</span><br><span class="line">        <span class="comment">!f(a)*f(b) &lt; 0 才是有效的猜测值</span></span><br><span class="line">        <span class="keyword">if</span>(func(a)*func(b) &lt; <span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;不正确的猜值&quot;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment">!调用二分法求根的函数</span></span><br><span class="line">    ans = bisect(a,b)</span><br><span class="line">    <span class="comment">!显示结果</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;x=&#x27;,f6.3)&quot;</span>) ans</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 输入两个猜测值</span><br><span class="line">2 100</span><br><span class="line">x&#x3D; 3.000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的实例程序有一个最大的缺点，那就是想要求解的函数已经被固定，即 f(x) = (x+3)*(x-3)。如果程序代码中还要计算其他函数时，最好使用下面的方法：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">! 二分法求解</span></span><br><span class="line"><span class="comment">! by pon 1997/9/2</span></span><br><span class="line"><span class="keyword">module</span> Numerical</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>, <span class="keyword">parameter</span> :: zero = <span class="number">0.00001</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> bisect(a,b,func)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> a,b <span class="comment">! 输入的猜值</span></span><br><span class="line">        <span class="keyword">real</span> c   <span class="comment">! 用来计算 (a+b)/2</span></span><br><span class="line">        <span class="keyword">real</span> fa  <span class="comment">! 记录f(a)</span></span><br><span class="line">        <span class="keyword">real</span> fb  <span class="comment">! 记录f(b)</span></span><br><span class="line">        <span class="keyword">real</span> fc  <span class="comment">! 记录f(c)</span></span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">external</span> :: func <span class="comment">! 所要求解的函数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">!先求c,f(c)的值</span></span><br><span class="line">        c = (a+b)/<span class="number">2.0</span></span><br><span class="line">        fc = func(c)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">!abs(f(c)) 小于 zero 时，就视 f(c) = 0，结束循环</span></span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(<span class="built_in">abs</span>(fc)&gt;zero)</span><br><span class="line">            fa = func(a)</span><br><span class="line">            fb = func(b)</span><br><span class="line">            <span class="keyword">if</span> (fa*fc &lt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">                <span class="comment">!以 a,c 值为新的区间</span></span><br><span class="line">                b=c</span><br><span class="line">                c=(a+b)/<span class="number">2.0</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">!不然就是以 b,c 值为新的区间</span></span><br><span class="line">                a=c</span><br><span class="line">                c=(a+b)/<span class="number">2.0</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">            <span class="comment">!求出新的 fc 值</span></span><br><span class="line">            fc = func(c)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        bisect = c</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">!求解用的函数1</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> f1(x)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> x</span><br><span class="line">        f1 = (x+<span class="number">3</span>)*(x-<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="comment">!求解用的函数2</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> f2(x)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> x</span><br><span class="line">        f2 = (x+<span class="number">4</span>)*(x-<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> numerical</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> a,b <span class="comment">!两个猜值</span></span><br><span class="line">    <span class="keyword">real</span> ans <span class="comment">!算出的值</span></span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;输入两个猜测值&quot;</span></span><br><span class="line">        read(*,*) a,b</span><br><span class="line">        <span class="comment">!f(a)*f(b) &lt; 0 才是有效的猜测值</span></span><br><span class="line">        <span class="keyword">if</span>(f1(a)*f1(b) &lt; <span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;不正确的猜值&quot;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment">!调用二分法求根的函数</span></span><br><span class="line">    ans = bisect(a,b,f1)</span><br><span class="line">    <span class="comment">!显示结果</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;x=&#x27;,f6.3)&quot;</span>) ans</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;输入两个猜测值&quot;</span></span><br><span class="line">        read(*,*) a,b</span><br><span class="line">        <span class="comment">!f(a)*f(b) &lt; 0 才是有效的猜测值</span></span><br><span class="line">        <span class="keyword">if</span>(f2(a)*f2(b) &lt; <span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;不正确的猜值&quot;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment">!调用二分法求根的函数</span></span><br><span class="line">    ans = bisect(a,b,f2)</span><br><span class="line">    <span class="comment">!显示结果</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;x=&#x27;,f6.3)&quot;</span>) ans</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 输入两个猜测值</span><br><span class="line">2 100</span><br><span class="line">x&#x3D; 3.000</span><br><span class="line"> 输入两个猜测值</span><br><span class="line">2 100</span><br><span class="line">x&#x3D; 5.000</span><br></pre></td></tr></table></figure>
<p>这个程序的做法，是把函数当作参数传到 bisect 函数中，函数 bisect 可以用来求解任何输入的函数。 ans = bisect(a,b,f1) 时会求解 f1 函数， ans = bisect(a,b,f2) 时则会求解 f2 函数。</p>
<h3 id="14-1-2-割线法-Secant">14-1-2 割线法 Secant</h3>
<p>现在介绍如何使用割线法，这个方法很适合使用图形来解释，它主要是利用线段来逼近结果，过程如下</p>
<ol>
<li>先选出两个猜测值 a,b</li>
<li>画一条通过 (a, f(a)) (b, f(b)) 这两点的直线，令这条指向与x轴的交点为 c 。检查f© 是否等于0</li>
<li>f© 不为0时，令 b,c 值为新的两个猜值值，回到上一步骤继续。</li>
</ol>
<p>所得到新的猜想 b, c 会比原本的 a, b 更接近答案，一步一步做下去就可以得到 f© = 0 的结果。</p>
<p>程序实现如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> NUMERICAL</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>, <span class="keyword">parameter</span> :: zero = <span class="number">0.00001</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> secant(a,b,f)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: a,b <span class="comment">!起始的两个猜值</span></span><br><span class="line">        <span class="keyword">real</span> :: c   <span class="comment">!新的解</span></span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">external</span> :: f <span class="comment">!输入的求解函数</span></span><br><span class="line">        <span class="keyword">real</span> :: fa,fb,fc <span class="comment">!记录函数结果</span></span><br><span class="line">        </span><br><span class="line">        fa=f(a)</span><br><span class="line">        fb=f(b)</span><br><span class="line">        c = a-fa*(b-a)/(fb-fa)</span><br><span class="line">        fc=f(c)</span><br><span class="line">        <span class="comment">!在趋近于0之前要一直做逼近的工作</span></span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(<span class="built_in">abs</span>(fc) &gt; zero)</span><br><span class="line">            a = b</span><br><span class="line">            b = c</span><br><span class="line">            fa=f(a)</span><br><span class="line">            fb=f(b)</span><br><span class="line">            c = a-fa*(b-a)/(fb-fa)</span><br><span class="line">            fc=f(c)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        secant = c</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> func(x)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: x</span><br><span class="line">        func = <span class="built_in">sin</span>(x)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> NUMERICAL</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> :: a,b <span class="comment">!起始猜值</span></span><br><span class="line">    <span class="keyword">real</span> :: ans</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;输入两个猜值&quot;</span></span><br><span class="line">    read(*,*) a,b</span><br><span class="line">    <span class="comment">! 输入起始猜值及求值的函数</span></span><br><span class="line">    ans = secant(a,b,func)</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;x=&#x27;,f8.4)&quot;</span>) ans</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>请注意，<strong>割线法并不一定保证会找到解</strong>。也有可能 c 值会越来越偏理答案。</p>
<p>比如，实例程序的执行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 输入两个猜值</span><br><span class="line">50 100</span><br><span class="line">x&#x3D;     NaN</span><br></pre></td></tr></table></figure>
<h3 id="14-1-3-牛顿法">14-1-3 牛顿法</h3>
<p>牛顿法也是利用线段来逼近结果，计算过程如下：</p>
<ol>
<li>先做一个猜想 a</li>
<li>以 f’(a) 为斜率，经过 (a, f(a)) 作一条直线，令这条直线与x轴的交点为b。检查 f(b) 是否为0。</li>
<li>f(b) 不为0时，重新令 b 为新的猜值，重复。</li>
</ol>
<p><strong>若初始猜值 a 取的好，f(b) 应该会越来越接近0</strong>。</p>
<p>程序如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> NUMERICAL </span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>, <span class="keyword">parameter</span> :: zero = <span class="number">0.00001</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> newton(a,f,df)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: a <span class="comment">!猜值</span></span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">external</span> :: f <span class="comment">!求值函数</span></span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">external</span> :: df <span class="comment">! f&#x27;(x)的函数</span></span><br><span class="line">        <span class="keyword">real</span> :: b <span class="comment">!解</span></span><br><span class="line">        <span class="keyword">real</span> :: fb</span><br><span class="line">        </span><br><span class="line">        b = a-f(a)/df(a)</span><br><span class="line">        fb = f(b)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(<span class="built_in">abs</span>(fb) &gt; zero)</span><br><span class="line">            a = b</span><br><span class="line">            b = a-f(a)/df(a)</span><br><span class="line">            fb = f(b)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        newton = b</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="comment">!求值的函数</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> func(x)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: x</span><br><span class="line">        func = <span class="built_in">sin</span>(x)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">!f&#x27;(x)</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> dfunc(x)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: x</span><br><span class="line">        dfunc = <span class="built_in">cos</span>(x)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> numerical</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> :: a <span class="comment">!猜值</span></span><br><span class="line">    <span class="keyword">real</span> :: ans <span class="comment">!解</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;输入起始猜值&quot;</span></span><br><span class="line">    read(*,*) a</span><br><span class="line">    ans = newton(a,func,dfunc)</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;x=&#x27;,f8.4)&quot;</span>) ans</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> 输入起始猜值</span><br><span class="line"><span class="number">1</span></span><br><span class="line">x=  <span class="number">0.0000</span></span><br></pre></td></tr></table></figure>
<p>使用牛顿法时，如果猜值给的不好，会永远无法逼近结果。实际使用时，应该要检查 f(b) 是否向0逼近。</p>
<h2 id="14-2-线性代数">14-2 线性代数</h2>
<p>学习线性代数的数值方法，就是在学习矩阵的应用。二维数组经常被当成矩阵来使用。</p>
<h3 id="14-2-1-矩阵的加、减、乘法">14-2-1 矩阵的加、减、乘法</h3>
<p>矩阵的加减法其实不需要介绍，因为它只是很单纯地把矩阵中相同坐标位置地数字相加、减而已。Fortran 90 可以直接对整个数组来做计算，所以可以用一个命令就完成矩阵的加减法。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">real</span> a(m,n), b(m,n), c(m,n)</span><br><span class="line">c = a + b <span class="comment">! 矩阵加法完成</span></span><br><span class="line">c = a - b <span class="comment">! 矩阵减法完成</span></span><br></pre></td></tr></table></figure>
<h3 id="14-2-2-三角矩阵">14-2-2 三角矩阵</h3>
<p>这一节和大家介绍如何经过矩阵中的两行数字相减，把矩阵换算成上三角矩阵和下三角矩阵。</p>
<p>使用程序来解决这个问题的方法，和用手计算的过程是一样的，同样是把某一行乘上一个系数之后和另外一行相减。做上三角矩阵时，就先把第1行的第1列以下的元素数值都清为0。再把第2行第2列以下的数值都清为0，…… 如此一直做到 N-1 行为止。</p>
<p>下面是实例程序：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> LinearAlgebra</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">!输出矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> output(matrix)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: m,n</span><br><span class="line">        <span class="keyword">real</span> :: matrix(:,:)</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        <span class="keyword">character</span>(len=<span class="number">20</span>) :: for=<span class="string">&#x27;(??(1x,f6.3))&#x27;</span></span><br><span class="line">        m = <span class="built_in">size</span>(matrix,<span class="number">1</span>)</span><br><span class="line">        n = <span class="built_in">size</span>(matrix,<span class="number">2</span>)</span><br><span class="line">        <span class="comment">!用字符串来设置输出格式</span></span><br><span class="line">        <span class="built_in">write</span>(for(<span class="number">2</span>:<span class="number">3</span>), <span class="string">&#x27;(i2)&#x27;</span>) N</span><br><span class="line">        <span class="keyword">do</span> i = <span class="number">1</span>,n</span><br><span class="line">            <span class="built_in">write</span>(*, <span class="keyword">fmt</span>=for) matrix(i,:)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!求上三角矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Upper(matrix)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: matrix(:,:)</span><br><span class="line">        <span class="keyword">integer</span> :: m,n</span><br><span class="line">        <span class="keyword">integer</span> :: i,j</span><br><span class="line">        <span class="keyword">real</span> :: e</span><br><span class="line">        m = <span class="built_in">size</span>(matrix,<span class="number">1</span>)</span><br><span class="line">        n = <span class="built_in">size</span>(matrix,<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">do</span> j=i+<span class="number">1</span>, m</span><br><span class="line">                e = matrix(j,i)/matrix(i,i)</span><br><span class="line">                <span class="comment">!用90的功能可以少一层xunhuan</span></span><br><span class="line">                matrix(j,i:m) = matrix(j,i:m)-matrix(i,i:m)*e</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!求下三角矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Lower(matrix)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: matrix(:,:)</span><br><span class="line">        <span class="keyword">integer</span> :: m,n</span><br><span class="line">        <span class="keyword">integer</span> :: i,j</span><br><span class="line">        <span class="keyword">real</span> :: e</span><br><span class="line">        m = <span class="built_in">size</span>(matrix,<span class="number">1</span>)</span><br><span class="line">        n = <span class="built_in">size</span>(matrix,<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">do</span> i=n,<span class="number">2</span>,-<span class="number">1</span></span><br><span class="line">            <span class="keyword">do</span> j=i-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span></span><br><span class="line">                e = matrix(j,i)/matrix(i,i)</span><br><span class="line">                <span class="comment">!用90的功能可以少一层xunhuan</span></span><br><span class="line">                matrix(j,<span class="number">1</span>:i) = matrix(j,<span class="number">1</span>:i)-matrix(i,<span class="number">1</span>:i)*e</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> LinearAlgebra</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n = <span class="number">3</span> <span class="comment">!矩阵大小</span></span><br><span class="line">    <span class="keyword">real</span> :: A(n,n) = <span class="built_in">reshape</span>((/<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>/),(/n,n/))</span><br><span class="line">    <span class="keyword">real</span> :: B(n,n)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Matrix A:&quot;</span></span><br><span class="line">    <span class="keyword">call</span> output(A)</span><br><span class="line">    B=A</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Upper:&quot;</span></span><br><span class="line">    <span class="keyword">call</span> Upper(B)</span><br><span class="line">    <span class="keyword">call</span> output(B)</span><br><span class="line">    B=A</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Lower:&quot;</span></span><br><span class="line">    <span class="keyword">call</span> Lower(B)</span><br><span class="line">    <span class="keyword">call</span> output(B)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Matrix A:</span><br><span class="line"> 1.000  3.000  2.000</span><br><span class="line"> 2.000  2.000  3.000</span><br><span class="line"> 1.000  3.000  4.000</span><br><span class="line">Upper:</span><br><span class="line"> 1.000  3.000  2.000</span><br><span class="line"> 0.000 -4.000 -1.000</span><br><span class="line"> 0.000  0.000  2.000</span><br><span class="line">Lower:</span><br><span class="line"> 8.000  0.000  0.000</span><br><span class="line"> 1.250 -0.250  0.000</span><br><span class="line"> 1.000  3.000  4.000</span><br></pre></td></tr></table></figure>
<p>为什么要先学习做上、下三角矩阵的办法呢？因为这个方法可以应用在很多地方，例如应用在用 Determinant, Gauss-Jordan 法求解联立式、求逆矩阵等等。</p>
<p>在这个程序中，传递数组时用了特殊方法。以函数 output 为例，声明数组时没有赋值大小。使用这个方法传递数组时，可以免去传递数组大小。库存函数 size 可以查询出数组的实际大小。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">real</span> :: matrix(:,:)</span><br></pre></td></tr></table></figure>
<h3 id="14-2-3-Determinant-矩阵的值">14-2-3 Determinant 矩阵的值</h3>
<p>求矩阵行列式值的方法很简单，把矩阵用上一个小节中的方法转换成上三角形或下三角矩阵后，把对角线的数值全部乘起来就是答案了。</p>
<p>下面是程序。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> LinearAlgebra</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">!求矩阵的Determinant值</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Determinant(matrix)</span><br><span class="line">        <span class="keyword">real</span> :: matrix(:,:)</span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">allocatable</span> :: ma(:,:)</span><br><span class="line">        <span class="keyword">integer</span> :: i,n</span><br><span class="line">        n = <span class="built_in">size</span>(matrix,<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">allocate</span>(ma(n,n))</span><br><span class="line">        ma = matrix</span><br><span class="line">        <span class="keyword">call</span> Upper(ma)</span><br><span class="line">        Determinant = <span class="number">1.0</span></span><br><span class="line">        <span class="keyword">do</span> i = <span class="number">1</span>,n</span><br><span class="line">            Determinant = Determinant * ma(i,i)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="comment">!求上三角矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Upper(matrix)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: matrix(:,:)</span><br><span class="line">        <span class="keyword">integer</span> :: m,n</span><br><span class="line">        <span class="keyword">integer</span> :: i,j</span><br><span class="line">        <span class="keyword">real</span> :: e</span><br><span class="line">        m = <span class="built_in">size</span>(matrix,<span class="number">1</span>)</span><br><span class="line">        n = <span class="built_in">size</span>(matrix,<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">do</span> j=i+<span class="number">1</span>, m</span><br><span class="line">                e = matrix(j,i)/matrix(i,i)</span><br><span class="line">                <span class="comment">!用90的功能可以少一层xunhuan</span></span><br><span class="line">                matrix(j,i:m) = matrix(j,i:m)-matrix(i,i:m)*e</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> LinearAlgebra</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n=<span class="number">3</span></span><br><span class="line">    <span class="keyword">real</span> :: A(n,n) = <span class="built_in">reshape</span>((/<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>/),(/n,n/))</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;det(A)=&#x27;,f6.2)&quot;</span>) Determinant(A)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">det(A)&#x3D; -8.00</span><br></pre></td></tr></table></figure>
<h3 id="14-2-4-Gauss-Jordan-法求联立方程式">14-2-4 Gauss-Jordan 法求联立方程式</h3>
<p>对于 <code>A*x=b</code> 的方程式，可以用 Gauss-Jordan 法来求解。唯一的差别在于矩阵后方又要夹带数组 b 来做为等号后面的数值。矩阵的每一行在互相加减时，数组 b 也要跟着一起做加减。（这句话的意思，直接把A矩阵转换成上/下三角矩阵即可，就直接得到了x的解。但是做加减的时候数组b要跟着变化。）。</p>
<p>高斯消去法：<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%B6%88%E5%8E%BB%E6%B3%95">https://zh.wikipedia.org/wiki/高斯消去法</a></p>
<p>来看代码</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> LinearAlgebra</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">! Gauss_Jordan 法</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Gauss_Jordan(A,S,ANS)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: A(:,:) <span class="comment">!左手项</span></span><br><span class="line">        <span class="keyword">real</span> :: S(:)   <span class="comment">!右手项</span></span><br><span class="line">        <span class="keyword">real</span> :: ANS(:) <span class="comment">!结果文件</span></span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">allocatable</span> :: B(:,:)</span><br><span class="line">        <span class="keyword">integer</span> :: i,n</span><br><span class="line">        n = <span class="built_in">size</span>(A,<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">allocate</span>(B(N,N))</span><br><span class="line">        <span class="comment">! 保存原先的矩阵A及数组S</span></span><br><span class="line">        B=A</span><br><span class="line">        ANS=S</span><br><span class="line">        <span class="comment">! 把B化成对角线矩阵（除了对角线外，都为0）</span></span><br><span class="line">        <span class="keyword">call</span> Upper(B,ANS,N) <span class="comment">!先把B化成上三角矩阵</span></span><br><span class="line">        <span class="keyword">call</span> Lower(B,ANS,N) <span class="comment">!先把B化成下三角矩阵</span></span><br><span class="line">        <span class="comment">! 求解</span></span><br><span class="line">        <span class="keyword">forall</span>(i=<span class="number">1</span>:n)</span><br><span class="line">            ANS(i) = ANS(i)/B(i,i)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!输出等式</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> output(M,S)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: M(:,:), S(:)</span><br><span class="line">        <span class="keyword">integer</span> :: n,i,j</span><br><span class="line">        n = <span class="built_in">size</span>(M,<span class="number">1</span>)</span><br><span class="line">        <span class="comment">! write中加上advance=&quot;no&quot;，可以终止断行发生，使下一次的</span></span><br><span class="line">        <span class="comment">! write接续在同一行当中</span></span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(1x,f5.2,a1)&quot;</span>, <span class="keyword">advance</span>=<span class="string">&quot;NO&quot;</span>) M(i,<span class="number">1</span>), <span class="string">&#x27;A&#x27;</span></span><br><span class="line">            <span class="keyword">do</span> j=<span class="number">2</span>,n</span><br><span class="line">                <span class="keyword">if</span> (M(i,j) &lt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">                    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;-&#x27;,f5.2,a1)&quot;</span>, <span class="keyword">advance</span>=<span class="string">&quot;NO&quot;</span>) -M(i,j),<span class="built_in">char</span>(<span class="number">64</span>+j)</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;+&#x27;,f5.2,a1)&quot;</span>, <span class="keyword">advance</span>=<span class="string">&quot;NO&quot;</span>) M(i,j),<span class="built_in">char</span>(<span class="number">64</span>+j)</span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;=&#x27;,f8.4)&quot;</span>) S(i)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!求上三角矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Upper(M,S,n)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: n</span><br><span class="line">        <span class="keyword">real</span> :: M(n,n)</span><br><span class="line">        <span class="keyword">real</span> :: S(n)</span><br><span class="line">        <span class="keyword">integer</span> :: i,j</span><br><span class="line">        <span class="keyword">real</span> :: e</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">do</span> j=i+<span class="number">1</span>, n</span><br><span class="line">                e = M(j,i)/M(i,i)</span><br><span class="line">                M(j,i:n) = M(j,i:n)-M(i,i:n)*e</span><br><span class="line">                S(j) = S(j) - S(i)*e <span class="comment">!右手项要随着左手项变化而变化</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!求下三角矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Lower(M,S,n)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: n</span><br><span class="line">        <span class="keyword">real</span> :: M(n,n)</span><br><span class="line">        <span class="keyword">real</span> :: S(n)</span><br><span class="line">        <span class="keyword">integer</span> :: i,j</span><br><span class="line">        <span class="keyword">real</span> :: e</span><br><span class="line">        <span class="keyword">do</span> i=n,<span class="number">2</span>,-<span class="number">1</span></span><br><span class="line">            <span class="keyword">do</span> j=i-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span></span><br><span class="line">                e = M(j,i)/M(i,i)</span><br><span class="line">                M(j,i:n) = M(j,i:n)-M(i,i:n)*e</span><br><span class="line">                S(j) = S(j) - S(i)*e</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"><span class="comment">! 求解联立式</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> LinearAlgebra</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n =<span class="number">3</span> </span><br><span class="line">    <span class="keyword">real</span> :: A(n,n) = <span class="built_in">reshape</span>((/<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>/),(/n,n/))</span><br><span class="line">    <span class="keyword">real</span> :: S(n) = (/<span class="number">12</span>,<span class="number">15</span>,<span class="number">17</span>/)</span><br><span class="line">    <span class="keyword">real</span> :: ans(n)</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;Equation:&#x27;</span></span><br><span class="line">    <span class="keyword">call</span> output(A,S)</span><br><span class="line">    <span class="keyword">call</span> Gauss_Jordan(A,S,ANS)</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Ans:&quot;</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a1,&#x27;=&#x27;,f8.4)&quot;</span>) <span class="built_in">char</span>(<span class="number">64</span>+i),ans(i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Equation:</span><br><span class="line"> 1.00A+ 4.00B+ 7.00C&#x3D; 12.0000</span><br><span class="line"> 2.00A+ 5.00B+ 8.00C&#x3D; 15.0000</span><br><span class="line"> 3.00A+ 6.00B+ 8.00C&#x3D; 17.0000</span><br><span class="line">Ans:</span><br><span class="line">A&#x3D;  1.0000</span><br><span class="line">B&#x3D;  1.0000</span><br><span class="line">C&#x3D;  1.0000</span><br></pre></td></tr></table></figure>
<p>这个程序通过<strong>先把矩阵转化为上三角矩阵，再转化为下三角矩阵</strong>的方式，得到对角线矩阵。</p>
<p>这里转化为上/下三角矩阵式，右手项要跟着变化。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">M(j,i:n) = M(j,i:n)-M(i,i:n)*e</span><br><span class="line">S(j) = S(j) - S(i)*e <span class="comment">!右手项要随着左手项变化而变化</span></span><br></pre></td></tr></table></figure>
<p>得到的对角线矩阵还不是单位矩阵，需要除以对角线元素的值</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">! 求解</span></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:n)</span><br><span class="line">    ANS(i) = ANS(i)/B(i,i)</span><br></pre></td></tr></table></figure>
<p>最终得到了解。</p>
<h3 id="14-2-5-逆矩阵">14-2-5 逆矩阵</h3>
<p>逆矩阵的算法与上一个小节中使用的方法差不多，在矩阵后面夹带一个单位矩阵，然后把前面那个矩阵处理成对角线矩阵，矩阵每一次的加减运行时，后面夹带的矩阵也要跟着变化。</p>
<p>再把前面的那个矩阵从对角线矩阵转化为单位矩阵，这个时候第二个矩阵就会变成第一个矩阵的逆矩阵。程序的实际方法与使用 Gauss-Jordan 法来求解联立式的方法非常类似。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> LinearAlgebra</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">! 求逆矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> inverse(A,IA)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: A(:,:), IA(:,:)</span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">allocatable</span> :: B(:,:)  </span><br><span class="line">        <span class="keyword">integer</span> :: i,j,n</span><br><span class="line">        n = <span class="built_in">size</span>(A,<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">allocate</span>(B(N,N))</span><br><span class="line">        <span class="comment">! 先把 IA 设置为单位矩阵</span></span><br><span class="line">        <span class="keyword">forall</span>(i=<span class="number">1</span>:n, j=<span class="number">1</span>:n, i==j)IA(i,j)=<span class="number">1.0</span></span><br><span class="line">        <span class="keyword">forall</span>(i=<span class="number">1</span>:n, j=<span class="number">1</span>:n, i/=j)IA(i,j)=<span class="number">0.0</span></span><br><span class="line">        <span class="comment">! 保存原先的矩阵A,使用B来计算</span></span><br><span class="line">        B=A</span><br><span class="line">        <span class="comment">! 把B化成对角线矩阵（除了对角线外，都为0）</span></span><br><span class="line">        <span class="keyword">call</span> Upper(B,IA,N) <span class="comment">!先把B化成上三角矩阵</span></span><br><span class="line">        <span class="keyword">call</span> Lower(B,IA,N) <span class="comment">!再把B化成下三角矩阵</span></span><br><span class="line">        <span class="comment">! 求解</span></span><br><span class="line">        <span class="keyword">forall</span>(i=<span class="number">1</span>:n)</span><br><span class="line">            IA(i,:) = IA(i,:)/B(i,i)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!输出矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> output(matrix)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: matrix(:,:)</span><br><span class="line">        <span class="keyword">integer</span> :: m,n,i</span><br><span class="line">        <span class="keyword">character</span>(len=<span class="number">20</span>) :: for=<span class="string">&#x27;(??(1x,f6.3))&#x27;</span></span><br><span class="line">        m = <span class="built_in">size</span>(matrix,<span class="number">1</span>)</span><br><span class="line">        n = <span class="built_in">size</span>(matrix,<span class="number">2</span>)</span><br><span class="line">        <span class="comment">!用字符串来设置输出格式</span></span><br><span class="line">        <span class="built_in">write</span>(for(<span class="number">2</span>:<span class="number">3</span>), <span class="string">&#x27;(i2)&#x27;</span>) n</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">            <span class="built_in">write</span>(*,<span class="keyword">fmt</span>=for) matrix(i,:)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!求上三角矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Upper(M,S,n)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: n</span><br><span class="line">        <span class="keyword">real</span> :: M(n,n)</span><br><span class="line">        <span class="keyword">real</span> :: S(n)</span><br><span class="line">        <span class="keyword">integer</span> :: i,j</span><br><span class="line">        <span class="keyword">real</span> :: e</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">do</span> j=i+<span class="number">1</span>, n</span><br><span class="line">                e = M(j,i)/M(i,i)</span><br><span class="line">                M(j,i:n) = M(j,i:n)-M(i,i:n)*e</span><br><span class="line">                S(j) = S(j) - S(i)*e <span class="comment">!右手项要随着左手项变化而变化</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!求下三角矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Lower(M,S,n)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: n</span><br><span class="line">        <span class="keyword">real</span> :: M(n,n)</span><br><span class="line">        <span class="keyword">real</span> :: S(n)</span><br><span class="line">        <span class="keyword">integer</span> :: i,j</span><br><span class="line">        <span class="keyword">real</span> :: e</span><br><span class="line">        <span class="keyword">do</span> i=n,<span class="number">2</span>,-<span class="number">1</span></span><br><span class="line">            <span class="keyword">do</span> j=i-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span></span><br><span class="line">                e = M(j,i)/M(i,i)</span><br><span class="line">                M(j,i:n) = M(j,i:n)-M(i,i:n)*e</span><br><span class="line">                S(j) = S(j) - S(i)*e</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"><span class="comment">! 求解联立式</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> LinearAlgebra</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n =<span class="number">3</span> </span><br><span class="line">    <span class="keyword">real</span> :: A(n,n) = <span class="built_in">reshape</span>((/<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>/),(/n,n/))</span><br><span class="line">    <span class="keyword">real</span> :: IA(n,n)</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;原矩阵&#x27;</span></span><br><span class="line">    <span class="keyword">call</span> output(A)</span><br><span class="line">    <span class="keyword">call</span> inverse(A,IA)</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;逆矩阵&quot;</span></span><br><span class="line">    <span class="keyword">call</span> output(IA)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原矩阵</span><br><span class="line"> 1.000  4.000  7.000</span><br><span class="line"> 2.000  5.000  8.000</span><br><span class="line"> 3.000  6.000  8.000</span><br><span class="line">逆矩阵</span><br><span class="line">-2.667  0.000  0.000</span><br><span class="line"> 2.667 -0.333 -0.000</span><br><span class="line">-1.000 -0.000 -1.000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="14-2-6-对角矩阵的运行">14-2-6 对角矩阵的运行</h3>
<p>所谓的对角矩阵，就是类似下面的情况：只有靠近对角线位置上2个相邻的位置有数值，其他位置为0。</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%0A%20%5Cbegin%7Bmatrix%7D%0A%20%20%202%20%26%203%20%26%200%20%26%200%20%26%200%20%5C%5C%0A%20%20%200%20%26%202%20%26%203%20%26%200%20%26%200%20%5C%5C%0A%20%20%200%20%26%200%20%26%202%20%26%203%20%26%200%20%5C%5C%0A%20%20%200%20%26%200%20%26%200%20%26%202%20%26%203%0A%20%20%5Cend%7Bmatrix%7D%0A%20%20%5Cright%5D%0A" /></p><p>利用这个特性来保存矩阵，可以节省很多空间。原本 N×N 大小的矩阵需要 N×N  的数组来保存，不过如果要保存想上例中的二对角矩阵，只要用N×2大小的数组就足够了，因为只需要记录有数值的部分就行了，数字为0的部分不需要另辟空间来做记录。</p>
<p>使用这个数据结构来操作矩阵时，与前几个小节的方法比较起来当然是会有一些不同，来看看求解联立方程式要如何运行。</p>
<p>在此同样使用 Gauss-Jordan 法来解联立方程式。事实上，用对角矩阵会比较简单。因为已经知道矩阵哪些低分为0，这些地方在把矩阵对角线化的时候可以不再去理会。简化后的结果，在每一个循环中，只要把矩阵相邻两行来互相加减就够了，不需要把每一行都拿来操作，可以节省大量的运算。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!三对角阵求解</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main </span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: Width = <span class="number">3</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: Row = <span class="number">5</span> <span class="comment">! size of Matrix</span></span><br><span class="line">    <span class="keyword">real</span> :: A(row, width)=<span class="built_in">reshape</span>((/<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,&amp;</span><br><span class="line">                        <span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,&amp;</span><br><span class="line">                        <span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">0</span>/),(/row,width/))</span><br><span class="line">    <span class="keyword">real</span> :: S(row)=(/<span class="number">3</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">10</span>,<span class="number">3</span>/)</span><br><span class="line">    <span class="keyword">real</span> :: ans(row)</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="comment">! equation:</span></span><br><span class="line">    <span class="comment">! a+2b=3</span></span><br><span class="line">    <span class="comment">! 2b+3c+4d=9</span></span><br><span class="line">    <span class="comment">! 3c+4d+5e=12</span></span><br><span class="line">    <span class="comment">! 4d+5e+f=10</span></span><br><span class="line">    <span class="comment">! e+2f=3</span></span><br><span class="line">    <span class="keyword">call</span> Gauss_Jordan(A,S,ANS,row,width)</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;Ans:&#x27;</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,row</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a1,&#x27;=&#x27;,f8.4)&quot;</span>) <span class="built_in">char</span>(<span class="number">96</span>+i),ANS(i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">! Gauss_Jordan 法的函数</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Gauss_Jordan(A,S,ANS,row,width)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: row, width</span><br><span class="line">    <span class="keyword">real</span> :: A(row, width)</span><br><span class="line">    <span class="keyword">real</span> :: S(row)</span><br><span class="line">    <span class="keyword">real</span> :: ANS(row)</span><br><span class="line">    <span class="keyword">real</span> :: B(row, width)</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 保存原先的矩阵A及数组S</span></span><br><span class="line">    B=A</span><br><span class="line">    ANS=S</span><br><span class="line">    <span class="comment">! 把B化为对角线矩阵</span></span><br><span class="line">    <span class="keyword">call</span> Upper(B,ANS,row,width) <span class="comment">! 先把B化成上三角矩阵</span></span><br><span class="line">    <span class="keyword">call</span> Lower(B,ANS,row,width) <span class="comment">! 再把B化成下三角矩阵</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 求出解</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,row</span><br><span class="line">        ANS(i) = ANS(i)/B(i,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="comment">! 求上三角矩阵的子程序</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Upper(M,S,row,width)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: row, width</span><br><span class="line">    <span class="keyword">real</span> :: M(row,width)</span><br><span class="line">    <span class="keyword">real</span> :: S(row)</span><br><span class="line">    <span class="keyword">integer</span> :: i,j</span><br><span class="line">    <span class="keyword">real</span> :: e</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>, row-<span class="number">1</span></span><br><span class="line">            j=i+<span class="number">1</span></span><br><span class="line">            e = M(j,<span class="number">1</span>)/M(i,<span class="number">2</span>)</span><br><span class="line">            M(j,<span class="number">1</span>:<span class="number">2</span>) = M(j,<span class="number">1</span>:<span class="number">2</span>)-M(i,<span class="number">2</span>:<span class="number">3</span>)*e</span><br><span class="line">            S(j) = S(j) - S(i)*e <span class="comment">!右手项要随着左手项变化而变化</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="comment">!求下三角矩阵的子程序</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Lower(M,S,row,width)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: row, width</span><br><span class="line">    <span class="keyword">real</span> :: M(row,width)</span><br><span class="line">    <span class="keyword">real</span> :: S(row)</span><br><span class="line">    <span class="keyword">integer</span> :: i,j</span><br><span class="line">    <span class="keyword">real</span> :: e</span><br><span class="line">    <span class="keyword">do</span> i=row,<span class="number">2</span>,-<span class="number">1</span></span><br><span class="line">            j=i-<span class="number">1</span></span><br><span class="line">            e = M(j,<span class="number">3</span>)/M(i,<span class="number">2</span>)</span><br><span class="line">            M(j,<span class="number">3</span>) = M(j,<span class="number">3</span>)-M(i,<span class="number">2</span>)*e</span><br><span class="line">            S(j) = S(j) - S(i)*e</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br></pre></td></tr></table></figure>
<p>这个在书上的代码有好几处 bug ，这里是我改过来，能跑通的。但是这个代码我没看懂，而且这里不是自动化的，是只适用他这里的”三对角矩阵“。</p>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ans:</span><br><span class="line">a&#x3D;  1.0000</span><br><span class="line">b&#x3D;  1.0000</span><br><span class="line">c&#x3D;  1.0000</span><br><span class="line">d&#x3D;  1.0000</span><br><span class="line">e&#x3D;  1.0000</span><br></pre></td></tr></table></figure>
<h2 id="14-3-积分">14-3 积分</h2>
<p>做积分的最好方法，当然是先求出积分函数再来求解。<strong>用数值方法来做积分，主要是应用在函数不存在时</strong>。从实验中得到的一连串数据，应该是没有办法刚好适用某一个函数来表示它，要对这一串数据做积分时，只能使用其他算法来做。一般最常见的方法是使用各种已知面积的小图形来填充这些区域，在经过计算这些图形的面积总和来逼近答案。</p>
<h3 id="14-3-1-梯形法积分">14-3-1 梯形法积分</h3>
<p>梯形法做积分的原理很简单，把所需积分的图形，用许多个小梯形方块来将它们填满。实现的程序如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Integral</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>, <span class="keyword">parameter</span> :: pi = <span class="number">3.14159</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">!生成数列</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> GenerateData(datas, width, func)</span><br><span class="line">        <span class="keyword">real</span> datas(:), width</span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">external</span> :: func</span><br><span class="line">        <span class="keyword">real</span> r</span><br><span class="line">        <span class="keyword">integer</span> i, n</span><br><span class="line">        n = <span class="built_in">size</span>(datas,<span class="number">1</span>)</span><br><span class="line">        width = pi/(n-<span class="number">1</span>)</span><br><span class="line">        r = <span class="number">0</span></span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">            datas(i) = func(r)</span><br><span class="line">            r = r + width</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!梯形积分法</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Trape_Integral(datas, width)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> datas(:)</span><br><span class="line">        <span class="keyword">real</span> width <span class="comment">!每条数据的间隔</span></span><br><span class="line">        <span class="keyword">real</span> <span class="built_in">sum</span> <span class="comment">!计算所有上底加下底除以二的和</span></span><br><span class="line">        <span class="keyword">integer</span> i,n</span><br><span class="line">        n = <span class="built_in">size</span>(datas,<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">sum</span> = (datas(<span class="number">1</span>)+datas(n))/<span class="number">2.0</span></span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">2</span>,n-<span class="number">1</span></span><br><span class="line">            <span class="built_in">sum</span> = <span class="built_in">sum</span>+datas(i) <span class="comment">!累加边长</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        Trape_Integral = <span class="built_in">sum</span>*width <span class="comment">!计算面积和</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="comment">! 梯形法积分范例</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> Integral</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: N = <span class="number">10</span></span><br><span class="line">    <span class="keyword">real</span> DATAS(n), width</span><br><span class="line">    <span class="keyword">real</span> ANS <span class="comment">!答案</span></span><br><span class="line">    <span class="keyword">real</span>, <span class="keyword">intrinsic</span> :: <span class="built_in">sin</span> <span class="comment">!仿真用来生成数据的函数</span></span><br><span class="line">    <span class="keyword">call</span> GenerateData(DATAS, width, <span class="built_in">sin</span>) </span><br><span class="line">    ANS = Trape_Integral(DATAS, width) <span class="comment">!计算积分</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;ans=&#x27;,f5.2)&quot;</span>) ANS <span class="comment">!显示答案</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line">            </span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ans&#x3D; 1.98</span><br></pre></td></tr></table></figure>
<p>积分的数据是使用 sin 函数所生成的一长串数值，使用计算机来计算积分时，通常都是面对一串数字来做计算，而不是直接面对一个数学函数。子程序 GenerateData 的作用就是用来生成一串数字来做积分计算，所生成的是X值范围在0~Π之间的sin(x) ，积分的结果应该是2。</p>
<p>他这里求 sum（所有上底加下底除以二的和） 的时候，由于第一个梯形的上底和最后一个梯形的下底只用了一次，因此该除以2；至于中间的函数值，都是既作为一个梯形的上底，又作为另一个梯形的下底，因此乘2除2正好抵消。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sum</span> = (datas(<span class="number">1</span>)+datas(n))/<span class="number">2.0</span> <span class="comment">!第一个梯形的上底和最后一个梯形的下底</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">2</span>,n-<span class="number">1</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span>+datas(i) <span class="comment">!累加边长，其他</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<h3 id="14-3-2-simpson-辛普森法积分">14-3-2 simpson 辛普森法积分</h3>
<p>辛普森法的原理，是把函数图形使用很多段的二次曲线来近似图形，再计算这些二次曲线形成的面积。使用辛普森法有一个限制，一定要有奇数个数据才能计算，因为每一条二次权限都要从数据中取3个点。每一条二次曲线的积分公式如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">f(x) 积分 = （f0 + <span class="number">4</span>*f1 + f2) * h/<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>把每一段二次曲线累加起来，就可以得到整个辛普森法积分的公式：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">f(x) 积分 = （f0 + <span class="number">4</span>*f1 + <span class="number">2</span>*f2 + <span class="number">4</span>*f3 + <span class="number">2</span>*f4…… + <span class="number">4</span>*fn-<span class="number">1</span> + fn) * h/<span class="number">3</span> </span><br></pre></td></tr></table></figure>
<p>ok, 我压根不知道这是啥，pass</p>
<p>代码略。</p>
<h2 id="14-4-插值法与曲线近似">14-4 插值法与曲线近似</h2>
<p>插值法与曲线近似其实是同样的一个课题，曲线近似的目的经常就是为了要做插值。插值法的应用很频繁，在实验室中，可以使用插值法来利用有限的已知数据点来预测未知的状态。</p>
<h3 id="14-4-1-Lagrange-Interpolation-多项式插值法">14-4-1 Lagrange Interpolation 多项式插值法</h3>
<p>使用多项式来做插值，会经过所获得的 N 个数据点，生成最高项为 N-1 的多项式，这个多项式函数图形会经过这 N 个数据点。Lagrange Interpolation 的公式可以来生成这个多项式。</p>
<p>假设 （X1,Y1),  (X2,Y2) … (Xn, Yn) 为 N 个数据点，经过 Lagrange Interpolation 法所生成通过这 N 个点的多项式函数 g(x) 为：</p>
<p>略</p>
<h3 id="14-4-2-牛顿法-Forward-Interpolation">14-4-2 牛顿法  Forward Interpolation</h3>
<p>看不懂，略。</p>
<h3 id="14-4-3-最小方差法（Least-Square）">14-4-3 最小方差法（Least Square）</h3>
<p>最小方差法是应用在已经可以用理论推得数据的函数形式，而不知道系数数值的时候。因为实验不可能处于完美的情况，所得的数据不可能工整地在函数曲线上，大多都是散步在理论所预测的附近。(这就是最小二乘)</p>
<p>求 N 个点到 Y = aT + b 直线上的距离平方总和。要使距离平方和为最短，可以把上述的式子分别对 a, b 做偏微分，令两式结果为0，并解出 a, b 值即可。联立两式，又可以写成一个新的方程式。（这里我没法把式子列出来，不直观）。</p>
<p>代码略。</p>
<h3 id="14-4-4-曲线近似法（Cubic-Spline）">14-4-4 曲线近似法（Cubic Spline）</h3>
<p>略</p>
<h1>15 数据结构与算法</h1>
<p>这一章所要介绍的课题是数据结构与算法。学会 Fortran 语法，只能算是学会程序设计的皮毛而已。<strong>程序员的能力，主要取决在实现及设计算法的能力，不在于他会使用哪些程序语言</strong>。</p>
<p>数据结构的课题，主要在于讨论如何使用程序语言的基本类型来记录数据的方法。简单的数据结构方法，不需要学习大家就自然会使用，例如使用二维数组来记录矩阵。在前面章节中，已经应用过一些比较复杂的数据结构，例如第10章的串行结构，第14章的对角矩阵等等。</p>
<p>算法是指：”通过编写程序解决问题的方法“。第14章的数值方法中，所介绍的就是各种用来计算数学问题的算法。这一章所要介绍的算法，是在编写每一种程序时，都有可能会使用的基本算法。</p>
<h2 id="15-1-排序">15-1 排序</h2>
<p>”排序“ 的算法很多，在本节会介绍其中的四种。实例程序只范例由小排到大的做法，相信读者应该能自行领会由大排到小的做法。</p>
<h3 id="15-1-1-冒泡排序法（Bubble-Sort）">15-1-1 冒泡排序法（Bubble Sort）</h3>
<p>冒泡排序法是最简单的排序方法之一，它的步骤如下：</p>
<ol>
<li>从第1个数字开始，依序把两个相邻的数值互相比较大小。如果前一个数字比后面一个数字大，就把它们的位置互相交换。</li>
<li>一直做到每一对相邻的数字都比较过后才结束这一轮的工作。</li>
<li>回到第1步，再做下一个循环的比较。如果有 N 个数字要排序，就需要重复 N-1次的扫描工作。</li>
</ol>
<p>第一次扫描，会找出最大的数值，并把它放在数组的最后面。第二次扫描，找出第2大的数值，放在倒数第二个位置……</p>
<p>可以看出，冒泡排序法可以想象成是让重的东西向下沉，轻的东西向上浮。等到状态稳定，就会得到排序结果。下面是冒泡排序法的程序：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">! 冒泡排序法范例</span></span><br><span class="line"><span class="comment">! By perng 1997/8/29</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> bubble_sort_demo</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n = <span class="number">10</span></span><br><span class="line">    <span class="keyword">integer</span> :: a(n) = (/<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>/) <span class="comment">! 待排序的数据</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source=&gt;&#x27;, 10I3)&quot;</span>) a</span><br><span class="line">    <span class="keyword">call</span> Bubble_Sort(a,n) <span class="comment">!调用排序的子程序</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Sort=&gt;&#x27;, 10I3)&quot;</span>) a</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Bubble_Sort(A,N)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: n, a(n)</span><br><span class="line">    <span class="keyword">integer</span> i,j, temp</span><br><span class="line">    <span class="keyword">do</span> i = n-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span> <span class="comment">! 开始做N-1次的扫描</span></span><br><span class="line">        <span class="keyword">do</span> j = <span class="number">1</span>,i  <span class="comment">! 一对一对的比较，i 之后的数字不用比较</span></span><br><span class="line">            <span class="comment">! 如果 A(j) &gt; A(j+1) 就把这两个数值交换</span></span><br><span class="line">            <span class="keyword">if</span> (A(j) &gt; A(j+<span class="number">1</span>)) <span class="keyword">then</span></span><br><span class="line">                temp = a(j)</span><br><span class="line">                a(j) = a(j+<span class="number">1</span>)</span><br><span class="line">                a(j+<span class="number">1</span>) = temp</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Source&#x3D;&gt;  6  2  8  4  0  9  3  5  1  7</span><br><span class="line">Sort&#x3D;&gt;  0  1  2  3  4  5  6  7  8  9</span><br></pre></td></tr></table></figure>
<h3 id="15-1-2-选择排序法（Selection-Sort）">15-1-2 选择排序法（Selection Sort）</h3>
<p>选择排序法的原理很简单，步骤如下：</p>
<ol>
<li>找出全部N个数据中最小的一个，把它和数列的第1个数字交换位置。</li>
<li>找出剩下N-1个数据中最小的一个，把它和数列的第2个数字交换位置。</li>
<li>找出剩下N-2个数据中最小的一个，把它和数列的第3个数字交换位置。</li>
<li>……</li>
<li>一直做到只剩下一个数据为止。</li>
</ol>
<p>选择排序法的过程，就是一步一步地精选出数据中最小的数值，并把它放到所该对应的位置上。需要处理的数据每次会减少一个，一直到只剩下一个数值为止。（这个方法感觉和上一个没啥区别啊）</p>
<p>程序如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">! 选择排序法范例</span></span><br><span class="line"><span class="comment">! By Perng 1997/8/29 </span></span><br><span class="line"><span class="comment">! 果然是一个人发明的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> selection_sort_demo</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n = <span class="number">10</span> </span><br><span class="line">    <span class="keyword">integer</span> :: a(n) = (/<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>/) <span class="comment">! 待排序的数据</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source=&gt;&#x27;, 10I3)&quot;</span>) a</span><br><span class="line">    <span class="keyword">call</span> Selection_Sort(a,n) <span class="comment">!调用排序的子程序</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Sort=&gt;&#x27;, 10I3)&quot;</span>) a</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">!选择排序法的子程序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Selection_Sort(a,n)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: n, a(n)</span><br><span class="line">    <span class="keyword">integer</span> i,j <span class="comment">! 循环计数器</span></span><br><span class="line">    <span class="keyword">integer</span> <span class="built_in">min</span> <span class="comment">! 找出每一轮中的最小值</span></span><br><span class="line">    <span class="keyword">integer</span> temp </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>,n</span><br><span class="line">        <span class="comment">! min = a(i) !暂时令a(i)是最小值 !我感觉这里的min是多余的</span></span><br><span class="line">        <span class="keyword">do</span> j = i+<span class="number">1</span>, n</span><br><span class="line">            <span class="keyword">if</span>(a(i) &gt; a(j)) <span class="keyword">then</span> <span class="comment">! 发现a(i)不是最小</span></span><br><span class="line">                temp = a(j) <span class="comment">!a(i),a(j) 交换</span></span><br><span class="line">                a(j) = a(i)</span><br><span class="line">                a(i) = temp </span><br><span class="line">                <span class="comment">! min = a(i)</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Source&#x3D;&gt;  6  2  8  4  0  9  3  5  1  7</span><br><span class="line">Sort&#x3D;&gt;  0  1  2  3  4  5  6  7  8  9</span><br></pre></td></tr></table></figure>
<p>这里需要注意，书上的代码里 min 这个变量完全是多余的，没有用处。我就删除了，看来作者偶尔也会犯点迷糊。</p>
<h3 id="15-1-3-Shell-排序法">15-1-3 Shell 排序法</h3>
<p>这是 1959 年 D.L.Shell 所发明的排序方法，这个方法和前面两个方法比较起来比较没有那么直观，在此所使用的是比较简单的一种 Shell 排序法。排序 N 个数据项的步骤如下：</p>
<blockquote>
<ol>
<li>令 k = n/2</li>
<li>把数据项分组，第1，1+k 的数字为一组，第2，2+k 为一组，一直到把所有的数据分配完毕为止。（也就是两两一组，那要是奇数个数字怎么办？）</li>
<li>每一组各自互相比较大小，如果前者大于后则J（第n项 &gt; 第n+k项），两者都要交换位置。而且还要再往回取出第n-k, n这两项再来比较，如果第 n-k 项 &gt; 第 n 项，那又要再往回取出 n-2k, n-k 这两项来比较。一直往回取到第 N-nK &lt; 第N - (n-1)K项，或者是到了不能往回取为止。</li>
<li>令 k = k/2 ，再回到第2步重复，一直到 k = 0 为止。</li>
</ol>
</blockquote>
<p>啊，这说的是人话嘛？</p>
<p>我不知道发明这个算法的人是怎么想到的，能搞成这么复杂。而且我粗略地感觉了一个，计算复杂度并不低，从书上看，排序5个数字，也计算了十几次（当然比前面两个算法要好）。</p>
<p>Shell 排序法可以形容成 ” 乱中有序“ ，因为它在每一次的循环中都只能大概地安排每一个元素到更加接近的位置，一直要到最后一次循环，才能确定每个数字的真正位置。</p>
<p>代码略。</p>
<h3 id="15-1-4-快速排序法（Quick-Sort）">15-1-4 快速排序法（Quick Sort）</h3>
<p>这个小节所要介绍的快速排序法，相信任何人听到一定都会非常心动，因为它的名字听起来就很有威力，在一般的情况下，也确实是目前最快的排序方法。这个实例程序会使用递归调用的功能。</p>
<p>快速排序法处理N个数据的步骤如下：</p>
<blockquote>
<ol>
<li>
<p>以数据组中的第1个数字做为键值K，令L=2, R=N。</p>
</li>
<li>
<p>以K值为基准，把小于K的数字向前移动，大于K的数字向后移动。移动的过程中，会同时发现K值在数列中的大小排名，并把K值放在正确的位置上。</p>
</li>
<li>
<p>假设K值排名为S，把移动后的数列分成比K小和比K大这两组。数列中第1~S-1 个数字都比K小，第S+1~N个数字都比K大，再把这两个小组拿去排序。</p>
<p>使用快速排序法时，每一个循环都会生成两个新的小组。切割的操作会一直进行到新的小组中只剩下一个数字为止。步骤2的过程有必要再详细地介绍，同样令 L=2， R=N，num(n) 为数据中第n个数字：</p>
</li>
<li>
<p>从数据组中的第L个数字开始，依序拿下一个数字和键值K来比较，一直到找出&gt;=K 的数值为止。把L重新设置为这个数值在数据中的位置。</p>
</li>
<li>
<p>从数据组中的第R个数字开始，依序拿前一个数字和键值K来比较，一直到找出&lt;=K 的数值为止。把R设为这个数值在数据中的位置。</p>
</li>
<li>
<p>如果 L &lt; R ，把数组中 L，R这两个位置的数值交换，再回到上一个步骤继续执行。如果　L &gt; R , 把数组第1个数字和第R个数字交换位置。到了这个时候，num(1~R-1)&lt;=num®, num(R+1~N) &gt;= num® , 会确定出第R个数值的排名。</p>
</li>
</ol>
</blockquote>
<p>下面这组数字 {3,2,5,1,4} 以快速排序法排序的过程如下：</p>
<p>先取 K = num(1) = 3 为键值来做比较，令 L = 2、R = 5。</p>
<ol>
<li>从第L个数字向后寻找&gt;=K的数值，结果发现 num(3) = 5 &gt; K，所以令L = 3</li>
<li>从第R个数字向前寻找&lt;K 的数值，结果发现 num(4) = 1 &lt; K，所以令R = 4</li>
<li>因为 L=3 &lt; R=4, 所以把 num(3) 及 num(4) 的数值交换，数据变成 {3,2,1,5,4}</li>
<li>再继续从 L=3 的地方向下找 &gt;= K的数值，结果发现num(4)=5&gt;k, 所以令L = 4</li>
<li>再继续从 R=4 的地方向前找 &lt; K 的数值，结果发现num(3)=1&lt;K, 所以令R = 3</li>
<li>因为 L =4 &gt; R=3，所以要把num(1) 和 num® 的数值交换。此时的数列内容为 {1,2,3,5,4}。而这一次的循环会确定 num(3) 的数值（因为 R=3），接下来要把 num(1~2) 的 [1,2] 及 num(4~5)  的 [5,4] 分成两组，再把它们用同样的方法来排序。</li>
</ol>
<p>经过上面的解释，可以简单地把快速排序法做一个简述。快速排序法是一次次地把整个数据细分成许多小组，而每一次都会确定小组的第1个成员在数据中的排名。快速排序法的实现程序如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">! 快速排序法范例</span></span><br><span class="line"><span class="comment">! By Perng 1997/8/30 </span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> QuickSort_Demo</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n = <span class="number">10</span></span><br><span class="line">    <span class="keyword">real</span> :: b(n)</span><br><span class="line">    <span class="keyword">integer</span> :: a(n)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 用随机数生成数列</span></span><br><span class="line">    <span class="keyword">call</span> random_seek()</span><br><span class="line">    <span class="keyword">call</span> <span class="built_in">random_number</span>(b)</span><br><span class="line">    a = b*<span class="number">100</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source=&gt;&#x27;, 10i3)&quot;</span>) a</span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 调用Quick_Sort 时除了要输入数组的信息外，还要给定要排列数组元素</span></span><br><span class="line">    <span class="comment">! 的上下限位置范围，在此当然是要给 1,n ， 表示从头排到尾。</span></span><br><span class="line">    <span class="keyword">call</span> Quick_Sort(a,n,<span class="number">1</span>,n)</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Sort=&gt;&#x27;, 10i3)&quot;</span>) a</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">!快速排序法的子程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">recursive</span> <span class="function"><span class="keyword">subroutine</span></span> Quick_Sort(a,n,s,e)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: n    <span class="comment">! 表示数组的大小</span></span><br><span class="line">    <span class="keyword">integer</span> :: a(n) <span class="comment">! 存放数据的数组</span></span><br><span class="line">    <span class="keyword">integer</span> :: s    <span class="comment">! 输入的参数，这一组的数组的起始位置</span></span><br><span class="line">    <span class="keyword">integer</span> :: e    <span class="comment">! 输入的参数，这一组的数组的结束位置</span></span><br><span class="line">    <span class="keyword">integer</span> :: l,r  <span class="comment">! 用来找a(l) &gt; k 及 a(r) &lt; k 时用的</span></span><br><span class="line">    <span class="keyword">integer</span> :: k    <span class="comment">! 记录键值 a(s) </span></span><br><span class="line">    <span class="keyword">integer</span> :: temp <span class="comment">! 交换两个数值时用的</span></span><br><span class="line">    <span class="comment">! 首先要先给定l, r 的初值。l 要从头开始，r 要从尾开始</span></span><br><span class="line">    l = s</span><br><span class="line">    r = e + <span class="number">1</span></span><br><span class="line">    <span class="comment">! Right 值 &gt; Left 值时才有必要进行排序</span></span><br><span class="line">    <span class="keyword">if</span>(r &lt;= l) <span class="keyword">return</span> <span class="comment">! return 就是提前结束子程序</span></span><br><span class="line">    </span><br><span class="line">    k = a(s) <span class="comment">! 设置键值</span></span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="comment">!找出 A(l) &lt; k 的所在</span></span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">            L = L + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span>((A(l) &gt; k) .or. (l&gt;=e)) <span class="keyword">exit</span> </span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="comment">! 找出 A(r) &gt; k 的所在</span></span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">            r = r-<span class="number">1</span> <span class="comment">!初值设为 e+1,这里就变成了 e</span></span><br><span class="line">            <span class="keyword">if</span>((a(r) &lt; k) .or. (r&lt;=s)) <span class="keyword">exit</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">        <span class="comment">! 如果 right 跑到 left 的 左边时，循环就该结束了</span></span><br><span class="line">        <span class="keyword">if</span>(r &lt;= l) <span class="keyword">exit</span></span><br><span class="line">        <span class="comment">! 交换 a(l), a(r) 的数值</span></span><br><span class="line">        temp = a(l)</span><br><span class="line">        a(l) = a(r)</span><br><span class="line">        a(r) = temp</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment">! 交换a(s), a(r)的数值</span></span><br><span class="line">    temp = a(s)</span><br><span class="line">    a(s) = a(r)</span><br><span class="line">    a(r) = temp</span><br><span class="line">    <span class="comment">! 把r之前的数据重新分组，再做排序</span></span><br><span class="line">    <span class="keyword">call</span> Quick_Sort(A,N,S,R-<span class="number">1</span>)</span><br><span class="line">    <span class="comment">! 把r之后的数据重新分组，再做排序</span></span><br><span class="line">    <span class="keyword">call</span> Quick_Sort(A,N,R+<span class="number">1</span>,E)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Source&#x3D;&gt;  5 45 37 72 29 70 18 46  3 44</span><br><span class="line">Sort&#x3D;&gt;  3  5 18 29 37 44 45 46 70 72</span><br></pre></td></tr></table></figure>
<p>注意，这里用到了递归。这个算法是真的漂亮。</p>
<p>这里所介绍的排序方法，在一般的情况下的工作效率排名为：</p>
<blockquote>
<p>快速排序法 &gt; shell 排序法 &gt; 冒泡排序法 &gt; 选择排序法</p>
</blockquote>
<h2 id="15-2-搜索">15-2 搜索</h2>
<p>搜索是在一堆东西中寻找特定物品。本节将会介绍三种搜索方法。</p>
<h3 id="15-2-1-顺序搜索">15-2-1 顺序搜索</h3>
<p>顺序搜索是最简单的方法，一句话就可以解释完毕：“把东西一个一个拿出来，看看它是不是我们所要找的东西。”</p>
<p>程序实现如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">! 顺序搜索法示范</span></span><br><span class="line"><span class="comment">! By Perng 1997/8/31</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> sequential_search_demo</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n = <span class="number">10</span></span><br><span class="line">    <span class="keyword">integer</span> :: a(n) = (/ <span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span> /) <span class="comment">! 存放数据组的数据</span></span><br><span class="line">    <span class="keyword">integer</span> key <span class="comment">! 记录要找的值</span></span><br><span class="line">    <span class="keyword">integer</span> loc </span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">external</span> :: sequential_search</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source=&gt;&#x27;,10i3)&quot;</span>) a</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;Input Key:&#x27;</span></span><br><span class="line">    read(*,*) key</span><br><span class="line">    <span class="comment">! 调用顺序搜索的函数</span></span><br><span class="line">    loc = sequential_search(a,n,key)</span><br><span class="line">    <span class="keyword">if</span>(loc/=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;A(&#x27;,i2,&#x27; )=&#x27;i3)&quot;</span>) loc, key</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;Not found&quot;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">! 顺序搜索法的子程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> Sequential_Search(a,n,key)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> n, a(n)</span><br><span class="line">    <span class="keyword">integer</span> key </span><br><span class="line">    <span class="keyword">integer</span> i <span class="comment">!循环的计数器</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> i =<span class="number">1</span>,n <span class="comment">!开始做扫描，最多做N次</span></span><br><span class="line">        <span class="keyword">if</span>(key == A(i)) <span class="keyword">then</span></span><br><span class="line">            <span class="comment">! 找到了，返回数字在数组中的位置</span></span><br><span class="line">            <span class="comment">! 但是如果有多个重复值，只会返回第一个位置</span></span><br><span class="line">            sequential_search = i</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment">! 没找到时返回 -1</span></span><br><span class="line">    sequential_search = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个太简单了。</p>
<h3 id="15-2-2-二元搜索">15-2-2 二元搜索</h3>
<p>二元搜索法必须配合<strong>排序好</strong>的数据才能使用，假设所要寻找的数值为K，数据存放在数组中，搜索的步骤如下：</p>
<ol>
<li>取出数组的中间值 M 与 K 值来互相比较，如果 k=M 就找到了；如果 K&gt;M ，那么 K一定在数组的后半段；如果K&lt;M ，同理。</li>
<li>根据K值在数组的前半段/后半段来重新分组，再回到第一步来做搜索。分组会一直细分到数组不能再细分下去为止，而到此时若还没有找到K，代表K值不存在。</li>
</ol>
<p>二元搜索法的程序实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">! 二元搜索法范例</span><br><span class="line">! By Perng 1997&#x2F;8&#x2F;31</span><br><span class="line">program Binary_Search_demo</span><br><span class="line">    implicit none</span><br><span class="line">    integer, parameter :: n &#x3D;10 !数组的大小</span><br><span class="line">    integer :: a(n) &#x3D; (&#x2F; 2,5,7,9,10,11,13,17,21,23 &#x2F;)</span><br><span class="line">    integer key</span><br><span class="line">    integer loc</span><br><span class="line">    integer, external :: binary_search</span><br><span class="line">    </span><br><span class="line">    write(*, &quot;(&#39;Source&#x3D;&gt;&#39;, 10i3)&quot;) A</span><br><span class="line">    write(*,*) &#39;Input Key:&#39;</span><br><span class="line">    read(*,*) key</span><br><span class="line">    !调用二元搜索的子程序</span><br><span class="line">    loc &#x3D; binary_search(a,n,key)</span><br><span class="line">    if(loc&#x2F;&#x3D;0) then</span><br><span class="line">        write(*, &quot;(&#39;A(&#39;,i2,&#39; )&#x3D;&#39;i3)&quot;) loc, key</span><br><span class="line">    else</span><br><span class="line">        write(*,*) &quot;Not found&quot;</span><br><span class="line">    end if</span><br><span class="line">    stop</span><br><span class="line">end program</span><br><span class="line"></span><br><span class="line">! 二元搜索法的子程序</span><br><span class="line"></span><br><span class="line">integer function Binary_Search(a,n,key)</span><br><span class="line">    implicit none</span><br><span class="line">    integer n,a(n)</span><br><span class="line">    integer key   ! 所要寻找的值</span><br><span class="line">    integer l     ! 记录每一个小组的数组起始位置</span><br><span class="line">    integer r     ! 记录每一个小组的数组结束位置</span><br><span class="line">    integer m     ! 记录每一个小组的数组开始位置</span><br><span class="line">    </span><br><span class="line">    ! 一开始的小组范围就是整个数组</span><br><span class="line">    l&#x3D;1</span><br><span class="line">    r&#x3D;n</span><br><span class="line">    m&#x3D;(l+r)&#x2F;2 ! 7&#x2F;2 &#x3D; 3</span><br><span class="line">    </span><br><span class="line">    ! 如果 key 值超出范围，肯定不存在数组中</span><br><span class="line">    if((key &lt; a(l)) .or. (key &gt; a(r))) then</span><br><span class="line">        binary_search &#x3D; 0</span><br><span class="line">        return</span><br><span class="line">    end if</span><br><span class="line">    </span><br><span class="line">    do while(l &lt;&#x3D; r)</span><br><span class="line">        if(key &gt; a(m)) then</span><br><span class="line">            ! 如果 key &gt; 中间值，那就落在后半段</span><br><span class="line">            L &#x3D; M+1</span><br><span class="line">            M &#x3D; (L+R)&#x2F;2</span><br><span class="line">        else if(key &lt; a(m)) then</span><br><span class="line">            ! 如果 key &lt; 中间值，那就落在前半段</span><br><span class="line">            r &#x3D; M -1</span><br><span class="line">            m &#x3D; (l+r)&#x2F;2</span><br><span class="line">        else if(key &#x3D;&#x3D;  a(m)) then</span><br><span class="line">            binary_search &#x3D; m</span><br><span class="line">            return</span><br><span class="line">        end if</span><br><span class="line">    end do</span><br><span class="line">    </span><br><span class="line">    !如果前面都没有找到，返回0</span><br><span class="line">    binary_search &#x3D; 0</span><br><span class="line">    return</span><br><span class="line">end function</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">Source=&gt;  <span class="number">2</span>  <span class="number">5</span>  <span class="number">7</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">13</span> <span class="number">17</span> <span class="number">21</span> <span class="number">23</span></span><br><span class="line"> Input Key:</span><br><span class="line"><span class="number">10</span></span><br><span class="line">A( <span class="number">5</span> )= <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h3 id="15-2-3-散列搜索（Hashing）">15-2-3 散列搜索（Hashing）</h3>
<p>这个算法光听名字实在是很难去想象它的作法。散列法的搜索效率很高，如果安排恰当，它几乎每次都只需要做一次对比操作，就可以判断数据是否存在。它主要的精力是放在如何安排数据在内存的位置。将数据安排好之后，搜索数据时只要计算它可能在内存的位置，直接与这个位置上的数据来做对比。</p>
<p>散列搜索法主要在于它的概念，并没有一定的实现方法。任何人都可以自行设计散列公式来计算数据要如何放在数组中。</p>
<p>直接来看一个实例，假如要在 {21,53,71,19,61,81,3,17,44,93} 这一组数字中搜索数据。首先要定义出一个散列公式来决定数据要如何安置。观察这一组数字后，可以发现它们的值域范围在0~100之间，所以可以声明一个大小为100的数组，而且可以使用最简单的方法来决定数据在 array 中的位置，就是直接把数值D放在 array(D) 中。用数学方法来解释这个散列函数，即为 <code>hash(D) = D</code>。</p>
<p>在搜索时，找到K值在数组中的位置，再比较 array(K)  的值是否等于 K 。如果相等就代表搜索成功，如果不相等就代表数据不存在。因此只要比对一次就能确定数据在不在。</p>
<p>程序实现如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">! 散列搜索法示例</span></span><br><span class="line"><span class="comment">! By Perng 1997/8/31</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> Hash_Search_Demo</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n = <span class="number">10</span> </span><br><span class="line">    <span class="keyword">integer</span> Source(n) <span class="comment">! 存放数据组的数组</span></span><br><span class="line">    <span class="keyword">integer</span> A(<span class="number">100</span>)    <span class="comment">! 存放 Hashing 后的数组</span></span><br><span class="line">    <span class="keyword">integer</span> key       <span class="comment">! 记录所要找的值</span></span><br><span class="line">    <span class="keyword">integer</span> i         <span class="comment">! 循环计数器</span></span><br><span class="line">    <span class="keyword">data</span> Source /<span class="number">21</span>,<span class="number">53</span>,<span class="number">71</span>,<span class="number">19</span>,<span class="number">61</span>,<span class="number">81</span>,<span class="number">3</span>,<span class="number">17</span>,<span class="number">44</span>,<span class="number">93</span>/</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source=&gt;&#x27;, 10i3)&quot;</span>) Source</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;Input Key:&#x27;</span></span><br><span class="line">    read(*,*) key</span><br><span class="line">    <span class="keyword">if</span> (key &lt;<span class="number">0</span> .or. key&gt;<span class="number">100</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;Not found&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 创建Hash 表格，表格中放的是数值在数组中的位置</span></span><br><span class="line">    A = <span class="number">0</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">        A(Source(i)) = i</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 在 Hash 表格中寻找数据</span></span><br><span class="line">    <span class="keyword">if</span>(A(key) /= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source(&#x27;,i2,&#x27; )=&#x27;,i3)&quot;</span>) A(key), key</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;Not found&quot;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的散列方法，使用大小为100的数组来存放10个数字。使用比较大的数组来存放数据会比较容易设计散列函数 hash(K)，比较不易发生当 a 不等于 b 时 hash(a) = hash(b) 的现象，可以得到比较好的搜索效率。（hash(a), hash(b) 指的是a,b 在数组中的位置，这个意思就是说不会出现两个不同的值执行同一个内存位置的情况）。</p>
<p>再来看一个新的散列方法，同样用上一个实例中的数据组来做搜索。上一个实例程序只使用了 10% 的数组空间，有 90% 是浪费掉的。这一次不会再浪费那么多内存空间，而是把散列的数据放在大小为10的数组来充方利用内存。散列函数必须重新设计，才能符合新的数组大小。</p>
<p>这一次可以定义 <code>hash(K) = K/10+1</code> ，也就是取出数字的10位数，再加上 1 来当做它在数组中的位置。不过这个方法会发生一个问题，因为<strong>它对不同数字很有可能算出同样的结果来</strong>，例如 hash(11) = hash(12) = 2 。对这个情况要做一些例外处理，可以加上一个条件：如果所要使用的位置已经被其他数字占据，就向后挪一步。</p>
<p>要搜索时，同样先由 L = hash(K) = K/10 + 1 来计算数据位置，但是如果 array(L) 不等于 K 时，并不代表 K 不存在，还要向后一个个来做检查，一直到全部数据都检查过为止。（这也太低效了吧）</p>
<p>实现程序如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">! 散列搜索法示例</span></span><br><span class="line"><span class="comment">! by perng 1997/8/31</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> hashing_search_demo</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n = <span class="number">10</span></span><br><span class="line">    <span class="keyword">integer</span> source(n) <span class="comment">! 存放数据组的数组</span></span><br><span class="line">    <span class="keyword">integer</span> a(n)      <span class="comment">! 存放hashing 后的数组</span></span><br><span class="line">    <span class="keyword">integer</span> key       </span><br><span class="line">    <span class="keyword">integer</span> i</span><br><span class="line">    <span class="keyword">integer</span> loc</span><br><span class="line">    <span class="keyword">data</span> Source /<span class="number">21</span>,<span class="number">53</span>,<span class="number">71</span>,<span class="number">19</span>,<span class="number">61</span>,<span class="number">81</span>,<span class="number">3</span>,<span class="number">17</span>,<span class="number">44</span>,<span class="number">93</span>/</span><br><span class="line">    <span class="keyword">integer</span> hash</span><br><span class="line">    hash(key) = key/<span class="number">10</span> + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source=&gt;&#x27;, 10i3)&quot;</span>) Source</span><br><span class="line">    </span><br><span class="line">    a=<span class="number">0</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">        loc = hash(source(i))</span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">            <span class="keyword">if</span>(a(loc)==<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">                a(loc) = i</span><br><span class="line">                <span class="keyword">exit</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loc = loc + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span>(loc&gt;n) loc = <span class="number">1</span> <span class="comment">!如果loc超出最大值就设为1，再从头循环一遍，反正得放进去</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;Input Key:&#x27;</span></span><br><span class="line">    read(*,*) key</span><br><span class="line">    </span><br><span class="line">    loc = hash(key)</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">        <span class="keyword">if</span>(a(loc)==<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;Not found&quot;</span></span><br><span class="line">            <span class="keyword">exit</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (source(a(loc)) == key) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source(&#x27;,i2,&#x27; )=&#x27;,i3)&quot;</span>) a(loc), key</span><br><span class="line">            <span class="keyword">exit</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            loc = loc + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span>(loc&gt;n) loc = <span class="number">1</span> <span class="comment">!这就是10个数据全部检查一遍</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment">!注意，这里循环结束后，i是11，不是10。所以这里才判断 i&gt;n</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;n) <span class="built_in">write</span>(*,*) <span class="string">&quot;Not found&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里由一个细节，就是 do 循环之后，i 最终的结果是11，而不是10。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!注意，这里循环结束后，i是11，不是10。所以这里才判断 i&gt;n</span></span><br><span class="line"><span class="keyword">if</span>(i&gt;n) <span class="built_in">write</span>(*,*) <span class="string">&quot;Not found&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面这个方法不算是很有效率的方法。如果所要搜索的数据不存在，要扫描整个数组才能确认这个事实。这主要归咎于散列表格太小，而不是散列法的缺点。如果配合上串行结构来存放数据，可以得到比较好的效率。</p>
<p>现在来示例针对这个散列法所设计的串行结构。在这里使用同样的散列函数 hash(x) = x/10 + 1，hash(x) 的值在1~10之间，所以可以用 10个串行来保存所有数值。这个方法所创建的串行结构如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hash(x)&#x3D;1 的串行：&#x3D;&gt;3</span><br><span class="line">hash(x)&#x3D;2 的串行：&#x3D;&gt;19&#x3D;&gt;17</span><br><span class="line">hash(x)&#x3D;3 的串行：&#x3D;&gt;21</span><br><span class="line">hash(x)&#x3D;4 的串行：没有东西</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>搜索时只要在所属的串行中来搜索即可，不需要跨越到其他的串行中。不必等到扫描整个数据后，才能确认数据不存在。实现的程序如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> NumLink</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n =<span class="number">10</span></span><br><span class="line">    <span class="comment">! 声明制作串行的类型</span></span><br><span class="line">    <span class="keyword">type</span> :: link</span><br><span class="line">        <span class="keyword">integer</span> :: num               <span class="comment">! 保存数据组</span></span><br><span class="line">        <span class="keyword">type</span>(link), <span class="keyword">pointer</span> :: next  <span class="comment">! 指向下一个环结的指针</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">type</span>(link), <span class="keyword">target</span> :: linking(n) <span class="comment">! 保存hashing后的数据</span></span><br><span class="line">    <span class="keyword">type</span>(link), <span class="keyword">pointer</span> :: proc      <span class="comment">! 暂时使用的指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">integer</span> :: Source(n) = (/<span class="number">21</span>,<span class="number">53</span>,<span class="number">71</span>,<span class="number">19</span>,<span class="number">61</span>,<span class="number">81</span>,<span class="number">3</span>,<span class="number">17</span>,<span class="number">44</span>,<span class="number">93</span>/)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> InitLink()</span><br><span class="line">        <span class="keyword">integer</span> i</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">            linking(i) = link(<span class="number">0</span>,null())</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">! hash函数</span></span><br><span class="line">    <span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> hash(key)</span><br><span class="line">        <span class="keyword">integer</span> key</span><br><span class="line">        hash = key/<span class="number">10</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 把数字经过散列处理后放入串行的子程序</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Insert(key, info)</span><br><span class="line">        <span class="keyword">integer</span> :: key, info <span class="comment">! 所要插入的数字及在 Source中的位置</span></span><br><span class="line">        <span class="keyword">integer</span> :: L         <span class="comment">! hashing 后的结果</span></span><br><span class="line">        </span><br><span class="line">        L = hash(key)</span><br><span class="line">        proc=&gt;linking(L) <span class="comment">! 把proc指向数组linking中hash(L)的位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">! 移动到串行中的最后一个位置</span></span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(proc%num /= <span class="number">0</span>)</span><br><span class="line">            proc =&gt; proc%next</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        </span><br><span class="line">        proc%num = INFO</span><br><span class="line">        <span class="comment">! 配置内存空间给 proc%next</span></span><br><span class="line">        <span class="built_in">allocate</span>(proc%next)</span><br><span class="line">        proc =&gt; proc%next</span><br><span class="line">        proc%num = <span class="number">0</span></span><br><span class="line">        <span class="built_in">nullify</span>(proc%next)</span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 在串行中搜索数据的子程序</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Hash_Search(key)</span><br><span class="line">        <span class="keyword">integer</span> :: key  <span class="comment">! 要搜索的值</span></span><br><span class="line">        <span class="keyword">integer</span> :: L    <span class="comment">! 计算hashing后的值</span></span><br><span class="line">        </span><br><span class="line">        L = hash(key)</span><br><span class="line">        proc =&gt; linking(L) <span class="comment">! 把proc指向数组linking中 hash(L)的位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">! 在这一个串行中一直向下顺序搜索到找到为止</span></span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">            <span class="keyword">if</span>(proc%num == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">write</span>(*,*) <span class="string">&quot;Not found&quot;</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line">            <span class="keyword">if</span>(Source(proc%num)==key) <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source(&#x27;,i2,&#x27; )=&#x27;,i3)&quot;</span>) proc%num, key</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">associated</span>(proc%next)) proc = proc%next</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 输出串行中数据的子程序</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> OutputLink()</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">            proc =&gt; linking(i)</span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(1x,i2,&#x27;:&#x27;)&quot;</span>, <span class="keyword">advance</span> = <span class="string">&quot;NO&quot;</span>) i</span><br><span class="line">            <span class="keyword">do</span> <span class="keyword">while</span>(<span class="built_in">associated</span>(proc%next))</span><br><span class="line">                <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;-&gt;&#x27;,i2)&quot;</span>, <span class="keyword">advance</span> = <span class="string">&quot;NO&quot;</span>) Source(proc%num)</span><br><span class="line">                proc =&gt; proc%next</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="comment">! ?</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="comment">! 散列搜索法举例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> hashing_search_demo</span><br><span class="line">    <span class="keyword">use</span> NumLink</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: key <span class="comment">! 记录要找的值</span></span><br><span class="line">    <span class="keyword">integer</span> :: i   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">call</span> InitLink()</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source=&gt;&#x27;,10i3)&quot;</span>) Source</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">        <span class="keyword">call</span> Insert(Source(i),i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Link List=&gt;&quot;</span></span><br><span class="line">    <span class="keyword">call</span> OutputLink()</span><br><span class="line">    <span class="comment">! 读入要找的值</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;Input Key:&#x27;</span></span><br><span class="line">    read(*,*) key</span><br><span class="line">    <span class="comment">! 调用顺序搜索的子程序</span></span><br><span class="line">    <span class="keyword">call</span> Hash_Search(key)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Source&#x3D;&gt; 21 53 71 19 61 81  3 17 44 93</span><br><span class="line"> Link List&#x3D;&gt;</span><br><span class="line">  1:-&gt; 3  2:-&gt;19-&gt;17  3:-&gt;21  4:  5:-&gt;44  6:-&gt;53  7:-&gt;61  8:-&gt;71  9:-&gt;81 10:-&gt;93</span><br><span class="line"> Input Key:</span><br><span class="line">44</span><br><span class="line">Source( 9 )&#x3D; 44</span><br></pre></td></tr></table></figure>
<p>这个程序还没有仔细看，之后有时间再看一下。</p>
<h2 id="15-3-堆栈-Stack">15-3 堆栈 Stack</h2>
<p>&quot;堆栈&quot;的概念很简单，它可以解决许多程序设计的问题。堆栈是一种管理数据进、出内存的规则，这个规则就是：“越早得到的数据越晚输出，越晚得到的数据越早输出”</p>
<h3 id="15-3-1-堆栈的基本范例">15-3-1 堆栈的基本范例</h3>
<p>根据堆栈 “后到先进” 的策略，可以编写一个实例程序来把所输入的一连串数据反向输出。这个程序的目的只是用来实例堆栈的运行过程，真正应用的过程在下一个小节中才会介绍。</p>
<p>来看程序：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> stack_utility</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">private</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: top = <span class="number">50</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">save</span> :: current = <span class="number">0</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">save</span> :: stack(top)</span><br><span class="line">    <span class="keyword">public</span> push, pop</span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">! 把数据放入堆栈中</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> push(<span class="keyword">value</span>)</span><br><span class="line">        <span class="keyword">integer</span> <span class="keyword">value</span></span><br><span class="line">        <span class="keyword">if</span>(current&gt;top) <span class="keyword">then</span> <span class="comment">!超过容量</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;Stack full.&quot;</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        current = current + <span class="number">1</span></span><br><span class="line">        stack(current) = <span class="keyword">value</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">! 从堆栈中取出数据</span></span><br><span class="line">    <span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> pop(<span class="keyword">value</span>)</span><br><span class="line">        <span class="keyword">integer</span> <span class="keyword">value</span></span><br><span class="line">        <span class="keyword">if</span>(current&lt;=<span class="number">0</span>) <span class="keyword">then</span> <span class="comment">! 已经没有东西可以拿了</span></span><br><span class="line">            pop = <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">value</span> = stack(current)</span><br><span class="line">        current = current - <span class="number">1</span></span><br><span class="line">        pop = <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> stack_utility</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n = <span class="number">5</span></span><br><span class="line">    <span class="keyword">integer</span> :: a(n) = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /)</span><br><span class="line">    <span class="keyword">integer</span> i, stat, <span class="keyword">value</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source=&gt;&#x27;, 5i3)&quot;</span>) a</span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>,n</span><br><span class="line">        <span class="keyword">call</span> push(a(i))</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>,n</span><br><span class="line">        stat = pop(<span class="keyword">value</span>)</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(i3)&quot;</span>, <span class="keyword">advance</span> = <span class="string">&quot;no&quot;</span>) <span class="keyword">value</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">write</span>(*,*)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Source&#x3D;&gt;  1  2  3  4  5</span><br><span class="line">  5  4  3  2  1</span><br></pre></td></tr></table></figure>
<p>这里堆栈数据实际上存放在数组 stack 中，变量 current 用来记录目前堆栈保存情况。这些数据被设置成私有的数据，外部数据不能直接访问它们（但是在module 内部一直在记录 current 的变化）。整个模块中，只有 push 和 pop 这两个函数是对外开发的使用接口。</p>
<p>调用 push 可以把数据放在堆栈的最顶端；调用 pop 则可以从堆栈的最顶端取出一条数据。push 和 pop 都不能无限制调用，当 stack 数组用完时，就不能再 push 数据。而堆栈没有数据时，就不能再调用 pop。</p>
<h3 id="15-3-2-堆栈的应用-骑士走棋盘">15-3-2 堆栈的应用 - 骑士走棋盘</h3>
<p>略</p>
<h2 id="15-4-树状结构">15-4 树状结构</h2>
<p>第10章介绍指针时，已经示范过串行结构的使用，指针还经常使用在另外一种称为树状结构的数据结构。被称为树状结构的原因在于，树状结构的链接情况换成图形时，会出现如同树枝状的结构来。</p>
<p>本节介绍二叉树的应用（<strong>二叉树指每一层的分枝都是两个枝干</strong>）。在这里示范应用二叉树来做排序及搜索的方法，二叉树的创建格式为，<strong>左枝所保存的数值，永远都小于跟它对称的右枝所保存的数值</strong>。以这种方式所创建的二叉树，可以很容易地来做数据搜索。从最上端开始来对比，如果要寻找的数据大于目前的树枝中所保存的数值，那么数据一定是落在右枝。如果是小于的话，那就是落在左枝。以这个方法可以很快速地由上而下寻找数据。</p>
<p>二叉树创建后，数据也等于完成“排序” 工作。经过特定的规则来取出二叉树数据，就可以达到排序的效果。以这个例子来看，只要先取出较小，而且较左边枝干中所保存的数值，就可以把数据由小到大来排序。</p>
<p>现在就来实现一个建构二叉树的实例，这个实例示例了如何使用二叉树来记录数据，并且同时完成排序。程序代码有点长，建议读者先翻到后面的程序说明解说部分来阅读，再回过头来看整个程序。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">! 二叉树排序范例</span></span><br><span class="line"><span class="keyword">module</span> typedef </span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> :: <span class="keyword">data</span></span><br><span class="line">        <span class="keyword">integer</span> :: n      <span class="comment">! 存放的数据</span></span><br><span class="line">        <span class="keyword">integer</span> :: <span class="built_in">repeat</span> <span class="comment">! 数据重复的次数</span></span><br><span class="line">        <span class="keyword">type</span>(<span class="keyword">data</span>), <span class="keyword">pointer</span> :: left  <span class="comment">! 左枝</span></span><br><span class="line">        <span class="keyword">type</span>(<span class="keyword">data</span>), <span class="keyword">pointer</span> :: right <span class="comment">! 右枝</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> bin_tree</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">private</span></span><br><span class="line">    <span class="keyword">type</span>(<span class="keyword">data</span>), <span class="keyword">pointer</span> :: tree, <span class="keyword">action</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">save</span> :: numbers = <span class="number">0</span></span><br><span class="line">    <span class="keyword">public</span> add, TraceTree</span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">! 新加入一条数据</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> add(n)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span>, <span class="keyword">intent</span>(<span class="keyword">in</span>) :: n</span><br><span class="line">        <span class="keyword">integer</span> :: err</span><br><span class="line">        <span class="keyword">type</span>(<span class="keyword">data</span>), <span class="keyword">pointer</span> :: new</span><br><span class="line">        <span class="keyword">integer</span> :: level</span><br><span class="line">        level = <span class="number">1</span></span><br><span class="line">        numbers = numbers+<span class="number">1</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a5,i4,a8)&quot;</span>) <span class="string">&quot;Get :&quot;</span>,numbers,<span class="string">&quot; numbers&quot;</span></span><br><span class="line">        <span class="comment">! 配置一块新的空间</span></span><br><span class="line">        <span class="built_in">allocate</span>(new, stat=err)</span><br><span class="line">        <span class="keyword">if</span>(err/=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;Out of memory!&quot;</span></span><br><span class="line">            <span class="keyword">stop</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;root &#x27;)&quot;</span>, <span class="keyword">advance</span> = <span class="string">&quot;no&quot;</span>)</span><br><span class="line">        <span class="comment">! 设置数据</span></span><br><span class="line">        new%<span class="built_in">repeat</span> = <span class="number">1</span></span><br><span class="line">        new%n = n</span><br><span class="line">        <span class="built_in">nullify</span>(new%right, new%left)</span><br><span class="line">        <span class="comment">! 如果是第一条数据</span></span><br><span class="line">        <span class="keyword">if</span>(numbers==<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">action</span> =&gt; new</span><br><span class="line">            tree =&gt; new</span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;: new&#x27;)&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">action</span> =&gt; tree</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">            level = level + <span class="number">1</span></span><br><span class="line">            <span class="comment">! 数据大于目前的枝干的数值时</span></span><br><span class="line">            <span class="keyword">if</span>(n&gt;<span class="keyword">action</span>%n) <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">associated</span>(<span class="keyword">action</span>%right)) <span class="keyword">then</span></span><br><span class="line">                    <span class="keyword">action</span> =&gt; <span class="keyword">action</span>%right <span class="comment">! 再向右去寻找立身处</span></span><br><span class="line">                    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;-&gt;R&#x27;)&quot;</span>, <span class="keyword">advance</span> = <span class="string">&quot;no&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">action</span>%right =&gt; new <span class="comment">!创建新的右枝</span></span><br><span class="line">                    <span class="keyword">action</span> =&gt; new</span><br><span class="line">                    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;-&gt;R: new&#x27;)&quot;</span>)</span><br><span class="line">                    <span class="keyword">exit</span> </span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">            <span class="comment">! 数据小于目前枝干的数值时</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;<span class="keyword">action</span>%n) <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">associated</span>(<span class="keyword">action</span>%left)) <span class="keyword">then</span></span><br><span class="line">                    <span class="keyword">action</span> =&gt; <span class="keyword">action</span>%left <span class="comment">! 再向左去寻找立身处</span></span><br><span class="line">                    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;-&gt;L&#x27;)&quot;</span>, <span class="keyword">advance</span> = <span class="string">&quot;no&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">action</span>%left =&gt; new <span class="comment">!创建新的左枝</span></span><br><span class="line">                    <span class="keyword">action</span> =&gt; new</span><br><span class="line">                    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;-&gt;L: new&#x27;)&quot;</span>)</span><br><span class="line">                    <span class="keyword">exit</span> </span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">            <span class="comment">! 数据等于目前枝干的数值时</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="keyword">action</span>%n) <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">action</span>%<span class="built_in">repeat</span> = <span class="keyword">action</span>%<span class="built_in">repeat</span> + <span class="number">1</span> <span class="comment">! 把重复的数目加1</span></span><br><span class="line">                <span class="built_in">deallocate</span>(new) <span class="comment">! 可以不需要找个新的空间</span></span><br><span class="line">                <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;: Repeat&#x27;)&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> add</span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 显示排序的数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> TraceTree()</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">call</span> show_tree(tree)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 排序数据的子程序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">recursive</span> <span class="function"><span class="keyword">subroutine</span></span> show_tree(show)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(<span class="keyword">data</span>), <span class="keyword">pointer</span> :: show</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">associated</span>(show)) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">call</span> show_tree(show%left) <span class="comment">! 先取出左枝的数据</span></span><br><span class="line">            <span class="keyword">call</span> show_data(show) <span class="comment">! 再取出目前位置的数据</span></span><br><span class="line">            <span class="keyword">call</span> show_tree(show%right) <span class="comment">! 最后才取出右枝的数据</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 显示这个枝干所保存的数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> show_data(show)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(<span class="keyword">data</span>), <span class="keyword">pointer</span> :: show</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>, show%<span class="built_in">repeat</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) show%n</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span> bin_tree</span><br><span class="line"></span><br><span class="line"><span class="comment">! 主程序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main </span><br><span class="line">    <span class="keyword">use</span> bin_tree</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> num </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;请输入整数，输入0代表结束&quot;</span></span><br><span class="line">        read(*,*) num</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        <span class="keyword">call</span> add(num)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">call</span> TraceTree()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> 请输入整数，输入<span class="number">0</span>代表结束</span><br><span class="line"><span class="number">4</span></span><br><span class="line"> Get :   <span class="number">1</span> numbers</span><br><span class="line">root : new</span><br><span class="line"> 请输入整数，输入<span class="number">0</span>代表结束</span><br><span class="line"><span class="number">6</span></span><br><span class="line"> Get :   <span class="number">2</span> numbers</span><br><span class="line">root -&gt;R: new</span><br><span class="line"> 请输入整数，输入<span class="number">0</span>代表结束</span><br><span class="line"><span class="number">2</span></span><br><span class="line"> Get :   <span class="number">3</span> numbers</span><br><span class="line">root -&gt;L: new</span><br><span class="line"> 请输入整数，输入<span class="number">0</span>代表结束</span><br><span class="line"><span class="number">7</span></span><br><span class="line"> Get :   <span class="number">4</span> numbers</span><br><span class="line">root -&gt;R-&gt;R: new</span><br><span class="line"> 请输入整数，输入<span class="number">0</span>代表结束</span><br><span class="line"><span class="number">3</span></span><br><span class="line"> Get :   <span class="number">5</span> numbers</span><br><span class="line">root -&gt;L-&gt;R: new</span><br><span class="line"> 请输入整数，输入<span class="number">0</span>代表结束</span><br><span class="line"><span class="number">5</span></span><br><span class="line"> Get :   <span class="number">6</span> numbers</span><br><span class="line">root -&gt;R-&gt;L: new</span><br><span class="line"> 请输入整数，输入<span class="number">0</span>代表结束</span><br><span class="line"><span class="number">1</span></span><br><span class="line"> Get :   <span class="number">7</span> numbers</span><br><span class="line">root -&gt;L-&gt;L: new</span><br><span class="line"> 请输入整数，输入<span class="number">0</span>代表结束</span><br><span class="line"><span class="number">0</span></span><br><span class="line">           <span class="number">1</span></span><br><span class="line">           <span class="number">2</span></span><br><span class="line">           <span class="number">3</span></span><br><span class="line">           <span class="number">4</span></span><br><span class="line">           <span class="number">5</span></span><br><span class="line">           <span class="number">6</span></span><br><span class="line">           <span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序可以让用户输入一组整数，程序执行时还会同时显示树枝的“生长”情况。输入数字0会结束数据的输入，并把所输入的整数数列由小到大来输出。</p>
<p>程序使用二叉树来保存、同时排序所输入的数据。假如输入了下面的整数数列 [4,6,2,7,3,5,1]。输入第一个数字时，二叉树只有“根”的部分存在，所以整数4会放在二叉树的树根部分。输入第2个数字时，会去比较二叉树树根所保存的数值，如果结果是“大于”，就会向右边生成一根新的树干，并保存这个新的数值；如果结果是“小于”，则会向左边开发。程序会一直重复这个操作，生长处越来越密的枝干，而比较的层次也会一层层地向越小地枝干延申下去。</p>
<p>后面的解析和代码还没仔细看，以后再看。</p>
<h1>16 IMSL 函数库</h1>
<p>数值方法中常遇到的问题，有专门的链接库可以使用。IMSL 是一套在数值方法上经常被使用的商业链接库。</p>
<p><strong>有现成的函数可以使用，不代表程序员不需要学习自行编写数值方法程序的技巧。因为只有了解这些算法的真正运行过程，才能适当地去使用它们。</strong></p>
<p>IMSL 的函数名称中，第1个字母可以用来判断参数的类型。如果第1个字母是D，会使用双精度浮点数来计算并返回答案。第一个字母不是D，则使用单精度浮点数。</p>
<p>因为 IMSL 的函数太多了，在这一章中不会完整介绍所有函数的详细用法。本书会介绍处理线性系统、非线性系统、微积分、微分方程、插值时会使用到的基本功能。</p>
<p>略。</p>
<h1>17 附录</h1>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>Fortran</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>Fortran</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建个人博客</title>
    <url>/posts/c442673f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>我这个个人博客第一次建立应该是在2019年，当时网页外表比较简陋，内容也不多，之后一直也没怎么更新。最近重新搭建了一次，网页的外在部分都改了，这个就是这次我重建博客的全过程记录。</p>
<p>搭建个人博客的过程还是有意思的，虽然我对于设计网页的这些语言并不了解，往往一个问题或需求可以卡几天，但是最终解决了还是会有成就感的。</p>
<p>最后感谢我现在的女朋友，为了想在见面前把这个网页建好，作为送给她的礼物，我才有足够的动机。不然这事完成的时间可能还得靠后。</p>
<span id="more"></span>
<h1>1 搭建个人博客-基础篇</h1>
<p>B站视频：<a href="https://www.bilibili.com/video/BV1Yb411a7ty">https://www.bilibili.com/video/BV1Yb411a7ty</a></p>
<p>hexo 官网文档：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p>
<p>跟着这个视频就应该没有太大的问题，很详细</p>
<h2 id="1-1-安装-node-js-和-git">1.1 安装 node.js 和 git</h2>
<p>我也不知道node.js 是啥，安装就完事了。</p>
<p>下载地址：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></p>
<p>选择“长期支持版”，下载后一直下一步下一步就行。</p>
<p>安装后会自带一个什么 npm，这也是安装博客必须的。</p>
<p>下载git: <a href="https://git-scm.com/">https://git-scm.com/</a></p>
<h2 id="1-2-安装hexo-windows-系统">1.2 安装hexo - windows 系统</h2>
<p>由于我是用个人电脑安装的，是windows系统，和视频不太一样，下面是我用的命令。</p>
<p><strong>管理员身份进入 cmd</strong> , 之后查看node版本和npm版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">node -v</span></span><br><span class="line">v14.16.0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">npm -v</span></span><br><span class="line">6.14.11</span><br></pre></td></tr></table></figure>
<p>因为npm速度很慢，利用npm安装cnpm（淘宝的版本）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>安装后检查</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;cnpm -v</span><br><span class="line">cnpm@6.1.1 (C:\Users\zhou\AppData\Roaming\npm\node_modules\cnpm\lib\parse_argv.js)</span><br><span class="line">npm@6.14.11 (C:\Users\zhou\AppData\Roaming\npm\node_modules\cnpm\node_modules\npm\lib\npm.js)</span><br><span class="line">node@14.16.0 (C:\Program Files\nodejs\node.exe)</span><br><span class="line">npminstall@3.28.0 (C:\Users\zhou\AppData\Roaming\npm\node_modules\cnpm\node_modules\npminstall\lib\index.js)</span><br><span class="line">prefix&#x3D;C:\Users\zhou\AppData\Roaming\npm</span><br><span class="line">win32 x64 10.0.19041</span><br><span class="line">registry&#x3D;https:&#x2F;&#x2F;r.npm.taobao.org</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用cnpm, 安装 hexo 框架</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>验证hexo是否安装完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;hexo -v</span><br><span class="line">hexo-cli: 4.2.0</span><br><span class="line">os: Windows_NT 10.0.19041 win32 x64</span><br><span class="line">node: 14.16.0</span><br><span class="line">v8: 8.4.371.19-node.18</span><br><span class="line">uv: 1.40.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.9</span><br><span class="line">ares: 1.16.1</span><br><span class="line">modules: 83</span><br><span class="line">nghttp2: 1.41.0</span><br><span class="line">napi: 7</span><br><span class="line">llhttp: 2.1.3</span><br><span class="line">openssl: 1.1.1j</span><br><span class="line">cldr: 37.0</span><br><span class="line">icu: 67.1</span><br><span class="line">tz: 2020a</span><br><span class="line">unicode: 13.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1-3-使用hexo搭建博客">1.3 使用hexo搭建博客</h2>
<p>切换目录，创建blog目录并进入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;d:</span><br><span class="line">&gt;cd desktop</span><br><span class="line">&gt;mkdir blog</span><br><span class="line">&gt;cd blog</span><br></pre></td></tr></table></figure>
<p>初始化博客</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;hexo init</span><br><span class="line">INFO  Cloning hexo-starter https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo-starter.git</span><br><span class="line">[32mINFO [39m Install dependencies</span><br><span class="line">added 190 packages from 159 contributors and audited 196 packages in 115.851s</span><br><span class="line"></span><br><span class="line">15 packages are looking for funding</span><br><span class="line">  run &#96;npm fund&#96; for details</span><br><span class="line"></span><br><span class="line">found 0 vulnerabilities</span><br><span class="line"></span><br><span class="line">INFO  Start blogging with Hexo!</span><br></pre></td></tr></table></figure>
<p>最后显示了，可以开始用 Hexo 写博客了。</p>
<p>启动博客，就是 hexo s（server 的缩写），平常就是在本地做预览用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;hexo s</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">Deprecated as of 10.7.0. highlight(lang, code, ...args) has been deprecated.</span><br><span class="line">Deprecated as of 10.7.0. Please use highlight(code, options) instead.</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;highlightjs&#x2F;highlight.js&#x2F;issues&#x2F;2277</span><br><span class="line">Deprecated as of 10.7.0. highlight(lang, code, ...args) has been deprecated.</span><br><span class="line">Deprecated as of 10.7.0. Please use highlight(code, options) instead.</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;highlightjs&#x2F;highlight.js&#x2F;issues&#x2F;2277</span><br><span class="line">Deprecated as of 10.7.0. highlight(lang, code, ...args) has been deprecated.</span><br><span class="line">Deprecated as of 10.7.0. Please use highlight(code, options) instead.</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;highlightjs&#x2F;highlight.js&#x2F;issues&#x2F;2277</span><br><span class="line">Deprecated as of 10.7.0. highlight(lang, code, ...args) has been deprecated.</span><br><span class="line">Deprecated as of 10.7.0. Please use highlight(code, options) instead.</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;highlightjs&#x2F;highlight.js&#x2F;issues&#x2F;2277</span><br><span class="line">INFO  Hexo is running at http:&#x2F;&#x2F;localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<p>就会在本地的4000端口启动。</p>
<p>在浏览器输入 <code>http://localhost:4000/</code> 看看。</p>
<p>然后可以输入 ctrl + c 断开。</p>
<h2 id="1-4-新建博客">1.4 新建博客</h2>
<p>使用 hexo new (简写为n) 命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;title&quot;</span><br></pre></td></tr></table></figure>
<p>然后在 source/_posts 目录下就有了新建的md文件</p>
<p>在cmd中，当前目录为blog目录下。先清理一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<p>这个命令hexo官网的说法如下：</p>
<blockquote>
<p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p>
<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
</blockquote>
<p>貌似这个清理的命令可以不用每次都输入，只是在输入命令后网页没有改变，才需要清理。从网上看，确实如此。</p>
<blockquote>
<p>#清除缓存，若是网页正常情况下可以忽略这条命令</p>
</blockquote>
<p>然后，生成静态文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>然后再启动一下，看看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<h2 id="1-5-hexo-官方配置">1.5 hexo 官方配置</h2>
<p>这里的配置指的是根目录下的 <strong>_config.yml</strong> 文件的设置</p>
<p>直接看官网资料即可，官网还有小视频。</p>
<p><a href="https://hexo.io/docs">https://hexo.io/docs</a></p>
<h3 id="网站-site">网站 (site)</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">VincereZhou&#x27;s</span> <span class="string">blog</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line"><span class="attr">description:</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Vincere</span> <span class="string">Zhou</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li><strong>title</strong> : 标题</li>
<li><strong>language</strong> :  网站使用的语言。简体中文常见的有 <code>zh-Hans</code>和 <code>zh-CN</code>。（我也搞不清楚这两个区别）</li>
<li><strong>timezone</strong> :  网站时区。中国大陆地区使用 <code>Asia/Shanghai</code>。</li>
</ul>
<p>其他的都不需要。</p>
<h3 id="网址-URL">网址 (URL)</h3>
<p><strong>全部不需要设置</strong>。</p>
<p>其中有一个 <code>permalink</code> ，用来设置文章的<strong>永久链接</strong>格式。每篇文章的网址默认是 <strong>年/月/日/文章名称</strong>。这个也不用改了，如果改了可能会出问题。</p>
<p>下面是我之前的一篇博客的默认网址，后面的乱码其实是文章名称，由于含有中文复制下来就成这样了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;vincere.fun&#x2F;2020&#x2F;01&#x2F;10&#x2F;%E5%8F%8D%E7%BB%8F-%E7%AC%AC%E5%85%AB%E5%8D%B7%E6%9D%82%E8%AF%B4-%E9%92%93%E6%83%85&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="目录-Directory">目录 (Directory)</h3>
<p>全部不需要设置。</p>
<h3 id="文章-Writing">文章 (Writing)</h3>
<h4 id="本地图片插入">本地图片插入</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>使用相对路径插入图片。</p>
<p>Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](image.jpg)</span><br></pre></td></tr></table></figure>
<p>上述是markdown的引用方式，图片只能在文章中显示，但无法在首页中正常显示。</p>
<p>如果希望图片在文章和首页中同时显示，可以使用标签插件语法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img image.jpg This is an image %&#125;</span><br></pre></td></tr></table></figure>
<p>我就是不太清楚，例子里的<code>This is an image</code> 是啥，图片标题？</p>
<p>但是我不用在首页显示图片，所以我用不到这种写法。</p>
<h3 id="分类-标签-Category-Tag">分类 &amp; 标签 (Category &amp; Tag)</h3>
<p>全部不需要设置。</p>
<h3 id="日期-时间格式-Date-Time-format">日期 / 时间格式 (Date / Time format)</h3>
<p>全部不需要设置。</p>
<h3 id="分页-Pagination">分页 (Pagination)</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">per_page:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>每页显示的文章量 (0 = 关闭分页功能)</p>
<h3 id="扩展-Extensions">扩展 (Extensions)</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">ayer</span></span><br></pre></td></tr></table></figure>
<p>当前主题名称。</p>
<h3 id="部署-Deployment">部署 (Deployment)</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="comment"># repo: https://github.com/VincereZhou/VincereZhou.github.io.git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:VincereZhou/VincereZhou.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表示连接上 Github</p>
<h2 id="1-6-hexo命令总结">1.6 hexo命令总结</h2>
<h4 id="常用命令">常用命令</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">hexo</span> <span class="string">new</span> <span class="string">&quot;title&quot;</span> <span class="comment"># 生成新文章</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">generate</span>    <span class="comment"># 生成静态文件          </span></span><br><span class="line"><span class="string">hexo</span> <span class="string">generate</span> <span class="string">-d</span> <span class="comment"># 生成静态文件，同时推到远端</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">server</span>      <span class="comment"># 本地查看</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">deploy</span>      <span class="comment"># 推到远端</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">clean</span>       <span class="comment"># 清楚缓存文件</span></span><br></pre></td></tr></table></figure>
<h4 id="选项">选项</h4>
<p>选项的意思是所有的命令都能携带。</p>
<p>可能用到的选项有两个：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">hexo</span> <span class="string">--safe</span></span><br></pre></td></tr></table></figure>
<p>在<strong>安全模式</strong>下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">hexo</span> <span class="string">--silent</span></span><br></pre></td></tr></table></figure>
<p>简洁模式，隐藏终端信息。</p>
<p>这个简洁模式什么都不会打印出来，但是我担心报错会不会正常显示。</p>
<h2 id="1-7-小技巧">1.7 小技巧</h2>
<h3 id="文章截断">文章截断</h3>
<p>文章截断指在主页那不显示全部的文章内容（因为内容太长了），只显示文章开头的一部分（就类似于只显示摘要）。这样如果读者可以方便地翻阅所有的文章，遇到有兴趣的就点进去看。</p>
<p><a href="https://hopefulnick.github.io/2018/04/01/180401Hexo%E6%96%87%E7%AB%A0%E6%88%AA%E6%96%AD/">https://hopefulnick.github.io/2018/04/01/180401Hexo文章截断/</a></p>
<p>推荐使用在文章中使用<code>&lt;!-- more --&gt;</code>手动进行截断</p>
<h1>2 部署到github</h1>
<p>如果不部署到github，那么你只能在本地上看到你的博客，那么别人就没法看到了。</p>
<p>在你的 <a href="https://github.com/">github</a> 主页上（没有账户就创建一个），创建一个新的 repository，名字必须为自己的用户名+<code>.github.io</code>。以后你博客的所有内容均会放在这个仓库里</p>
<p>回到 cmd 命令行，要装一个 git 部署的插件，windows 命令如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>设置 _config.yml 文件，修改最后的 Deployment 部分，我之前做过了，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;VincereZhou&#x2F;VincereZhou.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>部署到远端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<h2 id="2-0-绑定自己的域名">2.0 绑定自己的域名</h2>
<p>参考网址：<a href="https://oliverqueen.cn/2018/01/25/%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84%E4%BD%BF%E7%94%A8HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/">https://oliverqueen.cn/2018/01/25/%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84%E4%BD%BF%E7%94%A8HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</a></p>
<h3 id="域名解析">域名解析</h3>
<p>我的域名是在阿里云买的，在阿里云-域名控制台，找到自己的域名，新建两个CNAME记录（不要新建A记录了，github的ip地址可能会变，导致github一直给我发邮件说域名失效）</p>
<p>两个记录一条主机记录为@，一条主机记录为www，这样别人访问的时候无论加不加 www. 都能访问到。</p>
<p><img src="7.png" alt="7"></p>
<h3 id="本地操作">本地操作</h3>
<p>在你的本地hexo博客文件的source文件夹下创建一个CNAME文件，记住不要有文件后缀名。编辑CNAME文件，里面写你在第一步申请的域名，例如<a href="https://link.zhihu.com/?target=http%3A//xxxx.cn">http://xxxx.cn</a>，记住不要有www。</p>
<h3 id="github-仓库配置-https协议">github 仓库配置 - https协议</h3>
<p>找到github 仓库，设置的 pages - custom domain ，填上你的个人域名（不加www.）</p>
<p>在pages 里可以勾选<strong>Enforce HTTPS（实施 HTTPS）</strong> ，这样以后就会用 https协议， 谷歌浏览器打开你的网页就不会显示不安全了。如果无法勾选，旁边显示 <em>Unavailable for your site because your domain is not properly configured to support HTTPS</em>, 那就将填在<strong>Custom domain</strong>里的自定义域名清空，保存，然后重新填上自定义域名，再保存。</p>
<p>勾选<strong>Enforce HTTPS</strong>选项以后，别人说这时会提示正在签发证书: <em>Not yet available for your site because the certificate has not finished being issued</em>。（但是我没有显示这些文字）</p>
<p>证书签发成功后，可以使用 https 链接访问自定义域名了。</p>
<p>勾选完，等一段时间才会生效，重新推到远端，之后打开网址就都是 https 了。</p>
<h3 id="生成公钥，并复制到github">生成公钥，并复制到github</h3>
<p>按照下面这个网址进行操作</p>
<p><a href="https://zhuanlan.zhihu.com/p/26625249">https://zhuanlan.zhihu.com/p/26625249</a></p>
<p>检查有没有公钥。先打开 git bash , 然后输入命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>如果提示文件不存在，说明没有生成公钥。生成公钥如下，输入命令后，<strong>连着按三下Enter</strong>即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">&quot;zhuanzhugongxian@sina.com&quot;</span></span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/c/Users/zhou/.ssh/id_rsa): q</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure>
<p>然后复制公钥的全部内容，黏贴到 github 的 ”新建new SSH Key“ 中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>然后再检查一下，公钥是否设置成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -T git@github.com</span></span><br><span class="line">Hi VincereZhou! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>生成这条语句，就说明连接成功。</p>
<p>这一步操作的好处是，<strong>每次更新博客，不用输入昵称和邮箱进行确认了</strong>，一劳永逸。</p>
<h2 id="2-1-推到远端各种报错说明">2.1 推到远端各种报错说明</h2>
<h4 id="推到远端，报错who-you-are">推到远端，报错who you are</h4>
<p>运行下面两条命令，引号内容改成自己的邮箱和昵称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.email &quot;zhuanzhugongxian@sina.com&quot;</span><br><span class="line">git config --global user.name &quot;VincereZhou&quot;</span><br></pre></td></tr></table></figure>
<h4 id="推到远端，报错-OpenSSL-SSL-read">推到远端，报错 OpenSSL SSL_read</h4>
<p>报错信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#39;https:&#x2F;&#x2F;github.com&#x2F;VincereZhou&#x2F;VincereZhou.github.io.git&#x2F;&#39;: OpenSSL SSL_read: Connection was reset, errno 10054</span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (D:\Desktop\blog\node_modules\_hexo-util@2.4.0@hexo-util\lib\spawn.js:51:21)</span><br><span class="line">      at ChildProcess.emit (events.js:315:20)</span><br><span class="line">      at ChildProcess.cp.emit (D:\Desktop\blog\node_modules\_cross-spawn@7.0.3@cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">      at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:277:12) &#123;</span><br><span class="line">    code: 128</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something&#39;s wrong. Maybe you can find the solution here: %s https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;troubleshooting.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个报错貌似很常见，可以重新 <code>hexo d</code> 或过段时间 <code>hexo d</code> 看看，说不定就又好了。</p>
<p>如果还不行，这个网址 <a href="https://github.com/hexojs/hexo/issues/2778">https://github.com/hexojs/hexo/issues/2778</a> 有一个解决办法</p>
<p>根据这个网址的说法，就是把 _config.yml 中的 repo 内容修改一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> repo: https://github.com/VincereZhou/VincereZhou.github.io.git</span></span><br><span class="line">repo: git@github.com:VincereZhou/VincereZhou.github.io.git</span><br></pre></td></tr></table></figure>
<p>然后重新推送一下，就一切正常了。</p>
<h4 id="推断远端，报错没有git">推断远端，报错没有git</h4>
<p>报错信息为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR Deployer not found: git</span><br></pre></td></tr></table></figure>
<p>网上说，是没安装 hexo-deployer-git 插件</p>
<p><a href="https://blog.csdn.net/Java_Mike/article/details/96456318">https://blog.csdn.net/Java_Mike/article/details/96456318</a></p>
<p>可我明明安装了的，那就再装一次试试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>好吧，可以了。我在想，这是不是因为之前安装用的是 cmd ，这次用的是 git bash 的原因。从目前来看完全可以全部用 git bash，更方便。</p>
<h4 id="推到远端，报错-Timed-out">推到远端，报错 Timed out</h4>
<p>报错如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#39;https:&#x2F;&#x2F;github.com&#x2F;VincereZhou&#x2F;VincereZhou.github.io.git&#x2F;&#39;: Failed to connect to github.com port 443: Timed out</span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (D:\Desktop\blog\node_modules\_hexo-util@2.4.0@hexo-util\lib\spawn.js:51:21)</span><br><span class="line">      at ChildProcess.emit (events.js:315:20)</span><br><span class="line">      at ChildProcess.cp.emit (D:\Desktop\blog\node_modules\_cross-spawn@7.0.3@cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">      at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:277:12) &#123;</span><br><span class="line">    code: 128</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something&#39;s wrong. Maybe you can find the solution here: %s https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;troubleshooting.html</span><br></pre></td></tr></table></figure>
<p>这个我的经验是不用管它，重新 <code>hexo d</code> 或过段时间 <code>hexo d</code>就好了。</p>
<h1>3 博客迁移</h1>
<p>当你要把个人博客的文件从一台电脑转移到另一台电脑。我看知乎上说，直接替换文件夹就行了，我之前好像也这么干过。实际情况也说明确实可以，但是我上面的流程都得走完</p>
<p><a href="https://www.zhihu.com/question/21193762">https://www.zhihu.com/question/21193762</a></p>
<blockquote>
<p>不知道楼主说的是不是换了一台新电脑需要重新部署hexo，如果是的话请往下看。<br>
我从windows换到mac上来，用了上面的一些方法都不成功，其实并没有这么复杂。<br>
首先按照网上搭建hexo的过程一步步重新在新电脑上操作，<br>
之后只要用原电脑的scaffolds, source, themes 和 _config.yml替换新生成的文件就行了。<br>
十分简单～<br>
作者：王璐婷链接：<a href="https://www.zhihu.com/question/21193762/answer/105977542%E6%9D%A5%E6%BA%90%EF%BC%9A%E7%9F%A5%E4%B9%8E%E8%91%97%E4%BD%9C%E6%9D%83%E5%BD%92%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E8%81%94%E7%B3%BB%E4%BD%9C%E8%80%85%E8%8E%B7%E5%BE%97%E6%8E%88%E6%9D%83%EF%BC%8C%E9%9D%9E%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E6%B3%A8%E6%98%8E%E5%87%BA%E5%A4%84%E3%80%82">https://www.zhihu.com/question/21193762/answer/105977542来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a></p>
</blockquote>
<h1>4 主题设置 - 进阶</h1>
<p>hexo 默认的网页比较丑，你可以通过更换主题啥的来更改皮肤。</p>
<p>我这次用的 ayer 主题，但是不是用的这个主题的默认的样子，自己也基于这个主题改了很多东西。</p>
<h2 id="4-1-ayer-主题">4.1 ayer 主题</h2>
<p>看作者自己的中文说明</p>
<p><a href="https://shen-yu.gitee.io/2019/ayer/">https://shen-yu.gitee.io/2019/ayer/</a></p>
<p>下载那些就不说了。</p>
<h3 id="4-1-1-安装主题">4.1.1 安装主题</h3>
<p>作者给了了两种方法</p>
<p><strong>方法一：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 国内用户如果速度较慢，可以把github地址替换为：https:&#x2F;&#x2F;gitee.com&#x2F;mirrors&#x2F;ayer.git</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Shen-Yu&#x2F;hexo-theme-ayer.git themes&#x2F;ayer</span><br></pre></td></tr></table></figure>
<p><strong>方法二（hexo &gt;= 5.0）：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm i hexo-theme-ayer -S</span><br></pre></td></tr></table></figure>
<ul>
<li>如果是新安装本主题，安装完成后会在根目录生成一个<code>_config.ayer.yml</code>文件，直接编辑<code>_config.ayer.yml</code>文件进行配置即可。</li>
<li>如果是主题升级，可以使用方法一，也可以将原来的配置文件移动到根目录，并重命名为<code>_config.ayer.yml</code>。</li>
</ul>
<p><strong>我选了方法一</strong>。因为方法二就是在根目录下生成了 <code>_config.ayer.yml</code> 文件，没有生成 <code>/theme/ayer</code> 文件夹 ，不便于我之后修改。</p>
<p>使用方法一，之后可以直接修改 <code>/theme/ayer</code> 文件夹中的配置文件。</p>
<h3 id="4-1-2-安装必须插件">4.1.2 安装必须插件</h3>
<p>第一个插件，用于搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>然后将下面的内容复制到 根目录下的  <code>_config.yml</code> 里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hexo-generator-searchdb</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br></pre></td></tr></table></figure>
<p>另一个插件，用于生成RSS订阅</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>
<p>然后将下面的内容复制到 根目录下的  <code>_config.yml</code> 里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feed:</span><br><span class="line">    type: atom</span><br><span class="line">    path: atom.xml</span><br><span class="line">    limit: 20</span><br><span class="line">    hub:</span><br><span class="line">    content:</span><br><span class="line">    content_limit: 140</span><br><span class="line">    content_limit_delim: &#39; &#39;</span><br><span class="line">    order_by: -date	</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-1-3-“分类”页面">4.1.3 “分类”页面</h3>
<p>运行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<p>然后将以下复制到 /source/categories/index.md 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="4-1-4-“标签”页面">4.1.4 “标签”页面</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>同样配置相应的 <a href="http://index.md">index.md</a> 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">layout: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="4-1-5-友情链接">4.1.5 友情链接</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page friends</span><br></pre></td></tr></table></figure>
<p>然后将以下复制到 /source/friends/index.md 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: friends</span><br><span class="line">type: friends</span><br><span class="line">layout: &quot;friends&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>然后在 ayer 主题目录下的 <code>_config.yml</code> 中（我用第二种方法，修改根目录下的<code>_config.ayer.yml</code>）自定义 <code>friends_link</code> 配置项即可</p>
<h3 id="4-1-6-相册">4.1.6 相册</h3>
<p>这个我感觉根据个人需求吧，我不热爱摄影，所以我没有用这个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page photos</span><br></pre></td></tr></table></figure>
<p>然后将以下复制到 /source/photos/index.md 文件，<code>img_url</code> 替换成图片路径，<code>caption</code> 替换成图片名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Gallery</span><br><span class="line"></span><br><span class="line">albums: [</span><br><span class="line">        [&quot;img_url&quot;,&quot;img_caption&quot;],</span><br><span class="line">        [&quot;img_url&quot;,&quot;img_caption&quot;]</span><br><span class="line">        ]</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="4-1-7-文章目录">4.1.7  文章目录</h3>
<p>用 Tocbot 解析文章标题并生成目录</p>
<ul>
<li>将以下配置复制到你 ayer 主题目录下的 <code>_config.yml</code> 里（默认就有，不用做）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Toc</span><br><span class="line">toc: true</span><br></pre></td></tr></table></figure>
<ul>
<li>当然你可能并不想所有文章都生成悬浮目录，你可以在文章顶部的配置中加一行来进行关闭：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">no_toc: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="4-1-作者博客的设置">4.1. 作者博客的设置</h3>
<h4 id="front-matter">front matter</h4>
<p>以其中一篇文章为例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 大美湘西</span><br><span class="line">date: 2018-11-21 00:13:57</span><br><span class="line">id: xiangxi</span><br><span class="line">tags:</span><br><span class="line">    - 旅行</span><br><span class="line">    - 国内</span><br><span class="line">categories: </span><br><span class="line">    - 旅行</span><br><span class="line">    - 国内</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>id</strong> : 文章URL，这里应该是用了什么插件吧。这篇文章的URL 就是 <code>https://shen-yu.gitee.io/2018/xiangxi/</code></li>
<li><strong>tags</strong>:  标签，多个标签是平行的。</li>
<li><strong>categories</strong>： 目录，多个目录是有<strong>层级</strong>的。这里国内是旅行的子目录。</li>
</ul>
<p>作者写博客的结构是，先写一段总结式的话，然后断开。后面跟着正文。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>
<h4 id="menu">menu</h4>
<p>这里的设置对应的是网页左侧菜单栏的设置。有几个我注意到的地方</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">旅行: &#x2F;tags&#x2F;旅行&#x2F;</span><br><span class="line">摄影: http:&#x2F;&#x2F;shenyu-vip.lofter.com</span><br><span class="line">关于我: &#x2F;2019&#x2F;about</span><br></pre></td></tr></table></figure>
<p>摄影直接是跳到了一个新的网址，不用多说。</p>
<p>关于我，我看了一下，作者是在<code>source/_post</code> 里有一个 <code>about.md</code>，相当于一个博客。而作者在根目录对URL 的设置为 <strong>年/文章题目</strong>，因此这里就是对应 <code>/2019/about</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">permalink: :year&#x2F;:id&#x2F;</span><br></pre></td></tr></table></figure>
<p>旅行其实就是把 tags 中属于<strong>旅行</strong>的部分单独拿了出来，作为单独的一部分，和你自己点击标签-旅行效果一样。点击进去，网址就是（后面是中文，没有显示好）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;shen-yu.gitee.io&#x2F;tags&#x2F;旅行&#x2F;</span><br></pre></td></tr></table></figure>
<p>我感觉，<strong>menu 的设置就是看这个网址的后面跟着的部分</strong>，这里是在官网后面加了 <code>/tags/旅行/</code>，menu 设置就是 <code>旅行: /tags/旅行/</code> 。关于我的网址是 <code>https://shen-yu.gitee.io/2019/about/</code> ，menu 设置就是 <code>/2019/about</code> 。</p>
<p>所以，如果我想把我对只只的页面加到menu中，网址是 <code>http://vincere.fun/posts/ac7827ff/</code>，menu 就应该添加 <code>我的只只: /posts/ac7827ff</code> 。</p>
<h3 id="4-1-8-自己的设置">4.1.8 自己的设置</h3>
<h4 id="添加-关于我">添加&quot;关于我&quot;</h4>
<p><a href="https://durant35.github.io/2016/01/26/hexo_%E6%B7%BB%E5%8A%A0about%E5%AF%BC%E8%88%AA%E6%A0%8F/">https://durant35.github.io/2016/01/26/hexo_添加about导航栏/</a></p>
<p>先新建一个纯页面。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">hexo</span> <span class="string">new</span> <span class="string">page</span> <span class="string">about</span></span><br></pre></td></tr></table></figure>
<p>直接在<code>/source/about/index.md</code>中写入自己的信息。title 改成 <code>title: About Me</code></p>
<p>修改<code>/theme/ayer</code> 的主题配置文件的开头的目录部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">关于我: &#x2F;about</span><br></pre></td></tr></table></figure>
<p>ok，没有问题。</p>
<h4 id="网页底部统计运行天数">网页底部统计运行天数</h4>
<p><a href="https://blog.csdn.net/qq_35982918/article/details/106728754">https://blog.csdn.net/qq_35982918/article/details/106728754</a></p>
<p>找到 <code>\themes\ayer\layout\_partial\footer.ejs</code> 文件，在文件中（我是放在了最后一个 </ul> 的下面）加入下面一段代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 运行天数 --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;&lt;span id&#x3D;&quot;runtime_span&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;         </span><br><span class="line">    function show_runtime() &#123;</span><br><span class="line">        window.setTimeout(&quot;show_runtime()&quot;, 1000);</span><br><span class="line">        X &#x3D; new Date(&quot;08&#x2F;15&#x2F;2019 21:50:56&quot;);</span><br><span class="line">        Y &#x3D; new Date();</span><br><span class="line">        T &#x3D; (Y.getTime() - X.getTime());</span><br><span class="line">        M &#x3D; 24 * 60 * 60 * 1000;</span><br><span class="line">        a &#x3D; T &#x2F; M;</span><br><span class="line">        A &#x3D; Math.floor(a);</span><br><span class="line">        b &#x3D; (a - A) * 24;</span><br><span class="line">        B &#x3D; Math.floor(b);</span><br><span class="line">        c &#x3D; (b - B) * 60;</span><br><span class="line">        C &#x3D; Math.floor((b - B) * 60);</span><br><span class="line">        D &#x3D; Math.floor((c - C) * 60);</span><br><span class="line">        runtime_span.innerHTML &#x3D; &quot;小站在各种崩坏中坚持了: &quot; + A + &quot;天&quot; + B + &quot;小时&quot; + C + &quot;分&quot; + D + &quot;秒&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    show_runtime();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>改成我和只只在一起的时间</p>
<p>这里就是把 runtime_span 改成 lovetime_span</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 与只只在一起天数 --&gt;</span><br><span class="line"> &lt;ul&gt;</span><br><span class="line">     &lt;li&gt;&lt;span id&#x3D;&quot;lovetime_span&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;</span><br><span class="line"> &lt;&#x2F;ul&gt;</span><br><span class="line"> &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;         </span><br><span class="line">     function show_runtime() &#123;</span><br><span class="line">         window.setTimeout(&quot;show_runtime()&quot;, 1000);</span><br><span class="line">         X &#x3D; new Date(&quot;03&#x2F;04&#x2F;2021 22:11:00&quot;);</span><br><span class="line">         Y &#x3D; new Date();</span><br><span class="line">         T &#x3D; (Y.getTime() - X.getTime());</span><br><span class="line">         M &#x3D; 24 * 60 * 60 * 1000;</span><br><span class="line">         a &#x3D; T &#x2F; M;</span><br><span class="line">         A &#x3D; Math.floor(a);</span><br><span class="line">         b &#x3D; (a - A) * 24;</span><br><span class="line">         B &#x3D; Math.floor(b);</span><br><span class="line">         c &#x3D; (b - B) * 60;</span><br><span class="line">         C &#x3D; Math.floor((b - B) * 60);</span><br><span class="line">         D &#x3D; Math.floor((c - C) * 60);</span><br><span class="line">         lovetime_span.innerHTML &#x3D; &quot;只只和周周在一起了 &quot; + A + &quot;天&quot; + B + &quot;小时&quot; + C + &quot;分&quot; + D + &quot;秒&quot;</span><br><span class="line">     &#125;</span><br><span class="line">     show_runtime();</span><br><span class="line"> &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="网页底部取消hexo-和-ayer-推荐">网页底部取消hexo 和 ayer 推荐</h4>
<p>找到 <code>\themes\ayer\layout\_partial\footer.ejs</code> 文件，删除下面这一部分代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;% if (theme.pageFooter)&#123; %&gt;</span><br><span class="line">    &lt;% var hexoLink &#x3D; &#39;&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;hexo.io&quot; target&#x3D;&quot;_blank&quot;&gt;Hexo&lt;&#x2F;a&gt;&#39;; %&gt;</span><br><span class="line">    &lt;% var themeLink &#x3D; &#39;&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;github.com&#x2F;Shen-Yu&#x2F;hexo-theme-ayer&quot; target&#x3D;&quot;_blank&quot;&gt;Ayer&lt;&#x2F;a&gt;&#39;; %&gt;</span><br><span class="line">    &lt;%- __(&#39;powered_by&#39;, hexoLink) %&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;division&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;%- __(&#39;theme&#39;, themeLink) %&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">  &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>
<h4 id="文章置顶">文章置顶</h4>
<p><a href="http://wangwlj.com/2018/01/09/blog_pin_post/">http://wangwlj.com/2018/01/09/blog_pin_post/</a></p>
<p><a href="https://github.com/netcan/hexo-generator-index-pin-top">https://github.com/netcan/hexo-generator-index-pin-top</a></p>
<p>安装插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm uninstall hexo-generator-index --save</span><br><span class="line">cnpm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>
<p>需要置顶的文件 front matter 添加 <code>top: true</code>。</p>
<p>这就可以了。Github 里说还要设置根目录的配置文件，好像不需要。</p>
<h4 id="valine-评论系统">valine 评论系统</h4>
<p><a href="https://www.playpi.org/2019032001.html">https://www.playpi.org/2019032001.html</a></p>
<p>先去 <a href="https://www.leancloud.cn/">leancloud</a> 注册账号，然后<strong>创建一个应用</strong>（我起名为blog）,然后 进入应用-&gt;设置-&gt;应用key，获取你的appid 和 appkey 。</p>
<p>第二步，应用-&gt;设置-&gt;安全中心，将上方<strong>数据存储</strong>以外的服务全部关闭，因为用不到。然后设置下方的 <strong>Web 安全域名</strong>。</p>
<blockquote>
<p><s>里面一定要填写自己站点的域名，并且带上端口号，例如 <code>http</code> 请求的默认端口就是 80，<code>https</code> 请求的默认端口就是 443。这里如果没有配置好，评论的时候也会失败的。</s></p>
</blockquote>
<p>设置端口会出错，不设置端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;vincere.fun</span><br><span class="line">http:&#x2F;&#x2F;www.vincere.fun</span><br></pre></td></tr></table></figure>
<p>如果提示下面这句话，刷新一下，或等待一段时间。（可能是网页接受邮箱验证迟钝）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Invalid access, mismatch xsrf token.</span><br></pre></td></tr></table></figure>
<p>将应用的appid 和 appkey 复制到 ayer的主题配置中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leancloud:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: yHN3kf7fHt5wvleM2DVoHLdY-gzGzoHsz</span><br><span class="line">  app_key: RPIwmdftljIzOtAULwc7JCAp</span><br></pre></td></tr></table></figure>
<h5 id="推到远端报错">推到远端报错</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh: connect to host github.com port 22: Connection timed out</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我感觉是那个 <strong>Web 安全域名</strong> 的80端口设置错了，改成不设置端口。</p>
<p>确实是这个原因，取消端口就没事了。</p>
<h5 id="部分博客取消评论">部分博客取消评论</h5>
<p>设置好 valine 默认所有博客均有评论，如果有些博客不想要评论，那么在 front matter 部分设置一下，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">comments: false</span><br></pre></td></tr></table></figure>
<h5 id="查看leancloud-中的评论数据">查看leancloud 中的评论数据</h5>
<blockquote>
<p>好了，此时可以再回到 <code>Leancloud</code> 系统，看一下评论数据吧。直接在 <strong>存储 -&gt; 数据 -&gt;Comment</strong> 里面，可以看到已经有评论数据了。由于 <code>Valine</code> 是无后端的评论系统，所以数据直接被存储到了 <code>Leancloud</code> 系统的数据库表里面，看看就行了，不方便管理。如果评论数据很多，为了更方便管理评论数据，能收到更友好的邮件通知提醒，可以使用 <code>Valine-Admin</code> 来实现</p>
</blockquote>
<p>不过这里可以全选，删除所有的评论。（用于测试）</p>
<h5 id="Code-403：访问被API域名白名单拒绝，请检查你的安全域名设置">Code 403：访问被API域名白名单拒绝，请检查你的安全域名设置</h5>
<p>我使用了 https协议 之后，评论框就出现了上面的文字。因为是网址变了。</p>
<p>解决办法：在 leancloud 的评论应用&gt;设置&gt;安全中心&gt;Web安全域名中修改新的域名</p>
<h4 id="valine-admin">valine-admin</h4>
<h5 id="快速开始">快速开始</h5>
<p><a href="https://github.com/zhaojun1998/Valine-Admin">https://github.com/zhaojun1998/Valine-Admin</a></p>
<p>首先进入 leancloud 的应用中，本来是这么说的</p>
<blockquote>
<p>点击 <code>云引擎 -&gt; 设置</code> 填写代码库并保存：<code>https://github.com/zhaojun1998/Valine-Admin</code></p>
</blockquote>
<p>但我在这个地方根本没有找到所谓的<strong>代码库</strong>，然后从网上找了一下资料（<a href="https://github.com/DesertsP/Valine-Admin/issues/109%EF%BC%89%EF%BC%8C%E4%BB%96%E4%BB%AC%E8%AF%B4%E5%9C%A8">https://github.com/DesertsP/Valine-Admin/issues/109），他们说在</a><strong>云引擎-web组-部署-部署项目-git部署-配置git</strong>，找到了可以复制的地方，复制上面的路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;zhaojun1998&#x2F;Valine-Admin</span><br></pre></td></tr></table></figure>
<p>然后再次<strong>点击 Git 部署 -&gt; 部署</strong>即可（第一次部署可能会需要些时间。不点击不会生效的）</p>
<h5 id="配置项">配置项</h5>
<p>云引擎-web组-设置中，添加下面的环境变量</p>
<p>必选参数</p>
<ul>
<li><code>SITE_NAME</code> : 网站名称。</li>
<li><code>SITE_URL</code> : 网站地址, <strong>最后不要加 <code>/</code> 。</strong></li>
<li><code>SMTP_USER</code> : SMTP 服务用户名，一般为邮箱地址。</li>
<li><code>SMTP_PASS</code> : SMTP 密码，一般为授权码，而不是邮箱的登陆密码，请自行查询对应邮件服务商的获取方式</li>
<li><code>SMTP_SERVICE</code> : 邮件服务提供商，支持 <code>QQ</code>、<code>163</code>、<code>126</code>、<code>Gmail</code>、<code>&quot;Yahoo&quot;</code>、<code>......</code> ，全部支持请参考 : <a href="https://nodemailer.com/smtp/well-known/#supported-services">Nodemailer Supported services</a>。 — <em>如这里没有你使用的邮件提供商，请查看<a href="https://github.com/zhaojun1998/Valine-Admin/blob/master/%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE.md#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8">自定义邮件服务器</a></em></li>
<li><code>SENDER_NAME</code> : 寄件人名称。</li>
</ul>
<p>如果不能修改，出现下面的提示信息，不要怕，刷新一下网站可能就好了。我也不知道这是什么鬼东东。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Failed to fetch [N&#x2F;A PATCH &#x2F;engine&#x2F;groups&#x2F;web]</span><br></pre></td></tr></table></figure>
<p>这里 SMTP_PASS 用到了授权码，163邮箱获取授权码的方式如下（网页端就可以拿到）：</p>
<p><a href="https://help.mail.163.com/faqDetail.do?code=d7a5dc8471cd0c0e8b4b8f4f8e49998b374173cfe9171305fa1ce630d7f67ac2cda80145a1742516">https://help.mail.163.com/faqDetail.do?code=d7a5dc8471cd0c0e8b4b8f4f8e49998b374173cfe9171305fa1ce630d7f67ac2cda80145a1742516</a></p>
<p><a href="https://github.com/DesertsP/Valine-Admin">https://github.com/DesertsP/Valine-Admin</a></p>
<p>这里提到还有一个必选的变量， SENDER_EMAIL （发件邮箱）</p>
<p>最终设置如下</p>
<p><img src="1.png" alt="1"></p>
<p>修改后记得点击<strong>保存</strong>。</p>
<p>之后再次<strong>点击 Git 部署 -&gt; 部署</strong>，才会生效</p>
<h5 id="查看日志">查看日志</h5>
<p>云引擎 - WEB - 日志</p>
<p>这里可以查看所有的历史，包括部署项目，接收到的评论</p>
<p><img src="2.png" alt="1"></p>
<h5 id="leancloud-休眠策略">leancloud 休眠策略</h5>
<blockquote>
<p>免费版的 LeanCloud 容器，是有强制性休眠策略的，不能 24 小时运行：</p>
<ul>
<li>每天必须休眠 6 个小时</li>
<li>30 分钟内没有外部请求，则休眠。</li>
<li>休眠后如果有新的外部请求实例则马上启动（但激活时此次发送邮件会失败）。</li>
</ul>
<p>分析了一下上方的策略，如果不想付费的话，最佳使用方案就设置定时器，每天 7 - 23 点每 20 分钟访问一次，这样可以保持每天的绝大多数时间邮件服务是正常的。</p>
</blockquote>
<p>这个休眠的影响，貌似是说，休眠期间第一个评论可能不会有邮件提醒。</p>
<p><a href="https://github.com/DesertsP/Valine-Admin">https://github.com/DesertsP/Valine-Admin</a></p>
<p>云引擎 - 定时任务</p>
<p>创建两个定时任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 *&#x2F;30 0-16 * * ?</span><br></pre></td></tr></table></figure>
<p>表示每天早0点到晚16点每隔30分钟访问云引擎</p>
<p><img src="3.png" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 0 * * ?</span><br></pre></td></tr></table></figure>
<p>表示每天0点检查过去24小时内漏发的通知邮件并补发（如果要修改时间，就修改第三个数即可）。</p>
<p><img src="4.png" alt="1"></p>
<p>有的教程说要对于新建的定时任务要点击一下启动，但是我看leancloud页面已经没有启动按钮了，只有正常和暂停，应该就不用做什么了。</p>
<p><img src="5.png" alt="1"></p>
<p>不过，为了保险，我还是重新部署了一下。</p>
<h5 id="评论管理">评论管理</h5>
<p><a href="https://blog.csdn.net/u012208219/article/details/106883083">https://blog.csdn.net/u012208219/article/details/106883083</a></p>
<p>首先，先绑定域名（必须经过备案）。</p>
<p>在leancloud - 设置 - 域名绑定 - 云引擎域名中设置</p>
<p><img src="6.png" alt="1"></p>
<p>之后，这里显示 “正在检查备案信息”。</p>
<p>绑定失败了，我再查一下我的备案信息</p>
<p>如果这一步成功了，下一步进行初始化管理。</p>
<blockquote>
<p>打开绑定的域名+<code>/sign-up</code>，例如我的域名为<code>https://xiaokang.avosapps.us/</code>，那么我访问的地址就是<code>https://xiaokang.avosapps.us/sign-up</code>。</p>
</blockquote>
<p>接下来就可以用刚才的邮箱或者登录名登录了。</p>
<h6 id="没有域名备案，做不了">没有域名备案，做不了</h6>
<p>关于域名备案的问题，这里就说的很清楚了。也就是说，买了域名还要有服务器才能用，我是绑定了 Github，是国外的浏览器，所以不用备案，估计也没法备案了。</p>
<p><a href="https://zhuanlan.zhihu.com/p/33908110">https://zhuanlan.zhihu.com/p/33908110</a></p>
<blockquote>
<p>另外有了只有域名当然是不行的，还需要拥有自己的服务器，但是国内的服务器如阿里云绑定域名后还需要备案才能使用，很麻烦，下面我们利用<a href="https://link.zhihu.com/?target=https%3A//pages.github.com/36fda622.html">Github pages</a>来实现网页表白，因为Github的服务器在国外，所以小伙伴们不用担心备案的问题。</p>
</blockquote>
<h4 id="leancloud-设置失败就刷新一下网页">leancloud 设置失败就刷新一下网页</h4>
<p>说不定就好了。这种情况我碰到了不是一次两次了，开始还以为咋出了问题，后面才知道这玩意就这样，就刷新一下网页再设置一下可能就好了。</p>
<h4 id="文章url链接持久化">文章url链接持久化</h4>
<p><a href="https://www.fadai.cc/posts/fb8c11fe/">https://www.fadai.cc/posts/fb8c11fe/</a></p>
<blockquote>
<p>hexo默认生成的文章是以“年/月/日/文章标题”为路径存储的，这样的url结构超过了3层，对百度等其他搜索引擎的爬虫十分不友好，导致文章迟迟没有收录。我们可以通过安装链接持久化的插件优化我们的文章地址。</p>
</blockquote>
<h5 id="安装hexo-abbrlink-插件">安装<code>hexo-abbrlink</code> 插件</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>
<h5 id="修改根目录的配置文件">修改根目录的配置文件</h5>
<p>首先修改一个地方</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink: posts&#x2F;:abbrlink&#x2F;</span><br></pre></td></tr></table></figure>
<p>然后在文件文件末尾添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># abbrlink config</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32      #支持crc16（默认）和crc32</span><br><span class="line">  rep: hex        #支持dec（默认）和hex</span><br><span class="line">  drafts: false   #（true）处理草稿，（false）不处理草稿。false（默认）</span><br><span class="line">  # 从目录树生成类别</span><br><span class="line">  # depth: 要生成的目录树的最大深度，应大于0</span><br><span class="line">  auto_category:</span><br><span class="line">     enable: true  #true(默认)</span><br><span class="line">     depth:        #3(默认)</span><br><span class="line">     over_write: false </span><br><span class="line">  auto_title: false #启用自动标题，可按路径自动填充标题</span><br><span class="line">  auto_date: false #启用自动日期功能，可以按今天的时间自动填充日期</span><br><span class="line">  force: false #启用强制模式，在此模式下，插件将忽略缓存，并为每个帖子计算abbrlink，即使它已经有了abbrlink。</span><br></pre></td></tr></table></figure>
<p>最后重新推到远端就好了。</p>
<h4 id="添加音乐">添加音乐</h4>
<p><a href="http://yearito.cn/posts/hexo-writing-skills.html">http://yearito.cn/posts/hexo-writing-skills.html</a></p>
<h5 id="网易云音乐">网易云音乐</h5>
<p><a href="http://yearito.cn/posts/hexo-writing-skills.html">http://yearito.cn/posts/hexo-writing-skills.html</a></p>
<p>在<strong>网页版</strong>云音乐中找到歌曲，点击<strong>生成外链播放器</strong>。复制 iframe 插件的 <strong>HTML 代码</strong>。</p>
<p>我这里是飞奔向你的代码（为了让播放器居中，这里使用 <center> 标签）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;center&gt;</span><br><span class="line">&lt;iframe frameborder&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; marginwidth&#x3D;&quot;0&quot; marginheight&#x3D;&quot;0&quot; width&#x3D;330 height&#x3D;86 src&#x3D;&quot;&#x2F;&#x2F;music.163.com&#x2F;outchain&#x2F;player?type&#x3D;2&amp;id&#x3D;1483786045&amp;auto&#x3D;1&amp;height&#x3D;66&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line">&lt;&#x2F;center&gt;</span><br></pre></td></tr></table></figure>
<p>如果播放器宽度将会被拉长占满整个页宽，找到 <code>themes\next\source\js\src\utils.js</code> 这个文件，注释掉 <code>music.163.com</code> ( <strong>//</strong> 注释)</p>
<p>这种方式什么插件都不用（ok，真的可以）。直接把代码复制到markdown中就行（不要用代码框啥的），比如上面的“飞奔向你”</p>
<h5 id="aplayer">aplayer</h5>
<p>安装插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-tag-aplayer --save</span><br></pre></td></tr></table></figure>
<p>可用选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% aplayer title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx] %&#125;</span><br></pre></td></tr></table></figure>
<p>其中，各参数意义如下：</p>
<ul>
<li>title: 曲目标题</li>
<li>author: 曲目作者</li>
<li>url: 音乐文件 URL 地址</li>
<li>picture_url: (可选) 音乐对应的图片地址</li>
<li>narrow: （可选）播放器袖珍风格</li>
<li>autoplay: (可选) 自动播放，移动端浏览器暂时不支持此功能</li>
<li>width:xxx: (可选) 播放器宽度 (默认: 100%)</li>
<li>lrc:xxx: （可选）歌词文件 URL 地址</li>
</ul>
<p>我实际是把歌曲下载了下来，用网址发现没用，实际命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% aplayer &quot;因为你 所以我&quot; &quot;五月天&quot; &quot;&#x2F;images&#x2F;you_than_me.mp3&quot; &quot;&#x2F;images&#x2F;music1.jpg&quot; %&#125;</span><br></pre></td></tr></table></figure>
<h4 id="看板娘">看板娘</h4>
<p>看板娘就是网页中的小动物/人偶形象，具体效果可以通过电脑看我的博客：<a href="https://vincere.fun/">https://vincere.fun/</a></p>
<p><a href="https://blog.csdn.net/qq_35982918/article/details/106728754">https://blog.csdn.net/qq_35982918/article/details/106728754</a></p>
<p>安装插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-helper-live2d  --save</span><br></pre></td></tr></table></figure>
<p>下载模型（预览图 <a href="https://huaji8.top/post/live2d-plugin-2.0/">https://huaji8.top/post/live2d-plugin-2.0/</a> ）</p>
<p>这里我选 wanko ，小狗狗</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install live2d-widget-model-wanko </span><br></pre></td></tr></table></figure>
<p>修改根目录配置文件，添加下面的内容</p>
<p>我关闭手机端显示，因为我发现在手机端有点碍事。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Live2D动画</span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local</span><br><span class="line">  pluginRootPath: live2dw&#x2F;</span><br><span class="line">  pluginJsPath: lib&#x2F;</span><br><span class="line">  pluginModelPath: assets&#x2F;</span><br><span class="line">  tagMode: false</span><br><span class="line">  debug: false</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-wanko </span><br><span class="line">  display:</span><br><span class="line">    position: left</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">    hOffset: 80</span><br><span class="line">    vOffset: -70</span><br><span class="line">  mobile:</span><br><span class="line">    show: false</span><br><span class="line">    scale: 0.5 </span><br></pre></td></tr></table></figure>
<h4 id="为hexo添加上标、下标、脚注等功能">为hexo添加上标、下标、脚注等功能</h4>
<p><a href="https://www.jianshu.com/p/588ab3d22eb8">https://www.jianshu.com/p/588ab3d22eb8</a></p>
<p>使用插件 <strong>hexo-renderer-markdown-it</strong></p>
<p>先卸载旧的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm un hexo-renderer-marked --save</span><br></pre></td></tr></table></figure>
<p>再装新的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm i hexo-renderer-markdown-it --save</span><br></pre></td></tr></table></figure>
<p>在根目录下的目录文件进行配置，只需要进行简单配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Markdown-it config</span><br><span class="line">#markdown: &#39;zero&#39;</span><br><span class="line">#markdown: &#39;default&#39;</span><br><span class="line">markdown: &#39;commonmark&#39;</span><br></pre></td></tr></table></figure>
<p>每种简单配置有其默认的一些设置。更多个性化配置，请参考：高级配置。</p>
<ul>
<li>zero：禁用大多数解析器功能。仅支持斜体和粗体，甚至不支持所有原始Markdown功能。</li>
<li>default（GFM）：解析器的行为类似于github规范。</li>
<li>commonmark：提供比Zero预设更多的功能。 此设置将强制插件使用最新的CommonMark规范。</li>
</ul>
<h5 id="缩写">缩写</h5>
<p><a href="https://www.jianshu.com/p/62f2ded11f8f">https://www.jianshu.com/p/62f2ded11f8f</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;abbr title&#x3D;&quot;residual standard error&quot;&gt;RSE&lt;&#x2F;abbr&gt;</span><br></pre></td></tr></table></figure>
<p>title 写入完整名称。</p>
<h5 id="脚注">脚注</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">basic footnote[^1]</span><br><span class="line">here is an inline footnote[^2](inline footnote)</span><br><span class="line">and another one[^3]</span><br><span class="line">and another one[^4]</span><br><span class="line"></span><br><span class="line">[^1]: basic footnote content</span><br><span class="line">[^3]: paragraph</span><br><span class="line">footnote</span><br><span class="line">content</span><br><span class="line">[^4]: footnote content with some [markdown](https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Markdown)</span><br></pre></td></tr></table></figure>
<p>我估摸着，写法就是文本的地方手动插入脚注[^1]，末尾写入注释内容</p>
<p>[^1]: basic footnote content</p>
<h5 id="下标">下标</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">H~2~0 &#x3D;&gt; H&lt;sub&gt;2&lt;&#x2F;sub&gt;O</span><br></pre></td></tr></table></figure>
<h5 id="上标">上标</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">29^th^ &#x3D;&gt; 29&lt;sup&gt;th&lt;&#x2F;sup&gt;</span><br></pre></td></tr></table></figure>
<h5 id="插入（下划线）">插入（下划线）</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">++inserted++ &#x3D;&gt; &lt;ins&gt;inserted&lt;&#x2F;ins&gt;</span><br></pre></td></tr></table></figure>
<h4 id="访问速度优化-懒加载">访问速度优化 - 懒加载</h4>
<p>当博客内容比较长或图片比较多时加载速度很慢，然后上网搜了一下，貌似有一个”懒加载“可以试一试，内容来自于<a href="https://www.zyskys.com/posts/60945.html">Hexo博客的优化-提升访问速度，SEO</a>， 预加载和懒加载的定义如下</p>
<blockquote>
<p><code>预加载</code>就是进入项目前提前加载资源，避免在项目中加载缓慢，影响用户体验</p>
<ul>
<li>缺点：会增加服务器压力</li>
</ul>
<p><code>懒加载</code>一般是当图片滚动进可视窗口内才加载图片，可视窗口之外的图片则不加载</p>
<ul>
<li>优点：对服务器有一定的缓解压力作用</li>
</ul>
</blockquote>
<p>安装插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-lazyload-image --save</span><br></pre></td></tr></table></figure>
<p>然后在 Hexo 配置文件末尾加入以下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lazyload:</span><br><span class="line">  enable: true </span><br><span class="line">  onlypost: false  # 是否只对文章的图片做懒加载</span><br><span class="line">  loadingImg: # eg .&#x2F;images&#x2F;loading.gif</span><br></pre></td></tr></table></figure>
<p>然后更新博客即可。</p>
<p>实际发现不好用，弃了。</p>
<h3 id="4-1-9-目前所有可用的front-matter">4.1.9 目前所有可用的front matter</h3>
<p>新建一个博客之后，目前所有可用的 front matter 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tags: </span><br><span class="line">categories:</span><br><span class="line">top:       #置顶，默认false</span><br><span class="line">reward:    #是否显示打赏，我这里默认false</span><br><span class="line">comments:  #是否允许评论，默认true</span><br></pre></td></tr></table></figure>
<p>写好 front matter 后，<strong>写一段总结的话</strong>，然后加入阅读更多的截断。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>
<p>之后就是正文，就想怎么写怎么写了</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>linear algebra step by step</title>
    <url>/posts/aec3be7e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这本书的名字就是 ，作者是 Kuldeep Singh。这本书主要是讲解线性代数的基础知识，是我目前看过的关于线代的书中讲的最清楚的。看完这本书，我才有一种恍然大悟的感觉，才有一点线代学通了的感觉。不过我没有记笔记，这里只是安利。</p>
<span id="more"></span>
<p>这本书的电子版可以在<a href="http://libgen.rs/">Library Genesis</a> 下载到。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>DMU软件使用笔记</title>
    <url>/posts/59ca09be/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>DMU 是动植物育种领域常用的遗传评估软件，我之前也经常用。这里仅仅是我自己的一个备忘录，将一些疑难的点记录下来。</p>
<span id="more"></span>
<h1>参数卡设置</h1>
<h2 id="NOCOV">NOCOV</h2>
<p>设置模型中最后一个部分，应该是设置没有残差协方差的组分。</p>
<p>比如</p>
<p>1</p>
<p>1 2</p>
<p>就是说有一个组分没有残差协方差，第二行具体指明是哪两个性状，这是是说第一个性状和第二个性状之间没有残差协方差。</p>
<p>育种课的ppt是这么写的：</p>
<blockquote>
<p>多性状分析时，不同的性状可能在不同的个体测得。在这种情况下，性状间剩余值（即残差）相互独立，剩余值协方差通常要约束为0。</p>
</blockquote>
<h1>residual 结果文件</h1>
<p>官方文档。以单性状为例，第二列应该是表型值吧，不是所谓的predicted value 然后之后的三列才是文档说的三个残差。</p>
<p>这个文件的顺序和个数和表型文件一致。</p>
<p><img src="6.png" alt=""></p>
<h1>报错</h1>
<ul>
<li>估计是数据量太大，超出设置的内存总量</li>
</ul>
<p><img src="dmu1.png" alt=""></p>
<p>数据情况：芯片2万7 表型12万6 使用all 选项</p>
<ul>
<li>同时使用80k和50k的参考群，光跑dmu就跑了几天。结果没跑出来，也没报错。看了估计方差组分迭代了49次，估计是迭代次数设置了最多50次。</li>
</ul>
<p><img src="dmu2.png" alt=""></p>
<p><img src="dmu3.png" alt=""></p>
<ul>
<li>报日龄的单性状时报错，<strong>没解决</strong>。截至目前还不知道怎么处理。</li>
</ul>
<p><img src="dmu4.png" alt=""></p>
<ul>
<li>
<p>ssgblup 系谱报错</p>
<p>最后一列没有用行号</p>
</li>
</ul>
<p><img src="5.png" alt=""></p>
<ul>
<li>
<p>性状模型报错</p>
<p>他的意思应该是性状太多，信息不够，跑不出来。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AI or combined AI&#x2F;EM information matrix is not positive definite</span><br><span class="line">    Smallest eigenvalue:                       -7.015359837501943E-017</span><br><span class="line">    Rank:                                               44</span><br><span class="line">    No of co-variance components to estimate:           45</span><br><span class="line"> </span><br><span class="line">    This could be due to a variance component close to 0.0 or</span><br><span class="line">    that there is not enough information in the data for the model</span><br><span class="line"> </span><br><span class="line">    Program terminates</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>DMU</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>遗传育种</tag>
        <tag>DMU</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Analysis for the Life Sciences</title>
    <url>/posts/3263dd4c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这也是一本数据分析的书籍，用的语言是R，但是貌似我之前没看完……</p>
<span id="more"></span>
<h1>Data Analysis for the Life Sciences</h1>
<h2 id="introduction">introduction</h2>
<p>statistical inference(统计推断)：推断就是使用可能性从数据中获取群体特征值（Inference is the use of probability to learn population characteristic from data）。一个典型的例子就是推断两个群体的平均值是否相同。</p>
<h2 id="getting-started">getting started</h2>
<p>主要是介绍了一些R的基础部分和数学基础。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">###第一章 getting started </span></span><br><span class="line">install.packages(<span class="string">&quot;swirl&quot;</span>)</span><br><span class="line">install.packages(<span class="string">&quot;rafalib&quot;</span>)</span><br><span class="line">install.packages(<span class="string">&quot;downloader&quot;</span>)</span><br><span class="line">setwd(<span class="string">&#x27;D:\\Desktop\\下载英文文献\\模型\\R_model&#x27;</span>)</span><br><span class="line">dat &lt;- read.table(<span class="string">&#x27;female_mouse_weights.txt&#x27;</span>,header = <span class="built_in">T</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">###通过downloader直接下载网上的数据</span></span><br><span class="line">library(downloader) <span class="comment">##use install.packages to install ##通过downloader</span></span><br><span class="line">url &lt;- <span class="string">&quot;https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extd\</span></span><br><span class="line"><span class="string">ata/femaleMiceWeights.csv&quot;</span>  <span class="comment">## 数据的完整路径</span></span><br><span class="line">filename &lt;- <span class="string">&quot;femaleMiceWeights.csv&quot;</span></span><br><span class="line">download(url, destfile=filename) <span class="comment">## 下载，后面更的是下载后的名称</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 为了从GitHub 上直接下载文件夹，你需要下载devtools包</span></span><br><span class="line">library(devtools)</span><br><span class="line">install_github(<span class="string">&quot;genomicsclass/dagdata&quot;</span>)</span><br><span class="line"></span><br><span class="line">dir &lt;- system.file(package = <span class="string">&quot;dagdata&quot;</span>) <span class="comment"># 获取文件夹位置</span></span><br><span class="line">dir  <span class="comment">## &quot;D:/software/R/R-3.6.1/library/dagdata&quot;</span></span><br><span class="line">list.files(dir) <span class="comment"># 查看dir下面的文件和子文件夹</span></span><br><span class="line">list.files(dir,<span class="string">&quot;extdata&quot;</span>) <span class="comment"># 查看extdata下的子文件</span></span><br><span class="line">filename&lt;-file.path(dir,<span class="string">&quot;extdata/femaleMiceWeights.csv&quot;</span>) <span class="comment">## 文件的完整路径</span></span><br><span class="line">dat&lt;-read.csv(filename) <span class="comment">## 最终打开文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####初探dplyr </span></span><br><span class="line">library(<span class="string">&quot;dplyr&quot;</span>)</span><br><span class="line"><span class="comment">##dplyr包中filter是进行数据筛选</span></span><br><span class="line">chow &lt;- filter(dat,Diet==<span class="string">&quot;chow&quot;</span>) <span class="comment">## 筛选Diet列中为chow的数据</span></span><br><span class="line">head(chow)</span><br><span class="line"></span><br><span class="line"><span class="comment">## select貌似是选列</span></span><br><span class="line">chowVals &lt;- select(chow,Bodyweight) <span class="comment">## 选择chow中的Bodyweight列</span></span><br><span class="line">head(chowVals)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 还可以使用通道符 %&gt;% denote a pipe </span></span><br><span class="line"><span class="comment">## 因此上述两步可以合成一步</span></span><br><span class="line">chowVals &lt;- filter(dat,Diet==<span class="string">&quot;chow&quot;</span>) %&gt;% select(Bodyweight)</span><br><span class="line">head(chowVals)</span><br><span class="line"><span class="comment">## dplyr接收的是data.frame ，返回的也是data.frame</span></span><br><span class="line"><span class="built_in">class</span>(chowVals) <span class="comment">#data.frame</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 为了使结果为向量，可以使用unlist函数。将list(包括data.frame)转换成numeric vectors. </span></span><br><span class="line">chowVals &lt;- filter(dat,Diet==<span class="string">&quot;chow&quot;</span>) %&gt;% select(Bodyweight) %&gt;% unlist</span><br><span class="line"><span class="comment">## 通道少写一个参数，但是这里的unlist连()都省了</span></span><br><span class="line"><span class="built_in">class</span>(chowVals) <span class="comment">#numeric </span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 不用dplyr的写法</span></span><br><span class="line">chowVals &lt;- dat[dat$Diet==<span class="string">&quot;chow&quot;</span>,<span class="string">&quot;Bodyweight&quot;</span>]</span><br><span class="line">head(chowVals)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 小结，感觉R整理数据就是不太方便。</span></span><br></pre></td></tr></table></figure>
<h2 id="inference">inference</h2>
<p>以下为random variable,  null distribution,  p-value 的 简要介绍。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#inference</span></span><br><span class="line">setwd(<span class="string">&#x27;D:\\Desktop\\下载英文文献\\模型\\R_model&#x27;</span>)</span><br><span class="line">dat &lt;- read.table(<span class="string">&#x27;female_mouse_weights.txt&#x27;</span>,header = <span class="built_in">T</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#####didtribution 的解析</span></span><br><span class="line"><span class="comment">#distribution：可以简单地理解为一堆数。</span></span><br><span class="line"><span class="comment">#比如你测量了一个群体中所有人的身高。</span></span><br><span class="line"><span class="comment">#这个时候你要和其他人不懂的人（such as analien that has never visited Earth）描述这些数字。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#假如以下就是你取得的身高数据</span></span><br><span class="line">library(UsingR)</span><br><span class="line">x &lt;- father.son$fheight</span><br><span class="line"></span><br><span class="line"><span class="comment">#最简单的就是列出来给外星人看</span></span><br><span class="line"><span class="built_in">round</span>(sample(x,<span class="number">10</span>),<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#但这不够充分，我们可以定义一个累积分布函数（Cumulative Distribution Function）</span></span><br><span class="line"><span class="comment">#F(a) == Pr(x&lt;a) #小于等于号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#画图如下</span></span><br><span class="line"><span class="comment"># floor ceiling 是取整用的</span></span><br><span class="line"><span class="comment"># floor 是直接取整数，ceiling 是 “天花板” </span></span><br><span class="line"><span class="comment"># 如 floor(2.99) = 2 ceiling(2.99) = 3</span></span><br><span class="line"><span class="comment"># 用在画图还是挺好的</span></span><br><span class="line"></span><br><span class="line">smallest&lt;-<span class="built_in">floor</span>( <span class="built_in">min</span>(x) )</span><br><span class="line">largest&lt;-<span class="built_in">ceiling</span>( <span class="built_in">max</span>(x) )</span><br><span class="line">values&lt;-seq(smallest, largest,len=<span class="number">300</span>)</span><br><span class="line">heightecdf&lt;-ecdf(x)</span><br><span class="line">plot(values, heightecdf(values), type=<span class="string">&quot;l&quot;</span>,xlab=<span class="string">&quot;a (Height in inches)&quot;</span>,ylab=<span class="string">&quot;Pr(x &lt;= a)&quot;</span>)</span><br><span class="line"><span class="comment"># 但是现在更常见的是画直方图</span></span><br><span class="line"><span class="comment"># 把直方图给外星人一看，基本就很清晰了。</span></span><br><span class="line">hist(x)</span><br><span class="line">bins&lt;-seq(smallest, largest)</span><br><span class="line">hist(x,breaks=bins,xlab=<span class="string">&quot;Height (in inches)&quot;</span>,main=<span class="string">&quot;Adult men heights&quot;</span>)</span><br><span class="line"><span class="comment">#breaks设置中，不用floor,ceiling 画不成图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####回到正题</span></span><br><span class="line">library(dplyr)</span><br><span class="line">control &lt;- filter(dat,Diet==<span class="string">&quot;chow&quot;</span>) %&gt;% select(Bodyweight) %&gt;% unlist</span><br><span class="line">treatment  &lt;- filter(dat,Diet==<span class="string">&quot;hf&quot;</span>) %&gt;% select(Bodyweight) %&gt;% unlist</span><br><span class="line">mean(treatment)</span><br><span class="line">mean(control)</span><br><span class="line">obsdiff &lt;- mean(treatment) - mean(control)</span><br><span class="line">obsdiff</span><br><span class="line"><span class="comment">#[1] 3.020833</span></span><br><span class="line"><span class="comment">#只看均值和差值是不够的</span></span><br><span class="line"><span class="comment">#因为如果你再取24只老鼠重新做试验，每一次都能得到一个新的结果。</span></span><br><span class="line"><span class="comment">#我们把具有这种特性的数据称为随机变量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####更深刻地理解随机变量###########</span></span><br><span class="line"><span class="comment"># 假设我们有所有的control群体，如下</span></span><br><span class="line">library(downloader)</span><br><span class="line">url&lt;-<span class="string">&quot;https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extdata/femaleControlsPopulation.csv&quot;</span></span><br><span class="line">filename&lt;-<span class="string">&quot;femaleControlsPopulation.csv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!file.exists(filename)) download(url,destfile=filename)</span><br><span class="line"><span class="comment">#如果文件不存在则下载</span></span><br><span class="line"></span><br><span class="line">population&lt;-read.csv(filename)</span><br><span class="line"></span><br><span class="line">population &lt;- unlist(population) <span class="comment">#从data.frame 转为 vector</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#从总体中每次随机抽取12只老鼠，重复三次，每次均值均不同</span></span><br><span class="line"></span><br><span class="line">control&lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">mean(control)</span><br><span class="line"><span class="comment">#[1] 23.4925</span></span><br><span class="line"></span><br><span class="line">control&lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">mean(control)</span><br><span class="line"><span class="comment">#[1] 24.96583</span></span><br><span class="line"></span><br><span class="line">control&lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">mean(control)</span><br><span class="line"><span class="comment">#[1] 22.90083</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#因此哪怕同一个群体，抽取不同的样本，之间也是有差异的。</span></span><br><span class="line"><span class="comment">#所以对于上面两个群体的obsdiff，我们存有怀疑，这究竟是不是因为影响因素（diet）造成的</span></span><br><span class="line"><span class="comment">#如果我们给这24只老鼠相同的diet，差异还有有这么大吗？</span></span><br><span class="line"><span class="comment">#出于怀疑精神，一般统计推断的零假设（null hypothesis）会设定为两个群体没有区别。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#由于我们有了control的总体，所以我们可以无限次抽样。</span></span><br><span class="line"><span class="comment">#每次从control的群体中，抽2批12只老鼠，求均值。代码如下</span></span><br><span class="line"></span><br><span class="line">control&lt;-sample(population,<span class="number">12</span>)</span><br><span class="line"><span class="comment">##another 12 control mice that we act as if they were not</span></span><br><span class="line">treatment &lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">print(mean(treatment)-mean(control))</span><br><span class="line"><span class="comment">#[1] -1.175</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#现在让我们重复这一步骤10000次</span></span><br><span class="line"></span><br><span class="line">null &lt;- vector()</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">10000</span>)&#123;</span><br><span class="line">  control&lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">  treatment &lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">  null[i] &lt;- mean(treatment)-mean(control)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在在null中的值我们称之为null distribution</span></span><br><span class="line"></span><br><span class="line">mean(null&gt;=obsdiff)</span><br><span class="line"><span class="comment"># [1] 0.0147</span></span><br><span class="line"><span class="comment">#mean里面的是一个布尔向量，由TRUE和FALSE组成</span></span><br><span class="line"><span class="comment">#但是在计算的过程中，TRUE视为1，FALSE视为0。</span></span><br><span class="line"><span class="comment">#所以这个0.0147是这10000次中差距大于obsdiff的比例。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#因此作为一个怀疑主义者，我们可以得出结论</span></span><br><span class="line"><span class="comment">#如果没有diet effect，我们看到像obsdiff这么的差距的可能性是1.47%</span></span><br><span class="line"><span class="comment">#这就是所谓的P值！</span></span><br><span class="line"><span class="comment">#p值即原假设成立的前提下，此事件发生的概率。</span></span><br><span class="line"><span class="comment">#深入浅出，厉害！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#小结一下，像上述这样计算P值很简单。但是生活中不可行。</span></span><br><span class="line"><span class="comment">#因为你不肯真的把测量整个群体的信息，从而构成null distribution。</span></span><br><span class="line"><span class="comment">#一般也还是通过采样。</span></span><br><span class="line"><span class="comment">#也就是还是只通过数据中的24只老鼠的数据进行判断。</span></span><br></pre></td></tr></table></figure>
<h3 id="population-parameters">population parameters</h3>
<p>统计推断的第一步是弄清楚你感兴趣的群体。作者选这个这个小鼠的数据集的原因之一，是因为作者有所有这种类型的小鼠的体重信息（即这个群体的所有群体）。</p>
<p>如果你能收集你感兴趣的群体的所有数据，那么得到的参数（群体均值、方差、标准差）就被称为群体参数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(downloader)</span><br><span class="line">url&lt;-<span class="string">&quot;https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extdata/mice_pheno.csv&quot;</span></span><br><span class="line">filename&lt;-<span class="string">&quot;mice_pheno.csv&quot;</span> </span><br><span class="line">download(url,destfile=filename)</span><br><span class="line">dat&lt;-read.csv(filename) <span class="comment">#这是所有这个小鼠群体的数据</span></span><br><span class="line"></span><br><span class="line">library(dplyr)</span><br><span class="line">controlPopulation &lt;- filter(dat,Sex==<span class="string">&quot;F&quot;</span>&amp;Diet==<span class="string">&quot;chow&quot;</span>) </span><br><span class="line"><span class="built_in">length</span>(controlPopulation$Bodyweight)</span><br><span class="line"></span><br><span class="line">hfPopulation&lt;-filter(dat,Sex==<span class="string">&quot;F&quot;</span>&amp;Diet==<span class="string">&quot;hf&quot;</span>)</span><br><span class="line"><span class="built_in">length</span>(hfPopulation$Bodyweight)</span><br><span class="line"><span class="comment">#此时群体的均值、方差、标准差等就被称为群体参数（population parameters）</span></span><br><span class="line"><span class="comment">#此时回到我们的问题，两个群体的均值是否相等。</span></span><br><span class="line"><span class="comment">#由于我们拿到了两个群体的所有数据，那么用μy-ux（x:control y:hf）,直接看差值是否为0即可。</span></span><br></pre></td></tr></table></figure>
<p>但是，在实际生活中，我们拿不到群体的所有数据。比如，可能买下一个群体所有的小鼠是很贵的。<br>
因此，我们需要学会如何从样本数据来回答我们的问题。这就是统计推断的本质。</p>
<h3 id="Sample-estimates">Sample estimates</h3>
<p>在之前的章节中，我们从两个群体中各随机抽取了12只小鼠。我们一般用大写字母来表示抽样个体，以此表明他们是随机抽取的。这也是统计中的一种常规做法。因此抽样个体表示为X~1~ ……X~12~ 和 Y~1~ …… Y~12~。<br>
而对于上面的群体中的个体，用的是小写数字。因为这些个体是给定的，不是随机的。<br>
此时，研究目标是两个样本群体均值的差值。<br>
而这个差值也是一个随机变量（random variable）。前面，我们采用一种从原始数据中重复抽样的手段（10000次）。但是，这在实际中（in practice）是不可实现的，比如在我们这个例子中，就是要不断地买24只小鼠做试验。<br>
下面会介绍群体均值差与样本均值差的关系。这涉及到了中心极限定理。</p>
<h3 id="Central-Limit-Theorem-and-t-distribution">Central Limit Theorem and t-distribution</h3>
<p><strong>中心极限定理</strong>：<strong>无论群体总体服从什么分布</strong>，当抽样个体数足够大时（一般认为，每组大于等于30个），抽样群体的均值（Y拔）服从正态分布。其均值为群体均值，其标准差等于群体标准差除以根号N（N 为 simple size）。我们把这个随机变量分布的标准差称为标准误（<em>standard error</em>）。</p>
<ul>
<li>对于一个随机变量，加减常数（X+a），则该随机变量的均值也随之变化（u~X~+a）</li>
<li>对于一个随机变量，乘以一个常数（X*a），则该随机变量的均值和标准差也乘以此常数</li>
<li>对于两个独立的随机变量相加（X+Y），其均值为μ~X~+μ~Y~，其方差为二者之和。如果是两个独立的随机变量相减，其均值为二者之差，其方差仍未<strong>二者之和</strong>。</li>
<li>如果两个随机变量都满足正态分布，那么它们只和仍满足正态分布。</li>
</ul>
<p>在本例中，我们关心的两个群体的均值，由于中心极限定理，服从正态分布。因此它们的差值也服从正态分布，均值为两个随机变量之差，方差为<strong>两个随机变量之和</strong>。由于原假设是不存在差异，那么两个群体的均值的均值应该大致服从一个均值为0，标准差为√（σ2X+σ2Y）/√N的正态分布。<br>
也就是如下式</p>
<p><img src="clt.png" alt="clt"></p>
<p>这个进行了标准化的随机变量应该满足（0，1）的标准正态分布。（深入浅出！）</p>
<p>根据这个公式，我们可以更快地求出P值（已知标准正态分布）。例如，正态分布中大于2的值只有5%（in absolute value，应该是双尾的意思）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">pnorm(-<span class="number">2</span>)+(<span class="number">1</span>-pnorm(<span class="number">2</span>))</span><br><span class="line"><span class="comment">## [1] 0.04550026</span></span><br></pre></td></tr></table></figure>
<p>因此，我们不用再买更多的小鼠，24只够了。</p>
<p>然而，事情到这一步还没有结束。因为我们不知道群体的标准差，σ~X~和σ~Y~。这些都是不可知的群体参数。但是我们可以用样本标准差去估计群体标准差，称为s~X~ 和 s~Y~。定义如下：</p>
<p><img src="s2.png" alt="s2"></p>
<p>这里是除以M-1 和 N-1（出于理论原因，没解释）。</p>
<p>因此，我们可以把上式改为：</p>
<p><img src="clt_new.png" alt="t_value"></p>
<p>中心极限定理告诉我们，当M,N较大时，这个随机变量服从标准正态分布（零假设下）。因此，我们现在可以计算P值了。</p>
<h3 id="t-分布">t 分布</h3>
<p>中心极限定理需要较大的抽样个体数，这个我们称之为<em>asymptotic results</em>。当这个条件不满足时，还有一种方法可以使用。如果总体数据服从一个均值为0的正态分布，那么对于我们的抽样个体均值，可以计算以下分布，称为t分布：</p>
<p><img src="t-distribution.png" alt="t-distribution"></p>
<p>这里很重要的一点，我们提到的服从正态分布是总体（y1,y2,……yn）服从正态分布，而不是Y拔。虽然无法实际证明，但是我们看一看抽样个体的分布。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">control &lt;- controlPopulation$Bodyweight</span><br><span class="line">hf &lt;- hfPopulation$Bodyweight</span><br><span class="line"><span class="comment"># 直方图</span></span><br><span class="line">op &lt;- par(mfrow = <span class="built_in">c</span>(<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line">hist(control)</span><br><span class="line">hist(hf)</span><br><span class="line">par(op)</span><br></pre></td></tr></table></figure>
<p>更为直观的是，画一个QQ（quantie，分位数）图。分位数的实例之一就是四分位数。QQ图的个人理解为，对于x轴上的一点，能得到x分布中小于等于这个点的概率（比如5%）; 再找到y分布中对应5%概率的实际数值，即y值，这样就得到了一个点（x,y)。</p>
<ul>
<li>如果是离散变量，</li>
</ul>
<blockquote>
<p>在统计学中，QQ图[1] （Q代表分位数Quantile）是一种通过比较两个概率分布的分位数对这两个概率分布进行比较的概率图方法。首先选定分位数的对应概率区间集合，在此概率区间上，点(x,y)对应于第一个分布的一个分位数x和第二个分布在和x相同概率区间上相同的分位数。因此画出的是一条含参数的曲线，参数为概率区间的分割数。</p>
</blockquote>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">op &lt;- par(mfrow = <span class="built_in">c</span>(<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line">qqnorm(hf)</span><br><span class="line">qqline(hf)</span><br><span class="line">qqnorm(control)</span><br><span class="line">qqline(control)</span><br><span class="line">par(op)</span><br></pre></td></tr></table></figure>
<p>在R中，var() 和 sd() 函数都是用于计算样本参数（即除以n-1）。不适用于计算群体参数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x &lt;- control</span><br><span class="line">N &lt;- <span class="built_in">length</span>(x)</span><br><span class="line">populationvar &lt;- mean((x-mean(x))^<span class="number">2</span>)</span><br><span class="line">identical(var(x),populationvar)</span><br><span class="line"><span class="comment">#identical 判断两个值是否相等。</span></span><br><span class="line"><span class="comment">#R中的var() 和 sd() 都是除以n-1。</span></span><br></pre></td></tr></table></figure>
<p>但是实际中，我们没有用到计算总体参数的地方（得不到）。这里为了教学，用了popvar(), popsd() 函数 计算总体参数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(<span class="string">&#x27;rafalib&#x27;</span>)</span><br><span class="line">sd_hf &lt;- popsd(hf)</span><br><span class="line">sd_control &lt;- popsd(control)</span><br></pre></td></tr></table></figure>
<p>一般我们也只能得到样本，如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N &lt;- 12</span><br><span class="line">hf_sample &lt;- sample(hf,<span class="number">12</span>)</span><br><span class="line">control_sample &lt;- sample(control,<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<p>为了 进一步了解中心极限定理，这里采用不同的抽样大小进行抽样</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对不同地抽样个体数，抽样10000次</span></span><br><span class="line"><span class="comment">#sapple 对Ns中的每一个数，执行后面的函数</span></span><br><span class="line">Ns&lt;-<span class="built_in">c</span>(<span class="number">3</span>,<span class="number">12</span>,<span class="number">25</span>,<span class="number">50</span>)</span><br><span class="line">B &lt;-  10000   <span class="comment">#number of simulations</span></span><br><span class="line">res&lt;-sapply(Ns,<span class="keyword">function</span>(n) &#123;</span><br><span class="line">  replicate(B,mean(sample(hf,n))-mean(sample(control,n)))</span><br><span class="line">&#125;)</span><br><span class="line">res</span><br><span class="line"></span><br><span class="line"><span class="comment">## 现在我们可以用qq图看中心极限定理的效果如何</span></span><br><span class="line">op &lt;- par(mfrow=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> seq(along=Ns)) &#123;    <span class="comment"># 等于 seq(length(Ns))</span></span><br><span class="line">  titleavg&lt;-<span class="built_in">signif</span>(mean(res[,i]),<span class="number">3</span>) <span class="comment">#signif和round差不多，不过后面不是小数位数，而是有效数字。</span></span><br><span class="line">  titlesd&lt;-<span class="built_in">signif</span>(popsd(res[,i]),<span class="number">3</span>)</span><br><span class="line">  title&lt;-paste0(<span class="string">&quot;N=&quot;</span>,Ns[i],<span class="string">&quot;Avg=&quot;</span>,titleavg,<span class="string">&quot;SD=&quot;</span>,titlesd)</span><br><span class="line">  qqnorm(res[,i],main=title)</span><br><span class="line">  qqline(res[,i],col=<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#随着抽样数目的增加，标准误越小。基本符合根号N的规律。</span></span><br><span class="line"><span class="comment">#即便抽样数目为3，也基本符合正态分布。</span></span><br><span class="line"><span class="comment">#这和总体分布有关。因为我们这个小鼠体重分布本身就接近正态分布。哪怕采样个体为1，也会符合正态分布。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是在实践中，我们不会只求均值，而是会除以标准差。此时采样个数就重要了</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Ns&lt;-<span class="built_in">c</span>(<span class="number">3</span>,<span class="number">12</span>,<span class="number">25</span>,<span class="number">50</span>)</span><br><span class="line">B&lt;-<span class="number">10000</span><span class="comment">#number of simulations#</span></span><br><span class="line"><span class="comment">#function to compute a t-stat</span></span><br><span class="line">computetstat&lt;-<span class="keyword">function</span>(n) &#123;</span><br><span class="line">  y&lt;-sample(hfPopulation,n)</span><br><span class="line">  x&lt;-sample(controlPopulation,n)</span><br><span class="line">  (mean(y)-mean(x))/<span class="built_in">sqrt</span>(var(y)/n+var(x)/n)</span><br><span class="line">  &#125;</span><br><span class="line">res&lt;-sapply(Ns,<span class="keyword">function</span>(n) &#123;</span><br><span class="line">  replicate(B,computetstat(n))</span><br><span class="line">  &#125;)</span><br><span class="line">op &lt;- par(mfrow=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> seq(along=Ns)) &#123;</span><br><span class="line">  qqnorm(res[,i],main=Ns[i])</span><br><span class="line">  qqline(res[,i],col=<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">#此时N=3已经有些偏离，而N=12只有轻微偏离</span></span><br><span class="line"><span class="comment">#因此N=12已经够了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是这种模拟在实际中无法做到。这里只用于说明CLT的概念和局限。</p>
<h3 id="t-tests-in-Partice">t-tests in Partice</h3>
<p>逻辑线：</p>
<ol>
<li>首先我们得到了两个样本群体的均值差，这本身也是一个随机变量。而且根据零假设，这个变量分布的均值为0。</li>
<li>那么这个均值差分布的标准误（差）呢？</li>
<li>首先我们根据中心极限定理，每个群体均值服从正态分布，标准误为总体标准差（这里直接用样本标准差估计总体标准差）除以根号N。</li>
<li>但这仅仅是每个样本均值的标准误（或者说标准差，其实我觉得这里说标准误和标准差是一回事，标准误就是均值的标准差，所以不还是标准差吗？这里说的均值差的标准误其实也就是均值差的标准差。）</li>
<li>我们根据统计理论，我们知道两个随机变量差值的方差等于这两个随机变量的方差之和（var(x-y)=var(x)+var(y))</li>
<li>因此se = sd( x-y ) = sqrt(var(x)+var(y)) =  sqrt( sd(x)/sqrt(n) + (sd(y)/sqrt(m) )</li>
<li>tstat &lt;- diff(-0)/se</li>
<li>这就是t统计量，由于除以了se，这个统计量的SE为1。</li>
<li>因此我们只要知道这个t统计量的分布，我们就能得到P值。</li>
<li>根据中心极限定理，当<strong>抽样个体数较大</strong>时，两个抽样均值均符合正态分布。根据统计理论，那么这两个随机变量之差也服从正态分布。因此此时这个tstat也是服从<strong>均值为0，方差为1的正态分布</strong></li>
<li>那么计算为了计算P值，我们需要问：在正态分布中，出现diff或比diff（tstat）更极端的值的概率是多大？（ how often does a normally distributed randomvariable exceeddiff?）我们可以通过pnorm()函数进行计算双尾概率。</li>
<li>在本例中，p-value 小于 0.05， 我们认为差异是显著的。（深入理解P值，P值是零假设成立下该事件发生的概率）</li>
<li>但是我们又面临另一个问题。中心极限定理只有在样本量较大时适用，但是12足够大了吗？一般我们认为样本数大于30才比较好。所以我们刚刚计算的P值只有在这个成立时才有效，所以这里可能不适用。然而，除了使用中心极限定理，我们这里有另一种方法。</li>
</ol>
<p>R代码如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dat&lt;-read.csv(<span class="string">&quot;femaleMiceWeights.csv&quot;</span>)<span class="comment">#previously downloaded</span></span><br><span class="line">control&lt;-filter(dat,Diet==<span class="string">&quot;chow&quot;</span>)%&gt;%select(Bodyweight)%&gt;%unlist</span><br><span class="line">treatment&lt;-filter(dat,Diet==<span class="string">&quot;hf&quot;</span>)%&gt;%select(Bodyweight)%&gt;%unlist</span><br><span class="line">diff&lt;-mean(treatment)-mean(control)</span><br><span class="line">print(diff)</span><br><span class="line"><span class="comment">## [1] 3.020833</span></span><br><span class="line"></span><br><span class="line">se&lt;-<span class="built_in">sqrt</span>(</span><br><span class="line">  var(treatment)/<span class="built_in">length</span>(treatment) + </span><br><span class="line">    var(control)/<span class="built_in">length</span>(control)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">tstat&lt;-diff/se</span><br><span class="line"><span class="comment">## [1] 2.055174</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##tstat在标准正态分布中出现的概率(双尾)</span></span><br><span class="line"><span class="comment">##也就是在标准正态分布中出现tstat及比tstat更极端的值的概率</span></span><br><span class="line">righttail&lt;-<span class="number">1</span>-pnorm(<span class="built_in">abs</span>(tstat))</span><br><span class="line">lefttail&lt;-pnorm(-<span class="built_in">abs</span>(tstat))</span><br><span class="line">pval&lt;-lefttail+righttail</span><br><span class="line">print(pval)</span><br><span class="line"></span><br><span class="line"><span class="comment">## [1] 0.0398622</span></span><br></pre></td></tr></table></figure>
<h3 id="The-t-distribution-in-Practice">The t-distribution in Practice</h3>
<p>根据上面的模拟情况和统计理论。 如果<strong>总体的分布是正态的</strong>，那么我们可以<strong>不通过中心极限定理</strong>，而弄清楚t统计量的确切分布。但是如果抽样个体数很少，很难证明总体分布是否符合正态。但是对于体重这种数据，根据经验，我们一般认为总体分布极可能大致符合正态分布，因此我们可以利用这种近似。另外，我们也可以看一下样本的qq图，如下所示。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">op &lt;- par(mfrow=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">qqnorm(treatment)</span><br><span class="line">qqline(treatment,col=<span class="number">2</span>)</span><br><span class="line">qqnorm(control)</span><br><span class="line">qqline(control,col=<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果我们近似认为<strong>总体分布符合正态分布</strong>，那么基于统计理论，tstat服从t分布。相较于正态分布，t分布还有一个自由度的参数。我们直接通过下面的函数求解P值。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">t.test(treatment,control)</span><br><span class="line"></span><br><span class="line">t.test(treatment,control)$p.value <span class="comment">### 直接看P值</span></span><br><span class="line"><span class="comment">## [1] 0.05299888</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>The p-value is slightly bigger now. This is to be expected because our CLT approximation consideredthe denominator oftstatpractically fixed (with large samples it practically is), while the t-distribution approximation takes into account that the denominator (the standard error of thedifference) is a random variable. The smaller the sample size, the more the denominator varies.</p>
</blockquote>
<p>这段话没看太懂，大概理解是：这里用t分布计算出来的p值相较于上面用正态分布计算出来的P值较大。这是因为在CLT中，认为tstat的分母部分是固定的（也就是认为采用了大样本）；而t分布检验中认为tstat的分母部分是随机变量（还不是很懂）。</p>
<p>这可能会让人困惑，怎么会得到两个P值？但是，这在数据分析中是很常见的。通过不同的假设，不同的方法，我们就会得到不同的结果。</p>
<p>其实，基于中心极限定理得到的结果更容易出现<strong>假阳性</strong>，而基于t分布的结果更容易出现<strong>假阴性</strong>。</p>
<h3 id="Confidence-Intervals">Confidence Intervals</h3>
<p>在生命科学中，我们总是需要计算P值。但是我们并不推崇把P值当成唯一的统计指标。原因很简单：统计意义上的显著并不保证科学意义上的显著。当抽样个体数很大时，即便两个群体差异很小，你仍可以检测到一个统计意义上的显著差异。但是这有意义吗？如果只看P值，信息是不够的。还需要给出效应大小（这里是两个群体均值差）。<br>
另一种方法是给出置信区间。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#以control群体均值的置信区间为例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#先看总体的均值</span></span><br><span class="line">dat&lt;-read.csv(<span class="string">&quot;mice_pheno.csv&quot;</span>)</span><br><span class="line">chowPopulation&lt;-dat[dat$Sex==<span class="string">&quot;F&quot;</span>&amp;dat$Diet==<span class="string">&quot;chow&quot;</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">mu_chow&lt;-mean(chowPopulation)</span><br><span class="line">print(mu_chow)</span><br><span class="line"><span class="comment">## [1] 23.89338</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##我们是要估计这个参数，但是我们实际拿不到总体的数据</span></span><br><span class="line"><span class="comment">## 先抽取样本量为30的样本</span></span><br><span class="line"></span><br><span class="line">N&lt;-<span class="number">30</span></span><br><span class="line">chow&lt;-sample(chowPopulation,N)</span><br><span class="line">print(mean(chow))</span><br><span class="line"><span class="comment">## [1] 24.54567</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#我们知道样本均值是一个随机变量</span></span><br><span class="line"><span class="comment">#所以，这个值不是一个完美的估计</span></span><br><span class="line"><span class="comment">#通过置信区间来体现这个随机变量的variability</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#因为样本量为30，我们可以使用CLT。</span></span><br><span class="line"><span class="comment">#中心极限定理告诉我们，样本均值服从一个均值为总体均值，标准差为总体标准差除以根号30的正态分布。</span></span><br><span class="line"></span><br><span class="line">se&lt;-sd(chow)/<span class="built_in">sqrt</span>(N)</span><br><span class="line">print(se)</span><br><span class="line"><span class="comment">## [1] 0.6610814</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>A 95% confidence interval (we can use percentages other than 95%) is a random interval with a95% probability of falling on the parameter we are estimating. Keep in mind that saying 95% ofrandom intervals will fall on the true value (our definition above) isnot the sameas saying there isa 95% chance that the true value falls in our interval.(有点绕，没太懂。懂了，这个置信区间其实也是一个随机变量，你再抽一个样，这个置信区间也会变。所以你只能说置信区间（随机变量）从统计上说有95%的概率包含真值（你要是取10000个样本，计算出10000个置信区间，其中包含总体均值的概率在95%左右）。但是，如果是一个给定的区间(你最后计算出来的区间)，那么真值存在这个区间的概率只有0和1)</p>
</blockquote>
<p>由中心极限定理，我们可以对样本均值进行标准化。然后我们知道标准正态分布的95%区间大致在[-2,2]。因此可以得出下式</p>
<p><img src="confidence_interval.png" alt="confidence_interval"></p>
<p>我们直接得出置信区间</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Q&lt;-qnorm(<span class="number">1</span>-<span class="number">0.05</span>/<span class="number">2</span>)</span><br><span class="line">interval&lt;-<span class="built_in">c</span>(mean(chow)-Q*se, mean(chow)+Q*se )</span><br><span class="line">interval</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>模拟n次置信区间</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(rafalib)</span><br><span class="line">B&lt;-<span class="number">250</span></span><br><span class="line">mypar()</span><br><span class="line">plot(mean(chowPopulation)+<span class="built_in">c</span>(-<span class="number">7</span>,<span class="number">7</span>),<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>),type=<span class="string">&quot;n&quot;</span>,</span><br><span class="line">	xlab=<span class="string">&quot;weight&quot;</span>,ylab=<span class="string">&quot;interval&quot;</span>,ylim=<span class="built_in">c</span>(<span class="number">1</span>,B))</span><br><span class="line">	abline(v=mean(chowPopulation))</span><br><span class="line">	<span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:B) &#123;</span><br><span class="line">	chow&lt;-sample(chowPopulation,N)</span><br><span class="line">	se&lt;-sd(chow)/<span class="built_in">sqrt</span>(N)</span><br><span class="line">	interval&lt;-<span class="built_in">c</span>(mean(chow)-Q*se, mean(chow)+Q*se)</span><br><span class="line">	covered&lt;-</span><br><span class="line">		mean(chowPopulation) &lt;=interval[<span class="number">2</span>]&amp;mean(chowPopulation)&gt;=interval[<span class="number">1</span>]</span><br><span class="line">	color&lt;-ifelse(covered,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">	lines(interval, <span class="built_in">c</span>(i,i),col=color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个代码画出了250次置信区间的图（代码内容没看）。其中大概有5%的置信区间没有包含总体均值。</p>
<p>但是上面是因为抽样个体较多（N = 30），满足了中心极限定理。如果 N = 5，那么这样做也有效吗？我们就模拟这种N =5，使用CLT的情况。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N &lt;- 5</span><br><span class="line">mypar()</span><br><span class="line">plot(mean(chowPopulation)+<span class="built_in">c</span>(-<span class="number">7</span>,<span class="number">7</span>),<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>),type=<span class="string">&quot;n&quot;</span>,</span><br><span class="line">     xlab=<span class="string">&quot;weight&quot;</span>,ylab=<span class="string">&quot;interval&quot;</span>,ylim=<span class="built_in">c</span>(<span class="number">1</span>,B))</span><br><span class="line">abline(v=mean(chowPopulation))</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:B)&#123;</span><br><span class="line">  chow&lt;-sample(chowPopulation,N)</span><br><span class="line">  se&lt;-sd(chow)/<span class="built_in">sqrt</span>(N)</span><br><span class="line">  interval&lt;-<span class="built_in">c</span>(mean(chow)-Q*se, mean(chow)+Q*se)</span><br><span class="line">  covered&lt;- mean(chowPopulation) &lt;=interval[<span class="number">2</span>]&amp;mean(chowPopulation)&gt;=interval[<span class="number">1</span>]</span><br><span class="line">  color &lt;- ifelse(covered,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">  lines(interval, <span class="built_in">c</span>(i,i),col=color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们发现置信区间的宽度增加了，但是没有覆盖真值的情况却多了很多。这是因为这里我们通过CLT错误地认为样本均值符合正态分布，但是实际上相较于正态它两侧的尾巴更大（It has a fatter tail）。这影响到了我们Q值的计算（这里是-2到2）。这种情况下，采用t分布更合适。所以我们只需用qt() 函数来计算Q就可以了，其它不变。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N &lt;- 5</span><br><span class="line">Q&lt;-qt(<span class="number">1</span>-<span class="number">0.05</span>/<span class="number">2</span>, df=<span class="number">4</span>)</span><br><span class="line">mypar()</span><br><span class="line">plot(mean(chowPopulation)+<span class="built_in">c</span>(-<span class="number">7</span>,<span class="number">7</span>),<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>),type=<span class="string">&quot;n&quot;</span>,</span><br><span class="line">     xlab=<span class="string">&quot;weight&quot;</span>,ylab=<span class="string">&quot;interval&quot;</span>,ylim=<span class="built_in">c</span>(<span class="number">1</span>,B))</span><br><span class="line">abline(v=mean(chowPopulation))</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:B)&#123;</span><br><span class="line">  chow&lt;-sample(chowPopulation,N)</span><br><span class="line">  se&lt;-sd(chow)/<span class="built_in">sqrt</span>(N)</span><br><span class="line">  interval&lt;-<span class="built_in">c</span>(mean(chow)-Q*se, mean(chow)+Q*se)</span><br><span class="line">  covered&lt;- mean(chowPopulation) &lt;=interval[<span class="number">2</span>]&amp;mean(chowPopulation)&gt;=interval[<span class="number">1</span>]</span><br><span class="line">  color &lt;- ifelse(covered,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">  lines(interval, <span class="built_in">c</span>(i,i),col=color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们看到置信区间的宽度<strong>进一步</strong>（相较于CLT）增加了（因为t分布尾巴厚，得到的Q值更大），但是基本符合了95%的概率。</p>
<h3 id="置信区间和P值的关系">置信区间和P值的关系</h3>
<p>我们推荐在实际中更多的使用置信区间，而不是P值。</p>
<p>如果你给出P值，我们会问差距是不是真的像你计算或观测出来的值那么大。<strong>因为即便两个群体总体均值为0，得到的样本均值差也有可能出现你计算或观测的结果</strong>。因此，我们可以给出均值差的置信区间，来回答这个问题。</p>
<p>如果均值差的95%的置信区间中不包含0，那么我们可以说差异不显著（0.05水平下），也就是p值肯定小于0.05。（99%的置信区间类似）</p>
<p>t.test的结果中包含了95%的置信区间。</p>
<h3 id="Power-Calculations">Power Calculations</h3>
<p>由于我们有总体信息，我们从总体信息中可以直接得知，这两个群体确实是有差距的，而且按比例大约是10%。<br>
但是我们如果从中取样，然后进行t-test，有的时候P值不总是小于0.05。</p>
<p>所以我们犯错了吗？通过不拒绝原假设，我们要说diet没有影响吗？这个问题的答案是no。All we can say is that we did not reject the null hypothesis. But this does not necessarily imply that the null is true（我们只是说不拒绝原假设，但我们没有说原假设是真的）.</p>
<p>这个问题的本质是这样，在这次的实例中，我们没有得到足够的power（不知道啥意思）。在科学研究中，你很可能需要做某种程度的power calculation。在很多情况下，这是一种道德义务，来避免不必要地牺牲更多小鼠，或者使人们因为你的研究遭遇潜在的风险。</p>
<h4 id="types-of-error">types of error</h4>
<blockquote>
<p>Ⅰ型错误：原假设为真，我们拒绝的概率，等于P值<br>
Ⅱ型错误：原假设为假，没有拒绝原假设的概率</p>
</blockquote>
<p>当我们在进行统计检验时，我们始终需要注意我们很可能会犯错误。这就是为什么我们的p值不是0。在原假设成立的前提下，总是存在一个可能很少，但是可能发生的概率，使得我们拒绝了正确的原假设。如果P值设为0.05，那么这种情况发生的概率也就是0.05。这种错误叫做Ⅰ型错误（typeⅠerror）</p>
<p>Ⅰ型错误会发生<strong>假阳性</strong>。那么我们为什么只设为0.05？不设定一个非常小的值呢？因为还存在另外一种错误，Ⅱ型错误，即原假设为假，没有拒绝原假设的概率，这会造成<strong>假阴性</strong>。像上面我们提到的那种情况，就是犯了二型错误。如果我们把P值提高到0.25，那么上面的例子就能够显著。但是一般情况下我们愿不愿意提高P值到0.25呢？通常我们不会这么做。</p>
<h4 id="0-05或0-01-的-p值-是随意划分的（The-0-05-and-0-01-Cut-offs-Are-Arbitrary）">0.05或0.01 的 p值 是随意划分的（The 0.05 and 0.01 Cut-offs Are Arbitrary）</h4>
<p>很多杂志和监管部门强调要达到0.05或0.01水平的显著。但是这两个数字的设定其实没有特别的，这仅仅是因为最开始的文章用这两个数字作为例子而已。本书的部分目的之一就是让读者对于P值和置信区间有一个更加清晰的认识（受教了）。</p>
<h4 id="Power-Calculation">Power Calculation</h4>
<p>Power is the probability of rejecting the null when the null is false（Power 是指当原假设为假时拒绝原假设的概率）。</p>
<p>下面我们通过R中的实际代码去理解这个概念。</p>
<p>我们仍然假设样本大小为12，显著水平时0.05。由于我们已经两个群体均值有差异，我们可以重复抽样，看每次抽样t检验是否小于0.05</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N&lt;-12</span><br><span class="line">alpha&lt;-0.05</span><br><span class="line">B&lt;-2000</span><br><span class="line"></span><br><span class="line">reject&lt;-function(N, alpha&#x3D;0.05)&#123;</span><br><span class="line">	hf&lt;-sample(hfPopulation,N)</span><br><span class="line">	control&lt;-sample(controlPopulation,N)</span><br><span class="line">	pval&lt;-t.test(hf,control)$p.value</span><br><span class="line">	pval&lt;alpha</span><br><span class="line">&#125;</span><br><span class="line">#reject 给出一次抽样是否小于0.05</span><br><span class="line"></span><br><span class="line">reject(12)</span><br><span class="line">## [1] FALSE</span><br><span class="line"></span><br><span class="line">rejections &lt;- replicate(B,reject(N))</span><br><span class="line">#重复2000次，replicate(n,expr) </span><br><span class="line"></span><br><span class="line">mean(rejetions) # 这就是N&#x3D;12时Power的值</span><br><span class="line">## [1] 0.2215</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这就是为什么当我们知道原假设是错的时，t-test却没有拒绝原假设。当样本大小只有12时，power只有23%。为了降低<strong>假阳性</strong>发生的概率，我们将P值设在0.05水平。其实这个水平有点过高，导致发生<strong>Ⅱ型错误</strong>的概率大大提高。</p>
<blockquote>
<p>power 和 发生Ⅱ型的概率 相加为1。power低，说明发生Ⅱ型错误的概率高。</p>
</blockquote>
<p>接下来，让我们来看看power和抽样大小N的关系。这里我们用到了<strong>sapply(Ns,expr)</strong>，这个函数会对向量中的每一个数执行同样的function。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Ns&lt;-seq(<span class="number">5</span>,<span class="number">50</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># So we use apply() like this</span></span><br><span class="line">power&lt;-sapply(Ns,<span class="keyword">function</span>(N)&#123;</span><br><span class="line">	rejections&lt;-replicate(B, reject(N))</span><br><span class="line">	mean(rejections)</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">plot(Ns,power,type = <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看出，随着N的增加，power不断提高。</p>
<p>我们固定N，看一看alpha的设定对power 的影响</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N&lt;-<span class="number">30</span></span><br><span class="line">alphas&lt;-<span class="built_in">c</span>(<span class="number">0.1</span>,<span class="number">0.05</span>,<span class="number">0.01</span>,<span class="number">0.001</span>,<span class="number">0.0001</span>)</span><br><span class="line">power&lt;-sapply(alphas,<span class="keyword">function</span>(alpha)&#123;</span><br><span class="line">	rejections &lt;- replicate(B,reject(N,alpha=alpha))</span><br><span class="line">	mean(rejections)</span><br><span class="line">&#125;)</span><br><span class="line">plot(alphas, power, xlab=<span class="string">&quot;alpha&quot;</span>, type=<span class="string">&quot;b&quot;</span>, <span class="built_in">log</span>=<span class="string">&quot;x&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看出随着alpha的增加，power也在不断增加。</p>
<blockquote>
<p>There is no “right” power or “right” alpha level, but it is important that you understand what eachmeans.</p>
</blockquote>
<h5 id="p-values-are-Arbitrary-under-the-Alternative-Hypothesis">p-values are Arbitrary under the Alternative Hypothesis</h5>
<blockquote>
<p>Another consequence of what we have learned about power is that p-values are somewhat arbitrarywhen the null hypothesis is not true and therefore thealternativehypothesis is true (the differencebetween the population means is not zero). When the alternative hypothesis is true, we can make a p-value as small as we want simply by increasing the sample size (supposing that we have an infinitepopulation to sample from). We can show this property of p-values by drawing larger and largersamples from our population and calculating p-values. This works because, in our case, we knowthat the alternative hypothesis is true, since we have access to the populations and can calculate thedifference in their means.</p>
</blockquote>
<p>随着样本大小的增加，P值会减小（假设群体无限大）。证明如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">calculatePvalue&lt;-<span class="keyword">function</span>(N) &#123;</span><br><span class="line">	hf&lt;-sample(hfPopulation,N)</span><br><span class="line">	control&lt;-sample(controlPopulation,N)</span><br><span class="line">	t.test(hf,control)$p.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ns&lt;-seq(<span class="number">10</span>,<span class="number">200</span>,by=<span class="number">10</span>)</span><br><span class="line">Ns_rep&lt;-<span class="built_in">rep</span>(Ns, each=<span class="number">10</span>) <span class="comment">#each 的形式是 10 10 10…… 20 ……</span></span><br><span class="line"></span><br><span class="line">pvalues&lt;-sapply(Ns_rep, calculatePvalue)</span><br><span class="line"></span><br><span class="line">plot(Ns_rep, pvalues, <span class="built_in">log</span>=<span class="string">&quot;y&quot;</span>, xlab=<span class="string">&quot;sample size&quot;</span>,</span><br><span class="line">ylab=<span class="string">&quot;p-values&quot;</span>)</span><br><span class="line">abline(h=<span class="built_in">c</span>(<span class="number">.01</span>,<span class="number">.05</span>), col=<span class="string">&quot;red&quot;</span>, lwd=<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>样本量从10增加到200的过程中，p值最低下降到了10^-8^。但是p值太低也不见得是一件很好的事。一旦我们确信了一个reasonable alpha（比如0.05），那么如果我们获得了一个比这个阈值低得多的p值，那就说明<strong>我们用了过量的小鼠</strong>。适当地提高样本量，确实有助于估计的准确性。但是，实际上，随着样本量的增加p值的降低是一件自然的事。</p>
<blockquote>
<p>The p-values get smaller and smaller with increasing sample size because the numerator ofthe t-statistic haspN(for equal sized groups, and a similar effect occurs whenM̸=N). Therefore,if∆is non-zero, the t-statistic will increase with N.</p>
</blockquote>
<p>事实上，随着样本量的增加，t-test得到的p值也会不断降低。这是t统计量中有一个根号N。</p>
<p>算了个Cohen’s d，但没看懂这个统计量到底有啥用？</p>
<blockquote>
<p>This tells us how many standard deviations of the data the mean of the high-fat diet group is from the control group. Under the alternative hypothesis, unlike the t-statistic which is guaranteed to increase, the effect size and Cohen’s d will become more precise.（看不懂）</p>
</blockquote>
<h3 id="Monte-Carlo-Simulation">Monte Carlo Simulation</h3>
<p>电脑可以用来产生伪随机数（pseudo-random numbers），一个最大的好处是我们可以通过模拟数据来证明我们的假设或理论。</p>
<blockquote>
<p>伪随机性（英语：Pseudorandomness）是一个过程似乎是随机的，但实际上并不是。例如伪随机数是使用一个确定性的算法计算出来的似乎是随机的数序，因此伪随机数实际上并不随机。在计算伪随机数时假如使用的开始值不变的话，那么伪随机数的数序也不变。</p>
</blockquote>
<p>Simulations can also be used to check theoretical or analytical results. Also, many of the theoretical results we use in statistics are based on <strong>asymptotics</strong>: they hold when the sample size goes to <a href="http://infinity.In">infinity.In</a> practice, we never have an infinite number of samples so we may want to know how well thetheory works with our actual sample size.</p>
<p>作为例子，我们蒙特卡洛模拟（ Monte Carlo simulation）来比较不同样本大小的情况下CLT和t分布的近似值。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(dplyr)</span><br><span class="line">dat&lt;-read.csv(<span class="string">&quot;mice_pheno.csv&quot;</span>)<span class="comment">#Previously downloaded</span></span><br><span class="line">controlPopulation&lt;-filter(dat,Sex==<span class="string">&quot;F&quot;</span>&amp;Diet==<span class="string">&quot;chow&quot;</span>)%&gt;%select(Bodyweight)%&gt;%unlist</span><br><span class="line"></span><br><span class="line">ttestgenerator&lt;-<span class="keyword">function</span>(n) &#123;</span><br><span class="line">  <span class="comment">#note that here we have a false &quot;high fat&quot; group where we actually</span></span><br><span class="line">  <span class="comment">#sample from the nonsmokers. this is because we are modeling the *null*</span></span><br><span class="line">  cases&lt;-sample(controlPopulation,n)</span><br><span class="line">  controls&lt;-sample(controlPopulation,n)</span><br><span class="line">  tstat&lt;-(mean(cases)-mean(controls))/<span class="built_in">sqrt</span>( var(cases)/n+var(controls)/n ) <span class="comment">#这个t统计量是假设两个群体方差不等</span></span><br><span class="line">  <span class="built_in">return</span>(tstat)</span><br><span class="line">  &#125;</span><br><span class="line">ttests&lt;-replicate(<span class="number">1000</span>, ttestgenerator(<span class="number">10</span>))</span><br><span class="line">hist(ttests)</span><br></pre></td></tr></table></figure>
<p>从直方图中，我们近似看出符合正态分布。但是从上文提到，我们再看一下QQ图</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qqnorm(ttests)</span><br><span class="line">qqline(ttests)</span><br></pre></td></tr></table></figure>
<p>从QQ图中，可以看出近似符合正态分布。这说明在样本数是10的情况下，已经符合正态分布，可以使用中心极限定理了。那么如果样本数为3呢？</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ttests&lt;-replicate(<span class="number">1000</span>, ttestgenerator(<span class="number">3</span>))</span><br><span class="line">qqnorm(ttests)</span><br><span class="line">qqline(ttests)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Now we see that the large quantiles, referred to by statisticians as the tails, are larger than expected(below the line on the left side of the plot and above the line on the right side of the plot).</p>
</blockquote>
<p>我们可以看出QQ图中左侧低于直线，右侧高于直线。这说明两侧的尾巴比正态分布要肥。</p>
<p>在之前的章节中，我们提到，如果<strong>样本数不大</strong> 并且 <strong>总体符合正态分布</strong> ，那么使用t分布是一种更好的近似。证明如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ps&lt;-(seq(<span class="number">0</span>,<span class="number">999</span>)+<span class="number">0.5</span>)/<span class="number">1000</span> <span class="comment">#0到1的均匀分布</span></span><br><span class="line">qqplot(qt(ps,df=<span class="number">2</span>*<span class="number">3</span>-<span class="number">2</span>),ttests,xlim=<span class="built_in">c</span>(-<span class="number">6</span>,<span class="number">6</span>),ylim=<span class="built_in">c</span>(-<span class="number">6</span>,<span class="number">6</span>))</span><br><span class="line"><span class="comment"># qt获得某t分布累积概率的数值</span></span><br><span class="line"><span class="comment"># qqplot比较两个变量分布是否相同</span></span><br><span class="line">abline(<span class="number">0</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>从中我们可以看出，t分布在这种情况下更为近似，但是仍不完美。这是因为<strong>总体并不是很好地符合正态分布</strong>。(从下面总体的QQ图中看出，总体略偏)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qqnorm(controlPopulation)</span><br><span class="line">qqline(controlPopulation)</span><br></pre></td></tr></table></figure>
<h3 id="Parametric-Simulations-for-the-Observations">Parametric Simulations for the Observations</h3>
<p>我们再这里使用蒙特卡洛模拟随机变量和假设检验，这是因为我们有总体数据。这是为了教学的作用，但在实际运用中是不可能的。一般采用蒙特卡洛模拟，主要用于参数估计（如均值和标准差）。</p>
<p>以小鼠体重的例子来说，我们通过先验知识，认识到小鼠的体重均值为24盎司，标准差为3.5盎司，而且小鼠体重近似符合正态分布。通过以上信息，我们可以构建一个总体数据。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">controls&lt;-rnorm(<span class="number">5000</span>, mean=<span class="number">24</span>, sd=<span class="number">3.5</span>)</span><br></pre></td></tr></table></figure>
<p>由于我们可以重复上述操作。因此我们不需要用到sample()函数了。代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ttestgenerator&lt;-function(n, mean&#x3D;24, sd&#x3D;3.5) &#123;</span><br><span class="line">  cases&lt;-rnorm(n,mean,sd)</span><br><span class="line">  controls&lt;-rnorm(n,mean,sd)</span><br><span class="line">  tstat&lt;-(mean(cases)-mean(controls))&#x2F;sqrt( var(cases)&#x2F;n+var(controls)&#x2F;n )</span><br><span class="line">  return(tstat)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Permutation-Tests">Permutation Tests</h3>
<p>假设我们遇到这样一种情况，没有一种标准的统计量能近似模拟我们的数据。</p>
<p>We have computed a summary statistic, such as the difference in mean, but do not have auseful approximation, such as that provided by the CLT.</p>
<p>这个时候 Permutation Tests 就派上用场了。</p>
<p>让我们回到最开始拿到的样本</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dat=read.csv(<span class="string">&quot;femaleMiceWeights.csv&quot;</span>)</span><br><span class="line">library(dplyr)</span><br><span class="line">control&lt;-filter(dat,Diet==<span class="string">&quot;chow&quot;</span>)%&gt;%select(Bodyweight)%&gt;%unlist</span><br><span class="line">treatment&lt;-filter(dat,Diet==<span class="string">&quot;hf&quot;</span>)%&gt;%select(Bodyweight)%&gt;%unlist</span><br><span class="line">obsdiff&lt;-mean(treatment)-mean(control)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>In previous sections, we showed parametric approaches that helped determine if the observeddifference was significant. Permutation tests take advantage of the fact that if we randomly shufflethe cases and control labels, then the null is true. So we shuffle the cases and control labels andassume that the ensuing distribution approximates the null distribution. Here is how we generate anull distribution by shuffling the data 1,000 times:</p>
</blockquote>
<p>这段话的大意是，之前我们是用带参数的方法（均值，标准差）检验差异是否显著。而这个Permutation tests 认为，如果我们随机洗牌 cases 和 control 的标签，那么零假设应该是正确的。<br>
下面我们洗牌了1000次。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N&lt;-<span class="number">12</span></span><br><span class="line">avgdiff&lt;-replicate(<span class="number">1000</span>, &#123;</span><br><span class="line">  <span class="built_in">all</span>&lt;-sample(<span class="built_in">c</span>(control,treatment))</span><br><span class="line">  newcontrols&lt;-<span class="built_in">all</span>[<span class="number">1</span>:N]</span><br><span class="line">  newtreatments&lt;-<span class="built_in">all</span>[(N+<span class="number">1</span>):(<span class="number">2</span>*N)]</span><br><span class="line">  <span class="built_in">return</span>(mean(newtreatments)-mean(newcontrols))</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">#这个&#123;&#125;好像是不带名称的函数，类似于Python中的lambda</span></span><br><span class="line"><span class="comment">#sample(x)不加n,就是重排（permutation）的意思</span></span><br><span class="line">hist(avgdiff)</span><br><span class="line">abline(v=obsdiff, col=<span class="string">&quot;red&quot;</span>, lwd=<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>How many of the null means are bigger than the observed value? That proportion would be thep-value for the null. We add a 1 to the numerator and denominator to account for misestimation ofthe p-value</p>
</blockquote>
<p>在这1000次中，有多少比例大于这个obsdiff，这就是P值。但是，分子分母要都加上一个1。（个人理解实际上是做了1001次，没有算上真实情况）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">sum</span>(<span class="built_in">abs</span>(avgdiff)&gt;<span class="built_in">abs</span>(obsdiff))+<span class="number">1</span>)/(<span class="built_in">length</span>(avgdiff)+<span class="number">1</span>)</span><br><span class="line"><span class="comment">## [1] 0.05594406</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在我们把这个用在样本量更小的数据集，比如样本量为5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N&lt;-5</span><br><span class="line">control&lt;-sample(control,N)</span><br><span class="line">treatment&lt;-sample(treatment,N)</span><br><span class="line">obsdiff&lt;-mean(treatment)-mean(control)</span><br><span class="line"></span><br><span class="line">avgdiff&lt;-replicate(1000, &#123;</span><br><span class="line">  all&lt;-sample(c(control,treatment))</span><br><span class="line">  newcontrols&lt;-all[1:N]</span><br><span class="line">  newtreatments&lt;-all[(N+1):(2*N)]</span><br><span class="line">  return(mean(newtreatments)-mean(newcontrols))</span><br><span class="line">&#125;)</span><br><span class="line">hist(avgdiff)</span><br><span class="line">abline(v&#x3D;obsdiff, col&#x3D;&quot;red&quot;, lwd&#x3D;2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在可以明显看出差距不显著了。</p>
<blockquote>
<p>Now the observed difference is not significant using this approach. Keep in mind that there is notheoretical guarantee that the null distribution estimated from permutations approximates the actualnull distribution. For example, if there is a real difference between the populations, some of the permutations will be unbalanced and will contain some samples that explain this difference. This implies that the null distribution created with permutations will have larger tails than the actualnull distribution. This is why permutations result in conservative p-values. For this reason, whenwe have few samples, we can’t do permutations.</p>
</blockquote>
<p>没看懂，结论是数据量小时，不用这种permutation test</p>
<p>而且permutation test 也有假设：<strong>:samples are assumed to be independentand “exchangeable”</strong> 。 If there is hidden structure in your data, then permutation tests can result in estimated null distributions that underestimate the size of tails because the permutations may destroy the existing structure in the original data.</p>
<h3 id="Association-Tests">Association Tests</h3>
<p>前面的统计分析中，忽略了一类重要的数据，二元或者说分类数据。举个例子，当你有两种疾病的基因型的群体(AA/Aa 与 aa)作为cases 和 control。我们要提出的问题是，这个基因型与疾病是否有关系。<br>
这里疾病状况表示为0和1，那么我们为什么不能用t-test？因为数据要么是0要么是1，很明显不会符合正态分布，因此不能使用t-test。</p>
<p>如果样本数量很大的话，我们可以使用CLT。不然的话，我们就可以使用Association Tests。</p>
<h4 id="二项分布与超几何分布">二项分布与超几何分布</h4>
<p>解释: 我的这种算法是基于二项分布，而Fisher’s exact test是基于超几何分布（hypergeometric distribution）。<br>
二项分布</p>
<ol>
<li>试验次数固定</li>
<li>每一次事件都有两个可能的结果</li>
<li><strong>每次试验中的事件相互独立</strong></li>
<li><strong>每一次成功的概率相等</strong></li>
</ol>
<p>超几何分布 它描述了由<strong>有限个物件中</strong>抽出n个物件，成功抽出指定种类的物件的个数（不归还 （without replacement））。</p>
<p>例如在有N个样本，其中K个是不及格的。超几何分布描述了在该N个样本中抽出n个，其中k个是不及格的概率。</p>
<p>特点：</p>
<ol>
<li>每次抽取也只有两个互斥的结果</li>
<li><strong>每次抽取后成功的概率发生改变</strong>（因为是不放回抽样，这也导致了每次抽取事件不独立）</li>
</ol>
<h4 id="Lady-Tasting-Tea">Lady Tasting Tea</h4>
<p>R.A.Fisher 的一位熟人宣称她能分辨牛奶是早于或晚于茶放入杯中（就是牛奶和茶混合的顺序）。Fisher 就和她做了一个小实验，4次中对了3次。那么，我们能否说明这位女士存在这种特殊的能力呢？这个例子被称为&quot;Lady tasting tea&quot;。<br>
按照之前的经验。一个基本的问题是，如果这位女士仅仅靠猜，她能得到3/4或更高的正确率(即3/4+4/4)的概率是多少？<br>
仍和之前一样，我们需要计算在零假设成立的前提下事情发生的概率。这里的零假设就是这位女士都是猜的。</p>
<blockquote>
<p>he basic question we ask is: if the tester is actually guessing, what are the chances that she gets 3 ormore correct? Just as we have done before, we can compute a probability under the null hypothesisthat she is guessing four of each. If we assume this null hypothesis, we can think of this particularexamples as picking 4 balls out of an urn with 4 green (correct answer) and 4 red (incorrect answer)balls.</p>
</blockquote>
<blockquote>
<p>Under the null hypothesis that she is simply guessing, each ball has the same chance of beingpicked. We can then use combinatorics to figure out each probability. The probability of picking3 is(43)(41)/(84)= 16/70. The probability of picking all 4 correct is(44)(40)/(84)= 1/70. Thus, thechance of observing a 3 or something more extreme, under the null hypothesis, is 0.24. This isthe p-value. The procedure that produced this p-value is calledFisher’s exact testand it uses the hypergeometric distribution.</p>
</blockquote>
<p>它这种算法是8个球里摸4个。我的算法是每次猜对的概率是0.5，那么4次猜对3次的概率是4*0.5^3^*0.5=0.25。这两种结果不一样，我也搞不太清楚。</p>
<p>这里算错了，除了不清晰二项分布与超几何分布，还有一个原因，不清楚这个Lady tasting tea试验。在这个试验中，Fisher准备了8杯茶，每一种（tea first or milk first）都准备了4杯，并且随机拜放位置。试验者需挑出按其中一种方法泡制的4杯。</p>
<p>按Fisher’s exact test 只有当这位女士把4杯都挑出来（p=1/70），他才会承认她有这种能力（但是不能量化）。哪怕如题所示，她挑出来了3杯（p=16/70+1/70=17/70），P值也是不显著。</p>
<blockquote>
<p>当样本量更大时，也可以使用卡方分布。但是，当样本数目很少或数据分布极不平衡（如果某个cell的数目小于5 或小于10）时，卡方分布的估计是不充分的。而与之相反，Fisher 精确检验，正如它的名称，不论样本如何都能保持精确。但是当样本量很大或非常平衡，Fisher 精确检验计算不方便，这时就需要用到卡方分布。</p>
</blockquote>
<p>公式如下：<br>
<img src="Fisher's_exact_test.png" alt="Fisher's_exact_test"></p>
<p>小结：<br>
Fisher 精确检验使用于<strong>检验两个分类变量是否相关</strong>。</p>
<ul>
<li>Fisher 精确检验：适合样本小或不平衡数据</li>
<li>卡方检验：适合样本大、平衡数据</li>
</ul>
<h4 id="Two-By-Two-Tables">Two By Two Tables</h4>
<p>The data from the experiment above can be summarized by a 2 by 2 table:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tab&lt;-matrix(c(3,1,1,3),2,2)</span><br><span class="line">rownames(tab)&lt;-c(&quot;Poured Before&quot;,&quot;Poured After&quot;)</span><br><span class="line">colnames(tab)&lt;-c(&quot;Guessed before&quot;,&quot;Guessed after&quot;)</span><br><span class="line">tab</span><br><span class="line">#The function fisher.test performs the calculations above and can be obtained like this:</span><br><span class="line">fisher.test(tab,alternative&#x3D;&quot;greater&quot;)</span><br><span class="line">##</span><br><span class="line">##Fisher&#39;s Exact Test for Count Data</span><br><span class="line">##</span><br><span class="line">## data:  tab</span><br><span class="line">## p-value &#x3D; 0.2429</span><br><span class="line">## alternative hypothesis: true odds ratio is greater than 1</span><br><span class="line">## 95 percent confidence interval:</span><br><span class="line">##  0.3135693Inf</span><br><span class="line">## sample estimates:</span><br><span class="line">## odds ratio</span><br><span class="line">##   6.408309</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Fisher-精确检验的争议">Fisher 精确检验的争议</h4>
<p>很多人争论Fisher 精确检验结果保守。它的真实的拒绝概率低于名义上的显著水平。The apparent contradiction stems from the combination of a discrete statistic with fixed significance levels.（最明显的矛盾在于它计算出的统计量是分散的，但是显著水平是固定的，如0.05）（如上例，可能出现的P值只有5个（0，1，2，3，4杯））。To avoid the problem, many authors discourage the use of fixed significance levels when dealing with discrete problems.</p>
<h4 id="Chi-square-Test">Chi-square Test</h4>
<p>假设我们有250个个体，其中一部分患有疾病。我们观测到aa基因型的个体中有20%患病；其他基因型的个体中患病比例为10%。如果我们再挑250个个体这种现象会再次发生吗？（这个提问方式等同于问这个位点是否与疾病相关）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">disease=factor(<span class="built_in">c</span>(<span class="built_in">rep</span>(<span class="number">0</span>,<span class="number">180</span>),<span class="built_in">rep</span>(<span class="number">1</span>,<span class="number">20</span>),<span class="built_in">rep</span>(<span class="number">0</span>,<span class="number">40</span>),<span class="built_in">rep</span>(<span class="number">1</span>,<span class="number">10</span>)),labels=<span class="built_in">c</span>(<span class="string">&quot;control&quot;</span>,<span class="string">&quot;cases&quot;</span>))</span><br><span class="line">genotype=factor(<span class="built_in">c</span>(<span class="built_in">rep</span>(<span class="string">&quot;AA/Aa&quot;</span>,<span class="number">200</span>),<span class="built_in">rep</span>(<span class="string">&quot;aa&quot;</span>,<span class="number">50</span>)),levels=<span class="built_in">c</span>(<span class="string">&quot;AA/Aa&quot;</span>,<span class="string">&quot;aa&quot;</span>))</span><br><span class="line">dat&lt;-data.frame(disease, genotype)</span><br><span class="line">dat&lt;-dat[sample(nrow(dat)),]<span class="comment">#shuffle them up</span></span><br><span class="line">head(dat)</span><br><span class="line"></span><br><span class="line"><span class="comment">###统计频数</span></span><br><span class="line">table(genotype)</span><br><span class="line">table(disease)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 双因素统计频数，建立一个2*2表</span></span><br><span class="line">tab &lt;- table(genotype,disease)</span><br><span class="line">tab</span><br><span class="line"><span class="comment">##disease</span></span><br><span class="line"><span class="comment">## genotype control cases</span></span><br><span class="line"><span class="comment">##    AA/Aa     180    20</span></span><br><span class="line"><span class="comment">##    aa		 40    10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里最典型的统计量就是the odds ratio(OR)。). We compute the oddsof having the disease if you are an “aa”: 10/40, the odds of having the disease if you are an “AA/Aa”:20/180, and take the ratio:(10/40)/(20/180)</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">(tab[<span class="number">2</span>,<span class="number">2</span>]/tab[<span class="number">2</span>,<span class="number">1</span>])/(tab[<span class="number">1</span>,<span class="number">2</span>]/tab[<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line"><span class="comment">## [1] 2.25</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了计算P值，我们不直接使用OR。我们假设基因型和疾病没有关系，然后计算出每个cell的期望值。在零假设下，两种基因型的200个体和50个体，患病的概率是相同的。</p>
<p>首先，我们得到群体（200+50=250）的患病概率为</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">p=mean(disease==<span class="string">&quot;cases&quot;</span>)</span><br><span class="line">p</span><br><span class="line"><span class="comment">## [1] 0.12</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此，各cell 的期望值为</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">expected&lt;-rbind(<span class="built_in">c</span>(<span class="number">1</span>-p,p)*<span class="built_in">sum</span>(genotype==<span class="string">&quot;AA/Aa&quot;</span>),<span class="built_in">c</span>(<span class="number">1</span>-p,p)*<span class="built_in">sum</span>(genotype==<span class="string">&quot;aa&quot;</span>))</span><br><span class="line"><span class="built_in">dimnames</span>(expected)&lt;-<span class="built_in">dimnames</span>(tab)</span><br><span class="line">expected</span><br><span class="line"><span class="comment">##disease</span></span><br><span class="line"><span class="comment">## genotype control cases</span></span><br><span class="line"><span class="comment">##    AA/Aa     176    24</span></span><br><span class="line"><span class="comment">##    aa		 44     6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##这里没讲清楚，直接就算出来了</span></span><br><span class="line">chisq.test(tab)$p.value</span><br><span class="line"><span class="comment">## [1] 0.08857435</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Large-Samples-Small-p-values">Large Samples, Small p-values</h4>
<p>如上所述，仅报道P值是不正确的。很多做GWAS的人过于强调P值。他们样本很大，得到的P值很小。但是如果仔细看他们的结果，我们就能看到他们的odds ratios并不高：仅仅比1高一点。在这种情况下，基因型是AA/Aa 或 aa 可能不会改变动物患病的几率，但是这些位点确实是统计意义上显著的。<br>
<strong>odds ratio 和 p-value 并没有一对一的关系</strong>（这一点很重要，这个在effect size 中也专门提到了，效应大小与是否显著没有因果关系。P值只能判断这个效应是不是出于偶然（随机误差），并不能说明效应大小）</p>
<h4 id="Confidence-Intervals-For-The-Odd-Ratio">Confidence Intervals For The Odd Ratio</h4>
<p>计算OR 的置信区间不能直接做到。不像其他统计量，它们都能推导出近似的分布。但是OR仅仅是一个比例。因此，没有简单的方法可以使用，例如CLT。</p>
<p>One approach is to use the theory ofgeneralized linear models which provides estimates of thelog odds ratio, rather than the OR itself, that can be shown to be asymptotically normal.</p>
<p>后面的没看</p>
<h2 id="Exploratory-Data-Analysis">Exploratory Data Analysis</h2>
<p>这个探索性数据分析，没太搞懂</p>
<h3 id="Quantile-Quantile-Plots">Quantile Quantile Plots</h3>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(UsingR)<span class="comment">##available from CRAN</span></span><br><span class="line">library(rafalib)</span><br><span class="line">x&lt;-father.son$fheight</span><br><span class="line"></span><br><span class="line">ps&lt;-( seq(<span class="number">0</span>,<span class="number">99</span>)+<span class="number">0.5</span>)/<span class="number">100</span> <span class="comment">#0.005 0.015 ……</span></span><br><span class="line">qs&lt;-quantile(x, ps) <span class="comment">#获得x中的各分位数</span></span><br><span class="line">normalqs&lt;-qnorm(ps, mean(x), popsd(x)) <span class="comment">#形成以x均值，总体标准差的正态分布的分位数</span></span><br><span class="line">plot(normalqs,qs,xlab=<span class="string">&quot;Normal percentiles&quot;</span>,ylab=<span class="string">&quot;Height percentiles&quot;</span>) </span><br><span class="line"><span class="comment"># 两个分位数向量的散点图即为QQ图</span></span><br><span class="line">abline(<span class="number">0</span>,<span class="number">1</span>)<span class="comment">##identity line</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>简化命令,比上面的手动画图采了更多的点，因此更加准确。<br>
其中由于x轴为标准正态分布，因此添加的qqline的截距为mean(x) , 斜率为popsd(x)</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qqnorm(x)</span><br><span class="line">qqline(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当然，我们也可以看看非正态分布的QQ图，比如t分布，样本数越少，尾巴越肥。体现在QQ图上就是左侧的极端值低于identity line，右侧的极端值高于identity line。</p>
<h3 id="Boxplots">Boxplots</h3>
<p>数据也不是都服从正态分布。比如工资，只告诉均值和标准差根本不足以表现真实情况（not neccessarily informative），因为我们没办法通过这两个参数获取工资的分布情况。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">op &lt;- par(mfrow=<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">hist(exec.pay)<span class="comment">##in UsingR package</span></span><br><span class="line">qqnorm(exec.pay)</span><br><span class="line">qqline(exec.pay)</span><br><span class="line"></span><br><span class="line"><span class="comment">#boxplot</span></span><br><span class="line">boxplot(exec.pay, ylab=<span class="string">&quot;10,000s of dollars&quot;</span>, ylim=<span class="built_in">c</span>(<span class="number">0</span>,<span class="number">400</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Scatterplots-And-Correlation">Scatterplots And Correlation</h3>
<p>上面都是单一变量。我们也经常用到双变量或者更多的变量，比如父亲和儿子的身高。可以先画一个散点图。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(UsingR)</span><br><span class="line">data(<span class="string">&quot;father.son&quot;</span>)</span><br><span class="line">x=father.son$fheight</span><br><span class="line">y=father.son$sheight</span><br><span class="line">plot(x,y,xlab=<span class="string">&quot;Father&#x27;s height in inches&quot;</span>,ylab=<span class="string">&quot;Son&#x27;s height in inches&quot;</span>,main=paste(<span class="string">&quot;correlation =&quot;</span>,<span class="built_in">signif</span>(cor(x,y),<span class="number">2</span>)))</span><br></pre></td></tr></table></figure>
<p>从图中看出一个明显的趋势：父亲的身高越高，儿子的身高也越高。一个定量的统计量就是相关系数。</p>
<h4 id="Stratification">Stratification</h4>
<p>如果我们要预测身高为72 inches 的父亲的儿子的身高，我们可以看所有身高为72 inches 的父亲的儿子的情况。因此需要对数据按父亲身高进行分层。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">groups&lt;-split(y,<span class="built_in">round</span>(x))</span><br><span class="line">boxplot(groups)</span><br><span class="line">print(mean(y[ <span class="built_in">round</span>(x)==<span class="number">72</span>]))</span><br><span class="line"><span class="comment">## [1] 70.67719</span></span><br></pre></td></tr></table></figure>
<h3 id="Bi-variate-Normal-Distribution">Bi-variate Normal Distribution</h3>
<p>对于两个均服从正态分布的变量的联合分布，我们一般可以设定当X = x时，Y的条件分布。以身高数据为例，我们给出了以下4个层次。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">groups&lt;-split(y,<span class="built_in">round</span>(x))</span><br><span class="line">op &lt;- par(mfrow=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="built_in">c</span>(<span class="number">5</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">14</span>))&#123;</span><br><span class="line">  qqnorm(groups[[i]],main=paste0(<span class="string">&quot;X=&quot;</span>,<span class="built_in">names</span>(groups)[i],<span class="string">&quot;strata&quot;</span>),</span><br><span class="line">         ylim=<span class="built_in">range</span>(y),xlim=<span class="built_in">c</span>(-<span class="number">2.5</span>,<span class="number">2.5</span>))</span><br><span class="line"><span class="comment"># groups 是一个list，用groups[[i]] 获得的是向量</span></span><br><span class="line"><span class="comment"># range() 返回一个包含最小值和最大值的向量</span></span><br><span class="line"><span class="comment"># range(1:10) ## [1]  1 10</span></span><br><span class="line"></span><br><span class="line">  qqline(groups[[i]])</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>后面的公式推导没太明白。后面对x,y进行了标准化，然后按x分组求y均值，发现y均值 与 x 呈线性关系，截距为0，斜率为标准化的y与x的相关系数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x=( x-mean(x) )/sd(x)</span><br><span class="line">y=( y-mean(y) )/sd(y)</span><br><span class="line">means=tapply(y, <span class="built_in">round</span>(x*<span class="number">4</span>)/<span class="number">4</span>, mean) <span class="comment">#按round(x*4)/4 给y 分组求均值</span></span><br><span class="line">fatherheights=<span class="built_in">as.numeric</span>(<span class="built_in">names</span>(means))</span><br><span class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">plot(fatherheights, means, ylab=<span class="string">&quot;average of strata of son heights&quot;</span>, ylim=<span class="built_in">range</span>(fatherheights))</span><br><span class="line">abline(<span class="number">0</span>, cor(x,y))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Plots-To-Avoid">Plots To Avoid</h3>
<p>画图的目的是准确而清楚地展示数据。根据 Karl 的说法，不好的画图的标准如下：</p>
<ol>
<li>Display as little information as possible.</li>
<li>Obscure what you do show (with chart junk).</li>
<li>Use pseudo-3D and color gratuitously（免费地）.</li>
<li>Make a pie chart (preferably in color and 3D).</li>
<li>Use a poorly chosen scale.</li>
<li>Ignore significant figures.</li>
</ol>
<h3 id="Pie-charts">Pie charts</h3>
<blockquote>
<p>“Pie charts are a very bad way of displaying information. The eye is good at judginglinear measures and bad at judging relative areas. A bar chart or dot chart is a preferableway of displaying this type of data.”</p>
</blockquote>
<p>饼图是一种很差劲的展示数据的方式。人眼很容易辨别线性方式，但是劣于判断相对区域。一个条形图或散点图 都是更合适的方式。</p>
<p>举例来说，你可以看着饼图，去估计某一部分对应的百分比。你会发现这很困难，除非这个比例很接近25%，50% 或 75%。</p>
<p>这里我们可以用条形图用代替，这里我们每隔10添加了一条水平线</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">pie(browsers,main=<span class="string">&quot;Browser Usage (August 2013)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#条形图</span></span><br><span class="line">barplot(browsers, main=<span class="string">&quot;Browser Usage (August 2013)&quot;</span>, ylim=<span class="built_in">c</span>(<span class="number">0</span>,<span class="number">55</span>))</span><br><span class="line">abline(h=<span class="number">1</span>:<span class="number">5</span>*<span class="number">10</span>)</span><br><span class="line">barplot(browsers, add=<span class="literal">TRUE</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过条形图和y轴的水平线，我们可以很清楚的看到每个值的比例。</p>
<p>尽量不要使用3D图像，因为3D图像添加了看图的障碍，使得更难通过肉眼辨别各项比例。</p>
<h4 id="Barplots-as-data-summaries">Barplots as data summaries</h4>
<p>当条形图用于展示百分比时，很有用。但是，条形图也会被错误地用于<strong>只有两组</strong>的比较。特别当条形图的高度表示均值，上面的小触角表示标准误（standard errors）。</p>
<blockquote>
<p>Much more informative is to summarize with a boxplot. If the number of points is small enough,we might as well add them to the plot. When the number of points is too large for us to see them,just showing a boxplot is preferable. We can even setrange=0inboxplotto avoid drawing manyoutliers when the data is in the range of millions.</p>
</blockquote>
<p>这个时候更适合用箱线图来表示。箱线图展示了更多的信息，中心、分布、离群点。而条形图只展示了均值和标准误，而标准误很大程度上和样本大小有关，和分布无关。</p>
<blockquote>
<p>Notice how much more we see here: the center, spread, range and the points themselves. In thebarplot, we only see the mean and the SE, and the SE has more to do with sample size, than withthe spread of the data.</p>
</blockquote>
<p>问题还不止如此。当数据中的离群点很大（分组数据的尾巴很大）。如下条形图，看似两组区别很大。</p>
<p><img src="barplot1.png" alt="barplot1"></p>
<p>但仔细看数据，这种区别原来主要是因为有两个很大的离群点。将数据进行log以后，更加明朗。</p>
<p>如下箱线图所示，左边为原数据，可以看出二者可能区别不大，有两个非常大的离群点。log后基本展示了基本情况。（个人感觉，那两个离群点实在太大，也可以直接剔除）</p>
<p><img src="boxplot1.png" alt="barplot1"></p>
<h4 id="Show-the-scatter-plot">Show the scatter plot</h4>
<p>很多统计分析都是证明两个变量之间存在关系。相关系数和相应的图可以展示这一点。然而，只展现回归线是不够的，因为这掩饰了散点。</p>
<h4 id="High-correlation-does-not-imply-replication">High correlation does not imply replication</h4>
<p>相关系数很高，不代表重复性很好，这一部分没看懂。之后补上</p>
<h4 id="Barplots-for-paired-data">Barplots for paired data</h4>
<p>当样本数较少且为配对实验时，通常我们会用两种颜色的条形图表示比如实验前和实验后。</p>
<p><img src="pairdata1.png" alt="barplot1"></p>
<p>但是我们有更好的办法。比如散点图，我们可以看到点都是高于identity line（这里应该是y=x）。另一种方法是直接画差值的散点图。</p>
<p><img src="pairdata2.png" alt="barplot1"></p>
<p><img src="pairdata3.png" alt="barplot1"></p>
<h4 id="Gratuitous-3D-（没有必要的3D）">Gratuitous 3D （没有必要的3D）</h4>
<p>以下是一个3D图，你会发现并不清楚。很难去确定其中某一个点对应的数值。</p>
<p>其实这只要不同的颜色来区分三条线就可以了。</p>
<p><img src="3D.png" alt="barplot1"></p>
<p><img src="3D2.png" alt="barplot1"></p>
<h4 id="Too-many-significant-digits">Too many significant digits</h4>
<p>默认情况下，我们会得到很多重要的数字，但我们不是都要放上去。从R中直接复制粘贴是很愚蠢的，这导致你最后显示的不是一张图，而更像是一张表。</p>
<h4 id="Displaying-data-well">Displaying data well</h4>
<p>展示数据的一般准则：</p>
<ul>
<li>Be accurate and clear.</li>
<li>Let the data speak.</li>
<li>Show as much information as possible, taking care not to obscure the message.</li>
<li>Science not sales: avoid unnecessary frills (esp. gratuitous 3D).<br>
(科学不是销售，避免不必要的虚架子，比如3D)</li>
<li>In tables, every digit should be meaningful. Don’t drop ending 0’s.<br>
（表格中，每一个小数位点都有意义）</li>
</ul>
<h3 id="Misunderstanding-Correlation-Advanced">Misunderstanding Correlation (Advanced)</h3>
<p>现在相关系数主要用于体现reproducibility。但是实际上，相关系数不足以体现reproducibility。</p>
<p>最坏的错误是，计算相关系数的数据不是近似服从<strong>二元正态分布</strong>。上面提到，均值，标准差，相关系数都是基于二元正态分布。但是，有很多数据不符合，如基因表达量数据，通常有很肥的右侧尾巴。</p>
<p>计算reproducibility 最直接的方式就是计算两个变量的距离。</p>
<p>The standard way to quantify reproducibility between two sets of replicated measurements, sayx1; : : : ; xnandy1; : : : ; yn, is simply to compute the distance between them。</p>
<p><img src="reproducibility1.png" alt="barplot1"></p>
<p>后面没看，也看不懂。</p>
<p>我连这里的reproducibility是什么意思都不知道。</p>
<h3 id="Robust-Summaries">Robust Summaries</h3>
<p>在分析数据的过程中，我们通常假设数据符合正态分布。但是我们收集数据的过程中，总是不可避免地加入了一些错误的数据点（离群点）。类似这种偏离很大的离群点，会导致分析结果出现很大的偏差。</p>
<p>如下例，我们在0到1之间的数据中，插入一个值为100的离群点。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">set.seed(<span class="number">1</span>)</span><br><span class="line">x=<span class="built_in">c</span>(rnorm(<span class="number">100</span>,<span class="number">0</span>,<span class="number">1</span>))<span class="comment">##real distribution</span></span><br><span class="line">x[<span class="number">23</span>]&lt;-<span class="number">100</span><span class="comment">##mistake made in 23th measurement</span></span><br><span class="line">boxplot(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们看一下均值和标准差，发现偏离很大</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">cat(<span class="string">&quot;The average is&quot;</span>,mean(x),<span class="string">&quot;and the SD is&quot;</span>,sd(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">## The average is 1.108142 and the SD is 10.02938</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="The-median">The median</h4>
<p>这个中位数，对于离群点，是robust的。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">median(x)</span><br><span class="line">[<span class="number">1</span>] <span class="number">0.1684483</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="The-median-absolute-deviation">The median absolute deviation</h4>
<p>![](The median absolute deviation.png)</p>
<h4 id="Spearman-correlation">Spearman correlation</h4>
<p>和前面类似，也是robust 的相关系数。几乎不受离群点的影响。</p>
<h4 id="Symmetry-of-log-ratios">Symmetry of log ratios</h4>
<p>当涉及比值数据时，数据不是对称的，1/32 比 32/1 更接近1。这时候采用log()函数处理一下，就会对称（log(x/y) = log(x) - log(y) ）</p>
<h3 id="Wilcoxon-Rank-Sum-Test">Wilcoxon Rank Sum Test</h3>
<p>从上面知道，样本均值和标准差易受离群点的影响。t检验需要用到这两个数，因此也容易受到影响。这种Wilcoxon Rank Sum Test 就不会受到影响……</p>
<p>后面没看</p>
<h2 id="Matrix-Algebra">Matrix Algebra</h2>
<h3 id="自由落体实验">自由落体实验</h3>
<p>假设你是伽利略，你需要描述物体自由下落的速度。通过实验你获得了如下的25个数据，使用R模拟如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">set.seed(<span class="number">1</span>)</span><br><span class="line">g&lt;-<span class="number">9.8</span><span class="comment">##meters per second</span></span><br><span class="line">n&lt;-<span class="number">25</span></span><br><span class="line">tt&lt;-seq(<span class="number">0</span>,<span class="number">3.4</span>,len=n)<span class="comment">##time in secs, note: we use tt because t is a base function</span></span><br><span class="line">d&lt;-<span class="number">56.67</span>-<span class="number">0.5</span>*g*tt^<span class="number">2</span>+rnorm(n,sd=<span class="number">1</span>)<span class="comment">##meters</span></span><br><span class="line"><span class="comment">#rnorm 生成25个服从(0,1) 分布的随机数，模拟随机残差</span></span><br><span class="line"></span><br><span class="line">plot(tt,d,ylab=<span class="string">&quot;Distance in meters&quot;</span>,xlab=<span class="string">&quot;Time in seconds&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你不知道高度与时间的准确的关系式，但是你根据图片，推断可能符合的模型如下：</p>
<p><img src="falling_objects1.png" alt=""></p>
<h3 id="父亲和儿子的身高">父亲和儿子的身高</h3>
<p>现在假设你是19世纪的Francis Galton ，然后你获得了成对的父亲与儿子的身高数据。你假设身高是受遗传影响的。</p>
<p>你拿到的数据如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(UsingR)</span><br><span class="line">x=father.son$fheight</span><br><span class="line">y=father.son$sheight</span><br><span class="line">plot(x,y,xlab=<span class="string">&quot;Father&#x27;s height&quot;</span>,ylab=<span class="string">&quot;Son&#x27;s height&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>貌似是符合一元线性模型。于是，你设计出的模型如下：</p>
<p><img src="father_son1.png" alt=""></p>
<h3 id="从多个群体中随机抽样">从多个群体中随机抽样</h3>
<p>现在我们重新读取小鼠的体重数据。我们感兴趣的是diet是否对体重有影响。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dat&lt;-read.csv(<span class="string">&quot;femaleMiceWeights.csv&quot;</span>)</span><br><span class="line">stripchart(Bodyweight~Diet,data=dat,vertical=<span class="literal">TRUE</span>,method=<span class="string">&quot;jitter&quot;</span>,pch=<span class="number">1</span>,main=<span class="string">&quot;Mice weights&quot;</span>)</span><br><span class="line"><span class="comment">##stripchart 成串的散点图，当数据量较少时，是箱线图的有效代替</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们已经证明了如何使用t检验和置信区间来证明两个群体的平均体重是否有差异。但是，用线性模型也可以做到。</p>
<p><img src="liner_model_mice1.png" alt=""></p>
<p>这里的β0表示 chow diet 的平均体重，β1 表示两个群体均值的差异，当i 采用 high fat diet 时xi = 1 ；当 i 采用 chow diet 时 xi =0 。</p>
<h3 id="一般的线性模型">一般的线性模型</h3>
<p><img src="general_linear_model.png" alt=""></p>
<h3 id="估计参数">估计参数</h3>
<p>只有我们能够估计出 β s，线性模型才能起作用。</p>
<p>一般估计参数的方法都是使用最小二乘法（least squares LS）。</p>
<p><img src="LS.png" alt=""></p>
<p>一旦我们找到了最小值，我们就称他们为 least squares estimates (LSE) , 表示为β帽。获得最小二乘的统计量称之为 the residual sum of squares (RSS) 。因为这个统计量决定于 Y 这个随机变量。因此 β帽 也是一个随机变量。</p>
<h3 id="lm-函数">lm 函数</h3>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tt2&lt;-tt^<span class="number">2</span></span><br><span class="line">fit&lt;-lm(d~tt+tt2)</span><br><span class="line">summary(fit)$coef</span><br></pre></td></tr></table></figure>
<p>通过lm()函数，我们可以知道得到LSE，和它的标准误 和 p 值。</p>
<h3 id="LSE">LSE</h3>
<p>我们可以写个计算LSE的函数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">rss&lt;-<span class="keyword">function</span>(Beta0,Beta1,Beta2)&#123;</span><br><span class="line">  r&lt;- d-(Beta0+Beta1*tt+Beta2*tt^<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">return</span>(<span class="built_in">sum</span>(r^<span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#固定两个参数，观察beta2对rss的影响</span></span><br><span class="line">Beta2s&lt;-seq(-<span class="number">10</span>,<span class="number">0</span>,len=<span class="number">100</span>)</span><br><span class="line">plot(Beta2s,sapply(Beta2s,rss,Beta0=<span class="number">55</span>,Beta1=<span class="number">0</span>),ylab=<span class="string">&quot;RSS&quot;</span>,xlab=<span class="string">&quot;Beta2&quot;</span>,type=<span class="string">&quot;l&quot;</span>)</span><br><span class="line"><span class="comment">##Let&#x27;s add another curve fixing another pair:</span></span><br><span class="line">Beta2s&lt;-seq(-<span class="number">10</span>,<span class="number">0</span>,len=<span class="number">100</span>)</span><br><span class="line">lines(Beta2s,sapply(Beta2s,rss,Beta0=<span class="number">65</span>,Beta1=<span class="number">0</span>),col=<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>估计参数这里需要用到微积分。当然，如果参数众多，那么估计起来也很麻烦。</p>
<h3 id="More-on-Galton-父子身高">More on Galton (父子身高)</h3>
<h3 id="solving-system-of-equations">solving system of equations</h3>
<p>线性代数是被用来解决 systems of linear equations，如下：</p>
<p><img src="linear_equations1.png" alt=""></p>
<p>线性代数给我们提供了非常简便的一般方法解决这些问题。比如上例中，可以这么求解</p>
<p><img src="linear_equations2.png" alt=""></p>
<h3 id="The-inverse">The inverse</h3>
<p>我们可以通过R中的solve()函数求逆。但是注意，solve()函数并不总是numerically stable。</p>
<p>crossprod(A，B)  = t(A) %*% B</p>
<p>crossprod(A) = t(A) %*% A</p>
<h3 id="liner-model">liner model</h3>
<p>我们可以重新定义父子身高的矩阵形式</p>
<p><img src="linear_model_height1.png" alt=""></p>
<p>因此该线性模型为：</p>
<p><img src="linear_model_height2.png" alt=""></p>
<p>最小二乘统计量为</p>
<p><img src="linear_model_height3.png" alt=""></p>
<h3 id="advanced-使用求导求最小二乘">advanced:使用求导求最小二乘</h3>
<p><img src="LSE2.png" alt=""></p>
<p>由于最小二乘也是一个平方值，所以，类似于 f(x)^2^ 的求导为 2f(x)f’(x)</p>
<p>具体没太搞懂</p>
<h2 id="Linear-Models">Linear Models</h2>
<blockquote>
<p>“Linear”” here does not refer to lines, but rather to linear combinations.</p>
</blockquote>
<p>这句话的意思是，线性模型指的不是一条线（y=x+x^2^ 就是曲线），而是指的是影响因素的线性组合。</p>
<p>model matrix 来求出 LSE，我们称之为 fitting the model 。 我们在R中可以直接使用 lm() 函数，但是其实 lm() 函数内部也是使用了model.matrix()函数。</p>
<p>design matrix 至少包含两列（第一列全是1，表示截距）。但是我觉得，也可以不要截距。比如diet 对 小鼠体重的影响，截距是 chow diet 的平均体重，另一个是high fat - chow fat 的差值。也可以设置为，第一列是chow diet ，第二列是 high fat 。不过最少还是需要两列。</p>
<p>使用model.matrix() 函数前必须<strong>因子化</strong></p>
<p>所谓因子（factor），它们的具体名称不重要（字符串或者数值），重要的是order（把同一类的归到一组）</p>
<p>model.matrix() 中 +0 或 -1 不要截距，这样每一个水平都有一个单独的系数。</p>
<h3 id="Releveling-（实际没什么用）">Releveling （实际没什么用）</h3>
<p>参考水平（reference level，也就是截距所在的水平）一般是<strong>名称按字母排序</strong>的第一个水平，可以通过relevel 改变</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">group &lt;- factor(<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">group &lt;- relevel(group, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">model.matrix(~ group)</span><br><span class="line"><span class="comment">##   (Intercept) group1</span></span><br><span class="line"><span class="comment">## 1           1      1</span></span><br><span class="line"><span class="comment">## 2           1      1</span></span><br><span class="line"><span class="comment">## 3           1      0</span></span><br><span class="line"><span class="comment">## 4           1      0</span></span><br><span class="line"></span><br><span class="line">model.matrix(~ group-<span class="number">1</span>)</span><br><span class="line"><span class="comment">##          group2 group1</span></span><br><span class="line"><span class="comment">## 1           0      1</span></span><br><span class="line"><span class="comment">## 2           0      1</span></span><br><span class="line"><span class="comment">## 3           1      0</span></span><br><span class="line"><span class="comment">## 4           1      0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以直接在factor() 函数中说明顺序</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">group &lt;- factor(<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>),levels = <span class="built_in">c</span>(<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;1&#x27;</span>))</span><br><span class="line">model.matrix(~group-<span class="number">1</span>)</span><br><span class="line"><span class="comment">##  group3 group2 group1</span></span><br><span class="line"><span class="comment">## 1      0      0      1</span></span><br><span class="line"><span class="comment">## 2      0      0      1</span></span><br><span class="line"><span class="comment">## 3      0      1      0</span></span><br><span class="line"><span class="comment">## 4      0      1      0</span></span><br><span class="line"><span class="comment">## 5      1      0      0</span></span><br><span class="line"><span class="comment">## 6      1      0      0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是如果水平数很多，这样做就太麻烦了。</p>
<p>不如一开始就按照需要的顺序从1到n 重编号就好了。</p>
<h3 id="连续变量">连续变量</h3>
<p>在实际的使用中，除了分类变量。我们可能还会将连续的数字变量转化为design matrix。比如在自由落体实验中，时间和时间的平方就包含在了模型中。它们也要转化为model.matrix</p>
<p>连续变量不用因子化，也不能因子化。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tt&lt;-seq(<span class="number">0</span>,<span class="number">3.4</span>,len=<span class="number">4</span>)</span><br><span class="line">model.matrix(~tt+I(tt^<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">  (Intercept)       tt   I(tt^<span class="number">2</span>)</span><br><span class="line">1           <span class="number">1</span> <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line">2           <span class="number">1</span> <span class="number">1.133333</span>  <span class="number">1.284444</span></span><br><span class="line">3           <span class="number">1</span> <span class="number">2.266667</span>  <span class="number">5.137778</span></span><br><span class="line">4           <span class="number">1</span> <span class="number">3.400000</span> <span class="number">11.560000</span></span><br><span class="line"><span class="built_in">attr</span>(,<span class="string">&quot;assign&quot;</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>生命科学中经常需要考虑<strong>剂量效应</strong>，这也是一种连续变量。</p>
<p>但是，添加连续变量的假设<strong>难以辩护</strong>，因为分类变量仅仅是比较两个群体的均值之间是否有差异，而连续变量却意味着观测值与这个连续变量之间存在特别的关系。</p>
<p>比如落体试验中，这是因为我们以及知道了重力的公式。父子身高试验，我们能明显地看出来线性关系。但是如果你把年龄（age）也加入到身高的模型中，这就不对了。</p>
<p>因此，你的数据必须要能支持你把这个连续变量加入到模型中。即添加连续变量要小心。</p>
<h3 id="小鼠数据举例">小鼠数据举例</h3>
<p>在小鼠的数据中，我们之前是使用了t-test，其实我这里也可以使用线性模型，二者其实是<strong>异曲同工</strong>的。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dat&lt;-read.csv(<span class="string">&quot;femaleMiceWeights.csv&quot;</span>)</span><br><span class="line"><span class="comment">#没有设置stringsAsFactor，Diet已经是因子了</span></span><br><span class="line">levels(dat$Diet) </span><br><span class="line">X&lt;-model.matrix(~Diet, data=dat)</span><br><span class="line">head(X)</span><br><span class="line"></span><br><span class="line">Y&lt;-dat$Bodyweight</span><br><span class="line">X&lt;-model.matrix(~Diet, data=dat)</span><br><span class="line">solve(t(X)%*%X)%*%t(X)%*%Y</span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">                 [,<span class="number">1</span>]</span><br><span class="line">(Intercept) <span class="number">23.813333</span></span><br><span class="line">Diethf       <span class="number">3.020833</span></span><br></pre></td></tr></table></figure>
<p>查看均值、均值差，一致</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">s&lt;-split(dat$Bodyweight, dat$Diet)</span><br><span class="line"><span class="comment">#split() 按照分组因子，分类，形成一个列表</span></span><br><span class="line"><span class="comment">#有点实用啊</span></span><br><span class="line"></span><br><span class="line">mean(s[[<span class="string">&quot;chow&quot;</span>]])</span><br><span class="line"><span class="comment">## [1] 23.81333</span></span><br><span class="line"></span><br><span class="line">mean(s[[<span class="string">&quot;hf&quot;</span>]])-mean(s[[<span class="string">&quot;chow&quot;</span>]])</span><br><span class="line"><span class="comment">## [1] 3.020833</span></span><br></pre></td></tr></table></figure>
<p>使用lm() 函数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fit&lt;-lm(Bodyweight~Diet, data=dat)</span><br><span class="line">summary(fit)$coef</span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">             Estimate Std. Error   t value     Pr(&gt;|t|)</span><br><span class="line">(Intercept) <span class="number">23.813333</span>   <span class="number">1.039353</span> <span class="number">22.911684</span> <span class="number">7.642256e-17</span></span><br><span class="line">Diethf       <span class="number">3.020833</span>   <span class="number">1.469867</span>  <span class="number">2.055174</span> <span class="number">5.192480e-02</span></span><br></pre></td></tr></table></figure>
<p>t分布，当方差相等时结果一致。t分布的方差（标准差）一致等于线性模型中的残差分布一致。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">t.test(s[[<span class="string">&quot;chow&quot;</span>]],s[[<span class="string">&#x27;hf&#x27;</span>]],var.equal = <span class="built_in">T</span>)$p.value</span><br><span class="line"><span class="comment">## [1] 0.0519248</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Standard-Errors">Standard Errors</h3>
<p>实际我们得到的参数估计值仍然是一个<strong>随机变量</strong>，因此需要提供<strong>标准误</strong>才是有效的。</p>
<p>对于自由落体试验，我们可以采用Monte Carlo simulation</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">set.seed(<span class="number">1</span>)</span><br><span class="line">B&lt;-<span class="number">10000</span></span><br><span class="line">h0&lt;-<span class="number">56.67</span></span><br><span class="line">v0&lt;-<span class="number">0</span></span><br><span class="line">g&lt;-<span class="number">9.8</span><span class="comment">##meters per second</span></span><br><span class="line">n&lt;-<span class="number">25</span></span><br><span class="line">tt&lt;-seq(<span class="number">0</span>,<span class="number">3.4</span>,len=n)<span class="comment">##time in secs, t is a base function</span></span><br><span class="line">X&lt;-cbind(<span class="number">1</span>,tt,tt^<span class="number">2</span>)</span><br><span class="line"><span class="comment">##create X&#x27;X^-1 X&#x27;</span></span><br><span class="line">A&lt;-solve(crossprod(X))%*%t(X)</span><br><span class="line">betahat&lt;-replicate(B,&#123;</span><br><span class="line">  y&lt;-h0+v0*tt-<span class="number">0.5</span>*g*tt^<span class="number">2</span>+rnorm(n,sd=<span class="number">1</span>)</span><br><span class="line">  betahats&lt;-A%*%y</span><br><span class="line">  <span class="built_in">return</span>(betahats[<span class="number">3</span>])</span><br><span class="line">&#125;)</span><br><span class="line">head(betahat)</span><br><span class="line"><span class="comment"># [1] -5.038646 -4.894362 -5.143756 -5.220960 -5.063322</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每次得到的估计都不同</p>
<p>我们可以观察一下估计值的分布。发现符合正态，这是因为参数估计值是观测值的线性组合。因此，只要<strong>观测值符合正态分布</strong>，那么参数也符合正态分布</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(rafalib)</span><br><span class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">hist(betahat)</span><br><span class="line">qqnorm(betahat)</span><br><span class="line">qqline(betahat)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以得到参数均值和标准误的估计值</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="built_in">round</span>(mean(betahat),<span class="number">1</span>)</span><br><span class="line"><span class="comment">## [1] -4.9</span></span><br><span class="line"></span><br><span class="line">sd(betahat)</span><br><span class="line"><span class="comment">## [1] 0.2129976</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在父子身高的试验中，randomness 主要是我们是随机采样的父子对（father and son pairs）。为了说明，我们假设下面的就是整个群体的数据</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(UsingR)</span><br><span class="line">x&lt;-father.son$fheight</span><br><span class="line">y&lt;-father.son$sheight</span><br><span class="line">n&lt;-<span class="built_in">length</span>(y)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来我们采用Monte Carlo simulation，这里我们设定样本大小为50，然后重复抽样。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N&lt;-<span class="number">50</span></span><br><span class="line">B&lt;-<span class="number">1000</span></span><br><span class="line">betahat&lt;-replicate(B,&#123;</span><br><span class="line">  index&lt;-sample(n,N)</span><br><span class="line">  sampledat&lt;-father.son[index,]</span><br><span class="line">  x&lt;-sampledat$fheight</span><br><span class="line">  y&lt;-sampledat$sheight</span><br><span class="line">  lm(y~x)$coef</span><br><span class="line">  &#125;)</span><br><span class="line">betahat&lt;-t(betahat) <span class="comment">#have estimates in two columns</span></span><br><span class="line"></span><br><span class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">qqnorm(betahat[,<span class="number">1</span>])</span><br><span class="line">qqline(betahat[,<span class="number">1</span>])</span><br><span class="line">qqnorm(betahat[,<span class="number">2</span>])</span><br><span class="line">qqline(betahat[,<span class="number">2</span>])</span><br><span class="line"><span class="comment">#符合正态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#lm() 两个参数的相关</span></span><br><span class="line">cor(betahat[,<span class="number">1</span>],betahat[,<span class="number">2</span>])</span><br><span class="line"><span class="comment">## [1] -0.9991099</span></span><br></pre></td></tr></table></figure>
<h3 id="方差-协方差矩阵">方差-协方差矩阵</h3>
<p>我们用一个类似求和的符号表示协方差矩阵。</p>
<p><img src="variance1.png" alt=""></p>
<p>以观测值 Y 向量为例，由于来自于同一个群体，所以我们认为所有Yi 有着共同的方差，而且由于个体间互相独立，因此非对角线元素全为0。因此观测值 Y 向量的方差-协方差矩阵只有两种元素。</p>
<p><img src="variance2.png" alt=""></p>
<p><img src="variance3.png" alt=""></p>
<p>根据上面的公式，我们可以求出LSE的标准误（也就是标准差）</p>
<p><img src="variance4.png" alt=""></p>
<p>为了得到参数估计的标准误，我们需要估计群体的标准差。</p>
<p>这里我们采用下面方法估计群体的标准差（具体推导不了解）</p>
<p><img src="variance5.png" alt=""></p>
<p>采用R代码如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">n&lt;-nrow(father.son)</span><br><span class="line">N&lt;-<span class="number">50</span></span><br><span class="line">index&lt;-sample(n,N)</span><br><span class="line">sampledat&lt;-father.son[index,]</span><br><span class="line">x&lt;-sampledat$fheight</span><br><span class="line">y&lt;-sampledat$sheight</span><br><span class="line">X&lt;-model.matrix(~x)</span><br><span class="line"></span><br><span class="line">N&lt;-nrow(X)</span><br><span class="line">p&lt;-ncol(X)</span><br><span class="line"></span><br><span class="line">XtXinv&lt;-solve(crossprod(X))</span><br><span class="line"></span><br><span class="line">resid&lt;-y-X%*%XtXinv%*%crossprod(X,y)</span><br><span class="line"></span><br><span class="line">s&lt;-<span class="built_in">sqrt</span>( <span class="built_in">sum</span>(resid^<span class="number">2</span>)/(N-p))</span><br><span class="line"></span><br><span class="line">ses&lt;-<span class="built_in">sqrt</span>(diag(XtXinv))*s</span><br><span class="line"></span><br><span class="line"><span class="comment">## Let’s compare to whatlmprovides:</span></span><br><span class="line"></span><br><span class="line">summary(lm(y~x))$coef[,<span class="number">2</span>]</span><br><span class="line"><span class="comment">## (Intercept)           x </span></span><br><span class="line"><span class="comment">##   9.1642841   0.1359242 </span></span><br><span class="line"></span><br><span class="line">ses</span><br><span class="line"><span class="comment">## (Intercept)           x </span></span><br><span class="line"><span class="comment">##   9.1642841   0.1359242 </span></span><br></pre></td></tr></table></figure>
<p>后面一部分都没看懂</p>
<blockquote>
<p>They are identical because they are doing the same thing.</p>
</blockquote>
<p>192页后面没看</p>
<h3 id="The-QR-Factorization">The QR Factorization</h3>
<p>solve <strong>is numerically unstable</strong></p>
<p>例如，在求LSE中，需要求（X’X）^-1^</p>
<h4 id="分解（）">分解（）</h4>
<p>任何满秩的 N × p 矩阵X（如果不是方阵，哪来的满秩？？），都可以如下分解：</p>
<p><img src="factorization1.png" alt=""></p>
<h4 id="用QR求LSE">用QR求LSE</h4>
<p><img src="qr1.png" alt=""></p>
<p>R 代码如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">n&lt;-<span class="number">50</span>;M&lt;-<span class="number">500</span></span><br><span class="line">x&lt;-seq(<span class="number">1</span>,M,len=n)</span><br><span class="line">X&lt;-cbind(<span class="number">1</span>,x,x^<span class="number">2</span>,x^<span class="number">3</span>)</span><br><span class="line">colnames(X)&lt;-<span class="built_in">c</span>(<span class="string">&quot;Intercept&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&quot;x2&quot;</span>,<span class="string">&quot;x3&quot;</span>)</span><br><span class="line">beta&lt;-matrix(<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),<span class="number">4</span>,<span class="number">1</span>)</span><br><span class="line">set.seed(<span class="number">1</span>)</span><br><span class="line">y&lt;-X%*%beta+rnorm(n,sd=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">QR&lt;-qr(X)</span><br><span class="line">Q&lt;-qr.Q( QR )</span><br><span class="line">R&lt;-qr.R( QR )</span><br><span class="line">(betahat&lt;-backsolve(R, crossprod(Q,y) ) )</span><br><span class="line"></span><br><span class="line"><span class="comment">##也可以直接通过solve函数</span></span><br><span class="line"></span><br><span class="line">QR&lt;-qr(X)</span><br><span class="line">(betahat&lt;-solve.qr(QR, y))</span><br><span class="line"></span><br><span class="line"><span class="comment">##              [,1]</span></span><br><span class="line"><span class="comment">## Intercept 0.9038372</span></span><br><span class="line"><span class="comment">## x         1.0066440</span></span><br><span class="line"><span class="comment">## x2        0.9999622</span></span><br><span class="line"><span class="comment">## x3        1.0000001</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>理论学习</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>理论学习</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分课程第二部分学习笔记</title>
    <url>/posts/9e4272e7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这是微积分课程的第二部分，后面还有，但是我没有做笔记了。</p>
<p>这里是微积分的<a href="https://vincere.fun/posts/b445140c/">第一部分笔记</a>，微积分第二部分的资料见<a href="https://tutorial.math.lamar.edu/Classes/CalcII/CalcII.aspx">官网</a></p>
<span id="more"></span>
<h1>Intergration Techniques</h1>
<p><img src="parts1.png" alt=""></p>
<p><img src="parts2.png" alt=""></p>
<p><img src="parts3.png" alt=""></p>
<h2 id="Integrals-involving-trig-functions">Integrals involving trig functions</h2>
<p><img src="trigs1.png" alt=""></p>
<p><img src="trigs2.png" alt=""></p>
<p>关于tan(x) 和 sec(x) 的关系</p>
<p><img src="trigs3.png" alt=""></p>
<p><img src="trigs6.png" alt=""></p>
<h2 id="Trig-Substitutions">Trig Substitutions</h2>
<p>将正常函数转化为三角函数。如下例</p>
<p><img src="trigs5.png" alt=""></p>
<p><img src="trigs7.png" alt=""></p>
<p><img src="trigs8.png" alt=""></p>
<h2 id="Partial-Fractions">Partial Fractions</h2>
<p>对于分母与分子都是二项式的式子，如果<strong>分子的最高项低于分母</strong>，可以将这个式子先进行分解，再积分。、</p>
<p>下面这个图没看懂？</p>
<p><img src="parts4.png" alt=""></p>
<p><img src="parts5.png" alt=""></p>
<h2 id="Integrals-Involving-Roots">Integrals Involving Roots</h2>
<p><img src="parts6.png" alt=""></p>
<h2 id="Integrals-involving-quadratics">Integrals involving quadratics</h2>
<p>如果有不符合以上规则的多项式（最多为二次）（即首先分子不是分母导数的倍数；分母不能因式分解），还想要使用三角函数。那么就需要先提取出x 的平方的函数。如下。</p>
<p><img src="parts7.png" alt=""></p>
<h2 id="Integration-Strategy">Integration Strategy</h2>
<h2 id="Imporper-Integrals">Imporper Integrals</h2>
<h3 id="Infinite-interval">Infinite interval</h3>
<p>当定积分的一侧或两侧是无穷大时，正确的做法用一个字母代替无穷大，然后求其极限值。</p>
<p><img src="parts8.png" alt=""></p>
<p>如果这种积分<strong>存在</strong>并且是一个常数，我们就说这个被积变量是<strong>convergent</strong>；反之，如果积分<strong>不存在</strong>或是<strong>无穷大</strong>，那么我们就说这个被积变量是<strong>divergent</strong>。</p>
<h3 id="Distontinuous-Integrand">Distontinuous Integrand</h3>
<p><img src="parts9.png" alt=""></p>
<p><img src="parts10.png" alt=""></p>
<h2 id="Comparison-Test-for-Improper-Integrals">Comparison Test for Improper Integrals</h2>
<p>如果不容易求积分，可以通过下面这个式子判断函数是否<strong>coverge</strong>。</p>
<p><img src="parts11.png" alt=""></p>
<p>很容易理解，因为积分是面积。</p>
<h2 id="Approximating-Definite-Integrals">Approximating Definite Integrals</h2>
<p>不是所有的被积变量都能求出原函数。因此有时需要<strong>近似估计定积分</strong>的值。</p>
<p>就是把定积分看成是<strong>求面积</strong>的问题。</p>
<h3 id="Midpoint-Rule">Midpoint Rule</h3>
<p>将[a,b]区间平均取n等分，每个小区间取<strong>中间点</strong>的值作为每个<strong>小矩形</strong>的高。</p>
<p><img src="parts12.png" alt=""></p>
<h3 id="Trapezoid-Rule">Trapezoid Rule</h3>
<p>一样是n等分，不同是算每个<strong>梯形</strong>的面积。</p>
<p><img src="parts13.png" alt=""></p>
<p><img src="parts14.png" alt=""></p>
<h3 id="Simpson’s-Rule">Simpson’s Rule</h3>
<p>同上 n等分。不过n必须为<strong>偶数</strong>。</p>
<p>类似于上一条，不过上一条是取直线。而这里是每两个区间（有3个点），求其<strong>二次式</strong>。这里用的是曲线。</p>
<p><img src="parts15.png" alt=""></p>
<p>下面每两个区间的面积不知道是咋推的。（未证明）</p>
<p>我不知道三条边是直线，一条边是曲线，怎么求面积。</p>
<p><img src="parts16.png" alt=""></p>
<p>这三种方法中，第三种方法一般<strong>误差最小</strong>。</p>
<h1>Applications of Integrals</h1>
<h2 id="Arc-length">Arc length</h2>
<p><img src="arc1.png" alt=""></p>
<h2 id="Surface-Area">Surface Area</h2>
<p>求旋转体的表面积。由于没有看Calculus I 的求旋转体的体积，因此跳过。</p>
<h2 id="Center-of-Mass">Center of Mass</h2>
<p>求平均分布的薄板的质心。就是只支撑这一点能维持水平的地方。</p>
<p>公式没看懂。首先假设这个物体的上下边缘分别是一个函数。</p>
<p><img src="mass1.png" alt=""></p>
<p><img src="mass2.png" alt=""></p>
<p><img src="mass3.png" alt=""></p>
<h2 id="Hydrostatic-Pressure-and-Force">Hydrostatic Pressure and Force</h2>
<p>涉及流体力学。求流体静力，貌似是等于水压乘面积。但是水压随着水深的变化而变化，因此需要用到微积分。</p>
<p>自己推理计算，对了。</p>
<p>但是不严谨，没有严格按照定积分的公式。</p>
<h2 id="Probability">Probability</h2>
<p>根据概率密度曲线，求连续分布的随机变量在某区间取值的概率。</p>
<p><img src="prob1.png" alt=""></p>
<p><img src="prob2.png" alt=""></p>
<h1>Parametric Equations and Polar Coordinates</h1>
<h2 id="Parametric-Equations-and-Curves">Parametric Equations and Curves</h2>
<p>有的时候，我们得不到 y = f(x) 或 x = h(y) 这两种形式的函数。例如圆的式子。但是有时我们可以得到一个 x = f(t) 和 y = g(t) 的形式。根据t 的定义域，每一个t，就能得到一个点(f(t),g(t))。这些点连起来得到的曲线就是<strong>parametric curve</strong>。</p>
<p>注意 parametric curve 是有方向的，是t 不断增大的方向。</p>
<h2 id="Tangents-with-Parametric-Equations">Tangents with Parametric Equations</h2>
<p><img src="tang1.png" alt=""></p>
<p>感觉这个式子，可以用速度的例子。一个是水平的运动，一个是竖直方向的运动。</p>
<p><img src="tang2.png" alt=""></p>
<p><img src="tang3.png" alt=""></p>
<p><img src="tang4.png" alt=""></p>
<h2 id="Area-with-Parametric-Equations">Area with Parametric Equations</h2>
<p>求面积（积分），设 x = f(t) ; y = g(t)</p>
<p><img src="area1.png" alt=""></p>
<h2 id="Arc-Length-with-Parametric-Equations">Arc Length with Parametric Equations</h2>
<p>推导省略，下面少了一个条件，即 dx/dt &gt; 0 。即 t 要保持从左往右走。</p>
<p><img src="arc2.png" alt=""></p>
<p>不如用原来的函数。</p>
<p><img src="arc3.png" alt=""></p>
<p>懂了，如果<strong>不考虑方向</strong>（也就是路程，而不是位移），那么可以直接用省略的公式。考虑方向，那么省略公式如果 dx/dt &gt; 0 时用原公式，如果 dx/dt &lt; 0 时原公式加一个负号。</p>
<h2 id="Surface-Area-with-Parametric-Equations">Surface Area with Parametric Equations</h2>
<p>求Parametric Curve 旋转体的表面积。之前这部分没看，跳过。</p>
<h2 id="Polar-Coordinates">Polar Coordinates</h2>
<p><img src="polar1.png" alt=""></p>
<h3 id="Area-with-Polar-Coordinates">Area with Polar Coordinates</h3>
<p><img src="polar2.png" alt=""></p>
<p>应该是根据了圆弧求面积的公式。利用积分的思想。</p>
<p><img src="polar3.png" alt=""></p>
<p>注意：定积分中的 α 和 β ，要保持顺时针转动。</p>
<h3 id="Arc-Length-with-Polar-Coordinates">Arc Length with Polar Coordinates</h3>
<p>这里指的还是单纯的长度，不看方向。所以一直用的是 ds。</p>
<p><img src="polar4.png" alt=""></p>
<h3 id="Surface-Area-with-Polar-Coordinates">Surface Area with Polar Coordinates</h3>
<p>没看</p>
<h1>Series &amp; Sequence</h1>
<p><img src="seq1.png" alt=""></p>
<p>如果当n 趋于无穷，序列极限存在且为定值，那么我们就说这个序列是<strong>convergent</strong>；如果序列极限<strong>不存在</strong>或极限是<strong>无穷</strong>，那么我们就说这个序列是<strong>divergent</strong>。</p>
<p>求序列极限的方法</p>
<p><img src="seq2.png" alt=""></p>
<p>根据函数极限性质，推导出以下序列极限的特性。</p>
<p><img src="seq3.png" alt=""></p>
<p><img src="seq4.png" alt=""></p>
<p>注意：下面的定理2 只有在极限为0时适用。</p>
<p><img src="seq5.png" alt=""></p>
<p><img src="seq6.png" alt=""></p>
<p>下面这个定理很好证。n 只能取奇数和偶数，而奇数和偶数都为L。那么这个序列的极限就肯定是L了。</p>
<p><img src="seq7.png" alt=""></p>
<h2 id="More-on-Sequences">More on Sequences</h2>
<p><img src="seq8.png" alt=""></p>
<p><img src="seq9.png" alt=""></p>
<h2 id="Series-The-Basics">Series - The Basics</h2>
<p>没搞清楚这个series 的概念。</p>
<p><img src="seq10.png" alt=""></p>
<p>series 好像仅仅是一个数。懂了，其实series 只是上图中的 Sn。图里仅仅是推导步骤。</p>
<p><img src="seq11.png" alt=""></p>
<p>这个定理只是说 an 的极限为0 是其收敛的必要条件，并不是说 an 极限为0 就一定会收敛。</p>
<p><img src="seq12.png" alt=""></p>
<p>下面这个定理，很简单。就是从逻辑学里转换过来。</p>
<p><img src="seq13.png" alt=""></p>
<h2 id="Special-Series">Special Series</h2>
<p>后面的很多都是高中知识。</p>
<p>Integral Test 条件是 an 必须递减且为正数。</p>
<p><img src="series1.png" alt=""></p>
<p>通过相同函数的积分只能看是否收敛，而不能求出series的<strong>值</strong>。</p>
<p><img src="series2.png" alt=""></p>
<p><img src="series3.png" alt=""></p>
<p><img src="series4.png" alt=""></p>
<p><img src="series5.png" alt=""></p>
<h2 id="Absolute-Convergence-Divergence">Absolute Convergence/Divergence</h2>
<p><img src="series6.png" alt=""></p>
<p><img src="series7.png" alt=""></p>
<p>下面这条未证明</p>
<p><img src="series8.png" alt=""></p>
<h2 id="Ratio-Test">Ratio Test</h2>
<p><img src="series9.png" alt=""></p>
<h2 id="Root-Test">Root Test</h2>
<p><img src="series10.png" alt=""></p>
<p>下面未证明</p>
<p><img src="series11.png" alt=""></p>
<h2 id="Strategy-for-Series">Strategy for Series</h2>
<h2 id="Estimating-the-Value-of-a-Series">Estimating the Value of a Series</h2>
<p>计算 Series 的值很多时候很困难，因此这里是<strong>估计</strong>Series 的值。而且下面都需要指定 n 的大小，其实就是说把 1(0) - n 的 sn 视为真值(?) ，后面的 Rn 视为误差项(?) 。</p>
<p>如果 an 一直是正数且递减</p>
<p><img src="series12.png" alt=""></p>
<p>这里的n 越大，就越准。</p>
<h3 id="Comparison-Test">Comparison Test</h3>
<p><img src="series13.png" alt=""></p>
<p>这种估计的准确性，取决于你使用的用于对比的函数。</p>
<h3 id="Alternating-Series-Test">Alternating Series Test</h3>
<p>没看懂，没证明。</p>
<p><img src="series14.png" alt=""></p>
<h3 id="Ratio-Test-2">Ratio Test</h3>
<p>这里需要假设series terms （即 an）都是正数。而且series 收敛，即 L &lt; 1。</p>
<p><img src="series15.png" alt=""></p>
<p><img src="series16.png" alt=""></p>
<h2 id="Power-Series">Power Series</h2>
<p><img src="series17.png" alt=""></p>
<p><img src="series18.png" alt=""></p>
<h2 id="Power-Series-and-Functions">Power Series and Functions</h2>
<p><img src="series19.png" alt=""></p>
<p><img src="series20.png" alt=""></p>
<p><img src="series21.png" alt=""></p>
<p>这节有点不会用</p>
<h2 id="Taylor-Series">Taylor Series</h2>
<p>泰勒公式的 a 是自己给的，而且只是<strong>假设</strong> f(x) 可以转化为 下面的这个 series。</p>
<p>我懂了，泰勒公式里的a 取啥值都行，都成立，不过 一般取a=0 更简单。</p>
<p>泰勒公式不过是把一个函数换成了一个series。</p>
<p><img src="series22.png" alt=""></p>
<p>如果将 a 设为0 ，即得到下面这个式子。</p>
<p><img src="series23.png" alt=""></p>
<p>下面的式子没看懂，貌似是求收敛的区间？</p>
<p><img src="series24.png" alt=""></p>
<p>几个重要的泰勒公式（a=0）</p>
<p><img src="series25.png" alt=""></p>
<h2 id="Applications-of-Series">Applications of Series</h2>
<ol>
<li>当原函数不能直接求积分时，可以使用泰勒公式进行<strong>转换</strong>。</li>
<li>使用<strong>n阶泰勒公式</strong>近似估计函数值。</li>
</ol>
<h2 id="Binomial-Series">Binomial Series</h2>
<p><img src="series26.png" alt=""></p>
<p>下面的定理没有证明，没看懂。（k是任意数，比如k=0.5,下面的阶乘怎么算的）</p>
<p><img src="series27.png" alt=""></p>
<h1>Vectors</h1>
<h2 id="Vectors-The-Basics">Vectors - The Basics</h2>
<p>向量只需要<strong>大小</strong>和<strong>方向</strong>，和起始位置<strong>无关</strong>。所以下图都是<strong>同一向量</strong>。</p>
<p><img src="vector1.png" alt=""></p>
<p><img src="vector2.png" alt=""></p>
<h3 id="Dot-Product">Dot Product</h3>
<p><img src="vector3.png" alt=""></p>
<p>下面这个式子往往用于求两向量的<strong>夹角</strong>，多维同样适用。</p>
<p><img src="vector4.png" alt=""></p>
<h3 id="projections-（投影）">projections （投影）</h3>
<p>b向量 在 a 向量的投影为：</p>
<p><img src="vector5.png" alt=""></p>
<p><img src="vector6.png" alt=""></p>
<h3 id="Direction-Cosines">Direction Cosines</h3>
<p>三维空间下，向量与x , y , z 轴形成的夹角的cosine。</p>
<p><img src="vector7.png" alt=""></p>
<p>下面均易证</p>
<p><img src="vector8.png" alt=""></p>
<h2 id="Cross-Product">Cross Product</h2>
<ul>
<li>点乘的结果是一个<strong>标量</strong></li>
<li>叉乘的结果是一个<strong>向量</strong></li>
</ul>
<p><img src="vector9.png" alt=""></p>
<p>实际是3×3的行列式的结果</p>
<p><img src="vector10.png" alt=""></p>
<p><img src="vector11.png" alt=""></p>
<p>叉乘的大小和方向如下：（方向符合**右手准则，**从a到b旋转）</p>
<p><img src="vector12.png" alt=""></p>
<p><img src="vector13.png" alt=""></p>
<p>从图可知，叉乘<strong>垂直</strong>于两个向量，或者说垂直这两个向量构成的平面。</p>
<p>如果 a 和 b 平行（夹角为0或180度）, 那么其叉乘大小为0，即为0向量。</p>
<p><img src="vector14.png" alt=""></p>
<p><img src="vector15.png" alt=""></p>
<p>下面的性质不太懂，未证明</p>
<p><img src="vector16.png" alt=""></p>
<h3 id="叉乘的几何性质">叉乘的几何性质</h3>
<p>叉乘本身是两个向量形成的平行四边形的<strong>面积</strong></p>
<p>但是下面的<strong>体积</strong>计算没看懂</p>
<p><img src="vector17.png" alt=""></p>
<h1>3-Dimensional Space</h1>
<h2 id="Equations-of-Lines">Equations of Lines</h2>
<p><img src="vector18.png" alt=""></p>
<p><img src="vector19.png" alt=""></p>
<p>另一种形式</p>
<p><img src="vector20.png" alt=""></p>
<h2 id="Equations-of-Planes">Equations of Planes</h2>
<p>n向量是法线（normal vector）</p>
<p><img src="vector21.png" alt=""></p>
<p><img src="vector22.png" alt=""></p>
<p><img src="vector23.png" alt=""></p>
<h2 id="Quadric-Surfaces">Quadric Surfaces</h2>
<p>没细看。</p>
<p>351页后都没看。2020年前就先到这了。我看calculus Ⅲ还涉及这一部分，估计之后还得看。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分课程第一部分学习笔记</title>
    <url>/posts/b445140c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这是根据美国拉马尔大学 <em>Paul Dawkins</em> 老师的<strong>微积分</strong>教学材料写的笔记。</p>
<p>网址为：<a href="https://tutorial.math.lamar.edu/Classes/CalcI/CalcI.aspx">https://tutorial.math.lamar.edu/Classes/CalcI/CalcI.aspx</a>  （点击网页右上角的 download，选择 complete book 即可下载 pdf 格式的书籍 ）</p>
<p>我发现很多英文教材很适合自学，而且言语恳切，不嫌啰嗦，生怕你看不懂，不理解。这本书的特点也是如此，写的非常仔细，完全可以根据作者提供的pdf 自学。</p>
<span id="more"></span>
<h1>Review</h1>
<p>radical 根数</p>
<h2 id="逆函数（inverse-function）">逆函数（inverse function）</h2>
<p>如果两个不同的x值不会对应同一个y值，那么我们称这个函数是一对一的（<strong>one to one</strong>）。</p>
<p>但是证明函数是一对一的，可能很困难。因此我们一般都是假设函数不是一对一的，或者我们严格限定定义域（<strong>domain</strong>）使得函数符合一对一的性质。</p>
<p>现在让我们来定义<strong>逆函数</strong></p>
<blockquote>
<p><strong>逆函数</strong>：如果有两个满足<strong>一对一</strong>的函数 f(x) 和 g(x) ，如果满足以下式子，我们就称它们互为逆函数，记为 f^-1^(x) 或  g^-1^(x)</p>
</blockquote>
<p><img src="inverse_function1.png" alt=""></p>
<p>找出逆函数的五个步骤。相比我之前的认识，就是增加了第五步，复合函数的证明。</p>
<p><img src="inverse_function2.png" alt=""></p>
<p>第5步从理论上讲需要证明两种复合函数都等于x。</p>
<p>一个函数与其逆函数<strong>关于y=x对称</strong>。</p>
<p>三角函数中 角度为degree 弧度为 radian 。单位弧度定义为圆弧长度等于半径时的圆心角。</p>
<ul>
<li>sin(-x) = -sin(x)  ; tan(-x) = -tan(x)</li>
<li>cos(-x) = cos(x)</li>
</ul>
<h1>limits</h1>
<p><img src="limits1.png" alt=""></p>
<p>这种定义是通俗的定义方式，不是使用数学式子严格表示的定义。</p>
<p>要点：</p>
<ol>
<li>极限是需要从<strong>左右两边靠近</strong>均成立的。（<strong>both sides</strong>）</li>
<li>极限<strong>不需要</strong> x 真的取到 a值 。</li>
</ol>
<p>判断极限存不存在，简单地说，就是随着x 越来越接近 a (<strong>from two sides</strong>) ，f(x) <strong>must</strong> 越来越接近 L 。</p>
<p>另外，极限的定义里不包括 <strong>x = a</strong>，极限的值和 ** x = a ** 的值是<strong>不相关</strong>的。极限只和 点a 附近的函数值有关。</p>
<p>重申：有的时候函数的定义域可能不包括a，但是这也不影响其极限的存在。</p>
<blockquote>
<p>We are <strong>NOT</strong> asking what y value the graph takes at the point in question.  In other words, we are asking what the graph is doing <strong>around</strong> the point x = a.</p>
</blockquote>
<h2 id="one-sided-limits">one-sided limits</h2>
<p><img src="limits2.png" alt=""></p>
<p>one-sided limits 与 normal limits 的区别就是<strong>单边</strong>与<strong>双边</strong>。</p>
<p>单边极限与双边极限的关系如下：</p>
<p><img src="limits3.png" alt=""></p>
<h2 id="limit-Properties">limit Properties</h2>
<p>极限的性质如下：</p>
<p><img src="limits4.png" alt=""></p>
<p>这些性质对<strong>单边</strong>极限也适用。</p>
<p>对于多项式，其某点的极限值等于其函数值。</p>
<p>目前学过的大部分函数都是“nice enough&quot; ，在其定义域内，其极限值都等于函数值。其组合函数一般也是”nice enough&quot;。</p>
<p>定理：</p>
<p><img src="limits5.png" alt=""></p>
<p>由此引出<strong>夹逼定理</strong>（<strong>Squeeze Theorem</strong>）</p>
<p><img src="squeeze_theorem1.png" alt=""></p>
<p>看一个图，一下就明白（这里假设三个函数是nice enough，但实际夹逼定理不需要满足这一点）</p>
<p><img src="squeeze_theorem2.png" alt=""></p>
<h2 id="infinite-Limits">infinite Limits</h2>
<p>无穷大的定义：</p>
<p><img src="infinite_limits1.png" alt=""></p>
<p>垂直渐进线定义：</p>
<p><img src="vertical_asympotote1.png" alt=""></p>
<h2 id="limits-at-infinity">limits at infinity</h2>
<p>这个是当x 为无穷大时的极限。</p>
<p>对于多项式，其正无穷或负无穷处的极限值等于其最高项的极限值。</p>
<p><img src="limits_at_infinity1.png" alt=""></p>
<p>水平渐进线（horizontal asymptote）定义：</p>
<p><img src="horizontal_asymptote1.png" alt=""></p>
<p>对于多项式求极限，一个最重要的地方就在于找到<strong>最大项</strong>，然后提取出来。这里的最大项指的是<strong>与0偏离最远</strong>的项</p>
<p>如果是分式，那么只看<strong>分母</strong>的<strong>最大项</strong>。</p>
<h2 id="continuity">continuity</h2>
<p>在前面的章节中，我们一直用 ” nice enough &quot; 来定义一个函数其极限值等于函数值的性质。现在我们来定义什么叫做 ” nice enough &quot;。</p>
<p>连续性定义：</p>
<p><img src="continuity1.png" alt=""></p>
<p>反过来说也成立。也就是说如果再这一点 极限值等于函数值，那么函数在这一点具有连续性。反之也成立。</p>
<p><img src="continuity2.png" alt=""></p>
<p>常见的非连续性如下，第一种称为 jump discontinuity ，第二种称为 removable discontinuity 。</p>
<p><img src="continuity3.png" alt=""></p>
<p>如果我们简单地定义连续性，一个函数如果在某一区间具有连续性，我们用铅笔画出这一段从开始到结束的函数图像，中间不需要拿起铅笔（without ever once picking up our pencil ）。也就是能一气呵成的画完这一段。</p>
<p>另外一种解释，如果函数图像 没有 breaks 或 holes（指空心点） ，我们就说它在这一段是连续的。</p>
<h3 id="求复合函数（满足连续）的极限定理（重要）">求复合函数（满足连续）的极限定理（<strong>重要</strong>）</h3>
<p><img src="continuity4.png" alt=""></p>
<h3 id="介值定理（intermediate-value-theorem）">介值定理（intermediate value theorem）</h3>
<p><img src="continuity5.png" alt=""></p>
<p>介值定理的主要应用为，证明函数在某个区间有根。但是介值定理没办法告诉我们具体位置，也没办法证明是几个根。</p>
<p>注意，如果一个值不在两个端点的区间上，不能反推函数在这个区间不存在这个值。</p>
<h3 id="The-Definition-of-the-Limit">The Definition of the Limit</h3>
<p>极限的准确定义：</p>
<p><img src="limit_definition1.png" alt=""></p>
<p>再次重申，极限的定义只是 around a ，而不包括 x = a。我们不关心 x = a 时的情况。</p>
<p>左右极限定义如下：</p>
<p><img src="limit_definition2.png" alt=""></p>
<p><img src="limit_definition3.png" alt=""></p>
<p>极限为正无穷和负无穷的定义如下：</p>
<p><img src="limit_definition4.png" alt=""></p>
<p>x 趋于正负无穷的定义：</p>
<p><img src="limit_definition5.png" alt=""></p>
<p>再次重申：极限一定是不断<strong>趋近</strong>的。</p>
<p>使用极限的精确定义来定义<strong>连续</strong>。注意：连续的定义中 x = a 必须在定义域内，与之前的极限定义不同。</p>
<p><img src="limit_definition6.png" alt=""></p>
<h1>Derivatives</h1>
<p>导数定义：</p>
<p><img src="derivative1.png" alt=""></p>
<p>导数可能并不存在。如果f’(x) 在 x = a 处存在，那么我们称 f(x) 在 x=a 处是<strong>可导</strong>的（<strong>differentiable</strong>）。</p>
<p>如果 f(x) 在 x = a 处可导，那么 f(x) 在 x = a 处是连续的。但反过来并不成立。</p>
<h2 id="Differentiation-Formulas">Differentiation Formulas</h2>
<p><img src="derivative2.png" alt=""></p>
<p><img src="derivative3.png" alt=""></p>
<h2 id="函数乘积和商的求导（product-and-quotient-rule）">函数乘积和商的求导（product and quotient rule）</h2>
<p><img src="derivative4.png" alt=""></p>
<p><img src="derivative5.png" alt=""></p>
<p>多个函数的乘积公式为</p>
<p><img src="derivative6.png" alt=""></p>
<h2 id="Derivatives-of-trig-functions">Derivatives of trig functions</h2>
<p><img src="derivative7.png" alt=""></p>
<p>第二个式子可以通过第一个式子证明，写在书上了。主要应用 1 - cos(x) = sin^2^(x/2)</p>
<p>三角函数求导公式如下。注意，<strong>sec(x) = 1/cos(x)</strong> ; <strong>csc(x) = 1/sin(x)</strong> 。不要搞错了</p>
<p><img src="derivative8.png" alt=""></p>
<h2 id="Derivatives-of-Exponential-and-Logarithm-Functions">Derivatives of Exponential and Logarithm Functions</h2>
<p>自然对数底数e 的定义：</p>
<p><img src="derivative9.png" alt=""></p>
<p>指数函数求导公式（已证明，见后）</p>
<p><img src="derivative10.png" alt=""></p>
<p>逆函数求导公式（已证明）</p>
<p><img src="derivative11.png" alt=""></p>
<p>通过逆函数求导公式，指数函数和对数函数互为逆函数，因此推导出(lnx)’ = 1/x 。</p>
<p><img src="derivative12.png" alt=""></p>
<p>小结一下</p>
<p><img src="derivative13.png" alt=""></p>
<p>注意区分指数函数的求导和多次函数（不知道这个咋称呼）的求导</p>
<p><img src="derivative14.png" alt=""></p>
<h2 id="Derivatives-of-Inverse-Trig-Functions">Derivatives of Inverse Trig Functions</h2>
<p><img src="derivative15.png" alt=""></p>
<h2 id="Derivatives-of-Hyperbolic-Functions">Derivatives of Hyperbolic Functions</h2>
<p>有六种常见的双曲线函数（目前无用，且求导易证明）</p>
<p><img src="derivative16.png" alt=""></p>
<h2 id="Chain-Rule">Chain Rule</h2>
<p>复合函数的求导规则（未证明）</p>
<p>说复合函数不是很准确，这里给出的公式只嵌套了一层，实际可以嵌套n层。所以才叫<strong>Chain Rulu</strong>。求多层嵌套的复合函数需要多加小心，可以不用一步完成，分几步拆解。</p>
<p><img src="derivative17.png" alt=""></p>
<p>我们可以使用Chain Rule 和 (e^x^)’ = e^x^ 证明  (a^x^)’ = a^x^ ln(a)</p>
<h2 id="Implict-Differentiation">Implict Differentiation</h2>
<p>并不是所有的函数都能写成 y = f(x) 。</p>
<p>对于<strong>implict function</strong>，首先要记住，y 或 y(x) 其实是 x 的函数。第二步就是两边同时对x求导。</p>
<p><strong>implict function</strong> 的求导结果往往还包含y。</p>
<h2 id="Related-Rates">Related Rates</h2>
<p>当式子中存在两种函数时，如 x(t) 和 y(t) 。如果其中一个x’(t) 已知，那么就能求出y’(t) 。</p>
<p>在求解包含两种相关的函数的导数时，最重要的是要找到包含两个<strong>related rates</strong>的式子。</p>
<p>如果式子中含有更多的其它函数，需要进行<strong>消元</strong>。</p>
<h2 id="Higher-Order-Derivatives">Higher Order Derivatives</h2>
<p><strong>first derivative</strong> 和 <strong>second derivative</strong></p>
<p>对于多项式，如果其最高项的degree为n，那么其n+1阶求导及其后均为0。</p>
<p><img src="derivative18.png" alt=""></p>
<p>注意多阶导数和函数的n次方写法的区别</p>
<p><img src="derivative19.png" alt=""></p>
<p>高阶导数的写法</p>
<p><img src="derivative20.png" alt=""></p>
<h2 id="Logarithmic-Differentiation">Logarithmic Differentiation</h2>
<p>有时，通过log函数能够简化运算(一般使用<strong>ln()</strong>)。</p>
<p>适用场景</p>
<ol>
<li>式子可以分解为多个式子<strong>相乘</strong>或<strong>相除</strong></li>
<li>y = (f(x))^g(x)^ 。例如 y = x^x^</li>
</ol>
<p>最后，总结一下不同的带有指数的求导公式</p>
<p><img src="derivative21.png" alt=""></p>
<h1>Applications of Derivatives</h1>
<p>求导不仅仅是为了求导，是为了解决实际问题的。</p>
<h2 id="Rates-of-Change">Rates of Change</h2>
<p>复习上一章</p>
<h2 id="Critical-Points">Critical Points</h2>
<p>f(x) 的 Critical Points 的定义：</p>
<p><img src="derivative22.png" alt=""></p>
<p>注意前提中是 f© 必须存在，这个前提很重要但也容易被忽略。</p>
<h2 id="Minimum-and-Maximum-Values">Minimum and Maximum Values</h2>
<p>首先，存在绝对极值和相对极值。很好理解，绝对的极值即在整个定义域内均为最大或最小，而相对的极值仅在某区域内。</p>
<p><img src="derivative23.png" alt=""></p>
<p>一图以蔽之</p>
<p><img src="derivative24.png" alt=""></p>
<p>对于定义域两端的函数值能否成为相对极值，这一点一直有争议。本文中设定定义域两端的函数值不能成为相对极值。</p>
<p>绝对极值只能出现在<strong>相对极值</strong>和<strong>定义域两端的函数值</strong>中。</p>
<p>如果是连续函数，取一闭区间，则必存在绝对最大值和绝对最小值。定理表述如下</p>
<p><img src="derivative25.png" alt=""></p>
<p>但是，这条定理并没有告诉我们绝对极值出现在哪，或者会出现几次。我们知道绝对极值一定存在。</p>
<p>但是定理中规定了要取一闭区间。如果不取区间，那么可能不存在绝对极值。函数在闭区间的连续性也是一个重要的前提。</p>
<p>取到<strong>相对</strong>极值的条件是 Critical Point。定理如下</p>
<p><img src="derivative26.png" alt=""></p>
<p>但是反过来说并不成立，也就是说不是所有的Critical Point 都是相对极值。也就是说相对极值肯定是Critical Point ，Critical Points 是 all possible relative extreme 。</p>
<p>这个定理没说全。如果f’© 不存在，也是Critical Point ，也是 possible relative extreme。</p>
<p>重申一遍，我们说possible relative extreme 也就是说不是所有的Critical Point 都是相对极值。但是我们把所有的Critical Point 都找出来，那么所有的relative extreme 就肯定都在里面了，不会有缺漏。用俗话说，就是宁肯杀错一千，不可放过一个。</p>
<h2 id="Finding-Absolute-Extreme">Finding Absolute Extreme</h2>
<p>书中没说，但感觉这些定理的条件中几乎都需要函数满足<strong>连续性</strong>（continuous)。但是一般用到的函数基本都满足连续性。</p>
<p>首先我们需要根据前面的Extreme Value Theorem 确定函数在给定的闭区间<strong>存在</strong>绝对极值。再根据前面的Fermat’s Theorem ，所有的Critical Points 是 all possible relative extremes 。而根据我们之前的认识，所有的绝对极值只会出现在相对极值或函数区间两端的值中。</p>
<p>因此，所有的Critical Points 加上 函数区间两端的函数值 即是 all possible absolute extremes。</p>
<p>找绝对极值的一般步骤。记得要剔除不在闭区间的Critical Points。</p>
<p><img src="derivative27.png" alt=""></p>
<h2 id="The-shape-of-a-graph-part-I">The shape of a graph,part I</h2>
<p>首先，我们确认<strong>递增</strong>和<strong>递减</strong>的定义</p>
<p><img src="derivative28.png" alt=""></p>
<p>用一阶导数来定义则如下</p>
<p><img src="derivative29.png" alt=""></p>
<p>之前这步其实做过了。</p>
<p>首先确定函数的<strong>连续性</strong>。然后确认Critical Points 。在分割的每个区间内取一点，该点f’(x) (注意不是原函数)的符号即是此区间的符号。</p>
<p>重申：Critical Points 也包括了f’(x) 不存在的情况。这种情况下，f’(x) 也可能改变符号。</p>
<p>知道 f(x) 在哪些区间递增或递减，那么就能画出 f(x) 的草图。</p>
<p>判断Critical Point 是否是相对极值：</p>
<p><img src="derivative30.png" alt=""></p>
<h2 id="The-shape-of-a-graph-part-2">The shape of a graph, part 2</h2>
<p>这里需要用到<strong>二阶导数</strong>，主要是考虑函数的凹凸性(concavity)。如图所示。用书上的话说，函数如果趋于&quot;open up&quot; ，那么就是 Concave Up；如果趋于 &quot; open down &quot; ，那么就是 Concave down。</p>
<p><img src="derivative31.png" alt=""></p>
<p>数学定义：切线在函数上方或下方</p>
<p><img src="derivative32.png" alt=""></p>
<p>concavity 与函数的增减毫无关系。</p>
<p>inflection point 的定义</p>
<p><img src="derivative33.png" alt=""></p>
<p><img src="derivative34.png" alt=""></p>
<p>这里应该写错了，f’'(x) &lt; 0 应该是 concave down 。</p>
<p>因此，infection point 应该是 f’‘(x) = 0  或者 <strong>不存在</strong>的地方。 但是并不是 f’'(x) = 0 或者不存在的地方，就一定是 infection point 。</p>
<p>我们只有通过确认这个点两侧的凹凸性情况，我们才能确认infection point 。</p>
<p>这和前面的相对极值是类似的。所有的相对极值都是critical points ，但是不是所有的 critical points 都是 相对极值。只有确认了这个点两侧的递增递减情况，我们才能确认这个点是不是相对极值。</p>
<p>通过确定凹凸性我们能画出更精细的草图。</p>
<p>根据f&quot;(x) 的符号能确定 Critical point （只适用于f’(x) = 0 ，不适用于不存在）是否是相对极值。定理如下</p>
<p><img src="derivative35.png" alt=""></p>
<p>注意，这里没有说f’(x) 不存在的critical point 的情况。注意第三种情况下如果f’‘(x) = 0 , 那么可能是任何情况。那么就要使用 first derivative test 判断这个 critical point 两侧的f’(x) 的符号。</p>
<h2 id="The-Mean-Value-Theorem">The Mean Value Theorem</h2>
<p>Rolle’s Theorem ：满足一定条件的函数f’(x) ，两个相等的函数值之间一定存在一个点，其f’(x) = 0。</p>
<p><img src="derivative36.png" alt=""></p>
<p>The mean value theorem 如下</p>
<p><img src="derivative37.png" alt=""></p>
<p>一样的，这个定理没有告诉我们 c 在哪 , 只是说至少有一个 c。</p>
<p>Rolle’s Theorem 只是 mean value theorem 的一个特例。</p>
<h2 id="Optimization">Optimization</h2>
<p>求解极值的一般方法：</p>
<ol>
<li>
<p>通过<strong>Finding Absolute Extreme</strong> 方法。从critical points 和 endpoints 中找。需要满足两个条件：闭区间和连续性。</p>
</li>
<li>
<p>通过<strong>First Derivative Test</strong>方法。根据此方法，如果一个点两侧f’(x) 符号不同，则此点为相对极值。要求连续性。 如果只有一个Critical points , 易知如下定理。</p>
<p><img src="derivative38.png" alt=""></p>
</li>
<li>
<p>通过二阶求导。二阶求导的使用主要包括以下方面。一是去除一些critical points ，通过求critical points 的 二阶导数，我们能得知其是否是相对极值。二是如果只有一个critical point，判断其是否是我们要的绝对极值，这和第二点一致。</p>
<p><img src="derivative39.png" alt=""></p>
</li>
</ol>
<h2 id="More-Optimization-Problems">More Optimization Problems</h2>
<p>就是更多的题目。</p>
<p>一个小点：如果 求式子 A = B时，由于有根式，两边平方，A^2^=B^2^，此时求出的解不一定是真的解，需要带入原式进行后验。</p>
<p>证明：A^2^=B^2^ 其解可能是 A =B , 也可能是 A = -B。</p>
<h2 id="Indeterminate-forms-and-L’Hospital’s-Rule">Indeterminate forms and L’Hospital’s Rule</h2>
<p><img src="derivative40.png" alt=""></p>
<p>如果是0/0 或 无穷/无穷，那么其极限等于其一阶导数之商的极限。</p>
<p>对于其它类型的indeterminate forms（不确定形式），可以转换为上述的两种形式。</p>
<p><img src="derivative41.png" alt=""></p>
<h2 id="Linear-Approximations">Linear Approximations</h2>
<p>对于某一点的切线方程，可以用于近似估计附近点的函数值。</p>
<h2 id="Differentials">Differentials</h2>
<p>这里的Differentials 就是指 dy 和 dx</p>
<p>dy = f’(x) dx</p>
<p>dy dx 就是当x变化很小时，x 的变化量和 y 的变化量。</p>
<h2 id="Newton’s-Method">Newton’s Method</h2>
<p>这个方法目前没什么意义了。</p>
<p>估计f(x) 的根</p>
<p><img src="derivative42.png" alt=""></p>
<h2 id="Business-Applications">Business Applications</h2>
<p>商业中的实例。</p>
<h1>Integrals</h1>
<h2 id="Indefinite-Integrals">Indefinite Integrals</h2>
<p>首先我们要知道如何从导数函数反推原函数，注意需要加一个 常数c 。因为常数的导数是0。所以，实际上，如果只知道导数函数，求解出的原函数有无数个（因为c不确定）。</p>
<p>一些基础定义</p>
<p><img src="integral1.png" alt=""></p>
<p>不定积分的部分性质</p>
<p><img src="integral2.png" alt=""></p>
<p><img src="integral3.png" alt=""></p>
<p>积分对于变量之间的<strong>乘</strong>或<strong>除</strong>没有公式。</p>
<p>求解后，可以求导，看是否与被积函数一致。</p>
<h2 id="Computing-Indefinite-Integrals">Computing Indefinite Integrals</h2>
<p>其实和求导公式一致，不过是反过来。</p>
<h2 id="Substitution-Rule-for-Indefinite-Integrals">Substitution Rule for Indefinite Integrals</h2>
<p><img src="integral4.png" alt=""></p>
<p>容易得到，因为 d(g(x)) = g’(x) d(x) 。</p>
<p>替换后积分式子中不能再有x ，要全变成 u 表示的式子。</p>
<h2 id="More-Substitution-Rule">More Substitution Rule</h2>
<h2 id="Area-Problem">Area Problem</h2>
<h2 id="The-Definition-of-the-Definite-Integral">The Definition of the Definite Integral</h2>
<p><img src="integral5.png" alt=""></p>
<p>这里的定义没有说清楚每个小长方形的高选用哪个点的函数值。</p>
<p><img src="integral6.png" alt=""></p>
<p>对定积分的解释之一是，定积分是f(x) 在 x 轴上的<strong>净面积</strong>（net area) 。是原函数从 a 到 b 的变化量。</p>
<p><img src="integral7.png" alt=""></p>
<p><img src="integral8.png" alt=""></p>
<p><img src="integral9.png" alt=""></p>
<p><img src="integral10.png" alt=""></p>
<p>注意，不定积分要求在[a,b]间具有<strong>连续性</strong></p>
<h2 id="Substitution-Rule-for-Definite-Integrals">Substitution Rule for Definite Integrals</h2>
<p>不定积分换元的问题在于，原来的不定积分上下限都是针对x的，而不是u。</p>
<p>有两种策略：1. 最后将u 替换回 x  ; 2. 将原来的上下极限换成u的上下极限。我感觉第二种更方便。</p>
<h1>Applications of Integrals</h1>
<h2 id="Average-Function-Value">Average Function Value</h2>
<p><img src="integral11.png" alt=""></p>
<p><img src="integral12.png" alt=""></p>
<h2 id="Volumes-of-Solids-of-Revolution-Method-of-Rings">Volumes of Solids of Revolution / Method of Rings</h2>
<p>求旋转体的体积，不想看了，以后再看。</p>
<h1>Extras</h1>
<p>其实最后一部分附录是<strong>精华</strong>，看懂这些证明过程很重要。但是人生苦短，我急于初步完成这本书，因此只能先到这了，这一部分没看。2019年12月20号。</p>
<h2 id="Proof-of-Various-Limit-Properties">Proof of Various Limit Properties</h2>
<p>这一部分的证明都是严格根据极限的数学定义证明的，严谨但是繁琐，没看。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title>只只和男朋友</title>
    <url>/posts/ac7827ff/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>记录只只和男朋友的日常。</p>
<span id="more"></span>
<center>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1861711530&auto=1&height=66"></iframe>
</center>
<h1>我们的时间线</h1>
<p>2007年左右：初识</p>
<p>2021年2月16日：再次见面</p>
<p>2021年3月4日22时11分 ： 确定恋爱关系</p>
<p>……</p>
<h1>我们的语录</h1>
<blockquote>
<p>时间 不详</p>
<p>只只：谈恋爱不就和吃饭喝水一样嘛</p>
</blockquote>
<blockquote>
<p>时间 2021年3月2日</p>
<p>男朋友：那怎么称呼？</p>
<p>只只：啊？我没想过 我朋友都叫我全名</p>
<p>只只：你简直问到我了</p>
<p>男朋友：茴茴？哈哈哈</p>
<p>只只：啊 我不知道唉 因为我们口音不一样啊</p>
</blockquote>
<blockquote>
<p>时间 2021年3月3日</p>
<p>只只：不过我们现在算什么关系啊</p>
<p>只只：****聊天？哈哈哈</p>
<p>男朋友：浅了</p>
<p>男朋友：不行</p>
<p>……</p>
<p>只只：那你要好好追我哦</p>
<p>只只：哈哈哈</p>
<p>男朋友：好哦</p>
<p>只只：那就改变称呼吧</p>
<p>只只：叫我只只</p>
</blockquote>
<blockquote>
<p>时间 2021年3月4日</p>
<p>只只：小周 小周</p>
<p>只只：你怎么还不出现啊</p>
<p>只只：给你10分钟哦</p>
<p>六分钟后</p>
<p>男朋友：出现了，出现了</p>
<p>男朋友：刚刚洗澡去了</p>
<p>只只：哈哈哈</p>
<p>……</p>
<p>只只：那你有啥要问我的</p>
<p>男朋友：没有啥要问的</p>
<p>只只：公平起见 我之前问了你的 现在到你了</p>
<p>只只：那好吧</p>
<p>男朋友：我不问，你也会说的</p>
<p>男朋友：何必费那事</p>
<p>……</p>
<p>只只：那就今天开始谈恋爱吧</p>
<p>男朋友：先恋爱后追求啊</p>
<p>只只：反正你表白了</p>
<p>只只：嗯嗯</p>
<p>男朋友：我们好特殊啊</p>
<p>时间：2021年4月9日</p>
<p>只只：刚刚我们生气的时候</p>
<p>只只：就我哭的时候</p>
<p>只只：我突然想到如果你不是我男朋友了</p>
<p>只只：我就好难过</p>
<p>男朋友：你这么说，我就好很多了。比你说的有点应该强一千万倍。</p>
<p>只只：因为你刺激到我了</p>
<p>只只：我的感觉一下就出来了</p>
<p>只只：之前抑制的感情一下就出来了</p>
<p>时间：2021年4月10日</p>
<p>只只：我喜欢喝甜甜的东西</p>
<p>男朋友：就像我们的恋爱吗？</p>
<p>……</p>
<p>只只：我对你的感觉是安全感，信任感，成熟感。有时候会想和你聊天，会想和你分享，有时候会想你。</p>
<p>男朋友：那这不是喜欢是什么</p>
<p>只只：是</p>
<p>男朋友：嗯？</p>
<p>只只：是</p>
<p>男朋友：是什么？</p>
<p>只只：你的结论是对的</p>
<p>男朋友：把我的结论再说一遍</p>
<p>只只：是喜欢</p>
<p>男朋友：主谓宾，把主语和宾语加上</p>
<p>只只：我喜欢你</p>
<p>男朋友：我也喜欢你</p>
<p>时间：2021年4月14日</p>
<p>男朋友：如果你驯养了我，我们就互相不可缺少了。对我来说，你就是世界上唯一的了；我对你来说，也是世界上唯一的了。</p>
<p>只只：驯养是相互的，不是单方向的，是双方向的。你驯养了我，我也驯养了你。</p>
<p>只只：温暖是互相给的。</p>
</blockquote>
<blockquote>
<p>时间：2021年12月12日</p>
<p>男朋友：宝宝，你就这么想东想西的，一直到嫁给我。</p>
</blockquote>
<h1>我们一起做的事</h1>
<h2 id="电影《悬崖之上》-2021年5月万年">电影《悬崖之上》-2021年5月万年</h2>
<p><img src="movie1.jpg" alt=""></p>
<h1>我们的相册</h1>
<h2 id="仙女湖之旅-2021年4月新余">仙女湖之旅-2021年4月新余</h2>
<p>仙女湖位于新余，誉为“中国七夕情人节”的发源地。我和只只上午去的，可是等滴滴就等了一个小时……</p>
<p>门口有很多小花花，还有很多风车。</p>
<p><img src="xiannvhu3.jpg" alt=""></p>
<p><img src="xiannvhu6.jpg" alt=""></p>
<p>逛的时候发现的“鹊桥”</p>
<p><img src="xiannvhu4.jpg" alt=""></p>
<p>里面有一些书法，勉强能看懂，都是一些情诗。</p>
<p><img src="xiannvhu1.jpg" alt=""></p>
<p><img src="xiannvhu7.jpg" alt=""></p>
<p>然后，最最重要的是，我们一块买了四只说不上名字的鸟，只只一开始说是企鹅，确实有一点像，毕竟都是圆鼓鼓的。左边那两只现在在只只那里，我们起名叫 “周大胖”，“周小胖”；右边那两只现在在我这，我们起名叫“程大胖”，“程小胖”。哈哈哈！</p>
<p>不过，这四只胖胖以后还是会放在一块的。</p>
<p><img src="xiannvhu5.jpg" alt=""></p>
<p>在景区吃的饭，仙女湖的鱼和藕条。我们一致觉得鱼不行，但我觉得藕条还行。悄悄地说一句，某人只要觉得不好吃就吃得很少，难养哦。</p>
<p><img src="xiannvhu2.jpg" alt=""></p>
<p>我走的那天送只只的玫瑰。周边其实没有花店，当时正好碰到了一个花店老板给别人送花，我就叫住了她，买了一束花，让她送过来。</p>
<p><img src="xiannvhu8.jpg" alt=""></p>
<h2 id="南昌之旅-2021年国庆">南昌之旅-2021年国庆</h2>
<p>入住的酒店有点意思，高朋酒店，在江西师范的一个校区内，房间里有一个八一届毕业生的照片，也就是恢复高考的第一届学生。</p>
<p><img src="nanchang1.jpg" alt=""></p>
<p>酒店旁边有一个餐厅，在那吃早饭，也吃了一顿午饭，那个鱼就是图中这么大。</p>
<p><img src="nanchang3.jpg" alt=""></p>
<p>学校里一个小荷塘</p>
<p><img src="nanchang4.jpg" alt=""></p>
<p>秋水广场的喷泉，第一次感觉到南昌也有这么多人</p>
<p><img src="nanchang2.jpg" alt=""></p>
<p>回天津火车上的照片，一南一北像是两个季节了</p>
<p><img src="nanchang5.jpg" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>反经-第八卷杂说-诡信</title>
    <url>/posts/e52a7502/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>【议曰：“ 代有诡诈反为忠信者也。” 抑亦通变，适时所为、见机而作而不俟终日者。】</p>
<p>孔子曰：“ 君子贞而不谅。” 又曰：“ 近逝于义，言可复也。” 由是观之，唯义所在，不在信也。【议曰：微哉！微哉！天下之事也，不有所废则无以兴。若忠于斯，必不诚于彼，自然之理矣。由是观之，则我之所谓忠，则彼之所谓诈也。然则忠之与诈，将何所取定哉？抑我闻之：夫臣主有大义，上下有定分，此百代不易之道也。故欲行忠，观臣主之义定；欲行信，顾上下之分明。苟分义不愆于躬，虽谲而不正可也。】何以明之？</p>
<p>叶公问孔子曰：“ 吾党有直躬者，其父攘羊而其子证之。” 孔子曰：“ 吾党之直者异于是，父为子隐，子为父隐，直在其中矣。”</p>
<p>楚子围宋，宋求救于晋。晋侯使解扬如宋，使无降楚，曰：“ 晋师悉起，将至矣。” 郑人囚而献诸楚，楚子厚赂之，使反其言。许之。登诸楼车，使呼宋人而告之，遂致其君命。楚子将杀之，使与之言曰：“ 尔既许不谷而反之，何故？非我无信，尔其弃之，速即尔刑！” 对曰：“ 臣闻之，君能制命为义，臣能承命为信。信载义而行之有利，谋不失利，以卫社稷，民之主也。义无二信，信无二命。君之赂臣，不知命也。受命以出，有死无殒，又何赂乎？臣之许君，以成命也。死而成命，臣之禄也！寡君有信臣，下臣获考，死又何求！” 楚之舍之以归。</p>
<p>【韩子曰：“ 楚有直躬者，其父窃羊而讦之，令尹曰：” 必杀之！“ 以为直于君而曲于父，执其子而罪之。由是观之，夫君之直臣，父之暴子也。鲁人从君战，三战三北，仲尼问其故，对曰：” 吾有老父，死莫之养也。“ 仲尼以为孝，誉而用之。以是观之，夫父之孝子，君之北人也。故令尹诛而楚奸不止，闻仲尼赏之，鲁人易降。此上下之利，若是其异也，而人主兼誉匹夫之行，而求致社稷之福，必不几矣。】</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第八卷杂说-钓情</title>
    <url>/posts/ed6fb8cc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>孔子曰：“ 未见颜色而言曰瞽”，又曰：“ 未信则以为谤己。” 孙卿曰：“ 语而当，智也，默而当，智也。” 尸子曰：“ 听言，耳目不惧，视听不深，则善言不往焉。” 是知将语者，必先钓于人情，自古然矣。</p>
<p>韩子曰：“ 夫说之难也，在知所说之心可以吾说当之。说之以厚利，则见下节而遇 卑贱，必弃远矣【所说实为厚利则阴用其言而显弃其身，此不可不知也】。说之以名高，则见无心而远事情，必不收矣【所谓实为名高而阳收其身而实疏之。此不可不知也】。事以密成，语以泄败，未必其身泄之也，而说及其所匿之事，如是者身危【周泽未渥也，而语极知，说行而有功则德亡，说不行而有败则见疑，如是者身危】。贵人有过端，而说者明言善议以推其恶者身危。贵人或得计而欲自己为功，说者与知焉则身危。强之以其所不为，止之以其所不能已者身危。“ 又曰：” 与之论大人，则以为间己，与之论细人，则以为鬻权。论其所爱，则以为借资，论其所憎，则以为尝已。顺事陈意则曰怯懦而不尽，虑事广肆，则曰草野而居侮，此不可不知也……彼自智其计，则勿以其失当之，自勇其断，则勿以其敌怒之。“ 【凡说须旷日弥久，周泽而不凝，交争而不罪，乃明计利害，以致其功。直指是非，以饰其身。以此相持，此说之成也。】</p>
<p>荀悦曰：” 夫臣下所以难言者，何也？言出乎身则咎悔及之矣。“ 故曰：举过揭非，则有干忤之咎，劝励教诲，则有侠上之议。言而当，则耻其胜己也，言而不当，则贱其愚也。先己而同，则恶其夺己明也，后己而同，则以为从顺也。违下从上，则以为谄谀也，违上从下，则以为雷同也。言而浅露，则简而薄之，深妙弘远，则不知而非之。特见独智，则众恶其盖己也，虽是而不见称，与众同智，则以为附随也，虽得之不以为功。谦让不争，则以为易容，言而不尽，则以为怀隐，进说竭情，则以为不知量。言而不效，则受其怨责，言而事效，则以为固当。利于上不利于下，或便于左则不便于右，或合于前而忤于后，此下情所以常不通。仲尼发愤，称”予欲无言“者，盖为语之难也。何以明其难也？</p>
<p>昔宋有富人，天雨坏墙，其子曰：” 不筑，且有盗。“ 其邻人亦云。暮而果大亡，其家智其子而疑邻人之父。郑武公欲伐胡，乃以其子妻之，因问群臣：” 吾欲用兵，谁可伐者？“ 关其思曰：” 胡可伐。“ 乃戮关其思，曰：” 胡，兄弟之国也，子言伐之，何也？“ 胡君闻之，以为郑为亲己而不备郑，郑人袭胡，取之。此二说者，其智皆当矣，然而甚者为戮，薄者见疑，非智之难也，处智则难。</p>
<p>卫人迎新妇，妇上车，问：” 骖马，谁马也？“ 御者：” 借之。“ 新妇谓仆曰：” 拊骖，无苦服。“ 车至门，拔教：” 逆母，灭橹，将失火。“ 入室，见臼，曰：” 徙牖下，妨往来者。“ 主人大笑之。此三言，皆要言也，然而不免为笑者，早晚之时失矣。此说之难也。</p>
<p>说者知其难也，故语必有钓，以取人情。何以明之？</p>
<p>昔齐王后死，欲置后而未定，使群臣议。薛公田婴欲中王之意，因献其珥而美其一，旦日因问美珥所在，因劝立以为后，齐王大悦，遂重薛公。此情可以物钓也。</p>
<p>申不害始合于韩王，然未知王之所欲也，恐言而未必中于王也。王问申子曰：“吾谁与而可？” 对曰：“ 此安危之要，国家之大事也，臣请深惟而苦思之。” 乃微请赵卓、韩冕曰：“ 子，皆国之辩士也，夫为人臣者，言何必同？尽忠而已矣。” 二人各进议于王以事。申子微视王之所悦，以言于王，王大悦之。此情可以言钓也。</p>
<p>吴伐越，越栖于会稽，勾践喟然叹曰：“吾终此乎？” 大夫种曰：“汤系夏台，文王囚姜里，重耳奔翟，齐小白奔莒，其卒霸王。由是观之，何遽不为福乎？” 勾践既得免，务报吴。大夫种曰：“ 吾观吴王政骄矣，请尝之。” 乃贷粟以卜其事。子胥谏勿与，王遂与之。子胥曰：“ 王不听谏，后三年，吴其墟矣！” 太宰嚭闻之，馋曰：“ 伍员貌忠而实忍人。” 吴杀子胥，此情可以事钓也。</p>
<p>客以淳于髡见梁惠王，惠王屏左右，再见之，终无言，王怪之，让客。客谓淳于髡，髡曰：“ 吾前见王，王志在驰逐，后复见王，王志在音色，是以默然。” 客具以报王，王大骇曰：“ 淳于先生，诚圣人也。前有善献马者，寡人未及试，会生来。后有献讴者，未及试，又会生至。寡人虽屏人，然私心在彼。” 此情可以志钓也。</p>
<p>智伯从韩魏之君伐赵，韩魏用赵臣张孟谈之计，阴谋叛智伯。张孟谈因朝智伯，遇智果于辕门之外。智果入见智伯，曰：“ 二主殆将有变，臣遇张孟谈，察其志矜而行高，见二君色动而变，必背君矣。” 智伯不从，智果出，遂更其姓曰辅氏。张孟谈见赵襄子曰：“ 臣遇智果于辕门之外，其视有疑臣之心。入见智伯而更其族，今暮不击，必后之矣。” 襄子曰：“诺！” 因与韩魏杀守堤之吏，决水灌智伯军，此情可以视钓也。</p>
<p>殷浩仕晋，有盛名，时人观其出处，以卜江左兴亡，此情可以贤钓也。【 《吕氏春秋》曰：“ 夫国之将亡，有道者先去。”】</p>
<p>【《易》曰：“将叛者，其辞惭，中心疑者，其辞枝。吉人之辞寡，躁人之辞多。诬善之人，其辞游，失其守者，其辞屈。” 】</p>
<p>由是观之，夫人情必见于物。【昔者晋公好色，骊姬乘色以壅之。吴王好广地，太宰陈伐以壅之。桓公好味，易牙蒸子以壅之。沉冥无端，甚可畏也。故知人主之好恶，不可见于外。所好恶见于外，则臣妾乘其所好恶以行壅制焉。故曰：人君无意见则为下饵。此之谓也。】能知此者，可以纳说于人主矣。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第三卷权变-正论</title>
    <url>/posts/6a24346d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>【议曰：“反经”、“是非”、“适变” 三篇，虽博辩利害，然其弊流遁漫，羡无所归。故作“正论”以质之。】</p>
<p>孔子曰：“六艺于治一也。《礼》以节人，《乐》以发和，《书》以导事，《诗》以达意，《易》以神化，《春秋》以义。”</p>
<p>【班固曰：“ 乐者，圣人之所以乐也，而可以善人心，其感人也深。故先王著其教焉。夫人又血气心知之性，而无衰乐喜怒之常。应感而动，然后心术形焉。故纤微憔悴之音作，而民思忧；阐谐慢易之音作，而民康乐；粗厉猛奋之音作，而民刚毅；廉直正诚之音作，而民肃静；宽裕顺和之音作，而民慈爱；流僻邪散之音作，而民淫乱。先王耻其乱也，故制《雅》、《颂》之声。本之情性，稽之度数，制之礼义，合生气之和，导五常之行，使之阳而不散，阴而不集，刚气不怒，柔气不摄，四畅交于中，而发作于外。足以感人之善心，而不使邪气得接焉。是先王立乐之方也。”</p>
<p>班固曰：“人涵天地阴阳之气，有喜怒哀乐之情，天禀其性而不节也，圣人能为之节而不能绝也。故像天地而制礼乐，所以通神明，立人伦，正情性，节万事也。……。故孔子曰：‘ 安于治人，莫善于礼；风易俗，莫善于乐。揖让而治天下者，礼乐之谓也。’ ”】</p>
<p>【司马谈曰：“ 儒者，博而寡要，劳而少功，是以其事难尽从，然其 叙君臣父子之礼，列夫妇长幼之别，不可易也。夫儒者，以‘六艺’为法，经传以千万，累世不能通其学，当年不能究其礼，故曰‘ 博而寡要，劳而少功 ’ 。若夫列君臣父子之礼，叙夫妇长幼之别，虽百家勿能易也。”</p>
<p>司马谈曰：“ 阴阳之术，大详而众忌讳，使人拘而多畏，然其叙四时之大顺，不可失也。夫阴阳四时，八位十二度，二十四节，各有教令。曰顺之者昌，逆之者亡，未必然也。故曰使人拘而多忌。夫春生夏长，秋收冬藏，此天下之大经，弗顺则无以为天下纪纲。故曰叙四时之大顺，不可失也。”</p>
<p>司马谈曰：“ 法家严而少恩；然正君臣上下之分，不可改也。夫法家不别亲疏，不殊贵贱，一断于法，则亲亲尊尊之恩绝矣。可使行一时之计，而不可长用也。故‘ 严而少恩 ’。至于尊主卑臣，明职分不相逾越，虽百家不能改也。”</p>
<p>司马谈曰：“ 墨家俭而难遵，是以其事不可偏循。然其强本节用，不可废也。】</p>
</blockquote>
<blockquote>
<p>数子之言，当世得失，皆悉究矣。然多谬通方之训，好申一隅之说。贵清净者，以席上为腐论；束名实者，以柱下为诞辞。或推前王之风，可行于当年，有引救弊之规，宜流于长世。稽之笃论，将为弊矣。由此言之，故知有法无法，因时为业，时止则止，时行则行，动不失其时，其道光明。非至精者，孰能通于变哉？</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第三章权变-适变</title>
    <url>/posts/1e7152bf/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>昔先王当时而立法度，临务而制事，法宜其时则理，事适其务故有功。今时移而法不变，务易而事以古，是则法与时诡，而事与务易，是以法立而时益乱，务无而事益废。此圣人之理国也，不法古，不修今，当时而立功，在难而能免。</p>
<p>【秦孝公用卫鞅。鞅欲变法，孝公恐天下议己，疑之。卫鞅曰：“疑行无名，疑事无功。夫有高人之行者，固见非于世；有独智之虑者，必见教于人。愚者暗于成事，智者见于未萌。人不可与虑始，而可与乐成。论至德者，不和于俗；成大功者，不谋于众。是以圣人苟可以强国，不法其故；苟可以利人，不循其礼。” 孝公曰：“ 善。” 甘龙曰：“ 不然。圣人不易人而教，智者不变法而治。因人而教，不劳而功成。缘法而理，吏习而人安。” 卫鞅曰：“ 龙之所言，世俗之言。常人安于习俗，学者溺于所闻。以此两者居官守法可也，非所以与论于法之外也。三代不同礼而王；五霸不同法而霸。智者作法，愚者制焉。贤者更礼，不肖者拘焉。” 杜贽曰：“ 利不百，不变法；功不十，不易器。法古无过，修礼无邪。” 卫鞅又曰：“ 治代不一道，便国不法故。故汤武不循古而王，夏殷不易礼而亡。反古者不可非，而循礼者不足多。” 孝公曰：“ 善。” 遂变法也。】</p>
<p>由是言之，故知若人者，各因其时而建功立德焉。【孟子曰：“ 虽有磁基，不如遇时；虽有智慧，不如逢代。” 范蠡曰：“ 时不至，不可强生；事不究，不可强成。” 《语》 曰：“ 圣人修备以待时也。” 】</p>
<p>何以知其然耶？桓子曰：“ 三皇以道治，五帝用德化，三王由仁义，五伯用权智。” 【说曰：无制令刑罚谓之皇，有制令，无刑罚谓之义；赏善诛恶，朝诸侯，朝事，谓之王；兴兵众，立约盟，以信义矫代谓之伯。文子曰：“ 帝者，贵其德也；王者，尚其义也；霸者，迫其理也。道狭然后任智，德薄然后任刑，明浅然后任察。议曰：夫建国立功，其政不同也如此。】</p>
<p>五帝以上久远，经传无事，唯王霸二盛之类，以定古今之理焉。【秦汉居帝王之位，所行者霸事也。故以为德之次。】</p>
<p>夫王道之治，先除人害，而足其衣食。</p>
<p>【论曰：” 五亩之宅，树之以桑，匹妇蚕之，年五十者，可以衣帛矣。百亩之田，数口之家，耕稼修理，可以无饥矣。鸡豚狗彘之畜，不失其时，老者可以食肉矣。夫上无贪欲之求，下无奢淫之人，藉税省少而徭役不繁，其仕者，食禄而已，不与人争利焉。是以产业均而贫富不能相悬也。“ 】</p>
<p>然后教以礼仪。</p>
<p>【故明王审己正统，慎乃其位。宫室舆服不逾礼制，九女正序于内，三公分职于外。制井田以齐之，设诸侯以牧之，使饶不溢侈，少不匮乏，然后申以辟雍之化，示以揖让之容，是以和气四塞，祸乱不生，此圣王之教也。】</p>
<p>而威以刑诛，使知好恶去就。</p>
<p>是故大化四凑，天下安乐，此王者之术。</p>
<p>【王者，父天母地，调和阴阳，顺四时而理五行，养黎元而育群生，故王之为言往也。盖言其惠泽，优游善养润天下，天下归往之，故曰王也。】</p>
<p>霸功之大者，尊君卑臣，权统由一，政不二门，赏罚必信，法令著明，百官修理，威令必行。</p>
<p>【夫霸君亦为人除难兴利以富国强兵，或承衰乱之后，或兴兵征伐。皆未得，遵法度，申文理，度代而制，因时施宜，以从便善之计，而务在于立功也。】此霸者之术。</p>
<p>【王道纯而任德，霸道驳而任法。此优劣之差也。】</p>
<p>《道德经》曰：” 我无为而人自化。“ 《文子》曰：” 所谓无为者，非谓引之不来，推之不往，谓其循理而举事，因资而立功，推自然之势也。“ 【故曰：” 智而好问者圣；勇而好问者胜。乘众人之智，即无不任也；用众人之力，即无不胜也。故圣人举事，未尝不因其资而用也。】 故曰：汤武，圣主也，而不能与越人乘舲舟，泛江湖。伊尹，贤相也，而不能与胡人骑原马，服**。孔、墨，博通也，而不能与山居者入榛薄，出险阻。</p>
<p>由是观之，人智于物，浅矣，而欲以昭海内，存万物，不因道理之数，而专己之能，则其穷不远。故智不足以为理，勇不足以为强，明矣。然而君人者，在庙堂之上而知四海之外者，因物以识物，因人以知人也。</p>
<p>【《吕氏春秋》曰：“ 是天无形而万物以成，大圣无事而千官尽能，此谓不教之教，无言之昭业。” 】</p>
<p>夫冬日之阳，夏日之阴，万物归之，而莫之使。至精之感，弗召自来。待目而昭见，待言而使令，其于理难矣。</p>
<p>【《文子》曰：“ 三月婴儿，未知利害，而慈母之忧喻焉者，情也。” 故曰：“ 言之用者小，不言之用者大。又曰：不言而信，不施而仁，不怒而威，是以天心动化者也。施而仁，言而信，怒而威，是以精诚为之者也。施而不仁，言而不信，怒而不威，是以外貌为之也。】</p>
<p>【庄子曰：” 天地有大美而不言，四时有明法而不议，万物有成理而不说。圣人无为，大圣不作，观于天地之谓也。】</p>
<p>不言之令，不视之见，圣人所以为师。此黄老之术也。</p>
<p>六经之理，贵于未乱；兵家之胜，贵于未战。</p>
<p>此孔氏之术也。【议曰：孔氏之训，务德行义，盖王道也。】</p>
<p>墨子曰：“ 古之人未知为宫室，就陵阜而居，穴而处，故圣王作为宫室。为宫室之法，高足以避润湿，边足以圉风寒。宫墙之高，足以别男女之礼。谨此则止，不以为观乐也。故天下之人，财用可得而足也。当今之王为宫室则与此异矣。必厚敛于百姓以为宫室，台榭曲直之望，青黄刻镂之饰，为宫室若此，故左右皆法而象之。是以财不足以待凶饥，振孤寡，故国贫而难理也。为宫室不可不节。【议曰：此节宫室者。】</p>
<p>古之人未知为衣服，时衣皮带茭，冬则不轻而暖，夏则不轻而清。圣王以为不中人之情，故圣人作，诲妇人，以为人衣。为衣服之法，冬则练帛，足以为轻暖，夏则絺绤，足以为轻清，谨此则止，非为荣耳目，观于人也。是以其人用俭约而易治，其君用财节而易赡也。当今之王，其为衣服，则与此异矣。必厚敛于百姓，以为文彩靡曼之衣，铸金以为钩，珠玉以为佩。由此观之，其为衣服，非为身体，皆为观好耶。是以其人淫僻而难治，其君奢侈而难谏。夫以奢侈之君，御淫僻之人，欲国无乱，不可得也。为衣服不可不节。”【 议曰：此节衣服也。】</p>
<p>此墨翟之术也。【议曰：墨家之议，去奢节用，盖强本道。】</p>
<p>商子曰：“ 法令者，人之命也，为治之本。【慎子曰：” 君人者，舍法而以身治，则受赏者虽当，望多无穷；受罚者虽当，望轻无已。君舍法而以心裁轻重，怨之所由生也。是以分马者之用策，分田者之用钩，非以钩策为过人之智也，所以去私塞怨也。故曰：夫君任法而不躬为，则怨不生而上下和也。“ 】 一兔走，百人逐之，非以兔可分为百，由名分之未定也。卖兔满市，盗不敢取者，由名分已定也。故名分未定，虽尧舜禹汤，且皆加务而逐之。名分之定，则贫盗不敢取。故尧舜圣人之为法令也，置官也，置吏也，所以定分也。名分定则大诈贞信，巨盗原悫，而各自治也。” 【《尹文子》曰：“ 名定则物不竞，分明则私不行。物不竞，非无心，由名定，故无所措其心；私不行，非无欲，由分明，故无所措其欲。然则心欲人人有之，而得同于无心无欲者，在制之有道故也。” 】</p>
<p>申子曰：“ 君如身，臣如手，君设其本，臣操其末。为人君者，操契以责其名。名者，天地之网，圣人之符。张天地之网，用圣人之符，则万物无所逃矣。”</p>
<p>此商鞅、申、韩之术也。</p>
<p>【恒范曰：“ 夫商鞅申韩之徒，贵尚谲诈，务行苛刻。废礼义之教，任刑名之教，不师古，始败俗伤化。此则伊尹、周公之罪人也。然其尊君卑臣，富国强兵，守法持术，有可取焉。逮至汉兴，有宁成，郅都之辈，仿商、韩之治，专以杀伐残暴为能，顺人主之意，希旨之行，要时趋利，敢行败祸，此又商、韩之罪人也。然其抑强族，抚孤弱，清己禁奸，背私立公，亦有取焉。至于晚代之所谓能者，乃犯公家之法，赴私门之势，废百姓之务，趋人间之事，决烦理务，临时苛辩，使官无谴负之累，不省下人之冤，复是申、韩、宁、郅之罪人也。”】</p>
<p>由是观之，故知治天下者，有王霸焉，有黄老焉，有孔墨焉，有申商焉，此所以异也，虽经纬殊制，救弊不同，然康济群生，皆有以矣。今议者或引长代之法，诘救弊之言【议曰：救弊为夏人尚忠，殷人尚敬，周人尚文者】；或引帝王之风，讥霸者之政，不论时变，而务以饰说。故是非之论，纷然作矣。言伪而辩，顺非而泽，此罪人也。故君子禁之。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第三卷权变-反经</title>
    <url>/posts/7d0687a0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>《韩诗外传》曰：“夫士有五反，有势尊贵不以爱人行义理，而反以暴傲。” ——【 反贵也。古语曰：” 富能富人者，欲贫不可得；贵能贵人者，欲贱不可得；达能达人者，欲穷不可得。“ 梅福曰：“ 存人所以自立也；壅人所以自塞也。” 】</p>
<p>家富厚不以振穷救不足，而反以侈靡无度。 —— 【反富也。】</p>
<p>资勇悍不以卫上攻战，而反以侵凌私斗。 —— 【反勇也。凡将帅轻去就者，不可使镇边，使仁德守之则安矣。】</p>
<p>心智慧不以端计教，而反以事奸饰非。 —— 【反智慧也。《说苑》曰：“ 君子之权谋正，小人之权谋邪。” 】</p>
<p>貌美好不以统朝莅人，而反以盅女从欲。 —— 【反貌也。】</p>
<p>此五者，所谓士失其美质。</p>
</blockquote>
<blockquote>
<p>太公曰：“明罚使人畏慑，人畏慑则变故出。 —— 【反明罚也。】 明察使人扰，人扰则人徙，人徙则不安其处，易以成变。” —— 【反明察也。】 太公曰：“ 明赏则不足，不足则怨长。明王理人，不知所好，而知所恶；不知所归，而知所去。使人各安其所生，而天下静矣。”</p>
<p>晋刘颂曰：“ 凡监司欲举大而略小，何则？ 夫细过微阙，谬忘之失，此人情所必有，所固不许在不犯之地，而悉纠以法，则朝野无立人。此所谓以治而乱也。”</p>
<p>韩子曰：“儒者以文乱法，侠者以武犯禁。“</p>
<p>慎子曰：” 忠未足以救乱代而适足以重非。** 。然则孝子不生慈父之义【六亲不和有孝慈】，而忠臣不生于圣君之下【国家昏乱有忠臣】。故明主之使其臣也，忠不得过职，而职不得过官。 —— 【反忠也]</p>
</blockquote>
<p>这段话我的理解，如果不是因为国家昏乱，则个人的忠名不显。而个人的忠名越显，反而越彰显出国家昏乱（如果只是敢于进言而无助于事），因此“适足以重非”。</p>
<blockquote>
<p>跖之徒问于跖曰：“盗亦有道乎？” 跖曰：” 何适而无有道耶？夫妄意室中之藏，圣也。入先，勇也。出后，义也。知可否，智也。分均，仁也。五者不备而能成大盗者，天下未之有也。“</p>
</blockquote>
<blockquote>
<p>由是观之，善人不得圣人之道不立，盗跖不得圣人之道不行。天下之善人少而不善人多，则圣人之利天下也少而害天下也多矣。 —— 【反仁义也。】</p>
</blockquote>
<blockquote>
<p>汉武时，河间献王来朝，造次必于仁义。武帝色然难之，谓曰：” 汤以七十里，文王以百里，王其勉之！” 王知其意，归即纵酒。</p>
<p>由是言之，夫仁义兼济，必有分乃可。故尸子曰：“ 君臣父子，上下长幼，贵贱亲疏，皆得其分理。爱得分曰仁。施得分曰义。虑得分曰智。动得分曰适。言得分曰信。皆得其分而后为成人。”</p>
<p>由是言之，跖徒之仁义非其分矣。</p>
</blockquote>
<blockquote>
<p>由是言之，夫仁义礼乐、名法刑赏、忠孝贤智之道，文武明察之端，无隐于人，而常存于代，非自昭于尧汤之时，非故逃于桀纣之朝。用得其道则天下理，用失其道则天下乱。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第二卷德行-德表</title>
    <url>/posts/9c3a31d9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>孔子曰：“性相近也，习相远也。” 言嗜欲之本同，而迁染之途异也。夫刻意则行不肆，牵物则其志流。是以圣人导人理性，裁抑流宕，慎其所与，节其所偏。故《传》曰：“ 审好恶，理情性，则王道毕矣。” 治性之道，必审己之所有余，而强其所不足。盖聪明流通者，戒于太察；寡言少见者，戒于壅蔽；勇猛刚强者，戒于太暴；仁爱温良者，戒于无断；湛静安舒者，戒于后时；广心浩大者，戒于遗忘。</p>
</blockquote>
<blockquote>
<p>此拘亢之材，非中庸之德也。</p>
</blockquote>
<blockquote>
<p>文子曰：“ 凡人之道，心欲小，志欲大，智欲圆，行欲方，能欲多，事欲少。” 所谓“心小”者，虑患未生，戒祸慎微，不敢纵其欲也；“ 志大” 者，兼包万国，一齐殊俗，是非辐辏，中之为毂也；“智圆” 者，终始无端，方流四远，深泉而不竭也；“行方”者，直立而不挠，素白而不污，穷不易操，达不肆志也；“能多” 者，文武具备，动静中仪也；“事少” 者，执约以治广，处静以待躁也。</p>
<p>夫天道极即反，盈即损。故聪明广智，守以愚；多闻博辩，守以俭；武力毅勇，守以畏；富贵广大，守以狭；德施天下，守以让。此五者，先王所以守天下也。</p>
<p>《传》曰：“无始乱，无怙富，无恃宠，无违同，无傲礼，无骄能，无复怒，无谋非德，无犯非义。“  此九言，古人所以立身也。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>说文解字第四册笔记</title>
    <url>/posts/da100df3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《说文解字》节选</p>
<span id="more"></span>
<p><strong>羁</strong>：<br>
羁，马络头也。<br>
原义是马络头。进而延申指用笼头系住马头。<br>
由络马头延申为束缚。例如“放荡不羁”。</p>
<p><strong>益</strong>：<br>
益，饶也。<br>
甲骨文从皿，“皿”上有很多“水”，会水太多而流出盆外之意。</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>说文解字</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>说文解字第三册笔记</title>
    <url>/posts/259f533d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《说文解字》节选</p>
<span id="more"></span>
<p><strong>逮</strong>：<br>
逮，及也。<br>
金文似右手揪住一条尾巴的样子。</p>
<p><strong>族</strong>：<br>
族，矢锋也。束之族族也。<br>
族，原义是箭头。</p>
<p><strong>感</strong>：<br>
感，动人心也。<br>
感的原义是人心受到外界影响而触动。</p>
<p><strong>意</strong>：<br>
意，志也。从心察言而知意也。<br>
意，意向。用心去考察别人的言语就知道他的意向。</p>
<p><strong>期</strong>：<br>
期，会也。<br>
期，约会。</p>
<p><strong>拜</strong>：<br>
拜，手至地也。<br>
拜，两手至地。<br>
甲骨文似双手捧禾麦奉献给神祖之行，会向神祖拜祭祈祷之意。</p>
<p>​</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>说文解字</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第二卷德行-臣行</title>
    <url>/posts/6feddce9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>夫人臣萌芽未动，形兆未见，昭然独见存亡之机，得失之要，豫禁乎未然之前，使主超然立乎显荣之处，如此者，圣臣也。</p>
<p>虚心尽意，日进善道，勉主以礼义，谕主以长策，将顺其美，匡救其恶，如此者，大臣也。</p>
<p>夙兴夜寐，进贤不懈，数称往古之行事，以厉主意，如此者，忠臣也。</p>
<p>明察成败，早防而救之，塞其间，绝其源，转祸以为福，君终己无忧，如此者，智臣也。</p>
<p>依文奉法，任官职事，不受馈赠，食饮节俭，如此者，贞臣也。</p>
<p>国家昏乱，所为不谀，敢犯主之严颜，而言主之过失，如此者，直臣也。</p>
<p>是谓六正。</p>
</blockquote>
<blockquote>
<p>安官贪禄，不务公事，与世沉浮，左右观望，如此者，具臣也。</p>
<p>主所言皆曰“善”，主所为皆曰“可”，隐而求主之所好而进之，以快主之耳目。偷合苟容，与主为乐，不顾后害，如此者，谀臣也。</p>
<p>中实险诐，外貌小谨，巧言令色，又心疾贤。所欲进则明其美，隐其恶；所欲退则彰其过，匿其美，使主赏罚不当，号令不行，如此者，奸臣也。</p>
<p>智足以饰非，辩足以行说，内离骨肉之亲，外妒乱于朝廷，如此者，馋臣也。</p>
<p>专权擅势，以轻为重；私门成党，以富其家；擅矫主命，以自显贵，如此者，贼臣也。</p>
<p>谄主以佞邪，坠主于不义，朋党比周，以蔽主明，使白黑无别，是非无闻；使主恶布于境内，闻于四邻，如此者，亡国之臣也。</p>
<p>是谓六邪。</p>
</blockquote>
<blockquote>
<p>议曰：夫圣人德全，器无不备。中庸已降，才则好偏。故曰：柴也愚，参也鲁，师也辟，由也喭。由此观之，全德者鲜矣！全德既鲜，则资矫情而力善矣！然世恶矫伪，而人贤任真。使其真贪愚而亦任之，可为贤乎？对曰：吁！何为其然？夫肖貌天地，负阴抱阳，虽清浊贤愚，其性则异，而趋走嗜欲，所规则同。故靡颜腻理，人所悦也；乘坚驱良，人所爱也；哭心贞节，人所难也；徇公灭私，人所苦也。不以礼教节之，则荡而不制，安肯攻苦食淡，贞洁公方，临财廉而取与义乎？故《礼》曰：”欲不可纵，志不可满。“ 古语云：” 廉士非不爱财，取之有道。“ 诗云：” 如切如蹉，如琢如磨。“ 皆矫伪之谓也。 若肆其愚态，随其鄙情，名曰任真而贤之，此先王之罪之也。故吾以为矫伪者，礼义之端；任真者，贪鄙之主。夫强仁者，庸可诬乎？</p>
</blockquote>
<blockquote>
<p>或曰：”长平之事，白起坑赵卒四十万，可为奇将乎？“</p>
<p>何晏曰：”白起之降赵卒，诈而坑其四十万，其徒酷暴之谓乎？ 后亦难以重得其志矣！ 向使众人预知降之必死，则张虚拳，犹可畏也。况于四十万披坚执锐哉？天下见降秦之将头颅依山，归秦之众骸积成丘，则后日之战，死当死耳，何众肯服，何城肯下乎？是为虽能裁四十万之命，而适足以强天下之战。欲以一期之功，而乃更坚诸侯之守。故兵进而自伐其势，军胜而还丧其计，何者？设使赵众复合，马服更生，则后日之战，必非前日之对也，况今皆使天下为后日乎！其所以终不敢复加兵于邯郸者，非但忧平原之补缝，患诸侯之救至也，徒讳之而不言耳。且长平之事，秦人十五以上，皆荷戟而向赵矣。夫以秦之强，而十五以上，死伤过半，此为破赵之功小，伤秦之败大也。又何称奇哉？“</p>
<p>议曰：黄石公称柔者能制刚，弱者能制强。柔者德也，刚者贼也。柔者人之所助，刚者怨之所居。是故纣之百克而卒无后，项羽兵强，终失天下。故随何曰：” 使楚胜，则诸侯自危惧而相救。夫楚之强，适足以致天下兵耳。“ 由是观之，若天下已定，借一战之胜，诈之可也。若海内纷纷，雌雄未决而失信于天下，败亡之道也。当亡国之时，诸侯尚强，而白起乃坑赵降卒，使诸侯畏之而合纵。诸侯合纵，非秦之利，为战胜而反败。何晏之论当矣。</p>
</blockquote>
<p>有意思！长平之战或胜于军事，但输于政治。</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>说文解字第二册笔记</title>
    <url>/posts/c3d58b1a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《说文解字》节选</p>
<span id="more"></span>
<p><strong>绝</strong>：<br>
绝，断丝也。<br>
绝，用刀断丝为二。</p>
<p><strong>怕</strong>：<br>
怕，无为也。</p>
<p><strong>守</strong>：<br>
守，守官也。<br>
“守”，金文是屋子里的一只手，由手在屋内掌管职责之意。<br>
原义是掌管职守。</p>
<p><strong>安</strong>：<br>
安，静也。<br>
女子坐在房中，会平安、安适之意。</p>
<p><strong>家</strong>：<br>
家，居也。<br>
“屋里有豕”为“家”。</p>
<p><strong>圣</strong>：<br>
圣，通也。<br>
圣，双耳畅通。<br>
甲骨文从耳，从口。<br>
原义是通达，延申指聪明、才智超群。在很早的时候人们传播知识、交流经验主要通过口耳相传，于是，只有善于聆听的人才能得到这么多的知识，故“圣”延申指博学多闻的人。</p>
<p><strong>拯</strong>：<br>
抍，上举也。<br>
原义是向上举，延申为援助、救济。</p>
<p><strong>报</strong>：<br>
报，当罪人也。<br>
报，判决罪人。甲骨文和金文左边是一个刑具，右边是一只手抓住一个人给其加上刑具的样子，会给人治罪之意。<br>
“报”的原义是按律判决罪人。例如《韩非子》：“报而罪之。” 意思是判决而治他的罪。判决罪人需要告知上级审批，故延申指告诉、告知。例如“通报”、“报警”。也引申为报答，例如”投桃报李“。<br>
好的回报是报答，但恶的回报就是报复了，所以”报“又指报复。例如”报仇雪耻“。也引申指由某种行为得到的结果。例如”善有善报“。</p>
<p><strong>莠</strong>：<br>
莠，禾粟下生莠。<br>
莠，是在禾粟之间生长的似禾非禾的东西叫“莠”。<br>
“莠”的原义是一种田间生长的外形似禾苗的杂草，其穗上似狗尾巴的毛，也叫狗尾巴草。例如《诗经》：“惟莠骄骄。” 意思是只有莠草长得十分茂盛。莠会妨碍禾苗生长，故延申成恶草的通称。也引申为坏、恶。例如“良莠不齐”。</p>
<p><strong>英</strong>：<br>
英，草荣而不实者。<br>
英，草只开花却不结实。<br>
“英”的原义是花。如《桃花源记》：“芳草鲜美，落英缤纷。”<br>
花是美好的，延申成美好、杰出、优异。</p>
<p><strong>萌</strong>：<br>
萌，草芽也。<br>
“萌”的原义是草木的芽。延申指发芽；又引喻事情刚刚显露的发展趋势或者情况、开端。例如《韩非子》：“圣人见微以知萌，见端以知末。” 又指开始发生。例如“萌动”。</p>
<p><strong>大</strong>：<br>
大，天大，地大，人亦大。故大象人形。<br>
“大”是象形字。甲骨文、金文、小篆的形状全部似一个正面站立、张开双手双脚的人的形象。<br>
“大”的原义是人。人为“万物之灵”，上古以人为大，故延申为“大小”之“大”。也引申表示重要、重大。</p>
<p><strong>太</strong>：<br>
“太”是象形字。甲骨文中的“太”字就是“大”形，似正面站立的人形。金文下面增加了一个曲笔，以与“大”相区别。隶变以后楷书写成“太”。<br>
“太”是在“大”的基础上再加了一点而形成的，故延申成过于。如杜甫《新婚别》：“暮婚晨告别，无乃太匆忙！” 延申为最、极。进而延申指身份最高或者辈分更高的。例如”太公“、”太后“。</p>
<p><strong>天</strong>：<br>
天，颠也。至高无上，从一大<br>
天，头顶。<br>
”天“的原义是人的头顶；两眉之间，称为”天庭“。人至高无上的部分为”天“（头），自然界至高无上的部分也为“天”。</p>
<p><strong>夫</strong>：<br>
夫，丈夫也。从大，一以象簪也。周制以八寸为尺、十尺为丈。人长八尺，故曰丈夫。<br>
夫，成年男子。从大，一用以似成年男子头发上的簪子之形。</p>
<p><strong>君</strong>：<br>
君，尊也。从尹，发号，故从口。</p>
<p><strong>混</strong>：<br>
混，丰流也。从水昆声。<br>
混，盛大的水流。<br>
“混”的原义是水势盛大。水大则泥多，容易浑浊，故延申指浑浊，水多泥、多杂质而不清澈。进而延申指糊涂、不懂事。</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>说文解字</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-政体</title>
    <url>/posts/a3353214/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>【议曰：夫政理，得人则心，失人则毁。故首简才，次论政体也。】</p>
</blockquote>
<blockquote>
<p>措国于不倾之地，有德也。</p>
</blockquote>
<blockquote>
<p>积於不涸之仓，务五谷也。</p>
</blockquote>
<blockquote>
<p>下令于流水之原，以顺人心也。</p>
<p>尉缭子曰：“令，所以一众心也。不审所出，则数变，数变则令虽出，众不信也。出令之法虽有小过，无更，则众不二听，即令行矣。”</p>
</blockquote>
<blockquote>
<p>使士于不诤之官，使人各为其所长也</p>
<p>孙卿曰：“相高下，序五谷，君子不如农人；通财货，辩贵贱，君子不如贾人；设规矩，便备用，君子不如工人。若夫论德而定次，量能而授官，言必当理，事必当务，然后君子之所长。”</p>
<p>文子曰：“力胜其任即举之，不重也；能务其事则为之，不难也。”</p>
</blockquote>
<p>这里的“诤” 解释为不争夺权势，个人感觉根据下文说不通，解释为不让人争论更好，即举官应该做到让人无法非议。</p>
<blockquote>
<p>明必死之路，严刑罚也。</p>
<p>议曰：孔子曰：“上失其道而杀其下，非礼也。” 故三军大败，不斩；狱*不治，不可刑。何也？上教之不行，罪不在人故也。夫慢令致诛，贼也；征敛无时，暴也；不诫责成，虐也。政无此三者，然后刑，即可也。陈道德以先服之，犹不可，则尚贤以劝之，又不可，则废。不能以惮之，而犹有邪人不从化者，然后待之以刑矣。“</p>
</blockquote>
<blockquote>
<p>开必得之门，信庆赏也。</p>
</blockquote>
<blockquote>
<p>不为不可成，量人力也。</p>
<p>文子曰：”夫债少易偿也，职寡易守也，任轻易劝也。上操约少之分，下效易为之功，是以为君为臣久而不相厌也。末世之法，高为量而罪不及，重为任而罚不胜，危为难而诛不敢。人困于三责，即饰智以诈上，虽峻法严刑，不能禁其奸也。“</p>
</blockquote>
<blockquote>
<p>不求不可得，不强人以其所恶也。</p>
<p>故其称曰：”政“者，政之所行，在顺人心，政之所废，在逆人心。夫人恶忧劳，我逸乐之；人恶贫贱，我富贵之；人恶危坠，我存安之；人恶绝灭，我生育之。能逸乐之，则人为之忧劳；能富贵之，则人为之贫贱；能存安之，则人为之危坠；能生育之，则人为之绝灭。故从其四欲，则远者自亲，行其四恶，则近者亦叛。</p>
</blockquote>
<blockquote>
<p>不处不可久，不偷取一世宜也。</p>
</blockquote>
<blockquote>
<p>知时者，可立以为长。</p>
<p>范蠡曰：” 时不至不可强生，事不容不可强成。“ 管子曰：” 圣人能辅时，不能违时。“ 《语》曰：”圣人修备以待时也。“</p>
</blockquote>
<blockquote>
<p>审于时，察于用，而能备官者，可奉以为君。</p>
<p>管仲曰：” 大位不仁，不可授以国柄；见贤不让，不可与尊位；罚避亲戚，不可使主兵；不好本事，不可与都邑。“ 又曰：” 使贤者食于能，则上尊崇；斗士食于功，则卒轻死。使二者设于国，则天下理。“</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-论士</title>
    <url>/posts/b8f1ee07/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>《书》曰：“能自得师者王。” 何以明之？齐宣王见颜触曰：“触前。” 触亦曰：“王前。” 宣王作色曰：“王者贵乎？士者贵乎” ……</p>
<p>宣王左右曰：“大王据千乘之地，而建千石之钟，东西南北，莫敢不服。今夫士之高者，乃称匹夫，徒步而处于农亩，下则鄙野、监门、闾里。士之贱也，亦甚矣。” 触曰：“古大禹之时，诸侯万国。舜起农亩而为天子。及汤之时，诸侯三千。当今之世，南面称寡人则，乃四世。由此观之，非得失之策与？稍稍诛灭，灭亡无族之时，欲为监门、闾里，安可得哉？《易传》不云乎：‘居上位，未得其实。’ 故无其实而喜居名者削；无其德而望其福者约；无其功而受其禄者辱，祸必掘。故曰：‘ 矜功不立，虚愿不至。’ 至皆夸其名华而无其实德也。是以尧有九佐，舜有十友，禹有五丞，汤有三辅，自古及今，而能虚成名于天下者，无有。是以君王无羞亟问，不愧下学，而成其道。老子曰：‘ 虽贵，必以贱为本；虽高，必以下为基。’ 是以侯王称孤、寡人、不谷。夫孤寡者，困贱、下位者也，而侯王以是谓，岂非下人而尊贵士与？夫尧传舜，舜传禹，周成王传周公旦，而世世称名，实以明乎士之贵也。“</p>
<p>谚曰：”浴不必江海，要之去垢；马不必骐骥，要之善走；士不必贤也，要之知道；女不必贵种，要之贞好。“ 何以明之？淳于髡谓齐宣王曰：”古者好马，王亦好马；古者好味，王亦好味；古者好色，王亦好色；古者好士，王独不好。“ 王曰：” 国无士耳。有则寡人亦悦之。“ 髡曰：” 古有骅骝，今之无有，王选于众，王好马矣；古有豹像之胎，今之无有，王选于众，王好味矣；古有毛嫱、西施，今之无有，王选于众，王好色矣；王必待尧舜禹汤之士，而后好之，则尧舜禹汤之士，亦不好王矣。“</p>
<p>《淮南》曰：”待腰袅、飞兔而后驾，则世莫乘车矣；待西施、洛浦而后妃，则终身不家矣。然不待古之英隽而自足者，因其所有而遂用之也。“</p>
<p>郭隗说燕昭王曰：” 帝者与师处，王者与友处，霸者与臣处，亡国与厮役处。诎指而事之，北面受学，则百己者至；先趋而后息，先问而后默，则什己者至；人趋己趋，则若己者至；凭几据杖，眄视指使，则厮役之人至；恣睢奋击，呴藉叱咄，则徒隶之人至矣。“此乃古之服道致士者也。</p>
<p>黄石公曰：”礼者，士之所归；赏者，士之所死。招其所归，示其所死，则所求者至矣。“</p>
</blockquote>
<blockquote>
<p>【议曰：世之善恶，难得而知，苟非其人，莫见其际，何者？夫文章为武人所嗤，未必鄙也；为扬、马所嗤，此真鄙也。夫人臣为桀、纣所毁，未必为愚也；必若尧舜所毁，此真愚也。世之毁誉不足信也。故曰：不夜出，安知有夜行人？太公曰：“ 智与众同，非人师也；伎与众同，非国工。” 老子曰：“下士闻道，大笑之，不笑不足以为道。” 故曰：凡人所贱，圣人所贵。信矣哉！】</p>
</blockquote>
<blockquote>
<p>《语》曰：”知人未易，人未易知。“</p>
</blockquote>
<blockquote>
<p>《语》曰：”夫有国之主，不可谓举国无深谋之臣，合朝无智策之士，在听察所考精与不精，审与不审耳。“ …… 天下之国，莫不皆有忠臣谋士也。</p>
<p>议曰：天下无灾害，虽有贤德，无所施材。老子曰：”大道废，有仁义；国家混乱，有忠诚。《淮南子》曰：”未有其功而知其贤者，唯尧之知舜也；功成事立而知其贤者，市人之知舜也。“ …… 故曰：“贤、不肖者，才也；遇与不遇者，时也。” 诚哉，是言也。</p>
</blockquote>
<blockquote>
<p>黄石公曰：”罗其英雄，则敌国穷。夫英雄者，国家之干；士民者，国家之半。得其干，收其半，则政行而无怨。知人者哲，唯帝难之。“ 慎哉！</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-察相</title>
    <url>/posts/3e46a22e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这里的“相”除了长相，骨骼等，还指的是人的形态、举止。</p>
<span id="more"></span>
<blockquote>
<p>富贵在于骨法，忧喜在于容色，成败在于决断。由此参之，万不失一。</p>
</blockquote>
<blockquote>
<p>言性灵者存乎容止。斯其大体。</p>
</blockquote>
<blockquote>
<p>夫人有六贱：<br>
头小身大，为一贱 【又曰：额角陷缺，天中洼下，亦为一贱。】<br>
目无光泽，为二贱【又曰：胸背俱薄，亦为二贱。《经》曰：陷胸薄尻及猴目，皆穷相也】。<br>
举动不使，为三贱【又曰：声音雌散，亦为三贱。夫人不笑似笑，不嗔似嗔，不喜似喜，不畏似畏，不醉似醉，常如宿醒，不愁似愁，常如忧戚，容貌缺乏，如经痫病，神色凄怆，常如有失，举止张皇，恒如趋急，言语涩缩，若有隐藏，体貌低催，如遭凌辱，此并神不足者也。神不足者，多牢狱厄。有官隐藏而失，有位贬逐而黜者也。<br>
鼻不成就，准向前低，为四贱<br>
脚长腰短，为五贱<br>
文策不成，唇细横长，为六贱。【又曰：多言少信，亦为六贱。<br>
此贵贱存乎骨骼者也。</p>
</blockquote>
<p>译文解释：相面要从身体结构的整体上把握，绝不能只见树木、不见森林。大凡人的姿容，都以“整”为贵。这个“整”指的并不是整齐划一，而是人体的各个部位都要匀称、均衡，从而构成一个和谐有机的整体。比如个子矮的人不能太胖；个子高的人不能太瘦，不然就像一根茅草或电线杆。背部应该浑圆而厚实，腹部应该突出而平坦，手部应该温润而柔软，脚应该丰厚而饱满，足心应该虚能藏蛋 – 这也是所谓的“整”。</p>
<blockquote>
<p>昔姑布之卿谓子贡曰：“郑东门有一人，其长九尺六寸，河目而龙颜，其头似尧，其颈似皋陶，其肩似子产，然自腰以下不及禹三寸，垒然若丧家之犬。”</p>
</blockquote>
<p>译文：郑国东门的这个人虽然有尧一样的头颅，皋陶一样的脖颈，子产一样的肩膀，然而由于腿太短，所以像一只丧家之犬。这就是因为此人的相貌违反了“整”的原则。</p>
<blockquote>
<p>夫命之与相，犹声之与响也。声动乎几响，穷乎应，必然之理也。虽云以言信行，失之宰予，以貌度性，失之子羽。然《传》称：“无忧而戚，忧必及之；无庆而乐，乐必还之。” 此心有先动而神有先知，则色有先见。故扁鹊见桓公，知其将亡；申叔见巫臣，知其窃妻。或跃马膳珍，或飞而食肉，或早隶晚侯，或初刑末王。铜岩无饱生，玉馔终乎饿死。则彼度表扪骨，指色摘理，不可诬也。故列云尔。</p>
</blockquote>
<p>这一篇我原来当作糟粕，现在想想也很有道理的。长相、身高等确实是天生，但是形态、举止等是可以后天改变的，是可以教化的。按峰老师的说法，以貌取人仍然是最简单最直接的方法。人的内心的情志一定会通过外貌和举止来体现出来，而且更多的时候我们也只能通过人的外貌、形态和举止对其它人做出一个判断。</p>
<p>比如目光无泽、举动不使（译文，行为举止看着力不从心）就说明这个人意志薄弱（神不足）。就像这种情况，就完全是可以通过增强意志、锻炼身体等方式进行改变的。</p>
<p>其实这篇对我的意义在于，一是说明了以貌取人虽然不见得对，但是仍然是有道理的；二是要认识到自身形态举止的缺点，进行针对性的改造，以最大实现“整体”的和谐。</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-知人</title>
    <url>/posts/2dee69f0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>臣闻主将之法，务览英雄之心。然人未易知，知人未易。 汉光武聪听之主也，谬于庞萌；曹孟德知人之哲也，弊于张邈。何则？夫物类者，世之惑乱也。故曰：狙者类智而非智也，愚者类君子而非君子也，戆者类勇而非勇也。亡国之主似智；亡国之臣似忠；幽莠之幼似禾；骊牛之黄似虎；白骨疑象；碔砆类玉。此皆似是而非也。</p>
<p>《人物志》曰：”轻诺似烈而寡信；多易似能而无效；进锐似精而去速；诃者似察而事烦；许施似惠而无终；面从似忠而退违。此似是而非者也。亦有似非而是者：大权似奸而有功；大智似愚而内明；博爱似虚而实厚；正言似讦而情忠。非天下之至精，孰能得其实也？“</p>
</blockquote>
<blockquote>
<p>孔子曰：”凡人心险于山川，难知于天。天犹有春夏秋冬旦暮之期，人者厚貌深情，故有貌愿而益，有长若不肖，有顺怀而达，有坚而缦，有缓而钅干。“ 太公曰：”士有严而不肖者，有温良而为盗者，有外貌恭敬中心欺慢者，有精精而无情者，有威威而无成者，有如敢断而不能断者，有恍恍惚惚而反忠实者，有倭倭拖拖而有效者，有貌勇狠而内怯者，有梦梦而反易人者。无使不至，无使不遂，天下所贱，圣人所贵，凡人莫知，惟有大明，乃见其际。“ 此士之外貌不与中情相应者也。</p>
</blockquote>
<blockquote>
<p>知士者而有水焉。微察问之，以观其辞；穷之以辞，以观其变，与之间谋，以观其诚；明白显问，以观其德；远使以财，以观其廉；试之以色，以观其贞；告之以难，以观其勇；<strong>醉之以酒，以观其态</strong>。</p>
</blockquote>
<blockquote>
<p>《庄子》曰：”远使之而观其忠；近使之而观其敬；<strong>烦使之而观其能</strong>；<strong>卒然问焉而观其智</strong>；急与之期而观其信；杂之以处而观其色。</p>
</blockquote>
<p>简单地说，就是需要通过实践来验证一个人的才能和品格。</p>
<blockquote>
<p>桓范曰：“夫务名者不能出己之后，是故性同而材倾则相援而相赖也，性同而势均则相竞而相害也。” 此为同体之变，不可不察也。</p>
</blockquote>
<blockquote>
<p>夫圣贤所美，莫美乎聪明。聪明之所贵，莫贵乎知人。知人识智，则众材得其序，而庶绩之业兴矣。…… 察其所安，观其所由，以知居止之行。率此道也，人焉庾哉，人焉庾哉？</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>说文解字第一册笔记</title>
    <url>/posts/27938e11/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>果然是书非借不能读也。说文解字这一套书买来就没怎么看过了。哈哈哈，类似了买了健身卡就感觉自己锻炼了一样。</p>
<span id="more"></span>
<p><strong>才</strong>：<br>
才，草木之初也。<br>
象形字，上面一横表示土地，植物嫩芽刚刚出土而枝叶尚未出土的样子。<br>
原义是草木初生。延申为木料或木料的质性，人或物的质性。</p>
<p><strong>奉</strong>：<br>
奉，承也。<br>
金文似用双手捧着禾麦奉献给神祖之行，会向神祖拜祭祷告、祈求丰收之意。</p>
<p><strong>与</strong>：<br>
与，赐予也。一勺为与。<br>
一双手把器物交给一双手的意思。<br>
原义是赐给、给予。授人以物，除了是对对方的肯定之外，甚至还可能想跟对方结交，所以延申出赞许、嘉奖、交往、结交之意。</p>
<p><strong>本</strong>：<br>
本，木下曰本<br>
根本，根本，本就是根。</p>
<p><strong>考</strong>：<br>
考，老也。<br>
甲骨文为老人扶杖之形。</p>
<p><strong>北</strong>：<br>
北，乖也。从二人相背。<br>
两个人背靠背，是”背“的本字。<br>
打了败仗逃跑时总是以背对敌，”北“由此延申指败、败逃。例如败北。<br>
古代君主面朝南坐，臣子面君时则面朝北，所以对人称臣为”北面“</p>
<p><strong>卑</strong>：<br>
卑，贱也。<strong>执事</strong>也。<br>
金文似左手持一粗糙的酒器之形，会执事供役使之意。后延申为地位低微</p>
<p><strong>夭</strong>：</p>
<p>​	夭，屈也。</p>
<p>​	甲骨文字形似一个人弯曲双臂摆动的样子。</p>
<p>夭的原义是屈。但是屈过头了，就会折断。由此引申为折、短命，如“夭折”。</p>
<p>夭的字形，好似在跳舞的样子，所以也形容女子美丽姣好，也表示花开茂盛。</p>
<p><strong>州</strong>：<br>
州,水中可居曰州，周绕其旁，从重川。昔尧遭洪水，民居水中高土，或者曰九州。</p>
<pre><code>州，水中陆地。后来大禹将其领域划分为九州，之后九州就泛指天下。
</code></pre>
<p><strong>乡</strong>：<br>
甲骨文似两个人对着盛有食物的器皿，会两人相对而食之意。<br>
原义是两人相对而食。延申泛指用酒食款待别人。</p>
<p><strong>习</strong>：<br>
习，数飞也。<br>
甲骨文为鸟儿在日光下练习飞翔之意。<br>
后引申为反复练习、钻研。</p>
<p><strong>承</strong>：<br>
承，奉也，受也。<br>
甲骨文似一个屈膝的人作授物之形，下有一双手做出接受的样子。<br>
原义是<strong>捧</strong>，也延申为继承，如“汉承秦制”。<br>
承还可以表示顺从、侍奉。如“承欢膝下”。</p>
<p><strong>民</strong>：<br>
民，众萌也。<br>
众人懵懂无知的样子。<br>
金文似以锐物刺左目之形。古时候，俘获敌人则刺瞎其左眼用为奴。所以“民”的原义是奴隶。</p>
<p><strong>卒</strong>：<br>
卒，隶人给事者衣为卒。<br>
原指带有标记的衣服（叉号），也特指穿这种衣服供役使的隶役。也特指士兵。</p>
<p><strong>真</strong>：<br>
甲骨文为人从鼎中取食美味之意。<br>
原义指美食，由美食的原质原味延申为本质、本性。</p>
<p><strong>协</strong>：<br>
协，众之同和也。<br>
甲骨文似三耒并耕之形，会合力耕种之意。</p>
<p><strong>企</strong>：<br>
企，举踵也。<br>
踮起脚尖的意思。如“企盼”，“企鹅”，“企及”</p>
<p><strong>位</strong>：<br>
位，列中庭之左右谓之位。<br>
位，排列在朝廷中的左右位置叫做位。原义是朝廷中群臣排班所处的序列、地方。延申指所处的官职、级别。还特指封建君主的统治地位。“即位” 就是指登上帝位，“在位”就是居于帝王之位。<br>
位也延申指人在某一社会领域中所处的位置或者等级。例如“岗位”、”学位“<br>
位还指抽象的名分、地位。</p>
<p><strong>仔</strong>：<br>
原义是人背子，甲骨文是人背小孩的样子。</p>
<p><strong>保</strong>：<br>
保，养也<br>
甲骨文士大人手臂向后抱一小儿。</p>
<p><strong>儿</strong>；<br>
儿，孺子也。<br>
甲骨文是一个向左站着的大头娃娃，头顶中间是开口的，表示婴儿脑囟骨还没有长在一起。<br>
【原来婴儿出生后颅骨之间结合不紧密，存有空隙，长见识了。】</p>
<p><strong>先</strong>：<br>
先，前进也。<br>
甲骨文像是一个走路的样子。“先”的原义是在前引导，走在前面。</p>
<p><strong>公</strong>：<br>
公，平分也。<br>
甲骨文是平分器皿中的东西之意。<br>
原义是无私，延申为公正。</p>
<p><strong>周</strong>：<br>
周，密也。<br>
“周”是象形字。甲骨文似在玉片上雕刻出纹饰，四点则象征雕刻的图画和花纹有疏密。</p>
<p><strong>友</strong>：<br>
友，同志为友。<br>
甲骨文和金文都是方向相同的两只右手靠在一起的样子，会志同道合地做一件事情之意。</p>
<p><strong>冤</strong>：<br>
冤，屈也。<br>
兔子在覆罩之下不能跑。</p>
<p><strong>危</strong>：<br>
危，在高而惧也。<br>
人站在高处有危险而感到害怕之意。</p>
<p><strong>孝</strong>：<br>
孝，善事父母者<br>
甲骨文似长者长头发的老人，金文似孩子背着老人的样子。</p>
<p><strong>奴</strong>：<br>
“奴”是会意字。金文字形左为“女”，右下为“又”（手）向她抓去，会抓住了人之意。</p>
<p><strong>驳</strong>：<br>
驳，马色不纯。<br>
甲骨文为马身上有交错的花纹之意。<br>
原指马的毛色不纯，延申成混杂、杂乱、庞杂。</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>说文解字</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-量才</title>
    <url>/posts/c7a98fc8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>孙武曰：“主孰有道？”</p>
<p>昔汉王见围荥阳，谓陈平曰：“天下纷纷，何时定乎？“ 平曰：”项王为人恭敬爱人，士之廉节好礼者多归之。至于行功赏爵邑，重之，士亦以此不附。今大王慢人少礼，士之愚钝嗜利无耻者亦多归汉。诚宜各去两短，集其两长，天下指麾即定矣。“</p>
<p>魏太祖谓郭嘉曰：”袁本初地广兵强，吾欲讨之，力不能敌，何如？“ 嘉对曰：”刘，项之不敌，公所知也，汉祖惟智胜。项羽虽强，终为所擒。嘉窃料之，绍有十败，公有十胜，虽兵强，无能为也。绍繁礼多仪，公体任自然。此道胜一也。绍虽兵强，绍以逆动，公奉顺以率天下，此义胜二也。汉末政失于宽，绍以宽济，故不摄；公纠之以猛，而上下，而上下知制，此治胜三也。绍外宽内忌，用人而旋疑之，所任唯亲戚子弟耳；公外简易而内机明，用人无疑，唯才能所宜，不问远近，此度胜四也。绍多计少决，失在事后；公策得辄行，应变无穷，此谋胜五也。绍因累世之资，高议揖让，以收名誉，士之好言饰外者多归之；公至心待人，推诚而行之，不为虚美，以俭率下，与有功者无所吝，士之忠正远见而有实者皆愿为用，此德胜六也。绍见人饥寒，恤念之情形于颜色，其所不见，虑或不及，所谓妇人之仁耳；公于目前小事，时有所忽，至于大事，于四海相接，恩之所加，皆过其望，虽所不见，虑之所周，无不济也，此仁胜七也。绍大臣争权，谗言惑乱；公御下以道，浸润而行，此明胜八也。绍是非不可知；公所是进之以礼，所不是正之以法，以文胜九也。绍好为虚势，不知兵要；公以少克众，用兵如神，军人恃之，敌人畏之，此武胜十也。“ 曹公曰：”吾知之，绍为人志大而智小，色厉而胆薄，忌刻而少威，兵多而分画不明，将骄而政令不一，土地虽广，粮食虽丰，适所以谓吾奉也。“ 杨阜曰：”袁公宽而不断，好谋而少决。不断而无威，少决则后事。今虽强，终为所擒。曹公有雄才远略，决机无疑，法一兵精，必能济大事也。“</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-品目</title>
    <url>/posts/a8d66a27/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>夫天下重器，王者大统，莫不劳聪明于品材，或安逸于任使。故孔子曰：“人有五仪：有庸人，有士人，有君子，有圣，有贤。审此五者，则治道毕矣。”</p>
<p>所谓庸人者，心不存慎终之规，口不吐训格之言，不择贤以托身，不力行以自定，见小暗大而不知所务，从物如流而不知所执。此则庸人也。</p>
<p>所谓士人者，心有所定，计有所守。虽不能尽道术之术，必有率也；虽不能遍百善之美，必有处也。是故智不务多，务审其所知；言不务多，务审其所谓【所谓，言之要也】；行不务多，务审其所由。智既知之，言既得之【得其要也】，行既由之，则若性命形骸之不可易也。富贵不足以益，贫贱不足以损，此则士人也。</p>
<p>所谓君子者，言必忠信而心不忌【忌，怨害也】，仁义在身而色不伐，思虑通明而辞不专，笃行信道，自强不息，油然若将可越而终不及者。此君子也。【孙卿曰：“夫君子能为可贵，不能使人必贵己；能为可信，不能使人必信己；能为可用，不能使人必用己。故君子耻不修，不耻见污；耻不信，不耻不见信；耻不能，不耻不见用。不诱于誉，不怨于诽，率道而行，端然正己，谓之君子也。”】</p>
<p>所谓贤者，德不逾闲【闲，法也】，行中规绳，言足法于天下而不伤于其身【言满天下，无口过也】，道足化于百姓而不伤于本【本亦身也】，富则天下无菀财【菀：积】，施则天下无病贫。此谓贤者也。</p>
<p>所谓圣者，德合天地，变通无方，究万物之终始，协庶品之自然，敷其大道而遂成情性，明立日月，化行若神，下民不知其德，睹者不识其邻。此圣者也。</p>
</blockquote>
<blockquote>
<p>清节之流，不能弘恕，好尚讥诃，分别是非，是谓臧否。子夏之徒是也。法家之流，不能创思图远，而能受一官之任，错意施巧，是为伎俩。张敞、赵广汉是也。术家之流，不能创制垂则，而能遭变用权。权智有余，公正不足，是谓智意。陈平、韩安国是也。能文著述，是谓文章，司马迁、班固是也。能传圣人之业，而不能干事施政，是谓儒学。毛公、贯公是也。辩不入道，而应对给资，是谓口辩。乐毅、曹丘生是也。胆力绝众，才略过人，是谓骁雄。白起、韩信是也。</p>
</blockquote>
<blockquote>
<p>《家语》曰：“昔者明王必尽知天下良士之名，既知其名，又知其实，然后用天下之爵以尊之，则天下理也。”此之谓矣。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-任长</title>
    <url>/posts/4553ed87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>臣闻料才核能，治世之要。自非圣人，谁能兼兹百行，备贯众理乎？故舜合群司，随才授位；汉述功臣，三杰异称。况非此俦，而可备责耶？</p>
</blockquote>
<blockquote>
<p>夫刚略之人，不能理微，故其论大体则弘略而高远，历纤理微则宕往而疏越；亢厉之人，不能回挠，其论法直则括据而公正，说变通则否戾而不入；宽恕之人，不能速捷，论仁义则弘详而长雅，趋时务则迟缓而不及；好奇之人，横逸而求异，造诡谲则倜傥而瑰壮，案清道则诡常而恢迂。</p>
<p>又曰：王化之政，宜于统大，以之理小则迂；策术之政，宜于理难，以之理平则无奇；矫亢之政，宜于治侈，以之治弊则残；公刻之政，宜于纠奸，以之治边则失其众；威猛之政，宜于讨乱，以之治善则暴；伎俩之政，宜于治富，以之治贫则民劳而下困。此已上皆偏材也。</p>
</blockquote>
<blockquote>
<p>魏武诏曰：“进取之士，未必能有行。有行之士，未必能进取。陈平岂笃行，苏秦岂守信耶？而陈平定汉业，苏秦济弱燕者，任其长也。”</p>
<p>由此观之，使韩信下帏，仲舒当戎，于公驰说，陆贾听讼，必无曩时之勋，而显今日之名也。故“任长”之道，不可不察。</p>
</blockquote>
<blockquote>
<p>议曰：魏恒范云：“帝王用人，度世授才。争夺之时，书策为先。分定之后，忠义为首。故晋文行舅犯之计而赏雍季之言，高祖用陈平之智而托后于周勃。” 古语云：“守文之代，德高者位尊；仓促之时，功多者赏厚。”  诸葛亮曰：“老子长于养性，不可以临危难；商鞅长于理法，不可以从教化。苏张长于驰辞，不可以结盟誓；白起长于攻取，不可以广众；子胥长于图敌，不可以谋身；尾生长于守信，不可以应变；王嘉长于遇明君，不可以事暗主；许子将长于明臧否，不可以养人物。”  此任长之术也。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-原序</title>
    <url>/posts/48e2ba4b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>匠臣舆者，忧人不贵；做箭者，恐人不伤。彼其有爱憎哉？实技业驱之然耳。是知当代之士、驰骛之曹，书读纵横，则思诸侯之变；艺长奇正，则念风尘之会。此亦向时之论，必然之理矣。故先师孔子深探其本、忧其末，遂作《春秋》，大乎工道；制《孝经》，美乎德行。防萌杜渐，预有所抑。</p>
<p>斯圣人制作之本意也。</p>
<p>然作法于理，其弊必乱。若至于乱，将焉救之？是以御世理人，罕闻沿袭。三代不同礼，五霸不同法。非其相反，盖以救弊也。是故国容一致，而忠文之道必殊；圣哲同风，而皇王之名或异。岂非随时投教沿乎此，因物成务牵乎彼？沿乎此者，醇薄继于所遭；牵乎彼者，王霸存于所遇。故古之理者，其政有三：王者之政化之；霸者之政威之；强国之政胁之。各有所施，不可易也。管子曰：“圣人能辅时不能违时。智者善谋，不如当时。”邹之曰：“政教文质，所以匡救也。当时则用之，过则舍之。”由此观之，当霸者之朝而行王者之化，则悖矣。当强国之世而行霸者之威，则乖矣。若时逢狙诈，正道陵夷，欲宪章先王，广陈德化，是犹待越客以拯溺，白大人以救火（等待水性好的人来救溺水者，请求尊贵的人来救火）。善则善矣，岂所谓通于时变欤？</p>
<p>夫霸者， 驳道也，盖白黑杂合，不纯用德焉。期于所成，不问所以；论于大体，不守小节。虽称仁引义不及三王，扶颠定倾，其归一揆。恐儒者溺于所闻，不知王霸殊略，故叙以长短术，以经论通变者，并立题目总六十有三篇，合为十卷，名曰《反经》。大旨在乎宁固根蒂，革易时弊，兴亡治乱。</p>
<p>具载诸篇，为沿袭之远图，作经济之至道，非欲矫世夸欲，希声慕名。辄露见闻，逗机来哲。凡厥有位，幸望详焉。</p>
</blockquote>
<p>《反经》是我最喜欢的古文书，这篇序就很先声夺人，不明觉厉。拜服老祖宗的智慧！</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-大体</title>
    <url>/posts/112d874c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>臣闻老子曰：“以正理国，以奇用兵，以无事取天下。”荀卿曰：“人主者，以官人为能者也；匹夫者，以自能为能也。”</p>
</blockquote>
<blockquote>
<p>《人物志》曰：“夫一官之任，以一味协五味；一国之政，以无味协五味。故臣以自任为能；君以能用人为能。臣以能言为能；君以能听为能。臣以能行为能；君以能赏罚为能。所以不同，故能君众能也。”</p>
</blockquote>
<blockquote>
<p>故曰，知人者，王道也；知事者，臣道也；无形者，物之君也；无端者，事之本也。鼓不预五音，而为五音主；有道者，不为五官之事，而为理事之主。君守其道，官知其事，有自来矣。</p>
<p>先王知其如此也，故用非其有如己有之，通乎君道者也。</p>
</blockquote>
<blockquote>
<p>议曰：《淮南子》云：“巧匠为宫室，为圆必以规，为方必以矩，为平直必以准绳。功已就矣，而不知规矩准绳，而赏巧匠。宫室已成，不知巧匠，而皆曰某君某王之宫室也。”</p>
<p>孙卿曰：“夫人主故欲得善射中微，则莫若使羿；欲得善御致远，则莫若使王良；欲得调一天下，则莫若聪明君子矣。其用智甚简，其为事不劳，而功名甚大。”此能用其非其有如已有者也。</p>
</blockquote>
<blockquote>
<p>人主不通主道者则不然。自为之则不能任贤，不能任贤，则贤者恶之，此功名之所以伤，国家之所以危。</p>
</blockquote>
<blockquote>
<p>议曰：“《申之》云：君知其道也，臣知其事也。十言十当，百言百当者，人臣之事也，非人君之道也。”《尸子》云：“人臣者，以进贤为功也；君者，以用贤为功也。”</p>
</blockquote>
<blockquote>
<p>汤武一日而尽有夏商之财，以其地封，而天下莫敢不悦服；以其财赏，而天下皆竞劝，通乎用非其有也。</p>
</blockquote>
<blockquote>
<p>议曰：孙卿曰：“修礼者王，为政者强，取人者安，聚敛者亡。故王者富人；霸者富士；仅存之国富大夫；亡国者富筐箧、实府库。是谓上溢下漏。” 又曰：“天子不言多少，诸侯不言利害，大夫不言得失。”</p>
</blockquote>
<blockquote>
<p>魏文侯御廪灾，素服避正殿，群臣皆哭。公子成夫趋入贺曰：“臣闻天子藏于四海；诸侯藏于境内。非其所藏，必有火灾，必有人患。幸无人患，不亦善乎。”  孔子曰：“百姓足，君孰与不足？” 由此言之，夫圣王以其地封，以其财赏，不与人争利，乃能通于主道，是用非其有者也。</p>
</blockquote>
<blockquote>
<p>故称，设官分职，君之体也；委任责成，君之体也；好谋无倦，君之体也；宽以得众，君之体也；含垢藏疾，君之体也。君有君人之体，其臣畏而爱之，此帝王所以成业也。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>win10快捷键</title>
    <url>/posts/26dc69f9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>win10快捷键</p>
<span id="more"></span>
<h1>虚拟桌面</h1>
<p>win + ctrl+ D：<strong>创建虚拟桌面</strong><br>
win + ctrl + 左右箭头：<strong>切换虚拟桌面</strong><br>
win + ctrl + F4: <strong>关闭当前虚拟桌面</strong></p>
<h1>应用管理</h1>
<p>win + M: <strong>最小化所有应用</strong><br>
ctrl + alt + tab(或win + tab) : <strong>显示所有打开应用</strong><br>
win + 1-9: 快速打开应用</p>
<h1>当电脑卡死时</h1>
<p>ctrl + shift + esc: <strong>打开任务管理器</strong>（关闭卡死的程序，<strong>实用</strong>）<br>
ctrl + alt + delete: windows救命三键<br>
win + r 后输入[ shutdown -r ]重启 或 [ shutdown -s ] 关机</p>
<h1>打开文件夹</h1>
<p>win + E: 资源管理器</p>
<p>shift + delete : 永久删除文件</p>
<h1>锁屏</h1>
<p>win + l</p>
<h1>查看剪贴板</h1>
<p>win + v</p>
<h1>网页/应用字体缩放</h1>
<p>一般都是 ctrl + 滑轮</p>
<h1>分屏</h1>
<p>win + 左箭头/右箭头</p>
]]></content>
      <tags>
        <tag>软件学习</tag>
      </tags>
  </entry>
  <entry>
    <title>notpad++学习笔记</title>
    <url>/posts/897384da/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>notpad++是一款功能强大的文本编辑器。我一开始用的就是这个软件，感觉基本能满足我的所有需求。这款编辑器唯一的缺点就是作者脑残，但我就是用得过于顺手了，加上没有找到更好用的文本编辑器，就还是在用这个。</p>
<span id="more"></span>
<h1>快捷键</h1>
<h2 id="常规快捷键">常规快捷键</h2>
<ul>
<li>ctrl + Z  &amp; ctrl + Y ** 撤销与恢复**</li>
<li>ctrl + F  &amp; ctrl + H <strong>查找与替换</strong></li>
<li>ctrl + D 复制并黏贴当行（光标所在行）</li>
<li>ctrl + D 复制并快速黏贴多行（光标选中多行）</li>
<li>ctrl + L 删除当前行</li>
<li>shift + tab 删除缩进</li>
<li>ctrl + G <strong>快速跳到某一行</strong></li>
<li>ctrl + tab 多个文件中切换（与谷歌一致）</li>
</ul>
<h2 id="文件操作快捷键">文件操作快捷键</h2>
<ul>
<li>ctrl + S 保存当前文档</li>
<li>ctrl + alt + S 另存为</li>
<li>ctrl + shift + S <strong>保存所有文件</strong></li>
<li>ctrl + w 关闭当前</li>
<li>ctrl + p 打印（转为pdf）</li>
</ul>
<h2 id="文本编辑">文本编辑</h2>
<ul>
<li>Alt + C <strong>列编辑</strong>模式（在某一列插入相同的文字或数字）</li>
<li>ctrl + k <strong>注释</strong>（可选中多行，而且notpad++会根据文件类型添加相符合的注释符号）</li>
<li>ctrl + shift + k 取消注释</li>
</ul>
<h2 id="其他快捷键">其他快捷键</h2>
<ul>
<li><strong>块匹配</strong>：选择一个括号，按ctrl+b会跳转到与它对应的另外一半括号处。</li>
</ul>
<h1>其他功能</h1>
<h2 id="颜色标记">颜色标记</h2>
<p>就是给内容用不同的颜色做标记，用法就是选择要标记的文本然后点击右键-&gt;Style token，选择一个标记即可。也可以通过点击右键选择删除颜色标记Remove style。</p>
<h2 id="将tab转换成空格">将tab转换成空格</h2>
<blockquote>
<p>编程中一般都不允许使用Tab键作为缩进而是使用空格，但是Tab键确实方便。<br>
在首选项-&gt;语 言页面可以选择“以空格代替Tab”，同时可以配置一个Tab键替换成几个空格。</p>
</blockquote>
<h2 id="显示符号">显示符号</h2>
<p>在视图-显示符号中，可以显示空格、制表键、换行等。空格显示为**.<strong>，制表键显示为向右的箭头。linux格式的换行符显示为LF，windows格式的换行符显示为</strong>CRLF**。</p>
<h2 id="备份">备份</h2>
<p>这个比较实用。在设置-首选项-备份-备份与自动完成，选择<strong>简单备份</strong>。这样notpad++在编辑一个文件，会默认生成一个同名的<strong>bak</strong>文件。</p>
<h2 id="插件">插件</h2>
<p>notpad++有很多相应的插件，比如一款TextFX的插件，可以删除文件中的空行、插入行号或删除行号等。</p>
<h1>tips</h1>
<ul>
<li>notpad++通过后缀名判断文件类型，并实现<strong>代码高亮</strong>。如果文件无后缀，那么也无法实现自动代码高亮。可通过设置<strong>语言</strong>选项，实现未知类型文件的语法高亮。</li>
<li>通过<strong>格式</strong>选项，可查看和转换当前文件字符编码。</li>
<li>在其他地方修改文件后，notpad++会自动更新文件，并通知<strong>此文件已被其他程序修改了，是否重新加载</strong>。在首选项-其他中，勾选<strong>自动更新文件</strong>，关闭该通知。</li>
</ul>
<h1>参考网页</h1>
<p><a href="http://shouce.jb51.net/notepad_book/">http://shouce.jb51.net/notepad_book/</a><br>
<a href="https://blog.51cto.com/caochun/1530273">https://blog.51cto.com/caochun/1530273</a></p>
]]></content>
      <tags>
        <tag>软件学习</tag>
      </tags>
  </entry>
  <entry>
    <title>谷歌浏览器常用快捷键</title>
    <url>/posts/31e31a23/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>官方网址 [Chrome 键盘快捷键]（<a href="https://support.google.com/chrome/answer/157179?hl=zh-Hans%EF%BC%89">https://support.google.com/chrome/answer/157179?hl=zh-Hans）</a></p>
<span id="more"></span>
<h2 id="标签页和宽口快捷键">标签页和宽口快捷键</h2>
<ul>
<li>ctrl+n  打开新窗口</li>
<li>ctrl+t  打开新的标签页</li>
<li>ctrl+tab 跳到下一个标签页</li>
<li>ctrl+w 关闭当前标签页（等于鼠标中键点击标签页）</li>
<li>ctrl+shift+w 关闭当前窗口</li>
</ul>
<h2 id="功能快捷键">功能快捷键</h2>
<ul>
<li>ctrl+shift+o 打开书签</li>
<li>ctrl+h 历史</li>
<li>ctrl+j 下载</li>
<li>F5 刷新</li>
<li>F11 全屏（如看文献时）</li>
</ul>
<h2 id="地址栏快捷键">地址栏快捷键</h2>
<ul>
<li>ctrl+l 跳到地址栏</li>
<li>ctrl+enter <a href="http://xn--www-c88dx8l94buznxdx09to89cnbjl99b.xn--0tr.com">为输入地址默认添加www.和.com</a></li>
</ul>
<h2 id="网页快捷键">网页快捷键</h2>
<p>ctrl+d 将当前页面保存为书签<br>
ctrl+p 打印当前页面（可以将当前页面保存为pdf）<br>
ctrl+u 显示html源代码</p>
]]></content>
      <tags>
        <tag>软件学习</tag>
      </tags>
  </entry>
  <entry>
    <title>一份（不太）简短的LaTex介绍学习笔记</title>
    <url>/posts/9ab4ff8e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本书的别名叫做106分钟了解LaTeX，但是要看完根本不止106分钟，更别说理解了。暂时先看到第四章。</p>
<span id="more"></span>
<h1>第一章 LaTeX 须知</h1>
<h3 id="Tex">Tex</h3>
<blockquote>
<p>TEX是高德纳(Donald E.Knuth)开发的、以排版文字和数学公式为目的的一个计算机软件。高德纳从1977年开始开发TEX，以发掘当时开始用于出版工业的数字印刷设备的潜力。正在编写著作《计算机程序设计艺术》的高德纳，意图扭转排版质量每况愈下的状况，以免影响他的出书。TEX排版引擎发布于1982年，在1989年又加以改进以更好地支持8-bit字符和多语言排版。TEX以其卓越的稳定性、跨平台、几乎没有Bug而著称。TEX的版本号不断趋近于π，当前为3.141592653</p>
</blockquote>
<h3 id="LaTex">LaTex</h3>
<blockquote>
<p>LATEX为TEX基础上的一套格式，令作者能够使用预定义的专业格式以较高质量排版和印刷他们的作品。LATEX的最初开发者为Leslie Lamport博士。LATEX使用TEX程序作为自己的排版引擎。当前LATEX由LATEX3工作组1维护。</p>
</blockquote>
<h3 id="引擎、格式和编译命令">引擎、格式和编译命令</h3>
<ul>
<li><strong>引擎</strong>     是编译源代码并生成文档的程序，如pdfTeX，XeTeX等。有时也称为编译器。</li>
<li><strong>格式</strong>    是定义了一组命令的代码集，最广泛应用的一个格式就是latex，另外，还有一个简版的plain tex</li>
<li><strong>编译命令</strong> 是实际调用的，结合了引擎和格式的命令，如xelatex和pdflatex。</li>
</ul>
<h3 id="latex用到的文件">latex用到的文件</h3>
<ul>
<li><strong>.sty</strong> 宏包文件</li>
<li><strong>.cls</strong> 文档类文件</li>
<li><strong>.bib</strong> 参考文献数据库文件</li>
<li><strong>.bst</strong> 参考文献格式模板</li>
</ul>
<h3 id="latex编译中生成的文件">latex编译中生成的文件</h3>
<ul>
<li><strong>.log</strong> 日志</li>
<li><strong>.aux</strong> 主辅助文件，记录交叉引用、目录和参考文献的引用等。</li>
<li><strong>.toc</strong> 目录记录文件</li>
<li><strong>.lof</strong> 图片目录记录文件</li>
<li><strong>.lotLATEX</strong> 生成的表格目录记录文件。</li>
<li>.bbl  BIBTEX生成的参考文献记录文件。</li>
<li>.blg  BIBTEX生成的日志文件。</li>
<li>.idx  LATEX生成的供makeindex处理的索引记录文件。</li>
<li>.ind  makeindex 处理.idx生成的用于排版的格式化索引文件。</li>
<li>.ilg  makeindex生成的日志文件。</li>
<li>.out  hyperref宏包生成的PDF书签记录文件。</li>
</ul>
<h3 id="include-与-input">\include 与 \input</h3>
<ul>
<li>\include{ <em>filename</em> }  插入其他文件（不在同一目录需加路径），<strong>会另起一页</strong>。</li>
<li>\input{ <em>filename</em>} 一样，但是不会另起一页。</li>
</ul>
<h1>用LaTeX 排版文字</h1>
<p>作者对排版中文文档的建议是，使用ctex文档类型、源代码保存为<strong>UTF-8</strong>编码、编译时使用<strong>xelatex</strong>命令</p>
<h3 id="字符编码">字符编码</h3>
<p>latex命令和pdflatex命令下，可以使用<strong>inputenc</strong>宏包支持UTF-8编码：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>[utf8]&#123;inputenc&#125;</span><br></pre></td></tr></table></figure>
<p>xelatex和lualatex命令原生支持UTF-8编码。</p>
<h3 id="排版中文">排版中文</h3>
<p>ctex 文档包括ctexart 、ctexrep、ctexbook，是目前最新的排版中文的方式（老的我不太想知道了）。</p>
<h3 id="空格">空格</h3>
<ul>
<li>多个连续空格或tab键均视为一个空格。</li>
<li>每行开头的空格忽略不计、</li>
<li><strong>行末的回车</strong>视为一个空格</li>
</ul>
<h3 id="分段">分段</h3>
<ul>
<li>连续<strong>两个回车</strong>，也就是空一行，会分段。</li>
<li>多个空行仍视为一个空行</li>
<li><strong>\par</strong>命名分段</li>
</ul>
<h3 id="注释">注释</h3>
<ul>
<li><strong>%</strong></li>
</ul>
<h3 id="特殊字符">特殊字符</h3>
<p>以下字符具有特殊用途，如需直接输入这些字符，需使用 *<em>*</em> 转义<br>
# $ % &amp; { } _ ^ ~ \</p>
<p>注： \为手动换行，因此输入反斜线为**\textbackslash**</p>
<h3 id="标点符号">标点符号</h3>
<ul>
<li>中文标点符号直接输入即可</li>
<li>英文双引号输入<strong>两个单引号</strong></li>
<li>连字符
<ul>
<li>单个连字符**-**就是自身</li>
<li>两个连字符**–**连接数字表示范围</li>
<li>三个连字符**—**作为破折号—使用</li>
</ul>
</li>
<li>省略号 <strong>\ldots</strong> 和 <strong>\dots</strong> 表示输入三个点。</li>
<li>波浪号 <strong>-</strong> <strong>\sim</strong></li>
</ul>
<h3 id="文字强调">文字强调</h3>
<ul>
<li>\underline{} 下划线</li>
<li>\emph{}        斜体</li>
</ul>
<h3 id="断行">断行</h3>
<ul>
<li><strong>\</strong> 进行断行。</li>
<li>用**-**插入不会断行的空格（高德纳称之为tie），常用于英文人名、图表名称等。</li>
</ul>
<h3 id="断页">断页</h3>
<ul>
<li><strong>\newpage</strong>  <strong>\clearpage</strong></li>
</ul>
<h1>文档元素</h1>
<h3 id="章节题目">章节题目</h3>
<ul>
<li>\chapter{} <strong>只在 book 和 report 文档类有定义</strong></li>
<li>\section{}  \subsection{} \subsubsection{} \paragraph{} \subparagraph{}</li>
<li>命令变体
<ul>
<li>带可选参数的变体：\section[short title]{title}<br>
标题使用title 参数，在目录和页眉页脚中使用short title参数</li>
<li>带星号的变体：\section*{title}<br>
标题不带编号，也不生成目录项和页眉页脚</li>
</ul>
</li>
<li>article 文档类<strong>带编号</strong>的层级为 \section \subsection \subsubsection 三项</li>
<li>report/book 文档类<strong>带编号</strong>的层级为 \chapter \section \subsection</li>
</ul>
<h3 id="目录">目录</h3>
<ul>
<li>使用命令**\tableofcontents** 生成目录</li>
<li>正确生成目录，一般需要编译两次源代码</li>
</ul>
<h3 id="标题页">标题页</h3>
<p>latex 支持生成简单的标题页。首先需要给定标题和作者等信息：前两个命令必需，date命令可选。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\title</span>&#123;⟨title⟩&#125;   <span class="keyword">\author</span>&#123;⟨author⟩&#125;   <span class="keyword">\date</span>&#123;⟨date⟩&#125;</span><br></pre></td></tr></table></figure>
<p>之后就可以使用 \maketitle 生成一个简单的标题页了。<br>
article 文档类的标题默认不单独成页。</p>
<h3 id="交叉引用">交叉引用</h3>
<p>在能够被交叉引用的地方，如章节、公式、图表、定理等位置使用\label命令：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\label</span>&#123;⟨label-name⟩&#125;</span><br></pre></td></tr></table></figure>
<p>之后，可以在别处使用\ref和\pageref命令，分别生成交叉引用的编号和页码：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\ref</span>&#123;⟨label-name⟩&#125;   <span class="keyword">\pageref</span>&#123;⟨label-name⟩&#125;</span><br></pre></td></tr></table></figure>
<p>为了生成正确的交叉引用，一般需要<strong>多次编译源代码</strong>。<br>
对于使用不记编号的命令形式（\section*,\caption），<strong>不要使用\label命令</strong>，否则生成的引用编号不正确。</p>
<h3 id="脚注">脚注</h3>
<p>脚注就是在页脚的位置写上注释，一般使用\footnote命令。</p>
<h1>特殊环境</h1>
<h2 id="列表">列表</h2>
<h3 id="有序列表">有序列表</h3>
<p>基本命令是enumerate。item中包含一个可选参数，将列表符号改成自定义的符号，如\item[*]。<br>
列表可以嵌套使用，最多嵌套四层。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;</span><br><span class="line">	<span class="keyword">\item</span>. . .</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无序列表">无序列表</h3>
<p>无序列表的基本命令为itemize，格式同上。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line">	<span class="keyword">\item</span>. . .</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对齐环境">对齐环境</h2>
<p>文本对齐方式可用以下命令分别生成居中、左对齐和右对齐的文本环境。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;center&#125;. . .<span class="keyword">\end</span>&#123;center&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;flushleft&#125;. . .<span class="keyword">\end</span>&#123;flushleft&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;flushright&#125;. . .<span class="keyword">\end</span>&#123;flushright&#125;</span><br></pre></td></tr></table></figure>
<p>另外，如果只改变一句文本的对齐方式，可直接使用以下命令</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\centering</span>   <span class="keyword">\raggedright</span>   <span class="keyword">\raggedleft</span></span><br></pre></td></tr></table></figure>
<h2 id="引用环境">引用环境</h2>
<ul>
<li><strong>quote</strong>环境用于引用较短的文字，首行不缩进。</li>
<li><strong>quotation</strong>环境用于引用若干段文字，首行缩进。</li>
<li>不论是quote或quotation,引用环境相较于一般文字均有额外的左右缩进。</li>
</ul>
<h2 id="代码环境">代码环境</h2>
<p>有时我们需要将一段代码原样输出，这时需用到代码环境verbatim。</p>
<ul>
<li>verbatim* 环境会将空格显示为␣</li>
<li>只排版一行代码，可使用\verb命令，delim表明代码的边界，习惯使用|符号。</li>
</ul>
 <figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\verb</span>⟨<span class="string">delim⟩</span>⟨code⟩⟨delim⟩</span><br></pre></td></tr></table></figure>
<h2 id="表格环境">表格环境</h2>
<p>latex直接排版表格感觉比较复杂，不是很实用。大量的表格排版还是需要R语言相应的函数包的支持。<br>
最基本的tabular环境用法如下，其中⟨column-spec⟩是列格式标记（通常使用|c|表示居中）；&amp;用来分隔单元格；\用来换行；\hline用来在行与行之间绘制横线。<br>
注意：表格中每行的单元格数目不能多于列格式里l/c/r(左/居中/右对齐)的总数（可以少于这个总数）。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tablular&#125;&#123;&lt;column-spec&gt;&#125;</span><br><span class="line">&lt;item1&gt; <span class="built_in">&amp;</span> &lt;item2&gt; <span class="built_in">&amp;</span> ... <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span> </span><br><span class="line">&lt;item1&gt; <span class="built_in">&amp;</span> &lt;item2&gt; <span class="built_in">&amp;</span> ... <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图片">图片</h2>
<p>LaTex本身不支持插图功能，需要调用graphicx宏包辅助支持。<br>
各种编译方式支持的图片格式如下图（xelatex最好）<br>
<img src="graphicx.png" alt=""><br>
在调用了graphicx宏包后，就可以使用以下命令加载图片了。其中filename为文件名，不在同一路径时，需使用相对路径或绝对路径。可选参数如下图。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\includegraphics</span>[⟨options⟩]&#123;⟨filename⟩&#125;</span><br></pre></td></tr></table></figure>
<p><img src="includegraphics.png" alt=""></p>
<h1>排版数学公式</h1>
]]></content>
      <tags>
        <tag>LaTex</tag>
      </tags>
  </entry>
  <entry>
    <title>鸟叔的linux私房菜学习笔记</title>
    <url>/posts/e552a718/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>个人感觉，鸟叔讲得很细，但是这本书很难坚持看下去，本人都是挑着看的。</p>
<span id="more"></span>
<h1>第零章、计算机概论</h1>
<p>中央处理器（Central Processing Unit,cpu ）,主要工作是<strong>管理</strong>和<strong>运算</strong>，cpu读取的所有数据均来自于内存，处理后的数据也必须先写回内存。<br>
cpu 32位与64位：内存每次传给CPU的数据量，32bit 还是 64bit。所以说64位比32位，内存传给CPU的数据量翻了一倍。<br>
<strong>双通道</strong>：一条总线的带宽是64位，那么两个就是128位，所以双内存更快。最好两个内存的型号都完全一致。有的主板四条内存插槽的颜色不一样，需要两根容量相同的内存插在相同颜色的插槽当中，才能启用双通道。<br>
<strong>CPU第二层高速缓存内存</strong>：对于一些很常用的程序或数据可以放置在CPU内部，那么CPU就不用去内存读取数据了，这就是CPU第二层高速缓存的设计概念。</p>
<h3 id="字符编码">字符编码</h3>
<p>鸟叔的这张图相当形象了。<br>
<img src="encoding.png" alt=""></p>
<h3 id="机器语言与高阶程序语言">机器语言与高阶程序语言</h3>
<p><img src="bianyi.png" alt=""></p>
<h1>linux是什么与如何学习</h1>
<blockquote>
<p>鸟哥上课时，常常有学生问到：“老师，到底要听过你的课几次之后，才能学的会？”鸟 哥的标准答案是：“你永远学不会！”。<strong>因为你是用“听”的，没有动手做</strong>，那么永远不会知道“经 验”两个字怎么写!<br>
windows救命三键（Ctrl+Alt+Delete）</p>
</blockquote>
<h1>首次登录</h1>
<ul>
<li>shell中通过<strong>空格</strong>来区分命令，但是多个空格仍只会视为一个空格。</li>
<li><strong>tab</strong>：一次tab键<strong>命令补全</strong>，两次tab显示所有以输入字符开头的命令</li>
<li>ctrl+c：结束正在运行的命令</li>
<li><strong>ctrl+d</strong>：直接离开命令行（相当于exit)</li>
<li>shift+pageUp/pageDown：返回上次命令输出结果（相当于用鼠标滑轮）。</li>
</ul>
<h3 id="帮助文档">帮助文档</h3>
<ul>
<li>date <strong>–help</strong>: 简短说明</li>
<li><strong>man</strong> date: 详细说明。输入**/string**，向下搜寻string这个字符串。输入**?string**，向上搜索。</li>
</ul>
<h3 id="文件权限">文件权限</h3>
<ul>
<li>r(read) : 可读取此文件的内容</li>
<li>w(write): 可以修改文件内容（但不能删除该文件）</li>
<li>x(execute): 可以被系统执行</li>
</ul>
<h3 id="目录权限">目录权限</h3>
<ul>
<li>
<p>r(read) : 可读取该目录结构，即查询该目录下的文件名数据，可以使用ls命令。</p>
</li>
<li>
<p><strong>w(write)</strong>：可执行操作如下</p>
<ul>
<li>创建新的文件和目录</li>
<li><strong>删除</strong>已存在的文件或目录</li>
<li>将已存在的文件或目录进行更名</li>
<li>移动该目录下的文件、目录位置</li>
</ul>
</li>
<li>
<p>x(execute): 能否进入该目录，使之成为工作目录<br>
目录当然没有所谓的<strong>执行</strong>能力，这里的执行权限是指能不能直接进入该目录，用命令来说，就是能不能cd到该目录。<strong>如果不给x权限，w权限也没办法实现</strong></p>
</li>
</ul>
<h3 id="权限管理总结">权限管理总结</h3>
<p>需要给别人浏览的文件，<strong>目录</strong>需要提供<strong>r</strong>和<strong>x</strong>权限，<strong>文件</strong>需提供<strong>r</strong>权限。<strong>w</strong>权限需谨慎开放。</p>
<h1>Linux文件与目录管理</h1>
<h2 id="环境变量">环境变量</h2>
<p>通过<strong>echo $PATH</strong> 查看环境变量。设置环境变量的作用：运行程序时不用加路径，比如直接写plink，而不用写./plink。</p>
<ul>
<li>所有用户在PATH变量中都有/bin 或 /usr/bin 这个目录。这两个目录是一样的，因为/bin 是 /usr/bin的链接。</li>
<li>环境变量有<strong>顺序</strong>的区别，系统会按照顺序依次查找各个文件夹</li>
<li>添加环境目录
<ul>
<li>把当前的目录放入环境变量中。参考以下网页<a href="https://blog.csdn.net/yi412/article/details/11523525">linux 环境变量设置（临时 + 永久）</a>。</li>
<li>将程序或链接放在已在环境变量的目录中。个人常用，感觉更简单。</li>
</ul>
</li>
</ul>
<h2 id="查找文件">查找文件</h2>
<ul>
<li><strong>which</strong> 在PATH变量中搜索，并返回第一个搜索结果。 -a 列出所有结果</li>
<li><strong>whereis</strong> 只在特定的几个目录查找文件，感觉不实用。可以通过whereis -l 查看whereis查看的目录名称。</li>
<li><strong>locate</strong> 在数据库中查找，速度很快。但是数据库每天更新一次，因此最新创建的文件可能找不到，需要更新数据库（使用命令updatedb，需要root权限）。</li>
<li><strong>find</strong> 直接查找硬盘，速度慢。最后指定查找目录，缩小查找范围。</li>
</ul>
<h1>vim编辑器</h1>
<p>基本上 vi/vim 共分为三种模式，分别是一般模式或命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。但其实底线命令模式也是在一般模式下输入的。</p>
<h2 id="一般模式（命令模式）">一般模式（命令模式）</h2>
<ul>
<li><strong>/word</strong> <strong>向下</strong>寻找word（?word，向上）；通过<strong>n/N</strong>切换下（上）一个</li>
<li>:n1,n2s/word1/word2/g  从n1行到n2行查找word1,并替换为word2</li>
<li>1,$s/word1/word2/g   从第一行到最后一行查找替换</li>
</ul>
<h2 id="一般指令模式切换到编辑模式的可用的按钮说明">一般指令模式切换到编辑模式的可用的按钮说明</h2>
<ul>
<li>:wq</li>
<li>:wq! 强制写入</li>
<li>:w [filename] 另存为</li>
<li>set nu/nonu  显示/不显示行号</li>
</ul>
<h1>认识和学习BASH</h1>
<h2 id="万用字符（wildcard）">万用字符（wildcard）</h2>
<p>bash 支持万用字符（和正则表达式有区别），如用在ls命令中。<br>
<img src="wildcard.png" alt=""></p>
<h2 id="数据流重导向">数据流重导向</h2>
<p>standard output（标准输出）和 standard error output （标准错误输出）<strong>默认打印在屏幕上</strong>。</p>
<ul>
<li>标准输入，输出，错误输出代码分别为0，1，2。</li>
<li>
<blockquote>
<blockquote>
<p>追加，当文件不存在时主动创建，存在时追加。</p>
</blockquote>
</blockquote>
</li>
</ul>
<p><img src="standard.png" alt=""></p>
<h2 id="与">&amp;&amp; 与 ||</h2>
<p><img src="&amp;&amp;.png" alt=""></p>
<h2 id="管道命令">管道命令</h2>
<p>管道命令仅会处理standard output，对于 standard error output 会予以忽略。<br>
<img src="pipe.png" alt=""></p>
<h1>shell 编程</h1>
<p>shell 编程主要是用在<strong>系统管理</strong>上，不适合复杂的数据处理。</p>
<ul>
<li>多个空格视为一个空格</li>
<li>赋值（=）前后不能有空格</li>
<li>第一行必须为**/#!/bin/bash**，表明这个文件内的语法使用bash的语法</li>
<li>运行shell程序
<ul>
<li>直接运行（首先具有rx权限）
<ul>
<li>绝对路径：/home/dmtsai/shell.sh</li>
<li>相对路径：./shell.sh</li>
<li>PATH路径中：<a href="http://shell.sh">shell.sh</a></li>
</ul>
</li>
<li>以bash程序来执行（不需要权限，更方便）
<ul>
<li>bash <a href="http://shell.sh">shell.sh</a> 或 sh <a href="http://shell.sh">shell.sh</a></li>
</ul>
</li>
</ul>
</li>
<li>运行shell程序其实是在<strong>子程序</strong>的bash内执行的。（通过sourse命令在父程序中直接运行）<br>
<img src="sh.png" alt=""></li>
</ul>
<h1>账号管理</h1>
<h2 id="切换账号">切换账号</h2>
<ul>
<li>su - 切换为root账号</li>
<li>su zhouzw 切换为普通账号</li>
</ul>
<h1>程序管理</h1>
<h2 id="工作管理（job-control）">工作管理（job control）</h2>
<p>通过<strong>jobs -l</strong> 可以查看使用&amp;放入后台的程序的PID，然后就可以用kill命令杀掉后台程序。kill命令一般不建议使用-9选项强制关闭。</p>
]]></content>
      <tags>
        <tag>软件学习</tag>
      </tags>
  </entry>
  <entry>
    <title>word排版学习笔记</title>
    <url>/posts/821c2099/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>之前用word里包含十几个表，排版简直要吐血！而且更变态的是，不知道为什么，你调整其中的一个表，其他的表的格式却莫名其妙地乱了（一脸懵逼）。更让我难以接受的是，有的时候word报错其中一个表格已损坏，然后如果你没有备份的话，就一夜回到解放前。<br>
以上种种，让我已经坚定了要抛弃word的想法，用latex和markdown替代它。不过最近还是在B站看到了word排版的学习视频，那还是学一下吧！<br>
本文学习视频来自于<a href="https://www.bilibili.com/video/av64031582">word论文排版技巧</a></p>
<span id="more"></span>
<h1>快速设置三线表</h1>
<p>在一个表格内选择，在表格工具设计工具栏新建<strong>样式</strong>。修改样式名称，在格式应用于<strong>整个表格</strong>，修改右下角<strong>格式</strong>的边框属性、字体、<strong>边框和底纹</strong>（上下框线）。之后，将格式应用于<strong>标题行</strong>，修改<strong>格式</strong>的边框和底纹（下框线，上框线需要重新设置）。</p>
<ul>
<li>使用时，选中表格，点击该样式</li>
<li>右击该样式，可将该设置为默认，<strong>实用</strong>（这样把表格复制过来就是三线表）。</li>
<li>还需要手动调节表格工具-布局-对齐方式（<strong>文字居中</strong>），或<strong>自动调整</strong><br>
<img src="yangshi.png" alt=""></li>
</ul>
<h1>样式的概念</h1>
<blockquote>
<p>开始工具栏中右键<strong>样式</strong>-修改，可修改所有应用该样式的文本。<br>
另一种快捷方式是，修改某一个应用该样式的文本，右击样式，更新 ** 以匹配所选内容</p>
</blockquote>
<h1>标题的自动编号</h1>
<p>自动编号的好处是如果后面需要增删章节，不用手动修改。</p>
<ul>
<li>先写好文章标题和内容，标题不要写前缀，第一章或1.1什么的。点击段落中的多级列表（默认为1级，可点击<strong>更改列表级别</strong>）。然后右击样式，更新 ** 以匹配所选内容</li>
<li>修改编号：点击<strong>定义新的多级列表</strong> ，可以在输入编号的格式中添加文字，此级别的编号样式可以选择简体中文。<br>
<img src="many_list.png" alt=""></li>
</ul>
<h1>正文样式</h1>
<p>直接修改正文样式可能会导致标题等样式的改变，右击标题样式-修改，发现样式基础是正文。<br>
作者给出的解决方法是新建一个样式，命名为<strong>0_正文</strong>，将所有的正文在这里进行修改。</p>
<ul>
<li>行距最好使用倍数，而尽量不用多少磅，不然图片显示可能出问题。</li>
</ul>
<h1>图名、表明的设置与引用 7P</h1>
<p>比较复杂，放弃写了。打算自己以后直接看视频，这还比较简单。见谅。</p>
<h1>分页符与分节符 8P</h1>
<p>分页符，固定分页，比如下一章<br>
分节符，使不同节的<strong>页眉</strong>可以不一致。</p>
<h1>目录 9P</h1>
<h1>页眉与页脚的设置 10P</h1>
<h1>公式的编号与引用</h1>
<p>mathtype 插件</p>
<h1>参考文献-NE</h1>
<ul>
<li>插入多篇文献：在NE中使用shift或ctrl选中多篇文献</li>
<li>修改后更新编号：点击格式化</li>
<li>清除域代码前备份一份。<strong>必须保留一份含有域代码的文件</strong>，清除域代码的文件仅作为上交材料。</li>
</ul>
]]></content>
      <tags>
        <tag>软件学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel学习笔记</title>
    <url>/posts/438c10d4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>个人对Excel的态度经历过几次转变。研究生入学前后学了点excel的一些高级函数（vlookup啥的），录制点宏啥的，感觉excel还是蛮方便的。等到自己实际处理数据时，发现只要数据破万，excel做起来就很慢，右下角显示%4、%5，慢慢等待，也干不了别的，甚至有的时候显示未响应，又得重头来，这时候就可能在心里默默地喊一句excel垃圾。之后学了些python啥的，就开始逐渐抛弃excel了，基本不用excel做任何复杂处理，主要就是显示数据。现在逐渐感觉，每种语言或工具还是有它的独到之处，没有什么最优秀之说，只有适不适合。当数据量小，而且只做一些比较简单的处理或分析时，excel依然是最快的。<br>
本部分均是学习刘伟老师的Excel的系列课程，本文是根据本人的知识情况进行整理，详细可前往B站或其他网站观看视频课程。</p>
<span id="more"></span>
<h1>Excel 2016基础</h1>
<p>这里我个人觉得比较简单，就提取了一些之前不知道的点。</p>
<h2 id="快捷键">快捷键</h2>
<ul>
<li>ctrl+滑轮     改变excel显示比例。发现这个同样适用浏览器和其他软件</li>
<li>ctrl+enter  区域填充。先选中要填充的区域，在第一个单元格输入公式或数据后，按此快捷键。</li>
<li>alt+enter   单元格内换行</li>
<li>ctrl+A        选中区域。鼠标放在某个数据区域内，一次ctrl+A选中区域，两次ctrl+A选中工作表。</li>
<li>ctrl+G        定位快捷键。</li>
</ul>
<h2 id="其他快捷操作">其他快捷操作</h2>
<ul>
<li>
<p><strong>快速填充</strong> 。第一个单元格输入值后填充，右下选择快速填充，excel会比较<strong>智能</strong>地根据第一个单元格的形式填充。如下图所示，点击快速填充后即可提取个体号中的场代码。</p>
<p>利用快捷键更简单，在第二列输入第一个值以后，按 <strong>ctrl+E</strong> 即可快速填充。</p>
</li>
</ul>
<p><img src="quick_tianchong.png" alt=""></p>
<ul>
<li>
<p>公式迅速转为数值：鼠标<strong>右键</strong>该列右边框，向右边移动一列，再移回来，在弹出的对话框里显示仅复制数值。</p>
</li>
<li>
<p>对区域进行自动求和，选中包括数据和预计求和空白区域的区域，点击开始菜单栏的自动求和，即可看见空白区域为每行每列的和。有点绕，见下图<br>
<img src="area_sum.png" alt=""></p>
</li>
</ul>
<h2 id="小知识">小知识</h2>
<ul>
<li>excel显示的值与真实值可以不一样，但是实际运算是按照真实值计算的。
<ul>
<li>例如对数字1.23456，选择单元格形式为数值（小数点保留2位），可以看到单元格已经显示为1.23，但是你点击该单元格，上方的编辑栏依然显示为1.23456</li>
<li>只有使用ROUND函数，才是真正改变了数值。</li>
</ul>
</li>
<li>数值型数字与文本型数字
<ul>
<li>数值型数字：最长15位，超过15位后多余的位数在excel中自动变0，并用科学计数法表示</li>
<li>文本型数字：一般用于身份证号码等，只能计数，不能参与运算。</li>
<li>最简单的区别是对齐方式，文本格式数据<strong>靠左对齐</strong>，数值型数据<strong>靠右对齐</strong></li>
</ul>
</li>
<li>Excel 自动恢复并不靠谱，仅能在Excel本身出故障时起到一点作用，还是需要手动保存。这里，推荐一个VBA代码，可以直接保存打开的所有excel工作簿：<a href="https://www.extendoffice.com/zh-CN/documents/excel/2971-excel-save-all-open-files.html">一键保存所有打开工作簿</a>。</li>
<li>excel中日期的本质也是数字，将1900/01/01设为1，1900/01/02为2。一天是1，一个小时是1/24，以此类推。</li>
</ul>
<h1>Excel 公式与函数</h1>
<p>Excel个人感觉掌握几个用的比较多的函数就够了，比如VLOOKUP，SUMIF，COUNTIF。太复杂的函数或函数嵌套，个人感觉没有必要学，有点鸡肋。</p>
<h2 id="小知识-2">小知识</h2>
<ul>
<li>函数中需要引用字符串时，只能使用<strong>双引号</strong>，不能使用单引号。</li>
<li>在逻辑判断中，所有<strong>非0数值</strong>均认为是<strong>TRUE</strong>，只有0表示FALSE。</li>
<li>ctrl+左键选择多列后，右键插入下一行，会在列与列之间插入空行。</li>
<li>多条件判断。个人比较喜欢用第二种方式
<ul>
<li>AND(条件1，条件2)  = 条件1 * 条件2</li>
<li>OR（条件1，条件2）=条件1 + 条件2</li>
</ul>
</li>
<li>删除空格：使用替换，原值输入一个空格，替换的值什么也不输入即可。</li>
</ul>
<h2 id="vlookup">vlookup</h2>
<p>vlookup 最后一个参数，</p>
<blockquote>
<p>如果选择TRUE（模糊匹配），那么要求查找区域必须按<strong>升序</strong>排列。如果匹配不到原值，那么查找区域会匹配比原值<strong>小</strong>的最大值。这种情况比较适合查找值为数字，例如纳税，5000-6000是x，那高于5000低于6000的纳税比例都是x。<br>
如果选择FALSE（精确匹配），此时查找区域无需排序，必须匹配原值。个人主要是用精确匹配。</p>
</blockquote>
<h2 id="countif-s-与-sumif-s">countif(s) 与 sumif(s)</h2>
<p>按条件计数或求和，加s可以按多条件匹配，很实用。</p>
<h2 id="find-left-mid-right">find + left/mid/right</h2>
<p>find与search函数几乎是一样的，都是返回查找字符的索引（从1开始计数）,唯一区别就是<strong>find区分大小写</strong>，而search不区分大小写。<br>
估计find函数的使用也就是配合 left/mid/right这三个函数提取子字符串。如下，提取A1单元格（地址）的省份信息（光用left不够，因为不同省份字数不同，比如黑龙江就三个字）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B1&#x3D;LEFT(A1,FIND(&quot;省&quot;,A1))</span><br></pre></td></tr></table></figure>
<h2 id="英文处理">英文处理</h2>
<ul>
<li>proper 函数： 英文首字母大写</li>
<li>upper  函数：一律大写</li>
<li>lower   函数：一律小写</li>
</ul>
<h2 id="判断单元格类型">判断单元格类型</h2>
<ul>
<li>ISTEXT：        是否为文本</li>
<li>ISNUMBER：是否为数值</li>
</ul>
<h2 id="数组计算">数组计算</h2>
<ul>
<li><strong>F9</strong> 显示数组计算时的值（个人用于合并单元格内容）</li>
<li><strong>ctrl+shift+enter</strong> 数组计算</li>
</ul>
<h1>Excel 宏</h1>
<p>宏和VBA在实质上是相通的。个人感觉VBA有点鸡肋，对我而言，现在不太需要录制宏了。原因很简单，我不用Excel进行复杂的操作，自动也用不上宏了。</p>
<h2 id="小知识-3">小知识</h2>
<ul>
<li>
<p>相对引用与绝对引用。录制宏的时候可按需要切换引用方式。</p>
</li>
<li>
<p>录制宏与选择区域的顺序问题</p>
<ul>
<li><strong>先选择区域，再录制宏</strong>：一般这么做</li>
<li>先录制宏，再选择区域：无法更改选择区域，死的。</li>
</ul>
</li>
<li>
<p>逐条语句运行</p>
<ul>
<li>选择VBA界面的<strong>调试</strong>中的逐语句</li>
<li>F8快捷键</li>
</ul>
</li>
<li>
<p>屏蔽宏运行过程</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">application.screenupdating &#x3D; False</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据分析</tag>
        <tag>软件学习</tag>
      </tags>
  </entry>
  <entry>
    <title>plink学习笔记</title>
    <url>/posts/def937d0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近看到一个个人网站，里面有句话如下。</p>
<blockquote>
<p>为什么我最近更新得这么勤，因为我在不断充电。</p>
</blockquote>
<p>嗯，保持充电确实很重要啊！记录并总结自己的学习过程也很重要！我之前学东西都是记在笔记本或者脑子里，但是都不牢靠。纸质的东西总是易于损坏、丢失的，人脑的记忆能力也是有限的，而且我写的字也很难看。这个时候，将笔记什么的电子化就很有优势了。我在想，与其先记在本子上，再转到电子形式，不如从现在就训练自己用直接markdown写东西、记东西。</p>
<p>本文主要是学习了plink1.07的官方文档  <a href="http://zzz.bwh.harvard.edu/plink/dist/plink-doc-1.07.pdf">plink-doc-1.07.pdf</a>，有些内容因为个人暂时用不上，就跳过了，详细内容可直接阅读该文档。</p>
<span id="more"></span>
<h1>第一部分 plink 入门 —— 前三章</h1>
<p>ped文件前六列为家系ID，个体ID，父亲ID，母亲ID，性别（公1母2，其他为未知），表型（数量性状或疾病性状）。从第7列开始为基因型。ped不能有标题行。plink通过<strong>家系ID和个体ID</strong>来区分不同个体，即家系ID和个体ID不能都相同（但一般情况下要保持个体ID的唯一性）。<br>
map文件由四列组成，第一列为染色体（常染色体从1开始编号，性染色体是X或Y，0表示未知），第二列是SNP名称，第三列是遗传图谱（摩尔根距离，单位是厘摩，cm，大部分分析都用不上），第四列是物理图谱（真实距离，单位是bp，正整数，低于人的染色体长度。如果为负数，该SNP将被plink剔除)。–map3选项表示map文件中没有第三列遗传图谱。</p>
<h2 id="ped表型格式-phenotype">ped表型格式 phenotype</h2>
<p>疾病性状默认-9或0表示缺失，1表示未感染，2表示感染。可以使用–1选项，将-9认为缺失，0认为未感染，1认为感染。plink将性别不明的个体的表型也设置为缺失，可使用 --allow-no-sex禁止该现象。通过 --missing-phenotype -99 设置缺失表型值。<br>
如果ped文件中的一个个体的两个标记之间没有空格（例AG，而不是A G），那么在读取数据时可使用–compound-genotypes选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;plink --file mydata --compound-genotypes &lt;&#x2F;tt&gt;</span><br></pre></td></tr></table></figure>
<p>plink支持以标准输入流形式读取ped文件（用-替代ped文件名），但是不适用map文件。代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.... | .&#x2F;plink --ped - --map mymap.map --make-bed</span><br></pre></td></tr></table></figure>
<h2 id="ped基因型格式-genotype">ped基因型格式 genotype</h2>
<p>plink软件可以支持任何形式的SNP的编码，ATGC或1234都适用。plink 基因型缺失值格式默认为0，可通过–missing-genotype 修改缺失值。所有的标记都必须为<strong>双等位基因</strong>。<br>
可以通过–output-missing-phenotype 和 --output-missing-genotype修改plink输出文件的默认缺失值格式<br>
但需要输出新文件时（如生成二进制ped），plink通常会保留所有的基因型信息（即保持转换前后实际内容不变）。但是当使用plink进行统计和数据分析是，plink会对基因型数据进行筛选，将一部分基因型数据自动设置为缺失并剔除。</p>
<p>–file 需要ped和map文件名称相同。如果不加–out选项，默认名称均为plink。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file hapmap1</span><br></pre></td></tr></table></figure>
<h2 id="其他芯片文件格式-——-Transposed-filesets">其他芯片文件格式 ——  Transposed filesets</h2>
<p>文档中提到有一种转置的ped文件类型，由tped文件和tfam文件构成。tped文件每一行是一个snp，前4列是map文件的内容，后面每两列是一个个体该SNP的基因型。tfam文件是原ped文件的前六列。<br>
该文件可通过 --tfile 或 --tped --tfam读取，通过 --transpose 生成.<br>
<img src="/images/transpose_ped.png" alt=""></p>
<h2 id="其他芯片文件格式-——-Long-format-filesets">其他芯片文件格式 —— Long-format filesets</h2>
<p>该格式包括三个文件lgen文件，map文件（同上），fam文件（原ped文件的前六列）。lgen文件由5列组成，分别为家系ID，个体ID，snp名称，该snp的第一个等位基因，第二个等位基因。<br>
该文件可以通过 --lfile 命令读取，并使用 --recode 转换为标准的ped文件。根据说明文档，目前plink不支持输出这种格式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --lfile test --recode</span><br></pre></td></tr></table></figure>
<p><img src="/images/lgen_ped.png" alt=""></p>
<h2 id="额外的表型文件">额外的表型文件</h2>
<p>除了在ped文件（或fam文件）中的第六列准备表型，plink还支持输入一个单独的表型文件（–pheno）。表型文件应包含三列，家系ID，个体ID，表型。但是ped文件中依然不能缺少第六列（虽然此时没有作用了）。</p>
<ul>
<li>如果ped中的个体没有出现在表型文件中，那么plink会将该个体的表型设为缺失。</li>
<li>表型文件中个体的顺序不需要按照ped文件的顺序。</li>
<li>如果表型文件表型文件中不止一列表型，此时使用–mpheno N命令来明确使用的是第N列表型。如下代码所示，pheno2.txt共7列（即有5列表型，暂命名为A,B,C,D,E），那么这里用的是第4列表型，即表型D。</li>
<li>表型文件默认没有标题行，如果有，那么前两个标题必须为FID和IID，此时指定表型列可直接使用标题，如 --pheno-name age</li>
<li>表型文件中所有表型必须为数值，缺失值默认为-9（可以通过–missing-phenotype设置）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file mydata --pheno pheno2.txt --mpheno 4</span><br></pre></td></tr></table></figure>
<h2 id="生成二进制文件">生成二进制文件</h2>
<p>–make-bed 生成二进制ped文件，压缩数据大小，加快分析速度。该命令生成二进制文件时，不会根据missing rates或等位基因频率清洗任何SNP位点或个体。<br>
该命令生成三个文件，bed文件为二进制的ped文件，bim为扩展的map文件（相较于原map文件，增加了两列，为每个SNP的等位基因名称），fam文件（ped文件的前六列）。这三个文件是配套的，<strong>不能修改bim文件和fam文件</strong>，否则可能会导致错误。<br>
读取二进制文件，使用–bfile替代–file。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file val --make-bed</span><br></pre></td></tr></table></figure>
<h2 id="统计缺失率或基因分型率">统计缺失率或基因分型率</h2>
<p>生成二进制文件后，可直接使用二进制文件来进行分析（–bfile），如通过–missing分析基因分型率call rate（或missing rate）。<br>
生成missing_data.imiss和missing_data.lmiss文件（分别为个体的缺失情况文件和SNP位点的缺失情况文件，i和l为individual的individual和locus的缩写）。imiss文件中N_MISS列为该个体未测出的SNP数目，N_GENO为总的SNP数目，F_MISS为未检出的SNP所占比例。同样地，lmiss的最后三列分别为所有个体中该位点未检出个数，个体数，该位点未检出比例。<br>
（注，plink会首先联网查找更新，如果服务器没联网或者运行时不需要联网，需要添加命令 --noweb。）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile plink --missing --out missing_data</span><br></pre></td></tr></table></figure>
<p>–chr 1 按不同染色体去运行plink命令。减少运算量。</p>
<h2 id="统计等位基因频率">统计等位基因频率</h2>
<p>–freq 统计等位基因频率，生成frq文件。其中MAF为该snp位点最小等位基因频率<br>
（在plink中，将基因频率较小的叫做A1，将基因频率较大的叫做A2）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --noweb --bfile plink --freq --out freq_stat</span><br></pre></td></tr></table></figure>
<p>对有群体分层现象的不同群体进行等位基因频率分析。下面pop.phe描述了不同个体所属的群体（cluster）情况，三列（家系ID，个体ID，所属群体）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --noweb --bfile plink --freq --within pop.phe --out freq_stat</span><br></pre></td></tr></table></figure>
<p>–snp rs1891905 选择特定的SNP进行分析。–window kb --from --to 选择一堆snp进行分析。</p>
<h2 id="基本关联分析">基本关联分析</h2>
<p>基本关联分析 --assoc。（后面有关关联分析的内容没看，本人用不上。）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile plink --assoc --out as1</span><br></pre></td></tr></table></figure>
<h2 id="读取plink命令文件">读取plink命令文件</h2>
<p>当plink命令较长时，可将plink命令写入一个文件中。运行 --script命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --script myscript1.txt</span><br></pre></td></tr></table></figure>
<p>myscript1.txt内容如下，每一行一个命令，以–开始。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--ped ..\data\version1\50K\allsamples.ped</span><br><span class="line">--map ..\data\allmapfiles\finalversion\autosomal.map</span><br><span class="line">--out ..\results\working\sample-missingness-v1.22</span><br><span class="line">--from rs66537222</span><br><span class="line">--to rs8837323</span><br><span class="line">--geno 0.25</span><br><span class="line">--maf 0.02</span><br><span class="line">--missing</span><br></pre></td></tr></table></figure>
<h1>第二部分 plink 数据管理</h1>
<h2 id="recode">recode</h2>
<p>对于ped文件，使用–recode命令，生成的文件与原文件内容相同，仅仅按snp所在染色体及真实位置进行了排序。个人理解，如果要重新生成ped格式的芯片文件，那么就需要使用–recode命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --noweb --file val --recode</span><br></pre></td></tr></table></figure>
<p>plink支持将二进制文件重新转为普通ped文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile mydata --recode</span><br></pre></td></tr></table></figure>
<p>使用–recode12 命令将会使基因型重编码为1和2（0依然表示未知）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --noweb --file val --recode12</span><br></pre></td></tr></table></figure>
<p>将ped基因型从ATGC转到1234，使用–allele1234（相反则用–alleleACGT）。注意，–allele1234必须配合–recode 或 --make-bed等生成文件命令或其他分析命令使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file val --recode --allele1234</span><br></pre></td></tr></table></figure>
<h2 id="生成snp-list文件">生成snp list文件</h2>
<p>按SNP的基因型排列 --list，生成list文件，格式为染色体-snp名称-基因型（双）-第一个个体的家系ID-第一个个体的个体ID-第二个个体……。可配合–snp命令，查看某个snp的基因型情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file val --list</span><br></pre></td></tr></table></figure>
<h2 id="更新covariate文件">更新covariate文件</h2>
<p>重新生成covariate文件，当–covar 配合生成文件命令（–recode 或 --make-bed）。好处是当covariate文件包含个体多于芯片，或顺序不一致时，生成的新文件与芯片文件保持一致。(–write-cluster类似,形成新的cluster文件)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --covar myfile.txt --recode</span><br></pre></td></tr></table></figure>
<h2 id="翻转部分的SNP-例A变成T-改为等位基因基因型">翻转部分的SNP(例A变成T,改为等位基因基因型)</h2>
<p>准备一个snp名称文件(只有一列,为需要转换的snp名称),list.txt。flip命令需配合–recode等生成文件命令使用。适用于当芯片出现正反链问题时。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --flip list.txt --recode</span><br></pre></td></tr></table></figure>
<p>当只对芯片中的一部分个体进行转换时，增加–flip-subset选项。mylist.txt为个体ID。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --flip list.txt --flip-subset mylist.txt --recode</span><br></pre></td></tr></table></figure>
<h2 id="合并两个芯片文件">合并两个芯片文件</h2>
<p>合并两个芯片文件(merge 后面必须是ped map；–recode是必需的)。merge合并文件时，两个芯片文件的标记和个体之间可以是完全重合、部分重合甚至没有重合。文档中举例，如果一个snp只出现在第二个芯片文件中，那么第一个芯片文件中的个体（没出现在第二个文件）合并后该snp均为缺失。个人理解是，merge合并的文件应该会按照个体数最多、标记数最多的原则，所有不知道的位点全部设为缺失。<br>
第二，在第一个文件中已经存在的标记数据，默认情况下不会被第二个文件覆盖。例如第一个文件某个体某snp为AA，第二个文件该个体该SNP为AG，最终合并文件中还是AA。覆盖情况可以通过–merge-mode调整。<br>
第三，两个map同一个snp的物理位置需保持一致。<br>
第四，两个芯片文件的snp编码方式要保持一致，不能一个ATGC，一个123。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data1 --merge data2.ped data2.map --recode --out merge</span><br></pre></td></tr></table></figure>
<p>merge命令可用于二进制文件，此时需用–bmerge，输出需用–make-bed</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile data1 --bmerge data2.bed data2.bim data2.fam --make-bed --out merge</span><br></pre></td></tr></table></figure>
<h2 id="合并多个芯片文件">合并多个芯片文件</h2>
<p>使用–merge-list命令，需要准备文件，后面每一个芯片文件一行（可以为普通格式，也可以是二进制格式）。例如合并fA到fH的芯片文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file fA --merge-list allfiles.txt --recode --out mynewdata</span><br></pre></td></tr></table></figure>
<p>allfiles.txt格式如下图<br>
<img src="/images/merge_list.png" alt=""></p>
<h2 id="提取SNPs的子集">提取SNPs的子集</h2>
<h3 id="基于染色体">基于染色体</h3>
<p>以下命令会默认生成6号染色体的二进制芯片文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --chr 6</span><br></pre></td></tr></table></figure>
<p>如果想生成正常格式的芯片文件，增加recode命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --recode --chr 6 --out chr1</span><br></pre></td></tr></table></figure>
<h3 id="基于snp范围">基于snp范围</h3>
<p>如果是挑一个范围内的所有标记（必须在同一条染色体）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile mydata --from rs273744 --to rs89883</span><br></pre></td></tr></table></figure>
<p>基于某个snp的上下游范围（–snp 和 --window)。以下命令将挑出rs652423上下游20kb的所有snp。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile mydata --snp rs652423 --window 20</span><br></pre></td></tr></table></figure>
<h3 id="基于染色体的物理位置（–from-kb-to-kb）">基于染色体的物理位置（–from-kb --to-kb）</h3>
<p>以下命令为挑选2号染色体上5000kb到10000kb的所有snp。类似选项有–from-bp,–from-mb</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile mydata --chr 2 --from-kb 5000 --to-kb 10000</span><br></pre></td></tr></table></figure>
<h2 id="随机采样-thin">随机采样 --thin</h2>
<p>–thin 0.2 表示随机抽取20%的snp。</p>
<h2 id="基于给定文件挑选snp">基于给定文件挑选snp</h2>
<p>以下命令中，mysnps.txt为snp名称，仅一列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file --extract mysnps.txt --recode</span><br></pre></td></tr></table></figure>
<p>当添加–range命令时，此时添加的文件格式是染色体（空格）起始物理位置（单位bp）（空格）结束物理位置(单位bp) （空格）该范围名称。每一行（4列）表示一个范围。如下图所示。<br>
<img src="/images/extract_range.png" alt=""></p>
<h2 id="剔除部分snps-exclude">剔除部分snps --exclude</h2>
<p>mysnps.txt为不需要的snp名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --exclude mysnps.txt --recode</span><br></pre></td></tr></table></figure>
<p>另外一种剔除方式是，在map文件中snp的物理位置设为负数（不适用于二进制文件）。</p>
<h2 id="挑出或移除部分个体">挑出或移除部分个体</h2>
<p>以下命令中，mylist.txt前两列为家系号 个体号（后面可以有其他列，plink会忽视）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --keep mylist.txt --recode</span><br></pre></td></tr></table></figure>
<p>移除个体使用–remove命令，文件格式与上述一致。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --remove mylist.txt --recode</span><br></pre></td></tr></table></figure>
<h3 id="通过其他文件内容筛选个体">通过其他文件内容筛选个体</h3>
<p>以下命令为挑选myfile.raw中第三列为1的个体。myfile.raw格式为三列，与表型文件、cluster文件格式一致，分别为家系ID 个体ID 自定义（如表型）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --filter myfile.raw 1 --freq</span><br></pre></td></tr></table></figure>
<p>如果给定文件中有多列，可以通过–mfilter指定列。以下命令便指定为fam文件中的表型（4表示前两列之后的第四列）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile data --filter data.fam2 --mfilter 4</span><br></pre></td></tr></table></figure>
<p>plink 中衍生出各种filter的命令，提取不同条件的个体，如–filter-cases、–filter-controls、–filter-males、–filter-females、–filter-founders、–filter-nonfounders。</p>
<h3 id="通过其他文件内容筛选snp">通过其他文件内容筛选snp</h3>
<p>类似上述，准备一个snp属性文件，第一列为snp名称，第二列及之后列为属性（空格分开，自定义）。</p>
<blockquote>
<p>一个snp可以有多个属性,也可以不接属性(即只有snp名称)<br>
属性文件中不用包括所有的snp,也可以包含不在map中的snp(plink会忽视)<br>
文件内容不需要顺序<br>
每个snp只能占一行(即不能重复)<br>
属性名称使用一个横杠,表示否定(exclude).可同时挑选多个属性,以逗号隔开.</p>
</blockquote>
<blockquote>
<p>多个属性条件时,默认是OR(或)逻辑;正负属性之间是and逻辑.<br>
以下命令即为挑选含有exonic属性,但是不含有failed属性的snp</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--attrib snps.txt exonic,-failed</span><br></pre></td></tr></table></figure>
<h1>第三部分 数据分析</h1>
<h2 id="基因型缺失">基因型缺失</h2>
<p>基本命令–missing<br>
<s>注意，结果文件lmiss和imiss文件都事先剔除了基因分型率小于90%的snp和个体（plink默认,可使用–mind 1保留所有个体）。如下图，imiss文件中N_GENO为50683（原map为50697个位点），这说明有14个snp位点因为分型率低于90%而被剔除。</s><br>
之前说错了，plink新版本（1.04以后）已经不会默认按基因分型检出率或MAF剔除个体或snp了。后面检查，发现删除的14个snp均是Y染色体上的，具体原因不是很清晰（猜测是因为我用的ped性别一列均是0（实际都是母猪），plink估计会将这种性别未知或母猪的Y染色体的snp删除掉）。屏幕上打印的信息如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Warning: Nonmissing nonmale Y chromosome genotype(s) present; many commands treat these as missing.</span><br></pre></td></tr></table></figure>
<p><img src="/images/imiss.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --missing</span><br></pre></td></tr></table></figure>
<h2 id="bligatory-missing-genotypes">bligatory missing genotypes</h2>
<p>这个不好翻译,文档中解释是有些snp位点不是因为基因分型失败,而是根本没检测。对于这种位点，我们可能希望不要删除这些位点（–geno）、或者因此而删除个体(–geno)。这个个人感觉还是比较实用，比如在合并不同map的芯片文件进行质控时。<br>
以下命令中，test.clst为正常的三列cluster文件，三列（cluster名称自定义）。test.oblig文件指定缺失的snp,两列，第一列是snp名称，第二列是cluster名称，如下图。按文档的例子，个人理解为，cluster文件只需指定有指定缺失snp的个体即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file test --missing --oblig-missing test.oblig --oblig-clusters test.clst</span><br></pre></td></tr></table></figure>
<p><img src="/images/oblig.png" alt=""><br>
注意</p>
<blockquote>
<p>该命令只对质控操作（–mind --geno）有效果，其他分析无效。<br>
如果设定为缺失的snp实际有基因型，仍会设为缺失。</p>
</blockquote>
<h2 id="哈温平衡">哈温平衡</h2>
<p>以下命令生成plink.hwe文件，格式如下图。最后四列是三种基因型的数目，观察到的杂合子频率，通过哈温平衡计算得到的理论杂合子概率，哈温平衡检验的p值。<br>
文档中提出，只有founders（个人理解是系谱里的最古老的个体）才会进行哈温平衡。但是我们一般ped文件中父母都是未知（0），所以所有个体都会进行哈温平衡检验。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --hardy</span><br></pre></td></tr></table></figure>
<p><img src="/images/hwe.png" alt=""></p>
<h2 id="等位基因频率">等位基因频率</h2>
<p>这个入门部分也有，使用–freq命令，生成frq文件，含有5列，分别为染色体、snp名称、A1(基因频率较小)、A2(等位基因频率较大)、MAF、无缺失的总的等位基因个数（小于等于2n,n为个体数）。</p>
<h2 id="孟德尔误差（Mendel-errors）">孟德尔误差（Mendel errors）</h2>
<p>本人对这个概念不是很清晰，从文档说明来看，大概是指根据父母的基因型推断的后代基因型与后代真实的基因型不符的情形，如父母都是AA，后代却是AB。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --mendel</span><br></pre></td></tr></table></figure>
<h2 id="性别确认">性别确认</h2>
<p>通过X染色体的基因型数据确认ped文件中的性别列是否有误。结果文件sexcheck文件有6列，分别为家系ID，个体ID，ped文件中的性别（公1母2），通过X染色体确认的性别，匹配状态（PROBLEM or OK）,F(The actual X chromosome inbreeding (homozygosity) estimate)。</p>
<blockquote>
<p>如果ped文件中性别是0，也会显示不匹配（PROBLEM）<br>
F如果大于0.8认为性别为公，如果小于0.2认为母（不懂F的概念）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile data --check-sex</span><br></pre></td></tr></table></figure>
<p>–impute-sex命令可将基于SNP数据的性别修改ped文件中的性别，需要配合输出文件命令使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile data --impute-sex --make-bed --out newfile </span><br></pre></td></tr></table></figure>
<h2 id="PCA分析">PCA分析</h2>
<p><a href="https://www.cog-genomics.org/plink/1.9/strat#pca">https://www.cog-genomics.org/plink/1.9/strat#pca</a></p>
<p>plink 用于作PCA分析，命令相当简单，就是加一个 --pca 就完事了</p>
<p>默认会输出20个主成分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--pca [count] [&#39;header&#39;] [&#39;tabs&#39;] [&#39;var-wts&#39;]</span><br><span class="line"></span><br><span class="line">--pca-cluster-names &lt;name(s)...&gt;</span><br><span class="line">--pca-clusters &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>count: 输出几个主成分，如 --pca 3 ，就是只要前3个主成分</li>
<li>header: eigenvec 文件加标题</li>
<li>tabs: 用tab 代替空格</li>
<li>var-wts:  You can request variant weights with the ‘<strong>var-wts</strong>’ modifier（不懂）</li>
</ul>
<p>第二个和第三个命令是当聚类后，你可以只挑出某几个cluster的个体做分析，二者的区别在于–pca-cluster-names 后面直接跟cluster的名称（以空格分开），–pca-culsters 后面接cluster名称的文件名</p>
<h1>第四部分 质控（QC）</h1>
<p>这一节对应文档的第6章，Inculsion thresholds，个人理解其实就是质控。这一节和上一节的数据分析的命令是有关联的，文档中用了一个图片说明，这里用一个表格说明。</p>
<table>
<thead>
<tr>
<th style="text-align:center">功能</th>
<th style="text-align:center">分析命令</th>
<th style="text-align:center">质控命令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">个体基因分型缺失率</td>
<td style="text-align:center">–missing</td>
<td style="text-align:center">–mind N</td>
</tr>
<tr>
<td style="text-align:center">SNP基因分型缺失</td>
<td style="text-align:center">–missing</td>
<td style="text-align:center">–geno N</td>
</tr>
<tr>
<td style="text-align:center">等位基因频率</td>
<td style="text-align:center">–freq</td>
<td style="text-align:center">–maf N</td>
</tr>
<tr>
<td style="text-align:center">哈温平衡</td>
<td style="text-align:center">–hardy</td>
<td style="text-align:center">–hwe N</td>
</tr>
<tr>
<td style="text-align:center">孟德尔误差比例</td>
<td style="text-align:center">–mendel</td>
<td style="text-align:center">–me N M</td>
</tr>
</tbody>
</table>
<h2 id="默认质控">默认质控</h2>
<p>高版本的plink（如1.9）已不会默认对个体或snp根据基因分型检出率或MAF进行质控。<br>
–all 不剔除任何个体或SNP，等于–mind 1 --geno 1 --maf 0</p>
<h2 id="个体基因检出率">个体基因检出率</h2>
<p>–mind 0.1 即剔除缺失率高于0.1的个体，或者说保留检出率高于0.9的个体。如果有个体被剔除，其个体信息保存在irem文件中<br>
–mind 1 即不剔除任何个体。使用该命令载入数据时不会计算个体的检出率，提高plink读取文件速度。</p>
<h2 id="snp基因检出率">snp基因检出率</h2>
<p>–geno 0.1 即剔除缺失率高于0.1的SNP，或者说保留检出率高于0.9的SNP。<br>
注意：–geno 和 --maf命令执行优先程度低于–mind，也就是同用–mind和–geno时，会先剔除缺失率较高的个体，再计算SNP检出率。</p>
<h2 id="最小等位基因频率">最小等位基因频率</h2>
<p>–maf 0.01 剔除MAF小于0.01的SNP</p>
<h2 id="哈温平衡-2">哈温平衡</h2>
<p>–hwe 0.001 如果需要剔除不满足哈温平衡的位点，使用该选项。p值小于0.001的个体被剔除，具体信息可见控制台（屏幕打印出的信息）或log文件。</p>
<h2 id="孟德尔误差比例（Mendel-error-rate）">孟德尔误差比例（Mendel error rate）</h2>
<p>只适用于family-based data。<br>
–me 0.05 0.1 第一个参数表示孟德尔误差超过5%的家系会被剔除；第二个参数表示孟德尔误差超过10%的SNP会被剔除。目前plink是同时计算家系和SNP的孟德尔误差比例，未来可能有所修改。</p>
<h1>第五部分 plink群体分层分析（Stratification analysis）和聚类分析（cluster analysis）</h1>
<h2 id="一般聚类">一般聚类</h2>
<p>根据IBS（identity-by-state,同态相同）进行聚类分析。基本命令如下，生成cluster0、cluster1、cluster2、cluster3四个文件，这四个文件内容一致，但格式不同（一般只用cluster1和cluster2）。</p>
<blockquote>
<p>cluster1文件是最直接的cluster结果文件，每一行是一个cluster，第一列SOL-0(估计是plink起的cluster名称)，后面就是每个cluster的个体（家系号_个体号）。<br>
cluster2文件是用来给plink读取的（使用–within *.cluster2）。格式为标准的三列，家系ID，个体ID，所属cluster。<br>
聚类时间与个体数有关。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile plink --cluster</span><br></pre></td></tr></table></figure>
<h2 id="加限制条件">加限制条件</h2>
<p>–cluster --mc 每个cluster最大的个体数量<br>
–ppc 0.05（pairwise population concordance） 当两个个体之间属于相同组的概率小于0.05时不进行合并（即设定P值）。<br>
结果文件是cluster1文件，每一行是一个cluster。第一列SOL-0什么的不用管，后面就是每个cluster的个体（家系号和个体号）。cluster2和cluster1内容一样，格式不同，cluster有三列，分别为家系号、个体号、所属cluster（cluster2 用于plink读取，–within plink）。<br>
可以通过–K（大写）选项设定cluster 的数目。但是这时不能再设定ppc。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --noweb --bfile plink --cluster --mc 10 --ppc 0.05 --out str1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --noweb --bfile plink --cluster --K 2 --out str2</span><br></pre></td></tr></table></figure>
<p>如果个体比较多，而且需要按不同条件进行多次聚类时，可按如下命令操作，节约时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile mydata --genome --out mydata</span><br><span class="line">plink --bfile mydata --read-genome mydata.genome --cluster --ppc 0.01</span><br><span class="line">plink --bfile mydata --read-genome mydata.genome --cluster --mc 2 --ibm 0.01</span><br></pre></td></tr></table></figure>
<h2 id="IBS-similarity-matrix">IBS similarity matrix</h2>
<p>添加–matrix命令，生成mibs文件，为方阵形式，内容为所有个体两两之间的同态相同的比例（0-1）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file mydata --cluster --matrix</span><br></pre></td></tr></table></figure>
<p>通过R画图来具体描述群体结构（适合芯片中存在几个群体的情况，手册中是前45个个体是中国人，后44个是日本人）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --noweb --bfile plink --cluster --matrix --out ibd_view</span><br></pre></td></tr></table></figure>
<p>生成ibd_view.mibs文件（手册上写的是mdist文件)，在R中读取该文件，画图步骤如下。<br>
个人尝试了一下，使用这种方式画图，和PCA画图结果差不多。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">m &lt;- as.matrix(read.table(<span class="string">&quot;ibd_view.mibs&quot;</span>))</span><br><span class="line">mds &lt;- cmdscale(as.dist(<span class="number">1</span>-m))</span><br><span class="line">k &lt;- <span class="built_in">c</span>( <span class="built_in">rep</span>(<span class="string">&quot;green&quot;</span>,<span class="number">100</span>) , <span class="built_in">rep</span>(<span class="string">&quot;blue&quot;</span>,<span class="number">222</span>) )</span><br><span class="line">plot(mds,pch=<span class="number">20</span>,col=k)</span><br></pre></td></tr></table></figure>
<h1>第六部分 IBS/IBD 估计</h1>
<p>通过估计芯片个体间的IBS和IBD情况，可以用来检测测序时样品污染，重复样一致性，系谱错误以及发现未知的亲缘关系。</p>
<h2 id="配对的IBD估计">配对的IBD估计</h2>
<p>上一章说了个体间IBS的估计以及根据IBS划分cluster，我们可以检测个体间的IBD情况。以下命令生成genome文件，文件格式如下图。需要关注的是PI_HAT（这个指标就是两个个体IBD相同的大小），<br>
使用–Z-genome会生成压缩文件plink.genome.gz，–read-genome也可以直接读取压缩的genome文件。<br>
注意：IBD分析前需要进行群体分层分析。而且ped文件中的家系ID、父本ID、母本ID应该要完整。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file mydata --genome</span><br></pre></td></tr></table></figure>
<p><img src="/images/genome.png" alt=""><br>
如果只计算同一个家系的IBD（家系按照ped文件中的系谱划分），使用命令–rel-check，会大大加快速度，不用每两个个体都要计算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file mydata --genome --rel-check</span><br></pre></td></tr></table></figure>
<p>通过–min x挑选结果中PI_HAT大于x的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file mydata --genome --min 0.05</span><br></pre></td></tr></table></figure>
<h2 id="估计近交系数">估计近交系数</h2>
<p>不是很清楚原理，文档中说based on the observed versus expected number of homozygous genotypes<br>
以下命令生成het文件，格式如下图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file mydata --het</span><br></pre></td></tr></table></figure>
<p><img src="/images/het.png" alt=""></p>
]]></content>
      <tags>
        <tag>数据分析</tag>
        <tag>软件学习</tag>
        <tag>生物信息</tag>
      </tags>
  </entry>
  <entry>
    <title>序 - 构建个人博客的原因和过程</title>
    <url>/posts/7ce416b6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>第一篇博客，扯了一些闲天。</p>
<span id="more"></span>
<h1>为什么开通个人博客？</h1>
<p>我在B站关注了一位up主，名字叫codesheep（程序羊），他是华科出来的硕士（自称”资质平平“，感觉自己都不用活了）。自称看了他的视频，才产生了构建个人博客的想法。我看他宣传开通个人博客的视频，应该是在去葫芦岛旅游前（2019年7月27号）。按照大佬的说法，开通个人博客，有百利而无一害，比如避免自己重复掉坑、能够吸引一点关注、可能对其他人有帮助、结交同性朋友等。我想了想，感觉说得都很对，我没办法反驳，心里就种下了种子。等从葫芦岛回来，有空余时间的时候就可以动手做了。<br>
本科毕业的时候，我从一件事情上吸取到了一个教训。那时候我发现我有很多买回来的书，就一直放着，很多都没看，就一直放着，直到毕业。最后，我感觉实在有点累赘，就或卖或送打发了。这些买回来的书，如果一开始没去看，可能我永远都不会去翻他。其他事情应该也是一样的吧。对于想做的事，一开始不着手去做的话，这辈子都不会做了吧。毕竟，一辈子其实想想也没有多长。</p>
<h1>开通个人博客的过程</h1>
<p>当时好像程序羊还没有发布详细的构建个人博客的视频，我就从知网找了个教程，看着比较详细，那上面第一步就说要有个域名。然后，我就去了阿里云上去查找注册域名，本来想注册自己的名字 <a href="https://www.zhouzw.com">zhouzw</a>，没想到已经被注册了。然后我就不知道用啥英文了，毕竟我没有正儿八经起过英文名。我就找到了我的词汇课的课件，第一个词根是-vict（胜利的意思），一查也被注册了。后面对这个词根的注解上说，来自于希腊语vincere，就用了这个不是英文单词的词。之后我发现阿里云上域名都是按年买的，我感觉这是不是坑我（我刚开始以为应该是注册了就是终生的）。谷歌了一下，才发现域名都是按年买的，逾期不付费会回收，尴尬。为什么选.fun这个后缀呢，当然是希望自己开开心心（假的，因为便宜，我一次性买了10年才花了179，<a href="http://xn--6iq8fuf485iowl.com">相比于什么.com</a>,.cn这种正规后缀，真的是好便宜！)<br>
然后按照知乎的流程去走（其实什么软件、命令都不懂），从4点到了将近7点（我一般5点多去吃饭），并没有弄通。整个人就有点不太好，虽然其实也没搞多长时间。后来又是看了程序羊的视频，才算是最终构建好了。  搭建好了个人博客，当时发了个微信。然后到现在又过了一个多礼拜，这期间主要是其它事和学习shell编程啥的。我总是想先把手头的东西弄完或学完，再弄别的事。然后就一直到了今天。</p>
<h1>用个人博客做什么</h1>
<p>现在初步打算把自己一年多的学习的东西，总结提取重点，发到这个个人博客上来。当然都是一些很基础的东西。参考别人的博客，我对我这个博客的设定为总结，总结自己学习的东西，总结自己遇到的坑，总结一些实践经验（如果有的话），偶尔总结一下自己矫情的感想。</p>
]]></content>
  </entry>
</search>
