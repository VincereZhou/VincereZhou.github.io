<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>只只和男朋友</title>
    <url>/posts/ac7827ff/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录只只和男朋友的日常。</p>
<span id="more"></span>
<center>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1487460956&auto=1&height=66"></iframe>
</center>
<h1>我们的时间线</h1>
<p>2007年左右：初识</p>
<p>2021年2月16日：再次见面</p>
<p>2021年3月4日22时11分 ： 确定恋爱关系</p>
<p>2021年3月25日：只只的第一次生气</p>
<p>2021年4月3日： 确定恋爱关系后第一次见面</p>
<p>2021年4月9日23时：只只第一次为我哭泣</p>
<p>……</p>
<h1>我们的语录</h1>
<blockquote>
<p>时间 不详</p>
<p>只只：谈恋爱不就和吃饭喝水一样嘛</p>
</blockquote>
<blockquote>
<p>时间 2021年3月2日</p>
<p>周周：那怎么称呼？</p>
<p>只只：啊？我没想过 我朋友都叫我全名</p>
<p>只只：你简直问到我了</p>
<p>周周：茴茴？哈哈哈</p>
<p>只只：啊 我不知道唉 因为我们口音不一样啊</p>
</blockquote>
<blockquote>
<p>时间 2021年3月3日</p>
<p>只只：不过我们现在算什么关系啊</p>
<p>只只：****聊天？哈哈哈</p>
<p>周周：浅了</p>
<p>周周：不行</p>
<p>……</p>
<p>只只：那你要好好追我哦</p>
<p>只只：哈哈哈</p>
<p>周周：好哦</p>
<p>只只：那就改变称呼吧</p>
<p>只只：叫我只只</p>
</blockquote>
<blockquote>
<p>时间 2021年3月4日</p>
<p>只只：小周 小周</p>
<p>只只：你怎么还不出现啊</p>
<p>只只：给你10分钟哦</p>
<p>六分钟后</p>
<p>周周：出现了，出现了</p>
<p>周周：刚刚洗澡去了</p>
<p>只只：哈哈哈</p>
<p>……</p>
<p>只只：那你有啥要问我的</p>
<p>周周：没有啥要问的</p>
<p>只只：公平起见 我之前问了你的 现在到你了</p>
<p>只只：那好吧</p>
<p>周周：我不问，你也会说的</p>
<p>周周：何必费那事</p>
<p>……</p>
<p>只只：那就今天开始谈恋爱吧</p>
<p>周周：先恋爱后追求啊</p>
<p>只只：反正你表白了</p>
<p>只只：嗯嗯</p>
<p>周周：我们好特殊啊</p>
<p>时间：2021年4月9日</p>
<p>只只：刚刚我们生气的时候</p>
<p>只只：就我哭的时候</p>
<p>只只：我突然想到如果你不是我男朋友了</p>
<p>只只：我就好难过</p>
<p>周周：你这么说，我就好很多了。比你说的有点应该强一千万倍。</p>
<p>只只：因为你刺激到我了</p>
<p>只只：我的感觉一下就出来了</p>
<p>只只：之前抑制的感情一下就出来了</p>
<p>时间：2021年4月10日</p>
<p>只只：我喜欢喝甜甜的东西</p>
<p>周周：就像我们的恋爱吗？</p>
<p>……</p>
<p>只只：我对你的感觉是安全感，信任感，成熟感。有时候会想和你聊天，会想和你分享，有时候会想你。</p>
<p>周周：那这不是喜欢是什么</p>
<p>只只：是</p>
<p>周周：嗯？</p>
<p>只只：是</p>
<p>周周：是什么？</p>
<p>只只：你的结论是对的</p>
<p>周周：把我的结论再说一遍</p>
<p>只只：是喜欢</p>
<p>周周：主谓宾，把主语和宾语加上</p>
<p>只只：我喜欢你</p>
<p>周周：我也喜欢你</p>
<p>时间：2021年4月14日</p>
<p>周周：如果你驯养了我，我们就互相不可缺少了。对我来说，你就是世界上唯一的了；我对你来说，也是世界上唯一的了。</p>
<p>只只：驯养是相互的，不是单方向的，是双方向的。你驯养了我，我也驯养了你。</p>
<p>只只：温暖是互相给的。</p>
</blockquote>
<h1>我们一起做的事</h1>
<h2 id="电影《悬崖之上》-2021年5月万年">电影《悬崖之上》-2021年5月万年</h2>
<p><img src="movie1.jpg" alt=""></p>
<h1>我们的相册</h1>
<h2 id="仙女湖之旅-2021年4月新余">仙女湖之旅-2021年4月新余</h2>
<p>仙女湖位于新余，誉为“中国七夕情人节”的发源地。我和只只上午去的，可是等滴滴就等了一个小时……</p>
<p>门口有很多小花花，还有很多风车。</p>
<p><img src="xiannvhu3.jpg" alt=""></p>
<p><img src="xiannvhu6.jpg" alt=""></p>
<p>逛的时候发现的“鹊桥”</p>
<p><img src="xiannvhu4.jpg" alt=""></p>
<p>里面有一些书法，勉强能看懂，都是一些情诗。</p>
<p><img src="xiannvhu1.jpg" alt=""></p>
<p><img src="xiannvhu7.jpg" alt=""></p>
<p>然后，最最重要的是，我们一块买了四只说不上名字的鸟，只只一开始说是企鹅，确实有一点像，毕竟都是圆鼓鼓的。左边那两只现在在只只那里，我们起名叫 “周大胖”，“周小胖”；右边那两只现在在我这，我们起名叫“程大胖”，“程小胖”。哈哈哈！</p>
<p>不过，这四只胖胖以后还是会放在一块的。</p>
<p><img src="xiannvhu5.jpg" alt=""></p>
<p>在景区吃的饭，仙女湖的鱼和藕条。我们一致觉得鱼不行，但我觉得藕条还行。悄悄地说一句，某人只要觉得不好吃就吃得很少，难养哦。</p>
<p><img src="xiannvhu2.jpg" alt=""></p>
<p>我走的那天送只只的玫瑰。周边其实没有花店，当时正好碰到了一个花店老板给别人送花，我就叫住了她，买了一束花，让她送过来。</p>
<p><img src="xiannvhu8.jpg" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>重复抽样方法</title>
    <url>/posts/c54c0f20/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ISL 真是好书！</p>
<span id="more"></span> 
<h1>资料</h1>
<p><a href="https://www.statlearning.com/">An Introduction to Statistical Learning</a>，下文简称 <strong>ISL</strong></p>
<h1>概述</h1>
<p>重复抽样方法 (<em>Resampling methods</em>) 是统计中的一个常用工具。通过对一个训练集不断地提取子集，然后用同一个模型进行拟合，来获取这个模型的更多的信息，比如 <em>variance</em> 。</p>
<p>重复抽样方法最常用的是 <strong>交叉验证</strong>(<em>cross-validation</em>) 和 <strong>自助法</strong>(<em>bootstrap</em>) 。这两种方法都很重要，比如交叉验证方法可以用来估计模型的 <em>test error</em> ，从而用来评价模型/方法的表现。这种评估模型表现的过程称为 <em>model assessment</em> ，而选择一个模型的自由度（<em>level of flexibility</em>）称为 <em>model selection</em> 。自助法一般用于评估参数估计的准确性。</p>
<h1>交叉验证</h1>
<p>在 ISL 前面的章节里提过了 <em>test error rate</em> 和 <em>trainging error rate</em> 。一般我们评价模型的好坏会用 <em>test error rate</em> ，但是这就要求除了有<em>training data set</em> 外，还需要有 <em>test data set</em> 。但是实际情况里，我们可能会没有一个比较大的 <em>test data</em> 来估计 <em>test error rate</em> ，也就是说我们只有一个群体的数据。通过交叉验证方法，我们可以人为的从训练集中提取一个子集来计算 <em>test error rate</em> 。</p>
<h2 id="The-Validation-Set-Approach">The Validation Set Approach</h2>
<p>这个方法的思路就是将所有观测值分为两部分，训练集和验证集。训练集用于拟合模拟，然后将得到的模型用于验证集，计算 <em>test error rate</em> ，数量性状一般就是计算 <strong>均方误差(MSE)</strong>。</p>
<p>在 ISL 的书中提到了一个例子，在 Auto 数据集中，mpg 和 horsepower 之间存在非线性关系，然后用 horsepower 和 horsepower<sup>2</sup> 的模型效果更好。<strong>我们很容易想到如果继续添加立方项或者更多的项，效果会不会更好？</strong> 这在前面的例子中是通过查看立方项和更高的项的 P 值来确定的，但是我们也可以用交叉验证来回答。我们可以随机将 392 个观测值随机分为两个集合，一半作为训练集，一半作为验证集；对于相同的训练集，采用不同的模型进行拟合，然后用于同样的验证集计算MSE。效果如下，左边为一次结果，右边为重复十次结果。十次重复结果各不相同，均方误差最小值的项均不相同，我们只能说简单线性回归不是最优解，然后高于2项的回归即便有提升，提升幅度一般也比较小。</p>
<p><img src="1.png" alt="1"></p>
<p><strong>The validation set approach</strong> 这种方法思路非常简单，易于使用，但是又两个潜在的缺点：</p>
<ol>
<li>就像上面右图的结果，多次抽样的结果差异较大，取决于你把哪些个体放在训练集，把哪些个体放在验证集。</li>
<li>这个方法，仅仅只使用了一部分个体（划定为训练集的个体）用于拟合模型。一般来说，样本量越少，样本拟合效果越差，因此这里计算得到的 test error rate 比实际情况要高。</li>
</ol>
<h2 id="Leave-One-Out-Cross-Validation">Leave-One-Out Cross-Validation</h2>
<p><em>Leave-One-Out Cross-Validation</em> (LOOCV) 接近于上面的 <em>validation set approach</em> ，但是这种方法尝试来弥补上面这种方法的缺点。</p>
<p>LOOCV 也是把观测值分为两个群体，但区别在于它只将一个个体划定给验证集，将其他的 n-1 个个体划定给训练集，用于拟合模型，然后预测留出来的一个个体的，计算MSE。由于只有一个个体, MSE 的公式变为<br>
$$<br>
\mathrm{MSE}<em>{1}=\left(y</em>{1}-\hat{y}_{1}\right)^{2}<br>
$$<br>
虽然MSE<sub>1</sub> 是无偏的，但是它是一个很糟糕的估计值，因为变异太大。</p>
<p>我们可以重复这个过程，让所有个体都做一次验证个体，也就是总共重复n次。图示如下：</p>
<p><img src="2.png" alt="1"></p>
<p>然后我们计算这n次的平均MSE<br>
$$<br>
\mathrm{CV}<em>{(n)}=\frac{1}{n} \sum</em>{i=1}^{n} \mathrm{MSE}_{i}<br>
$$<br>
LOOCV 方法相比于上面的 validation set 方法又很多优势。首先，LOOCV 方法有更小的 bias，因为 LOOCV 方法用了接近所有个体来拟合模型，而 validation set 只用了一半。因此，LOOCV 方法不会高估 <em>test error rate</em> 。其次，validation set 随机划分群体使得多次重复结果的差异较大，而多次重复 LOOCV 也只会产生一个相同的结果，LOOCV 方法根本没有训练集和验证集划分的随意性问题。</p>
<p>我们对 Auto 数据集采用 LOOCV 方法进行计算，结果如下图左图（右图为9次单独的 10-fold CV结果，每次均随机地将群体分成10份。从这里可以看出 10-fold CV 多次结果之间的差异较小）</p>
<p><img src="3.png" alt="1"></p>
<p>LOOCV 的计算量比较大，毕竟需要计算 n 次。如果 n 比较大，那么 可能会非常耗时。<strong>在最小二乘的线性回归或二项式回归分析中</strong>，存在一个简化可以使得 LOOCV 的计算量与单次模型拟合差不多，公式如下。这个式子看上去类似于普通的 MSE 的计算公式，除了分母部分增加了 一个 (1-h<sub>i</sub>)<br>
$$<br>
\mathrm{CV}<em>{(n)}=\frac{1}{n} \sum</em>{i=1}^{n}\left(\frac{y_{i}-\hat{y}<em>{i}}{1-h</em>{i}}\right)^{2}<br>
$$<br>
这里预测值 y_hat 是采用原始的最小二乘拟合的结果， <em>h<sub>i</sub></em>  是 leverage ，值在1/n 与 1 之间，表示一个观测值对模型拟合的影响程度。因此，对于 high-leverage 的点，1-  <em>h<sub>i</sub></em>  越低，这里相当于放大了残差。<br>
$$<br>
h_{i}=\frac{1}{n}+\frac{\left(x_{i}-\bar{x}\right)^{2}}{\sum_{i^{\prime}=1}^{n}\left(x_{i^{\prime}}-\bar{x}\right)^{2}}<br>
$$<br>
LOOCV 是一个一般方法，可以用于各种各样的模型，比如用于逻辑回归或LDA分析。</p>
<h2 id="k-fold-Cross-Validation">k-fold Cross-Validation</h2>
<p>LOOCV 方法的一个备选方法是 k-fold CV 方法。这种方法将所有个体随机分成相同大小的 k groups ，或者说是 k folds。将第一个 fold 视为验证集，然后用其他folds拟合模型，计算得到 MSE<sub>1</sub>。这个过程重复 k 次，每次均拿出一个fold 视为验证集，其他视为训练集，得到多个 MSE。</p>
<p>然后通过下面这个式子计算平均MSE<br>
$$<br>
\mathrm{CV}<em>{(k)}=\frac{1}{k} \sum</em>{i=1}^{k} \mathrm{MSE}_{i}<br>
$$<br>
下图便反映了这个过程</p>
<p><img src="4.png" alt="1"></p>
<p>我们很容易看到，LOOCV 方法是 k-fold CV 方法的一个特例，即 k = n。在实际中，一般k会设为5或10，那么k设为5/10 相比于 设为n 的优势在哪里呢？首先最明显的就是<strong>计算量</strong>，因为 LOOCV 需要拟合模型 n 次（通过最小二乘法估计的线性模型除外），而 k-fold CV 只需要拟合 5次或10次。</p>
<p>但我们使用真实数据时，由于我们不知道真实的 test MSE ，因此我们很难决定CV估计的准确性。但是，如果我们使用模拟数据，我们计算得到真实的 test MSE，因此可以评价CV结果。下图中，我们画出了CV得到的 test error rate 估计值 和 真实的 test error rate，这里蓝线是真实值，黑色虚线是LOOCV估计值，红色线是 10-fold CV 估计值。我们可以看到 10-fold CV 和 LOOCV 结果差不多。</p>
<p><img src="5.png" alt="1"></p>
<p>但我执行交叉验证时，我们的目的可能是看一个统计模型应用在一个与训练集独立的数据中的效果，也就是说， 我们感兴趣地是 test MSE 的 估计值。但是有时候，我们仅仅是对 <em>estimated test MSE</em> 曲线的最小值，比如比较一系列统计方法/模型的优劣，一种模型但是使用不同水平的 <em>flexibility</em> 的比较，为了得到最佳的模型，或者最佳的 <em>flexibility</em> 。这种情况下，test MSE 的最小值的位置是最重要的，但是实际test MSE的大小不重要。根据上面的图(5.6)，我们可以看到 CV 的MSE估计值可能是低估的，但是通过CV曲线来查找最佳的 <em>flexibility</em> 水平基本和真实情况差不多。</p>
<h2 id="Bias-Variance-Trade-Off-for-k-fold-CV">Bias-Variance Trade-Off for k-fold CV</h2>
<p>前面起到 k-fold CV 相比于 LOOCV 的优点是减少计算量，其实 k-fold CV 相比于 LOOCV 还有一个优点，就是 <strong><em>test error rate</em> 估计更准确</strong>。这和 bias-variance trade-off 有关。</p>
<p>前面提到过 validation set 方法估计得到的 test error rate 会比真实值高，因为只用了一半数据来拟合模型。通过这个逻辑，LOOCV 方法会给出一个接近无偏的 test error ，因为几乎用了全部的数据来拟合模型。然后 k-fold CV 方法的 bias 会介于这二者之间。</p>
<p>但是我们知道，bias 并不是我们关心的估计过程的唯一指标，我们还关心 variance ，结果表明 LOOCV 比 k-fold CV 有更高的 variance 。为什么是这样呢？当我们执行 LOOCV 方法时，我们拟合的n个模型，几乎都是使用相同的数据；因此，这些模型的拟合结果之间具有高度的相关性。但是当我们执行 k-fold CV 时，k 个拟合的模型之间相关较弱，因为训练集数据之间的重合程度较小。因为很多高度相关的数量性状的均值比相关程度较低的数量性状均值的 variance 更小，因此 LOOCV 方法得到的 test error 估计值通常比 k-fold CV 方法有更高的 variance。</p>
<p>总结一下，综合考虑 bias 和 variance ，我们容易得到 k=5 或 k=10 的 k-fold CV 得到的 test error estimates 最佳，既不会有很高的 bias ，也不会有很高的 variance。</p>
<h2 id="Cross-Validation-on-Classification-problems">Cross-Validation on Classification problems</h2>
<p>上面提高的交叉验证的使用均是基于<strong>数量性状</strong>，因此都是用 MSE 来衡量 test error 。但是交叉验证同样可以用于质量性状的分析上，其实大同小异，只是用 test error rate 替换 MSE 来衡量 test error。例如， LOOCV 的公式如下<br>
$$<br>
\mathrm{CV}<em>{(n)}=\frac{1}{n} \sum</em>{i=1}^{n} \mathrm{Err}_{i}<br>
$$</p>
<p>$$<br>
\operatorname{Err}<em>{i}=I\left(y</em>{i} \neq \hat{y}_{i}\right)<br>
$$</p>
<p>下图为一个模拟数据的逻辑回归结果，p=2，通过多项式回归不断增加自由度。</p>
<p><img src="6.png" alt="1"></p>
<p>但是在真实的数据中，真实的决策线和 test error rate 均是未知的。因此我们需要决定上面的四种逻辑回归哪一种比较好。我们可以通过交叉验证来实现这一点。下图的左图显示了十倍交叉验证的结果（黑线），真实的 test error 是棕线，十倍交叉验证的结果很好的预测了真实结果（略低估了真实结果）。右图显示了KNN的结果，我们可以随着 flexibility 的增加，traing error rate 迅速下降，而 test error rate 呈U字型变化，这再次说明了不能用 training error rate 来说明模型的好坏。</p>
<p><img src="7.png" alt="1"></p>
<h1>自助法</h1>
<p>自助法可以衡量一个给定估计值或方法的不确定性。作为一个简单的例子，自助法可以用来估计线性回归拟合参数的标准误，这并不是很实用，因为R在做回归分析的时候会自动给出标准误。但是像一些复杂的统计方法，或者软件不能自动给出的不确定性，自助法就有用了。</p>
<p>如果我们使用模拟数据，计算一个参数估计的标准误，可以直接通过多次抽样直接计算多次参数估计的标准差即可。但是实际情况里，我们没法这么做，自助法则是通过一个数据集，生成多个数据集（比如1000个），然后计算所有生成的数据集中估计参数的标准差，做为估计参数标准误的估计值。</p>
<p>生成数据集的过程如下，加入原始数据是3条数据，生成的数据集也都是3条数据，生成的数据集的每条数据都是<strong>可重复地</strong>从原始数据集中进行随机抽样的结果。</p>
<p><img src="8.png" alt="1"></p>
<p>自助法效果如下，左图为多次创建数据集的结果，中图为使用一个数据集采用自助法的结果，右图为二者比较，我们可以看到自助法与真实结果很接近。</p>
<p><img src="9.png" alt="1"></p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑回归及其他分类变量分析方法</title>
    <url>/posts/749a327e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ISL 真是好书！</p>
<span id="more"></span> 
<h1>资料</h1>
<p><a href="https://www.statlearning.com/">An Introduction to Statistical Learning</a>，下文简称 <strong>ISL</strong></p>
<h1>概述</h1>
<p><strong>线性回归的因变量都是连续变量</strong>（例如人的身高），但是生活中我们也有很多因变量是分类变量的情况。比如：</p>
<ol>
<li>一位来到急诊室的病人，具有很多的临床症状，这些症状可能是由三种疾病导致的，那么到底这个病人是患上了什么疾病呢？</li>
<li>邮箱区分哪些邮件是垃圾邮件，哪些邮件不是垃圾邮件</li>
<li>全基因组关联分析：确定哪些基因突变与疾病有关联</li>
</ol>
<p>在 ISL 书中，分析的例子是基于一个人的年收入和每月信用卡余额来预测这个人是否会拖欠信用卡付款。数据如下图所示</p>
<p><img src="1.png" alt="1"></p>
<h1>为什么不用线性回归？</h1>
<p>假设我们想要基于一个急诊室的病人的症状来预测他/她患了什么病。在这个简化的例子中，假设我们有三个可能的疾病：stroke, drug overdose, epileptic seizure 。 我们可以将这些重编码为数字，如下：</p>
<p><img src="2.png" alt="1"></p>
<p>如果这里我们用最小二乘的方式来预测 Y，并且我们认为这三者之间的差异是相同的。<strong>实际上我们这么重编码数字是没有道理的</strong>。比如，有些人还可能用另外一种编码方式：</p>
<p><img src="3.png" alt="1"></p>
<p><strong>如果换了一种重编码方式，那么这三者之间的关系就完全变了。</strong></p>
<p>如果反应变量的值是有序的，例如 <em>mild</em>, <em>moderate</em>, <em>severe</em> ，这样我们把这几个变量编码为1,2,3 还有一点道理。但是这么做还不是一种自然的方式。</p>
<p>对于一个<strong>二变量</strong>的分类性状，情况就好一点。比如如果病人的病症只有两种情况：stroke 和 drug overdose 。 我们可以将这两个变量转换为哑变量。</p>
<p><img src="4.png" alt="1"></p>
<p>我们可以对这个二变量进行线性回归，如果预测值大于0.5， 我们认为是 drug overdose；反之我们认为 stroke 。在这种情况，<strong>即使颠倒了重编码方法，预测结果还是一样的</strong>。这种情况下，线性回归是有意义的，我们得到的预测值可以理解为 <em>drug overdose</em> 的<strong>可能性</strong>，但是<strong>线性回归的预测值可能会超出 [0,1] 区间</strong>，使得这个结果难以解释。</p>
<h1>衡量分类变量模型的准确性</h1>
<p><em><strong>training error rate</strong></em> :  公式如下，其中 <code>I()</code> 为哑变量，如果预测值和真实值不同则为1，相同则为0。这个式子其实就是计算 traing data 有多少比例的预测值预测错了。<br>
$$<br>
\frac{1}{n} \sum_{i=1}^{n} I\left(y_{i} \neq \hat{y}_{i}\right)<br>
$$<br>
但是，实际上我们更关心的是 <em>test data</em> 的结果，同样的我们计算 <em><strong>test error rate</strong></em> 。一个好的模型，我们得到的  <em><strong>test error rate</strong></em> 应该是很低的。</p>
<h1>逻辑回归</h1>
<p>逻辑回归（logistic 回归）采用的因变量是<strong>某一个水平的概率</strong>。</p>
<p>线性回归与逻辑回归比对的结果如下：</p>
<p><img src="5.png" alt="1"></p>
<p>对于 ISL 的 Default 数据集（信用卡是否违约）， 逻辑回归会预测违约的概率。例如，基于 balance 因子的预测可以写成</p>
<p><img src="6.png" alt="1"></p>
<p>简写为 p(balance)，如果这个值大于0.5，我们可能预测会违约（这个阈值也可以调整）。</p>
<h2 id="逻辑回归模型">逻辑回归模型</h2>
<p>常规的线性模型如下：</p>
<p><img src="7.png" alt="1"></p>
<p>线性模型的问题在于预测值会超出[0,1]区间，这是不合理的。为了避免预测值超出[0,1]区间，我们设定逻辑回归的预测函数为：</p>
<p><img src="8.png" alt="1"></p>
<p>个人理解：β0+β1X 就是原来的线性模型的预测函数，范围是负无穷到正无穷。因此，e<sup>β0+β1X</sup> 的范围就是 (0,+∞] 。整个 p(X) 在这个范围内是递增函数（由求导得到，易知导数永远大于0），整个p(x) 的两个极值在自变量的两个端点取得，范围为 (0,1)</p>
<p>为了求解这个预测函数，我们需要用到<strong>最大似然法</strong>。</p>
<p>对上面的函数进行变换，我们得到下面这个式子。这个式子 p(x)/[1-p(x)] 称为 <em>odds</em> ，这个式子的值的范围为 (0, ∞)</p>
<p><img src="9.png" alt="1"></p>
<p>如果我们对左右两边取对数，我们可以得到下面这个式子：下式中左侧称之为 <em>log-odds</em> 或者 <em>logit</em> 。我们可以看到 <em>logit</em> 是符合线性模型的。</p>
<p><img src="10.png" alt="1"></p>
<p>我们这里估计得到的 β1 的值虽然和 p(x) 不是线性相关，但是<strong>如果β1 是正数，说明增加 X 的值，会提高 p(x)</strong>。</p>
<h2 id="估计回归系数">估计回归系数</h2>
<p>逻辑回归中的 β0 和 β1 是未知的，必须通过已有的 training data 来进行估计。在线性模型中，我们采用最小二乘法来估计线性回归的系数。虽然这里我们也可以用最小二乘来拟合模型，当我们偏向采用更一般的方式 - <strong>最大似然法</strong>。最大似然法用于拟合逻辑回归的基本思路是：<strong>我们想寻找一组 β0 β1 的值，使得每个个体p(x) 的预测值和观测值尽可能的接近</strong>。在这个例子中，也就是对于存在违约的个体的预测值要接近1，对于不存在违约的个体的预测值要接近于0。</p>
<p>我们可以把上面这个思路用一个 <abbr title="likelihood function">似然函数</abbr> 来表示，如下图所示：</p>
<p><img src="11.png" alt="1"></p>
<p>使得这个似然函数<strong>最大</strong>的一组 β0 和 β1 的值就是我们选中的估计值。</p>
<p>在ISL书中，最大似然法是一种估计<strong>非线性模型</strong>参数的一种普遍的方法。<strong>在线性模型中，最小二乘法实际是最大似然法的一个特例</strong>（理由呢？）。</p>
<p>回到信用卡的例子，如果我们采用逻辑回归，结果如下图。我们可以看到 β1 的估计值为正数，说明 随着 balance 的增加，违约的概率在增加。</p>
<p><img src="12.png" alt="1"></p>
<h2 id="预测">预测</h2>
<p>一旦我们得到了系数的估计值，我们就可以带入逻辑回归的公式进行预测。例如，加入我们要预测 balance 为 1000 时的违约概率：</p>
<p><img src="13.png" alt="1"></p>
<p>如果自变量是分类变量也是可以的，不过需要先转变为<strong>哑变量</strong>。比如下面是“是否是学生” 的分析结果，我们可以看到学生违约的风险高于非学生群体。</p>
<p><img src="16.png" alt=""></p>
<p>预测值如下</p>
<p><img src="17.png" alt="1"></p>
<h2 id="多重逻辑回归">多重逻辑回归</h2>
<p>如果我们多个自变量，我们可以将逻辑函数扩展如下：</p>
<p><img src="14.png" alt="1"></p>
<p><img src="15.png" alt="1"></p>
<p>之后我们还是采用最大似然法来估计这些系数。</p>
<p>比如，我们用三个自变量去预测信用卡违约，结果如下，我们可以看到 balance 和 student[Yes] 的 P 值都很小，说明这这两个自变量都是显著的。但是<strong>stdent[Yes] 的系数是负数</strong>，说明学生违约的概率更小，这和上面的简单逻辑回归的结论相反。</p>
<p><img src="18.png" alt="1"></p>
<p>下图就说明了这个矛盾的结论：左图说明了，如果固定了 Balance 因子，既在相同的 Balance 水平下，学生的违约风险更低；右图中是不管Balance 和 income 水平，计算所有的学生和非学生的结果，可以看到学生的违约风险更高。这对于信用卡发放的决策者而言这是一个重要的区别，<strong>如果不知道balance信息，学生的违约风险比非学生更高； 但是如果在相同的balance水平下，学生比非学术的违约风险要低。</strong></p>
<p><img src="19.png" alt="1"></p>
<p>发生这种矛盾的原因还是<strong>自变量之间的相关</strong>，这种现象称之为 <em>confounding</em> 。是否是学生 与  balance 绝对是存在相关关系的，或者说学生的balance 的 分布 和 非学生的 balance 分布是不一样的。</p>
<p>我这里可以通过画图来看一下，代码和图片结果如下。我们可以看到学生和非学生的 balance 的分布基本还是类似于正态分布，但是学生的均值更高，而且右侧的尾巴更肥。我们可以通过这个图简单地总结一下，就是学生群体balance的值倾向于比非学生群体更高。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(ggplot2)</span><br><span class="line">ggplot(Default, aes(x=balance, fill=student)) + geom_histogram(position = <span class="string">&#x27;identity&#x27;</span>, alpha = <span class="number">0.4</span>, bins=<span class="number">60</span>)</span><br></pre></td></tr></table></figure>
<p><img src="20.png" alt="1"></p>
<h2 id="大于2个水平的因变量">大于2个水平的因变量</h2>
<p>如果有多个水平的话，一般就不用逻辑回归了。我们会用 <abbr title="discriminant analysis"><strong>判别分析</strong></abbr>  方法。</p>
<h1><abbr title="Linear Discriminant Analysis, LDA">线性判别分析</abbr></h1>
<p>对于大于2个水平（K&gt;2）的因变量，我们假定我们获取因变量的<strong>先验分布</strong>（即一个随机挑选的观察值来自于其中某个水平的概率），记为下面的符号。<br>
$$<br>
\pi_{k}<br>
$$<br>
另外一个式子就是基于某个因变量水平的自变量分布，见下式。如果这个值很高，说明当Y=k时，X=x 的概率很大。<br>
$$<br>
f_{k}(x) \equiv \operatorname{Pr}(X=x \mid Y=k)<br>
$$<br>
我们通过<strong>贝叶斯定理</strong>，就可以得到基于某个X的Y的条件概率，即<strong>后验概率</strong>，我们用 <em><strong>p<sub>k</sub>(x)</strong></em>  来表示<br>
$$<br>
\operatorname{Pr}(Y=k \mid X=x)=\frac{\pi_{k} f_{k}(x)}{\sum_{l=1}^{K} \pi_{l} f_{l}(x)}<br>
$$<br>
在这个公式里，因变量的先验分布比较容易获得，我们先对总体进行随机抽样，之后算一下每个水平的比例即可。但是 f<sub>k</sub>(x) 就不是很容易获得。<strong>如果我们可以估计  f<sub>k</sub>(x)</strong> ，我们就可以计算不同因变量水平的<strong>后验概率</strong>，我们认为后验概率最大的水平就是预测值。</p>
<h2 id="p-1的线性判别分析">p=1的线性判别分析</h2>
<p>如果只有一个自变量，我们需要首先估计  f<sub>k</sub>(x) ，我们需要先做一些假设。</p>
<p>我们假设  <strong>f<sub>k</sub>(x) 是符合正态分布的</strong> （假设1），在一个自变量的情况下，即符合下面这个式子：<br>
$$<br>
f_{k}(x)=\frac{1}{\sqrt{2 \pi} \sigma_{k}} \exp \left(-\frac{1}{2 \sigma_{k}^{2}}\left(x-\mu_{k}\right)^{2}\right)<br>
$$<br>
其中 u<sub>k</sub> 和 σ<sup>2</sup><sub>k</sub>  分别为第K个水平的均值和方差。我们进一步假设<strong>所有的水平的方差均相同</strong>（假设2），即如下式，可以简化为 σ<sup>2</sup> 。<br>
$$<br>
\sigma_{1}^{2}=\ldots=\sigma_{K}^{2}<br>
$$<br>
将这个式子带入到上面计算  <em><strong>p<sub>k</sub>(x)</strong></em> 的式子中，得到<br>
$$<br>
p_{k}(x)=\frac{\pi_{k} \frac{1}{\sqrt{2 \pi} \sigma} \exp \left(-\frac{1}{2 \sigma^{2}}\left(x-\mu_{k}\right)^{2}\right)}{\sum_{l=1}^{K} \pi_{l} \frac{1}{\sqrt{2 \pi} \sigma} \exp \left(-\frac{1}{2 \sigma^{2}}\left(x-\mu_{l}\right)^{2}\right)}<br>
$$<br>
计算所有水平的后验概率，选择<strong>后验概率最大</strong>的水平。我们可以看到对所有的水平，分母部分都是一样的，因此我们只需要关注分子部分，只要找对分子最大的水平。对分子部分采用 log 函数，剔除常数部分，我们得到下面这个式子。这个式子值最大的水平，就是后验概率最大的水平<br>
$$<br>
\delta_{k}(x)=x \cdot \frac{\mu_{k}}{\sigma^{2}}-\frac{\mu_{k}^{2}}{2 \sigma^{2}}+\log \left(\pi_{k}\right)<br>
$$<br>
假设 K=2，并且 π<sub>1</sub> = π<sub>2</sub> 。那么如果满足下面这个式子，则最终分配为水平1；否则则为水平2<br>
$$<br>
2 x\left(\mu_{1}-\mu_{2}\right)&gt;\mu_{1}^{2}-\mu_{2}^{2}<br>
$$<br>
在这种情况下，<abbr title="Bayes decision boundary">贝叶斯决策线</abbr> 为<br>
$$<br>
x=\frac{\mu_{1}^{2}-\mu_{2}^{2}}{2\left(\mu_{1}-\mu_{2}\right)}=\frac{\mu_{1}+\mu_{2}}{2} \text { . }<br>
$$<br>
但是在实际中， π<sub>k</sub> , μ<sub>k</sub> ， σ<sup>2</sup>  这些参数都是未知的，我们需要先估计这些常数，再估计 <em>p<sub>k</sub>(x)</em><br>
$$<br>
\begin{aligned}<br>
\hat{\mu}<em>{k} &amp;=\frac{1}{n</em>{k}} \sum_{i: y_{i}=k} x_{i} \<br>
\hat{\sigma}^{2} &amp;=\frac{1}{n-K} \sum_{k=1}^{K} \sum_{i: y_{i}=k}\left(x_{i}-\hat{\mu}<em>{k}\right)^{2}<br>
\end{aligned}<br>
$$<br>
这里 n 是所有的观测值数目，n<sub>k</sub> 是观测值为水平k 时的数目。至于 π<sub>k</sub> ，有先验就用，没有就从 training data 计算一下<br>
$$<br>
\hat{\pi}</em>{k}=n_{k} / n<br>
$$<br>
将上面的参数估计值带入下式，计算得到值最大的水平<br>
$$<br>
\hat{\delta}<em>{k}(x)=x \cdot \frac{\hat{\mu}</em>{k}}{\hat{\sigma}^{2}}-\frac{\hat{\mu}<em>{k}^{2}}{2 \hat{\sigma}^{2}}+\log \left(\hat{\pi}</em>{k}\right)<br>
$$<br>
为什么判别分析称为<strong>线性</strong>判别分析呢？因为 <em>discriminant functions</em> δ<sub>k</sub>(x) 是 x 的线性函数。</p>
<h2 id="p-1的线性判别分析-2">p&gt;1的线性判别分析</h2>
<p>我们现在看多个自变量的情况，并且这些自变量服从<strong>多元正态分布</strong>（每个变量均服从一维正态分布）， 下图为两个变量时服从多元正态分布的概率密度图。</p>
<p><img src="21.png" alt="1"></p>
<p>为了表示 p维的随机变量X 服从多元正态分布，我们写作<br>
$$<br>
X \sim N(\mu, \boldsymbol{\Sigma})<br>
$$<br>
其中，<em>μ</em> 为均值，是一个p维的向量。<br>
$$<br>
E(X)=\mu<br>
$$<br>
方差分布为 Σ , 为 <em>p × p</em> 的矩阵。</p>
<p>最后，多元正态分布定义为<br>
$$<br>
f(x)=\frac{1}{(2 \pi)^{p / 2}|\Sigma|^{1 / 2}} \exp \left(-\frac{1}{2}(x-\mu)^{T} \mathbf{\Sigma}^{-1}(x-\mu)\right)<br>
$$<br>
类似于p=1的判别分析，这里假定因变量所有水平的观测值均服从<strong>方差相同的</strong>多元正态分布。</p>
<p>p&gt;1的判别函数如下<br>
$$<br>
\delta_{k}(x)=x^{T} \boldsymbol{\Sigma}^{-1} \mu_{k}-\frac{1}{2} \mu_{k}^{T} \boldsymbol{\Sigma}^{-1} \mu_{k}+\log \pi_{k}<br>
$$<br>
以下图为例，作图是三种水平所有观测值结果，圆圈为95%的概率的范围，虚线为画出的贝叶斯决策线；右图为各随机抽取了20个样本的结果，实线为抽样结果的贝叶斯决策线。</p>
<p>个人理解：这张图给了我一个提示，<strong>分类变量的每个水平必须是能几乎截然分开的</strong>，才能进行分析。不然对于判别分析，无法画出决策线。所以我感觉进行分析前有必要先进行一下可视化，看一下分类变量的各个水平的设置是否合理，有没有两个水平实际是差不多同一个水平的情况。</p>
<p><img src="22.png" alt="1"></p>
<p>这里我们同样需要估计这些参数，类似于p=1的情况</p>
<p>从判别函数的形式看，判别函数依然是 X 的线性转换，这就是线性判别分析中线性的由来。</p>
<p>如果对信用卡违约的数据进行判别分析，因变量是<strong>是否违约</strong>，自变量是 <em>credit card balance</em> 和 <em>student status</em> ，通过对 10,000 个 traing samples 进行建模，我们得到的 <em>training error rate</em> 的结果是 2.75% 。这个结果看上去很好，但是有两个注意事项：</p>
<ol>
<li>首先，<em>training error rate</em>  通常会低于 <em>test error rate</em>，也就是说 test data 的结果通常会更差一点，这是因为我们是根据 <em>training data</em> 来拟合的模型参数。如果参数 p 除以 样本 n 的比例越高，我们可能越可能遇到<strong>过拟合</strong>问题。</li>
<li>其次，由于 <em>training data</em> 中只有3.33%的个体违约，因此一个最简单的 <em>classifier</em> 可以将所有个体都预测为不会违约，无论这个人的 credit card balance 和 student status 是什么情况，这个 <em>classifier</em> 的 <em>trainging error rate</em> 就是 3.33%。这种情况下仅仅比上面的 2.75% 略高。</li>
</ol>
<p>在实际情况中，一个二分类的 <em>classifier</em> 会产生两种错误：它可能将一个不违约的个体判定为违约，或者将违约的个体判定为不违约。这两种错误发生的原因，通常是需要关注的地方。我们一般会通过 <em><strong>confusion matrix</strong></em> 来查看一下，我们可以看到在真实为NO的个体中（9667），总共有23个个体是错误预测的，这看上去错误概率很低。但是，在总共333个违约个体中，总共有252（75.7%）的个体被错误预测为No。因此，<strong>虽然总的 <em>training error rate</em>  很低，但是针对违约的个体的<em>error rate</em> 很高</strong>。由于信用卡公司做预测的目的是为了确定高风险可能违约的用户，这种预测情况肯定是无法接受的。</p>
<p><img src="23.png" alt="1"></p>
<h3 id="sensitivity-和-specificity">sensitivity 和 specificity</h3>
<p>有两个概念可以说明一个 <em>classifier</em> 的表现， <em><strong>sensitivity</strong></em> 和 <em><strong>specificity</strong></em> 。在这个例子中，<em>sensitivity</em> 就是违约者被正确预测的概率，这里是24.3%；<em>specificity</em> 就是非违约者被正确预测的概率，这里是 99.8%。</p>
<p>为什么判别分析在违约个体的表现如此糟糕呢？或者说，为什么 <em>sensitivity</em> 如此低？如我们所见，判别分析会采用贝叶斯方法，会含有最低的 <em>total error rate</em> ，也就是说会产生最少的总的错误分类的数目，无论这些错误分类原本来自于哪个分类。但是基于信用卡公司的角度，肯定是希望尽量避免将会违约的个体判定为不会违约的错误，相比之下，将不会违约的个体判定为违约问题则没有那么严重。因此我们需要需改这个方法，来新建一个 <em>classifier</em> 来更好地符合信用卡公司的需求。</p>
<p>判别分析会将个体判定为<strong>后验概率最大</strong>的分类。在只有两种分类的情况下，一个观测值会判定为违约的公式如下（后验概率大于0.5）<br>
$$<br>
\operatorname{Pr}(\text { default }=\operatorname{Yes} \mid X=x)&gt;0.5<br>
$$<br>
这里默认阈值就是0.5，但是，如果我们特别关心将违约个体预测为非违约的情况，那么我们就可以降低这个阈值。例如如果后验概率超过0.2，我们就判定为违约，公式如下<br>
$$<br>
\operatorname{Pr}(\text { default }=\operatorname{Yes} \mid X=x)&gt;0.2<br>
$$</p>
<p>修改阈值后，预测结果如下，我们可以看到相比于上面的结果，违约个体预测错误下降，但是非违约个体的预测错误上升。总的预测错误轻微上升至3.73%。</p>
<p><img src="24.png" alt="1"></p>
<p>下图说明了修改违约后验概率阈值的 trade-off 结果。如果阈值设定为0.5，那么总的错误概率是最低的，如下图的黑线，但是违约个体的错误概率却是最高的，如蓝色虚线所示。</p>
<p><img src="25.png" alt="1"></p>
<p><abbr title="receiver operating characteristics">ROC</abbr>  曲线是用来展现不同的阈值下两种错误的错误概率的变化。下图就是 ROC 图 ，纵坐标是 <em>sensitivity</em> ，就是违约者被正确预测的概率；横坐标为 <em>1-specificity</em> ，为非违约者被错误预测的概率。这幅图不显示阈值。</p>
<p><img src="26.png" alt="1"></p>
<h3 id="一型错误和二型错误">一型错误和二型错误</h3>
<p>我们把上面的表格进行一般化，用 - 或 Null 表示零假设（本例为不违约），+ 或 Non-null 表示备择假设（本例为违约）。</p>
<p><img src="27.png" alt="1"></p>
<p>根据上面的表格，我们得到一些重要的统计量。</p>
<p><img src="28.png" alt="1"></p>
<h1><abbr title="Quadratic Discriminant Analysis,  QDA">二次判别分析</abbr></h1>
<p>线性判别分析假设所有水平的观测值均假设服从一个<strong>方差矩阵</strong>相同的<strong>多元正态分布</strong>。二次判别分析则假设所有水平的观测值均服从一个正态分布，但是不像线性判别分析，二次判别分析假设<strong>所有水平的方差矩阵各不相同</strong>。即对第k个水平的观测值的分布为：<br>
$$<br>
X \sim N\left(\mu_{k}, \Sigma_{k}\right)<br>
$$<br>
在这个假设下，判别函数如下。这个函数是 x 的二次函数，这就是二次判别分析名字的来源。<br>
$$<br>
\begin{aligned}<br>
\delta_{k}(x) &amp;=-\frac{1}{2}\left(x-\mu_{k}\right)^{T} \Sigma_{k}^{-1}\left(x-\mu_{k}\right)-\frac{1}{2} \log \left|\Sigma_{k}\right|+\log \pi_{k} \<br>
&amp;=-\frac{1}{2} x^{T} \Sigma_{k}^{-1} x+x^{T} \Sigma_{k}^{-1} \mu_{k}-\frac{1}{2} \mu_{k}^{T} \Sigma_{k}^{-1} \mu_{k}-\frac{1}{2} \log \left|\Sigma_{k}\right|+\log \pi_{k}<br>
\end{aligned}<br>
$$<br>
我们应该在什么情况下采用线性判别分析，什么情况下采用二次判别分析呢？这个答案在 <code>bias-variance trade-off</code> 中。二次判别分析需要估计的参数比线性判别分析多得多，如果我们有 p 个预测因子，那么估计线性分析的方差矩阵需要 <em>p(p+1)/2</em> 个参数；而二次判别分析需要对每个水平均要估计一个单独的方差矩阵，则总共需要 <em>Kp(p+1)/2</em> 个参数。因此二次判别分析更灵活，bias 比较低，但 variance 比较高。<strong>一般来说，当样本数量比较少时，推荐使用线性判别分析来降低 variance；如果样本数量非常大或者严重偏理所有水平同方差的假设，更推荐使用二次判别分析。</strong></p>
<p>下图说明了线性判别分析和二次判别分析在两种情况下的表现。</p>
<p><img src="29.png" alt="1"></p>
<h1>不同方法的比较</h1>
<p>逻辑回归和线性判别分析虽然思路不同，但却是紧密相关的。在线性判别分析的框架里，<em>log odds</em> 计算公式可简化如下（就是两个判别函数相减）：<br>
$$<br>
\log \left(\frac{p_{1}(x)}{1-p_{1}(x)}\right)=\log \left(\frac{p_{1}(x)}{p_{2}(x)}\right)=c_{0}+c_{1} x<br>
$$<br>
根据逻辑回归公式，<em>log odd</em> 可写为：<br>
$$<br>
\log \left(\frac{p_{1}}{1-p_{1}}\right)=\beta_{0}+\beta_{1} x<br>
$$<br>
这两种方法得到的 <em>log odd</em> 都是 x 的线性函数，因此这两种方法的决策边界均为直线。这两种方法唯一的区别在于 β0 和 β1 是通过最大似然得到的，而 c<sub>0</sub>  和 c<sub>1</sub> 是通过估计正态分布的均值和方差得到的。</p>
<p>由于这两种方法仅仅是拟合参数的过程有区别，因此这两种方法的结果往往是非常相似的，但偶尔可能情况不一样。线性判别分析由于存在<strong>同方差正态分布</strong>的假设，因此<strong>如果数据符合这个假设，那么结果可能比较好。相反，如果数据不符合这个假设，那么逻辑回归的结果会更好。</strong></p>
<p>而 KNN 方法但预测 X = x 的值时，会提取x附近的多个观测值，然后分配X为大多数观测值的结果。因此 KNN 方法是一种完全的非参数方法，没有对决策界限的任何假设。因此，如果只有当决策线是高度非线性的情况下，KNN 方法才可能由于线性判别方法和逻辑回归方法。另一方面，KNN 方面没有告诉我们哪些预测是重要的，哪些是不重要的。</p>
<p>最后，二次判别分析是 KNN 方法 和 LDA/逻辑回归方法 之间的折中方法，它的决策线是二次函数。</p>
<p>为了说明这四种方法的表型，ISL 书中模拟了六种情况，在前三种情况下，真实的决策线就是线性的，另外三种情况则是非线性的。对于每种情况下，均随机生成 100 个训练集，我们在每个训练集中拟合模型，然后计算一个很大的 <em>test data</em> 数据集的 <em>test error rate</em> 。</p>
<p>真实决策线是直线的三种情况画图如下：</p>
<p><img src="30.png" alt="1"></p>
<p>真实决策线不是直线的三种情况画图如下：</p>
<p><img src="31.png" alt="1"></p>
<p>其中，KNN 方法做了两次，一次 K = 1，一次 K 值通过 <em>cross validation</em> 获得。在所有的情况中，p 均等于2。</p>
<p>我们可以看到，如果真实的预测线是线性的，那么 LDA和逻辑回归方法较好；如果是非线性的，那么 QDA 方法更好。最后，对于非常复杂的预测线，那么非参方法，例如KNN方法更好，但是需要慎重选择平滑度。</p>
<p>最后，在线性回归中，我们可以通过对预测因子进行转换，来实现对非线性关系的模拟。我们同样可以在分类变量的分析中采用相同的操作，例如采用 X<sup>2</sup> , X<sup>3</sup>  等加入到逻辑回归 和 LDA分析中，这样可以实现类似与 QDA 的效果。</p>
<h1>R代码</h1>
<p>ISl 使用的数据是股票数据，Smarket data ，来自于 ISLR 包。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(ISLR)</span><br><span class="line"><span class="built_in">names</span>(Smarket)</span><br><span class="line"><span class="built_in">dim</span>(Smarket)</span><br><span class="line">summary(Smarket)</span><br></pre></td></tr></table></figure>
<p>使用 cor() 函数可以计算所有数据集的相关矩阵，所有变量必须为连续变量。</p>
<p>我们可以看到这里只有 Year 和 Volume 这两个变量之间存在实质相关。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; cor(Smarket)</span><br><span class="line">Error <span class="keyword">in</span> cor(Smarket) : <span class="string">&#x27;x&#x27;</span>必需为数值</span><br><span class="line">&gt; cor(Smarket[,-<span class="number">9</span>])</span><br><span class="line">             Year         Lag1         Lag2         Lag3         Lag4         Lag5      Volume</span><br><span class="line">Year   <span class="number">1.00000000</span>  <span class="number">0.029699649</span>  <span class="number">0.030596422</span>  <span class="number">0.033194581</span>  <span class="number">0.035688718</span>  <span class="number">0.029787995</span>  <span class="number">0.53900647</span></span><br><span class="line">Lag1   <span class="number">0.02969965</span>  <span class="number">1.000000000</span> -<span class="number">0.026294328</span> -<span class="number">0.010803402</span> -<span class="number">0.002985911</span> -<span class="number">0.005674606</span>  <span class="number">0.04090991</span></span><br><span class="line">Lag2   <span class="number">0.03059642</span> -<span class="number">0.026294328</span>  <span class="number">1.000000000</span> -<span class="number">0.025896670</span> -<span class="number">0.010853533</span> -<span class="number">0.003557949</span> -<span class="number">0.04338321</span></span><br><span class="line">Lag3   <span class="number">0.03319458</span> -<span class="number">0.010803402</span> -<span class="number">0.025896670</span>  <span class="number">1.000000000</span> -<span class="number">0.024051036</span> -<span class="number">0.018808338</span> -<span class="number">0.04182369</span></span><br><span class="line">Lag4   <span class="number">0.03568872</span> -<span class="number">0.002985911</span> -<span class="number">0.010853533</span> -<span class="number">0.024051036</span>  <span class="number">1.000000000</span> -<span class="number">0.027083641</span> -<span class="number">0.04841425</span></span><br><span class="line">Lag5   <span class="number">0.02978799</span> -<span class="number">0.005674606</span> -<span class="number">0.003557949</span> -<span class="number">0.018808338</span> -<span class="number">0.027083641</span>  <span class="number">1.000000000</span> -<span class="number">0.02200231</span></span><br><span class="line">Volume <span class="number">0.53900647</span>  <span class="number">0.040909908</span> -<span class="number">0.043383215</span> -<span class="number">0.041823686</span> -<span class="number">0.048414246</span> -<span class="number">0.022002315</span>  <span class="number">1.00000000</span></span><br><span class="line">Today  <span class="number">0.03009523</span> -<span class="number">0.026155045</span> -<span class="number">0.010250033</span> -<span class="number">0.002447647</span> -<span class="number">0.006899527</span> -<span class="number">0.034860083</span>  <span class="number">0.01459182</span></span><br><span class="line">              Today</span><br><span class="line">Year    <span class="number">0.030095229</span></span><br><span class="line">Lag1   -<span class="number">0.026155045</span></span><br><span class="line">Lag2   -<span class="number">0.010250033</span></span><br><span class="line">Lag3   -<span class="number">0.002447647</span></span><br><span class="line">Lag4   -<span class="number">0.006899527</span></span><br><span class="line">Lag5   -<span class="number">0.034860083</span></span><br><span class="line">Volume  <span class="number">0.014591823</span></span><br><span class="line">Today   <span class="number">1.000000000</span></span><br></pre></td></tr></table></figure>
<h2 id="逻辑回归">逻辑回归</h2>
<p><code>glm()</code> 函数使用广义线性模型，包括一系列模型，其中就有逻辑回归。这里我们通过指定 <code>family = binomial</code> 来指定使用逻辑回归。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; glm.fit = glm(Direction ~ Lag1+Lag2+Lag3+Lag4+Lag5+Volume, data=Smarket, family=binomial)</span><br><span class="line">&gt; summary(glm.fit)</span><br><span class="line"></span><br><span class="line">Call:</span><br><span class="line">glm(formula = Direction ~ Lag1 + Lag2 + Lag3 + Lag4 + Lag5 + </span><br><span class="line">    Volume, family = binomial, data = Smarket)</span><br><span class="line"></span><br><span class="line">Deviance Residuals: </span><br><span class="line">   Min      <span class="number">1</span>Q  Median      <span class="number">3</span>Q     Max  </span><br><span class="line">-<span class="number">1.446</span>  -<span class="number">1.203</span>   <span class="number">1.065</span>   <span class="number">1.145</span>   <span class="number">1.326</span>  </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">             Estimate Std. Error z value Pr(&gt;|z|)</span><br><span class="line">(Intercept) -<span class="number">0.126000</span>   <span class="number">0.240736</span>  -<span class="number">0.523</span>    <span class="number">0.601</span></span><br><span class="line">Lag1        -<span class="number">0.073074</span>   <span class="number">0.050167</span>  -<span class="number">1.457</span>    <span class="number">0.145</span></span><br><span class="line">Lag2        -<span class="number">0.042301</span>   <span class="number">0.050086</span>  -<span class="number">0.845</span>    <span class="number">0.398</span></span><br><span class="line">Lag3         <span class="number">0.011085</span>   <span class="number">0.049939</span>   <span class="number">0.222</span>    <span class="number">0.824</span></span><br><span class="line">Lag4         <span class="number">0.009359</span>   <span class="number">0.049974</span>   <span class="number">0.187</span>    <span class="number">0.851</span></span><br><span class="line">Lag5         <span class="number">0.010313</span>   <span class="number">0.049511</span>   <span class="number">0.208</span>    <span class="number">0.835</span></span><br><span class="line">Volume       <span class="number">0.135441</span>   <span class="number">0.158360</span>   <span class="number">0.855</span>    <span class="number">0.392</span></span><br><span class="line"></span><br><span class="line">(Dispersion parameter <span class="keyword">for</span> binomial family taken to be <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    Null deviance: <span class="number">1731.2</span>  on <span class="number">1249</span>  degrees of freedom</span><br><span class="line">Residual deviance: <span class="number">1727.6</span>  on <span class="number">1243</span>  degrees of freedom</span><br><span class="line">AIC: <span class="number">1741.6</span></span><br><span class="line"></span><br><span class="line">Number of Fisher Scoring iterations: <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看系数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; coef(glm.fit)</span><br><span class="line"> (Intercept)         Lag1         Lag2         Lag3         Lag4         Lag5       Volume </span><br><span class="line">-<span class="number">0.126000257</span> -<span class="number">0.073073746</span> -<span class="number">0.042301344</span>  <span class="number">0.011085108</span>  <span class="number">0.009358938</span>  <span class="number">0.010313068</span>  <span class="number">0.135440659</span></span><br><span class="line">&gt; summary(glm.fit)$coef</span><br><span class="line">                Estimate Std. Error    z value  Pr(&gt;|z|)</span><br><span class="line">(Intercept) -<span class="number">0.126000257</span> <span class="number">0.24073574</span> -<span class="number">0.5233966</span> <span class="number">0.6006983</span></span><br><span class="line">Lag1        -<span class="number">0.073073746</span> <span class="number">0.05016739</span> -<span class="number">1.4565986</span> <span class="number">0.1452272</span></span><br><span class="line">Lag2        -<span class="number">0.042301344</span> <span class="number">0.05008605</span> -<span class="number">0.8445733</span> <span class="number">0.3983491</span></span><br><span class="line">Lag3         <span class="number">0.011085108</span> <span class="number">0.04993854</span>  <span class="number">0.2219750</span> <span class="number">0.8243333</span></span><br><span class="line">Lag4         <span class="number">0.009358938</span> <span class="number">0.04997413</span>  <span class="number">0.1872757</span> <span class="number">0.8514445</span></span><br><span class="line">Lag5         <span class="number">0.010313068</span> <span class="number">0.04951146</span>  <span class="number">0.2082966</span> <span class="number">0.8349974</span></span><br><span class="line">Volume       <span class="number">0.135440659</span> <span class="number">0.15835970</span>  <span class="number">0.8552723</span> <span class="number">0.3924004</span></span><br></pre></td></tr></table></figure>
<h2 id="线性判别分析">线性判别分析</h2>
<p>我们可以用 MASS 包的 lda() 函数进行LDA分析。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; library(MASS)</span><br><span class="line">&gt; lda.fit = lda(Direction ~ Lag1 + Lag2, data=Smarket)</span><br><span class="line">&gt; lda.fit</span><br><span class="line">Call:</span><br><span class="line">lda(Direction ~ Lag1 + Lag2, data = Smarket)</span><br><span class="line"></span><br><span class="line">Prior probabilities of groups:</span><br><span class="line">  Down     Up </span><br><span class="line">0.4816 <span class="number">0.5184</span> </span><br><span class="line"></span><br><span class="line">Group means:</span><br><span class="line">            Lag1        Lag2</span><br><span class="line">Down  <span class="number">0.05068605</span>  <span class="number">0.03229734</span></span><br><span class="line">Up   -<span class="number">0.03969136</span> -<span class="number">0.02244444</span></span><br><span class="line"></span><br><span class="line">Coefficients of linear discriminants:</span><br><span class="line">            LD1</span><br><span class="line">Lag1 -<span class="number">0.7567605</span></span><br><span class="line">Lag2 -<span class="number">0.4707872</span></span><br></pre></td></tr></table></figure>
<p>这里提供了先验概率的估计值，每个水平均值的估计值。最后的 <em>Coefficients of linear discriminants</em> 提供了两个因子的线性组合，用于形成决策线。在本例中，就是下式<br>
$$<br>
-0.642 \times \operatorname{Lag} 1-0.514 \times \text { Lag } 2<br>
$$<br>
如果这个式子很大，那么就会预测为 Up，否则就预测为 down 。</p>
<h2 id="二次判别分析">二次判别分析</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; library(MASS)</span><br><span class="line">&gt; qda.fit &#x3D; qda(Direction ~ Lag1 + Lag2, data&#x3D;Smarket)</span><br><span class="line">&gt; qda.fit</span><br><span class="line">Call:</span><br><span class="line">qda(Direction ~ Lag1 + Lag2, data &#x3D; Smarket)</span><br><span class="line"></span><br><span class="line">Prior probabilities of groups:</span><br><span class="line">  Down     Up </span><br><span class="line">0.4816 0.5184 </span><br><span class="line"></span><br><span class="line">Group means:</span><br><span class="line">            Lag1        Lag2</span><br><span class="line">Down  0.05068605  0.03229734</span><br><span class="line">Up   -0.03969136 -0.02244444</span><br></pre></td></tr></table></figure>
<p>这里没有提供系数。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>《Bioinformatics Data Skills》读书笔记</title>
    <url>/posts/a96a52e9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这本书确实是强力推荐，作者的数据分析技巧和编程技巧均很高超，而且无论是务实还是务虚的部分（道和术）都总结得特别好。我读过一遍以后，刷新了我对很多东西的认知。</p>
<p>这本书分了三大章，第一章介绍数据分析和生信分析的“道”，建议认真阅读；第二章介绍基础技能，我印象最深刻的是讲 Git 的部分，讲解很清楚；第三章才是实际生物信息分析的部分，涉及到很多格式的文件的处理，比如FASTA文件啥的，对我这种生信小白很有帮助。</p>
<p>据说作者是在读硕士的时候写的这本书，真是令人汗颜！这本书的电子版可以在 <a href="http://libgen.rs/">libgen</a> 找到。</p>
<p>最后，最后附有<code>(好)</code> 字样的标题是我读的时候觉得办案叫绝的章节。</p>
<span id="more"></span>
<h1>第1部分 Ideology: Data Skills for Robust and Reproducible Bioinformatics</h1>
<h2 id="1-1-How-to-Learn-Bioinformatics">1.1 How to Learn Bioinformatics</h2>
<p>测序价格极速下降，导致测序数据数量激增。因此，做生信急需数据分析能力。</p>
<p>生信分析的软件众多，但面临两个问题：第一，没有校准（我的理解适合一个物种的软件，不见得适合另一种物种）；第二，可能有bug。因此，<strong>你需要做测试，能够看懂结果，并具有分析结果是否正确的能力</strong></p>
<h2 id="1-2-Reproducible-Research">1.2 Reproducible Research</h2>
<p>生信的东西很多时候难以重现，第一是测序太贵，不可能重复测序；第二是相同的数据，由于方法太多，步骤太大，参考基因组和软件、网站啥的又不断更新，因此也很难重现。</p>
<p>这里作者举了个例子，他和同事同时做一个RNA-seq的分析，发现找到的表达基因完全不同，找了半天也没找到原因，最后发现是<strong>使用R包的版本不同</strong>。</p>
<blockquote>
<p>he lesson here is that often replication, by either you in the  future  or  someone  else,  relies  on  not  just  data  and  code  but  details  like  software versions  and  when  data  was  downloaded  and  what  version  it  is.  This  metadata,  or data about data, is a crucial detail in ensuring reproducibility.</p>
</blockquote>
<p>在教授生物信息时，作者给出的黄金法则是</p>
<blockquote>
<p>Never ever trust your tools (or data)</p>
</blockquote>
<p>保持怀疑，保持验证。</p>
<h3 id="1-2-1-Adopting-Robust-and-Reproducible-Practices-Will-Make-Your-Life-Easier-Too">1.2.1 Adopting Robust and Reproducible Practices Will Make Your Life Easier, Too</h3>
<p>做生信分析，我保证你会经历下面两件事：</p>
<ul>
<li>rerun an analysis more than once，这可能是由于数据有变化、发现bug，想要更新流程等等</li>
<li>当你或别人回过头看你之前做的东西，会发现有些地方很怪。这时候你唯一可辩护的地方是拿出你当时做的每一步的文档。如果你没有记录一些重要的事实，你肯定会忘记。</li>
</ul>
<p>这要求两点：</p>
<ol>
<li>使用脚本处理</li>
<li><strong>步骤记录</strong></li>
</ol>
<h2 id="1-3-Recommendations-for-Robust-Research">1.3 Recommendations for Robust Research</h2>
<h3 id="1-3-1-Pay-Attention-to-Experimental-Design">1.3.1 Pay Attention to Experimental Design</h3>
<h3 id="1-3-2-Write-Code-for-Humans-Write-Data-for-Computers">1.3.2 Write Code for Humans, Write Data for Computers</h3>
<p>调试代码比写代码更难，因为需要人去调试代码，因此代码要具有可读性。</p>
<p>为什么代码可读性很重要：</p>
<blockquote>
<p>First, readable  code  makes  projects  more  reproducible,  as  others  can  more  easily  understand what scripts do and how they work. Second, it’s much easier to find and correct software bugs in readable, well-commented code than messy code. Third, revisiting code in  the  future  is  always  easier  when  the  code  is  well  commented  and  clearly  written.</p>
</blockquote>
<h3 id="1-3-3-Make-Assertions-and-Be-Loud-in-Code-and-in-Your-Methods">1.3.3 Make Assertions and Be Loud, in Code and in Your Methods</h3>
<p>通常来说，我们对拿到的数据有一些潜在的假设。比如基因的起始位置要小于结束位置、物理位置不能为负值。这些假设影响了我们写代码，在我们写的代码中我们可能从没想过如果不满足这些假设该怎么处理（说白了，就是我们写代码可能没有考虑这些假设，如果不满足这些假设，实际上是不能运行的）。不幸的是，这会导致致命的<strong>silent error</strong>：  our  code  or  programs  receive  values  outside  our  expected  values,  behave improperly,  and  yet  still  return  output  without  warning.</p>
<p>一个最好的办法就是使用 assert 功能 判断数据是否符合这些假设（Python’s assert() and R’s stopifnot()）</p>
<p>不同的语言都有自己的assert 函数，而且功能都相同：如果判断为false，那么程序会停止运行，抛出一个error。</p>
<blockquote>
<p>Early  in  my  career,  a  mentor motivated me to adopt the habit of using asserts quite liberally—even when it seems like there is absolutely no way the statement could ever be false—and yet I’m continually  surprised  at  how  many  times  these  have  caught  a  subtle  error.</p>
<p><strong>In  bioinformatics (and  all  fields),  it’s  crucial  that  we  do  as  much  as  possible  to  turn  the  dreaded  silent error into loud errors.</strong></p>
</blockquote>
<h3 id="1-3-4-Test-Code-or-Better-Yet-Let-Code-Test-Code">1.3.4 Test Code, or Better Yet, Let Code Test Code</h3>
<p>就是说为了检验一段代码，编写另一段代码去检验它，而不是自己亲自动手检验</p>
<p>In  practice,  this  means  if  we  have  a  function  called  add(),  we  write  an  additional function (usually in separate file) called test_add(). This test_add() function would  call  the  add()  function  with  certain  input,  and  test  that  the  output  is  as expected. In Python, this may look like:</p>
<p><img src="1.png" alt=""></p>
<h4 id="当你写代码时，需要考虑下面三个问题">当你写代码时，需要考虑下面三个问题</h4>
<ul>
<li>这段代码被其他代码引用的次数有多高？</li>
<li>如果这段代码有误，对最终结果的影响有多大</li>
<li>如果错误发生，错误提示有多明显？</li>
</ul>
<p>前两个问题决定了测试这段代码的重要性；第三个问题决定测试的比例（如果报错很明显，也不用去测试）。</p>
<h3 id="1-3-5-Use-Existing-Libraries-Whenever-Possible">1.3.5 Use Existing Libraries Whenever Possible</h3>
<p>Existing open source libraries have two advantages over libraries you write yourself: a</p>
<p>longer history and a wider audience. Both of these advantages translate to fewer bugs.</p>
<p>自己写的代码存在两个问题：</p>
<ol>
<li>没有其他人帮你找bug</li>
<li>你可能没有考虑到所有可能的情况。</li>
</ol>
<h3 id="1-3-6-Treat-Data-as-Read-Only-（好）">1.3.6 Treat Data as Read-Only （好）</h3>
<p>**很多科学家用Excel，很可能不小心改变了一个单元格的数值，然后保存了。**作者强烈不建议在Excel 中修改数据。<strong>相反，应该把所有的数据均视为只读数据，只允许用代码读取数据，然后创造新的结果文件。</strong></p>
<p>为什么这么做？首先，直接修改数据可以会导致不好的结果。比如，你写了一个代码，直接修改源文件，但是在运行过程中，出现错误程序崩了。由于初始文件已经改变了，这就造成了不可逆的结果，没法再用了（除非你有备份）</p>
<p>其次，<strong>当我们原地修改一个文件时，我们很容易忘记当时是怎么修改的</strong>（确实是这样，特别是在excel里）。不像在使用代码的流程中，每一步都有input file 和 output file。原地修改文件后，重新打开文件，我们不知道我们改了啥，这种改变是<strong>不能再现的</strong>。</p>
<p>很棒的想法。我之前在excel 整理表型数据，看来是错了。</p>
<blockquote>
<p>Treating data as read-only may seem counterintuitive to scientists familiar with working extensively in Excel, but it’s essential to robust research (and prevents catastrophe, and  helps  reproducibility).  The  initial  difficulty  is  well  worth  it;  in  addition  to  safe-guarding  data  from  corruption  and  incorrect  changes,  it  also  fosters  reproducibility. Additionally,  any  step  of  the  analysis  can  easily  be  redone,  as  the  input  data  is unchanged by the program.</p>
</blockquote>
<h3 id="1-3-7-Spend-Time-Developing-Frequently-Used-Scripts-into-Tools">1.3.7 Spend Time Developing Frequently Used Scripts into Tools</h3>
<p>对于经常使用的脚本，建议写成 tools 。作者对 tool 的定义是： They are well documented,  have  explicit  versioning,  have  understandable  command-line  arguments,  and  are  kept  in  a  shared  version  control  repository。</p>
<p>说白了，就是要robust 、 要有足够的文档解释、用户友好。</p>
<h3 id="1-3-8-Let-Data-Prove-That-It’s-High-Quality">1.3.8 Let Data Prove That It’s High Quality</h3>
<p>exploratory  data  analysis (探索性数据分析)</p>
<h2 id="1-4-Recommendations-for-Reproducible-Research">1.4 Recommendations for Reproducible Research</h2>
<p>可重复是说<strong>当你做完一项工作很久之后，你可能都忘了细节，这时如果你还需要重新跑一遍时的难易程度</strong>（这个定义比较好）</p>
<h3 id="1-4-1-Release-your-code-and-data">1.4.1 Release your code and data</h3>
<h3 id="1-4-2-Document-everything（好）">1.4.2 Document everything（好）</h3>
<p>**当一个新人进入实验室，他们被告知的第一件事就是保留一个实验记录本。**当很可惜的是，这个好的习惯在数据计算领域被抛弃了。给出代码和数据是结果重现的必要条件，但是足够的记录也是结果可重现的重要成分。为了完整的重现一个研究，分析的每一步都必须足够详细的描述（甚至要超过学术论文的描述）</p>
<p>一个好的习惯是把你的每一步操作都记录在一个<strong>README</strong>的文本文件中，就像一个详细的实验记录本一样，包括了有哪些准备文件，来自哪里，有哪些内容。这个文本文件中还要包括每个软件执行时的参数，软件版本，然后怎么运行的（对我而言，就是命令+软件版本）。</p>
<h3 id="1-4-3-Make-Figures-and-Statistics-the-Results-of-Scripts-（好）">1.4.3 Make Figures and Statistics the Results of Scripts （好）</h3>
<blockquote>
<p>Ensuring that a scientific project is reproducible involves more than just replicability of  the  key  statistical  tests  important  for  findings—supporting  elements  of  a  paper (e.g.,  figures  and  tables)  should  also  be  reproducible.  The  best  way  to  ensure  these components are reproducible is to have each image or table be the output of a script (or scripts).</p>
</blockquote>
<p>这段话的意思是，为了真正的重现每一步，图片和表格也应该是用代码生成的（而不是手动生成的）。</p>
<p><strong>用代码生成图片或者表格可能比在 R 或 excel 里互动地生成这些东西更加耗时</strong>。但是如果你体验需要重新手动生成很多图片时（改了前面的某个步骤），你就会知道这样做的好处。如果你用代码生成图片和代码，可以很轻松地重新跑，节约时间。</p>
<h3 id="1-4-4-Use-Code-as-Documentation">1.4.4 Use Code as Documentation</h3>
<p>对于复杂流程，可能最好的说明文档就是<strong>well-documented code</strong>。</p>
<p>这里就是说一个总的程序（比如sh程序），把所有用到的步骤都串起来，但是要有足够多的注释。</p>
<h1>第2部分 Prerequisites: Essential Skills for Getting Started with a Bioinformatics Project</h1>
<h2 id="2-1-Project-Directories-and-Directory-Structures">2.1 Project Directories and Directory Structures</h2>
<p><strong>一个管理良好的目录结构是生信项目可重复的基础</strong>。</p>
<p>首先，把一个项目的所有文件都放在一个文件夹中。</p>
<p><strong>个人感觉，文件夹深度最好不要超过两层。</strong></p>
<h3 id="2-1-1-What’s-in-a-Name">2.1.1 What’s in a Name?</h3>
<p>给文件或文件夹起名这件事很重要。比如有些人起名时存在空格，这在linux系统内绝对不允许，因为linux是通过空格分隔参数的。</p>
<p>在项目中，代码中经常需要引用其他文件（如数据），如果需要引用其他文件夹的文件，如果你的文件管理很规范，那么<strong>尽量使用相对路径，而不是绝对路径</strong>，因为<strong>绝对路径和你的账户名和目录结构有关</strong>，使得你的工作移植性变差。</p>
<h2 id="2-2-Project-Documentation">2.2 Project Documentation</h2>
<p>除了良好的目录结构外，你还需要良好的记录。记录的方法如下</p>
<ol>
<li>
<p>记录下你的所有方法和workflows</p>
<p><strong>需要把所有的在shell中运行的命令行复制粘贴到文档中</strong>。记录下所有的步骤和参数。</p>
</li>
<li>
<p>记录下你项目中所有数据的来源</p>
<p>不仅仅是实验数据，还包括别人发你的数据，参考基因组等。如果是从网上下载的，需要附上链接。</p>
</li>
<li>
<p>记录下你下载数据的时间</p>
<p>当你从晚上或服务器下载数据时，这个链接的数据将来可能会改变。</p>
</li>
<li>
<p>记录下数据版本信息</p>
</li>
<li>
<p>记录下你下载数据的方式</p>
</li>
<li>
<p>记录下你使用软件的版本（重要）</p>
<p>很多软件通过命令行就能查询版本。如果没有版本，记录下<strong>发行日期，软件链接，下载日期</strong>。</p>
</li>
</ol>
<p>所有的这些信息最好都存储在一个文本格式的README文件。文本文件没有格式，这样在复制命令并重新运行的时候不会出问题。<strong>不要使用word这种带有格式的文件</strong>。</p>
<p>README文件最好放在项目的主文件夹中。下面的描述我感觉真的是<strong>人间真实</strong>。</p>
<blockquote>
<p>These README files don’t necessarily need  to  be  lengthy,  but  they  should  at  the  very  least  explain  what’s  in  this  directory and how it got there. Even this small effort can save someone exploring your project directory a lot of time and prevent confusion. This someone could be your advisor or a  collaborator,  a  colleague  trying  to  reproduce  your  work  after  you’ve  moved  onto  a different lab, or even yourself six months from now when you’ve completely forgotten what you’ve done (this happens to everyone!)</p>
</blockquote>
<p>即使你觉得你能记住所有的数据信息，把所有的信息直接丢到README文件中更简单（当其他人看你做的东西，也不需要给你打电话或发邮件）。</p>
<h2 id="2-3-Use-Directories-to-Divide-Up-Your-Project-into-Subprojects">2.3 Use Directories to Divide Up Your Project into Subprojects</h2>
<h2 id="2-4-Organizing-Data-to-Automate-File-Processing-Tasks">2.4 Organizing Data to Automate File Processing Tasks</h2>
<p>文件命名要规律，方便使用程序自动化运行。</p>
<p>比如有三个玉米样本，A，B，C，各有两个read，可以这么命名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ touch seqs&#x2F;zmays&#123;A,B,C&#125;_R&#123;1,2&#125;.fastq</span><br><span class="line">$ ls</span><br><span class="line">zmaysA_R1.fastq zmaysB_R1.fastq zmaysC_R1.fastq</span><br><span class="line">zmaysA_R2.fastq zmaysB_R2.fastq zmaysC_R2.fastq</span><br><span class="line">#如果你要查找B样本的所有数据，可以使用通配符</span><br><span class="line">$ ls zmaysB*</span><br></pre></td></tr></table></figure>
<p>使用通配符查找文件，这个功能非常强大。</p>
<p>但是如果你的文件命名不一致，通配符就无用了。比如zmays sampleA - 1.fastq, zmays_sampleA-2.fastq,  sampleB1.fastq, sample-B2.fastq。</p>
<h3 id="2-4-1-Leading-Zeros-and-Sorting-文件命名补0-（好）">2.4.1 Leading Zeros and Sorting (文件命名补0)（好）</h3>
<p>如果你的文件名为gene-1.txt, gene-2.txt, ……， gene-14.txt，查找和排序顺序就会是下面这种</p>
<p><img src="2.png" alt="2"></p>
<p>一个有效的方法是开头补0（比如 001 002 014），这样文件就会按正确的顺序排序。</p>
<p>这种方法不仅仅是对于文件命名有用，对于命名基因等也很有用，比如<strong>Ensembl就用这种方式命名基因</strong>（如 ENSG00000164256 ）</p>
<p><img src="3.png" alt="2"></p>
<h2 id="2-5-Markdown-for-Project-Notebooks">2.5 Markdown for Project Notebooks</h2>
<p>项目笔记里要包括计算步骤、为什么这么做的详细信息。</p>
<h3 id="2-5-1-Markdown-Formatting-Basics">2.5.1 Markdown Formatting Basics</h3>
<h3 id="2-5-2-Using-Pandoc-to-Render-Markdown-to-HTML">2.5.2 Using Pandoc to Render Markdown to HTML</h3>
<p>把markdown 转化为html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pandoc --from markdown --to html notebook.md &gt; output.html</span><br></pre></td></tr></table></figure>
<h1>3 Remedial Unix Shell</h1>
<h2 id="3-1-Why-Do-We-Use-Unix-in-Bioinformatics-Modularity-and-the-Unix-Philosophy">3.1 Why Do We Use Unix in Bioinformatics? Modularity and the Unix Philosophy</h2>
<h3 id="Unix-哲学">Unix 哲学</h3>
<p>即模块化开发。Unix 还有一个好处就是兼容各种语言和工具。</p>
<blockquote>
<p>This  is  the  Unix  philosophy:  Write  programs  that  do  one  thing  and  do  it  well.  Write programs  to  work  together.  Write  programs  to  handle  text  streams,  because  that  is  a universal interface.</p>
<p>​																									                                                 —Doug McIlory</p>
</blockquote>
<blockquote>
<p>Unix  was  not  designed  to  stop  its  users  from  doing  stupid  things,  as  that  would  also stop them from doing clever things.</p>
<p>​																																				     —Doug Gwyn</p>
</blockquote>
<h4 id="tail-f">tail -f</h4>
<p>监视重定向的<strong>标准错误文件</strong>。</p>
<p>-f 选项 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。</p>
<h4 id="管道（pipe）">管道（pipe）</h4>
<p>上一个文件的标准输出是下一个文件的标准输入，但是<strong>标准错误还是打印在屏幕上</strong>。管道符不会处理标准错误信息</p>
<p>为什么通过管道符来连接两个程序？而不是把上一个程序的结果写入到一个文件中，然后再由另一个程序读取呢？在很多情况下，生成中间文件有利于debug。</p>
<p>管道符的优点在于计算效率上：<strong>读取和写入文件很耗时</strong>。使用管道符，一直是在内存中读取数据，<strong>而内存读取的速度远快于磁盘</strong>。</p>
<p><strong>实践中，写入和读取数据通常是数据处理的瓶颈</strong>。</p>
<blockquote>
<p>In  practice,  writing  or  reading  from  a  disk  (e.g.,  during  redirection  of standard  output  to  a  file)  is  often  a  bottleneck  in  data  processing.  For  large  next-generation sequencing  data,  this  can  slow  things  down  quite  considerably.  If  you  implement  a clever algorithm that’s twice as fast as an older version, you may not even notice the difference if the true bottleneck is reading or writing to the disk. Additionally, unnecessarily  redirecting  output  to  a  file  uses  up  disk  space.  With  large  next-generation data and potentially many experimental samples, this can be quite a problem.</p>
</blockquote>
<blockquote>
<p>Pipes allow us to build larger, more complex tools from smaller modular parts. It  doesn’t  matter  what  language  a  program  is  written  in,  either;  pipes  will  work between  anything  as  long  as  both  programs  understand  the  data  passed  between them</p>
</blockquote>
<h5 id="实践">实践</h5>
<p>需求：在 FASTA 文件中存在非ATGC的字符，找到这些字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -v &quot;^&gt;&quot; tb1.fasta | \</span><br><span class="line">grep --color -i &quot;[^ATCG]&quot;  </span><br></pre></td></tr></table></figure>
<p>第一句找出不是以 &gt; 开头的行（-v 反转）</p>
<p>\ <strong>反斜杠断行，提高可读性</strong></p>
<p>第二句找出存在非ATGC的行，-i 忽视大小写 --color 用颜色标记匹配上的字符</p>
<p><strong>grep中的查找部分最好加上双引号</strong>，这样能与其他部分区分。</p>
<h4 id="合并管道符和重定向-好">合并管道符和重定向 (好)</h4>
<p>假如我们有两个程序，program1 和 program2 ，program 2 使用 program1 的结果文件作为输入文件，但是这两个程序的标准错误文件都会打印到屏幕上，这会导致屏幕上的信息非常乱。我们可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">program1 input.txt 2&gt; program1.stderr  | \      </span><br><span class="line">program2 2&gt; program2.stderr &gt; results.txt </span><br></pre></td></tr></table></figure>
<h4 id="管道符生成中间文件-tee">管道符生成中间文件 - tee</h4>
<p>管道符本身是不生成中间文件的。但是有时候需要生成中间文件，一是为了 debug ；二是为了 存储耗时比较长的步骤的中间文件（说白了，就是避免报错后完全从头开始）</p>
<p>使用 tee 命令可以做到（翻译成中文是三通管），就像是水管的三通管（T形管）一样，tee 命令一方面将结果传给标准输出，一方面备份生成中间文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">program1 input.txt | tee intermediate-file.txt | program2 &gt; results.txt</span><br></pre></td></tr></table></figure>
<h4 id="后台程序">后台程序</h4>
<h4 id="">&amp;</h4>
<p>这个会打印出来一个 process ID (PID)，这个问题是<strong>如果终端关闭，这个程序也会关闭</strong>。</p>
<blockquote>
<p>Whenever  our  terminal  window  closes,  it  sends  a  hangup signal. Hangup  signals  (also  know  as  SIGHUP)  are  from  the  era  in  which network  connections  were  much  less  reliable.  A  dropped  connection  could  prevent  a  user  from  stopping  an  aberrant,  resource-hungry  process.  To  address  this,  the  hangup  signal  is  sent  to  all processes started from closed terminal. Nearly all Unix command-line programs stop running as soon as they receive this signal. So beware—running a process in the background does not guarantee that it won’t die when your terminal closes. To prevent this, we need to use the tool  nohup or run it from within Tmux.</p>
</blockquote>
<p>这段没看懂，大概是说终端关闭时，会发送一个挂起信号（hangup）。所有的程序接到这个信号就会关闭。</p>
<p>nohup 原来就是不挂起的意思</p>
<h4 id="前台转后台">前台转后台</h4>
<p>第一步先暂停（suspend , 使用快捷键 ctrl + z），第二步使用 bg 命令（background）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ program1 input.txt &gt; results.txt # forgot to append ampersand</span><br><span class="line">$ # enter control-z</span><br><span class="line">[1]+  Stopped                  program1 input.txt &gt; results.txt</span><br><span class="line">$ bg</span><br><span class="line">[1]+ program1 input.txt &gt; results.txt</span><br></pre></td></tr></table></figure>
<h4 id="退出状态">退出状态</h4>
<p>程序退出状态的好处在于运行下一个程序前可以先检查上一个程序的退出状态，如果正常，再进行下一步。</p>
<p>&amp;&amp; 符号 只有前面的程序退出状态是0时，才执行下一步的程序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ program1 input.txt &gt; intermediate-results.txt &amp;&amp; \    </span><br><span class="line">	program2 intermediate-results.txt &gt; results.txt</span><br></pre></td></tr></table></figure>
<p>|| 符号 只有前面的程序运行失败时，才运行下一步，这个用于提示警告信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ program1 input.txt &gt; intermediate-results.txt || \    </span><br><span class="line">	echo &quot;warning: an error occurred&quot;</span><br></pre></td></tr></table></figure>
<p>我觉得这两个都用不上。反正我没有这个习惯，毕竟报错了下一步肯定也运行不下去。这里感觉可读性也不好。</p>
<h4 id="命令替换">命令替换 $()</h4>
<p>这里其实是替换为 $() 中程序运行的结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep -c &#39;^&gt;&#39; input.fasta </span><br><span class="line">416</span><br><span class="line">$ echo &quot;There are $(grep -c &#39;^&gt;&#39; input.fasta) entries in my FASTA file.&quot;</span><br><span class="line">There are 416 entries in my FASTA file</span><br></pre></td></tr></table></figure>
<h5 id="date-创建文件夹">$() + date 创建文件夹</h5>
<p>有一个妙用是按日期创建文件夹（正好满足规范命名的要求，而且 ls 会按日期顺序排列）</p>
<p>这个我可以用 “项目号+日期” 来命名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir results-$(date +%F)</span><br><span class="line">$ ls results-2015-04-13</span><br></pre></td></tr></table></figure>
<h5 id="存储别名（不好）">存储别名（不好）</h5>
<p>你可以将常用的命令用 alias 命令设置个别名，然后把这条命令放在 ~/.bashrc 文件中。</p>
<p>比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alias mkpr&#x3D;&quot;mkdir -p &#123;data&#x2F;seqs,scripts,analysis&#125;&quot;</span><br><span class="line"></span><br><span class="line">alias today&#x3D;&quot;date +%F&quot;</span><br><span class="line"># mkdir results-$(today) </span><br></pre></td></tr></table></figure>
<p>但是，这种做法不要用在脚本中，因为不可移植。</p>
<h1>4 Working with Remote Machines</h1>
<h2 id="4-1-Connecting-to-Remote-Machines-with-SSH">4.1 Connecting to Remote Machines with SSH</h2>
<p>连接远方的服务器最常见的方法是通过 secure shell (SSH)。ssh 首先是安全，其次是在每个UNIX 系统都存在。</p>
<p>第一次使用ssh连接远方的主机时，我们使用如下命令：你需要输入你远方主机账号的密码</p>
<p>ssh 直接输入 ip地址，比如 192.169.237.42；如果你的服务器使用的端口不同（默认22），可以通过 -p 选项修改；如果你远方服务器使用的账号名称和你本地的账号名称不一样，你需要指定账号名称。如果你连接不上远方服务器，你可以使用 -v (冗长信息)选项</p>
<p><img src="12.png" alt=""></p>
<p><img src="13.png" alt=""></p>
<h3 id="4-1-1-Storing-Your-Frequent-SSH-Hosts-好">4.1.1 Storing Your Frequent SSH Hosts (好)</h3>
<p>经常输入IP地址啥的，让人很烦。你可以使用 SSH config file 来储存常用的 host 信息。（这个文件还可以用于 scp 和 rsync 命令）</p>
<p>首先创建文件 ~/.ssh/config</p>
<p>每个目录按照下面这种形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host bio_serv</span><br><span class="line">	 HostName 192.168.237.42     </span><br><span class="line">	 User cdarwin     </span><br><span class="line">	 Port 50453</span><br></pre></td></tr></table></figure>
<p>之后你就可以不用指定port 和 user 。直接使用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh bio_serv</span><br></pre></td></tr></table></figure>
<p>如果你连上了很多个服务器，你可能想知道 hostname ，来确认现在在哪个服务器中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hostname </span><br><span class="line">hostname -i #ip地址</span><br></pre></td></tr></table></figure>
<p>hostname 和 IP地址的区别</p>
<blockquote>
<p>hostname是主机名，用于在系统上标bai识一台机器； IP地址是在tcp/ip网络中du唯一标志一台机器。zhi联系到实际生活。主机dao名相当于你家的主人名，如张三家；而IP地址相当于小区内你家的门牌号，如30号楼2单元302。</p>
</blockquote>
<h2 id="4-2-Quick-Authentication-with-SSH-Keys">4.2 Quick Authentication with SSH Keys</h2>
<p>每次登录远方的账户都要输入密码，这很麻烦，而且可能不安全（可能有人看到你敲键盘，然后记住了）（大神真是严谨！）</p>
<p>一个更安全更快的方式是使用 <strong>SSH public key</strong>。这个好像和密码学有关系。</p>
<p>首先我们需要通过 <strong>ssh-keygen</strong> 命令 创建一个 public/private key pair 。公钥和私钥的区别在于你可以把公钥分享给其他的servers，但是私钥是不能分享的。</p>
<p>这个命令可以不加任何参数，直接加一个-o选项（提高安全性，描述的意思是降低了暴力破解的难度）</p>
<p>然后就会在 ~/.ssh 目录下生成 id_rsa （私钥）和 id_rsa.pub （公钥）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -o</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-o      Causes ssh-keygen to save private keys using the new OpenSSH format<br>
rather than the more compatible PEM format.  The new format has<br>
increased resistance to brute-force password cracking but is not sup‐<br>
ported by versions of OpenSSH prior to 6.5.  Ed25519 keys always use<br>
the new private key format.</p>
<pre><code>  														-- man ssh-keygen
</code></pre>
</blockquote>
<p>为了可以登录你的远方账号而不输入密码，第一步先正常输入密码登录你的远方账号，然后切换目录到 ~/.ssh，然后把你本地目录下的公钥的内容（id_rsa.pub）<strong>追加到</strong> 远方账号的~/.ssh/authorized_keys 文件中（这个文件不存在怎么办？）。</p>
<blockquote>
<p>Again,  be  sure  you’re  using  your  public  key,  and  not  the  private  key.  If  your  private key  ever  is  accidentally  distributed,  this  compromises  the  security  of  the  machines you’ve  set  up  key-based  authentication  on.  The   ~/.ssh/id_rsa private  key  has  read/write  permissions  only  for  the  creator,  and  these  restrictive  permissions  should  be kept this way</p>
</blockquote>
<p>最后一步看不懂，不知道啥意思。这一步完了，之后就不用输入密码了。</p>
<p><img src="14.png" alt=""></p>
<h2 id="4-3-Maintaining-Long-Running-Jobs-with-nohup-and-tmux">4.3 Maintaining Long-Running Jobs with nohup and tmux</h2>
<p>SSH 的方式应该是通过网络的方法连接到服务器，如果网断了，就连不上了，正在跑的程序也中断了（这个时候要用nohup）</p>
<p>使用nohup 的时候<strong>最好把标准输出和标准错误都重定向</strong>（默认是标准输出和标准错误均<strong>追加</strong>到nohup.out，如果重复运行这个程序，nohup.out 会比较乱）。第二，是记录下PID（这是终端关闭后唯一能找到程序的办法）</p>
<p>jobs -l 只能看到当前终端生效的，关闭终端后，在另一个终端jobs已经无法看到后台跑得程序了，此时利用ps（进程查看命令）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -aux|grep chat.js</span><br><span class="line">ps -aux|grep chat.js| grep -v grep</span><br><span class="line">ps -aux|grep chat.js| grep -v grep | awk &#39;&#123;print $2&#125;&#39;</span><br></pre></td></tr></table></figure>
<h2 id="4-4-Working-with-Remote-Machines-Through-Tmux">4.4 Working with Remote Machines Through Tmux</h2>
<p>nohup 的一个替代方法是使用 <strong>terminal multiplexer</strong>。这里我们使用的是 Tmux，但是更流行的是 GNU Screen。这个适合用于远程服务器，所有打开的窗口都是persistent，无论断网或者你自己关闭窗口，都不会影响程序的运行。</p>
<p>之后再看。</p>
<h3 id="4-4-1-Installing-and-Configuring-Tmux">4.4.1 Installing and Configuring Tmux</h3>
<h3 id="4-4-2-Creating-Detaching-and-Attaching-Tmux-Sessions">4.4.2 Creating, Detaching, and Attaching Tmux Sessions</h3>
<h3 id="4-4-3-Working-with-Tmux-Windows">4.4.3 Working with Tmux Windows</h3>
<h1>5 Git for Scientists</h1>
<h2 id="5-1-Basic-Git-Creating-Repositories-Tracking-Files-and-Staging-and-Committing-Changes">5.1 Basic Git: Creating Repositories, Tracking Files, and Staging and Committing Changes</h2>
<p>首先告诉GIT 你是谁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;Sewall Wright&quot;</span><br><span class="line">$ git config --global user.email &quot;swright@adaptivelandscape.org&quot;</span><br></pre></td></tr></table></figure>
<p>GIT 可以通过颜色显示变化（例如红色表示删除，绿色表示新增或修改）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global color.ui true</span><br></pre></td></tr></table></figure>
<h3 id="5-1-1-git-init-and-git-clone-Creating-Repositories">5.1.1 git init and git clone: Creating Repositories</h3>
<p>为了开始使用git，我们需要新建一个文件夹（git repository）。一个 repository 就是一个处于版本控制下的目录，包括当前的文件和过去某个时间节点的快照。这些快照用行话来说就是<strong>commits</strong>。</p>
<blockquote>
<p>With Git, there are two primary ways to create a repository: by initializing one from an  existing  directory,  or  cloning  a  repository  that  exists  elsewhere.  Either  way,  the result is a directory that Git treats as a repository. Git only manages the files and subdirectories  inside  the  repository  directory—it  cannot  manage  files  outside  of  your repository.</p>
</blockquote>
<p><strong>git init</strong></p>
<pre><code>1.  先cd到需要的位置
2.  git init
</code></pre>
<p><strong>git clone</strong></p>
<p>github 是固定格式 <em>user/repository</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git:&#x2F;&#x2F;github.com&#x2F;user&#x2F;repository.git</span><br></pre></td></tr></table></figure>
<h3 id="5-1-2-Tracking-Files-in-Git-git-add-and-git-status-Part-I">5.1.2 Tracking Files in Git: git add and git status Part I</h3>
<p>虽然你创建了repository ，但git并不会跟踪所有的文件（必须手动 git add）。<strong>这一点在生信项目中很有用，生信项目中有很多我们不想追踪的文件，包括数据文件、中间结果文件等</strong>。</p>
<p>在追踪文件中，我们先通过命令<code>git status</code>来查看repo（个人之后用repo作为repository的简写）的状态</p>
<p><img src="4.png" alt=""></p>
<p>然后使用 git add 加入需要追踪的文件（一行可以添加多个文件）</p>
<h3 id="5-1-3-Staging-Files-in-Git-git-add-and-git-status-Part-II">5.1.3 Staging Files in Git: git add and git status Part II</h3>
<p>这里的stage file 的意思是之前使用git add 追踪的文件，如果修改git不会自动获取，还需要进行git add，这就叫做 staging (应该就是暂存的意思)</p>
<blockquote>
<p>Part of the confusion lies in the fact that <strong>git add</strong> both tracks new files and stages the changes made to tracked files.</p>
</blockquote>
<p><img src="5.png" alt=""></p>
<p>如果我们更改了跟踪的文件，而没有进行<code>git add</code>，使用 <code>git status</code>查看结果如下：</p>
<p>提示 README 文件当前状态是 <strong>“Changes not staged for commit”</strong></p>
<p>如果这个时候进行 <code>git commit</code>提交的就是旧的 README 文件，而不是新的文件。</p>
<p><img src="6.png" alt=""></p>
<p>这个给我的提示就是常用<code>git status</code>命令。</p>
<blockquote>
<p>It’s  important  to  be  aware  that  any  modifications  made  to  a  file  since  the  last  time  it was  staged  will  not  be  included  in  the  next  commit  unless  they  are  staged  with  git add.  This  extra  step  may  seem  like  an  inconvenience  but  actually  has  many  benefits.</p>
<p>Suppose  you’ve  made  changes  to  many  files  in  a  project.  Two  of  these  files’  changes are  complete,  but  everything  else  isn’t  quite  ready.  Using  Git’s  staging,  you  can  stage and commit only these two complete files and keep other incomplete files out of your commit.  Through  planned  staging,  your  commits  can  reflect  meaningful  points  in development  rather  than  random  snapshots  of  your  entire  project  directory  (which would likely include many files in a state of disarray). When we learn about committing in the next section, we’ll see a shortcut to stage and commit all modified files</p>
</blockquote>
<h3 id="5-1-4-git-commit-Taking-a-Snapshot-of-Your-Project">5.1.4 git commit: Taking a Snapshot of Your Project</h3>
<p>如果只有一行说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;&quot;</span><br></pre></td></tr></table></figure>
<p>如果有多行说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit</span><br><span class="line">#会弹出界面，然后写入即可</span><br><span class="line">#修改默认编辑器，这里改成emacs</span><br><span class="line">git config --global core.editor emacs</span><br></pre></td></tr></table></figure>
<p>最好不要稍微有些改动就commit，这样会使得你在回顾log文件时很迷惑，整个开发流程不清晰。因此每次commit的版本要有非常清晰的改动和变化，比如添加了某个功能，修改了某个bug。</p>
<p><strong>-a <strong>选项可以将所有已跟踪文件中的执行修改或删除操作的文件都提交到本地仓库（也就是可以跳过 git add），但是</strong>新加的文件（即没有被git系统管理的文件）是不能被提交到本地仓库的。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -a -m “”</span><br></pre></td></tr></table></figure>
<p><strong>我们需要将所有的改变都记录在commit中，并且要有一个清晰的脉络（git commit的注释要足够清晰），方便我们自己看或别人看</strong>。</p>
<h3 id="5-1-5-Seeing-File-Differences-git-diff">5.1.5 Seeing File Differences: git diff</h3>
<p><code>git diff</code>会告诉你工作目录和暂存区（stage）文件的差别。具体提示信息不太懂</p>
<p>如果你修改文件后进行<code>git add</code>，那么<code>git diff</code>不会显示任何不同。</p>
<p><img src="7.png" alt=""></p>
<p>如果你想看暂存和上次commit之间的区别（ compare  what’s  been  staged  to  our  last  commit  ），可以使用<code>git diff --staged</code> 选项。</p>
<h3 id="5-1-6-Seeing-Your-Commit-History-git-log">5.1.6 Seeing Your Commit History: git log</h3>
<p>commits 像一条链状图，每个commit 都指向 它的上一版本</p>
<p><img src="8.png" alt=""></p>
<h3 id="5-1-7-Moving-and-Removing-Files-git-mv-and-git-rm">5.1.7 Moving and Removing Files: git mv and git rm</h3>
<p>对于追踪的文件，GIT希望绝对掌控，因此不能使用默认的mv 和 rm 命令，需要使用 git mv 和 git rm 命令。</p>
<p>比如我们把之前建的 README 添加后缀为 <a href="http://README.md">README.md</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git mv README README.md</span><br><span class="line">$ git mv data&#x2F;README data&#x2F;README.md</span><br></pre></td></tr></table></figure>
<p>使用 git status，我们看到这个重命名已经staged，等待 committed。这里不需要<code>git add</code>,<code>git add</code> 只适用于修改内容的情况.</p>
<p><img src="9.png" alt=""></p>
<blockquote>
<p>Note  that  even  if  you  change  or  remove  a  file  and  commit  it,  it  still  exists  in  past snapshots. Git does its best to make everything recoverable. We’ll see how to recover files later on in this chapter.</p>
</blockquote>
<h3 id="5-1-8-Telling-Git-What-to-Ignore-git-ignore">5.1.8 Telling Git What to Ignore: .git ignore</h3>
<p><code>git status</code> 会告诉你哪些文件是 not tracked。如果不被追踪的文件数目过多，也会造成负担。</p>
<p>如果你想要忽视所有的FASTQ文件（后缀为.fastq），你可以新建一个.gitignore文件，然后在文件中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data&#x2F;seqs&#x2F;*.fastq</span><br></pre></td></tr></table></figure>
<p>最好的办法是将.gitignore文件 上传到版本库</p>
<p>哪些文件应该放进.gitignore文件呢？</p>
<ul>
<li>
<p>大文件</p>
<p>GIT 不适合追踪大文件，貌似忽视后 git clone 就不会复制数据文件了</p>
</li>
<li>
<p>中间文件</p>
</li>
</ul>
<p>global.gitignore 文件可以忽视所有项目中的指定文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global core.excludesfile ~&#x2F;.gitignore_global</span><br></pre></td></tr></table></figure>
<blockquote>
<p>A repository should store everything required to replicate a project except large datasets  and  external  programs.  This  includes  all  scripts,  documentation,  analysis,  and possibly even a final manuscript. Organizing your repository this way means that all of  your  project’s  dependencies  are  in  one  place  and  are  managed  by  Git. In  the  long run, it’s far easier to have Git keep track of your project’s files, than try to keep track of them yourself.</p>
</blockquote>
<p>这段话很有意思。他是说一个分析中，所有文件（除了大的数据和外部程序）都要放在repo中，甚至包括<strong>文章手稿</strong>。这样会形成一个清晰的脉络，你可以清楚地清晰轨迹。</p>
<h3 id="5-1-9-Undoing-a-Stage-git-reset">5.1.9 Undoing a Stage: git reset</h3>
<p>如果你修改了文件，并且使用<code>git add</code>了。这时候你后悔了，想要unstage （这里不回退工作目录的文件），使用如下命令</p>
<p>HEAD 是当前分支的上一个 commit ，这里使用上一个commit 替代了 staging area （index） 的内容</p>
<p>**注意 staging area 也称为 index **</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD README.md</span><br></pre></td></tr></table></figure>
<p><strong>使用 --hard 选项可以一并回滚工作目录的文件</strong></p>
<h2 id="5-2-Collaborating-with-Git-Git-Remotes-git-push-and-git-pull">5.2 Collaborating with Git: Git Remotes, git push, and git pull</h2>
<p>使用git进行合作开发要求我们有一个本地的版本库和一个remote repositories。</p>
<blockquote>
<p>Then, we can retrieve commits from a remote repository (a  pull) and send commits to a remote repository (a push).</p>
</blockquote>
<p>假如你已经在本地提交了几个commits，然后你打算和你的同事分享你的进度，这个工作流程是这样的：</p>
<p><img src="10.png" alt=""></p>
<p><img src="11.png" alt=""></p>
<p>这个过程可以重复，你和你的同事各自独立在自己的本地的repo工作，然后需要共享的时候，push them to the central repository。在大部分情况下，你和你的同事 work on different files or different sections of the same file，Git can automatically figure out how best to merge these changes. 这样你和你的同事可以同事做同一个项目。</p>
<p>注意 <strong>merge conflict</strong>：如果你和同事同时改变了同一个文件的同一部分，那么合并时会产生错误，这个错误只能手动处理。</p>
<h3 id="5-2-1-Creating-a-Shared-Central-Repository-with-GitHub">5.2.1 Creating a Shared Central Repository with GitHub</h3>
<p>上面提到的 central repository 这里主要是用 GitHub</p>
<p>Authenticating with Git Remotes</p>
<h3 id="5-2-2-Authenticating-with-Git-Remotes">5.2.2 Authenticating with Git Remotes</h3>
<p>GitHub 用 SSH keys 来确认你的身份。SSH keys 避免你每次push or pull 都要输入一个密码。</p>
<p>生成公钥的命令见4.2章节，之后复制~/.ssh/id_rsa.pub 的内容，登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容</p>
<h3 id="5-2-3-Connecting-with-Git-Remotes-git-remote">5.2.3 Connecting with Git Remotes: git remote</h3>
<p>现在我们使用 <code>git remote add</code>命令将我们的本地库和github的库连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:username&#x2F;zmays-snps.git</span><br></pre></td></tr></table></figure>
<p>这里 origin 是我们起的github库的名称（貌似惯例都是这个名称）。</p>
<p>实际上你可以连接多个 remote repositories（起不同的名称就行，那么我猜测origin 应该是最重要的remote repos）</p>
<p>如果你要删除一个不用的 remote repository ,你可以使用下面的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote rm &lt;repository-name&gt;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-4-Pushing-Commits-to-a-Remote-Repository-with-git-push">5.2.4 Pushing Commits to a Remote Repository with git push</h3>
<p>你可以不停地和remote repos 分享commits (但是记住，你只做你该做的部分，避免merge conflict)</p>
<p>我们可以把我们的本地 repo <strong>push</strong> 到远方的服务器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push &lt;remote-name&gt; &lt;branch&gt; </span><br><span class="line">#默认是 git push origin master</span><br></pre></td></tr></table></figure>
<h3 id="5-2-5-Pulling-Commits-from-a-Remote-Repository-with-git-pull">5.2.5 Pulling Commits from a Remote Repository with git pull</h3>
<p>你push 了之后，由于 remote repos 更新了，其他人本地的 repos 过时了，他就需要从 remote repos <strong>pull</strong> 到他自己本地的 repos。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull &lt;remote-name&gt; &lt;branch&gt; </span><br><span class="line">#默认是 git pull origin master</span><br></pre></td></tr></table></figure>
<h3 id="5-2-6-Working-with-Your-Collaborators-Pushing-and-Pulling">5.2.6 Working with Your Collaborators: Pushing and Pulling</h3>
<blockquote>
<p>once  you  grow  a  bit  more  acquainted  with  pushing  and  pulling  commits,  it  will become second nature.</p>
</blockquote>
<p>注意事项：</p>
<ol>
<li><strong>pull 前 先 commit 你的本地 repos</strong>，不然会报错，也避免丢失你的工作</li>
<li><strong>pull often</strong>: 也就是不停更新你的本地 repos，使你的工作一直是建立你的同事的最新版本之上。</li>
</ol>
<h3 id="5-2-7-Merge-Conflicts">5.2.7 Merge Conflicts</h3>
<p>作者建议遇到了再看，那就恭敬不如从命了</p>
<h3 id="5-2-8-More-GitHub-Workflows-Forking-and-Pull-Requests">5.2.8 More GitHub Workflows: Forking and Pull Requests</h3>
<p>这里提到的使用一个共享的 central repository 不是 Github推荐的工作流。github的惯用做法是，你先fork别人的repo到自己的账户，修改后再发出一个 <strong>pull request</strong> 请求合并。</p>
<p>这样做的好处是使得<strong>核心管理员</strong>可以决定哪些commits 可以加入到项目中。不像本书提到的流程，每个人都能自由地向 central repos 提交commit，这可能会造成bug。</p>
<h2 id="5-3-Using-Git-to-Make-Life-Easier-Working-with-Past-Commits">5.3 Using Git to Make Life Easier: Working with Past Commits</h2>
<p>我们的 commit history 可以做更多的事：比如比对不同版本文件的区别，回退到旧版本，给某些commits 添加 tag。</p>
<h3 id="5-3-1-Getting-Files-from-the-Past-git-checkout">5.3.1 Getting Files from the Past: git checkout</h3>
<p>git 只要是 commit 之后的任何文件都可以轻易恢复。</p>
<p>比如你不小心重写了 <a href="http://README.md">README.md</a> 的文件内容（通过使用 &gt; ，而不是 &gt;&gt; ）。</p>
<p>但是我们可以通过查询上一个commit 中的文件版本来恢复这个文件，命令如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/piglite/article/details/55328665">https://blog.csdn.net/piglite/article/details/55328665</a></p>
<p>git checkout – filename的作用是把filename文件在工作区的修改撤销到最近一次git add 或 git commit时的内容</p>
<blockquote>
<p>But beware: restoring a file this way erases all changes made to that file since the last commit!  If  you’re  curious,  the  cryptic   –  indicates  to  Git  that  you’re  checking  out  a file, not a branch ( git checkout is also used to check out branches; commands with multiple uses are common in Git)</p>
</blockquote>
<p>这条命令默认是回归到上一次的版本（HEAD）。其实 <code>git checkout</code>可以回退到任何一个版本。</p>
<p>首先通过git log 查看版本号，-n 选项表示查看最近的几条commit</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log -n 3</span><br></pre></td></tr></table></figure>
<p>查到我们想要回退的commit ID之后，可以使用下列命令回退到该版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout 08ccd3b -- README.md</span><br></pre></td></tr></table></figure>
<p>回退之后还可以恢复，只要 commit ID  用最新的就行，比如下面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout 20041ab -- README.md</span><br></pre></td></tr></table></figure>
<p>恢复后使用 <code>git status</code>可以发现没有任何改变</p>
<h4 id="个人理解">个人理解</h4>
<p>这种回退单个文件的方式，我感觉更符合实际。不像那种直接回退整个工作区的文件，过于暴力！</p>
<h3 id="5-3-2-Stashing-Your-Changes-git-stash">5.3.2 Stashing Your Changes: git stash</h3>
<p>git stash 可以保存工作目录下与上次commit 有所改变的文件。</p>
<p>适用的情况是：如果你在这个目录下代码写到一半，突然要去干别的事情，你又不想提交完成一半或者不完善的代码，你就可以使用<code>git stash</code>就可以将你当前未提交到本地（和服务器）的代码推入到Git的栈中，这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修Bug，等到修完Bug，提交到服务器上后，再使用<code>git stash apply</code>将以前一半的工作应用回来。</p>
<p>注意：修改的文件也要保存。</p>
<p>首先，使用 git stash 保存当前目录的已改变的文件（工作目录此时和上一次的commit一致）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>
<p>之后，使用 git stash pop 恢复（貌似这里和 apply 一样）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash pop</span><br><span class="line">git stash apply</span><br></pre></td></tr></table></figure>
<h3 id="5-3-3-More-git-diff-Comparing-Commits-and-Files">5.3.3 More git diff: Comparing Commits and Files</h3>
<p><code>git diff</code>的一个应用使查看任意两个commit之间的区别。比如我们想比较当前commit（HEAD）与 commit <em>dafce75</em> 的区别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff dafce75</span><br></pre></td></tr></table></figure>
<p>可以使用 HEAD^ 这种形式， ^ 表示上一级commit</p>
<p>使用<code>git diff</code>，我们还可以只看某个文件的改变。命令如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff 46f0781 269aa09 README.md</span><br></pre></td></tr></table></figure>
<h3 id="5-3-4-Undoing-and-Editing-Commits-git-commit-amend">5.3.4 Undoing and Editing Commits: git commit --amend</h3>
<p>算了，这个没看懂</p>
<p>如果你上一次的commit的注释打错了，你可以通过下面的命令修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>
<h2 id="5-4-Working-with-Branches">5.4 Working with Branches</h2>
<p>最后一章是Git最伟大的功能：分支。</p>
<p>Git 的 分支是<strong>虚拟</strong>的，也就是创建一个分支不需要真的复制你repos中的文件。分支可以在下面几点帮助你：</p>
<ul>
<li>分支可以让你做<strong>测试</strong>，而不影响主要的分支，master。这种测试我感觉主要是一个临时的想法，比如你想尝试一下那么做，如果结果好就merge到主要分支中；如果不好，就算了，重新切换回master</li>
<li>如果你在开发软件，你可以创建分支来<strong>开发新功能</strong>和<strong>debug</strong></li>
<li><strong>共同开发</strong>：不同的人可以工作在他们各自的分支中，如果他们写的东西过关了，可以merge到 主要的分支</li>
</ul>
<p>这个有点像是</p>
<h3 id="5-4-1-Creating-and-Working-with-Branches-git-branch-and-git-checkout">5.4.1 Creating and Working with Branches: git branch and git checkout</h3>
<p>创建分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch &lt;branchname&gt;</span><br></pre></td></tr></table></figure>
<p>查看当前分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch</span><br><span class="line">git branch --all #查看全部分支（包括 remote branch，比如github）</span><br></pre></td></tr></table></figure>
<p>切换分支（我觉得用git switch更好）(切换前保证工作台干净)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git switch &lt;branchname&gt;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-2-Merging-Branches-git-merge">5.4.2 Merging Branches: git merge</h3>
<p>当我们的两个分支 diverged，我们现在想要合并这两个分支。首先，我们用<code>git switch</code>来回到我们想要合并其他的分支的主分支中（比如 master）。然后，我们使用 git merge <otherbranch> 来合并其他分支的内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git switch master</span><br><span class="line">git merge &lt;otherbranch&gt; </span><br></pre></td></tr></table></figure>
<p>之后我们可以通过 <code>git log</code> 的 --branches 选项来查看所有分支的可视化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --abbrev-commit --pretty&#x3D;oneline --graph --branches -n 2</span><br></pre></td></tr></table></figure>
<h3 id="5-4-3-Branches-and-Remotes">5.4.3 Branches and Remotes</h3>
<p>有点复杂，没看懂，或者说没仔细看，不知道说了啥</p>
<h2 id="5-5-Continuing-Your-Git-Education">5.5 Continuing Your Git Education</h2>
<h1>6 Bioinformatics Data</h1>
<p>生信数据的挑战：</p>
<ul>
<li>检索数据</li>
<li>确保数据的完整性：通过网络下载的数据可能会存在下载中断，在分析前需要先确保数据是完整的</li>
<li>压缩文件操作：由于生信的数据太大了，因此如果处理压缩数据是必备技能</li>
</ul>
<h2 id="6-1-Retrieving-Bioinformatics-Data">6.1 Retrieving Bioinformatics Data</h2>
<p>假如你的测序项目已经完成，你需要下载。通过浏览器下载并不现实，而且你是需要下载到服务器上，而不是本地的电脑上。</p>
<h3 id="6-1-1-Downloading-Data-with-wget-and-curl">6.1.1 Downloading Data with wget and curl</h3>
<p>最通用的两个从网络下载东西的命令是 wegt 和 curl。</p>
<p><strong>wget</strong></p>
<p>wget 的一个好处是可以递归下载（–recursive or -r），wget 甚至会跟踪网页连接会下载文件。默认情况下，wget 只追 5 层 links deep （–level or -l）</p>
<p>这种情况可以下载一个页面的所有文件或者某种类型的文件，比如说你想下载某个页面所有的 GTF 文件，可以使用下面命令</p>
<p><img src=".%5CBioinformatics_Data_Skills%5C15.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget --accept &quot;*.gtf&quot; --no-directories --recursive --no-parent \ </span><br><span class="line">http:&#x2F;&#x2F;genomics.someuniversity.edu&#x2F;labsite&#x2F;annotation.html</span><br></pre></td></tr></table></figure>
<p>貌似，所有的程序都是用反斜杠**\**续行</p>
<p>但是需要注意的是，wegt 的 递归下载十分贪婪，如果不限制，它会下载它能抵达的深度的所有东西。</p>
<p>在这个例子，我们通过两种方式限制它的下载量，–no-parent 阻止 wget 下载更深的页面的文件；-- accept “*.gtf” 只下载后缀为 gtf 的文件</p>
<p>注意，如果用远程服务器的话，下载速度太快可能会被禁，这个时候可以通过 --limit-rate 限制最大速度。</p>
<p><img src=".%5CBioinformatics_Data_Skills%5C16.png" alt=""></p>
<p><strong>Curl</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;[...]&#x2F;goldenPath&#x2F;hg19&#x2F;chromosomes&#x2F;chr22.fa.gz &gt; chr22.fa.gz</span><br></pre></td></tr></table></figure>
<p>这个命令相比于 wget ，就是可以支持更多的协议，比如 SFTP 和 SCP</p>
<h3 id="6-1-2-Rsync-and-Secure-Copy-scp">6.1.2 Rsync and Secure Copy (scp) (?)</h3>
<p>这两个命令应该都是用于<strong>不同服务器之间传输数据</strong>。</p>
<p>Rsync 命令的好处在于它只传输两个文件版本的差异部分，它能在传播时比较文件差异。</p>
<p>基本语法为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rsync source destination </span><br><span class="line">#两个路径都可以使用下面的表达方式 user@host:&#x2F;path&#x2F;to&#x2F;directory&#x2F;.</span><br></pre></td></tr></table></figure>
<p>假如你要将你在 <em>zea_mays/data</em> 中的数据复制到你同事的*/home/deborah/zea_mays/data* 目录下（IP 地址为 <em>192.168.237.42</em> ）</p>
<p>rsync 复制整个文件夹常用的组合选项是 <strong>-avz</strong>，- a 选项 应该允许递归，-z 选项是传输时使用压缩文件，- v (verbose) 打印详细信息。 因为我们是通过 ssh 连接的远程服务器，还要使用一个选项 -e ssh。整条命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rsync -avz -e ssh zea_mays&#x2F;data&#x2F; vinceb@[...]:&#x2F;home&#x2F;deborah&#x2F;zea_mays&#x2F;data</span><br></pre></td></tr></table></figure>
<p>需要注释的是，路径最后的斜杠是有意义的（比如 data/ 和 data）,有斜杠是复制这个文件夹的所有<strong>内容</strong>，而没有斜杠是表示直接复制这个文件夹本身。因为在我们这个例子中，我们是想复制这个文件夹的所有内容，因此要加上最后的斜杠。</p>
<p>但是有的时候，我们只是想复制一个单独的文件（通过SSH），这个时候 Secure copy (scp) 可以比较方便的做到。scp 和 cp 命令一致，但是目的路径要加上HOST 和 PATH</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp Zea_mays.AGPv3.20.gtf 192.168.237.42:&#x2F;home&#x2F;deborah&#x2F;zea_mays&#x2F;data&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-Data-Integrity">6.2 Data Integrity</h2>
<p>下载数据是进行分析的第一步，虽然不太可能，但是下载数据或传输数据的时候可能会出现问题。你可以使用 <em>checksums</em> 来检查传输数据的完整性。<em>checksums</em> 是对数据的总结，哪怕数据只有一丁点的改变，<em>checksums</em> 也会不一样。</p>
<p>数据完整性检查也使用数据版本的跟踪。</p>
<h3 id="6-2-1-SHA-and-MD5-Checksums">6.2.1 SHA and MD5 Checksums</h3>
<p>现在最常用的两种 checksum 算法 就是 MD5 和 SHA-1。Git 的 commit id 就是使用的 SHA-1 算法。 <strong>MD5 是较老的算法，但是使用更加流行</strong></p>
<p>让我们开始用 SHA-1 算法熟悉 checksums。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;bioinformatics is fun&quot; | shasum</span><br></pre></td></tr></table></figure>
<p>我这要使用 <strong>sha1sum</strong></p>
<p>Checksums 是完全确定的（只要输入内容一致）</p>
<p>额，我的电脑同样的内容都是一致的，但是我的checksums 和 教程上显示的不一致（算法不一样？）</p>
<p>求文件的shasum</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sha1sum &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>这样就可以检查传输前后的大文件的checksum是否一致。（速度很快，可行）</p>
<p>如果下载了很多文件，每个文件都挨个检查很繁琐。shasum 提供了一个便捷的方法–它可以创建和验证包含 checksums的文件。我们可以创建 data/ 目录下所有 FASTQ文件的 checksums  ，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sha1sum data&#x2F;*fastq &gt; fastq_checksums.sha</span><br></pre></td></tr></table></figure>
<p>然后可以使用 -c 选项 检查下载的文件 是否和原来的版本一致</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sha1sum -c fastq_checksums.sha</span><br></pre></td></tr></table></figure>
<p><img src=".%5CBioinformatics_Data_Skills%5C17.png" alt=""></p>
<h2 id="6-3-Looking-at-Differences-Between-Data">6.3 Looking at Differences Between Data</h2>
<p>由于你用checksums 发现两个文件不一致，你会想找出两个文件具体不一致在哪。</p>
<p>可以使用 unix 的 diff 命令（但是大文件慎用，因为会很费时间）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">diff -u &lt;file1&gt; &lt;file2&gt;</span><br></pre></td></tr></table></figure>
<p>-u 选项 表示输出格式 为 <em>unified diff format</em>，这种格式最接近 git diff。</p>
<p>具体输出的内容没看懂（说明文字也没太看懂）</p>
<p><img src=".%5CBioinformatics_Data_Skills%5C18.png" alt=""></p>
<p><img src=".%5CBioinformatics_Data_Skills%5C19.png" alt=""></p>
<h2 id="6-4-Compressing-Data-and-Working-with-Compressed-Data">6.4 Compressing Data and Working with Compressed Data</h2>
<p>文件压缩是生信的不可或缺的技术。</p>
<p>压缩比率 = 未压缩的文件大小/压缩文件大小</p>
<p><strong>大部分写好的生信工具都可以直接使用压缩文件作为输入文件，而不需要解压缩。</strong> unix 工具如 cat,grep,less 都有对应的使用压缩文件的变体。<strong>python 的 gzip 模块使得我们可以直接在python读写压缩文件</strong>。</p>
<p>因此当我们分析大规模数据时，使用压缩工具直接处理压缩文件，make lives easier</p>
<h3 id="6-4-1-gzip">6.4.1 gzip</h3>
<p>最常见的压缩命令时 gzip 和 bzip2。<strong>gzip 压缩和解压缩更快；但是 bzip2 压缩比例更高</strong>。一般来说，gzip 用于正常情况下的压缩，而 bzip2用于长期存档的数据。</p>
<p>gzip 有几种使用方式，首先它可以压缩标准输出（也就是原本是打印到屏幕的）。假如我们有一个程序 trimmer ，可以移除 FASTQ 中的 low-quality bases，这个程序可以处理 gzipped 输入文件，但是会将没压缩的内容标准输出到屏幕。使用 gzip 命令，我们可以压缩 它的输出为压缩文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">trimmer in.fastq.gz | gzip &gt; out.fastq.gz</span><br></pre></td></tr></table></figure>
<p>gzip 也可以直接压缩文件（默认原位压缩）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip &lt;filename&gt; #原位压缩</span><br><span class="line">gunzip &lt;filename.zip&gt; #原位解压缩</span><br></pre></td></tr></table></figure>
<p>如果想保留原文件，加 -c 选项（标准输出）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -c &lt;filename&gt; &gt; &lt;filename.zip&gt;</span><br><span class="line">gunzip -c &lt;filename.zip&gt; &gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>gzip 还有一个特征是，你可以将压缩内容直接合并到一个已存在的 gzip 文件中。如果我们想把 <em>in2.fastq</em> 文件的内容压缩之后，追加到 <em>in.fastq.gz</em> 文件中。我们不会先解压 <em>in.fastq.gz</em> 文件，合并两个文件内容，再压缩合并文件，相反我们会这么做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -c in2.fastq &gt;&gt; in.fastq.gz</span><br></pre></td></tr></table></figure>
<p>注意：这里是 &gt;&gt; ，如果误写成 &gt; ，就会覆盖原文件的内容。（使用重定向的时候永远要当心，确保你使用了正确的符号，而且<strong>一定要有文件备份</strong>）。</p>
<h3 id="6-4-2-Working-with-Gzipped-Compressed-Files">6.4.2 Working with Gzipped Compressed Files</h3>
<p>有很多命令和工具可以直接处理压缩文件，比如 zgrep, zcat, zless, zdiff……。</p>
<p><strong>如果有的程序不能处理压缩文件，你可以使用 zcat 打印出来，然后使用管道符处理。</strong></p>
<p>使用z系列的结果和正常一样，但是就是稍微费一点CPU而已（实际过程还是要先解压）。</p>
<h2 id="6-5-Case-Study-Reproducibly-Downloading-Data">6.5 Case Study: Reproducibly Downloading Data</h2>
<p>当我们通过网络下载一些基因组数据（测序数据、注释数据等），这个网页的内容将来可能会有变化（数据可能会更新）。</p>
<p>为了能够完整复现，我们要记录所有的东西。</p>
<p><strong>记录你的下载时间，下载了什么东西，命令，还有文件的checksums</strong></p>
<p>这个要养成习惯，有点难度</p>
<h1>第3部分 Practice: Bioinformatics Data Skills</h1>
<h1>7 Unix Data Tools</h1>
<h2 id="7-1-Unix-Data-Tools-and-the-Unix-One-Liner-Approach-Lessons-from-Programming-Pearls">7.1 Unix Data Tools and the Unix One-Liner Approach: Lessons from Programming Pearls</h2>
<h2 id="7-2-When-to-Use-the-Unix-Pipeline-Approach-and-How-to-Use-It-Safely">7.2 When to Use the Unix Pipeline Approach and How to Use It Safely</h2>
<p>有些工作适合使用linux的one-liner （管道符连接的多个linux命令），有些适合自己写脚本完成。</p>
<blockquote>
<p>As with most tasks in bioinformatics, choosing the most suitable approach can</p>
<p>be half the battle.</p>
</blockquote>
<p>unix 管道符命令适用于探索数据，转换格式，检查错误等。</p>
<blockquote>
<p>Many  tasks  in  bioinformatics  are  of  this  nature:  we  want  to  get  a  quick  answer  and keep moving forward with our project. We could write a custom script, but for simple tasks  this  might  be  overkill  and  would  take  more  time  than  necessary.  As  we’ll  see later  in  this  chapter,  building  Unix  pipelines  is  fast:  we  can  iteratively  assemble  and test Unix pipelines directly in the shell.</p>
<p>For larger, more complex tasks it’s often preferable to write a custom script in a language  like  Python  (or  R  if  the  work  involves  lots  of  data  analysis).  While  shell approaches (whether a one-liner or a shell script) are useful, these don’t allow for the same  level  of  flexibility  in  checking  input  data,  structuring  programs,  use  of  data structures,  code  documentation,  and  adding  assert  statements  and  tests  as  languages like Python and R. In  contrast,  lengthy  Unix  pipelines can be fragile and less robust than a custom script.</p>
</blockquote>
<p>one-liner 还有一个问题是，由于我们直接在shell中敲命令，然后容易丢失记录，影响 reproducibility。把 piplines 写入脚本是一种好方法，可以rerun。</p>
<h2 id="7-3-Inspecting-and-Manipulating-Text-Data-with-Unix-Tools">7.3 Inspecting and Manipulating Text Data with Unix Tools</h2>
<p>常见的文本文件很多是 tab 分隔的，因为很多linux 命令，比如 cut 和 awk 都是默认将 tab 视为分隔符的。（blupf90 是个怪胎！）。</p>
<p>文本文件有三种格式：<strong>tab分隔、逗号分隔、空格分隔。</strong></p>
<p>tab 分隔最常用：例如  BED,  GTF/GFF,  SAM,  tabular  BLAST  output,  and  VCF。tab分隔的文件每个字段之间只有一个tab符号（\t）。</p>
<p>逗号分隔的文件（comma-separated values CSV）是另一种格式。</p>
<p>最后是以空格分隔的文件。一些顽固的生信程序使用<strong>可变数量的空格</strong>来分隔列。<strong>一般来说，使用tab或逗号分隔，比使用空格分隔要好，因为文件内容中可能会包含空格</strong>。</p>
<h3 id="7-3-1-Inspecting-Data-with-Head-and-Tail">7.3.1 Inspecting Data with Head and Tail</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">head &lt;filename&gt;</span><br><span class="line">head -n 3 &lt;filename&gt;</span><br><span class="line"></span><br><span class="line">tail -n 3 &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>tail 命令还可以用来去除标题行，如果 -n 选项后面的数字含有 + 号，tail 就会从第n 行开始。</p>
<p>比如，剔除第一行（标题），可以使用以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -n +2 &lt;filename&gt; </span><br></pre></td></tr></table></figure>
<p>**head 还可以用在检查以下 pipeline 的结果是否正常。**比如我们先从 gtf 文件查找包含某个基因的行，然后再做下一步处理前，我们想先看一下输出结果，确保正常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &#39;gene_id &quot;ENSMUSG00000025907&quot;&#39; Mus_musculus.GRCm38.75_chr1.gtf | head -n 1</span><br></pre></td></tr></table></figure>
<p>在打印了前几行数据后，the head process exits。</p>
<blockquote>
<p>when <em>head</em> exits, your shell catches this and stops the <em>entire</em> pipe, including the <em>grep</em> process too. Under the hood, your shell sends a signal to other programs in the pipe called SIGPIPE – much like the signal that’s sent when you press Control-c (that signal is SIGINT).</p>
</blockquote>
<p>当你使用很大的数据集，很复杂的pipeline ，这尤其重要。例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &quot;some_string&quot; huge_file.txt | program1 | program2 | head -n 5</span><br></pre></td></tr></table></figure>
<p>当打印前五行之后，grep 不再运行，program1 program2 也停止运行。</p>
<h3 id="7-3-2-less">7.3.2 less</h3>
<p>实用的</p>
<ul>
<li>g 返回首行</li>
<li>/   查找字符
<ul>
<li>n 下一个查找结果</li>
<li>N 上一个查找结果</li>
</ul>
</li>
</ul>
<p><img src=".%5CBioinformatics_Data_Skills%5C20.png" alt=""></p>
<p>less 还可以用来 <strong>debug</strong> 你的 pipelines ，或者构建 pipelines</p>
<p>这样做的好处是，当less 能够展示一个全屏的结果时，<strong>整个流程会暂停</strong>。这样我们不用担心会占用过多的电脑性能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">step1 input.txt | less</span><br><span class="line">step1 input.txt | step2 | less</span><br><span class="line">step1 input.txt | step2 | step3 | less</span><br></pre></td></tr></table></figure>
<h3 id="7-3-3-Plain-Text-Data-Summary-Information-with-wc-ls-and-awk（好）">7.3.3 Plain-Text Data Summary Information with wc, ls, and awk（好）</h3>
<p>查看文件大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -lh # -h 以人类的方式显示大小</span><br></pre></td></tr></table></figure>
<p><code>wc -l</code>统计的行数包括末尾的空行，但是最后一行如果没有换行符，也是不统计的。</p>
<p>比如下面这个文件，最后一行没有换行符，在notpad++里显示为12行，但是<code>wc -l</code>显示为11行，<strong>即没有换行符的行不视为一行</strong>。</p>
<p>**notpad++ 显示的行数 = linux 行数 + 1 **</p>
<p><img src=".%5CBioinformatics_Data_Skills%5C21.png" alt=""></p>
<p>如果我增加几行空行，<code>wc-l</code> 显示为 13行</p>
<p><img src=".%5CBioinformatics_Data_Skills%5C23.png" alt=""></p>
<p>如果要显示<strong>非空行</strong>的行数 （里面的正则没看懂）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -c &quot;[^ \\n\\t]&quot; &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>显示字段数目，下面这个命令只打印第一行的字段数，这里指定了分隔符为tab。</p>
<p>但是由于这个文件有注释，这条命令没有作用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk -F &quot;\t&quot; &#39;&#123;print NF; exit&#125;&#39; Mus_musculus.GRCm38.75_chr1.bed</span><br></pre></td></tr></table></figure>
<p>首先我们要去除前面的注释部分，再使用 awk 来做：</p>
<p><img src=".%5CBioinformatics_Data_Skills%5C24.png" alt=""></p>
<p>但是这种方式很脆弱，因为不同文件的注释行数目不同，我们可以通过 grep 命令，可以剔除以#号开头的行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -v &quot;^#&quot; Mus_musculus.GRCm38.75_chr1.gtf | head -n 3</span><br></pre></td></tr></table></figure>
<h3 id="7-3-4-Working-with-Column-Data-with-cut-and-Columns">7.3.4 Working with Column Data with cut and Columns</h3>
<p>有些时候我们只想看某些列的内容，这个时候我们可以使用cut命令（默认分隔符为tab）(其实awk也可以)，例如只看第二列（-f 指定字段，也可以指定字段的区域，<strong>例如 -f 3-8 （首尾都包括）  或 -f 3,5,8</strong> 但是只能按照文件中的顺序提取，例如 -f 6,5,4,3 并不起作用，如果要打乱顺序提取，需要使用 awk）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cut -f 2 Mus_musculus.GRCm38.75_chr1.bed | head -n 3</span><br></pre></td></tr></table></figure>
<p>通过联合使用 grep 和 cut 命令，可以提取GTF文件中的染色体、起始位置、终止位置三列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -v &quot;^#&quot; Mus_musculus.GRCm38.75_chr1.gtf | cut -f1,4,5 | head -n 3</span><br></pre></td></tr></table></figure>
<p>cut 可以通过 -d 指定分隔符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cut -d, -f2,3 Mus_musculus.GRCm38.75_chr1_bed.csv | head -n 3</span><br></pre></td></tr></table></figure>
<h4 id="cut-切割空格分隔的文件">cut 切割空格分隔的文件</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cut -d &#x27; &#x27; -f 1 filename</span><br></pre></td></tr></table></figure>
<p>但是 cut 只允许间隔符是一个字符，如果间隔符是多个空格，就不能这么做了。需要用 sed 先把多个空格替换为一个空格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -r &#39;s&#x2F;\s+&#x2F; &#x2F;g&#39; filename | cut -d &#39; &#39; -f 1</span><br></pre></td></tr></table></figure>
<h4 id="cut-提取连续多列">cut 提取连续多列</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cut -d &#x27; &#x27; -f2,7- filename</span><br></pre></td></tr></table></figure>
<p><code>7-</code> 表示从第7列到最后一列，如果是<code>-7</code> ，则表示前7列。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cut -d &#x27; &#x27; -f 3-5 filename</span><br></pre></td></tr></table></figure>
<p>提取第3列，第4列，第5列。</p>
<h3 id="7-3-5-Formatting-Tabular-Data-with-column">7.3.5 Formatting Tabular Data with column</h3>
<p>当我们处理tab分隔的文件时，有的时候不好看某个元素属于第几列（就是每一列的元素不对齐）。</p>
<p><img src=".%5CBioinformatics_Data_Skills%5C25.png" alt=""></p>
<p>这里有一个解决办法是 <code>column -t</code> (-t 选项告诉 column 将数据视为表格)，之后数据每一列看上去就对齐了（注意：这只能用于可视化，而不能真的用于改变数据格式，不然影响了电脑对数据的可读性）(write code for human , write data for computers )</p>
<blockquote>
<p>这让我想到了最近处理一些excel表，里面有各种格式（合并单元格，居中……），用程序处理很麻烦，这就是违背了<strong>write data for computers</strong>的原则，相反是 write data for human 。</p>
</blockquote>
<p><img src=".%5CBioinformatics_Data_Skills%5C26.png" alt=""></p>
<p>column 默认分隔符也是 \t，可以通过 -s 选项更改分隔符。</p>
<h3 id="7-3-6-The-All-Powerful-Grep">7.3.6 The All-Powerful Grep</h3>
<p>grep 速度很快，如果你想要查找文件中某种 pattern ，grep 会比你写的所有python脚本都要快。对比4种查找文件内容的命令或程序中（grep,sed,awk,Python script）, grep 速度最快，比第二名还要快5倍。</p>
<p>这是由于 grep 是<strong>专门化</strong>的查找文件内容的命令。这提示我们，如果你要提高速度，unix 的专门处理这个需求的命令一般来说速度是最快的</p>
<p><img src=".%5CBioinformatics_Data_Skills%5C27.png" alt=""></p>
<p>grep 的基本用法：grep 需要两个参数，<strong>pattern</strong>（需要查找的字符或正则表达式），<strong>文件名称</strong>。最简单的用法如下，pattern 的引号是非必须的，但建议还是加上双引号，更加安全。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &quot;Olfr418-ps1&quot; Mus_musculus.GRCm38.75_chr1_genes.txt</span><br></pre></td></tr></table></figure>
<p>grep 的一个常用选项是 <code>--color=auto</code>，这个选项可以让终端中匹配的部分显示颜色（我现在的服务器默认就有）</p>
<p>如果我们想查找 包含”Olfr” ，但是不包含 “Olfr1413” 的行，我们可以使用以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep Olfr Mus_musculus.GRCm38.75_chr1_genes.txt | grep -v Olfr1413</span><br></pre></td></tr></table></figure>
<p>但是这个命令可能会出问题，因为 <strong>grep 是部分匹配</strong>，这里我们只想剔除 “Olfr1413” 的行，但是这个命令也会一并剔除像 “Olfr1413a” 和  “Olfr14130“ 这种名称的基因。</p>
<p><strong>我们可以使用 -w 来匹配全词（两边都是空格）</strong>。这个说法不准确，应该是 非单词构成字符（除字母、数字、下划线的其他字符），<code>man grep</code> 官方文档见下</p>
<blockquote>
<p>-w, --word-regexp<br>
Select only those lines containing matches that form whole words.  The test is that the matching substring must either be at the beginning of the line, or preceded  by  a  non-word  constituent character.   Similarly,  it  must  be  either  at  the end of the line or followed by a non-word constituent character.  Word-constituent characters are letters, digits, and the underscore.</p>
</blockquote>
<p><img src=".%5CBioinformatics_Data_Skills%5C28.png" alt=""></p>
<p>一般情况下，我们都要加 -w 选项来限制匹配，来避免错误的部分匹配。</p>
<p>grep 支持正则表达式（POSIX Basic Regular Expressions (BRE)）,这种匹配方式貌似是阉割版。但在一些简单的应用中可以完美工作。</p>
<p>举例，你想查找 Ensembl gene id 是  “Olfr1413”  或者  “Olfr1411”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &quot;Olfr141[13]&quot; Mus_musculus.GRCm38.75_chr1_genes.txt</span><br></pre></td></tr></table></figure>
<p>如果你想查找 “Olfr218”  and  “Olfr1416” ，上面这种就没办法了，你可以使用</p>
<p>POSIX Extended Regular Expressions （ERE），具体方式是 使用 -E 选项 （或 egrep）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -E &quot;(Olfr1413|Olfr1411)&quot; Mus_musculus.GRCm38.75_chr1_genes.txt</span><br></pre></td></tr></table></figure>
<p>grep 有一个选项 -c ，用于统计匹配到 pattern 的行数</p>
<p>这个选项很实用，比如我们想看一个gtf文件里有多少 small nuclear RNA</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -c &#39;gene_biotype &quot;snRNA&quot;&#39; Mus_musculus.GRCm38.75_chr1.gtf</span><br></pre></td></tr></table></figure>
<p>grep 默认是打印存在pattern的整行，有时我们需要只打印匹配上的字段，这个时候我们就可以使用 -o 选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep -o &quot;Olfr.*&quot; Mus_musculus.GRCm38.75_chr1_genes.txt | head -n 3</span><br><span class="line">0lfr1416</span><br><span class="line">Olfr1415</span><br><span class="line">0lfr1414</span><br></pre></td></tr></table></figure>
<p>假如我们想挑出某个gtf文件的所有基因：这里 -E 采用拓展正则， -o 只打印匹配字符，\w 表示[a-z A-Z 0-9 _]， 注意这里\w+ 有引号，所以匹配的字符是有引号的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep -E -o &#39;gene_id &quot;\w+&quot;&#39; Mus_musculus.GRCm38.75_chr1.gtf | head -n 5</span><br><span class="line"># 这里查找的字符内有双引号，外面只能用单引号，用双引号不行（老shell了）</span><br><span class="line">gene_id &quot;ENSMUSG00000090025&quot;</span><br><span class="line">gene_id &quot;ENSMUSG00000090025&quot;</span><br><span class="line">gene_id &quot;ENSMUSG00000090025&quot;</span><br><span class="line">gene_id &quot;ENSMUSG00000064842&quot;</span><br><span class="line">gene_id &quot;ENSMUSG00000064842&quot;</span><br></pre></td></tr></table></figure>
<p>但是gtf中有很多功能区域会匹配到同一基因 (基因，外显子，起始密码子)，下面这个pipeline 就是处理找到的基因结果，去重排序（妙啊）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep -E -o &#39;gene_id &quot;(\w+)&quot;&#39; Mus_musculus.GRCm38.75_chr1.gtf | \</span><br><span class="line">	cut -f2 -d&quot; &quot; | \</span><br><span class="line">    sed &#39;s&#x2F;&quot;&#x2F;&#x2F;g&#39; | \</span><br><span class="line">    sort | \</span><br><span class="line">    uniq &gt; mm_gene_id.txt</span><br></pre></td></tr></table></figure>
<h4 id="grep-选项小结">grep 选项小结</h4>
<ul>
<li>-v 反向查找</li>
<li>-w 全词匹配（前后必须为空格或tab）</li>
<li>-c 打印匹配行数</li>
<li>-o 打印匹配字符</li>
<li>-r 文件夹内递归搜索</li>
</ul>
<h3 id="7-3-7-Decoding-Plain-Text-Data-hexdump">7.3.7 Decoding Plain-Text Data: hexdump</h3>
<p>查看文件编码：<code>file</code></p>
<p>注意：由于UTF-8 编码包含了ASCII码，因此如果UTF-8文件中不包含特殊字符（比如中文），<code>file</code>命令会将文件解释为 ASCII 编码。</p>
<h3 id="7-3-8-Sorting-Plain-Text-Data-with-Sort">7.3.8 Sorting Plain-Text Data with Sort</h3>
<p>sort 不加参数，是<strong>按每一行的ASCII码顺序排列</strong>，比如下面的例子，每一行一个字符字符的比较。</p>
<p><img src="29.png" alt="29"></p>
<p>不同的分隔符，比如CSV文件，使用 <code>-t&quot;,&quot;</code></p>
<p>这里可以看到，第二列的顺序是乱的，可以使用-k 选项；下面这两种格式都可以，第一种方式的-k 后面的1,1 表示初始列和最终列。但是两种方式不能混用（老shell了）</p>
<p>但是 -n 放在最前面表示所有列均按照数字大小排序，放在 -k2,2n 表示只有第二列按数字大小排列。</p>
<p><strong>第一种更全，以后固定使用第一种</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort -k1,1 -k2,2n example.bed</span><br><span class="line">$ sort -n -k 1 -k 2 example.bed</span><br></pre></td></tr></table></figure>
<p>sort 过程可能十分耗时，可以通过 -c 选项检查文件是否已按要求排序完毕。应该没有输出表示为排序好的文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort -k1,1 -k2,2n -c example_sorted.bed </span><br><span class="line">$ echo $?</span><br><span class="line">0</span><br><span class="line">$ sort -k1,1 -k2,2n -c example.bed </span><br><span class="line">sort: example.bed:4: disorder: chr1     40      49</span><br><span class="line">$ echo $?1</span><br></pre></td></tr></table></figure>
<p>可以通过 -r 选项逆序排列（正常时从小到大，递增）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort -k1,1 -k2,2n -r example.bed</span><br></pre></td></tr></table></figure>
<p>如果只想某一列逆序，可以只将 r 选项加到那一列中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort -k1,1 -k2,2nr example.bed</span><br></pre></td></tr></table></figure>
<p>但是，对于既有字符又有数字的列，刚刚的排序方式可能就不一样了，下面的染色体超过了10，可以看到染色体排序是不对的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort -k1,1 -k2,2n example2.bed</span><br><span class="line">chr1    34      49</span><br><span class="line">chr10   30      42</span><br><span class="line">chr10   31      47</span><br><span class="line">chr11   6       16</span><br><span class="line">chr2    15      19</span><br><span class="line">chr2    17      22</span><br><span class="line">chr2    27      46</span><br><span class="line">chr22   32      46</span><br></pre></td></tr></table></figure>
<p>也不能使用 -n 选项，使用 -n 选项如下图，彻底是乱的，完全没逻辑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort -k1,1n -k2,2n example2.bed</span><br><span class="line">chr11   6       16</span><br><span class="line">chr2    15      19</span><br><span class="line">chr2    17      22</span><br><span class="line">chr2    27      46</span><br><span class="line">chr10   30      42</span><br><span class="line">chr10   31      47</span><br><span class="line">chr22   32      46</span><br><span class="line">chr1    34      49</span><br></pre></td></tr></table></figure>
<p>这时，需要使用 <code>-V</code> 选项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort -k1,1V -k2,2n example2.bed</span><br><span class="line">chr1    34      49</span><br><span class="line">chr2    15      19</span><br><span class="line">chr2    17      22</span><br><span class="line">chr2    27      46</span><br><span class="line">chr10   30      42</span><br><span class="line">chr10   31      47</span><br><span class="line">chr11   6       16</span><br><span class="line">chr22   32      46</span><br></pre></td></tr></table></figure>
<p>linux 的 sort 命令可以很好的用于中等大小的数据。sort 命令的一个特征时如果文件太大，超过内存，那么sort 命令会将中间文件存储在磁盘中。对于大数据而言，对磁盘中的中间文件的读写操作会是一个瓶颈（磁盘的速度很慢）。我们可以通过<strong>设置sort使用的内存大小</strong>来提高sort命令的内存占用量，避免它把数据存储为中间文件。例如，下式，-S 选项就是设置内存大小的，它能够获知后缀，比如 K、G，这里设置为2G，也可以设置为所有内存的百分比（-S 50%）</p>
<p>sort 还有一个选项支持并发计算。下式中就使用了4核。</p>
<p>但是小数据的话不需要额外设置，因为实际上并发计算存在一个固定的成本，因此如果运行小数据速度可能更慢。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort -k1,1 -k4,4n -S2G Mus_musculus.GRCm38.75_chr1_random.gtf</span><br><span class="line">$ sort -k1,1 -k4,4n --parallel 4 Mus_musculus.GRCm38.75_chr1_random.gtf</span><br></pre></td></tr></table></figure>
<h4 id="Sorting-Stability">Sorting Stability</h4>
<p>当存在所有的sort keys 都相同的行，sort 仍会按照它们整行的顺序排列这些行的顺序。如果你想让这些行之间的顺序与源文件的顺序一致（即不要改变），可以使用 -s 选项。</p>
<h4 id="sort-遇到科学计数法结果不可靠">sort 遇到科学计数法结果不可靠</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -n +2 maf.frq | sort -k5,5nr | less -S</span><br></pre></td></tr></table></figure>
<p>我想按第5列，从大到小排列。</p>
<p>但是结果跑出来一开始是非常小的数，然后才是从大到小排列。但是用<strong>python</strong> 就没问题。</p>
<p><img src="40.png" alt="29"></p>
<h3 id="7-3-9-Finding-Unique-Values-in-Uniq">7.3.9 Finding Unique Values in Uniq</h3>
<p>uniq 会移除连续的重复行（保留一个）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat letters.txt</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">C</span><br><span class="line">C</span><br><span class="line">$ uniq letters.txt</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure>
<p>因此，如果需要真正去重，需要先sort。</p>
<p>使用 -c 选项可以查看每一行出现的次数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort letters.txt | uniq -c   </span><br><span class="line">2 A   </span><br><span class="line">2 B   </span><br><span class="line">4 C</span><br></pre></td></tr></table></figure>
<p>通过与 grep、cut 命令合用，uniq 命令可以用来查来某一列所有水平的重复次数（分类数据）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep -v &quot;^#&quot; Mus_musculus.GRCm38.75_chr1.gtf | cut -f3 | sort | uniq -c</span><br><span class="line">25901 CDS</span><br><span class="line">7588 UTR</span><br><span class="line">36128 exon</span><br><span class="line">2027 gene</span><br><span class="line">2290 start_codon</span><br><span class="line">2299 stop_codon</span><br><span class="line">4993 transcript</span><br></pre></td></tr></table></figure>
<p>因为 sort 和 uniq 都是行处理的命令，<strong>我们可以人为创造新的行</strong>，作为sort 和 cut 的输入（比如 通过 cut）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep -v &quot;^#&quot; Mus_musculus.GRCm38.75_chr1.gtf | cut -f3,7 | sort | uniq -c</span><br><span class="line">12891  CDS          +</span><br><span class="line">13010  CDS          -</span><br><span class="line">3754   UTR          +</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>uniq 还可以通过 -d 选项 来检查文件是否存在重复。-d 会打印存在重复的行，之后再通过 <code>wc -l</code> 就可以查看是否有重复行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort letters.txt | uniq -d</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">$ sort letters.txt | uniq -d | wc -l</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="7-3-10-Join">7.3.10 Join</h3>
<p>join 命令可以通过一个相同的列合并不同的文件。比如存在下面两个文件，我们想把第二个文件的内容合并到第一个文件里（相同的字段是染色体；结果文件是一个tab分隔的文件）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat example.bed</span><br><span class="line">chr1    26      39</span><br><span class="line">chr1    32      47</span><br><span class="line">chr3    11      28</span><br><span class="line">chr1    40      49</span><br><span class="line">chr3    16      27</span><br><span class="line">chr1    9       28</span><br><span class="line">chr2    35      54</span><br><span class="line">chr1    10      19</span><br><span class="line">$ cat example_lengths.txt</span><br><span class="line">chr1    58352</span><br><span class="line">chr2    39521</span><br><span class="line">chr3    24859</span><br></pre></td></tr></table></figure>
<p>首先，我们要对两个文件按照染色体进行 sort，join命令没法处理没有排序的文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sort -k1,1 example.bed &gt; example_sorted.bed</span><br><span class="line">$ sort -c -k1,1 example_lengths.txt # verifies is already sorte</span><br></pre></td></tr></table></figure>
<p>然后，我们就可以使用<code>join</code>命令了，基本语法如下，字段表示为列数。输出的字段顺序与给定的文件顺序一致。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">join -1 &lt;file_1_field&gt; -2 &lt;file_2_field&gt; &lt;file_1&gt; &lt;file_2&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ join -1 1 -2 1 example_sorted.bed example_lengths.txt</span><br><span class="line">chr1 10 19 58352</span><br><span class="line">chr1 26 39 58352</span><br><span class="line">chr1 32 47 58352</span><br><span class="line">chr1 40 49 58352</span><br><span class="line">chr1 9 28 58352</span><br><span class="line">chr2 35 54 39521</span><br><span class="line">chr3 11 28 24859</span><br><span class="line">chr3 16 27 24859</span><br><span class="line"></span><br><span class="line">$ join -1 1 -2 1 example_lengths.txt example_sorted.bed</span><br><span class="line">chr1 58352 10 19</span><br><span class="line">chr1 58352 26 39</span><br><span class="line">chr1 58352 32 47</span><br><span class="line">chr1 58352 40 49</span><br><span class="line">chr1 58352 9 28</span><br><span class="line">chr2 39521 35 54</span><br><span class="line">chr3 24859 11 28</span><br><span class="line">chr3 24859 16 27</span><br></pre></td></tr></table></figure>
<p>但是如果第二个文件没有 chr3 怎么办呢，可以看到 <code>join</code> 实行内连接，剔除了 chr3 的行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ head -n2 example_lengths.txt &gt; example_lengths_alt.txt # truncate file</span><br><span class="line">$ join -1 1 -2 1 example_sorted.bed example_lengths_alt.txt</span><br><span class="line">chr1 10 19 58352</span><br><span class="line">chr1 26 39 58352</span><br><span class="line">chr1 32 47 58352</span><br><span class="line">chr1 40 49 58352</span><br><span class="line">chr1 9 28 58352</span><br><span class="line">chr2 35 54 39521</span><br><span class="line">$ join -1 1 -2 1 example_sorted.bed example_lengths_alt.txt | wc -l</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<p>我们可以通过 -a 选项（需要指定哪个文件可以包含没有匹配的行）来包括没有匹配的行（左连接或右连接）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ join -1 1 -2 1 -a 1 example_sorted.bed example_lengths_alt.txt # GNU join only</span><br><span class="line">chr1  10  19  58352</span><br><span class="line">chr1  26  39  58352</span><br><span class="line">chr1  32  47  58352</span><br><span class="line">chr1  40  49  58352</span><br><span class="line">chr1  9   28  58352</span><br><span class="line">chr2  35  54  39521</span><br><span class="line">chr3  11  28</span><br><span class="line">chr3  16  27</span><br></pre></td></tr></table></figure>
<h3 id="7-3-11-Text-Processing-with-Awk">7.3.11 Text Processing with Awk</h3>
<p>格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;&#125; /search pattern/&#123;action&#125; END&#123;&#125;&#x27; file </span><br></pre></td></tr></table></figure>
<p>工作原理：</p>
<ol>
<li>
<p>运行 BEGIN</p>
</li>
<li>
<p>每次输入一行，赋给内部变量 $0</p>
</li>
<li>
<p>按 <strong>空格/制表符</strong> 将每一行分解为字段，赋给 $1-$n</p>
</li>
<li>
<p>search pattern 和 action 必选其一</p>
<p>如果没有 search pattern ， 则对所有行均执行 action 操作</p>
<p>如果没有 action，则默认打印改行</p>
</li>
</ol>
<p>行数：NR (row) ,  列数：NF (<strong>field</strong>)</p>
<p>简单匹配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;&#123; print $0 &#125;&#39; example.bed</span><br><span class="line">$ awk &#39;&#123; print $2 &quot;\t&quot; $3 &#125;&#39; example.bed</span><br></pre></td></tr></table></figure>
<p>simple pattern matching</p>
<p>假设我们想打印结束位置与起始位置大于18的行，awk 支持算术运算符 <strong>+ - * / % ^</strong> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39; $3 - $2 &gt; 18&#39; example.bed</span><br><span class="line">chr1    9       28</span><br><span class="line">chr2    35      54</span><br></pre></td></tr></table></figure>
<p>awk 的 比较和逻辑运算符</p>
<p><img src="30.png" alt=""></p>
<p>我们可以通过 &amp;&amp; || ！来连接多个运算符。</p>
<p>如果我们想要在1号染色体 并且 长度大于10的功能区域。第一个pattern，采用了正则表达式，正则表达式在斜杠中，~ 表示 匹配 （不匹配 表示 !~），这里就仅仅是表示 $1 匹配 chr1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;$1 ~ &#x2F;chr1&#x2F; &amp;&amp; $3 - $2 &gt; 10&#39; example.bed</span><br><span class="line">chr1    26      39</span><br><span class="line">chr1    32      47</span><br><span class="line">chr1    9       28</span><br></pre></td></tr></table></figure>
<p>这个还可以更复杂，比如我们想挑出 chr2/chr3 的行，并且在最后增加一列长度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;$1 ~ &#x2F;chr2|chr3&#x2F; &#123; print $0 &quot;\t&quot; $3 - $2 &#125;&#39; example.bed</span><br><span class="line">chr3    11      28      17</span><br><span class="line">chr3    16      27      11</span><br><span class="line">chr2    35      54      19</span><br></pre></td></tr></table></figure>
<p>到目前为止，我们发现 awk 可以很方便的做两件事：</p>
<ul>
<li>按正则表达式/四则运算 提出需要的行</li>
<li>打印需要的字段或重排</li>
</ul>
<p>awk 还有 BEGIN 和 END ，BEGIN 一般用于新建变量，END 一般用于打印数据总结。</p>
<p>比如我们想看所有功能区域的平均长度。<strong>NR 是当前记录的行号，因此最后一行的行号就是总共的数据行数。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;BEGIN&#123; s &#x3D; 0 &#125;; &#123; s +&#x3D; ($3-$2) &#125;; END&#123; print &quot;mean: &quot; s&#x2F;NR &#125;;&#39; example.bed</span><br><span class="line">mean: 14</span><br></pre></td></tr></table></figure>
<p>对于使用其他字段分割的文件，比如 CSV 文件，我们可以使用 -F 选项，比如 <code>awk -F&quot;,&quot;</code></p>
<p>我们可以使用 NR 来挑某些行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;NR &gt;&#x3D; 3 &amp;&amp; NR &lt;&#x3D; 5&#39; example.bed</span><br><span class="line">chr3    11      28</span><br><span class="line">chr1    40      49</span><br><span class="line">chr3    16      27</span><br></pre></td></tr></table></figure>
<p>awk 使得生信数据之间的转换更加方便，比如 BED 和 GTF 文件。注意，这里的起始位置减1，来转变为 BED 数据（具体啥叫BED格式不知道）。这是由于BED的索引从0开始，而GTF的索引从1开始。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;!&#x2F;^#&#x2F; &#123; print $1 &quot;\t&quot; $4-1 &quot;\t&quot; $5 &#125;&#39; Mus_musculus.GRCm38.75_chr1.gtf | head -n 3</span><br><span class="line">1       3054232 3054733</span><br><span class="line">1       3054232 3054733</span><br><span class="line">1       3054232 3054733</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>awk 还有一个很有用的数据结构，称为关联数组，类似于python里面的字典，存在key和value。比如我们想计算 属于 基因 ”Lypla1&quot; 的 features 的 重复数目，我们可以按照以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;&#x2F;Lypla1&#x2F; &#123; feature[$3] +&#x3D; 1 &#125;; \</span><br><span class="line">    END &#123; for (k in feature)          \    </span><br><span class="line">    print k &quot;\t&quot; feature[k] &#125;&#39; Mus_musculus.GRCm38.75_chr1.gtf</span><br><span class="line">exon    69</span><br><span class="line">CDS     56</span><br><span class="line">UTR     24</span><br><span class="line">gene    1</span><br><span class="line">start_codon     5</span><br><span class="line">stop_codon      5</span><br><span class="line">transcript      9</span><br></pre></td></tr></table></figure>
<p>从这我们可以看出，awk 是一门真正的编程语言，可以使用 if for while 等循环。</p>
<p>但是，如果 awk 语句 变得复杂或者需要占据多行，我通常更推荐转向python。python 可以更加轻松地完成复杂的任务。（知己）</p>
<p>我们可以通过 unix 的管道符来完成这项任务。但是如果你需要对数据进行过滤，此时使用这种方式会很麻烦；而使用awk命令会很简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep &quot;Lypla1&quot; Mus_musculus.GRCm38.75_chr1.gtf | cut -f 3 | sort | uniq -c</span><br><span class="line">     56 CDS</span><br><span class="line">     69 exon</span><br><span class="line">      1 gene</span><br><span class="line">      5 start_codon</span><br><span class="line">      5 stop_codon</span><br><span class="line">      9 transcript</span><br><span class="line">     24 UTR</span><br></pre></td></tr></table></figure>
<h4 id="awk-分隔符设置">awk 分隔符设置</h4>
<p><a href="https://www.zsythink.net/archives/1357">https://www.zsythink.net/archives/1357</a></p>
<p>输入输出（设置每一个参数值均需要使用 <code>-v</code> 参数）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk -v FS&#x3D;&quot;&quot; -v OFS&#x3D;&quot;&quot; &#39;&#123;&#125;&#39;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-12-Bioawk-An-Awk-for-Biological-Formats">7.3.12 Bioawk: An Awk for Biological Formats</h3>
<p>Bioawk 是将 awk 扩展到处理一些常见的生信格式上，如FASTA/FASTQ, GTF/GFF, BED, SAM, VCF。其实没有特别大的变动，就是给每一列一个具有意义的名称而已。</p>
<p>直接用conda 安装（有一说一，conda 真好用）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install bioawk</span><br></pre></td></tr></table></figure>
<p>安装完之后，通过以下命令查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bioawk -c help</span><br></pre></td></tr></table></figure>
<h3 id="7-3-13-Stream-Editing-with-Sed">7.3.13 Stream Editing with Sed</h3>
<p>在前面，我们提到了为什么 Unix pipes 速度快，因为Unix pipes 直接在内存中处理数据（而不是将数据写入磁盘中再读取），除此之外，Unix pipes 不是一次性将所有数据放到内存中，而是<strong>每次只操作一行数据</strong>。</p>
<p>通常我们使用 Unix 命令处理数据需要好几个命令，但是 sed (The stream editor) 允许你直接做。类似于 ask 和 grep ，你应该只用 sed 命令做比较简单的事情（最主要是<strong>替换</strong>）。</p>
<p>sed 也是每次读取一行进行处理（流编辑，stream editing）。举例，假如我们将一个文件的“chrom&quot; 均改为 ”chr&quot;，这用到了sed 的替换命令（substitute, sed 的最常用的用法）。</p>
<p>使用 <code>s/pattern/replacement/</code> 默认只替换第一次出现的值；有时我们需要替换所有匹配的值，我们可以在最后一个斜杠后添加 一个 global flag g ，也就是<code>s/pattern/replacement/g</code></p>
<p>如果 我们需要匹配时忽视大小写，我们可以添加一个 flag i （<code>s/pattern/replacement/i</code>）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ head -n 3 chroms.txt</span><br><span class="line">chrom1  3214482 3216968</span><br><span class="line">chrom1  3216025 3216968</span><br><span class="line">chrom1  3216022 3216024</span><br><span class="line"></span><br><span class="line">$ sed &#39;s&#x2F;chrom&#x2F;chr&#x2F;&#39; chroms.txt | head -n 3</span><br><span class="line">chr1    3214482 3216968</span><br><span class="line">chr1    3216025 3216968</span><br><span class="line">chr1    3216022 3216024</span><br></pre></td></tr></table></figure>
<p>默认情况下，sed 使用 POSIX  Basic  Regular  Expressions  (BRE)，就像时 grep 命令一样，我们可以使用 <code>-E</code> 来使用拓展的正则表达式。</p>
<p>下面有三种办法实现同一功能，第二种方式采用了管道符的方法，可能更符合复杂情况；第三种方式采用 <code>tr</code> 函数（translate），同样是实现替换功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &quot;chr1:28427874-28425431&quot; | sed &#39;s&#x2F;[:-]&#x2F;\t&#x2F;g&#39;</span><br><span class="line">chr1    28427874        28425431</span><br><span class="line"></span><br><span class="line">$ echo &quot;chr1:28427874-28425431&quot; | sed &#39;s&#x2F;:&#x2F;\t&#x2F;&#39; | sed &#39;s&#x2F;-&#x2F;\t&#x2F;&#39;</span><br><span class="line">chr1    28427874        28425431</span><br><span class="line"></span><br><span class="line">$  echo &quot;chr1:28427874-28425431&quot; | tr &#39;:-&#39; &#39;\t&#39;</span><br><span class="line">chr1    28427874        28425431</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当某些行，sed 没有找到匹配的pattern 时，sed 会打印出整行，可以使用 <code>-n</code> 选项，避免 sed 打印没找到 pattern 的行。</p>
<p>如果采用 <code>.*</code> 方式采用的<strong>贪婪算法</strong>，如下面的例子，采用 <code>[^&quot;]</code> 是匹配非引号的字符，因此是非贪婪的。</p>
<blockquote>
<p><a href="https://blog.csdn.net/Jasonliujintao/article/details/53509732">https://blog.csdn.net/Jasonliujintao/article/details/53509732</a></p>
<p>sed 第二个斜杠和第三个斜杠的 <code>\1</code>  表示被匹配到的第一个模式，sed 一共可以记录9个模式 （\1 - \9）。模式就是用（）括起来的正则表达式的内容。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &#39;transcript_id &quot;ENSMUST00000160944&quot;; gene_name &quot;Gm16088&quot;&#39; &gt; greedy_example.txt</span><br><span class="line"></span><br><span class="line">$ sed -E &#39;s&#x2F;transcript_id &quot;(.*)&quot;.*&#x2F;\1&#x2F;&#39; greedy_example.txt</span><br><span class="line">ENSMUST00000160944&quot;; gene_name &quot;Gm16088</span><br><span class="line"></span><br><span class="line">$ sed -E &#39;s&#x2F;transcript_id &quot;([^&quot;]+)&quot;.*&#x2F;\1&#x2F;&#39; greedy_example.txt</span><br><span class="line">ENSMUST00000160944</span><br></pre></td></tr></table></figure>
<p>sed 还可以打印某些特定范围的行，比如 前10行，20行至50行（首尾都包括，从1开始）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sed -n &#39;1,10p&#39; Mus_musculus.GRCm38.75_chr1.gtf</span><br><span class="line">$ sed -n &#39;20,50p&#39; Mus_musculus.GRCm38.75_chr1.gtf</span><br></pre></td></tr></table></figure>
<h2 id="7-4-Advanced-Shell-Tricks">7.4 Advanced Shell Tricks</h2>
<h3 id="7-4-1-Subshells">7.4.1 Subshells</h3>
<p>首先 分清楚 <em>sequential</em> commands (不同的命令采用 &amp;&amp; 或者 ；) 和 <em>piped</em> commands (采用管道符 | 连接) 。sequential commands 只是一个接一个运行而已，但是彼此之间没有关系。但是 piped command ，前一个命令的输出是下一个命令的输入。</p>
<p>采用 &amp;&amp; 和  ；的区别在于他们的退出状态，如果我们采用 <code>command1 ; command2</code> 的方式，无论 command1 退出状态是否正常，command2 都会运行。但是如果我们使用 <code>command1 &amp;&amp; command2</code>，那么<strong>只有command1 运行成功后才会运行 command2</strong>。但是 <strong>在 pipelines 不方便检查退出状态</strong>。</p>
<p>我们可以将多个命令打包放在一起，他们的输出结果会形成一个数据流。举例而言，第一条命令将<code>echo &quot;this command&quot;</code>  和 <code>echo &quot;that command&quot; | sed 's/command/step/'</code> 视为两条命令，因此 <code>this command</code> 没有变化。</p>
<p>第二条命令通过 （） 将前面的两条命令打包一块输出。（这里所谓的subshell 就是用括号将sequential commands 括起来）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &quot;this command&quot;; echo &quot;that command&quot; | sed &#39;s&#x2F;command&#x2F;step&#x2F;&#39;</span><br><span class="line">this command</span><br><span class="line">that step</span><br><span class="line"></span><br><span class="line">$ (echo &quot;this command&quot;; echo &quot;that command&quot;) | sed &#39;s&#x2F;command&#x2F;step&#x2F;&#39;</span><br><span class="line">this step</span><br><span class="line">that step</span><br></pre></td></tr></table></figure>
<p>假如我们想对一个 GTF 文件进行排序，但是由于GTF 文件具有注释行，我们希望是注释行不动，对数据部分进行排序。</p>
<p>我们就可以用 subshell 来解决这个问题。因为用了 （）里面的两条命令的结果输出为一个总的数据流，实现了<strong>不动表头，对数据进行排序</strong>的需求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ (zgrep &quot;^#&quot; Mus_musculus.GRCm38.75_chr1.gtf.gz; \</span><br><span class="line">zgrep -v &quot;^#&quot; Mus_musculus.GRCm38.75_chr1.gtf.gz | \</span><br><span class="line">sort -k1,1 -k4,4n) | less</span><br></pre></td></tr></table></figure>
<p>我们也可以使用 <code>&gt;</code> 重定向到一个文件中，但是最好是<code>gzip</code> 压缩一下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ (zgrep &quot;^#&quot; Mus_musculus.GRCm38.75_chr1.gtf.gz; \</span><br><span class="line">zgrep -v &quot;^#&quot; Mus_musculus.GRCm38.75_chr1.gtf.gz | \</span><br><span class="line">sort -k1,1 -k4,4n) | gzip &gt; Mus_musculus.GRCm38.75_chr1_sorted.gtf.gz</span><br></pre></td></tr></table></figure>
<p>这个subshell 可以使用python 来写代码完成，但是问题是更复杂了，而且不能直接处理压缩文件。</p>
<h3 id="7-4-2-Named-Pipes-and-Process-Substitution">7.4.2 Named Pipes and Process Substitution</h3>
<p>到目前为止，我们已经使用 pipes 来连接不同的命令行工具来创建定制的数据处理 pipelines。<strong>但是，有些软件不能和 unix pipes 连接上</strong>。比如有一些生信工具读写多个文件形式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ processing_tool --in1 in1.fq --in2 in2.fq --out1 out2.fq --out2.fq</span><br></pre></td></tr></table></figure>
<p>因为这里需要多个输入文件，因此我们将pipeline 前一步的输出结果作为这里的输入。相似的，这个软件生成了两个结果文件，这也没办法将它的输出作为另一个程序的标准输入。</p>
<p>除了不能使用 Unix pipe 将 processing_tool 与其他程序互相协作外，这里还有一个更严重的问题：<strong>使用这个程序我们需要从磁盘读取4个中间文件</strong>。如果这个程序在整个pipeline的中间步骤，那么很有可能会造成一个显著的计算瓶颈。</p>
<p>幸运的是，Unix 提供了一个解决办法：<em>named pipes</em>，也称之为 FIFO (First In First Out) 。</p>
<p>常见的pipeline 没有名称，而且只有运行的时候才存在于内存中。命令的pipes 就像文件一样，会一直存在你的文件系统中。采用 <code>mkfifo</code> 可以实现命名的pipe</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkfifo fqin</span><br><span class="line">$ ls -l fqin</span><br><span class="line">prw-rw-r-- 1 zhouziwen zhouziwen 0 Sep 15 10:41 fqin</span><br></pre></td></tr></table></figure>
<p>这个实际上就是一个特殊形式的文件：p 表示 pipe。举个简单的例子，我们可以使用 <code>echo</code> 来重定向一些文本到一个 named pipe 中，然后使用<code>cat</code> 打印内容。</p>
<p>注意：<strong>这个named pipe ，就像标准的pipe 一样，读取过的数据就不复存在了。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &quot;hello, named pipes&quot; &gt; fqin </span><br><span class="line">[1] 1536</span><br><span class="line">$ cat fqin</span><br><span class="line">hello, named pipes</span><br><span class="line">$ rm fqin</span><br><span class="line"></span><br><span class="line">$ cat fqin #再次读取，失败。</span><br><span class="line">cat: fqin: No such file or directory</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然这个语法很像是重定向到一个文件中，但是<strong>我们实际上没有向磁盘写入任何东西</strong>。因此 processing_tool 这种软件的输入输出均可以使用 named pipe 替代。</p>
<p>但是，创建和销毁这些 file-like named pipes 有一些枯燥无聊。这里有一种方式使用 named pipe 时 可以不用特地创建它们，称之为 <em>process substitution</em>, 或者 anonymous named pipes。举例如下 <code>&lt;(echo &quot;hello, process substitution&quot;)</code>  将里面的命令输出给一个 anonymous named pipe。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$  cat &lt;(echo &quot;hello, process substitution&quot;)</span><br><span class="line">hello, process substitution</span><br></pre></td></tr></table></figure>
<p>举例，上面的program 需要两个输入文件，这里没法用简单的 unix pipeline 。我们需要使用  <code>mkfifo</code> 创建两个 named pipes，也可以使用 process substitution。比如我们假设存在一个软件<code>makein</code> 可以创建输入文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">program --in1 &lt;(makein raw1.txt) --in2 &lt;(makein raw2.txt) \</span><br><span class="line">	--out1 out1.txt --out2 out2.txt</span><br></pre></td></tr></table></figure>
<p>process substitution 还可以用于<strong>输出文件中</strong>，这通常是用于大数据文件在写入磁盘前<strong>压缩</strong>（先写入磁盘，再压缩，会读写两个大文件，多花时间）。还是以上面的文件为例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">program --in1 in1.txt --in2 in2.txt \</span><br><span class="line">	--out1 &gt;(gzip &gt; out1.txt.gz) --out2 &gt;(gzip &gt; out2.txt.gz)</span><br></pre></td></tr></table></figure>
<h2 id="7-5-The-Unix-Philosophy-Revisited">7.5 The Unix Philosophy Revisited</h2>
<p>通读本章，Unix 哲学 – 采用 Unix pipe 来组合多个小的程序。 不仅仅是因为 Unix piped workflows 容易创建、容易 debug，而已<strong>unix pipe 通常也是计算效率最高的解决办法</strong>。</p>
<h1>8 A Rapid Introduction to the R Language</h1>
<p>这里主要是侧重 R语言在 <em>exploratory data analysis (EDA)</em> 方面的应用。</p>
<p>EDA 是一种互动式的对数据的探索。EDA 在整个的生信数据分析中都很重要。这些分析本身并不复杂或者很细致，但是可以满足我们想看一眼数据的需求。</p>
<p>在很多情况下，EDA ，特别是可视化，可以发现生信数据的模式（pattern），而这可能会被统计模型或假设检验忽视。我们的大脑是最精巧的 pattern-finding 工具，而 EDA 就是将数据用不同的方式展示给我们的大脑看，并让我们的大脑去寻找 pattern，从而可以找到有趣的生物信号或者展示出潜在的问题。相比于我们的大脑，统计检验是一个迟钝的工具，而且当处理复杂的多维度的数据时就更加迟钝，比如生信数据。</p>
<p>虽然这一章节强调 EDA 的重要性，但统计检验同样也很重要。</p>
<h2 id="8-1-Getting-Started-with-R-and-RStudio">8.1 Getting Started with R and RStudio</h2>
<h2 id="8-2-R-Language-Basics">8.2 R Language Basics</h2>
<h3 id="8-2-1-Simple-Calculations-in-R-Calling-Functions-and-Getting-Help-in-R">8.2.1 Simple Calculations in R, Calling Functions, and Getting Help in R</h3>
<p>R 参数要输入参数名称，虽然R支持不输入参数名称，但是这会影响代码的可读性。（受教了）</p>
<blockquote>
<p>First,  values  are  matched  to  arguments  by  name.  Technically,  R  also  allows  partial matching of argument names but I would discourage this, as it decreases code readability.  Second,  values  are  matched  based  on  position  within  the  argument  list.  For functions  that  have  many  arguments  with  default  values  such  as   foo(x, a=3, b=4, c=5), it’s easier to set an argument later in the function by specifying it by name.</p>
</blockquote>
<h3 id="8-2-2-Variables-and-Assignment">8.2.2 Variables and Assignment</h3>
<p>R 中的赋值符号除了 使用 <code>&lt;-</code>，还可以使用 <code>=</code>，但是 <code>&lt;-</code>是更加传统的做法。（感觉用=更好，与其他语言一致）。</p>
<p>通过 <code>ls()</code> 可以查看所有的 global environment 。当 R 需要查找一个变量名称时，它有一个查找路径和顺序。我们可以通过<code>search()</code> 函数查看 R 的查找路径（包括全局环境变量、打开的R包等）。</p>
<h3 id="8-2-3-Vectors-Vectorization-and-Indexing">8.2.3 Vectors, Vectorization, and Indexing</h3>
<p>R 语言最重要的特征就是它的向量。不像其他语言，R 没有<strong>标量</strong>的概念（a single value），这些值在R中实际上是长度为1的向量。</p>
<p>R的向量是R中一个最重要的特征的基础：<strong>向量化</strong>。**向量化支持我们去 loop over 向量元素，而不需要写一个具体的循环。**举例而言：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x &lt;- <span class="built_in">c</span>(<span class="number">56</span>, <span class="number">95.3</span>, <span class="number">0.4</span>)</span><br><span class="line">&gt; y &lt;- <span class="built_in">c</span>(<span class="number">3.2</span>, <span class="number">1.1</span>, <span class="number">0.2</span>)</span><br><span class="line">&gt; x + y</span><br><span class="line">[<span class="number">1</span>] <span class="number">59.2</span> <span class="number">96.4</span>  <span class="number">0.6</span></span><br><span class="line">&gt; x - y</span><br><span class="line">[<span class="number">1</span>] <span class="number">52.8</span> <span class="number">94.2</span>  <span class="number">0.2</span></span><br><span class="line">&gt; x/y</span><br><span class="line">[<span class="number">1</span>] <span class="number">17.50000</span> <span class="number">86.63636</span>  <span class="number">2.00000</span></span><br></pre></td></tr></table></figure>
<p>创建整数序列</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; seq(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">&gt; <span class="number">1</span>:<span class="number">5</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>对两个向量进行向量化操作时，如果两个向量长度不一致，那么R会循环使用短的向量的值。这时一种默认的行为，一般R不会给提示，<strong>除非长向量的长度不是短向量的整数倍</strong>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x</span><br><span class="line">[<span class="number">1</span>] <span class="number">56.0</span> <span class="number">95.3</span>  <span class="number">0.4</span></span><br><span class="line">&gt; x - <span class="number">3</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">53.0</span> <span class="number">92.3</span> -<span class="number">2.6</span></span><br></pre></td></tr></table></figure>
<p>当两个向量的长度不是整数倍的关系时，R会给出<strong>Warning</strong>提示：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">c</span>(<span class="number">1</span>, <span class="number">2</span>) + <span class="built_in">c</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line">&gt; <span class="built_in">c</span>(<span class="number">1</span>, <span class="number">2</span>) + <span class="built_in">c</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line">Warning message:</span><br><span class="line">In <span class="built_in">c</span>(<span class="number">1</span>, <span class="number">2</span>) + <span class="built_in">c</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) : 长的对象长度不是短的对象长度的整倍数</span><br></pre></td></tr></table></figure>
<p>这种向量化操作不仅仅时更加清晰，计算效率也更快。因为这个特性，R语言支持<strong>完全放弃for循环</strong>。</p>
<p>R 的索引从1开始。（不像python，从0开始）。<strong>如果索引超出了实际范围，R会返回NA值（“not available”）。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; x &lt;- c(56, 95.3, 0.4)</span><br><span class="line">&gt; x[2] </span><br><span class="line">[1] 95.3</span><br><span class="line">&gt; x[1]</span><br><span class="line">[1] 56</span><br><span class="line">&gt; x[4] </span><br><span class="line">[1] NA</span><br><span class="line">&gt; x[3] &lt;- 0.5</span><br><span class="line">&gt; x</span><br><span class="line">[1] 56.0 95.3  0.5</span><br></pre></td></tr></table></figure>
<p>向量也可以有名称（通过<code>names()</code>函数设定）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; b &lt;- c(a&#x3D;3.4, b&#x3D;5.4, c&#x3D;0.4)</span><br><span class="line">&gt; b</span><br><span class="line">a   b   c</span><br><span class="line">3.4 5.4 0.4</span><br><span class="line">&gt; names(b)</span><br><span class="line">[1] &quot;a&quot; &quot;b&quot; &quot;c&quot;</span><br><span class="line">&gt; names(b) &lt;- c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;) # change these names</span><br><span class="line">&gt; b</span><br><span class="line">  x   y   z </span><br><span class="line">3.4 5.4 0.4 </span><br><span class="line">&gt; b[&#39;x&#39;]</span><br><span class="line">  x </span><br><span class="line">3.4 </span><br></pre></td></tr></table></figure>
<p>也可以一次提取多个值，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; x[c(2,3)]</span><br><span class="line">[1] 95.3  0.4</span><br></pre></td></tr></table></figure>
<p>当使用索引提取子向量，出现NA值时，可能有两个原因：1，向量中这个值本身就是NA，即缺失；2，索引超出范围，返回NA。</p>
<p>R 支持使用负数来剔除某些索引</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x[-<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">95.3</span>  <span class="number">0.4</span></span><br><span class="line">&gt; y=<span class="number">1</span>:<span class="number">10</span></span><br><span class="line">&gt; y[-(<span class="number">2</span>:<span class="number">4</span>)]</span><br><span class="line">[<span class="number">1</span>]  <span class="number">1</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>我们也可以打乱索引，重排顺序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; z &lt;- c(3.4, 2.2, 0.4, -0.4, 1.2)</span><br><span class="line">&gt; z[5:1][1]  1.2 -0.4  0.4  2.2  3.4</span><br></pre></td></tr></table></figure>
<p>相似地，我们可以通过 R函数来给我们创造索引。比如，order() 函数能够返回一个索引向量，这个索引向量默认是按照元素递增的顺序。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; order(z)</span><br><span class="line">[<span class="number">1</span>] <span class="number">4</span> <span class="number">3</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line">&gt; z[order(z)]</span><br><span class="line">[<span class="number">1</span>] -<span class="number">0.4</span>  <span class="number">0.4</span>  <span class="number">1.2</span>  <span class="number">2.2</span>  <span class="number">3.4</span></span><br><span class="line">&gt; z[order(z, decreasing = <span class="literal">TRUE</span>)]</span><br><span class="line">[<span class="number">1</span>]  <span class="number">3.4</span>  <span class="number">2.2</span>  <span class="number">1.2</span>  <span class="number">0.4</span> -<span class="number">0.4</span></span><br></pre></td></tr></table></figure>
<p>就像我们采用一些函数生成索引向量，我们可以使用逻辑运算符来创建逻辑向量（<em>logical vectors</em>, 只包含TRUE 和 FALSE），比如 ==, !=, &gt;, &lt; 等等。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; v &lt;- <span class="built_in">c</span>(<span class="number">2.3</span>, <span class="number">6</span>, -<span class="number">3</span>, <span class="number">3.8</span>, <span class="number">2</span>, -<span class="number">1.1</span>)</span><br><span class="line">&gt; v == <span class="number">6</span></span><br><span class="line">[<span class="number">1</span>] <span class="literal">FALSE</span>  <span class="literal">TRUE</span> <span class="literal">FALSE</span> <span class="literal">FALSE</span> <span class="literal">FALSE</span> <span class="literal">FALSE</span></span><br><span class="line">&gt; v &lt;= -<span class="number">3</span></span><br><span class="line">[<span class="number">1</span>] <span class="literal">FALSE</span> <span class="literal">FALSE</span>  <span class="literal">TRUE</span> <span class="literal">FALSE</span> <span class="literal">FALSE</span> <span class="literal">FALSE</span></span><br><span class="line">&gt; <span class="built_in">abs</span>(v) &gt; <span class="number">5</span></span><br><span class="line">[<span class="number">1</span>] <span class="literal">FALSE</span>  <span class="literal">TRUE</span> <span class="literal">FALSE</span> <span class="literal">FALSE</span> <span class="literal">FALSE</span> <span class="literal">FALSE</span></span><br></pre></td></tr></table></figure>
<p><strong>逻辑向量很有用，因为他们可以直接用做索引向量</strong>。比如</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; v[<span class="built_in">c</span>(<span class="literal">TRUE</span>, <span class="literal">TRUE</span>, <span class="literal">FALSE</span>, <span class="literal">TRUE</span>, <span class="literal">FALSE</span>, <span class="literal">FALSE</span>)]</span><br><span class="line">[<span class="number">1</span>] <span class="number">2.3</span> <span class="number">6.0</span> <span class="number">3.8</span></span><br></pre></td></tr></table></figure>
<p>但是自己创建 由 TRUE和FALSE组成的逻辑向量很枯燥，因此可以直接使用比较运算符在索引中，比如下式</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; v[v &gt; <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">2.3</span> <span class="number">6.0</span> <span class="number">3.8</span></span><br></pre></td></tr></table></figure>
<p>向量类型</p>
<ul>
<li><strong>Numeric</strong> : 实数，R所有的数字<strong>默认是 numeric vector</strong>, 哪怕所有数字都是整数。</li>
<li><strong>Integer</strong> ：整数</li>
<li><strong>Character</strong>：字符串（<em>strings</em>）, r 和 其他语言一样，可以包括一些特殊字符，如 <code>\n</code>，<code>\t</code></li>
<li><strong>Logical</strong> :  TRUE FALSE （作者建议不要使用T F缩写，因为影响可读性，而且T F可能在代码中重定义了，比如 T &lt;- 0）</li>
</ul>
<p>R 中的特殊值</p>
<ul>
<li>
<p><strong>NA</strong> : 缺失值，对NA 值的任何操作都会返回一个NA值（比如 2+NA ）。通过 <code>is.na()</code> 查看所有的缺失值</p>
</li>
<li>
<p><strong>NULL</strong> :  NULL 表示没有一个值（NA 表示有一个值，但是缺失）（没看懂）</p>
<blockquote>
<p>NULL represents  not  having  a  value  (which  is  different  than  having  a  value  that’s missing).</p>
</blockquote>
</li>
<li>
<p><strong>-Inf, Inf</strong> ：negative infinite 和 positive infinite values。</p>
</li>
<li>
<p><strong>NaN</strong> ：”not a number&quot; , 这会发生在一些不返回值的计算中，比如 0/0</p>
</li>
</ul>
<p>R中的<strong>向量</strong>所有的元素必须是<strong>相同的数据类型</strong>。R 会 silently 强制使所有的元素具有相同的数据类型。</p>
<p>另一种你会碰到的向量类型是<strong>因子</strong>（factors）。因子存储分类变量。通过 <code>levels()</code> 查看因子型向量的所有水平。可以通过 <code>table()</code> 查看每个水平的重复数。</p>
<h2 id="8-3-WRorking-with-and-Visualizing-Data-in-R">8.3 WRorking with and Visualizing Data in R</h2>
<h3 id="8-3-1-Loading-Data-into-R">8.3.1 Loading Data into R</h3>
<p>对于一些大的基因组数据，仅仅在R中读取就很困难，会消耗大量内存，或者你的电脑没有足够的内存读入所有数据。在很多情况下，最好的策略是使用某种方式降低你的数据量：比如删除不需要的列，文件切分（比如每次只跑一条染色体），或者随机抽取一个子数据集。</p>
<p>如果你的内存够用，在R中加载数据可能也很慢。使用 read.csv() 等方式时，可以通过 <code>colClasses</code> 参数注明每一列的类型，这可以节约一半时间 （麻烦）。</p>
<p>使用 <code>data.table</code> 包的 <code>fread() </code> 函数是最快的方式。但是fread() 读取的不是 data.frame() 格式，而是 data.table() 格式 （暂时不清楚区别）。</p>
<p>使用 <code>data.frame()</code> 函数可以合并多个向量，创建新的数据集，而且可以设置列的名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; x &lt;- sample(1:50, 300, replace&#x3D;TRUE)</span><br><span class="line">&gt; y &lt;- 3.2*x + rnorm(300, 0, 40)</span><br><span class="line">&gt; d_sim &lt;- data.frame(y&#x3D;y, x&#x3D;x)</span><br></pre></td></tr></table></figure>
<h3 id="8-3-2-Exploring-and-Transforming-Dataframes">8.3.2 Exploring and Transforming Dataframes</h3>
<p>创建子集</p>
<ol>
<li>
<p><code>d$depth</code> : 索取一列</p>
</li>
<li>
<p>使用 [] 符号</p>
 <figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; d[ , <span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">&gt; d[ , <span class="built_in">c</span>(<span class="string">&quot;start&quot;</span>,<span class="string">&quot;end&quot;</span>)]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>作者建议不要使用这种方式截取特定的行，因为则可能会导致错误。相似地，提取列信息地最好的方式是<strong>使用列名</strong>，而不是位置，同样是面临可能取错列的问题，而且这样做可以<strong>提高代码的可读性</strong>。</p>
<p>当只提取数据集中的一列时，R默认返回一个向量——而不是一个单列的数据集。如果下游需要索取一个数据集时，这可能会导致错误。为了避免这种行为，我们可以通过设置 <code>drop = FALSE</code> 来避免</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; d[, &quot;start&quot;, drop&#x3D;FALSE]</span><br></pre></td></tr></table></figure>
<p>假如我们需要新增一列，这一列表示位点是否在25 ,800,000 to 29,700,000 的区间内。<code>&amp;</code> 是向量化操作的逻辑运算符。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; d$cent &lt;- (d$start &gt;= <span class="number">25800000</span> &amp; d$end &lt;= <span class="number">29700000</span>)</span><br></pre></td></tr></table></figure>
<h3 id="8-3-3-Exploring-Data-Through-Slicing-and-Dicing-Subsetting-Dataframes">8.3.3 Exploring Data Through Slicing and Dicing: Subsetting Dataframes</h3>
<p>挑出特定的行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; d[d$total.SNPs &gt;&#x3D; 85, ]</span><br></pre></td></tr></table></figure>
<p>使用 <code>which</code> 函数返回符合条件的索引值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; which(d$Pi &gt; 3)</span><br><span class="line">[1]  2  4  5  6  7 10 [...]</span><br></pre></td></tr></table></figure>
<p>因此， <code>d[d$Pi &gt; 3, ]</code> 和 <code>d[which(d$Pi &gt; 3), ]</code> 是等价的。</p>
<p><code>which</code> 还有两个相关的函数，返回<strong>第一个</strong>最大值和最小值的索引（也就是说，有重复的值也只返回第一个）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; d[which.min(d$total.Bases),]</span><br><span class="line">&gt; d[which.max(d$depth),]</span><br></pre></td></tr></table></figure>
<p>还可以使用 <code>subset</code> 函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; subset(d, Pi &gt; 16 &amp; percent.GC &gt; 80)</span><br></pre></td></tr></table></figure>
<h3 id="8-3-4-Exploring-Data-Visually-with-ggplot2-I-Scatterplots-and-Densities">8.3.4 Exploring Data Visually with ggplot2 I: Scatterplots and Densities</h3>
<p><strong>探索性数据分析</strong>强调<strong>可视化</strong> 是理解和探索数据的最好的工具。这里只介绍 ggplot2 的使用</p>
<p>一个简单的例子，这里由两块组成，ggplot() 函数 指定了使用的数据集；geom_point() 指定添加的图层，其中 aes() 函数英文为 aesthetics （美学）。aes() 函数同样可以放在ggplot() 函数中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ggplot(d) + geom_point(aes(x&#x3D;position, y&#x3D;diversity))</span><br><span class="line">ggplot(d, aes(x&#x3D;position, y&#x3D;diversity)) + geom_point()</span><br><span class="line">ggplot(d) + geom_point(aes(x&#x3D;position, y&#x3D;diversity, color&#x3D;cent))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过设置透明度，来避免点之间的重叠。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ggplot(d) + geom_point(aes(x&#x3D;position, y&#x3D;diversity), alpha&#x3D;0.01)</span><br></pre></td></tr></table></figure>
<p>通过密度图看分布。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ggplot(d) + geom_density(aes(x&#x3D;diversity), fill&#x3D;&quot;black&quot;)</span><br></pre></td></tr></table></figure>
<p>密度图可以分类，为了能够看到二者重叠的部分，需要设置透明度。</p>
<p>通过将额外的 aesthetic 属性 分配给别的分类变量，可以揭示分类变量不同水平的差别。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ggplot(d) + geom_density(aes(x&#x3D;diversity, fill&#x3D;cent), alpha&#x3D;0.4)</span><br></pre></td></tr></table></figure>
<h3 id="8-3-5-Exploring-Data-Visually-with-ggplot2-II-Smoothing">8.3.5 Exploring Data Visually with ggplot2 II: Smoothing</h3>
<p>上面提到使用散点图中的<strong>重叠</strong>现象会掩盖数据的真实的分布，我们可以通过设置透明度来避免；还有另外一种方法是通过 <code>geom_smooth()</code> 函数 来添加一个平滑曲线，来查看趋势。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ggplot(d, aes(x&#x3D;depth, y&#x3D;total.SNPs)) + geom_point() + geom_smooth()</span><br></pre></td></tr></table></figure>
<p>默认情况下，但是数据集超过1000行时，ggplot2 使用 <code>generalized additive models</code>(GAM) 来拟合曲线。</p>
<p>从图像中可以看到，当测序深度越高时，能够发现的SNP越多。</p>
<p>另外，GC 含量会影响测序质量（PCR 不能有效复制这些区域）。从加了拟合曲线的散点图可以看出，GC 含量确实对数据的测序深度有影响。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ggplot(d, aes(x&#x3D;X.GC, y&#x3D;depth)) + geom_point() + geom_smooth()</span><br></pre></td></tr></table></figure>
<h3 id="8-3-6-Binning-Data-with-cut-and-Bar-Plots-with-ggplot2">8.3.6 Binning Data with cut() and Bar Plots with ggplot2</h3>
<p>我们可以将连续变量进行分组，划分到不同的组里（binning），这个功能可以使用 <code>cut()</code> 函数实现，第二个参数是划分成几个组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; d$GC.binned &lt;- cut(d$percent.GC, 5)</span><br><span class="line">&gt; d$GC.binned</span><br><span class="line">&gt; table(d$GC.binned)</span><br><span class="line">(0.716,17.7]  (17.7,34.7]  (34.7,51.6]  (51.6,68.5] </span><br><span class="line">           6         4976        45784         8122 </span><br><span class="line"> (68.5,85.6] </span><br><span class="line">         252 </span><br></pre></td></tr></table></figure>
<p>也可以自己划分组，但是如果手动划分的组不能包括所有的值，那么组外的值会返回NA。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; cut(d$percent.GC, c(0, 25, 50, 75, 100))</span><br></pre></td></tr></table></figure>
<p>通过 <code>cut()</code> 函数生成的 bins 的可视化的最好办法是条形图。如果 <code>geom_bar()</code> 给定的aes 中是一个分类变量，会根据计数创造条形图；如果给定的 aes 中是一个连续变量，那么 <code>geom_bar()</code> 会自动分组，然后创造一个直方图。（<strong>条形图和直方图的区别在于分类变量和连续变量</strong>）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt;  ggplot(d) + geom_bar(aes(x=GC.binned))</span><br><span class="line">&gt;  ggplot(d) + geom_bar(aes(x=percent.GC))</span><br></pre></td></tr></table></figure>
<p>查看某一分类变量对密度图的影响（根本分不清楚）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; ggplot(d) + geom_density(aes(x&#x3D;depth, linetype&#x3D;GC.binned), alpha&#x3D;0.5)</span><br></pre></td></tr></table></figure>
<h3 id="8-3-7-Merging-and-Combining-Data-Matching-Vectors">8.3.7 Merging and Combining Data: Matching Vectors</h3>
<h3 id="and-Merging-Dataframes">and Merging Dataframes</h3>
<p>在生信分析，我们需要用到多个数据集，因此如何合并使用不同的数据集是一个重要的能力。</p>
<p>最简单的匹配两个向量的操作就是使用 <code>%in%</code> 函数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">c</span>(<span class="number">3</span>, <span class="number">4</span>, -<span class="number">1</span>) %in% <span class="built_in">c</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>)</span><br><span class="line">[<span class="number">1</span>]  <span class="literal">TRUE</span>  <span class="literal">TRUE</span> <span class="literal">FALSE</span></span><br></pre></td></tr></table></figure>
<p>我去，<code>read.delim()</code>  或 <code>read.table()</code> 可以直接读取压缩文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reps &lt;- read.delim(&quot;chrX_rmsk.txt.gz&quot;, header&#x3D;TRUE)</span><br><span class="line">#reps2 &lt;- read.table(&quot;chrX_rmsk.txt.gz&quot;, header&#x3D;TRUE)</span><br><span class="line"></span><br><span class="line">head(reps2,3)</span><br></pre></td></tr></table></figure>
<p>假如我们要挑某一列中某些水平的行，可以使用 <code>%in%</code> 这么写（而不是使用多个判断）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">common_repclass &lt;- c(&quot;SINE&quot;, &quot;LINE&quot;, &quot;LTR&quot;, &quot;DNA&quot;, &quot;Simple_repeat&quot;)</span><br><span class="line">reps[reps$repClass %in% common_repclass, ]</span><br></pre></td></tr></table></figure>
<p><code>%in%</code> 是 <code>match()</code> 函数的简化版本。<code>%in%</code>  对每一个 x 的值返回 TRUE/FALSE。而 <code>match(x,y)</code> 返回 每一个 x 的值在y 中第一次出现的位置，如果没有匹配到，会返回一个 NA 值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; match(c(&quot;A&quot;, &quot;C&quot;, &quot;E&quot;, &quot;A&quot;), c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;E&quot;))</span><br><span class="line">[1]  1 NA  4  1</span><br></pre></td></tr></table></figure>
<p>match 函数 可以通过一个共同的列合并两个数据集。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; mtfs &lt;- read.delim(&quot;motif_recombrates.txt&quot;, header&#x3D;TRUE)</span><br><span class="line">&gt; head(mtfs, 3)</span><br><span class="line">&gt; rpts &lt;- read.delim(&quot;motif_repeats.txt&quot;, header&#x3D;TRUE)</span><br><span class="line">&gt; head(rpts, 3)</span><br></pre></td></tr></table></figure>
<p>合并两列内容，形成一个两个文件均有的新列，这个 pos 列可以作为两个文件共有的列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; mtfs$pos &lt;- paste(mtfs$chr, mtfs$motif_start, sep&#x3D;&quot;-&quot;)</span><br><span class="line">&gt; rpts$pos &lt;- paste(rpts$chr, rpts$motif_start, sep&#x3D;&quot;-&quot;)</span><br></pre></td></tr></table></figure>
<p>合并前，你需要知道两个文件确实共同拥有一列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; table(mtfs$pos %in% rpts$pos)</span><br><span class="line">FALSE  TRUE </span><br><span class="line">10832  9218 </span><br></pre></td></tr></table></figure>
<p>但是注意：这里方向很重要，如果反过来就不能说明问题了。（因为 mtfs 数据量小）</p>
<blockquote>
<p>you don’t go looking for a haystack in a needle !</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; table(rpts$pos %in% mtfs$pos)</span><br><span class="line"></span><br><span class="line">TRUE </span><br><span class="line"> 317 </span><br></pre></td></tr></table></figure>
<p>现在我们可以通过 <code>match</code> 函数 来找出哪些行是共同的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; i &lt;- match(mtfs$pos, rpts$pos)</span><br></pre></td></tr></table></figure>
<p>这里如果没有匹配上就会返回 NA。</p>
<p>然后我们就可以挑出 rpts$name 列中相应的元素，然后合并到 mtfs 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; mtfs$repeat_name &lt;- rpts$name[i]</span><br></pre></td></tr></table></figure>
<p>当然也可以一步到位</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; mtfs$repeat_name &lt;- rpts$name[match(mtfs$pos, rpts$pos)]</span><br></pre></td></tr></table></figure>
<p>合并数据后的最后一步是：验证、验证、验证。从上面可以看到，使用merge() 函数合并不同的数据集的信息，这样做是很挑巧的，这很容易犯错。因此需要外部验证，找几个数据来看一下</p>
<p>事实上，R 中 有一个更加用户友好的合并参数 ：merge() 。 相同的列后面会添加列名称（这里是 .x .y）。默认 merge() 函数 采用内连接，可以通过 <code>all.x = TRUE</code>，设置为左连接；同样的，通过 <code>all.y = TRUE</code>，设置为左连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; recm &lt;- merge(mtfs, rpts, by.x&#x3D;&quot;pos&quot;, by.y&#x3D;&quot;pos&quot;)</span><br><span class="line">&gt; head(recm, 2)</span><br></pre></td></tr></table></figure>
<h3 id="8-3-8-Using-ggplot2-Facets">8.3.8 Using ggplot2 Facets</h3>
<p>这里使用分面来进行数据的可视化，首先看一下数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; p &lt;- ggplot(mtfs, aes(x&#x3D;dist, y&#x3D;recom)) + geom_point(size&#x3D;1)</span><br><span class="line">&gt; p &lt;- p + geom_smooth(method&#x3D;&quot;loess&quot;, se&#x3D;FALSE, span&#x3D;1&#x2F;10)</span><br><span class="line">&gt; print(p)</span><br></pre></td></tr></table></figure>
<p>分面：ggplot2 有两个分面函数：<code>facet_wrap()</code> 和 <code>facet_grid()</code> 。<code>facet_wrap()</code> 需要一个因子变量，然后对其中的每一个水平均创建一个 panel。<code>facet_grid()</code> 可以设置地更加细腻，来划分哪列用于垂直分面，哪列用于水平分列。</p>
<p>这里用到的 ~ 符号是用来指定 R中的模型的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; p &lt;- ggplot(mtfs, aes(x&#x3D;dist, y&#x3D;recom)) + geom_point(size&#x3D;1, color&#x3D;&quot;grey&quot;)</span><br><span class="line">&gt; p &lt;- p + geom_smooth(method&#x3D;&#39;loess&#39;, se&#x3D;FALSE, span&#x3D;1&#x2F;10)</span><br><span class="line">&gt; p &lt;- p + facet_wrap(~ motif)</span><br><span class="line">&gt; print(p)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; p &lt;- ggplot(mtfs, aes(x&#x3D;dist, y&#x3D;recom)) + geom_point(size&#x3D;1, color&#x3D;&quot;grey&quot;)</span><br><span class="line">&gt; p &lt;- p + geom_smooth(method&#x3D;&#39;loess&#39;, se&#x3D;FALSE, span&#x3D;1&#x2F;10)</span><br><span class="line">&gt; p &lt;- p + facet_grid(repeat_name ~ motif)</span><br><span class="line">&gt; print(p)</span><br></pre></td></tr></table></figure>
<h3 id="8-3-9-More-R-Data-Structures-Lists">8.3.9 More R Data Structures: Lists</h3>
<p>R 中 的列表 可以包括不同类型的元素；每个元素可以是任何对象（其他列表，数据库，矩阵，向量等）。</p>
<p>其实你在不知不觉中已经在使用 list 了，之前使用的数据集其实就是 list 。</p>
<p>创建 list</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; adh &lt;- list(chr&#x3D;&quot;2L&quot;, start&#x3D;14615555L, end&#x3D;14618902L, name&#x3D;&quot;Adh&quot;)</span><br><span class="line">&gt; adh</span><br></pre></td></tr></table></figure>
<p>列表取子集，由于列表中包换多种类型的数据，因此取子集默认还是一个列表，还有一种方式可以提取列表中的某个元素，就是使用两个方括号（这样得到的就不是一个列表了）。采用 <code>$</code> 符号也可以提取元素，这和数据集（dataframe）操作相同，这并不是巧合，而是因为数据集本身就是从列表中来的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adh[1:2]</span><br><span class="line">adh[[1]]</span><br><span class="line">adh$chr #返回元素</span><br><span class="line">adh[&quot;chr&quot;] #返回列表</span><br></pre></td></tr></table></figure>
<p>由于 列表结构可能非常复杂，我们可以使用 <code>str()</code> 函数查看列表结构。</p>
<p>更改列表的值</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; adh$id &lt;- <span class="string">&quot;FBgn0000055&quot;</span></span><br><span class="line">&gt; adh$id &lt;- <span class="literal">NULL</span> <span class="comment">#删除某个值</span></span><br></pre></td></tr></table></figure>
<h3 id="8-3-10-Writing-and-Applying-Functions-to-Lists-with-lapply-and-sapply">8.3.10 Writing and Applying Functions to Lists with lapply() and sapply()</h3>
<p>使用 <code>lapply</code></p>
<p>假设我们有以下的列表数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; ll &lt;- list(a&#x3D;rnorm(6, mean&#x3D;1), b&#x3D;rnorm(6, mean&#x3D;4), c&#x3D;rnorm(6, mean&#x3D;6))</span><br></pre></td></tr></table></figure>
<p>我们如何获得列表中每个向量的均值呢？首先，我们可以使用 for 循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll_means &lt;- numeric(length(ll))</span><br><span class="line"></span><br><span class="line"># loop over each list element and calculate mean</span><br><span class="line">for (i in seq_along(ll)) &#123;</span><br><span class="line">	ll_means[i] &lt;- mean(ll[[i]])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，这并不符合R的语言习惯，一个更好的方式是采用一个 apply 函数，对 list 的每一个元素采用相同的函数。这里 我们使用 <code>lapply()</code> 函数（第一个 l 表示 list），但是同样会返回一个list</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; lapply(ll, mean)</span><br></pre></td></tr></table></figure>
<p>使用 <code>lapply()</code> 函数的好处在于：代码苏更少，更清晰，某些情况下甚至比 for 循环更快。</p>
<p>使用 <code>lapply()</code> 函数的一个重要特征是可以<strong>平行计算</strong>。R 中的 parallel 包存在一个 lapply() 函数的平行计算版本 <code>mclapply()</code>（mc 表示 multicore）。</p>
<p>这个函数会使用你在 options() 函数设置的核心数（如果不设置，会使用两个核心。）（注意，lapply 和 mclapply  接的函数只有名称，没有括号和参数）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; library(parallel)</span><br><span class="line">&gt; results &lt;- mclapply(my_samples, slowFunction)</span><br><span class="line">&gt; options(cores&#x3D;3)</span><br><span class="line">&gt; getOption(&#39;cores&#39;)</span><br></pre></td></tr></table></figure>
<p>对于列表中有NA的，lapply ()  还需要添加的参数。一般来说传递参数的时候需要写参数名，一方面提高代码的可读性，一方面避免用错了参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; ll$a[3] &lt;- NA</span><br><span class="line">&gt; lapply(ll, mean)</span><br><span class="line">$a</span><br><span class="line">[1] NA</span><br><span class="line">$b</span><br><span class="line">[1] 4.19003</span><br><span class="line">$c</span><br><span class="line">[1] 5.53541</span><br><span class="line">&gt; lapply(ll, mean, na.rm&#x3D;TRUE)</span><br><span class="line">$a</span><br><span class="line">[1] 1.216768</span><br><span class="line">$b</span><br><span class="line">[1] 4.19003</span><br><span class="line">$c</span><br><span class="line">[1] 5.53541</span><br></pre></td></tr></table></figure>
<p>你可以把 <code>mean()</code> 包装到另外一个函数中，这样就能添加额外的参数了。R 中函数的 <code>return</code> 是可选的，默认会见最后一行表达式返给 <code>return</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">meanRemoveNA &lt;- <span class="keyword">function</span>(x)&#123;</span><br><span class="line">  mean(x,na.rm = <span class="literal">TRUE</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lapply(ll,meanRemoveNA)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于我们需要经常使用的函数，我们需要打磨这些函数，可以让函数的文档输出功能更完善，也可以增加一些额外的功能。比如下面这一版的函数会提醒用户，移除了一些缺失值（这个功能可以通过设置 <code>warn=FALSE</code> 关闭）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">meanRemoveNAVerbose &lt;- <span class="keyword">function</span>(x, warn=<span class="literal">TRUE</span>) &#123;</span><br><span class="line">	<span class="comment"># A function that removes missing values when calculating the mean</span></span><br><span class="line">	<span class="comment"># and warns us about it.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">any</span>(<span class="built_in">is.na</span>(x)) &amp;&amp; warn) &#123;</span><br><span class="line">		warning(<span class="string">&quot;removing some missing values!&quot;</span>)</span><br><span class="line">		&#125;  </span><br><span class="line">     mean(x, na.rm=<span class="literal">TRUE</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数中定义的变量是<strong>局部变量</strong>，不会影响同名的全局变量。</p>
<p>函数的优点是<strong>可重复利用</strong>，缺点<strong>难以debug</strong>。但是，在R中，存在很多Debug的函数，比如 <code>browser()</code> 函数，可以中断函数。运行后输入 n (执行下一行) ， c (继续执行这一行) ， Q（退出）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">foo &lt;- <span class="keyword">function</span>(x) &#123;</span><br><span class="line">  a &lt;- 2  </span><br><span class="line">  <span class="built_in">browser</span>()  </span><br><span class="line">  y &lt;- x + a</span><br><span class="line">  <span class="built_in">return</span>(y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; foo(<span class="number">1</span>)</span><br><span class="line">Called from: foo(<span class="number">1</span>)</span><br><span class="line">Browse[<span class="number">1</span>]&gt;</span><br><span class="line">Browse[<span class="number">1</span>]&gt; n</span><br><span class="line">debug at <span class="comment">#4: y &lt;- x + a</span></span><br><span class="line">Browse[<span class="number">2</span>]&gt; n</span><br><span class="line">debug at <span class="comment">#5: return(y)</span></span><br><span class="line">Browse[<span class="number">2</span>]&gt; y</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="8-3-11-Working-with-the-Split-Apply-Combine-Pattern">8.3.11 Working with the Split-Apply-Combine Pattern</h3>
<p>一种常见的数据分析方法是<strong>先将需要分析的数据分组，对每组数据应用一个函数，然后合并结果</strong>，称之为 <em>split-apply-combine</em>。</p>
<p>首先我们先使用 <code>split()</code> 函数通过 d$GC.binned （factor）将 d$depth 切分为一个列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; d_split &lt;- split(d$depth, d$GC.binned)</span><br><span class="line">&gt; str(d_split)</span><br><span class="line">List of 5</span><br><span class="line"> $ (0.716,17.7]: num [1:6] 4.57 1.12 6.95 2.66 3.69 3.87</span><br><span class="line"> $ (17.7,34.7] : num [1:4976] 8 8.38 9.02 10.31 12.09 ...</span><br><span class="line"> $ (34.7,51.6] : num [1:45784] 6.68 9.06 10.26 8.06 7.05 ...</span><br><span class="line"> $ (51.6,68.5] : num [1:8122] 3.41 7 6.63 7.15 6.97 4.77 5.18 6.6 6.62 5.05 ...</span><br><span class="line"> $ (68.5,85.6] : num [1:252] 8.04 1.96 3.71 1.97 4.82 4.22 3.76 3.84 1.85 1.05 ...</span><br></pre></td></tr></table></figure>
<p>之后我们可以通过 <code>lapply()</code> 函数对每组数据采用相同的函数处理</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; lapply(d_split, mean)</span><br><span class="line">$`(0.716,17.7]`</span><br><span class="line">[<span class="number">1</span>] <span class="number">3.8</span></span><br><span class="line"></span><br><span class="line">$`(17.7,34.7]`</span><br><span class="line">[<span class="number">1</span>] <span class="number">8.8</span></span><br><span class="line"></span><br><span class="line">$`(34.7,51.6]`</span><br><span class="line">[<span class="number">1</span>] <span class="number">8.3</span></span><br><span class="line"></span><br><span class="line">$`(51.6,68.5]`</span><br><span class="line">[<span class="number">1</span>] <span class="number">7.3</span></span><br><span class="line"></span><br><span class="line">$`(68.5,85.6]`</span><br><span class="line">[<span class="number">1</span>] <span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后，我们需要整合结果（这里结果就是我们想要的），比如我们可以使用<code>unlist()</code> 函数将结果的列表形式转化为向量（ following  R’s  coercion  rules）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; unlist(lapply(d_split, mean))</span><br><span class="line">(<span class="number">0.716</span>,<span class="number">17.7</span>]  (<span class="number">17.7</span>,<span class="number">34.7</span>]  (<span class="number">34.7</span>,<span class="number">51.6</span>]  (<span class="number">51.6</span>,<span class="number">68.5</span>] </span><br><span class="line">         <span class="number">3.8</span>          <span class="number">8.8</span>          <span class="number">8.3</span>          <span class="number">7.3</span> </span><br><span class="line"> (<span class="number">68.5</span>,<span class="number">85.6</span>] </span><br><span class="line">         <span class="number">4.0</span> </span><br></pre></td></tr></table></figure>
<p>对于一个列表中每个元素中具有多个值的情况，可以联合使用 <code>do.call()</code> 函数和<code>rbind()</code>函数将列表其转化为一个矩阵。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; do.call(rbind, lapply(split(d$depth, d$GC.binned), summary))</span><br><span class="line">             Min. <span class="number">1</span>st Qu. Median Mean <span class="number">3</span>rd Qu. Max.</span><br><span class="line">(<span class="number">0.716</span>,<span class="number">17.7</span>]  <span class="number">1.1</span>     <span class="number">2.9</span>    <span class="number">3.8</span>  <span class="number">3.8</span>     <span class="number">4.4</span>  <span class="number">7.0</span></span><br><span class="line">(<span class="number">17.7</span>,<span class="number">34.7</span>]   <span class="number">1.0</span>     <span class="number">7.7</span>    <span class="number">8.7</span>  <span class="number">8.8</span>     <span class="number">9.8</span> <span class="number">17.8</span></span><br><span class="line">(<span class="number">34.7</span>,<span class="number">51.6</span>]   <span class="number">1.0</span>     <span class="number">7.1</span>    <span class="number">8.3</span>  <span class="number">8.3</span>     <span class="number">9.5</span> <span class="number">21.9</span></span><br><span class="line">(<span class="number">51.6</span>,<span class="number">68.5</span>]   <span class="number">1.0</span>     <span class="number">6.0</span>    <span class="number">7.2</span>  <span class="number">7.3</span>     <span class="number">8.5</span> <span class="number">21.2</span></span><br><span class="line">(<span class="number">68.5</span>,<span class="number">85.6</span>]   <span class="number">1.0</span>     <span class="number">2.7</span>    <span class="number">4.0</span>  <span class="number">4.0</span>     <span class="number">5.2</span>  <span class="number">9.7</span></span><br></pre></td></tr></table></figure>
<p>R 本身还有一些比较方便的函数，比如 <code>tapply()</code> 和 <code>aggregate()</code>可以一步到位实现上面的功能。</p>
<p>那为什么还要像上面那样使用 <code>split()</code> <code>lapply()</code>  <code>do.call()</code> 函数一步一步去做呢？第一，一步一步做可以让你很灵活，中间可以改；第二，使用 dplyr 包 可以更方便地实现这个功能。</p>
<p><img src="31.png" alt="31"></p>
<h4 id="Understanding-do-call">Understanding do.call()</h4>
<p>在R中，运行函数需要写明函数名和参数名，比如 <code>func(arg1, arg2, arg3)</code>，func 是函数名， arg1、arg2 、arg3 是参数名。</p>
<p>do.call() 可以让你通过使用一个函数名和 <strong>一个参数的列表</strong>  来使用函数。比如 <code>func(arg1, arg2, arg3)</code>  等价于 <code>do.call(func, list(arg1, arg2, arg3))</code> 。如果传递给 do.call() 函数的列表的元素都有名称，这些元素的名称会匹配函数的参数名称。比如，对于 <code>rnorm()</code> 函数，可以这么写：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; do.call(rnorm, <span class="built_in">list</span>(n=<span class="number">4</span>, mean=<span class="number">3.3</span>, sd=<span class="number">4</span>))</span><br><span class="line">[<span class="number">1</span>] <span class="number">8.351817</span> <span class="number">1.995067</span> <span class="number">8.619197</span> <span class="number">8.389717</span></span><br></pre></td></tr></table></figure>
<p><code>do.call()</code> 看上去复杂，但是当函数需要使用的参数都在一个<strong>list</strong>里，这种传参方法就很实用，比如这里使用<code>cbind()</code> 或 <code>rbind()</code> 函数整合结果。</p>
<h3 id="8-3-12-Exploring-Dataframes-with-dplyr">8.3.12 Exploring Dataframes with dplyr</h3>
<p>在 R 中的数据操作都与<strong>数据框</strong>有关。dplyr 巩固和简化了很多设计数据框的操作，而且 dplyr 速度很快，它的核心函数是用 C++写的。</p>
<p>dplyr 有5个操作数据框的基本函数：arrange(), filter(), mutate(), select(), summarize()。这些你都可以用R 的基础函数实现，但是 dplyr 的优势在于稳定、速度快并且用途广。</p>
<p>通常数据框的行数和列数都很多，无法全部在屏幕上打印出来，<code>dplyr</code> 使用一个 函数 <code>tbl_df</code> 可以折叠数据框，这样 print 的时候不会铺满全屏（相当于 head()）(到这里都感觉没什么用)</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; install.packages(<span class="string">&quot;dplyr&quot;</span>) <span class="comment"># install dplyr if it&#x27;s not already installed</span></span><br><span class="line">&gt; library(dplyr)</span><br><span class="line">&gt; d_df &lt;- tbl_df(d)</span><br><span class="line">&gt; d_df</span><br><span class="line"><span class="comment"># A tibble: 59,140 x 20</span></span><br><span class="line">   start   end total.SNPs total.Bases depth unique.SNPs</span><br><span class="line">   &lt;int&gt; &lt;int&gt;      &lt;int&gt;       &lt;int&gt; &lt;dbl&gt;       &lt;int&gt;</span><br><span class="line"> <span class="number">1</span> <span class="number">55001</span> <span class="number">56000</span>          <span class="number">0</span>        <span class="number">1894</span>  <span class="number">3.41</span>           <span class="number">0</span></span><br><span class="line"> <span class="number">2</span> <span class="number">56001</span> <span class="number">57000</span>          <span class="number">5</span>        <span class="number">6683</span>  <span class="number">6.68</span>           <span class="number">2</span></span><br><span class="line"> <span class="number">3</span> <span class="number">57001</span> <span class="number">58000</span>          <span class="number">1</span>        <span class="number">9063</span>  <span class="number">9.06</span>           <span class="number">1</span></span><br><span class="line"> <span class="number">4</span> <span class="number">58001</span> <span class="number">59000</span>          <span class="number">7</span>       <span class="number">10256</span> <span class="number">10.3</span>            <span class="number">3</span></span><br><span class="line"> <span class="number">5</span> <span class="number">59001</span> <span class="number">60000</span>          <span class="number">4</span>        <span class="number">8057</span>  <span class="number">8.06</span>           <span class="number">4</span></span><br><span class="line"> <span class="number">6</span> <span class="number">60001</span> <span class="number">61000</span>          <span class="number">6</span>        <span class="number">7051</span>  <span class="number">7.05</span>           <span class="number">2</span></span><br><span class="line"> <span class="number">7</span> <span class="number">61001</span> <span class="number">62000</span>          <span class="number">7</span>        <span class="number">6950</span>  <span class="number">6.95</span>           <span class="number">2</span></span><br><span class="line"> <span class="number">8</span> <span class="number">62001</span> <span class="number">63000</span>          <span class="number">1</span>        <span class="number">8834</span>  <span class="number">8.83</span>           <span class="number">1</span></span><br><span class="line"> <span class="number">9</span> <span class="number">63001</span> <span class="number">64000</span>          <span class="number">1</span>        <span class="number">9629</span>  <span class="number">9.63</span>           <span class="number">1</span></span><br><span class="line">10 <span class="number">64001</span> <span class="number">65000</span>          <span class="number">3</span>        <span class="number">7999</span>  <span class="number">8</span>              <span class="number">1</span></span><br><span class="line"><span class="comment"># ... with 59,130 more rows, and 14 more variables:</span></span><br><span class="line"><span class="comment">#   dhSNPs &lt;int&gt;, reference.Bases &lt;int&gt;, Theta &lt;dbl&gt;,</span></span><br><span class="line"><span class="comment">#   Pi &lt;dbl&gt;, Heterozygosity &lt;dbl&gt;, X.GC &lt;dbl&gt;,</span></span><br><span class="line"><span class="comment">#   Recombination &lt;dbl&gt;, Divergence &lt;dbl&gt;, Constraint &lt;int&gt;,</span></span><br><span class="line"><span class="comment">#   SNPs &lt;int&gt;, position &lt;dbl&gt;, diversity &lt;dbl&gt;, cent &lt;lgl&gt;,</span></span><br><span class="line"><span class="comment">#   GC.binned &lt;fct&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们可以使用 <code>select()</code> 函数挑选某些列</p>
<p>这和 <code>d[, c(&quot;start&quot;, &quot;end&quot;, &quot;Pi&quot;, &quot;Recombination&quot;, &quot;depth&quot;)]</code> 是等价的，但是 select 可以省略双引号。<code>select()</code> 可以写一个列的范围，比如 <code>select(d_df, start:total.Bases)</code> ，而且你可以通过在范围前面加一个负号，来剔除某些列。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; select(d_df, start, end, Pi, Recombination, depth)</span><br><span class="line"> start   end    Pi Recombination depth</span><br><span class="line">   &lt;int&gt; &lt;int&gt; &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;</span><br><span class="line"> <span class="number">1</span> <span class="number">55001</span> <span class="number">56000</span>  <span class="number">0</span>          <span class="number">0.00960</span>  <span class="number">3.41</span></span><br><span class="line"> <span class="number">2</span> <span class="number">56001</span> <span class="number">57000</span> <span class="number">10.4</span>        <span class="number">0.00960</span>  <span class="number">6.68</span></span><br><span class="line"> <span class="number">3</span> <span class="number">57001</span> <span class="number">58000</span>  <span class="number">1.99</span>       <span class="number">0.00960</span>  <span class="number">9.06</span></span><br><span class="line"> <span class="number">4</span> <span class="number">58001</span> <span class="number">59000</span>  <span class="number">9.56</span>       <span class="number">0.00960</span> <span class="number">10.3</span> </span><br><span class="line"> <span class="number">5</span> <span class="number">59001</span> <span class="number">60000</span>  <span class="number">8.51</span>       <span class="number">0.00960</span>  <span class="number">8.06</span></span><br><span class="line"> <span class="number">6</span> <span class="number">60001</span> <span class="number">61000</span>  <span class="number">9.12</span>       <span class="number">0.00960</span>  <span class="number">7.05</span></span><br><span class="line"> <span class="number">7</span> <span class="number">61001</span> <span class="number">62000</span>  <span class="number">8.06</span>       <span class="number">0.00960</span>  <span class="number">6.95</span></span><br><span class="line"> <span class="number">8</span> <span class="number">62001</span> <span class="number">63000</span>  <span class="number">2.06</span>       <span class="number">0.00960</span>  <span class="number">8.83</span></span><br><span class="line"> <span class="number">9</span> <span class="number">63001</span> <span class="number">64000</span>  <span class="number">1.88</span>       <span class="number">0.00960</span>  <span class="number">9.63</span></span><br><span class="line">10 <span class="number">64001</span> <span class="number">65000</span>  <span class="number">5.41</span>       <span class="number">0.00958</span>  <span class="number">8</span>   </span><br><span class="line"><span class="comment"># ... with 59,130 more rows</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; select(d_df, -(start:cent))</span><br><span class="line">  GC.binned  </span><br><span class="line">   &lt;fct&gt;      </span><br><span class="line"> <span class="number">1</span> (<span class="number">51.6</span>,<span class="number">68.5</span>]</span><br><span class="line"> <span class="number">2</span> (<span class="number">34.7</span>,<span class="number">51.6</span>]</span><br><span class="line"> <span class="number">3</span> (<span class="number">34.7</span>,<span class="number">51.6</span>]</span><br><span class="line"> <span class="number">4</span> (<span class="number">34.7</span>,<span class="number">51.6</span>]</span><br><span class="line"> <span class="number">5</span> (<span class="number">34.7</span>,<span class="number">51.6</span>]</span><br><span class="line"> <span class="number">6</span> (<span class="number">34.7</span>,<span class="number">51.6</span>]</span><br><span class="line"> <span class="number">7</span> (<span class="number">34.7</span>,<span class="number">51.6</span>]</span><br><span class="line"> <span class="number">8</span> (<span class="number">34.7</span>,<span class="number">51.6</span>]</span><br><span class="line"> <span class="number">9</span> (<span class="number">34.7</span>,<span class="number">51.6</span>]</span><br><span class="line">10 (<span class="number">17.7</span>,<span class="number">34.7</span>]</span><br><span class="line"><span class="comment"># ... with 59,130 more rows</span></span><br></pre></td></tr></table></figure>
<p>你可以使用 filter() 函数取子集，比如 <code>d[d$Pi  &gt;  16  &amp;  d$percent.GC  &gt;  80,  ]</code>， 在 <code>filter()</code> 函数中 多个条件使用逗号 <code>,</code> 分隔</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; filter(d_df, Pi &gt; <span class="number">16</span>, X.GC &gt; <span class="number">80</span>)</span><br><span class="line"> start    end total.SNPs total.Bases depth unique.SNPs</span><br><span class="line">   &lt;int&gt;  &lt;int&gt;      &lt;int&gt;       &lt;int&gt; &lt;dbl&gt;       &lt;int&gt;</span><br><span class="line">1 <span class="number">6.31e7</span> <span class="number">6.31e7</span>          <span class="number">5</span>         <span class="number">947</span>  <span class="number">2.39</span>           <span class="number">2</span></span><br><span class="line">2 <span class="number">6.32e7</span> <span class="number">6.32e7</span>          <span class="number">2</span>        <span class="number">1623</span>  <span class="number">3.21</span>           <span class="number">2</span></span><br><span class="line">3 <span class="number">6.32e7</span> <span class="number">6.32e7</span>          <span class="number">5</span>        <span class="number">1395</span>  <span class="number">1.89</span>           <span class="number">3</span></span><br><span class="line"><span class="comment"># ... with 14 more variables: dhSNPs &lt;int&gt;,</span></span><br><span class="line"><span class="comment">#   reference.Bases &lt;int&gt;, Theta &lt;dbl&gt;, Pi &lt;dbl&gt;,</span></span><br><span class="line"><span class="comment">#   Heterozygosity &lt;dbl&gt;, X.GC &lt;dbl&gt;, Recombination &lt;dbl&gt;,</span></span><br><span class="line"><span class="comment">#   Divergence &lt;dbl&gt;, Constraint &lt;int&gt;, SNPs &lt;int&gt;,</span></span><br><span class="line"><span class="comment">#   position &lt;dbl&gt;, diversity &lt;dbl&gt;, cent &lt;lgl&gt;,</span></span><br><span class="line"><span class="comment">#   GC.binned &lt;fct&gt;</span></span><br></pre></td></tr></table></figure>
<p>你可以使用 <code>arrange()</code> 来简化排序的操作，比如 <code>d[order(d$X.GC), ]</code></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; arrange(d_df, depth)</span><br><span class="line"><span class="comment"># A tibble: 59,140 x 20</span></span><br><span class="line">    start    end total.SNPs total.Bases depth unique.SNPs</span><br><span class="line">    &lt;int&gt;  &lt;int&gt;      &lt;int&gt;       &lt;int&gt; &lt;dbl&gt;       &lt;int&gt;</span><br><span class="line"> <span class="number">1</span> <span class="number">1.23e6</span> <span class="number">1.24e6</span>          <span class="number">0</span>         <span class="number">444</span>     <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"> <span class="number">2</span> <span class="number">1.58e6</span> <span class="number">1.58e6</span>          <span class="number">0</span>         <span class="number">716</span>     <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"> <span class="number">3</span> <span class="number">2.80e6</span> <span class="number">2.80e6</span>          <span class="number">0</span>         <span class="number">277</span>     <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"> <span class="number">4</span> <span class="number">2.80e6</span> <span class="number">2.80e6</span>          <span class="number">0</span>         <span class="number">115</span>     <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"> <span class="number">5</span> <span class="number">7.09e6</span> <span class="number">7.09e6</span>          <span class="number">0</span>         <span class="number">519</span>     <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"> <span class="number">6</span> <span class="number">7.09e6</span> <span class="number">7.09e6</span>          <span class="number">2</span>         <span class="number">686</span>     <span class="number">1</span>           <span class="number">2</span></span><br><span class="line"> <span class="number">7</span> <span class="number">1.16e7</span> <span class="number">1.16e7</span>          <span class="number">1</span>         <span class="number">429</span>     <span class="number">1</span>           <span class="number">1</span></span><br><span class="line"> <span class="number">8</span> <span class="number">1.28e7</span> <span class="number">1.28e7</span>          <span class="number">0</span>         <span class="number">165</span>     <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"> <span class="number">9</span> <span class="number">2.58e7</span> <span class="number">2.58e7</span>          <span class="number">0</span>         <span class="number">221</span>     <span class="number">1</span>           <span class="number">0</span></span><br><span class="line">10 <span class="number">2.58e7</span> <span class="number">2.58e7</span>          <span class="number">0</span>         <span class="number">172</span>     <span class="number">1</span>           <span class="number">0</span></span><br><span class="line"><span class="comment"># ... with 59,130 more rows, and 14 more variables:</span></span><br><span class="line"><span class="comment">#   dhSNPs &lt;int&gt;, reference.Bases &lt;int&gt;, Theta &lt;dbl&gt;,</span></span><br><span class="line"><span class="comment">#   Pi &lt;dbl&gt;, Heterozygosity &lt;dbl&gt;, X.GC &lt;dbl&gt;,</span></span><br><span class="line"><span class="comment">#   Recombination &lt;dbl&gt;, Divergence &lt;dbl&gt;, Constraint &lt;int&gt;,</span></span><br><span class="line"><span class="comment">#   SNPs &lt;int&gt;, position &lt;dbl&gt;, diversity &lt;dbl&gt;, cent &lt;lgl&gt;,</span></span><br><span class="line"><span class="comment">#   GC.binned &lt;fct&gt;</span></span><br></pre></td></tr></table></figure>
<p>你可以在 arrange() 中使用 <code>desc()</code> 函数来逆序排列</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; arrange(d_df, desc(total.SNPs), desc(depth))</span><br><span class="line"><span class="comment"># A tibble: 59,140 x 20</span></span><br><span class="line">    start    end total.SNPs total.Bases depth unique.SNPs</span><br><span class="line">    &lt;int&gt;  &lt;int&gt;      &lt;int&gt;       &lt;int&gt; &lt;dbl&gt;       &lt;int&gt;</span><br><span class="line"> <span class="number">1</span> <span class="number">2.62e6</span> <span class="number">2.62e6</span>         <span class="number">93</span>       <span class="number">11337</span> <span class="number">11.3</span>           <span class="number">13</span></span><br><span class="line"> <span class="number">2</span> <span class="number">1.30e7</span> <span class="number">1.30e7</span>         <span class="number">88</span>       <span class="number">11784</span> <span class="number">11.8</span>           <span class="number">11</span></span><br><span class="line"> <span class="number">3</span> <span class="number">4.74e7</span> <span class="number">4.74e7</span>         <span class="number">87</span>       <span class="number">12505</span> <span class="number">12.5</span>            <span class="number">9</span></span><br><span class="line"> <span class="number">4</span> <span class="number">6.00e7</span> <span class="number">6.00e7</span>         <span class="number">84</span>       <span class="number">11553</span> <span class="number">11.6</span>           <span class="number">15</span></span><br><span class="line"> <span class="number">5</span> <span class="number">8.77e6</span> <span class="number">8.77e6</span>         <span class="number">83</span>       <span class="number">10253</span> <span class="number">10.2</span>           <span class="number">12</span></span><br><span class="line"> <span class="number">6</span> <span class="number">1.78e7</span> <span class="number">1.78e7</span>         <span class="number">81</span>       <span class="number">13347</span> <span class="number">13.4</span>           <span class="number">11</span></span><br><span class="line"> <span class="number">7</span> <span class="number">4.74e7</span> <span class="number">4.74e7</span>         <span class="number">80</span>       <span class="number">14218</span> <span class="number">14.2</span>            <span class="number">8</span></span><br><span class="line"> <span class="number">8</span> <span class="number">4.59e7</span> <span class="number">4.59e7</span>         <span class="number">80</span>        <span class="number">9820</span>  <span class="number">9.82</span>          <span class="number">11</span></span><br><span class="line"> <span class="number">9</span> <span class="number">2.49e7</span> <span class="number">2.49e7</span>         <span class="number">78</span>       <span class="number">11206</span> <span class="number">11.2</span>           <span class="number">16</span></span><br><span class="line">10 <span class="number">5.45e7</span> <span class="number">5.45e7</span>         <span class="number">76</span>        <span class="number">9691</span>  <span class="number">9.69</span>          <span class="number">12</span></span><br><span class="line"><span class="comment"># ... with 59,130 more rows, and 14 more variables:</span></span><br><span class="line"><span class="comment">#   dhSNPs &lt;int&gt;, reference.Bases &lt;int&gt;, Theta &lt;dbl&gt;,</span></span><br><span class="line"><span class="comment">#   Pi &lt;dbl&gt;, Heterozygosity &lt;dbl&gt;, X.GC &lt;dbl&gt;,</span></span><br><span class="line"><span class="comment">#   Recombination &lt;dbl&gt;, Divergence &lt;dbl&gt;, Constraint &lt;int&gt;,</span></span><br><span class="line"><span class="comment">#   SNPs &lt;int&gt;, position &lt;dbl&gt;, diversity &lt;dbl&gt;, cent &lt;lgl&gt;,</span></span><br><span class="line"><span class="comment">#   GC.binned &lt;fct&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过使用 <code>mutate()</code> 函数可以增加新列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; d_df &lt;- select(d_df, -diversity) # remove our earlier diversity column</span><br><span class="line">&gt; d_df &lt;- mutate(d_df, diversity &#x3D; Pi&#x2F;(10*1000))</span><br><span class="line">&gt; d_df</span><br></pre></td></tr></table></figure>
<p>通过 <code>%&gt;%</code> 可以创建 <code>dplyr</code> 的 pipeline， <code>%&gt;%</code> 会<strong>将左边的变量视为右边函数的第一个参数</strong>，比如：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt;  d_df %&gt;% mutate(GC.scaled = scale(percent.GC)) %&gt;% </span><br><span class="line">	        filter(GC.scaled &gt; <span class="number">4</span>, depth &gt; <span class="number">4</span>) %&gt;% </span><br><span class="line">            select(start, end, depth, GC.scaled, percent.GC) %&gt;%  </span><br><span class="line">            arrange(desc(depth))</span><br></pre></td></tr></table></figure>
<p><code>dplyr</code> 包的一个原始功能是可以处理分组和数据的描述统计</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; mtfs_df &lt;- tbl_df(mtfs)</span><br><span class="line">&gt; mtfs_df %&gt;% group_by(chr)</span><br></pre></td></tr></table></figure>
<p>汇总分组统计，我们可以一样使用dplyr 的 summarize() 函数去汇总，可以按照每一列去汇总。这里的 n() 函数返回每组观测值的数目。<code>n_distinct()</code> 返回每组观测值去重后的数目。first()  last()  nth()  返回第一个、最后一个和第n个观测值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;  mtfs_df %&gt;%</span><br><span class="line">	group_by(chr) %&gt;%</span><br><span class="line">    summarize(max_recom &#x3D; max(recom), mean_recom &#x3D; mean(recom), num&#x3D;n())</span><br></pre></td></tr></table></figure>
<p>结果再排序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;  mtfs_df %&gt;%</span><br><span class="line">	group_by(chr) %&gt;%</span><br><span class="line">    summarize(max_recom &#x3D; max(recom), mean_recom &#x3D; mean(recom), num&#x3D;n()) %&gt;%     </span><br><span class="line">    arrange(desc(max_recom))</span><br></pre></td></tr></table></figure>
<h3 id="8-3-13-Working-with-Strings">8.3.13 Working with Strings</h3>
<p>R 语言并不是处理大多数生信文本处理的最佳语言。首先，R 处理数据前会将所有数据都存储在内存中；很多生信文本任务，更适合采用<strong>流处理</strong>的方式。其次，R处理字符串的方式，相比于python更加笨拙。</p>
<p>虽然有这些局限，但是有些时候我们还是需要用R来处理字符串。比如探索性数据分析。</p>
<p>如果你想要知道字符串的长度，使用 <code>nchar()</code> 函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; nchar(c(&quot;AGCTAG&quot;, &quot;ATA&quot;, &quot;GATCTGAG&quot;, &quot;&quot;))</span><br><span class="line">[1] 6 3 8 0</span><br></pre></td></tr></table></figure>
<p>我们可以通过 <code>grep()</code> 或 <code>regexpr()</code> 来查找符合某种pattern 的字符串向量的子集。</p>
<p><code>grep(pattern,x)</code>  返回匹配的字符的<strong>位置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; re_sites &lt;- c(&quot;CTGCAG&quot;, &quot;CGATCG&quot;, &quot;CAGCTG&quot;, &quot;CCCACA&quot;)</span><br><span class="line">&gt; grep(&quot;CAG&quot;, re_sites)</span><br></pre></td></tr></table></figure>
<p><code>grep()</code> 函数默认使用   POSIX  extended  regular  expressions，因此我们可以采用更加复杂的 patterns</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; grep(&quot;CT[CG]&quot;, re_sites)</span><br><span class="line">[1] 1 3</span><br></pre></td></tr></table></figure>
<p>你可以通过设置 <code>perl=TRUE</code> 来采用 Perl Compatible Regular Expressions (PCRE)  语法；你也可以通过 <code>fixed=TRUE</code> 来设置不使用正则表达式（特殊字符也视为一般字符）。</p>
<p>比如，下式中你打算匹配6号染色体，但是不能直接使用 grep(“6”, chrs) ，因为这会匹配到 16。</p>
<p>下式中 \d 表示数字，整个匹配模式改为6前面不能是数字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; chrs &lt;- c(&quot;chrom6&quot;, &quot;chr2&quot;, &quot;chr6&quot;, &quot;chr4&quot;, &quot;chr1&quot;, &quot;chr16&quot;, &quot; chrom8&quot;)</span><br><span class="line">&gt; grep(&quot;[^\\d]6&quot;, chrs, perl&#x3D;TRUE)</span><br><span class="line">[1] 1 3</span><br><span class="line">&gt; chrs[grep(&quot;[^\\d]6&quot;, chrs, perl&#x3D;TRUE)]</span><br><span class="line">[1] &quot;chrom6&quot; &quot;chr6&quot;</span><br></pre></td></tr></table></figure>
<p>与 grep 不一样， <code>regexpr()</code> 每个元素都会返回一个值，如果不匹配会返回 -1。（这个函数没搞懂，不用）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; regexpr(<span class="string">&quot;[^\\d]6&quot;</span>, chrs, perl=<span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure>
<p>我们可以用 <code>sub()</code> 函数来替换字符串。我们先开始一个简单的例子。 sub(pattern , replacement, x) ，会替换 x 向量中每个元素的 <strong>第一个</strong> 出现的pattern ，替换为 replacement。 <code>sub()</code> 函数 通过支持 perl=TRUE 和  fixed=TRUE。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; sub(pattern&#x3D;&quot;Watson&quot;, replacement&#x3D;&quot;Watson, Franklin,&quot;,      </span><br><span class="line">	x&#x3D;&quot;Watson and Crick discovered DNA&#39;s structure.&quot;)</span><br><span class="line">[1] &quot;Watson, Franklin, and Crick discovered DNA&#39;s structure.&quot;</span><br></pre></td></tr></table></figure>
<p>替换功能除了可以替换，还可以用于<strong>提取信息</strong>。这样做是通过正则表达式 <em>capturing groups</em>（捕获组）。这个功能会提取<strong>括号内的内容</strong>。</p>
<p>下面是几个例子，使用正则的时候一定要小心 <strong>silent error</strong>，比如下面第三个例子，得到的结果就是错的，这里是由于<code>.*</code> 是贪婪的。</p>
<p><img src="32.png" alt="32"></p>
<p><code>strsplit(x, split)</code> 将字符串分开，按照 split 将 x 分开。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; region &lt;- &quot;chr10:158395-172881&quot;</span><br><span class="line">&gt; chunks &lt;- sub(&quot;(chr[\\d+MYX]+):(\\d+)-(\\d+)&quot;,</span><br><span class="line">				&quot;\\1;;\\2;;\\3&quot;,</span><br><span class="line">                region, perl&#x3D;TRUE)</span><br><span class="line">&gt; strsplit(chunks, &quot;;;&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="8-4-Developing-Workflows-with-R-Scripts">8.4 Developing Workflows with R Scripts</h2>
<h3 id="8-4-1-Control-Flow-if-for-and-while">8.4.1 Control Flow: if, for, and while</h3>
<p>R本身通过 apply() 家族来避免使用循环，但有时仍需要使用循环。</p>
<p>if、for、while 循环基本语法如下</p>
<p><img src="33.png" alt=""></p>
<h3 id="8-4-2-Working-with-R-Scripts">8.4.2 Working with R Scripts</h3>
<p>第一种 在R中，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; source(&quot;my_analysis.R&quot;)</span><br></pre></td></tr></table></figure>
<p>第二种，在linux 中，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Rscript --vanilla my_analysis.R</span><br></pre></td></tr></table></figure>
<p>推荐加上参数 <strong>–vanilla</strong>，因为默认情况下 Rscript 可以存储所有过去保存的环境和现在的环境（environment），即便执行结束了。（这段话没看懂，但是作者建议加上，那还是加上吧）</p>
<p><img src="34.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--vanilla</span><br><span class="line">       Combine --no-save, --no-restore, --no-site-file --no-init-file and --no-environ</span><br></pre></td></tr></table></figure>
<p>R代码加参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">args &lt;- commandArgs(trailingOnly&#x3D;TRUE)</span><br></pre></td></tr></table></figure>
<h3 id="8-4-3-Workflows-for-Loading-and-Combining-Multiple-Files">8.4.3 Workflows for Loading and Combining Multiple Files</h3>
<p>当你需要同时读取多个文件时，比如多条染色体的文件。第一步，获取这些文件的文件名，<code>list.files()</code> 可以做到，而且支持正则表达式（尽量严格）, 这里需要用两个反斜杠来一般化这里的<code>.</code> 。通过设置 <code>full.names=TRUE</code> ，结果会给出相对路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; list.files(&quot;hotspots&quot;, pattern&#x3D;&quot;hotspots.*\\.bed&quot;)</span><br><span class="line"> [1] &quot;hotspots_chr1.bed&quot;  &quot;hotspots_chr10.bed&quot; &quot;hotspots_chr11.bed&quot;</span><br><span class="line"> [4] &quot;hotspots_chr12.bed&quot; &quot;hotspots_chr13.bed&quot; &quot;hotspots_chr14.bed&quot;</span><br><span class="line"> [...]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; hs_files &lt;- list.files(&quot;hotspots&quot;, pattern&#x3D;&quot;hotspots.*\\.bed&quot;, full.names&#x3D;TRUE)</span><br></pre></td></tr></table></figure>
<p>之后你就可以使用 lapply() 对每个文件采用相同的函数，之后可以可以再采用 do.call() 合并多个文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; bedcols &lt;- c(&quot;chr&quot;, &quot;start&quot;, &quot;end&quot;)</span><br><span class="line">&gt; loadFile &lt;- function(x) read.delim(x, header&#x3D;FALSE, col.names&#x3D;bedcols)</span><br><span class="line">&gt; hs &lt;- lapply(hs_files, loadFile)</span><br><span class="line">&gt; head(hs[[1]])</span><br><span class="line">&gt; hsd &lt;- do.call(rbind, hs)</span><br></pre></td></tr></table></figure>
<p>可以不用先合并文件，使用 lapply() 循环处理每个文件即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loadAndSummarizeFile &lt;- function(x) &#123;</span><br><span class="line">	df &lt;- read.table(x, header&#x3D;FALSE, col.names&#x3D;bedcols)</span><br><span class="line">	data.frame(chr&#x3D;unique(df$chr), n&#x3D;nrow(df), mean_len&#x3D;mean(df$end - df$start))</span><br><span class="line">&#125;</span><br><span class="line">&gt; chr_hs_summaries &lt;- lapply(hs_files, loadAndSummarizeFile)</span><br><span class="line">&gt; chr_hs_summaries[1:2]</span><br></pre></td></tr></table></figure>
<h3 id="8-4-4-Exporting-Data">8.4.4 Exporting Data</h3>
<p><code>write.table()</code> 有一些不太好的地方，需要手动设置，比如<code>quote</code>, <code>row.names</code> 等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; write.table(mtfs, file&#x3D;&quot;hotspot_motifs.txt&quot;, quote&#x3D;FALSE,              </span><br><span class="line">              sep&#x3D;&quot;\t&quot;, row.names&#x3D;FALSE, col.names&#x3D;TRUE)</span><br></pre></td></tr></table></figure>
<p>R 也可以输出为压缩文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; hs_gzf &lt;- gzfile(&quot;hotspot_motifs.txt.gz&quot;)</span><br><span class="line">&gt; write.table(mtfs, file&#x3D;hs_gzf, quote&#x3D;FALSE, sep&#x3D;&quot;\t&quot;, row.names&#x3D;FALSE, </span><br><span class="line">              col.names&#x3D;TRUE)</span><br></pre></td></tr></table></figure>
<p>文本文件很好，但是R中的一些对象无法有效地转换为文本文件，比如列表，这个时候最好的办法是  save R objects as R objects 。</p>
<p><img src="35.png" alt=""></p>
<p>save() 函数还有一个类似的函数 save.image() ，这个函数可以保存工作路径下的所有对象。</p>
<h2 id="8-5-Further-R-Directions-and-Resources">8.5 Further R Directions and Resources</h2>
<h1>9 Working with Range Data</h1>
<h2 id="9-1-A-Crash-Course-in-Genomic-Ranges-and-Coordinate-Systems">9.1 A Crash Course in Genomic Ranges and Coordinate Systems</h2>
<p>range 表示一段序列的子序列（比如染色体的一段序列）。为了确定基因组上的区域或位置，我们需要以下信息：</p>
<ul>
<li>染色体名称 ：也称之为 <em>sequence name</em> （有些片段可能没有分配到染色体上）。但是令人头疼的是，<strong>染色体名称没有固定规范</strong>，比如 ”7,”  “22,”  “chrX,”  “Y,”  “MT”</li>
<li>范围：比如114,414,997  to  114,693,772</li>
<li>strand ：因为 DNA 是双链，因此需要指明是哪条链。forward (positive) or reverse(negative)。</li>
<li>参考基因组版本</li>
</ul>
<p>这三个组成部分形成了一个 <em>genomic range</em> (or <em>genomic interval</em> ) ，由于参考基因组是range 的坐标系， <em>ranges are completely linked to a specific genome version</em>. 换句话说，基因组位置都是相对于参考基因组来说的，因此当我们说 range 时 还需要<strong>指定参考基因组版本</strong>。</p>
<p>range 有两种表示方式。在 0-based 中，一个 sequence （比如染色体）的第一个位置标记为0，在这个参考系中，我们使用半闭半开区间 [start,end)，这和 python 的语法一致。在 1-based 中，第一个位置标记为1，区间为全闭区间 [start,end]，如同R中的语法。</p>
<ul>
<li>0-based coordinate system, with  half-closed, half-open intervals.</li>
<li>1-based coordinate system, with closed intervals.</li>
</ul>
<p>两种方式各有利弊，比如如果我们想看range 长度，对于 0-based，直接就是 end - start；而对于 1-based，则是  end - start +1 。0-based 还有一个优点在于可以表示长度是0的range （第二条没看懂，267页）</p>
<p><img src="37.png" alt=""></p>
<p>还有一个需要考虑的细节是 strand，但是一般不用管，<strong>因为除了 BLAST 格式外，所有 range 格式都是 forward 链</strong>。</p>
<p>但是有时你需要知道，因为 有些 features 只有在某条链的信息才有生物学功能。比如编码蛋白的基因，如果这个基因在 forward 链上，那么 forward 链上的序列和 mRNA 是一样的；反过来，如果这个基因型在 reverse 链上，那么必须把forward 链上的序列 <em>reverse complement</em> ，才能获得 mRNA 上的信息。</p>
<h3 id="参考基因组版本">参考基因组版本</h3>
<p><strong>同一片段在不同参考基因组版本中的位置不同</strong>。</p>
<p>有时你需要从旧版本升级到新版本，这个工作很繁琐，但是目前有些工具可以帮助你完成</p>
<p><img src="36.png" alt=""></p>
<h2 id="9-2-An-Inter-active-Introduction-to-Range-Data-with-GenomicRanges">9.2 An Inter active Introduction to Range Data with GenomicRanges</h2>
<h3 id="9-2-1-Installing-and-Working-with-Bioconductor-Packages">9.2.1 Installing and Working with Bioconductor Packages</h3>
<p>这里我们用到了几个 Bioconductor 的包。</p>
<ul>
<li>GenomicRanges : 处理 genomic ranges</li>
<li>GenomicFeatures: 处理genomic features （有功能的 genomic ranges，比如genes, exons）</li>
<li>Biostrings and  BSgenome ：处理 genomic sequence data</li>
<li>rtracklayer ：读取生信格式的文件，比如 BED，GTF/GFF，WIG</li>
</ul>
<p>Bioconductor 包不同于 CRAN 的包，它会严格地一年更新两次，来跟上R版本的更新。</p>
<p>安装包的方式（这个是旧的，没法用了，需要提前安装 BiocInstaller ）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; source(&quot;http:&#x2F;&#x2F;bioconductor.org&#x2F;biocLite.R&quot;)</span><br><span class="line">&gt; biocLite()</span><br><span class="line">&gt; biocLite(&quot;GenomicRanges&quot;)</span><br></pre></td></tr></table></figure>
<p>现在的安装方式是采用 BiocManager 包</p>
<h4 id="BiocManager">BiocManager</h4>
<p><a href="https://bioconductor.org/install/">https://bioconductor.org/install/</a></p>
<p>安装核心安装包：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!requireNamespace(<span class="string">&quot;BiocManager&quot;</span>, quietly = <span class="literal">TRUE</span>))</span><br><span class="line">    install.packages(<span class="string">&quot;BiocManager&quot;</span>)</span><br><span class="line">BiocManager::install()</span><br></pre></td></tr></table></figure>
<p>安装特定的包</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">BiocManager::install(<span class="built_in">c</span>(<span class="string">&quot;GenomicFeatures&quot;</span>, <span class="string">&quot;AnnotationDbi&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>查找包，比如输入“^org” ，查找所有可用的  organism annotation 包。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">BiocManager::available()</span><br></pre></td></tr></table></figure>
<p>更新安装的包</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">BiocManager::install()</span><br></pre></td></tr></table></figure>
<h3 id="9-2-2-Storing-Generic-Ranges-with-IRanges">9.2.2 Storing Generic Ranges with IRanges</h3>
<p>通过 IRanges 函数包可以创建 IRanges 对象，包含两个元素：一个起始位置和结束位置，也可以设置长度。（注意，这里是 1-based 对象）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">library(IRanges)</span><br><span class="line">rng &lt;- IRanges(start &#x3D; 4, end &#x3D; 13)</span><br><span class="line">rng</span><br><span class="line">IRanges(start&#x3D;4, width&#x3D;3)</span><br></pre></td></tr></table></figure>
<p>也可以创建包含多个ranges的对象，并且可以给每个range命名</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x = IRanges(start = <span class="built_in">c</span>(<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">20</span>), end = <span class="built_in">c</span>(<span class="number">13</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">23</span>))</span><br><span class="line">x</span><br><span class="line"><span class="built_in">names</span>(x) &lt;- <span class="built_in">letters</span>[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">x</span><br><span class="line">start(x)</span><br><span class="line">end(x)</span><br><span class="line">width(x)</span><br><span class="line">end(x) = end(x) + <span class="number">4</span> <span class="comment">#延长ranges</span></span><br><span class="line">x</span><br><span class="line"><span class="built_in">range</span>(x) <span class="comment">#返回所有range的最大值和最小值</span></span><br></pre></td></tr></table></figure>
<p>取子集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x[2:3]</span><br><span class="line">start(x) &lt; 5 </span><br><span class="line">x[start(x) &lt;5]</span><br><span class="line">x[start(x) &gt;8]</span><br><span class="line">x[&#39;a&#39;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="9-2-3-Basic-Range-Operations-Arithmetic-Transformations-and-Set-Operations">9.2.3 Basic Range Operations: Arithmetic, Transformations, and Set Operations</h3>
<p>我们可以对range对象很方便地进行简单运算（+ - *，除法不行）。这里后面的 L 不知道有什么用，加不加都一样。</p>
<p>乘法一般用不上，乘以一个正数，缩小范围；乘以一个负数，扩大范围。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x &lt;- IRanges(start=<span class="built_in">c</span>(<span class="number">40</span>, <span class="number">80</span>), end=<span class="built_in">c</span>(<span class="number">67</span>, <span class="number">114</span>))</span><br><span class="line">&gt; x + <span class="number">4L</span></span><br><span class="line">IRanges object with <span class="number">2</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]        <span class="number">36</span>        <span class="number">71</span>        <span class="number">36</span></span><br><span class="line">  [<span class="number">2</span>]        <span class="number">76</span>       <span class="number">118</span>        <span class="number">43</span></span><br><span class="line"></span><br><span class="line">&gt; x - <span class="number">10L</span></span><br><span class="line">IRanges object with <span class="number">2</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]        <span class="number">50</span>        <span class="number">57</span>         <span class="number">8</span></span><br><span class="line">  [<span class="number">2</span>]        <span class="number">90</span>       <span class="number">104</span>        <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>有的时候我们需要指定某个区间内的片段，可以使用restrict() 函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y &#x3D; IRanges(start &#x3D; c(4,6,10,12),width&#x3D;13)</span><br><span class="line">y</span><br><span class="line">restrict(y,5,10)</span><br></pre></td></tr></table></figure>
<p><img src="38.png" alt="38"></p>
<p>另一种转换方法是 flank() ，返回 range 中 上游/下游的片段。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x</span><br><span class="line">IRanges object with <span class="number">2</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]        <span class="number">40</span>        <span class="number">67</span>        <span class="number">28</span></span><br><span class="line">  [<span class="number">2</span>]        <span class="number">80</span>       <span class="number">114</span>        <span class="number">35</span></span><br><span class="line">&gt; flank(x, width=<span class="number">7</span>)</span><br><span class="line">IRanges object with <span class="number">2</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]        <span class="number">33</span>        <span class="number">39</span>         <span class="number">7</span></span><br><span class="line">  [<span class="number">2</span>]        <span class="number">73</span>        <span class="number">79</span>         <span class="number">7</span></span><br><span class="line"></span><br><span class="line">&gt; flank(x, width=<span class="number">7</span>, start = <span class="literal">FALSE</span>)</span><br><span class="line">IRanges object with <span class="number">2</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]        <span class="number">68</span>        <span class="number">74</span>         <span class="number">7</span></span><br><span class="line">  [<span class="number">2</span>]       <span class="number">115</span>       <span class="number">121</span>         <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>另一个常用的函数是 reduce() ，将有交叉的 ranges 划分为没有交叉的 ranges（有重叠的ranges 会合并为一个大的 range）。这个函数用于我们想看序列上有哪些位置是覆盖的。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; set.seed(<span class="number">0</span>)</span><br><span class="line">&gt; alns &lt;- IRanges(start=sample(<span class="built_in">seq_len</span>(<span class="number">50</span>),<span class="number">20</span>), width=<span class="number">5</span>)</span><br><span class="line">&gt; head(alns,<span class="number">4</span>)</span><br><span class="line">IRanges object with <span class="number">4</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]        <span class="number">14</span>        <span class="number">18</span>         <span class="number">5</span></span><br><span class="line">  [<span class="number">2</span>]         <span class="number">4</span>         <span class="number">8</span>         <span class="number">5</span></span><br><span class="line">  [<span class="number">3</span>]        <span class="number">39</span>        <span class="number">43</span>         <span class="number">5</span></span><br><span class="line">  [<span class="number">4</span>]         <span class="number">1</span>         <span class="number">5</span>         <span class="number">5</span></span><br><span class="line">&gt; reduce(alns)</span><br><span class="line">IRanges object with <span class="number">2</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]         <span class="number">1</span>        <span class="number">29</span>        <span class="number">29</span></span><br><span class="line">  [<span class="number">2</span>]        <span class="number">33</span>        <span class="number">54</span>        <span class="number">22</span></span><br></pre></td></tr></table></figure>
<p>相似的函数是 gaps() ，这个会返回哪些位置是没有覆盖的。</p>
<p>默认情况下，只会考虑 ranges 之间的gap，不会显示距离起始位置/终止位置的gap。这样做是因为 gaps 不知道起始位置和终止位置在哪，如果你要显示的话，需要指定，比如（<code>gaps(alns, start=1, end=60)</code>）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; gaps(alns)</span><br><span class="line">IRanges object with 1 range and 0 metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [1]        30        32         3</span><br></pre></td></tr></table></figure>
<p>另一套有用的函数是 set 操作。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; a &lt;- IRanges(start = <span class="number">4</span>, end = <span class="number">13</span>)</span><br><span class="line">&gt; b &lt;- IRanges(start = <span class="number">12</span>, end = <span class="number">17</span>)</span><br><span class="line">&gt; intersect(a,b)</span><br><span class="line">IRanges object with <span class="number">1</span> <span class="built_in">range</span> and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]        <span class="number">12</span>        <span class="number">13</span>         <span class="number">2</span></span><br><span class="line">&gt; setdiff(a,b)</span><br><span class="line">IRanges object with <span class="number">1</span> <span class="built_in">range</span> and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]         <span class="number">4</span>        <span class="number">11</span>         <span class="number">8</span></span><br><span class="line">&gt; union(a,b)</span><br><span class="line">IRanges object with <span class="number">1</span> <span class="built_in">range</span> and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]         <span class="number">4</span>        <span class="number">17</span>        <span class="number">14</span></span><br><span class="line">&gt; union(b,a)</span><br><span class="line">IRanges object with <span class="number">1</span> <span class="built_in">range</span> and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]         <span class="number">4</span>        <span class="number">17</span>        <span class="number">14</span></span><br></pre></td></tr></table></figure>
<h3 id="9-2-4-Finding-Overlapping-Ranges">9.2.4 Finding Overlapping Ranges</h3>
<p>查找重叠的ranges很重要，如何查找重叠区域有不同的方法，需要视情况选用。</p>
<p><code>findOverlaps() </code> 函数是将第一个ranges 中所有range 与第二个的所有range 进行匹配，存在overlap 就显示在结果中（仅为索引）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qry &lt;- IRanges(start = <span class="built_in">c</span>(<span class="number">1</span>,<span class="number">26</span>,<span class="number">19</span>,<span class="number">11</span>,<span class="number">21</span>,<span class="number">7</span>), end=<span class="built_in">c</span>(<span class="number">16</span>,<span class="number">30</span>,<span class="number">19</span>,<span class="number">15</span>,<span class="number">24</span>,<span class="number">8</span>),<span class="built_in">names</span>=<span class="built_in">letters</span>[<span class="number">1</span>:<span class="number">6</span>])</span><br><span class="line">sbj &lt;- IRanges(start = <span class="built_in">c</span>(<span class="number">1</span>,<span class="number">19</span>,<span class="number">10</span>), end=<span class="built_in">c</span>(<span class="number">5</span>,<span class="number">29</span>,<span class="number">16</span>), <span class="built_in">names</span>=<span class="built_in">letters</span>[<span class="number">24</span>:<span class="number">26</span>])</span><br><span class="line">qry</span><br><span class="line">sbj</span><br><span class="line">hts &lt;- findOverlaps(qry,sbj)</span><br><span class="line">hts</span><br><span class="line"></span><br><span class="line">&gt; hts</span><br><span class="line">Hits object with <span class="number">6</span> hits and <span class="number">0</span> metadata columns:</span><br><span class="line">      queryHits subjectHits</span><br><span class="line">      &lt;integer&gt;   &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]         <span class="number">1</span>           <span class="number">1</span></span><br><span class="line">  [<span class="number">2</span>]         <span class="number">1</span>           <span class="number">3</span></span><br><span class="line">  [<span class="number">3</span>]         <span class="number">2</span>           <span class="number">2</span></span><br><span class="line">  [<span class="number">4</span>]         <span class="number">3</span>           <span class="number">2</span></span><br><span class="line">  [<span class="number">5</span>]         <span class="number">4</span>           <span class="number">3</span></span><br><span class="line">  [<span class="number">6</span>]         <span class="number">5</span>           <span class="number">2</span></span><br><span class="line">  -------</span><br><span class="line">  queryLength: <span class="number">6</span> / subjectLength: <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>默认情况下只有任意存在overlapping，就会显示在结果中（ type = “any”）。</p>
<p>可以更改这个参数，比如 改为 “within”，第一个参数的range 必须包含在第二个参数的range 中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hts_within &lt;- findOverlaps(qry, sbj, type&#x3D;&quot;within&quot;)</span><br><span class="line">hts_within</span><br></pre></td></tr></table></figure>
<p><img src="39.png" alt="38"></p>
<p>另一个需要考虑的参数是 <code>select</code>，这决定当一个 query 与多个 subject ranges 具有重叠时如何处理。“all” 会返回所有的配对，“first” “last” “arbitrary” 只返回一个配对（没有返回NA），选择这三个选项会返回一个整数的向量，每个元素表示 每个 query range 的匹配结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; findOverlaps(qry, sbj, select&#x3D;&quot;first&quot;)</span><br><span class="line">[1]  1  2  2  3  2 NA</span><br><span class="line">&gt; findOverlaps(qry, sbj, select&#x3D;&quot;last&quot;)</span><br><span class="line">[1]  3  2  2  3  2 NA</span><br><span class="line">&gt; findOverlaps(qry, sbj, select&#x3D;&quot;arbitrary&quot;)</span><br><span class="line">[1]  1  2  2  3  2 NA</span><br></pre></td></tr></table></figure>
<p>如果query 的 ranges 很多，那么如果还要逐次配对，那么计算量很大。我们可以通过对subject序列排序（构建 interval trees ）降低配对数目。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sbj_it &lt;- IntervalTree(sbj) #现在没用了</span><br></pre></td></tr></table></figure>
<p>其他方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; as.matrix(hts)</span><br><span class="line">     queryHits subjectHits</span><br><span class="line">[1,]         1           1</span><br><span class="line">[2,]         1           3</span><br><span class="line">[3,]         2           2</span><br><span class="line">[4,]         3           2</span><br><span class="line">[5,]         4           3</span><br><span class="line">[6,]         5           2</span><br><span class="line">&gt; setNames(countQueryHits(hts),names(qry))</span><br><span class="line">a b c d e f </span><br><span class="line">2 1 1 1 1 0 </span><br><span class="line">&gt; countSubjectHits(hts)</span><br><span class="line">[1] 1 3 2</span><br><span class="line">&gt; setNames(countSubjectHits(hts),names(sbj))</span><br><span class="line">x y z </span><br><span class="line">1 3 2 </span><br><span class="line">&gt; ranges(hts, qry, sbj) #显示重叠区域</span><br><span class="line">Error in (function (classes, fdef, mtable)  : </span><br><span class="line">  unable to find an inherited method for function ‘ranges’ for signature ‘&quot;SortedByQueryHits&quot;’</span><br></pre></td></tr></table></figure>
<h3 id="9-2-5-Finding-Nearest-Ranges-and-Calculating-Distance">9.2.5 Finding Nearest Ranges and Calculating Distance</h3>
<p>查找与 query 序列临近的 subject 序列。IRanges 有三个函数可以实现：nearest()  precede() follow()。 nearest() 返回最近的序列，不管时上游还是下游；precede() follow() 分别返回 query precede subject 和  query follow subject 最近的序列。</p>
<p>但是 nearest() 和 precede() follow() 还有一点不一样，nearest() 即使重叠也会考虑。<strong>这些细节说明在进行这些操作前需要仔细阅读文档</strong>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; qry &lt;- IRanges(start=<span class="number">6</span>, end=<span class="number">13</span>, name=<span class="string">&#x27;query&#x27;</span>)</span><br><span class="line">&gt; sbj &lt;- IRanges(start=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">4</span>,<span class="number">18</span>,<span class="number">19</span>), end=<span class="built_in">c</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">21</span>,<span class="number">24</span>), <span class="built_in">names</span>=<span class="number">1</span>:<span class="number">4</span>)</span><br><span class="line">&gt; qry</span><br><span class="line">IRanges object with <span class="number">1</span> <span class="built_in">range</span> and <span class="number">0</span> metadata columns:</span><br><span class="line">            start       end     width</span><br><span class="line">        &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  query         <span class="number">6</span>        <span class="number">13</span>         <span class="number">8</span></span><br><span class="line">&gt; sbj</span><br><span class="line">IRanges object with <span class="number">4</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">        start       end     width</span><br><span class="line">    &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  <span class="number">1</span>         <span class="number">2</span>         <span class="number">4</span>         <span class="number">3</span></span><br><span class="line">  <span class="number">2</span>         <span class="number">4</span>         <span class="number">5</span>         <span class="number">2</span></span><br><span class="line">  <span class="number">3</span>        <span class="number">18</span>        <span class="number">21</span>         <span class="number">4</span></span><br><span class="line">  <span class="number">4</span>        <span class="number">19</span>        <span class="number">24</span>         <span class="number">6</span></span><br><span class="line">&gt; nearest(qry,sbj)</span><br><span class="line">[<span class="number">1</span>] <span class="number">2</span></span><br><span class="line">&gt; precede(qry,sbj)</span><br><span class="line">[<span class="number">1</span>] <span class="number">3</span></span><br><span class="line">&gt; follow(qry,sbj)</span><br><span class="line">[<span class="number">1</span>] <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>可以通过 <code>distanceToNearest()</code> 和 <code>distance()</code> ，返回离最近的range的距离，和两边的最近的距离。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; qry &lt;- IRanges(sample(<span class="built_in">seq_len</span>(<span class="number">1000</span>), <span class="number">5</span>), width=<span class="number">10</span>)</span><br><span class="line">&gt; sbj &lt;- IRanges(sample(<span class="built_in">seq_len</span>(<span class="number">1000</span>), <span class="number">5</span>), width=<span class="number">10</span>)</span><br><span class="line">&gt; qry</span><br><span class="line">IRanges object with <span class="number">5</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]       <span class="number">677</span>       <span class="number">686</span>        <span class="number">10</span></span><br><span class="line">  [<span class="number">2</span>]       <span class="number">802</span>       <span class="number">811</span>        <span class="number">10</span></span><br><span class="line">  [<span class="number">3</span>]       <span class="number">874</span>       <span class="number">883</span>        <span class="number">10</span></span><br><span class="line">  [<span class="number">4</span>]       <span class="number">382</span>       <span class="number">391</span>        <span class="number">10</span></span><br><span class="line">  [<span class="number">5</span>]       <span class="number">601</span>       <span class="number">610</span>        <span class="number">10</span></span><br><span class="line">&gt; sbj</span><br><span class="line">IRanges object with <span class="number">5</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">          start       end     width</span><br><span class="line">      &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]       <span class="number">940</span>       <span class="number">949</span>        <span class="number">10</span></span><br><span class="line">  [<span class="number">2</span>]       <span class="number">975</span>       <span class="number">984</span>        <span class="number">10</span></span><br><span class="line">  [<span class="number">3</span>]       <span class="number">801</span>       <span class="number">810</span>        <span class="number">10</span></span><br><span class="line">  [<span class="number">4</span>]       <span class="number">852</span>       <span class="number">861</span>        <span class="number">10</span></span><br><span class="line">  [<span class="number">5</span>]       <span class="number">931</span>       <span class="number">940</span>        <span class="number">10</span></span><br><span class="line">&gt; distanceToNearest(qry, sbj)</span><br><span class="line">Hits object with <span class="number">5</span> hits and <span class="number">1</span> metadata column:</span><br><span class="line">      queryHits subjectHits |  distance</span><br><span class="line">      &lt;integer&gt;   &lt;integer&gt; | &lt;integer&gt;</span><br><span class="line">  [<span class="number">1</span>]         <span class="number">1</span>           <span class="number">3</span> |       <span class="number">114</span></span><br><span class="line">  [<span class="number">2</span>]         <span class="number">2</span>           <span class="number">3</span> |         <span class="number">0</span></span><br><span class="line">  [<span class="number">3</span>]         <span class="number">3</span>           <span class="number">4</span> |        <span class="number">12</span></span><br><span class="line">  [<span class="number">4</span>]         <span class="number">4</span>           <span class="number">3</span> |       <span class="number">409</span></span><br><span class="line">  [<span class="number">5</span>]         <span class="number">5</span>           <span class="number">3</span> |       <span class="number">190</span></span><br><span class="line">  -------</span><br><span class="line">  queryLength: <span class="number">5</span> / subjectLength: <span class="number">5</span></span><br><span class="line">&gt; distance(qry, sbj)</span><br><span class="line">[<span class="number">1</span>] <span class="number">253</span> <span class="number">163</span>  <span class="number">63</span> <span class="number">460</span> <span class="number">320</span></span><br></pre></td></tr></table></figure>
<h3 id="9-2-6-Run-Length-Encoding-and-Views">9.2.6 Run Length Encoding and Views</h3>
<p>看不懂，先看下一章。</p>
<h3 id="9-2-7-Storing-Genomic-Ranges-with-GenomicRanges">9.2.7 Storing Genomic Ranges with GenomicRanges</h3>
<p>GenomicRanges 可以创建 GRanges 来存放 genomic ranges，这个来源于 IRanges，但是可以存在额外的两条信息（sequence name, strand）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; library(GenomicRanges)</span><br><span class="line">载入需要的程辑包：GenomeInfoDb</span><br><span class="line">&gt; gr &lt;- GRanges(seqnames = <span class="built_in">c</span>(<span class="string">&quot;chr1&quot;</span>,<span class="string">&quot;chr1&quot;</span>,<span class="string">&quot;chr2&quot;</span>,<span class="string">&quot;chr3&quot;</span>), </span><br><span class="line">+               ranges=IRanges(start=<span class="number">5</span>:<span class="number">8</span>, width=<span class="number">10</span>),</span><br><span class="line">+               strand=<span class="built_in">c</span>(<span class="string">&quot;+&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;+&quot;</span>))</span><br><span class="line">&gt; gr</span><br><span class="line">GRanges object with <span class="number">4</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">      seqnames    ranges strand</span><br><span class="line">         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;</span><br><span class="line">  [<span class="number">1</span>]     chr1      <span class="number">5</span>-<span class="number">14</span>      +</span><br><span class="line">  [<span class="number">2</span>]     chr1      <span class="number">6</span>-<span class="number">15</span>      -</span><br><span class="line">  [<span class="number">3</span>]     chr2      <span class="number">7</span>-<span class="number">16</span>      -</span><br><span class="line">  [<span class="number">4</span>]     chr3      <span class="number">8</span>-<span class="number">17</span>      +</span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">3</span> sequences from an unspecified genome; no seqlengths</span><br><span class="line">&gt; ?runif </span><br><span class="line">&gt; gr &lt;- GRanges(seqnames = <span class="built_in">c</span>(<span class="string">&quot;chr1&quot;</span>,<span class="string">&quot;chr1&quot;</span>,<span class="string">&quot;chr2&quot;</span>,<span class="string">&quot;chr3&quot;</span>), </span><br><span class="line">+               ranges=IRanges(start=<span class="number">5</span>:<span class="number">8</span>, width=<span class="number">10</span>),</span><br><span class="line">+               strand=<span class="built_in">c</span>(<span class="string">&quot;+&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;+&quot;</span>), gc=<span class="built_in">round</span>(runif(<span class="number">4</span>), <span class="number">3</span>))</span><br><span class="line">&gt; gr</span><br><span class="line">GRanges object with <span class="number">4</span> ranges and <span class="number">1</span> metadata column:</span><br><span class="line">      seqnames    ranges strand |        gc</span><br><span class="line">         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;numeric&gt;</span><br><span class="line">  [<span class="number">1</span>]     chr1      <span class="number">5</span>-<span class="number">14</span>      + |     <span class="number">0.724</span></span><br><span class="line">  [<span class="number">2</span>]     chr1      <span class="number">6</span>-<span class="number">15</span>      - |     <span class="number">0.411</span></span><br><span class="line">  [<span class="number">3</span>]     chr2      <span class="number">7</span>-<span class="number">16</span>      - |     <span class="number">0.821</span></span><br><span class="line">  [<span class="number">4</span>]     chr3      <span class="number">8</span>-<span class="number">17</span>      + |     <span class="number">0.647</span></span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">3</span> sequences from an unspecified genome; no seqlengths</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于测序数据都有参考基因组，因此我们可以实现知道每个 sequence 的长度，这样才可以判断 coverage 和 gap。我们可以在创建GRanges 时说明，也可以在创建后指明长度。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">seqlens &lt;- <span class="built_in">c</span>(chr1=<span class="number">152</span>, chr2=<span class="number">432</span>, chr3=<span class="number">903</span>)</span><br><span class="line">gr &lt;- GRanges(seqnames = <span class="built_in">c</span>(<span class="string">&quot;chr1&quot;</span>,<span class="string">&quot;chr1&quot;</span>,<span class="string">&quot;chr2&quot;</span>,<span class="string">&quot;chr3&quot;</span>), </span><br><span class="line">               ranges=IRanges(start=<span class="number">5</span>:<span class="number">8</span>, width=<span class="number">10</span>),</span><br><span class="line">               strand=<span class="built_in">c</span>(<span class="string">&quot;+&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;+&quot;</span>), </span><br><span class="line">               gc=<span class="built_in">round</span>(runif(<span class="number">4</span>), <span class="number">3</span>),</span><br><span class="line">               seqlengths = seqlens )</span><br><span class="line">gr</span><br><span class="line">seqlengths(gr) &lt;- seqlens  <span class="comment"># 另一种方式</span></span><br><span class="line">gr</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; start(gr)</span><br><span class="line">[<span class="number">1</span>] <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line">&gt; end(gr)</span><br><span class="line">[<span class="number">1</span>] <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span></span><br><span class="line">&gt; width(gr)</span><br><span class="line">[<span class="number">1</span>] <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">length</span>(gr)</span><br><span class="line">[<span class="number">1</span>] <span class="number">4</span></span><br><span class="line">&gt; <span class="built_in">names</span>(gr) = <span class="built_in">letters</span>[<span class="number">1</span>:<span class="built_in">length</span>(gr)]</span><br><span class="line">&gt; gr</span><br><span class="line">GRanges object with <span class="number">4</span> ranges and <span class="number">1</span> metadata column:</span><br><span class="line">    seqnames    ranges strand |        gc</span><br><span class="line">       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;numeric&gt;</span><br><span class="line">  a     chr1      <span class="number">5</span>-<span class="number">14</span>      + |     <span class="number">0.783</span></span><br><span class="line">  b     chr1      <span class="number">6</span>-<span class="number">15</span>      - |     <span class="number">0.553</span></span><br><span class="line">  <span class="built_in">c</span>     chr2      <span class="number">7</span>-<span class="number">16</span>      - |     <span class="number">0.530</span></span><br><span class="line">  d     chr3      <span class="number">8</span>-<span class="number">17</span>      + |     <span class="number">0.789</span></span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">3</span> sequences from an unspecified genome</span><br></pre></td></tr></table></figure>
<p>GRanges 的一个优点是你可以取子集。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt; start(gr) &gt; <span class="number">7</span></span><br><span class="line">[<span class="number">1</span>] FALSE FALSE FALSE  TRUE</span><br><span class="line">&gt; gr[start(gr) &gt; <span class="number">7</span>]</span><br><span class="line">GRanges object with <span class="number">1</span> range <span class="keyword">and</span> <span class="number">1</span> metadata <span class="symbol">column:</span></span><br><span class="line">    seqnames    ranges strand <span class="params">|        gc</span></span><br><span class="line"><span class="params">       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; |</span> &lt;numeric&gt;</span><br><span class="line">  d     chr3      <span class="number">8</span>-<span class="number">17</span>      + <span class="params">|     0.789</span></span><br><span class="line"><span class="params">  -------</span></span><br><span class="line"><span class="params">  seqinfo: 3 sequences from an unspecified genome</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; table(seqnames(gr))</span><br><span class="line"></span><br><span class="line">chr1 chr2 chr3 </span><br><span class="line">   <span class="number">2</span>    <span class="number">1</span>    <span class="number">1</span> </span><br><span class="line">&gt; gr[seqnames(gr) == <span class="string">&quot;chr1&quot;</span>]</span><br><span class="line">GRanges object with <span class="number">2</span> ranges and <span class="number">1</span> metadata column:</span><br><span class="line">    seqnames    ranges strand |        gc</span><br><span class="line">       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;numeric&gt;</span><br><span class="line">  a     chr1      <span class="number">5</span>-<span class="number">14</span>      + |     <span class="number">0.783</span></span><br><span class="line">  b     chr1      <span class="number">6</span>-<span class="number">15</span>      - |     <span class="number">0.553</span></span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">3</span> sequences from an unspecified genome</span><br></pre></td></tr></table></figure>
<p>取某一列</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; gr$gc</span><br><span class="line">[<span class="number">1</span>] <span class="number">0.783</span> <span class="number">0.553</span> <span class="number">0.530</span> <span class="number">0.789</span></span><br></pre></td></tr></table></figure>
<h3 id="9-2-8-Grouping-Data-with-GRangesList">9.2.8 Grouping Data with GRangesList</h3>
<p>GRanges 对象也有相应的列表，称之为 GRangesList。</p>
<p>我们可以手动创建一个 GRangesList</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(GenomicRanges)</span><br><span class="line">gr1 &lt;- GRanges(<span class="built_in">c</span>(<span class="string">&quot;chr1&quot;</span>,<span class="string">&quot;chr2&quot;</span>), IRanges(start=<span class="built_in">c</span>(<span class="number">32</span>,<span class="number">95</span>), width=<span class="built_in">c</span>(<span class="number">24</span>,<span class="number">123</span>)))</span><br><span class="line">gr2 &lt;- GRanges(<span class="built_in">c</span>(<span class="string">&quot;chr8&quot;</span>,<span class="string">&quot;chr2&quot;</span>), IRanges(start=<span class="built_in">c</span>(<span class="number">27</span>,<span class="number">12</span>), width=<span class="built_in">c</span>(<span class="number">42</span>,<span class="number">34</span>)))</span><br><span class="line">grl &lt;- GRangesList(gr1,gr2)</span><br><span class="line">grl</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>GRangesList 同样有普通列表的功能</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">unlist(grl) #把GRangesList转换为GRanges 对象</span><br><span class="line">doubled_grl = c(grl,grl) #合并list</span><br><span class="line">length(doubled_grl)</span><br><span class="line">doubled_grl</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>切片同样如此，一个方括号仍然返回一个 GRangesList 对象，两个方括号返回GRanges 对象</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">doubled_grl[<span class="number">2</span>]</span><br><span class="line">doubled_grl[[<span class="number">2</span>]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>GRangesList  还有一些特殊的函数（seqnames(), start(), end(), width(), ranges(), strand(), 等）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">seqnames(grl)</span><br><span class="line">start(grl)</span><br></pre></td></tr></table></figure>
<p>除了通过 <code>GRangesList()</code> 手动创建 GRanges 对象外，还可以通过 <code>split()</code> 函数处理 GRanges 对象。比如将一个 GRanges 对象 按照 sequence name （染色体）切分开，创建几个子对象。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">chrs &lt;- <span class="built_in">c</span>(<span class="string">&quot;chr3&quot;</span>, <span class="string">&quot;chr1&quot;</span>, <span class="string">&quot;chr2&quot;</span>, <span class="string">&quot;chr2&quot;</span>, <span class="string">&quot;chr3&quot;</span>, <span class="string">&quot;chr1&quot;</span>)</span><br><span class="line">gr &lt;- GRanges(chrs, IRanges(sample(<span class="number">1</span>:<span class="number">100</span>, <span class="number">6</span>, replace=<span class="literal">TRUE</span>), width=sample(<span class="number">3</span>:<span class="number">30</span>, <span class="number">6</span>, replace=<span class="literal">TRUE</span>)))</span><br><span class="line">head(gr)</span><br><span class="line">gr_split &lt;- split(gr, seqnames(gr))</span><br><span class="line">gr_split[[<span class="number">1</span>]]</span><br><span class="line"><span class="built_in">names</span>(gr_split)</span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; gr_split[[<span class="number">1</span>]]</span><br><span class="line">GRanges object with <span class="number">2</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">      seqnames    ranges strand</span><br><span class="line">         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;</span><br><span class="line">  [<span class="number">1</span>]     chr3     <span class="number">31</span>-<span class="number">40</span>      *</span><br><span class="line">  [<span class="number">2</span>]     chr3     <span class="number">16</span>-<span class="number">24</span>      *</span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">3</span> sequences from an unspecified genome; no seqlengths</span><br><span class="line">&gt; <span class="built_in">names</span>(gr_split)</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;chr3&quot;</span> <span class="string">&quot;chr1&quot;</span> <span class="string">&quot;chr2&quot;</span></span><br></pre></td></tr></table></figure>
<p>还可以通过 unsplit() 反向操作。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">unsplit(gr_split,seqnames(gr))</span><br></pre></td></tr></table></figure>
<p>数据分组是 split-apply-combine 模式（239页）的基础。通过R的基本数据格式-列表，我们可以通过 lapply() 和 sapply() 来对所有的元素进行迭代。这两个函数也可以应用于 GRangesLists 对象。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; lapply(gr_split, <span class="keyword">function</span>(x) order(width(x)))</span><br><span class="line">$chr3</span><br><span class="line">[<span class="number">1</span>] <span class="number">2</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">$chr1</span><br><span class="line">[<span class="number">1</span>] <span class="number">2</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">$chr2</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">&gt; sapply(gr_split, <span class="keyword">function</span>(x) <span class="built_in">min</span>(start(x)))</span><br><span class="line">chr3 chr1 chr2 </span><br><span class="line">  <span class="number">16</span>   <span class="number">26</span>   <span class="number">48</span> </span><br><span class="line">&gt; sapply(gr_split, <span class="built_in">length</span>)</span><br><span class="line">chr3 chr1 chr2 </span><br><span class="line">   <span class="number">2</span>    <span class="number">2</span>    <span class="number">2</span> </span><br><span class="line">&gt; elementLengths(gr_split)</span><br><span class="line">Error <span class="keyword">in</span> elementLengths(gr_split) : 没有<span class="string">&quot;elementLengths&quot;</span>这个函数</span><br></pre></td></tr></table></figure>
<p>最后一个函数运行报错，不知道这个函数是哪个包的。</p>
<p>之前的 overlap 操作的函数都可以直接使用（我已经忘了，下面的结果我都看不懂）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; reduce(gr_split)</span><br><span class="line">GRangesList object of <span class="built_in">length</span> <span class="number">3</span>:</span><br><span class="line">$chr3</span><br><span class="line">GRanges object with <span class="number">2</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">      seqnames    ranges strand</span><br><span class="line">         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;</span><br><span class="line">  [<span class="number">1</span>]     chr3     <span class="number">16</span>-<span class="number">24</span>      *</span><br><span class="line">  [<span class="number">2</span>]     chr3     <span class="number">31</span>-<span class="number">40</span>      *</span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">3</span> sequences from an unspecified genome; no seqlengths</span><br><span class="line"></span><br><span class="line">$chr1</span><br><span class="line">GRanges object with <span class="number">1</span> <span class="built_in">range</span> and <span class="number">0</span> metadata columns:</span><br><span class="line">      seqnames    ranges strand</span><br><span class="line">         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;</span><br><span class="line">  [<span class="number">1</span>]     chr1     <span class="number">26</span>-<span class="number">60</span>      *</span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">3</span> sequences from an unspecified genome; no seqlengths</span><br><span class="line"></span><br><span class="line">$chr2</span><br><span class="line">GRanges object with <span class="number">2</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">      seqnames    ranges strand</span><br><span class="line">         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;</span><br><span class="line">  [<span class="number">1</span>]     chr2     <span class="number">48</span>-<span class="number">73</span>      *</span><br><span class="line">  [<span class="number">2</span>]     chr2     <span class="number">77</span>-<span class="number">79</span>      *</span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">3</span> sequences from an unspecified genome; no seqlengths</span><br></pre></td></tr></table></figure>
<h3 id="9-2-9-Working-with-Annotation-Data-GenomicFeatures-and-rtracklayer">9.2.9 Working with Annotation Data: GenomicFeatures and rtracklayer</h3>
<p>上面提到的 GenomicRanges 包适用于<strong>互作式运行命令</strong>和<strong>中等</strong>大小数据。这里我们学习两个 Bioconductor 包来导入和处理外部数据。这两个包有不同的目的。第一个包，GenomicFeatures 应用于基于转录的基因组注释。第二个包，rtracklayer ，可以采用不同的方式导入和导出注释数据。</p>
<p>GenomicFeatures  可以创建和处理 TranscriptDb 对象，这种对象可以允许 genomic features （genes, transcripts, exons, coding sequences），可以用一种特定的方式提取出来。在这一章节中，我们会使用一个提取写好的 TranscriptDb 对象。</p>
<p>首先，我们安装一下 GenomicFeatures 包。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!requireNamespace(<span class="string">&quot;BiocManager&quot;</span>, quietly = <span class="literal">TRUE</span>))</span><br><span class="line">  install.packages(<span class="string">&quot;BiocManager&quot;</span>)</span><br><span class="line"></span><br><span class="line">BiocManager::install(<span class="string">&quot;GenomicFeatures&quot;</span>)</span><br><span class="line"></span><br><span class="line">library(<span class="string">&quot;GenomicFeatures&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我们安装一个小鼠的转录注释包（包含了注释数据），所有的注释数据包都有相同格式的名称，</p>
<p>TxDb.<organism>.<annotation-source>.<annotation-version>.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">BiocManager::install(<span class="string">&quot;TxDb.Mmusculus.UCSC.mm10.ensGene&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>使用注释数据</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(TxDb.Mmusculus.UCSC.mm10.ensGene)</span><br><span class="line">txdb &lt;- TxDb.Mmusculus.UCSC.mm10.ensGene</span><br><span class="line">txdb</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> class(txdb)</span></span><br><span class="line">[1] &quot;TxDb&quot;</span><br><span class="line">attr(,&quot;package&quot;)</span><br><span class="line">[1] &quot;GenomicFeatures&quot;</span><br></pre></td></tr></table></figure>
<p>首先，假如我们想看注释文件中素有的基因区域。GenomicFeatures 有一个方便的函数，genes()</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; mm_genes &lt;- genes(txdb)</span><br><span class="line">&gt; head(mm_genes)</span><br><span class="line">GRanges object with <span class="number">6</span> ranges and <span class="number">1</span> metadata column:</span><br><span class="line">                     seqnames              ranges strand |            gene_id</span><br><span class="line">                        &lt;Rle&gt;           &lt;IRanges&gt;  &lt;Rle&gt; |        &lt;character&gt;</span><br><span class="line">  ENSMUSG00000000001     chr3 <span class="number">108107280</span>-<span class="number">108146146</span>      - | ENSMUSG00000000001</span><br><span class="line">  ENSMUSG00000000003     chrX   <span class="number">77837901</span>-<span class="number">77853623</span>      - | ENSMUSG00000000003</span><br><span class="line">  ENSMUSG00000000028    chr16   <span class="number">18780447</span>-<span class="number">18811987</span>      - | ENSMUSG00000000028</span><br><span class="line">  ENSMUSG00000000031     chr7 <span class="number">142575529</span>-<span class="number">142578143</span>      - | ENSMUSG00000000031</span><br><span class="line">  ENSMUSG00000000037     chrX <span class="number">161117193</span>-<span class="number">161258213</span>      + | ENSMUSG00000000037</span><br><span class="line">  ENSMUSG00000000049    chr11 <span class="number">108343354</span>-<span class="number">108414396</span>      + | ENSMUSG00000000049</span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">66</span> sequences (<span class="number">1</span> circular) from mm10 genome</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">length</span>(mm_genes)</span><br><span class="line">[<span class="number">1</span>] <span class="number">39017</span></span><br></pre></td></tr></table></figure>
<p>同样的，GenomicFeatures 还可以通过 transcripts(), exons(), cds(), promoters() 来检索转录区域，外显子，coding sequence, 启动子。</p>
<p>很多情况下我们可以像根据某种 features 来分组统计计算。比如，我们可能回根据转录区域或基因来检索所有的外显子。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; mm_exons_by_tx &lt;- exonsBy(txdb, by=<span class="string">&quot;tx&quot;</span>) <span class="comment">#根据转录区域划分外显子</span></span><br><span class="line">&gt; mm_exons_by_gn &lt;- exonsBy(txdb, by=<span class="string">&quot;gene&quot;</span>)</span><br><span class="line">&gt; <span class="built_in">length</span>(mm_exons_by_tx)</span><br><span class="line">[<span class="number">1</span>] <span class="number">94647</span></span><br><span class="line">&gt; <span class="built_in">length</span>(mm_exons_by_gn)</span><br><span class="line">[<span class="number">1</span>] <span class="number">39017</span></span><br></pre></td></tr></table></figure>
<p>还有其他的类似的函数，transcriptsBy(), exonsBy(), cdsBy(), intronsBy(), fiveUTRsByTranscript()</p>
<p>, threeUTRsByTranscript()。</p>
<p>GenomicFeatures 还可以根据重叠一个特定的染色体或范围，提取某种 features 的子集。比如指定某条染色体。（下面的命令没看懂）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">seqlevels(txdb) &lt;- <span class="string">&quot;chr1&quot;</span></span><br><span class="line">chr1_exons &lt;- exonsBy(txdb, <span class="string">&quot;tx&quot;</span>)</span><br><span class="line"><span class="built_in">all</span>(unlist(seqnames(chr1_exons)) == <span class="string">&quot;chr1&quot;</span>)</span><br><span class="line">txdb &lt;- restoreSeqlevels(txdb)</span><br></pre></td></tr></table></figure>
<p>为了提取与某个区域重叠的feature，可以使用下面这个家族的函数：transcriptsByOverlaps()， exonsByOverlaps()， cdsByOverlaps() （通过 help(transcriptByOverlaps() 查看更多信息 ）。举个例子，假如一个QTL研究在8号染色体某个区域找到了一个 QTL，从 123,260,562  到  123,557,264。但是我们仅仅是得到了一个粗略的范围，所以我们增加了 10kb 范围。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qtl_region &lt;- GRanges(<span class="string">&quot;chr8&quot;</span>, IRanges(<span class="number">123260562</span>, <span class="number">123557264</span>))</span><br><span class="line">qtl_region_expanded &lt;- qtl_region + <span class="number">10e3</span></span><br><span class="line">transcriptsByOverlaps(txdb, qtl_region_expanded)</span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; transcriptsByOverlaps(txdb, qtl_region_expanded)</span><br><span class="line">GRanges object with <span class="number">73</span> ranges and <span class="number">2</span> metadata columns:</span><br><span class="line">       seqnames              ranges strand |     tx_id            tx_name</span><br><span class="line">          &lt;Rle&gt;           &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt;        &lt;character&gt;</span><br><span class="line">   [<span class="number">1</span>]     chr8 <span class="number">119910841</span>-<span class="number">124345722</span>      + |     <span class="number">47374</span> ENSMUST00000127664</span><br><span class="line">   [<span class="number">2</span>]     chr8 <span class="number">123254195</span>-<span class="number">123269745</span>      + |     <span class="number">47530</span> ENSMUST00000001092</span><br><span class="line">   [<span class="number">3</span>]     chr8 <span class="number">123254271</span>-<span class="number">123257636</span>      + |     <span class="number">47531</span> ENSMUST00000150356</span><br><span class="line">   [<span class="number">4</span>]     chr8 <span class="number">123254284</span>-<span class="number">123269743</span>      + |     <span class="number">47532</span> ENSMUST00000156896</span><br><span class="line">   [<span class="number">5</span>]     chr8 <span class="number">123254686</span>-<span class="number">123265070</span>      + |     <span class="number">47533</span> ENSMUST00000154450</span><br><span class="line">   ...      ...                 ...    ... .       ...                ...</span><br><span class="line">  [<span class="number">69</span>]     chr8 <span class="number">123559201</span>-<span class="number">123559319</span>      - |     <span class="number">49320</span> ENSMUST00000178208</span><br><span class="line">  [<span class="number">70</span>]     chr8 <span class="number">123560888</span>-<span class="number">123561006</span>      - |     <span class="number">49321</span> ENSMUST00000179143</span><br><span class="line">  [<span class="number">71</span>]     chr8 <span class="number">123562595</span>-<span class="number">123562713</span>      - |     <span class="number">49322</span> ENSMUST00000178297</span><br><span class="line">  [<span class="number">72</span>]     chr8 <span class="number">123564286</span>-<span class="number">123564404</span>      - |     <span class="number">49323</span> ENSMUST00000179019</span><br><span class="line">  [<span class="number">73</span>]     chr8 <span class="number">123565969</span>-<span class="number">123566087</span>      - |     <span class="number">49324</span> ENSMUST00000179081</span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">66</span> sequences (<span class="number">1</span> circular) from mm10 genome</span><br></pre></td></tr></table></figure>
<p>通过 rtracklayer 导入注释数据</p>
<p>import 函数回通过后缀自动判定文件类型，然后将数据导入为一个GRanges 对象。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(rtracklayer)</span><br><span class="line">setwd(<span class="string">&quot;D:/Desktop/下载文献/生信入门/bds-files-master/chapter-09-working-with-range-data&quot;</span>)</span><br><span class="line">mm_gtf &lt;- import(<span class="string">&#x27;Mus_musculus.GRCm38.75_chr1.gtf.gz&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>rtracklayer 包也提供不同的导出方式，可以保存为很多种类的 range formats。例如，假如我们想将 5个随机的 pseudogenes 写入到一个 GTF 文件。我们可以使用</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">set.seed(<span class="number">0</span>)</span><br><span class="line">pseudogene_i &lt;- which(mm_gtf$gene_biotype == <span class="string">&quot;pseudogene&quot;</span> &amp; mm_gtf$type == <span class="string">&quot;gene&quot;</span>)</span><br><span class="line">pseudogene_sample &lt;- sample(pseudogene_i, <span class="number">5</span>)</span><br><span class="line">export(mm_gtf[pseudogene_sample], con=<span class="string">&quot;five_random_pseudogene.gtf&quot;</span>,  format=<span class="string">&quot;GTF&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还可以存储为 BED 文件格式</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">bed_data &lt;- mm_gtf[pseudogene_sample]</span><br><span class="line">mcols(bed_data) &lt;- <span class="literal">NULL</span><span class="comment"># clear out metadata columns</span></span><br><span class="line">export(bed_data, con=<span class="string">&quot;five_random_pseudogene.bed&quot;</span>, format=<span class="string">&quot;BED&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="9-2-10-Retrieving-Promoter-Regions-Flank-and-Promoters">9.2.10 Retrieving Promoter Regions: Flank and Promoters</h3>
<p>现在，我们看这些 range operation 如何解决实际问题。我们先从上面导入的 GTF 注释文件中<strong>提取1号染色体上的所有蛋白质编码基因的启动子区域</strong>（长难句）。</p>
<p>首先，我们要找到我们感兴趣的基因的子集，也就是编码蛋白质的基因。</p>
<p>查看基因的类型</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; table(mm_gtf$gene_biotype)</span><br><span class="line"></span><br><span class="line">             antisense                lincRNA                  miRNA </span><br><span class="line">                   <span class="number">480</span>                    <span class="number">551</span>                    <span class="number">354</span> </span><br><span class="line">              misc_RNA polymorphic_pseudogene   processed_transcript </span><br><span class="line">                    <span class="number">93</span>                     <span class="number">61</span>                    <span class="number">400</span> </span><br><span class="line">        protein_coding             pseudogene                   rRNA </span><br><span class="line">                 <span class="number">77603</span>                    <span class="number">978</span>                     <span class="number">69</span> </span><br><span class="line">        sense_intronic      sense_overlapping                 snoRNA </span><br><span class="line">                    <span class="number">21</span>                      <span class="number">4</span>                    <span class="number">297</span> </span><br><span class="line">                 snRNA </span><br><span class="line">                   <span class="number">315</span> </span><br></pre></td></tr></table></figure>
<p>提取想要的基因，并统计</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; chr1_pcg &lt;- mm_gtf[mm_gtf$type == <span class="string">&quot;gene&quot;</span> &amp; mm_gtf$gene_biotype == <span class="string">&quot;protein_coding&quot;</span>]</span><br><span class="line">&gt; summary(width(chr1_pcg))</span><br><span class="line">   Min. <span class="number">1</span>st Qu.  Median    Mean <span class="number">3</span>rd Qu.    Max. </span><br><span class="line">     <span class="number">78</span>    <span class="number">9429</span>   <span class="number">25754</span>   <span class="number">60640</span>   <span class="number">62423</span> <span class="number">1075874</span> </span><br><span class="line">&gt; <span class="built_in">length</span>(chr1_pcg)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1240</span></span><br></pre></td></tr></table></figure>
<p>然后我们用 flank 函数 来抓取每个基因的 3K 上游区域。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">chr1_pcg_3kb_up &lt;- flank(chr1_pcg, width=<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>
<p>GenomociRanges 还有一个简单的函数可以实现上述操作，promoters() （自动提取每个区域 3K 的上游区域，还有 200 bp 的下游区域）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; chr1_pcg_3kb_up2 &lt;- promoters(chr1_pcg, upstream=<span class="number">3000</span>, downstream=<span class="number">0</span>)</span><br><span class="line">&gt; identical(chr1_pcg_3kb_up, chr1_pcg_3kb_up2)</span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure>
<h3 id="9-2-11-Retrieving-Promoter-Sequence-Connection-GenomicRanges-with-Sequence-Data">9.2.11 Retrieving Promoter Sequence: Connection GenomicRanges with Sequence Data</h3>
<p>一旦我们确定了启动子的范围，我们就可以从一个基因组序列中提取启动的序列。这里存在两种不同的方式可以实现这一点。</p>
<ul>
<li>通过 Bioconductor 的包来实现</li>
<li>通过将 GenomicRanges 对象导出为一个 range file，例如 BED，然后通过一个命令行工具实现，比如 BEDTools</li>
</ul>
<p>这两种都可以，但是第一种方式需要实现将基因组序列信息保存为一个特殊的R包（类似于上面的注释包）。如果你研究的物种没有这样一个 genome package ，第二种方式可能更快。</p>
<p>由于我们研究的物种是小鼠，事先已经有了 genome package，供我们下载及使用。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">BiocManager::install(<span class="string">&quot;BSgenome&quot;</span>)</span><br><span class="line">library(BSgenome)</span><br><span class="line">BiocManager::install(<span class="string">&quot;BSgenome.Mmusculus.UCSC.mm10&quot;</span>)</span><br><span class="line">library(BSgenome.Mmusculus.UCSC.mm10)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以查看一些基本信息</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; mm_gm &lt;- BSgenome.Mmusculus.UCSC.mm10</span><br><span class="line">&gt; organism(mm_gm)</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;Mus musculus&quot;</span></span><br><span class="line">&gt; providerVersion(mm_gm)</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;mm10&quot;</span></span><br><span class="line">&gt; provider(mm_gm)</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;UCSC&quot;</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过 seqinfo() 查看序列信息。BSgenome  packages 包括了每条染色体的序列，存储在一个类似列表的结构中，我们可以通过索引提取某条染色体的信息。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; seqinfo(mm_gm)</span><br><span class="line">Seqinfo object with <span class="number">66</span> sequences (<span class="number">1</span> circular) from mm10 genome:</span><br><span class="line">  seqnames       seqlengths isCircular genome</span><br><span class="line">  chr1            <span class="number">195471971</span>      <span class="literal">FALSE</span>   mm10</span><br><span class="line">  chr2            <span class="number">182113224</span>      <span class="literal">FALSE</span>   mm10</span><br><span class="line">  chr3            <span class="number">160039680</span>      <span class="literal">FALSE</span>   mm10</span><br><span class="line">  chr4            <span class="number">156508116</span>      <span class="literal">FALSE</span>   mm10</span><br><span class="line">  chr5            <span class="number">151834684</span>      <span class="literal">FALSE</span>   mm10</span><br><span class="line">  ...                   ...        ...    ...</span><br><span class="line">  chrUn_GL456392      <span class="number">23629</span>      <span class="literal">FALSE</span>   mm10</span><br><span class="line">  chrUn_GL456393      <span class="number">55711</span>      <span class="literal">FALSE</span>   mm10</span><br><span class="line">  chrUn_GL456394      <span class="number">24323</span>      <span class="literal">FALSE</span>   mm10</span><br><span class="line">  chrUn_GL456396      <span class="number">21240</span>      <span class="literal">FALSE</span>   mm10</span><br><span class="line">  chrUn_JH584304     <span class="number">114452</span>      <span class="literal">FALSE</span>   mm10</span><br><span class="line">&gt; mm_gm$chrM</span><br><span class="line">16299-letter DNAString object</span><br><span class="line">seq: GTTAATGTAGCTTAATAACAAAGCAAAGCACTGAAAATGCTTAGATGGATAATTGTATCCCATAAACACAA...AAATTTTACAAAATCATGTTCCGTGAACCAAAACTCTAATCATACTCTATTACGCAATAAACATTAACAA</span><br><span class="line">&gt; mm_gm[[<span class="number">22</span>]]</span><br><span class="line">16299-letter DNAString object</span><br><span class="line">seq: GTTAATGTAGCTTAATAACAAAGCAAAGCACTGAAAATGCTTAGATGGATAATTGTATCCCATAAACACAA...AAATTTTACAAAATCATGTTCCGTGAACCAAAACTCTAATCATACTCTATTACGCAATAAACATTAACAA</span><br></pre></td></tr></table></figure>
<p>另外， BSgenome objects 还可以通过字符配对 和 alignment functions（？）来搜索序列。比如</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; library(Biostrings)</span><br><span class="line">&gt; matchPattern(<span class="string">&quot;GGCGCGCC&quot;</span>, mm_gm$chr1)</span><br><span class="line">Views on a <span class="number">195471971</span>-letter DNAString subject</span><br><span class="line">subject: NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN...NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN</span><br><span class="line">views:</span><br><span class="line">            start       end width</span><br><span class="line">    [<span class="number">1</span>]   <span class="number">4557138</span>   <span class="number">4557145</span>     <span class="number">8</span> [GGCGCGCC]</span><br><span class="line">    [<span class="number">2</span>]   <span class="number">4567326</span>   <span class="number">4567333</span>     <span class="number">8</span> [GGCGCGCC]</span><br><span class="line">    [<span class="number">3</span>]   <span class="number">6960128</span>   <span class="number">6960135</span>     <span class="number">8</span> [GGCGCGCC]</span><br><span class="line">    [<span class="number">4</span>]   <span class="number">7397441</span>   <span class="number">7397448</span>     <span class="number">8</span> [GGCGCGCC]</span><br><span class="line">    [<span class="number">5</span>]   <span class="number">7398352</span>   <span class="number">7398359</span>     <span class="number">8</span> [GGCGCGCC]</span><br><span class="line">    ...       ...       ...   ... ...</span><br><span class="line">  [<span class="number">144</span>] <span class="number">191907520</span> <span class="number">191907527</span>     <span class="number">8</span> [GGCGCGCC]</span><br><span class="line">  [<span class="number">145</span>] <span class="number">191934164</span> <span class="number">191934171</span>     <span class="number">8</span> [GGCGCGCC]</span><br><span class="line">  [<span class="number">146</span>] <span class="number">191942448</span> <span class="number">191942455</span>     <span class="number">8</span> [GGCGCGCC]</span><br><span class="line">  [<span class="number">147</span>] <span class="number">192834335</span> <span class="number">192834342</span>     <span class="number">8</span> [GGCGCGCC]</span><br><span class="line">  [<span class="number">148</span>] <span class="number">193589224</span> <span class="number">193589231</span>     <span class="number">8</span> [GGCGCGCC]</span><br></pre></td></tr></table></figure>
<p>之前的染色体编号是数字，这里是 chr1、chr2 ，首先我们需要先统一染色体编号。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">all</span>(seqlevels(chr1_pcg_3kb_up) %in% seqlevels(mm_gm))</span><br><span class="line">[<span class="number">1</span>] <span class="literal">FALSE</span></span><br><span class="line">&gt; gr &lt;- GRanges(<span class="built_in">c</span>(<span class="string">&quot;chr1&quot;</span>, <span class="string">&quot;chr2&quot;</span>), IRanges(start=<span class="built_in">c</span>(<span class="number">3</span>, <span class="number">4</span>), width=<span class="number">10</span>)) <span class="comment">#测试</span></span><br><span class="line">&gt; seqlevels(gr)</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;chr1&quot;</span> <span class="string">&quot;chr2&quot;</span></span><br><span class="line">&gt; seqlevels(gr) &lt;- <span class="built_in">c</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>) <span class="comment">#按照相同的顺序重编码</span></span><br><span class="line">&gt; seqlevels(gr)</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;1&quot;</span> <span class="string">&quot;2&quot;</span></span><br><span class="line">&gt; seqlevelsStyle(chr1_pcg_3kb_up)</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;NCBI&quot;</span>    <span class="string">&quot;Ensembl&quot;</span> <span class="string">&quot;MSU6&quot;</span>    <span class="string">&quot;AGPvF&quot;</span>  </span><br><span class="line">&gt; seqlevelsStyle(mm_gm)</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;UCSC&quot;</span></span><br><span class="line">&gt; seqlevelsStyle(chr1_pcg_3kb_up) &lt;- <span class="string">&quot;UCSC&quot;</span> <span class="comment">#转化为UCSC格式</span></span><br><span class="line">&gt; <span class="built_in">all</span>(seqlevels(chr1_pcg_3kb_up) %in% seqlevels(mm_gm))</span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure>
<p>统一了二者格式之后，可以轻松提取 GRanges 对象中特定区域的序列</p>
<p>getSeq() 函数需要两个参数，第一个为 BSgenome 对象，第二个是  GRanges 对象，最终回返回每个range的序列信息。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; chr1_3kb_seqs &lt;- getSeq(mm_gm, chr1_pcg_3kb_up)</span><br><span class="line">&gt; chr1_3kb_seqs</span><br><span class="line">DNAStringSet object of <span class="built_in">length</span> <span class="number">1240</span>:</span><br><span class="line">       width seq</span><br><span class="line">   [<span class="number">1</span>]  <span class="number">3000</span> ATTCTGAGATGTGGTTACTAGATCAATGGGATTAGAGACTATTGAGAGCAGTATTGCACACAAAGCC...CAGCCAGGCGGCGCTCCTGCGGGTCCCGAGCGTGCGGCTAGCCGGGCCCAGCGCCCAGCCCCGCGG</span><br><span class="line">   [<span class="number">2</span>]  <span class="number">3000</span> GAAGTGGTATATCTGCCTAGTCTAGGTGTGCAGCTTATAAATAGTATAATTCAGTTGTGTGTTCTTT...TGGAGATTAACATCACCTTGGATTAAATTAATTGGCTGTACTTAATCTGTGAGCACACATGCTAGT</span><br><span class="line">   [<span class="number">3</span>]  <span class="number">3000</span> CTTAAAAACCTAGATATTCTATTTTTTTTTTTTCTGAGACAGGGTTTTTCTGTGTAGCCCTGGCTGT...TGTTTGCTTCTTTACTTGTGGCATTTGTGGCTGGCTTTGATAACGTCGTGAGCTCGGCTTCCAACA</span><br><span class="line">   [<span class="number">4</span>]  <span class="number">3000</span> GAATTGGCACAGTTTCACATGATTGGTCCATTTAAACATTAGCAGACTGTCAGAAGGGCGGGAGATA...TGCGGTCGCTCTGCAGCACGACAGGGGCGGGGCAGTACGGCCGCTGCAGCGCGACAGGGGCCGGGC</span><br><span class="line">   [<span class="number">5</span>]  <span class="number">3000</span> AAATATAAAGTTAACATACAAAAACTAGTCGCATTGATATACACTCACAACTATCAGAAAGGGAAAT...GGAAGGCTCACTATGACGCGCACGCGCGGCCGAATCGGGGCGCGAGCTCGGGGCCGAACGCGAGGA</span><br><span class="line">   ...   ... ...</span><br><span class="line">[<span class="number">1236</span>]  <span class="number">3000</span> CAACATGGGTAGTAGTGGGGGAGCTTTAGTTCCAAAGTATGAAACTGAAAAAATAGAAATGAAAAAA...TGACACACGGTTAAAAGTGAAGTAGGAACTACGAGAGGGGCTGGCCTCACCAAGACGCAACAGGGA</span><br><span class="line">[<span class="number">1237</span>]  <span class="number">3000</span> AGGTGTGTTATATAATAATTGGTTTGACACTGCCCTGGTTAGTTTTATGTCAGTTTGACATAAGATA...TTTAGTTTCAGGATTGTTGCGTCTGTTCACCTATCTTAAAACTTGCTCTCTGGCTTCCTGGCGCCC</span><br><span class="line">[<span class="number">1238</span>]  <span class="number">3000</span> TTGGCCAGGTGATTGATCTTGTCCAACTGGAATATTAGTCATCTATACAGGCCAGGTATTTTAATTT...GGTTAGGCTCCACCCTTGCAGATTTTTAAAAGGAGTAAGGCCGGGCTATATGCAAACCGAGTTCCC</span><br><span class="line">[<span class="number">1239</span>]  <span class="number">3000</span> GGCATTCCCCTATACTGGGGCATAGAACCTTCTCAAGACCAAGGGCCTCTCTTCCCATTGATGGCCG...TCAGTACCCAGCGCCACCGCGCGGAGCCGATGCTATTTAAGGGTCTGCTCCCCACTGCTTACAGCC</span><br><span class="line">[<span class="number">1240</span>]  <span class="number">3000</span> GTAAATTTTCAGGTATATTTCTTTCTACTCTTGTAGGGTTTCACAAAGTGGTACTTTTTGTCTAGAT...AAAAGAGAAGCAGAGAAACTTTAGCTTTTCTCAGCTTTGATATTTCTGTGGTCCTTATTTCTAGGT</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>
<p>我们还可以把这些序列信息写入到一个 FASTA 文件</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">writeXStringSet(chr1_3kb_seqs, file=<span class="string">&quot;mm10_chr1_3kb_promoters.fasta&quot;</span>,  format=<span class="string">&quot;fasta&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="9-2-12-Getting-Intergenic-and-Intronic-Regions-Gaps-Reduce-and-Setdiffs-in-Practice">9.2.12 Getting Intergenic and Intronic Regions: Gaps, Reduce, and  Setdiffs in Practice</h3>
<p>作为一个例子，我们来看 gaps() 函数如何作用于 GRanges 对象。</p>
<p>由于考虑了 strands  （+ - *, * 表示不确定的链），结果变得很复杂。 gaps 是覆盖整条染色体得到的结果。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; gr2 &lt;- GRanges(<span class="built_in">c</span>(<span class="string">&quot;chr1&quot;</span>, <span class="string">&quot;chr2&quot;</span>), IRanges(start=<span class="built_in">c</span>(<span class="number">4</span>, <span class="number">12</span>), width=<span class="number">6</span>), strand=<span class="built_in">c</span>(<span class="string">&quot;+&quot;</span>, <span class="string">&quot;-&quot;</span>), seqlengths=<span class="built_in">c</span>(chr1=<span class="number">21</span>, chr2=<span class="number">41</span>))</span><br><span class="line">&gt; gr2</span><br><span class="line">GRanges object with <span class="number">2</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">      seqnames    ranges strand</span><br><span class="line">         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;</span><br><span class="line">  [<span class="number">1</span>]     chr1       <span class="number">4</span>-<span class="number">9</span>      +</span><br><span class="line">  [<span class="number">2</span>]     chr2     <span class="number">12</span>-<span class="number">17</span>      -</span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">2</span> sequences from an unspecified genome</span><br><span class="line">&gt; gaps(gr2)</span><br><span class="line">GRanges object with <span class="number">8</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">      seqnames    ranges strand</span><br><span class="line">         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;</span><br><span class="line">  [<span class="number">1</span>]     chr1       <span class="number">1</span>-<span class="number">3</span>      +</span><br><span class="line">  [<span class="number">2</span>]     chr1     <span class="number">10</span>-<span class="number">21</span>      +</span><br><span class="line">  [<span class="number">3</span>]     chr1      <span class="number">1</span>-<span class="number">21</span>      -</span><br><span class="line">  [<span class="number">4</span>]     chr1      <span class="number">1</span>-<span class="number">21</span>      *</span><br><span class="line">  [<span class="number">5</span>]     chr2      <span class="number">1</span>-<span class="number">41</span>      +</span><br><span class="line">  [<span class="number">6</span>]     chr2      <span class="number">1</span>-<span class="number">11</span>      -</span><br><span class="line">  [<span class="number">7</span>]     chr2     <span class="number">18</span>-<span class="number">41</span>      -</span><br><span class="line">  [<span class="number">8</span>]     chr2      <span class="number">1</span>-<span class="number">41</span>      *</span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">2</span> sequences from an unspecified genome</span><br></pre></td></tr></table></figure>
<p>如果我们不关心 strands，我们可以按照以下命令操作（通常我们都不关心 strand信息，我们区域是一个 range，哪些区域是一个 gap）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; gr3 &lt;- gr2</span><br><span class="line">&gt; strand(gr3) &lt;- <span class="string">&quot;*&quot;</span> <span class="comment">#strand信息均改为 *</span></span><br><span class="line">&gt; gaps(gr3)[strand(gaps(gr3)) == <span class="string">&quot;*&quot;</span>]</span><br><span class="line">GRanges object with <span class="number">4</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">      seqnames    ranges strand</span><br><span class="line">         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;</span><br><span class="line">  [<span class="number">1</span>]     chr1       <span class="number">1</span>-<span class="number">3</span>      *</span><br><span class="line">  [<span class="number">2</span>]     chr1     <span class="number">10</span>-<span class="number">21</span>      *</span><br><span class="line">  [<span class="number">3</span>]     chr2      <span class="number">1</span>-<span class="number">11</span>      *</span><br><span class="line">  [<span class="number">4</span>]     chr2     <span class="number">18</span>-<span class="number">41</span>      *</span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">2</span> sequences from an unspecified genome</span><br></pre></td></tr></table></figure>
<p>另外一个创建 gaps 的方式是利用 set operations。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">chrom_grngs &lt;- as(seqinfo(txdb), <span class="string">&quot;GRanges&quot;</span>)</span><br><span class="line"><span class="comment">#使用 as() 函数强行转化为 GRanges 对象</span></span><br><span class="line">head(chrom_grngs, <span class="number">2</span>)</span><br><span class="line">collapsed_tx &lt;- reduce(transcripts(txdb))</span><br><span class="line"><span class="comment">#提取Transcripts对象，并通过 reduce() 将重叠的序列合并为1个</span></span><br><span class="line"></span><br><span class="line">strand(collapsed_tx) &lt;- <span class="string">&quot;*&quot;</span></span><br><span class="line"><span class="comment">#将 strand 信息均设置为*，即之后不考虑strand</span></span><br><span class="line">intergenic &lt;- setdiff(chrom_grngs, collapsed_tx)</span><br><span class="line"><span class="comment">#重整个染色体中提取不转录的gap序列</span></span><br></pre></td></tr></table></figure>
<p>现在我们看看如果创建表示内含子的 GRanges 对象。我们可以通过两种方式实现：第一种，使用一个简单的函数 intronsByTranscripts() ，这种方法很快。第二种方法，自己手动操作，利用 range set operations, 这样之后你可以自己解决很多其他的序列问题。</p>
<p>首先，看第一种方法</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; mm_introns &lt;- intronsByTranscript(txdb)</span><br><span class="line">&gt; head(mm_introns[[<span class="string">&#x27;18880&#x27;</span>]], <span class="number">2</span>) </span><br><span class="line">GRanges object with <span class="number">2</span> ranges and <span class="number">0</span> metadata columns:</span><br><span class="line">      seqnames              ranges strand</span><br><span class="line">         &lt;Rle&gt;           &lt;IRanges&gt;  &lt;Rle&gt;</span><br><span class="line">  [<span class="number">1</span>]     chr3 <span class="number">113556174</span>-<span class="number">113558092</span>      -</span><br><span class="line">  [<span class="number">2</span>]     chr3 <span class="number">113558219</span>-<span class="number">113558321</span>      -</span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">66</span> sequences (<span class="number">1</span> circular) from mm10 genome</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>
<p>现在我们看第二种方法，通过 range set operations。这种比较难。</p>
<p>首先我们通过一个简单的例子，提取单个基因（amylase 1，在Ensembl 的编号为 ENSMUSG00000074264）的内含子序列。我们提取内含子序列的原理是用<strong>transcripts range - exons’ ranges</strong>。我们先拿到整个转录序列</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; amy1 &lt;- transcriptsBy(txdb, <span class="string">&#x27;gene&#x27;</span>)$ENSMUSG00000074264</span><br><span class="line">&gt; </span><br><span class="line">&gt; amy1</span><br><span class="line">GRanges object with <span class="number">5</span> ranges and <span class="number">2</span> metadata columns:</span><br><span class="line">      seqnames              ranges strand |     tx_id            tx_name</span><br><span class="line">         &lt;Rle&gt;           &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt;        &lt;character&gt;</span><br><span class="line">  [<span class="number">1</span>]     chr3 <span class="number">113555710</span>-<span class="number">113577830</span>      - |     <span class="number">18879</span> ENSMUST00000067980</span><br><span class="line">  [<span class="number">2</span>]     chr3 <span class="number">113555953</span>-<span class="number">113574762</span>      - |     <span class="number">18880</span> ENSMUST00000106540</span><br><span class="line">  [<span class="number">3</span>]     chr3 <span class="number">113556149</span>-<span class="number">113562018</span>      - |     <span class="number">18881</span> ENSMUST00000172885</span><br><span class="line">  [<span class="number">4</span>]     chr3 <span class="number">113562690</span>-<span class="number">113574272</span>      - |     <span class="number">18882</span> ENSMUST00000142505</span><br><span class="line">  [<span class="number">5</span>]     chr3 <span class="number">113564987</span>-<span class="number">113606699</span>      - |     <span class="number">18883</span> ENSMUST00000174147</span><br><span class="line">  -------</span><br><span class="line">  seqinfo: <span class="number">66</span> sequences (<span class="number">1</span> circular) from mm10 genome</span><br></pre></td></tr></table></figure>
<p>在 amylase 1 基因上存在 5 个 transcripts （每一个都要计算内含子区域）（为什么一个基因会有5个转录区域？）。我们可以先提取所有的外显子区域，然后提取我们需要的子集。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mm_exons &lt;- exonsBy(txdb, <span class="string">&quot;tx&quot;</span>)</span><br><span class="line">mm_exons[[<span class="number">18881</span>]] <span class="comment">#举例</span></span><br></pre></td></tr></table></figure>
<p>由于生成的 mm_exons 是一个以transcript names 为元素名称的 GRangesList 对象。因此我们可以对transcript GRangesList 和 exon GRangesList 进行匹配 （采用 match() 函数）</p>
<p>首先，我们需要把转录序列也转变成以transcript names 为元素名称的 GRangesList 对象</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">amy1_tx &lt;- split(amy1, amy1$tx_id)</span><br></pre></td></tr></table></figure>
<p>然后，配对，获得这个基因的外显子区域序列</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">amy1_exons &lt;- mm_exons[match(<span class="built_in">names</span>(amy1_tx), <span class="built_in">names</span>(mm_exons))]</span><br><span class="line">amy1_exons</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后通过 pairwise set difference 操作（psetdiff() 函数），得到每个 transcript 的内含子区域。（报错了）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">all</span>(<span class="built_in">names</span>(amy1_tx) == <span class="built_in">names</span>(amy1_exons))  <span class="comment"># check everything&#x27;s matched up</span></span><br><span class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></span><br><span class="line">&gt; amy1_introns &lt;- psetdiff(amy1_tx, amy1_exons)</span><br><span class="line">Error <span class="keyword">in</span> (<span class="keyword">function</span> (classes, fdef, mtable)  : </span><br><span class="line">  unable to find an inherited method <span class="keyword">for</span> <span class="keyword">function</span> ‘psetdiff’ <span class="keyword">for</span> signature ‘<span class="string">&quot;CompressedGRangesList&quot;</span>, <span class="string">&quot;CompressedGRangesList&quot;</span>’</span><br></pre></td></tr></table></figure>
<h3 id="9-2-13-Finding-and-Working-with-Overlapping-Ranges">9.2.13 Finding and Working with Overlapping Ranges</h3>
<p>发现和计算 overlaps 可能是最重要的操作。</p>
<p>为了说明 findoverlaps() 能够用于 GRanges 对象，我们会加载一个 dpSNP（除了SNP，dpSNP 还包括   insertions/deletions,   short   tandem   repeats,   multinucleotide  polymorphisms)） 的 BED 文件（染色体1）。这个文件在GitHub的库中。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; library(rtracklayer)</span><br><span class="line">&gt; dbsnp137 &lt;- import(<span class="string">&quot;D:/Desktop/下载文献/生信入门/bds-files-master/chapter-09-working-with-range-data/mm10_snp137_chr1_trunc.bed.gz&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>假设我们想要找出多少个 variants 在外显子区域中，然后多少个 variants 不在外显子区域。</p>
<p>首先，我们提取1号染色体上的所有外显子区域</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">collapsed_exons &lt;- reduce(exons(txdb), ignore.strand=<span class="literal">TRUE</span>)</span><br><span class="line">chr1_collapsed_exons &lt;- collapsed_exons[seqnames(collapsed_exons) == <span class="string">&quot;chr1&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以参看 variants 的分布，最大的序列长度是732，有点太大了（作者估计是存在大范围的插入/缺失 insertion/deletion）。但是最多的还是一个长度的，这种估计就是SNP或者一个位点长度的indel 位点。</p>
<p>然后还有长度是0的位点，这种是参考基因组没有，突变型是插入碱基的情况。长度是0的variant，不会和其他 feature 存在 overlap。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; summary(width(dbsnp137))</span><br><span class="line">   Min. <span class="number">1</span>st Qu.  Median    Mean <span class="number">3</span>rd Qu.    Max. </span><br><span class="line">  <span class="number">0.000</span>   <span class="number">1.000</span>   <span class="number">1.000</span>   <span class="number">1.142</span>   <span class="number">1.000</span> <span class="number">732.000</span> </span><br><span class="line">&gt; dbsnp137$name[which.max(width(dbsnp137))]</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;rs232497063&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>To count these zero-width features too, we’ll resize using the  resize() function :</p>
</blockquote>
<p>不知道 resize 函数是做什么的。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dbsnp137_resized &lt;- dbsnp137</span><br><span class="line">zw_i &lt;- width(dbsnp137_resized) == <span class="number">0</span></span><br><span class="line">dbsnp137_resized[zw_i] &lt;- resize(dbsnp137_resized[zw_i], width=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>现在我们可以查看有多少 variants 在1号染色体的外显子中（忽略 strand）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; hits &lt;- findOverlaps(dbsnp137_resized, chr1_collapsed_exons,  ignore.strand=<span class="literal">TRUE</span>)</span><br><span class="line">&gt; hits</span><br><span class="line">Hits object with <span class="number">57624</span> hits and <span class="number">0</span> metadata columns:</span><br><span class="line">          queryHits subjectHits</span><br><span class="line">          &lt;integer&gt;   &lt;integer&gt;</span><br><span class="line">      [<span class="number">1</span>]        <span class="number">89</span>        <span class="number">2336</span></span><br><span class="line">      [<span class="number">2</span>]       <span class="number">190</span>        <span class="number">1731</span></span><br><span class="line">      [<span class="number">3</span>]       <span class="number">266</span>        <span class="number">9170</span></span><br><span class="line">      [<span class="number">4</span>]       <span class="number">356</span>       <span class="number">11652</span></span><br><span class="line">      [<span class="number">5</span>]       <span class="number">426</span>        <span class="number">5986</span></span><br><span class="line">      ...       ...         ...</span><br><span class="line">  [<span class="number">57620</span>]   <span class="number">2699766</span>       <span class="number">14422</span></span><br><span class="line">  [<span class="number">57621</span>]   <span class="number">2699875</span>        <span class="number">9548</span></span><br><span class="line">  [<span class="number">57622</span>]   <span class="number">2699961</span>        <span class="number">8735</span></span><br><span class="line">  [<span class="number">57623</span>]   <span class="number">2699985</span>        <span class="number">7981</span></span><br><span class="line">  [<span class="number">57624</span>]   <span class="number">2699987</span>        <span class="number">7691</span></span><br><span class="line">  -------</span><br><span class="line">  queryLength: <span class="number">2700000</span> / subjectLength: <span class="number">15048</span></span><br><span class="line">&gt; <span class="built_in">length</span>(unique(queryHits(hits)))</span><br><span class="line">[<span class="number">1</span>] <span class="number">57623</span></span><br><span class="line">&gt; <span class="built_in">length</span>(unique(queryHits(hits)))/<span class="built_in">length</span>(dbsnp137_resized)</span><br><span class="line">[<span class="number">1</span>] <span class="number">0.02134185</span></span><br></pre></td></tr></table></figure>
<p>假设我们想要查看这些与1号染色体的外显子重叠的variants，我们可以用 subsetByOverlaps() 函数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; subsetByOverlaps(dbsnp137_resized, chr1_collapsed_exons, ignore.strand=<span class="literal">TRUE</span>)</span><br><span class="line">GRanges object with <span class="number">57623</span> ranges and <span class="number">2</span> metadata columns:</span><br><span class="line">          seqnames            ranges strand |        name     score</span><br><span class="line">             &lt;Rle&gt;         &lt;IRanges&gt;  &lt;Rle&gt; | &lt;character&gt; &lt;numeric&gt;</span><br><span class="line">      [<span class="number">1</span>]     chr1          <span class="number">43032144</span>      + | rs250123171         <span class="number">0</span></span><br><span class="line">      [<span class="number">2</span>]     chr1          <span class="number">36713805</span>      + |  rs50487270         <span class="number">0</span></span><br><span class="line">      [<span class="number">3</span>]     chr1         <span class="number">132567494</span>      + | rs247294715         <span class="number">0</span></span><br><span class="line">      [<span class="number">4</span>]     chr1         <span class="number">160995431</span>      + |  rs47617081         <span class="number">0</span></span><br><span class="line">      [<span class="number">5</span>]     chr1 <span class="number">84036552</span>-<span class="number">84036553</span>      + | rs216202117         <span class="number">0</span></span><br><span class="line">      ...      ...               ...    ... .         ...       ...</span><br></pre></td></tr></table></figure>
<p>GenomicRanges 还有一个函数  countOverlaps()，可以分组统计重叠数目。比如我们想基于外显子区域统计重叠的variants 数目。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; var_counts &lt;- countOverlaps(chr1_collapsed_exons, dbsnp137_resized,  ignore.strand=<span class="literal">TRUE</span>)</span><br><span class="line">&gt; head(var_counts)</span><br><span class="line">[<span class="number">1</span>]  <span class="number">1</span>  <span class="number">0</span> <span class="number">17</span> <span class="number">21</span>  <span class="number">1</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="9-2-14-Calculating-Coverage-of-GRanges-Objects">9.2.14 Calculating Coverage of GRanges Objects</h3>
<p>让我们基于19号染色体随机生成一些150bp的 reads，然后根据经验计算 coverage。我们的目标是5乘的 coverage。采用著名的 Lander-Waterman coverage equation （C = LN/G，C 是乘数，L 是 read length，N 是 the number of reads ，G 是 sequence length ）（很简单啊）</p>
<p>根据这个式子，如果采用 150bp 的read，对于一个长度为 61,431,566bp 的染色体，达到5乘的深度需要 5*61,431,566/150 = 2,047,719 reads。我们通过sample() 函数实现这一点</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">set.seed(<span class="number">0</span>)</span><br><span class="line">chr19_len &lt;- seqlengths(txdb)[<span class="string">&#x27;chr19&#x27;</span>]</span><br><span class="line">chr19_len</span><br><span class="line">start_pos &lt;- sample(<span class="number">1</span>:(chr19_len-<span class="number">150</span>), <span class="number">2047719</span>, replace=<span class="literal">TRUE</span>)</span><br><span class="line">reads &lt;- GRanges(<span class="string">&quot;chr19&quot;</span>, IRanges(start=start_pos, width=<span class="number">150</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，我们可以用  GenomicRanges 包中的 coverage() 函数计算这些reads的测序深度。</p>
<p>coverage() 是基于染色体计算的</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; cov_reads &lt;- coverage(reads)</span><br><span class="line">&gt; mean(cov_reads)</span><br><span class="line">   chr19 </span><br><span class="line">5.000001 </span><br></pre></td></tr></table></figure>
<p>通过这个函数我们也可以轻松计算，在这条染色体上有多少地方是没有reads覆盖的（这会发生在 shotgun sequencing）。这个也可以通过两种方式计算</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; table(cov_reads == <span class="number">0</span>)</span><br><span class="line">         <span class="literal">FALSE</span>     <span class="literal">TRUE</span></span><br><span class="line">chr19 <span class="number">61016613</span>   <span class="number">414942</span></span><br></pre></td></tr></table></figure>
<p>第二种，使用 run-length encoding tricks （速度更快）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">sum</span>(runLength(cov_reads)[runValue(cov_reads) == <span class="number">0</span>])</span><br><span class="line"> chr19 </span><br><span class="line">414942 </span><br><span class="line">&gt; <span class="number">406487</span>/chr19_len</span><br><span class="line">      chr19 </span><br><span class="line">0.006616908 </span><br></pre></td></tr></table></figure>
<p>可以看出，我们通过随机抽样的结果是仍然有0.6%的地方没有覆盖。</p>
<h2 id="9-3-Working-with-Ranges-Data-on-the-Command-Line-with-BEDTools">9.3 Working with Ranges Data on the Command Line with BEDTools</h2>
<p>前面提到的 GenomicRanges 包需要一次性将数据储存到内存中。</p>
<p>BEDTools suite 是一系列处理 range file （例如 BED, GTF, GFF）的 命令行工具。</p>
<p>本章节用到的数据:</p>
<ul>
<li>
<p>ranges_qry.bed ： 包含6个 ranges 的 BED文件。</p>
<blockquote>
<p>These  are  the  queryranges used in the GenomicRangesfindOverlaps examples (except, because theseare in BED format, they are 0-indexed).</p>
</blockquote>
</li>
<li>
<p>ranges_sbj.bed :  没看懂</p>
</li>
<li>
<p>Mus_musculus.GRCm38.75_chr1.gtf.gz ：1号染色体上的 features</p>
</li>
<li>
<p>Mus_musculus.GRCm38_genome.txt ： 染色体名称和长度</p>
</li>
</ul>
<h3 id="9-3-1-Computing-Overlaps-with-BEDTools-Intersect">9.3.1 Computing Overlaps with BEDTools Intersect</h3>
<p>BEDTools 的 intersect 子命令计算两个ranges集之间的overlaps。</p>
<p>最终返回第一个文件中二者的共同部分。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(base) [zhouziwen@ny 20210107]$ cat ranges-qry.bed</span><br><span class="line">chr1    0       15      a</span><br><span class="line">chr1    25      29      b</span><br><span class="line">chr1    18      18      c</span><br><span class="line">chr1    10      14      d</span><br><span class="line">chr1    20      23      e</span><br><span class="line">chr1    6       7       f</span><br><span class="line">(base) [zhouziwen@ny 20210107]$ cat ranges-sbj.bed</span><br><span class="line">chr1    0       4       x</span><br><span class="line">chr1    18      28      y</span><br><span class="line">chr1    9       15      z</span><br><span class="line">(base) [zhouziwen@ny 20210107]$ bedtools intersect -a ranges-qry.bed -b ranges-sbj.bed</span><br><span class="line">chr1    0       4       a</span><br><span class="line">chr1    9       15      a</span><br><span class="line">chr1    25      28      b</span><br><span class="line">chr1    18      18      c</span><br><span class="line">chr1    10      14      d</span><br><span class="line">chr1    20      23      e</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有时我们只想返回 overlap B 序列的A序列，需要使用 -wa 选项</p>
<p>这里a 返回了两次，是因为 a 与另一个文件重叠了两次（x 和 z），如果你不想这些重复行，你可以使用 -u 选项（unique）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(base) [zhouziwen@ny 20210107]$ bedtools intersect -a ranges-qry.bed -b ranges-sbj.bed -wa</span><br><span class="line">chr1    0       15      a</span><br><span class="line">chr1    0       15      a</span><br><span class="line">chr1    25      29      b</span><br><span class="line">chr1    18      18      c</span><br><span class="line">chr1    10      14      d</span><br><span class="line">chr1    20      23      e</span><br></pre></td></tr></table></figure>
<p>类似地，还有 -wb 选项，这条命令会在 -wa 的基础上显示第二个文件重叠的序列。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(base) [zhouziwen@ny 20210107]$ bedtools intersect -a ranges-qry.bed -b ranges-sbj.bed -wb</span><br><span class="line">chr1    0       4       a       chr1    0       4       x</span><br><span class="line">chr1    9       15      a       chr1    9       15      z</span><br><span class="line">chr1    25      28      b       chr1    18      28      y</span><br><span class="line">chr1    18      18      c       chr1    18      28      y</span><br><span class="line">chr1    10      14      d       chr1    9       15      z</span><br><span class="line">chr1    20      23      e       chr1    18      28      y</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对两个大的文件进行 intersect 操作可能会占用很多内存。<strong>对于大文件，先对两个文件按照染色体和物理位置排序，再计算intersect，效率会更高</strong>。<code>bedtools intersect</code> 可以添加一个 --sorted 选项来处理排序好的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bedtools intersect -a query-sorted.bed -b subject-sorted.bed --sorted</span><br></pre></td></tr></table></figure>
<p>bedtools intersect 还有其他的功能，例如通过 -wo 选项返回 重叠的bases 数目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(base) [zhouziwen@ny 20210107]$ bedtools intersect -a ranges-qry.bed -b ranges-sbj.bed -wo</span><br><span class="line">chr1    0       15      a       chr1    0       4       x       4</span><br><span class="line">chr1    0       15      a       chr1    9       15      z       6</span><br><span class="line">chr1    25      29      b       chr1    18      28      y       3</span><br><span class="line">chr1    18      18      c       chr1    18      28      y       0</span><br><span class="line">chr1    10      14      d       chr1    9       15      z       4</span><br><span class="line">chr1    20      23      e       chr1    18      28      y       3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>类似于 grep 的 -v 选项，bedtools intersect 也有一个 -v 选项，这会返回所有的非重叠的片段。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(base) [zhouziwen@ny 20210107]$ bedtools intersect -a ranges-qry.bed -b ranges-sbj.bed -v</span><br><span class="line">chr1    6       7       f</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们用到的数据没有包含 strand 信息，但是真实数据是要考虑 strand 信息的。bedtools intersect 默认不考虑 strand 信息，因此如果你想要只看同一个 strand 的 intersects ，你可以通过 -s 选项指定</p>
<h3 id="9-3-2-BEDTools-Slop-and-Flank">9.3.2 BEDTools Slop and Flank</h3>
<p>bedtools slop 通过 -i 选项指定输入 range file，除此之外，还需要提供一个tab分隔的genome file，说明每条染色体的长度（bedtools 用于确保 ranges 不会超出染色体的长度范围）。</p>
<p>实际项目中，我们可以通过 bioawk 生成</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bioawk -c fastx &#x27;&#123;print $name&quot;\t&quot;length($seq)&#125;&#x27; your_genome.fastq &gt; genome.txt</span><br></pre></td></tr></table></figure>
<p>但是在这里，我们用 echo 创建一个假的 genome.txt。</p>
<p>从下面的结果来看，相比于原来的数据，<code>-b 4</code> 表示每个起始位置和终止位置均拓展了4个bp（起始位置-4；终止位置+4；如果超出染色体范围则采用染色体的极值，就像 a 的起始位置还是0）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -e <span class="string">&quot;chr1\t100&quot;</span> &gt; genome.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bedtools slop -i ranges-qry.bed -g genome.txt -b 4</span></span><br><span class="line">chr1    0       19      a</span><br><span class="line">chr1    21      33      b</span><br><span class="line">chr1    14      22      c</span><br><span class="line">chr1    6       18      d</span><br><span class="line">chr1    16      27      e</span><br><span class="line">chr1    2       11      f</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你也可以具体地指定左边界（-l）和右边界（-r）扩展的bp数目。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">$ bedtools slop -i ranges-qry.bed -g genome.txt -l <span class="number">3</span> -r <span class="number">5</span></span><br><span class="line">chr1    <span class="number">0</span>       <span class="number">20</span>      a</span><br><span class="line">chr1    <span class="number">22</span>      <span class="number">34</span>      b</span><br><span class="line">chr1    <span class="number">15</span>      <span class="number">23</span>      <span class="built_in">c</span></span><br><span class="line">chr1    <span class="number">7</span>       <span class="number">19</span>      d</span><br><span class="line">chr1    <span class="number">17</span>      <span class="number">28</span>      e</span><br><span class="line">chr1    <span class="number">3</span>       <span class="number">12</span>      f</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>bedtools flank 命令可以用于提取 promoter sequences。flank 命令也需要一个 genome file。让我们用 bedtools flank 来提取基因的一些promoter regions。我们用 Mus_musculus.GRCm38.75_chr1.gtf.gz 文件。</p>
<p>但是，这个文件里包括了所有种类的 features ： exons, transcripts, CDS, noncoding regions 等等。如果我们只想看编码蛋白质的基因的启动子，我们可以用uniq命令提取这些区域：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bioawk -cgff &#x27;&#123;if ($feature == &quot;gene&quot;) print $0&#125;&#x27; Mus_musculus.GRCm38.75_chr1.gtf.gz | grep &#x27;gene_biotype &quot;protein_coding&quot;;&#x27; &gt; mm_GRCm38.75_protein_coding_genes.gtf</span><br></pre></td></tr></table></figure>
<p>现在，我们可以用这些编码蛋白质的 gene feature 和 genome file ，来提取每个range 前面 3Kbp 的区域。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bedtools flank -i mm_GRCm38.75_protein_coding_genes.gtf -g Mus_musculus.GRCm38_genome.txt  -l 3000 -r 0 &gt; mm_GRCm38_3kb_promoters.gtf</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cut -f1,4,5,7 mm_GRCm38.75_protein_coding_genes.gtf | head -n 3</span></span><br><span class="line">1       3205901 3671498 -</span><br><span class="line">1       4343507 4360314 -</span><br><span class="line">1       4490928 4496413 -</span><br><span class="line"><span class="meta">$</span><span class="bash"> cut -f1,4,5,7 mm_GRCm38_3kb_promoters.gtf | head -n 3</span></span><br><span class="line">1       3202901 3205900 -</span><br><span class="line">1       4340507 4343506 -</span><br><span class="line">1       4487928 4490927 -</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，上述操作成立建立在 strand 都是 - 号的前提。</p>
<p>我们可以通过 bedtools getfasta 来提取给定 range set 的 sequence 信息。比如，我们可以提取上面得到的promoter ranges 的序列信息。</p>
<p>由于整个基因组的序列信息太大了，我们这里只使用 1号染色体的序列信息，首先需要先解压</p>
<ul>
<li>-fi : 总的序列文件</li>
<li>-bed :  输入的 bed 文件（range 信息）</li>
<li>-fo : 输出的序列文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gunzip Mus_musculus.GRCm38.75.dna_rm.toplevel_chr1.fa.gz</span><br><span class="line">bedtools getfasta -fi Mus_musculus.GRCm38.75.dna_rm.toplevel_chr1.fa -bed mm_GRCm38_3kb_promoters.gtf -fo mm_GRCm38_3kb_promoters.fasta</span><br></pre></td></tr></table></figure>
<h3 id="9-3-3-Coverage-with-BEDTools">9.3.3 Coverage with BEDTools</h3>
<p>bedtools genomecov 根据染色体统计 features 的 coverage。默认情况下，它会将每个染色体的coverage情况生成直方图。举例而言。</p>
<p>最终结果中，第二列是测序深度，第三列是在这个测序深度的碱基有多少个，第四列四整个染色体的碱基数目，最后一列为比例。比如第一行显示在1号染色体共有23%的位点没有覆盖到。</p>
<p>最后的 genome 行是整个基因组的统计信息。</p>
<p>这个命令要求<strong>使用的 bed 文件需要按照染色体的顺序排序</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat ranges-cov.bed</span></span><br><span class="line">chr1    4       9</span><br><span class="line">chr1    1       6</span><br><span class="line">chr1    8       19</span><br><span class="line">chr1    25      30</span><br><span class="line">chr2    0       20</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat cov.txt</span></span><br><span class="line">chr1    30</span><br><span class="line">chr2    20</span><br><span class="line"><span class="meta">$</span><span class="bash"> bedtools genomecov -i ranges-cov.bed -g cov.txt</span></span><br><span class="line">chr1    0       7       30      0.233333</span><br><span class="line">chr1    1       20      30      0.666667</span><br><span class="line">chr1    2       3       30      0.1</span><br><span class="line">chr2    1       20      20      1</span><br><span class="line">genome  0       7       50      0.14</span><br><span class="line">genome  1       40      50      0.8</span><br><span class="line">genome  2       3       50      0.06</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 bedtools genomecov ，也可以得到每个碱基的 coverage</p>
<p>这里的三列分别是 染色体 - 物理位置 - 这个物理位置的 coverage。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bedtools genomecov -i ranges-cov.bed -g cov.txt -d  | head -n5</span></span><br><span class="line">chr1    1       0</span><br><span class="line">chr1    2       1</span><br><span class="line">chr1    3       1</span><br><span class="line">chr1    4       1</span><br><span class="line">chr1    5       2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="9-3-4-Other-BEDTools-Subcommands-and-pybedtools">9.3.4 Other BEDTools Subcommands and pybedtools</h3>
<p>其他有用的命令</p>
<h1>10 Working with Sequence Data</h1>
<h2 id="10-1-The-FASTA-Format">10.1 The FASTA Format</h2>
<p>FASTA 可以存储任何的序列数据，比如参考基因组文件，蛋白质序列，coding DNA sequence (CDS) , 转录序列等。</p>
<p>FASTA 文件的每条记录包含两个部分：一个是描述部分（&gt; 开始，包含序列名称和其他信息），一个是序列数据部分（第二行直至到描述行，<strong>可占据多行</strong>）。</p>
<p>FASTA 文件的灵活性导致它的结构定义很宽泛，结构不严谨，运行程序可能会遭遇未知的错误。</p>
<p>因此，作者建议用什么   FASTA/FASTQ  parsing libraries，而不是直接用你自己的文件，因为上面的那个库里的文件是已经经过审查的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ head -10  egfr_flank.fasta</span><br><span class="line">&gt;ENSMUSG00000020122|ENSMUST00000138518</span><br><span class="line">CCCTCCTATCATGCTGTCAGTGTATCTCTAAATAGCACTCTCAACCCCCGTGAACTTGGT</span><br><span class="line">TATTAAAAACATGCCCAAAGTCTGGGAGCCAGGGCTGCAGGGAAATACCACAGCCTCAGT</span><br><span class="line">TCATCAAAACAGTTCATTGCCCAAAATGTTCTCAGCTGCAGCTTTCATGAGGTAACTCCA</span><br><span class="line">GGGCCCACCTGTTCTCTGGT</span><br><span class="line">&gt;ENSMUSG00000020122|ENSMUST00000125984</span><br><span class="line">GAGTCAGGTTGAAGCTGCCCTGAACACTACAGAGAAGAGAGGCCTTGGTGTCCTGTTGTC</span><br><span class="line">TCCAGAACCCCAATATGTCTTGTGAAGGGCACACAACCCCTCAAAGGGGTGTCACTTCTT</span><br><span class="line">CTGATCACTTTTGTTACTGTTTACTAACTGATCCTATGAATCACTGTGTCTTCTCAGAGG</span><br><span class="line">CCGTGAACCACGTCTGCAAT</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>困扰 FASTA 格式文件的最大的问题，在于描述行中序列名称的格式没有明确的定义。比如下面这些行是不是表示同一个序列呢？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">ENSMUSG00000020122|ENSMUST00000138518</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ENSMUSG00000020122|ENSMUST00000125984</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ENSMUSG00000020122|ENSMUST00000125984|epidermal growth factor receptor</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ENSMUSG00000020122|ENSMUST00000125984|Egfr</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ENSMUSG00000020122|ENSMUST00000125984|11|ENSFM00410000138465</span></span><br></pre></td></tr></table></figure>
<p>没有一个统计的规范，我们就不能通过<strong>精确匹配</strong>能确认一个FASTA存不存在某个序列。事实上，我们只能是进行<strong>模糊匹配</strong>。这就让情况变得复杂了：我们的匹配规则的严格程度怎么控制？可不可能匹配到错误的序列？基本上说，模糊匹配是一种很脆弱的策略。</p>
<p>事实上，存在一个更简单的解决办法，就是确保数据是严格符合规范的。如果是拿到了陌生的数据，需要进行数据规范检验，来确保这个数据是否符合要求。这个检验规则不用太复杂，比如检验是否有重复名称，检查&gt; 和序列名称之间是否存在空格等。</p>
<p>如果你需要整理外来的数据，记得<strong>一定要备份原始数据</strong>。</p>
<p>一个命名惯例是将描述行通过一个空格分开两部分：序列名和其他描述。举例如下，序列名称是gene_00284728， 然后 length=231;type=dna 是其他描述部分。</p>
<p>在这种命名规则下，查找特定的序列是很轻松的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">gene_00284728 length=231;<span class="built_in">type</span>=dna</span></span><br><span class="line">GAGAACTGATTCTGTTACCGCAGGGCATTCGGATGTGCTAAGGTAGTAATCCATTATAAGTAACATGCGCGGAATATCCGGAGGTCATAGTCGTAATGCATAATTATTCC</span><br><span class="line">CTCCCTCAGAAGGACTCCCTTGCGAGACGCCAATACCAAAGACTTTCGTAGCTGGAACGATTGGACGGCCCAACCGGGGGGAGTCGGCTATACGTCTGATTGCTACGCCT</span><br><span class="line">GGACTTCTCTT</span><br></pre></td></tr></table></figure>
<h2 id="10-2-The-FASTQ-Format">10.2 The FASTQ Format</h2>
<p>FASTQ 格式是对 FASTA 格式的拓展，对于序列的每个碱基添加了一个 quality score。FASTQ 广泛应用于 <strong>高通量测序数据</strong>，通过显示每个碱基的quality score 来表示每个碱基 call 的置信度。不像 FASTA，FASTQ 有各种变体和陷阱。</p>
<p>FASTQ 格式如下：</p>
<p>第一行是描述行，以@开头，包括序列码名和其他信息</p>
<p>之后是序列数据，可以是一行或多行</p>
<p>以 + 开头的行，表示序列的末尾。在老的 FASTQ文件，这一行后面通常会重复一遍描述行，这造成了不必要的冗余。</p>
<p>第四行是 quality data，可以占据一行或多行，但是必须和序列长度一致。它的quality score 是通过一种特殊的方式显示为字母。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@DJB775P1:248:D0MDGACXX:7:1202:12362:49613</span><br><span class="line">TGCTTACTCTGCGTTGATACCACTGCTTAGATCGGAAGAGCACACGTCTGAA </span><br><span class="line">+ </span><br><span class="line">JJJJJIIJJJJJJHIHHHGHFFFFFFCEEEEEDBD?DDDDDDBDDDABDDCA </span><br><span class="line">@DJB775P1:248:D0MDGACXX:7:1202:12782:49716</span><br><span class="line">CTCTGCGTTGATACCACTGCTTACTCTGCGTTGATACCACTGCTTAGATCGG</span><br><span class="line">+</span><br><span class="line">IIIIIIIIIIIIIIIHHHHHHFFFFFFEECCCCBCECCCCCCCCCCCCCCCC</span><br></pre></td></tr></table></figure>
<p>类似于FASTA，FASTQ的一个惯例是通过第一个空格分为两部分，序列名和其他描述部分。</p>
<p>FASTQ 文件很难正确解析，一个通常的陷阱是将以@开头的行视为一个描述行。然而，@也是一个有效的 quality character。但是，我们可以通过序列行和质量行长度相等来解析数据。</p>
<h3 id="查询-FASTA-FASTQ-记录数">查询 FASTA/FASTQ 记录数</h3>
<p>查看 FASTA 记录数比较简单</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -c &quot;^&gt;&quot; egfr_flank.fasta</span><br></pre></td></tr></table></figure>
<p>我们一开始想到一个同样简单的办法来查找 FASTQ 文件，如下，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">  grep -c <span class="string">&quot;^@&quot;</span> untreated1_chr4.fq</span></span><br><span class="line">208779</span><br></pre></td></tr></table></figure>
<p>但是，细看这个文件结构，我们发现它都是4行一个记录，通过查找文件行数，再除以4，应该是204355 个记录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wc -l untreated1_chr4.fq</span></span><br><span class="line">817420 untreated1_chr4.fq</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; <span class="number">817420</span>/<span class="number">4</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">204355</span></span><br></pre></td></tr></table></figure>
<p>这里就是上面提到的，存在质量行以@开头。可以通过以下命令查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> grep <span class="string">&quot;^@&quot;</span> untreated1_chr4.fq | less</span></span><br><span class="line">@SRR031729.5549475</span><br><span class="line">@SRR031729.10518513</span><br><span class="line">@SRR031729.2324257</span><br><span class="line">@AAB@?A2AA?AAA=???=;A9&gt;:1==3A4=8119=0&gt;1;4A=9,25A11603=;&gt;;411;/0493#########</span><br><span class="line">@SRR031729.7021582</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种情况下，最保险的措施是采用 bioawk</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bioawk -cfastx &#39;END&#123;print NR&#125;&#39; untreated1_chr4.fq</span><br><span class="line">204355</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="10-3-Nucleotide-Codes">10.3 Nucleotide Codes</h2>
<p>The  International  Union  of  Pure  and Applied Chemistry (IUPAC) 设定的碱基编码规则如下</p>
<p><img src="41.png" alt="41"></p>
<p><img src="42.png" alt="41"></p>
<h2 id="10-4-Base-Qualities">10.4 Base Qualities</h2>
<p>quality 编码为 ASCII 字符。 ASCII 码用0-127来表示，但是并不是所有的 ASCII 字符都是可以打印的字符。quality score 只使用可打印的ASCII 字符，从33到126.</p>
<p>所有的编程语言都有转化字符和它的ASCII码的函数。比如python，就存在函数 ord() 和 chr() 。我们试一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>qual = <span class="string">&quot;JJJJJJJJJJJJGJJJJJIIJJJJJIGJJJJJIJJJJJJJIJIJJJJHHHHHFFFDFCCC&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="built_in">ord</span>(b) <span class="keyword">for</span> b <span class="keyword">in</span> qual]</span><br><span class="line">[<span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">71</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">73</span>, <span class="number">73</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">73</span>, <span class="number">71</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">73</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">73</span>, <span class="number">74</span>, <span class="number">73</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">74</span>, <span class="number">72</span>, <span class="number">72</span>, <span class="number">72</span>, <span class="number">72</span>, <span class="number">72</span>, <span class="number">70</span>, <span class="number">70</span>, <span class="number">70</span>, <span class="number">68</span>, <span class="number">70</span>, <span class="number">67</span>, <span class="number">67</span>, <span class="number">67</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>很不幸的是，如果相把表示quality 的字符重新转化为有含义的 quality scores ，这是非常困难的。因为这里存在三种不同的quality schemes: sanger, solexa, illumina 。见下图，但是现在好像都统一成了 sanger scheme。</p>
<p><img src="43.png" alt="41"></p>
<p>这里只看 sanger scheme，首先我们需要从质量的字符对应的ASCII码 减去一个 offset (33)，得到了一个 PHRED quality score。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>phred = [<span class="built_in">ord</span>(b)-<span class="number">33</span> <span class="keyword">for</span> b <span class="keyword">in</span> qual]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>phred</span><br><span class="line">[<span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">38</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">40</span>, <span class="number">38</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">41</span>, <span class="number">39</span>, <span class="number">39</span>, <span class="number">39</span>, <span class="number">39</span>, <span class="number">39</span>, <span class="number">37</span>, <span class="number">37</span>, <span class="number">37</span>, <span class="number">35</span>, <span class="number">37</span>, <span class="number">34</span>, <span class="number">34</span>, <span class="number">34</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之后我们可以根据下面这个式子，见quality score 转化为这个碱基 call 的估计准确性</p>
<p>（疑问：如果是这个公式，Q越大，P越小。如果 P代表准确性，那么就是说quality score 数值越小，准确性越高。但好像从后面的表述看，不是这样，quality score 数值是越大越好）</p>
<p><a href="https://www.jianshu.com/p/1726696e54e5">https://www.jianshu.com/p/1726696e54e5</a></p>
<p>（解答：根据上面的内容，这个P值指<strong>检测错误的概率</strong>，所以 <strong>quality score 越大越好</strong>）</p>
<p><img src="44.png" alt="41"></p>
<p>根据这个公式计算出碱基call的估计准确性（这个结果和pdf不一样）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">10</span>**(-q/<span class="number">10</span>) <span class="keyword">for</span> q <span class="keyword">in</span> phred]</span><br><span class="line">[<span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">0.00015848931924611142</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">0.0001</span>, <span class="number">0.0001</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">0.0001</span>, <span class="number">0.00015848931924611142</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">0.0001</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">0.0001</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">0.0001</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">7.943282347242822e-05</span>, <span class="number">0.00012589254117941674</span>, <span class="number">0.00012589254117941674</span>, <span class="number">0.00012589254117941674</span>, <span class="number">0.00012589254117941674</span>, <span class="number">0.00012589254117941674</span>, <span class="number">0.00019952623149688788</span>, <span class="number">0.00019952623149688788</span>, <span class="number">0.00019952623149688788</span>, <span class="number">0.00031622776601683794</span>, <span class="number">0.00019952623149688788</span>, <span class="number">0.00039810717055349735</span>, <span class="number">0.00039810717055349735</span>, <span class="number">0.00039810717055349735</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="10-5-Example-Inspecting-and-Trimming-Low-Quality-Bases">10.5 Example: Inspecting and Trimming Low-Quality Bases</h2>
<p>如果你想把所有reads 的quality score 可视化，你可以用 java 软件 FastQC。如果你想用R统计，你可以使用一个 Bioconducter 包 qrqc  。这里用qrqc包举例</p>
<p>之后，我们按照两个软件包来删掉低质量的碱基：sickle 和 seqtk 。</p>
<p>sickle 软件过滤低质量位点的命令为（用conda安装后运行说没找到程序）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sickle se -f untreated1_chr4.fq -t sanger -o untreated1_chr4_sickle.fq</span><br></pre></td></tr></table></figure>
<p>seqtk 的相应命令为（conda安装运行成功）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">seqtk trimfq untreated1_chr4.fq &gt; untreated1_chr4_trimfq.fq</span><br></pre></td></tr></table></figure>
<p>查看行数，发现没有变化。那我猜，这个命令是把每个read中的低质量碱基剔除了，比如说原来是200bp，现在只有160bp。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wc -l untreated1_chr4.fq</span></span><br><span class="line">817420 untreated1_chr4.fq</span><br><span class="line"><span class="meta">$</span><span class="bash"> wc -l untreated1_chr4_trimfq.fq</span></span><br><span class="line">817420 untreated1_chr4_trimfq.fq</span><br></pre></td></tr></table></figure>
<p>使用 qrqc 进行 quality score 的可视化（由于sickle没装好，剔除了它的文件）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(qrqc)</span><br><span class="line">fqfiles &lt;- <span class="built_in">c</span>(none=<span class="string">&quot;untreated1_chr4.fq&quot;</span>, trimfq=<span class="string">&quot;untreated1_chr4_trimfq.fq&quot;</span>)</span><br><span class="line"><span class="comment"># Load each file in, using qrqc&#x27;s readSeqFile</span></span><br><span class="line"><span class="comment"># We only need qualities, so we turn off some of</span></span><br><span class="line"><span class="comment"># readSeqFile&#x27;s other features.</span></span><br><span class="line">seq_info &lt;- lapply(fqfiles, <span class="keyword">function</span>(file) &#123;readSeqFile(file, hash=<span class="literal">FALSE</span>, kmer=<span class="literal">FALSE</span>)&#125;)</span><br><span class="line"><span class="comment"># Extract the qualities as dataframe, and append</span></span><br><span class="line"><span class="comment"># a column of which trimmer (or none) was used. This</span></span><br><span class="line"><span class="comment"># is used in later plots.</span></span><br><span class="line">quals &lt;- mapply(<span class="keyword">function</span>(sfq, name) &#123;</span><br><span class="line">                qs &lt;- getQual(sfq)</span><br><span class="line">                qs$trimmer &lt;- name                </span><br><span class="line">                qs</span><br><span class="line">                &#125;, seq_info, <span class="built_in">names</span>(fqfiles), SIMPLIFY=<span class="literal">FALSE</span>)</span><br><span class="line"><span class="comment"># Combine separate dataframes in a list into single dataframe</span></span><br><span class="line">d &lt;- do.call(rbind, quals)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Visualize qualities</span></span><br><span class="line">library(ggplot2)</span><br><span class="line">p1 &lt;- ggplot(d) + geom_line(aes(x=position, y=mean, linetype=trimmer))</span><br><span class="line">p1 &lt;- p1 + ylab(<span class="string">&quot;mean quality (sanger)&quot;</span>) + theme_bw()</span><br><span class="line">ggsave(<span class="string">&quot;mean_quality.png&quot;</span>,plot=p1)</span><br><span class="line"><span class="comment"># Use qrqc&#x27;s qualPlot with list produces panel plots</span></span><br><span class="line"><span class="comment"># Only shows 10% to 90% quantiles and lowess curve</span></span><br><span class="line">p2 &lt;- qualPlot(seq_info, quartile.color=<span class="literal">NULL</span>, mean.color=<span class="literal">NULL</span>) + theme_bw()</span><br><span class="line">p2 &lt;- p2 + scale_y_continuous(<span class="string">&quot;quality (sanger)&quot;</span>)</span><br><span class="line">ggsave(<span class="string">&quot;quality.png&quot;</span>,plot=p2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每个位置的平均quality score</p>
<p><img src="mean_quality.png" alt="mean_quality"></p>
<p>每个位点的quality score 的分布（上下限为90%和10%分位点）。从这里还可以看到，一条read上的位点的测序质量随着长度的延申而下降。</p>
<p><img src="quality.png" alt="quality"></p>
<p>清楚低质量位点并不难，一行命令解决。但是<strong>更重要的步骤是对数据清洗前后使用可视化进行对比</strong>，来检查这些软件如何作用于我们的数据，而不是单纯地相应软件。（<strong>黄金守则：不要相信你的工具</strong>）。</p>
<p>一个谨慎的生信操作流程应该是这样的：运行一个程序，比对原始数据，运行一个程序，比对原始数据，循环往复……</p>
<h2 id="10-6-A-FASTA-FASTQ-Parsing-Example-Counting-Nucleotides">10.6 A FASTA/FASTQ Parsing Example: Counting Nucleotides</h2>
<p>你可以自己写一个处理 FASTQ/FASTQ 的流程，这是一个很好的编程训练。但是当处理实际数据时，最好还是用现有的可靠的库。<strong>great programmers know when to reuse code</strong>。有很多开源的包，它们也调试到了尽可能的高效。</p>
<p>这里我们会用 Heng Li 写的 readfq 软件，因为它可以同时处理 FASTA 和 FASTQ 文件。其他可选的软件由 Biopython 和 BioPerl。</p>
<p>我们会用到 readfq 的 python 版本 <a href="http://reafq.py">reafq.py</a> 。可以当成一个库文件，使用 <code>from readfq import readfq</code>；或者更方便的是，直接复制到你自己的脚本里（这里举例用第一种，我用第二种）。</p>
<p>（有一个问题是，这个python脚本是用 python2 写的，需要修改，就是print 加上括号）</p>
<p>这个 readfq() 函数用起来很简单，需要一个文件对象（已经用open()打开的），然后数生成 FASTQ/FASTQ 的 entris 直至文件末尾。 每个 FASTQ/FASTA entry 会返回成一个元组（包括entry’s description, sequence, quality）。如果 readfq 是读取一个 FASTA 文件，那么 quality line 会是 None。</p>
<p>如果你仔细看 readfq() 的代码，你会发现存在 yield 部分。这说明 readfq() 是一个 generator function 。</p>
<p>让我们写一个简单的程序，来计算一个文件的碱基数目。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># nuccount.py -- tally nucleotides in a file</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="comment">#Counter函数是字典的子类，可以计数可哈希对象。</span></span><br><span class="line"><span class="comment">#它是一个集合，元素像字典键(key)一样存储，它们的计数存储为值。计数可以是任何整数值，包括0和负数。</span></span><br><span class="line"><span class="keyword">from</span> readfq <span class="keyword">import</span> readfq</span><br><span class="line"></span><br><span class="line"><span class="comment">#IUPAC固定的碱基编码</span></span><br><span class="line">IUPAC_BASES = <span class="string">&quot;ACGTRYSWKMBDHVN-.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># intialize counter</span></span><br><span class="line">counts = Counter()</span><br><span class="line"></span><br><span class="line"><span class="comment">#sys.stdin 从标准输入中获取数据，这样可以实用linux的pipeline了</span></span><br><span class="line"><span class="keyword">for</span> name, seq, qual <span class="keyword">in</span> readfq(sys.stdin):</span><br><span class="line">    <span class="comment"># for each sequence entry, add all its bases to the counter</span></span><br><span class="line">    counts.update(seq.upper())</span><br><span class="line"></span><br><span class="line"><span class="comment"># print the results</span></span><br><span class="line"><span class="keyword">for</span> base <span class="keyword">in</span> IUPAC_BASES:</span><br><span class="line">    <span class="built_in">print</span>(base + <span class="string">&quot;\t&quot;</span> + <span class="built_in">str</span>(counts[base]))</span><br></pre></td></tr></table></figure>
<p>运行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat contam.fastq | python nuccount.py</span></span><br><span class="line">A       103</span><br><span class="line">C       110</span><br><span class="line">G       94</span><br><span class="line">T       109</span><br><span class="line">R       0</span><br><span class="line">Y       0</span><br><span class="line">S       0</span><br><span class="line">W       0</span><br><span class="line">K       0</span><br><span class="line">M       0</span><br><span class="line">B       0</span><br><span class="line">D       0</span><br><span class="line">H       0</span><br><span class="line">V       0</span><br><span class="line">N       0</span><br><span class="line">-       0</span><br><span class="line">.       0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后，作者又赞美了 reuse code</p>
<blockquote>
<p>Reusing software isn’t cheating—it’s how the experts program</p>
</blockquote>
<h3 id="generator-生成器-python">generator 生成器 - python</h3>
<p><a href="https://www.liaoxuefeng.com/wiki/897692888725344/923029685138624">https://www.liaoxuefeng.com/wiki/897692888725344/923029685138624</a></p>
<p>主要应用于大数据：直接读取会占用过多内存，使用 generator 和循环，每次只读取一个元素。</p>
<p>举例，斐波那契数列写成 generator function。函数中用 yield 代替print 即可。每次调用函数的时候，遇到 yield 语句就会返回，再次执行时从上次返回的 yield 语句处继续执行（这里是 a, b = b, a + b）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> fib(<span class="number">6</span>):</span><br><span class="line">	<span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure>
<h3 id="多个元素同时赋值-python">多个元素同时赋值 - python</h3>
<p>最近越来越多地看到这种多个元素同时赋值的代码，比如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = <span class="number">1</span>,<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>确实是可以运行，但是上面这种我觉得没有必要，影响了可读性。</p>
<p>下面这种比较实用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i,j,k <span class="keyword">in</span> a:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i,j,k)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i,j,k <span class="keyword">in</span> a:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i,j,k)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="10-7-Indexed-FASTA-Files">10.7 Indexed FASTA Files</h2>
<p>有时我们需要提取 FASTA 文件地某些子序列，如果只做一次，可以直接遍历FASTA的所有序列，但是这不是一个有效的方式，尤其是对于大文件。比如果我们想提取在8号染色体（23,407,082 to 123,410,742）的序列，这种方式还会和其他染色体的序列进行比对，而且从硬盘中把整个基因组文件读取进来也是非常低效的。</p>
<p>一个通常的计算策略是 <strong>indexing</strong> the file 。 这里为了举例，只用8号染色体的基因组数据。</p>
<p>这里要先解压FASTA文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gunzip Mus_musculus.GRCm38.75.dna.chromosome.8.fa.gz</span><br></pre></td></tr></table></figure>
<p>然后，使用 samtools 软件 index 这个 FASTA 文件，生成文件 Mus_musculus.GRCm38.75.dna.chromosome.8.fa.fai 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">samtools faidx Mus_musculus.GRCm38.75.dna.chromosome.8.fa</span><br></pre></td></tr></table></figure>
<p><strong>提取子序列</strong>的代码为如下，其中 <region> 要是chromosome:start-end 格式。（注意染色体是 chr8 还是 8 格式）。之后屏幕上就会打印出需要提取的序列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">faidx &lt;in.fa&gt; &lt;region&gt;</span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools faidx Mus_musculus.GRCm38.75.dna.chromosome.8.fa 8:123407082-123410744</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">8:123407082-123410744</span></span><br><span class="line">GAGAAAAGCTCCCTTCTTCTCCAGAGTCCCGTCTACCCTGGCTTGGCGAGGGAAAGGAAC</span><br><span class="line">CAGACATATATCAGAGGCAAGTAACCAAGAAGTCTGGAGGTGTTGAGTTTAGGCATGTCT</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>samtools 支持同时提取多个序列。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools faidx Mus_musculus.GRCm38.75.dna.chromosome.8.fa \</span></span><br><span class="line"><span class="bash">8:123407082-123410744 8:123518835-123536649</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">8:123407082-123410744</span></span><br><span class="line">GAGAAAAGCTCCCTTCTTCTCCAGAGTCCCGTCTACCCTGGCTTGGCGAGGGAAAGGAAC</span><br><span class="line">CAGACATATATCAGAGGCAAGTAACCAAGAAGTCTGGAGGTGTTGAGTTTAGGCATGTCT</span><br><span class="line">[...]</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">8:123518835-123536649</span></span><br><span class="line">TCTCGCGAGGATTTGAGAACCAGCACGGGATCTAGTCGGAGTTGCCAGGAGACCGCGCAG</span><br><span class="line">CCTCCTCTGACCAGCGCCCATCCCGGATTAGTGGAAGTGCTGGACTGCTGGCACCATGGT</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<h3 id="为什么index使得检索更快">为什么index使得检索更快</h3>
<p>首先，之前那么做速度慢，主要是因为从硬盘中读写数据非常耗时。</p>
<p>通过 index ，我们记录下来了每个序列在文件开始的地方。这样检索的时候，就不用读取整个文件，而是直接跳到我们想要的序列的位置。</p>
<p>说白了，这就是像是做了一本书的目录一样，想找东西，看目录，然后跳到指定的页码。</p>
<h1>11 Working with Alignment Data</h1>
<p>the Sequence Alignment Mapping (SAM) 格式 （二进制格式为BAM）。</p>
<blockquote>
<p>The  SAM and BAM formats are the standard formats for storing sequencing reads mapped to a reference.</p>
</blockquote>
<h2 id="11-1-Getting-to-Know-Alignment-Formats-SAM-and-BAM">11.1 Getting to Know Alignment Formats: SAM and BAM</h2>
<h3 id="11-1-1-The-SAM-Header">11.1.1 The SAM Header</h3>
<p><img src="45.png" alt="45"></p>
<p>表头以 @ 符号开始，后面跟着两个字符。再后面就是tab分隔的 key-value pairs （KEY:VALUE）。</p>
<ul>
<li>
<p>@SQ 行存储着参考基因组序列的信息。必需的键值对为 SN， 存储着 sequence name （比如 染色体 1）；还有 LN，存储序列长度。参考基因组的所有分开的序列都会占据一行。</p>
</li>
<li>
<p>@RG 包含重要的 read group 和 sample metadata。(没看懂)</p>
<blockquote>
<p>This ID value contains information about the origin of a set of reads.<br>
Some software relies on read groups toindicate  a  technical  groups<br>
of  reads,  to  account  for  batch  effects  (undesirabletechnical artifacts  in  data).  Consequently, it’s  beneficial  to  create  read  groupsrelated to the specific sequencing run  (e.g., ID could be related to the name of thesequencing run and lane)</p>
</blockquote>
<p>样本信息存放在 SM 字段中（(e.g.,  individual,  treatment  group,  replicate,  etc.）</p>
<p>可能地话，还会有检测平台 PL (platform) ，比如 ILLUMINA, PACBIO,。</p>
</li>
<li>
<p>@PG 包含创建和处理 SAM/BAM 文件使用的软件。 软件版本（VN），命令行（CL）。</p>
</li>
</ul>
<p>但是标准的处理 SAM/BAM 文件是通过 SAMtools 命令行。</p>
<p>查看 headline 使用以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools view -H celegans.sam</span></span><br><span class="line">@SQ     SN:I    LN:15072434</span><br><span class="line">@SQ     SN:II   LN:15279421</span><br><span class="line">@SQ     SN:III  LN:13783801</span><br><span class="line">@SQ     SN:IV   LN:17493829</span><br><span class="line">@SQ     SN:MtDNA        LN:13794</span><br><span class="line">@SQ     SN:V    LN:20924180</span><br><span class="line">@SQ     SN:X    LN:17718942</span><br><span class="line">@RG     ID:VB00023_L001 SM:celegans-01</span><br><span class="line">@PG     ID:bwa  PN:bwa  VN:0.7.10-r789  CL:bwa mem -R @RG\tID:VB00023_L001\tSM:celegans-01 Caenorhabditis_elegans.WBcel235.dna.toplevel.fa celegans-1.fq celegans-2.fq</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同样可以用于 BAM 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools view -H celegans.bam</span></span><br><span class="line">@SQ     SN:I    LN:15072434</span><br><span class="line">@SQ     SN:II   LN:15279421</span><br><span class="line">@SQ     SN:III  LN:13783801</span><br><span class="line">@SQ     SN:IV   LN:17493829</span><br><span class="line">@SQ     SN:MtDNA        LN:13794</span><br><span class="line">@SQ     SN:V    LN:20924180</span><br><span class="line">@SQ     SN:X    LN:17718942</span><br><span class="line">@RG     ID:VB00023_L001 SM:celegans-01</span><br><span class="line">@PG     ID:bwa  PN:bwa  VN:0.7.10-r789  CL:bwa mem -R @RG\tID:VB00023_L001\tSM:celegans-01 Caenorhabditis_elegans.WBcel235.dna.toplevel.fa celegans-1.fq celegans-2.fq</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果不加 -H 选项，默认返回没有标题的数据部分</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools view celegans.sam | head -n 1</span></span><br><span class="line">I_2011868_2012306_0:0:0_0:0:0_2489      83      I       2012257 40      50M     =       2011868 -439    CAAAAAATTTTGAAAAAAAAAATTGAATAAAAATTCACGGATTTCTGGCT       22222222222222222222222222222222222222222222222222      NM:i:0  MD:Z:50 AS:i:50 XS:i:50  RG:Z:VB00023_L001       XA:Z:I,-2021713,50M,0;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="SAM-更多资料">SAM 更多资料</h4>
<p><a href="http://samtools.github.io/hts-specs/">http://samtools.github.io/hts-specs/</a></p>
<h3 id="11-1-2-The-SAM-Alignment-Section">11.1.2 The SAM Alignment Section</h3>
<p><img src="46.png" alt="45"></p>
<ol>
<li>
<p>QNAME， the query name (e.g., a sequence read’s name)</p>
</li>
<li>
<p>FLAG, the  bitwise  flag,  which  contains  information  about  the  alignment.  (?)</p>
</li>
<li>
<p>RNAME,  the  reference  name  (比如 “chr1&quot;)</p>
</li>
<li>
<p>POS, 参考序列中第一个与 query sequence 匹配上的碱基位置（1-based indexing）.如果没有比对上，这个数值会是0。</p>
</li>
<li>
<p>MAPQ 是 mapping quality ，衡量 read 确实是起源于它比对上的位置的可能性。这个是由软件估计得到。很多软件会自动过滤掉 mapping quality 很低的 read。</p>
</li>
<li>
<p>CIGAR : 描述 alignment 的特殊格式（matching bases,  insertions/deletions, clipping）</p>
</li>
<li>
<p>RNEXT （reference name, * 表示未知， = 表示和 RNAME 相同） and  PNEXT  (下一行，position，未知是0)</p>
</li>
<li>
<p>TLEN 是 <code>template length for paired-end reads</code></p>
</li>
<li>
<p>SEQ 是原始的 read 序列。</p>
<blockquote>
<p>This sequence will always be in the orienta‐tion  it  aligned  in  (and  this  may  be  the  reverse  complement  of  the  original  readsequence). Thus, if your read aligned to the reverse strand (which is informationkept in the bitwise flag field), this sequence will be the reverse complement.</p>
</blockquote>
</li>
<li>
<p>QUAL 存储原始的  quality</p>
</li>
</ol>
<h3 id="11-1-3-Bitwise-Flags">11.1.3 Bitwise Flags</h3>
<p>通过 <code>samtools flags</code> 查看所有可用的 flags</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools flags</span></span><br><span class="line"></span><br><span class="line">About: Convert between textual and numeric flag representation</span><br><span class="line">Usage: samtools flags INT|STR[,...]</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">        0x1     PAIRED        .. paired-end (or multiple-segment) sequencing technology</span><br><span class="line">        0x2     PROPER_PAIR   .. each segment properly aligned according to the aligner</span><br><span class="line">        0x4     UNMAP         .. segment unmapped</span><br><span class="line">        0x8     MUNMAP        .. next segment in the template unmapped</span><br><span class="line">        0x10    REVERSE       .. SEQ is reverse complemented</span><br><span class="line">        0x20    MREVERSE      .. SEQ of the next segment in the template is reversed</span><br><span class="line">        0x40    READ1         .. the first segment in the template</span><br><span class="line">        0x80    READ2         .. the last segment in the template</span><br><span class="line">        0x100   SECONDARY     .. secondary alignment</span><br><span class="line">        0x200   QCFAIL        .. not passing quality controls</span><br><span class="line">        0x400   DUP           .. PCR or optical duplicate</span><br><span class="line">        0x800   SUPPLEMENTARY .. supplementary alignment</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里设计到二进制，十进制和十六进制的转化。</p>
<p>比如你遇到了一个 bitflag 是147 （转化位十六进制是 93），第一步先转化为二进制，是 1001 0011 ，其中是1的位数是第一、第二、第五和第八位（位数是从右往左数）。参照上面的 flags 的顺序，分别对应着 0x1 0x2 0x10 和 0x80 。</p>
<p>你可以直接通过 samtools 完成上述的对应过程，既可以用十进制，也可以用十六进制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools flags 147</span></span><br><span class="line">0x93    147     PAIRED,PROPER_PAIR,REVERSE,READ2</span><br><span class="line"><span class="meta">$</span><span class="bash"> samtools flags 0x93</span></span><br><span class="line">0x93    147     PAIRED,PROPER_PAIR,REVERSE,READ2</span><br></pre></td></tr></table></figure>
<p>也可以反过来</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools flags paired,read1,qcfail</span></span><br><span class="line">0x241   577     PAIRED,READ1,QCFAIL</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="11-1-4-CIGAR-Strings">11.1.4 CIGAR Strings</h3>
<p>类似于 bitwise flags， CIGAR 字段也有一种特殊的方式来编码信息。CIGAR 存储着关于比对文件中的哪些碱基是Matches/misMatches, insertions, deletions, soft or hard clipped。</p>
<p>soft clipping 是指当只有一部分 query sequence 比对上了参考序列，其他部分无法比对上。这种情况发生在当匹配一个 read 与一个位置时，要么头部要么尾部无法匹配上。hard clipping 类似，但是hard-clipped 区域不会出现 SEQ 字段的序列中。</p>
<p>一个基本的 CIGAR 字段包含合并的整数和字符。比如一个51个碱基的read完全匹配上 了，没有插入和缺失，会有一个 CIGAR 字段包含一个单独的 length/operation pair : <strong>51M</strong>。注意，这里M 表示能配对上，而不是说所有的碱基和参考基因组是一样的。</p>
<p><img src="47.png" alt="45"></p>
<p><img src="48.png" alt="45"></p>
<p>让我们看一个复杂一点的例子：<strong>43S6M1I26M</strong>。首先我们把它分解成 43S, 6M, 1I, 26M ，利用上面的表格，这是说 开始的43个碱基 是 soft-clipped， 之后的6个碱基是 matched， 然后是 1 个插入，最后是26 个碱基 match。</p>
<p>注意，这些数字加起来必需等于 read sequence 的长度。</p>
<h3 id="11-1-5-Mapping-Qualities">11.1.5 Mapping Qualities</h3>
<p>比对后的所有下游操作均基于<strong>可靠</strong>的比对结果（ SNP calling and genotyping, RNA-seq）。Mapping qualities 是衡量比对的可靠性的指标。类似于 base quality ， mapping quality 也是一个log probability ，见下式，其中 P 是<strong>错误比对的概率</strong>。</p>
<p><img src="49.png" alt="45"></p>
<p>比对质量和另一个概念也是相关的，比对唯一性（mapping uniqueness）。这通常定义为 一条read 的第二好的比对结果比第一好的比对结果有更多地的 mismatches。然而，比对唯一性的概念并不能解释 mismatches 的碱基质量，也就是说一个mismatch 究竟是 base calling error 还是 一个真实的变异。</p>
<p>我们可以通过 mapping qualities 来过滤掉可能是错误的比对，找出哪些区域比对结果很差。</p>
<h2 id="11-2-Command-Line-Tools-for-Working-with-Alignments-in-the-SAM-Format">11.2 Command-Line Tools for Working with Alignments in the SAM Format</h2>
<h3 id="11-2-1-Using-samtools-view-to-Convert-between-SAM-and-BAM">11.2.1 Using samtools view to Convert between SAM and BAM</h3>
<p>samtools 的很多子命令都要求输入文件是 BAM 格式。因此我们经常需要在 SAM 和 BAM 两种格式中切换。 samtools view 可以做到这一点。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">samtools view -b celegans.sam &gt; celegans_copy.bam</span><br><span class="line">samtools view celegans.bam &gt; celegans_copy.sam</span><br></pre></td></tr></table></figure>
<p>但是，samtools view 生成的 SAM 文件不会包括 SAM header 。这种格式无法再转化位 BAM 文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools view -b celegans_copy.sam &gt; celegans_copy.bam</span></span><br><span class="line">[E::sam_parse1] missing SAM header</span><br><span class="line">[W::sam_read1] Parse error at line 1</span><br><span class="line">[main_samview] truncated file.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以通过 添加 -h 来保留表头。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">samtools view -h celegans.bam &gt; celegans_copy.sam</span><br><span class="line">samtools view -b celegans_copy.sam &gt; celegans_copy.bam #now we can convert back</span><br></pre></td></tr></table></figure>
<p>通常来说，我们将 BAM 转化为 SAM，一般仅仅是为了看一下数据。一般情况下，使用 BAM 格式更好，因为更节省空间，符合 samtools 输入文件要求，处理速度也更快。</p>
<h4 id="The-CRAM-Format">The CRAM Format</h4>
<p>samtools 现在支持一个新的，高度压缩的文件格式， CRAM，相比于 BAM 文件能够进一步压缩10%-30%的空间。CRAM 是一种 reference-based 压缩系统，即只有当aligned sequence 和参考基因组序列不同时才会被记录。这大幅度地压缩了文件大小，因为很多的比对序列和参考基因组只有很少的不同。因此对于这种格式而言，<strong>参考序列是必要的，而且不能改变</strong>。由于参考序列对于这种格式特别重要，CRAM 文件还包含了一个参考序列文件的 MD5 校验码。</p>
<h3 id="11-2-2-Samtools-Sort-and-Index">11.2.2 Samtools Sort and Index</h3>
<p>类似于 FASTA 格式， BAM 文件也可以 sort 和 index ，方便查找某个区域的比对的reads。</p>
<p>首先我们可以通过 samtools sort 来进行排序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">samtools sort celegans_unsorted.bam -o celegans_sorted.bam</span><br></pre></td></tr></table></figure>
<p>如果对一个大的文件进行排序计算量会很大，因此 samtools sort 存在选项来让你提高内存和线程数。通常情况下，对于一个很大的 BAM 文件，可能无法完全放进内存中，因此samtools sort 会将文件切分成几个部分，对每个部分进行排序，写入到临时文件中，最后合并所有的临时文件（和我的填充策略一样）。用计算机科学的术语来说，samtools sort 使用了一个 merge sort 。</p>
<p>提高内存，可以减少samtools sort 分割文件的数量，这样速度更快（？）。由于切分文件后，对每个部分进行排序的步骤彼此之间是独立的，因此这一步可以平行处理。我们可以通过 -m 来增加内存( K, M, G)，-@ 来增加线程数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">samtools sort -m 4G -@ 2 celegans_unsorted.bam -o celegans_sorted.bam</span><br></pre></td></tr></table></figure>
<p>很多时候，我们想提取基因组上某个区域的 alignments。这时就需要index（只能针对 sorted BAM文件）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">samtools index celegans_sorted.bam</span><br></pre></td></tr></table></figure>
<p>这个时候就生成了一个新文件，<code>celegans_sorted.bam.bai</code> 。</p>
<h3 id="11-2-3-Extracting-and-Filtering-Alignments-with-samtools-view">11.2.3 Extracting and Filtering Alignments with samtools view</h3>
<p>为了模拟提取部分区域的 alignments ，我们使用了千人基因组的数据的子集。</p>
<p>首先，我们对bam文件进行 index。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools index NA12891_CEU_sample.bam</span></span><br></pre></td></tr></table></figure>
<p>然后，我们看一下位于1号染色体 215,906,469-215,906,652 区域的 alignments</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools view NA12891_CEU_sample.bam 1:215906469-215906652 | head -n 3</span></span><br><span class="line">SRR003212.5855757   147  1  215906433  60  33S43M  =  215906402 [...]</span><br><span class="line">SRR003206.18432241  163  1  215906434  60  43M8S   =  215906468 [...]</span><br><span class="line">SRR014595.5642583   16   1  215906435  37  8S43M   *  0 [...]</span><br></pre></td></tr></table></figure>
<p>也可以写入一个新的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools view -b NA12891_CEU_sample.bam 1:215906469-215906652 &gt;  USH2A_sample_alns.bam</span></span><br></pre></td></tr></table></figure>
<p>如果你有很多区域存放在 BED 文件中，你可以直接通过 -L 选项使用 BED 文件提取区域。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools view -L USH2A_exons.bed NA12891_CEU_sample.bam  | head -n 3</span></span><br></pre></td></tr></table></figure>
<h4 id="Filtering-alignments-with-samtools-view">Filtering alignments with samtools view</h4>
<p>samtools view 也可以根据 bitwise flags, mapping quality, read group 等过滤 alignments。</p>
<p>你可以通过直接输入 <code>samtools view</code> 命令查看说明。</p>
<p>让我们先看如何根据 bitwise flags 过滤。总共有两个选项可用：-f , 只输出具有特定flag 的reads； -F, 相反会输出没有特定flag 的 reads。让我们通过一个例子来说明，我们用  samtools flags 来找出我们需要的 flags。假设你想要输出所有unmapped 的 reads。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools flags unmap</span></span><br><span class="line">0x4     4       UNMAP</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之后我们通过 <code>samtools view -f 4</code> 来输出符合这个flag 的 reads</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools view -f 4 NA12891_CEU_sample.bam | head -n 3</span></span><br><span class="line">SRR003208.1496374       69      1       215623168       0       35M16S  =       215623168    0TTTGTAGGTCCAAAAAAAGAGAGGGANGAAGTGCTCCGTATAATCATAGTA     &gt;@&gt;=&lt;5&lt;;#&gt;&gt;:28-813;$&lt;.;$0/!:%%&lt;%9$3%3.41&quot;#&quot;$0$/&quot;%%#   XC:i:35 RG:Z:SRR003208  OQ:Z:=D@B6-EC#=:.)+&amp;+&#x27;(2$4&amp;4$(&amp;!,%%0%)$&amp;%(*(&#x27;&quot;#&quot;$&amp;$&#x27;&quot;%%#</span><br><span class="line">SRR002141.16953736      181     1       215623191       0       40M11S  =       215623191    0AATATCCACTACACCAACCATAAACTTAATTGTCTCTATTTTTTTTCCTGT     $$7;$%&lt;&lt;$$&gt;%&lt;9?B&gt;:@B;@&lt;??&gt;&lt;???&gt;:4=02@%?;&gt;%?==&lt;)A@,&lt;   XC:i:40 RG:Z:SRR002141  OQ:Z:$$(+$%).$$,%6+II+EII+&lt;,2C.04D51,*&gt;()I%:0:%CI6&lt;&amp;AF&amp;8</span><br><span class="line">SRR002143.2512308       181     1       215623216       0       *       =       215623216    0GTTCACAAATAACAGTATATTTATAACAACCATAAACTTAATTGGCACTAT     +4$&quot;$#&quot;$&quot;$#$#%4041&quot;%244&quot;&lt;1&gt;A::9?=A@8=/&lt;A&gt;6==;24&lt;;?;   RG:Z:SRR002143  OQ:Z:I&amp;$&quot;$#&quot;$&quot;$#$#%&amp;&amp;&amp;&amp;&quot;%&amp;(&#x27;&quot;+&amp;85+4-29&lt;7+B&#x27;5H4,765++&lt;756</span><br></pre></td></tr></table></figure>
<p>我们可以通过 samtools flags 来证实这些reads 都是 unmapped</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools flags 69</span></span><br><span class="line">0x45    69      PAIRED,UNMAP,READ1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们也可以同时指定多个 flag。我们先找到相应的十进制的数字。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools flags READ1,PROPER_PAIR</span></span><br><span class="line">0x42    66      PROPER_PAIR,READ1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之后，再提取符合条件的 reads</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools view -f 66 NA12891_CEU_sample.bam | head -n 3</span></span><br><span class="line">SRR005672.8895  99      1       215622850       60      51M     =       215623041       227  GGAATAAATATAGGAAATGTATAATATATAGGAAATATATATATATAGTAA      ;=&lt;&gt;=&lt;&gt;&lt;9&lt;=&lt;9:&lt;=?&gt;&lt;=&gt;?&gt;@?&gt;&gt;9&gt;&gt;&gt;=&gt;@A@?@?@??7??==:19;   XT:A:U  NM:i:1  SM:i:37 AM:i:37 X0:i:1  X1:i:0  XM:i:1  XO:i:0  XG:i:0  MD:Z:48G2     RG:Z:SRR005672  OQ:Z:IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII?114I</span><br><span class="line">SRR005674.4317449       99      1       215622863       37      51M     =       215622987    175      GAAATGTATAATATATAGGAAATATATATATATAGGAAATATATAATATAT     ;=&gt;&gt;=&lt;;&lt;=&lt;&gt;=:&gt;=:==&lt;&lt;@@?:&gt;?&lt;?;&gt;&gt;&gt;?&gt;;44@@?&gt;?&gt;&gt;&gt;/:&gt;;=9   XT:A:U  NM:i:0  SM:i:37 AM:i:37 X0:i:1  X1:i:0  XM:i:0  XO:i:0  XG:i:0MD:Z:51 RG:Z:SRR005674  OQ:Z:IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII&lt;2+IIIIIIII&amp;GIICI</span><br><span class="line">SRR010927.10846964      83      1       215622892       60      51M     =       215622860    -83      ATATAGAAAATATATAATATATGTTAGGAATATATTAAGGCACCAGCTGTG     9596?$$===&lt;&gt;=&gt;;&gt;?&lt;?;??4?=@34&gt;=&lt;=;??;?@?===:=?=&lt;==@?   XT:A:U  NM:i:1  SM:i:37 AM:i:37 X0:i:1  X1:i:0  XM:i:1  XO:i:0  XG:i:0MD:Z:6G44       RG:Z:SRR010927  OQ:Z:G,I.F$$III=ICI7IICI8II-IEI-/IIIIIIGBIIIIIIIIIIIIIII</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以使用 -F 反向过滤（提取不符合条件的 reads）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools flags UNMAP</span></span><br><span class="line">0x4     4       UNMAP</span><br><span class="line"><span class="meta">$</span><span class="bash"> samtools view -F 4 NA12891_CEU_sample.bam | head -n 3</span></span><br><span class="line">SRR005672.8895  99      1       215622850       60      51M     =       215623041       227  GGAATAAATATAGGAAATGTATAATATATAGGAAATATATATATATAGTAA      ;=&lt;&gt;=&lt;&gt;&lt;9&lt;=&lt;9:&lt;=?&gt;&lt;=&gt;?&gt;@?&gt;&gt;9&gt;&gt;&gt;=&gt;@A@?@?@??7??==:19;   XT:A:U  NM:i:1  SM:i:37 AM:i:37 X0:i:1  X1:i:0  XM:i:1  XO:i:0  XG:i:0  MD:Z:48G2     RG:Z:SRR005672  OQ:Z:IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII?114I</span><br><span class="line">SRR010927.10846964      163     1       215622860       60      35M16S  =       215622892    83       TAGGAAATGTATAATATATAGGAAATATATATATATAGGAAATATATAATA     ;9=;&lt;???&gt;&gt;&lt;@?@@?@?A??==AA@&gt;@?@&gt;@8?69&lt;$2%&lt;::6:395%3,   XC:i:35 XT:A:U  NM:i:0  SM:i:37 AM:i:37 X0:i:1  X1:i:0  XM:i:0  XO:i:0XG:i:0  MD:Z:35 RG:Z:SRR010927  OQ:Z:IEIIIIIIIIEIIGIIIHIIII37:?3&gt;6E/&gt;*&gt;(.-$&#x27;%+*4+4&#x27;3)%,(</span><br><span class="line">SRR005674.4317449       99      1       215622863       37      51M     =       215622987    175      GAAATGTATAATATATAGGAAATATATATATATAGGAAATATATAATATAT     ;=&gt;&gt;=&lt;;&lt;=&lt;&gt;=:&gt;=:==&lt;&lt;@@?:&gt;?&lt;?;&gt;&gt;&gt;?&gt;;44@@?&gt;?&gt;&gt;&gt;/:&gt;;=9   XT:A:U  NM:i:0  SM:i:37 AM:i:37 X0:i:1  X1:i:0  XM:i:0  XO:i:0  XG:i:0MD:Z:51 RG:Z:SRR005674  OQ:Z:IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII&lt;2+IIIIIIII&amp;GIICI</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="SAM-Bitwise-Flags-and-SAM-Fields">SAM Bitwise Flags and SAM Fields</h4>
<p>这段话的意思大概是说不同flag 之间是有优先顺序的，应先满足底层的 flag。比如判断一个 read 是否比对上了，唯一的标准只有 unmapped flag，如果这个flag为真，哪怕其他字段有值，其实都是错的。</p>
<blockquote>
<p>It’s  vital  to  consider  how  some  bitflags  may  affect  other  bitflags(technically speaking, some bitflags are non-orthogonal). Similarly,if some bitflags are set, certain SAM fields may no longer apply.For  example,  0x4  (unmapped)  is  the  only  reliable  way  to  tell  if  analignment is unaligned. In other words, one cannot tell if a read isaligned  by  looking  at  fields  such  as  mapped  position  (POS  and  ref‐erence  RNAME);  the  SAM  format  specification  does  not  limit  thesefields’ values if a read is unaligned. If the 0x4 bit is set (meaning theread  is  unmapped),  the  fields  regarding  alignment  including  posi‐tion,  CIGAR  string,  mapping  quality,  and  reference  name  are  notrelevant and their values cannot be relied upon. Similarly, if the 0x4bit is set, bits that only apply to mapped reads such as 0x2 (properpair), 0x10 (aligned to reverse strand), and others cannot be reliedupon. The primary lesson is you should carefully consider all flagsthat  may  apply  when  working  with  SAM  entries,  and  start  withlow-level attributes (whether it’s aligned, paired). See the SAM for‐mat specification for more detail on bitflags.</p>
</blockquote>
<p>然后 ，<code>we want to make sure the unmapped (0x4) and proper paired bits are unset(so the read is aligned and paired), and the paired end bit is set (so the read is not in aproper pair). We do this by combining bits:</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools flags paired</span></span><br><span class="line">0x1     1       PAIRED</span><br><span class="line"><span class="meta">$</span><span class="bash"> samtools flags unmap,proper_pair</span></span><br><span class="line">0x6     6       PROPER_PAIR,UNMAP</span><br><span class="line"><span class="meta">$</span><span class="bash"> samtools view -F 6 -f 1 NA12891_CEU_sample.bam | head -n 3</span></span><br><span class="line">SRR003208.1496374       137     1       215623168       0       35M16S  =       215623168    0AAATAGTGCCAATTACGTTTATGGTTGTTATAATGATACTGTTTGTTCTTT     ;/,&gt;);5&lt;;&lt;2+?=,%34??.&lt;&lt;97@&lt;#.&quot;5$4%#&quot;#&quot;&quot;2%%%&quot;#%+&quot;$$&quot;   XC:i:35 XT:A:R  NM:i:1  SM:i:0  AM:i:0  X0:i:2  X1:i:0  XM:i:1  XO:i:0  XG:i:0MD:Z:15A19      RG:Z:SRR003208  OQ:Z:7(&#x27;@&amp;?,84I(&amp;42&amp;%0(55&amp;,.3(4-#&amp;&quot;&#x27;$&amp;%#&quot;#&quot;&quot;&amp;%%%&quot;#%&amp;&quot;$$&quot;</span><br><span class="line">ERR002297.5178166       177     1       215623174       0       36M     =       215582813    -40361   TGCCAATTAAGTTTATGGTTGTTATAATGATACTGT    4:*?4,1;?6:/&lt;0?@==@@=@&gt;@&gt;@?@&gt;@&gt;??A&gt;=    XT:A:RNM:i:0  SM:i:0  AM:i:0  X0:i:2  X1:i:0  XM:i:0  XO:i:0  XG:i:0  MD:Z:36 RG:Z:ERR002297  OQ:Z:3&lt;4&lt;74.&lt;&gt;-&lt;6&lt;/&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">SRR002141.16953736      121     1       215623191       0       7S44M   =       215623191    0GTTTATTGTTGTTATAATGATACTGTTGGTGCTGAACACATGTTTACTAAC     &quot;55%50%%::.&lt;9?&lt;@@=&gt;A=&gt;;?4&lt;=&gt;&lt;&gt;=;&gt;.B@&gt;@?C?:==?@=?BA?   XC:i:44 XT:A:R  NM:i:0  SM:i:0  AM:i:0  X0:i:2  X1:i:0  XM:i:0  XO:i:0  XG:i:0MD:Z:44 RG:Z:SRR002141  OQ:Z:&quot;2/%,(%%:7&amp;:EI:II=+IGIID&#x27;II2-I4II&amp;IIIIIII0IIIIIIIII</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一个检查结果的方式是查看函数。<code> In  this  case,  our  total  number  of  readsthat  are  mapped  and  paired  should  be  equal  to  the  sum  of  the  number  of  reads  thatare  mapped,  paired,  and  properly  paired,  and  the  number  of  reads  that  are  mapped,paired, and not properly paired:</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools view -F 6 NA12891_CEU_sample.bam | wc -l  <span class="comment"># total mapped and paired</span></span></span><br><span class="line">233628</span><br><span class="line"><span class="meta">$</span><span class="bash"> samtools view -F 7 NA12891_CEU_sample.bam | wc -l  <span class="comment"># total mapped, paired,</span></span></span><br><span class="line">201101                                               # proper paired</span><br><span class="line"><span class="meta">$</span><span class="bash"> samtools view -F 6 -f 1 NA12891_CEU_sample.bam | wc -l <span class="comment"># total mapped, paired,</span></span></span><br><span class="line">32527                                                    # and not proper paired</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;201101 + 32527&quot;</span> | bc</span></span><br><span class="line">233628</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="11-3-Visualizing-Alignments-with-samtools-tview-and-the-Integrated-Genomics-Viewer">11.3 Visualizing Alignments with samtools tview and the Integrated Genomics Viewer</h2>
<p><code>samtools tview</code> 要求 sorted 和 indexed BAM 文件。<code>samtools tview</code>  也可以导入参考基因组的序列文件。这里<code>NA12891_CEU_sample.bam </code> 文件的参考基因组为 <code> human_g1k_v37.fasta</code>，这个文件太大了，无法放在GitHub 文件夹下，但是下载方式在 <a href="http://README.md">README.md</a> 文件中（这里我没有下）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools tview NA12891_CEU_sample.bam human_g1k_v37.fasta</span></span><br></pre></td></tr></table></figure>
<p>我们也可以选定特定区域</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools tview -p 1:215906469-215906652 NA12891_CEU_sample.bam human_g1k_v37.fasta</span></span><br></pre></td></tr></table></figure>
<p>如果你需要花更多的时间查看 alignments, variants, insertions/deletions ，你可以用 Integrated Genomic Viewer (IGV)，这是一个图形界面的软件。</p>
<p>图片中带有颜色的字母表示 mismatching bases，可能的原因包括分型错误，比对错误，errors in library preparation, 或者是一个 SNP。</p>
<p>比对错误的原因可能是由于序列相似，共源序列。这种类型的比对错误是假阳性的variant call 的主要原因。还有一个可能的原因是 low-complexity sequence ，比如 <code>GGCGGGGGGGCGGGGGGCGGG</code>。这种如果实际是产生了一个 indel 突变，但是软件一般会判定为一个 SNP。</p>
<p><img src="50.png" alt="45"></p>
<h3 id="11-3-1-Pileups-with-samtools-pileup-Variant-Calling-and-Base-Alignment-Quality">11.3.1 Pileups with samtools pileup, Variant Calling, and Base Alignment Quality</h3>
<p>pileup fromat 是之后call SNP的基础，让我们先看一个简单的流程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools mpileup --no-BAQ --region 1:215906528-215906567  --fasta-ref human_g1k_v37.fasta NA12891_CEU_sample.bam</span></span><br></pre></td></tr></table></figure>
<ul>
<li>–no-BAQ : disable  Base Alignment Quality (BAQ)</li>
</ul>
<p>使用 -v 选项生成 VCF 文件，或者使用 -g 选项生成 BCF 文件，这里默认是生成压缩格式的vcf，可以使用 -u 生成未压缩的vcf格式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> samtools mpileup -v --no-BAQ --region 1:215906528-215906567  --fasta-ref human_g1k_v37.fasta NA12891_CEU_sample.bam &gt; NA12891_CEU_sample.vcf.gz</span></span><br></pre></td></tr></table></figure>
<p>通过 <code>bcftools call</code> ，来推断哪些位点是真的变异，然后每个个体的基因型是什么。</p>
<p>-m 选项采用  multiallelic caller； -v  选项只输出 variant sites</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bcftools call -v -m NA12891_CEU_sample.vcf.gz &gt; NA12891_CEU_sample_calls.vcf.gz</span></span><br></pre></td></tr></table></figure>
<p>生成的结果文件如图</p>
<p><img src="51.png" alt="45"></p>
<p>我们可以看到位点 215,906,548 不再显示为一个SNP，这和IGV的可视化结果一致，因为它有20 reference (G)，只有 4 个 C alleles，很难相信它是一个真实的变异。</p>
<p>除此之外，<code>bcftools call</code> 估计了一个 quality score (即 QUAL 字段)，每个 ALT 基因均有一个 quality score 值。 <code>These  quality  scores  are  Phred-scaled  values </code> 。这个数值越高，说明置信度越高。</p>
<p>如果 ALT 是 <code>.</code> （表示没有变异），那么 quality score 反映这个位点真的有一个变异的可能性。</p>
<p><strong>对于 low-complexity regions 发生的错误比对（通常是由于 indels 解释为 mismatches）是错误的 SNP calls 的主要原因。</strong> 为了避免这一点，samtools mpileup 可以采用 <code> Base Alignment Quality (BAQ)</code> , 来矫正碱基质量，不仅反映不正确的 SNP call, 而且反映 a particular base being misaligned。之前我们没用，现在我们用一下看看，我们发现215,906,547 和 215,906,548 不再视为是SNP了。</p>
<p><img src="52.png" alt="45"></p>
<h2 id="11-4-Creating-Your-Own-SAM-BAM-Processing-Tools-with-Pysam">11.4 Creating Your Own SAM/BAM Processing Tools with Pysam</h2>
<p>在这一部分，我们会学习 Pysam 的基本至少，它是一个应用程序编程接口（通常称为API）.</p>
<p>我们先下载这个包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install pysam</span><br></pre></td></tr></table></figure>
<h3 id="11-4-1-Opening-BAM-Files-Fetching-Alignments-from-a-Region-and-Iterating-Across-Reads">11.4.1 Opening BAM Files, Fetching Alignments from a Region, and Iterating Across Reads</h3>
<p>这里由于是读取二进制文件，采用 “rb”</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>importpysam</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fname = <span class="string">&quot;NA12891_CEU_sample.bam&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bamfile = pysam.AlignmentFile(filename=fname, mode=<span class="string">&quot;rb&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(bamfile)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;pysam.calignmentfile.AlignmentFile&#x27;</span></span><br><span class="line">&gt;&gt;&gt;&gt; <span class="built_in">dir</span>(bamfile)</span><br><span class="line">[<span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, ..., <span class="string">&#x27;close&#x27;</span>, <span class="string">&#x27;count&#x27;</span>, <span class="string">&#x27;fetch&#x27;</span>, <span class="string">&#x27;filename&#x27;</span>,<span class="string">&#x27;getrname&#x27;</span>, <span class="string">&#x27;gettid&#x27;</span>, <span class="string">&#x27;head&#x27;</span>, <span class="string">&#x27;header&#x27;</span>, <span class="string">&#x27;lengths&#x27;</span>, <span class="string">&#x27;mapped&#x27;</span>, <span class="string">&#x27;mate&#x27;</span>,<span class="string">&#x27;next&#x27;</span>, <span class="string">&#x27;nocoordinate&#x27;</span>, <span class="string">&#x27;nreferences&#x27;</span>, <span class="string">&#x27;pileup&#x27;</span>, <span class="string">&#x27;references&#x27;</span>, <span class="string">&#x27;reset&#x27;</span>,<span class="string">&#x27;seek&#x27;</span>, <span class="string">&#x27;tell&#x27;</span>, <span class="string">&#x27;text&#x27;</span>, <span class="string">&#x27;unmapped&#x27;</span>, <span class="string">&#x27;write&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>我们可以采用 <code>pysam.AlignmentFile.fetch() </code> 来提取一个 indexed 的 BAM 文件的区域。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> read <span class="keyword">in</span> bamfile.fetch(<span class="string">&#x27;1&#x27;</span>, start=<span class="number">215906528</span>, end=<span class="number">215906567</span>):</span><br><span class="line"><span class="meta">... </span>  <span class="built_in">print</span>(read.qname, <span class="string">&quot;aligned at position&quot;</span>,read.pos)</span><br><span class="line">...</span><br><span class="line">SRR005672<span class="number">.5788073</span> aligned at position <span class="number">215906479</span></span><br><span class="line">SRR005666<span class="number">.5830972</span> aligned at position <span class="number">215906486</span></span><br><span class="line">ERR002294<span class="number">.5383813</span> aligned at position <span class="number">215906495</span></span><br><span class="line">[...]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们也可以遍历所有的 reads</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bamfile = pysam.AlignmentFile(filename=fname, mode=<span class="string">&quot;rb&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> read <span class="keyword">in</span> bamfile:</span><br><span class="line"><span class="meta">... </span>  status = <span class="string">&quot;unaligned&quot;</span><span class="keyword">if</span> read.is_unmappedelse <span class="string">&quot;aligned&quot;</span></span><br><span class="line"><span class="meta">... </span>  <span class="built_in">print</span>(read.qname, <span class="string">&quot;is&quot;</span>, status)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>遍历一遍之后，如果想再遍历一遍，需要采用reset() 函数（类似于seek()）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bamfile.reset()</span><br></pre></td></tr></table></figure>
<p>文件用完之后需要关闭</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bamfile.close()</span><br></pre></td></tr></table></figure>
<h3 id="11-4-2-Extracting-SAM-BAM-Header-Information-from-an-AlignmentFile-Object">11.4.2 Extracting SAM/BAM Header Information from an AlignmentFile Object</h3>
<p>所有的SAM/BAM文件的表头均存放在一个python 字典中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bamfile.header.keys()</span><br><span class="line">odict_keys([<span class="string">&#x27;HD&#x27;</span>, <span class="string">&#x27;SQ&#x27;</span>, <span class="string">&#x27;RG&#x27;</span>, <span class="string">&#x27;PG&#x27;</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bamfile.header[<span class="string">&#x27;RG&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">&#123;<span class="string">&#x27;ID&#x27;</span>: <span class="string">&#x27;ERR001776&#x27;</span>, <span class="string">&#x27;PL&#x27;</span>: <span class="string">&#x27;ILLUMINA&#x27;</span>, <span class="string">&#x27;LB&#x27;</span>: <span class="string">&#x27;g1k-sc-NA12891-CEU-1&#x27;</span>, <span class="string">&#x27;PI&#x27;</span>: <span class="string">&#x27;200&#x27;</span>, <span class="string">&#x27;DS&#x27;</span>: <span class="string">&#x27;SRP000032&#x27;</span>, <span class="string">&#x27;SM&#x27;</span>: <span class="string">&#x27;NA12891&#x27;</span>, <span class="string">&#x27;CN&#x27;</span>: <span class="string">&#x27;SC&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bamfile.header[<span class="string">&#x27;SQ&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">&#123;<span class="string">&#x27;SN&#x27;</span>: <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;LN&#x27;</span>: <span class="number">249250621</span>, <span class="string">&#x27;AS&#x27;</span>: <span class="string">&#x27;NCBI37&#x27;</span>, <span class="string">&#x27;UR&#x27;</span>: <span class="string">&#x27;file:/lustre/scratch102/projects/g1k/ref/main_project/human_g1k_v37.fasta&#x27;</span>, <span class="string">&#x27;M5&#x27;</span>: <span class="string">&#x27;1b22b98cdeb4a9304cb5d48026a85128&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bamfile.references</span><br><span class="line">(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;13&#x27;</span>, <span class="string">&#x27;14&#x27;</span>, <span class="string">&#x27;15&#x27;</span>, <span class="string">&#x27;16&#x27;</span>, <span class="string">&#x27;17&#x27;</span>, <span class="string">&#x27;18&#x27;</span>, <span class="string">&#x27;19&#x27;</span>, <span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;22&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;MT&#x27;</span>, <span class="string">&#x27;GL000207.1&#x27;</span>, <span class="string">&#x27;GL000226.1&#x27;</span>, <span class="string">&#x27;GL000229.1&#x27;</span>, <span class="string">&#x27;GL000231.1&#x27;</span>, <span class="string">&#x27;GL000210.1&#x27;</span>, <span class="string">&#x27;GL000239.1&#x27;</span>, <span class="string">&#x27;GL000235.1&#x27;</span>, <span class="string">&#x27;GL000201.1&#x27;</span>, <span class="string">&#x27;GL000247.1&#x27;</span>, <span class="string">&#x27;GL000245.1&#x27;</span>, <span class="string">&#x27;GL000197.1&#x27;</span>, <span class="string">&#x27;GL000203.1&#x27;</span>, <span class="string">&#x27;GL000246.1&#x27;</span>, <span class="string">&#x27;GL000249.1&#x27;</span>, <span class="string">&#x27;GL000196.1&#x27;</span>, <span class="string">&#x27;GL000248.1&#x27;</span>, <span class="string">&#x27;GL000244.1&#x27;</span>, <span class="string">&#x27;GL000238.1&#x27;</span>, <span class="string">&#x27;GL000202.1&#x27;</span>, <span class="string">&#x27;GL000234.1&#x27;</span>, <span class="string">&#x27;GL000232.1&#x27;</span>, <span class="string">&#x27;GL000206.1&#x27;</span>, <span class="string">&#x27;GL000240.1&#x27;</span>, <span class="string">&#x27;GL000236.1&#x27;</span>, <span class="string">&#x27;GL000241.1&#x27;</span>, <span class="string">&#x27;GL000243.1&#x27;</span>, <span class="string">&#x27;GL000242.1&#x27;</span>, <span class="string">&#x27;GL000230.1&#x27;</span>, <span class="string">&#x27;GL000237.1&#x27;</span>, <span class="string">&#x27;GL000233.1&#x27;</span>, <span class="string">&#x27;GL000204.1&#x27;</span>, <span class="string">&#x27;GL000198.1&#x27;</span>, <span class="string">&#x27;GL000208.1&#x27;</span>, <span class="string">&#x27;GL000191.1&#x27;</span>, <span class="string">&#x27;GL000227.1&#x27;</span>, <span class="string">&#x27;GL000228.1&#x27;</span>, <span class="string">&#x27;GL000214.1&#x27;</span>, <span class="string">&#x27;GL000221.1&#x27;</span>, <span class="string">&#x27;GL000209.1&#x27;</span>, <span class="string">&#x27;GL000218.1&#x27;</span>, <span class="string">&#x27;GL000220.1&#x27;</span>, <span class="string">&#x27;GL000213.1&#x27;</span>, <span class="string">&#x27;GL000211.1&#x27;</span>, <span class="string">&#x27;GL000199.1&#x27;</span>, <span class="string">&#x27;GL000217.1&#x27;</span>, <span class="string">&#x27;GL000216.1&#x27;</span>, <span class="string">&#x27;GL000215.1&#x27;</span>, <span class="string">&#x27;GL000205.1&#x27;</span>, <span class="string">&#x27;GL000219.1&#x27;</span>, <span class="string">&#x27;GL000224.1&#x27;</span>, <span class="string">&#x27;GL000223.1&#x27;</span>, <span class="string">&#x27;GL000195.1&#x27;</span>, <span class="string">&#x27;GL000212.1&#x27;</span>, <span class="string">&#x27;GL000222.1&#x27;</span>, <span class="string">&#x27;GL000200.1&#x27;</span>, <span class="string">&#x27;GL000193.1&#x27;</span>, <span class="string">&#x27;GL000194.1&#x27;</span>, <span class="string">&#x27;GL000225.1&#x27;</span>, <span class="string">&#x27;GL000192.1&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bamfile.lengths</span><br><span class="line">(<span class="number">249250621</span>, <span class="number">243199373</span>, <span class="number">198022430</span>, <span class="number">191154276</span>, <span class="number">180915260</span>, <span class="number">171115067</span>, <span class="number">159138663</span>, <span class="number">146364022</span>, <span class="number">141213431</span>, <span class="number">135534747</span>, <span class="number">135006516</span>, <span class="number">133851895</span>, <span class="number">115169878</span>, <span class="number">107349540</span>, <span class="number">102531392</span>, <span class="number">90354753</span>, <span class="number">81195210</span>, <span class="number">78077248</span>, <span class="number">59128983</span>, <span class="number">63025520</span>, <span class="number">48129895</span>, <span class="number">51304566</span>, <span class="number">155270560</span>, <span class="number">59373566</span>, <span class="number">16569</span>, <span class="number">4262</span>, <span class="number">15008</span>, <span class="number">19913</span>, <span class="number">27386</span>, <span class="number">27682</span>, <span class="number">33824</span>, <span class="number">34474</span>, <span class="number">36148</span>, <span class="number">36422</span>, <span class="number">36651</span>, <span class="number">37175</span>, <span class="number">37498</span>, <span class="number">38154</span>, <span class="number">38502</span>, <span class="number">38914</span>, <span class="number">39786</span>, <span class="number">39929</span>, <span class="number">39939</span>, <span class="number">40103</span>, <span class="number">40531</span>, <span class="number">40652</span>, <span class="number">41001</span>, <span class="number">41933</span>, <span class="number">41934</span>, <span class="number">42152</span>, <span class="number">43341</span>, <span class="number">43523</span>, <span class="number">43691</span>, <span class="number">45867</span>, <span class="number">45941</span>, <span class="number">81310</span>, <span class="number">90085</span>, <span class="number">92689</span>, <span class="number">106433</span>, <span class="number">128374</span>, <span class="number">129120</span>, <span class="number">137718</span>, <span class="number">155397</span>, <span class="number">159169</span>, <span class="number">161147</span>, <span class="number">161802</span>, <span class="number">164239</span>, <span class="number">166566</span>, <span class="number">169874</span>, <span class="number">172149</span>, <span class="number">172294</span>, <span class="number">172545</span>, <span class="number">174588</span>, <span class="number">179198</span>, <span class="number">179693</span>, <span class="number">180455</span>, <span class="number">182896</span>, <span class="number">186858</span>, <span class="number">186861</span>, <span class="number">187035</span>, <span class="number">189789</span>, <span class="number">191469</span>, <span class="number">211173</span>, <span class="number">547496</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>后面都没看</p>
<h3 id="11-4-3-Working-with-AlignedSegment-Objects">11.4.3 Working with AlignedSegment Objects</h3>
<h3 id="11-4-4-Writing-a-Program-to-Record-Alignment-Statistics">11.4.4 Writing a Program to Record Alignment Statistics</h3>
<h3 id="11-4-5-Additional-Pysam-Features-and-Other-SAM-BAM-APIs">11.4.5 Additional Pysam Features and Other SAM/BAM APIs</h3>
<h1>12 Bioinformatics Shell Scripting, WritingPipelines, and Parallelizing Tasks</h1>
<h2 id="12-1-Basic-Bash-Scripting">12.1 Basic Bash Scripting</h2>
<h3 id="12-1-1-Writing-and-Running-Robust-Bash-Scripts">12.1.1 Writing and Running Robust Bash Scripts</h3>
<p>每次你写 bash 脚本时，你都需要使用下面的脚本表头，让你的程序更稳健。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">set -e</span><br><span class="line">set -u</span><br><span class="line">set -o pipefail</span><br></pre></td></tr></table></figure>
<p>第一行指定解释器（shebang）</p>
<blockquote>
<h1>Shebang[[编辑](<a href="https://zh.wikipedia.org/w/index.php?title=Shebang&amp;action=edit&amp;section=0&amp;summary=/*">https://zh.wikipedia.org/w/index.php?title=Shebang&amp;action=edit&amp;section=0&amp;summary=/*</a> top */ )]</h1>
<p>维基百科，自由的百科全书</p>
<p><a href="https://zh.wikipedia.org/wiki/Shebang#mw-head">跳到导航</a><a href="https://zh.wikipedia.org/wiki/Shebang#searchInput">跳到搜索</a></p>
<p>在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97">计算</a>领域中，<strong>Shebang</strong>（也称为<strong>Hashbang</strong>）是一个由<a href="https://zh.wikipedia.org/wiki/%E4%BA%95%E8%99%9F">井号</a>和<a href="https://zh.wikipedia.org/wiki/%E5%8F%B9%E5%8F%B7">叹号</a>构成的字符序列*<code>#!</code>*，其出现在文本文件的第一行的前两个字符。 在文件中存在Shebang的情况下，<a href="https://zh.wikipedia.org/wiki/%E7%B1%BBUnix%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">类Unix操作系统</a>的<a href="https://zh.wikipedia.org/w/index.php?title=%E7%A8%8B%E5%BA%8F%E8%BD%BD%E5%85%A5%E5%99%A8&amp;action=edit&amp;redlink=1">程序载入器</a>会分析Shebang后的内容，将这些内容作为解释器指令，并调用该指令，并将载有Shebang的文件路径作为该解释器的参数[<a href="https://zh.wikipedia.org/wiki/Shebang#cite_note-absg_shabang-1">1]</a>[<a href="https://zh.wikipedia.org/wiki/Shebang#cite_note-2">2]</a>。</p>
<p>例如，以指令<code>#!/bin/sh</code>开头的文件在执行时会实际调用*/bin/sh*程序（通常是<a href="https://zh.wikipedia.org/wiki/Bourne_shell">Bourne shell</a>或兼容的<a href="https://zh.wikipedia.org/wiki/Unix_shell">shell</a>，例如<a href="https://zh.wikipedia.org/wiki/Bash">bash</a>、<a href="https://zh.wikipedia.org/wiki/Debian_Almquist_shell">dash</a>等）来执行。这行内容也是<a href="https://zh.wikipedia.org/wiki/Shell%E8%84%9A%E6%9C%AC">shell脚本</a>的标准起始行。</p>
</blockquote>
<p>第二行：默认情况下，一个shell 脚本如果报错（exit status 不为0），不会导致整个shell脚本退出（?）, shell 脚本会继续执行下一行命令。这不是我们想要的运行方式，我们通常都想看到 errors to be loud and noticeable. <code>set -e</code> 阻止了这一做法，如果脚本中的任何命令退出码不为0，整个脚本的运行便会中止。但是，有些时候退出码不为0，并不表示报错，而是 false。比如使用 <code>test -d file.txt</code> 来判断是否为文件夹，就会返回一个非0的退出码（非文件夹），但是这并不是一个错误。因此，<code>set -e</code> 会忽视在 if 的条件语句中的非0的退出码。同样地，<code>set -e</code> 会忽视Unix 管道命令中除了最后一个管道之外的所有退出状态。</p>
<p>第三行：<code>set -u</code> 修改了另一个默认行为： 包含对<strong>未设置的变量名称的引用</strong>的任何命令仍将运行。举一个可怕的例子，假设有个命令：<code>rm -rf $TEMP_DIR/*</code> ，如果 $TEMP_DIR 没有设置，BASH 会实际会执行下列语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf &#x2F;*</span><br></pre></td></tr></table></figure>
<p>通过 <code>set -u</code>  来阻止这种类型的错误。如果变量名未设置，这条命令不会执行。</p>
<p>第四行：前面提到了 <code>set -e</code>  有一些例外情况，其中一种情况就是如果在一个 Unix pipe 中没有运行成功，除非错误出现在最后一个命令，不然 <code>set -e</code>  不会让程序中止。 通过添加 <code>set -o pipefail</code> 可以阻止这种行为 - <strong>在管道命令中的任何一个命令返回一个非0的退出码，都会导致整个pipe 返回一个非0的退出码</strong>。再加上 <code>set -e</code> 选项，就会让这个shell 脚本运行中止。</p>
<p>上面这三个选项时避免 Bash scripts 出现 silent errors 和 unsafe behavior 的第一层防护。<strong>不幸的是，Bash 是一个脆弱的语言</strong>。我们需要注意一些其他事项才能使得它能够安全运行。</p>
<h3 id="12-1-2-Variables-and-Command-Arguments">12.1.2 Variables and Command Arguments</h3>
<p>引用变量：最规范的是第三种</p>
<ol>
<li>使用 <code>$&#123;&#125;</code> 确定变量边界</li>
<li>整个引用外层使用引号，避免因为中间出现空格或其他特殊字符，导致出错。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir $sample_aln/</span><br><span class="line">mkdir $&#123;sample&#125;_aln/</span><br><span class="line">mkdir &quot;$&#123;sample&#125;_aln/&quot;</span><br></pre></td></tr></table></figure>
<h3 id="12-1-3-Conditionals-in-a-Bash-Script-if-Statements">12.1.3 Conditionals in a Bash Script: if Statements</h3>
<p>shell 中的 if 语句和其他语言不同的地方在于：shell 中判断是看<strong>退出码</strong>，退出码为0运行then之后的语句，退出码是其他值则运行else之后的值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [commands]</span><br><span class="line">then</span><br><span class="line">	do sth</span><br><span class="line">else</span><br><span class="line">	do sth</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>举个简单的例子，假如我们想看一个文件中是否包含某字符串。由于 grep 函数如果匹配到了会 return 0；如果没有匹配到会 return 1。我们就可以这么写</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if grep &quot;pattern&quot; some_file.txt &gt; /dev/null</span><br><span class="line">then </span><br><span class="line">	echo &quot;found &#x27;pattern&#x27; in &#x27;some_file.txt&#x27;&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>if 做判断时可以使用 <strong><code>&amp;&amp;</code></strong> (and) 和 <strong><code>||</code></strong>(not) ，例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if grep &quot;pattern&quot; file_1.txt &gt; /dev/null &amp;&amp;</span><br><span class="line">   grep &quot;pattern&quot; file_2.txt &gt; /dev/null</span><br><span class="line">then </span><br><span class="line">	echo &quot;found &#x27;pattern&#x27; in &#x27;file_1.txt&#x27; and &#x27;file_2.txt&#x27; &quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>还有 <strong>！</strong> （取反）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if ! grep &quot;pattern&quot; some_file.txt &gt; /dev/null</span><br><span class="line">then </span><br><span class="line">	echo &quot;did not found &#x27;pattern&#x27; in &#x27;some_file.txt&#x27;&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>if 语句也可以使用 pipeline，但是这取决于你用不用<code>set -o pipefail</code> 。如果你设置了 pipefail ，那么pipe 中任何一个命令的退出码非0，就会跳过这个 if statement ，直接运行 else 的语句（如果有的话）。但是你如果没有设置 pipeline，那么只会看最后一个命令的退出码。设置pipefail 是更加合理的。</p>
<p>最后，我们来看 <strong>test</strong> 命令。test 命令用于检查某个条件是否成立，同样返回 0和1。</p>
<p>test 支持三种比较，<strong>字符串</strong>、<strong>整数</strong>（浮点数没法弄）、<strong>文件和文件夹</strong>。具体见shell 编程。</p>
<p>注意 shell 编程有一点错了或者不规范，shell 编程里是不能用**&gt;<strong>这种符号来比较数字或字符串的，因为和</strong>重定向符合重复了**。</p>
<p>test 语句可以写成 <strong>[ “$#” -ne 1 ]<strong>这种格式，但是注意</strong>[ 后 ] 前必须有一个空格</strong>。</p>
<p>test 语句 支持 -a -o ! （and,or,or）来连接多个条件，但是我觉得不如使用多个test 语句，然后用 &amp;&amp; || ! 连接更清晰，用书上的例子，可以改写一下（可读性明显增加了）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ &quot;$#&quot; -ne 1 -o ! -r &quot;$1&quot; ]</span><br><span class="line">if [ &quot;$#&quot; -ne 1 ] || [ ! -r &quot;$1&quot; ]</span><br></pre></td></tr></table></figure>
<h3 id="12-1-4-Processing-Files-with-Bash-Using-for-Loops-and-Globbing">12.1.4 Processing Files with Bash Using for Loops and Globbing</h3>
<p>在很多生信分析中，数据可以会切分成多个文件。因此需要使用 for 循环遍历所有的文件。遍历过程分为三步：</p>
<ol>
<li>挑选哪些文件需要处理</li>
<li>对需要处理的文件应用同一套命令</li>
<li>按照输入文件名称命名输出文件。</li>
</ol>
<p>让我们先看第一步，挑选需要处理的文件。假设存在一个包含了文件基础信息的文件(samples.txt)，包括样本名，链名和文件路径。如下</p>
<p>前两列又称之为 <em>metadata</em> (<strong>data about data</strong>，这个data about data有意思) ，包含了文件的重要信息。我们这里注意到文件的文件名也包含了 metadata，这对我们提取文件很有用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat samples.txt</span></span><br><span class="line">zmaysA  R1      seq/zmaysA_R1.fastq</span><br><span class="line">zmaysA  R2      seq/zmaysA_R2.fastq</span><br><span class="line">zmaysB  R1      seq/zmaysB_R1.fastq</span><br><span class="line">zmaysB  R2      seq/zmaysB_R2.fastq</span><br><span class="line">zmaysC  R1      seq/zmaysC_R1.fastq</span><br><span class="line">zmaysC  R2      seq/zmaysC_R2.fastq</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假如说我们先收集每个文件的 quality statistics （使用假想的程序 fastq_stat），然后将这些信息保存到一个输出文件中。这里我们用到了 Bash 中的<strong>数组</strong>，<strong>basename</strong>。</p>
<p>首先，我们先将文件名导入到一个数组中，用于后面的循环。手动创建如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sample_names=(zmaysA zmaysB zmaysC)</span></span><br></pre></td></tr></table></figure>
<p>可以通过索引提取（0-indexed）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;sample_names[0]&#125;</span></span></span><br><span class="line">zmaysA</span><br></pre></td></tr></table></figure>
<p>提取所有元素</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;sample_names[@]&#125;</span></span></span><br><span class="line">zmaysA zmaysB zmaysC</span><br></pre></td></tr></table></figure>
<p>查看元素个数，每个元素的索引</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;#sample_names[@]&#125;</span></span></span><br><span class="line">3</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;!sample_names[@]&#125;</span></span></span><br><span class="line">0 1 2</span><br></pre></td></tr></table></figure>
<p>但是，手动创建数组是无聊而又任意出错的工作，特别使当我们已经有了一个文件。我们可以通过 shell 的 <em>command substitution</em> 来创建数组（这么做存在风险）。</p>
<p>我们可以用 cut -f 3 来提取文件名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sample_files=($(cut -f 3 samples.txt))</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;sample_files[@]&#125;</span></span></span><br><span class="line">seq/zmaysA_R1.fastq seq/zmaysA_R2.fastq seq/zmaysB_R1.fastq seq/zmaysB_R2.fastq seq/zmaysC_R1.fastq seq/zmaysC_R2.fastq</span><br></pre></td></tr></table></figure>
<p>这么做的前提是你事先确保你的文件名是<strong>规范的</strong> — 只有字母、数字、<code>_</code>  和 <code>-</code> 构成。如果在文件名中存在空格，制表符，换行符，又或者类似<code>*</code>的特殊字符，上面这种做法会出错。</p>
<p><strong>The Internal Field Separator, Word Splitting, and Filenames</strong></p>
<p>当我们通过 <em>command substitution</em> 来创建数组时，Bash 采用 <em>word spliting</em> 来分割出字段作为数组的元素，使用的规则是 <em>Internal Field Separator</em> (IFS) 。IFS 的值存储在 IFS 变量中，默认为<strong>空格、制表位和换行符</strong>。你可以这么查看 IFS 的值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">printf</span> %q <span class="string">&quot;<span class="variable">$IFS</span>&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="string">&#x27; \t\n&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>由于空格包含在IFS中，因此如果文件名包含空格，它会被切分为两部分。</p>
<p>获取了文件名之后，我们需要去除路径和后缀，只提取基本的文件名，用于命名结果文件。我们可以使用 basename 命令来完成这一步</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> basename seqs/zmaysA_R1.fastq</span></span><br><span class="line">zmaysA_R1.fastq</span><br></pre></td></tr></table></figure>
<p>可以进一步剔除后缀</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> basename seqs/zmaysA_R1.fastq .fastq</span></span><br><span class="line">zmaysA_R1</span><br><span class="line"><span class="meta">$</span><span class="bash"> basename -s .fastq seqs/zmaysA_R1.fastq</span></span><br><span class="line">zmaysA_R1</span><br></pre></td></tr></table></figure>
<p>现在，所有的步骤均已完备，可以搭建流程了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">set -e</span><br><span class="line">set -u</span><br><span class="line">set -o pipefail</span><br><span class="line"><span class="meta">#</span><span class="bash"> specify the input samples file, <span class="built_in">where</span> the third</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> column is the path to each sample FASTQ file</span></span><br><span class="line">sample_info=samples.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> create a Bash array from the third column of <span class="variable">$sample_info</span></span></span><br><span class="line">sample_files=($(cut -f 3 &quot;$sample_info&quot;))</span><br><span class="line"> </span><br><span class="line">for fastq_file in $&#123;sample_files[@]&#125;</span><br><span class="line">do</span><br><span class="line">    # strip .fastq from each FASTQ file, and add suffix</span><br><span class="line">    # &quot;-stats.txt&quot; to create an output filename for each FASTQ file    </span><br><span class="line">    results_file=&quot;$(basename $fastq_file .fastq)-stats.txt&quot;</span><br><span class="line">    # run fastq_stat on a file, writing results to the filename we&#x27;ve</span><br><span class="line">    # above    </span><br><span class="line">    fastq_stat $fastq_file &gt; stats/$results_file</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>上面这个流程是一个简单的流程，但是在生信分析中，我们经常需要合并两个或多个输入文件的信息，生成一个输出文件。比对的reads数据就是一个例子：很多软件要求输入两个 FASTQ 文件，最终返回一个 alignment 文件。当我们进行比对时，我们不能像上面那样循环。相反，每个样本是一个处理单元（?）。我们的比对步骤要求输入一个样本的两个 FASTQ 文件，然后返回这个样本的一个alignment 文件。因此，我们需要通过唯一的文件名进行迭代，然后利用文件名来 re-create 输入的 FASTQ 文件。</p>
<p>我们用个例子来说明：假设我们使用比对软件 BWA ，并且我们的参考基因组是 zmays_AGPv3.20.fa</p>
<p><img src="53.png" alt="53"></p>
<p>很多时候，直接对文件进行循环可能更加方便。</p>
<p>下面这个例子是简单地查找 fastq 文件中有多少条记录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">set -e</span><br><span class="line">set -u</span><br><span class="line">set -o pipefail</span><br><span class="line"></span><br><span class="line">for file in *.fastq</span><br><span class="line">do</span><br><span class="line">	echo &quot;$file: &quot; $(bioawk -c fastx &#x27;END &#123;print NR&#125;&#x27; $file)</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>Bash 的循环可以很方便地遍历多个文件，但是存在一些缺点。首先相比于上面那种方式，使用find命令更加强大。然后，Bash 的循环命令无法 parallelize 。下一节我们会看到更加强大的文件处理命令。</p>
<h2 id="12-2-Automating-File-Processing-with-find-and-xargs">12.2 Automating File-Processing with find and xargs</h2>
<p>find 和 xargs 组合使用，能够创建强大的Unix-based 文件处理流程。</p>
<h3 id="12-2-1-Using-find-and-xargs">12.2.1 Using find and xargs</h3>
<p>我们先举个例子，假设你有个程序 process_fq 可以从标准输入接收多个文件名并进行处理。如果你想对所有后缀为 .fq 的文件进行处理，你可能会这样运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls *.fq</span></span><br><span class="line">treatment-01.fq treatment 02.fq treatment-03.fq</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls *.fq | process_fq</span></span><br></pre></td></tr></table></figure>
<p>这里使用了 ls 和 通配符来实现，但是这个方案是很脆弱的。假设你存在一个文件 treatment 02.fq 。在这种情况下，由于每个文件名之间是通过空格分隔的，因此这个文件名就会切分成两部分，导致程序报错。</p>
<p>如果你直接用 file globbing 作为参数，上面的这种情况不会发生，它会自动会忽略 reatment  02.fq 中的空格（? 没搞懂）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> process_fq *.fq</span></span><br></pre></td></tr></table></figure>
<p>那为什么不用这种方式呢？因为这种方式对文件数目有限制。举例，假如你在 tmp/ 目录下存在成千上万个文件，你想先把这个目录下的所有文件删除，你可以会采用下述命令，但是会面临报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm tmp/*</span></span><br><span class="line">/bin/rm: cannot execute [Argument list too long]</span><br></pre></td></tr></table></figure>
<p>新手经常会面临上面这个文件。解决办法就是利用 find 和 xargs</p>
<h3 id="12-2-2-Finding-Files-with-find">12.2.2 Finding Files with find</h3>
<p>不像 ls，find 命令是递归的（它会遍历当前目录的子目录，子目录的子目录……）。如果你有多层目录嵌套的话，find 命令尤其有用。</p>
<p>事实上，对一个目录简单地采用 find 命令（不加任何参数）是参看<strong>目录结构</strong>的一个快捷方式。 例如</p>
<p><img src="54.png" alt="53"></p>
<p>通过 -maxdepth 可以限制目录深度，比如你只想查找当前目录下的所有文件，使用 <code>-maxdepth 1</code>。</p>
<p>find 的 基本语法是 <code>find path expression</code> 。这里 path 指 find 用于查找的文件夹。</p>
<p>最简单的就是 -name，下面的命令和 <code>ls zmaysB*fastq</code> 结果一样，区别在于find的结果每个文件占一行，而且find命令是递归的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find data/seqs -name <span class="string">&quot;zmaysB*fastq&quot;</span></span></span><br><span class="line">data/seqs/zmaysB_R1.fastq</span><br><span class="line">data/seqs/zmaysB_R2.fastq</span><br></pre></td></tr></table></figure>
<h3 id="12-2-3-find’s-Expressions">12.2.3 find’s Expressions</h3>
<p>在上面的例子中，文件夹也可能会匹配上。因为我们只想返回 FASTQ 文件，我们可能需要通过 -type 来限制结果的类型（常用类型 f : 文件 d : 目录 l : 链接）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find data/seqs -name <span class="string">&quot;zmaysB*fastq&quot;</span> -<span class="built_in">type</span> f</span></span><br><span class="line">data/seqs/zmaysB_R1.fastq</span><br><span class="line">data/seqs/zmaysB_R2.fastq</span><br></pre></td></tr></table></figure>
<p>默认情况下，find 会通过 AND 逻辑来连接不同的expression，也就是说上面的例子找出的结果是既符合&quot;zmaysB*fastq&quot; 又是文件。上面的例子等同于</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find data/seqs -name <span class="string">&quot;zmaysB*fastq&quot;</span> -and -<span class="built_in">type</span> f</span></span><br><span class="line">data/seqs/zmaysB_R1.fastq</span><br><span class="line">data/seqs/zmaysB_R2.fastq</span><br></pre></td></tr></table></figure>
<p>我们可能想要找到样本A 或 样本C 的所有的FASTQ文件。在这个例子中，我们可能得用 -or 选项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find data/seqs -name <span class="string">&quot;zmaysA*fastq&quot;</span> -or -name <span class="string">&quot;zmaysC*fastq&quot;</span> -<span class="built_in">type</span> f</span></span><br><span class="line">data/seqs/zmaysA_R1.fastq</span><br><span class="line">data/seqs/zmaysA_R2.fastq</span><br><span class="line">data/seqs/zmaysC_R1.fastq</span><br><span class="line">data/seqs/zmaysC_R2.fastq</span><br></pre></td></tr></table></figure>
<p>还有一个操作就是<strong>取反</strong>：比如提取除了样本C之外的 FASTQ 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find seqs -<span class="built_in">type</span> f <span class="string">&quot;!&quot;</span> -name <span class="string">&quot;zmaysC*fastq&quot;</span></span></span><br><span class="line">seqs/zmaysA_R1.fastq</span><br><span class="line">seqs/zmaysA_R2.fastq</span><br><span class="line">seqs/zmaysB_R1.fastq</span><br><span class="line">seqs/zmaysB_R2.fastq</span><br></pre></td></tr></table></figure>
<p>让我们看一个更高级的例子：假如你有一个messy的同事，创建一个名为zmaysB_R1-temp.fastq 的文件，然后你通过 find 发现了这个文件</p>
<p><img src="55.png" alt="53"></p>
<p>你不想删除或者重命名这个文件，因为你的同事可能需要用到这个文件。因此，最好的办法就是改变你的 find命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find seqs -<span class="built_in">type</span> f <span class="string">&quot;!&quot;</span> -name <span class="string">&quot;zmaysC*fastq&quot;</span> -and <span class="string">&quot;!&quot;</span> -name <span class="string">&quot;*-temp*&quot;</span></span></span><br><span class="line">seqs/zmaysA_R1.fastq</span><br><span class="line">seqs/zmaysA_R2.fastq</span><br><span class="line">seqs/zmaysB_R1.fastq</span><br><span class="line">seqs/zmaysB_R2.fastq</span><br></pre></td></tr></table></figure>
<p>注意到在find中，<strong>!</strong> 和 括号必须用引号。</p>
<h3 id="12-2-4-find’s-exec-Running-Commands-on-find’s-Results">12.2.4 find’s -exec: Running Commands on find’s Results</h3>
<p>我们通过 find 来定位文件，通常都是需要对文件进行处理。这一步也可以通过 -exec 选项来实现。</p>
<p>让我们通过一个简单的例子来理解 -exec 如何工作。继续之前的例子，假设一个 messy 的同事创建很多的临时文件。我们试着模拟一下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch zmays&#123;A,C&#125;_R&#123;1,2&#125;-temp.fastq</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">zmaysA_R1.fastq       zmaysA_R2_temp.fastq  zmaysB_R2.fastq       zmaysC_R1_temp.fastq</span><br><span class="line">zmaysA_R1_temp.fastq  zmaysB_R1.fastq       zmaysB_R2_temp.fastq  zmaysC_R2.fastq</span><br><span class="line">zmaysA_R2.fastq       zmaysB_R1_temp.fastq  zmaysC_R1.fastq       zmaysC_R2_temp.fastq</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设你的同事允许你删除这些临时文件。一种方式是 <code>rm *-temp.fastq</code>，但是在重要的文件夹中使用通配符来删除文件风险很大。如果你一不小心在 <code>*</code>和 -temp.fastq 之间放了一个空格，由于使用通配符<code>*</code> ，这个文件夹的所有文件均会被删除（可怕）。</p>
<p>我们通过 find 的 -exec 命令更加安全。如果使用 -exec 命令，那么在命令结束的部分添加一个分号是必需的。比如，我们这里我们可以用 find -exec 和 <code>rm -i</code> 来删除中间文件。 <code>rm -i</code> 表示 interactive 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;*_temp.fastq&quot;</span> -<span class="built_in">exec</span> rm -i &#123;&#125; \;</span></span><br><span class="line">rm: remove regular empty file ‘./zmaysA_R1_temp.fastq’? y</span><br><span class="line">rm: remove regular empty file ‘./zmaysA_R2_temp.fastq’? y</span><br><span class="line">rm: remove regular empty file ‘./zmaysC_R1_temp.fastq’? y</span><br><span class="line">rm: remove regular empty file ‘./zmaysC_R2_temp.fastq’? y</span><br><span class="line">rm: remove regular empty file ‘./zmaysB_R1_temp.fastq’? y</span><br><span class="line">rm: remove regular empty file ‘./zmaysB_R2_temp.fastq’? y</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通常而言，-exec 选项只用于简单的命令，比如删除文件，更改权限等。对于复杂的任务，xargs 是更好的选择。</p>
<h3 id="12-2-5-xargs-A-Unix-Powertool">12.2.5 xargs: A Unix Powertool</h3>
<p><code>xargs</code> 从标准输入中获取值（以<strong>空格，制表符或换行符</strong>分隔），然后将其作为下一个程序的参数。</p>
<p>让我们重建上面的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch zmays&#123;A,C&#125;_R&#123;1,2&#125;-temp.fastq</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">zmaysA_R1.fastq       zmaysA_R2.fastq       zmaysB_R1.fastq  zmaysC_R1.fastq       zmaysC_R2.fastq</span><br><span class="line">zmaysA_R1-temp.fastq  zmaysA_R2-temp.fastq  zmaysB_R2.fastq  zmaysC_R1-temp.fastq  zmaysC_R2-temp.fastq</span><br></pre></td></tr></table></figure>
<p>这里我们可以模拟上面删除文件的操作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;*-temp.fastq&quot;</span></span></span><br><span class="line">./zmaysA_R1-temp.fastq</span><br><span class="line">./zmaysA_R2-temp.fastq</span><br><span class="line">./zmaysC_R1-temp.fastq</span><br><span class="line">./zmaysC_R2-temp.fastq</span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;*-temp.fastq&quot;</span> | xargs rm</span></span><br></pre></td></tr></table></figure>
<p>我测试了一下，这里 rm 不能用 -i 选项（提示了信息，但是不能互动，结果也没有删除文件）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;*-temp.fastq&quot;</span> | xargs rm -i</span></span><br><span class="line">rm: remove regular empty file ‘./zmaysA_R1-temp.fastq’? rm: remove regular empty file ‘./zmaysA_R2-temp.fastq’? rm: remove regular empty file ‘./zmaysC_R1-temp.fastq’? rm: remove regular empty file ‘./zmaysC_R2-temp.fastq’? </span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">zmaysA_R1.fastq       zmaysA_R2.fastq       zmaysB_R1.fastq  zmaysC_R1.fastq       zmaysC_R2.fastq</span><br><span class="line">zmaysA_R1-temp.fastq  zmaysA_R2-temp.fastq  zmaysB_R2.fastq  zmaysC_R1-temp.fastq  zmaysC_R2-temp.fastq</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实际上，后面的 xargs 选项是将find找到的所有文件切分为参数，然后执行下面命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm ./zmaysA_R1-temp.fastq ./zmaysA_R2-temp.fa ./zmaysC_R1-temp.fastq ./zmaysC_R2-temp.fa</span></span><br></pre></td></tr></table></figure>
<p>像这种将所有文件直接当成n个参数传给后面的命令，适合像rm, touch, mkdir 这种可以处理多个参数的命令。</p>
<p>但是，很多命令一次只能接受一个参数。我们可以通过 xargs 的 -n 选项来设置一次传递几个参数。例如，我们可以运行 rm 命令 4 次（一个文件一次），命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;*-temp.fastq&quot;</span> | xargs -n 1 rm</span></span><br></pre></td></tr></table></figure>
<p>如果我们想在删除文件前，查看find 找到的文件名。我们可以这么写：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;*-temp.fastq&quot;</span> &gt; files-to-delete.tx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat files-to-delete.tx</span></span><br><span class="line">./zmaysA_R1-temp.fastq</span><br><span class="line">./zmaysA_R2-temp.fastq</span><br><span class="line">./zmaysC_R1-temp.fastq</span><br><span class="line">./zmaysC_R2-temp.fastq</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat files-to-delete.txt | xargs rm</span></span><br></pre></td></tr></table></figure>
<p>另一个使用 xargs 的技巧在于将最终用到的命令行写入一个Bash 脚本中。比如上面的例子中，我们我们使用 echo 命令。例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;*-temp.fastq&quot;</span> | xargs -n 1 <span class="built_in">echo</span> <span class="string">&quot;rm -i&quot;</span> &gt; delete-temp.s</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat delete-temp.s</span></span><br><span class="line">rm -i ./zmaysA_R1-temp.fastq</span><br><span class="line">rm -i ./zmaysA_R2-temp.fastq</span><br><span class="line">rm -i ./zmaysC_R1-temp.fastq</span><br><span class="line">rm -i ./zmaysC_R2-temp.fastq</span><br></pre></td></tr></table></figure>
<p>这种方式让我们可以互动式地删除文件（之前试过了直接用xargs不行），我们可以运行上面生产的脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bash delete-temp.sh</span></span><br><span class="line">remove ./zmaysA_R1-temp.fastq? y</span><br><span class="line">remove ./zmaysA_R2-temp.fastq? y</span><br><span class="line">remove ./zmaysC_R1-temp.fastq? y</span><br><span class="line">remove ./zmaysC_R2-temp.fastq? y</span><br></pre></td></tr></table></figure>
<h4 id="playing-it-safe-with-find-and-xargs">playing it safe with find and xargs</h4>
<p>由于xargs 也会将空格视为分隔符，因此如果<strong>文件名中包含空格</strong>，这个文件名就会被xargs视为两个文件，造成错误。</p>
<p>避免办法：</p>
<ol>
<li>文件命名一定要规范</li>
<li>find 可以通过 -print0 选项，配合 xargs 的 -0 选项，使得文件之间不再以换行符隔开，而是以<strong>空字符</strong>隔开，这样即便文件名不规范，也可以正常运行</li>
</ol>
<blockquote>
<p>-print0<br>
True; print the full file name on the standard output, followed by a null character (instead of the newline character that -print uses).  This allows file names that contain newlines or other types of white space to be correctly interpreted by programs that process the find output.  This option corresponds to the -0 option of xargs.</p>
</blockquote>
<p>例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;samples [AB].txt&quot;</span> -print0 | xargs -0 r</span></span><br></pre></td></tr></table></figure>
<p>作者建议所有的 find - xargs 都加上这两个选项，我倒觉得没必要，文件名就应该规范，报错并不是坏事。</p>
<h3 id="12-2-6-Using-xargs-with-Replacement-Strings-to-Apply-Commands-to-Files">12.2.6 Using xargs with Replacement Strings to Apply Commands to Files</h3>
<p>有些软件通过选项来传参，类似于 <code>program --in file.txt --out-file out.txt</code>；其他一些软件可能通过位置参数来传参，类似于 <code>program arg1 arg2</code> 。xargs 的 <code>-I</code> 选项可以实现这一点，默认使用 {} 代替参数，但是注意<strong>只能传入一个参数</strong>。</p>
<p>让我们先看一个例子，假设我们有一个假想的程序 fastq_stat ，它需要一个输入文件通过选项 --in 传入，然后会收集 FASTQ的统计信息，最后写入 --out 指定的输出文件，输出文件名称由输入文件确定。我们可以通过 find, xargs 和 basename 来实现这一点。第一步通过 find 找到你需要处理的文件，然后利用 xargs 和 basename 来提取文件名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;*.fastq&quot;</span> | xargs basename -s <span class="string">&quot;.fastq&quot;</span></span></span><br><span class="line">zmaysA_R1</span><br><span class="line">zmaysA_R2</span><br><span class="line">zmaysB_R1</span><br><span class="line">zmaysB_R2</span><br><span class="line">zmaysC_R1</span><br><span class="line">zmaysC_R2</span><br></pre></td></tr></table></figure>
<p>然后我们想运行 <code>fastq_stat  --in  file.fastq  --out  ../summaries/file.txt</code> ，不过要将 file 替换为上面提取的 basename。我们的做法是后面再接一个 xargs 命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;*.fastq&quot;</span> | xargs basename -s <span class="string">&quot;.fastq&quot;</span> | xargs -I&#123;&#125; fastq_stat --<span class="keyword">in</span> &#123;&#125;.fastq --out ../summaries/&#123;&#125;.txt</span></span><br></pre></td></tr></table></figure>
<p>这种将 xargs 和 basename 联合使用的方法是一种很强大的范式，用于传参，并使得输出文件的名称根据输入文件确定。</p>
<h3 id="12-2-7-xargs-and-Parallelization">12.2.7 xargs and Parallelization</h3>
<p>xargs 可以创建<strong>有限</strong>数目的<strong>进程</strong>（processes），用于平行计算。这里强调有限数目，是说相对于bash的 for 循环，xargs 具有优势。我们可以通过 Bash 的 for 循环发起无数个后台进程，例如下面的语句，有多少个FASTQ 文件，就发起了多少个后台进程，这会占用很多的服务器资源。即便你是服务器唯一的使用者，但所有程序都可以从硬盘中进行读写，也可能发生 瓶颈。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for filename in *.fastq; do</span><br><span class="line">	program &quot;$filename&quot; &amp;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>因此，我们想要限制同时运行的进程数目。xargs 可以 通过 <code>-P num</code> 来设定进程数目。</p>
<p>让我们看一个简单的例子，上面运行我们的假想软件 fastq_stat ，现在我们采用6个进程同时计算。这里不需要对第一个xargs采用多进程，因为这一步非常快。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;*.fastq&quot;</span> | xargs basename -s <span class="string">&quot;.fastq&quot;</span> | xargs -P 6 -I&#123;&#125; fastq_stat --<span class="keyword">in</span> &#123;&#125;.fastq --out ../summaries/&#123;&#125;.txt</span></span><br></pre></td></tr></table></figure>
<h4 id="xargs-Pipes-and-Redirects">xargs, Pipes, and Redirects</h4>
<p>下面这段话没看懂，貌似大概的意思是说 xargs 没法直接使用重定向。</p>
<blockquote>
<p>One  stumbling  block  beginners  frequently  encounter  is  trying  touse  pipes  and  redirects  with  xargs.  This  won’t  work,  as  the  shell process  that  reads  your  xargs  command  will  interpret  pipes  and redirects as what to do with xarg’s output, not as part of the command  run  by  xargs.</p>
</blockquote>
<p>一个简单的解决办法是创建一个一次处理一个文件的简单的Bash 脚本，然后使用 xargs 运行这个脚本。</p>
<p>比如，我们先写一个简单的脚本，命名为 <a href="http://script.sh">script.sh</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">set -e</span><br><span class="line">set -u</span><br><span class="line">set -o pipefail</span><br><span class="line">sample_name=$(basename -s &quot;.fastq&quot; &quot;$1&quot;)</span><br><span class="line">some_program $&#123;sample_name&#125;.fastq | another_program &gt;  $&#123;sample_name&#125;-results.txt</span><br></pre></td></tr></table></figure>
<p>然后，运行下面的命令。通过 <code>-n 1</code> 限定每次传递一个参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;*.fastq&quot;</span> | xargs -n 1 -P 4 bash script.sh</span></span><br></pre></td></tr></table></figure>
<p>xargs 适合比较简单的命令。如果命令比较复杂，可以使用 <a href="http://www.gnu.org/software/parallel/">GNU Parallel</a>。 它可以说是 xargs 的扩展版，解决了 xargs 的一些局限。例如，GNU Parallel 可以使用重定向，可以通过一个简写（{/.}）来提取 basename (这个估计是去除了后缀的)。我们可以通过 GNU Parallel 写出一个简短而又强大的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;*.fastq&quot;</span> | parallel --max-procs=6 <span class="string">&#x27;program &#123;/.&#125; &gt; &#123;/.&#125;-out.txt&#x27;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="12-3-Make-and-Makefiles-Another-Option-for-Pipelines">12.3 Make and Makefiles: Another Option for Pipelines</h2>
<p>Make 用于生成 <em>makefilies</em> (采用他们自己的 makefile 语言)。Make 适用于编译（compile）软件，这是一个很复杂的过程，因为编译一个文件需要确保这个文件的所有附属文件已被编译或可用。就像 SQL ，</p>
<p>makefile language 是陈述性的（declarative）— 不像是 Bash scripts，makefiles 不会按顺序从头跑到尾。相反，makefiles 是按照一系列规则构建的，每个规则都有三部分：the target, the prerequisites, the recipe。每个  recipe 是用于 build a target 的一系列命令……（看不懂）</p>
<blockquote>
<p>The  amazing  ingenuity  of  Make  is  that  the  program  figures  outhow to use all rules to build files for you from the prerequisites and targets.</p>
</blockquote>
<p>让我们看一个简单的例子 ，我们先写一个简单的流程，从网上下载文件然后汇总信息。</p>
<p><img src="56.png" alt="56"></p>
<ol>
<li>我们像Bash 脚本中一样定义了一个变量。</li>
</ol>
<p>后面都没太看懂，不过好像这里的格式是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">target:  prerequisites</span><br><span class="line">recipe</span><br></pre></td></tr></table></figure>
<ul>
<li>target : 目标文件</li>
<li>prerequisites ：附属文件</li>
<li>recipe : 生成target 文件的命令行</li>
</ul>
<p>我们通过<strong>make命令运行上面生成的Makefile</strong>（这里文件名定死了，只能是Makefile）。像上面的生成的文件，我们可以运行命令 <code>make all</code> ，这里 <code>all</code> 参数指定 make 应该首先从 all target 开始。然后，make 命令会首先在当前目录查找文件名为 <strong>Makefile</strong> 的文件，加载这个文件，然后从 target all 开始运行。</p>
<p>实际运行逻辑如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make all</span></span><br><span class="line">curl -L http://bit.ly/egfr_flank &gt; egfr_flank.fa #第一步</span><br><span class="line">seqtk comp egfr_flank.fa &gt; egfr_comp.txt #第二步</span><br></pre></td></tr></table></figure>
<p>我的理解是：从all 开始（3），根据附属文件跳到（5）, (5) 的附属文件是（4），（4）没有附属文件，那就先跑 （4），顺序就是 (4) - (5) - (3) 。</p>
<p>make 的一个特别有用的功能是，它只会生成没有附属文件/附属文件已<strong>修改</strong>的目标文件。这很有用：如果你有一个很长很复杂的makefile文件，你修改了一个文件，重跑 make 命令只会重新运行附属文件是这个修改的文件的target 的命令行。</p>
<p>比如，你现在重新再跑一遍make all，因为所有的文件均未改变，所以这里啥也没做。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make all</span></span><br><span class="line">make: Nothing to be done for `all&#x27;.</span><br></pre></td></tr></table></figure>
<p>现在我们创建一个新的 FASTQ 文件。因为 egfr_flank.fa 是 egfr_comp.txt 的附属文件，因此它的语句会重新运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch egfr_flank.fa</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make all</span></span><br><span class="line">seqtk comp egfr_flank.fa &gt; egfr_comp.txt</span><br></pre></td></tr></table></figure>
<p>Make 语句如果写复杂了，会很晦涩难懂。但是还是可以用于简单的任务。（那问题来了，简单的任务我用得着写Make语句吗？）</p>
<h1>13 Out-of-Memory Approaches:Tabix and SQLite</h1>
<p>当数据量超出<strong>内存的上限</strong>时，有两个工具可以用：Tabix 和 SQLite databases。</p>
<h2 id="13-1-Fast-Access-to-Indexed-Tab-Delimited-Fileswith-BGZF-and-Tabix">13.1 Fast Access to Indexed Tab-Delimited Fileswith BGZF and Tabix</h2>
<p>BGZF 和 Tabix 解决了处理基因组数据的重要问题。</p>
<p>下面的话没看懂。大概意思是说，如果想要获取基因组上某个范围的数据，首先由于基因组数据太大，可能不能全部放进内存中，还有一部分数据可能要从速度很慢的磁盘中读取；第二，基本是使用关系型数据库，如果检索三百万条条目，速度也是很慢的。这里即将提到的工具，是专门用于处理这个问题的，可以对tab分隔的基因组数据进行快速查找。</p>
<p>在基因组比对的章节，我们看到了如何排序和 indexed BAM 文件，可以快速找到某个特定区域的比对结果，基于一种特定的压缩格式，称为 BGZF （Blocked GUN Zip Format），使用了gzip 来压缩。但是，gzip 一般是直接压缩整个文件，BGZF 文件是分区块压缩的。这些区块提供一个新的特征：我们可以直接解压我们想要的区块，而不用解压整个文件。</p>
<p>联合使用 Block compression  和 indexing 使得我们可以通过 samtools view 快速检索 alignments。</p>
<p>在这一章节，我们会用到 BGZF 压缩，还有一个命令行工具 Tabix，来提供对很多 tab 分隔的基因组格式数据的快速检索，包括 GFF, BED, VCF。</p>
<p>为了使用 Tabix 来检索与某个 query region 重叠的行，我们首先准备包含了基因组区域的文件，通常包括以下步骤：</p>
<ol>
<li>通过染色体和物理位置进行排序</li>
<li>使用 bgzip 命令来使用 BGZF 压缩</li>
<li>使用 tabix 来 index file。</li>
</ol>
<p>bgzip 和 tabix 都是 <strong>Samtools</strong> 中的命令。</p>
<h3 id="13-1-1-Compressing-Files-for-Tabix-with-Bgzip">13.1.1 Compressing Files for Tabix with Bgzip</h3>
<p>以 <em>Mus_musculus.GRCm38.75.gtf.gz</em> 为例，我们需要先解压，然后排序，再用 bgzip 压缩。我们可以通过一个pipeline 完成这些操作。</p>
<p>但是有一点需要注意，由于 GTF 文件中含有 metadata, 不能直接使用sort</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> zcat Mus_musculus.GRCm38.75.gtf.gz | head -n5</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!genome-build GRCm38.p2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!genome-version GRCm38</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!genome-date 2012-01</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!genome-build-accession NCBI:GCA_000001635.4</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!genebuild-last-updated 2013-09</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里他说可以用到 169页教的 subshell 技巧（好吧，我已经忘了）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> (zgrep <span class="string">&quot;^#&quot;</span> Mus_musculus.GRCm38.75.gtf.gz; zgrep -v <span class="string">&quot;^#&quot;</span> Mus_musculus.GRCm38.75.gtf.gz | sort -k1,1 -k4,4n) | bgzip &gt; Mus_musculus.GRCm38.75.gtf.bgz</span></span><br></pre></td></tr></table></figure>
<h3 id="13-1-2-Indexing-Files-with-Tabix">13.1.2 Indexing Files with Tabix</h3>
<p>完成了 BGZF 压缩后，我们可以使用 tabix 命令行工具来进行 index。使用 tabix 来 indexing 标准的生信格式是很简单的，tabix 有对于 GTF/GFF, SAM, VCF, PSL 等格式的选项。我们能通过 -p 参数来index 上述格式的数据。因此，我们可以对上面生成给的 BGZF 文件进行 index</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tabix -p gff Mus_musculus.GRCm38.75.gtf.bgz</span></span><br></pre></td></tr></table></figure>
<p>我们注意到，tabix 会生成一个后缀为 tbi 的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls *tbi</span></span><br><span class="line">Mus_musculus.GRCm38.75.gtf.bgz.tbi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="13-1-3-Using-Tabix">13.1.3 Using Tabix</h3>
<p>一旦我们的 tab 分隔的文件采用 Tabix 进行index 了，我们就可以使用 tabix 命令来进行检索。例如，我们想查找在 16号染色体 23,146,536  to 23,158,028 区间的 features。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tabix Mus_musculus.GRCm38.75.gtf.bgz 16:23146536-23158028 | head -n3</span></span><br><span class="line">16      protein_coding  exon    23146536        23146641        .       +       .       gene_id &quot;ENSMUSG00000022878&quot;; transcript_id &quot;ENSMUST00000023593&quot;; exon_number &quot;1&quot;; gene_name &quot;Adipoq&quot;; gene_source &quot;ensembl_havana&quot;; gene_biotype &quot;protein_coding&quot;; transcript_name &quot;Adipoq-001&quot;; transcript_source &quot;ensembl_havana&quot;; tag &quot;CCDS&quot;; ccds_id &quot;CCDS28075&quot;; exon_id &quot;ENSMUSE00000131550&quot;;</span><br><span class="line">16      protein_coding  gene    23146536        23158028        .       +       .       gene_id &quot;ENSMUSG00000022878&quot;; gene_name &quot;Adipoq&quot;; gene_source &quot;ensembl_havana&quot;; gene_biotype &quot;protein_coding&quot;;</span><br><span class="line">16      protein_coding  transcript      23146536        23158028        .       +       .       gene_id &quot;ENSMUSG00000022878&quot;; transcript_id &quot;ENSMUST00000023593&quot;; gene_name &quot;Adipoq&quot;; gene_source &quot;ensembl_havana&quot;; gene_biotype &quot;protein_coding&quot;; transcript_name &quot;Adipoq-001&quot;; transcript_source &quot;ensembl_havana&quot;; tag &quot;CCDS&quot;; ccds_id &quot;CCDS28075&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以重定向到一个文件中，或者后面接别的命令。例如我们可以用 awk 来提取含有 “exon&quot; 字段的 feature （？这个我也不知道，还是忘了）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tabix Mus_musculus.GRCm38.75.gtf.bgz 16:23146536-23158028  | awk <span class="string">&#x27;$3 ~ /exon/ &#123;print&#125;&#x27;</span></span></span><br><span class="line">16      protein_coding  exon    23146536        23146641        .       +       .       gene_id &quot;ENSMUSG00000022878&quot;; transcript_id &quot;ENSMUST00000023593&quot;; exon_number &quot;1&quot;; gene_name &quot;Adipoq&quot;; gene_source &quot;ensembl_havana&quot;; gene_biotype &quot;protein_coding&quot;; transcript_name &quot;Adipoq-001&quot;; transcript_source &quot;ensembl_havana&quot;; tag &quot;CCDS&quot;; ccds_id &quot;CCDS28075&quot;; exon_id &quot;ENSMUSE00000131550&quot;;</span><br><span class="line">16      protein_coding  exon    23146646        23146734        .       +       .       gene_id &quot;ENSMUSG00000022878&quot;; transcript_id &quot;ENSMUST00000171309&quot;; exon_number &quot;1&quot;; gene_name &quot;Adipoq&quot;; gene_source &quot;ensembl_havana&quot;; gene_biotype &quot;protein_coding&quot;; transcript_name &quot;Adipoq-002&quot;; transcript_source &quot;havana&quot;; exon_id &quot;ENSMUSE00000875966&quot;; tag &quot;cds_end_NF&quot;; tag &quot;mRNA_end_NF&quot;;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h2 id="13-2-Introducing-Relational-Databases-Through-SQLite">13.2 Introducing Relational Databases Through SQLite</h2>
<p>很多标准的生信数据格式（GTF/GFF, BED, VCF/BCF, SAM/BAM）其实都是将表格式的数据存储在文本文件中。而普通文本文件内部没有结果，和其他表格内容也没有关联。当我们能使用 unix’s join 命令，还有 R’s match() 和 merge() 函数来合并多个表格的内容，这些文件本身却无法建立表格之间的联系。</p>
<p>这里可以采用关系型数据库。在这一章节中，我们可以学习一个关系型数据库管理系统，称为 SQLite。</p>
<p>这里使用 SQLite 的理由是，它不需要任何启动 ，你可以用最快的时间进行检索，花最少的时间用在 configuring 和 administrating database。与之相对，其他的数据库系统，比如 MySQL 和  PostgreSQL 仅仅是启动和运行就需要很多的配置工作。虽然 SQLite 没有大型数据库系统强大，但是它对于GB级别的数据库运行良好。</p>
<p>如果想在生信分析中，建立一个关系型数据库管理系统，SQLite 就够了。</p>
<h3 id="13-2-1-When-to-Use-Relational-Databases-in-Bioinformatics">13.2.1 When to Use Relational Databases in Bioinformatics</h3>
<p>事实上，你需要和数据库打交道的需求并不高，理由有两个。第一，很多大型生信数据库提供了用户友好的图形化界面，用于获取数据。第二，对于很多生信任务，采用关系型数据库并不是一个最佳方案。</p>
<p><strong>关系型数据库是设计用来存储和管理多个表中的记录，通过用户需要添加/更新新记录，并进行检索。</strong></p>
<p>为了让你知道什么时候适合使用关系型数据，我们可以比较处理两种不同类型的数据的情况：一套 gene models ，一套测序的 alignment data</p>
<h4 id="Adding-and-Merging-Data">Adding and Merging Data</h4>
<p>假设我们需要合并一个新的 gene models (这是啥?) 进入到现存的 gene models 的数据库中。简单地合并是不合适地，因为我们可以会导致 exons, gene identifiers, gene names 等出现重复。这种数据库合并前需要判断重复。</p>
<p>相反，当我们合并两个 alignment files，我们可以直接合并，不用关心数据结构和一致性。因为每个比对结果都是特定的某个实验结果。也就是说，alignment data 的特性使它没有采用特殊的merge命令的需求。</p>
<h4 id="Updating-Data">Updating Data</h4>
<p>假设你的一个同事运行了一个新版本的 gene finding software。处理了一些数据后，你生成不同于之前的 gene models。经过了仔细的检查后，你发现新的 gene models 更好，然后你想将所有原来的 gene models 更新为 new models’ coordinates。就像是 merging data, 这种更新操作在数据库中更简单。</p>
<p>整个没看懂</p>
<h4 id="Querying-data">Querying data</h4>
<blockquote>
<p>irst,  SQL  acts  as  a  language  you  can  use  to  specify  anytype of query. Second, unlike Python and R, SQL is a declarative language, mean‐ing  you  state  what  you  want,  not  how  to  get  it  (the  RDBMS  implements  this)</p>
</blockquote>
<p>但是通过 samtools view 对 indexed BAM file 进行检索很快，比你先把数据导入到数据库中，再使用SQL 检索快得多。</p>
<p>我感觉，作者的意思大概就是说在这里，数据库的操作基本用不上。数据库适用于<strong>数据量较小</strong>，<strong>整理好</strong>（refined）的数据。</p>
<h3 id="13-2-2-Installing-SQLite">13.2.2 Installing SQLite</h3>
<h3 id="13-2-3-Exploring-SQLite-Databases-with-the-Command-Line-Interface">13.2.3 Exploring SQLite Databases with the Command-Line Interface</h3>
<p>我们先以 <em>gwascat.db</em> 作为一个例子数据库。这是一个 SQLite 数据库，包括了GWAS的东西。</p>
<p>可以通过下面的命令互动式操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; .tables #查看表</span><br><span class="line">gwascat</span><br><span class="line"></span><br><span class="line">sqlite&gt; .schema #查看表和表结构</span><br><span class="line">CREATE TABLE gwascat(</span><br><span class="line">id integer PRIMARY KEY NOT NULL,</span><br><span class="line">dbdate text,</span><br><span class="line">pubmedid integer,</span><br><span class="line">author text,</span><br><span class="line">date text,</span><br><span class="line">journal text,</span><br><span class="line"></span><br><span class="line">sqlite&gt; .exit #退出</span><br></pre></td></tr></table></figure>
<p><img src="57.png" alt="57"></p>
<p>sqlite 每一列允许有多种数据类型，但是会有一个推荐的数据类型，而且会像R语言一样尽可能地转成推荐的数据类型。</p>
<p>总共有5种数据类型：</p>
<ul>
<li>text</li>
<li>integer</li>
<li>real</li>
<li>NULL，used for missing data, or no value</li>
<li>BLOB, which stands for binary large object, and stores any type of object as bytes</li>
</ul>
<h3 id="13-2-4-Querying-Out-Data-The-Almighty-SELECT-Command">13.2.4 Querying Out Data: The Almighty SELECT Command</h3>
<p>SELECT 最简单的用法，所有语句必须以<strong>分号</strong>结束。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT * FROM gwascat;</span></span><br></pre></td></tr></table></figure>
<p>如果你输入命令的时候输入错误，你不能用 ctrl+c，可以用 ctrl + u 清空输入的所有代码。但是如果已经开始运行了，你可以输入一个错误的指定（以分号结束）让它报错（测试过了，直接输入一个分号就行）。</p>
<p>你也可以直接使用命令行的方式，可以通过 -separator 指定输出的分隔符（“,” for CSV , “\t” ）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sqlite3 gwascat.db <span class="string">&quot;SELECT * FROM gwascat&quot;</span> &gt; results.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> head -n 1 results.txt</span></span><br><span class="line">1|2014-08-02|24388013|Ferreira MA|2013-12-30|J Allergy Clin Immunol|http://www.ncbi.nlm.nih.gov/pubmed/24388013|Genome-wide association analysis identifies 11 </span><br></pre></td></tr></table></figure>
<h4 id="Limiting-results-with-LIMIT">Limiting results with LIMIT</h4>
<p>LIMIT 限制输出的行数。</p>
<p>但是，不像存储在文件中顺序是固定的，但是<strong>数据库里的行的顺序是不固定的</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT * FROM gwascatLIMIT 2;</span></span><br><span class="line">id|dbdate|pubmedid|author|date|journal| [...]</span><br><span class="line">1|08/02/2014|24388013|Ferreira MA|12/30/2013|J Allergy Clin Immunol| [...]</span><br><span class="line">2|08/02/2014|24388013|Ferreira MA|12/30/2013|J Allergy Clin Immunol| [...]</span><br></pre></td></tr></table></figure>
<h4 id="Selecting-columns-with-SELECT">Selecting columns with SELECT</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT trait, chrom, position, strongest_risk_snp, pvalue FROM gwascat LIMIT 5</span></span><br><span class="line">   ...&gt; ;</span><br><span class="line">Asthma and hay fever|6|32658824|rs9273373|4.0e-14</span><br><span class="line">Asthma and hay fever|4|38798089|rs4833095|5.0e-12</span><br><span class="line">Asthma and hay fever|5|111131801|rs1438673|3.0e-11</span><br><span class="line">Asthma and hay fever|2|102350089|rs10197862|4.0e-11</span><br><span class="line">Asthma and hay fever|17|39966427|rs7212938|4.0e-10</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>改一下设置，显示更清晰</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> .header on</span></span><br><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> .mode column</span></span><br><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT trait, chrom, position, strongest_risk_snp, pvalue FROM gwascat LIMIT 5;</span></span><br><span class="line">trait                 chrom  position   strongest_risk_snp  pvalue</span><br><span class="line">--------------------  -----  ---------  ------------------  -------</span><br><span class="line">Asthma and hay fever  6      32658824   rs9273373           4.0e-14</span><br><span class="line">Asthma and hay fever  4      38798089   rs4833095           5.0e-12</span><br><span class="line">Asthma and hay fever  5      111131801  rs1438673           3.0e-11</span><br><span class="line">Asthma and hay fever  2      102350089  rs10197862          4.0e-11</span><br><span class="line">Asthma and hay fever  17     39966427   rs7212938           4.0e-10</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Ordering-rows-with-ORDER-BY">Ordering rows with ORDER BY</h4>
<p>上面得到的结果顺序是不定的，可以通过 ORDER BY 排好序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT author, trait, journal FROM gwascat ORDER BY author LIMIT 5;</span><br><span class="line">author   trait                                                            journal</span><br><span class="line">-------  ---------------------------------------------------------------  ------------------</span><br><span class="line">Aberg K  Antipsychotic-induced QTc interval prolongation                  Pharmacogenomics J</span><br><span class="line">Aberg K  Antipsychotic-induced QTc interval prolongation                  Pharmacogenomics J</span><br><span class="line">Aberg K  Antipsychotic-induced QTc interval prolongation                  Pharmacogenomics J</span><br><span class="line">Aberg K  Response to antipsychotic therapy (extrapyramidal side effects)  Biol Psychiatry</span><br><span class="line">Aberg K  Response to antipsychotic therapy (extrapyramidal side effects)  Biol Psychiatry</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果以<strong>降序</strong>排列，增加 DESC</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT author, trait, journal FROM gwascat ORDER BY author DESC LIMIT 5;</span></span><br><span class="line">author             trait                                        journal</span><br><span class="line">-----------------  -------------------------------------------  ----------------------</span><br><span class="line">van der Zanden LF  Hypospadias                                  Nat Genet</span><br><span class="line">van der Valk RJ    Fractional exhaled nitric oxide (childhood)  J Allergy Clin Immunol</span><br><span class="line">van der Valk RJ    Fractional exhaled nitric oxide (childhood)  J Allergy Clin Immunol</span><br><span class="line">van der Valk RJ    Fractional exhaled nitric oxide (childhood)  J Allergy Clin Immunol</span><br><span class="line">van der Valk RJ    Fractional exhaled nitric oxide (childhood)  J Allergy Clin Immunol</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为 sqlite 的列没有固定数据类型，因此使用 ORDER BY 遇到混合格式会按照下面的顺序排序：<strong>NULL values, integer and real values, text values, blob values</strong>。需要特别注意的是，NULL 永远排在前面，无论是顺序还是逆序，我们可以通过以p-value 排序看一下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT trait, chrom, position, strongest_risk_snp, pvalue FROM gwascat ORDER BY pvalue LIMIT 5;</span></span><br><span class="line">trait          chrom  position  strongest_risk_snp  pvalue</span><br><span class="line">-------------  -----  --------  ------------------  ------</span><br><span class="line">Brain imaging                   rs10932886</span><br><span class="line">Brain imaging                   rs429358</span><br><span class="line">Brain imaging                   rs7610017</span><br><span class="line">Brain imaging                   rs6463843</span><br><span class="line">Brain imaging                   rs2075650</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下一章节，我们会讲到如何使用 WHICH 语句来剔除 NULL 行。</p>
<p>我们可以 ORDER BY 来查看异常值，比如 p-value 应该是在0和1之间，我们按逆序排序，查看有没有超过1的。发现有两个错误（估计是 9e-7 ，误写成了9e7）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT trait, strongest_risk_snp, pvalue FROM gwascat ORDER BY pvalue DESC LIMIT 5;</span></span><br><span class="line">trait                                       strongest_risk_snp  pvalue</span><br><span class="line">------------------------------------------  ------------------  ----------</span><br><span class="line">Serum protein levels (sST2)                 rs206548            90000000.0</span><br><span class="line">Periodontitis (Mean PAL)                    rs12050161          4000000.0</span><br><span class="line">Coronary artery disease or ischemic stroke  rs964184            2.0e-05</span><br><span class="line">Lipid traits                                rs10158897          9.0e-06</span><br><span class="line">Rheumatoid arthritis                        rs8032939           9.0e-06</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Filtering-which-rows-with-WHERE">Filtering which rows with WHERE</h4>
<p>这里 = 和 == 都可以。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT chrom, position, trait, strongest_risk_snp, pvalue FROM gwascat WHERE strongest_risk_snp = <span class="string">&quot;rs429358&quot;</span>;</span></span><br><span class="line">chrom  position  trait                           strongest_risk_snp  pvalue</span><br><span class="line">-----  --------  ------------------------------  ------------------  -------</span><br><span class="line">19     44908684  Alzheimer&#x27;s disease biomarkers  rs429358            5.0e-14</span><br><span class="line">19     44908684  Alzheimer&#x27;s disease biomarkers  rs429358            1.0e-06</span><br><span class="line">                 Brain imaging                   rs429358</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意大小写问题，比如你可以用 lower() 函数先都转为小写 (more robust)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT chrom, position, trait, strongest_risk_snp, pvalue FROM gwascat WHERE lower(strongest_risk_snp) = <span class="string">&quot;rs429358&quot;</span>;</span></span><br><span class="line">chrom  position  trait                           strongest_risk_snp  pvalue</span><br><span class="line">-----  --------  ------------------------------  ------------------  -------</span><br><span class="line">19     44908684  Alzheimer&#x27;s disease biomarkers  rs429358            5.0e-14</span><br><span class="line">19     44908684  Alzheimer&#x27;s disease biomarkers  rs429358            1.0e-06</span><br><span class="line">                 Brain imaging                   rs429358</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其他比较符号，下面的图漏了一个 + （positive）</p>
<p><img src="58.png" alt="57"></p>
<p>比如，我们可以通过 AND OR 创建更复杂的表达式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT chrom, position, trait, strongest_risk_snp, pvalue</span></span><br><span class="line">   ...&gt; FROM gwascat WHERE chrom = &quot;22&quot; AND pvalue &lt; 10e-15;</span><br><span class="line">chrom  position  trait                                             strongest_risk_snp  pvalue</span><br><span class="line">-----  --------  ------------------------------------------------  ------------------  --------</span><br><span class="line">22     39351666  Rheumatoid arthritis                              rs909685            1.0e-16</span><br><span class="line">22     21577779  HDL cholesterol                                   rs181362            4.0e-18</span><br><span class="line">22     39146287  Multiple myeloma                                  rs877529            8.0e-16</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要指出的是，通过设定 colname = NULL 没用，这里需要用 IS 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT chrom, position, trait, strongest_risk_snp, pvalue</span></span><br><span class="line">   ...&gt; FROM gwascat ORDER BY pvalue LIMIT 5;</span><br><span class="line">chrom  position  trait          strongest_risk_snp  pvalue</span><br><span class="line">-----  --------  -------------  ------------------  ------</span><br><span class="line">                 Brain imaging  rs10932886</span><br><span class="line">                 Brain imaging  rs429358</span><br><span class="line">                 Brain imaging  rs7610017</span><br><span class="line">                 Brain imaging  rs6463843</span><br><span class="line">                 Brain imaging  rs2075650</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过 WHERE pvalue IS NOT NULL 来剔除空值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT chrom, position, trait, strongest_risk_snp, pvalue</span></span><br><span class="line">   ...&gt; FROM gwascat WHERE pvalue IS NOT NULL ORDER BY pvalue LIMIT 5;</span><br><span class="line">chrom  position   trait                                      strongest_risk_snp  pvalue</span><br><span class="line">-----  ---------  -----------------------------------------  ------------------  ------</span><br><span class="line">16     56959412   HDL cholesterol                            rs3764261           0.0</span><br><span class="line">10     122454932  Age-related macular degeneration           rs10490924          0.0</span><br><span class="line">1      196710325  Age-related macular degeneration           rs10737680          0.0</span><br><span class="line">4      9942428    Urate levels                               rs12498742          0.0</span><br><span class="line">6      43957789   Vascular endothelial growth factor levels  rs4513773           0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>OR 语句</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT chrom, position, strongest_risk_snp, pvalue FROM gwascat</span></span><br><span class="line">   ...&gt; WHERE (chrom = &quot;1&quot; OR chrom = &quot;2&quot; OR chrom = &quot;3&quot;)</span><br><span class="line">   ...&gt; AND pvalue &lt; 10e-11 ORDER BY pvalue LIMIT 5;</span><br><span class="line">chrom  position   strongest_risk_snp  pvalue</span><br><span class="line">-----  ---------  ------------------  ---------------------</span><br><span class="line">1      196710325  rs10737680          0.0</span><br><span class="line">2      233763993  rs6742078           4.94065645841247e-324</span><br><span class="line">3      165773492  rs1803274           6.0e-262</span><br><span class="line">1      196690107  rs1061170           1.0e-261</span><br><span class="line">2      73591809   rs13391552          5.0e-252</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更简单的方式是用 IN (NOT IN)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT chrom, position, strongest_risk_snp, pvalue FROM gwascat</span><br><span class="line">   ...&gt; WHERE chrom IN (&quot;1&quot;, &quot;2&quot;, &quot;3&quot;) AND pvalue &lt; 10e-11</span><br><span class="line">   ...&gt; ORDER BY pvalue LIMIT 5;</span><br><span class="line">chrom  position   strongest_risk_snp  pvalue</span><br><span class="line">-----  ---------  ------------------  ---------------------</span><br><span class="line">1      196710325  rs10737680          0.0</span><br><span class="line">2      233763993  rs6742078           4.94065645841247e-324</span><br><span class="line">3      165773492  rs1803274           6.0e-262</span><br><span class="line">1      196690107  rs1061170           1.0e-261</span><br><span class="line">2      73591809   rs13391552          5.0e-252</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BETWEEN AND 语句 类似于 X &gt;= AND X &lt;=</p>
<p>但是这种方式没有别的方法效率高，比如 Tabix, BedTools，GenomicRanges。如果你在速度上遇到了瓶颈，你可以用上面的那些工具。</p>
<p>另外一个选项是应用 <em>binning</em> scheme，这会将 features 分配到特定的 bins 中。为了查看某个区域的 features，可以先计算这些features 可能会包括在哪些 bins 中。UCSC Genome Browser 就是采用了这种系统。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT chrom, position, strongest_risk_snp, pvalue</span><br><span class="line">   ...&gt; FROM gwascat WHERE chrom &#x3D; &quot;22&quot;</span><br><span class="line">   ...&gt; AND position BETWEEN 24000000 AND 25000000</span><br><span class="line">   ...&gt; AND pvalue IS NOT NULL ORDER BY pvalue LIMIT 5;</span><br><span class="line">chrom  position  strongest_risk_snp  pvalue</span><br><span class="line">-----  --------  ------------------  --------</span><br><span class="line">22     24603137  rs2073398           1.0e-109</span><br><span class="line">22     24594246  rs4820599           7.0e-53</span><br><span class="line">22     24600663  rs5751902           8.0e-20</span><br><span class="line">22     24594246  rs4820599           4.0e-11</span><br><span class="line">22     24186073  rs8141797           2.0e-09</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="13-2-5-SQLite-Functions">13.2.5 SQLite Functions</h3>
<p>有时我们需要从现有的列中创建新列。我们采用 SQLite functions 和 operators 来实现这一点，然后使用 AS 给新列起名。</p>
<p>这里 <code>||</code> 是连接符，连接两个字符串。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT lower(trait) AS trait,</span></span><br><span class="line">   ...&gt; &quot;chr&quot; || chrom || &quot;:&quot; || position AS region FROM gwascat LIMIT 5;</span><br><span class="line">trait                 region</span><br><span class="line">--------------------  --------------</span><br><span class="line">asthma and hay fever  chr6:32658824</span><br><span class="line">asthma and hay fever  chr4:38798089</span><br><span class="line">asthma and hay fever  chr5:111131801</span><br><span class="line">asthma and hay fever  chr2:102350089</span><br><span class="line">asthma and hay fever  chr17:39966427</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设我们面临另一个需求，是将空值转化为NA（输出到R中）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT ifnull(chrom, <span class="string">&quot;NA&quot;</span>) AS chrom, ifnull(position, <span class="string">&quot;NA&quot;</span>) AS position,</span></span><br><span class="line">   ...&gt; strongest_risk_snp, ifnull(pvalue, &quot;NA&quot;) AS pvalue FROM gwascat</span><br><span class="line">   ...&gt; WHERE strongest_risk_snp = &quot;rs429358&quot;;</span><br><span class="line">chrom  position  strongest_risk_snp  pvalue</span><br><span class="line">-----  --------  ------------------  -------</span><br><span class="line">19     44908684  rs429358            5.0e-14</span><br><span class="line">19     44908684  rs429358            1.0e-06</span><br><span class="line">NA     NA        rs429358            NA</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面我们会简单接触到如果与R互作（会自动将NULL转化为NA）。</p>
<p>下面是一些有用的函数</p>
<p><img src="59.png" alt="57"></p>
<p><img src="60.png" alt="57"></p>
<h3 id="13-2-6-SQLite-Aggregate-Functions">13.2.6 SQLite Aggregate Functions</h3>
<p>另一种函数将查询得到的结果作为输入，然后返回一个单独的值。比如 count() (某个字段非空的记录数)</p>
<p>count(*) 统计数据库行数（不考虑NULL）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT count(*) FROM gwascat;</span></span><br><span class="line">count(*)</span><br><span class="line">--------</span><br><span class="line">17290</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>count(colname) 剔除 NULL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT count(pvalue) FROM gwascat;</span><br><span class="line">count(pvalue)</span><br><span class="line">-------------</span><br><span class="line">17279</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT count(*) - count(pvalue) AS number_of_null_pvalues FROM gwascat;</span><br><span class="line">number_of_null_pvalues</span><br><span class="line">----------------------</span><br><span class="line">11</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select &quot;2007&quot; AS year, count(*) AS number_entries</span><br><span class="line">   ...&gt; from gwascat WHERE date BETWEEN &quot;2007-01-01&quot; AND &quot;2008-01-01&quot;;</span><br><span class="line">year  number_entries</span><br><span class="line">----  --------------</span><br><span class="line">2007  435</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>常见的统计命令</p>
<p><img src="61.png" alt="57"></p>
<p>下面这段话没看懂</p>
<p><img src="62.png" alt="57"></p>
<p>aggregate function 的一个好处是允许事先剔除重复值（通过 DISTINCT）。比如，假如我们要统计去重后的 rs 号的数目。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT count(DISTINCT strongest_risk_snp) AS unique_rs FROM gwascat;</span><br><span class="line">unique_rs</span><br><span class="line">---------</span><br><span class="line">13619</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Grouping-rows-with-GROUP-BY">Grouping rows with GROUP BY</h4>
<p>很多的数据库操作和R语句很相似。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT chrom, count(*) FROM gwascat GROUP BY chrom;</span><br><span class="line">chrom  count(*)</span><br><span class="line">-----  --------</span><br><span class="line">       70</span><br><span class="line">1      1458</span><br><span class="line">10     930</span><br><span class="line">11     988</span><br><span class="line">12     858</span><br><span class="line">13     432</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>按出现次数从多到少</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT chrom, count(*) as nhits FROM gwascat GROUP BY chrom</span><br><span class="line">   ...&gt; ORDER BY nhits DESC;</span><br><span class="line">chrom  nhits</span><br><span class="line">-----  -----</span><br><span class="line">6      1658</span><br><span class="line">1      1458</span><br><span class="line">2      1432</span><br><span class="line">3      1033</span><br><span class="line">11     988</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> select strongest_risk_snp, count(*) AS count</span></span><br><span class="line">   ...&gt; FROM gwascat GROUP BY strongest_risk_snp</span><br><span class="line">   ...&gt; ORDER BY count DESC LIMIT 5;</span><br><span class="line">strongest_risk_snp  count</span><br><span class="line">------------------  -----</span><br><span class="line">rs1260326           36</span><br><span class="line">rs4420638           30</span><br><span class="line">rs1800562           28</span><br><span class="line">rs7903146           27</span><br><span class="line">rs964184            25</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select strongest_risk_snp, strongest_risk_allele, count(*) AS count</span><br><span class="line">   ...&gt; FROM gwascat GROUP BY strongest_risk_snp, strongest_risk_allele</span><br><span class="line">   ...&gt; ORDER BY count DESC LIMIT 10;</span><br><span class="line">strongest_risk_snp  strongest_risk_allele  count</span><br><span class="line">------------------  ---------------------  -----</span><br><span class="line">rs1260326           T                      22</span><br><span class="line">rs2186369           G                      22</span><br><span class="line">rs1800562           A                      20</span><br><span class="line">rs909674            C                      20</span><br><span class="line">rs11710456          G                      19</span><br><span class="line">rs7903146           T                      19</span><br><span class="line">rs4420638           G                      18</span><br><span class="line">rs964184            G                      15</span><br><span class="line">rs11847263          G                      14</span><br><span class="line">rs3184504           T                      12</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假如我们想按照年份排序，首先我们用substr() 提取日期的前4位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT substr(date, 1, 4) AS year FROM gwascat GROUP BY year;</span><br><span class="line">year</span><br><span class="line">----</span><br><span class="line">2005</span><br><span class="line">2006</span><br><span class="line">2007</span><br><span class="line">2008</span><br><span class="line">2009</span><br><span class="line">2010</span><br><span class="line">2011</span><br><span class="line">2012</span><br><span class="line">2013</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT substr(date, 1, 4) AS year,</span></span><br><span class="line">   ...&gt; round(avg(pvalue_mlog), 4) AS mean_log_pvalue,</span><br><span class="line">   ...&gt; count(pvalue_mlog) AS n</span><br><span class="line">   ...&gt; FROM gwascat GROUP BY year;</span><br><span class="line">year  mean_log_pvalue  n</span><br><span class="line">----  ---------------  ----</span><br><span class="line">2005  6.2474           2</span><br><span class="line">2006  7.234            8</span><br><span class="line">2007  11.0973          434</span><br><span class="line">2008  11.5054          971</span><br><span class="line">2009  12.6279          1323</span><br><span class="line">2010  13.0641          2528</span><br><span class="line">2011  13.3437          2349</span><br><span class="line">2012  9.6976           4197</span><br><span class="line">2013  10.3643          5406</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>很重要的一点在于 where 语句运行早于 grouping，如果你想过滤 groups，你可以使用 having 语句。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT substr(date, 1, 4) AS year,</span></span><br><span class="line">   ...&gt; round(avg(pvalue_mlog), 4) AS mean_log_pvalue,</span><br><span class="line">   ...&gt; count(pvalue_mlog) AS n</span><br><span class="line">   ...&gt; FROM gwascat GROUP BY year</span><br><span class="line">   ...&gt; HAVING count(pvalue_mlog) &gt; 10;</span><br><span class="line">year  mean_log_pvalue  n</span><br><span class="line">----  ---------------  ----</span><br><span class="line">2007  11.0973          434</span><br><span class="line">2008  11.5054          971</span><br><span class="line">2009  12.6279          1323</span><br><span class="line">2010  13.0641          2528</span><br><span class="line">2011  13.3437          2349</span><br><span class="line">2012  9.6976           4197</span><br><span class="line">2013  10.3643          5406</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="13-2-7-Subqueries">13.2.7 Subqueries</h3>
<p>如果我们想查找每个研究找到的显著位点的数目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT substr(date, 1, 4) AS year, author, pubmedid,</span><br><span class="line">   ...&gt; count(*) AS num_assoc FROM gwascat GROUP BY pubmedid</span><br><span class="line">   ...&gt; LIMIT 5;</span><br><span class="line">year  author         pubmedid  num_assoc</span><br><span class="line">----  -------------  --------  ---------</span><br><span class="line">2005  Klein RJ       15761122  1</span><br><span class="line">2005  Maraganore DM  16252231  1</span><br><span class="line">2006  Arking DE      16648850  1</span><br><span class="line">2006  Fung HC        17052657  3</span><br><span class="line">2006  Dewan A        17053108  1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果我们做得深一点，我们想看每个期刊每年找到的显著位点的平均数。在 SQL 的行话中，这就是说我们需要用到之前的结果，再进一步按年份分组，然后使用 avg() 计算均值（开始套娃）。这种嵌套式的query 称为 <em>subqueries</em>。我们可以通过<strong>括号</strong>来将前面的语句括起来，然后通过 FROM 语句将其视为一个数据库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> SELECT year, avg(num_assoc)</span></span><br><span class="line">   ...&gt; FROM (SELECT substr(date, 1, 4) AS year,</span><br><span class="line">   ...&gt;     author,</span><br><span class="line">   ...&gt;     count(*) AS num_assoc</span><br><span class="line">   ...&gt;     FROM gwascat GROUP BY pubmedid)</span><br><span class="line">   ...&gt; GROUP BY year;</span><br><span class="line">year  avg(num_assoc)</span><br><span class="line">----  ----------------</span><br><span class="line">2005  1.0</span><br><span class="line">2006  1.6</span><br><span class="line">2007  5.87837837837838</span><br><span class="line">2008  7.64566929133858</span><br><span class="line">2009  6.90625</span><br><span class="line">2010  9.21660649819495</span><br><span class="line">2011  7.4968152866242</span><br><span class="line">2012  13.4536741214058</span><br><span class="line">2013  16.605504587156</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="13-2-8-Organizing-Relational-Databases-and-Joins">13.2.8 Organizing Relational Databases and Joins</h3>
<p>如果你仔细看 gwascat 表格，你会发现有很多的冗余。一个研究（看pubmedid）可能会找到多个显著的SNP，一个SNP占据一行，这些行除了SNP名称不一样，其他列都是重复的。如下图</p>
<p><img src="63.png" alt="63"></p>
<p>当你直接从表格中复制数据时，这种冗余是很常见的。对于很大的数据库，这种冗余会占据很多的额外空间。</p>
<p>在我们提及如何联合使用多个表的信息前，我们先要理解关系型数据库<strong>管理数据的哲学</strong>，来避免上面的这种情况（<em>spreadsheet syndrome</em>）。这个哲学就是 <em>database normalization</em>。</p>
<p>首先<strong>每个字段只能存储一个值</strong>。下面这个assocs 表就破坏了这个规则。这种情况下，比如你想检索 rs4833095 在不在这个表里，你不能再用 SQL 语法如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> assoc <span class="keyword">WHERE</span> strongest_risk_snp <span class="operator">=</span> &quot;rs4833095&quot;</span><br></pre></td></tr></table></figure>
<p><img src="64.png" alt="63"></p>
<p>我们可以把多个切断切分成多行，如下图</p>
<p><img src="66.png" alt=""></p>
<p>但是，这又造成了重复冗余，我们可以看懂 pubmedid, year, journal 是重复的。这种重复是可以避免的，而且year 和 journal 字段是依赖于 pubmedid 字段的。</p>
<p>一个更好的管理数据的方式是，将这个表格切分为两个表格（一个是GWAS结果，一个是study信息）（ trait 还有冗余，可以把 trait 也放到 studies 表中，但是逻辑就不是很清晰了。因此从逻辑上讲，GWAS 表中应该要注明是哪个性状）</p>
<p><img src="67.png" alt=""></p>
<p>现在我们有两个表了，我们可以同时查询两个表格的信息。</p>
<h4 id="Inner-joins">Inner joins</h4>
<p>这里已经把这两个表放在 joins.db 中了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sqlite3 joins.db</span><br><span class="line">SQLite version 3.33.0 2020-08-14 13:23:32</span><br><span class="line">Enter &quot;.help&quot; for usage hints.</span><br><span class="line">sqlite&gt; .mode columns</span><br><span class="line">sqlite&gt; .header on</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>先查看一下两个表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT * FROM assocs;</span><br><span class="line">id  study_id  trait              strongest_risk_snp</span><br><span class="line">--  --------  -----------------  ------------------</span><br><span class="line">1   1         Asthma, hay fever  rs9273373</span><br><span class="line">2   1         Asthma, hay fever  rs4833095</span><br><span class="line">3   1         Asthma, hay fever  rs1438673</span><br><span class="line">4   2         Hypertension       rs2820037</span><br><span class="line">5   2         Crohn&#39;s disease    rs6596075</span><br><span class="line">6             Urate levels       rs12498742</span><br><span class="line"></span><br><span class="line">sqlite&gt; SELECT * FROM studies;</span><br><span class="line">id  pubmedid  year  journal</span><br><span class="line">--  --------  ----  --------------</span><br><span class="line">1   24388013  2013  J Allergy</span><br><span class="line">2   17554300  2007  Nature</span><br><span class="line">3   16252231  2005  Am J Hum Genet</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们最常用的连接方式就是内连接。</p>
<p>连接条件采用 <strong>on</strong> 选项</p>
<p>由于两个表中可能含有相同名称的列名，提取列一律采用<strong>表名.列名</strong> 的方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT * FROM assocs INNER JOIN studies ON assocs.study_id &#x3D; studies.id;</span><br><span class="line">id  study_id  trait              strongest_risk_snp  id  pubmedid  year  journal</span><br><span class="line">--  --------  -----------------  ------------------  --  --------  ----  ---------</span><br><span class="line">1   1         Asthma, hay fever  rs9273373           1   24388013  2013  J Allergy</span><br><span class="line">2   1         Asthma, hay fever  rs4833095           1   24388013  2013  J Allergy</span><br><span class="line">3   1         Asthma, hay fever  rs1438673           1   24388013  2013  J Allergy</span><br><span class="line">4   2         Hypertension       rs2820037           2   17554300  2007  Nature</span><br><span class="line">5   2         Crohn&#39;s disease    rs6596075           2   17554300  2007  Nature</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>提取部分列（使用 AS 重命名）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT studies.id AS study_id, assocs.id AS assoc_id, trait, year</span><br><span class="line">   ...&gt; FROM assocs INNER JOIN studies ON assocs.study_id &#x3D; studies.id;</span><br><span class="line">study_id  assoc_id  trait              year</span><br><span class="line">--------  --------  -----------------  ----</span><br><span class="line">1         1         Asthma, hay fever  2013</span><br><span class="line">1         2         Asthma, hay fever  2013</span><br><span class="line">1         3         Asthma, hay fever  2013</span><br><span class="line">2         4         Hypertension       2007</span><br><span class="line">2         5         Crohn&#39;s disease    2007</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看 assocs 表中的 study_id 不在 studies 表中的 id 列的行（这里用到了 subqueries）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT * FROM assocs WHERE study_id NOT IN (SELECT id FROM studies);</span><br><span class="line">id  study_id  trait         strongest_risk_snp</span><br><span class="line">--  --------  ------------  ------------------</span><br><span class="line">6             Urate levels  rs12498742</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Left-outer-joins">Left outer joins</h4>
<p>保留左边表的所有行，如果匹配不上右边的表，则右边表的字段均设置为 <strong>NULL</strong>。</p>
<p>s<strong>qlite 仅支持 left outer joins</strong>，但是其实 outer joins 还有两种类型，right outer joins （右连接，和左连接一样）和 full outer joins （全外连接返回两个表格合并的所有行）。</p>
<p>假如我们想保留 assocs 表的所有字段，无论它在不在 studies 表中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT * FROM assocs LEFT OUTER JOIN studies</span><br><span class="line">   ...&gt; ON assocs.study_id &#x3D; studies.id;</span><br><span class="line">id  study_id  trait              strongest_risk_snp  id  pubmedid  year  journal</span><br><span class="line">--  --------  -----------------  ------------------  --  --------  ----  ---------</span><br><span class="line">1   1         Asthma, hay fever  rs9273373           1   24388013  2013  J Allergy</span><br><span class="line">2   1         Asthma, hay fever  rs4833095           1   24388013  2013  J Allergy</span><br><span class="line">3   1         Asthma, hay fever  rs1438673           1   24388013  2013  J Allergy</span><br><span class="line">4   2         Hypertension       rs2820037           2   17554300  2007  Nature</span><br><span class="line">5   2         Crohn&#39;s disease    rs6596075           2   17554300  2007  Nature</span><br><span class="line">6             Urate levels       rs12498742</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="13-2-9-Writing-to-Databases">13.2.9 Writing to Databases</h3>
<p>由于我们通常都是一次性地将数据导入到生信数据库中，因此这里不将常见地修改和删除命令。</p>
<h4 id="Creating-tables">Creating tables</h4>
<p>在 gwas‐cat2table.db 中创建 study 表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sqlite3   gwas‐cat2table.db</span><br><span class="line">SQLite version 3.33.0 2020-08-14 13:23:32</span><br><span class="line">Enter &quot;.help&quot; for usage hints.</span><br><span class="line">sqlite&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建表格的基本语法是，每个字段均要设置一个偏好的数据类型（不填是 none）。</p>
<p>第一个字段通常都设置为 <code>id integer primary key</code>。每个表格均要设置一个主键，主键不能重复。</p>
<p>主键是表格的条件之一，其他还有 UNIQUE, NOT NULL, CHECK, FOREIGN KEY。</p>
<p>如果你想要创建一个复制的数据库，作者建议你看完这一章节之后，再专门看一下 SQL 的书籍。</p>
<blockquote>
<p>Thoughtfulness and planning definitely pay off when it comes to organizing a database.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tablename(</span><br><span class="line">	id integer primary key,</span><br><span class="line">	column1 column1_type,</span><br><span class="line">	column2 column2_type,  </span><br><span class="line">	...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>让我们创建一个简单的数据库，然后创建一个表格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sqlite3 practice.db</span><br><span class="line">SQLite version 3.33.0 2020-08-14 13:23:32</span><br><span class="line">Enter &quot;.help&quot; for usage hints.</span><br><span class="line">sqlite&gt; CREATE TABLE variants(</span><br><span class="line">   ...&gt;     id integerprimarykey,</span><br><span class="line">   ...&gt;     chrom text,</span><br><span class="line">   ...&gt;     start integer,</span><br><span class="line">   ...&gt;     end integer,</span><br><span class="line">   ...&gt;     strand text,</span><br><span class="line">   ...&gt;     name text);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我们可以查看到这个表格已存在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; .tables</span><br><span class="line">variants</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Inserting-records-into-tables">Inserting records into tables</h4>
<p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERTINTO tablename(column1, column2) VALUES (value1, value2);</span><br></pre></td></tr></table></figure>
<p>也可以忽略字段名（column1, column2），但是作者不建议这么做，指定字段名称更加清楚，提高<strong>可读性</strong>。</p>
<p>在之前的章节中，我们提高了主键。如果在插入的数据中，主键的值为NULL，那么数据库会自动创建一个主键（之前的主键+1，前提是主键是数字）。</p>
<p>我们可以试一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; INSERT INTO variants(id, chrom, start, end, strand, name)</span><br><span class="line">   ...&gt;  VALUES(NULL, &quot;16&quot;, 48224287, 48224287, &quot;+&quot;, &quot;rs17822931&quot;);</span><br></pre></td></tr></table></figure>
<p>查看所有记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT * FROM variants;</span><br><span class="line">id  chrom  start     end       strand  name</span><br><span class="line">--  -----  --------  --------  ------  ----------</span><br><span class="line">    16     48224287  48224287  +       rs17822931</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>额，打脸了，id 列还是空的。作者给的 id 是 1</p>
<p><img src="68.png" alt=""></p>
<h4 id="Indexing">Indexing</h4>
<p>在简单的数据库里查询很快，但是复杂的数据库里查询很慢。这种情况下，sqlite 需要遍历所有的记录。这里有一个技巧，index a column of a table。</p>
<p>数据库索引会包含一个排好序的某一列的所有元素，还有对应的行。由于索引列的元素已经排好序了，查找起来更快（就像在书的目录中找一个词 VS 在整本书里找一个词）。</p>
<p>indexs 也有缺陷，就像书添加索引会占据额外的页数，表格的索引也会占据硬盘空间。</p>
<p>创建索引很简单。这里我们给 gwascat2table.db 数据库的 assocs 表格 的 strongest_risk_snp 字段填上索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; CREATE INDEX snp_idx ON assocs(strongest_risk_snp);</span><br></pre></td></tr></table></figure>
<p>可以查看索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; .indices</span><br><span class="line">snp_idx       study_id_idx</span><br></pre></td></tr></table></figure>
<p>当你更新/插入数据，<strong>索引会自动更新</strong>。</p>
<p>你需要对外键创建索引，来提高 JOIN 速度。（这里是之前建过了）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; CREATE INDEX study_id_idx ON assocs(study_id);</span><br><span class="line">Error: index study_id_idx already exists</span><br><span class="line">sqlite&gt; .indices</span><br><span class="line">snp_idx       study_id_idx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你想要删除索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; DROP INDEX snp_idx;</span><br><span class="line">sqlite&gt; .indices</span><br><span class="line">study_id_idx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="13-2-10-Dropping-Tables-and-Deleting-Databases">13.2.10 Dropping Tables and Deleting Databases</h3>
<p>删除表格的语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE table_name</span><br></pre></td></tr></table></figure>
<p>删除数据库的方式是直接删除 db 文件</p>
<h3 id="13-2-11-Interacting-with-SQLite-from-Python">13.2.11 Interacting with SQLite from Python</h3>
<p>通常我们直接使用sqlite 进行操作。但是如果你需要将 N 多个记录导入到数据库中，或者执行非常复杂的检索操作。你可以通过 API 互动操作。这里可以查看 python 的一个API</p>
<h4 id="Connecting-to-SQLite-databases-and-creating-tables-from-Python">Connecting to SQLite databases and creating tables from Python</h4>
<p>这里我们用到了一个python的标准库，sqlite3。</p>
<p>通过python 将大块数据插入到 SQLite 数据库中很方便。下面是一个简单的例子，如果连接到一个SQL数据库，并且创立新表</p>
<p><img src="69.png" alt=""></p>
<ol>
<li>使用 connect() 方法连接上数据库。</li>
<li>当我们想和sqlite 数据库使用python的接口进行交互，我们使用一个 Cursor 对象。通过创建 Cursor 对象，我们可以直接从数据库中调取数据。</li>
<li>创建表格的sql命令</li>
<li>执行命令</li>
<li>commit 会将变化写入到数据库中。</li>
<li>停止和数据库的连接。</li>
</ol>
<p>运行命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python create_table.py</span><br></pre></td></tr></table></figure>
<p>运行后新建了一个数据库 <em>variants.db</em> 。我们可以查看一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sqlite3 variants.db</span><br><span class="line">SQLite version 3.33.0 2020-08-14 13:23:32</span><br><span class="line">Enter &quot;.help&quot; for usage hints.</span><br><span class="line">sqlite&gt; .table</span><br><span class="line">variants</span><br><span class="line">sqlite&gt; .schema</span><br><span class="line">CREATE TABLE variants(</span><br><span class="line">        id integer primary key,</span><br><span class="line">        chrom test,</span><br><span class="line">        start integer,</span><br><span class="line">        end integer,</span><br><span class="line">        strand text,</span><br><span class="line">        rsid text);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Loading-data-into-a-table-from-Python">Loading data into a table from Python</h4>
<p>下一步我们需要将一些数据导入到 variants 表格中。在这个目录中，我们已经有了一个 tab分隔的文件 variants.txt</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat variants.txt</span></span><br><span class="line">chr10   114808901       114808902       +       rs12255372</span><br><span class="line">chr9    22125502        22125503        +       rs1333049</span><br><span class="line">chr3    46414946        46414978        +       rs333</span><br><span class="line">chr2    136608645       136608646       -       rs4988235</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>导入数据的时候，有几个需要注意的地方。首先，确保<code>data loaded into the database is clean</code> 。也就说每列都有正确的数据类型，并且缺失值转化为了 NULL （在pyhon中是None）。虽然sqlite 允许多种数据类型，但还是要做到每个字段的数据类型一致。</p>
<p>现在我们把 variants.txt 的内容导入到新建的表中。一个简单的代码如下：</p>
<p><img src="70.png" alt="70"></p>
<p><img src="71.png" alt="70"></p>
<ol>
<li>
<p>首先，我们用orderdict 来存储表格中的每个字段，并且使用 str() / int() 强制数据类型。</p>
</li>
<li>
<p>通过zip函数，将列名和值组合起来。</p>
</li>
<li>
<p>没看懂，我懂了，这里的 orderdict  应该类似于下面的 dick，就是强制转换格式的。</p>
<p>下面的 <code>dick['chrom']</code>  就是 <code>str()</code> 函数</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dick=&#123;<span class="string">&#x27;chrom&#x27;</span>:<span class="built_in">str</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dick</span><br><span class="line">&#123;<span class="string">&#x27;chrom&#x27;</span>: &lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dick[<span class="string">&#x27;chrom&#x27;</span>]</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dick[<span class="string">&#x27;chrom&#x27;</span>](<span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dick[<span class="string">&#x27;chrom&#x27;</span>](<span class="number">2019</span>)</span><br><span class="line"><span class="string">&#x27;2019&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里没有提到缺失值的处理。建议看 GitHub 的 readme</p>
</li>
<li>
<p>又没看懂<img src="72.png" alt="70"></p>
</li>
</ol>
<p>最后，我们执行一下程序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python load_variants.py variants.txt</span><br></pre></td></tr></table></figure>
<p>查看一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select * from variants;</span><br><span class="line">id  chrom  start      end        strand  rsid</span><br><span class="line">--  -----  ---------  ---------  ------  ----------</span><br><span class="line">1   chr10  114808901  114808902  +       rs12255372</span><br><span class="line">2   chr9   22125502   22125503   +       rs1333049</span><br><span class="line">3   chr3   46414946   46414978   +       rs333</span><br><span class="line">4   chr2   136608645  136608646  -       rs4988235</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里有一个问题，这里再for循环结束后，才进行 commit。 这在小的数据库里不是问题，对于超出内存的数据就是一个问题。但是如果每经过一次for循环一次，就commit 一次，就会很低效。为了解决这个问题， python 的 sqlite3 Cursor 对象有一个 exectutemany() 方法，…… （后面没看懂）</p>
<p>最后我们看看python 如何提取数据库的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn = sqlite3.connect(<span class="string">&quot;variants.db&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = conn.cursor()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>statement = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>SELECT chrom, start, end FROM variants WHERE rsid IN (&#x27;rs12255372&#x27;, &#x27;rs333&#x27;)</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.execute(statement)</span><br><span class="line">&lt;sqlite3.Cursor <span class="built_in">object</span> at <span class="number">0x2b13e8423810</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我们可以通过 c.fetchone() 来查看一行数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.fetchone()</span><br><span class="line">(<span class="string">u&#x27;chr10&#x27;</span>, <span class="number">114808901</span>, <span class="number">114808902</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.fetchone()</span><br><span class="line">(<span class="string">u&#x27;chr3&#x27;</span>, <span class="number">46414946</span>, <span class="number">46414978</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.fetchone()</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="R’s-RSQLite-Package">R’s RSQLite Package</h4>
<p>R 和 sqlite 数据库互作的包为 ：RSQLite</p>
<h3 id="13-2-12-Dumping-Databases">13.2.12 Dumping Databases</h3>
<p>sqlite 复制数据库直接复制db文件就行（这在其他数据库做不到，比附MySQL, PostgreSQL）。</p>
<p>命令行的操作方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sqlite3 variants.db &quot;.dump&quot;</span><br><span class="line">PRAGMA foreign_keys&#x3D;OFF;</span><br><span class="line">BEGIN TRANSACTION;</span><br><span class="line">CREATE TABLE variants(</span><br><span class="line">        id integer primary key,</span><br><span class="line">        chrom test,</span><br><span class="line">        start integer,</span><br><span class="line">        end integer,</span><br><span class="line">        strand text,</span><br><span class="line">        rsid text);</span><br><span class="line">INSERT INTO variants VALUES(1,&#39;chr10&#39;,114808901,114808902,&#39;+&#39;,&#39;rs12255372&#39;);</span><br><span class="line">INSERT INTO variants VALUES(2,&#39;chr9&#39;,22125502,22125503,&#39;+&#39;,&#39;rs1333049&#39;);</span><br><span class="line">INSERT INTO variants VALUES(3,&#39;chr3&#39;,46414946,46414978,&#39;+&#39;,&#39;rs333&#39;);</span><br><span class="line">INSERT INTO variants VALUES(4,&#39;chr2&#39;,136608645,136608646,&#39;-&#39;,&#39;rs4988235&#39;);</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以复制为一个新的数据库。下面这个命令将 variants.db 的所有表格他 dumps to a SQL file，然后再将这个 SQL file 的内容复制到一个新的数据库 variants-duplicate.db</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sqlite3 variants.db <span class="string">&quot;.dump&quot;</span> &gt; dump.sql</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sqlite3 variants-duplicate.db &lt; dump.sql</span></span><br></pre></td></tr></table></figure>
<p>我没看懂 dump 到底是啥。这里复制db文件就可以了啊</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cp variants.db variants-duplicate2.db</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sqlite3 variants-duplicate2.db</span></span><br><span class="line">SQLite version 3.33.0 2020-08-14 13:23:32</span><br><span class="line">Enter &quot;.help&quot; for usage hints.</span><br><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> .table</span></span><br><span class="line">variants</span><br><span class="line"><span class="meta">sqlite&gt;</span><span class="bash"> select * from variants;</span></span><br><span class="line">1|chr10|114808901|114808902|+|rs12255372</span><br><span class="line">2|chr9|22125502|22125503|+|rs1333049</span><br><span class="line">3|chr3|46414946|46414978|+|rs333</span><br><span class="line">4|chr2|136608645|136608646|-|rs4988235</span><br></pre></td></tr></table></figure>
<h1>14  Conclusion</h1>
<blockquote>
<p>while we can’t be certain what future sequencing technology will allow us to do, we can be confident that Unix, Python, and R will continue to be the foundation of modern bioinformatics.</p>
</blockquote>
<blockquote>
<p><em>Bioinformatics  Data  Skills</em>  focuses  on  a  <strong>robust  and  reproducible</strong>  approach because  this  is  the  best  context  in  which  to  develop  your  bioinformatics  skills.  <strong>Distrust  of  one’s  tools  and  data</strong>  and  awareness  of  the  numerous  pitfalls  that  can  occur during  analysis  is  one  of  the  most  important  skills  to  develop.  However,  you’ll  only fully  develop  these  skills  when  you’ve  encountered  and  been  surprised  by  serious issues in your own research</p>
</blockquote>
<h2 id="14-1-Where-to-Go-From-Here">14.1 Where to Go From Here?</h2>
<blockquote>
<p>First,  I’d  recommend  you  learn  more  <em>statistics</em>  and  <em>probability</em>.</p>
</blockquote>
<blockquote>
<p>Second,  I  would  recommend  learning  some  basic  topics  in  computer  science—especially <em>algorithms</em> and <em>data structures</em>.</p>
<p>All  too  often  researchers  reach  for  more  computational power  to  parallelize  code  that  could  easily  run  on  their  desktop  machines  if  it  were written more efficiently. (我感觉这是在说我……)</p>
</blockquote>
<blockquote>
<p>For more direction into these topics, see this chapter’s README file on GitHub. I’ve included my favorite books on these subjects there—and will continue to add others as I discover them. （一定要看readme）</p>
</blockquote>
<blockquote>
<p>Finally, the last piece of advice I can give you in your path toward becoming  a  skilled  bioinformatician  is  to  <em>use  the  source</em>.  In  other  words,  read  code,and  read  lots  of  code—(especially  from  programmers  who  are  more  skilled  than you).  Developing  programming  skills  is  90%  about  experience—writing,  debugging,and  wrestling  with  code  for  years  and  years.  But  reading  and  learning  from  others’ code is like a secret shortcut in this process.（看别人的代码）</p>
</blockquote>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>生物信息</tag>
      </tags>
  </entry>
  <entry>
    <title>Fortran95程序设计基础学习笔记</title>
    <url>/posts/f06ad5f5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>很多人都说，彭国伦老师的这本书是很经典的Fortran基础书籍。我看完了，感觉确实深入浅出，除了让我对Fortran语言有一定的了解，而且让我对一些计算机方面的基础概念更加清晰了。</p>
<p>但是如果仅仅针对 Fortran 而言，我可能以后不会考虑用Fortran写代码。我的理由很肤浅，Fortran 代码的可读性太差了，更别提之前版本的 goto 语法。如果让我看一个别人写的很长的 Fortran 代码，我觉得这是一种谋杀。</p>
<span id="more"></span>
<h1>准备工作</h1>
<p>运行fortran 需要编译器。我这里用的gfortran，在 linux 系统下运行，而且免费。</p>
<h2 id="安装gfortran">安装gfortran</h2>
<p><a href="https://blog.csdn.net/yangle4695/article/details/51533770">https://blog.csdn.net/yangle4695/article/details/51533770</a></p>
<p>显示下面这条信息就说明安装好了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(base) [zhouziwen@ny ~]$ which gfortran</span><br><span class="line">/usr/bin/gfortran</span><br><span class="line">(base) [zhouziwen@ny ~]$ gfortran -v</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gfortran</span><br><span class="line">COLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/lto-wrapper</span><br><span class="line">Target: x86_64-redhat-linux</span><br><span class="line">Configured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzil                                                                                                                                la.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-                                                                                                                                zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-link                                                                                                                                er-hash-style=gnu --enable-languages=c,c++,objc,obj-c++,java,fortran,ada,go,lto --enable-plugin --enable-initfini-array -                                                                                                                                -disable-libgcj --with-isl=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/isl-install --with-cloog=/bui                                                                                                                                lddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/cloog-install --enable-gnu-indirect-function --with-tune=gen                                                                                                                                eric --with-arch_32=x86-64 --build=x86_64-redhat-linux</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>redhat 安装命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install gcc-gfortran</span><br></pre></td></tr></table></figure>
<h2 id="编译和链接">编译和链接</h2>
<p><a href="https://www.bilibili.com/video/BV1tx411u7o4?p=2">https://www.bilibili.com/video/BV1tx411u7o4?p=2</a></p>
<p>编译文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gfortran -c hello.f90 -o fcode</span><br></pre></td></tr></table></figure>
<ul>
<li>-c 需要编译的文件</li>
<li>-o 结果文件（不提供，则生成 hello.o）</li>
</ul>
<p>链接（生成一个可执行文件）：拼接各代码的过程，是编译器检查代码完整性的过程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gfortran 1.o 2.o 3.o -o 3body</span><br></pre></td></tr></table></figure>
<p>貌似这个命令能把三个绑在一起。</p>
<p><strong>编译和链接可以放在一起</strong></p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">gfortran main.f90 sub.f90 func.f90 -o <span class="number">3</span>body</span><br></pre></td></tr></table></figure>
<h1>Fortran95 程序设计基础</h1>
<h1>3 Fortran 程序设计基础</h1>
<h2 id="3-1-字符集">3-1 字符集</h2>
<p>编写Fortran 程序时所能使用的所有字符和符号</p>
<ul>
<li>英文 26个字母：不分大小写</li>
<li>数字：0-9</li>
<li>特殊符号：22个<code>:=+-*/(),.'!&quot;%&amp;;&lt;&gt;?$_&quot;</code>  ，还有一个空格</li>
</ul>
<p>注意，<strong>Fortran 大小写不分</strong>，INTEGER 和 integer 是一样的</p>
<h2 id="3-2-书面格式">3-2 书面格式</h2>
<p>Fortran 有两种编写格式：Fixed Format 是旧的，不建议使用；建议全部使用 Free Format 格式。</p>
<h3 id="3-2-1-Fixed-Format">3-2-1 Fixed Format</h3>
<p>规定了程序代码每一行中每个字段的意义。第 7 - 72 个字符是可以编写程序的字段。每一行的前5个字符只能是空格或数字，数字用来作为”行代码“。每一行的第6个字符只能是空格或”0“以外的字符。</p>
<h3 id="3-2-2-Free-Format">3-2-2 Free Format</h3>
<p>不需要在每一行的开头预留空格。</p>
<p>注意事项</p>
<ol>
<li>叹号 ！后面都是注释</li>
<li>每一行可以编写 132 个字符</li>
<li>行号放在每行程序的最前面（这个我感觉不是必须的）</li>
<li>一行程序代码的最后符合如果是 &amp; ，代表下一行程序会和这一行连接。如果一行代码开头是 &amp; ，表示它会和上一行连接。</li>
</ol>
<h2 id="3-3-数据类型">3-3 数据类型</h2>
<h3 id="整数（integeral）">整数（integeral）</h3>
<p>又分为长整型（4个字节）和短整型（2个字节）</p>
<h3 id="浮点数（real）">浮点数（real）</h3>
<p>单精度（4个字节），双精度（8个字节）</p>
<h3 id="复数（complex）">复数（complex）</h3>
<h3 id="字符（character）">字符（character）</h3>
<h3 id="逻辑判断（logical）">逻辑判断（logical）</h3>
<p>true 和 false</p>
<h2 id="3-4-数学表达式">3-4 数学表达式</h2>
<blockquote>
<p>+  - * /</p>
<p>** :  幂运算</p>
<p>( ) : 优先计算</p>
</blockquote>
<p>注意事项:</p>
<ul>
<li>乘法不能省略: 不能写AB, 必须写 A*B</li>
</ul>
<h1>4 输入输出及声明</h1>
<h2 id="4-1-输入-write-输出-print-命令">4-1 输入(write)输出(print)命令</h2>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0401</span><br><span class="line">wirte(*,*) <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="keyword">stop</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Fortran 程序通常以 program 开头,后面接一个自定义的程序名称, 可以用文件名, 如果想不出来, 可以用 main 。</p>
<p>write 表示的作用就是显示后面双引号所包含的字符串。后面的两个星号都有各自的意义，第一个星号表示输出的位置使用默认值，也就是屏幕；第二个星号则表示不特别设置输出格式。</p>
<p>有两点注意：</p>
<ol>
<li>write 后会自动换行</li>
<li>如果要打印双引号，那么要写两次双引号。</li>
</ol>
<p><strong>Fortran90 可以使用双引号或单引号来封装字符串</strong></p>
<p>stop 是终止程序，可以出现在程序的任意一个位置。但是除非必要，不要把STOP使用在主程序结束之外的其他地方。因为有太多的终止点，容易出错。</p>
<p>其实这里不需要 stop，因为主程序已经运行完毕了。</p>
<p>end 是用来封装程序代码使用的，说明程序代码已经编写完毕。</p>
<p>print 也可以打印，下面这一句和 write 一样。</p>
<p>print 不接括号，且只有一个星号，表示不限定输出格式。print 只能打印到屏幕上。作者建议<strong>只使用write</strong>，因为之后如果想输出转移到文件中，write 改起来更方便。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print *,&quot;Hello&quot;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-声明">4-2 声明</h2>
<p>声明是指：在程序代码中，程序员向编译器要求预留一些存放数据的内存空间。</p>
<h3 id="4-2-1-整数类型（integeral）">4-2-1 整数类型（integeral）</h3>
<p>声明一个整型变量的描述如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a</span><br></pre></td></tr></table></figure>
<p>但是，因为 a 定义为整型变量，因此如果计算结果有小数部分，都会被自动舍去</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">A = <span class="number">3</span>/<span class="number">2</span> <span class="comment">!A=1</span></span><br><span class="line">A = <span class="number">1</span>/<span class="number">2</span> <span class="comment">!A=0</span></span><br></pre></td></tr></table></figure>
<p>赋值为长整型和短整型的声明方法如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>(<span class="keyword">kind</span>=<span class="number">4</span>) <span class="comment">!4个字节</span></span><br><span class="line"><span class="keyword">integer</span>(<span class="keyword">kind</span>=<span class="number">2</span>) <span class="comment">!2个字节</span></span><br></pre></td></tr></table></figure>
<p>如果想同时声明多个相同数据类型的变量可以写在一行，用逗号分隔</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a,b,c</span><br></pre></td></tr></table></figure>
<p>命名规则：</p>
<ol>
<li>英文名称开头</li>
<li>不要和执行命令，主程序的名称，已声明的变量同名。</li>
</ol>
<p>Fortran90 在声明变量时，后面先写两个冒号</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a</span><br></pre></td></tr></table></figure>
<h3 id="4-2-2-浮点数（real">4-2-2 浮点数（real)</h3>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">real</span> a</span><br></pre></td></tr></table></figure>
<p>不加任何形容词时，通常会声明占用4个字节的 单精度浮点数。可以进一步准确声明，双精度更准确，但是会占用更多内存。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">4</span>) a</span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">8</span>) a</span><br></pre></td></tr></table></figure>
<p>改写上面的程序</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0407</span><br><span class="line">    <span class="keyword">real</span> :: a</span><br><span class="line">    a = <span class="number">2.5</span>+<span class="number">3.0</span>/<span class="number">2.0</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;2.5+3.0/2.0&quot;</span>,a</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里把 3 和 2 分别写成了 3.0 和 2.0 ，这是必要的操作，确保计算机在计算的时候按照”浮点数“来计算。</p>
<p>如果这里写成 <code>a=2.5+3/2</code> ，结果就会变成 3.5 。因为 3/2 会按照整型计算规则计算。</p>
<p>“有效位数“ 的 概念</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0408</span><br><span class="line">    <span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">4</span>) :: a,b</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">0.1</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a,<span class="string">&quot;+&quot;</span>,b,<span class="string">&quot;=&quot;</span>,a+b</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>我的输出结果如下（很奇怪，0.1最后为什么还有一个数字）</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1.00000000</span>     +  <span class="number">0.100000001</span>     =   <span class="number">1.10000002</span></span><br></pre></td></tr></table></figure>
<p>如果改成 a = 1000000 , b= 0.1</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1000000.00</span>     +  <span class="number">0.100000001</span>     =   <span class="number">1000000.12</span></span><br></pre></td></tr></table></figure>
<p>和教科书不一样。</p>
<p>教科书上写单精度的有效数字是6-7位。为了避免有效数字带来的误差，可以使用双精度。</p>
<p><strong>双精度有高达15位的有效数字</strong>。</p>
<p>对单精度设定很大的数时，可以采用 <strong>1E10</strong>, <strong>2.5E23</strong> 这种格式。</p>
<p>对双精度设定很大的数时，可以采用 <strong>1D10</strong>, <strong>2.5D23</strong> 这种格式。</p>
<p>应用 Fortran 数学函数库</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0409</span><br><span class="line">    <span class="keyword">real</span> :: a</span><br><span class="line">    a = <span class="number">3.14159</span>/<span class="number">2.0</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;sin(&quot;</span>,a,<span class="string">&quot;)=&quot;</span>,<span class="built_in">sin</span>(a)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Fortran 中计算平方根，可以用乘幂得到；或者调用数学函数 SQRT完成</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a=<span class="number">4.0</span>**<span class="number">0.5</span></span><br><span class="line">a=<span class="built_in">sqrt</span>(<span class="number">4.0</span>)</span><br></pre></td></tr></table></figure>
<p>开立方</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a=<span class="number">8.0</span>**(<span class="number">1.0</span>/<span class="number">3.0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="4-2-3-复数（complex）">4-2-3 复数（complex）</h3>
<h3 id="4-2-4-字符及字符串（character）">4-2-4 字符及字符串（character）</h3>
<p>声明一个字符</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">character</span> a</span><br></pre></td></tr></table></figure>
<p>声明一个字符串，同时注明最大长度</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">character</span>(len=<span class="number">10</span>) a</span><br></pre></td></tr></table></figure>
<p>字符串赋值</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a=<span class="string">&quot;hello&quot;</span></span><br><span class="line">a=<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">a=<span class="string">&quot;That&#x27;s right&quot;</span> <span class="comment">!用双引号封装时，里面任意使用单引号</span></span><br><span class="line">a=<span class="string">&#x27;That&#x27;</span><span class="string">&#x27;s right&#x27;</span> <span class="comment">!用单引号封装时，输出单引号时要连续使用两个单引号</span></span><br><span class="line">a=<span class="string">&quot;That&#x27;s &quot;</span><span class="string">&quot;right&quot;</span><span class="string">&quot;.&quot;</span> <span class="comment">!用双引号封装时，输出双引号也要连用两个双引号</span></span><br></pre></td></tr></table></figure>
<p>注意，Fortran 是变量名不区分大小写，但是字符串里的字符大小写是区分的，因为这是数据。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0412</span><br><span class="line">    <span class="keyword">character</span> a</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">10</span>) b</span><br><span class="line">    a = <span class="string">&#x27;H&#x27;</span></span><br><span class="line">    b = <span class="string">&#x27;ello&#x27;</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a,b</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello</span><br></pre></td></tr></table></figure>
<p>字符串可以一次只改变其中的几个字符（报错，我估计不能修改）</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0413</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) string</span><br><span class="line">    string = <span class="string">&quot;Good morning.&quot;</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) string</span><br><span class="line">    string(<span class="number">6</span>) = <span class="string">&quot;evening.&quot;</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) string</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">EX0413.F90:<span class="number">6.21</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(*,*) string(<span class="number">6</span>)</span><br><span class="line">                     <span class="number">1</span></span><br><span class="line">Error: Syntax error <span class="keyword">in</span> <span class="built_in">WRITE</span> statement at (<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>切片可以</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">write</span>(*,*) string(<span class="number">1</span>:<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>拼接字符串</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0414</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">6</span>) first</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">10</span>) second</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) add</span><br><span class="line">    first = <span class="string">&quot;Happy&quot;</span></span><br><span class="line">    second = <span class="string">&quot;Birthday&quot;</span></span><br><span class="line">    add = first//second <span class="comment">!两个连续的/表示拼接</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) add</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Happy Birthday</span><br></pre></td></tr></table></figure>
<p>其他函数</p>
<table>
<thead>
<tr>
<th>char(num)</th>
<th>返回ASCII表上数字num表示的字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>ichar(num)</td>
<td>返回字符在ASCII表上的编号</td>
</tr>
<tr>
<td>len(string)</td>
<td>返回输入字符串的<strong>声明</strong>长度</td>
</tr>
<tr>
<td>len_trim(string)</td>
<td>返回字符串去除尾端空格后的实际空格长度</td>
</tr>
<tr>
<td>index(string, key)</td>
<td>返回 key 子字符串在string中第一次出现的位置（索引应该是从1开始）</td>
</tr>
<tr>
<td>trim(string)</td>
<td>返回把string 字符串尾端多余空格清除过后的字符串</td>
</tr>
</tbody>
</table>
<h3 id="4-2-5-逻辑变量（logical">4-2-5 逻辑变量（logical)</h3>
<p>声明变量</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">logical</span> a</span><br><span class="line">a = .true. <span class="comment">!前后有两个点</span></span><br><span class="line">a = .false. </span><br></pre></td></tr></table></figure>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0416</span><br><span class="line">    <span class="keyword">logical</span> a,b</span><br><span class="line">    a = .true.</span><br><span class="line">    b = .false.</span><br><span class="line">    <span class="built_in">write</span>(*,*) a,b</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果只打印 T F</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T F</span><br></pre></td></tr></table></figure>
<h2 id="4-3-输入命令（read）">4-3 输入命令（read）</h2>
<p>通过键盘输入</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0417</span><br><span class="line">    <span class="keyword">integer</span> a </span><br><span class="line">    read(*,*) a</span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>read 命令中第一个*号表示使用默认的设备（键盘），第二个*号表示不指定输入格式。</p>
<p>同一行输入多个值（以空格或逗号分隔，或者每输入一个数按一次enter）</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0418</span><br><span class="line">    <span class="keyword">real</span> a,b,c</span><br><span class="line">    read(*,*) a,b,c</span><br><span class="line">    <span class="built_in">write</span>(*,*) a+b+c</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>如果需要输入字符串，字符串中间如果有空格，会被截断，视为两个字符串</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0419</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) a</span><br><span class="line">    read(*,*) a</span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">(base) [zhouziwen@ny gfortran]$ ./ex0419</span><br><span class="line">Happy Birthday <span class="comment">!输入</span></span><br><span class="line"> Happy <span class="comment">!输出</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解决办法是不要用默认的格式读取数据，这是需要格式化输入输出的原因之一。</p>
<h2 id="4-4-格式化输入输出（format）">4-4 格式化输入输出（format）</h2>
<p>格式化输入输出的用处</p>
<ol>
<li>美观</li>
<li>有时读取数据必须要格式化输入</li>
</ol>
<h3 id="4-4-1-格式化输出概论">4-4-1 格式化输出概论</h3>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0420</span><br><span class="line">    <span class="keyword">integer</span> a</span><br><span class="line">    a = <span class="number">100</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="number">100</span>) a <span class="comment">!使用行代码100的地方设置的格式来输出变量a</span></span><br><span class="line">    <span class="number">100</span> <span class="keyword">format</span>(I4) <span class="comment">!最前面的100是行代码</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面这个程序只会使用4个字符宽来输出整数。</p>
<p>通过使用相同的行代码，第四行的数字会通过第五行的格式输出，其中 I4 是说用4列来显示整数a的数值。</p>
<p>fortran 90 只要在每一行的开头设置一个数字，就能取一个行代码。</p>
<p>下面是格式化输出的例子， 1X 应该是输出右跳过1个位置（就是说从第二个位置输出，默认前面存在一个空格）</p>
<p>这种就不需要用什么行代码了，相比之下我也喜欢这种方式。</p>
<p>好处有：</p>
<ol>
<li>减少行数</li>
<li>提高代码可读性。不用向上面那样还要找format语句行。</li>
<li>避免在程序中使用行号</li>
</ol>
<p>缺点是</p>
<ol>
<li>输出格式很麻烦时，编写复杂</li>
<li>在不同的地方使用相同的输出格式时，程序代码会重复（这个我不觉得是缺点，相比于代码重复，可读性更重要）</li>
</ol>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0421</span><br><span class="line">    <span class="keyword">integer</span> a </span><br><span class="line">    <span class="keyword">real</span> b</span><br><span class="line">    <span class="keyword">complex</span> c</span><br><span class="line">    <span class="keyword">logical</span> d</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) e</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    b = <span class="number">12.34</span></span><br><span class="line">    c = (<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    d = .true.</span><br><span class="line">    e = <span class="string">&quot;Fortran&quot;</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(1X,I5)&quot;</span>) a <span class="comment">!用I来格式化整数</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(1X,F5.2)&quot;</span>) b <span class="comment">!用F来格式化浮点数</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(1X,F4.1,F4.1)&quot;</span>) c <span class="comment">!complex</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(1X,L3)&quot;</span>) d <span class="comment">!用L来输出logical</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(1X,A10)&quot;</span>) e <span class="comment">!用A来输出字符串</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(1x,a10)&quot;</span>) e <span class="comment">!a也可以</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有些时候，用 Format 也有好处，只是位置不能乱放，不然代码会很难阅读，要&quot;跳跃式阅读&quot;。（这个我在python中也感觉到了，有些人封装一堆函数，在阅读代码主体的时候，时不时就要去上面翻函数的内容）</p>
<h3 id="4-4-2-详述格式化输出">4-4-2 详述格式化输出</h3>
<p>常用的格式化输出的控制字符有5个</p>
<p>整数格式化：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0422</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(i5)&quot;</span>) <span class="number">100</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(i3)&quot;</span>) <span class="number">10000</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(i5.3)&quot;</span>) <span class="number">10</span> <span class="comment">!固定使用5个字符，至少输出3个数字</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">  <span class="number">100</span></span><br><span class="line">***     <span class="comment">!设置的长度低于真实字符长度，输出星号作为警告</span></span><br><span class="line">  <span class="number">010</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>格式化浮点数</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0422_2</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(f9.3)&quot;</span>) <span class="number">123.45</span> <span class="comment">!总共9个字符宽(不足左边补空格)，其中小数部分占3个字符宽（不足补0）</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(e15.7)&quot;</span>) <span class="number">123.45</span> <span class="comment">!用科学计数法，使用15个字符宽，其中小数部分占7个字符宽</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(e9.2e3)&quot;</span>) <span class="number">12.34</span> <span class="comment">!指数部分有3位数字</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">  <span class="number">123.450</span> <span class="comment">!不足9位，补三个空格</span></span><br><span class="line">  <span class="number">0.1234500E+03</span> <span class="comment">!总字符长度（包括后面的E+03）不足15位补空格，小数部分不足7位补0</span></span><br><span class="line"><span class="number">0.12E+002</span> <span class="comment">!指数部分不足补0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>字符串格式化</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0422_3</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(a10)&quot;</span>) <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(a3)&quot;</span>) <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">     Hello</span><br><span class="line">Hel <span class="comment">!如果设定的长度低于真实长度，会自动截取</span></span><br></pre></td></tr></table></figure>
<p>输出的位置向右移动</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0422_4</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(5x,i3)&quot;</span>) <span class="number">100</span> <span class="comment">!向右移动5位</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>换行输出 /</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0422_4</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(i3//i3)&quot;</span>) <span class="number">10</span>,<span class="number">10</span> <span class="comment">!中间两个空行</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>输出结果只有一个空行，和书上不一样</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重复地以相同的格式输出数据</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0423</span><br><span class="line">    <span class="keyword">real</span> a,b,c</span><br><span class="line">    a = <span class="number">1.0</span></span><br><span class="line">    b = <span class="number">2.0</span></span><br><span class="line">    c = <span class="number">3.0</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(3(1xf5.2))&quot;</span>) a,b,c</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1.00</span>  <span class="number">2.00</span>  <span class="number">3.00</span>、</span><br></pre></td></tr></table></figure>
<p>格式设置的字符串中，还可以放进固定要输出的字符串。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0424</span><br><span class="line">	<span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;3+4=&#x27;,i1)&quot;</span>) <span class="number">3</span>+<span class="number">4</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>+<span class="number">4</span>=<span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>另外，也可以把输出格式单独提取出来，放在一个字符串变量中。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0425</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">10</span>) fmtstring</span><br><span class="line">    fmtstring = <span class="string">&quot;(i2)&quot;</span></span><br><span class="line">    <span class="built_in">write</span>(*,fmtstring) <span class="number">3</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>这种方法的好处是，可以动态地改变输出格式。</p>
<p>输入数据一般不需要设置输入格式，除非输入数据<strong>存在空格</strong>。下面的程序可以读入长度在80字符内，包含任何字符（包括空格和逗号）的字符串。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0426</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) string</span><br><span class="line">    read(*,<span class="string">&quot;(a80)&quot;</span>) string</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(a80)&quot;</span>) string</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-5-声明的其他事项">4-5 声明的其他事项</h2>
<h3 id="4-5-1-变量名称的取名策略">4-5-1 变量名称的取名策略</h3>
<p>英文开头，下划线连接（这个应该所有语言通用）</p>
<h3 id="4-5-2-implicit-命令">4-5-2 implicit 命令</h3>
<p>Fortran 标准中有一项不好的功能，它的变量不一定要经过程序的声明才能使用，编译器会根据变量名称的第一个字母来自动决定这个变量的类型。来看一个实例。</p>
<p>下面这两个数字 fa, fb 没有经过定义就直接用了。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0427</span><br><span class="line">    read(*,*) fa, fb</span><br><span class="line">    <span class="built_in">write</span>(*,*) fa+fb</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>建议不要这么做，理由如下：</p>
<ol>
<li>先定义变量再使用，才能明白地了解程序执行时的内存使用情况。</li>
<li>变量如果不经声明就使用，很容易发生“人为错误”。</li>
</ol>
<p>举一个错误的实例</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0428</span><br><span class="line">    i = <span class="number">123</span> +<span class="number">321</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;123+321=&#x27;, i4)&quot;</span>) j</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">123</span>+<span class="number">321</span>=   <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这里本来要输出 i，但是由于<strong>打错字</strong>，写成了 j 。由于 j 没有设定任何数值，所以会输出0来。</p>
<p>作者建议，在声明前，都加上 <code>implicit none</code> 这个描述（这个命令要放在program 一行的后面，也就是第二行）</p>
<p>implicit 命令的功能是用来设置“默认类型”（即Fortran 不经过声明，由第一个字母来决定变量类型）。</p>
<p>修改 ex0428</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0428</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    i = <span class="number">123</span> +<span class="number">321</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;123+321=&#x27;, i4)&quot;</span>) j</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译报错</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">EX0428.F90:<span class="number">3.5</span>:</span><br><span class="line"></span><br><span class="line">    i = <span class="number">123</span> +<span class="number">321</span></span><br><span class="line">     <span class="number">1</span></span><br><span class="line">Error: Symbol <span class="string">&#x27;i&#x27;</span> at (<span class="number">1</span>) has no <span class="keyword">IMPLICIT</span> <span class="keyword">type</span></span><br><span class="line">EX0428.F90:<span class="number">4.34</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;123+321=&#x27;, i4)&quot;</span>) j</span><br><span class="line">                                  <span class="number">1</span></span><br><span class="line">Error: Symbol <span class="string">&#x27;j&#x27;</span> at (<span class="number">1</span>) has no <span class="keyword">IMPLICIT</span> <span class="keyword">type</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-5-3-常数的声明方法（parameter）">4-5-3 常数的声明方法（parameter）</h3>
<p>常数：固定不变的数</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0429</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> pi</span><br><span class="line">    <span class="keyword">parameter</span>(pi=<span class="number">3.14159</span>)</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(f4.2)&quot;</span>) <span class="built_in">sin</span>(pi/<span class="number">6</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">0.50</span></span><br></pre></td></tr></table></figure>
<p>设定为 parameter 后，不能再更改，不然会报错。</p>
<p>事实上，声明不声明常量，对结果没有影响。但是声明常量还是有他的价值。</p>
<ol>
<li>设置后常数后，再更改会报错，因此会降低错误发生的机会。</li>
<li>把不会改变内容的变量都设置成常数，可以增加程序执行的速度。</li>
</ol>
<p>fortran90 上面两行可以合并</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: pi=<span class="number">3.14159</span> </span><br></pre></td></tr></table></figure>
<h3 id="4-5-4-设置变量的初值">4-5-4 设置变量的初值</h3>
<p>Fortran90 可以在声明变量时直接设置初值，注意不能省略中间的两个冒号。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0430</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">real</span> :: b = <span class="number">2.0</span></span><br><span class="line">    <span class="keyword">complex</span> :: c = (<span class="number">1.0</span>, <span class="number">2.0</span>)</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: str = <span class="string">&quot;Fortran 90&quot;</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a,b,c,str</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-5-5-等价声明（equivalence）">4-5-5 等价声明（equivalence）</h3>
<p>把两个以上的变量，声明它们使用同一个内存地址，就是“等价声明”。使用同一个内存位置的变量，只要改变其中的一个变量，就会同时改变其他变量的数值，因为它们都占用同一块内存。</p>
<p>等价声明的方法如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a,b</span><br><span class="line"><span class="keyword">equivalence</span>(a,b)</span><br></pre></td></tr></table></figure>
<p>用处：</p>
<ol>
<li>节省内存</li>
<li>精简代码（相当于起了一个短的别名）</li>
</ol>
<h3 id="4-5-6-声明在程序中的结构">4-5-6 声明在程序中的结构</h3>
<p>变量需要先声明，才能赋值处理</p>
<h2 id="4-6-混合运算">4-6 混合运算</h2>
<p>“混合运算” 指的是比如一个整数加一个浮点数。因此需要先进行类型转换。</p>
<p>编译器会自动做一些类型转换的工作，但不一定对。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0431</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">integer</span> :: b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">real</span> :: c</span><br><span class="line">    c = a/b <span class="comment">!这里由于a,b是整数 a/b = 0</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(f5.2)&quot;</span>) c</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">0.00</span></span><br></pre></td></tr></table></figure>
<p>本来 c = 1/2 ，应该得到结果是 0.5。如果要获得正确答案，改写如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0432</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a=<span class="number">1</span></span><br><span class="line">    <span class="keyword">integer</span> :: b=<span class="number">2</span></span><br><span class="line">    <span class="keyword">real</span> :: c</span><br><span class="line">    c = <span class="keyword">real</span>(a)/<span class="keyword">real</span>(b) <span class="comment">!先进行类型转换</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(f5.2)&quot;</span>) c</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">0.50</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过 int() 函数将浮点数转化为整数，但是一般这个编译器可以自动地正确地进行类型转换。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0433</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a=<span class="number">1</span></span><br><span class="line">    <span class="keyword">real</span> :: b=<span class="number">2</span></span><br><span class="line">    <span class="keyword">real</span> :: c </span><br><span class="line">    c = a <span class="comment">!整数设置给浮点数地操作会自动转型</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(f5.2)&quot;</span>) c</span><br><span class="line">    c=a/b <span class="comment">!除数和被除数类型不同，结果会以浮点数来表示</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(f5.2)&quot;</span>) c</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1.00</span></span><br><span class="line"><span class="number">0.50</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里编译器自动转换是对的，但是为了确保不发生意外，最好是自己手动转换。</p>
<h2 id="4-7-Fortran90-的自定义数据类型">4-7 Fortran90 的自定义数据类型</h2>
<p>我们可以把多个基本数据来创建一个自定义数据类型。</p>
<p>比如我们把一个人的姓名，年龄，身高等信息合并到一起，组成一个 “person” 的数据类型。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0434</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="comment">!开始创建 person 这个类型</span></span><br><span class="line"><span class="keyword">type</span> :: person</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">30</span>) :: <span class="keyword">name</span> </span><br><span class="line">    <span class="keyword">integer</span> :: age</span><br><span class="line">    <span class="keyword">integer</span> :: height</span><br><span class="line">    <span class="keyword">integer</span> :: weight </span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) :: address</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span> person</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>(person) :: a <span class="comment">!声明一个person变量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;name:&quot;</span></span><br><span class="line">read(*,*) a%<span class="keyword">name</span> <span class="comment">!变量和元素以%分隔</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;age:&quot;</span></span><br><span class="line">read(*,*) a%age</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;height:&quot;</span></span><br><span class="line">read(*,*) a%height</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;weight:&quot;</span></span><br><span class="line">read(*,*) a%weight</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;address:&quot;</span></span><br><span class="line">read(*,<span class="string">&quot;(a80)&quot;</span>) a%address</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="number">100</span>) a%<span class="keyword">name</span>, a%age, a%height, a%weight</span><br><span class="line"><span class="number">100</span> <span class="keyword">format</span>(/,<span class="string">&quot;Name:&quot;</span>, a10/, <span class="string">&quot;age:&quot;</span>, i3/, <span class="string">&quot;height:&quot;</span>, i3/, <span class="string">&quot;weight:&quot;</span>, i3, <span class="string">&quot;address:&quot;</span>, a50 )</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">name</span>:</span><br><span class="line">zhouziwen</span><br><span class="line"> age:</span><br><span class="line"><span class="number">18</span></span><br><span class="line"> height:</span><br><span class="line"><span class="number">175</span></span><br><span class="line"> weight:</span><br><span class="line"><span class="number">50</span></span><br><span class="line"> address:</span><br><span class="line">jx</span><br><span class="line"></span><br><span class="line"><span class="keyword">Name</span>:zhouziwen</span><br><span class="line">age: <span class="number">18</span></span><br><span class="line">height:<span class="number">175</span></span><br><span class="line">weight: <span class="number">50</span>address:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以一次设置所有元素</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a = person(<span class="string">&quot;peter&quot;</span>, <span class="number">20</span>, <span class="number">170</span>, <span class="number">60</span>,<span class="string">&quot;Taiwan&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="4-8-kind-的使用">4-8 kind 的使用</h2>
<p>kind 是声明变量所占用的内存大小，主要是根据计算时所要使用到的有效位数以及值域范围。各类变量所保存的值域范围如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>(<span class="keyword">kind</span>=<span class="number">1</span>)  -<span class="number">128</span> ~ <span class="number">127</span></span><br><span class="line"><span class="keyword">integer</span>(<span class="keyword">kind</span>=<span class="number">2</span>)  -<span class="number">32768</span> ~ <span class="number">32767</span></span><br><span class="line"><span class="keyword">integer</span>(<span class="keyword">kind</span>=<span class="number">4</span>)  -<span class="number">2147483648</span> ~ <span class="number">2147483647</span></span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">4</span>)     ±<span class="number">1.18</span>*<span class="number">10</span>^-<span class="number">38</span> ~ ±<span class="number">3.40</span>*<span class="number">10</span>^<span class="number">38</span></span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">8</span>)     ±<span class="number">2.23</span>*<span class="number">10</span>^-<span class="number">308</span> ~ ±<span class="number">1.79</span>*<span class="number">10</span>^<span class="number">308</span></span><br></pre></td></tr></table></figure>
<p>根据取值范围判断需要的kind值（感觉没啥用）</p>
<p>哦哦，果然，作者解释了。主要原因是想在不同的机器上保存同样位数的数值，所使用的 kind 值不一定相同。而且不同的机器所能保存的值域范围也可能不太一样。这里所指的不同机器，是指“等级不同” 的机器，例如工作站和个人计算机之间。</p>
<p>说白了，就是方便程序在不同机器之间移植（目前感觉不到）。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0435</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="comment">!判断可以记录9个位数的整数kind值</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: long_int = <span class="built_in">selected_int_kind</span>(<span class="number">9</span>)</span><br><span class="line"><span class="comment">!判断可以记录3个位数的整数kind值</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: short_int = <span class="built_in">selected_int_kind</span>(<span class="number">3</span>)</span><br><span class="line"><span class="comment">!判断可以有10个有效位数，指数可以记录到50的浮点数kind值</span></span><br><span class="line"><span class="comment">!第一个数字表示需要的最大的十进制位数（10的多少次方），第二个数字表示最小的有效数字</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: long_real = <span class="built_in">selected_real_kind</span>(<span class="number">10</span>,<span class="number">50</span>)</span><br><span class="line"><span class="comment">!判断可以有3个有效位数，指数可以记录到3的浮点数kind值</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: short_real = <span class="built_in">selected_real_kind</span>(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">integer</span>(<span class="keyword">kind</span>=long_int) :: a = <span class="number">12345678</span></span><br><span class="line"><span class="keyword">integer</span>(<span class="keyword">kind</span>=short_int) :: b = <span class="number">12</span></span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=long_real) :: c = <span class="number">1.23456789D45</span></span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=short_real) :: d = <span class="number">1230</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(i3,1x,i10)&quot;</span>) long_int, a</span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(i3,1x,i10)&quot;</span>) short_int, b</span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(i3,1x,e10.5)&quot;</span>) long_real, c</span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(i3,1x,e10.5)&quot;</span>) short_real, d</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>   <span class="number">12345678</span></span><br><span class="line"><span class="number">2</span>         <span class="number">12</span></span><br><span class="line"><span class="number">8</span> <span class="number">.12346E+46</span></span><br><span class="line"><span class="number">4</span> <span class="number">.12300E+04</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>除了在声明的时候指定字符宽度，设置数值时同样可以赋值数字所使用的 KIND 值类型，但这不常用，例子如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0436</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">4</span>) :: a</span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">8</span>) :: b</span><br><span class="line">a = <span class="number">1.0_4</span> <span class="comment">!确保使用单精度</span></span><br><span class="line">b = <span class="number">1.0_8</span> <span class="comment">!确保使用双精度</span></span><br><span class="line"><span class="built_in">write</span>(*,*) a,b</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1.00000000</span>       <span class="number">1.0000000000000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-9-习题">4-9 习题</h2>
<p>1 输出字符串</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0437</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Have a good time&quot;</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;That&#x27;s not bad&quot;</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot; &quot;</span><span class="string">&quot;Mary&quot;</span><span class="string">&quot; isn&#x27;t my name.&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">Have a good time</span><br><span class="line">That<span class="string">&#x27;s not bad</span></span><br><span class="line"><span class="string"> &quot;Mary&quot; isn&#x27;</span>t my <span class="keyword">name</span>.</span><br></pre></td></tr></table></figure>
<p>2 计算圆的面积</p>
<p>下面这种，把parameter 放在 read 后面会报错。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0438</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> radius,area</span><br><span class="line">    <span class="keyword">real</span> pi</span><br><span class="line">    read(*,*) radius</span><br><span class="line">    <span class="keyword">parameter</span>(pi=<span class="number">3.14159</span>)</span><br><span class="line">    area = pi*(radius**<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(f9.3)&quot;</span>) area</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>报错如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">EX0438.F90:<span class="number">6.25</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span>(pi=<span class="number">3.14159</span>)</span><br><span class="line">                         <span class="number">1</span></span><br><span class="line">Error: Unexpected <span class="keyword">PARAMETER</span> statement at (<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>调整顺序后如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0438</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> radius,area,pi</span><br><span class="line">    <span class="keyword">parameter</span>(pi=<span class="number">3.14159</span>)</span><br><span class="line">    read(*,*) radius</span><br><span class="line">    area = pi*(radius**<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(f9.3)&quot;</span>) area</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line">   <span class="number">12.566</span></span><br></pre></td></tr></table></figure>
<p>3 调整成绩，对输入值平方后乘以10</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0438</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> old_num, new_num</span><br><span class="line">    read(*,*) old_num</span><br><span class="line">    new_num = <span class="number">10</span>*(old_num**<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(f9.3)&quot;</span>) new_num</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line">   <span class="number">40.000</span></span><br></pre></td></tr></table></figure>
<p>4 请问下面程序的输出结果是什么</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0440</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> a,b</span><br><span class="line"><span class="keyword">real</span> ra,rb</span><br><span class="line">a=<span class="number">2</span></span><br><span class="line">b=<span class="number">3</span></span><br><span class="line">ra=<span class="number">2.0</span></span><br><span class="line">rb=<span class="number">3.0</span></span><br><span class="line"><span class="built_in">write</span>(*,*) b/a</span><br><span class="line"><span class="built_in">write</span>(*,*) rb/ra</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>应该是 1 1.5</p>
<p>输出结果如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">        <span class="number">1</span></span><br><span class="line"><span class="number">1.50000000</span></span><br></pre></td></tr></table></figure>
<p>5 自定义类型，定义一个新的类型 distance 。有 3个浮点数的元素，分别以米、厘米、英寸为单位来记录同一段长度。请编写一个程序，程序会以米为单位来读入一段长度，并自动计算其他单位的数值。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0441</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="comment">!创建distance这个类型</span></span><br><span class="line"><span class="keyword">type</span> :: distance</span><br><span class="line">    <span class="keyword">real</span> :: meter</span><br><span class="line">    <span class="keyword">real</span> :: centimeter</span><br><span class="line">    <span class="keyword">real</span> :: inch</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span> distance</span><br><span class="line"><span class="comment">!声明一个distance变量</span></span><br><span class="line"><span class="keyword">type</span>(distance) :: a</span><br><span class="line"><span class="comment">!输入米</span></span><br><span class="line"><span class="keyword">real</span> b</span><br><span class="line">read(*,*) b</span><br><span class="line"></span><br><span class="line">a%meter = b</span><br><span class="line">a%centimeter = <span class="number">100</span>*b</span><br><span class="line">a%inch = <span class="number">100</span>*b/<span class="number">2.54</span></span><br><span class="line"><span class="built_in">write</span>(*,*) a</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">   <span class="number">1.00000000</span>       <span class="number">100.000000</span>       <span class="number">39.3700790</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>5 流程控制与逻辑运算</h1>
<h2 id="5-1-if-语句">5-1 if 语句</h2>
<p>基本语句</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (逻辑判断式) <span class="keyword">then</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ……</span><br><span class="line">    ……</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br></pre></td></tr></table></figure>
<p>用 if 来试着写一个警告车速过快的程序。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0501</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">4</span>) :: speed</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;speed:&quot;</span> </span><br><span class="line">read(*,*) speed</span><br><span class="line"><span class="keyword">if</span> ( speed &gt; <span class="number">100.0</span> ) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Slow down.&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> speed:</span><br><span class="line"><span class="number">120</span></span><br><span class="line"> Slow down.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>写一个小程序，如果一个人的体重大于身高减去100后得到的数值，代表这个人超重。</p>
<p>注意，一样需要有缩进，不然难以阅读。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0502</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">4</span>) :: height </span><br><span class="line"><span class="keyword">real</span>(<span class="keyword">kind</span>=<span class="number">4</span>) :: weight</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;height:&quot;</span></span><br><span class="line">read(*,*) height</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;weight:&quot;</span></span><br><span class="line">read(*,*) weight</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( weight &gt; height - <span class="number">100</span> ) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Too fat&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Under control&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> height:</span><br><span class="line"><span class="number">170</span></span><br><span class="line"> weight:</span><br><span class="line"><span class="number">50</span></span><br><span class="line"> Under control</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-1-2-逻辑运算">5-1-2 逻辑运算</h3>
<p>Fortran90 的逻辑运算符共有以下几种：</p>
<ul>
<li><code>==</code> :  是否相等</li>
<li><code>/=</code> :  是否不相等</li>
<li><code>&gt;</code></li>
<li><code>&gt;=</code></li>
<li><code>&lt;</code></li>
<li><code>&lt;=</code></li>
</ul>
<p>相互关系之间的集合运算符号</p>
<ul>
<li><code>.and.</code>  : 两个表达式均成立</li>
<li><code>.or.</code></li>
<li><code>.not.</code></li>
<li><code>.eqv.</code> ： 两边表达式的逻辑运算结果相同时，整个表达式就成立</li>
<li><code>.neqv.</code>： 两边表达式的逻辑运算结果不同时，整个表达式就成立</li>
</ul>
<p>大于小于等式的运算符号优先级高于集合运算符号，例子如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((a&gt;=<span class="number">80</span>) .and. (a&lt;<span class="number">90</span>)) <span class="keyword">then</span></span><br></pre></td></tr></table></figure>
<p>判断如果风势超过10级或是降雨量超过500厘米，就停止上班上课</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0503</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span> </span><br><span class="line"><span class="keyword">integer</span> rain, windspeed</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Rain:&quot;</span></span><br><span class="line">read(*,*) rain</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Wind:&quot;</span></span><br><span class="line">read(*,*) windspeed</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( rain&gt;=<span class="number">500</span> .or. windspeed &gt;=<span class="number">10</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;停止上班上课&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;照常上班上课&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> Rain:</span><br><span class="line"><span class="number">100</span></span><br><span class="line"> Wind:</span><br><span class="line"><span class="number">8</span></span><br><span class="line"> 照常上班上课</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 if 时，可以先把逻辑运算的结果存放在逻辑变量中，再利用逻辑变量来做条件判断。利用这个方法把程序 ex0503 改写如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0504</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> rain, windspeed</span><br><span class="line"><span class="keyword">logical</span> r,w</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Rain:&quot;</span></span><br><span class="line">read(*,*) rain</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Wind:&quot;</span></span><br><span class="line">read(*,*) windspeed</span><br><span class="line"></span><br><span class="line">r = (rain &gt;= <span class="number">500</span>)</span><br><span class="line">w = (windspeed &gt;= <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r .or. w) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;停止上班上课&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;照常上班上课&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> Rain:</span><br><span class="line"><span class="number">100</span></span><br><span class="line"> Wind:</span><br><span class="line"><span class="number">8</span></span><br><span class="line"> 照常上班上课</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-1-3-多重判断-if-else-if">5-1-3 多重判断 if - else if</h3>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件<span class="number">2</span>) <span class="keyword">then</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br></pre></td></tr></table></figure>
<p>举例，90-100 分为A级，80-89 分为B级，70-79分为C级， 60-69分为D级，60分以下为E级。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0505</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> score</span><br><span class="line"><span class="keyword">character</span> grade</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Score:&quot;</span></span><br><span class="line">read(*,*) score</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( score &gt;= <span class="number">90</span> .and. score &lt;= <span class="number">100</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">80</span> .and. score &lt; <span class="number">90</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">70</span> .and. score &lt; <span class="number">80</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;C&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">60</span> .and. score &lt; <span class="number">70</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;D&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">0</span> .and. score &lt; <span class="number">60</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;E&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    grade = <span class="string">&#x27;?&#x27;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;Grade:&#x27;,A1)&quot;</span>) grade</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> Score:</span><br><span class="line"><span class="number">85</span></span><br><span class="line">Grade:B</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于多重判断，只有上一个条件不满足才会判断下一个条件，因此上一个程序可以简化如下（但是我觉得这样写不好，虽然提高了一点效率，但是降低了可读性）</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0505</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> score</span><br><span class="line"><span class="keyword">character</span> grade</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Score:&quot;</span></span><br><span class="line">read(*,*) score</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( score &gt; <span class="number">100</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;?&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">90</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">80</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">70</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;C&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">60</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;D&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( score &gt;= <span class="number">0</span> ) <span class="keyword">then</span></span><br><span class="line">    grade = <span class="string">&#x27;E&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    grade = <span class="string">&#x27;?&#x27;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;Grade:&#x27;,A1)&quot;</span>) grade</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-1-4-嵌套if语句">5-1-4 嵌套if语句</h3>
<p>多个if 语句嵌套</p>
<p>举例</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0508</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> x,y </span><br><span class="line"><span class="keyword">integer</span> ans</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Imput (x,y)&quot;</span></span><br><span class="line">read(*,*) x,y</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x&gt;<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> (y&gt;<span class="number">0</span>) <span class="keyword">then</span> </span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (y&lt;<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        ans = <span class="number">4</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> (y&gt;<span class="number">0</span>) <span class="keyword">then</span> </span><br><span class="line">        ans = <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (y&lt;<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        ans = <span class="number">3</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( ans/=<span class="number">0</span> ) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;第&#x27;,i1,&#x27;象限&#x27;)&quot;</span>) ans</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;落在轴上&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p>输入输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> Imput (x,y)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line">第<span class="number">1</span>象限</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-2-浮点数及字符的逻辑运算">5-2 浮点数及字符的逻辑运算</h2>
<h3 id="5-2-1-浮点数的逻辑判断">5-2-1 浮点数的逻辑判断</h3>
<p>使用浮点数来做逻辑运算时，要避免使用“等于”的判断。因为使用浮点数做计算时，有效位数是有限的，难免会出现计算上的误差，理想中的等号不一定会成立。要使用浮点数来做“等于”的逻辑判断时，最好用其他方法来取代。来看看下面的例子</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0509</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> :: a</span><br><span class="line"><span class="keyword">real</span> :: b = <span class="number">3.0</span></span><br><span class="line"></span><br><span class="line">a = <span class="built_in">sqrt</span>(b)**<span class="number">2</span> -b</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">0.0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;a 等于0&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;a不等于0&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然理论上 a = (根号b)^2^  - b = 0。但是用程序执行出来的结果却不见得是0，因为这里求根号时，得到的结果是保留了有效数字的，因此一开始就有误差。</p>
<p>浮点数的计算误差经常发生，所以在判断式中，要给误差预留一点空间。改写上面的例子</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0509</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> :: a</span><br><span class="line"><span class="keyword">real</span> :: b = <span class="number">3.0</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: e = <span class="number">0.0001</span> <span class="comment">!设置误差范围</span></span><br><span class="line"></span><br><span class="line">a = <span class="built_in">sqrt</span>(b)**<span class="number">2</span> -b</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(a-<span class="number">0.0</span>) &lt;= e) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;a 等于0&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;a不等于0&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-2-2-字符的逻辑判断">5-2-2 字符的逻辑判断</h3>
<p>除了数字可以比大小，字符也可以比大小（实际是比ASCII码）</p>
<p>用一个程序读取两个字符串来做比较</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0511</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">character</span>(len=<span class="number">20</span>) :: str1,str2</span><br><span class="line"><span class="keyword">character</span> relation</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;String 1:&quot;</span></span><br><span class="line">read(*,<span class="string">&quot;(a20)&quot;</span>) str1</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;String 2:&quot;</span></span><br><span class="line">read(*,<span class="string">&quot;(a20)&quot;</span>) str2</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str1 &gt; str2) <span class="keyword">then</span></span><br><span class="line">    relation = <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (str1 == str2) <span class="keyword">then</span></span><br><span class="line">    relation = <span class="string">&#x27;=&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    relation = <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;string1&#x27;,a1,&#x27;string2&#x27;)&quot;</span>) relation</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> String <span class="number">1</span>:</span><br><span class="line">zh</span><br><span class="line"> String <span class="number">2</span>:</span><br><span class="line">zi</span><br><span class="line">string1&lt;string2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-3-select-case-语句">5-3 select case 语句</h2>
<p>除了if 外，多重判断的另一种方法（我不喜欢用这个）</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0512</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> score</span><br><span class="line"><span class="keyword">character</span> grade</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Score:&quot;</span></span><br><span class="line">read(*,*) score</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">case</span>(score)</span><br><span class="line"><span class="keyword">case</span>(<span class="number">90</span>:<span class="number">100</span>)</span><br><span class="line">    grade = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">case</span>(<span class="number">80</span>:<span class="number">89</span>)</span><br><span class="line">    grade = <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">case</span>(<span class="number">70</span>:<span class="number">79</span>)</span><br><span class="line">    grade = <span class="string">&#x27;C&#x27;</span></span><br><span class="line"><span class="keyword">case</span>(<span class="number">60</span>:<span class="number">69</span>)</span><br><span class="line">    grade = <span class="string">&#x27;D&#x27;</span></span><br><span class="line"><span class="keyword">case</span>(<span class="number">0</span>:<span class="number">59</span>)</span><br><span class="line">    grade = <span class="string">&#x27;E&#x27;</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">default</span> <span class="comment">!其他情况</span></span><br><span class="line">    grade = <span class="string">&#x27;?&#x27;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">select</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;Grade:&#x27;,a1)&quot;</span>) grade</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>事实上，select case 中的判断经常不是判断是否落在一个数值范围内，而是判断是否等于某个数值。</p>
<p>语法如下：其中 case default 语句不是必需的。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">case</span>(变量)</span><br><span class="line"><span class="keyword">case</span> (数值<span class="number">1</span>)</span><br><span class="line">……</span><br><span class="line"><span class="keyword">case</span> (数值<span class="number">2</span>)</span><br><span class="line">……</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">default</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">select</span></span><br></pre></td></tr></table></figure>
<p>case 详细解释如下</p>
<blockquote>
<p>case(1)  变量=1</p>
<p>case(1:5)  1&lt;=变量&lt;=5</p>
<p>case(1: )   1&lt;=变量</p>
<p>case( :5)   变量 &lt;= 5</p>
<p>case(1,3,5)  变量等于1或3或5</p>
</blockquote>
<p>使用 selct case ，相比于 if ，看上去更加整洁。不过使用 select case 有一些限制：</p>
<ol>
<li>只能使用整数，字符，及逻辑变量，<strong>不能使用浮点数</strong>和复数。</li>
<li>每个 case 中所使用的数值必须是<strong>固定的常量</strong>（parameter），不能使用变量。</li>
</ol>
<h2 id="5-4-其他流程控制">5-4 其他流程控制</h2>
<h3 id="5-4-1-goto">5-4-1 goto</h3>
<p>fortran77 的老语句，不建议使用。</p>
<h3 id="5-4-3-pause-continue-stop">5-4-3 pause, continue, stop</h3>
<p>pause 的功能是当程序执行到 pause 时，会暂停执行，直到用户按下 enter 键才会继续执行。（目前我不知哪里需要用到这个）</p>
<p>continue 没有实际用途，就是放那和不放一样，用不到</p>
<p>stop 结束程序执行，小心使用（貌似类似于shell 的 exit）。</p>
<h2 id="5-5-习题">5-5 习题</h2>
<p>1 判断个人所得税</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0513</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> wage</span><br><span class="line"><span class="keyword">real</span> tax</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;wage:&quot;</span></span><br><span class="line">read(*,*) wage</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (wage &gt; <span class="number">0</span> .and. wage &lt; <span class="number">1000</span>) <span class="keyword">then</span></span><br><span class="line">    tax = <span class="number">0.03</span> * wage</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (wage &gt;=<span class="number">1000</span> .and. wage &lt; <span class="number">5000</span>) <span class="keyword">then</span></span><br><span class="line">    tax = <span class="number">0.1</span> * wage</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (wage &gt;= <span class="number">5000</span>) <span class="keyword">then</span></span><br><span class="line">    tax = <span class="number">0.15</span> * wage</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Error: wage must be a positive number&quot;</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;wage:&#x27;,f9.2,&#x27; tax:&#x27;,f9.2)&quot;</span>) wage,tax</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> wage:</span><br><span class="line"><span class="number">6000</span></span><br><span class="line">wage:  <span class="number">6000.00</span> tax:   <span class="number">900.00</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>输入星期几查询当晚的电视节目</li>
</ol>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0514</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> day</span><br><span class="line"><span class="keyword">character</span> tv</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Today is:&quot;</span></span><br><span class="line">read(*,*) day</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((day == <span class="number">1</span>) .or. (day ==<span class="number">4</span>)) <span class="keyword">then</span></span><br><span class="line">    tv = <span class="string">&#x27;新闻&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((day == <span class="number">2</span>) .or. (day ==<span class="number">5</span>)) <span class="keyword">then</span></span><br><span class="line">    tv = <span class="string">&#x27;电视剧&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((day == <span class="number">3</span>) .or. (day ==<span class="number">6</span>)) <span class="keyword">then</span></span><br><span class="line">    tv = <span class="string">&#x27;卡通片&#x27;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (day == <span class="number">7</span>) <span class="keyword">then</span></span><br><span class="line">    tv = <span class="string">&#x27;电影&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Error: day must be 1 to 7&quot;</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;tv is&#x27;,a3)&quot;</span>) tv</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码没错，但是中文显示不出来</p>
<p>错了，错了。</p>
<p>注意下面这两句的区别。上面只是设置为一个单个字符，下面才是字符串</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">character</span> tv</span><br><span class="line"><span class="keyword">character</span>(len=<span class="number">10</span>) tv</span><br></pre></td></tr></table></figure>
<p>3 个人所得税根据年纪和收入计算</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0515</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> year</span><br><span class="line"><span class="keyword">real</span> wage_year,wage,tax</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;how old are you?&quot;</span></span><br><span class="line">read(*,*) year</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Wage in a year:&quot;</span></span><br><span class="line">read(*,*) wage_year</span><br><span class="line"></span><br><span class="line">wage = wage_year/<span class="number">12</span> <span class="comment">!月收入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (year &lt; <span class="number">50</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> (wage &lt; <span class="number">1000</span>) <span class="keyword">then</span></span><br><span class="line">        tax = wage_year * <span class="number">0.03</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wage &lt; <span class="number">5000</span>) <span class="keyword">then</span></span><br><span class="line">        tax = wage_year * <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tax = wage_year * <span class="number">0.15</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (wage &lt; <span class="number">1000</span>) <span class="keyword">then</span></span><br><span class="line">        tax = wage_year * <span class="number">0.05</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wage &lt; <span class="number">5000</span>) <span class="keyword">then</span></span><br><span class="line">        tax = wage_year * <span class="number">0.07</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tax = wage_year * <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">&quot;(f9.2)&quot;</span>) tax</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> how old are you?</span><br><span class="line"><span class="number">25</span></span><br><span class="line"> Wage <span class="keyword">in</span> a year:</span><br><span class="line"><span class="number">120000</span></span><br><span class="line"> <span class="number">18000.00</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4 输入年份，判断天数（老题目了）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">program ex0516</span><br><span class="line">implicit none</span><br><span class="line">integer year,days</span><br><span class="line"></span><br><span class="line">write(*,*) &quot;Year:&quot;</span><br><span class="line">read(*,*) year</span><br><span class="line"></span><br><span class="line">if (mod(year,100) &#x3D;&#x3D; 0) then !被100整除</span><br><span class="line">    if (mod(year,400) &#x3D;&#x3D; 0) then !又被400整除</span><br><span class="line">        days &#x3D; 366</span><br><span class="line">    else</span><br><span class="line">        days &#x3D; 365</span><br><span class="line">    end if </span><br><span class="line">else !不能被100整除</span><br><span class="line">    if (mod(year,4) &#x3D;&#x3D; 0) then !被4整除</span><br><span class="line">        days &#x3D; 366</span><br><span class="line">    else</span><br><span class="line">        days &#x3D; 365</span><br><span class="line">    end if </span><br><span class="line">end if </span><br><span class="line"></span><br><span class="line">write(*, &quot;(&#39;days of year &#39;,i4,&#39; is &#39;,i3)&quot;) year,days</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> Year:</span><br><span class="line"><span class="number">2000</span></span><br><span class="line">days of <span class="number">2000</span> is <span class="number">366</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>6 循环</h1>
<p>循环可以用来自动重复执行某一段程序代码，善用循环可以让程序代码变得很精简。</p>
<p>循环又两种执行格式，第一种格式会固定重复程序代码 n 次。另一种格式着是不固定重复几次，一直执行到出现跳出循环的命令为止。</p>
<h2 id="6-1-do">6-1 do</h2>
<p>说 10 次 happy birthday</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0601</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> counter</span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: lines = <span class="number">10</span></span><br><span class="line"><span class="comment">! counter &lt;= lines 会一直循环，每执行一次循环 counter 加 1</span></span><br><span class="line"><span class="comment">! counter 称之为 计数器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> counter=<span class="number">1</span>,lines,<span class="number">1</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Happy Birthday&quot;</span>, counter</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">Happy Birthday           <span class="number">1</span></span><br><span class="line">Happy Birthday           <span class="number">2</span></span><br><span class="line">Happy Birthday           <span class="number">3</span></span><br><span class="line">Happy Birthday           <span class="number">4</span></span><br><span class="line">Happy Birthday           <span class="number">5</span></span><br><span class="line">Happy Birthday           <span class="number">6</span></span><br><span class="line">Happy Birthday           <span class="number">7</span></span><br><span class="line">Happy Birthday           <span class="number">8</span></span><br><span class="line">Happy Birthday           <span class="number">9</span></span><br><span class="line">Happy Birthday          <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再看一个例子，使用循环计算 2+4+……+10</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0602</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: limit = <span class="number">10</span></span><br><span class="line"><span class="keyword">integer</span> counter</span><br><span class="line"><span class="keyword">integer</span> :: ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> counter=<span class="number">2</span>,limit,<span class="number">2</span></span><br><span class="line">    ans = ans + counter</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>增值（我叫步长）也可以设置为负值。</p>
<p>嵌套循环</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0603</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> i,j</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">3</span></span><br><span class="line">    <span class="keyword">do</span> j=<span class="number">1</span>,<span class="number">3</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(i2,i2)&quot;</span>) i,j</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;another cycle&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line">another <span class="keyword">cycle</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line">another <span class="keyword">cycle</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line">another <span class="keyword">cycle</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-2-do-while-循环">6-2 do while 循环</h2>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> <span class="keyword">while</span> (逻辑运算) <span class="comment">!成立就一直重复执行</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>以这个方法改写 2+4+……10</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0604</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: limit = <span class="number">10</span> </span><br><span class="line"><span class="keyword">integer</span> counter</span><br><span class="line"><span class="keyword">integer</span> :: ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">counter = <span class="number">2</span> </span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span> (counter &lt;= limit)</span><br><span class="line">    ans = ans + counter</span><br><span class="line">    counter = counter + <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) ans</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是 do while 一般不是处理这种任务的，do while 处理的任务一般是不知道要循环几次的。</p>
<p>蔡小姐把她的体重视为秘密，不过这里有个程序可以让大家猜她的体重。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0605</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: weight = <span class="number">45.0</span> <span class="comment">!答案</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: e = <span class="number">0.001</span> <span class="comment">!误差</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">real</span> :: guess = <span class="number">0.0</span> <span class="comment">!猜测值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span> ( <span class="built_in">abs</span>(guess - weight) &gt; e )</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;weight:&quot;</span></span><br><span class="line">    read(*,*) guess</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;You&#x27;re right&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-3-循环的流程控制">6-3 循环的流程控制</h2>
<h3 id="6-3-1-cycle">6-3-1 cycle</h3>
<p>等同于 python 的 continue</p>
<p>假设百货公司共有9层楼，但电梯在4层不停，显示电梯灯号显示情况</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0606</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: dest = <span class="number">9</span></span><br><span class="line"><span class="keyword">integer</span> <span class="built_in">floor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> <span class="built_in">floor</span>=<span class="number">1</span>, dest</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">floor</span> == <span class="number">4</span>) <span class="keyword">cycle</span> <span class="comment">!if 就一行可以这么写</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="built_in">floor</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出如下，跳过了 4</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="6-3-2-exit">6-3-2 exit</h3>
<p>相当于 python 的 break</p>
<p>改写前面的猜体重的程序</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0607</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: weight = <span class="number">45.0</span> <span class="comment">!答案</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: e = <span class="number">0.001</span> <span class="comment">!误差</span></span><br><span class="line"><span class="keyword">real</span> :: guess </span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span> (.true.)</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;weight:&quot;</span></span><br><span class="line">    read(*,*) guess</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(guess - weight) &lt; e) <span class="keyword">exit</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;You&#x27;re right&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里用到了死循环，必须要用 exit</p>
<h3 id="6-3-3-署名的循环">6-3-3 署名的循环</h3>
<p>给循环取名字，避免多层循环弄错</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0608</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> i,j</span><br><span class="line"></span><br><span class="line">outter: <span class="keyword">do</span> i = <span class="number">1</span>,<span class="number">3</span> <span class="comment">!循环取名为outter</span></span><br><span class="line">    inner: <span class="keyword">do</span> j = <span class="number">1</span>,<span class="number">3</span> <span class="comment">!循环取名为inner</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;(&#x27;,i2,&#x27;,&#x27;,i2,&#x27;)&#x27;)&quot;</span>) i,j</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> inner</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span> outter </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">( <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">( <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">( <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">( <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">( <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">( <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">( <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">( <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">( <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>起名字的循环，还可以使用 cycle exit 在内层直接挑出外层的循环，例子如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0609</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> i,j</span><br><span class="line"></span><br><span class="line">loop1: <span class="keyword">do</span> i = <span class="number">1</span>,<span class="number">3</span> </span><br><span class="line">    loop2: <span class="keyword">do</span> j = <span class="number">1</span>,<span class="number">3</span> </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">3</span>) <span class="keyword">exit</span> loop1 <span class="comment">!跳离 loop1</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">2</span>) <span class="keyword">cycle</span> loop2 <span class="comment">!重做 loop2</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;(&#x27;,i2,&#x27;,&#x27;,i2,&#x27;)&#x27;)&quot;</span>) i,j</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> loop2</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span> loop1</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">( <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">( <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">( <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">( <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-4-循环的应用">6-4 循环的应用</h2>
<p>实例1 求等差数列1+2+……100</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0610</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> counter</span><br><span class="line"><span class="keyword">integer</span> :: ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">do</span> counter=<span class="number">1</span>,<span class="number">100</span>,<span class="number">1</span></span><br><span class="line">    ans = ans + counter</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">write</span>(*,*) ans</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">5050</span></span><br></pre></td></tr></table></figure>
<p>实例2 列举费氏数列前10个数字</p>
<p>f0 = 0, f1 =1, fn = fn-1 + fn-2</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0611</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: counter </span><br><span class="line"><span class="keyword">integer</span> :: fn_1 = <span class="number">1</span></span><br><span class="line"><span class="keyword">integer</span> :: fn_2 = <span class="number">0</span></span><br><span class="line"><span class="keyword">integer</span> :: fn = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) fn_2</span><br><span class="line"><span class="built_in">write</span>(*,*) fn_1</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> counter = <span class="number">2</span>,<span class="number">9</span></span><br><span class="line">    fn = fn_2 + fn_1</span><br><span class="line">    <span class="built_in">write</span>(*,*) fn</span><br><span class="line">    fn_2 = fn_1</span><br><span class="line">    fn_1 = fn</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"> <span class="number">1</span></span><br><span class="line"> <span class="number">1</span></span><br><span class="line"> <span class="number">2</span></span><br><span class="line"> <span class="number">3</span></span><br><span class="line"> <span class="number">5</span></span><br><span class="line"> <span class="number">8</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实例三，做简单的密码加密、解密程序。加密方法很简单，把每个英文字母在ASCII表中的编号加2作为密码来传输，解密就是还原</p>
<p>加密程序</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0612</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> i </span><br><span class="line"><span class="keyword">integer</span> strlen</span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: key = <span class="number">2</span></span><br><span class="line"><span class="keyword">character</span>(len=<span class="number">20</span>) :: string</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;String:&quot;</span></span><br><span class="line">read(*,*) string</span><br><span class="line"></span><br><span class="line">strlen = <span class="built_in">len_trim</span>(string) <span class="comment">!字符串实际长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i = <span class="number">1</span>,strlen</span><br><span class="line">    string(i:i) = <span class="built_in">char</span>( <span class="built_in">ichar</span>(string(i:i)) + key )</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;encoded:&#x27;,a20)&quot;</span>) string</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> String:</span><br><span class="line">attack now</span><br><span class="line">encoded:cvvcem</span><br></pre></td></tr></table></figure>
<p>解密程序 ，就是把 + key 变成了  - key</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0613</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> i </span><br><span class="line"><span class="keyword">integer</span> strlen</span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: key = <span class="number">2</span></span><br><span class="line"><span class="keyword">character</span>(len=<span class="number">20</span>) :: string</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;String:&quot;</span></span><br><span class="line">read(*,*) string</span><br><span class="line"></span><br><span class="line">strlen = <span class="built_in">len_trim</span>(string) <span class="comment">!字符串实际长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i = <span class="number">1</span>,strlen</span><br><span class="line">    string(i:i) = <span class="built_in">char</span>( <span class="built_in">ichar</span>(string(i:i)) - key )</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;encoded:&#x27;,a20)&quot;</span>) string</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> String:</span><br><span class="line">cvvcem</span><br><span class="line">encoded:attack</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个代码有一个问题，输入由于没有格式化，“attack now” 实际只输入了 “attack” 。假如真的是军事命令，比如是 “attack tomorrow&quot; ，就会变成 “attack&quot; ，从明天发起攻击变成了现在就攻击，呕吼。</p>
<p>实例4，写一个小的计算程序，用户输入两个数字和计算符号来进行一次运算。运算结束后，让用户来决定要再做新的计算或结束程序</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0614</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> a,b,ans</span><br><span class="line"><span class="keyword">character</span> :: key = <span class="string">&#x27;y&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span> (key == <span class="string">&#x27;y&#x27;</span> .or. key == <span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">    read(*,*) a</span><br><span class="line">    read(*, <span class="string">&quot;(a1)&quot;</span>) key</span><br><span class="line">    read(*,*) b</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">case</span>(key)</span><br><span class="line">    <span class="keyword">case</span>(<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        ans = a+b</span><br><span class="line">    <span class="keyword">case</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        ans = a-b</span><br><span class="line">    <span class="keyword">case</span>(<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        ans = a*b</span><br><span class="line">    <span class="keyword">case</span>(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        ans = a/b</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">default</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Unknown operater &#x27;,a1)&quot;</span>) key</span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">select</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(f6.2,a1,f6.2,&#x27;=&#x27;,f6.2)&quot;</span>) a,key,b,ans</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;(Y/y) to do again. (other) to exit.&quot;</span></span><br><span class="line">    read(*,<span class="string">&quot;(a1)&quot;</span>) key</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p>输入输出如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line">*</span><br><span class="line"><span class="number">5</span></span><br><span class="line">  <span class="number">3.00</span>*  <span class="number">5.00</span>= <span class="number">15.00</span></span><br><span class="line"> (Y/y) to <span class="keyword">do</span> again. (other) to <span class="keyword">exit</span>.</span><br><span class="line">n</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-5-习题">6-5 习题</h2>
<p>1 显示相同的字符串</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0615</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> counter</span><br><span class="line"><span class="keyword">do</span> counter=<span class="number">1</span>,<span class="number">5</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Fortran&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2 计算等差数列 1+3+……99</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0616</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> counter</span><br><span class="line"><span class="keyword">integer</span> :: ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">do</span> counter=<span class="number">1</span>,<span class="number">99</span>,<span class="number">2</span></span><br><span class="line">    ans = ans + counter</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) ans</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>输出结果 2500</p>
<p>3 改变一下猜体重的程序，最多猜5次，最后要告诉用户猜没猜对。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0605</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: weight = <span class="number">45.0</span> <span class="comment">!答案</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: e = <span class="number">0.001</span> <span class="comment">!误差</span></span><br><span class="line"><span class="keyword">real</span> :: guess = <span class="number">0.0</span> <span class="comment">!猜测值</span></span><br><span class="line"><span class="keyword">integer</span> :: counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> counter=<span class="number">1</span>,<span class="number">5</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;weight:&quot;</span></span><br><span class="line">    read(*,*) guess</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(guess - weight) &lt; e) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;You&#x27;re right&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;You&#x27;re wrong&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> weight:</span><br><span class="line"><span class="number">46</span></span><br><span class="line"> weight:</span><br><span class="line"><span class="number">45</span></span><br><span class="line"> You<span class="string">&#x27;re right</span></span><br><span class="line"><span class="string"> You&#x27;</span>re wrong</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我想实现的效果是，如果猜对了，用 stop 直接退出程序，这样就不会打印 ”You’re wrong“ 了。</p>
<p>但是这里 用stop 没有直接退出程序，仅仅是退出了循环。（不清楚什么原因）</p>
<p>重写</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0605</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: weight = <span class="number">45.0</span> <span class="comment">!答案</span></span><br><span class="line"><span class="keyword">real</span>, <span class="keyword">parameter</span> :: e = <span class="number">0.001</span> <span class="comment">!误差</span></span><br><span class="line"><span class="keyword">real</span> :: guess = <span class="number">0.0</span> <span class="comment">!猜测值</span></span><br><span class="line"><span class="keyword">integer</span> :: counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> counter=<span class="number">1</span>,<span class="number">5</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;weight:&quot;</span></span><br><span class="line">    read(*,*) guess</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(guess - weight) &lt; e) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">exit</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(guess - weight) &lt; e) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;You&#x27;re right&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;You&#x27;re wrong&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>逻辑是这样的，如果五次都没有猜对，最后的判断肯定还是不对的。如果有一次猜对了，退出循环，guess 就是正确的值，最后的判断就是对的。</p>
<p>4 以循环来计算 1/1！+ …… 1/10！</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0618</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> counter1,counter2</span><br><span class="line"><span class="keyword">integer</span> :: ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">integer</span> :: a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> counter1=<span class="number">1</span>,<span class="number">10</span></span><br><span class="line">    <span class="keyword">do</span> counter2=<span class="number">1</span>,counter1</span><br><span class="line">        a = a * counter2</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    ans = ans + <span class="number">1.0</span>/<span class="keyword">real</span>(a) <span class="comment">!必须进行类型转换，整数改为浮点数</span></span><br><span class="line">    a = <span class="number">1</span> <span class="comment">!a重新调整为1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">write</span>(*,*) ans</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为 1</p>
<p>这个结果错了，错的地方在于 ans 的数据格式，不是整数，而是浮点数</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0618</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> counter1,counter2</span><br><span class="line"><span class="keyword">real</span> :: ans = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">integer</span> :: a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> counter1=<span class="number">1</span>,<span class="number">10</span></span><br><span class="line">    <span class="keyword">do</span> counter2=<span class="number">1</span>,counter1</span><br><span class="line">        a = a * counter2</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    ans = ans + <span class="number">1.0</span>/<span class="keyword">real</span>(a) <span class="comment">!必须进行类型转换，整数改为浮点数</span></span><br><span class="line">    a = <span class="number">1</span> <span class="comment">!a重新调整为1</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) ans</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>输出结果为：1.71828163</p>
<p>5 消除字符串的空格（<strong>?</strong>）</p>
<p>这个我只能实现到，把所有非空格的字符打印出来。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0619</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">character</span>(len=<span class="number">30</span>) string</span><br><span class="line"><span class="keyword">integer</span> length</span><br><span class="line"><span class="keyword">integer</span> counter</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;char:&quot;</span></span><br><span class="line">read(*,<span class="string">&quot;(a30)&quot;</span>) string</span><br><span class="line"></span><br><span class="line">length = <span class="built_in">len_trim</span>(string)</span><br><span class="line"><span class="keyword">do</span> counter=<span class="number">1</span>,length</span><br><span class="line">    <span class="keyword">if</span> (string(counter:counter) /= <span class="string">&quot; &quot;</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,<span class="string">&quot;(a1)&quot;</span>) string(counter:counter)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>7 数组</h1>
<h2 id="7-1-基本使用">7-1 基本使用</h2>
<h3 id="7-1-1-一维数组">7-1-1 一维数组</h3>
<p>写一个程序来记录全班5位同学的数学成绩，并提供由座号来查询成绩的功能。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0701</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: students = <span class="number">5</span></span><br><span class="line"><span class="keyword">integer</span> :: student(students)</span><br><span class="line"><span class="keyword">integer</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i = <span class="number">1</span>,students</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Number&#x27;,i2)&quot;</span>) i</span><br><span class="line">    read(*,*) student(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Query:&quot;</span></span><br><span class="line">    read(*,*) i</span><br><span class="line">    <span class="keyword">if</span> (i&lt;=<span class="number">0</span> .or. i&gt;students) <span class="keyword">exit</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) student(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Number</span> <span class="number">1</span></span><br><span class="line"><span class="number">80</span></span><br><span class="line"><span class="keyword">Number</span> <span class="number">2</span></span><br><span class="line"><span class="number">85</span></span><br><span class="line"><span class="keyword">Number</span> <span class="number">3</span></span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="keyword">Number</span> <span class="number">4</span></span><br><span class="line"><span class="number">75</span></span><br><span class="line"><span class="keyword">Number</span> <span class="number">5</span></span><br><span class="line"><span class="number">95</span></span><br><span class="line"> Query:</span><br><span class="line"><span class="number">13</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>数组的声明方法如下（相比于正常的类型，就是加了一个括号而已）</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">datatype <span class="keyword">name</span>(<span class="built_in">size</span>)</span><br></pre></td></tr></table></figure>
<p>注意：这里的size 必须为<strong>常量</strong>（直接填入数字或者是使用声明为 parameter 的常数）</p>
<p>数组取值</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">student(<span class="number">1</span>) = <span class="number">89</span> <span class="comment">!第一个元素设置为89</span></span><br></pre></td></tr></table></figure>
<p>数组的索引值不需要是常量，也可以是变量。</p>
<p>使用数组时超出范围是很危险的，绝对要避免发生这种情况。</p>
<p>如果不使用数组，这个程序会这样写，非常繁琐（如果是50个人，500个人，这样写是不可能的）：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0702</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: student1,student2,student3,student4,student5</span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Number 1&quot;</span></span><br><span class="line">read(*,*) student1</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Number 2&quot;</span></span><br><span class="line">read(*,*) student2</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Number 3&quot;</span></span><br><span class="line">read(*,*) student3</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Number 4&quot;</span></span><br><span class="line">read(*,*) student4</span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Number 5&quot;</span></span><br><span class="line">read(*,*) student5</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>(.true.) </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Query:&quot;</span></span><br><span class="line">    read(*,*) i</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">case</span>(i)</span><br><span class="line">    <span class="keyword">case</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">write</span>(*,*) student1</span><br><span class="line">    <span class="keyword">case</span>(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">write</span>(*,*) student2</span><br><span class="line">    <span class="keyword">case</span>(<span class="number">3</span>)</span><br><span class="line">        <span class="built_in">write</span>(*,*) student3</span><br><span class="line">    <span class="keyword">case</span>(<span class="number">4</span>)</span><br><span class="line">        <span class="built_in">write</span>(*,*) student4</span><br><span class="line">    <span class="keyword">case</span>(<span class="number">5</span>)</span><br><span class="line">        <span class="built_in">write</span>(*,*) student5</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">default</span></span><br><span class="line">        <span class="keyword">exit</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">select</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p>最后再强调一点，数组除了可以使用基本的4种类型之外，还可以使用自定义类型。</p>
<h3 id="7-1-2-二维数组">7-1-2 二维数组</h3>
<p>声明数组大小，如果使用两个数字，它就变成二维数组。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">3</span>,<span class="number">3</span>) <span class="comment">!数组a是3×3的二维数组</span></span><br><span class="line">a(<span class="number">1</span>,<span class="number">1</span>) = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>保存整个年级5个班级，每班5个同学的数学考试成绩</p>
<p>这个程序和ex0701 很类似，差别这个是记录了几个班的学生成绩</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0703</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: classes = <span class="number">5</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: students = <span class="number">5</span></span><br><span class="line"><span class="keyword">integer</span> :: student(students, classes)</span><br><span class="line"><span class="keyword">integer</span> s <span class="comment">!用于赋值学生号码</span></span><br><span class="line"><span class="keyword">integer</span> c <span class="comment">!用于赋值班级号码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> c=<span class="number">1</span>,classes</span><br><span class="line">    <span class="keyword">do</span> s=<span class="number">1</span>,students</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Number &#x27;,i2, &#x27; of class &#x27;,i2)&quot;</span>) s,c</span><br><span class="line">        read(*,*) student(s,c)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;class:&quot;</span></span><br><span class="line">    read(*,*) c</span><br><span class="line">    <span class="keyword">if</span> (c&lt;=<span class="number">0</span> .or. c&gt;classes) <span class="keyword">exit</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;student:&quot;</span></span><br><span class="line">    read(*,*) s</span><br><span class="line">    <span class="keyword">if</span> (s&lt;=<span class="number">0</span> .or. s&gt;students) <span class="keyword">exit</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;score:&#x27;,i3)&quot;</span>) student(s,c) </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再看一个二维数组的例子，二维数组经常被拿来当作矩阵使用。</p>
<p>下面的例子可以让用户输入两个2×2矩阵的值，再把这两个矩阵相加。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0704</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: row = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: col = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span> :: matrixA(row,col)</span><br><span class="line"><span class="keyword">integer</span> :: matrixB(row,col)</span><br><span class="line"><span class="keyword">integer</span> :: matrixC(row,col)</span><br><span class="line"><span class="keyword">integer</span> r</span><br><span class="line"><span class="keyword">integer</span> c</span><br><span class="line"></span><br><span class="line"><span class="comment">!读入矩阵A的内容</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Matrix A&quot;</span></span><br><span class="line"><span class="keyword">do</span> r=<span class="number">1</span>,row</span><br><span class="line">    <span class="keyword">do</span> c=<span class="number">1</span>,col</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;A(&#x27;,i1,&#x27;,&#x27;,i1,&#x27;)=&#x27;)&quot;</span>) r,c</span><br><span class="line">        read(*,*) matrixA(r,c)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!读入矩阵B的内容</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Matrix B&quot;</span></span><br><span class="line"><span class="keyword">do</span> r=<span class="number">1</span>,row</span><br><span class="line">    <span class="keyword">do</span> c=<span class="number">1</span>,col</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;B(&#x27;,i1,&#x27;,&#x27;,i1,&#x27;)=&#x27;)&quot;</span>) r,c</span><br><span class="line">        read(*,*) matrixB(r,c)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!把矩阵A, B相加并输出结果</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Matrix A+B=&quot;</span></span><br><span class="line"><span class="keyword">do</span> r=<span class="number">1</span>,row</span><br><span class="line">    <span class="keyword">do</span> c=<span class="number">1</span>,col</span><br><span class="line">        matrixC(r,c) = matrixA(r,c) + matrixB(r,c)</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;(&#x27;,i1,&#x27;,&#x27;,i1,&#x27;)=&#x27;,i3)&quot;</span>) r,c,matrixC(r,c)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> Matrix A</span><br><span class="line">A(<span class="number">1</span>,<span class="number">1</span>)=</span><br><span class="line"><span class="number">1</span></span><br><span class="line">A(<span class="number">1</span>,<span class="number">2</span>)=</span><br><span class="line"><span class="number">1</span></span><br><span class="line">A(<span class="number">2</span>,<span class="number">1</span>)=</span><br><span class="line"><span class="number">1</span></span><br><span class="line">A(<span class="number">2</span>,<span class="number">2</span>)=</span><br><span class="line"><span class="number">1</span></span><br><span class="line"> Matrix B</span><br><span class="line">B(<span class="number">1</span>,<span class="number">1</span>)=</span><br><span class="line"><span class="number">2</span></span><br><span class="line">B(<span class="number">1</span>,<span class="number">2</span>)=</span><br><span class="line"><span class="number">2</span></span><br><span class="line">B(<span class="number">2</span>,<span class="number">1</span>)=</span><br><span class="line"><span class="number">2</span></span><br><span class="line">B(<span class="number">2</span>,<span class="number">2</span>)=</span><br><span class="line"><span class="number">2</span></span><br><span class="line"> Matrix A+B=</span><br><span class="line">(<span class="number">1</span>,<span class="number">1</span>)=  <span class="number">3</span></span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>)=  <span class="number">3</span></span><br><span class="line">(<span class="number">2</span>,<span class="number">1</span>)=  <span class="number">3</span></span><br><span class="line">(<span class="number">2</span>,<span class="number">2</span>)=  <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-1-3-多维数组">7-1-3 多维数组</h3>
<p>fortran 最高可以声明高达7维的数组。</p>
<p>看一个三维数组的实例，把上面那个矩阵相加的程序使用三维数组来改写。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0705</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: row = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: col = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span> :: matrix(row,col,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">integer</span> m</span><br><span class="line"><span class="keyword">integer</span> r</span><br><span class="line"><span class="keyword">integer</span> c</span><br><span class="line"></span><br><span class="line"><span class="comment">!读入矩阵的内容</span></span><br><span class="line"><span class="keyword">do</span> m=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Matrix &#x27;,i1)&quot;</span>) m</span><br><span class="line">    <span class="keyword">do</span> r=<span class="number">1</span>,row</span><br><span class="line">        <span class="keyword">do</span> c=<span class="number">1</span>,col</span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;(&#x27;,i1,&#x27;,&#x27;,i1,&#x27;)=&#x27;)&quot;</span>) r,c</span><br><span class="line">            read(*,*) matrix(r,c,m)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!把第1，2个矩阵相加</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Matrix 1 + Matrix 2 = &quot;</span></span><br><span class="line"><span class="keyword">do</span> r=<span class="number">1</span>,row</span><br><span class="line">    <span class="keyword">do</span> c=<span class="number">1</span>,col</span><br><span class="line">        matrix(r,c,<span class="number">3</span>) = matrix(r,c,<span class="number">1</span>) + matrix(r,c,<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;(&#x27;,i1,&#x27;,&#x27;,i1,&#x27;)=&#x27;,i3)&quot;</span>) r,c,matrix(r,c,<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-1-4-另类的数组声明">7-1-4 另类的数组声明</h3>
<p>在没有特别赋值的前提下，数组的索引值都是从1开始，例如：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">5</span>) <span class="comment">!共5个元素 a(1)-a(5)</span></span><br></pre></td></tr></table></figure>
<p>可以经过特别声明的办法来改变这个默认的规则，在声明时，可以特别赋值数组的坐标值使用范围，例如：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">0</span>:<span class="number">5</span>) </span><br><span class="line"><span class="comment">! 这个数组可以使用 a(0),a(1)……a(5) 这6个元素</span></span><br></pre></td></tr></table></figure>
<p>其他范围也是可以的。多维数组也是一样的道理。</p>
<h2 id="7-2-数组内容的设置">7-2 数组内容的设置</h2>
<p>数组也可以先设定初值</p>
<h3 id="7-2-1-赋初值">7-2-1 赋初值</h3>
<p>数组也可以像一般变量一样使用DATA 来设置数组的初值。例子如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">data</span> a /<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>/</span><br><span class="line"><span class="comment">!这样会把a的初始值设置为1-5</span></span><br></pre></td></tr></table></figure>
<p>data 的数据区还可以使用星号* 来表示数据重复</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">data</span> a /<span class="number">5</span>*<span class="number">3</span>/ <span class="comment">!5*3 在此指有5个3</span></span><br><span class="line"><span class="comment">! a(1) = a(2) = …… a(5) = 3</span></span><br></pre></td></tr></table></figure>
<p>另外有一种”隐含式“ 循环的功能可以用来设置数组的初值</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">integer</span> i</span><br><span class="line"><span class="keyword">data</span>(a(i), i=<span class="number">2</span>, <span class="number">4</span>)/<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>/</span><br><span class="line"><span class="comment">!这就是一个”隐含式”循环，i 会从2增加到4， 依照顺序到后面取数字，初值设定结果为a(2)=2,a(3)=3,</span></span><br><span class="line"><span class="comment">!a(4)=4, a(1)和a(5)没有设置</span></span><br></pre></td></tr></table></figure>
<p>“隐含” 的循环省略了 DO 的描述， 除了应用在声明的初值设置， 还可以应用在其他的程序代码中，像用来输出数组的内容</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">write</span>(*,*) (a(i), i=<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">!显示a(2),a(3),a(4)的值</span></span><br></pre></td></tr></table></figure>
<p>“隐含” 循环，只要在最后面再多加一个数字，同样可以改变计数器的累加数值，默认值为1。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">(A(i), i=<span class="number">2</span>,<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">!循环执行5次，分别为2 4 6 8 10</span></span><br></pre></td></tr></table></figure>
<p>隐含式循环也可以是多层嵌套的，所以也可以应用在多维数组上：（个人不建议）</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">integer</span> i,j</span><br><span class="line"><span class="keyword">data</span>((a(i,j), i=<span class="number">1</span>,<span class="number">2</span>),j=<span class="number">1</span>,<span class="number">2</span>) /<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>/</span><br><span class="line"><span class="comment">!里面括号的循环会先执行，设置结果为</span></span><br><span class="line">！a(<span class="number">1</span>,<span class="number">1</span>) =<span class="number">1</span> a(<span class="number">2</span>,<span class="number">1</span>)=<span class="number">2</span> a(<span class="number">1</span>,<span class="number">2</span>)=<span class="number">3</span> a(<span class="number">2</span>,<span class="number">2</span>)=<span class="number">4</span> 这个乱了</span><br></pre></td></tr></table></figure>
<p>Fortran90 中，可以省略DATA描述，直接设置初值</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>) =(/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /) <span class="comment">!注意括号和除号间不能有空格</span></span><br></pre></td></tr></table></figure>
<p>这种方式，数组的所有元素都必须给定一个初值。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>) = (/ <span class="number">1</span>,(<span class="number">2</span>,i=<span class="number">2</span>,<span class="number">4</span>),<span class="number">5</span> /)</span><br><span class="line"><span class="comment">!a(1)=1</span></span><br><span class="line"><span class="comment">!a(2)=a(3)=a(4)=2</span></span><br><span class="line"><span class="comment">!a(5)=5</span></span><br></pre></td></tr></table></figure>
<p>Fortran90 隐含式循环的功能可以更强大，例如</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>) = (/ (i,i=<span class="number">1</span>,<span class="number">5</span>) /)</span><br><span class="line"><span class="comment">! a(1)=1, a(2)=2, a(3)=3 ……</span></span><br></pre></td></tr></table></figure>
<p>把查询成绩的程序改写，学生成绩直接写在代码中</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0706</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: students = <span class="number">5</span></span><br><span class="line"><span class="keyword">integer</span> :: student(<span class="number">5</span>) = (/ <span class="number">80</span>,<span class="number">90</span>,<span class="number">85</span>,<span class="number">75</span>,<span class="number">95</span> /)</span><br><span class="line"><span class="keyword">integer</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Query:&quot;</span></span><br><span class="line">    read(*,*) i</span><br><span class="line">    <span class="keyword">if</span> (i&lt;=<span class="number">0</span> .or. i&gt;students) <span class="keyword">exit</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) student(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> Query:</span><br><span class="line"><span class="number">1</span></span><br><span class="line">          <span class="number">80</span></span><br><span class="line"> Query:</span><br><span class="line"><span class="number">2</span></span><br><span class="line">          <span class="number">90</span></span><br><span class="line"> Query:</span><br><span class="line"><span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>设置二维数组的内容，再输出到屏幕上。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0707</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: row = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: col = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span> :: m(row,col)</span><br><span class="line"><span class="keyword">integer</span> r</span><br><span class="line"><span class="keyword">integer</span> c</span><br><span class="line"><span class="keyword">data</span>((m(r,c), r=<span class="number">1</span>,<span class="number">2</span>), c=<span class="number">1</span>,<span class="number">2</span>) /<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>/</span><br><span class="line"></span><br><span class="line"><span class="comment">!按顺序输出m(1,1), m(2,1), m(1,2), m(2,2) 这4个数字</span></span><br><span class="line"><span class="comment">!在write中，用/换行</span></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(i3,i3,/,i3,i3)&quot;</span>) ((m(r,c),c=<span class="number">1</span>,<span class="number">2</span>),r=<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Fortran90 中，可以把所有数组元素都设置为一个相同的数值。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>) = <span class="number">5</span></span><br><span class="line"><span class="comment">!a(1) = a(2) = …… = a(5) =5</span></span><br></pre></td></tr></table></figure>
<h3 id="7-2-2-对整个数组的操作">7-2-2 对整个数组的操作</h3>
<p>Fortran 有一些方便的命名，可以直接操作整个数组。比如：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>这个命令将 a 的每个元素的值都设置为5。以一维的情况来看，这个命令相当于下面的程序代码：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,N</span><br><span class="line">	a(i) = <span class="number">5</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>下面这个命令设置为，a(1) =1， a(2) =2, a(3) =3，注意，这里等号右边所提供的数字数目必须跟数组a的大小一样。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> /)</span><br></pre></td></tr></table></figure>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a = b <span class="comment">!将a的元素设置和b相同</span></span><br><span class="line">a = b+c <span class="comment">!+-*/</span></span><br><span class="line">a = <span class="built_in">sin</span>(b)</span><br></pre></td></tr></table></figure>
<p>改写矩阵相加的程序。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0708</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: row = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">parameter</span> :: col = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span> :: ma(row,col) = <span class="number">1</span></span><br><span class="line"><span class="keyword">integer</span> :: mb(row,col) = <span class="number">4</span></span><br><span class="line"><span class="keyword">integer</span> :: mc(row,col)</span><br><span class="line"><span class="keyword">integer</span> :: i,j</span><br><span class="line"></span><br><span class="line">mc = ma + mb</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(i3,i3,/,i3,i3)&quot;</span>) ((mc(i,j),i=<span class="number">1</span>,<span class="number">2</span>),j=<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>  <span class="number">5</span></span><br><span class="line"><span class="number">5</span>  <span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再介绍一个特别的用法，这个需要和 where 命令搭配</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a = b &gt; c</span><br></pre></td></tr></table></figure>
<h3 id="7-2-3-对部分数组的操作">7-2-3 对部分数组的操作</h3>
<p>举例如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a(<span class="number">3</span>:<span class="number">5</span>) = <span class="number">5</span> <span class="comment">!把a(3) a(4) a(5) 内容设置为5</span></span><br><span class="line">a(<span class="number">3</span>:) =<span class="number">5</span> <span class="comment">!把a(3) 及之后的元素设置为5</span></span><br><span class="line">a(<span class="number">3</span>:<span class="number">5</span>) = (/ <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /)</span><br><span class="line">a(<span class="number">1</span>:<span class="number">3</span>) = b(<span class="number">4</span>:<span class="number">6</span>)</span><br><span class="line">a(<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>) = <span class="number">3</span> <span class="comment">!a(1)=a(3)=a(5)=3</span></span><br><span class="line">a(<span class="number">1</span>:<span class="number">10</span>) = a(<span class="number">10</span>:<span class="number">1</span>:-<span class="number">1</span>) <span class="comment">!反转</span></span><br><span class="line">a(:) = b(:, <span class="number">2</span>) <span class="comment">!a的元素设置为b的第二列</span></span><br></pre></td></tr></table></figure>
<p>要拿数组中一部分内容来使用时，只要把握两个原则就可以：</p>
<ol>
<li>
<p>等号两边所使用的数组元素数目要一样多</p>
</li>
<li>
<p>同时使用多个隐含式循环时，较低维的循环可以想象成是内层的循环。用一个实例来说明这个原则：</p>
</li>
</ol>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">2</span>,<span class="number">2</span>), b(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">b = a(<span class="number">2</span>:<span class="number">1</span>:-<span class="number">1</span>, <span class="number">2</span>:<span class="number">1</span>:-<span class="number">1</span>)</span><br><span class="line"><span class="comment">!b没特别赋值时，等于b(1:2:1, 1:2:1)</span></span><br><span class="line"><span class="comment">!低维的是内层循环，会先执行，所以这个命令结果为</span></span><br><span class="line"><span class="comment">!这个顺序和python的顺序是相反的</span></span><br><span class="line"><span class="comment">!b(1,1) = a(2,2)</span></span><br><span class="line"><span class="comment">!b(2,1) = a(1,2)</span></span><br><span class="line"><span class="comment">!b(1,2) = a(2,1)</span></span><br><span class="line"><span class="comment">!b(2,2) = a(1,1)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面用一个实例来简单示范一下本节的功能</p>
<p>源代码如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0709</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: row = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: col = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">2</span>,<span class="number">2</span>)  = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> /)</span><br><span class="line"><span class="comment">! a(1,1)=1,a(2,1)=2,a(1,2)=3,a(2,2)=4</span></span><br><span class="line"><span class="keyword">integer</span> :: b(<span class="number">4</span>) = (/ <span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> /)</span><br><span class="line"><span class="keyword">integer</span> :: c(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) a</span><br><span class="line"><span class="built_in">write</span>(*,*) a(:,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">c = a(:,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">write</span>(*,*) c</span><br><span class="line"></span><br><span class="line">c = a(<span class="number">2</span>,:)</span><br><span class="line"><span class="built_in">write</span>(*,*) c</span><br><span class="line"><span class="built_in">write</span>(*,*) c(<span class="number">2</span>:<span class="number">1</span>:-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">c = b(<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>)</span><br><span class="line"><span class="built_in">write</span>(*,*) c</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>报错了，因为下面这句话，a 是一个二维数组，却赋值给了一个一维数组的值。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">2</span>,<span class="number">2</span>)  = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> /)</span><br></pre></td></tr></table></figure>
<p>改写成如下，另外这里这里声明的 row 和 col 没有用到，可以删掉。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">integer</span> i,j</span><br><span class="line"><span class="keyword">data</span>((a(i,j),i=<span class="number">1</span>,<span class="number">2</span>),j=<span class="number">1</span>,<span class="number">2</span>) /<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>/</span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>           <span class="number">2</span>           <span class="number">3</span>           <span class="number">4</span></span><br><span class="line"><span class="number">1</span>           <span class="number">2</span></span><br><span class="line"><span class="number">1</span>           <span class="number">2</span></span><br><span class="line"><span class="number">2</span>           <span class="number">4</span></span><br><span class="line"><span class="number">4</span>           <span class="number">2</span></span><br><span class="line"><span class="number">5</span>           <span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意 <code>write(*,*) a</code> ，相当于 <code>write(1:2:1,1:2:1) a</code> ，低维的是内层循环，会先进行，所以会按照 a(1,1)  a(2,1) a(1,2)  a(2,2)  的顺序读取。</p>
<h3 id="7-2-4-where">7-2-4 where</h3>
<p>where 是 Fortran95 添加的功能。看一个实例</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0710 </span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>) = (/ (i,i=<span class="number">1</span>,<span class="number">5</span>) /)</span><br><span class="line"><span class="keyword">integer</span> :: b(<span class="number">5</span>) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!把a中小于3的元素设置给b</span></span><br><span class="line"><span class="keyword">where</span>(a&lt;<span class="number">3</span>)</span><br><span class="line">    b = a</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(5(i3,1x))&quot;</span>) b</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="number">2</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这里的 where 相当于</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">5</span></span><br><span class="line">	<span class="keyword">if</span>(a(i) &lt; <span class="number">3</span>) b(i) = a(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>虽然执行结果相同，但是使用 where 更简便，速度更快。</p>
<p>where 描述与 if 有点类似，如果程序模块只有一行命令时，同样可以把这一行命令写在where 后面，并且省略 end where。这个程序的9-11行可以改写为：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">where</span>(a&lt;<span class="number">3</span>) b=a</span><br></pre></td></tr></table></figure>
<p>where 只用于数组，而且用到的所有数组变量，都必须是<strong>同样维数和大小的数组</strong>。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>) = <span class="number">1</span></span><br><span class="line"><span class="keyword">integer</span> :: c(<span class="number">3</span>) = <span class="number">2</span></span><br><span class="line"><span class="keyword">where</span>(a/=<span class="number">0</span>) c=a</span><br><span class="line"><span class="comment">!上一行错误，维数不同</span></span><br><span class="line"><span class="keyword">where</span>(a(<span class="number">1</span>:<span class="number">3</span>)/=<span class="number">0</span>) c=a</span><br><span class="line"><span class="comment">!正确</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>where 还可以配合 elsewhere 来处理逻辑不成立的情况。来看下面的例子。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0711</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>) = (/ (i,i=<span class="number">1</span>,<span class="number">5</span>) /)</span><br><span class="line"><span class="keyword">integer</span> :: b(<span class="number">5</span>) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> (a&lt;<span class="number">3</span>)</span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line"><span class="keyword">elsewhere</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(5(i3,1x))&quot;</span>) b</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">2</span>   <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>where 还可以做多重判断，只要在 elsewhere 后面接上逻辑判断就行了</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">where</span>(a&lt;<span class="number">2</span>)</span><br><span class="line">	b=<span class="number">1</span></span><br><span class="line"><span class="keyword">elsewhere</span>(a&gt;<span class="number">5</span>)</span><br><span class="line">	b=<span class="number">2</span></span><br><span class="line"><span class="keyword">elsewhere</span> <span class="comment">!剩下2&lt;a(i)&lt;5的部分</span></span><br><span class="line">	b=<span class="number">3</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">where</span></span><br></pre></td></tr></table></figure>
<p>where 也可以嵌套，也可以起名字，不过取名的where 描述在结束时 end where 后面一定要接上名字。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">name</span>: <span class="keyword">where</span>(a&lt;<span class="number">5</span>) </span><br><span class="line">	b = a</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">where</span> <span class="keyword">name</span></span><br></pre></td></tr></table></figure>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">where</span>(a&lt;<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">where</span>(a/=<span class="number">2</span>)</span><br><span class="line">		b=<span class="number">3</span></span><br><span class="line">    <span class="keyword">elsewhere</span></span><br><span class="line">    	b=<span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">where</span></span><br><span class="line"><span class="keyword">elsewhere</span></span><br><span class="line">	b = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">where</span></span><br></pre></td></tr></table></figure>
<p>最后再看一个实例，计算10个人的所得税金额</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0712</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"><span class="keyword">real</span> :: income(<span class="number">10</span>) = (/ <span class="number">25000</span>,<span class="number">30000</span>,<span class="number">50000</span>,<span class="number">40000</span>,<span class="number">35000</span>,&amp;</span><br><span class="line">                        <span class="number">60000</span>,<span class="number">27000</span>,<span class="number">45000</span>,<span class="number">20000</span>,<span class="number">70000</span> /)</span><br><span class="line"><span class="keyword">real</span> :: tax(<span class="number">10</span>) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span>(income &lt; <span class="number">30000.0</span>)</span><br><span class="line">    tax = income*<span class="number">0.10</span></span><br><span class="line"><span class="keyword">elsewhere</span>(income &lt; <span class="number">50000.0</span>)</span><br><span class="line">    tax = income*<span class="number">0.12</span></span><br><span class="line"><span class="keyword">elsewhere</span></span><br><span class="line">    tax = income*<span class="number">0.15</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(10(f8.1,1x))&quot;</span>) tax</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">2500.0</span>   <span class="number">3600.0</span>   <span class="number">7500.0</span>   <span class="number">4800.0</span>   <span class="number">4200.0</span>   <span class="number">9000.0</span>   <span class="number">2700.0</span>   <span class="number">5400.0</span>   <span class="number">2000.0</span>  <span class="number">10500.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-2-5-forall">7-2-5 forall</h3>
<p>forall 是 Fortran95 添加的功能。它也可以看成是一种使用隐含式循环来使用数组的方式。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0713</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> i</span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">    a(i) = <span class="number">5</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line"><span class="comment">!a(1)=……=a(5)=5</span></span><br><span class="line"><span class="built_in">write</span>(*,*) a</span><br><span class="line"></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">    a(i) = i</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line"><span class="built_in">write</span>(*,*) a</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>           <span class="number">5</span>           <span class="number">5</span>           <span class="number">5</span>           <span class="number">5</span></span><br><span class="line"><span class="number">1</span>           <span class="number">2</span>           <span class="number">3</span>           <span class="number">4</span>           <span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第一段相当于</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">5</span></span><br><span class="line">	a(i) = <span class="number">5</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a(<span class="number">1</span>:<span class="number">5</span>) = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>forall 的 详细语法为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">forall</span> (triplet1[, triplet2[, triplet3……]], mask)</span><br></pre></td></tr></table></figure>
<p>triplet 是用来赋值数组坐标范围的值。</p>
<p>forall 中可以赋值好几个 triplet，数组最多有几维就可以赋值多少个。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">2</span>:<span class="number">10</span>:<span class="number">2</span>, j=<span class="number">1</span>:<span class="number">5</span>) <span class="comment">!二维数组可以用两个数字</span></span><br><span class="line">	a(i,j) = i+j</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br></pre></td></tr></table></figure>
<p>mask 是用来做条件判断，跟 where 命令中使用的条件判断类似，它可以用来限定 forall 程序模块中，只作用于数组中符合条件的元素。还可以做其他的条件限制，直接来看几个例子：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">integer</span> :: i,j</span><br><span class="line"></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>,j=<span class="number">1</span>:<span class="number">5</span>,a(i,j)&lt;<span class="number">10</span>) <span class="comment">!只处理数组a中小于10的元素</span></span><br><span class="line">	a(i,j) = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>,j=<span class="number">1</span>:<span class="number">5</span>,i==j)</span><br><span class="line"><span class="comment">!只做i==j的情况</span></span><br><span class="line">	a(i,j) = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>,j=<span class="number">1</span>:<span class="number">5</span>,((i&gt;j) .and. a(i,j) &gt; <span class="number">0</span>))</span><br><span class="line"><span class="comment">!多个判断条件</span></span><br><span class="line">	a(i,j) = <span class="number">1</span>/a(i,j)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>forall 描述中的程序模块如果只有一行程序代码时，也可以省略 end forall ， 把程序模块跟forall 写在同一行，就跟 if 及 where 的情况相同。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>, j=<span class="number">1</span>:<span class="number">5</span>, a(i,j) /= <span class="number">0</span>) a(i,j) = <span class="number">1</span>/a(i,j) </span><br></pre></td></tr></table></figure>
<p>再看一个实例，声明一个二维数组作为二维矩阵使用。它使用 forall 命令把矩阵的上半部设置为1， 对角线部分设置为2， 下半部设置为3。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0714</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> i,j</span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: <span class="built_in">size</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="built_in">size</span>,<span class="built_in">size</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="built_in">size</span>,j=<span class="number">1</span>:<span class="built_in">size</span>,i&gt;j) a(i,j) = <span class="number">1</span> <span class="comment">!上半部</span></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="built_in">size</span>,j=<span class="number">1</span>:<span class="built_in">size</span>,i==j) a(i,j) = <span class="number">2</span> <span class="comment">!对角线</span></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="built_in">size</span>,j=<span class="number">1</span>:<span class="built_in">size</span>,i&lt;j) a(i,j) = <span class="number">3</span> <span class="comment">!下半部</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(5(5i5,/))&quot;</span>) a</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>    <span class="number">1</span>    <span class="number">1</span>    <span class="number">1</span>    <span class="number">1</span></span><br><span class="line"><span class="number">3</span>    <span class="number">2</span>    <span class="number">1</span>    <span class="number">1</span>    <span class="number">1</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span>    <span class="number">2</span>    <span class="number">1</span>    <span class="number">1</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span>    <span class="number">3</span>    <span class="number">2</span>    <span class="number">1</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span>    <span class="number">3</span>    <span class="number">3</span>    <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>forall 可以写成多层的嵌套结构。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">forall</span>(j=<span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">		a(i,j) = <span class="number">2</span></span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line">	<span class="keyword">forall</span>(j=<span class="number">6</span>:<span class="number">10</span>)</span><br><span class="line">		a(i,j) = <span class="number">2</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br></pre></td></tr></table></figure>
<p>forall 中还可以嵌套 where。不过 where 当中不能使用 forall。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">where</span>(a(:,i)/=<span class="number">0</span>) </span><br><span class="line">		a(:,i) = <span class="number">1.0</span>/a(:,i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">where</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br></pre></td></tr></table></figure>
<h2 id="7-3-数组的保存规则">7-3 数组的保存规则</h2>
<p>一个数组不管是声明成什么“形状”（指维数和大小），它的所有元素都是分布再计算机内存的同一个连续模块当中。一维数组是最简单的，它的元素在内存中的排列位置刚好就依照元素的顺序。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">5</span>)</span><br><span class="line"><span class="comment">!元素在内存连续模块中的排列顺序为</span></span><br><span class="line"><span class="comment">!a(1) → a(2) → a(3) →  a(4) → a(5)</span></span><br></pre></td></tr></table></figure>
<p>多维数组的元素，在内存中的排列情况按照 “Column Major” 的方法来排列。先使用二维数组来解释，会先放入 column 中 每个 row 的元素， 第一个 column 放完了再放第二个 column。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">!a(1,1) → a(2,1) → a(3,1) (先放入第1个column中的元素)</span></span><br><span class="line"><span class="comment">!a(1,2) → a(2,2) → a(3,2) (再放入第2个column中的元素)</span></span><br><span class="line"><span class="comment">!a(1,3) → a(2,3) → a(3,3) (最后放入第3个column中的元素)</span></span><br></pre></td></tr></table></figure>
<p>引申到多维数组，会先放入较低维的元素，再放入较高维的元素。来看一个三维数组的实例</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">!a(1,1,1) → a(2,1,1) (先放入第1维)</span></span><br><span class="line"><span class="comment">!a(1,2,1) → a(2,2,1) (接着放入第2维)</span></span><br><span class="line"><span class="comment">!a(1,1,2) → a(2,1,2) (接着放入第3维)</span></span><br><span class="line"><span class="comment">!a(1,2,2) → a(2,2,2) </span></span><br></pre></td></tr></table></figure>
<p>用循环依照内存顺序读出这个数组的方法为：</p>
<p>这个有点难看懂，首先do 是内层先循环，这里维数越小的放在内层，也就是维数越小的先循环。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">	<span class="keyword">do</span> j=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">		<span class="keyword">do</span> k=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">			<span class="comment">!维越小的使用越内层的循环</span></span><br><span class="line">			<span class="built_in">write</span>(*,*) a(k,j,i)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>计算机原理：如果读取的数据比较近，速度会比较快。</p>
<p>因此，下面这种是比较不好的写法：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">	<span class="keyword">do</span> j=<span class="number">1</span>,m</span><br><span class="line">		a(i,j) = </span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>因为 a(i,j) 和 a(i,j+1) 在内存中的位置并不是连续的。下面的写法会比较好一点：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">	<span class="keyword">do</span> j=<span class="number">1</span>,m</span><br><span class="line">		a(j,i) = </span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>只要简单地把 i, j 的使用位置交换，就可以得到比较好的效率。因为 a(j,i) 和 a(j+1,i) 在内存中的位置是连续的。</p>
<p>解释过数组在内存的排列方法后，再回忆设置初值的部分，现在可以理解下面的程序为什么会有那样子的结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: a(<span class="number">2</span>,<span class="number">2</span>) = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> /)</span><br><span class="line"><span class="comment">!a(1,1)=1, a(2,1)=2, a(1,2)=3, a(2,2)=4</span></span><br><span class="line"><span class="comment">!正好是根据内存的排列顺序来设置数值</span></span><br></pre></td></tr></table></figure>
<h2 id="7-4-可变大小的数组">7-4 可变大小的数组</h2>
<p>某些情况下，要等程序执行之后，才会知道所需要使用的数组大小。</p>
<p>如果数组大小不能改变，只能这么编写程序：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0715</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: <span class="built_in">max</span> = <span class="number">1000</span></span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="built_in">max</span>) <span class="comment">!先声明一个超级大的数组</span></span><br><span class="line"><span class="keyword">integer</span> :: students</span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;How many students:&quot;</span></span><br><span class="line">read(*,*) students <span class="comment">!输入的数值不能超过 max</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!输入成绩</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,students</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Number &#x27;,i3)&quot;</span>) i</span><br><span class="line">    read(*,*) a(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> How many students:</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="keyword">Number</span>   <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">Number</span>   <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个做法是无可奈何的做法，首先声明一个超大的数组，然后再来使用数组的一小部分。</p>
<p>Fortran90 的数组则可以等到程序执行后，根据需求来实时决定它的大小。来看看下面的写法</p>
<p>这里用一个 ：表示 a是一维数组</p>
<p>分配内存空间的值可以使用变量，不像在声明一般数组时需要使用常量。</p>
<p>deallocate 可以释放内存。使用这两个命令可以用来重新设置数组大小。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0716</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: students</span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">allocatable</span> :: a(:) <span class="comment">!声明一个可变大小的一维数组</span></span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;How many students:&quot;</span></span><br><span class="line">read(*,*) students</span><br><span class="line"><span class="built_in">allocate</span>(a(students)) <span class="comment">!配置内存空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!输入成绩</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,students</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Number &#x27;,i3)&quot;</span>) i</span><br><span class="line">    read(*,*) a(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么，我在想，可不可以等知道需要多大的时候，再声明数组。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0716_2</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: students</span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;How many students:&quot;</span></span><br><span class="line">read(*,*) students</span><br><span class="line"></span><br><span class="line"><span class="keyword">integer</span> :: a(students)</span><br><span class="line"></span><br><span class="line"><span class="comment">!输入成绩</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,students</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Number &#x27;,i3)&quot;</span>) i</span><br><span class="line">    read(*,*) a(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不行，报错，貌似声明变量只能放在最前面</p>
<p>Fortran 报错应该也是看第一个报错。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">EX0716_2.F90:<span class="number">9.22</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">integer</span> :: a(students)</span><br><span class="line">                      <span class="number">1</span></span><br><span class="line">Error: Unexpected <span class="keyword">data</span> declaration statement at (<span class="number">1</span>)</span><br><span class="line">EX0716_2.F90:<span class="number">14.15</span>:</span><br><span class="line"></span><br><span class="line">    read(*,*) a(i)</span><br><span class="line">               <span class="number">1</span></span><br><span class="line">Error: Syntax error <span class="keyword">in</span> READ statement at (<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于内存空间有限，当然也就不能无限地要求空间。加一个 stat 的文本来判断内存配置是否成功。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">allocate</span>(a(<span class="number">100</span>),stat = error) <span class="comment">!如果error=0 表示分配成功；其他值表示分配失败</span></span><br></pre></td></tr></table></figure>
<p>声明其他维度的数组</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>,<span class="keyword">allocatable</span> :: a2(:,:) <span class="comment">!二维数组</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">allocatable</span> :: a3(:,:,:) <span class="comment">!三维数组</span></span><br><span class="line"><span class="built_in">allocate</span>(a2(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line"><span class="built_in">allocate</span>(a3(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<p>和 allocate 相关的函数还有 allocated ，用于检查一个可变大小的矩阵是否已经分配内存来使用，它会返回一个逻辑值。例如</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(.not. <span class="built_in">allocated</span>(a)) <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">allocate</span>(a(<span class="number">5</span>))</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="comment">!检查数组a是否分配内存，没有则分配5个</span></span><br></pre></td></tr></table></figure>
<h2 id="7-5-数组的应用">7-5 数组的应用</h2>
<p>首先看一个实用的问题，数组的排序。</p>
<p>先示范一个最简单的排序方法，叫做选择排序法</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0718</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: <span class="built_in">size</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="built_in">size</span>) = (/ <span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">10</span> /)</span><br><span class="line"><span class="keyword">integer</span> :: i,j</span><br><span class="line"><span class="keyword">integer</span> :: t</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="built_in">size</span>-<span class="number">1</span></span><br><span class="line">    <span class="keyword">do</span> j=i+<span class="number">1</span>,<span class="built_in">size</span></span><br><span class="line">        <span class="keyword">if</span>(a(i) &gt; a(j)) <span class="keyword">then</span> <span class="comment">!a(i)跟a(j) 交换</span></span><br><span class="line">            t = a(i) </span><br><span class="line">            a(i) = a(j)</span><br><span class="line">            a(j) = t</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(10i4)&quot;</span>) a</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>这个排序方法很简单，先说明它的步骤：</p>
<ol>
<li>把全部10个数字中，最小的那个找出来，跟 a(1) 交换位置。</li>
<li>把a(2~10)中，最小的那个找出来，跟 a(2) 交换位置。</li>
</ol>
<p>​    ……</p>
<ol start="9">
<li>把a(9~10)中，最小的那个找出来，跟 a(9) 交换位置，排序完成。</li>
</ol>
<p>具体看交换位置的内容</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">t = a(i) <span class="comment">!先把a(i)存起来</span></span><br><span class="line">a(i) = a(j) <span class="comment">!a(i) 设置成 a(j) 的值</span></span><br><span class="line">a(j) = t <span class="comment">!a(j) 设置成 a(i) 的值</span></span><br></pre></td></tr></table></figure>
<p>这里需要有一个中间变量。如果只用两个变量，会出错</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a(i) = a(j) <span class="comment">!a(i) 设置成 a(j) 的值</span></span><br><span class="line">a(j) = a(i) </span><br><span class="line"><span class="comment">!这里a(j)设置成a(i)的值，不过由于上一行a(i)已经设置成a(j)了。</span></span><br><span class="line"><span class="comment">!所以这一行白做工，啥也没干</span></span><br></pre></td></tr></table></figure>
<p>再看一个实例，做一个矩阵相乘的程序。</p>
<p>假设现在有两个二维矩阵 A, B，其中 A 的大小为 L*M ， B的大小为 M*N。现在要计算 C = A*B，它的大小一定为 L*N</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0719</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: l=<span class="number">3</span>,m=<span class="number">4</span>,n=<span class="number">2</span></span><br><span class="line"><span class="keyword">real</span> :: a(l,m)</span><br><span class="line"><span class="keyword">real</span> :: b(m,n)</span><br><span class="line"><span class="keyword">real</span> :: c(l,n)</span><br><span class="line"><span class="keyword">integer</span> :: i,j,k</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span>((a(i,j),i=<span class="number">1</span>,l),j=<span class="number">1</span>,m) / <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span> /</span><br><span class="line"><span class="keyword">data</span>((b(i,j),i=<span class="number">1</span>,m),j=<span class="number">1</span>,n) / <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> /</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i = <span class="number">1</span>,l</span><br><span class="line">    <span class="keyword">do</span> j = <span class="number">1</span>,n</span><br><span class="line">        c(i,j) = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">do</span> k=<span class="number">1</span>,m</span><br><span class="line">            c(i,j) = c(i,j) + a(i,k)*b(k,j)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,l</span><br><span class="line">    <span class="built_in">write</span>(*,*) c(i,:)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">70.0000000</span>       <span class="number">158.000000</span></span><br><span class="line"><span class="number">80.0000000</span>       <span class="number">184.000000</span></span><br><span class="line"><span class="number">90.0000000</span>       <span class="number">210.000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先要搞清楚，多层循环，内层先循环。这里也就是 i 和 j 不变，k 先循环一遍。得到的累加的结果就是 c(i,j) 的值。</p>
<p>事实上Fortran 90 库存函数就有提供 matmul 函数来做矩阵乘法。不过还是有必要学会作矩阵乘法的程序方法。</p>
<p>如果用函数，就一句解决</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">c = <span class="built_in">matmul</span>(a,b)</span><br></pre></td></tr></table></figure>
<h2 id="7-6-习题">7-6 习题</h2>
<p>1 声明一个大小为 10 的一维数组，初值为 a(i) = 2i ，并计算均值</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0720 </span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"><span class="keyword">integer</span> :: sum_a = <span class="number">0</span></span><br><span class="line"><span class="keyword">real</span> :: mean_a</span><br><span class="line"></span><br><span class="line"><span class="comment">!分配值</span></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">10</span>)</span><br><span class="line">    a(i) = <span class="number">2</span>*i <span class="comment">!开始少了*</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!求和</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">10</span></span><br><span class="line">    sum_a = sum_a + a(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">mean_a = <span class="keyword">real</span>(sum_a)/<span class="number">10.0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(f6.2)&quot;</span>) mean_a</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">11.00</span></span><br></pre></td></tr></table></figure>
<p>3 编写一个程序来计算前10个费氏数列，并保存在一个一维数组中。</p>
<p>费氏数列的规则</p>
<p>f(0) = 0</p>
<p>f(1) = 1</p>
<p>当 n &gt; 1, f(n) = f(n-1) + f(n-2)</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0721</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="number">0</span>:<span class="number">9</span>) <span class="comment">!注意这里的索引从0开始</span></span><br><span class="line"><span class="keyword">integer</span> :: i,j</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">0</span>,<span class="number">9</span></span><br><span class="line">    <span class="keyword">if</span> (i==<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        a(i) = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">        a(i) = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a(i) = a(i-<span class="number">1</span>) + a(i-<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(10i4)&quot;</span>) a</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>   <span class="number">1</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">5</span>   <span class="number">8</span>  <span class="number">13</span>  <span class="number">21</span>  <span class="number">34</span></span><br></pre></td></tr></table></figure>
<p>4 把排序程序 ex0718 改为从大排到小</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0718</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: <span class="built_in">size</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">integer</span> :: a(<span class="built_in">size</span>) = (/ <span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">10</span> /)</span><br><span class="line"><span class="keyword">integer</span> :: i,j</span><br><span class="line"><span class="keyword">integer</span> :: t</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="built_in">size</span>-<span class="number">1</span></span><br><span class="line">    <span class="keyword">do</span> j=i+<span class="number">1</span>,<span class="built_in">size</span></span><br><span class="line">        <span class="keyword">if</span>(a(i) &lt; a(j)) <span class="keyword">then</span> <span class="comment">!a(i)跟a(j) 交换</span></span><br><span class="line">            t = a(i) </span><br><span class="line">            a(i) = a(j)</span><br><span class="line">            a(j) = t</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(10i4)&quot;</span>) a</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>就是改一个符号</p>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>   <span class="number">9</span>   <span class="number">8</span>   <span class="number">7</span>   <span class="number">6</span>   <span class="number">5</span>   <span class="number">4</span>   <span class="number">3</span>   <span class="number">2</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1>8 函数</h1>
<p>函数是自定义函数和子程序的统称。</p>
<p>字符 →  Token  → 语句  →  程序单元  → 模块（module）  → 程序</p>
<p>程序单元： 执行某一特定任务的具有一定独立性的代码区域。包括<strong>主程序</strong>，<strong>子程序</strong>，<strong>函数</strong>。</p>
<blockquote>
<p>子程序 是没有返回值的函数</p>
<p>主程序只是默认被系统首次调用的，具有程序入口点作用的函数</p>
<p>程序单元的存在，是为了提高代码<strong>重复利用率</strong>。因此，各程序代码越“独立”，越能体现重复利用的作用。</p>
<p>一组程序单元及一组相关联的变量，可组成模块（module）</p>
</blockquote>
<blockquote>
<p>程序单元间的变量，一般是互相不通的！</p>
<p>implicit none 应该写在每一个程序单元</p>
</blockquote>
<h2 id="8-1-子程序（subroutine）的使用">8-1 子程序（subroutine）的使用</h2>
<p>写程序时，可以把某一段常常被使用、具有特定功能的程序代码独立出来，封装成子程序，以后只要经过调用的 call 命令就可以执行这一段程序代码。</p>
<p>先看一个例子</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0801</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">call</span> message() <span class="comment">!调用子程序 message</span></span><br><span class="line"><span class="keyword">call</span> message() <span class="comment">!再调用一次</span></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!子程序message</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> message()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;Hello.&quot;</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>子程序里可以包含所有命令，甚至包括调用其他子程序。</p>
<p>子程序和主程序的最大不同处在于：“主程序的程序代码，在程序一开始就自动会被执行，而子程序则不会自动执行，它需要被别人‘调用’ 才会执行。”</p>
<p>子程序以 subroutine 开头，同样要取一个名字，以end 或 end subroutine 结束（这个觉得更好）。严格地讲， end subroutine 后还可以接子程序的名字。</p>
<p>一个包含子程序的 Fortran 程序在结构上的模样大致如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> main <span class="comment">!主程序</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub1() <span class="comment">!第一个子程序</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> sub1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub2() <span class="comment">!第二个子程序</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> sub2</span><br></pre></td></tr></table></figure>
<p>其中，对主程序和子程序的安放顺序不作要求。</p>
<p>子程序最后一个命令通常是 “return&quot; ，表示程序要”返回“ 原来调用它的地方来继续执行程序（不写也可以，程序会自动返回）。<strong>return 可以使用在子程序中的任何地方，让子程序提早返回</strong>。</p>
<p>子程序除了可以让主程序调用之外，子程序之间也可以互相调用。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0802 </span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">call</span> sub1()</span><br><span class="line"><span class="keyword">call</span> sub2()</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> ex0802</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub1()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span> </span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;This is sub1&quot;</span></span><br><span class="line"><span class="keyword">call</span> sub2()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> sub1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub2()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="string">&quot;This is sub2&quot;</span></span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> sub2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">This is sub1 <span class="comment">!调用sub1</span></span><br><span class="line">This is sub2 <span class="comment">!调用sub1, sub1中又调用sub2</span></span><br><span class="line">This is sub2 <span class="comment">!调用sub2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>子程序可以在程序的任何地方被别人调用，甚至可以自己调用自己。这个操作称为”递归“。</p>
<p>关于子程序还有一个重要的概念，就是 ”子程序独立地拥有属于自己的变量声明”。也就是说，在主程序和其他的子程序之间，所声明出来的变量彼此是不相干的，假设在主程序与其他的子程序中使用了相同的变量名称，它们也是没有关系的不同变量。（说白了，就是变量空间呗）</p>
<p>来看一个实例</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0803</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a = <span class="number">1</span></span><br><span class="line"><span class="keyword">call</span> sub1()</span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;a=&#x27;,i2)&quot;</span>) a</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> ex0803</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub1()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a = <span class="number">2</span></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;a=&#x27;,i2)&quot;</span>) a</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> sub1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a= <span class="number">2</span> <span class="comment">!子程序</span></span><br><span class="line">a= <span class="number">1</span> <span class="comment">!主程序</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>除了变量独立以外，子程序也独立地拥有自己的“行代码”。</p>
<p>不过，有时候，调用子程序时，可以同时传递一些变量数据过去让它处理，这个操作叫做 ”传递参数“。</p>
<p>来看一个实例。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0804</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a = <span class="number">1</span></span><br><span class="line"><span class="keyword">integer</span> :: b = <span class="number">2</span></span><br><span class="line"><span class="keyword">call</span> add(a,b)</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> ex0804</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> add(first,second)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: first,second <span class="comment">!内容从 call中得到</span></span><br><span class="line"><span class="built_in">write</span>(*,*) first+second</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> add</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Fortran 在传递参数时使用的是传址调用（call by address/call by reference），这个意思是说所传递的参数，和子程序接收的参数，它们会使用相同的内存地址来记录数据（使用同一块内存来记录，可以视为同一个变量）。</p>
<p>比如，这里 first 和 a 会使用相同的内存地址来存储数值，所以 first 的值会等于 a，而<strong>如果修改first 的值，a 的内容也会跟着修改</strong>。</p>
<p>再来看一个实例。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0805</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a = <span class="number">1</span></span><br><span class="line"><span class="keyword">integer</span> :: b = <span class="number">2</span></span><br><span class="line"><span class="built_in">write</span>(*,*) a,b</span><br><span class="line"><span class="keyword">call</span> add(a)</span><br><span class="line"><span class="keyword">call</span> add(b)</span><br><span class="line"><span class="built_in">write</span>(*,*) a,b</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> ex0805</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> add(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: num</span><br><span class="line">num = num + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> add</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>           <span class="number">2</span></span><br><span class="line"><span class="number">2</span>           <span class="number">3</span> <span class="comment">!调用子程序后，修改了a,b</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有的程序语言会使用 “传值调用” （call by value）来传递参数，像C语言就使用传值调用。使用传值调用的程序语言，在子程序中改变参数内容，不会影响到调用处的变量内容。混合使用这两种语言时要注意这一点。（python 是只能调用，不能改变值的大小）</p>
<p>了解子程序的使用规则后，现在写一些比较有用途的东西。假设在一场田径赛的标枪选项中，有5位选手的投掷标枪的情况如下：</p>
<blockquote>
<p>1号选手：以30度角，每秒25米的速度掷出标枪。</p>
<p>2号选手：以45度角，每秒20米的速度掷出标枪。</p>
<p>3号选手：以35度角，每秒21米的速度掷出标枪。</p>
<p>4号选手：以50度角，每秒27米的速度掷出标枪。</p>
<p>5号选手：以40度角，每秒22米的速度掷出标枪。</p>
</blockquote>
<p>假设忽略空气阻力以及身高等等的因素，请写一个程序来计算选手们的投射距离。（自由投射物体的抛物线距离）。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0806</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: players = <span class="number">5</span></span><br><span class="line"><span class="keyword">real</span> :: angle(players) = (/ <span class="number">30.0</span>,<span class="number">45.0</span>,<span class="number">35.0</span>,<span class="number">50.0</span>,<span class="number">40.0</span> /)</span><br><span class="line"><span class="keyword">real</span> :: speed(players) = (/ <span class="number">25.0</span>,<span class="number">20.0</span>,<span class="number">21.0</span>,<span class="number">27.0</span>,<span class="number">22.0</span> /)</span><br><span class="line"><span class="keyword">real</span> :: distance(players)</span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,players</span><br><span class="line">    <span class="keyword">call</span> get_distance(angle(i),speed(i),distance(i))</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Player &#x27;,i1,&#x27; =&#x27;,f8.2)&quot;</span>) i,distance(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> ex0806</span><br><span class="line"></span><br><span class="line"><span class="comment">!把0-360的角度转换成弧度</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> angle_to_rad(angle,rad)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> angle,rad</span><br><span class="line"><span class="keyword">real</span>,<span class="keyword">parameter</span> :: pi = <span class="number">3.14159</span></span><br><span class="line">rad = angle*pi/<span class="number">180.0</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> angle_to_rad</span><br><span class="line"></span><br><span class="line"><span class="comment">!由角度、切线速度来计算投射距离</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> get_distance(angle,speed,distance)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> angle,speed <span class="comment">!输入的参数</span></span><br><span class="line"><span class="keyword">real</span> distance  <span class="comment">!返回结果</span></span><br><span class="line"><span class="keyword">real</span> rad,vx,time <span class="comment">!内部使用</span></span><br><span class="line"><span class="keyword">real</span>,<span class="keyword">parameter</span> :: g=<span class="number">9.81</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> angle_to_rad(angle,rad) <span class="comment">!单位转换</span></span><br><span class="line">vx = speed*<span class="built_in">cos</span>(rad) <span class="comment">!水平方向速度</span></span><br><span class="line">time = <span class="number">2.0</span>*speed*<span class="built_in">sin</span>(rad)/g <span class="comment">!在空中飞行时间</span></span><br><span class="line">distance = vx*time <span class="comment">!距离</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> get_distance</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">Player <span class="number">1</span> =   <span class="number">55.17</span></span><br><span class="line">Player <span class="number">2</span> =   <span class="number">40.77</span></span><br><span class="line">Player <span class="number">3</span> =   <span class="number">42.24</span></span><br><span class="line">Player <span class="number">4</span> =   <span class="number">73.18</span></span><br><span class="line">Player <span class="number">5</span> =   <span class="number">48.59</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>感觉函数和子程序最好还是用<strong>大小写混合</strong>，和一般变量区分开。</p>
<p>这种比较长的程序，需要有一个相应的说明书，写明每个子程序输入的参数、参数类型以及调用的功能。规范如下</p>
<blockquote>
<p><em>subroutine Get_Distance (angle, speed, distance)</em></p>
<p>功能：</p>
<p>计算投掷距离，只要输入速度（speed）及角度（angle），就可以由 distance 返回值中得到投掷距离。</p>
<p>参数：</p>
<p>real angle  输入投掷出去的角度</p>
<p>real speed 输入投掷出去的速度</p>
<p>real distance 返回计算得到的投掷距离</p>
<p><em>subroutine Angle_To_Rad (angle, rad)</em></p>
<p>功能：</p>
<p>把”角度“ 值转换成 ”弧度“， 输入一个角度就可以由 rad 得到转换出来的弧度。</p>
<p>参数：</p>
<p>real angle 输入所有转换的角度值</p>
<p>real rad     返回所对应的弧度值</p>
</blockquote>
<p>知道每一个子程序的功能后，可以直接阅读主程序来了解这个程序的运行。</p>
<h2 id="8-2-自定义函数（function">8-2 自定义函数（function)</h2>
<p>函数和子程序只有两点不同：</p>
<ol>
<li>调用自定义函数前要先声明。</li>
<li>自定义函数执行后会返回一个数值。</li>
</ol>
<p>先来看一个简单的实例</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0807</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> :: a = <span class="number">1</span></span><br><span class="line"><span class="keyword">real</span> :: b = <span class="number">2</span></span><br><span class="line"><span class="keyword">real</span>,<span class="keyword">external</span> :: Add <span class="comment">!声明 add是一个函数而不是变量</span></span><br><span class="line"><span class="comment">!调用函数add，调用函数不必使用call命令</span></span><br><span class="line"><span class="built_in">write</span>(*,*) Add(a,b)</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span></span> Add(a,b)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> :: a,b</span><br><span class="line"><span class="keyword">real</span> :: add</span><br><span class="line"><span class="comment">!add和函数名称一样，这里不是用来声明变量</span></span><br><span class="line"><span class="comment">!是声明这个函数会返回的数值类型</span></span><br><span class="line">add = a+b</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">3.00000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第14行是声明函数返回值的类型，这句可以合并在 function 的行</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> add(a,b) </span><br></pre></td></tr></table></figure>
<p>使用函数时有一个**”不成文规定“** ：”<strong>传递给函数的参数，只准读取，不要改变它的数值</strong>。</p>
<p>如果想要改变输入的参数时，最好使用子程序，而不是使用函数来完成这个工作。</p>
<p>上一节计算投标枪的程序很适合使用函数来编写，来看看改写后的结果：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0808</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span>,<span class="keyword">parameter</span> :: players = <span class="number">5</span></span><br><span class="line"><span class="keyword">real</span> :: angle(players) = (/ <span class="number">30.0</span>,<span class="number">45.0</span>,<span class="number">35.0</span>,<span class="number">50.0</span>,<span class="number">40.0</span> /)</span><br><span class="line"><span class="keyword">real</span> :: speed(players) = (/ <span class="number">25.0</span>,<span class="number">20.0</span>,<span class="number">21.0</span>,<span class="number">27.0</span>,<span class="number">22.0</span> /)</span><br><span class="line"><span class="keyword">real</span> :: distance(players)</span><br><span class="line"><span class="keyword">real</span>,<span class="keyword">external</span> :: Get_Distance <span class="comment">!声明Get_Distance 是个函数</span></span><br><span class="line"><span class="keyword">integer</span> :: i</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,players</span><br><span class="line">    distance(i) =  Get_Distance(angle(i),speed(i))</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Player &#x27;,i1,&#x27; =&#x27;,f8.2)&quot;</span>) i,distance(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> ex0808</span><br><span class="line"></span><br><span class="line"><span class="comment">!把0-360的角度转换成弧度</span></span><br><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Angle_To_Rad(angle)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> angle</span><br><span class="line"><span class="keyword">real</span>,<span class="keyword">parameter</span> :: pi = <span class="number">3.14159</span></span><br><span class="line">Angle_To_Rad = angle*pi/<span class="number">180.0</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!由角度、切线速度来计算投射距离</span></span><br><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Get_Distance(angle,speed)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> angle,speed <span class="comment">!输入的参数</span></span><br><span class="line"><span class="keyword">real</span> rad,vx,time <span class="comment">!内部使用</span></span><br><span class="line"><span class="keyword">real</span>,<span class="keyword">external</span> :: Angle_To_Rad <span class="comment">!声明Angle_To_Rad是个函数</span></span><br><span class="line"><span class="keyword">real</span>,<span class="keyword">parameter</span> :: g=<span class="number">9.81</span></span><br><span class="line"></span><br><span class="line">rad = Angle_To_Rad(angle) <span class="comment">!单位转换</span></span><br><span class="line">vx = speed*<span class="built_in">cos</span>(rad) <span class="comment">!水平方向速度</span></span><br><span class="line">time = <span class="number">2.0</span>*speed*<span class="built_in">sin</span>(rad)/g <span class="comment">!在空中飞行时间</span></span><br><span class="line">Get_Distance = vx*time <span class="comment">!距离</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用函数来改写后，可以比原来的程序少输入一个参数。因为计算结果值直接由函数返回去，不需要另外使用变量来返回结果。</p>
<h2 id="8-3-全局变量（common）">8-3 全局变量（common）</h2>
<p>不同的程序（不同的函数，主程序和函数）之间，除了可以通过传递参数的方法来共享内存，还可以通过“全局变量” 来让不同程序中声明出来的变量使用相同的内存位置。</p>
<h3 id="8-3-1-common-的使用">8-3-1 common 的使用</h3>
<p>来可以一个实例</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0810</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a,b</span><br><span class="line"><span class="keyword">common</span> a,b <span class="comment">!定义a,b是全局变量中的第1及第2个变量</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="keyword">call</span> ShowCommon()</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowCommon()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: num1,num2</span><br><span class="line"><span class="keyword">common</span> num1,num2 <span class="comment">!定义num1,num2是全局变量中的第1个及第2个变量</span></span><br><span class="line"><span class="built_in">write</span>(*,*) num1,num2</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>           <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>取用全局变量时，是根据它们声明时的<strong>相对位置</strong>关系来作对应，而不是使用变量名称。因此这里的 a 和 num1 都是指向第一个全局变量，b 和 num2 都是指向第二个全局变量。</p>
<p>如果在程序的任何一个地方改变了全局变量的值，因为全局变量都使用相同的内存位置，所以程序中的每一个函数中都可以觉察到这个变动。</p>
<p>由于全局变量是使用“地址对应”的方法共享数据，因此如果你只想调出第6个全局变量，也得宣告出前5个全局变量在前面垫着。</p>
<p>这种麻烦在全局变量多的情况之下更为惊人。有一种方法可以减少这个麻烦，就是可以把变量归类，放在彼此独立的 common 区间中。</p>
<p>来看下面这个程序</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0811</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a,b</span><br><span class="line"><span class="keyword">common</span> /group1/ a <span class="comment">!变量a 放在group1中</span></span><br><span class="line"><span class="keyword">common</span> /group2/ b</span><br><span class="line">a=<span class="number">1</span></span><br><span class="line">b=<span class="number">2</span></span><br><span class="line"><span class="keyword">call</span> Show_Group1()</span><br><span class="line"><span class="keyword">call</span> Show_Group2()</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Show_Group1()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: num1</span><br><span class="line"><span class="keyword">common</span> /group1/ num1</span><br><span class="line"><span class="built_in">write</span>(*,*) num1</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Show_Group2()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: num2</span><br><span class="line"><span class="keyword">common</span> /group2/ num2</span><br><span class="line"><span class="built_in">write</span>(*,*) num2</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么，什么时候该使用参数，什么时候该使用全局变量呢？</p>
<p>简单地说，当需要共享的变量不多，而且只有少数几个程序需要使用这些数据时，那就使用参数。需要共享大笔数据，或是有很多个不同程序都需要使用这些数据时，就使用全局变量。</p>
<h3 id="8-3-2-block-data">8-3-2 block data</h3>
<p>关于全局变量，还有一点要介绍的就是设置初值的方法，common 变量不能直接在子程序或主程序中使用 data 来设置初值，要在 block data 程序模块中使用 data 命令来设置初值，直接看一个程序。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0812</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> :: a,b</span><br><span class="line"><span class="keyword">common</span> a,b</span><br><span class="line"><span class="keyword">integer</span> :: c,d</span><br><span class="line"><span class="keyword">common</span> /group1/ c,d</span><br><span class="line"><span class="keyword">integer</span> :: e,f</span><br><span class="line"><span class="keyword">common</span> /group2/ e,f</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(*, <span class="string">&quot;(6i4)&quot;</span>) a,b,c,d,e,f</span><br><span class="line"></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">block</span> <span class="keyword">data</span></span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> a,b</span><br><span class="line"><span class="keyword">common</span> a,b </span><br><span class="line"><span class="keyword">data</span> a,b /<span class="number">1</span>,<span class="number">2</span>/</span><br><span class="line"><span class="keyword">integer</span> :: c,d</span><br><span class="line"><span class="keyword">common</span> /group1/ c,d</span><br><span class="line"><span class="keyword">data</span> c,d /<span class="number">3</span>,<span class="number">4</span>/</span><br><span class="line"><span class="keyword">integer</span> :: e,f</span><br><span class="line"><span class="keyword">common</span> /group2/ e,f</span><br><span class="line"><span class="keyword">data</span> e,f /<span class="number">5</span>,<span class="number">6</span>/</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">block</span> <span class="keyword">data</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>block data 会自己执行，事实上这一段程序会在主程序执行前就会生效，不过只能设置初值（那有球用）。还有一点，全局变量不能设置为常数，所以block data中不能出现 parameter。</p>
<h3 id="8-3-3-注意事项">8-3-3 注意事项</h3>
<p>使用 common 时要注意两点：</p>
<ol>
<li>变量的类型</li>
<li>变量的位置</li>
</ol>
<p>来看一个例子</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0813</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> a</span><br><span class="line"><span class="keyword">common</span> a <span class="comment">!把浮点数a放在全局变量中</span></span><br><span class="line">a = <span class="number">1.0</span></span><br><span class="line"><span class="keyword">call</span> Show_Common()</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Show_Common()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">integer</span> a</span><br><span class="line"><span class="keyword">common</span> a</span><br><span class="line"><span class="built_in">write</span>(*,*) a <span class="comment">!把整数a放在全局变量中</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行后输出一个很奇怪的数值</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1065353216</span></span><br></pre></td></tr></table></figure>
<p>主程序把全局变量设置为 1.0 , 但是在子程序中却声明成整数。这是存入数据的时候按照浮点数的规则，读取数据的时候又按照整数的规则。但是浮点数和整数保存规则不同。</p>
<p>使用 common 时还有一些技巧，来看下一个例子。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0814</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> a,b</span><br><span class="line"><span class="keyword">common</span> a,b <span class="comment">!把浮点数a,b加入全局变量中</span></span><br><span class="line">a = <span class="number">1.0</span></span><br><span class="line">b = <span class="number">2.0</span></span><br><span class="line"><span class="keyword">call</span> Show_Common()</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Show_Common()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">real</span> a(<span class="number">2</span>) </span><br><span class="line"><span class="keyword">common</span> a <span class="comment">!把数组a放入到全局变量中</span></span><br><span class="line"><span class="built_in">write</span>(*,*) a(<span class="number">1</span>),a(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">1.00000000</span>       <span class="number">2.00000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里使用全局变量时，把握了它们会使用相同内存空间的策略。主程序中在全局变量中放了两个变量a和b，子程序也放入了两个变量，不过它放的是一个大小为2 的数组。所以数组的第1个值就等于主程序中的变量a，第2个值等于主程序中的变量b。</p>
<p>使用 COMMON 时，编译器并不会帮忙做类型检查的工作，这个责任要由程序员自行负责。有一点很麻烦的是，如果要修改 COMMON 的数据类型，要改的地方可能会很多。</p>
<p>Fortran90 有另一种方法来使用全局变量，它可以避免这两个问题。</p>
<h2 id="8-4-函数中的变量">8-4 函数中的变量</h2>
<h3 id="8-4-1-传递参数的注意事项">8-4-1 传递参数的注意事项</h3>
<p>传递参数给函数时，最重要的一点是：”类型要正确“。</p>
<p>如果类型不同，可以会得到难以预料的结果（因为Fortran实际是传递内存地址，”加密“ ”解密“ 方式不同肯定会出问题）。</p>
<p>这里来做一个实验</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0815</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> :: a=<span class="number">1.0</span></span><br><span class="line">    <span class="keyword">call</span> ShowInteger(a)</span><br><span class="line">    <span class="keyword">call</span> ShowReal(a)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowInteger(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: num </span><br><span class="line">    <span class="built_in">write</span>(*,*) num</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowReal(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> :: num</span><br><span class="line">    <span class="built_in">write</span>(*,*) num</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1065353216</span><br><span class="line">  1.00000000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>传递参数也可以直接传递常量，但是记得输入正确的数据类型，区分整数和浮点数；另外，函数中不能修改参数的值，因为常量不能被修改。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> ShowInteger(<span class="number">1</span>) </span><br><span class="line"><span class="keyword">call</span> ShowReal(<span class="number">1.0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="8-4-2-数组参数">8-4-2 数组参数</h3>
<p>数组惠占据一块内存中的连续空间。在传递数组参数时，实际上是传递数组元素当中的某一个内存地址。</p>
<p>举个例子。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0816</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a(<span class="number">5</span>)=(/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /)</span><br><span class="line">    <span class="keyword">call</span> ShowOne(a) <span class="comment">!输入a, 就是输入数组a第一个元素的内存地址</span></span><br><span class="line">    <span class="keyword">call</span> ShowArray5(a)</span><br><span class="line">    <span class="keyword">call</span> ShowArray3(a)</span><br><span class="line">    <span class="keyword">call</span> ShowArray3(a(<span class="number">2</span>)) <span class="comment">!输入a(2), 就是输入数组a第2个元素的内存地址</span></span><br><span class="line">    <span class="keyword">call</span> ShowArray2X2(a)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowOne(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: num <span class="comment">!只取出参数地址中的第1个数字</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) num</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowArray5(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: num(<span class="number">5</span>) <span class="comment">!只取出参数地址中的前5个数字， 当成数组来使用</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) num</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowArray3(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: num(<span class="number">3</span>) <span class="comment">!只取出参数地址中的前3个数字， 当成数组来使用</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) num</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowArray2X2(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: num(<span class="number">2</span>,<span class="number">2</span>) <span class="comment">!只取出参数地址中的前4个数字， 当成2X2数组来使用</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) num(<span class="number">2</span>,<span class="number">1</span>),num(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译时有 warning</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gfortran EX0816.F90</span></span><br><span class="line">EX0816.F90:4.17:</span><br><span class="line"></span><br><span class="line">    call ShowOne(a) !\xE8\xBE\x93\xE5\x85\xA5a, \xE5\xB0\xB1\xE6\x98\xAF\xE8\xBE</span><br><span class="line">                 1</span><br><span class="line">Warning: Rank mismatch in argument &#x27;num&#x27; at (1) (scalar and rank-1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果如下</p>
<p>先看第一个结果， call ShowOne(a) 会将传入的参数作为一个整数接收，这里传进来的是数组a，也就是 a(1) 的地址。</p>
<p>第二个结果，call showArray5(a) 正好将传入的参数作为一个大小为5的一维数组。第三个结果截取了前三个元素。</p>
<p>第四个个结果输入a(2) ，因此返回的数组的起始位置会等于 a(2)。</p>
<p>第五个结果会将参数当作2×2的数组使用。根据数组的内存排列原则，num(1,1) = a(1) , num(2,1) = a(2), num(1,2) = a(3), num(2,2) = a(4)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1           2           3           4           5</span><br><span class="line">1           2           3</span><br><span class="line">2           3           4</span><br><span class="line">2           4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>数组在定义的时候需要使用常量来赋值它的大小。不过在函数中，如果数组是接收用的参数时，可以例外。这个时候可以用变量来赋值它的大小，甚至可以不去赋值大小，来看下面的例子。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0817</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">parameter</span> :: <span class="built_in">size</span> = <span class="number">5</span></span><br><span class="line">    <span class="keyword">integer</span> :: s = <span class="built_in">size</span></span><br><span class="line">    <span class="keyword">integer</span> :: a(<span class="built_in">size</span>) = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /)</span><br><span class="line">    <span class="keyword">call</span> UseArray1(a,<span class="built_in">size</span>) <span class="comment">!把常量size输入做数组大小</span></span><br><span class="line">    <span class="keyword">call</span> UseArray1(a,s) <span class="comment">!把一般变量s输入做数组大小</span></span><br><span class="line">    <span class="keyword">call</span> UseArray2(a) <span class="comment">!不输入数组大小</span></span><br><span class="line">    <span class="keyword">call</span> UseArray3(a) </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> UseArray1(num,<span class="built_in">size</span>)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: <span class="built_in">size</span></span><br><span class="line">    <span class="keyword">integer</span> :: num(<span class="built_in">size</span>) <span class="comment">!输入数组的大小可用变量来赋值</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) num</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> UseArray2(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: num(*) <span class="comment">!不赋值数组大小</span></span><br><span class="line">    <span class="keyword">integer</span> :: i </span><br><span class="line">    <span class="built_in">write</span>(*,*) (num(i),i=<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line">    <span class="comment">!如果输入的数组大于小于5，write在执行时会出现错误</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> UseArray3(num)</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: num(-<span class="number">2</span>:<span class="number">2</span>) <span class="comment">!重新定义数组坐标范围</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) num(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果如下。其中 UseArray1 中使用输入的变量来设置数组的大小，UseArray2 则在设置大小时使用一个星号，代表不指定大小的意思。UseArray3 则重新定义了数组坐标值范围。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1           2           3           4           5</span><br><span class="line">1           2           3           4           5</span><br><span class="line">1           2           3           4           5</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为什么在函数中不用赋值数组大小呢？因为在主程序中已经创建好了数组，在进入到子程序前数组就已经配置到内存空间了。函数不会额外配置新的内存空间，在函数中赋值数组大小只是用来方便检查，不会去重新配置内存，所以可以省略。</p>
<p>子程序 UseArray3 是比较特殊的用法，它定义数组 num 坐标范围为 -2~2, 所以 num(-2) = a(1), num(-1)=a(0) ……。</p>
<p>函数中只要注意使用数组参数时，<strong>不要超过它的实际范围</strong>就行了。其他方面要如何使用都没有关系。如果超出了实际范围，编译时不会出现错误，在执行时会出现奇怪的结果，甚至死机。</p>
<p>顺便提一点，传递字符串变量时，也可以不特别赋值它的长度。原因相同，因为它的长度早就设置好了。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">character</span>(len=*) string</span><br></pre></td></tr></table></figure>
<p>举例</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0818</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: str=<span class="string">&quot;Hello, Fortran 95.&quot;</span></span><br><span class="line">    <span class="keyword">call</span> ShowString(str) <span class="comment">!输入字符串开头地址</span></span><br><span class="line">    <span class="keyword">call</span> ShowString(str(<span class="number">8</span>:)) <span class="comment">!输入字符串第8个字符的地址</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ShowString(str)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=*) :: str</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="built_in">len_trim</span>(str)</span><br><span class="line">    <span class="built_in">write</span>(*,*) str</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         18</span><br><span class="line">Hello, Fortran 95.</span><br><span class="line">         11</span><br><span class="line">Fortran 95.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>子程序如果赋值字符串长度，不能超过实际长度。</p>
<p>再回到数组的部分，多维数组在传递时，只有最后一维可以不赋值大小，其他维都必须赋值大小，来看一个实例。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0819</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">parameter</span> :: dim1 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">parameter</span> :: dim2 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">parameter</span> :: dim3 = <span class="number">2</span></span><br><span class="line">    <span class="keyword">integer</span> :: a(dim1,dim2,dim3)</span><br><span class="line">    a(:,:,<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">    a(:,:,<span class="number">2</span>) = <span class="number">2</span></span><br><span class="line">    <span class="keyword">call</span> GetArray1(a(:,:,<span class="number">1</span>),dim1,dim2)</span><br><span class="line">    <span class="keyword">call</span> GetArray2(a(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>),dim1)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> GetArray1(a,dim1,dim2)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: dim1,dim2</span><br><span class="line">    <span class="keyword">integer</span> :: a(dim1,dim2)</span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> GetArray2(a,dim1)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: dim1,dim2</span><br><span class="line">    <span class="keyword">integer</span> :: a(dim1,*) <span class="comment">!最后一维可以不赋值数组大小</span></span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="built_in">write</span>(*,*) (a(:,i),i=<span class="number">1</span>,<span class="number">2</span>) <span class="comment">! 必须指定输出哪几维</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1           1           1           1</span><br><span class="line">2           2           2           2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序示范了两个东西，第一是把三维数组传递到子程序中变成二维数组的方法，第二是示范了多维数组的最后一个维度可以不赋值大小。程序第9行是用来输入部分数组。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> GetArray1(a(:,:,<span class="number">1</span>),dim1,dim2)</span><br></pre></td></tr></table></figure>
<p>因为数组 a(1~2, 1~2, 1) 这4个元素在内存中是连续存放的，这里<strong>参数放入a(:,:,1) 就等于放入a(1,1,1) 的地址</strong>。子程序接收时改用二维数组来使用这块内存，所以这里等于是把原来容量为 dim1×dim2×dim3 的 三维数组中拿出当中一小块当成容量为 dim1×dim2 的 二维数组。</p>
<p>第10行是同样的用法，只是它换了一个写法，而且放入的是另一块空间。但是它没有赋值第二维的大小，这是合理的语法。</p>
<p>不过用这个方法后，输出数组a的时候要指定它的范围。因为声明时没说明它的第二维有多大。（—这不是脱裤子××嘛，那就直接指定好范围就行了呗）</p>
<p>你看，后面又建议。</p>
<blockquote>
<p>笔者建议还是不要偷懒，把数组实际声明大小全部都传递出去是比较好的做法。</p>
</blockquote>
<h3 id="8-4-3-变量的生存周期">8-4-3 变量的生存周期</h3>
<p>函数中的变量（不含所输入的参数）有它们的 “生存周期”。它们所能够生存的时间，只有在这个子程序被调用执行的这一段时间中。子程序结束后，它们就“死亡” 了，所保存的数据也会跟着被埋没掉。</p>
<p>在声明中加入 SAVE 可以拯救这些变量。这些变量可以在程序执行中永久记忆住上一次函数调用时所被设置的数值，来看看这一个实例：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0820</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">call</span> sub()</span><br><span class="line">    <span class="keyword">call</span> sub()</span><br><span class="line">    <span class="keyword">call</span> sub()</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub()</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: <span class="built_in">count</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">save</span> <span class="built_in">count</span> <span class="comment">!赋值count变量会永久活着，不会忘记它的内容</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="built_in">count</span></span><br><span class="line">    <span class="built_in">count</span> = <span class="built_in">count</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在 save 命令后面的变量的生存周期将不只局限在子程序的执行过程中，会延申到整个程序的执行时间一样长。<strong>注意，变量的初值只会设置一次</strong>。所以第11行设置 count 初值的操作只会执行一次，并不是每次调用 sub 时，count 都会重新设置为1。</p>
<p>在 Fortran 90 中，可以把 save 和 声明写在同一行，如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>,<span class="keyword">save</span> :: <span class="built_in">count</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>有些编译器不管有没有指明 save，都会记住数值</strong>。我这里做了一次，gfortran 就是这样，注释掉 save 行，输出结果不变。（我感觉这一点不好，我可能会重复运行一个函数，中间的临时变量我肯定希望重置，现在默认都记住了，不知道怎么弄）</p>
<h3 id="8-4-4-传递函数">8-4-4 传递函数</h3>
<p>传递参数时，除了传递数字、字符串等数据外，还可以把一个函数名称传递过去。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0821</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: func <span class="comment">!声明 func 是个自定义函数</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">intrinsic</span> :: <span class="built_in">sin</span> <span class="comment">!声明sin是一个库函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">call</span> ExecFunc(func) <span class="comment">!输入自定义函数 func</span></span><br><span class="line">    <span class="keyword">call</span> ExecFunc(<span class="built_in">sin</span>) <span class="comment">!输入库函数 sin</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> ExecFunc(f)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: f <span class="comment">!声明参数f是个函数</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) f(<span class="number">1.0</span>) </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> func(num)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> :: num</span><br><span class="line">    func = num*<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 2.00000000</span><br><span class="line">0.841470957</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第三行的声明中使用了 EXTERNAL,  前面曾介绍过这是用来表明所声明的是一个自定义函数的名称。第四行的声明中使用了一个新的关键字 INTRINSIC, 用来表明所声明的 sin 是 Fortran 的 库存函数，而不是一个变量。在这个程序中 EXTERNAL 和 INTRINSIC 这两个字都不能省略，因为在这里要把函数名称当成参数传递出去。如果纯粹把函数拿来计算使用，不把它当成参数传递出去，声明 func 时可以省略 EXTERNAL，声明 sin 的这一整行则可以完全省略。</p>
<p>第6、7行执行调用了两次子程序 ExecFunc ，分别把自定义函数 func 函数和库函数 sin 输入。</p>
<p>除了函数可以当成参数来传递之外，子程序也可以拿来作为参数传递出去。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0822</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">external</span> sub1,sub2 <span class="comment">!声明sub1 sub2 是子程序名称</span></span><br><span class="line">    <span class="keyword">call</span> sub(sub1) <span class="comment">!把子程序当参数传出去</span></span><br><span class="line">    <span class="keyword">call</span> sub(sub2)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub(sub_name)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">external</span> sub_name <span class="comment">!声明 sub_name 是个子程序</span></span><br><span class="line">    <span class="keyword">call</span> sub_name() <span class="comment">!调用输入的子程序 sub_name</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub1()</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;sub1&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub2()</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;sub2&quot;</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub1</span><br><span class="line">sub2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>8-5 特殊参数的使用方法</h1>
<p>Fortran 90 中，可以赋值参数的属性，设置某些参数是只读不能改变的。它还可以输入不定个数的参数，还可以不按照顺序来传递参数。</p>
<h3 id="8-5-1-参数属性">8-5-1 参数属性</h3>
<p>Fortran 中，参数传递出去后可能在函数中被改变。有的时候程序员会希望某些参数是只读的，它的数值不能在函数中被改变。Fortran 90 的 INTENT 命令可以用来设置函数属性，先来看一个简单的实例：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0823</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a=<span class="number">4</span></span><br><span class="line">    <span class="keyword">integer</span> b</span><br><span class="line">    <span class="keyword">call</span> div(a,b)</span><br><span class="line">    <span class="built_in">write</span>(*,*) a,b</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> div(a,b)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>)::a <span class="comment">!指定a是只读</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">intent</span>(<span class="keyword">out</span>)::b <span class="comment">!指定b在子程序中应该重新设置数值</span></span><br><span class="line">    b=a/<span class="number">2</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里 intent(in) 表示只读， intent(out) 表示指定为应该重新设置数值。</p>
<p>事实上，不指定参数属性并不会影响程序执行结果，加上这两行只是用来避免编写程序时不小心出错。设置成只读的变量，在函数中如果重新设置数值，编译过程中会出现错误。而设置成要输出的变量，如果在函数中没有重新设置一个数值给它，编译过程中会出现警告信息。</p>
<p>在计算丢标枪的实例程序 EX0809 中的两个函数 Angle_To_Rad 及 Get_Distance 都不会去改变参数，这两个函数的参数都是可读的。这个程序严格的写法会变成下面的样子。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0824</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">parameter</span> :: players = <span class="number">5</span></span><br><span class="line">    <span class="keyword">real</span> :: angle(players) = (/<span class="number">30.0</span>,<span class="number">45.0</span>,<span class="number">35.0</span>,<span class="number">50.0</span>,<span class="number">40.0</span>/)</span><br><span class="line">    <span class="keyword">real</span> :: speed(players) = (/<span class="number">25.0</span>,<span class="number">20.0</span>,<span class="number">21.0</span>,<span class="number">27.0</span>,<span class="number">22.0</span>/)</span><br><span class="line">    <span class="keyword">real</span> :: distance(players)</span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: Get_Distance <span class="comment">!声明Get_Distance 是个函数</span></span><br><span class="line">    <span class="keyword">integer</span> :: I</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> I=<span class="number">1</span>,players</span><br><span class="line">        distance(i)=Get_Distance(angle(i),speed(i))</span><br><span class="line">        <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;player &#x27;,I1,&#x27; =&#x27;,F8.2)&quot;</span>) I,distance(i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">!把0~360的角度转换成弧度</span></span><br><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Angle_TO_Rad(angle)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>) :: angle</span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">parameter</span> :: pi = <span class="number">3.14159</span></span><br><span class="line">    Angle_TO_Rad = angle*pi/<span class="number">180.0</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">!由角度，切线速度来计算投射距离</span></span><br><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Get_Distance(angle,speed)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>) :: angle,speed <span class="comment">!输入的参数</span></span><br><span class="line">    <span class="keyword">real</span> rad,Vx,time <span class="comment">!内部使用</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: Angle_TO_Rad <span class="comment">!声明是个函数</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">parameter</span> :: G = <span class="number">9.81</span></span><br><span class="line">    </span><br><span class="line">    rad = Angle_TO_Rad(angle) <span class="comment">!单位转换</span></span><br><span class="line">    Vx = speed*<span class="built_in">cos</span>(rad) <span class="comment">!水平方向速度</span></span><br><span class="line">    time = <span class="number">2.0</span>*speed*<span class="built_in">sin</span>(rad)/G <span class="comment">!在空中飞行时间</span></span><br><span class="line">    Get_Distance = Vx * time <span class="comment">!距离 = 水平方向速度 * 飞行时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>这个程序和原来的程序只有两行的差别，第20，30行。在这里把输入的参数都指定成只读的属性。</p>
<h3 id="8-5-2-函数的使用接口（INTERFACE）">8-5-2 函数的使用接口（INTERFACE）</h3>
<p>INTERFACE 是一段程序模块，用来清楚说明所要调用函数的参数类型及返回值类型等等的”使用接口“。在一般情况下，使用函数时不需要特别说明它们的”使用接口“，不过在下面这些情况下是必要的”</p>
<blockquote>
<ol>
<li>函数返回值为数组时</li>
<li>指定参数位置来传递参数时</li>
<li>所调用的函数参数数目不固定时</li>
<li>输入指标参数时</li>
<li>函数返回值为指针时</li>
</ol>
</blockquote>
<p>第1点很容易理解，目前为止举例中的函数都只返回一个数值，函数的返回值也可以是一个数组，来看下面的实例。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0825</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="comment">!定义函数func的使用接口</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span></span> random10(<span class="built_in">lbound</span>,<span class="built_in">ubound</span>)</span><br><span class="line">            <span class="keyword">implicit</span> <span class="keyword">none</span> </span><br><span class="line">            <span class="keyword">real</span> :: <span class="built_in">lbound</span>,<span class="built_in">ubound</span></span><br><span class="line">            <span class="keyword">real</span> :: random10(<span class="number">10</span>) <span class="comment">!返回值是个数组</span></span><br><span class="line">        <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">real</span> :: a(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">call</span> <span class="built_in">random_seed</span>() <span class="comment">!库存子程序，使用随机数前调用</span></span><br><span class="line">    a = random10(<span class="number">1.0</span>,<span class="number">10.0</span>) <span class="comment">!生成10个1.0~10.0之间的随机数</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(10F6.2)&quot;</span>) a <span class="comment">!输出数组a的内容</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">! random10 会返回10个范围在 lbound 和 ubound 之间的随机数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span></span> random10(<span class="built_in">lbound</span>,<span class="built_in">ubound</span>)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> :: <span class="built_in">lbound</span>,<span class="built_in">ubound</span></span><br><span class="line">    <span class="keyword">real</span> :: len</span><br><span class="line">    <span class="keyword">real</span> :: random10(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">real</span> t</span><br><span class="line">    <span class="keyword">integer</span> i</span><br><span class="line">    len = <span class="built_in">ubound</span> - <span class="built_in">lbound</span> <span class="comment">!计算范围大小</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">10</span></span><br><span class="line">        <span class="keyword">call</span> <span class="built_in">random_number</span>(t) <span class="comment">!t是0~1之间的随机数</span></span><br><span class="line">        random10(i) = <span class="built_in">lbound</span> + len*t <span class="comment">!把t转换成 lbound~ubound 间的随机数</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序会输出10个1~10之间随机生成的随机数，每次执行出来的结果应该均不相同（错了，我重复了两次，结果一样）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(base) [zhouziwen@ny gfortran]$ gfortran EX0825.F90</span><br><span class="line">(base) [zhouziwen@ny gfortran]$ ./a.out</span><br><span class="line">  9.98  6.10  9.69  7.73  4.31  5.33  1.66  1.05  4.12  4.08</span><br><span class="line">(base) [zhouziwen@ny gfortran]$ gfortran EX0825.F90</span><br><span class="line">(base) [zhouziwen@ny gfortran]$ ./a.out</span><br><span class="line">  9.98  6.10  9.69  7.73  4.31  5.33  1.66  1.05  4.12  4.08</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里先说明随机数的使用方法，在写程序的时候，常常会需要使用类似丢铜板的情况，以随机的方法来决定下一步要怎么做，这时候就要使用随机数。使用随机数前要先调用 random_seed 这个子程序来启动随机数生成器，启动之后就可以通过调用 random_number 来得到一个 0~1 之间的随机数。</p>
<p>这个实例中的函数 random10, 会通过输入的两个参数来决定随机数的值域范围，生成10个随机数，放在一维数组中作为返回值。这里示例了函数返回数组的方法，主程序中要用 interface 来说明函数的使用接口，使用接口包括参数类型及返回值类型。</p>
<p>一般情况并不需要使用 interface, 只有本小节最前面提到的那些情况才需要使用 interface 。声明使用接口，对程序员来说，是一个很麻烦的工作。尤其是在需要调用多个函数时，整个程序代码看起来会很烦杂。以这个例子来说，如果有另一个子程序也要调用 random10, 那在这个子程序中也需要再写清楚函数 random10 的 interface 才行。使用 module 可以减少这个麻烦，下面的章节会介绍 module 的使用。</p>
<p>interface 的编写结构很简单，它一次可以放入好几个函数的使用接口声明：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="comment">!开始写作 interface</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span></span> func_name <span class="comment">!开始定义函数 func_name</span></span><br><span class="line">		<span class="keyword">implicit</span> <span class="keyword">none</span> </span><br><span class="line">		<span class="keyword">real</span> ……  <span class="comment">!这里只能说明参数或传回值类型</span></span><br><span class="line">		<span class="keyword">integer</span> ……</span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span> <span class="comment">!定义函数结束</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> sub_name <span class="comment">!可以再定义另一个子函数/程序</span></span><br><span class="line">    	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    	<span class="keyword">integer</span> ……</span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">interface</span></span><br></pre></td></tr></table></figure>
<h3 id="8-5-3-不定个数的参数传递">8-5-3 不定个数的参数传递</h3>
<p>Fortran 90 当中，可以用 OPTIONAL 命令来表示某些参数是&quot;可以省略的&quot;。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0826</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">interface</span></span><br><span class="line">        <span class="function"><span class="keyword">subroutine</span></span> sub(a,b) <span class="comment">!定义子程序 sub 的使用接口</span></span><br><span class="line">            <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">            <span class="keyword">integer</span> :: a</span><br><span class="line">            <span class="keyword">integer</span>,<span class="keyword">optional</span> :: b</span><br><span class="line">        <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    <span class="comment">!开始编写命令</span></span><br><span class="line">    <span class="keyword">call</span> sub(<span class="number">1</span>) <span class="comment">!使用1个参数</span></span><br><span class="line">    <span class="keyword">call</span> sub(<span class="number">2</span>,<span class="number">3</span>) <span class="comment">!使用2个参数</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub(a,b)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a</span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">optional</span> :: b</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">present</span>(b)) <span class="keyword">then</span><span class="comment">!有输入b时</span></span><br><span class="line">        <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;a=&#x27;,i3,&#x27; b=&#x27;,i3)&quot;</span>) a,b</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;a=&#x27;,i3,&#x27; b=unknown&#x27;)&quot;</span>) a</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;  1 b&#x3D;unknown</span><br><span class="line">a&#x3D;  2 b&#x3D;  3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在子程序sub 及主程序的 interface 声明中，声明第二个参数时可以忽略的。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">optional</span> :: b</span><br></pre></td></tr></table></figure>
<p>函数 present 可以检查一个参数是否传递进来，函数 present 的返回值是布尔变量，如果想要检查的参数传递进来，会返回.true.，没有则返回.false.</p>
<p>注意，调用不定参数时，一定要先声明出函数的 interface，使用 module 时可以省略。</p>
<h3 id="8-5-4-改变参数传递位置的方法">8-5-4 改变参数传递位置的方法</h3>
<p>Fortran 90 中，甚至可以不用按照参数的顺序来传递参数。例如有一个子程序如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub(a,b,c)</span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br></pre></td></tr></table></figure>
<p>调用这个子程序时，可以直接代入子程序的变量名称来做”变换参数位置“的调用，例如：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> sub(b=<span class="number">2</span>,c=<span class="number">3</span>,a=<span class="number">1</span>) <span class="comment">!根据变量名称来传递参数</span></span><br></pre></td></tr></table></figure>
<p>编写程序的时候也可以让某些参数有<strong>默认值</strong>，不输入这些参数时就使用默认值。来看下面的例子，这个例子会编写一个函数来计算 F(X) = A*X^2^ + B*X + C 的值，一定要输入X来计算，A,B,C 没有输入的画默认值为0.</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0827</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">interface</span></span><br><span class="line">        <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> func(x,a,b,c) <span class="comment">!定义子程序func的使用接口</span></span><br><span class="line">            <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">            <span class="keyword">real</span> x</span><br><span class="line">            <span class="keyword">real</span>,<span class="keyword">optional</span> :: a,b,c</span><br><span class="line">        <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    <span class="comment">!开始编写命令</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) func(<span class="number">2.0</span>,c=<span class="number">1.0</span>) <span class="comment">!F(2)=0*2^2 + 0*2 + 1 = 1</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) func(<span class="number">2.0</span>,a=<span class="number">2.0</span>,b=<span class="number">1.0</span>) <span class="comment">!F(2)=2*2^2 + 1*2 + 0 = 10</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">!计算func(X)=A*X^2+B*X+C</span></span><br><span class="line"><span class="comment">!A,B,C不输入的话为0</span></span><br><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> func(x,a,b,c)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> x </span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">optional</span> :: a,b,c <span class="comment">!a,b,c可以不输入</span></span><br><span class="line">    <span class="keyword">real</span> ra,rb,rc <span class="comment">!实际计算的数字</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">present</span>(a)) <span class="keyword">then</span></span><br><span class="line">        ra=a</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ra=<span class="number">0.0</span> <span class="comment">!默认值为0</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">present</span>(b)) <span class="keyword">then</span></span><br><span class="line">        rb=b</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rb=<span class="number">0.0</span> <span class="comment">!默认值为0</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">present</span>(c)) <span class="keyword">then</span></span><br><span class="line">        rc=c</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rc=<span class="number">0.0</span> <span class="comment">!默认值为0</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    func = ra*x**<span class="number">2</span> + rb*x + rc</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.00000000</span><br><span class="line">10.0000000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="8-6-特殊的函数类型">8-6 特殊的函数类型</h2>
<p>Fortran 90 的函数，除了一般正常使用的类型外，还可以特别指定成 RECURSIVE, PURE, ELEMENTAL 这三种类型之一。 RECURSIVE 是让函数可以自己调用自己，即递归。PURE 及 ELEMENTAL 是用来做并行处理时及设置数组时使用。</p>
<h3 id="8-6-1-递归">8-6-1 递归</h3>
<p>函数除了可以让别人调用，自己也可以调用自己来执行，这叫做”递归“。能够”递归“执行的函数有一个必要条件，那就是递归函数每次被调用执行时，函数中所声明的局部变量（指那些不是传递进来的参数，及没有SAVE的变量）都会使用不同的内容地址。简单地说，函数中的局部变量在每次调用时都是独立存在的。</p>
<p>下面的实例程序会使用”递归“的方式来编写计算阶乘的子程序。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0828</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: n</span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">external</span> :: fact</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;N=&quot;</span></span><br><span class="line">    read(*,*) n</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(i2,&#x27;! = &#x27;,i8)&quot;</span>) n,fact(n)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">recursive</span> <span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> fact(n) reasut(ans)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>) :: n</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">then</span> <span class="comment">!不合理的输入</span></span><br><span class="line">        ans = -<span class="number">1</span> <span class="comment">!随便设置一个值</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line">    <span class="comment">!下面表示 n&gt;1 的情况，利用n*(n-1)! 来计算 n!</span></span><br><span class="line">    ans = n * fact(n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> N&#x3D;</span><br><span class="line">5</span><br><span class="line"> 5! &#x3D;      120</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数fact 一开头就以 recursive 开头，表示这个子程序可以递归使用。 result() 表示在函数中使用另外一个名字来设置函数的返回值，这里用 ans 来代替原来的 fact</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">recursive</span> <span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> fact(n) result(ans)</span><br></pre></td></tr></table></figure>
<p>Fortran 90 标准中，递归函数一定要使用 RESULT 来改名。</p>
<p>使用递归要有很清楚的逻辑概念，先分析一下阶乘的计算过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n! &#x3D; n*(n-1)*(n-2)*……*3*2*1</span><br></pre></td></tr></table></figure>
<p>因为 n! = n*(n-1)! ，所以调用函数 fact 来计算 n! 时，又可以再调用一次 fact 函数（自身）。</p>
<p>**递归调用时，需要确定一个明确的”终点“，用于停止递归。**不然会造成函数不断地调用自己来执行，可能会导致程序死机。</p>
<p>这里一开始就加入了两个判断：</p>
<ol>
<li>如果 n &lt; 0，则 n 值不合理，不做计算</li>
<li>若n &lt;= 1，根据数学定义 0! = 1! = 1，这是已知的数值。</li>
</ol>
<p>因此，如果用户一开始输入了一个负值，函数 fact 不做计算，直接 return 。 第二个条件是用来做递归的结束条件，当n减到1时，就不再递归下去。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">then</span> <span class="comment">!不合理的输入</span></span><br><span class="line">    ans = -<span class="number">1</span> <span class="comment">!随便设置一个值</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    ans = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br></pre></td></tr></table></figure>
<p>下面详细列出了整个阶乘计算的运行流程，请记住每一次调用 fact 时，它的局部变量都是独立存在的。</p>
<blockquote>
<p>N=4</p>
<p>主程序读入n值</p>
<p>fact(n) = fact(4)</p>
<p>在主程序中第一次调用函数fact来计算 4!</p>
<p>ans = n * fact(n-1) = 4*fact(3)</p>
<p>第1次执行fact时n=4，因为n&gt;1，所以还要调用 fact(n-1)</p>
<p>ans = n * fact(n-1) = 3*fact(2)</p>
<p>第2次执行fact时n=3，因为n&gt;1，所以还要调用 fact(n-1)</p>
<p>ans = n * fact(n-1) = 2*fact(1)</p>
<p>第3次执行fact时n=2，因为n&gt;1，所以还要调用 fact(n-1)</p>
<p>ans = 1</p>
<p>第4次执行fact时会到达递归调用的终点。因为n = 1，所以 ans = 1。函数会开始一个接着一个 return，先返回第3次执行 fact 的地方继续执行。</p>
<p>n*fact(n-1) = 2*fact(1) = 2*1 = 2 = 2!</p>
<p>第3次执行 fact 时 n = 2</p>
<p>n*fact(n-1) = 3*fact(2) = 3*2 = 6 = 3!</p>
<p>第2次执行 fact 时 n = 3</p>
<p>n*fact(n-1) = 4*fact(3) = 4*6 = 24 = 4!</p>
<p>第1次执行 fact 时 n = 4。这个时候计算结束，返回主程序。</p>
<p>fact(4) = 24</p>
</blockquote>
<p>递归调用的思维就在于把难得问题简化，以这个实例来说，因为计算n的阶乘比较难，可以一步步分解来计算。</p>
<p>把这个程序加入一些额外的信息，再重新看一次：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> N&#x3D;</span><br><span class="line">4</span><br><span class="line"> 4! &#x3D;  1th enter,n&#x3D; 4</span><br><span class="line"> 2th enter,n&#x3D; 3</span><br><span class="line"> 3th enter,n&#x3D; 2</span><br><span class="line"> 4th enter,n&#x3D; 1</span><br><span class="line"> 4th exit,n&#x3D; 1 ans&#x3D;       1</span><br><span class="line"> 3th exit,n&#x3D; 2 ans&#x3D;       2</span><br><span class="line"> 2th exit,n&#x3D; 3 ans&#x3D;       6</span><br><span class="line"> 1th exit,n&#x3D; 4 ans&#x3D;      24</span><br><span class="line">      24</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里多加了一些额外信息来显示出程序进行的流程，可以发现函数 fact 会一层一层地深入，再一层一层慢慢 return 回来。第n次调用fact执行完，会回到第 n-1 次调用fact中。</p>
<p>函数 fact 的局部变量 localcount 及 temp 是独立存在于每一次的调用当中，第 n-1 次调用 fact 时的localcount 跟第n次调用 fact 时的localcount 会存放不同的内存中，它们会是两个不同的变量。</p>
<p>用递归的方式计算阶乘， 并不会比使用循环来得好。事实上在这里使用递归程序执行效率会比较差，这里只是为了要示范递归的使用方法而已。不过，在处理某些问题时，使用递归可以大幅精简程序代码。</p>
<h3 id="8-6-2-内部函数">8-6-2 内部函数</h3>
<p>Fortran 90 还可以把函数做一个“归属”，定义出某些函数只能再某些特定的函数中被调用，写法如：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> main 或 <span class="function"><span class="keyword">subroutine</span></span> sub 或 <span class="function"><span class="keyword">function</span></span> func</span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">contains</span> <span class="comment">!contains 后面开始写作局部函数</span></span><br><span class="line">		<span class="function"><span class="keyword">subroutine</span></span> localsub</span><br><span class="line">		……</span><br><span class="line">		<span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span>/<span class="function"><span class="keyword">subroutine</span></span>/<span class="function"><span class="keyword">function</span></span></span><br></pre></td></tr></table></figure>
<p>这个方法，可以用来设计一个函数中的“内部运行”，因为内部运行是不希望被别人所使用的。来看一个实例。</p>
<p>这个程序只是 ex0828 改写后的结果，把函数放在主程序中，这样<strong>函数fact 只能在主程序中被调用，其它函数不能调用它</strong>。还有一点就是在这里<strong>主程序不需要声明就可以直接调用到函数fact</strong>。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0831</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: n</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;N=&#x27;</span></span><br><span class="line">    read(*,*) n</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(i2,&#x27;! = &#x27;,i8)&quot;</span>) n,fact(n)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">contains</span></span><br><span class="line">        <span class="keyword">recursive</span> <span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> fact(n) result(ans)</span><br><span class="line">            <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">            <span class="keyword">integer</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>) :: n</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">then</span> <span class="comment">!不合理的输入</span></span><br><span class="line">                ans = -<span class="number">1</span> <span class="comment">!随便设置一个值</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">                ans = <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line">            <span class="comment">!下面表示 n&gt;1 的情况，利用n*(n-1)! 来计算 n!</span></span><br><span class="line">            ans = n * fact(n-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="8-6-3-PURE函数">8-6-3 PURE函数</h3>
<p>在 function/subroutine 前面加上 pure 就可以使用pure函数。一般情况下不需要使用pure函数，它只是用来配合<strong>并行计算</strong>使用。使用pure函数有很多限制：</p>
<blockquote>
<ol>
<li>pure 函数的参数必须都是只读 intent(in)</li>
<li>pure 子程序的每个参数都要赋值属性</li>
<li>pure 函数中不能使用 save</li>
<li>pure 函数中所包含的内部函数也都必须是 pure 类型函数。</li>
<li>pure 函数中不能使用 stop，print 及跟输出入相关的命令。（如read, write, open, close, backspace,endfile, rewind, inquire）</li>
<li>pure 函数中只能读取，不能改变全局变量的值</li>
</ol>
</blockquote>
<p>这些限制是为了配合并行计算。并行计算可以让程序中，不同部分的程序代码在同时间执行，加快执行速度。如果不对并行计算进行限制，会出现一些问题。例如假设现在同时正在执行函数A和函数B，而这两个函数都可以在屏幕上输出一些信息，假设函数A正好要输出a=1, 函数B正好要输出 b=2，不过由于它们是同时在执行，但是屏幕只有一个，所以有可能会显示 a=b=21, ab==12, b=a1=2 等等的结果。因为 a = 1 跟 b = 2 这两段文本都抢着要输出到屏幕上，结果会导致这两段文本混在一起显示出来。</p>
<p>上面的6项限制，都是为了避免在并行计算时，出现奇怪的执行结果而指定的。</p>
<p>下面我们来看一个实例。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0832</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">external</span> :: func</span><br><span class="line">    <span class="built_in">write</span>(*,*) func(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pure</span> <span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> func(a,b)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>) :: a,b</span><br><span class="line">    func = a+b</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个实例纯粹是示范PURE函数的语法，计算机不具备并行运算能力时，不需要使用PURE函数。</p>
<h3 id="8-6-4-ELEMENTAL-函数">8-6-4 ELEMENTAL 函数</h3>
<p>这个函数也是用于并行计算，它同样有上一个小节中的那6项限制。不过它多了一个功能，可以用来做数组的设置，不过它也多了一个限制，就是它的参数不能是数组。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> a(<span class="number">10</span>)</span><br><span class="line">a=func(a)</span><br><span class="line"><span class="comment">!如果func 是elemental 函数，这段程序代码执行结果跟下面的循环相同。</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">10</span></span><br><span class="line">a(i) = func(a(i))</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>elemental 函数主要是用来配合 Fortran 90 可以对整个数组操作的语法来设置数组内容。下面是一个实例。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0833</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">interface</span> <span class="comment">!说明函数func的使用接口</span></span><br><span class="line">        <span class="keyword">elemental</span> <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> func(num)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>) :: num </span><br><span class="line">        <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">integer</span> i</span><br><span class="line">    <span class="keyword">real</span> :: a(<span class="number">10</span>) = (/ (i,i=<span class="number">1</span>,<span class="number">10</span>) /)</span><br><span class="line">    <span class="keyword">real</span> :: b(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(10F6.2)&quot;</span>) a</span><br><span class="line">    a = func(a)</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(10F6.2)&quot;</span>) a</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elemental</span> <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> func(num)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>) :: num</span><br><span class="line">    func = <span class="built_in">sin</span>(num) + <span class="built_in">cos</span>(num)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.00  2.00  3.00  4.00  5.00  6.00  7.00  8.00  9.00 10.00</span><br><span class="line">1.38  0.49 -0.85 -1.41 -0.68  0.68  1.41  0.84 -0.50 -1.38</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 elemental 函数时要先说明它的使用接口，主程序才会正确地设置数组地调用。程序的第16行表明上看数据类型并不对，等号左边是个数组，等号右边返回的却只是一个浮点数。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a = func(a)</span><br></pre></td></tr></table></figure>
<p>因为函数 func 是 elemental 类型，这一行会自动变成类似使用循环来执行 a(i) = func(a(i)) 的情况，数组中的每一个数值都会重新设置。不管几维数组都可以使用这个方法来设置数值。</p>
<h2 id="8-7-MODULE">8-7 MODULE</h2>
<p>MODULE 可以用来封装程序模块，通常是用来把程序中，具备相关功能的函数及变量封装在一起。</p>
<h3 id="8-7-1-MODULE-中的变量">8-7-1 MODULE 中的变量</h3>
<p>举例来说，需要使用全局变量时，可以把全局变量都声明在MODULE中，需要使用这些变量的函数只要 USE 这个 MODULE 就可以使用它们。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> a,b</span><br><span class="line">    <span class="keyword">common</span> a,b</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0834</span><br><span class="line">    <span class="keyword">use</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">call</span> sub()</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub()</span><br><span class="line">    <span class="keyword">use</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a,b</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1           2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主程序和子程序都没有声明a,b这两个变量，不过主程序和子程序中都有 use global 这一行描述。变量 a, b 都是声明在 module global 当中，所以只要使用了 global 这个程序单元，就可以看到 a, b 这两个变量。</p>
<p>MODULE 的语法如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> module_name</span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">end</span> [<span class="keyword">module</span> [module_name]]</span><br></pre></td></tr></table></figure>
<p>在函数中使用MODULE时，要在开始声明之前就使用 use module_name 的描述来使用某一个 MODULE。这个实例中，如果不使用 MODULE 的话，主程序和子程序中都要编写重复的程序代码来声明全局变量。还有一点，MODULE的程序代码需要编写在前面，这个程序在主程序和子程序中都使用 module global，所以 module global 要编写在最前面。</p>
<p>MODULE 中的变量如果不是声明成全局变量，这些变量被函数使用时，只会是函数中的局部变量。如果想让函数之间通过MODULE中的变量来传递数据，要把这些变量声明成全局变量。或者是在声明变量时加上 SAVE, 在 MODULE 声明中指定要 SAVE 的变量，功能上也等同于全局变量。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">save</span> :: a</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0835</span><br><span class="line">    <span class="keyword">use</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    <span class="keyword">call</span> sub()</span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub()</span><br><span class="line">    <span class="keyword">use</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    a = <span class="number">20</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">20</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="8-7-2-MODULE-中的自定义类型-TYPE">8-7-2 MODULE 中的自定义类型 TYPE</h3>
<p>在第4章第一次介绍自定义类型TYPE 后，就一直没有再使用它。事实上 TYPE 是个很好用的语法，编写大程序时，会把程序分区成很多函数，使用这些函数有时候会需要传递很多参数，使用自定义类型可以减少参数的数目。</p>
<p>就以本章一开始的射标枪程序为例，如果我们考虑更多的因素，比如风速、阻力等，需要传递的参数就不再只是角度和速度而已。传递多个参数时会很容易发生错误，程序员不可能永远记得每个参数的意义，可能会把参数位置弄反，铸成大错。</p>
<p>如果添加一个自定义类型，把这些数值都封装在这个新的类型中，传递参数时只要传递一个变量过去就行了，来看一个实例。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> constant</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">parameter</span> :: PI = <span class="number">3.14159</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">parameter</span> :: G = <span class="number">9.81</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> player</span><br><span class="line">        <span class="keyword">real</span> :: angle</span><br><span class="line">        <span class="keyword">real</span> :: speed</span><br><span class="line">        <span class="keyword">real</span> :: distance</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0836</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">parameter</span> :: players = <span class="number">5</span></span><br><span class="line">    <span class="keyword">type</span>(player) :: people(players) = (/ player(<span class="number">30.0</span>,<span class="number">25.0</span>,<span class="number">0.0</span>),&amp;</span><br><span class="line">                                        player(<span class="number">45.0</span>,<span class="number">20.0</span>,<span class="number">0.0</span>),&amp;</span><br><span class="line">                                        player(<span class="number">35.0</span>,<span class="number">21.0</span>,<span class="number">0.0</span>),&amp;</span><br><span class="line">                                        player(<span class="number">50.0</span>,<span class="number">27.0</span>,<span class="number">0.0</span>),&amp;</span><br><span class="line">                                        player(<span class="number">40.0</span>,<span class="number">22.0</span>,<span class="number">0.0</span>)&amp;</span><br><span class="line">                                    /)</span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: Get_Distance <span class="comment">!声明Get_Distance 是一个函数。  </span></span><br><span class="line">    <span class="keyword">integer</span> :: I</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> I=<span class="number">1</span>,players</span><br><span class="line">        <span class="keyword">call</span> Get_Distance(people(I))</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Player &#x27;,i1,&#x27; =&#x27;,f8.2)&quot;</span>) I,people(I)%distance</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">!把0~360的角度转换成0~2PI的弧度</span></span><br><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Angle_TO_Rad(angle)</span><br><span class="line">    <span class="keyword">use</span> constant</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> angle</span><br><span class="line">    Angle_TO_Rad = angle*pi/<span class="number">180.0</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">!由角度、切线速度来计算投掷距离</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Get_Distance(person)</span><br><span class="line">    <span class="keyword">use</span> constant</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(player) :: person</span><br><span class="line">    <span class="keyword">real</span> rad,Vx,time</span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: Angle_TO_Rad <span class="comment">!声明Angle_TO_Rad 是个函数</span></span><br><span class="line">    </span><br><span class="line">    rad = Angle_TO_Rad(person%angle) <span class="comment">!单位转换</span></span><br><span class="line">    Vx = person%speed * <span class="built_in">cos</span>(rad) <span class="comment">!水平方向速度</span></span><br><span class="line">    time = <span class="number">2.0</span> * person%speed * <span class="built_in">sin</span>(rad)/G <span class="comment">!在空中飞行时间</span></span><br><span class="line">    person%distance = Vx * time </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>报错了，是下面这一行代码编译出错</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">real</span>,<span class="keyword">external</span> :: Get_Distance <span class="comment">!声明Get_Distance 是一个函数。</span></span><br></pre></td></tr></table></figure>
<p>报错的理由好像是说，这一句应该是用在函数上，但是这里 Get_Distance 是一个子程序，不匹配。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">EX0836.F90:<span class="number">26.33</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: Get_Distance</span><br><span class="line">                                 <span class="number">1</span></span><br><span class="line">Error: <span class="function"><span class="keyword">FUNCTION</span></span> attribute conflicts with <span class="function"><span class="keyword">SUBROUTINE</span></span> attribute <span class="keyword">in</span> <span class="string">&#x27;get_distance&#x27;</span> at (<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用自定义数据类型封装后，一次只要提交一个变量即可。这里主程序和子程序都要用到 player 类型，如果不使用 MODULE，需要在主程序和子程序中都分别声明一次 player 类型才行，这样会让程序代码显得很罗嗦。把自定义类型 player 写在 MODULE 中，只要在函数中 USE 这个 MODULE 就可以认得 player 类型。</p>
<h3 id="8-7-3-MODULE-中的函数">8-7-3 MODULE 中的函数</h3>
<p>MODULE 中还可以容纳函数，编写结构如下。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> module_name</span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line"><span class="keyword">contains</span> <span class="comment">!从contains后开始写作函数</span></span><br><span class="line">	<span class="function"><span class="keyword">subroutine</span></span> sub_name</span><br><span class="line">		……</span><br><span class="line">		……</span><br><span class="line">	<span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br></pre></td></tr></table></figure>
<p>通常会把功能上相关的函数放在同一个 MODULE 模块中。而程序想要调用 MODULE 中的函数时，也要先通过 use module_name 的命令，才能够调用到它们。这个做法比较符合模块化概念，编写大程序时，可以把程序中属于绘图功能的部分放在 module Graphics 中， 把数值计算的部分放在 module Numerical 中。</p>
<p>Visual Fortran 中所提供的一些扩充函数库就用这个方法归类，像是数值函数库 IMSL 就放在 module IMSL，3D 绘图程序库 OpenGL 的函数就放在 module OpenGL 中。使用它们之前都要先 use IMSL, use OpenGL。</p>
<p>在同一个 MODULE 中的变量及函数间还有一个重要的关系，那就是函数可以直接使用同一个 MODULE 里所声明的变量，说明如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> tool</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">	<span class="keyword">integer</span> :: a <span class="comment">!先声明一个变量a</span></span><br><span class="line">	……</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">contains</span></span><br><span class="line">		<span class="function"><span class="keyword">subroutine</span></span> add()</span><br><span class="line">		<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">		a = a + <span class="number">1</span> <span class="comment">!module 中的子程序可以使用module中声明的变量</span></span><br><span class="line">		……</span><br><span class="line">		</span><br></pre></td></tr></table></figure>
<p>现在我们看看一个把函数编写在MODULE 中的实例程序，改写 ex0836 如下：</p>
<p>这个程序比前一个多了 module shoot .</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> constant</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">parameter</span> :: PI = <span class="number">3.14159</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">parameter</span> :: G = <span class="number">9.81</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> player</span><br><span class="line">        <span class="keyword">real</span> :: angle</span><br><span class="line">        <span class="keyword">real</span> :: speed</span><br><span class="line">        <span class="keyword">real</span> :: distance</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> shoot </span><br><span class="line">    <span class="keyword">use</span> constant</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">!把0~360的角度转换成0~2PI的弧度</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Angle_TO_Rad(angle)</span><br><span class="line">        <span class="keyword">use</span> constant</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> angle</span><br><span class="line">        Angle_TO_Rad = angle*pi/<span class="number">180.0</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">!由角度、切线速度来计算投掷距离</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Get_Distance(person)</span><br><span class="line">        <span class="keyword">use</span> constant</span><br><span class="line">        <span class="keyword">use</span> typedef</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(player) :: person</span><br><span class="line">        <span class="keyword">real</span> rad,Vx,time</span><br><span class="line">        <span class="keyword">real</span>,<span class="keyword">external</span> :: Angle_TO_Rad <span class="comment">!声明Angle_TO_Rad 是个函数</span></span><br><span class="line">        </span><br><span class="line">        rad = Angle_TO_Rad(person%angle) <span class="comment">!单位转换</span></span><br><span class="line">        Vx = person%speed * <span class="built_in">cos</span>(rad) <span class="comment">!水平方向速度</span></span><br><span class="line">        time = <span class="number">2.0</span> * person%speed * <span class="built_in">sin</span>(rad)/G <span class="comment">!在空中飞行时间</span></span><br><span class="line">        person%distance = Vx * time </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0837</span><br><span class="line">    <span class="keyword">use</span> shoot</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">parameter</span> :: players = <span class="number">5</span></span><br><span class="line">    <span class="keyword">type</span>(player) :: people(players) = (/ player(<span class="number">30.0</span>,<span class="number">25.0</span>,<span class="number">0.0</span>),&amp;</span><br><span class="line">                                        player(<span class="number">45.0</span>,<span class="number">20.0</span>,<span class="number">0.0</span>),&amp;</span><br><span class="line">                                        player(<span class="number">35.0</span>,<span class="number">21.0</span>,<span class="number">0.0</span>),&amp;</span><br><span class="line">                                        player(<span class="number">50.0</span>,<span class="number">27.0</span>,<span class="number">0.0</span>),&amp;</span><br><span class="line">                                        player(<span class="number">40.0</span>,<span class="number">22.0</span>,<span class="number">0.0</span>)&amp;</span><br><span class="line">                                    /)</span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: Get_Distance <span class="comment">!声明Get_Distance 是一个函数。  </span></span><br><span class="line">    <span class="keyword">integer</span> :: I</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> I=<span class="number">1</span>,players</span><br><span class="line">        <span class="keyword">call</span> Get_Distance(people(I))</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Player &#x27;,i1,&#x27; =&#x27;,f8.2)&quot;</span>) I,people(I)%distance</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="8-8-一些少用的功能">8-8 一些少用的功能</h2>
<h3 id="8-8-1-ENTRY">8-8-1 ENTRY</h3>
<p>ENTRY 用来在函数中创建一个新的“入口”，调用这个入口时，会跳过进入点之前的程序代码来执行函数，直接用一个实例来说明：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0838</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">call</span> sub()</span><br><span class="line">    <span class="keyword">call</span> mid()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub()</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Hello.&quot;</span></span><br><span class="line">    <span class="built_in">entry</span> mid() <span class="comment">!另一个进入点mid</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Good morning.&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello.</span><br><span class="line">Good morning.</span><br><span class="line">Good morning.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>前两行输出是调用子程序 sub 时所得到的，第3行输出是调用子程序中的另一个进入点 mid 得到的。 entry 在子程序 sub 建立了一个新的调用进入点 mid。主程序调用 mid 时，会从子程序 sub 中， entry mid() 这一行来执行程序。</p>
<h3 id="8-8-2-特别的-return">8-8-2 <s>特别的 return</s></h3>
<p>从函数中 return 返回调用处时，通常会直接返回调用处来继续执行程序。关于这一点也是可以改变的，调用函数时可以额外指定其他的折返点，这里有一个实例：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0839</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a</span><br><span class="line">    </span><br><span class="line">    read(*,*) a</span><br><span class="line">    <span class="keyword">call</span> sub(a,*<span class="number">100</span>,*<span class="number">200</span>)</span><br><span class="line">    <span class="comment">!特别另外指定两个折返点，分别时行代码100及200这两个地方</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Default&quot;</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line">    <span class="number">100</span> <span class="built_in">write</span>(*,*) <span class="string">&quot;Return 1&quot;</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line">    <span class="number">200</span> <span class="built_in">write</span>(*,*) <span class="string">&quot;Return 2&quot;</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub(a,*,*)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a</span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">0</span>) tehn</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">!返回默认的折返点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="comment">!返回特别指定的第1个折返点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> <span class="comment">!返回特别指定的第2个折返点</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序执行后会要求输入一个整数，输入值小于等于0时，调用子程序 sub 会返回默认折返点。输入值为1时，会返回特定指定的第1个折返点。输入其他值会返回特别指定的第2个折返点。</p>
<p>程序第6行输入的最后两个参数时程序代码中的行代码，要加上星号来做识别，不然会被当成普通的整数，它们用来指定折返点的位置</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> sub(a,*<span class="number">100</span>,*<span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<p>子程序sub接收最后两个参数时只要使用星号就行了，不需要再声明变量去接收。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub(a,*,*)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我一看到行代码，就知道这个我用不上。</p>
</blockquote>
<h2 id="8-9-使用多个文件">8-9 使用多个文件</h2>
<p>程序员通常会把一些具有相关功能的函数，独立编写在不同的文件中，编译器可以分别编译这些程序文件，最后再把它们链接到同一个执行文件中。把程序代码分散在不同的文件中有几个好处：</p>
<ol>
<li>独立文件的函数，可以再拿给其他程序使用</li>
<li>可以加快编译速度，修改其中一个文件时，编译器只需要重新编译这个文件就行了。</li>
</ol>
<p>这个小节会教读者如何把程序代码分散到不同文件中。</p>
<h3 id="8-9-1-include">8-9-1 include</h3>
<p>include 命令用在程序代码中，插入另一个文件中的内容。这是在 Fortran 中使用多个文件的最简单方法，下面的实例包含两个文件，读者要先确定这两个文件都放在同一个目录下再来做编译。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0840m</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">call</span> sub() <span class="comment">!子程序sub写在另一个文件中</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;EX0840S.F90&#x27;</span> <span class="comment">!在这里插入 EX0840S.F90 这个文件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第二个程序 EX0840S.F90</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub()</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Hello.&quot;</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于采用了 include 命令将第二个文件的内容插入了进来，直接编码运行第一个程序即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gfortran EX0840M.F90</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./a.out</span></span><br><span class="line"> Hello.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个实例把主程序和子程序写在两个不同文件中，然后采用 include 合并在一块。</p>
<p>include 命令可以写在任何地方，它只是单纯地用来插入一个文件的内容。有时候也会应用在声明全局变量，先把声明全局变量的程序代码编写在某个文件中，需要使用全局变量的时候再去include这个文件（这种情况用 module 不香嘛，作者也说了 module 更香）。</p>
<h3 id="8-9-4-程序库">8-9-4 程序库</h3>
<p>具有特殊功能的一组函数，可以编译成*.LIB 程序库来给其他人使用。*.LIB 的文件内容经过编译，无法从这个文件中读到初始程序代码。<strong>如果程序员想保留自己的独门技巧不被外人偷学，可以把程序代码编译成程序库之后，再交给其他人使用。</strong></p>
<p>市面上也有一些公司专门开发程序库，著名的有数值运算的 IMSL 等。使用程序库可以减轻程序员的负担。</p>
<h2 id="8-10-函数的应用">8-10 函数的应用</h2>
<h2 id="8-11-习题">8-11 习题</h2>
<h3 id="8-11-1-通过子程序计算圆面积">8-11-1 通过子程序计算圆面积</h3>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">parameter</span> :: pi = <span class="number">3.14159</span></span><br><span class="line">    <span class="keyword">real</span> r,s</span><br><span class="line">    <span class="keyword">common</span> r,s</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0841</span><br><span class="line">    <span class="keyword">use</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;radius is&quot;</span></span><br><span class="line">    read(*,*) r</span><br><span class="line">    <span class="keyword">call</span> Circle_Area()</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Circle_Area()</span><br><span class="line">    <span class="keyword">use</span> global</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    s = pi*r**<span class="number">2</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;area is &#x27;,f8.2)&quot;</span>) s</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>输入输出为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> radius is</span><br><span class="line">2</span><br><span class="line">area is    12.57</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="8-11-2-通过函数计算圆面积">8-11-2 通过函数计算圆面积</h3>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0841</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> r,s</span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">external</span> :: Circle_Area <span class="comment">!声明Circle_Area是一个函数</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;radius is&quot;</span></span><br><span class="line">    read(*,*) r</span><br><span class="line">    s = Circle_Area(r)</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;area is &#x27;,f8.2)&quot;</span>) s</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Circle_Area(r)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>,<span class="keyword">parameter</span> :: pi = <span class="number">3.14159</span></span><br><span class="line">    <span class="keyword">real</span> r</span><br><span class="line">    Circle_Area = pi*r**<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数这里不好用 module 来事先指定参数的类型（除非是固定参数，比如这里的pi），比如这里的函数的参数r，好像必须要在函数中指定。</p>
<h3 id="8-11-3-画长条图">8-11-3 画长条图</h3>
<p>pass</p>
<h3 id="8-11-4-计算等差数列1-2-3-……-100的结果">8-11-4 计算等差数列1+2+3+……+100的结果</h3>
<p>直接套用之前阶乘的程序。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0828</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: n</span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">external</span> :: fact</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;N=&quot;</span></span><br><span class="line">    read(*,*) n</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(i2,&#x27;! = &#x27;,i8)&quot;</span>) n,fact(n)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">recursive</span> <span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> fact(n) result(ans)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>,<span class="keyword">intent</span>(<span class="keyword">in</span>) :: n</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">then</span> <span class="comment">!不合理的输入</span></span><br><span class="line">        ans = -<span class="number">1</span> <span class="comment">!随便设置一个值</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line">    <span class="comment">!下面表示 n&gt;1 的情况，利用n*(n-1)! 来计算 n!</span></span><br><span class="line">    ans = n + fact(n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="8-11-5-计算两个整数的最大公因子">8-11-5 计算两个整数的最大公因子</h3>
<p>一开始没想到怎么做，后来想到用<strong>递归</strong>来做，按较小的整数，每次自减1，看能不能被原来的两个整数整除。</p>
<p>先留个伪代码在这。我还不清楚fortran怎么判断整除，但有了这个思路了，写起来也很简单。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0. 先判断两个整数是不是符合要求，必须为正数。</span><br><span class="line">1. 先看两个整数能否直接整除，如果能，最大公因子就是较小的整数。</span><br><span class="line">2. 如果不能，以较小的数为基本，每次自减1，看能否被两个整数整除。递归的终点是1。</span><br></pre></td></tr></table></figure>
<h1>9 文件</h1>
<p>文件是很实用的功能，使用文件才能永远记录程序的执行结果。</p>
<h2 id="9-1-文件读取的概念">9-1 文件读取的概念</h2>
<p>在 Fortran 语言中，读取文件的操作可以有“顺序读取”及“直接读取” 两种方式。</p>
<p>所谓的“顺序读取”，是指读写一个文件时，只能从头开始，一步步地向下来读取数据，就像听录音带一样。想要略过数据、或是重新读取时，同样要先“快转” 或是 “倒带”。这是最简单地文件运行方式，不过已经足以应付许多的状况。</p>
<p>而“直接读取” 是指在读写文件时，可以任意跳跃到文件的任何一个位置来读写。</p>
<p>另外在文件的“保存格式” 上，也有两种方法：分别是“文本文件” 以及 “二进制文件”。使用二进制文件无法看到内容，它的好处是：一是<strong>读取速度比较快</strong>，因为它的保存格式和数据在内存中的保存方法相同，不像“文本文件”需要经过转换。另一个优点是<strong>较省空间</strong>。</p>
<h2 id="9-2-文件的操作">9-2 文件的操作</h2>
<p>在 Fortran 中，跟文件有关的操作命令非常丰富，不过有很多命令根本就不常用，只需要先浏览一遍。</p>
<h3 id="9-2-1-open-的使用">9-2-1 open 的使用</h3>
<p>前面使用 READ, WRITE 命令时，括号的第一栏都是放一个星号，表示输入/出的位置使用默认值，也就是从键盘输入以及从屏幕输出。使用open命令打开文件之后，就可以对文件进行输入/出，来看看下面这个实例：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0901</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    open(<span class="keyword">unit</span>=<span class="number">10</span>, <span class="keyword">file</span> = <span class="string">&#x27;hello.txt&#x27;</span>)</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">10</span>,*) <span class="string">&quot;hello&quot;</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行后生成了一个文件，程序第3行使用 open 命令来打开文件，open的第1个参数用来给文件指定一个代码（避开1,2,5,6，因为2,6 是默认的输出位置，也就是屏幕。1,5 是默认的输入位置，也就是键盘 ），第二个参数是文件名称（最好不要使用中文名称）。文件打开之后，程序中都会以这个代码来使用 hello.txt 这个文件。</p>
<p>文件打开之后，使用 read, write 命令时，把输入/出的位置指定成某个文件代码，就可以读写文件。</p>
<p>open的具体参数</p>
<blockquote>
<p>open(unit=number, file=filename, form=…, status=…, access=…, recl=length, err=label, iostat=iostat, blank=…, position=…, action=action, pad=…, delim=…,)</p>
<ul>
<li>
<p>form = ‘formatted’ (表示文件使用“文本文件”格式保存) or ‘unformatted’ (“二进制文件”格式保存)</p>
</li>
<li>
<p>status = ‘new’ /  ‘old’ / ‘scratch’ / ‘unkown’</p>
<p>‘new’ : 表示这个文件原本不存在，是第一次打开</p>
<p>’old’ : 表示这个文件原本已经存在</p>
<p>‘replace’ : 文件若已经存在，会重新创建一次，原本的内容会消失。文件若不存在，会创建新文件。</p>
<p>’scratch’ : 表示要打开一个暂存盘，这个时候可以不需要指定文件名称，也就是 FILE 这一栏可以忽略。因为程序本身会自动取一个文件名，至于文件名是什么也不重要，因为暂存盘会在程序结束后自动删除。</p>
<p>‘unknown’ : 由各编译器自定义。通常会同 replace 的效果</p>
<p>这一栏不给定时，默认为 unkonwn</p>
</li>
<li>
<p>access = ‘sequential’ / ‘direct’</p>
<p>设置读写文件的方法。</p>
<p>‘sequential’ ：顺序读取，默认值</p>
<p>‘direct’ ：直接读取，读写文件可以任意指定位置。</p>
</li>
<li>
<p>recl = length</p>
<p>在顺序读取文件中，recl 字段用来设置一次可以读写多大容量的数据。</p>
<p>在打开“直接读取文件”时，recl = length 的 length 值是用来设置文件中的每一个模块单元的区分长度。</p>
</li>
<li>
<p>err = label</p>
<p>这个字段用来设置当文件打开发生错误时，程序会跳跃到 label 所指的行代码处来继续执行程序。</p>
</li>
<li>
<p>iostat = var</p>
<p>这个字段会设置一个整数值给后面的整型变量，这是用来说明文件打开的状态，数值会有三种情况。</p>
<p>var &gt; 0    表示读取操作发生错误</p>
<p>var = 0    表示读取操作正常</p>
<p>var &lt; 0     表示文件终了</p>
</li>
<li>
<p>blank = ‘null’ / ‘zero’</p>
<p>这用来设置文件输入数字时，当所设置的格式字段中有空格存在时所代表的意义。‘null’ 说明空格代表没有东西；’zero’ ，空格部分会自动以0代入。</p>
</li>
</ul>
</blockquote>
<p>以下为 Fortran 90 添加功能</p>
<blockquote>
<ul>
<li>
<p>position = ‘asis’ / ‘rewind’ / ‘append’</p>
<p>‘asis’ :  表示文件打开时的读取位置，不特别指定，通常就是在文件开头。这是默认值。</p>
<p>‘rewind’ ： 表示文件打开时的读取位置移到文件的开头</p>
<p>‘append’ ：表示文件打开时的读取位置移到文件的末尾</p>
</li>
<li>
<p>action = ‘read’ / ‘write’ / ‘readwrite’</p>
<p>‘readwrite’ :  可读可写，默认值</p>
<p>’read’ : 只读</p>
<p>‘write’ : 只写</p>
</li>
<li>
<p>pad = ‘yes’ / ‘no’</p>
<p>‘yes’ :  在格式化输出时，最前面的不足字段会自动以空格填满，默认值</p>
<p>‘no’ :  不会自动以空格填满</p>
</li>
<li>
<p>delim = ‘apostrophe’ / ‘quote’ / ‘none’</p>
<p>‘none’ : 纯粹输出字符串内容</p>
<p>‘quote’ :  输出字符串加上双引号</p>
<p>‘apostrophe’ : 输出字符串加上单引号</p>
</li>
</ul>
</blockquote>
<h3 id="9-2-2-write-read-的使用">9-2-2 write, read 的使用</h3>
<p>先看一个实例</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0902</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: string</span><br><span class="line">    </span><br><span class="line">    open(<span class="keyword">unit</span>=<span class="number">10</span>, <span class="keyword">file</span> = <span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">10</span>,<span class="string">&quot;(a20)&quot;</span>) <span class="string">&quot;Good morning.&quot;</span> <span class="comment">!写到文件中</span></span><br><span class="line">    rewind(<span class="number">10</span>)</span><br><span class="line">    read(<span class="number">10</span>,<span class="string">&quot;(a20)&quot;</span>) string <span class="comment">!从文件中读出来</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(a20)&quot;</span>) string <span class="comment">!写到屏幕上</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>这里通过 <code>rewind(10)</code> 把文件的读写位置移回文件最前面。</p>
<p>现在来详细介绍 read, write 命令的所有功能，这两个命令的设置字段都很类似，所以可以一起介绍：</p>
<blockquote>
<p>write/read(unit=number, fmt=format, nml=namelist, rec=record, iostat=stat, err=errlabel, end=endlabel, advance=advance, size=size)</p>
<ul>
<li>
<p>unit</p>
</li>
<li>
<p>fmt : 指定输入输出格式</p>
</li>
<li>
<p>nml = namelist</p>
<p>指定读写某个 namelist 的内容。</p>
</li>
<li>
<p>rec = record</p>
<p>在直接读取文件中，设置所要读写的文件模块位置</p>
</li>
<li>
<p>iostat,err ： 同上</p>
</li>
<li>
<p>end = endlabel</p>
<p>指定在读写到文件末尾时，要转移到某个行代码来继续执行程序。</p>
</li>
</ul>
</blockquote>
<p>以下是 Fortran 90 添加功能</p>
<blockquote>
<ul>
<li>
<p>advance = ‘yes’ / ‘no’ : 设置在文本格式下的顺序文件中，每一次的 read, write 命令完成后，读写位置会不会自动向下移动一行。</p>
</li>
<li>
<p>size = count</p>
<p>当 advance = ‘no’ 时，才可以用这个字段。它会把这一次输出入的字符数目设置给后面的整型变量</p>
</li>
</ul>
</blockquote>
<h3 id="9-2-3-查询文件的状态">9-2-3 查询文件的状态</h3>
<p>在使用 open 命令打开文件的前后，都可以通过 inquire 命令来查询文件目前的情况，inquire 命令中的每个字段和第一个小节open的字段很类似。先来看一小段程序，编写一个检查某个文件是否存在的程序：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0903</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: filename = <span class="string">&quot;EX0903.F90&quot;</span></span><br><span class="line">    <span class="keyword">logical</span> alive</span><br><span class="line">    </span><br><span class="line">    inquire(<span class="keyword">file</span>=filename, <span class="keyword">exist</span>=alive)</span><br><span class="line">    <span class="keyword">if</span>(alive) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) filename, <span class="string">&quot; exist.&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) filename, <span class="string">&quot; doesn&#x27;t exist&quot;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里通过 inquire 命令来查询字符串 filename 中记录的文件是否存在。文件存在时 alive 会被设为 .true. ， 不存在则会被设为 .false.</p>
<p>下面详细介绍 inquire 的使用方法:</p>
<blockquote>
<p>inquire(unit=number, file=filename, iostat=stat, err=label, exist=exist, opened=opened, number=number, named=named, access=access, sequential=sequential, direct=direct, form=form, formatted=formatted, unformatted=unformatted, recl=recl)</p>
<ul>
<li>
<p>exist = exist</p>
<p>检查文件是否存在，会返回一个布尔向量给后面的逻辑变量。</p>
</li>
<li>
<p>opened = opened</p>
<p>检查文件是否已经使用 open 命令来打开，会返回一个布尔变量给后面的逻辑变量。</p>
</li>
<li>
<p>number = number</p>
<p>由文件名来查询这个文件所给定的代码。</p>
</li>
<li>
<p>named = named</p>
<p>查询文件是否取了名字，也就是检查文件是否为临时保存盘。</p>
</li>
<li>
<p>access = access</p>
<p>检查文件的读取格式，会返回一个字符串，字符串值可以是：</p>
<p>‘sequential’ : 代表文件使用顺序读取格式</p>
<p>‘direct’ : 代表文件使用直接读取格式</p>
<p>‘undefined’ : 代表没有定义</p>
</li>
<li>
<p>sequential = sequential</p>
<p>查看文件是否使用顺序格式，会返回一个字符串，字符串值可以是：</p>
<p>‘yes’ / ‘no’ / ‘unknown’</p>
</li>
<li>
<p>direct = direct</p>
<p>查看文件是否使用直接格式，会返回一个字符串，字符串值可以是：</p>
<p>‘yes’ / ‘no’ / ‘unknown’</p>
</li>
<li>
<p>form = form</p>
<p>查看文件的保存方法，会返回一个字符串，字符串值可以是：</p>
<p>‘formatted’ : 打开的是文本文件</p>
<p>‘unformatted’ : 打开的是二进制文件</p>
<p>‘undefined’ : 没有定义</p>
</li>
<li>
<p>formatted = fmt</p>
<p>查看文件是否是文本文件，会返回一个字符串，字符串值可以是：</p>
<p>‘yes’ / ‘no’ / ‘unknown’</p>
</li>
<li>
<p>recl = length</p>
<p>返回 open 文件时 recl 栏的设置值</p>
</li>
<li>
<p>nextrec = nr</p>
<p>返回下一次文件读写的位置</p>
</li>
<li>
<p>blank = blank</p>
<p>返回值是字符串，用来查看open文件时的blank参数所给定的字符串值。</p>
</li>
</ul>
</blockquote>
<p>以下为 Fortran 90 添加功能</p>
<blockquote>
<ul>
<li>
<p>position=position</p>
<p>返回打开文件时 position 字段所给定的字符串。</p>
</li>
<li>
<p>action=action</p>
<p>返回打开文件时 action 字段所赋值的字符串</p>
</li>
<li>
<p>delim=delim</p>
<p>返回打开文件时 delim 字段所设置的字符串</p>
</li>
<li>
<p>pad=pad</p>
<p>返回打开文件时 pad 字段所设置的字符串</p>
</li>
</ul>
</blockquote>
<p>其他文件运行命令</p>
<blockquote>
<ul>
<li>
<p>backspace(unit=number, err=errlabel, iostat=iostat)</p>
<p>把文件的读写位置退回一步，其他字段参考上一节</p>
</li>
<li>
<p>endfile(unit=number, err=errlabel, iostat=iostat)</p>
<p>把文件的读写位置变成文件的结尾</p>
</li>
<li>
<p>rewind(unit=number, err=errlabel, iostat=iostat)</p>
<p>把文件的读写位置倒回文件开头。</p>
</li>
<li>
<p>close(unit=number, status=string, err=errlabel, iostat=iostat)</p>
<p>把文件关闭，不再进行读写操作</p>
<p>status=‘keep’ 会在文件关闭后，保留住这个文件。默认值</p>
<p>status=‘delete’ 会在文件关闭后，消除这个文件。</p>
</li>
</ul>
</blockquote>
<p>前面示例过 rewind 的 用法，这里来举例编写一个删除文件的程序：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0904</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">logical</span> alive</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: filename;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*)  <span class="string">&quot;filename:&quot;</span></span><br><span class="line">    read(*,<span class="string">&quot;(a20)&quot;</span>) filename</span><br><span class="line">    </span><br><span class="line">    inquire(<span class="keyword">file</span>=filename, <span class="keyword">exist</span>=alive)</span><br><span class="line">    <span class="keyword">if</span> (alive) <span class="keyword">then</span></span><br><span class="line">        open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename)</span><br><span class="line">        close(fileid, <span class="keyword">status</span>=<span class="string">&quot;delete&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="built_in">trim</span>(filename),<span class="string">&quot; doesn&#x27;t exist.&quot;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序执行后会要求输入一个文件名称，如果存在则删除，如果不存在则会输出错误信息。</p>
<p>删除文件的方法很简单，先用 open 打开，再用 close 关闭文件，close 时赋值不保留这个文件就会把它删除。</p>
<h2 id="9-3-顺序文件的操作">9-3 顺序文件的操作</h2>
<p>顺序文件就好像使用录音带、录像带一样，只能慢慢地播放带子。想要略过一些片段时，要使用快进来跳过它们。</p>
<p>在 windows 的命令窗口下，type 命令可以用来在屏幕上快速浏览一个文本文件内容。下面的实例程序有同样的功能。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0905</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">79</span>) :: filename</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">79</span>) :: buffer</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">integer</span> :: <span class="keyword">status</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">logical</span> alive</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Filename:&quot;</span></span><br><span class="line">    read(*, <span class="string">&quot;(a79)&quot;</span>) filename</span><br><span class="line">    inquire(<span class="keyword">file</span>=filename, <span class="keyword">exist</span>=alive)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(alive) <span class="keyword">then</span></span><br><span class="line">        open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename, &amp;</span><br><span class="line">            <span class="keyword">access</span>=<span class="string">&quot;sequential&quot;</span>, <span class="keyword">status</span>=<span class="string">&quot;old&quot;</span>)</span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">            read(<span class="keyword">unit</span>=fileid, <span class="keyword">fmt</span>=<span class="string">&quot;(a79)&quot;</span>, <span class="keyword">iostat</span>=<span class="keyword">status</span>) buffer</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">status</span>/=<span class="number">0</span>) <span class="keyword">exit</span> <span class="comment">!没有数据就跳出循环</span></span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(a79)&quot;</span>) buffer</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="built_in">trim</span>(filename),<span class="string">&quot; doesn&#x27;t exist.&quot;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序运行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> Filename:</span><br><span class="line">hello.txt</span><br><span class="line"> hello</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序会先要求用户输入所要阅读的文件名，输入完毕后，再使用 inquire 命令来检查文件是否存在。如果文件存在，就会开始读取文件：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename, &amp;</span><br><span class="line">            <span class="keyword">access</span>=<span class="string">&quot;sequential&quot;</span>, <span class="keyword">status</span>=<span class="string">&quot;old&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这里 status 默认值是 unknown ，一般编译的做法是若文件已存在，它会被改写，如果不存在，就会打开一个新的文件。这里由于已经确认这个文件已存在，所以这里 status 设置为 old。</p>
<p>文件打开之后，就使用循环来一行一行地读出文件内容。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">	read(<span class="keyword">unit</span>=fileid, <span class="keyword">fmt</span>=<span class="string">&quot;(a79)&quot;</span>, <span class="keyword">iostat</span>=<span class="keyword">status</span>) buffer</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">status</span>/=<span class="number">0</span>) <span class="keyword">exit</span> <span class="comment">!没有数据就跳出循环</span></span><br><span class="line">	<span class="built_in">write</span>(*, <span class="string">&quot;(a79)&quot;</span>) buffer</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>这个循环的工作是：“每次读入一行后，就把这一行的文本写到屏幕上”。 read 命令每读一次，会自动把读取位置移动到下一行。所以这里每一次 read 命令都会读入一行新的文本。不过在读取字符串时，限定输入格式，限定它一次读入每一行的前79个字符，因为在标准的 DOS 及 windows 命令行窗口中，一次也只能显示 80 个字符，所以读太多字符没有意义。如果刚好输出 80 个字符，有的编译器所编译的程序会发生断行的现象。</p>
<p>因为没有办法事先就知道文件会有几行文本，也就不会事先知道应该执行几次循环。这里循环的终止条件是当变量 status 不为0的时候。</p>
<p>上一个程序只是单纯地读取文件而已，现在来看看一个需要写入文件的程序。下面的实例程序可以用来记录全班同学的中文、英文及数学的考试成绩：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">type</span> student</span><br><span class="line">        <span class="keyword">integer</span> Chinese, English, Math</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0906</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: students</span><br><span class="line">    <span class="keyword">type</span>(student), <span class="keyword">allocatable</span> :: s(:)</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) :: filename = <span class="string">&quot;data.txt&quot;</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;班上有多少学术&quot;</span></span><br><span class="line">    read(*,*) students</span><br><span class="line">    <span class="built_in">allocate</span>(s(students), stat=i)</span><br><span class="line">    <span class="keyword">if</span>(i/=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;Allocate buffer fail.&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    open(fileid, <span class="keyword">file</span>=filename)</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>, students</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;请输入&#x27;i2&#x27;号同学的中文、英文及数学成绩&#x27;&quot;</span>) i</span><br><span class="line">        read(*,*) s(i)%Chinese, s(i)%English, s(i)%Math</span><br><span class="line">        <span class="built_in">write</span>(fileid, <span class="string">&quot;(&#x27;site:&#x27;i2/&#x27;Chinese:&#x27;i3&#x27; English:&#x27;i3&#x27; Math:&#x27;i3)&quot;</span>) i,s(i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    close(fileid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译报错，报错的地方在这一句</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">write</span>(fileid, <span class="string">&quot;(&#x27;site:&#x27;i2/&#x27;Chinese:&#x27;i3&#x27; English:&#x27;i3&#x27; Math:&#x27;i3)&quot;</span>) i,s(i)</span><br></pre></td></tr></table></figure>
<p>报错信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Error: Unexpected end of format string in format string at (1)</span><br></pre></td></tr></table></figure>
<p>暂时还不清楚原因。</p>
<p>如果运行成功，data.txt 文件的格式应该如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">座号：1</span><br><span class="line">中文：82 英文：90 数学：95</span><br></pre></td></tr></table></figure>
<p>这里将文件的代码赋值给了一个常数（fileid）, 这个方法可以避免在写大程序时，同时打开多个文件却忘记文件代码，毕竟使用变量名称会比硬记数字容易。（确实好一点，可以和 python 一致）</p>
<p>打开这个文件时并没有赋值 status 字段，没有说明文件是“新的”或是“旧的”。这个方法在第1次执行程序时会创造出新文件，第2次执行后则会重新覆盖掉文件上一次的记录。</p>
<p>循环执行结束后，用 close(fileid) 把文件关闭，程序结束。如果省略关闭文件的操作，在程序结束时其实也会自动关闭文件。不过最好还是养成自己来关闭文件的习惯比较好。</p>
<p>这个程序只是示范了如何把成绩写到文件中，如何把成绩从文件中读出来是另外一个问题。读取成绩时要注意格式，要懂得略过一些没有必要的数据。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">type</span> student</span><br><span class="line">        <span class="keyword">integer</span> Chinese, English, Math</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0907</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(student) :: s</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) :: filename = <span class="string">&quot;data.txt&quot;</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">logical</span> alive </span><br><span class="line">    <span class="keyword">integer</span> :: error</span><br><span class="line">    <span class="keyword">integer</span> :: no</span><br><span class="line">    </span><br><span class="line">    inquire(<span class="keyword">file</span>=filename, <span class="keyword">exist</span>=alive)</span><br><span class="line">    <span class="keyword">if</span>(.not. alive)<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="built_in">trim</span>(filename),<span class="string">&quot; doesn&#x27;t exist.&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    open(fileid, <span class="keyword">file</span>=filename)</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        read(fileid, <span class="string">&quot;(5xi2,/,5xi3,6xi3,6xi3)&quot;</span>, <span class="keyword">iostat</span>=error) no,s</span><br><span class="line">        <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(i2,&#x27;号 中文:&#x27;i3&#x27; 英文:&#x27;i3&#x27; 数学:&#x27;i3)&quot;</span>) no,s</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    close(fileid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于每一位学生的数据都占两行，先保存座号再保存成绩，而且使用的字段是固定的。要读取数据也要用相同的格式及字段来读取数据，下面会把输出跟输入部分的程序代码列出来做比较，读者可以发现输出时的文本部分，在输入时都使用 nX 来跳过它们。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!输出</span></span><br><span class="line"><span class="built_in">write</span>(fileid, <span class="string">&quot;(&#x27;座号:&#x27;i2/&#x27;中文:&#x27;i3&#x27; 英文:&#x27;i3&#x27; 数学:&#x27;i3)&quot;</span>) i,s(i)</span><br><span class="line"><span class="comment">!输入</span></span><br><span class="line">read(fileid, <span class="string">&quot;(5xi2,/,5xi3,6xi3,6xi3)&quot;</span>, <span class="keyword">iostat</span>=error) no,s</span><br></pre></td></tr></table></figure>
<p>输入时，文本中的一些文本，例如”座号:“ 等字符对程序来说都没有意义，程序只要读取它们后面的数字就行了，这些文本可以跳过去不管它。输入格式中的 nX 都是用来跳过这些文本，<strong>请注意一个中文字占的宽度正好是两个英文字母的宽度，所以”座号:“ 会占用5个英文字母的位置。</strong>（一个中文两个字节）。</p>
<p>上一个实例中，因为学生数据的保存格式是固定的。先保存座号，再根据顺序保存中文、英文、数学成绩。所以程序可以直接略过说明字符串。如果每一条数据的位置不固定，读取数据时会很麻烦。</p>
<p>现在来尝试读取一个版面格式比较自由的文件，这个文件记录了好几位篮球员的姓名、身高、体重、平均得分等等数据，每位球员的第一条数据都固定是姓名，其他数据就不固定顺序。每位球员的数据之间可以有任意数目的空行，这个文件（EX0908DAT.TXT）的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">姓名 王天才</span><br><span class="line">体重 80.5 </span><br><span class="line">身高 195.2</span><br><span class="line">得分 15.8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">姓名 李天才</span><br><span class="line">身高 190.3 </span><br><span class="line">体重 85.1</span><br><span class="line">得分 10.8</span><br><span class="line"></span><br><span class="line">姓名 洪天才</span><br><span class="line">体重 90.8</span><br><span class="line">身高 201.3</span><br><span class="line">得分 19.8</span><br><span class="line"></span><br><span class="line">姓名 彭天才</span><br><span class="line">体重 70.2</span><br><span class="line">得分 22.2 </span><br><span class="line">身高 185.0</span><br><span class="line"></span><br><span class="line">姓名 黄天才</span><br><span class="line">得分 20.1</span><br><span class="line">体重 85.0</span><br><span class="line">身高 190.3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在需要一个程序来读入所有选手的数据，并挑选出平均每场可以得分20分以上的球员来显示他们的数据。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">type</span> player</span><br><span class="line">        <span class="keyword">character</span>(len=<span class="number">80</span>) :: <span class="keyword">name</span></span><br><span class="line">        <span class="keyword">real</span> weight, height</span><br><span class="line">        <span class="keyword">real</span> score</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0908</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: filename = <span class="string">&quot;EX0908DAT.TXT&quot;</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">20</span></span><br><span class="line">    <span class="keyword">logical</span> :: alive <span class="comment">!检查文件是否存在</span></span><br><span class="line">    <span class="keyword">type</span>(player) :: p <span class="comment">!读取选手数据</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">10</span>) :: title <span class="comment">!读取数据项</span></span><br><span class="line">    <span class="keyword">real</span> tempnum <span class="comment">!读取数据</span></span><br><span class="line">    <span class="keyword">logical</span>, <span class="keyword">external</span> :: GetNextPlayer <span class="comment">!找出下一位球员的函数</span></span><br><span class="line">    <span class="keyword">integer</span> i <span class="comment">!循环记数器</span></span><br><span class="line">    <span class="keyword">integer</span> error <span class="comment">!检查文件读取是否正常</span></span><br><span class="line">    </span><br><span class="line">    inquire(<span class="keyword">file</span>=filename, <span class="keyword">exist</span>=alive)</span><br><span class="line">    <span class="keyword">if</span>(.not. alive) <span class="keyword">then</span> <span class="comment">!文件不存在就结束程序</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="built_in">trim</span>(filename),<span class="string">&quot; doesn&#x27;t exist&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename)</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="keyword">if</span>(GetNextPlayer(fileid, p%<span class="keyword">name</span>)) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">3</span></span><br><span class="line">                read(fileid, <span class="string">&quot;(a4,1x,f3.2)&quot;</span>, <span class="keyword">iostat</span>=error) title, tempnum</span><br><span class="line">                <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">                    <span class="built_in">write</span>(*,*) <span class="string">&quot;文件读取错误&quot;</span></span><br><span class="line">                    <span class="keyword">stop</span></span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">                <span class="comment">!要经过每一行最前面两个中文来判断读入的是什么数据</span></span><br><span class="line">                <span class="keyword">select</span> <span class="keyword">case</span>(title)</span><br><span class="line">                <span class="keyword">case</span>(<span class="string">&quot;身高&quot;</span>)</span><br><span class="line">                    p%height = tempnum</span><br><span class="line">                <span class="keyword">case</span>(<span class="string">&quot;体重&quot;</span>)</span><br><span class="line">                    p%weight = tempnum</span><br><span class="line">                <span class="keyword">case</span>(<span class="string">&quot;得分&quot;</span>)</span><br><span class="line">                    p%score = tempnum</span><br><span class="line">                <span class="keyword">case</span> <span class="keyword">default</span></span><br><span class="line">                    <span class="built_in">write</span>(*,*) <span class="string">&quot;出现不正确的数据&quot;</span></span><br><span class="line">                    <span class="keyword">stop</span></span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">select</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">exit</span> <span class="comment">!没有数据了，离开循环</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p%score &gt; <span class="number">20.0</span>) <span class="keyword">then</span> <span class="comment">!显示得分高于20分的选手数据</span></span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;姓名:&#x27;a8/,&#x27;身高:&#x27;f5.1,&#x27; 体重:&#x27;f5.1,&#x27; 得分:&#x27;f4.1)&quot;</span>) p</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">!GetNextPlayer 函数会从文件中找出下一位球员的数据位置</span></span><br><span class="line"><span class="comment">!如果文件中还有数据需要读取，返回.true.</span></span><br><span class="line"><span class="comment">!入股文件中没有数据需要读取，返回.false.</span></span><br><span class="line"><span class="keyword">logical</span> <span class="function"><span class="keyword">function</span></span> GetNextPlayer(fileid, <span class="keyword">name</span>)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">intent</span>(<span class="keyword">in</span>):: fileid</span><br><span class="line">    <span class="keyword">character</span>(len=*), <span class="keyword">intent</span>(<span class="keyword">out</span>) :: <span class="keyword">name</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) title</span><br><span class="line">    <span class="keyword">integer</span> error</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        read(fileid, <span class="string">&quot;(a80)&quot;</span>,<span class="keyword">iostat</span>=error) title</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">then</span> <span class="comment">!文件中已经没有数据了</span></span><br><span class="line">            GetNextPlayer = .false.</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(title(<span class="number">1</span>:<span class="number">4</span>)==<span class="string">&quot;姓名&quot;</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">name</span> = title(<span class="number">6</span>:)</span><br><span class="line">            GetNextPlayer = .true.</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结束之后，啥也没有，这不对啊。应该是打印出来得分高于20的个体信息。</p>
<p>程序代码长了一点，把它分为几部分来说明。第28行之前的程序代码是声明和检查的部分，跟前几个实例差不多，不需要再多做介绍。需要介绍的只有 29~57 行的循环部分和函数 GetNextPlayer。</p>
<p>循环第1行会调用函数 GetNextPlayer，函数 GetNextPlayer 会去寻找文件中保存“姓名”这个字符串的位置，并且读出球员姓名。读取方法是使用循环一次读入一行字符串，检查字符串最前面是否为“姓名”这两个中文字，如果是就取出字符串后半部的球员姓名，并返回主程序；如果不是就再读入下一行。一个中文字会使用 两个character来保存，所以第79行要检查字符串最前面的两个中文字时，等于要检查最前面的4个Character 。下面是函数 GetNextPlayer 的核心部分：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">      read(fileid, <span class="string">&quot;(a80)&quot;</span>,<span class="keyword">iostat</span>=error) title</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">then</span> <span class="comment">!文件中已经没有数据了</span></span><br><span class="line">          GetNextPlayer = .false.</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(title(<span class="number">1</span>:<span class="number">4</span>)==<span class="string">&quot;姓名&quot;</span>) <span class="keyword">then</span></span><br><span class="line">          <span class="keyword">name</span> = title(<span class="number">6</span>:)</span><br><span class="line">          GetNextPlayer = .true.</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">do</span> </span><br></pre></td></tr></table></figure>
<p>文件的代码在整个程序中是共享的，不同的函数可以使用相同的代码来读写同一个文件，函数不会独立拥有自己的文件代码。所以在这边，函数 GetNextPlayer 从参数中得到的文件代码，会和主程序使用相同的文件。</p>
<p>再回到主程序的部分，因为在文件中，每位球员的4项数据都是连续4行写在一起，而调用 GetNextPlayer 时会读入第一行的姓名部分，接下来需要再读入3项数据。第31~49 行是一个固定执行3次的循环，它会连续读入3行数据。不过这3项数据的顺序并不固定，所以要检查每一行最前面的文本才能判断它是什么数据。</p>
<p>读取一位球员的数据后，检查他的平均得分是否超过20分，是就输出这位球员的个人数据。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p%score &gt; <span class="number">20.0</span>) <span class="keyword">then</span> <span class="comment">!显示得分高于20分的选手数据</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;姓名:&#x27;a8/,&#x27;身高:&#x27;f5.1,&#x27; 体重:&#x27;f5.1,&#x27; 得分:&#x27;f4.1)&quot;</span>) p</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br></pre></td></tr></table></figure>
<p>从这可以发现，如果版面格式太过自由，读取数据时会很麻烦。</p>
<p>前面的实例都是单纯的读入数据或是输出文件，现在来示例一个同时读写文件的程序。编写一个程序来把文本文件的内容的最前面加上行号后，输出到另一个文件中。例如文件A的内容为：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">	<span class="keyword">integer</span> a</span><br><span class="line">	……</span><br></pre></td></tr></table></figure>
<p>输出到文件B后，每一行最前面会按照顺序补上行号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.program main</span><br><span class="line">2.	implicit none</span><br><span class="line">3.	integer a</span><br><span class="line">  	……</span><br></pre></td></tr></table></figure>
<p>程序如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0909</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: inputfileid = <span class="number">10</span>, outputfileid = <span class="number">11</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: maxbuffer = <span class="number">200</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) :: inputfile, outputfile</span><br><span class="line">    <span class="keyword">character</span>(len=maxbuffer) buffer</span><br><span class="line">    <span class="keyword">integer</span> <span class="built_in">count</span></span><br><span class="line">    <span class="keyword">integer</span> error</span><br><span class="line">    <span class="keyword">logical</span> alive</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Input Filename:&quot;</span></span><br><span class="line">    read(*, <span class="string">&quot;(a80)&quot;</span>) inputfile</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Output Filename:&quot;</span></span><br><span class="line">    read(*, <span class="string">&quot;(a80)&quot;</span>) outputfile</span><br><span class="line">    </span><br><span class="line">    inquire(<span class="keyword">file</span>=inputfile, <span class="keyword">exist</span>=alive)</span><br><span class="line">    <span class="keyword">if</span>(.not. alive) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="built_in">trim</span>(inputfile), <span class="string">&quot; doesn&#x27;t exist.&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    open(<span class="keyword">unit</span>=inputfileid, <span class="keyword">file</span>=inputfile, <span class="keyword">status</span>=<span class="string">&quot;old&quot;</span>)</span><br><span class="line">    open(<span class="keyword">unit</span>=outputfileid, <span class="keyword">file</span>=outputfile, <span class="keyword">status</span>=<span class="string">&quot;replace&quot;</span>)</span><br><span class="line">    <span class="built_in">count</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="comment">!读入一整行的数据</span></span><br><span class="line">        read(inputfileid, <span class="string">&quot;(a200)&quot;</span>, <span class="keyword">iostat</span>=error) buffer</span><br><span class="line">        <span class="keyword">if</span>(error/=<span class="number">0</span>) eixt <span class="comment">!没有数据了 离开循环</span></span><br><span class="line">        <span class="comment">!在最前面加上行号再输出到另一个文件中</span></span><br><span class="line">        <span class="built_in">write</span>(outputfileid, <span class="string">&quot;(i3,&#x27;.&#x27;,A)&quot;</span>) <span class="built_in">count</span>,<span class="built_in">trim</span>(buffer)</span><br><span class="line">        <span class="built_in">count</span> = <span class="built_in">count</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    close(inputfileid)</span><br><span class="line">    close(outputfileid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> Input Filename:</span><br><span class="line">EX0909.F90</span><br><span class="line"> Output Filename:</span><br><span class="line">EX0909_test.F90</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行完后打开输出文件，确实每一行都添加了行号。</p>
<p>这个程序很简单，基本上就是利用循环一行一行地把文件内容当作字符串读进来。读入字符串后，把这个字符串前面加上行号，再输出到另一个文件中。下面就是这个程序的核心部分。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">    <span class="comment">!读入一整行的数据</span></span><br><span class="line">    read(inputfileid, <span class="string">&quot;(a200)&quot;</span>, <span class="keyword">iostat</span>=error) buffer</span><br><span class="line">    <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">exit</span> <span class="comment">!没有数据了 离开循环</span></span><br><span class="line">    <span class="comment">!在最前面加上行号再输出到另一个文件中</span></span><br><span class="line">    <span class="built_in">write</span>(outputfileid, <span class="string">&quot;(i3,&#x27;.&#x27;,A)&quot;</span>) <span class="built_in">count</span>,<span class="built_in">trim</span>(buffer)</span><br><span class="line">    <span class="built_in">count</span> = <span class="built_in">count</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>这个程序示例了一次打开两个文件的办法，程序只要在OPEN, READ, WRITE 时使用不同的 UNIT 值，就可以同时使用多个文件。</p>
<h2 id="9-4-直接访问文件的操作">9-4 直接访问文件的操作</h2>
<p>直接访问文件的意义是：“把文件的空间、内容事先分区成好几个同样大小的小模块，这些模块会自动按顺序编号。读写文件时，要先赋值文件读写位置在第几个模块，再来进行读写的工作”。直接访问文件可以任意到文件的任何一个地方来读写，就像欣赏镭射唱片、影盘片时一样，可以任意跳跃到我们所想要欣赏的片段。</p>
<p>来看一段实例，文件 list.txt 中，按照棒次顺序记录了“熊帝队”选手的打击率：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.12</span><br><span class="line">2.98</span><br><span class="line">3.34</span><br><span class="line">3.45</span><br><span class="line">2.86</span><br><span class="line">2.54</span><br><span class="line">2.78</span><br><span class="line">2.23</span><br><span class="line">2.56</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编写一个可以经过棒次来查询选手打击率的程序。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0910</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: filename = <span class="string">&quot;list.txt&quot;</span></span><br><span class="line">    <span class="keyword">integer</span> player</span><br><span class="line">    <span class="keyword">real</span> hit</span><br><span class="line">    <span class="keyword">integer</span> error</span><br><span class="line">    <span class="keyword">logical</span> alive</span><br><span class="line">    </span><br><span class="line">    inquire(<span class="keyword">file</span>=filename, <span class="keyword">exist</span>=alive)</span><br><span class="line">    <span class="keyword">if</span>(.not. alive) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="built_in">trim</span>(filename), <span class="string">&quot; doesn&#x27;t exist.&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename, <span class="keyword">access</span>=<span class="string">&quot;direct&quot;</span>,&amp;</span><br><span class="line">        <span class="keyword">form</span>=<span class="string">&quot;formatted&quot;</span>, <span class="keyword">recl</span>=<span class="number">6</span>, <span class="keyword">status</span>=<span class="string">&quot;old&quot;</span>)</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;查询第几棒？&#x27;)&quot;</span>)</span><br><span class="line">        read(*,*) player</span><br><span class="line">        read(fileid, <span class="keyword">fmt</span>=<span class="string">&quot;(f4.2)&quot;</span>, <span class="keyword">rec</span>=player, <span class="keyword">iostat</span>=error) hit</span><br><span class="line">        <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;打击率:&#x27;f4.2)&quot;</span>) hit</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    close(fileid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查询第几棒？</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>没有显示结果啊，应该后面一行跟着打击率结果。</p>
<p>程序使用下面的open命令打开了一个直接读取文件：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename, <span class="keyword">access</span>=<span class="string">&quot;direct&quot;</span>,&amp;</span><br><span class="line">    <span class="keyword">form</span>=<span class="string">&quot;formatted&quot;</span>, <span class="keyword">recl</span>=<span class="number">6</span>, <span class="keyword">status</span>=<span class="string">&quot;old&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>打开直接读取文件时，open命令中的 access = “direct” 及定义模块大小的 recl 字段不能省略。access = ‘direct’ 时，form 的默认值是 “unformatted” （二进制文件），所以要打开直接读取的文本文件时，要记得加上 form=“formatted” 这一参数描述。</p>
<p>文件打开后，使用循环来读取用户所要查询的棒次号码。当用户输入一个不存在的棒次时，会挑出循环。循环的主要工作就是从键盘读取棒次，并且从文件中读出打击率。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">read(fileid, <span class="keyword">fmt</span>=<span class="string">&quot;(f4.2)&quot;</span>, <span class="keyword">rec</span>=player, <span class="keyword">iostat</span>=error) hit</span><br></pre></td></tr></table></figure>
<p>这里的 read 命令，rec 字段填入的 player 值，就是用户所输入的棒次号码，也就是所要去读取的文件位置。这一行命令会从文件中的 第 player 笔数据读出打击率给变量 hit。</p>
<p>关于这个程序，读者可能还有一些疑问，就是在 open 文件时，为什么要把 recl 设为6？来看看文件list 的内容。可以发现 list.txt 文件中每一行刚好有4个字符，而上场打击的棒次有九人，所以文件中有9行。<strong>而在window的操作系统中，文本文件每一行的末尾都有两个看不见的符号用来代表一行文本的结束。所以一行文本的长度是 “这一行文本的字符数量再加上2”。</strong></p>
<p>在文本文件格式中，recl 字段设置的值代表一个模块会使用几个字符。</p>
<p>由于这个程序是给用户自行输入所要查询的棒次号码，所以读取数据时常常会在文件中任意跳跃。使用直接读取文件才能任意赋值文件的读取位置。</p>
<p>事实上这个程序的最好的编写方法是声明数组，并打开一个顺序文件来把数据读入数组中。用户查询数据时，直接在数组中读取就好了。**因为数组的数据是在内存中，查询数据的速度远快于硬盘中读取。**这个程序中使用直接访问文件纯粹是为了范例。</p>
<p>来看看一个写入直接访问文件的实例，假如现在需要一个输入选手打击率的程序，这个程序能够自由让用户决定现在要输入哪一位打击者的打击率。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0911</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: filename = <span class="string">&quot;ex0911dat.txt&quot;</span></span><br><span class="line">    <span class="keyword">integer</span> player</span><br><span class="line">    <span class="keyword">real</span> hit</span><br><span class="line">    <span class="keyword">integer</span> error</span><br><span class="line">    </span><br><span class="line">    open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename, <span class="keyword">access</span>=<span class="string">&quot;direct&quot;</span>,&amp;</span><br><span class="line">        <span class="keyword">form</span>=<span class="string">&quot;formatted&quot;</span>, <span class="keyword">recl</span>=<span class="number">6</span>, <span class="keyword">status</span>=<span class="string">&quot;replace&quot;</span>)</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;第几棒?&#x27;)&quot;</span>)</span><br><span class="line">        read(*,*) player</span><br><span class="line">        <span class="keyword">if</span>(player&lt;<span class="number">1</span> .or. player&gt;<span class="number">9</span>) <span class="keyword">exit</span> </span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;打击率?&#x27;)&quot;</span>)</span><br><span class="line">        read(*,*) hit</span><br><span class="line">        <span class="built_in">write</span>(fileid, <span class="keyword">fmt</span>= <span class="string">&quot;(f5.2)&quot;</span>, <span class="keyword">rec</span>=player, <span class="keyword">iostat</span>=error) hit</span><br><span class="line">        <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    close(fileid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">第几棒?</span><br><span class="line"><span class="number">3</span></span><br><span class="line">打击率?</span><br><span class="line"><span class="number">3.2</span></span><br><span class="line">第几棒?</span><br><span class="line"><span class="number">5</span></span><br><span class="line">打击率?</span><br><span class="line"><span class="number">2.8</span></span><br><span class="line">第几棒?</span><br><span class="line"><span class="number">9</span></span><br><span class="line">打击率?</span><br><span class="line"><span class="number">2.3</span></span><br><span class="line">第几棒?</span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入的数据在 ex0911dat.txt 当中。因为只输入了3个棒次的数据，所以其他选手的位置都是空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.20        2.80                    2.30 </span><br></pre></td></tr></table></figure>
<p>这个实例程序和上一个实例程序差不多，只是在把 read 改成 write 而已。</p>
<p>这个程序只是很简单地做写入文件的范例。通常使用直接格式时，不会使用文本格式而会使用二进制格式来保存数据。</p>
<p>使用直接访问文件时，要小心使用 endfile 命令。使用这个命令时，会把目前所在的文件位置之后的数据都清除掉。</p>
<h2 id="9-5-二进制文件的操作">9-5 二进制文件的操作</h2>
<p>文本文件的内容都是用肉眼就可以明白辨认的，现在来试试看“二进制文件”。使用二进制文件来做直接读取时，open 命令中的 recl 字段所设置的整数 n 值所代表的大小会随着编译器不同而改变。有的编译器会视为 n bytes，有的编译器会视为 n*4 bytes。</p>
<p>把输入棒球选手打击率的程序，改成使用二进制文件来记录：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0912</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: filename = <span class="string">&quot;list.bin&quot;</span></span><br><span class="line">    <span class="keyword">integer</span> player</span><br><span class="line">    <span class="keyword">real</span> :: hit(<span class="number">9</span>) = (/ <span class="number">3.12</span>, <span class="number">2.98</span>, <span class="number">3.34</span>, <span class="number">3.45</span>, <span class="number">2.86</span>, <span class="number">2.54</span>, <span class="number">2.78</span>, <span class="number">2.23</span>, <span class="number">2.56</span> /)</span><br><span class="line">    open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename, <span class="keyword">access</span>=<span class="string">&quot;direct&quot;</span>,&amp;</span><br><span class="line">        <span class="keyword">form</span>=<span class="string">&quot;unformatted&quot;</span>, <span class="keyword">recl</span>=<span class="number">1</span>, <span class="keyword">status</span>=<span class="string">&quot;replace&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> player = <span class="number">1</span>,<span class="number">9</span></span><br><span class="line">        <span class="built_in">write</span>(fileid, <span class="keyword">rec</span>=player) hit(player)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    close(fileid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出报错</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">At line <span class="number">11</span> of <span class="keyword">file</span> EX0912.F90 (<span class="keyword">unit</span> = <span class="number">10</span>, <span class="keyword">file</span> = <span class="string">&#x27;list.bin&#x27;</span>)</span><br><span class="line">Fortran runtime error: <span class="built_in">Write</span> exceeds length of <span class="keyword">DIRECT</span> <span class="keyword">access</span> record</span><br></pre></td></tr></table></figure>
<p>把 open 语句中的 recl 改成 4 ，就好了。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename, <span class="keyword">access</span>=<span class="string">&quot;direct&quot;</span>,&amp;</span><br><span class="line">    <span class="keyword">form</span>=<span class="string">&quot;unformatted&quot;</span>, <span class="keyword">recl</span>=<span class="number">4</span>, <span class="keyword">status</span>=<span class="string">&quot;replace&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>生成的文件 list.bin 放在文本编辑器中看起来会很奇怪。必须另外编写程序才能从 list.bin 中查询数据。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0913</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: filename = <span class="string">&quot;list.bin&quot;</span></span><br><span class="line">    <span class="keyword">integer</span> player</span><br><span class="line">    <span class="keyword">real</span> hit</span><br><span class="line">    <span class="keyword">integer</span> error</span><br><span class="line">    <span class="keyword">logical</span> alive</span><br><span class="line">    </span><br><span class="line">    inquire(<span class="keyword">file</span>=filename, <span class="keyword">exist</span>=alive)</span><br><span class="line">    <span class="keyword">if</span>(.not. alive) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="built_in">trim</span>(filename), <span class="string">&quot; doesn&#x27;t exist.&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    open(<span class="keyword">unit</span>=fileid, <span class="keyword">file</span>=filename, <span class="keyword">access</span>=<span class="string">&quot;direct&quot;</span>,&amp;</span><br><span class="line">        <span class="keyword">form</span>=<span class="string">&quot;unformatted&quot;</span>, <span class="keyword">recl</span>=<span class="number">4</span>, <span class="keyword">status</span>=<span class="string">&quot;old&quot;</span>)</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;查询第几棒？&#x27;)&quot;</span>)</span><br><span class="line">        read(*,*) player</span><br><span class="line">        read(fileid,  <span class="keyword">rec</span>=player, <span class="keyword">iostat</span>=error) hit</span><br><span class="line">        <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;打击率:&#x27;f5.2)&quot;</span>) hit</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    close(fileid)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查询第几棒？</span><br><span class="line">2</span><br><span class="line">打击率: 2.98</span><br><span class="line">查询第几棒？</span><br><span class="line">3</span><br><span class="line">打击率: 3.34</span><br><span class="line">查询第几棒？</span><br><span class="line">0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序和 ex0910 差不多，只是差在常量 recl 字段的值及在 open 中的 form 设为 unformatted ，其实可以省略这一栏，因为打开直接访问文件时 form 的默认值就是 unformatted 。</p>
<p>在这边把 recl 字段设为1（有些编译器必须设为4），ex0910 中把 recl 设置成6是因为输出数据的格式为 f4.2，占4个字段。不过如果两笔数据间没有用空格来区分，在文件中会出现一连串紧密的数字。RECL 设置为6之后，每一条数据都会固定输出6个字符。但是这个程序使用的是二进制文件，就没有必要在数据之间用区分符号来增加文件的可读性，因为二进制文件本来就没有可读性可言。</p>
<p>在这一节的实例程序中，对文件读写时都没有使用任何的输入/出格式。二进制文件是直接把在内存中的二进制数据写入文件，就没有所谓的格式化输入/出存在。</p>
<p>二进制文件可以节省空间，不过在这个例子中还不是很明显。假如要记录 1000 个格式为 f8.3 的浮点数，使用文本文件时，所需要的文件长度理论上最少为 1000*8 = 8000 bytes。但事实上一定还要再数据间加上空格符合来区分数据、方便阅读。所以文件最小长度为 1000*9 = 9000 bytes。</p>
<p>用文本文件保存数字，很可能会造成部分数据流失，因为格式 f8.3 只允许存放3位小数，第3位以下的小数都会被舍去，解决办法是多保存几位数字，不过这样会使用更多的空间。</p>
<p><strong>使用二进制文件时，所需要的文件最少长度为 1000*4 = 4000 bytes，而且不会有任何的数据流失。从这里可以知道，要存放 “精确” 及 “大量” 的数据时，使用二进制文件是较好的选择。</strong> （这里我还是不太理解）</p>
<p>重新看这本书的28-30页，Fortran 的数据类型章节，就大概理解了。</p>
<p>首先根据下面这段话，不同的数据格式会按照不同的规则存储为二进制编码</p>
<blockquote>
<p>程序代码中要清除地指定每种数据所要存储的格式。不同种类的数据需要经过转换才能互通，因为它们可能是使用不同方法来存储的。就以整数和浮点数来说，整数是很单纯地以二进制来存储数字。浮点数和整数的不同在于浮点数可以存储带有小数的实数，浮点数会把数字转换成二进制的指数方法来表示，并把数字分为指数部分和小数部分来做记录。</p>
<p>0.5 = 5.0 * 10 ^-1^ = 1.0 * 2^-1^ 。0.5 这个数值会被分成二进制的数值部分1.0，和指数部分 -1 来记录。</p>
<p>读者不需要实际了解每个数值真正会被记录的格式，只需要知道上面所介绍的整数、浮点数、字符、逻辑这4种数据会使用不同的方法来记录就行了。</p>
</blockquote>
<p>下面这段话就介绍了同样一个数字，以文本格式保存和以数字格式保存的区别。</p>
<blockquote>
<p>假如现在需要记录 15243 这个数字，使用整数来记录的话，会把 15243 转换成二进制的 101111110011 保存在内存。它可以使用短整型（2 bytes）或长整型（4 bytes）来记录。使用字符串来记录的话，需要分别去记录“1”，“5”，“2”，“4”，“3”，这5个字符，需要5 bytes 来记录。</p>
</blockquote>
<p>这里就说的很清楚了， 15243 如果视为一个数字，直接可以转为一个二进制代码。如果视为字符串，那么要视为5个字符，每个字符均需要用一个bytes存储。而且使用字符串来记录数字时，不能直接把它们拿来进行加减乘除的运算，要把字符串先转换成整数或浮点数等等的数值类型才能拿来计算。</p>
<h2 id="9-6-Internal-File（内部文件）">9-6 Internal File（内部文件）</h2>
<p>在前面介绍过把数据写入文本文件的方法，现在再介绍一个类似的新概念——“内部文件”。</p>
<p>“内部文件” 是直接从英文原文翻译成中文的名词，其实如果把它叫做“字符串变量文件”会比较切合原义。因为它是使用写入文件的方法，把数据写到一个字符串变量中，来看一个实例：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0914</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a=<span class="number">2</span></span><br><span class="line">    <span class="keyword">integer</span> :: b=<span class="number">3</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: string</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(<span class="keyword">unit</span>=string, <span class="keyword">fmt</span>= <span class="string">&quot;(i2,&#x27;+&#x27;,i2,&#x27;=&#x27;,i2)&quot;</span>) a,b,a+b</span><br><span class="line">    <span class="built_in">write</span>(*,*) string</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序的重点在第7行，write 命令除了可以赋值一个整数值来作为输出位置之外，还可以赋值一个字符串变量来当做输出的目的。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">write</span>(<span class="keyword">unit</span>=string, <span class="keyword">fmt</span>= <span class="string">&quot;(i2,&#x27;+&#x27;,i2,&#x27;=&#x27;,i2)&quot;</span>) a,b,a+b</span><br></pre></td></tr></table></figure>
<p>字符串 string 的内容，会按照赋值的格式得到 “2+3=5” 的值。除了可以把数据经过 write 写入字符串之外，还可以把数据经过 read 命令从字符串中读入数据。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0915</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: string = <span class="string">&quot;123&quot;</span></span><br><span class="line">    </span><br><span class="line">    read(string, *) a</span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行后变量 a 的值被设置成 123，设置的操作是发生在第6行的read命令。read命令可以把输入的来源设置到一个字符串变量中，在这里字符串 string 的内容为 “123” , 所以变量a 会被赋值为123。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">read(string, *) a</span><br></pre></td></tr></table></figure>
<p>在某些情况下，需要使用内部文件来设置数据。</p>
<p>使用 read 命令从键盘输入数据时，如果用户输入错误的数据，会导致程序死机。例如需要输入整数时却输入英文字母，就可以会死机。比较好的处理方法是，程序先把数据当成字符串读入，检查字符串中是否含有不合理的字符，如果字符串中都是0-9的数字字符，就把字符串转换成整数，不然就请用户再输入一次。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0916</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> i</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">external</span> :: GetInteger</span><br><span class="line">    i = GetInteger()</span><br><span class="line">    <span class="built_in">write</span>(*,*) i</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> GetIntger()</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) :: string</span><br><span class="line">    <span class="keyword">logical</span> :: invalid</span><br><span class="line">    <span class="keyword">integer</span> i, code</span><br><span class="line">    </span><br><span class="line">    invalid = .true.</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(invalid)</span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;请输入正整数&quot;</span></span><br><span class="line">        read(*, <span class="string">&quot;(a80)&quot;</span>) string</span><br><span class="line">        invalid = .false.</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>, <span class="built_in">len_trim</span>(string)</span><br><span class="line">            <span class="comment">!检查输入的字符是否包含&#x27;0&#x27;~&#x27;9&#x27;以外的字符</span></span><br><span class="line">            code = <span class="built_in">ichar</span>(string(i:i))</span><br><span class="line">            <span class="keyword">if</span>(code &lt; <span class="built_in">ichar</span>(<span class="string">&#x27;0&#x27;</span>) .or. code &gt; <span class="built_in">ichar</span>(<span class="string">&#x27;9&#x27;</span>)) <span class="keyword">then</span></span><br><span class="line">                invalid = .true.</span><br><span class="line">                <span class="keyword">exit</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    read(string, *) GetInteger</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 请输入正整数</span><br><span class="line">2.a</span><br><span class="line"> 请输入正整数</span><br><span class="line">2</span><br><span class="line">           2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>读取数据的程序代码是在函数 GetInteger 中，它会暂时先把数据以字符串方法读入，用循环检查每个字符是否为数字字符，如果发现了不是数字的字符，就会要求重新输入数据。</p>
<p>检查是否为数字字符的方法，是从字符的ASCII 值来看，数字字符0~9在ASCII 中是连号排列，0的ASCII 值最小，9最大。所以只要字符串中有任何一个字符的 ASCII 值小于 0 的ASCII 值，或是大于9的ASCII 值，字符串中就包含非数字的字符。</p>
<p>得到合理的输入后，再使用 read 命令把字符串中的数字读出来。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">read(string, *) GetInteger</span><br></pre></td></tr></table></figure>
<p>内部文件还可以应用在动态改变输出格式，输出格式可以事先存放在字符串中，程序进行中，动态改变字符串内容就可以<strong>改变输出格式</strong>（比如整数格式改为字符串），下面是一个实例：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0917</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> a,b</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">30</span>) :: fmtstring = <span class="string">&quot;(i??,&#x27;+&#x27;,i??,&#x27;=&#x27;,i??)&quot;</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">external</span> :: GetInteger</span><br><span class="line">    </span><br><span class="line">    a = GetInteger()</span><br><span class="line">    b = GetInteger()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(fmtstring(<span class="number">3</span>:<span class="number">4</span>), <span class="string">&quot;(i2.2)&quot;</span>) <span class="built_in">int</span>(<span class="built_in">log10</span>(<span class="keyword">real</span>(a))+<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">write</span>(fmtstring(<span class="number">11</span>:<span class="number">12</span>), <span class="string">&quot;(i2.2)&quot;</span>) <span class="built_in">int</span>(<span class="built_in">log10</span>(<span class="keyword">real</span>(b))+<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">write</span>(fmtstring(<span class="number">19</span>:<span class="number">20</span>), <span class="string">&quot;(i2.2)&quot;</span>) <span class="built_in">int</span>(<span class="built_in">log10</span>(<span class="keyword">real</span>(a+b))+<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">write</span>(*,fmtstring) a,b,a+b</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> GetInteger()</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) :: string</span><br><span class="line">    <span class="keyword">logical</span> :: invalid</span><br><span class="line">    <span class="keyword">integer</span> i, code</span><br><span class="line">    </span><br><span class="line">    invalid = .true.</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(invalid)</span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;请输入正整数&quot;</span></span><br><span class="line">        read(*, <span class="string">&quot;(a80)&quot;</span>) string</span><br><span class="line">        invalid = .false.</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>, <span class="built_in">len_trim</span>(string)</span><br><span class="line">            <span class="comment">!检查输入的字符是否包含&#x27;0&#x27;~&#x27;9&#x27;以外的字符</span></span><br><span class="line">            code = <span class="built_in">ichar</span>(string(i:i))</span><br><span class="line">            <span class="keyword">if</span>(code &lt; <span class="built_in">ichar</span>(<span class="string">&#x27;0&#x27;</span>) .or. code &gt; <span class="built_in">ichar</span>(<span class="string">&#x27;9&#x27;</span>)) <span class="keyword">then</span></span><br><span class="line">                invalid = .true.</span><br><span class="line">                <span class="keyword">exit</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    read(string, *) GetInteger</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 请输入正整数</span><br><span class="line">100</span><br><span class="line"> 请输入正整数</span><br><span class="line">1</span><br><span class="line">100+1&#x3D;101</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序的重点在于最后一行的输出，在这里希望能够把数字都很紧密地输出到屏幕上，所以需要知道输入的两个数字占用几个位数，再根据它们的值来决定输出格式。程序10-12行才会计算出这些数字占用几个位数。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">write</span>(fmtstring(<span class="number">3</span>:<span class="number">4</span>), <span class="string">&quot;(i2.2)&quot;</span>) <span class="built_in">int</span>(<span class="built_in">log10</span>(<span class="keyword">real</span>(a))+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>从 log10(a) + 1 可以得到变量 a 占用几个位数。因为 0&lt;a&lt;10 时 log10(a)&lt;1, 10&lt;a&lt;100时 log10(a) &lt; 2 …… ，把 log10(a)+1 转化为整数后就是数字 a 所占用的位数。<strong>如果不动态计算数字的位数大小，输出格式一定是固定的，不管数字的大小是多少，都会占用同样的字段宽度来做输出。</strong></p>
<h2 id="9-7-namelist">9-7 namelist</h2>
<p>namelist 也是很特殊的输入/出方法，它可以把一组相关变量封装在一起，输入/出这一组变量时，只要在 write/read 的 nml 字段赋值要使用哪一个 namelist 就行了，下面是一个实例：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0918</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span></span><br><span class="line">    <span class="keyword">namelist</span> /na/ a,b,c</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="keyword">nml</span>=na)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;NA</span><br><span class="line"> A&#x3D;          1,</span><br><span class="line"> B&#x3D;          2,</span><br><span class="line"> C&#x3D;          3,</span><br><span class="line"> &#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序的第4行，把a,b,c 这3个变量放在名字叫做 na 的 namelist 中。namelist 也算是声明的一部分，必须编写在程序执行命令的前面。 namelist 的语法很类似 common ， 不过使用 namelist 时一定要取名字。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namelist</span> /nl_name/ var1,var2,……</span><br></pre></td></tr></table></figure>
<p>封装好 namelist 后，在 write 的 nml 字段中指明要输出哪一个 namelist ，就可以把在 namelist 中的变量全部输出。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">write</span>(*,<span class="keyword">nml</span>=na)</span><br></pre></td></tr></table></figure>
<p>输出namelist 时不能赋值输出格式，Fortran 90 标准中规定输出 namelist 时首先会输出符合&amp;，后面紧接着这个namelist 的名字。接着会根据顺序输出变量的名称、等号及内容，变量之间用空格或逗号来做分隔，最后使用除号来作结束。</p>
<p>至于每个数字内容会用什么格式来输出，就由编译器自行决定。（gfortran 的显示结果就和书上不太一样）</p>
<p>namelist 也可以用来输入数据。不过通常都会用来读取文件，不会用在键盘输入，先来看一个键盘输入的实例：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0919</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a,b,c</span><br><span class="line">    <span class="keyword">namelist</span> /na/ a,b,c</span><br><span class="line">    read(*, <span class="keyword">nml</span>=na)</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="keyword">nml</span>=na)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;na a&#x3D;1 b&#x3D;2 c&#x3D;3 &#x2F;</span><br><span class="line">&amp;NA</span><br><span class="line"> A&#x3D;          1,</span><br><span class="line"> B&#x3D;          2,</span><br><span class="line"> C&#x3D;          3,</span><br><span class="line"> &#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里输入必须要按照上面介绍的格式来输入，先输入符号&amp;，紧接namelist 的名字，再输入变量名称、等号及内容，要结束时还要加上除号。</p>
<p>读取namelist 时，可以不填入所有变量的值，只要以&amp;na开始输入，给一个除号就可以结束输入。变量可以不按照顺序输入，程序会自动按照变量名称来设置数值。变量设置可以重复输入，不过变量会得到最后一次设置的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;na a&#x3D;1 a&#x3D;2 &#x2F; (重复设置a两次，变量a最后会等于2)</span><br></pre></td></tr></table></figure>
<p>从这个例子可以发现，使用键盘来输入namelist 的内容会非常麻烦。namelist 通常使用再文本文件的输入/出中，使用 read 从文件中读取数据时，会自动从目前的位置向下寻找存放 namelist 的地方。来看下一个实例：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex0920</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: a(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">namelist</span> /na/ a</span><br><span class="line">    </span><br><span class="line">    open(<span class="number">10</span>,<span class="keyword">file</span>=<span class="string">&quot;ex0920.txt&quot;</span>)</span><br><span class="line">    read(<span class="number">10</span>,<span class="keyword">nml</span>=na)</span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(3i2)&quot;</span>) a</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中 ex0920.txt 的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">happy birthday</span><br><span class="line">&amp;na a&#x3D;1,2,3 &#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序打开时，读写位置在文件的开头。读者可以发现文件开头的内容是字符串 happy birthday ，第7行的read命令会自动向下寻找 na 这个 namelist 的存放位置来读取数据。这边看到了namelist 处理数组的方法，它会在等号后面根据序号显示数组内容。</p>
<h2 id="9-8-文件的应用">9-8 文件的应用</h2>
<p>光盘中 \program\chap09\grades.txt 的文件是一张成绩单，记录了全班 20 位学生的某一次阶段考试成绩。</p>
<p>编写程序来读取成绩单，计算每位同学的总分，及各科的全部平均分，以下面的程序重新输出成绩单的内容：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">type</span> student</span><br><span class="line">        <span class="keyword">integer</span> :: Chinese, English, Math, Natural, Social</span><br><span class="line">        <span class="keyword">integer</span> :: total</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex0921</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: students = <span class="number">20</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) :: tempstr</span><br><span class="line">    <span class="keyword">type</span>(student) :: s(students) <span class="comment">!保存学生成绩</span></span><br><span class="line">    <span class="keyword">type</span>(student) :: total <span class="comment">!保存平均分数</span></span><br><span class="line">    <span class="keyword">integer</span> i, num, error</span><br><span class="line">    </span><br><span class="line">    open(fileid, <span class="keyword">file</span>=<span class="string">&quot;grades.txt&quot;</span>, <span class="keyword">status</span>=<span class="string">&quot;old&quot;</span>, <span class="keyword">iostat</span>=error)</span><br><span class="line">    <span class="keyword">if</span> (error/=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;open grades.txt fail&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    read(fileid, <span class="string">&quot;(a80)&quot;</span>) tempstr <span class="comment">!读入第一行文本</span></span><br><span class="line">    total = student(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="comment">!用循环读入每位同学的成绩</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,students</span><br><span class="line">        read(fileid, *) num, s(i)%Chinese, s(i)%English, &amp;</span><br><span class="line">                        s(i)%Math, s(i)%Natural, s(i)%Social</span><br><span class="line">        <span class="comment">!计算总分</span></span><br><span class="line">        s(i)%Total = s(i)%Chinese + s(i)%English + &amp;</span><br><span class="line">                    s(i)%Math + s(i)%Natural + s(i)%Social</span><br><span class="line">        <span class="comment">!累加上各科的分数，计算各科平均时使用</span></span><br><span class="line">        total%Chinese = total%Chinese + s(i)%Chinese</span><br><span class="line">        total%English = total%English + s(i)%English</span><br><span class="line">        total%Math = total%Math + s(i)%Math</span><br><span class="line">        total%Natural = total%Natural + s(i)%Natural</span><br><span class="line">        total%Social = total%Social + s(i)%Social</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">!重新输出每位学生成绩</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(7a7)&quot;</span>) <span class="string">&quot;座号&quot;</span>,<span class="string">&quot;中文&quot;</span>,<span class="string">&quot;英文&quot;</span>,<span class="string">&quot;数学&quot;</span>,<span class="string">&quot;自然&quot;</span>,<span class="string">&quot;社会&quot;</span>,<span class="string">&quot;总分&quot;</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,students</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(7i7)&quot;</span>) i,s(i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">!计算并输出平均分数</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(a7,6f7,1)&quot;</span>) <span class="string">&quot;平均&quot;</span>,&amp;</span><br><span class="line">        <span class="keyword">real</span>(total%Chinese)/<span class="keyword">real</span>(students),&amp;</span><br><span class="line">        <span class="keyword">real</span>(total%English)/<span class="keyword">real</span>(students),&amp;</span><br><span class="line">        <span class="keyword">real</span>(total%Math)/<span class="keyword">real</span>(students),&amp;</span><br><span class="line">        <span class="keyword">real</span>(total%Natural)/<span class="keyword">real</span>(students),&amp;</span><br><span class="line">        <span class="keyword">real</span>(total%Social)/<span class="keyword">real</span>(students),&amp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序使用另一个方法来判断 grades.txt 是否存在，第18行的open 命令中，iostat 字段会把文件打开是否成功的结果放在变量 error 中。 error 的值若不为零代表找不到这个文件。</p>
<p>读入文件时，有几个地方的数据是可以直接跳过去不处理的，像第一行的表头字符串及每一行最前面的学生座号。表头字符串只是用来说明这个位置存放的是哪个科目的成绩，而每一行最前面的学生座号是按照顺序排列下来的。这些固定的数据不需要再处理，把它们读进来之后就可以不再理会它们。程序中的变量 tempstr 和 num 从文件中得到数据后就没有再去使用。</p>
<p>第24行的 read 命令需要赋值输入格式，如果不赋值这里要一口气读入80个字符长度的字符串，读取数据时，grade.txt 中第一行会被当成 6 个小字符串。<strong>使用默认输入格式时，遇到空格符会当成分隔符</strong>。</p>
<p>第28行的 read 命令可以不赋值输入格式，在文本文件格式下，两笔数据之间如果只用空格来做分隔，不特别赋值输入格式就可以正确得到内容。文件 grades.txt 中，从第2行开始，每一行都是连续的 6 个整数，数字之间用空格来分隔，所以从第2行之后，不需要赋值输入格式，每一行都读入6个整数就行了。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">read(fileid, *) num, s(i)%Chinese, s(i)%English, &amp;</span><br><span class="line">                s(i)%Math, s(i)%Natural, s(i)%Social</span><br></pre></td></tr></table></figure>
<p>这个实例没有做成绩排名，这部分留到习题给读者练习。在这里使用自定义类型来记录每位学生的成绩，如果不用自定义类型时，分别需要对每个科目都声明一个数组来记录成绩，在做排序时交换数据会变得很麻烦。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!使用自定义类型时，s(j)及s(i) 中就包含了一位学生的全部数据</span></span><br><span class="line">temp = s(j)</span><br><span class="line">s(j) = s(i)</span><br><span class="line">s(i) = temp</span><br><span class="line"></span><br><span class="line"><span class="comment">!不使用自定义类型时，要对每个科目声明一个数组来记录成绩</span></span><br><span class="line"><span class="comment">!需要交换两位学生数据时，要交换5个数组的数据，非常麻烦</span></span><br><span class="line">temp=Chinese(j)</span><br><span class="line">Chinese(j)=Chinese(i)</span><br><span class="line">Chinese(i)=temp</span><br><span class="line">temp=English(j)</span><br><span class="line">English(j)=English(i)</span><br><span class="line">English(i)=temp</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h1>10 指针</h1>
<p>指针是一个很有趣的东西，它最简单的应用可以用来保存变量，或者是动态使用内存。更进一层则可以应用在特别的“数据结构”上，例如创建“串行结构”、“树状结构”等等。</p>
<h2 id="10-1-指针基本概念">10-1 指针基本概念</h2>
<p>简单地说，指针是一种“间接使用数据”的方法。指针变量用来保存一个“内存地址”。当程序要读写指针变量时，实际上会经过两个步骤：</p>
<ol>
<li>取出指针所保存的内存位置。</li>
<li>到这个内存位置读写数据</li>
</ol>
<p>指针变量中所保存的内存地址来源可以有两种：</p>
<ol>
<li>记录其他非指针变量的内存位置。</li>
<li>程序执行中动态配置一块内存。</li>
</ol>
<p>最基本的指针运行，是指指针变量拿来记录另外一个目标变量的地址，再经过指针来读写数据，来看看这个实例：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex1001</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">target</span> :: a=<span class="number">1</span> <span class="comment">!声明一个可以当成目标的变量</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p <span class="comment">!声明一个可以指向整数的指针</span></span><br><span class="line">    p=&gt;a <span class="comment">!把指针p指到变量a</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) p</span><br><span class="line">    a = <span class="number">2</span> <span class="comment">!改变a的值</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) p</span><br><span class="line">    p = <span class="number">3</span> <span class="comment">!改变指针p所指向的内存内容</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 </span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序的第3行出现新的声明方法，第3行的声明中出现新的形容词 target 。声明中加上 target 的变量，在使用上并不会有任何不同，只不过这种变量可以把它的内存地址赋值给指针变量。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">target</span> :: a = <span class="number">1</span> </span><br></pre></td></tr></table></figure>
<p>第4行也出现了新的声明方法，声明中使用了 pointer, 表示这里要声明的是指针变量。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p <span class="comment">!声明一个可以指向整数的指针</span></span><br></pre></td></tr></table></figure>
<p>有了指针之后，程序第5行会把指针p指向变量a。也就是把向量a的内存地址记录在指针p中。请注意在这边使用了类似箭头&quot;=&gt;&quot;的符号来作指针的指向设置，而不是使用等号。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">p=&gt;a</span><br></pre></td></tr></table></figure>
<p>指针设置后内存指向位置后，就可以把它当成一般变量来使用。程序会自动取出指针中所记录的内存地址，再对这个内存地址来做读写。第6行输出指针p时，内容为1，正是变量a这个时候的值。</p>
<p>程序第7行把变量a的值重新设置为2，第8行再试着输出指针p的内容，理所当然地可以发现这个时候输出的值为2。使用指针p，就等于使用变量a。</p>
<p>程序第9行会把指针p所指向的内存中的数值设置为3，也就等于把变量a设置成3。</p>
<p>这个程序很简单地示例了指针的使用方法，只要把指针赋值到一个目标变量上，使用指针与使用这个变量会变成没有差别，这是第1种使用方法。下面来看看第2种使用方法，动态配置内存。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex1002</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p <span class="comment">!声明一个可以指向整数的指针</span></span><br><span class="line">    <span class="built_in">allocate</span>(p) <span class="comment">!配置一块可以存放integer 的内存空间给指针p</span></span><br><span class="line">    p=<span class="number">100</span> <span class="comment">!得到内存后指针p可以像一般整数一样来使用</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) p</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure>
<p>这个程序示范了第2种使用指针的方法。函数 allocate 在第7章中曾经介绍过，那个时候是用来配置内存空间给可变大小的矩阵使用，它也可以用来配置一块内存空间给指针使用。程序第4行会把配置到的内存地址存放在指针p中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allocate(p) </span><br></pre></td></tr></table></figure>
<p>如果指针指向变量，指针可以随时重新设置它的指向。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">target</span> :: a = <span class="number">1</span>, b = <span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p</span><br><span class="line">p=&gt;a <span class="comment">!把p指向a</span></span><br><span class="line"><span class="built_in">write</span>(*,*) p <span class="comment">!会输出1</span></span><br><span class="line">p=&gt;b <span class="comment">!把p指向b</span></span><br><span class="line"><span class="built_in">write</span>(*,*) p <span class="comment">!会输出2</span></span><br></pre></td></tr></table></figure>
<p>不过如果指针中所指向的通过 allocate 所配置的内存，重新改变指向前要对这个内存地址做一些处理，看是把它交给其他指针，或是把内存空间经过 deallocate 释放都行，不然会在计算机中形成一块已经配置、却被丢弃的内存。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">target</span> :: a=<span class="number">1</span>, b=<span class="number">2</span></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p</span><br><span class="line"><span class="built_in">allocate</span>(p) <span class="comment">!配置内存</span></span><br><span class="line">p=<span class="number">1</span></span><br><span class="line"><span class="built_in">write</span>(*,*) p</span><br><span class="line"><span class="built_in">deallocate</span>(p) <span class="comment">!释放内存</span></span><br><span class="line">p=&gt;a <span class="comment">!再改变指针p的指向</span></span><br></pre></td></tr></table></figure>
<p>上面这段代码中，如果指针在指向变量a之前，没有先把配置得到的内存释放回去，那这块内存空间会变得无人认领。经过函数allocate 得到的内存空间，再经过 dellocate 释放回去，或是程序结束之前，操作系统仍然会认定这块空间是安排给这个程序使用的。如果不先 deallocate，就重新设置指针p的指向，会导致内存空间白白浪费。</p>
<p>使用指针之前，一定要先设置好指针的目标。不然在程序执行时，会发生意想不到的情况。因为使用指针是使用它所记录的内存地址。还没设置指向的指针，不会知道哪里有内存可以使用。在这个时候使用指针，会出现内存使用错误的信息。在 windows 系统下可能会显示一堆内存地址，显示内存读写不正常的信息，然后中断程序。在 Unix 系统下可能会出现 Segmentation fault 的错误信息。</p>
<p>Fortran 提供 associated 函数，用来检查指针是否已经设置指向。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">associated</span>(<span class="keyword">pointer</span>,[<span class="keyword">target</span>])</span><br><span class="line">检查指针是否设置指向，返回值为布尔变量。如果只放入第<span class="number">1</span>个指针参数，会检查这个指针是否已经赋值好”方向“。</span><br><span class="line">如果放入<span class="number">2</span>个变量，则会检查第<span class="number">1</span>个指针变量是否指向第<span class="number">2</span>个变量。</span><br></pre></td></tr></table></figure>
<p>一般来说，判断指针有没有赋值好方向，是检查它的指向是否指到了不可能拿来使用的内存地址。函数 null() 会返回一个不能使用的内存地址，它可以用来把指针初值指向一个不能使用的内存地址，确保 associated 函数可以正确判断出这个指针还没有给定指向</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p =&gt; null() <span class="comment">!把指针初值指向一个不能使用的内存地址</span></span><br></pre></td></tr></table></figure>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">NUll()</span><br><span class="line">Fortran <span class="number">95</span> 添加的函数。会返回一个不能使用的内存地址，在指针还没有指向前设置成这个值，</span><br><span class="line">可以让<span class="built_in">associated</span> 函数判断不会出错。</span><br></pre></td></tr></table></figure>
<p>除了函数NULL 之外，还可以使用 nullify 命令来把指针设置成不能使用的内存地址。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nullify</span>(pointer1,[pointer2,...])</span><br><span class="line">用来将指针设置成还没有指向任何内存地址。Fortran <span class="number">90</span> 只能使用 <span class="built_in">nullify</span> 而不能使用 null 函数来设置指针</span><br></pre></td></tr></table></figure>
<p>来看一个实验性质的程序：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex1003</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: a=&gt;null()</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">target</span> :: b=<span class="number">1</span>,c=<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="built_in">associated</span>(a) <span class="comment">!false，指针a尚未赋值</span></span><br><span class="line">    a=&gt;c</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="built_in">associated</span>(a) <span class="comment">!true，指针a已赋值</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="built_in">associated</span>(a,c) <span class="comment">!true，指针a指向c</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="built_in">associated</span>(a,b) <span class="comment">!false，指针a不指向b</span></span><br><span class="line">    <span class="built_in">nullify</span>(a) <span class="comment">!把指针a设为没有指向</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="built_in">associated</span>(a) <span class="comment">!false，指针a尚未赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F</span><br><span class="line">T</span><br><span class="line">T</span><br><span class="line">F</span><br><span class="line">F</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>指针可以声明成任何数据类型，甚至是使用 type 来自定义的数据类型。有一个概念很重要，那就是不管指针是用来指向哪一种数据类型，不论是integer, real, character, complex 或是自定义类型，每一种指针变量都占用相同的内存空间。因为指针变量实际上是用来记录内存地址，以现在的32位计算机来说，记录一个内存地址，固定需要使用32 bits = 4 bytes 的空间。</p>
<h2 id="10-2-指针数组">10-2 指针数组</h2>
<p>指针也可以声明成数组，声明成数组的指针同样可以有两种使用方法：</p>
<ol>
<li>把指针指到其他数组。</li>
<li>配置内存空间来所用。</li>
</ol>
<p>先来看第一种使用方法：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex1004</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: a(:)</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">target</span> :: b(<span class="number">5</span>)  = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /)</span><br><span class="line">    <span class="comment">!把指针数组a指向数组b</span></span><br><span class="line">    a=&gt;b</span><br><span class="line">    <span class="comment">!a(1~5) =&gt; b(1~5)</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    a=&gt;b(<span class="number">1</span>:<span class="number">3</span>)</span><br><span class="line">    <span class="comment">!a(1)=&gt;b(1),a(2)=&gt;b(2),a(3)=&gt;b(3)</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    a =&gt; b(<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>)</span><br><span class="line">    <span class="comment">!a(1)=&gt;b(1),a(3)=&gt;b(3),a(5)=&gt;b(5)</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    a =&gt; b(<span class="number">5</span>:<span class="number">1</span>:-<span class="number">1</span>)</span><br><span class="line">    <span class="comment">!a(1)=&gt;b(5),a(2)=&gt;b(4),a(3)=&gt;b(3),a(4)=&gt;b(2),a(5)=&gt;b(1)</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1           2           3           4           5</span><br><span class="line">1           2           3</span><br><span class="line">1           3           5</span><br><span class="line">5           4           3           2           1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序实例是指针数组的第一种使用方法，指针数组在声明时只需要说明它的维数就行了，不需要说明它的大小。这一点类似可变大小数组。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">pointer</span> :: a(:) <span class="comment">!声明一维的指针数组</span></span><br></pre></td></tr></table></figure>
<p>被当成目标给指针使用的数组，在声明时同样要加上 target 这个形容词。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">target</span> :: b(<span class="number">5</span>) = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /) <span class="comment">!这个数组可以给指针使用</span></span><br></pre></td></tr></table></figure>
<p>把指针数组指向一个数组可以有很多设置方法，最简单的方法就是直接指过去，就像程序中第6行的做法一样。这种做法会让指针a成为数组b的分身，使用指针a就跟使用数组b完全一样。输出结果的第1行可以证明指针数组a所指到的内容与数组b是完全相同的。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a=&gt;b</span><br></pre></td></tr></table></figure>
<p>指针数组可以只选择目标数组中的一小部分来使用，第9行只取出数组b中的前3个变量来使用。这个时候指针数组a的大小为3，使用a等于使用b的前3个变量。输出结果的第2行可以证明这个事实。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a=&gt;b(<span class="number">1</span>:<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>除了可以把指针数组拿来指向某个目标数组之外，还可以使用 allocate 来分配一块内存来给它使用，所以指针数组也可以拿来当作可变大小的数组使用。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex1005</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: a(:) <span class="comment">!定义a是一维的指针数组</span></span><br><span class="line">    <span class="built_in">allocate</span>(a(<span class="number">5</span>)) <span class="comment">!配置5个整数的空间给指针a</span></span><br><span class="line">    a = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /)</span><br><span class="line">    <span class="built_in">write</span>(*,*) a</span><br><span class="line">    <span class="built_in">deallocate</span>(a) <span class="comment">!allocate 得到的内存要记得归还</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1           2           3           4           5</span><br></pre></td></tr></table></figure>
<p>在这边还是要提醒一点，allocate 得到的内存，在不需要使用时，要记得用 deallocate 释放回去。</p>
<p>看完了一维指针数组的例子，现在来看看多维指针数组的使用方法：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex1006</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: a(:,:) <span class="comment">!定义a是二维的指针数组</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">target</span> :: b(<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">integer</span> i</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">3</span>)</span><br><span class="line">        b(:,i,<span class="number">1</span>) = i</span><br><span class="line">        b(:,i,<span class="number">2</span>) = <span class="number">2</span>*i</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line">    </span><br><span class="line">    a =&gt; b(:,:,<span class="number">1</span>)</span><br><span class="line">    <span class="comment">! a(i,j) =&gt; b(i,j,1)</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(9i2)&quot;</span>) a</span><br><span class="line">    a =&gt; b(<span class="number">1</span>:<span class="number">3</span>:<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="comment">! a(1,1)=&gt;b(1,1,2), a(2,1)=&gt;b(3,1,2)</span></span><br><span class="line">    <span class="comment">! a(1,2)=&gt;b(1,2,2), a(2,1)=&gt;b(3,2,2)</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(4i2)&quot;</span>) a</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 1 1 2 2 2 3 3 3</span><br><span class="line">2 2 4 4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在程序中需要常常使用数组的一小部分时，声明一个指针来使用这一部分的数组，使用起来会比较方便。</p>
<p>最后说明一个概念，既然指针也可以拿来作为可变大小的数组，那它和第7章中介绍的可变大小数组有什么不同？</p>
<p>声明成 allocatable 的 数组有它的生存周期，它只存在于声明它的函数中，函数结束后数组会自动 deallocate 释放内存空间。如果声明成指针，在函数结束时，不会自动去 deallocate 指针所指到的内存，在程序进行中要程序员自行使用 deallocate 才会释放内存。不然要等到程序结束，让操作系统来回收这一块内存。</p>
<h2 id="10-3-指针与函数">10-3 指针与函数</h2>
<p>指针变量一样可以作为参数在函数之间传递，也可以作为函数的返回值。使用时有下面几种策略：</p>
<ol>
<li>要把指针传递给函数时，要声明这个函数的参数使用接口 interface</li>
<li>指针参数声明时不需要 intent 这个形容词</li>
<li>函数返回值若为指针时，需要定义函数的 interface</li>
</ol>
<p>来看一个实例</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> ex1007</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">target</span> :: a(<span class="number">8</span>) = (/ <span class="number">10</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">25</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">17</span>, <span class="number">19</span> /)</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p(:)</span><br><span class="line">    <span class="keyword">interface</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span></span> GetMin(p)</span><br><span class="line">            <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p(:)</span><br><span class="line">            <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: getmin</span><br><span class="line">        <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    </span><br><span class="line">    p =&gt; a(<span class="number">1</span>:<span class="number">8</span>:<span class="number">2</span>)</span><br><span class="line">    <span class="comment">! p(1) =&gt; a(1), p(2) =&gt; a(3), p(3) =&gt; a(5), p(4) =&gt; a(7)</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) GetMin(p)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span></span> GetMin(p)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p(:)</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: GetMin</span><br><span class="line">    <span class="keyword">integer</span> i,s</span><br><span class="line">    <span class="keyword">integer</span> <span class="built_in">min</span></span><br><span class="line">    </span><br><span class="line">    s=<span class="built_in">size</span>(p,<span class="number">1</span>) <span class="comment">!查询数组的大小</span></span><br><span class="line">    <span class="built_in">min</span> = <span class="number">2</span>**<span class="number">30</span> <span class="comment">!先把min设置为一个很大的值</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,s</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">min</span>&gt;p(i)) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">min</span>=p(i)</span><br><span class="line">            GetMin=&gt;p(i)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<p>这个程序示例了传递指针给函数，以及从函数中返回指针的方法。函数 GetMin 会把输入的数组值中，最小的数值找出来。函数 GetMin 的参数类型及返回值都是指针，所以在调用前要说明它的使用接口 interface 。没有编写 interface 时，编译过程当中并不一定会出现错误信息，不过在程序执行时会不正确，参数不会正确地传递出去。</p>
<p>程序第12行先设置指针 p 的指向，它指到数组 a中的一部分，再把指针 p 当成参数传给函数 GetMin 使用。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">p =&gt; a(<span class="number">1</span>:<span class="number">8</span>:<span class="number">2</span>)</span><br><span class="line"><span class="comment">! p(1) =&gt; a(1), p(2) =&gt; a(3), p(3) =&gt; a(5), p(4) =&gt; a(7)</span></span><br></pre></td></tr></table></figure>
<p>找到最小值的地方，是使用循环来一个一个检查数组中的数值。min 变量在进入循环前先设置成一个很大的数值，在数组中发现比它小的数值时，就重新设置 min 的值。循环执行完后，min 值就会是数组中最小的数值。</p>
<p>编写 interface 是一件麻烦的工作，不过如果函数是封装在 module 中，就等于已经编写好使用接口。来看看这个程序写成 module 的版本。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> func</span><br><span class="line"></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line"><span class="function"><span class="keyword">function</span></span> GetMin(p)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p(:)</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: GetMin</span><br><span class="line">    <span class="keyword">integer</span> i,s</span><br><span class="line">    <span class="keyword">integer</span> <span class="built_in">min</span></span><br><span class="line">    </span><br><span class="line">    s=<span class="built_in">size</span>(p,<span class="number">1</span>) <span class="comment">!查询数组的大小</span></span><br><span class="line">    <span class="built_in">min</span> = <span class="number">2</span>**<span class="number">30</span> <span class="comment">!先把min设置为一个很大的值</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,s</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">min</span>&gt;p(i)) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">min</span>=p(i)</span><br><span class="line">            GetMin=&gt;p(i)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1008</span><br><span class="line">    <span class="keyword">use</span> func</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">target</span> :: a(<span class="number">8</span>) = (/ <span class="number">10</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">25</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">17</span>, <span class="number">19</span> /)</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p(:)</span><br><span class="line">    </span><br><span class="line">    p =&gt; a(<span class="number">1</span>:<span class="number">8</span>:<span class="number">2</span>)</span><br><span class="line">    <span class="comment">! p(1) =&gt; a(1), p(2) =&gt; a(3), p(3) =&gt; a(5), p(4) =&gt; a(7)</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) GetMin(p)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="10-4-基本的指针应用">10-4 基本的指针应用</h2>
<p>读者看过上一节对指针使用的介绍后，大概还是会对指针存在的必要性感到怀疑。究竟这种”间接读写数据“的数据类型有什么作用？</p>
<p>方便使用高维数组中的某一部分元素。</p>
<p>不管指针是用来指向什么类型，它都占用相同的内存空间（在PC上为 4 bytes）。指向自定义类型时，指针可以很快速地交换数据。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span>, <span class="keyword">target</span> :: a(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">pointer</span> :: b</span><br><span class="line">b =&gt; a(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">!假如经常要使用 a(2,2,2)的值，就可以通过指针来使用它，程序代码中只要用b就可以代替a(2,2,2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">target</span> :: matrix(<span class="number">100</span>,<span class="number">100</span>)</span><br><span class="line"><span class="keyword">integer</span>, <span class="keyword">pointer</span> :: p(:,:)</span><br><span class="line">p =&gt; matrix(<span class="number">10</span>:<span class="number">20</span>,<span class="number">10</span>:<span class="number">20</span>)</span><br><span class="line"><span class="comment">!用这个方法就可以把100×100的矩阵中里面的一块10×10矩阵拿出来使用。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person</span><br><span class="line">	<span class="keyword">character</span>(len=<span class="number">20</span>) <span class="keyword">name</span></span><br><span class="line">	<span class="keyword">real</span> :: weight, height</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!一个type(person)类型至少占用28 bytes</span></span><br><span class="line"><span class="comment">!因为它里面有20个字符及2个浮点数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>(person) :: a,b,temp</span><br><span class="line"><span class="comment">!指向 type(person) 的指针，在PC中每个变量只占4 bytes</span></span><br><span class="line"><span class="keyword">type</span>(person), <span class="keyword">pointer</span> :: pa,pb,pt</span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"><span class="comment">!要交换 type(person) 类型时，最少需要移动 28*3=84 bytes 的空间</span></span><br><span class="line">temp = a</span><br><span class="line">a = b</span><br><span class="line">b = temp</span><br><span class="line"></span><br><span class="line">pa=&gt;a</span><br><span class="line">pb=&gt;b</span><br><span class="line"><span class="comment">!如果拿指针来交换，以PC来说，只需要移动 4*3=12 bytes 的空间</span></span><br><span class="line">pt =&gt; pa</span><br><span class="line">pa =&gt; pb</span><br><span class="line">pb =&gt; pt</span><br></pre></td></tr></table></figure>
<p>来看一个以自定义类型数据来做排序的实例，排序程序常常会需要把两条数据交换，如果不使用指针，交换数据时需要移动很大块的内存空间。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> func</span><br><span class="line"><span class="comment">! person类型至少占用18 bytes</span></span><br><span class="line"><span class="comment">! 因为它有10个字符及2个浮点数</span></span><br><span class="line"><span class="keyword">type</span> person</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">10</span>) :: <span class="keyword">name</span></span><br><span class="line">    <span class="keyword">real</span> :: height, weight</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="comment">! pperson 类型通常占用 4 bytes </span></span><br><span class="line"><span class="comment">! 因为它里面只有一个指针，指针在PC中固定使用 4 bytes</span></span><br><span class="line"><span class="keyword">type</span> pperson</span><br><span class="line">    <span class="keyword">type</span>(person), <span class="keyword">pointer</span> :: p</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sort(p)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(pperson) :: p(:)</span><br><span class="line">    <span class="keyword">type</span>(pperson) :: temp</span><br><span class="line">    <span class="keyword">integer</span> i,j,s</span><br><span class="line">    </span><br><span class="line">    s = <span class="built_in">size</span>(p,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,s-<span class="number">1</span></span><br><span class="line">        <span class="keyword">do</span> j=i+<span class="number">1</span>, s</span><br><span class="line">            <span class="keyword">if</span>(p(j)%p%height &lt; p(i)%p%height) <span class="keyword">then</span></span><br><span class="line">                temp = p(i)</span><br><span class="line">                p(i) = p(j)</span><br><span class="line">                p(j) = temp</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1008</span><br><span class="line">    <span class="keyword">use</span> func</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(person), <span class="keyword">target</span> :: p(<span class="number">5</span>)=(/ person(<span class="string">&quot;陈同学&quot;</span>, <span class="number">180.0</span>, <span class="number">75.0</span>), &amp;</span><br><span class="line">                                person(<span class="string">&quot;黄同学&quot;</span>, <span class="number">170.0</span>,<span class="number">65.0</span>), &amp;</span><br><span class="line">                                person(<span class="string">&quot;刘同学&quot;</span>, <span class="number">175.0</span>,<span class="number">80.0</span>), &amp;</span><br><span class="line">                                person(<span class="string">&quot;蔡同学&quot;</span>, <span class="number">182.0</span>,<span class="number">78.0</span>), &amp;</span><br><span class="line">                                person(<span class="string">&quot;许同学&quot;</span>, <span class="number">178.0</span>,<span class="number">70.0</span>)&amp;</span><br><span class="line">                                                                /)</span><br><span class="line">    <span class="keyword">type</span>(pperson) :: pt(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">integer</span> i</span><br><span class="line">    <span class="comment">! 把pt数组中的指针全部指向数组p</span></span><br><span class="line">    <span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">        pt(i)%p =&gt; p(i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line">    <span class="comment">! 按照身高从小到大排序</span></span><br><span class="line">    <span class="keyword">call</span> sort(pt)</span><br><span class="line">    <span class="comment">! 输出排序的结果</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(5(a10,f6.1,f5.1/))&quot;</span>) (pt(i)%p, i=<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line">    <span class="comment">! 这里书上是 a8, 应该改成 a10，不然输出不完整</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">黄同学  <span class="number">170.0</span> <span class="number">65.0</span></span><br><span class="line">刘同学  <span class="number">175.0</span> <span class="number">80.0</span></span><br><span class="line">许同学  <span class="number">178.0</span> <span class="number">70.0</span></span><br><span class="line">陈同学  <span class="number">180.0</span> <span class="number">75.0</span></span><br><span class="line">蔡同学  <span class="number">182.0</span> <span class="number">78.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行过程中发现了一个现象，书上输出语句上是 a8 (字符串指定为8个字符)，而 person 自定义类型声明的时候字符长度是10，导致<strong>字符输出不完整</strong>。如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">黄同▒ 170.0 65.0</span><br><span class="line">刘同▒ 175.0 80.0</span><br><span class="line">许同▒ 178.0 70.0</span><br><span class="line">陈同▒ 180.0 75.0</span><br><span class="line">蔡同▒ 182.0 78.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里程序中使用了两个自定义类型 person 及 pperson 。person 类型可以用来记录人名、身高、体重等数据，pperson 类型中只有一个指向 person 类型的指针。数组p是 type(person) 类型，声明时同时设置了它的初值，数组 pt 则是 type(pperson) 类型。数组 p 最少会使用 28×5=140 bytes 的内存空间，而数组 pt 在目前的 PC 中只需要使用 4×5=20 bytes 的内存空间。</p>
<p>程序第49~51 行用来把数组 pt 中的指针指到数组 p 中。请注意 pt(i) 并不是指针，它是 type(pperson) 类型的变量，数组中的 pt(i)%p 元素才是指针。设置好指针之后，使用  pt(i)%p 就等于使用 pt(i)%p 就等于使用 p(i).</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">! 把pt数组中的指针全部指向数组p</span></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">    pt(i)%p =&gt; p(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">forall</span></span><br></pre></td></tr></table></figure>
<p>函数 sort 使用的算法是第7章介绍过的选择排序法，他会根据每个人的身高信息来排序。这个程序中，排序程序在做数据交换时只需要交换两条数据的内存地址，不需要去移动两条数据的内存。当自定义数据中的数据量很大时，执行效率可以有明显地提升。</p>
<h2 id="10-5-指针的高级应用">10-5 指针的高级应用</h2>
<p>指针除了可以间接地使用变量，以及当成可变大小数组来使用之外，还有一个很重要的用途，它可以创建各种的”串行结构“ 以及 ” 树状结构“ 等等。</p>
<p>使用指针来创建 ”串行结构“ 可以有很多应用，其中最重要的一项应用是用来动态使用内存。在写程序时常常会遇到无法事先估计数据数目的情况，这个问题最传统的解决方法，是声明一个”超级巨大“的数据来保存数据。而所声明的数组，在使用时大部分的空间都是闲置的。要是空间不够时，那就麻烦大了，所以一开始就尽可能地把数组加大。</p>
<p>使用”串行结构“来解决这一类的问题时，可以配合需要向内存要求刚好的空间。只有一条数据时就要求一条数据的空间，有一千条数据时，就要求一千条数据的空间。这个方法可以非常有效率地来使用内存。</p>
<h3 id="10-5-1-单向串行">10-5-1 单向串行</h3>
<p>如何节省内存，在程序设计中一直是非常重要的课题。很早的时候，节省内存是屈就于现实，因为当时计算机的内存容量都很小，所以程序一定要短小精干才行。虽然现在内存越来越便宜，内存越来越大，节省内存仍然有其必要的价值。<strong>因为无论计算机配备多少的内存，都永远无法满足贪得无厌的人类。</strong></p>
<p>现代的操作系统都号称是”多任务“的操作系统，所谓多任务的操作系统，是指计算机可以同时执行多个程序。而能够执行几个程序就取决于计算机的内存大小，以及程序所占据的内存空间。所以，如果单个程序所占用的内存越少，就可以同时执行更多的程序，或是在执行程序时得到更高的效率。</p>
<p>前面已经介绍过可变大小数组，这个功能已经可以有效率地使用内存。这个做法虽然已经有相当程度的灵活性，但是在某些情况之下仍然不足。要是数组声明好大小以后，却发现不够用了，那该怎么办？先 deallocate 再重新 allocate 吗？ 那原来在数组中已经存放的数据要怎么办？必须另外找地方把它们先保存起来，不然 deallocate 时数据会流失。</p>
<p>还有就是如果想要在数组中 ”插入“ 一个数值，必须要把数组中的数据一个个向后移动。这个方法的执行效率很差，需要做很多次的内存移动。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> j=i+<span class="number">1</span>, size_of_A-<span class="number">1</span></span><br><span class="line">	A(j)=A(j-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">A(i)=n</span><br><span class="line"><span class="comment">!要在数组A(I)插入数值时，必须使用类似上面的方法</span></span><br><span class="line"><span class="comment">!数组A(I)后面的元素必须先一个一个向后移动，再把数值插入A(I)</span></span><br></pre></td></tr></table></figure>
<p>串行结构可以解决这些问题，来看一个最简单的单行串行结构：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef </span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> :: datalink</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1010</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">target</span> :: node1,node2,node3</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    </span><br><span class="line">    node1%i=<span class="number">1</span></span><br><span class="line">    node1%next =&gt; node2</span><br><span class="line">    node2%i=<span class="number">2</span></span><br><span class="line">    node2%next =&gt; node3</span><br><span class="line">    node3%i=<span class="number">3</span></span><br><span class="line">    <span class="built_in">nullify</span>(node3%next)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) node1%i</span><br><span class="line">    <span class="built_in">write</span>(*,*) node1%next%i</span><br><span class="line">    <span class="built_in">write</span>(*,*) node1%next%next%i</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> 2</span><br><span class="line"> 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序在 module typedef 中定义了一个自定义类型 datalink 。这个类型最少占用 8 bytes，因为它里面有一个整数及一个指针。指针 next 还没设置指向谁，是不能使用的。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> :: datalink</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span></span><br></pre></td></tr></table></figure>
<p>读者可能觉得第5行的声明在逻辑上有点奇怪。在这边只要把握一个策略，指针是用来记录内存地址，所以事实上任何类型指针所记录的内容都一样。声明指针时，它的类型只是用来说明指针所记录的内存地址，存放的是什么东西。（这句话是不是所指针的数据类型只是给人看的，电脑并不在乎）</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next</span><br><span class="line"><span class="comment">!在type datalink 声明中，又出现一个 type(datalink)的类型。在这里是合理的，因为变量 next</span></span><br><span class="line"><span class="comment">!是指针，在这儿就不合理。</span></span><br></pre></td></tr></table></figure>
<p>如果 type(datalink) 可以声明成下面的类型，会出现一个问题，那就是这个类型所声明出来的变量 d，所占用的内存空间无法计算。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> :: datalink</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="keyword">type</span>(datalink) :: next <span class="comment">! 错误的声明</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span></span><br></pre></td></tr></table></figure>
<p>如果上面的程序代码是合理的，那变量 d 中可以使用的元素有无限多个，因为按照语法，下面这些变量应该都可以使用。这会导致不管多少内存都不够给变量 d 使用。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">d%i</span><br><span class="line">d%next%i</span><br><span class="line">d%next%next%i</span><br><span class="line">d%next%next%next%i</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>把 next 设置成指针就没有这个问题。因为 next 指针本身并不会记录 type(datalink) 类型的内容，它只记录在内存中哪里有 type(datalink) 类型的数据可以使用。在 next 还没设置方向之前，d%next%i 是不存在的。</p>
<p>程序的第15~20行在从事串行的创建。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">node1%i=<span class="number">1</span></span><br><span class="line">node1%next =&gt; node2</span><br><span class="line">node2%i=<span class="number">2</span></span><br><span class="line">node2%next =&gt; node3</span><br><span class="line">node3%i=<span class="number">3</span></span><br><span class="line"><span class="built_in">nullify</span>(node3%next)</span><br></pre></td></tr></table></figure>
<p>串行创建好了之后，可以出现很有趣的使用方法，来看看程序第22~24行的内容：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">write</span>(*,*) node1%i</span><br><span class="line"><span class="built_in">write</span>(*,*) node1%next%i</span><br><span class="line"><span class="built_in">write</span>(*,*) node1%next%next%i</span><br></pre></td></tr></table></figure>
<p>程序第16行做了 node1%next =&gt; node2 的设置，所以现在可以使用 node1%next, 使用它就等于使用 node2。第23行使用 node1%next%i，就等于在使用 node2%i</p>
<p>……</p>
<p>程序第20行做了 nullify(node3%next)，这个命令会确保 node3%next 不能使用，也就是所 node1%next%next%next 是不能使用的。</p>
<p>用循环来改写这个程序，看起来会更有趣。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef </span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> :: datalink</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1010</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">target</span> :: node1,node2,node3</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: p</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    </span><br><span class="line">    p=&gt;node1</span><br><span class="line">    node1%i=<span class="number">1</span></span><br><span class="line">    node1%next =&gt; node2</span><br><span class="line">    node2%i=<span class="number">2</span></span><br><span class="line">    node2%next =&gt; node3</span><br><span class="line">    node3%i=<span class="number">3</span></span><br><span class="line">    <span class="built_in">nullify</span>(node3%next)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*,*) p%i</span><br><span class="line">        <span class="keyword">if</span>(.not. <span class="built_in">associated</span>(p%next)) <span class="keyword">exit</span></span><br><span class="line">        p =&gt; p%next <span class="comment">! 把p向后移动，从node(n)移到node(n+1)</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>这个程序和改写前的 ex1011.f90 大同小异，只多使用了一个指针 p。另外在输出串行时，改用循环来输出。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">    <span class="built_in">write</span>(*,*) p%i</span><br><span class="line">    <span class="keyword">if</span>(.not. <span class="built_in">associated</span>(p%next)) <span class="keyword">exit</span></span><br><span class="line">    p =&gt; p%next <span class="comment">! 把p向后移动，从node(n)移到node(n+1)</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>来看看这一段程序为什么可以这样做。因为 p 在一开始做了 p=&gt;node1 的设置，所以刚开始进入循环时，使用p等于使用 node1。</p>
<p>循环中会输出 p%i 的内容，再检查 p%next 有没有设置。如果有设置，就重新设置指针 p 的指向，把它指向 p%next 。如果没设置，就离开循环。</p>
<p>事实上，真正的串行是不会使用本程序的方法来创建的，本程序只是用来给读者一个基础的概念。下面的实例程序才是典型的创建串行方法：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> :: datalink</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1012</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: p, head</span><br><span class="line">    <span class="keyword">integer</span> :: i,n,err</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;Input N:&#x27;</span></span><br><span class="line">    read(*,*) n</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">allocate</span>(head)</span><br><span class="line">    head%i = <span class="number">1</span></span><br><span class="line">    <span class="built_in">nullify</span>(head%next)</span><br><span class="line">    </span><br><span class="line">    p=&gt;head</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">2</span>,n</span><br><span class="line">        <span class="built_in">allocate</span>(p%next, stat=err)</span><br><span class="line">        <span class="keyword">if</span>(err /= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&#x27;Out of memory!&#x27;</span></span><br><span class="line">            <span class="keyword">stop</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        p=&gt;p%next</span><br><span class="line">        p%i=i</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">nullify</span>(p%next)</span><br><span class="line">    </span><br><span class="line">    p=&gt;head</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(i5)&quot;</span>) p%i</span><br><span class="line">        <span class="keyword">if</span>(.not. <span class="built_in">associated</span>(p%next)) <span class="keyword">exit</span></span><br><span class="line">        p =&gt; p%next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> Input N:</span><br><span class="line">5</span><br><span class="line">    1</span><br><span class="line">    2</span><br><span class="line">    3</span><br><span class="line">    4</span><br><span class="line">    5</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序把实例 ex1011.f90 中创建串行的过程，由手动一个一个衔接起来，改成使用循环自动生成。用户可以输入任意长度，由循环来生成串行。</p>
<p>第12行中声明的指针 head 会用来作为串行的”头“，也就是串行的第一条数据。指针p则用来当临时保存变量，在串行中移动。</p>
<p>第18行会配置串行中第一行数据的内存空间，第19、20行则会设置第一行数据的内容。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">allocate</span>(head)</span><br><span class="line">head%i = <span class="number">1</span></span><br><span class="line"><span class="built_in">nullify</span>(head%next)</span><br></pre></td></tr></table></figure>
<p>第22~32 行是创建串行的程序代码，进入循环之前，先把指针p指到串行的头。在循环中会一节一节添加出每个串行，再把它接上去。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">p=&gt;head</span><br><span class="line"><span class="keyword">do</span> i=<span class="number">2</span>,n</span><br><span class="line">    <span class="built_in">allocate</span>(p%next, stat=err)</span><br><span class="line">    <span class="keyword">if</span>(err /= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&#x27;Out of memory!&#x27;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    p=&gt;p%next</span><br><span class="line">    p%i=i</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">nullify</span>(p%next) <span class="comment">!出了循环，p就是串行的最后，要设置它后面没东西</span></span><br></pre></td></tr></table></figure>
<h3 id="10-5-2-双向串行、环状串行">10-5-2 双向串行、环状串行</h3>
<p>上一个小节所创建的串行结构，都只能沿着一个方向走。程序只能按照顺序，一条接着一条数据向下读取，没有办法往回走。需要往回走时，要使用双向串行。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> :: datalink</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: prev <span class="comment">!指向上一条数据</span></span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next <span class="comment">!指向下一条数据</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1013</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">target</span> :: node1,node2,node3</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: p</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    </span><br><span class="line">    node1 = datalink(<span class="number">1</span>, null(), node2)</span><br><span class="line">    node2 = datalink(<span class="number">2</span>, node1, node3)</span><br><span class="line">    node3 = datalink(<span class="number">3</span>, node2, null())</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;照顺序输出&quot;</span></span><br><span class="line">    p=&gt;node1</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*,*) p%i</span><br><span class="line">        <span class="keyword">if</span>(.not. <span class="built_in">associated</span>(p%next)) <span class="keyword">exit</span></span><br><span class="line">        p=&gt;p%next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;反过来输出&quot;</span></span><br><span class="line">    p=&gt;node3</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*,*) p%i</span><br><span class="line">        <span class="keyword">if</span>(.not. <span class="built_in">associated</span>(p%prev)) <span class="keyword">exit</span></span><br><span class="line">        p=p%prev</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">照顺序输出</span><br><span class="line">          1</span><br><span class="line">          2</span><br><span class="line">          3</span><br><span class="line">反过来输出</span><br><span class="line">          3</span><br><span class="line">          2</span><br><span class="line">          1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序把前面使用过的自定义类型 datalink 做了一点修改，增加了 prev 这个指针用来指向上一条数据。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> :: datalink</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: prev <span class="comment">!指向上一条数据</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next <span class="comment">!指向下一条数据</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span></span><br></pre></td></tr></table></figure>
<p>创建双向串行的时候，要赋值清楚上一条数据和下一条数据的位置。程序的第17-19行会创建下面的信息。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">node1 = datalink(<span class="number">1</span>, null(), node2)</span><br><span class="line">node2 = datalink(<span class="number">2</span>, node1, node3)</span><br><span class="line">node3 = datalink(<span class="number">3</span>, node2, null())</span><br></pre></td></tr></table></figure>
<p>在这里使用另一种语法来设置数据，程序第17行命令的效果，和下面三行代码相同。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">node1%i = <span class="number">1</span></span><br><span class="line">node1%prev =&gt; null()</span><br><span class="line">node1%next =&gt; node2</span><br></pre></td></tr></table></figure>
<p>这个程序会使用两种方法来输出串行数据，第1种方法和上一节的方法一样。不过这里由于使用了双向串行，既可以从前向后输出，也可以从后向前输出。</p>
<p>这个实例程序使用手动方法创建串行，实际应用时，应该都是使用自动创建串行的方式。</p>
<p>目前为止所介绍的串行结构都是有头有尾的结构，串行结构还有另外一种类型，叫做环状串行。环状串行简单地说，就是把串行的头跟尾接起来，变成一个圈圈。上一个实例程序中，只要把node1%prev 指向 node3, node3%next 指向 node1 就变成了环状串行。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> :: datalink</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: prev <span class="comment">!指向上一条数据</span></span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next <span class="comment">!指向下一条数据</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1014</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">target</span> :: node1,node2,node3</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: p</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: s=<span class="number">6</span></span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    </span><br><span class="line">    node1 = datalink(<span class="number">1</span>, node3, node2)</span><br><span class="line">    node2 = datalink(<span class="number">2</span>, node1, node3)</span><br><span class="line">    node3 = datalink(<span class="number">3</span>, node2, node1)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;照顺序输出&quot;</span></span><br><span class="line">    p=&gt;node1</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,s</span><br><span class="line">        <span class="built_in">write</span>(*,*) p%i</span><br><span class="line">        <span class="keyword">if</span>(.not. <span class="built_in">associated</span>(p%next)) <span class="keyword">exit</span></span><br><span class="line">        p=&gt;p%next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;反过来输出&quot;</span></span><br><span class="line">    p=&gt;node3</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,s</span><br><span class="line">        <span class="built_in">write</span>(*,*) p%i</span><br><span class="line">        <span class="keyword">if</span>(.not. <span class="built_in">associated</span>(p%prev)) <span class="keyword">exit</span></span><br><span class="line">        p=p%prev</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">照顺序输出</span><br><span class="line">          1</span><br><span class="line">          2</span><br><span class="line">          3</span><br><span class="line">          1</span><br><span class="line">          2</span><br><span class="line">          3</span><br><span class="line">反过来输出</span><br><span class="line">          3</span><br><span class="line">          2</span><br><span class="line">          1</span><br><span class="line">          1</span><br><span class="line">          1</span><br><span class="line">          1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>读者可以发现，在环状串行中，可以一直向后或是向前抓取数据，数据永远不会有结束的时候。</p>
<h3 id="10-5-3-插入及删除">10-5-3 插入及删除</h3>
<p>前面两个小节中介绍了创建串行的方法，不过关于串行的操作还有很多内容要学习。学会创建串行之后，还要学习在串行中插入数据及删除数据的方法。</p>
<p>使用串行的好处是，串行可以很快速地插入或删除一条数据。先来看看在数组中如果想在A(n) 中插入数据，要怎么做</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!先把a(n)之后的数据都向后移动一个位置</span></span><br><span class="line"><span class="keyword">do</span> i=size_ofA, n,-<span class="number">1</span></span><br><span class="line">	A(I+<span class="number">1</span>) = A(I)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="comment">!再把需要插入的数值放入A(N)中</span></span><br><span class="line">A(n) = <span class="keyword">value</span></span><br></pre></td></tr></table></figure>
<p>当数组A的大小很大时，循环会执行很久。再来看看如果想把A(n)删除，要怎么做</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!把a(n)之后的数据都向前移动一个位置</span></span><br><span class="line"><span class="keyword">do</span> i=n, size_of_A</span><br><span class="line">	A(i) = A(i+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>想要再数组中插入或删除数据，都非常麻烦，而且数组越大时会越没有效率。在串行中插入或删除数据就没有这个问题，不管这个串行总共有多长，都可以迅速地插入或删除数据。</p>
<p>下面是插入数据的方法：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!添加一条数据来插入</span></span><br><span class="line"><span class="built_in">allocate</span>(item)</span><br><span class="line"><span class="comment">!把item插入到目前串行位置p的后面</span></span><br><span class="line">item%next =&gt; p%next</span><br><span class="line">item%prev =&gt; p</span><br><span class="line">p%next%prev =&gt; item </span><br><span class="line">p%next =&gt; item</span><br></pre></td></tr></table></figure>
<p>下面是删除数据的方法</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!把串行目前位置指针p删除</span></span><br><span class="line">p%prev%next =&gt; p%next</span><br><span class="line">p%next%prev =&gt; p%prev</span><br><span class="line"><span class="built_in">deallocate</span>(p)</span><br></pre></td></tr></table></figure>
<p>下面是一个实际的实例程序，插入数据跟删除数据的程序代码，都独立写成两个函数：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> linklist</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> :: datalink</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: prev <span class="comment">! 指向上一条数据</span></span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next <span class="comment">! 指向下一条数据</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> OutputList(list)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: list,p</span><br><span class="line">    p=&gt;list</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(<span class="built_in">associated</span>(p))</span><br><span class="line">        <span class="built_in">write</span>(*,*) p%i</span><br><span class="line">        p =&gt; p%next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="comment">! 把指针所指到的串行位置释放</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> DelItem(item)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: item</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: prev, next</span><br><span class="line">    </span><br><span class="line">    prev =&gt; item%prev <span class="comment">! 记录item上一条数据的位置</span></span><br><span class="line">    next =&gt; item%next <span class="comment">! 记录item下一条数据的位置</span></span><br><span class="line">    <span class="built_in">deallocate</span>(item) <span class="comment">!释放item所占用内存</span></span><br><span class="line">    <span class="comment">!重新设置prev%next, 原本 prev%next=&gt;item, 不过item已经删除了</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">associated</span>(prev)) prev%next =&gt; next</span><br><span class="line">    <span class="comment">!重新设置next%prev, 原本 next%prev=&gt;item, 不过item已经删除了</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">associated</span>(next)) next%prev =&gt; prev</span><br><span class="line">    item =&gt; next</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="comment">! 在pos指针所指到的串行位置中插入 item</span></span><br><span class="line"><span class="comment">! after=.true. 时，item 插在 pos 之后</span></span><br><span class="line"><span class="comment">! after=.false. 时，item 插在 pos 之前</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> InsItem(pos,item, after)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: pos,item</span><br><span class="line">    <span class="keyword">logical</span> :: after</span><br><span class="line">    <span class="keyword">if</span>(after) <span class="keyword">then</span></span><br><span class="line">        <span class="comment">! item 插在 pos 的后面</span></span><br><span class="line">        item%next =&gt; pos%next</span><br><span class="line">        item%prev =&gt; pos</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">associated</span>(pos%next)) <span class="keyword">then</span></span><br><span class="line">            pos%next%prev =&gt; item</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        pos%prev =&gt; item</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1015</span><br><span class="line">    <span class="keyword">use</span> linklist</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: head</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: item, p</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: s=<span class="number">5</span></span><br><span class="line">    <span class="keyword">integer</span> :: i,n,error</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">allocate</span>(head)</span><br><span class="line">    head = datalink(<span class="number">1</span>, null(), null())</span><br><span class="line">    <span class="comment">!创建串行</span></span><br><span class="line">    p=&gt;head</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">2</span>,s</span><br><span class="line">        <span class="built_in">allocate</span>(p%next, stat=error)</span><br><span class="line">        <span class="keyword">if</span>(error /= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;Out of memory&quot;</span></span><br><span class="line">            <span class="keyword">stop</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        p%next = datalink(i,p,null())</span><br><span class="line">        p=&gt;p%next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;拿掉第3条数据&quot;</span></span><br><span class="line">    <span class="keyword">call</span> DelItem(head%next%next)</span><br><span class="line">    <span class="keyword">call</span> OutputList(head)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;插入新的第3条数据&quot;</span></span><br><span class="line">    <span class="built_in">allocate</span>(item)</span><br><span class="line">    item%i = <span class="number">30</span></span><br><span class="line">    <span class="keyword">call</span> InsItem(head%next, item, .true.)</span><br><span class="line">    <span class="keyword">call</span> OutputList(head)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">拿掉第3条数据</span><br><span class="line">          1</span><br><span class="line">          2</span><br><span class="line">          4</span><br><span class="line">          5</span><br><span class="line">插入新的第3条数据</span><br><span class="line">          1</span><br><span class="line">          2</span><br><span class="line">         30</span><br><span class="line">          4</span><br><span class="line">          5</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序的重点在 delitem 和 insitem 这两个子程序。delitem 用来删除串行中的一条数据，insitem 用来插入一条数据。先来看看如何删除数据：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">subroutine</span></span> DelItem(item)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: item</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: prev, next</span><br><span class="line">    </span><br><span class="line">    prev =&gt; item%prev <span class="comment">! 记录item上一条数据的位置</span></span><br><span class="line">    next =&gt; item%next <span class="comment">! 记录item下一条数据的位置</span></span><br><span class="line">    <span class="built_in">deallocate</span>(item) <span class="comment">!释放item所占用内存</span></span><br><span class="line">    <span class="comment">!重新设置prev%next, 原本 prev%next=&gt;item, 不过item已经删除了</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">associated</span>(prev)) prev%next =&gt; next</span><br><span class="line">    <span class="comment">!重新设置next%prev, 原本 next%prev=&gt;item, 不过item已经删除了</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">associated</span>(next)) next%prev =&gt; prev</span><br><span class="line">    item =&gt; next</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br></pre></td></tr></table></figure>
<p>删除数据时，要先记录一些必要的信息。释放item 指针所使用的内存之前，要把item 前后两条数据连接起来，不能让串行因为删除数据而从中间断掉。</p>
<p>数据删除后，还要重新连接串行。把原本 item 指针的上一条数据中的 next 指向原本在 item 中的下一行数据（第31行），还要把原来 item 的下一条数据中的 prev 指向原来在 item 中的上一条数据（第33行）</p>
<p>在重新链接时，要注意两点：</p>
<ol>
<li>如果要删除的 item 是串行中的第1条数据，那它就不会有上一条数据， prev%next 不存在，不需要重接</li>
<li>如果要删除的 item 是串行中的最后1条数据，那它就不会有下一条数据， next%prev 不存在，不需要重接</li>
</ol>
<p>所以，这里用到了 IF 判断。</p>
<p>再来看看插入数据的子程序 insitem 。它需要3个参数，pos 用来赋值数据要插入串行中的哪一个位置，item 是用来插入的数据，after 用来赋值 item 是要拿来插在指针 pos 的前面还是后面。</p>
<p>这个子程序允许用户把数据插入在赋值前面或是后面，所以插入数据的程序会分成两种情况处理。</p>
<p>先来看把数据插在后面的部分：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">item%next =&gt; pos%next</span><br><span class="line">item%prev =&gt; pos</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">associated</span>(pos%next)) <span class="keyword">then</span></span><br><span class="line">    pos%next%prev =&gt; item</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">pos%next =&gt; item</span><br></pre></td></tr></table></figure>
<p>先把新插入的 item 中的 next 及 prev 指针指好位置，再重新设置 pos 中 next 指针及原来在 pos 后面数据中 prev 指针的位置。这两个指针都要重新指向新插入的item。</p>
<p>另一种情况也类似。</p>
<p>这一节的实例程序示例了使用串行的方法，不过目前为止，经过 allocate 所得到的串行数据，在程序代码中都没有使用 deallocate 函数来释放。实际编写程序时最好不要省略这一步。下面列出一段可以释放整个串行的程序代码，只要把串行开头的指针输入，就可以释放整个串行所使用的内存。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">subroutine</span></span> deletelist(list)</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">	<span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: list, next</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">do</span> <span class="keyword">while</span>(<span class="built_in">associated</span>(list))</span><br><span class="line">		next =&gt; list%next</span><br><span class="line">		<span class="built_in">deallocate</span>(list)</span><br><span class="line">		list =&gt; next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br></pre></td></tr></table></figure>
<p>请记住只有通过 allocate 函数所配置到的内存才要使用 deallocate 来释放。所以用变量所创建出来的串行，就不需要，也不可以使用 deallocate 来释放内存。</p>
<h3 id="10-5-4-串行的应用">10-5-4 串行的应用</h3>
<p>串行比数组好用的地方，在于串行可以比较灵活地使用内存。使用串行时可以不用考虑这个串行需要记录多少条数据，反正串行可以很快速的增减数据。</p>
<p>来看一个读取文件的例子。假如我们事先不确定文件中会有多少数据，就不能使用数组来读取数据，因为不知道数组该声明成多大。一定要使用数组的话，就必须把数组设置成很大、一定够用的数量。这个方法会造成内存的浪费，因为很可能这个数组中，实际只用了很小的一部分。</p>
<p>光盘中 program\chap10\data1. txt 及 data2.txt 是两个班级的段考成绩单，两班的人数不同，请编写一个可以读取成绩的程序，让用户输入文件名来决定读取哪一个文件，还要提供给用户通过座号来查询成绩的功能。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> linklist</span><br><span class="line">    <span class="keyword">type</span> student</span><br><span class="line">        <span class="keyword">integer</span> :: num</span><br><span class="line">        <span class="keyword">integer</span> :: Chinese, English, Math, Science, Social</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">type</span> datalink</span><br><span class="line">        <span class="keyword">type</span>(student) :: item</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: next</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span></span> SearchList(num, head)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: num</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: head, p</span><br><span class="line">        <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: SearchList</span><br><span class="line">        </span><br><span class="line">        p=&gt;head</span><br><span class="line">        <span class="built_in">nullify</span>(SearchList)</span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(<span class="built_in">associated</span>(p))</span><br><span class="line">            <span class="keyword">if</span>(p%item%num==num) <span class="keyword">then</span></span><br><span class="line">                SearchList =&gt; p</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">            p=&gt;p%next</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1016</span><br><span class="line">    <span class="keyword">use</span> linklist</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: filename</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">80</span>) :: tempstr</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: head</span><br><span class="line">    <span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: p</span><br><span class="line">    <span class="keyword">integer</span> i,error,<span class="built_in">size</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;filename: &quot;</span></span><br><span class="line">    read(*,*) filename</span><br><span class="line">    open(<span class="number">10</span>, <span class="keyword">file</span>=filename, <span class="keyword">status</span>=<span class="string">&quot;old&quot;</span>, <span class="keyword">iostat</span>=error)</span><br><span class="line">    <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;Open file fail!&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">allocate</span>(head)</span><br><span class="line">    <span class="built_in">nullify</span>(head%next)</span><br><span class="line">    p=&gt;head</span><br><span class="line">    <span class="built_in">size</span>=<span class="number">0</span></span><br><span class="line">    read(<span class="number">10</span>, <span class="string">&quot;(a80)&quot;</span>) tempstr <span class="comment">!读入第一行字符串，不需要处理它</span></span><br><span class="line">    <span class="comment">! 读入每一位学生的成绩</span></span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        read(<span class="number">10</span>, <span class="keyword">fmt</span>=*, <span class="keyword">iostat</span>=error) p%item</span><br><span class="line">        <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        <span class="built_in">size</span> = <span class="built_in">size</span>+<span class="number">1</span></span><br><span class="line">        <span class="built_in">allocate</span>(p%next, stat=error) <span class="comment">! 添加下一条数据</span></span><br><span class="line">        <span class="keyword">if</span>(error/=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;Out of memory&quot;</span></span><br><span class="line">            <span class="keyword">stop</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        p =&gt; p%next <span class="comment">!移动到串行的下一条数据</span></span><br><span class="line">        <span class="built_in">nullify</span>(p%next)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;总共有&#x27;,i3,&#x27;位学生&#x27;)&quot;</span>) <span class="built_in">size</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;要查询几号同学的成绩？&quot;</span></span><br><span class="line">        read(*,*) i</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">1</span> .or. i&gt;<span class="built_in">size</span>) <span class="keyword">exit</span> <span class="comment">!输入不合理的座号</span></span><br><span class="line">        p =&gt; SearchList(i,head)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">associated</span>(p)) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(5(a6,i3))&quot;</span>) <span class="string">&quot;中文&quot;</span>, p%item%Chinese, &amp;</span><br><span class="line">                                <span class="string">&quot;英文&quot;</span>, p%item%English, &amp;</span><br><span class="line">                                <span class="string">&quot;数学&quot;</span>, p%item%Math, &amp;</span><br><span class="line">                                <span class="string">&quot;自然&quot;</span>, p%item%Science, &amp;</span><br><span class="line">                                <span class="string">&quot;社会&quot;</span>, p%item%Social</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">exit</span> <span class="comment">! 找不到数据，离开循环</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;座号&#x27;,i3,&#x27;不存在，程序结束.&#x27;)&quot;</span>) i</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序使用单向串行来记录学生数据。使用串行的缺点是，不能够很快速地随机使用串行中地第n行数据。串行只适合用来顺序读取数据，不适合做随机读取。函数 SearchList 会根据输入的学生座号，在串行中找出数据的所在位置。</p>
<p>事实上函数 SearchList 可以不需要写得如此麻烦。因为在这里是根据座号来查询成绩，创建串行是，是根据座号一条数据一条数据接起来的。所以第n号学生，也就是串行的第n条数据，在这里可以使用循环来定位出第n条数据的位置。在这个程序中，用下面的 GetN 函数可以做到与 SearchList 相同的效果。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> GetN(num, head)</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">	<span class="keyword">integer</span> :: num</span><br><span class="line">	<span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: head, p</span><br><span class="line">	<span class="keyword">type</span>(datalink), <span class="keyword">pointer</span> :: GetN</span><br><span class="line">	<span class="keyword">integer</span> i</span><br><span class="line">	p =&gt; head</span><br><span class="line">	<span class="keyword">do</span> i=<span class="number">2</span>,num</span><br><span class="line">		p=&gt;head%next</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">	GetN =&gt; p</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br></pre></td></tr></table></figure>
<p>比较好的编写方法，应该是先使用串行来读取文件。读完文件之后，就会指到学生数目，这时候就可以使用另一个可变大小数组来复制串行中的学生成绩。接着再把串行全部删除，查询成绩时直接使用数组来查询就行了。</p>
<h2 id="11-module-及面向对象">11 module 及面向对象</h2>
<p>第8章并没有完全说明 module 的作用，在这一章会详细解释它的功能。</p>
<h2 id="11-1-结构化与面向对象">11-1 结构化与面向对象</h2>
<h3 id="11-1-1-结构化程序设计概念">11-1-1 结构化程序设计概念</h3>
<p>现在的程序语言，都可以算是”结构化“ 程序语言。结构化程序的特点在于”层次分明“， 检查程序代码时，可以把它们分成不同的程序模块。</p>
<p>结构化的程序代码，可以做出 “层次的分析”。在没有遇到循环、流程控制时，程序代码都属于同一个层次；进入循环、流程控制时，程序代码则会归类成下一个层次。相同层次的程序代码，可以把它们视为相同的程序模块。</p>
<p>同一个模块的程序代码，执行顺序都是由上而下，一行行地来进行。遇到循环时，也是以模块为单位来重复执行程序代码。编写程序时，最好把不同层次的程序模块做不同的画面处理，例如每多一个层次，就多使用两个空格来向后错位，这个习惯可以提高程序代码的可读性。（一直在这么做）。结构化的意义，就在于程序代码是由井然有序的模块结构所创建起来的。</p>
<p>读者应该记得之前介绍过一个很有威力的 goto 命令，但是并不建议读者使用它。因为使用 goto 命令的程序，执行时常常会在程序代码中忽前忽后地跳转，这样会很容易破坏程序结构。</p>
<h3 id="11-1-2-面向对象程序设计概论">11-1-2 面向对象程序设计概论</h3>
<p>新一代地程序语言，出了具有原来地结构化程序设计方法外，还加入了“面向对象”概念。简单地说，面向对象是在做程序代码封装地操作。封装过后的程序代码，在使用上会比较安全。</p>
<p>举个例子，上银行领钱时，一定要通过银行的出纳员或是自动提款机的帮忙，才能领出户头里的钱。为了安全理由，银行不可能直接把金库开放，让客户自行取出属于自己的金钱。要是让每个人都自己去金库领钱，那一定会天下大乱。</p>
<p>为了安全起见，每个人到银行领款，一定要通过出纳员或是提款机的服务才能拿到钱。读者可以把出纳员和提款机想象成是银行对外界服务的接口，这个接口隐含了背后的实际工作情况。</p>
<p>面向对象中很重要的一项工作，就是数据封装。数据经过封装之后可以分为两种数据，一种是可以直接让大家使用的数据，另一种是只能在内部使用的数据。函数也可以拿来做封装，分开公开使用和内部使用的函数。以银行的例子来说，银行里的钱，就算是银行的内部数据，不能直接让外人使用，只有银行内部的员工才能直接接触它们。</p>
<p>出了数据封装外，面向对象的另一个重点是程序代码的重复使用。重复使用程序代码最简单的方法，就是使用函数。面向对象提供另外一种思考方法来重复使用程序代码。</p>
<p>有句俗话说：“老鼠生的儿子会打洞”，这里面有遗传的概念，它假设儿女可以继承父母亲所拥有的能力。虽然在现实生活中，继承的现象不一定会发生，不过在编写程序时，程序员可以强迫它发生，使用 module 可以用类似继承的方法来重复使用程序代码。</p>
<p>简单地说，面向对象给程序员两个新的思考方向：</p>
<ol>
<li>为了安全起见，有些数据不应该让外界使用。</li>
<li>经过继承来重复使用程序代码。</li>
</ol>
<h2 id="11-2-再论-module">11-2 再论 module</h2>
<p>module 是 fortran 90 中很重要的一项添加功能，它不单纯只是一个添加的功能，它还带来了很多新的概念，这一节会把 module 的用法做一个总结。</p>
<h3 id="11-2-1-module-的结构及功能">11-2-1 module 的结构及功能</h3>
<p>第8章已经介绍过 module 的部分功能，再来回顾一下这些内容：</p>
<ol>
<li>module 里面可以声明变量，经常用来声明程序中所需要的常量、或是用来存放全局变量。</li>
<li>module 里面可以定义自定义类型，再经过 use 的命令让程序的每一个函数都能使用这个类型。</li>
<li>module 里面可以编写函数，通常会把功能相关的函数放在同一个 module 中。在 module 外面调用这些函数时，同样要使用 use 命令</li>
<li>module 里面的函数，可以直接使用同一个 module 中所声明的变量。所以 module 里面的函数，可以经过 module 里面的变量来互相传递数据。</li>
</ol>
<h3 id="11-2-2-public-private">11-2-2 public, private</h3>
<p>module 里面的数据和函数，可以通过 public 或 private 命令，来区分成公开使用及私下使用，这里用一个实例程序来模拟到银行领钱的例子。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> bank </span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">private</span> money</span><br><span class="line">    <span class="keyword">public</span> LoadMoney, SaveMoney, Report</span><br><span class="line">    <span class="keyword">integer</span> :: money = <span class="number">1000000</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> LoadMoney(num)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: num</span><br><span class="line">        money = money - num</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> SaveMoney(num)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: num</span><br><span class="line">        money = money + num</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Report()</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;银行目前库存&#x27;,i8,&#x27;元&#x27;)&quot;</span>) money</span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1101</span><br><span class="line">    <span class="keyword">use</span> bank</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">call</span> LoadMoney(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">call</span> SaveMoney(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">call</span> Report()</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">银行目前库存 1000900元</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序执行结果并不重要，这个程序的重点在于 module bank 中把 money 变量限制为私下使用。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> money</span><br></pre></td></tr></table></figure>
<p><strong>经过这个声明，变量 money 只能在 module bank 中使用，所以主程序中不能使用 money 变量。</strong></p>
<p>除了变量，函数也可以经过 private 或 public 来定义它是否能对外公开。 程序第4行定义了几个可以对外界公开使用的接口：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> LoadMoney, SaveMoney, Report</span><br></pre></td></tr></table></figure>
<p>没有特别经过 private 或 public 来赋值时，<strong>默认的状态为 public</strong>。</p>
<p>变量 money 代表银行中目前的库存现金数量。只有银行的出纳员才能直接动用这些现金，所以变量 money 定义为 private 的状态。读者如果试着在主程序中去使用变量 money ，编译时会发生错误。如果外界可以直接使用变量 money ，很可能会发生 “抢银行” 的事件。</p>
<p>上一个实例不太实用，函数 LoadMoney 和 SaveMoney 只是单纯地重新计算银行的库存现金。实际上在提款和存款时，银行一定都会留下记录，下面是比较完整的实例程序。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> bank </span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: money = <span class="number">1000000</span></span><br><span class="line">    <span class="keyword">integer</span> :: fileid = <span class="number">10</span></span><br><span class="line">    <span class="keyword">private</span> money, fileid <span class="comment">! 这两个变量不对外公开</span></span><br><span class="line">    <span class="keyword">private</span> TimeLog <span class="comment">!这个函数不对外公开</span></span><br><span class="line">    <span class="comment">! public LoadMoney, SaveMoney, Report</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> TimeLog() <span class="comment">! 在log 文件中写入现在的时间</span></span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: num</span><br><span class="line">        <span class="keyword">character</span>(len=<span class="number">20</span>) :: date, time</span><br><span class="line">        <span class="keyword">call</span> <span class="built_in">Date_And_Time</span>(date,time)</span><br><span class="line">        <span class="built_in">write</span>(fileid, <span class="string">&quot;(&#x27;Date:&#x27;,a8,&#x27; Time:&#x27;,a2,&#x27;:&#x27;,a2,&#x27;:&#x27;,a2)&quot;</span>) &amp;</span><br><span class="line">            date, time(<span class="number">1</span>:<span class="number">2</span>), time(<span class="number">3</span>:<span class="number">4</span>), time(<span class="number">5</span>:<span class="number">6</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> LoadMoney(<span class="keyword">name</span>,num)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">character</span>(len=*) :: <span class="keyword">name</span></span><br><span class="line">        <span class="keyword">integer</span> :: num</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(num&lt;=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;不合理的金额&quot;</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        </span><br><span class="line">        open(fileid, <span class="keyword">file</span>=<span class="string">&quot;log.txt&quot;</span>, <span class="keyword">position</span> = <span class="string">&quot;append&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span>(money &gt;= num) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">call</span> TimeLog() <span class="comment">! 写下时间</span></span><br><span class="line">            <span class="built_in">write</span>(fileid, <span class="string">&quot;(a10, &#x27; 领取&#x27;,i5,&#x27;元&#x27;)&quot;</span>) <span class="keyword">name</span>, num <span class="comment">!提款记录</span></span><br><span class="line">            money = money - num</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">write</span>(fileid, *) <span class="string">&quot;银行目前现金不足&quot;</span></span><br><span class="line">            <span class="built_in">write</span>(*, *) <span class="string">&quot;银行目前现金不足&quot;</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        close(fileid)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> SaveMoney(<span class="keyword">name</span>,num)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">character</span>(len=*) :: <span class="keyword">name</span></span><br><span class="line">        <span class="keyword">integer</span> :: num</span><br><span class="line">        <span class="keyword">if</span>(num&lt;=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;不合理的金额&quot;</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        open(fileid, <span class="keyword">file</span>=<span class="string">&quot;log.txt&quot;</span>, <span class="keyword">position</span>=<span class="string">&quot;append&quot;</span>)</span><br><span class="line">        <span class="keyword">call</span> TimeLog() <span class="comment">! 写下时间</span></span><br><span class="line">        <span class="built_in">write</span>(fileid, <span class="string">&quot;(a10,&#x27; 存入&#x27;,i5,&#x27;元&#x27;)&quot;</span>) <span class="keyword">name</span>, num <span class="comment">! 存款记录</span></span><br><span class="line">        close(fileid)</span><br><span class="line">        money = money + num</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1102</span><br><span class="line">    <span class="keyword">use</span> bank</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">call</span> LoadMoney(<span class="string">&quot;彭先生&quot;</span>,<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">call</span> SaveMoney(<span class="string">&quot;陈先生&quot;</span>,<span class="number">1000</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行后生成 log.txt 文件，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Date:20210310 Time:10:35:56</span><br><span class="line"> 彭先生 领取  100元</span><br><span class="line">Date:20210310 Time:10:35:56</span><br><span class="line"> 陈先生 存入 1000元</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序把原本很不实用的 module bank 做了很多修改，像调用 LoadMoney 来进行提款之前，会判断提款金额是否合理，还会判断银行是否有足够的库存现金来支付。调用 SaveMoney 来进行存款前，会先判断存款金额是否合理。最重要的是在调用 LoadMoney 及 SaveMoney 来提款或存款时，都会在文件 log.txt 中留下记录。</p>
<p>程序中已经调用 Fortran 90 的库存函数 date_and_time，这个函数会用字符串来返回目前的日期和时间。</p>
<p>这个实例程序的 LoadMoney 函数比上一个版本合理，因为它不再只是单纯地重新设置变量 money 的值，他会检查变量 money 的数值，不让 money 变成负值。面向对象中，经过使用接口来操作内部数据，主要时为了避免不正常使用数据，并减少错误发生的机会。</p>
<p>private 和 public 命令也可以通过下面的方法来使用：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="comment">!定义这个module中，没有特别赋值的东西都不对外公开</span></span><br><span class="line"><span class="keyword">public</span> c <span class="comment">!定义变量c可以对外公开</span></span><br></pre></td></tr></table></figure>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="comment">!定义这个module中，没有特别赋值的东西都对外公开</span></span><br><span class="line"><span class="keyword">private</span> c <span class="comment">!定义变量c不对外公开</span></span><br></pre></td></tr></table></figure>
<h3 id="11-2-3-use">11-2-3 use</h3>
<p>第8章已经介绍过 use 命令的使用，编写好 module 之后，要使用 use 命令才能让 module 外的函数使用 module 里面的东西。在 module 中也可以使用另外一个 module。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> A</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">	<span class="keyword">integer</span> :: a,b</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> B</span><br><span class="line">	<span class="keyword">use</span> A <span class="comment">! module中可以使用另外一个 module</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub()</span><br><span class="line">	<span class="keyword">use</span> B <span class="comment">! 函数中要经过 use 才能使用编写好的 module</span></span><br><span class="line">	……</span><br></pre></td></tr></table></figure>
<p>使用 module 的数量并没有限制，可以同时使用好几个 module，只要多写几个 use 就行了。同时使用多个 module 时，可能会遇到变量名称或是函数名称重复的问题。use 命令后面，可以临时把 module 里面的变量或函数名称改名。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> A</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">	<span class="keyword">integer</span> va</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> B</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">	<span class="keyword">integer</span> va</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">	<span class="keyword">use</span> A, aa=&gt;va <span class="comment">!把 module A 的变量va改名为aa来使用</span></span><br><span class="line">	<span class="keyword">use</span> B</span><br><span class="line">	……</span><br></pre></td></tr></table></figure>
<p>上面的例子中，module A 和 module B 都同时拥有名称为 va 的变量。在主程序中同时使用这两个 module 时，会出现呢变量名称重复的问题。所以在主程序中必须临时把 module A 中的变量 va 改成另外一个名字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use A, aa&#x3D;&gt;va !把 module A 的变量va改名为aa来使用</span><br></pre></td></tr></table></figure>
<p>改名是解决名称重复的方法，而如果两个 module 中重复的名称太多时，把每个名字都改掉也很麻烦。如果不需要用到两个 module 中的所有东西，可以只选择 module 里某一些东西来使用。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> A, <span class="keyword">only</span> : vc <span class="comment">! 只用 module A 中的变量 vc</span></span><br></pre></td></tr></table></figure>
<p>使用 only 时，同时也可以做临时改名的操作。和前面一样，只要再加上符合 “=&gt;“ 就行了。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> A, <span class="keyword">only</span> : c =&gt; vc <span class="comment">! 只用 module A 中的变量 vc, 并改名为c</span></span><br></pre></td></tr></table></figure>
<p>在 module A 中使用 module B，可以想象是 module A 继承了 module B 的数据和函数。<strong>不过继承的东西只限制在 module B 中对外公开的变量及函数，module B 所私下使用的东西不会被继承。</strong></p>
<p>来看一个例子</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> MA</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> a,b</span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> getx()</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;x=&#x27;,f5.2)&quot;</span>) -b/a</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> MB</span><br><span class="line">    <span class="keyword">use</span> MA</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> c</span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> getx2()</span><br><span class="line">        <span class="keyword">real</span> a2, d, sqrt_d</span><br><span class="line">        a2 = <span class="number">2</span>*a</span><br><span class="line">        d = b*b-<span class="number">4</span>*a*c</span><br><span class="line">        <span class="keyword">if</span>(d&gt;=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            sqrt_d = <span class="built_in">sqrt</span>(d)</span><br><span class="line">            <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;x=&#x27;,f5.2,&#x27;,&#x27;,f5.2)&quot;</span>) (-b+sqrt_d)/a2, (-b-sqrt_d)/a2</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;无实数解&quot;</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub1()</span><br><span class="line">    <span class="keyword">use</span> MA</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    a = <span class="number">2.0</span></span><br><span class="line">    b = <span class="number">3.0</span></span><br><span class="line">    <span class="keyword">call</span> getx()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> sub2()</span><br><span class="line">    <span class="keyword">use</span> MB</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    a = <span class="number">1.0</span></span><br><span class="line">    b = <span class="number">4.0</span></span><br><span class="line">    c = <span class="number">4.0</span></span><br><span class="line">    <span class="keyword">call</span> getx2()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">call</span> sub1()</span><br><span class="line">    <span class="keyword">call</span> sub2()</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x&#x3D;-1.50</span><br><span class="line">x&#x3D;-2.00,-2.00</span><br></pre></td></tr></table></figure>
<p>这个程序中的 module MA 可以用来解 ax+b=0 的 x值，module MB 则可以用来解 ax+b=0 的 x 值及 ax^2^ + bx + c=0 的 x 值。module MB 中只实现了第2部分的功能，第1部分的功能是从 module MA 中继承来的。</p>
<p>不过有一个地方需要特别介绍一下，程序的第22行使用<code>(-b±sqrt(b^2-4ac))/2a</code> 这个公式来计算两个解。</p>
<p>为了避免重复不必要的计算，程序先把 2a 和 sqrt(b^2-4ac) 的计算结果保存至变量 a2 和 sqrt_d 中，计算 x 值则用下面两个式子来做计算：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">x0 = (-b+sqrt_d)/a2</span><br><span class="line">x1 = (-b-sqrt_d)/a2</span><br></pre></td></tr></table></figure>
<p>如果不事先计算 2a 和 sqrt(b^2-4ac)  的结果，计算 x 值时需要用下面这两个算式来计算：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">x0 = (-b+<span class="built_in">sqrt</span>(b*b-<span class="number">4</span>*a*c))/(<span class="number">2</span>*a)</span><br><span class="line">x1 = (-b-<span class="built_in">sqrt</span>(b*b-<span class="number">4</span>*a*c))/(<span class="number">2</span>*a)</span><br></pre></td></tr></table></figure>
<p>第2个方法效率比较差，因为这两个算式会重复计算  2a 和 sqrt(b^2-4ac)   的值。在大程序中，这种多余的计算会明显地影响执行效率。</p>
<blockquote>
<p>我不太懂这里的意思，在目前这个程序中，x0 x1均只计算一次，所以 2a 和 sqrt(b^2-4ac) 这两个值事先计算还是放在公式里，都是只算一次啊，哪来的重复计算影响效率。</p>
<p>估计是作者说错了，除非这里用到了循环，事先计算才能提高效率。</p>
</blockquote>
<p>这个实例程序中，module MB 里面使用 getx2 来计算 ax^2^ + bx + c = 0 的 x 值。封装成链接库时，用户要记得 getx 和 getx2 的差别。如果能把所有的名称都统一成 getx 也许会是一个好方法。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> MB</span><br><span class="line">    <span class="keyword">use</span> MA, getx1 =&gt; getx <span class="comment">!MA中的 getx 改为 getx1</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> c</span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> getx() <span class="comment">!MB 中的 getx2 改为 getx</span></span><br><span class="line">        <span class="keyword">real</span> a2, d, sqrt_d</span><br><span class="line">        a2 = <span class="number">2</span>*a</span><br><span class="line">        d = b*b-<span class="number">4</span>*a*c</span><br><span class="line">        <span class="keyword">if</span>(d&gt;=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            sqrt_d = <span class="built_in">sqrt</span>(d)</span><br><span class="line">            <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;x=&#x27;,f5.2,&#x27;,&#x27;,f5.2)&quot;</span>) (-b+sqrt_d)/a2, (-b-sqrt_d)/a2</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;无实数解&quot;</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br></pre></td></tr></table></figure>
<p>把 module MB 经过上面的方法来改写后，使用 module MB 时，可以经过 getx 函数来计算 ax^2^ + bx + c = 0 的 x 值，因为在 module MB 中，继承来的 getx 函数被改名成 getx1，所以可以在 module MB 中显示新的 getx。不过要计算 ax+b=0时，变成要调用 getx1，所以这个方法并不能算是很好的方法，下一节会介绍一个更好的解决方法。</p>
<h2 id="11-3-再论-interface">11-3 再论 interface</h2>
<p>在第8章中，interface 是用来说明函数的参数及返回值类型。不过<strong>当函数封装在 module 里面时，就不需要再使用 interface 来做这些说明</strong>。事实上 interface 的功能不只是这些，它还有其他很强大的功能可以使用。</p>
<h3 id="11-3-1-同名函数的重载（overload）">11-3-1 同名函数的重载（overload）</h3>
<p>overload 的意义是：”在程序代码中可以同时拥有多个名称相同，但是参数类型、数目不同的函数，程序会自动根据输入的参数，来决定要调用哪一个函数“。</p>
<p>Fortran 90 编写函数重载的方法和C++不太一样，在module中使用 interface，可以用来定义一个虚拟的函数名称，来看下面的实例：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> MA</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">interface</span> show <span class="comment">! 虚拟的函数名称 show</span></span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> show_int <span class="comment">!等待选择的函数show_int</span></span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> show_character <span class="comment">!等待选择的函数show_character</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> show_int(n)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span>, <span class="keyword">intent</span>(<span class="keyword">in</span>) :: n</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;n=&#x27;,i3)&quot;</span>) n</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> show_character(str)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">character</span>(len=*), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: str</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;str=&#x27;,a)&quot;</span>) str</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> MA</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">call</span> show_int(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">! 输入的参数是整数，会自动选择调用 show_int</span></span><br><span class="line">    <span class="keyword">call</span> show(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">call</span> show_character(<span class="string">&quot;Fortran 95&quot;</span>)</span><br><span class="line">    <span class="comment">! 输入的参数是字符串，会自动选择调用 show_character</span></span><br><span class="line">    <span class="keyword">call</span> show(<span class="string">&quot;Fortran 95&quot;</span>)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n&#x3D;  1</span><br><span class="line">n&#x3D;  1</span><br><span class="line">str&#x3D;Fortran 95</span><br><span class="line">str&#x3D;Fortran 95</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个实例程序的第4~7行，在 module MA 中使用 interface 定义出虚拟的函数 show。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> show <span class="comment">! 虚拟的函数名称 show</span></span><br><span class="line">    <span class="keyword">module</span> <span class="keyword">procedure</span> show_int <span class="comment">!等待选择的函数show_int</span></span><br><span class="line">    <span class="keyword">module</span> <span class="keyword">procedure</span> show_character <span class="comment">!等待选择的函数show_character</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">interface</span></span><br></pre></td></tr></table></figure>
<p>在 interface show 中，定义的两个函数可以被冒名顶替。在程序进行中调用 show 时，实际上会从这两个函数中挑出一个出来执行，挑选的根据在于调用 show 时所输入的参数。输入一个整数时，会调用 show_int ；输入一个字符串时，会调用 show_character。</p>
<p>因此我们可以改写一下之前计算 ax+b=0 ; ax^2^ + bx +c =0 的程序</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> MA</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">interface</span> getx</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> getx1</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> getx2</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> getx1(a,b)</span><br><span class="line">        <span class="keyword">real</span> a,b</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;x=&#x27;,f5.2)&quot;</span>) -b/a</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> getx2(a,b,c)</span><br><span class="line">        <span class="keyword">real</span> a, b, c</span><br><span class="line">        <span class="keyword">real</span> a2, d, sqrt_d</span><br><span class="line">        a2 = <span class="number">2</span>*a</span><br><span class="line">        d = b*b-<span class="number">4</span>*a*c</span><br><span class="line">        <span class="keyword">if</span>(d&gt;=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            sqrt_d = <span class="built_in">sqrt</span>(d)</span><br><span class="line">            <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;x=&#x27;,f5.2,&#x27;,&#x27;,f5.2)&quot;</span>) (-b+sqrt_d)/a2, (-b-sqrt_d)/a2</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;无实数解&quot;</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> MA</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">call</span> getx(<span class="number">1.0</span>,<span class="number">2.0</span>) <span class="comment">!实际上会调用 getx1</span></span><br><span class="line">    <span class="keyword">call</span> getx(<span class="number">1.0</span>,<span class="number">3.0</span>,<span class="number">2.0</span>) <span class="comment">!实际上会调用 getx2</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x&#x3D;-2.00</span><br><span class="line">x&#x3D;-1.00,-2.00</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序统一调用 getx ，通过参数个数来判断调用哪个函数。</p>
<h3 id="11-3-2-自定义操作符">11-3-2 自定义操作符</h3>
<p>Fortran 基本数值的数据类型，主要有 integer, real 这两种。使用这两种类型所声明出来的变量，除了可以用来保存数值外，还可以拿来做+,-,*,/ 数学计算及 &lt;, &lt;=, &gt;, &gt;=, ==, /= 等等的逻辑判断。而使用 type 所声明的自定义类型，默认时不能拿来做这些运算。不过通过 interface 的帮忙，可以虚拟出上述的运算符号。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> operator(+)</span><br><span class="line">	<span class="comment">!在程序代码中，使用a+b时，若a和b的参数符合下面任何函数中的</span></span><br><span class="line">	<span class="comment">!两个参数类型，会调用其中一个函数来执行</span></span><br><span class="line">	<span class="keyword">module</span> <span class="keyword">procedure</span> add1</span><br><span class="line">	<span class="keyword">module</span> <span class="keyword">procedure</span> add2</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">interface</span></span><br></pre></td></tr></table></figure>
<p>来看一个简单的例子：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> MA</span><br><span class="line">	<span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">	<span class="keyword">type</span> ta</span><br><span class="line">		<span class="keyword">integer</span> a</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line">    <span class="keyword">interface</span> operator(+) <span class="comment">!这个interface让 type(ta) 类型变量也能相加</span></span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> add</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> add(a,b)</span><br><span class="line">        <span class="keyword">type</span>(ta), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: a,b</span><br><span class="line">        add = a%a+b%a</span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1106</span><br><span class="line">    <span class="keyword">use</span> MA</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(ta) :: a,b</span><br><span class="line">    <span class="keyword">integer</span> :: c</span><br><span class="line">    a%a = <span class="number">1</span></span><br><span class="line">    b%a = <span class="number">2</span></span><br><span class="line">    c = a+b <span class="comment">!会调用add(a,b)来执行</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) c</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<p>这正是 a%a + b%b 的结果。这个程序主要是用来示例自定义操作符的方法，在module MA中定义了一个特别的 interface，它把加法 ”+“ 符号也拿来当成虚拟函数的名称。所以主程序中出现加法时，如果相加的两个变量都是 type(ta) 类型，会自动转换成调用函数 add 来执行。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> operator(+) <span class="comment">!这个interface让 type(ta) 类型变量也能相加</span></span><br><span class="line">    <span class="keyword">module</span> <span class="keyword">procedure</span> add</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">interface</span></span><br></pre></td></tr></table></figure>
<p>请注意，要把运算符号拿来当成虚拟函数名称时， interface 后面要先接上 operator 这个字，再用括号把运算符号括起来。另外在 interface 中等待候选的函数，必须明确显示每一个参数属性 intent。</p>
<p>来看一个比较实用的实例：黄先生在这个月的5日 及 20日分别和许律师约谈了1个小时45分，2小时18分。请问黄先生这个月花了多少时间和他的律师讨论有关他的遗产分配问题？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module time_util</span><br><span class="line">    implicit none</span><br><span class="line">    type :: time</span><br><span class="line">        integer :: hour, minute</span><br><span class="line">    end type time</span><br><span class="line">    interface operator(+) ! 让type(time)类型变量能够相加</span><br><span class="line">        module procedure add</span><br><span class="line">    end interface</span><br><span class="line">    </span><br><span class="line">contains</span><br><span class="line">    function add(a,b)</span><br><span class="line">        implicit none</span><br><span class="line">        type(time),intent(in) :: a,b</span><br><span class="line">        type(time) :: add</span><br><span class="line">        integer :: minutes, carry</span><br><span class="line">        minutes &#x3D; a%minute + b%minute</span><br><span class="line">        carry &#x3D; minutes&#x2F;60</span><br><span class="line">        add%minute &#x3D; mod(minutes,60) !取余数</span><br><span class="line">        add%hour &#x3D; a%hour + b%hour + carry</span><br><span class="line">        return</span><br><span class="line">    end function</span><br><span class="line">    </span><br><span class="line">    subroutine output(t)</span><br><span class="line">        type(time), intent(in) :: t</span><br><span class="line">        write(*, &quot;(i2,&#39;:&#39;,i2.2)&quot;) t%hour, t%minute</span><br><span class="line">        return</span><br><span class="line">    end subroutine</span><br><span class="line"></span><br><span class="line">end module</span><br><span class="line"></span><br><span class="line">program ex1107</span><br><span class="line">    use time_util</span><br><span class="line">    implicit none</span><br><span class="line">    type(time) :: a,b,c</span><br><span class="line">    a &#x3D; time(1,45)</span><br><span class="line">    b &#x3D; time(2,18)</span><br><span class="line">    c&#x3D;a+b !实际上会调用函数add(a,b)</span><br><span class="line">    call output(c)</span><br><span class="line">    </span><br><span class="line">    stop</span><br><span class="line">end program</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>程序执行后会计算出1小时45分加上2小时18分的时间长度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4:03</span><br></pre></td></tr></table></figure>
<p>这里的 interface 里面，只有一个”候选“的函数。在这里的候选函数只能是函数，不能是子程序。因为数学计算 a+b 一定要返回一个结果。在主程序中执行 c = a+b 时，实际上执行的是 c=add(a,b) 。经过 interface 的封装，可以让程序代码中使用直观的运算符号来调用这个函数。</p>
<p>使用 interface operator() 来自定义操作符时，还有一点很有趣，程序员可以任意制作出 Fortran 标准中不存在的操作符。</p>
<p>例如在制作”向量类型“时，可能会需要用到 dot，不过Fortran 中并没有 dot 这个操作符，但是可以使用 interface operator(.dot.) 来创造这个操作符。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">a = b .dot. c <span class="comment">!新定义的操作符 dot</span></span><br></pre></td></tr></table></figure>
<p>最后再来看一个比较完整的实例程序，上一个实例程序只定义了 type(time) 类型变量的加法。下面的实例程序会定义出 type(time)+real, real +type(time), 小于的判断及两种等号 type(time)=real, real=type(time) 操作。</p>
<p>代码略。</p>
<p>这里一个加法有三种不同的函数，之所以可行是因为这三种函数的参数的类型不同。如果存在参数个数和类型均相同的两个函数，这里估计会报错。</p>
<h2 id="11-4-实际应用">11-4 实际应用</h2>
<p>这一节会实际示范继承 module 来增强功能的方法，以及比较完整的自定义类型运算。</p>
<h3 id="11-4-1-继承module">11-4-1 继承module</h3>
<h3 id="11-4-2-自定义操作符的应用">11-4-2 自定义操作符的应用</h3>
<p>Fortran 中并没有提供”分数“类型，不过在现实世界中，常常会使用这个类型。分数可以保存更为精确的数值，例如 2/3。因为2/3转换成实数后，会变成循环小数，小数的位数高达无限多个。使用浮点数来记录2/3时，因为有效位数的限制，没有办法正确保存循环小数的值。</p>
<p>下面这个程序实现了分数和分数间的加减乘除。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> rational_util</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span></span><br><span class="line">    <span class="keyword">public</span> :: rational, &amp;</span><br><span class="line">            operator(+),operator(-),operator(*),&amp;</span><br><span class="line">            operator(/),assignment(=),&amp;</span><br><span class="line">            output</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">type</span> :: rational</span><br><span class="line">        <span class="keyword">integer</span> :: num <span class="comment">! 分子</span></span><br><span class="line">        <span class="keyword">integer</span> :: denum <span class="comment">! 分母</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 加法</span></span><br><span class="line">    <span class="keyword">interface</span> operator(+)</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> rat_plus_rat</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    <span class="comment">! 减法</span></span><br><span class="line">    <span class="keyword">interface</span> operator(-)</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> rat_minus_rat</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    <span class="comment">! 乘法</span></span><br><span class="line">    <span class="keyword">interface</span> operator(*)</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> rat_times_rat</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    <span class="comment">! 除法</span></span><br><span class="line">    <span class="keyword">interface</span> operator(/)</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> rat_div_rat</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line">    <span class="comment">! 等号</span></span><br><span class="line">    <span class="keyword">interface</span> assignment(=)</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> int_eq_rat</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> real_eq_rat</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">!整数=分数</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> int_eq_rat(<span class="built_in">int</span>, rat)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span>, <span class="keyword">intent</span>(<span class="keyword">out</span>) :: <span class="built_in">int</span></span><br><span class="line">        <span class="keyword">type</span>(rational), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: rat</span><br><span class="line">        <span class="comment">!分子除以分母来转换成整数</span></span><br><span class="line">        <span class="built_in">int</span> = rat%num / rat%denum</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!浮点数=分数</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> real_eq_rat(<span class="built_in">float</span>, rat)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">intent</span>(<span class="keyword">out</span>) :: <span class="built_in">float</span></span><br><span class="line">        <span class="keyword">type</span>(rational), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: rat</span><br><span class="line">        <span class="comment">!分子除以分母</span></span><br><span class="line">        <span class="built_in">float</span> = <span class="keyword">real</span>(rat%num) / <span class="keyword">real</span>(rat%denum) <span class="comment">!分子分母先转化为实数类型</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!化简分数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span></span> reduse(a)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(rational), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: a</span><br><span class="line">        <span class="keyword">type</span>(rational) :: temp</span><br><span class="line">        <span class="keyword">integer</span> :: b</span><br><span class="line">        <span class="keyword">integer</span> :: <span class="built_in">sign</span></span><br><span class="line">        <span class="keyword">type</span>(rational) :: reduse</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a%num*a%denum &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">sign</span> = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">sign</span> = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        </span><br><span class="line">        temp%num = <span class="built_in">abs</span>(a%num)</span><br><span class="line">        temp%denum = <span class="built_in">abs</span>(a%denum)</span><br><span class="line">        b=gcv(temp%num, temp%denum) <span class="comment">!找出分子与分母的最大公因子</span></span><br><span class="line">        <span class="comment">!把分子，分母同时除以最大公因子</span></span><br><span class="line">        reduse%num = temp%num / b * <span class="built_in">sign</span></span><br><span class="line">        reduse%denum = temp%denum / b</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="comment">!用辗转相除法找最大公因子</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span></span> gcv(a,b)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span>, <span class="keyword">intent</span>(<span class="keyword">in</span>) :: a,b</span><br><span class="line">        <span class="keyword">integer</span> :: big,small</span><br><span class="line">        <span class="keyword">integer</span> :: temp</span><br><span class="line">        <span class="keyword">integer</span> :: gcv</span><br><span class="line">        </span><br><span class="line">        big = <span class="built_in">max</span>(a,b)</span><br><span class="line">        small = <span class="built_in">min</span>(a,b)</span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(small&gt;<span class="number">1</span>)</span><br><span class="line">            temp=<span class="built_in">mod</span>(big,small)</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">            big = small</span><br><span class="line">            small = temp</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">        gcv = small</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span> gcv</span><br><span class="line">   </span><br><span class="line">    <span class="comment">!分数相加</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span></span> rat_plus_rat(rat1,rat2)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(rational) :: rat_plus_rat</span><br><span class="line">        <span class="keyword">type</span>(rational), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: rat1, rat2</span><br><span class="line">        <span class="keyword">type</span>(rational) :: act</span><br><span class="line">        <span class="comment">! b/a+d/c=(b*c+d*a)/(a*c)</span></span><br><span class="line">        act%denum = rat1%denum * rat2%denum <span class="comment">!a*c</span></span><br><span class="line">        act%num = rat1%num*rat2%denum + rat2%num*rat1%denum <span class="comment">!(b*c+d*a)</span></span><br><span class="line">        rat_plus_rat = reduse(act) <span class="comment">!约分</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="comment">!分数相减</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span></span> rat_minus_rat(rat1,rat2)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(rational) :: rat_minus_rat</span><br><span class="line">        <span class="keyword">type</span>(rational), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: rat1, rat2</span><br><span class="line">        <span class="keyword">type</span>(rational) :: act</span><br><span class="line">        <span class="comment">! b/a-d/c=(b*c-d*a)/(a*c)</span></span><br><span class="line">        act%denum = rat1%denum * rat2%denum <span class="comment">!a*c</span></span><br><span class="line">        act%num = rat1%num*rat2%denum - rat2%num*rat1%denum <span class="comment">!(b*c-d*a)</span></span><br><span class="line">        rat_minus_rat = reduse(act) <span class="comment">!约分</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="comment">!分数相乘</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span></span> rat_times_rat(rat1,rat2)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(rational) :: rat_times_rat</span><br><span class="line">        <span class="keyword">type</span>(rational), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: rat1, rat2</span><br><span class="line">        <span class="keyword">type</span>(rational) :: act</span><br><span class="line">        <span class="comment">! b/a*d/c=(b*d)/(a*c)</span></span><br><span class="line">        act%denum = rat1%denum * rat2%denum <span class="comment">!a*c</span></span><br><span class="line">        act%num = rat1%num*rat2%num <span class="comment">!b*d</span></span><br><span class="line">        rat_times_rat = reduse(act) <span class="comment">!约分</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="comment">!分数相除</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span></span> rat_div_rat(rat1,rat2)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(rational) :: rat_div_rat</span><br><span class="line">        <span class="keyword">type</span>(rational), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: rat1, rat2</span><br><span class="line">        <span class="keyword">type</span>(rational) :: act</span><br><span class="line">        <span class="comment">! (b/a) / (d/c)=(b*c)/(a*d)</span></span><br><span class="line">        act%denum = rat1%denum * rat2%num <span class="comment">!a*d</span></span><br><span class="line">        act%num = rat1%num*rat2%denum <span class="comment">!b*c</span></span><br><span class="line">        rat_div_rat = reduse(act) <span class="comment">!约分</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="comment">!输出</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> output(a)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(rational), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: a</span><br><span class="line">        <span class="keyword">if</span>(a%denum /= <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(1x,&#x27;(&#x27;,i3,&#x27;/&#x27;,i3,&#x27;)&#x27;)&quot;</span>) a%num, a%denum</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(1x,i3)&quot;</span>) a%num</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!主程序</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> ex1110</span><br><span class="line">    <span class="keyword">use</span> rational_util</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span>(rational) :: a,b,c</span><br><span class="line">    <span class="keyword">real</span> :: f</span><br><span class="line">    </span><br><span class="line">    a=rational(<span class="number">1.0</span>,<span class="number">3.0</span>)</span><br><span class="line">    b=rational(<span class="number">2.0</span>,<span class="number">3.0</span>)</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a4)&quot;</span>,<span class="keyword">advance</span>=<span class="string">&quot;no&quot;</span>) <span class="string">&#x27;a=&#x27;</span></span><br><span class="line">    <span class="keyword">call</span> output(a)</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a4)&quot;</span>,<span class="keyword">advance</span>=<span class="string">&quot;no&quot;</span>) <span class="string">&#x27;b=&#x27;</span></span><br><span class="line">    <span class="keyword">call</span> output(b)</span><br><span class="line">    c=a+b</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a4)&quot;</span>,<span class="keyword">advance</span>=<span class="string">&quot;no&quot;</span>) <span class="string">&#x27;a+b=&#x27;</span></span><br><span class="line">    <span class="keyword">call</span> output(c)</span><br><span class="line">    c=a-b</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a4)&quot;</span>,<span class="keyword">advance</span>=<span class="string">&quot;no&quot;</span>) <span class="string">&#x27;a-b=&#x27;</span></span><br><span class="line">    <span class="keyword">call</span> output(c)</span><br><span class="line">    c=a*b</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a4)&quot;</span>,<span class="keyword">advance</span>=<span class="string">&quot;no&quot;</span>) <span class="string">&#x27;a*b=&#x27;</span></span><br><span class="line">    <span class="keyword">call</span> output(c)</span><br><span class="line">    c=a/b</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a4)&quot;</span>,<span class="keyword">advance</span>=<span class="string">&quot;no&quot;</span>) <span class="string">&#x27;a/b=&#x27;</span></span><br><span class="line">    <span class="keyword">call</span> output(c)</span><br><span class="line">    f=c</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(f6.2)&quot;</span>) f</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  a&#x3D; (  1&#x2F;  3)</span><br><span class="line">  b&#x3D; (  2&#x2F;  3)</span><br><span class="line">a+b&#x3D;   1</span><br><span class="line">a-b&#x3D; ( -1&#x2F;  3)</span><br><span class="line">a*b&#x3D; (  2&#x2F;  9)</span><br><span class="line">a&#x2F;b&#x3D; (  1&#x2F;  2)</span><br><span class="line"> 0.50</span><br></pre></td></tr></table></figure>
<p>这个程序虽然长，但是不难。就是有一点有意思，就是他这里提到的”辗转相除法“ 求余数有点意思，之前没学过。</p>
<p>他这个原理很简单，就是两个数求最大公约数，通过两个数求余不断缩小这两个数，直至一个数为0，此时另一个数就是最大公约数。这样做效率很高。</p>
<p>我自己也简单地证明了一下，假设这两个数是 m n（m比n大），这两个数的最大公约数是k</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">m = ak</span><br><span class="line">n = bk</span><br><span class="line">m % n = ak % bk #求余，这里余数设为p</span><br><span class="line">p = m % n = ak - x*bk (x为整除数) = (a-xb)k</span><br><span class="line">#证明余数 p 仍可以整除k</span><br></pre></td></tr></table></figure>
<p>体现在fortran 中的代码为</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!用辗转相除法找最大公因子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span></span> gcv(a,b)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">intent</span>(<span class="keyword">in</span>) :: a,b</span><br><span class="line">    <span class="keyword">integer</span> :: big,small</span><br><span class="line">    <span class="keyword">integer</span> :: temp</span><br><span class="line">    <span class="keyword">integer</span> :: gcv</span><br><span class="line">    </span><br><span class="line">    big = <span class="built_in">max</span>(a,b)</span><br><span class="line">    small = <span class="built_in">min</span>(a,b)</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(small&gt;<span class="number">1</span>)</span><br><span class="line">        temp=<span class="built_in">mod</span>(big,small)</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        big = small <span class="comment">!此时较大的数改为原来较小的数</span></span><br><span class="line">        small = temp <span class="comment">!此时较小的数改为余数</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">    gcv = small</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span> gcv</span><br></pre></td></tr></table></figure>
<p>关于 Fortran 语法的介绍，到这一章算是完全结束。下一章会开始进入 Fortran 应用的部分，都是各自独立的不同应用，可以跳着看。</p>
<h2 id="12-编译器的高级使用">12 编译器的高级使用</h2>
<p>这一章要再次说明编译器的使用。第2章示例过编译程序的方法，整套编译器所提供的功能不只是单纯的编译程序而已，善用编译器所提供的工具，对于开发程序有很大帮助。</p>
<p>除了介绍编译器的使用，这一章还会示例 Fortran 与其他语言的互相链接。还有很重要的一个课题： 如何对程序进行优化。</p>
<h2 id="12-1-编译器的完整功能">12-1 编译器的完整功能</h2>
<p>一般来说，编译器所提供的工具，大概有以下这几大类：</p>
<blockquote>
<ol>
<li>
<p>编译器 (Compiler)</p>
<p>用来把程序代码转换成目的文件（.obj）或执行文件（.exe）的工具，是编译工具的主角。Compiler 在编译时有很多选项可以设置，要如何使用这些设置也是一门学科。不同的设置会编译出不同的机器码。</p>
<p>最常见的选项格式有两种，Release 格式和 Debug 格式。Release 格式所编译出来的执行文件执行效率比较好，Debug 格式所编译出来的文件执行效率比较差，不过可以配合Debug 工具来进行调试。</p>
</li>
<li>
<p>链接器（Link）</p>
<p>用来把 Compiler 所生成的目的文件（.obj）链接成最后的可执行文件（.exe），或是链接库（.lib, .dll）。有的编译器执行后会自动调用Link来生成执行文件，所以很多用户不会发现Link的存在。经过目的文件来生成执行文件有几项好处：</p>
<ol>
<li>可以把大程序拆解成许多小文件来编写。</li>
<li>可以把不同语言程序代码所生成的OBJ文件链接成一个执行文件。</li>
</ol>
</li>
<li>
<p>链接库（Library）</p>
<p>编写 Fortran 程序所使用的库存函数，都是事先写好放在.lib 的链接库中。通常各家编译器会自行额外提供扩充函数，像Visual Fortran 专业版中已经提供 IMSL。</p>
</li>
<li>
<p>说明文件（Help)</p>
</li>
<li>
<p>调试工具（Debug）</p>
<p>调试工具是很重要的一项功能，它的重要性仅次于 Compiler。好的调试工具可以让程序员快速找到程序代码的错误。调试格式下，可以对程序代码设置断点，程序执行到断点会暂停执行。这个时候程序员可以查看变量内容，看看它们是否和预期相同。还可以一行一行来执行程序，检查程序执行流程是否正确。</p>
</li>
<li>
<p>分析工具（Profile）</p>
<p>用于分析程序代码中各个函数所花费的执行时间，可以用来找出程序代码中执行效率最差的部分，程序员可以针对这部分程序代码来作修正。</p>
</li>
</ol>
</blockquote>
<p>这一章以 MS Developer Studio 的使用环境做模板。</p>
<h2 id="12-4-优化">12-4 优化</h2>
<p>在信息界广泛流传这样的一句话：”有90%的程序执行时间是花在10%的程序代码里“。换句话说，假如程序代码总共有1000行的话，可能有900行的程序只花了0.1秒就执行完，但是却有100行程序会花掉0.9秒来执行。</p>
<h3 id="12-4-2-程序代码优化">12-4-2 程序代码优化</h3>
<p>要如何写程序来解决问题，一向没有标准答案。解决同样的问题，可以编写出好几种不同的程序。程序的好坏通常取决于两个方面：</p>
<ol>
<li>执行速度</li>
<li>内存使用量。</li>
</ol>
<p>这个小节会强调执行速度的问题，介绍如何让程序代码拥有更好的执行效率，也就是所谓的程序优化。程序代码优化处理，大致上有下面几个方向。</p>
<ol>
<li>
<p>使用好的算法。</p>
<p>算法是指用来解决某个问题的特定程序方法。以数据排序为例子，前面已经介绍过选择排序法（Selection Sort），一般来说它并不算是个好方法，在排序问题中有一个称为快速排序（Quick sort）的算法，在一般情况下执行效率最高。</p>
<p>再以计算等差数列的和来说，要计算 1+2+3+……+n 的值，用循环累加跟使用梯型公式比较起来，当然是用梯形公式比较快。</p>
</li>
<li>
<p>避免重复的计算</p>
<p>做计算的时候经常会重复使用某一个计算结果。这个时候就应该把这个计算结果事先保存起来，再让其他算式使用。例如要计算 ax^2 + bx + c =0 的解，如果直接根据公式计算，写成代码是</p>
 <figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">x1=(-b+<span class="built_in">sqrt</span>(b*b-<span class="number">4</span>*a*c))/(<span class="number">2.0</span>*a)</span><br><span class="line">x1=(-b-<span class="built_in">sqrt</span>(b*b-<span class="number">4</span>*a*c))/(<span class="number">2.0</span>*a)</span><br></pre></td></tr></table></figure>
<p>用这个写法， <code>sqrt(b*b-4*a*c)</code> 和 <code>2.0*a</code> 会重复计算两次。比较好的方法应该是先把这两个值算出来，再计算 x1, x2 的值。</p>
<blockquote>
<p>ok，我现在知道为什么要这么做了，这也太严谨了。</p>
</blockquote>
<p>在循环中很容易会不自觉地出现重复计算，循环里地计算式，如果没有必要写在循环里，就应该把它移到循环外面。</p>
 <figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">10</span></span><br><span class="line">	a(i) = <span class="keyword">real</span>(i)/(b+c)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>上面的循环中，b+c 的值没有必要在循环里计算，因为不管 i 是多少，b + c 的值都不会改变，没有必要在循环中算10次，应该把它移到循环外面来做。（严谨！但是似乎有一点点影响可读性）</p>
 <figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">d = b+c <span class="comment">! 把b+c的结果记录在变量d中</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,<span class="number">10</span></span><br><span class="line">	a(i) = <span class="keyword">real</span>(i)/d</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>表达式的选择</p>
<p>数学算式中，使用不同的式子可以得到同样的结果，下面是几个例子。</p>
 <figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>*A = A+A</span><br><span class="line">A**<span class="number">2</span> = A*A</span><br><span class="line">X**<span class="number">2</span>+<span class="number">2</span>*X+<span class="number">3</span> = ((X=<span class="number">2</span>)*X)+<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>这3个例子中，等号右边的写法都会比等号左边的写法来得迅速。计算机运算时，做加减法会比做乘除法快，乘法又会比乘幂快。所以计算2A时，用 A+A 会比用 2*A 来得快；同理计算 A*A 会比 计算 A**2 来得快。至于第3个式子，左边的方法会使用1个乘幂，1个乘法，2个加法；右边的方法则会使用1个乘法跟2个加法，很明显的是右边的方法会比较快。</p>
<blockquote>
<p>这有一点吹毛求疵，而且影响了可读性了。我最多接受将乘幂写成乘法，即 A**2 改成 A*A</p>
</blockquote>
</li>
<li>
<p>整数与浮点数的选择</p>
<p>计算机的整数运算比浮点数运算快，能够使用整数时，就应该尽量多使用整数。</p>
<p>在混合使用整数和浮点数的算式中，应该要尽量把整数集合在一起。</p>
<p><strong>使用浮点数时，双精度和单精度的计算速度相同，差别在于内存使用量</strong>。</p>
<p>（为什么？百度百科说CPU处理单精度更快，<a href="https://baike.baidu.com/item/%E5%8F%8C%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0%EF%BC%89">https://baike.baidu.com/item/双精度浮点数）</a></p>
</li>
<li>
<p>访问速度</p>
<p>不同的变量类型，在使用时会有不同的访问速度。例如声明成 parameter 的常量，使用时会比一般变量快。因为使用常量不用再到内存中取出数据，数字可以直接写在程序代码中。使用常量来做计算时，在编译过程中就会计算完毕，不需要在执行过程中计算。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;b&#x2F;2.0</span><br><span class="line">a&#x3D;b&#x2F;c</span><br></pre></td></tr></table></figure>
<p>使用数组的访问速度比变量慢，而且越高维的数组访问速度越慢。因为使用数组时，要先计算出坐标在数组中的内存位置，越高维的数组需要计算的式子会越长。</p>
 <figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">b=a(i)+a(j)</span><br><span class="line">b=e+f <span class="comment">! 假设 e=a(i), f=a(j)</span></span><br></pre></td></tr></table></figure>
<p>使用指针也会比使用变量慢上一点点，因为使用指针要经过两个步骤，先取出指针所保存的内存地址，再去使用这个内存。直接使用变量时不需要第1个操作，使用变量时马上就可以知道它使用哪一块内存。</p>
</li>
<li>
<p>利用 cache</p>
<p>程序执行时，如果能尽量避免跳转式使用内存，会得到比较好的执行效率。使用数组时最需要注意这一点。</p>
 <figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,n1</span><br><span class="line">	<span class="keyword">do</span> j =<span class="number">1</span>,n2</span><br><span class="line">		<span class="keyword">do</span> k=<span class="number">1</span>,n3</span><br><span class="line">			<span class="comment">! s=s+a(i,j,k) !不好的写法</span></span><br><span class="line">			s=s+a(k,j,i) <span class="comment">!比较好的写法</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>上面这两种写法，第2种写法会比较好，因为它会依照内存的排列顺序来使用数组；第1种方法则会跳转式地在内存中访问。</p>
<p>关于计算机的存储知识见：<a href="https://zhuanlan.zhihu.com/p/71956210">https://zhuanlan.zhihu.com/p/71956210</a></p>
<blockquote>
<p><strong>计算机的存储系统可以看成一个金字塔形结构（也称为 memory hierarchy）</strong>，越是上层的存储设备容量越小、速度越快、价格也越贵，而越是下层的存储设备容量越大、速度越慢、价格也越便宜。</p>
<p>寄存器（Regs）- 一级缓存（L1 cache）- 二级缓存 - 三级缓存 - 内存（Main memory）- 本地磁盘（Local disks）- 网络存储（Network storage）</p>
</blockquote>
<p>下面这段话解释了计算机时如何查找和访问数据的。</p>
<blockquote>
<p>通常来讲，越是上层的存储设备 block size 越小（例如几个字节），而越到下层 block size 越大（例如整个文件）。当我们要读取某个数据的时候，我们沿着金字塔从上往下看。由于越是上层的存储设备访问速度越快，如果该数据在上一层已经被缓存了（称作 cache hit），那么皆大欢喜，我们可以直接读出数据。如果该数据在上一层没有被缓存（称作 cache miss），那么我们只能从下一层取出包含该数据的 block 放到上一层。</p>
<p>**要是上一层的缓存已经全部装满了怎么办？**那我们只能替换掉一个别的 block 了。替换的策略有很多种，最简单的方法当然可以随机选一个倒霉的 block 扔掉，不过这不一定是最好的办法。</p>
<p>由于时间局部性告诉我们，越是最近访问过的数据越应该被缓存，因此另一个常用的策略 LRU (least recently used) 干的事情就是把最久没有访问过的 block 扔掉。</p>
</blockquote>
<p>简单地说，就是按照计算机存储系统从上往下一级一级地查找，找到了就把包含该数据的 block 放到上一层。（注意，这里的一个 block 指的是一段连续的数据，也就是除了要找的数据外它附近的数据也调到上层了，比如你只是查找数组中的某一个元素，那么可能整个数组都会被放到上一层，这样如果你之后查找数组中的其他元素，速度也很快）</p>
<p>如果上一层的缓存已经全部装满，那就将最久没有访问过的 block 扔掉。（因此相关的数据，代码最好放在一块，不要东一块西一块的）</p>
</li>
<li>
<p>减少程序代码的跳转、转向</p>
<p>使用流程控制命令 if, select case, 及 do 循环、调用函数时，都会导致程序执行做出跳转和转向的操作。执行程序和开车一样，在笔直的路上开车是最快的，遇到转弯甚至回转时就需要减速。执行程序时也是相同的，照顺序直线执行的程序会比较快。</p>
 <figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!比较好的写法</span></span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">20</span>) <span class="keyword">then</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a &gt; <span class="number">10</span>)</span><br><span class="line">……</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="comment">!比较不好的写法</span></span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">20</span>) <span class="keyword">then</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">if</span>(a &gt; <span class="number">10</span> .and. a&lt;=<span class="number">20</span>) <span class="keyword">then</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">if</span>(a&lt;=<span class="number">10</span>) <span class="keyword">then</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span></span><br></pre></td></tr></table></figure>
<p>上面这两种代码效果相同，不过第1种写法比较好，第2种写法固定要做3次if 判断。第1种写法则不一定会做几次if判断，不过最多只会做2次。</p>
 <figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">	read(<span class="number">10</span>, *) a(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>, n</span><br><span class="line">	s = s*a(i)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">1</span>,n <span class="comment">!把上面两个循环合并起来</span></span><br><span class="line">	read(<span class="number">10</span>, *) a(i)</span><br><span class="line">	s = s*a(i) </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<p>上面这两个循环第2种写法比较好，因为这两个循环本来就可以合并，减少一次循环次数。</p>
</li>
</ol>
<p>上面介绍了几个程序优化的策略，<strong>使用这些策略不需要矫枉过正</strong>。</p>
<p>编写程序时，不需要把每个部分都做优化处理。如果某个函数只会调用一次，那就可以不太注意它的执行效率。前面已经提到，通常最花时间的程序代码大概都只会集中在少部分程序中。一般来说，只要把循环中的程序代码，跟经常会调用使用的函数做优化处理，整个程序就可以有不错的执行效率。</p>
<blockquote>
<p>我一直在想，这些优化策略对代码<strong>可读性</strong>的影响。然后我又看了一下 Fortran 代码，Fortran 代码<strong>有个毛线的可读性</strong>，他们正常写的代码都没什么可读性可言。</p>
</blockquote>
<h1>14 数值方法</h1>
<p>数值计算是 Fortran 语言最主要的应用领域，现在就来进入这个课题。本书把数值方法分成两个章节来介绍，这一章会示例如何自行编写程序来求解最基本的几个数值方法问题，第16章会示例如何使用 IMSL 链接库来做数值计算。</p>
<h2 id="14-1-求解非线性函数">14-1 求解非线性函数</h2>
<p>这一节是要示例如何计算函数 f(x) =0 的解。</p>
<h3 id="14-1-1-二分法-Bisection">14-1-1 二分法 Bisection</h3>
<p>二分法是最简单的解法，这个算法只有很简单的几个步骤。</p>
<ol>
<li>先猜两个值a,b，是的 f(a)*f(b) 小于0。</li>
<li>令 c=(a+b)/2 ，如果 f© = 0 ，就找到了一个正解，工作完成。</li>
<li>f© 不为0时，如果f(a), f© 异号，则以a,c 为新的起点。f(b) f© 同理。</li>
</ol>
<p>程序实现如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">! 二分法求解</span></span><br><span class="line"><span class="comment">! by pon 1997/9/2</span></span><br><span class="line"><span class="keyword">module</span> Numerical</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>, <span class="keyword">parameter</span> :: zero = <span class="number">0.00001</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> bisect(a,b)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> a,b <span class="comment">! 输入的猜值</span></span><br><span class="line">        <span class="keyword">real</span> c   <span class="comment">! 用来计算 (a+b)/2</span></span><br><span class="line">        <span class="keyword">real</span> fa  <span class="comment">! 记录f(a)</span></span><br><span class="line">        <span class="keyword">real</span> fb  <span class="comment">! 记录f(b)</span></span><br><span class="line">        <span class="keyword">real</span> fc  <span class="comment">! 记录f(c)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">!先求c,f(c)的值</span></span><br><span class="line">        c = (a+b)/<span class="number">2.0</span></span><br><span class="line">        fc = func(c)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">!abs(f(c)) 小于 zero 时，就视 f(c) = 0，结束循环</span></span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(<span class="built_in">abs</span>(fc)&gt;zero)</span><br><span class="line">            fa = func(a)</span><br><span class="line">            fb = func(b)</span><br><span class="line">            <span class="keyword">if</span> (fa*fc &lt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">                <span class="comment">!以 a,c 值为新的区间</span></span><br><span class="line">                b=c</span><br><span class="line">                c=(a+b)/<span class="number">2.0</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">!不然就是以 b,c 值为新的区间</span></span><br><span class="line">                a=c</span><br><span class="line">                c=(a+b)/<span class="number">2.0</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">            <span class="comment">!求出新的 fc 值</span></span><br><span class="line">            fc = func(c)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        bisect = c</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">!求解用的函数</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> func(x)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> x</span><br><span class="line">        func = (x+<span class="number">3</span>)*(x-<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> numerical</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> a,b <span class="comment">!两个猜值</span></span><br><span class="line">    <span class="keyword">real</span> ans <span class="comment">!算出的值</span></span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;输入两个猜测值&quot;</span></span><br><span class="line">        read(*,*) a,b</span><br><span class="line">        <span class="comment">!f(a)*f(b) &lt; 0 才是有效的猜测值</span></span><br><span class="line">        <span class="keyword">if</span>(func(a)*func(b) &lt; <span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;不正确的猜值&quot;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment">!调用二分法求根的函数</span></span><br><span class="line">    ans = bisect(a,b)</span><br><span class="line">    <span class="comment">!显示结果</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;x=&#x27;,f6.3)&quot;</span>) ans</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 输入两个猜测值</span><br><span class="line">2 100</span><br><span class="line">x&#x3D; 3.000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的实例程序有一个最大的缺点，那就是想要求解的函数已经被固定，即 f(x) = (x+3)*(x-3)。如果程序代码中还要计算其他函数时，最好使用下面的方法：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">! 二分法求解</span></span><br><span class="line"><span class="comment">! by pon 1997/9/2</span></span><br><span class="line"><span class="keyword">module</span> Numerical</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>, <span class="keyword">parameter</span> :: zero = <span class="number">0.00001</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> bisect(a,b,func)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> a,b <span class="comment">! 输入的猜值</span></span><br><span class="line">        <span class="keyword">real</span> c   <span class="comment">! 用来计算 (a+b)/2</span></span><br><span class="line">        <span class="keyword">real</span> fa  <span class="comment">! 记录f(a)</span></span><br><span class="line">        <span class="keyword">real</span> fb  <span class="comment">! 记录f(b)</span></span><br><span class="line">        <span class="keyword">real</span> fc  <span class="comment">! 记录f(c)</span></span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">external</span> :: func <span class="comment">! 所要求解的函数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">!先求c,f(c)的值</span></span><br><span class="line">        c = (a+b)/<span class="number">2.0</span></span><br><span class="line">        fc = func(c)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">!abs(f(c)) 小于 zero 时，就视 f(c) = 0，结束循环</span></span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(<span class="built_in">abs</span>(fc)&gt;zero)</span><br><span class="line">            fa = func(a)</span><br><span class="line">            fb = func(b)</span><br><span class="line">            <span class="keyword">if</span> (fa*fc &lt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">                <span class="comment">!以 a,c 值为新的区间</span></span><br><span class="line">                b=c</span><br><span class="line">                c=(a+b)/<span class="number">2.0</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">!不然就是以 b,c 值为新的区间</span></span><br><span class="line">                a=c</span><br><span class="line">                c=(a+b)/<span class="number">2.0</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">            <span class="comment">!求出新的 fc 值</span></span><br><span class="line">            fc = func(c)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        bisect = c</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">!求解用的函数1</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> f1(x)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> x</span><br><span class="line">        f1 = (x+<span class="number">3</span>)*(x-<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="comment">!求解用的函数2</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> f2(x)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> x</span><br><span class="line">        f2 = (x+<span class="number">4</span>)*(x-<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> numerical</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> a,b <span class="comment">!两个猜值</span></span><br><span class="line">    <span class="keyword">real</span> ans <span class="comment">!算出的值</span></span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;输入两个猜测值&quot;</span></span><br><span class="line">        read(*,*) a,b</span><br><span class="line">        <span class="comment">!f(a)*f(b) &lt; 0 才是有效的猜测值</span></span><br><span class="line">        <span class="keyword">if</span>(f1(a)*f1(b) &lt; <span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;不正确的猜值&quot;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment">!调用二分法求根的函数</span></span><br><span class="line">    ans = bisect(a,b,f1)</span><br><span class="line">    <span class="comment">!显示结果</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;x=&#x27;,f6.3)&quot;</span>) ans</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;输入两个猜测值&quot;</span></span><br><span class="line">        read(*,*) a,b</span><br><span class="line">        <span class="comment">!f(a)*f(b) &lt; 0 才是有效的猜测值</span></span><br><span class="line">        <span class="keyword">if</span>(f2(a)*f2(b) &lt; <span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;不正确的猜值&quot;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment">!调用二分法求根的函数</span></span><br><span class="line">    ans = bisect(a,b,f2)</span><br><span class="line">    <span class="comment">!显示结果</span></span><br><span class="line">    <span class="built_in">write</span>(*,<span class="string">&quot;(&#x27;x=&#x27;,f6.3)&quot;</span>) ans</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 输入两个猜测值</span><br><span class="line">2 100</span><br><span class="line">x&#x3D; 3.000</span><br><span class="line"> 输入两个猜测值</span><br><span class="line">2 100</span><br><span class="line">x&#x3D; 5.000</span><br></pre></td></tr></table></figure>
<p>这个程序的做法，是把函数当作参数传到 bisect 函数中，函数 bisect 可以用来求解任何输入的函数。 ans = bisect(a,b,f1) 时会求解 f1 函数， ans = bisect(a,b,f2) 时则会求解 f2 函数。</p>
<h3 id="14-1-2-割线法-Secant">14-1-2 割线法 Secant</h3>
<p>现在介绍如何使用割线法，这个方法很适合使用图形来解释，它主要是利用线段来逼近结果，过程如下</p>
<ol>
<li>先选出两个猜测值 a,b</li>
<li>画一条通过 (a, f(a)) (b, f(b)) 这两点的直线，令这条指向与x轴的交点为 c 。检查f© 是否等于0</li>
<li>f© 不为0时，令 b,c 值为新的两个猜值值，回到上一步骤继续。</li>
</ol>
<p>所得到新的猜想 b, c 会比原本的 a, b 更接近答案，一步一步做下去就可以得到 f© = 0 的结果。</p>
<p>程序实现如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> NUMERICAL</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>, <span class="keyword">parameter</span> :: zero = <span class="number">0.00001</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> secant(a,b,f)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: a,b <span class="comment">!起始的两个猜值</span></span><br><span class="line">        <span class="keyword">real</span> :: c   <span class="comment">!新的解</span></span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">external</span> :: f <span class="comment">!输入的求解函数</span></span><br><span class="line">        <span class="keyword">real</span> :: fa,fb,fc <span class="comment">!记录函数结果</span></span><br><span class="line">        </span><br><span class="line">        fa=f(a)</span><br><span class="line">        fb=f(b)</span><br><span class="line">        c = a-fa*(b-a)/(fb-fa)</span><br><span class="line">        fc=f(c)</span><br><span class="line">        <span class="comment">!在趋近于0之前要一直做逼近的工作</span></span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(<span class="built_in">abs</span>(fc) &gt; zero)</span><br><span class="line">            a = b</span><br><span class="line">            b = c</span><br><span class="line">            fa=f(a)</span><br><span class="line">            fb=f(b)</span><br><span class="line">            c = a-fa*(b-a)/(fb-fa)</span><br><span class="line">            fc=f(c)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        secant = c</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> func(x)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: x</span><br><span class="line">        func = <span class="built_in">sin</span>(x)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> NUMERICAL</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> :: a,b <span class="comment">!起始猜值</span></span><br><span class="line">    <span class="keyword">real</span> :: ans</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;输入两个猜值&quot;</span></span><br><span class="line">    read(*,*) a,b</span><br><span class="line">    <span class="comment">! 输入起始猜值及求值的函数</span></span><br><span class="line">    ans = secant(a,b,func)</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;x=&#x27;,f8.4)&quot;</span>) ans</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>请注意，<strong>割线法并不一定保证会找到解</strong>。也有可能 c 值会越来越偏理答案。</p>
<p>比如，实例程序的执行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 输入两个猜值</span><br><span class="line">50 100</span><br><span class="line">x&#x3D;     NaN</span><br></pre></td></tr></table></figure>
<h3 id="14-1-3-牛顿法">14-1-3 牛顿法</h3>
<p>牛顿法也是利用线段来逼近结果，计算过程如下：</p>
<ol>
<li>先做一个猜想 a</li>
<li>以 f’(a) 为斜率，经过 (a, f(a)) 作一条直线，令这条直线与x轴的交点为b。检查 f(b) 是否为0。</li>
<li>f(b) 不为0时，重新令 b 为新的猜值，重复。</li>
</ol>
<p><strong>若初始猜值 a 取的好，f(b) 应该会越来越接近0</strong>。</p>
<p>程序如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> NUMERICAL </span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>, <span class="keyword">parameter</span> :: zero = <span class="number">0.00001</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> newton(a,f,df)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: a <span class="comment">!猜值</span></span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">external</span> :: f <span class="comment">!求值函数</span></span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">external</span> :: df <span class="comment">! f&#x27;(x)的函数</span></span><br><span class="line">        <span class="keyword">real</span> :: b <span class="comment">!解</span></span><br><span class="line">        <span class="keyword">real</span> :: fb</span><br><span class="line">        </span><br><span class="line">        b = a-f(a)/df(a)</span><br><span class="line">        fb = f(b)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(<span class="built_in">abs</span>(fb) &gt; zero)</span><br><span class="line">            a = b</span><br><span class="line">            b = a-f(a)/df(a)</span><br><span class="line">            fb = f(b)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        newton = b</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="comment">!求值的函数</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> func(x)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: x</span><br><span class="line">        func = <span class="built_in">sin</span>(x)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">!f&#x27;(x)</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> dfunc(x)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: x</span><br><span class="line">        dfunc = <span class="built_in">cos</span>(x)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> numerical</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span> :: a <span class="comment">!猜值</span></span><br><span class="line">    <span class="keyword">real</span> :: ans <span class="comment">!解</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;输入起始猜值&quot;</span></span><br><span class="line">    read(*,*) a</span><br><span class="line">    ans = newton(a,func,dfunc)</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;x=&#x27;,f8.4)&quot;</span>) ans</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> 输入起始猜值</span><br><span class="line"><span class="number">1</span></span><br><span class="line">x=  <span class="number">0.0000</span></span><br></pre></td></tr></table></figure>
<p>使用牛顿法时，如果猜值给的不好，会永远无法逼近结果。实际使用时，应该要检查 f(b) 是否向0逼近。</p>
<h2 id="14-2-线性代数">14-2 线性代数</h2>
<p>学习线性代数的数值方法，就是在学习矩阵的应用。二维数组经常被当成矩阵来使用。</p>
<h3 id="14-2-1-矩阵的加、减、乘法">14-2-1 矩阵的加、减、乘法</h3>
<p>矩阵的加减法其实不需要介绍，因为它只是很单纯地把矩阵中相同坐标位置地数字相加、减而已。Fortran 90 可以直接对整个数组来做计算，所以可以用一个命令就完成矩阵的加减法。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">real</span> a(m,n), b(m,n), c(m,n)</span><br><span class="line">c = a + b <span class="comment">! 矩阵加法完成</span></span><br><span class="line">c = a - b <span class="comment">! 矩阵减法完成</span></span><br></pre></td></tr></table></figure>
<h3 id="14-2-2-三角矩阵">14-2-2 三角矩阵</h3>
<p>这一节和大家介绍如何经过矩阵中的两行数字相减，把矩阵换算成上三角矩阵和下三角矩阵。</p>
<p>使用程序来解决这个问题的方法，和用手计算的过程是一样的，同样是把某一行乘上一个系数之后和另外一行相减。做上三角矩阵时，就先把第1行的第1列以下的元素数值都清为0。再把第2行第2列以下的数值都清为0，…… 如此一直做到 N-1 行为止。</p>
<p>下面是实例程序：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> LinearAlgebra</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">!输出矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> output(matrix)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: m,n</span><br><span class="line">        <span class="keyword">real</span> :: matrix(:,:)</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        <span class="keyword">character</span>(len=<span class="number">20</span>) :: for=<span class="string">&#x27;(??(1x,f6.3))&#x27;</span></span><br><span class="line">        m = <span class="built_in">size</span>(matrix,<span class="number">1</span>)</span><br><span class="line">        n = <span class="built_in">size</span>(matrix,<span class="number">2</span>)</span><br><span class="line">        <span class="comment">!用字符串来设置输出格式</span></span><br><span class="line">        <span class="built_in">write</span>(for(<span class="number">2</span>:<span class="number">3</span>), <span class="string">&#x27;(i2)&#x27;</span>) N</span><br><span class="line">        <span class="keyword">do</span> i = <span class="number">1</span>,n</span><br><span class="line">            <span class="built_in">write</span>(*, <span class="keyword">fmt</span>=for) matrix(i,:)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!求上三角矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Upper(matrix)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: matrix(:,:)</span><br><span class="line">        <span class="keyword">integer</span> :: m,n</span><br><span class="line">        <span class="keyword">integer</span> :: i,j</span><br><span class="line">        <span class="keyword">real</span> :: e</span><br><span class="line">        m = <span class="built_in">size</span>(matrix,<span class="number">1</span>)</span><br><span class="line">        n = <span class="built_in">size</span>(matrix,<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">do</span> j=i+<span class="number">1</span>, m</span><br><span class="line">                e = matrix(j,i)/matrix(i,i)</span><br><span class="line">                <span class="comment">!用90的功能可以少一层xunhuan</span></span><br><span class="line">                matrix(j,i:m) = matrix(j,i:m)-matrix(i,i:m)*e</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!求下三角矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Lower(matrix)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: matrix(:,:)</span><br><span class="line">        <span class="keyword">integer</span> :: m,n</span><br><span class="line">        <span class="keyword">integer</span> :: i,j</span><br><span class="line">        <span class="keyword">real</span> :: e</span><br><span class="line">        m = <span class="built_in">size</span>(matrix,<span class="number">1</span>)</span><br><span class="line">        n = <span class="built_in">size</span>(matrix,<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">do</span> i=n,<span class="number">2</span>,-<span class="number">1</span></span><br><span class="line">            <span class="keyword">do</span> j=i-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span></span><br><span class="line">                e = matrix(j,i)/matrix(i,i)</span><br><span class="line">                <span class="comment">!用90的功能可以少一层xunhuan</span></span><br><span class="line">                matrix(j,<span class="number">1</span>:i) = matrix(j,<span class="number">1</span>:i)-matrix(i,<span class="number">1</span>:i)*e</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> LinearAlgebra</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n = <span class="number">3</span> <span class="comment">!矩阵大小</span></span><br><span class="line">    <span class="keyword">real</span> :: A(n,n) = <span class="built_in">reshape</span>((/<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>/),(/n,n/))</span><br><span class="line">    <span class="keyword">real</span> :: B(n,n)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Matrix A:&quot;</span></span><br><span class="line">    <span class="keyword">call</span> output(A)</span><br><span class="line">    B=A</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Upper:&quot;</span></span><br><span class="line">    <span class="keyword">call</span> Upper(B)</span><br><span class="line">    <span class="keyword">call</span> output(B)</span><br><span class="line">    B=A</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Lower:&quot;</span></span><br><span class="line">    <span class="keyword">call</span> Lower(B)</span><br><span class="line">    <span class="keyword">call</span> output(B)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Matrix A:</span><br><span class="line"> 1.000  3.000  2.000</span><br><span class="line"> 2.000  2.000  3.000</span><br><span class="line"> 1.000  3.000  4.000</span><br><span class="line">Upper:</span><br><span class="line"> 1.000  3.000  2.000</span><br><span class="line"> 0.000 -4.000 -1.000</span><br><span class="line"> 0.000  0.000  2.000</span><br><span class="line">Lower:</span><br><span class="line"> 8.000  0.000  0.000</span><br><span class="line"> 1.250 -0.250  0.000</span><br><span class="line"> 1.000  3.000  4.000</span><br></pre></td></tr></table></figure>
<p>为什么要先学习做上、下三角矩阵的办法呢？因为这个方法可以应用在很多地方，例如应用在用 Determinant, Gauss-Jordan 法求解联立式、求逆矩阵等等。</p>
<p>在这个程序中，传递数组时用了特殊方法。以函数 output 为例，声明数组时没有赋值大小。使用这个方法传递数组时，可以免去传递数组大小。库存函数 size 可以查询出数组的实际大小。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">real</span> :: matrix(:,:)</span><br></pre></td></tr></table></figure>
<h3 id="14-2-3-Determinant-矩阵的值">14-2-3 Determinant 矩阵的值</h3>
<p>求矩阵行列式值的方法很简单，把矩阵用上一个小节中的方法转换成上三角形或下三角矩阵后，把对角线的数值全部乘起来就是答案了。</p>
<p>下面是程序。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> LinearAlgebra</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">!求矩阵的Determinant值</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Determinant(matrix)</span><br><span class="line">        <span class="keyword">real</span> :: matrix(:,:)</span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">allocatable</span> :: ma(:,:)</span><br><span class="line">        <span class="keyword">integer</span> :: i,n</span><br><span class="line">        n = <span class="built_in">size</span>(matrix,<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">allocate</span>(ma(n,n))</span><br><span class="line">        ma = matrix</span><br><span class="line">        <span class="keyword">call</span> Upper(ma)</span><br><span class="line">        Determinant = <span class="number">1.0</span></span><br><span class="line">        <span class="keyword">do</span> i = <span class="number">1</span>,n</span><br><span class="line">            Determinant = Determinant * ma(i,i)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    <span class="comment">!求上三角矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Upper(matrix)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: matrix(:,:)</span><br><span class="line">        <span class="keyword">integer</span> :: m,n</span><br><span class="line">        <span class="keyword">integer</span> :: i,j</span><br><span class="line">        <span class="keyword">real</span> :: e</span><br><span class="line">        m = <span class="built_in">size</span>(matrix,<span class="number">1</span>)</span><br><span class="line">        n = <span class="built_in">size</span>(matrix,<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">do</span> j=i+<span class="number">1</span>, m</span><br><span class="line">                e = matrix(j,i)/matrix(i,i)</span><br><span class="line">                <span class="comment">!用90的功能可以少一层xunhuan</span></span><br><span class="line">                matrix(j,i:m) = matrix(j,i:m)-matrix(i,i:m)*e</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> LinearAlgebra</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n=<span class="number">3</span></span><br><span class="line">    <span class="keyword">real</span> :: A(n,n) = <span class="built_in">reshape</span>((/<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>/),(/n,n/))</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;det(A)=&#x27;,f6.2)&quot;</span>) Determinant(A)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">det(A)&#x3D; -8.00</span><br></pre></td></tr></table></figure>
<h3 id="14-2-4-Gauss-Jordan-法求联立方程式">14-2-4 Gauss-Jordan 法求联立方程式</h3>
<p>对于 <code>A*x=b</code> 的方程式，可以用 Gauss-Jordan 法来求解。唯一的差别在于矩阵后方又要夹带数组 b 来做为等号后面的数值。矩阵的每一行在互相加减时，数组 b 也要跟着一起做加减。（这句话的意思，直接把A矩阵转换成上/下三角矩阵即可，就直接得到了x的解。但是做加减的时候数组b要跟着变化。）。</p>
<p>高斯消去法：<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%B6%88%E5%8E%BB%E6%B3%95">https://zh.wikipedia.org/wiki/高斯消去法</a></p>
<p>来看代码</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> LinearAlgebra</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">! Gauss_Jordan 法</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Gauss_Jordan(A,S,ANS)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: A(:,:) <span class="comment">!左手项</span></span><br><span class="line">        <span class="keyword">real</span> :: S(:)   <span class="comment">!右手项</span></span><br><span class="line">        <span class="keyword">real</span> :: ANS(:) <span class="comment">!结果文件</span></span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">allocatable</span> :: B(:,:)</span><br><span class="line">        <span class="keyword">integer</span> :: i,n</span><br><span class="line">        n = <span class="built_in">size</span>(A,<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">allocate</span>(B(N,N))</span><br><span class="line">        <span class="comment">! 保存原先的矩阵A及数组S</span></span><br><span class="line">        B=A</span><br><span class="line">        ANS=S</span><br><span class="line">        <span class="comment">! 把B化成对角线矩阵（除了对角线外，都为0）</span></span><br><span class="line">        <span class="keyword">call</span> Upper(B,ANS,N) <span class="comment">!先把B化成上三角矩阵</span></span><br><span class="line">        <span class="keyword">call</span> Lower(B,ANS,N) <span class="comment">!先把B化成下三角矩阵</span></span><br><span class="line">        <span class="comment">! 求解</span></span><br><span class="line">        <span class="keyword">forall</span>(i=<span class="number">1</span>:n)</span><br><span class="line">            ANS(i) = ANS(i)/B(i,i)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!输出等式</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> output(M,S)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: M(:,:), S(:)</span><br><span class="line">        <span class="keyword">integer</span> :: n,i,j</span><br><span class="line">        n = <span class="built_in">size</span>(M,<span class="number">1</span>)</span><br><span class="line">        <span class="comment">! write中加上advance=&quot;no&quot;，可以终止断行发生，使下一次的</span></span><br><span class="line">        <span class="comment">! write接续在同一行当中</span></span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(1x,f5.2,a1)&quot;</span>, <span class="keyword">advance</span>=<span class="string">&quot;NO&quot;</span>) M(i,<span class="number">1</span>), <span class="string">&#x27;A&#x27;</span></span><br><span class="line">            <span class="keyword">do</span> j=<span class="number">2</span>,n</span><br><span class="line">                <span class="keyword">if</span> (M(i,j) &lt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">                    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;-&#x27;,f5.2,a1)&quot;</span>, <span class="keyword">advance</span>=<span class="string">&quot;NO&quot;</span>) -M(i,j),<span class="built_in">char</span>(<span class="number">64</span>+j)</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;+&#x27;,f5.2,a1)&quot;</span>, <span class="keyword">advance</span>=<span class="string">&quot;NO&quot;</span>) M(i,j),<span class="built_in">char</span>(<span class="number">64</span>+j)</span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;=&#x27;,f8.4)&quot;</span>) S(i)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!求上三角矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Upper(M,S,n)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: n</span><br><span class="line">        <span class="keyword">real</span> :: M(n,n)</span><br><span class="line">        <span class="keyword">real</span> :: S(n)</span><br><span class="line">        <span class="keyword">integer</span> :: i,j</span><br><span class="line">        <span class="keyword">real</span> :: e</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">do</span> j=i+<span class="number">1</span>, n</span><br><span class="line">                e = M(j,i)/M(i,i)</span><br><span class="line">                M(j,i:n) = M(j,i:n)-M(i,i:n)*e</span><br><span class="line">                S(j) = S(j) - S(i)*e <span class="comment">!右手项要随着左手项变化而变化</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!求下三角矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Lower(M,S,n)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: n</span><br><span class="line">        <span class="keyword">real</span> :: M(n,n)</span><br><span class="line">        <span class="keyword">real</span> :: S(n)</span><br><span class="line">        <span class="keyword">integer</span> :: i,j</span><br><span class="line">        <span class="keyword">real</span> :: e</span><br><span class="line">        <span class="keyword">do</span> i=n,<span class="number">2</span>,-<span class="number">1</span></span><br><span class="line">            <span class="keyword">do</span> j=i-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span></span><br><span class="line">                e = M(j,i)/M(i,i)</span><br><span class="line">                M(j,i:n) = M(j,i:n)-M(i,i:n)*e</span><br><span class="line">                S(j) = S(j) - S(i)*e</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"><span class="comment">! 求解联立式</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> LinearAlgebra</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n =<span class="number">3</span> </span><br><span class="line">    <span class="keyword">real</span> :: A(n,n) = <span class="built_in">reshape</span>((/<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>/),(/n,n/))</span><br><span class="line">    <span class="keyword">real</span> :: S(n) = (/<span class="number">12</span>,<span class="number">15</span>,<span class="number">17</span>/)</span><br><span class="line">    <span class="keyword">real</span> :: ans(n)</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;Equation:&#x27;</span></span><br><span class="line">    <span class="keyword">call</span> output(A,S)</span><br><span class="line">    <span class="keyword">call</span> Gauss_Jordan(A,S,ANS)</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Ans:&quot;</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a1,&#x27;=&#x27;,f8.4)&quot;</span>) <span class="built_in">char</span>(<span class="number">64</span>+i),ans(i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Equation:</span><br><span class="line"> 1.00A+ 4.00B+ 7.00C&#x3D; 12.0000</span><br><span class="line"> 2.00A+ 5.00B+ 8.00C&#x3D; 15.0000</span><br><span class="line"> 3.00A+ 6.00B+ 8.00C&#x3D; 17.0000</span><br><span class="line">Ans:</span><br><span class="line">A&#x3D;  1.0000</span><br><span class="line">B&#x3D;  1.0000</span><br><span class="line">C&#x3D;  1.0000</span><br></pre></td></tr></table></figure>
<p>这个程序通过<strong>先把矩阵转化为上三角矩阵，再转化为下三角矩阵</strong>的方式，得到对角线矩阵。</p>
<p>这里转化为上/下三角矩阵式，右手项要跟着变化。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">M(j,i:n) = M(j,i:n)-M(i,i:n)*e</span><br><span class="line">S(j) = S(j) - S(i)*e <span class="comment">!右手项要随着左手项变化而变化</span></span><br></pre></td></tr></table></figure>
<p>得到的对角线矩阵还不是单位矩阵，需要除以对角线元素的值</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">! 求解</span></span><br><span class="line"><span class="keyword">forall</span>(i=<span class="number">1</span>:n)</span><br><span class="line">    ANS(i) = ANS(i)/B(i,i)</span><br></pre></td></tr></table></figure>
<p>最终得到了解。</p>
<h3 id="14-2-5-逆矩阵">14-2-5 逆矩阵</h3>
<p>逆矩阵的算法与上一个小节中使用的方法差不多，在矩阵后面夹带一个单位矩阵，然后把前面那个矩阵处理成对角线矩阵，矩阵每一次的加减运行时，后面夹带的矩阵也要跟着变化。</p>
<p>再把前面的那个矩阵从对角线矩阵转化为单位矩阵，这个时候第二个矩阵就会变成第一个矩阵的逆矩阵。程序的实际方法与使用 Gauss-Jordan 法来求解联立式的方法非常类似。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> LinearAlgebra</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">! 求逆矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> inverse(A,IA)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: A(:,:), IA(:,:)</span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">allocatable</span> :: B(:,:)  </span><br><span class="line">        <span class="keyword">integer</span> :: i,j,n</span><br><span class="line">        n = <span class="built_in">size</span>(A,<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">allocate</span>(B(N,N))</span><br><span class="line">        <span class="comment">! 先把 IA 设置为单位矩阵</span></span><br><span class="line">        <span class="keyword">forall</span>(i=<span class="number">1</span>:n, j=<span class="number">1</span>:n, i==j)IA(i,j)=<span class="number">1.0</span></span><br><span class="line">        <span class="keyword">forall</span>(i=<span class="number">1</span>:n, j=<span class="number">1</span>:n, i/=j)IA(i,j)=<span class="number">0.0</span></span><br><span class="line">        <span class="comment">! 保存原先的矩阵A,使用B来计算</span></span><br><span class="line">        B=A</span><br><span class="line">        <span class="comment">! 把B化成对角线矩阵（除了对角线外，都为0）</span></span><br><span class="line">        <span class="keyword">call</span> Upper(B,IA,N) <span class="comment">!先把B化成上三角矩阵</span></span><br><span class="line">        <span class="keyword">call</span> Lower(B,IA,N) <span class="comment">!再把B化成下三角矩阵</span></span><br><span class="line">        <span class="comment">! 求解</span></span><br><span class="line">        <span class="keyword">forall</span>(i=<span class="number">1</span>:n)</span><br><span class="line">            IA(i,:) = IA(i,:)/B(i,i)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">forall</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!输出矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> output(matrix)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> :: matrix(:,:)</span><br><span class="line">        <span class="keyword">integer</span> :: m,n,i</span><br><span class="line">        <span class="keyword">character</span>(len=<span class="number">20</span>) :: for=<span class="string">&#x27;(??(1x,f6.3))&#x27;</span></span><br><span class="line">        m = <span class="built_in">size</span>(matrix,<span class="number">1</span>)</span><br><span class="line">        n = <span class="built_in">size</span>(matrix,<span class="number">2</span>)</span><br><span class="line">        <span class="comment">!用字符串来设置输出格式</span></span><br><span class="line">        <span class="built_in">write</span>(for(<span class="number">2</span>:<span class="number">3</span>), <span class="string">&#x27;(i2)&#x27;</span>) n</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">            <span class="built_in">write</span>(*,<span class="keyword">fmt</span>=for) matrix(i,:)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!求上三角矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Upper(M,S,n)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: n</span><br><span class="line">        <span class="keyword">real</span> :: M(n,n)</span><br><span class="line">        <span class="keyword">real</span> :: S(n)</span><br><span class="line">        <span class="keyword">integer</span> :: i,j</span><br><span class="line">        <span class="keyword">real</span> :: e</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line">            <span class="keyword">do</span> j=i+<span class="number">1</span>, n</span><br><span class="line">                e = M(j,i)/M(i,i)</span><br><span class="line">                M(j,i:n) = M(j,i:n)-M(i,i:n)*e</span><br><span class="line">                S(j) = S(j) - S(i)*e <span class="comment">!右手项要随着左手项变化而变化</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!求下三角矩阵的子程序</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Lower(M,S,n)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span> :: n</span><br><span class="line">        <span class="keyword">real</span> :: M(n,n)</span><br><span class="line">        <span class="keyword">real</span> :: S(n)</span><br><span class="line">        <span class="keyword">integer</span> :: i,j</span><br><span class="line">        <span class="keyword">real</span> :: e</span><br><span class="line">        <span class="keyword">do</span> i=n,<span class="number">2</span>,-<span class="number">1</span></span><br><span class="line">            <span class="keyword">do</span> j=i-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span></span><br><span class="line">                e = M(j,i)/M(i,i)</span><br><span class="line">                M(j,i:n) = M(j,i:n)-M(i,i:n)*e</span><br><span class="line">                S(j) = S(j) - S(i)*e</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"><span class="comment">! 求解联立式</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> LinearAlgebra</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n =<span class="number">3</span> </span><br><span class="line">    <span class="keyword">real</span> :: A(n,n) = <span class="built_in">reshape</span>((/<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>/),(/n,n/))</span><br><span class="line">    <span class="keyword">real</span> :: IA(n,n)</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;原矩阵&#x27;</span></span><br><span class="line">    <span class="keyword">call</span> output(A)</span><br><span class="line">    <span class="keyword">call</span> inverse(A,IA)</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;逆矩阵&quot;</span></span><br><span class="line">    <span class="keyword">call</span> output(IA)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原矩阵</span><br><span class="line"> 1.000  4.000  7.000</span><br><span class="line"> 2.000  5.000  8.000</span><br><span class="line"> 3.000  6.000  8.000</span><br><span class="line">逆矩阵</span><br><span class="line">-2.667  0.000  0.000</span><br><span class="line"> 2.667 -0.333 -0.000</span><br><span class="line">-1.000 -0.000 -1.000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="14-2-6-对角矩阵的运行">14-2-6 对角矩阵的运行</h3>
<p>所谓的对角矩阵，就是类似下面的情况：只有靠近对角线位置上2个相邻的位置有数值，其他位置为0。<br>
$$<br>
\left[<br>
\begin{matrix}<br>
2 &amp; 3 &amp; 0 &amp; 0 &amp; 0 \<br>
0 &amp; 2 &amp; 3 &amp; 0 &amp; 0 \<br>
0 &amp; 0 &amp; 2 &amp; 3 &amp; 0 \<br>
0 &amp; 0 &amp; 0 &amp; 2 &amp; 3<br>
\end{matrix}<br>
\right]<br>
$$<br>
利用这个特性来保存矩阵，可以节省很多空间。原本 N×N 大小的矩阵需要 N×N  的数组来保存，不过如果要保存想上例中的二对角矩阵，只要用N×2大小的数组就足够了，因为只需要记录有数值的部分就行了，数字为0的部分不需要另辟空间来做记录。</p>
<p>使用这个数据结构来操作矩阵时，与前几个小节的方法比较起来当然是会有一些不同，来看看求解联立方程式要如何运行。</p>
<p>在此同样使用 Gauss-Jordan 法来解联立方程式。事实上，用对角矩阵会比较简单。因为已经知道矩阵哪些低分为0，这些地方在把矩阵对角线化的时候可以不再去理会。简化后的结果，在每一个循环中，只要把矩阵相邻两行来互相加减就够了，不需要把每一行都拿来操作，可以节省大量的运算。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!三对角阵求解</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main </span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: Width = <span class="number">3</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: Row = <span class="number">5</span> <span class="comment">! size of Matrix</span></span><br><span class="line">    <span class="keyword">real</span> :: A(row, width)=<span class="built_in">reshape</span>((/<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,&amp;</span><br><span class="line">                        <span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,&amp;</span><br><span class="line">                        <span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">0</span>/),(/row,width/))</span><br><span class="line">    <span class="keyword">real</span> :: S(row)=(/<span class="number">3</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">10</span>,<span class="number">3</span>/)</span><br><span class="line">    <span class="keyword">real</span> :: ans(row)</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="comment">! equation:</span></span><br><span class="line">    <span class="comment">! a+2b=3</span></span><br><span class="line">    <span class="comment">! 2b+3c+4d=9</span></span><br><span class="line">    <span class="comment">! 3c+4d+5e=12</span></span><br><span class="line">    <span class="comment">! 4d+5e+f=10</span></span><br><span class="line">    <span class="comment">! e+2f=3</span></span><br><span class="line">    <span class="keyword">call</span> Gauss_Jordan(A,S,ANS,row,width)</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;Ans:&#x27;</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,row</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a1,&#x27;=&#x27;,f8.4)&quot;</span>) <span class="built_in">char</span>(<span class="number">96</span>+i),ANS(i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">! Gauss_Jordan 法的函数</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Gauss_Jordan(A,S,ANS,row,width)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: row, width</span><br><span class="line">    <span class="keyword">real</span> :: A(row, width)</span><br><span class="line">    <span class="keyword">real</span> :: S(row)</span><br><span class="line">    <span class="keyword">real</span> :: ANS(row)</span><br><span class="line">    <span class="keyword">real</span> :: B(row, width)</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 保存原先的矩阵A及数组S</span></span><br><span class="line">    B=A</span><br><span class="line">    ANS=S</span><br><span class="line">    <span class="comment">! 把B化为对角线矩阵</span></span><br><span class="line">    <span class="keyword">call</span> Upper(B,ANS,row,width) <span class="comment">! 先把B化成上三角矩阵</span></span><br><span class="line">    <span class="keyword">call</span> Lower(B,ANS,row,width) <span class="comment">! 再把B化成下三角矩阵</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 求出解</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,row</span><br><span class="line">        ANS(i) = ANS(i)/B(i,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="comment">! 求上三角矩阵的子程序</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Upper(M,S,row,width)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: row, width</span><br><span class="line">    <span class="keyword">real</span> :: M(row,width)</span><br><span class="line">    <span class="keyword">real</span> :: S(row)</span><br><span class="line">    <span class="keyword">integer</span> :: i,j</span><br><span class="line">    <span class="keyword">real</span> :: e</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>, row-<span class="number">1</span></span><br><span class="line">            j=i+<span class="number">1</span></span><br><span class="line">            e = M(j,<span class="number">1</span>)/M(i,<span class="number">2</span>)</span><br><span class="line">            M(j,<span class="number">1</span>:<span class="number">2</span>) = M(j,<span class="number">1</span>:<span class="number">2</span>)-M(i,<span class="number">2</span>:<span class="number">3</span>)*e</span><br><span class="line">            S(j) = S(j) - S(i)*e <span class="comment">!右手项要随着左手项变化而变化</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="comment">!求下三角矩阵的子程序</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Lower(M,S,row,width)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: row, width</span><br><span class="line">    <span class="keyword">real</span> :: M(row,width)</span><br><span class="line">    <span class="keyword">real</span> :: S(row)</span><br><span class="line">    <span class="keyword">integer</span> :: i,j</span><br><span class="line">    <span class="keyword">real</span> :: e</span><br><span class="line">    <span class="keyword">do</span> i=row,<span class="number">2</span>,-<span class="number">1</span></span><br><span class="line">            j=i-<span class="number">1</span></span><br><span class="line">            e = M(j,<span class="number">3</span>)/M(i,<span class="number">2</span>)</span><br><span class="line">            M(j,<span class="number">3</span>) = M(j,<span class="number">3</span>)-M(i,<span class="number">2</span>)*e</span><br><span class="line">            S(j) = S(j) - S(i)*e</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br></pre></td></tr></table></figure>
<p>这个在书上的代码有好几处 bug ，这里是我改过来，能跑通的。但是这个代码我没看懂，而且这里不是自动化的，是只适用他这里的”三对角矩阵“。</p>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ans:</span><br><span class="line">a&#x3D;  1.0000</span><br><span class="line">b&#x3D;  1.0000</span><br><span class="line">c&#x3D;  1.0000</span><br><span class="line">d&#x3D;  1.0000</span><br><span class="line">e&#x3D;  1.0000</span><br></pre></td></tr></table></figure>
<h2 id="14-3-积分">14-3 积分</h2>
<p>做积分的最好方法，当然是先求出积分函数再来求解。<strong>用数值方法来做积分，主要是应用在函数不存在时</strong>。从实验中得到的一连串数据，应该是没有办法刚好适用某一个函数来表示它，要对这一串数据做积分时，只能使用其他算法来做。一般最常见的方法是使用各种已知面积的小图形来填充这些区域，在经过计算这些图形的面积总和来逼近答案。</p>
<h3 id="14-3-1-梯形法积分">14-3-1 梯形法积分</h3>
<p>梯形法做积分的原理很简单，把所需积分的图形，用许多个小梯形方块来将它们填满。实现的程序如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Integral</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">real</span>, <span class="keyword">parameter</span> :: pi = <span class="number">3.14159</span></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">!生成数列</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> GenerateData(datas, width, func)</span><br><span class="line">        <span class="keyword">real</span> datas(:), width</span><br><span class="line">        <span class="keyword">real</span>, <span class="keyword">external</span> :: func</span><br><span class="line">        <span class="keyword">real</span> r</span><br><span class="line">        <span class="keyword">integer</span> i, n</span><br><span class="line">        n = <span class="built_in">size</span>(datas,<span class="number">1</span>)</span><br><span class="line">        width = pi/(n-<span class="number">1</span>)</span><br><span class="line">        r = <span class="number">0</span></span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">            datas(i) = func(r)</span><br><span class="line">            r = r + width</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">!梯形积分法</span></span><br><span class="line">    <span class="keyword">real</span> <span class="function"><span class="keyword">function</span></span> Trape_Integral(datas, width)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">real</span> datas(:)</span><br><span class="line">        <span class="keyword">real</span> width <span class="comment">!每条数据的间隔</span></span><br><span class="line">        <span class="keyword">real</span> <span class="built_in">sum</span> <span class="comment">!计算所有上底加下底除以二的和</span></span><br><span class="line">        <span class="keyword">integer</span> i,n</span><br><span class="line">        n = <span class="built_in">size</span>(datas,<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">sum</span> = (datas(<span class="number">1</span>)+datas(n))/<span class="number">2.0</span></span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">2</span>,n-<span class="number">1</span></span><br><span class="line">            <span class="built_in">sum</span> = <span class="built_in">sum</span>+datas(i) <span class="comment">!累加边长</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        Trape_Integral = <span class="built_in">sum</span>*width <span class="comment">!计算面积和</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="comment">! 梯形法积分范例</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> Integral</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: N = <span class="number">10</span></span><br><span class="line">    <span class="keyword">real</span> DATAS(n), width</span><br><span class="line">    <span class="keyword">real</span> ANS <span class="comment">!答案</span></span><br><span class="line">    <span class="keyword">real</span>, <span class="keyword">intrinsic</span> :: <span class="built_in">sin</span> <span class="comment">!仿真用来生成数据的函数</span></span><br><span class="line">    <span class="keyword">call</span> GenerateData(DATAS, width, <span class="built_in">sin</span>) </span><br><span class="line">    ANS = Trape_Integral(DATAS, width) <span class="comment">!计算积分</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;ans=&#x27;,f5.2)&quot;</span>) ANS <span class="comment">!显示答案</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line">            </span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ans&#x3D; 1.98</span><br></pre></td></tr></table></figure>
<p>积分的数据是使用 sin 函数所生成的一长串数值，使用计算机来计算积分时，通常都是面对一串数字来做计算，而不是直接面对一个数学函数。子程序 GenerateData 的作用就是用来生成一串数字来做积分计算，所生成的是X值范围在0~Π之间的sin(x) ，积分的结果应该是2。</p>
<p>他这里求 sum（所有上底加下底除以二的和） 的时候，由于第一个梯形的上底和最后一个梯形的下底只用了一次，因此该除以2；至于中间的函数值，都是既作为一个梯形的上底，又作为另一个梯形的下底，因此乘2除2正好抵消。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sum</span> = (datas(<span class="number">1</span>)+datas(n))/<span class="number">2.0</span> <span class="comment">!第一个梯形的上底和最后一个梯形的下底</span></span><br><span class="line"><span class="keyword">do</span> i=<span class="number">2</span>,n-<span class="number">1</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span>+datas(i) <span class="comment">!累加边长，其他</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">do</span></span><br></pre></td></tr></table></figure>
<h3 id="14-3-2-simpson-辛普森法积分">14-3-2 simpson 辛普森法积分</h3>
<p>辛普森法的原理，是把函数图形使用很多段的二次曲线来近似图形，再计算这些二次曲线形成的面积。使用辛普森法有一个限制，一定要有奇数个数据才能计算，因为每一条二次权限都要从数据中取3个点。每一条二次曲线的积分公式如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">f(x) 积分 = （f0 + <span class="number">4</span>*f1 + f2) * h/<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>把每一段二次曲线累加起来，就可以得到整个辛普森法积分的公式：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">f(x) 积分 = （f0 + <span class="number">4</span>*f1 + <span class="number">2</span>*f2 + <span class="number">4</span>*f3 + <span class="number">2</span>*f4…… + <span class="number">4</span>*fn-<span class="number">1</span> + fn) * h/<span class="number">3</span> </span><br></pre></td></tr></table></figure>
<p>ok, 我压根不知道这是啥，pass</p>
<p>代码略。</p>
<h2 id="14-4-插值法与曲线近似">14-4 插值法与曲线近似</h2>
<p>插值法与曲线近似其实是同样的一个课题，曲线近似的目的经常就是为了要做插值。插值法的应用很频繁，在实验室中，可以使用插值法来利用有限的已知数据点来预测未知的状态。</p>
<h3 id="14-4-1-Lagrange-Interpolation-多项式插值法">14-4-1 Lagrange Interpolation 多项式插值法</h3>
<p>使用多项式来做插值，会经过所获得的 N 个数据点，生成最高项为 N-1 的多项式，这个多项式函数图形会经过这 N 个数据点。Lagrange Interpolation 的公式可以来生成这个多项式。</p>
<p>假设 （X1,Y1),  (X2,Y2) … (Xn, Yn) 为 N 个数据点，经过 Lagrange Interpolation 法所生成通过这 N 个点的多项式函数 g(x) 为：</p>
<p>略</p>
<h3 id="14-4-2-牛顿法-Forward-Interpolation">14-4-2 牛顿法  Forward Interpolation</h3>
<p>看不懂，略。</p>
<h3 id="14-4-3-最小方差法（Least-Square）">14-4-3 最小方差法（Least Square）</h3>
<p>最小方差法是应用在已经可以用理论推得数据的函数形式，而不知道系数数值的时候。因为实验不可能处于完美的情况，所得的数据不可能工整地在函数曲线上，大多都是散步在理论所预测的附近。(这就是最小二乘)</p>
<p>求 N 个点到 Y = aT + b 直线上的距离平方总和。要使距离平方和为最短，可以把上述的式子分别对 a, b 做偏微分，令两式结果为0，并解出 a, b 值即可。联立两式，又可以写成一个新的方程式。（这里我没法把式子列出来，不直观）。</p>
<p>代码略。</p>
<h3 id="14-4-4-曲线近似法（Cubic-Spline）">14-4-4 曲线近似法（Cubic Spline）</h3>
<p>略</p>
<h1>15 数据结构与算法</h1>
<p>这一章所要介绍的课题是数据结构与算法。学会 Fortran 语法，只能算是学会程序设计的皮毛而已。<strong>程序员的能力，主要取决在实现及设计算法的能力，不在于他会使用哪些程序语言</strong>。</p>
<p>数据结构的课题，主要在于讨论如何使用程序语言的基本类型来记录数据的方法。简单的数据结构方法，不需要学习大家就自然会使用，例如使用二维数组来记录矩阵。在前面章节中，已经应用过一些比较复杂的数据结构，例如第10章的串行结构，第14章的对角矩阵等等。</p>
<p>算法是指：”通过编写程序解决问题的方法“。第14章的数值方法中，所介绍的就是各种用来计算数学问题的算法。这一章所要介绍的算法，是在编写每一种程序时，都有可能会使用的基本算法。</p>
<h2 id="15-1-排序">15-1 排序</h2>
<p>”排序“ 的算法很多，在本节会介绍其中的四种。实例程序只范例由小排到大的做法，相信读者应该能自行领会由大排到小的做法。</p>
<h3 id="15-1-1-冒泡排序法（Bubble-Sort）">15-1-1 冒泡排序法（Bubble Sort）</h3>
<p>冒泡排序法是最简单的排序方法之一，它的步骤如下：</p>
<ol>
<li>从第1个数字开始，依序把两个相邻的数值互相比较大小。如果前一个数字比后面一个数字大，就把它们的位置互相交换。</li>
<li>一直做到每一对相邻的数字都比较过后才结束这一轮的工作。</li>
<li>回到第1步，再做下一个循环的比较。如果有 N 个数字要排序，就需要重复 N-1次的扫描工作。</li>
</ol>
<p>第一次扫描，会找出最大的数值，并把它放在数组的最后面。第二次扫描，找出第2大的数值，放在倒数第二个位置……</p>
<p>可以看出，冒泡排序法可以想象成是让重的东西向下沉，轻的东西向上浮。等到状态稳定，就会得到排序结果。下面是冒泡排序法的程序：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">! 冒泡排序法范例</span></span><br><span class="line"><span class="comment">! By perng 1997/8/29</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> bubble_sort_demo</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n = <span class="number">10</span></span><br><span class="line">    <span class="keyword">integer</span> :: a(n) = (/<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>/) <span class="comment">! 待排序的数据</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source=&gt;&#x27;, 10I3)&quot;</span>) a</span><br><span class="line">    <span class="keyword">call</span> Bubble_Sort(a,n) <span class="comment">!调用排序的子程序</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Sort=&gt;&#x27;, 10I3)&quot;</span>) a</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Bubble_Sort(A,N)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: n, a(n)</span><br><span class="line">    <span class="keyword">integer</span> i,j, temp</span><br><span class="line">    <span class="keyword">do</span> i = n-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span> <span class="comment">! 开始做N-1次的扫描</span></span><br><span class="line">        <span class="keyword">do</span> j = <span class="number">1</span>,i  <span class="comment">! 一对一对的比较，i 之后的数字不用比较</span></span><br><span class="line">            <span class="comment">! 如果 A(j) &gt; A(j+1) 就把这两个数值交换</span></span><br><span class="line">            <span class="keyword">if</span> (A(j) &gt; A(j+<span class="number">1</span>)) <span class="keyword">then</span></span><br><span class="line">                temp = a(j)</span><br><span class="line">                a(j) = a(j+<span class="number">1</span>)</span><br><span class="line">                a(j+<span class="number">1</span>) = temp</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Source&#x3D;&gt;  6  2  8  4  0  9  3  5  1  7</span><br><span class="line">Sort&#x3D;&gt;  0  1  2  3  4  5  6  7  8  9</span><br></pre></td></tr></table></figure>
<h3 id="15-1-2-选择排序法（Selection-Sort）">15-1-2 选择排序法（Selection Sort）</h3>
<p>选择排序法的原理很简单，步骤如下：</p>
<ol>
<li>找出全部N个数据中最小的一个，把它和数列的第1个数字交换位置。</li>
<li>找出剩下N-1个数据中最小的一个，把它和数列的第2个数字交换位置。</li>
<li>找出剩下N-2个数据中最小的一个，把它和数列的第3个数字交换位置。</li>
<li>……</li>
<li>一直做到只剩下一个数据为止。</li>
</ol>
<p>选择排序法的过程，就是一步一步地精选出数据中最小的数值，并把它放到所该对应的位置上。需要处理的数据每次会减少一个，一直到只剩下一个数值为止。（这个方法感觉和上一个没啥区别啊）</p>
<p>程序如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">! 选择排序法范例</span></span><br><span class="line"><span class="comment">! By Perng 1997/8/29 </span></span><br><span class="line"><span class="comment">! 果然是一个人发明的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> selection_sort_demo</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n = <span class="number">10</span> </span><br><span class="line">    <span class="keyword">integer</span> :: a(n) = (/<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>/) <span class="comment">! 待排序的数据</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source=&gt;&#x27;, 10I3)&quot;</span>) a</span><br><span class="line">    <span class="keyword">call</span> Selection_Sort(a,n) <span class="comment">!调用排序的子程序</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Sort=&gt;&#x27;, 10I3)&quot;</span>) a</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">!选择排序法的子程序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> Selection_Sort(a,n)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: n, a(n)</span><br><span class="line">    <span class="keyword">integer</span> i,j <span class="comment">! 循环计数器</span></span><br><span class="line">    <span class="keyword">integer</span> <span class="built_in">min</span> <span class="comment">! 找出每一轮中的最小值</span></span><br><span class="line">    <span class="keyword">integer</span> temp </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>,n</span><br><span class="line">        <span class="comment">! min = a(i) !暂时令a(i)是最小值 !我感觉这里的min是多余的</span></span><br><span class="line">        <span class="keyword">do</span> j = i+<span class="number">1</span>, n</span><br><span class="line">            <span class="keyword">if</span>(a(i) &gt; a(j)) <span class="keyword">then</span> <span class="comment">! 发现a(i)不是最小</span></span><br><span class="line">                temp = a(j) <span class="comment">!a(i),a(j) 交换</span></span><br><span class="line">                a(j) = a(i)</span><br><span class="line">                a(i) = temp </span><br><span class="line">                <span class="comment">! min = a(i)</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Source&#x3D;&gt;  6  2  8  4  0  9  3  5  1  7</span><br><span class="line">Sort&#x3D;&gt;  0  1  2  3  4  5  6  7  8  9</span><br></pre></td></tr></table></figure>
<p>这里需要注意，书上的代码里 min 这个变量完全是多余的，没有用处。我就删除了，看来作者偶尔也会犯点迷糊。</p>
<h3 id="15-1-3-Shell-排序法">15-1-3 Shell 排序法</h3>
<p>这是 1959 年 D.L.Shell 所发明的排序方法，这个方法和前面两个方法比较起来比较没有那么直观，在此所使用的是比较简单的一种 Shell 排序法。排序 N 个数据项的步骤如下：</p>
<blockquote>
<ol>
<li>令 k = n/2</li>
<li>把数据项分组，第1，1+k 的数字为一组，第2，2+k 为一组，一直到把所有的数据分配完毕为止。（也就是两两一组，那要是奇数个数字怎么办？）</li>
<li>每一组各自互相比较大小，如果前者大于后则J（第n项 &gt; 第n+k项），两者都要交换位置。而且还要再往回取出第n-k, n这两项再来比较，如果第 n-k 项 &gt; 第 n 项，那又要再往回取出 n-2k, n-k 这两项来比较。一直往回取到第 N-nK &lt; 第N - (n-1)K项，或者是到了不能往回取为止。</li>
<li>令 k = k/2 ，再回到第2步重复，一直到 k = 0 为止。</li>
</ol>
</blockquote>
<p>啊，这说的是人话嘛？</p>
<p>我不知道发明这个算法的人是怎么想到的，能搞成这么复杂。而且我粗略地感觉了一个，计算复杂度并不低，从书上看，排序5个数字，也计算了十几次（当然比前面两个算法要好）。</p>
<p>Shell 排序法可以形容成 ” 乱中有序“ ，因为它在每一次的循环中都只能大概地安排每一个元素到更加接近的位置，一直要到最后一次循环，才能确定每个数字的真正位置。</p>
<p>代码略。</p>
<h3 id="15-1-4-快速排序法（Quick-Sort）">15-1-4 快速排序法（Quick Sort）</h3>
<p>这个小节所要介绍的快速排序法，相信任何人听到一定都会非常心动，因为它的名字听起来就很有威力，在一般的情况下，也确实是目前最快的排序方法。这个实例程序会使用递归调用的功能。</p>
<p>快速排序法处理N个数据的步骤如下：</p>
<blockquote>
<ol>
<li>
<p>以数据组中的第1个数字做为键值K，令L=2, R=N。</p>
</li>
<li>
<p>以K值为基准，把小于K的数字向前移动，大于K的数字向后移动。移动的过程中，会同时发现K值在数列中的大小排名，并把K值放在正确的位置上。</p>
</li>
<li>
<p>假设K值排名为S，把移动后的数列分成比K小和比K大这两组。数列中第1~S-1 个数字都比K小，第S+1~N个数字都比K大，再把这两个小组拿去排序。</p>
<p>使用快速排序法时，每一个循环都会生成两个新的小组。切割的操作会一直进行到新的小组中只剩下一个数字为止。步骤2的过程有必要再详细地介绍，同样令 L=2， R=N，num(n) 为数据中第n个数字：</p>
</li>
<li>
<p>从数据组中的第L个数字开始，依序拿下一个数字和键值K来比较，一直到找出&gt;=K 的数值为止。把L重新设置为这个数值在数据中的位置。</p>
</li>
<li>
<p>从数据组中的第R个数字开始，依序拿前一个数字和键值K来比较，一直到找出&lt;=K 的数值为止。把R设为这个数值在数据中的位置。</p>
</li>
<li>
<p>如果 L &lt; R ，把数组中 L，R这两个位置的数值交换，再回到上一个步骤继续执行。如果　L &gt; R , 把数组第1个数字和第R个数字交换位置。到了这个时候，num(1~R-1)&lt;=num®, num(R+1~N) &gt;= num® , 会确定出第R个数值的排名。</p>
</li>
</ol>
</blockquote>
<p>下面这组数字 {3,2,5,1,4} 以快速排序法排序的过程如下：</p>
<p>先取 K = num(1) = 3 为键值来做比较，令 L = 2、R = 5。</p>
<ol>
<li>从第L个数字向后寻找&gt;=K的数值，结果发现 num(3) = 5 &gt; K，所以令L = 3</li>
<li>从第R个数字向前寻找&lt;K 的数值，结果发现 num(4) = 1 &lt; K，所以令R = 4</li>
<li>因为 L=3 &lt; R=4, 所以把 num(3) 及 num(4) 的数值交换，数据变成 {3,2,1,5,4}</li>
<li>再继续从 L=3 的地方向下找 &gt;= K的数值，结果发现num(4)=5&gt;k, 所以令L = 4</li>
<li>再继续从 R=4 的地方向前找 &lt; K 的数值，结果发现num(3)=1&lt;K, 所以令R = 3</li>
<li>因为 L =4 &gt; R=3，所以要把num(1) 和 num® 的数值交换。此时的数列内容为 {1,2,3,5,4}。而这一次的循环会确定 num(3) 的数值（因为 R=3），接下来要把 num(1~2) 的 [1,2] 及 num(4~5)  的 [5,4] 分成两组，再把它们用同样的方法来排序。</li>
</ol>
<p>经过上面的解释，可以简单地把快速排序法做一个简述。快速排序法是一次次地把整个数据细分成许多小组，而每一次都会确定小组的第1个成员在数据中的排名。快速排序法的实现程序如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">! 快速排序法范例</span></span><br><span class="line"><span class="comment">! By Perng 1997/8/30 </span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> QuickSort_Demo</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n = <span class="number">10</span></span><br><span class="line">    <span class="keyword">real</span> :: b(n)</span><br><span class="line">    <span class="keyword">integer</span> :: a(n)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 用随机数生成数列</span></span><br><span class="line">    <span class="keyword">call</span> random_seek()</span><br><span class="line">    <span class="keyword">call</span> <span class="built_in">random_number</span>(b)</span><br><span class="line">    a = b*<span class="number">100</span></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source=&gt;&#x27;, 10i3)&quot;</span>) a</span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 调用Quick_Sort 时除了要输入数组的信息外，还要给定要排列数组元素</span></span><br><span class="line">    <span class="comment">! 的上下限位置范围，在此当然是要给 1,n ， 表示从头排到尾。</span></span><br><span class="line">    <span class="keyword">call</span> Quick_Sort(a,n,<span class="number">1</span>,n)</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Sort=&gt;&#x27;, 10i3)&quot;</span>) a</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">!快速排序法的子程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">recursive</span> <span class="function"><span class="keyword">subroutine</span></span> Quick_Sort(a,n,s,e)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: n    <span class="comment">! 表示数组的大小</span></span><br><span class="line">    <span class="keyword">integer</span> :: a(n) <span class="comment">! 存放数据的数组</span></span><br><span class="line">    <span class="keyword">integer</span> :: s    <span class="comment">! 输入的参数，这一组的数组的起始位置</span></span><br><span class="line">    <span class="keyword">integer</span> :: e    <span class="comment">! 输入的参数，这一组的数组的结束位置</span></span><br><span class="line">    <span class="keyword">integer</span> :: l,r  <span class="comment">! 用来找a(l) &gt; k 及 a(r) &lt; k 时用的</span></span><br><span class="line">    <span class="keyword">integer</span> :: k    <span class="comment">! 记录键值 a(s) </span></span><br><span class="line">    <span class="keyword">integer</span> :: temp <span class="comment">! 交换两个数值时用的</span></span><br><span class="line">    <span class="comment">! 首先要先给定l, r 的初值。l 要从头开始，r 要从尾开始</span></span><br><span class="line">    l = s</span><br><span class="line">    r = e + <span class="number">1</span></span><br><span class="line">    <span class="comment">! Right 值 &gt; Left 值时才有必要进行排序</span></span><br><span class="line">    <span class="keyword">if</span>(r &lt;= l) <span class="keyword">return</span> <span class="comment">! return 就是提前结束子程序</span></span><br><span class="line">    </span><br><span class="line">    k = a(s) <span class="comment">! 设置键值</span></span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="comment">!找出 A(l) &lt; k 的所在</span></span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">            L = L + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span>((A(l) &gt; k) .or. (l&gt;=e)) <span class="keyword">exit</span> </span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="comment">! 找出 A(r) &gt; k 的所在</span></span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">            r = r-<span class="number">1</span> <span class="comment">!初值设为 e+1,这里就变成了 e</span></span><br><span class="line">            <span class="keyword">if</span>((a(r) &lt; k) .or. (r&lt;=s)) <span class="keyword">exit</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">        <span class="comment">! 如果 right 跑到 left 的 左边时，循环就该结束了</span></span><br><span class="line">        <span class="keyword">if</span>(r &lt;= l) <span class="keyword">exit</span></span><br><span class="line">        <span class="comment">! 交换 a(l), a(r) 的数值</span></span><br><span class="line">        temp = a(l)</span><br><span class="line">        a(l) = a(r)</span><br><span class="line">        a(r) = temp</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment">! 交换a(s), a(r)的数值</span></span><br><span class="line">    temp = a(s)</span><br><span class="line">    a(s) = a(r)</span><br><span class="line">    a(r) = temp</span><br><span class="line">    <span class="comment">! 把r之前的数据重新分组，再做排序</span></span><br><span class="line">    <span class="keyword">call</span> Quick_Sort(A,N,S,R-<span class="number">1</span>)</span><br><span class="line">    <span class="comment">! 把r之后的数据重新分组，再做排序</span></span><br><span class="line">    <span class="keyword">call</span> Quick_Sort(A,N,R+<span class="number">1</span>,E)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Source&#x3D;&gt;  5 45 37 72 29 70 18 46  3 44</span><br><span class="line">Sort&#x3D;&gt;  3  5 18 29 37 44 45 46 70 72</span><br></pre></td></tr></table></figure>
<p>注意，这里用到了递归。这个算法是真的漂亮。</p>
<p>这里所介绍的排序方法，在一般的情况下的工作效率排名为：</p>
<blockquote>
<p>快速排序法 &gt; shell 排序法 &gt; 冒泡排序法 &gt; 选择排序法</p>
</blockquote>
<h2 id="15-2-搜索">15-2 搜索</h2>
<p>搜索是在一堆东西中寻找特定物品。本节将会介绍三种搜索方法。</p>
<h3 id="15-2-1-顺序搜索">15-2-1 顺序搜索</h3>
<p>顺序搜索是最简单的方法，一句话就可以解释完毕：“把东西一个一个拿出来，看看它是不是我们所要找的东西。”</p>
<p>程序实现如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">! 顺序搜索法示范</span></span><br><span class="line"><span class="comment">! By Perng 1997/8/31</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> sequential_search_demo</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n = <span class="number">10</span></span><br><span class="line">    <span class="keyword">integer</span> :: a(n) = (/ <span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span> /) <span class="comment">! 存放数据组的数据</span></span><br><span class="line">    <span class="keyword">integer</span> key <span class="comment">! 记录要找的值</span></span><br><span class="line">    <span class="keyword">integer</span> loc </span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">external</span> :: sequential_search</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source=&gt;&#x27;,10i3)&quot;</span>) a</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;Input Key:&#x27;</span></span><br><span class="line">    read(*,*) key</span><br><span class="line">    <span class="comment">! 调用顺序搜索的函数</span></span><br><span class="line">    loc = sequential_search(a,n,key)</span><br><span class="line">    <span class="keyword">if</span>(loc/=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;A(&#x27;,i2,&#x27; )=&#x27;i3)&quot;</span>) loc, key</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;Not found&quot;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">! 顺序搜索法的子程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> Sequential_Search(a,n,key)</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> n, a(n)</span><br><span class="line">    <span class="keyword">integer</span> key </span><br><span class="line">    <span class="keyword">integer</span> i <span class="comment">!循环的计数器</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> i =<span class="number">1</span>,n <span class="comment">!开始做扫描，最多做N次</span></span><br><span class="line">        <span class="keyword">if</span>(key == A(i)) <span class="keyword">then</span></span><br><span class="line">            <span class="comment">! 找到了，返回数字在数组中的位置</span></span><br><span class="line">            <span class="comment">! 但是如果有多个重复值，只会返回第一个位置</span></span><br><span class="line">            sequential_search = i</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment">! 没找到时返回 -1</span></span><br><span class="line">    sequential_search = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个太简单了。</p>
<h3 id="15-2-2-二元搜索">15-2-2 二元搜索</h3>
<p>二元搜索法必须配合<strong>排序好</strong>的数据才能使用，假设所要寻找的数值为K，数据存放在数组中，搜索的步骤如下：</p>
<ol>
<li>取出数组的中间值 M 与 K 值来互相比较，如果 k=M 就找到了；如果 K&gt;M ，那么 K一定在数组的后半段；如果K&lt;M ，同理。</li>
<li>根据K值在数组的前半段/后半段来重新分组，再回到第一步来做搜索。分组会一直细分到数组不能再细分下去为止，而到此时若还没有找到K，代表K值不存在。</li>
</ol>
<p>二元搜索法的程序实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">! 二元搜索法范例</span><br><span class="line">! By Perng 1997&#x2F;8&#x2F;31</span><br><span class="line">program Binary_Search_demo</span><br><span class="line">    implicit none</span><br><span class="line">    integer, parameter :: n &#x3D;10 !数组的大小</span><br><span class="line">    integer :: a(n) &#x3D; (&#x2F; 2,5,7,9,10,11,13,17,21,23 &#x2F;)</span><br><span class="line">    integer key</span><br><span class="line">    integer loc</span><br><span class="line">    integer, external :: binary_search</span><br><span class="line">    </span><br><span class="line">    write(*, &quot;(&#39;Source&#x3D;&gt;&#39;, 10i3)&quot;) A</span><br><span class="line">    write(*,*) &#39;Input Key:&#39;</span><br><span class="line">    read(*,*) key</span><br><span class="line">    !调用二元搜索的子程序</span><br><span class="line">    loc &#x3D; binary_search(a,n,key)</span><br><span class="line">    if(loc&#x2F;&#x3D;0) then</span><br><span class="line">        write(*, &quot;(&#39;A(&#39;,i2,&#39; )&#x3D;&#39;i3)&quot;) loc, key</span><br><span class="line">    else</span><br><span class="line">        write(*,*) &quot;Not found&quot;</span><br><span class="line">    end if</span><br><span class="line">    stop</span><br><span class="line">end program</span><br><span class="line"></span><br><span class="line">! 二元搜索法的子程序</span><br><span class="line"></span><br><span class="line">integer function Binary_Search(a,n,key)</span><br><span class="line">    implicit none</span><br><span class="line">    integer n,a(n)</span><br><span class="line">    integer key   ! 所要寻找的值</span><br><span class="line">    integer l     ! 记录每一个小组的数组起始位置</span><br><span class="line">    integer r     ! 记录每一个小组的数组结束位置</span><br><span class="line">    integer m     ! 记录每一个小组的数组开始位置</span><br><span class="line">    </span><br><span class="line">    ! 一开始的小组范围就是整个数组</span><br><span class="line">    l&#x3D;1</span><br><span class="line">    r&#x3D;n</span><br><span class="line">    m&#x3D;(l+r)&#x2F;2 ! 7&#x2F;2 &#x3D; 3</span><br><span class="line">    </span><br><span class="line">    ! 如果 key 值超出范围，肯定不存在数组中</span><br><span class="line">    if((key &lt; a(l)) .or. (key &gt; a(r))) then</span><br><span class="line">        binary_search &#x3D; 0</span><br><span class="line">        return</span><br><span class="line">    end if</span><br><span class="line">    </span><br><span class="line">    do while(l &lt;&#x3D; r)</span><br><span class="line">        if(key &gt; a(m)) then</span><br><span class="line">            ! 如果 key &gt; 中间值，那就落在后半段</span><br><span class="line">            L &#x3D; M+1</span><br><span class="line">            M &#x3D; (L+R)&#x2F;2</span><br><span class="line">        else if(key &lt; a(m)) then</span><br><span class="line">            ! 如果 key &lt; 中间值，那就落在前半段</span><br><span class="line">            r &#x3D; M -1</span><br><span class="line">            m &#x3D; (l+r)&#x2F;2</span><br><span class="line">        else if(key &#x3D;&#x3D;  a(m)) then</span><br><span class="line">            binary_search &#x3D; m</span><br><span class="line">            return</span><br><span class="line">        end if</span><br><span class="line">    end do</span><br><span class="line">    </span><br><span class="line">    !如果前面都没有找到，返回0</span><br><span class="line">    binary_search &#x3D; 0</span><br><span class="line">    return</span><br><span class="line">end function</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">Source=&gt;  <span class="number">2</span>  <span class="number">5</span>  <span class="number">7</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">13</span> <span class="number">17</span> <span class="number">21</span> <span class="number">23</span></span><br><span class="line"> Input Key:</span><br><span class="line"><span class="number">10</span></span><br><span class="line">A( <span class="number">5</span> )= <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h3 id="15-2-3-散列搜索（Hashing）">15-2-3 散列搜索（Hashing）</h3>
<p>这个算法光听名字实在是很难去想象它的作法。散列法的搜索效率很高，如果安排恰当，它几乎每次都只需要做一次对比操作，就可以判断数据是否存在。它主要的精力是放在如何安排数据在内存的位置。将数据安排好之后，搜索数据时只要计算它可能在内存的位置，直接与这个位置上的数据来做对比。</p>
<p>散列搜索法主要在于它的概念，并没有一定的实现方法。任何人都可以自行设计散列公式来计算数据要如何放在数组中。</p>
<p>直接来看一个实例，假如要在 {21,53,71,19,61,81,3,17,44,93} 这一组数字中搜索数据。首先要定义出一个散列公式来决定数据要如何安置。观察这一组数字后，可以发现它们的值域范围在0~100之间，所以可以声明一个大小为100的数组，而且可以使用最简单的方法来决定数据在 array 中的位置，就是直接把数值D放在 array(D) 中。用数学方法来解释这个散列函数，即为 <code>hash(D) = D</code>。</p>
<p>在搜索时，找到K值在数组中的位置，再比较 array(K)  的值是否等于 K 。如果相等就代表搜索成功，如果不相等就代表数据不存在。因此只要比对一次就能确定数据在不在。</p>
<p>程序实现如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">! 散列搜索法示例</span></span><br><span class="line"><span class="comment">! By Perng 1997/8/31</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> Hash_Search_Demo</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n = <span class="number">10</span> </span><br><span class="line">    <span class="keyword">integer</span> Source(n) <span class="comment">! 存放数据组的数组</span></span><br><span class="line">    <span class="keyword">integer</span> A(<span class="number">100</span>)    <span class="comment">! 存放 Hashing 后的数组</span></span><br><span class="line">    <span class="keyword">integer</span> key       <span class="comment">! 记录所要找的值</span></span><br><span class="line">    <span class="keyword">integer</span> i         <span class="comment">! 循环计数器</span></span><br><span class="line">    <span class="keyword">data</span> Source /<span class="number">21</span>,<span class="number">53</span>,<span class="number">71</span>,<span class="number">19</span>,<span class="number">61</span>,<span class="number">81</span>,<span class="number">3</span>,<span class="number">17</span>,<span class="number">44</span>,<span class="number">93</span>/</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source=&gt;&#x27;, 10i3)&quot;</span>) Source</span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;Input Key:&#x27;</span></span><br><span class="line">    read(*,*) key</span><br><span class="line">    <span class="keyword">if</span> (key &lt;<span class="number">0</span> .or. key&gt;<span class="number">100</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;Not found&quot;</span></span><br><span class="line">        <span class="keyword">stop</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 创建Hash 表格，表格中放的是数值在数组中的位置</span></span><br><span class="line">    A = <span class="number">0</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">        A(Source(i)) = i</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 在 Hash 表格中寻找数据</span></span><br><span class="line">    <span class="keyword">if</span>(A(key) /= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source(&#x27;,i2,&#x27; )=&#x27;,i3)&quot;</span>) A(key), key</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;Not found&quot;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的散列方法，使用大小为100的数组来存放10个数字。使用比较大的数组来存放数据会比较容易设计散列函数 hash(K)，比较不易发生当 a 不等于 b 时 hash(a) = hash(b) 的现象，可以得到比较好的搜索效率。（hash(a), hash(b) 指的是a,b 在数组中的位置，这个意思就是说不会出现两个不同的值执行同一个内存位置的情况）。</p>
<p>再来看一个新的散列方法，同样用上一个实例中的数据组来做搜索。上一个实例程序只使用了 10% 的数组空间，有 90% 是浪费掉的。这一次不会再浪费那么多内存空间，而是把散列的数据放在大小为10的数组来充方利用内存。散列函数必须重新设计，才能符合新的数组大小。</p>
<p>这一次可以定义 <code>hash(K) = K/10+1</code> ，也就是取出数字的10位数，再加上 1 来当做它在数组中的位置。不过这个方法会发生一个问题，因为<strong>它对不同数字很有可能算出同样的结果来</strong>，例如 hash(11) = hash(12) = 2 。对这个情况要做一些例外处理，可以加上一个条件：如果所要使用的位置已经被其他数字占据，就向后挪一步。</p>
<p>要搜索时，同样先由 L = hash(K) = K/10 + 1 来计算数据位置，但是如果 array(L) 不等于 K 时，并不代表 K 不存在，还要向后一个个来做检查，一直到全部数据都检查过为止。（这也太低效了吧）</p>
<p>实现程序如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">! 散列搜索法示例</span></span><br><span class="line"><span class="comment">! by perng 1997/8/31</span></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> hashing_search_demo</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n = <span class="number">10</span></span><br><span class="line">    <span class="keyword">integer</span> source(n) <span class="comment">! 存放数据组的数组</span></span><br><span class="line">    <span class="keyword">integer</span> a(n)      <span class="comment">! 存放hashing 后的数组</span></span><br><span class="line">    <span class="keyword">integer</span> key       </span><br><span class="line">    <span class="keyword">integer</span> i</span><br><span class="line">    <span class="keyword">integer</span> loc</span><br><span class="line">    <span class="keyword">data</span> Source /<span class="number">21</span>,<span class="number">53</span>,<span class="number">71</span>,<span class="number">19</span>,<span class="number">61</span>,<span class="number">81</span>,<span class="number">3</span>,<span class="number">17</span>,<span class="number">44</span>,<span class="number">93</span>/</span><br><span class="line">    <span class="keyword">integer</span> hash</span><br><span class="line">    hash(key) = key/<span class="number">10</span> + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source=&gt;&#x27;, 10i3)&quot;</span>) Source</span><br><span class="line">    </span><br><span class="line">    a=<span class="number">0</span></span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">        loc = hash(source(i))</span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">            <span class="keyword">if</span>(a(loc)==<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">                a(loc) = i</span><br><span class="line">                <span class="keyword">exit</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loc = loc + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span>(loc&gt;n) loc = <span class="number">1</span> <span class="comment">!如果loc超出最大值就设为1，再从头循环一遍，反正得放进去</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;Input Key:&#x27;</span></span><br><span class="line">    read(*,*) key</span><br><span class="line">    </span><br><span class="line">    loc = hash(key)</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">        <span class="keyword">if</span>(a(loc)==<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;Not found&quot;</span></span><br><span class="line">            <span class="keyword">exit</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (source(a(loc)) == key) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source(&#x27;,i2,&#x27; )=&#x27;,i3)&quot;</span>) a(loc), key</span><br><span class="line">            <span class="keyword">exit</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            loc = loc + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span>(loc&gt;n) loc = <span class="number">1</span> <span class="comment">!这就是10个数据全部检查一遍</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment">!注意，这里循环结束后，i是11，不是10。所以这里才判断 i&gt;n</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;n) <span class="built_in">write</span>(*,*) <span class="string">&quot;Not found&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里由一个细节，就是 do 循环之后，i 最终的结果是11，而不是10。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!注意，这里循环结束后，i是11，不是10。所以这里才判断 i&gt;n</span></span><br><span class="line"><span class="keyword">if</span>(i&gt;n) <span class="built_in">write</span>(*,*) <span class="string">&quot;Not found&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面这个方法不算是很有效率的方法。如果所要搜索的数据不存在，要扫描整个数组才能确认这个事实。这主要归咎于散列表格太小，而不是散列法的缺点。如果配合上串行结构来存放数据，可以得到比较好的效率。</p>
<p>现在来示例针对这个散列法所设计的串行结构。在这里使用同样的散列函数 hash(x) = x/10 + 1，hash(x) 的值在1~10之间，所以可以用 10个串行来保存所有数值。这个方法所创建的串行结构如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hash(x)&#x3D;1 的串行：&#x3D;&gt;3</span><br><span class="line">hash(x)&#x3D;2 的串行：&#x3D;&gt;19&#x3D;&gt;17</span><br><span class="line">hash(x)&#x3D;3 的串行：&#x3D;&gt;21</span><br><span class="line">hash(x)&#x3D;4 的串行：没有东西</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>搜索时只要在所属的串行中来搜索即可，不需要跨越到其他的串行中。不必等到扫描整个数据后，才能确认数据不存在。实现的程序如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> NumLink</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n =<span class="number">10</span></span><br><span class="line">    <span class="comment">! 声明制作串行的类型</span></span><br><span class="line">    <span class="keyword">type</span> :: link</span><br><span class="line">        <span class="keyword">integer</span> :: num               <span class="comment">! 保存数据组</span></span><br><span class="line">        <span class="keyword">type</span>(link), <span class="keyword">pointer</span> :: next  <span class="comment">! 指向下一个环结的指针</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">type</span>(link), <span class="keyword">target</span> :: linking(n) <span class="comment">! 保存hashing后的数据</span></span><br><span class="line">    <span class="keyword">type</span>(link), <span class="keyword">pointer</span> :: proc      <span class="comment">! 暂时使用的指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">integer</span> :: Source(n) = (/<span class="number">21</span>,<span class="number">53</span>,<span class="number">71</span>,<span class="number">19</span>,<span class="number">61</span>,<span class="number">81</span>,<span class="number">3</span>,<span class="number">17</span>,<span class="number">44</span>,<span class="number">93</span>/)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> InitLink()</span><br><span class="line">        <span class="keyword">integer</span> i</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">            linking(i) = link(<span class="number">0</span>,null())</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">! hash函数</span></span><br><span class="line">    <span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> hash(key)</span><br><span class="line">        <span class="keyword">integer</span> key</span><br><span class="line">        hash = key/<span class="number">10</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 把数字经过散列处理后放入串行的子程序</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Insert(key, info)</span><br><span class="line">        <span class="keyword">integer</span> :: key, info <span class="comment">! 所要插入的数字及在 Source中的位置</span></span><br><span class="line">        <span class="keyword">integer</span> :: L         <span class="comment">! hashing 后的结果</span></span><br><span class="line">        </span><br><span class="line">        L = hash(key)</span><br><span class="line">        proc=&gt;linking(L) <span class="comment">! 把proc指向数组linking中hash(L)的位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">! 移动到串行中的最后一个位置</span></span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(proc%num /= <span class="number">0</span>)</span><br><span class="line">            proc =&gt; proc%next</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        </span><br><span class="line">        proc%num = INFO</span><br><span class="line">        <span class="comment">! 配置内存空间给 proc%next</span></span><br><span class="line">        <span class="built_in">allocate</span>(proc%next)</span><br><span class="line">        proc =&gt; proc%next</span><br><span class="line">        proc%num = <span class="number">0</span></span><br><span class="line">        <span class="built_in">nullify</span>(proc%next)</span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 在串行中搜索数据的子程序</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> Hash_Search(key)</span><br><span class="line">        <span class="keyword">integer</span> :: key  <span class="comment">! 要搜索的值</span></span><br><span class="line">        <span class="keyword">integer</span> :: L    <span class="comment">! 计算hashing后的值</span></span><br><span class="line">        </span><br><span class="line">        L = hash(key)</span><br><span class="line">        proc =&gt; linking(L) <span class="comment">! 把proc指向数组linking中 hash(L)的位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">! 在这一个串行中一直向下顺序搜索到找到为止</span></span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">            <span class="keyword">if</span>(proc%num == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">write</span>(*,*) <span class="string">&quot;Not found&quot;</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line">            <span class="keyword">if</span>(Source(proc%num)==key) <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source(&#x27;,i2,&#x27; )=&#x27;,i3)&quot;</span>) proc%num, key</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">associated</span>(proc%next)) proc = proc%next</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 输出串行中数据的子程序</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> OutputLink()</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">            proc =&gt; linking(i)</span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(1x,i2,&#x27;:&#x27;)&quot;</span>, <span class="keyword">advance</span> = <span class="string">&quot;NO&quot;</span>) i</span><br><span class="line">            <span class="keyword">do</span> <span class="keyword">while</span>(<span class="built_in">associated</span>(proc%next))</span><br><span class="line">                <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;-&gt;&#x27;,i2)&quot;</span>, <span class="keyword">advance</span> = <span class="string">&quot;NO&quot;</span>) Source(proc%num)</span><br><span class="line">                proc =&gt; proc%next</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="comment">! ?</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="comment">! 散列搜索法举例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> hashing_search_demo</span><br><span class="line">    <span class="keyword">use</span> NumLink</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> :: key <span class="comment">! 记录要找的值</span></span><br><span class="line">    <span class="keyword">integer</span> :: i   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">call</span> InitLink()</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source=&gt;&#x27;,10i3)&quot;</span>) Source</span><br><span class="line">    <span class="keyword">do</span> i=<span class="number">1</span>,n</span><br><span class="line">        <span class="keyword">call</span> Insert(Source(i),i)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&quot;Link List=&gt;&quot;</span></span><br><span class="line">    <span class="keyword">call</span> OutputLink()</span><br><span class="line">    <span class="comment">! 读入要找的值</span></span><br><span class="line">    <span class="built_in">write</span>(*,*) <span class="string">&#x27;Input Key:&#x27;</span></span><br><span class="line">    read(*,*) key</span><br><span class="line">    <span class="comment">! 调用顺序搜索的子程序</span></span><br><span class="line">    <span class="keyword">call</span> Hash_Search(key)</span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Source&#x3D;&gt; 21 53 71 19 61 81  3 17 44 93</span><br><span class="line"> Link List&#x3D;&gt;</span><br><span class="line">  1:-&gt; 3  2:-&gt;19-&gt;17  3:-&gt;21  4:  5:-&gt;44  6:-&gt;53  7:-&gt;61  8:-&gt;71  9:-&gt;81 10:-&gt;93</span><br><span class="line"> Input Key:</span><br><span class="line">44</span><br><span class="line">Source( 9 )&#x3D; 44</span><br></pre></td></tr></table></figure>
<p>这个程序还没有仔细看，之后有时间再看一下。</p>
<h2 id="15-3-堆栈-Stack">15-3 堆栈 Stack</h2>
<p>&quot;堆栈&quot;的概念很简单，它可以解决许多程序设计的问题。堆栈是一种管理数据进、出内存的规则，这个规则就是：“越早得到的数据越晚输出，越晚得到的数据越早输出”</p>
<h3 id="15-3-1-堆栈的基本范例">15-3-1 堆栈的基本范例</h3>
<p>根据堆栈 “后到先进” 的策略，可以编写一个实例程序来把所输入的一连串数据反向输出。这个程序的目的只是用来实例堆栈的运行过程，真正应用的过程在下一个小节中才会介绍。</p>
<p>来看程序：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> stack_utility</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">private</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: top = <span class="number">50</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">save</span> :: current = <span class="number">0</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">save</span> :: stack(top)</span><br><span class="line">    <span class="keyword">public</span> push, pop</span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">! 把数据放入堆栈中</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> push(<span class="keyword">value</span>)</span><br><span class="line">        <span class="keyword">integer</span> <span class="keyword">value</span></span><br><span class="line">        <span class="keyword">if</span>(current&gt;top) <span class="keyword">then</span> <span class="comment">!超过容量</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;Stack full.&quot;</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        current = current + <span class="number">1</span></span><br><span class="line">        stack(current) = <span class="keyword">value</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    <span class="comment">! 从堆栈中取出数据</span></span><br><span class="line">    <span class="keyword">integer</span> <span class="function"><span class="keyword">function</span></span> pop(<span class="keyword">value</span>)</span><br><span class="line">        <span class="keyword">integer</span> <span class="keyword">value</span></span><br><span class="line">        <span class="keyword">if</span>(current&lt;=<span class="number">0</span>) <span class="keyword">then</span> <span class="comment">! 已经没有东西可以拿了</span></span><br><span class="line">            pop = <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">value</span> = stack(current)</span><br><span class="line">        current = current - <span class="number">1</span></span><br><span class="line">        pop = <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">    <span class="keyword">use</span> stack_utility</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: n = <span class="number">5</span></span><br><span class="line">    <span class="keyword">integer</span> :: a(n) = (/ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> /)</span><br><span class="line">    <span class="keyword">integer</span> i, stat, <span class="keyword">value</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;Source=&gt;&#x27;, 5i3)&quot;</span>) a</span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>,n</span><br><span class="line">        <span class="keyword">call</span> push(a(i))</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>,n</span><br><span class="line">        stat = pop(<span class="keyword">value</span>)</span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(i3)&quot;</span>, <span class="keyword">advance</span> = <span class="string">&quot;no&quot;</span>) <span class="keyword">value</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">write</span>(*,*)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Source&#x3D;&gt;  1  2  3  4  5</span><br><span class="line">  5  4  3  2  1</span><br></pre></td></tr></table></figure>
<p>这里堆栈数据实际上存放在数组 stack 中，变量 current 用来记录目前堆栈保存情况。这些数据被设置成私有的数据，外部数据不能直接访问它们（但是在module 内部一直在记录 current 的变化）。整个模块中，只有 push 和 pop 这两个函数是对外开发的使用接口。</p>
<p>调用 push 可以把数据放在堆栈的最顶端；调用 pop 则可以从堆栈的最顶端取出一条数据。push 和 pop 都不能无限制调用，当 stack 数组用完时，就不能再 push 数据。而堆栈没有数据时，就不能再调用 pop。</p>
<h3 id="15-3-2-堆栈的应用-骑士走棋盘">15-3-2 堆栈的应用 - 骑士走棋盘</h3>
<p>略</p>
<h2 id="15-4-树状结构">15-4 树状结构</h2>
<p>第10章介绍指针时，已经示范过串行结构的使用，指针还经常使用在另外一种称为树状结构的数据结构。被称为树状结构的原因在于，树状结构的链接情况换成图形时，会出现如同树枝状的结构来。</p>
<p>本节介绍二叉树的应用（<strong>二叉树指每一层的分枝都是两个枝干</strong>）。在这里示范应用二叉树来做排序及搜索的方法，二叉树的创建格式为，<strong>左枝所保存的数值，永远都小于跟它对称的右枝所保存的数值</strong>。以这种方式所创建的二叉树，可以很容易地来做数据搜索。从最上端开始来对比，如果要寻找的数据大于目前的树枝中所保存的数值，那么数据一定是落在右枝。如果是小于的话，那就是落在左枝。以这个方法可以很快速地由上而下寻找数据。</p>
<p>二叉树创建后，数据也等于完成“排序” 工作。经过特定的规则来取出二叉树数据，就可以达到排序的效果。以这个例子来看，只要先取出较小，而且较左边枝干中所保存的数值，就可以把数据由小到大来排序。</p>
<p>现在就来实现一个建构二叉树的实例，这个实例示例了如何使用二叉树来记录数据，并且同时完成排序。程序代码有点长，建议读者先翻到后面的程序说明解说部分来阅读，再回过头来看整个程序。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">! 二叉树排序范例</span></span><br><span class="line"><span class="keyword">module</span> typedef </span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">type</span> :: <span class="keyword">data</span></span><br><span class="line">        <span class="keyword">integer</span> :: n      <span class="comment">! 存放的数据</span></span><br><span class="line">        <span class="keyword">integer</span> :: <span class="built_in">repeat</span> <span class="comment">! 数据重复的次数</span></span><br><span class="line">        <span class="keyword">type</span>(<span class="keyword">data</span>), <span class="keyword">pointer</span> :: left  <span class="comment">! 左枝</span></span><br><span class="line">        <span class="keyword">type</span>(<span class="keyword">data</span>), <span class="keyword">pointer</span> :: right <span class="comment">! 右枝</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> bin_tree</span><br><span class="line">    <span class="keyword">use</span> typedef</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">private</span></span><br><span class="line">    <span class="keyword">type</span>(<span class="keyword">data</span>), <span class="keyword">pointer</span> :: tree, <span class="keyword">action</span></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">save</span> :: numbers = <span class="number">0</span></span><br><span class="line">    <span class="keyword">public</span> add, TraceTree</span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line">    <span class="comment">! 新加入一条数据</span></span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> add(n)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">integer</span>, <span class="keyword">intent</span>(<span class="keyword">in</span>) :: n</span><br><span class="line">        <span class="keyword">integer</span> :: err</span><br><span class="line">        <span class="keyword">type</span>(<span class="keyword">data</span>), <span class="keyword">pointer</span> :: new</span><br><span class="line">        <span class="keyword">integer</span> :: level</span><br><span class="line">        level = <span class="number">1</span></span><br><span class="line">        numbers = numbers+<span class="number">1</span></span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(1x,a5,i4,a8)&quot;</span>) <span class="string">&quot;Get :&quot;</span>,numbers,<span class="string">&quot; numbers&quot;</span></span><br><span class="line">        <span class="comment">! 配置一块新的空间</span></span><br><span class="line">        <span class="built_in">allocate</span>(new, stat=err)</span><br><span class="line">        <span class="keyword">if</span>(err/=<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) <span class="string">&quot;Out of memory!&quot;</span></span><br><span class="line">            <span class="keyword">stop</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;root &#x27;)&quot;</span>, <span class="keyword">advance</span> = <span class="string">&quot;no&quot;</span>)</span><br><span class="line">        <span class="comment">! 设置数据</span></span><br><span class="line">        new%<span class="built_in">repeat</span> = <span class="number">1</span></span><br><span class="line">        new%n = n</span><br><span class="line">        <span class="built_in">nullify</span>(new%right, new%left)</span><br><span class="line">        <span class="comment">! 如果是第一条数据</span></span><br><span class="line">        <span class="keyword">if</span>(numbers==<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">action</span> =&gt; new</span><br><span class="line">            tree =&gt; new</span><br><span class="line">            <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;: new&#x27;)&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">action</span> =&gt; tree</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">            level = level + <span class="number">1</span></span><br><span class="line">            <span class="comment">! 数据大于目前的枝干的数值时</span></span><br><span class="line">            <span class="keyword">if</span>(n&gt;<span class="keyword">action</span>%n) <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">associated</span>(<span class="keyword">action</span>%right)) <span class="keyword">then</span></span><br><span class="line">                    <span class="keyword">action</span> =&gt; <span class="keyword">action</span>%right <span class="comment">! 再向右去寻找立身处</span></span><br><span class="line">                    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;-&gt;R&#x27;)&quot;</span>, <span class="keyword">advance</span> = <span class="string">&quot;no&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">action</span>%right =&gt; new <span class="comment">!创建新的右枝</span></span><br><span class="line">                    <span class="keyword">action</span> =&gt; new</span><br><span class="line">                    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;-&gt;R: new&#x27;)&quot;</span>)</span><br><span class="line">                    <span class="keyword">exit</span> </span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">            <span class="comment">! 数据小于目前枝干的数值时</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n&lt;<span class="keyword">action</span>%n) <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">associated</span>(<span class="keyword">action</span>%left)) <span class="keyword">then</span></span><br><span class="line">                    <span class="keyword">action</span> =&gt; <span class="keyword">action</span>%left <span class="comment">! 再向左去寻找立身处</span></span><br><span class="line">                    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;-&gt;L&#x27;)&quot;</span>, <span class="keyword">advance</span> = <span class="string">&quot;no&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">action</span>%left =&gt; new <span class="comment">!创建新的左枝</span></span><br><span class="line">                    <span class="keyword">action</span> =&gt; new</span><br><span class="line">                    <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;-&gt;L: new&#x27;)&quot;</span>)</span><br><span class="line">                    <span class="keyword">exit</span> </span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">            <span class="comment">! 数据等于目前枝干的数值时</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="keyword">action</span>%n) <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">action</span>%<span class="built_in">repeat</span> = <span class="keyword">action</span>%<span class="built_in">repeat</span> + <span class="number">1</span> <span class="comment">! 把重复的数目加1</span></span><br><span class="line">                <span class="built_in">deallocate</span>(new) <span class="comment">! 可以不需要找个新的空间</span></span><br><span class="line">                <span class="built_in">write</span>(*, <span class="string">&quot;(&#x27;: Repeat&#x27;)&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span> </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> add</span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 显示排序的数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> TraceTree()</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">call</span> show_tree(tree)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 排序数据的子程序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">recursive</span> <span class="function"><span class="keyword">subroutine</span></span> show_tree(show)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(<span class="keyword">data</span>), <span class="keyword">pointer</span> :: show</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">associated</span>(show)) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">call</span> show_tree(show%left) <span class="comment">! 先取出左枝的数据</span></span><br><span class="line">            <span class="keyword">call</span> show_data(show) <span class="comment">! 再取出目前位置的数据</span></span><br><span class="line">            <span class="keyword">call</span> show_tree(show%right) <span class="comment">! 最后才取出右枝的数据</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">! 显示这个枝干所保存的数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> show_data(show)</span><br><span class="line">        <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">type</span>(<span class="keyword">data</span>), <span class="keyword">pointer</span> :: show</span><br><span class="line">        <span class="keyword">integer</span> :: i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> i=<span class="number">1</span>, show%<span class="built_in">repeat</span></span><br><span class="line">            <span class="built_in">write</span>(*,*) show%n</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span> bin_tree</span><br><span class="line"></span><br><span class="line"><span class="comment">! 主程序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> main </span><br><span class="line">    <span class="keyword">use</span> bin_tree</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">integer</span> num </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">while</span>(.true.)</span><br><span class="line">        <span class="built_in">write</span>(*,*) <span class="string">&quot;请输入整数，输入0代表结束&quot;</span></span><br><span class="line">        read(*,*) num</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>) <span class="keyword">exit</span></span><br><span class="line">        <span class="keyword">call</span> add(num)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">call</span> TraceTree()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> 请输入整数，输入<span class="number">0</span>代表结束</span><br><span class="line"><span class="number">4</span></span><br><span class="line"> Get :   <span class="number">1</span> numbers</span><br><span class="line">root : new</span><br><span class="line"> 请输入整数，输入<span class="number">0</span>代表结束</span><br><span class="line"><span class="number">6</span></span><br><span class="line"> Get :   <span class="number">2</span> numbers</span><br><span class="line">root -&gt;R: new</span><br><span class="line"> 请输入整数，输入<span class="number">0</span>代表结束</span><br><span class="line"><span class="number">2</span></span><br><span class="line"> Get :   <span class="number">3</span> numbers</span><br><span class="line">root -&gt;L: new</span><br><span class="line"> 请输入整数，输入<span class="number">0</span>代表结束</span><br><span class="line"><span class="number">7</span></span><br><span class="line"> Get :   <span class="number">4</span> numbers</span><br><span class="line">root -&gt;R-&gt;R: new</span><br><span class="line"> 请输入整数，输入<span class="number">0</span>代表结束</span><br><span class="line"><span class="number">3</span></span><br><span class="line"> Get :   <span class="number">5</span> numbers</span><br><span class="line">root -&gt;L-&gt;R: new</span><br><span class="line"> 请输入整数，输入<span class="number">0</span>代表结束</span><br><span class="line"><span class="number">5</span></span><br><span class="line"> Get :   <span class="number">6</span> numbers</span><br><span class="line">root -&gt;R-&gt;L: new</span><br><span class="line"> 请输入整数，输入<span class="number">0</span>代表结束</span><br><span class="line"><span class="number">1</span></span><br><span class="line"> Get :   <span class="number">7</span> numbers</span><br><span class="line">root -&gt;L-&gt;L: new</span><br><span class="line"> 请输入整数，输入<span class="number">0</span>代表结束</span><br><span class="line"><span class="number">0</span></span><br><span class="line">           <span class="number">1</span></span><br><span class="line">           <span class="number">2</span></span><br><span class="line">           <span class="number">3</span></span><br><span class="line">           <span class="number">4</span></span><br><span class="line">           <span class="number">5</span></span><br><span class="line">           <span class="number">6</span></span><br><span class="line">           <span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个程序可以让用户输入一组整数，程序执行时还会同时显示树枝的“生长”情况。输入数字0会结束数据的输入，并把所输入的整数数列由小到大来输出。</p>
<p>程序使用二叉树来保存、同时排序所输入的数据。假如输入了下面的整数数列 [4,6,2,7,3,5,1]。输入第一个数字时，二叉树只有“根”的部分存在，所以整数4会放在二叉树的树根部分。输入第2个数字时，会去比较二叉树树根所保存的数值，如果结果是“大于”，就会向右边生成一根新的树干，并保存这个新的数值；如果结果是“小于”，则会向左边开发。程序会一直重复这个操作，生长处越来越密的枝干，而比较的层次也会一层层地向越小地枝干延申下去。</p>
<p>后面的解析和代码还没仔细看，以后再看。</p>
<h1>16 IMSL 函数库</h1>
<p>数值方法中常遇到的问题，有专门的链接库可以使用。IMSL 是一套在数值方法上经常被使用的商业链接库。</p>
<p><strong>有现成的函数可以使用，不代表程序员不需要学习自行编写数值方法程序的技巧。因为只有了解这些算法的真正运行过程，才能适当地去使用它们。</strong></p>
<p>IMSL 的函数名称中，第1个字母可以用来判断参数的类型。如果第1个字母是D，会使用双精度浮点数来计算并返回答案。第一个字母不是D，则使用单精度浮点数。</p>
<p>因为 IMSL 的函数太多了，在这一章中不会完整介绍所有函数的详细用法。本书会介绍处理线性系统、非线性系统、微积分、微分方程、插值时会使用到的基本功能。</p>
<p>略。</p>
<h1>17 附录</h1>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>Fortran</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>Fortran</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归与R代码实现</title>
    <url>/posts/6cb58071/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>线性回归是最基础的统计模型，也应该是应用最广泛的应用模型。线性回归的因变量必须为连续变量；自变量可以为连续变量，也可以为分类变量（转化为哑变量/虚拟变量）</p>
<p>这里是我通过看资料对线性回归的总结。</p>
<span id="more"></span>
<h1>参考资料</h1>
<p><a href="https://www.statlearning.com/">An Introduction to Statistical Learning</a>，下文简称 <strong>ISL</strong></p>
<h1>线性回归的假设</h1>
<h2 id="1-自变量和因变量线性相关">1 自变量和因变量线性相关</h2>
<p>线性相关的意思是，无论自变量多大，自变量每增加一个单位，因变量都会产生固定的变化。</p>
<h2 id="2-多个自变量之间具有可加性">2 多个自变量之间具有可加性</h2>
<p>无论 X1 多大，X2 每增加一个单位，因变量都会产生固定的变化。如果满足这个条件，说明 X1和X2 之间具有可加性。否则说明 X1 和 X2 之间存在<strong>互作</strong>效应。用图表示如下（左图两条线平行说明不存在互作，右图不平行说明存在互作）：</p>
<p><img src="12.png" alt="1"></p>
<h2 id="3-多个自变量之间彼此独立">3 多个自变量之间彼此独立</h2>
<p>多个自变量之间不能存在<strong>相关</strong>关系。相关关系分为两种，一种是简单的两两之间的相关，这个通过相关系数矩阵就能看出来是否存在两个变量之间的明显的相关（看绝对值）；第二种是多重线性相关（Multicollinearity），例如 X1 = a + bX2 + cX3，一个自变量可以用其他的多个自变量来解释，就说明存在多重线性相关。</p>
<h2 id="4-观测值的误差项之间互相独立">4 观测值的误差项之间互相独立</h2>
<p>误差项即实际值 - 预测值。如果观测值之间存在我们没有添加到模型中的其他影响因素，那么误差项之间就可能存在相关关系，比如有些样本搜集自同一个家庭的成员，而我们没有把家庭这个因素加入到模型中。</p>
<h2 id="5-误差项（ε）呈正态分布，期望为0，方差为定值">5 误差项（ε）呈正态分布，期望为0，方差为定值</h2>
<blockquote>
<p>这里其实分为两个假设。第一个假设：误差项服从均值为0的正态分布。第二个假设：误差项的方差为定值（不变）。这两个假设是为了保证回归模型在小样本下能够顺利进行假设检验。正态分布假设仅在小样本的情况下需要，大样本的情况下则不需要，因为有中心极限定理做正态性的支撑。而方差齐性则保证最小二乘法估计出来的统计量具有最小的方差。如果违反了这个假设，置信区间会变宽，这称之为<strong>异方差性（heteroscedasticity）</strong>。当异方差性出现的时候，如果仍采用最小二乘法估计参数，会导致参数的t检验值被高估，可能造成本来不显著的某些参数变为显著，使假设检验失去意义。</p>
<p><a href="https://www.cnblogs.com/HuZihu/p/10142737.html">https://www.cnblogs.com/HuZihu/p/10142737.html</a></p>
</blockquote>
<h2 id="6-自变量和误差项之间互相独立">6 自变量和误差项之间互相独立</h2>
<blockquote>
<p>模型中一个或多个自变量与随机误差项存在相关关系，这称之为<strong>内生性（endogeneity）</strong>。内生性通常由于遗漏变量而导致的，因此是一个普遍存在的问题。内生性会导致模型参数估计不准确。</p>
<p><a href="https://www.cnblogs.com/HuZihu/p/10142737.html">https://www.cnblogs.com/HuZihu/p/10142737.html</a></p>
</blockquote>
<h1>简单线性回归</h1>
<h2 id="β0-β1-参数估计-最小二乘法">β0, β1 参数估计 - 最小二乘法</h2>
<p>最小二乘的思路是，查找使得<strong>误差平方和</strong>或<strong>均方误差</strong>最小的参数。</p>
<p>我们首先知道，<strong>误差 = 实际值 - 预测值</strong>，我们的目的实际是想要所有观察值的总体的误差最小，因为误差有正有负，如果采用误差项直接相加会互相抵消，因为我们采用误差的平方进行相加，得到误差平方和 (<abbr title="residual sum of squares">RSS</abbr>)。</p>
<p><img src="1.png" alt="1"></p>
<p>或者写成</p>
<p><img src="2.png" alt="1"></p>
<p>除以总共的样本数 n，便得到<abbr title="mean square error, MSE"><strong>均方误差</strong></abbr>，使得 RSS/MSE 最小的参数便是最小二乘的最优解。写成公式如下（缺推导过程）：</p>
<p><img src="3.png" alt="1"></p>
<p>画成等高图如下（作图横纵坐标为β0和β1，图中一圈表示相同的RSS，数字即为 RSS 大小），我们可以看到这是向下凹的图形，只有一个点RSS 最小。</p>
<p><img src="4.png" alt="1"></p>
<h3 id="为什么不用残差的绝对值？">为什么不用残差的绝对值？</h3>
<p>我上统计课的时候就有这个问题，就一直有这个疑问，如果因为残差有方向，不能直接求和，那为什么不直接用绝对值呢？这不是更直接的更贴近残差本质的思路吗？</p>
<p>后来上了吴恩达老师的机器学习课，知道了代价函数的概念，寻找代价函数最小值的最简单的方法就是<strong>求导</strong>。最小二乘法的代价函数就是 RSS/MSE，由于这里采用平方和（二次函数），<strong>求导会直接变成一次函数</strong>。而如果使用残差的绝对值的和，根本无法进行简单的求导，就无法简单地得到最优解的公式。</p>
<p>所以，目前我个人的理解是使用平方和<strong>简化了运算</strong>。</p>
<h2 id="参数估计准确性">参数估计准确性</h2>
<p>我们使用的模型为</p>
<p><img src="5.png" alt="1"></p>
<p>这里的<strong>残差项包含了所有我们模型中没有考虑到的地方</strong>，比如Y 和 X 的关系不是线性的，还有其他的影响因素，存在测量误差等等。</p>
<p>为了估计参数的估计值与真实值之间的误差，我们需要计算两个参数估计值的标准误，使用下列公式（缺证明）</p>
<p><img src="6.png" alt="1"></p>
<p>这里 σ2 是残差方差，是未知的。残差标准差 σ 可以用 RSE (residual standard error) 来估计（缺证明）。</p>
<p><img src="7.png" alt="1"></p>
<p>知道了标准误，我们可以计算<strong>β0、β1的置信区间</strong>，例如 β1 的 95%的置信区间为：</p>
<p><img src="8.png" alt="1"></p>
<p>如果  β1 的 95%的置信区间 <strong>包含 0</strong>，那说明不能拒绝  β1  = 0 的原假设，我们认为不存在线性相关。</p>
<p>我们也可以通过 t 检验得到 P值。构建 t 统计量如下（自由度 n-2）：</p>
<p><img src="9.png" alt="1"></p>
<p>同理可以检验β0 估计值的P值（零假设：β0 = 0），但实际上截距的显著性没啥大的意义，主要还是看 β1。如果  β1 的 P值小于 0.05，我们认为  β1 ≠ 0。</p>
<h2 id="模型准确性">模型准确性</h2>
<p>上面是得到估计的两个参数的准确性，这里我们想知道，我们构建的简单线性模型与数据的契合程度（<em>which the model fits the data</em>）。</p>
<p>线性模型一般用两个指标， <em>residual standard error</em>(RSE) 和 R<sup>2</sup> 。</p>
<h3 id="RSE">RSE</h3>
<p><img src="7.png" alt="1"></p>
<p>RSE 是<strong>残差的标准误的估计值</strong>，它表示<strong>预测值与真实值的平均偏差量</strong>（这句话需要理解标准误的概念：标准误是样本统计量的标准差，均值为真值，结合标准差的公式，可知标准误就是预测值与真实值的平均偏差量（绝对值），所以一般提供参数估计值的时候，都会写成 参数估计值±<strong>标准误</strong>的形式）。</p>
<p>RSE 是最直接说明模型准确性的统计量，它的缺点是有单位，是一个绝对值，仅仅是RSE你不知道到底是大还是小，所以你还得和因变量的均值啥的进行比较才知道相对大小。</p>
<h3 id="R-sup-2-sup">R<sup>2</sup></h3>
<p>R<sup>2</sup> 指的是因变量方差能够被线性模型解释的比例，始终在0和1之间，是一个相对值，越大越好。公式如下：</p>
<p><img src="10.png" alt="1"></p>
<p>其中<abbr title="total sum of squares">TSS</abbr> 计算如下，表示因变量的总的方差。</p>
<p><img src="11.png" alt="1"></p>
<p>R<sup>2</sup> 比 RSE 更容易解释，因此更常用，但是还是面临一个问题，<strong>R<sup>2</sup> 多大才算结果很好呢？<strong>这可能得根据实际情况来定，在我们一般的实验中，实际上往往还有很多</strong>未测量的影响因素</strong>，所以 RSS 可能比较大，这时可能 R<sup>2</sup> 哪怕比较小可能也说明有用。</p>
<h1>多重线性回归</h1>
<p>简单线性回归只有一个自变量，但在实际情况中，我们往往有多个自变量（即生活中其实几乎不存在简单线性回归的应用场景）。例如，如果我们有三个影响因素，我们如何同时分析这三个影响因素呢？</p>
<p>一种思路是我们分别做上次简单的线性回归，但是这种思路无法令人满意。首先，如果给定一组三个自变量的值，我们无法给出因变量的预测值；其次，每一次简单回归都忽视了其他两个影响因素的作用，这可能会带来严重的误判。更好的解决思路是同时将多个自变量均放到线性回归的模型中。</p>
<p>ISL 书中提到了一个例子，销量和三种媒体预算的回归分析。在简单线性回归下，报纸的作用是显著的，如下图。</p>
<p><img src="13.png" alt="1"></p>
<p>但是，同时考虑三种媒体后，报纸的P值是不显著的。这说明简单线性回归和多重线性回归的结果是不一样的。这种差距的出现的原因是，简单回归得到的<strong>斜率</strong>是不考虑其他因素（TV 和 radio）下得到的，而多重回归得到的<strong>斜率</strong>是<strong>保持 TV 和 radio 固定不变</strong>的基础上计算得到的。</p>
<p><img src="14.png" alt="1"></p>
<p>这种情况说明了什么呢，说明这三个自变量之间并不是互相独立的，通过下面的相关矩阵我们可以看到，radio 和 newspaper 的相关系数为0.35，表示当投资人在 radio advertising 花更多的钱的同时，存在一种趋势在 newspaper advertising 上也花更多的钱。因此，我们对 newspaper 进行简单回归时得到的显著性，<strong>实际不是 newspaper 的作用，而是 radio 因素的作用</strong>。</p>
<p>这样的例子实际上比比皆是。ISL 提了一个离谱的例子来说明这一点。如果我们计算<strong>沙滩冰淇淋销量</strong>对<strong>鲨鱼伤人事件的数量</strong>求回归，我们应该能得到一个正向的关系，类似于上面的 newpaper 的例子。但是这实际是很荒谬的，这两个事件不存在因果关系，<strong>你无法通过禁止销售冰淇淋来减少鲨鱼伤人的事件</strong>。实际上是高温天气促使了人们去海边，从而导致更多的冰淇淋销量和鲨鱼伤人事件。<strong>如果你同时考虑冰淇淋销量和天气，对鲨鱼伤人事件做多重回归，你就会发现冰淇淋销量不再是一个显著的影响因素</strong>。</p>
<h2 id="决定重要的影响因素">决定重要的影响因素</h2>
<p>当我们有多个影响因素时，很有可能所有的影响因素都和因变量是有联系的，但是因变量可能仅仅是由其中的一小部分自变量决定的（相关不等于因果，比如上面的冰淇淋销量的例子）。我们把如何挑选自变量的过程称为 <em>variable selection</em>。</p>
<p>理想情况下，我们可以通过<strong>穷举</strong>所有的模型，每种模型均包含一部分的自变量。通过对比所有模型的表现，我们就可以得到最佳的自变量的集合。例如假如我们手上总共有2个可选的自变量X1 X2，那么总共就有4种可能的模型，（1）不包含任何自变量 ；（2）包含X1 ；（3）包含X2；（4）包含X1和X2。但是我们用什么指标来判断不同模型的优劣呢？<strong>这里有很多的判定模型优劣的统计量，比如<abbr title="Akaike information criterion">AIC</abbr>， <abbr title="Bayesian information criterion">BIC</abbr>  , 校正后R<sup>2</sup> 等。</strong></p>
<h3 id="为什么使用校正后的R-sup-2-sup">为什么使用校正后的R<sup>2</sup></h3>
<p>我们看R<sup>2</sup> 的计算公式，可以看到 TSS 是固定值。如果你增加了变量后（比如原来只包含X1，到包含X1和X2），<strong>残差平方和只会减少</strong>（这就是overfitting的原理，哪怕仅仅是增加了无关变量，也会造成与本次数据的拟合程度“变好”）。这导致增加了变量后，R<sup>2</sup>只会进一步增加。</p>
<p><img src="10.png" alt="1"></p>
<p>校正后的R<sup>2</sup>的公式如下，考虑了自变量个数的影响。可以看到，校正后的R<sup>2</sup> 随着自变量个数的增加而降低，并且始终低于未校正的R<sup>2</sup>。</p>
<p><img src="15.png" alt="1"></p>
<p>ISL 还提到了了使用 RSE 来校正自变量个数的影响。</p>
<p><img src="7.png" alt="1"></p>
<h3 id="三种经典的挑选变量的思路">三种经典的挑选变量的思路</h3>
<ul>
<li><em>Forward selection</em>:  先从<em>null model</em> (没有任何变量的模型)出发，对所有的候选因素（假设 <em>p</em> 个）各做一次简单回归，然后挑选结果中 RSS 最低的变量加入到模型中。然后我们将剩下的 <em>p</em>-1 个候选因素，挨个加入到目前的模型中，再挑选结果中 RSS 最低的变量加入到模型中。一直循环下去，知道达到了某个终止条件。</li>
<li><em>Backward selection</em>:  首先将所有的变量均加入到模型中，然后移除其中 P值最大的变量，我们就得到了一个 <em>p</em>-1个变量的模型。循环往复直到达到终止条件（比如所有剩下的变量的P值均低于某个值）。</li>
<li><em>Mixed selection</em>: 结合了上述的两个方法，我们先从空的模型出发，就像第一种方法的示例，不停地往里加变量，直到最佳。在加变量的过程中，我们观察有没有变量的P值变大并且超出了我们设定的阈值，如果存在这种现象，我们就从模型中移除这个变量（backward）。我们一直重复这种添加变量和删除变量的操作，直到最终实现<strong>所有剩下的变量的P值均很低，所有剔除的变量只要加入到模型中就会有一个很大的P值</strong>。</li>
</ul>
<p>如果变量的个数超过了记录数，那么我们无法用 <em>Backward selection</em> (因为将所有变量均加入到模型中，会发生<a href="https://zh.wikipedia.org/wiki/%E7%BB%B4%E6%95%B0%E7%81%BE%E9%9A%BE">维数灾难</a>)，此时 <em>Forward selection</em> 是可用的。但是<strong><em>Forward selection</em> 是一种贪婪算法</strong>，早期加入的变量可能是多余的，而  <em>Mixed selection</em> 算法修正了这一点。</p>
<h2 id="变量之间是否存在互作">变量之间是否存在互作</h2>
<p>还是采用上面三种媒介的例子，我们已经确定了 newpaper 没有作用， TV  和 radio 对 sales 有作用，那是不是模型就是下面的形式呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Y &#x3D; β0 + β1*TV + β2*radio + e</span><br></pre></td></tr></table></figure>
<p>我们可以通过这个模型画出一个三维图，图中的平面为预测值。我们可以看到当主要的钱都投向一种媒体时，销量会低于预测值；而如果我们均衡投资这两种媒体，销量会高于预测值（虽然我没有很好的看懂这个三维图）。这说明<strong>TV 和 radio 这两个因素之间存在互作。</strong></p>
<p><img src="16.png" alt="1"></p>
<h2 id="预测的不确定性">预测的不确定性</h2>
<p>一旦我们得到了最终的多重线性回归模型，我们就可以基于一套自变量的值来预测反应变量的值。但是，我们所做的预测至少存在三种不确定性。</p>
<ol>
<li>
<p>我们得到的仅仅是 β0, β1, β2……等参数的估计值。这些参数的估计值与真实值存在差距，这种差距是<strong>可消除误差(<em>reducible error</em>)</strong> 的一种。我们统计计算一个 <em><strong>confidence interval</strong></em> 来决定估计参数得到的预测值与真实参数得到的预测值的差距。</p>
</li>
<li>
<p>第二种不确定性是由于线性模型仅仅是对实际数据的一个近似，这种带来的错误我们称之为<em><strong>model bias</strong></em> 。</p>
</li>
<li>
<p>即使我们知道真实的模型 f(x)（我们知道所有参数的真实值），我们也不能完全精确地预测因变量，因为还存在<strong>随机误差(<em>random error</em>)</strong>，这种属于<strong>不可消除误差(<em>irreducible error</em>)</strong>。真实模型的预测值与真实值之间的差距，用<em><strong>prediction intervals</strong></em> 来评价。<em>prediction intervals</em> 通常比 <em>confidence intervals</em> 更宽， 因为 <em>prediction intervals</em> 不仅包括了可消除误差，也包含了不可预测误差（ <em>prediction intervals</em> 包含了 <em>confidence interval</em> ）。下面这段话解释地更明确一点：</p>
<p><img src="27.png" alt="1"></p>
</li>
</ol>
<h1>线性回归潜在的问题</h1>
<h2 id="1-自变量与因变量之间为非线性关系">1 自变量与因变量之间为非线性关系</h2>
<p>线性回归假设因变量与自变量之间存在直接的线性关系。如果因变量与自变量之间不是线性关系，那么线性回归的准确性会显著降低。</p>
<p>我们一般通过<strong>残差图</strong>来确定非线性关系。如果是简单线性回归，横坐标可以是自变量X，纵坐标是残差e；但是如果是多重线性回归，由于存在多个自变量，横坐标改为因变量的预测值。</p>
<p>下边左图为简单线性回归的残差图，可以看到残差不是均匀地分布在均值为0这条线地上下两侧，说明存在非线性关系。右图通过<strong>多项式回归</strong>，残差图的结果变好了很多，虽然看上去还是有一点非随机分布。</p>
<p><img src="17.png" alt="1"></p>
<h2 id="2-残差项的相关">2 残差项的相关</h2>
<p>线性回归的一个重要的假设是残差项，e<sub>1</sub>,e<sub>2</sub>,e<sub>3</sub>…… e<sub>n</sub> 之间是不相关的。这句话的含义是，如果残差项是不相关的，那么某一个残差项的值不受其他残差项的影响。ISL 原文如下：</p>
<blockquote>
<p>For instance, if the errors are uncorrelated, then the fact that ε<sub>i</sub> is positive provides little or no information about the sign of ε<sub>i+1</sub>.</p>
</blockquote>
<p>预测参数或预测值的<strong>标准误</strong>都是基于残差不相关的假设计算得到的。<strong>如果实际上残差项之间存在相关，那么标准误倾向于被低估</strong>（缺解释），因此置信区间也会比正常情况下更窄，因此 p值会更低，容易出现<strong>假阳性</strong>。</p>
<p>下面这段话举了个例子，但是我没理解。这里假如我们不小心把数据重复了一遍（本来是n条数据，现在是2n条数据），参数估计的置信区间会缩减 √2 。</p>
<p><img src="18.png" alt="1"></p>
<p>**什么时候会出现残差项的相关？**这种情况频繁出现在 <em>time series</em> 数据，也有在不同的时间点去观测得到的数据。在很多情况下，相邻时间观测到的记录之间会有正相关的残差项。为了确定这种情况，我们可以画一个横坐标是时间的残差图，如果残差项之间是不相关的，你就不会观测到明显的模式（残差应该是忽上忽下）；相反，如果残差项之间是正相反的，你可以会发现相邻时间的残差会倾向于有相似的值。</p>
<p>下图就体现了这一点，最上面是没有残差相关的图，越往下残差相关越高，我们可以看到很清晰的模式 - 相邻的点之间倾向于有相似的值。</p>
<p><img src="19.png" alt="1"></p>
<p>除了  <em>time series</em> 数据以外，其他数据也可能出现残差相关。举个例子，假设我们有一个研究通过体重去预测一个人的身高。如果有一些研究个体来自于相同的家庭，或吃相同的饮食，又或者面临某些相同的环境因素，那么残差不相关的假设就可能被打破。</p>
<p>一般来说，<strong>残差不相关</strong>的假设对于线性回归和其他统计方法是非常重要的。<strong>良好的实验设计</strong>对于减少残差不相关的风险至关重要。</p>
<h3 id="为什么会出现残差相关？">为什么会出现残差相关？</h3>
<p>因为<strong>残差是个筐，啥都往里装</strong>。我们的模型中所有没有考虑到的影响因素都会包含在这个残差里。实际上我们的模型不可能包含所有的影响因素，我们也不可能收集到所有影响因素的数据，所以我感觉残差相关是不可能完全避免的，或多或少有一点，只要不是很严重。</p>
<p>所以<strong>实验设计</strong>很重要，你要事先把重要的影响因素考虑到，而且把这些数据收集到。如果没有收集到相应的数据，貌似都无法发现残差相关，比如上面的 <em>time series</em> 数据，如果你没有搜集每个数据的时间信息，你都没法画上面的残差图。你不知道就等于没有了。</p>
<h2 id="3-残差方差不齐性">3 残差方差不齐性</h2>
<p>线性回归的另一个重要的假设是所有残差项均有一个固定的方差。我们计算标准误、置信区间等都依赖于这个假设。</p>
<p>但不幸地是，残差项的方差不是固定的，才是通常的情况。比如，残差方差可能会随着因变量值的提高而提高。我们可以通过残差图来发现这一点，比如下图的左图。<strong>当面临这种情况时，一个可能的解决思路是将反应变量Y 转换为 log(Y)  或 √Y</strong> ，这两个函数对于较大的值都会有一个很好的收缩效应，从而导致方差不齐性的改善。下图的右图就展示了转换后的残差图，我们可以看到方差不齐性的结果大大改善了（残差的宽度都差不多了），但是存在轻微的非线性关系。</p>
<p><img src="20.png" alt="1"></p>
<h2 id="4-Outliers">4 Outliers</h2>
<p><strong>Outliers 的定义是这个点的真实值与预测值偏差很大</strong>。Outliers 出现的原因有很多，比如错误记录。</p>
<p>下图中的红点（观测值为20）就是一个典型的Outlier。左边图中的红线是包含了Outlier的回归线，蓝色虚线是剔除了Outlier的回归线，我们可以看到移除或不移除这个Outlier对参数估计的影响很小。</p>
<p>但是Outliers 还会造成另外的问题。比如，在这个例子中，如果包括Outlier 计算得到的 RSE 为 1.09 ，如果剔除Outlier 得到的 RSE 为 0.77 。因为 RSE 在计算置信区间和 p值时均会用到，这样因为一个点导致RSE剧增会影响到回归方差拟合效果的解释。相似地，加入这个 Outlier， R<sup>2</sup> 从 0.892 降低到 0.805。</p>
<p>我们可以通过残差图来找到Outlier。在本例中我们轻松地找到这个Outlier，但是在实际应用中，我们很难决定到底偏离多少才可以视为一个 Outlier。为了解决这个问题，我们可以画图<em><strong>studentized residuals</strong></em> 图，纵坐标时残差除以它的标准误估计值。如果学生残差超过3，我们一般就认为可能是Outlier。在下图的右图中，我们发现这个Outlier的学生残差超过了6，而其他点均在 -2 与 2 之间。</p>
<p>如果你相信Outlier的出现是由于<strong>数据记录或收集时出错</strong>，那么解决办法就是移除这个观测值。但是你需要担心，Outlier的出现也可能是说明你的<strong>模型不完善</strong>，比如缺了一个影响因子。</p>
<p><img src="21.png" alt="1"></p>
<h2 id="5-High-Leverage-Points">5 High Leverage Points</h2>
<p><em><strong>High Leverage Points</strong></em> 仅指<strong>拥有异常的 x<sub>i</sub> 的观测值</strong>。例如，下图中的观测值 41 就是一个 <em>High Leverage Point</em>。 左图中的红线为包含这个点的回归直线，蓝色虚线是剔除了这个点的回归直线。我们可以看到， <em>High Leverage Point</em> 的影响很大，因此找 <em>High Leverage Point</em> 很重要。</p>
<p>对于简单线性回归， <em>High Leverage Point</em> 很容易找到，我们可以直接从 X-Y 图中直接看出。但是多重线性回归存在多个因变量，有可能一个观测值的<strong>所有的自变量单独看都在合理的范围</strong>，但是<strong>这一组自变量的组合是异常的</strong>。下图中间的图就显示了这一点，这是一个有两个自变量(X1, X2)的回归。很多观测值的两个自变量均落在蓝色虚线框定的椭圆中，但是这个红色的点不在这个范围内，虽然这个点的 X1 和 X2 值单独看都不是异常的值。**因此对于多重回归，如果仅仅看单个自变量是否存在 <em>High Leverage Point</em>，我们可能会漏掉一些 <em>High Leverage Point</em>。 ** 但是对于超过2个变量的多重回归模型，如果能够同时查看多个自变量组合的 <em>High Leverage Point</em>  就是一个问题，因为你没法针对2维以上的变量进行画图。</p>
<p><img src="22.png" alt="1"></p>
<p>为了确定一个观测值的 leverage，我们可以计算一个 <em>leverage statistic</em> 。这个值越大说明 leverage 程度越高。对于一个简单线性回归，公式如下（多重回归的公式未给）：</p>
<p><img src="23.png" alt="1"></p>
<p>这个统计量的值在 1/n 与 1 之间，而且所有的观测值的  <em>leverage statistic</em> 的均值是 (p+1)/n 。所以如果一个观测值的  <em>leverage statistic</em> 远超均值，我们就可以怀疑这是一个  <em>High Leverage Point</em></p>
<p>上图 3.13 中的右图是 学生残差 vs h<sub>i</sub>  的散点图。观测值41 的 h<sub>i</sub> 和 学生残差均特别高，说明**这个点即是   <em>High Leverage Point</em>  ，也是一个 outlier ** 。这种情况是非常危险的组合，会对回归结果造成很大的影响，相比之下观测值20 虽然是一个 outlier, 但是 leverage 很低，最起码对回归方程没什么影响。</p>
<h2 id="6-Collinearity">6  Collinearity</h2>
<p><em>Collinearity</em> 表示<strong>两个或更多个自变量之间具有紧密的相关关系</strong>。<em>Collinearity</em> 可以用下图来表示，左图中的两个变量之间表现出来没有明显的关系，而右图的两个变量之间存在<strong>高度</strong>的相关关系（我不知道这个等高图为什么可以这么解释）。</p>
<p><img src="24.png" alt="1"></p>
<p><em>Collinearity</em> 的影响在于无非区分开多个自变量对因变量的影响程度。比如右图中，RSS最低的（β<sub>Limit</sub> , β<sub>Rating</sub>）有很多个，他们在一个狭长的椭圆当中，这导致了参数估计的不确定性。</p>
<p><em>Collinearity</em> 会降低回归参数估计的准确性，导致斜率估计的标准误增加，因此 P 值会增加，会导致 power（正确地拒绝原假设的概率） 降低。下图就是两次回归得到的回归系数和 P值，我们可以看到由于存在 <em>Collinearity</em> ，导致 limit 因素第二次分析时变得不显著。</p>
<p><img src="25.png" alt="1"></p>
<p>因此<strong>我们需要在进行回归分析前进行 <em>Collinearity</em> 的检测</strong>。一个简单的思路是看<strong>自变量之间的相关矩阵</strong>，看是否存在相关系数很高的情况。但是有可能存在一种情况，就是自变量之间不存在两两之间的强相关，但是存在三个及以上的变量之间的相关（例如 X1 = a + bX2 + cX3）。我们把这种情况称为 <em><strong>multicollinearity</strong></em> 。因此我们不采用自变量的相关矩阵，我们引入了一个新的统计量来检测 <em>Collinearity</em>，就是 <abbr title="variance inflation factor">VIF</abbr> 。定义如下：</p>
<blockquote>
<p>The VIF is  the ratio of the variance of ˆβ<sub>j</sub> when fitting the full model divided by the variance of ˆβ<sub>j</sub> if fit on its own.</p>
</blockquote>
<p>VIF 的最小值为1， 说明完全没有<em>Collinearity</em> ，一般来说自变量之间存在一定的 <em>Collinearity</em> , 一般我们认为 VIF 超过 5 或 10 就说明存在严重的 <em>Collinearity</em> 。对于每个变量的 VIF 计算公式为</p>
<p><img src="26.png" alt="1"></p>
<p>在上面的例子中，对 age, rating  和 limit 这三个变量做 VIF 分析，计算结果分别为 1.01， 160.67 和 160.59 。</p>
<p>如果面临 <em>Collinearity</em>  的问题，有两个简单的思路：<strong>一是删除其中一个变量</strong>，这通常不会导致模型拟合程度的降低，因为变量之间的信息是冗余的；<strong>二是合并共显性的变量为一个变量</strong>。</p>
<h1>R代码实现</h1>
<h2 id="简单线性回归">简单线性回归</h2>
<p>回归分析</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简单回归</span></span><br><span class="line">library(MASS)</span><br><span class="line">library(ISLR)</span><br><span class="line"><span class="comment">## 采用MASS包的Boston数据集</span></span><br><span class="line">lm.fit = lm(medv~lstat, data = Boston)</span><br><span class="line">summary(lm.fit) <span class="comment">#各种回归的信息</span></span><br></pre></td></tr></table></figure>
<p>回归分析结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Call:</span><br><span class="line">lm(formula &#x3D; medv ~ lstat, data &#x3D; Boston)</span><br><span class="line"></span><br><span class="line">Residuals:</span><br><span class="line">    Min      1Q  Median      3Q     Max </span><br><span class="line">-15.168  -3.990  -1.318   2.034  24.500 </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">            Estimate Std. Error t value Pr(&gt;|t|)    </span><br><span class="line">(Intercept) 34.55384    0.56263   61.41   &lt;2e-16 ***</span><br><span class="line">lstat       -0.95005    0.03873  -24.53   &lt;2e-16 ***</span><br><span class="line">---</span><br><span class="line">Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1</span><br><span class="line"></span><br><span class="line">Residual standard error: 6.216 on 504 degrees of freedom</span><br><span class="line">Multiple R-squared:  0.5441,	Adjusted R-squared:  0.5432 </span><br><span class="line">F-statistic: 601.6 on 1 and 504 DF,  p-value: &lt; 2.2e-16</span><br></pre></td></tr></table></figure>
<p>只看系数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; coef(lm.fit)</span><br><span class="line">(Intercept)       lstat </span><br><span class="line"> <span class="number">34.5538409</span>  -<span class="number">0.9500494</span> </span><br></pre></td></tr></table></figure>
<p>查看系数的置信区间（confidence interval ）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; confint(lm.fit)</span><br><span class="line">                <span class="number">2.5</span> %     97.5 %</span><br><span class="line">(Intercept) <span class="number">33.448457</span> <span class="number">35.6592247</span></span><br><span class="line">lstat       -<span class="number">1.026148</span> -<span class="number">0.8739505</span></span><br></pre></td></tr></table></figure>
<p>画 x-y 散点图，并添加回归线</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot(Boston$lstat, Boston$medv)</span><br><span class="line">abline(lm.fit)</span><br></pre></td></tr></table></figure>
<p>我们可以查看检查线性回归是否正常的图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">par(mfrow&#x3D;c(2,2))</span><br><span class="line">plot(lm.fit) # 直接画4副图</span><br></pre></td></tr></table></figure>
<p>绘图如下：上方左图就是正常的残差图，可以查看<strong>非线性</strong>，<strong>残差异方差</strong>等，我们可以看到这里存在非线性关系；上方右图就是QQ图，用于<strong>检验残差是否符合正态分布</strong>；下方左图也是一个残差图，不过就是把纵坐标改成了 <em><strong>standardized residuals</strong></em>（缺公式）；下方右图用于判断 <em>Outlier</em> 和  <em>High Leverage Point</em>  ，横坐标是 leverage， 通常大于 4/n (n 是样本点的数目)，就算 <em>High Leverage Point</em> ； 纵轴是residuals，通常小样本大于2，大样本大于4的算作outliers 。</p>
<p><img src="28.png" alt="1"></p>
<h2 id="多重线性回归">多重线性回归</h2>
<p>看一下数据结构</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; str(Boston)</span><br><span class="line"><span class="string">&#x27;data.frame&#x27;</span>:	<span class="number">506</span> obs. of  <span class="number">14</span> variables:</span><br><span class="line"> $ crim   : num  <span class="number">0.00632</span> <span class="number">0.02731</span> <span class="number">0.02729</span> <span class="number">0.03237</span> <span class="number">0.06905</span> ...</span><br><span class="line"> $ zn     : num  <span class="number">18</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">12.5</span> <span class="number">12.5</span> <span class="number">12.5</span> <span class="number">12.5</span> ...</span><br><span class="line"> $ indus  : num  <span class="number">2.31</span> <span class="number">7.07</span> <span class="number">7.07</span> <span class="number">2.18</span> <span class="number">2.18</span> <span class="number">2.18</span> <span class="number">7.87</span> <span class="number">7.87</span> <span class="number">7.87</span> <span class="number">7.87</span> ...</span><br><span class="line"> $ chas   : int  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> ...</span><br><span class="line"> $ nox    : num  <span class="number">0.538</span> <span class="number">0.469</span> <span class="number">0.469</span> <span class="number">0.458</span> <span class="number">0.458</span> <span class="number">0.458</span> <span class="number">0.524</span> <span class="number">0.524</span> <span class="number">0.524</span> <span class="number">0.524</span> ...</span><br><span class="line"> $ rm     : num  <span class="number">6.58</span> <span class="number">6.42</span> <span class="number">7.18</span> <span class="number">7</span> <span class="number">7.15</span> ...</span><br><span class="line"> $ age    : num  <span class="number">65.2</span> <span class="number">78.9</span> <span class="number">61.1</span> <span class="number">45.8</span> <span class="number">54.2</span> <span class="number">58.7</span> <span class="number">66.6</span> <span class="number">96.1</span> <span class="number">100</span> <span class="number">85.9</span> ...</span><br><span class="line"> $ dis    : num  <span class="number">4.09</span> <span class="number">4.97</span> <span class="number">4.97</span> <span class="number">6.06</span> <span class="number">6.06</span> ...</span><br><span class="line"> $ rad    : int  <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> ...</span><br><span class="line"> $ tax    : num  <span class="number">296</span> <span class="number">242</span> <span class="number">242</span> <span class="number">222</span> <span class="number">222</span> <span class="number">222</span> <span class="number">311</span> <span class="number">311</span> <span class="number">311</span> <span class="number">311</span> ...</span><br><span class="line"> $ ptratio: num  <span class="number">15.3</span> <span class="number">17.8</span> <span class="number">17.8</span> <span class="number">18.7</span> <span class="number">18.7</span> <span class="number">18.7</span> <span class="number">15.2</span> <span class="number">15.2</span> <span class="number">15.2</span> <span class="number">15.2</span> ...</span><br><span class="line"> $ black  : num  <span class="number">397</span> <span class="number">397</span> <span class="number">393</span> <span class="number">395</span> <span class="number">397</span> ...</span><br><span class="line"> $ lstat  : num  <span class="number">4.98</span> <span class="number">9.14</span> <span class="number">4.03</span> <span class="number">2.94</span> <span class="number">5.33</span> ...</span><br><span class="line"> $ medv   : num  <span class="number">24</span> <span class="number">21.6</span> <span class="number">34.7</span> <span class="number">33.4</span> <span class="number">36.2</span> <span class="number">28.7</span> <span class="number">22.9</span> <span class="number">27.1</span> <span class="number">16.5</span> <span class="number">18.9</span> ...</span><br></pre></td></tr></table></figure>
<p>两个回归因素，lstat 和 age</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; lm.fit=lm(medv~lstat+age,data=Boston)</span><br><span class="line">&gt; summary(lm.fit)</span><br><span class="line"></span><br><span class="line">Call:</span><br><span class="line">lm(formula = medv ~ lstat + age, data = Boston)</span><br><span class="line"></span><br><span class="line">Residuals:</span><br><span class="line">    Min      <span class="number">1</span>Q  Median      <span class="number">3</span>Q     Max </span><br><span class="line">-<span class="number">15.981</span>  -<span class="number">3.978</span>  -<span class="number">1.283</span>   <span class="number">1.968</span>  <span class="number">23.158</span> </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">            Estimate Std. Error t value Pr(&gt;|t|)    </span><br><span class="line">(Intercept) <span class="number">33.22276</span>    <span class="number">0.73085</span>  <span class="number">45.458</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">lstat       -<span class="number">1.03207</span>    <span class="number">0.04819</span> -<span class="number">21.416</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">age          <span class="number">0.03454</span>    <span class="number">0.01223</span>   <span class="number">2.826</span>  <span class="number">0.00491</span> ** </span><br><span class="line">---</span><br><span class="line">Signif. codes:  <span class="number">0</span> ‘***’ <span class="number">0.001</span> ‘**’ <span class="number">0.01</span> ‘*’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error: <span class="number">6.173</span> on <span class="number">503</span> degrees of freedom</span><br><span class="line">Multiple R-squared:  <span class="number">0.5513</span>,	Adjusted R-squared:  <span class="number">0.5495</span> </span><br><span class="line"><span class="built_in">F</span>-statistic:   <span class="number">309</span> on <span class="number">2</span> and <span class="number">503</span> DF,  p-value: &lt; <span class="number">2.2e-16</span></span><br></pre></td></tr></table></figure>
<p>Boston 数据集总共有 13 个自变量，我们可以通过这种简写方式，直接使用所有的自变量（前提是除了因变量以外，其他全是自变量）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; lm.fit=lm(medv~.,data=Boston)</span><br><span class="line">&gt; summary(lm.fit)</span><br><span class="line"></span><br><span class="line">Call:</span><br><span class="line">lm(formula = medv ~ ., data = Boston)</span><br><span class="line"></span><br><span class="line">Residuals:</span><br><span class="line">    Min      <span class="number">1</span>Q  Median      <span class="number">3</span>Q     Max </span><br><span class="line">-<span class="number">15.595</span>  -<span class="number">2.730</span>  -<span class="number">0.518</span>   <span class="number">1.777</span>  <span class="number">26.199</span> </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">              Estimate Std. Error t value Pr(&gt;|t|)    </span><br><span class="line">(Intercept)  <span class="number">3.646e+01</span>  <span class="number">5.103e+00</span>   <span class="number">7.144</span> <span class="number">3.28e-12</span> ***</span><br><span class="line">crim        -<span class="number">1.080e-01</span>  <span class="number">3.286e-02</span>  -<span class="number">3.287</span> <span class="number">0.001087</span> ** </span><br><span class="line">zn           <span class="number">4.642e-02</span>  <span class="number">1.373e-02</span>   <span class="number">3.382</span> <span class="number">0.000778</span> ***</span><br><span class="line">indus        <span class="number">2.056e-02</span>  <span class="number">6.150e-02</span>   <span class="number">0.334</span> <span class="number">0.738288</span>    </span><br><span class="line">chas         <span class="number">2.687e+00</span>  <span class="number">8.616e-01</span>   <span class="number">3.118</span> <span class="number">0.001925</span> ** </span><br><span class="line">nox         -<span class="number">1.777e+01</span>  <span class="number">3.820e+00</span>  -<span class="number">4.651</span> <span class="number">4.25e-06</span> ***</span><br><span class="line">rm           <span class="number">3.810e+00</span>  <span class="number">4.179e-01</span>   <span class="number">9.116</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">age          <span class="number">6.922e-04</span>  <span class="number">1.321e-02</span>   <span class="number">0.052</span> <span class="number">0.958229</span>    </span><br><span class="line">dis         -<span class="number">1.476e+00</span>  <span class="number">1.995e-01</span>  -<span class="number">7.398</span> <span class="number">6.01e-13</span> ***</span><br><span class="line">rad          <span class="number">3.060e-01</span>  <span class="number">6.635e-02</span>   <span class="number">4.613</span> <span class="number">5.07e-06</span> ***</span><br><span class="line">tax         -<span class="number">1.233e-02</span>  <span class="number">3.760e-03</span>  -<span class="number">3.280</span> <span class="number">0.001112</span> ** </span><br><span class="line">ptratio     -<span class="number">9.527e-01</span>  <span class="number">1.308e-01</span>  -<span class="number">7.283</span> <span class="number">1.31e-12</span> ***</span><br><span class="line">black        <span class="number">9.312e-03</span>  <span class="number">2.686e-03</span>   <span class="number">3.467</span> <span class="number">0.000573</span> ***</span><br><span class="line">lstat       -<span class="number">5.248e-01</span>  <span class="number">5.072e-02</span> -<span class="number">10.347</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">---</span><br><span class="line">Signif. codes:  <span class="number">0</span> ‘***’ <span class="number">0.001</span> ‘**’ <span class="number">0.01</span> ‘*’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error: <span class="number">4.745</span> on <span class="number">492</span> degrees of freedom</span><br><span class="line">Multiple R-squared:  <span class="number">0.7406</span>,	Adjusted R-squared:  <span class="number">0.7338</span> </span><br><span class="line"><span class="built_in">F</span>-statistic: <span class="number">108.1</span> on <span class="number">13</span> and <span class="number">492</span> DF,  p-value: &lt; <span class="number">2.2e-16</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以通过car包的 vif() 函数计算 各个因子的VIF，这里可以看到 rad 和 tax 这两个因素的 VIF 比较高。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; library(car)</span><br><span class="line">载入需要的程辑包：carData</span><br><span class="line">Registered S3 methods overwritten by <span class="string">&#x27;tibble&#x27;</span>:</span><br><span class="line">  method     from  </span><br><span class="line">  format.tbl pillar</span><br><span class="line">  print.tbl  pillar</span><br><span class="line">Warning messages:</span><br><span class="line">1: 程辑包‘car’是用R版本<span class="number">4.0</span>.3 来建造的 </span><br><span class="line">2: 程辑包‘carData’是用R版本<span class="number">4.0</span>.3 来建造的 </span><br><span class="line">&gt; vif(lm.fit)</span><br><span class="line">    crim       zn    indus     chas      nox       rm      age      dis      rad      tax </span><br><span class="line">1.792192 <span class="number">2.298758</span> <span class="number">3.991596</span> <span class="number">1.073995</span> <span class="number">4.393720</span> <span class="number">1.933744</span> <span class="number">3.100826</span> <span class="number">3.955945</span> <span class="number">7.484496</span> <span class="number">9.008554</span> </span><br><span class="line"> ptratio    black    lstat </span><br><span class="line">1.799084 <span class="number">1.348521</span> <span class="number">2.941491</span> </span><br></pre></td></tr></table></figure>
<p>使用除了某一个因子外的其他所有因子的回归（采用 - 号），例如剔除 age 因子。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt;lm.fit1 = lm(medv∼.-age,data=Boston)</span><br><span class="line">&gt;summary(lm.fit1)</span><br></pre></td></tr></table></figure>
<h2 id="互作项">互作项</h2>
<p>回归模型中 ， <code>lstat:black</code> 表示新增一个 <code>lstat</code> 和 <code>black</code> 的互作项。<code>lstat*age</code> 表示同时<code>lstat</code>, <code>age</code> 和他们之间的互作项，是 <code>lstat+age+lstat:age</code> 的简写。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; summary(lm(medv~lstat*age,data=Boston))</span><br><span class="line"></span><br><span class="line">Call:</span><br><span class="line">lm(formula = medv ~ lstat * age, data = Boston)</span><br><span class="line"></span><br><span class="line">Residuals:</span><br><span class="line">    Min      <span class="number">1</span>Q  Median      <span class="number">3</span>Q     Max </span><br><span class="line">-<span class="number">15.806</span>  -<span class="number">4.045</span>  -<span class="number">1.333</span>   <span class="number">2.085</span>  <span class="number">27.552</span> </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">              Estimate Std. Error t value Pr(&gt;|t|)    </span><br><span class="line">(Intercept) <span class="number">36.0885359</span>  <span class="number">1.4698355</span>  <span class="number">24.553</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">lstat       -<span class="number">1.3921168</span>  <span class="number">0.1674555</span>  -<span class="number">8.313</span> <span class="number">8.78e-16</span> ***</span><br><span class="line">age         -<span class="number">0.0007209</span>  <span class="number">0.0198792</span>  -<span class="number">0.036</span>   <span class="number">0.9711</span>    </span><br><span class="line">lstat:age    <span class="number">0.0041560</span>  <span class="number">0.0018518</span>   <span class="number">2.244</span>   <span class="number">0.0252</span> *  </span><br><span class="line">---</span><br><span class="line">Signif. codes:  <span class="number">0</span> ‘***’ <span class="number">0.001</span> ‘**’ <span class="number">0.01</span> ‘*’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error: <span class="number">6.149</span> on <span class="number">502</span> degrees of freedom</span><br><span class="line">Multiple R-squared:  <span class="number">0.5557</span>,	Adjusted R-squared:  <span class="number">0.5531</span> </span><br><span class="line"><span class="built_in">F</span>-statistic: <span class="number">209.3</span> on <span class="number">3</span> and <span class="number">502</span> DF,  p-value: &lt; <span class="number">2.2e-16</span></span><br></pre></td></tr></table></figure>
<h2 id="自变量的非线性转换">自变量的非线性转换</h2>
<p>我们可以创建一个新的自变量 X<sup>2</sup>，采用 <code>I(X^2)</code> 函数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; lm.fit2 = lm(medv~lstat+I(lstat^<span class="number">2</span>), data = Boston)</span><br><span class="line">&gt; summary(lm.fit2)</span><br><span class="line"></span><br><span class="line">Call:</span><br><span class="line">lm(formula = medv ~ lstat + I(lstat^<span class="number">2</span>), data = Boston)</span><br><span class="line"></span><br><span class="line">Residuals:</span><br><span class="line">     Min       <span class="number">1</span>Q   Median       <span class="number">3</span>Q      Max </span><br><span class="line">-<span class="number">15.2834</span>  -<span class="number">3.8313</span>  -<span class="number">0.5295</span>   <span class="number">2.3095</span>  <span class="number">25.4148</span> </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">             Estimate Std. Error t value Pr(&gt;|t|)    </span><br><span class="line">(Intercept) <span class="number">42.862007</span>   <span class="number">0.872084</span>   <span class="number">49.15</span>   &lt;<span class="number">2e-16</span> ***</span><br><span class="line">lstat       -<span class="number">2.332821</span>   <span class="number">0.123803</span>  -<span class="number">18.84</span>   &lt;<span class="number">2e-16</span> ***</span><br><span class="line">I(lstat^<span class="number">2</span>)   <span class="number">0.043547</span>   <span class="number">0.003745</span>   <span class="number">11.63</span>   &lt;<span class="number">2e-16</span> ***</span><br><span class="line">---</span><br><span class="line">Signif. codes:  <span class="number">0</span> ‘***’ <span class="number">0.001</span> ‘**’ <span class="number">0.01</span> ‘*’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error: <span class="number">5.524</span> on <span class="number">503</span> degrees of freedom</span><br><span class="line">Multiple R-squared:  <span class="number">0.6407</span>,	Adjusted R-squared:  <span class="number">0.6393</span> </span><br><span class="line"><span class="built_in">F</span>-statistic: <span class="number">448.5</span> on <span class="number">2</span> and <span class="number">503</span> DF,  p-value: &lt; <span class="number">2.2e-16</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看到二次项的P值也是显著的，说明模型拟合结果有所改善。我们可以使用 <code>anova()</code> 函数来比对两个模型。</p>
<p>这里 Model 1 表示原来的线性模型，Model 2 表示二次项回归模型。这个  <code>anova()</code> 函数执行了一个比对两个模型的假设检验，零假设是两个模型拟合程度一致，备择假设是更全的模型更好。这里F统计量是135， 相应的 P值也很低，说明二次项模型拟合程度更好。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; lm.fit = lm(medv~lstat, data=Boston)</span><br><span class="line">&gt; anova(lm.fit, lm.fit2)</span><br><span class="line">Analysis of Variance Table</span><br><span class="line"></span><br><span class="line">Model <span class="number">1</span>: medv ~ lstat</span><br><span class="line">Model <span class="number">2</span>: medv ~ lstat + I(lstat^<span class="number">2</span>)</span><br><span class="line">  Res.Df   RSS Df Sum of Sq     <span class="built_in">F</span>    Pr(&gt;<span class="built_in">F</span>)    </span><br><span class="line">1    <span class="number">504</span> <span class="number">19472</span>                                 </span><br><span class="line">2    <span class="number">503</span> <span class="number">15347</span>  <span class="number">1</span>    <span class="number">4125.1</span> <span class="number">135.2</span> &lt; <span class="number">2.2e-16</span> ***</span><br><span class="line">---</span><br><span class="line">Signif. codes:  <span class="number">0</span> ‘***’ <span class="number">0.001</span> ‘**’ <span class="number">0.01</span> ‘*’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如果要建立<strong>三次型</strong>方程，我们可以新增一个变量 <code>I(X^3)</code> 。但是，这种写法比较啰嗦。一个更好的写法是使用**<code>poly()</code>** 函数来创建一个多项式。比如下面就会创建一个自由度为5的二次型拟合</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; lm.fit5 = lm(medv~poly(lstat,<span class="number">5</span>),data=Boston)</span><br><span class="line">&gt; summary(lm.fit5)</span><br><span class="line"></span><br><span class="line">Call:</span><br><span class="line">lm(formula = medv ~ poly(lstat, <span class="number">5</span>), data = Boston)</span><br><span class="line"></span><br><span class="line">Residuals:</span><br><span class="line">     Min       <span class="number">1</span>Q   Median       <span class="number">3</span>Q      Max </span><br><span class="line">-<span class="number">13.5433</span>  -<span class="number">3.1039</span>  -<span class="number">0.7052</span>   <span class="number">2.0844</span>  <span class="number">27.1153</span> </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">                 Estimate Std. Error t value Pr(&gt;|t|)    </span><br><span class="line">(Intercept)       <span class="number">22.5328</span>     <span class="number">0.2318</span>  <span class="number">97.197</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">poly(lstat, <span class="number">5</span>)<span class="number">1</span> -<span class="number">152.4595</span>     <span class="number">5.2148</span> -<span class="number">29.236</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">poly(lstat, <span class="number">5</span>)<span class="number">2</span>   <span class="number">64.2272</span>     <span class="number">5.2148</span>  <span class="number">12.316</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">poly(lstat, <span class="number">5</span>)<span class="number">3</span>  -<span class="number">27.0511</span>     <span class="number">5.2148</span>  -<span class="number">5.187</span> <span class="number">3.10e-07</span> ***</span><br><span class="line">poly(lstat, <span class="number">5</span>)<span class="number">4</span>   <span class="number">25.4517</span>     <span class="number">5.2148</span>   <span class="number">4.881</span> <span class="number">1.42e-06</span> ***</span><br><span class="line">poly(lstat, <span class="number">5</span>)<span class="number">5</span>  -<span class="number">19.2524</span>     <span class="number">5.2148</span>  -<span class="number">3.692</span> <span class="number">0.000247</span> ***</span><br><span class="line">---</span><br><span class="line">Signif. codes:  <span class="number">0</span> ‘***’ <span class="number">0.001</span> ‘**’ <span class="number">0.01</span> ‘*’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error: <span class="number">5.215</span> on <span class="number">500</span> degrees of freedom</span><br><span class="line">Multiple R-squared:  <span class="number">0.6817</span>,	Adjusted R-squared:  <span class="number">0.6785</span> </span><br><span class="line"><span class="built_in">F</span>-statistic: <span class="number">214.2</span> on <span class="number">5</span> and <span class="number">500</span> DF,  p-value: &lt; <span class="number">2.2e-16</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里说明如果增加二次项，加到5， 可以增加模型的拟合程度。但是，进一步研究会发现，如果增加超过项数超过5的项，这些超过5的项的p值均不显著。</p>
<p>当然，除了使用二次项以外，我们还可以使用其他转换函数，比如<strong>log函数</strong>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">summary(lm(medv~<span class="built_in">log</span>(rm), data=Boston))</span><br></pre></td></tr></table></figure>
<h2 id="分类因子">分类因子</h2>
<p>这里我们用 <code>ISLR</code> 包的 <code>Carseats</code> 数据集。我们想要预测的变量是 <em>Sales</em></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; library(ISLR)</span><br><span class="line">&gt; fix(Carseats)</span><br><span class="line">&gt; str(Carseats)</span><br><span class="line"><span class="string">&#x27;data.frame&#x27;</span>:	<span class="number">400</span> obs. of  <span class="number">11</span> variables:</span><br><span class="line"> $ Sales      : num  <span class="number">9.5</span> <span class="number">11.22</span> <span class="number">10.06</span> <span class="number">7.4</span> <span class="number">4.15</span> ...</span><br><span class="line"> $ CompPrice  : num  <span class="number">138</span> <span class="number">111</span> <span class="number">113</span> <span class="number">117</span> <span class="number">141</span> <span class="number">124</span> <span class="number">115</span> <span class="number">136</span> <span class="number">132</span> <span class="number">132</span> ...</span><br><span class="line"> $ Income     : num  <span class="number">73</span> <span class="number">48</span> <span class="number">35</span> <span class="number">100</span> <span class="number">64</span> <span class="number">113</span> <span class="number">105</span> <span class="number">81</span> <span class="number">110</span> <span class="number">113</span> ...</span><br><span class="line"> $ Advertising: num  <span class="number">11</span> <span class="number">16</span> <span class="number">10</span> <span class="number">4</span> <span class="number">3</span> <span class="number">13</span> <span class="number">0</span> <span class="number">15</span> <span class="number">0</span> <span class="number">0</span> ...</span><br><span class="line"> $ Population : num  <span class="number">276</span> <span class="number">260</span> <span class="number">269</span> <span class="number">466</span> <span class="number">340</span> <span class="number">501</span> <span class="number">45</span> <span class="number">425</span> <span class="number">108</span> <span class="number">131</span> ...</span><br><span class="line"> $ Price      : num  <span class="number">120</span> <span class="number">83</span> <span class="number">80</span> <span class="number">97</span> <span class="number">128</span> <span class="number">72</span> <span class="number">108</span> <span class="number">120</span> <span class="number">124</span> <span class="number">124</span> ...</span><br><span class="line"> $ ShelveLoc  : Factor w/ <span class="number">3</span> levels <span class="string">&quot;Bad&quot;</span>,<span class="string">&quot;Good&quot;</span>,<span class="string">&quot;Medium&quot;</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> ...</span><br><span class="line"> $ Age        : num  <span class="number">42</span> <span class="number">65</span> <span class="number">59</span> <span class="number">55</span> <span class="number">38</span> <span class="number">78</span> <span class="number">71</span> <span class="number">67</span> <span class="number">76</span> <span class="number">76</span> ...</span><br><span class="line"> $ Education  : num  <span class="number">17</span> <span class="number">10</span> <span class="number">12</span> <span class="number">14</span> <span class="number">13</span> <span class="number">16</span> <span class="number">15</span> <span class="number">10</span> <span class="number">10</span> <span class="number">17</span> ...</span><br><span class="line"> $ Urban      : Factor w/ <span class="number">2</span> levels <span class="string">&quot;No&quot;</span>,<span class="string">&quot;Yes&quot;</span>: <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> ...</span><br><span class="line"> $ US         : Factor w/ <span class="number">2</span> levels <span class="string">&quot;No&quot;</span>,<span class="string">&quot;Yes&quot;</span>: <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> ...</span><br></pre></td></tr></table></figure>
<p>这里包含了类似于 <code>ShelveLoc</code> 的分类变量。如果使用分类变量，R会<strong>自动转变为哑变量</strong>。下面我们进行包含了一些互作项的多重回归模型。</p>
<p>这里  <code>ShelveLoc</code>  生成了两个哑变量 ShelveLocGood 和 ShelveLocMedium ，Bad 水平视为基础水平。我们可以看到 Good 和 Medium 水平的斜率都是正数，且均显著，说明 Good 和 Medium 水平的因变量的均值均比 Bad 水平要高。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; lm.fit=lm(Sales~.+Income:Advertising +Price:Age,data=Carseats)</span><br><span class="line">&gt; summary(lm.fit)</span><br><span class="line"></span><br><span class="line">Call:</span><br><span class="line">lm(formula = Sales ~ . + Income:Advertising + Price:Age, data = Carseats)</span><br><span class="line"></span><br><span class="line">Residuals:</span><br><span class="line">    Min      <span class="number">1</span>Q  Median      <span class="number">3</span>Q     Max </span><br><span class="line">-<span class="number">2.9208</span> -<span class="number">0.7503</span>  <span class="number">0.0177</span>  <span class="number">0.6754</span>  <span class="number">3.3413</span> </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">                     Estimate Std. Error t value Pr(&gt;|t|)    </span><br><span class="line">(Intercept)         <span class="number">6.5755654</span>  <span class="number">1.0087470</span>   <span class="number">6.519</span> <span class="number">2.22e-10</span> ***</span><br><span class="line">CompPrice           <span class="number">0.0929371</span>  <span class="number">0.0041183</span>  <span class="number">22.567</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">Income              <span class="number">0.0108940</span>  <span class="number">0.0026044</span>   <span class="number">4.183</span> <span class="number">3.57e-05</span> ***</span><br><span class="line">Advertising         <span class="number">0.0702462</span>  <span class="number">0.0226091</span>   <span class="number">3.107</span> <span class="number">0.002030</span> ** </span><br><span class="line">Population          <span class="number">0.0001592</span>  <span class="number">0.0003679</span>   <span class="number">0.433</span> <span class="number">0.665330</span>    </span><br><span class="line">Price              -<span class="number">0.1008064</span>  <span class="number">0.0074399</span> -<span class="number">13.549</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">ShelveLocGood       <span class="number">4.8486762</span>  <span class="number">0.1528378</span>  <span class="number">31.724</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">ShelveLocMedium     <span class="number">1.9532620</span>  <span class="number">0.1257682</span>  <span class="number">15.531</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">Age                -<span class="number">0.0579466</span>  <span class="number">0.0159506</span>  -<span class="number">3.633</span> <span class="number">0.000318</span> ***</span><br><span class="line">Education          -<span class="number">0.0208525</span>  <span class="number">0.0196131</span>  -<span class="number">1.063</span> <span class="number">0.288361</span>    </span><br><span class="line">UrbanYes            <span class="number">0.1401597</span>  <span class="number">0.1124019</span>   <span class="number">1.247</span> <span class="number">0.213171</span>    </span><br><span class="line">USYes              -<span class="number">0.1575571</span>  <span class="number">0.1489234</span>  -<span class="number">1.058</span> <span class="number">0.290729</span>    </span><br><span class="line">Income:Advertising  <span class="number">0.0007510</span>  <span class="number">0.0002784</span>   <span class="number">2.698</span> <span class="number">0.007290</span> ** </span><br><span class="line">Price:Age           <span class="number">0.0001068</span>  <span class="number">0.0001333</span>   <span class="number">0.801</span> <span class="number">0.423812</span>    </span><br><span class="line">---</span><br><span class="line">Signif. codes:  <span class="number">0</span> ‘***’ <span class="number">0.001</span> ‘**’ <span class="number">0.01</span> ‘*’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error: <span class="number">1.011</span> on <span class="number">386</span> degrees of freedom</span><br><span class="line">Multiple R-squared:  <span class="number">0.8761</span>,	Adjusted R-squared:  <span class="number">0.8719</span> </span><br><span class="line"><span class="built_in">F</span>-statistic:   <span class="number">210</span> on <span class="number">13</span> and <span class="number">386</span> DF,  p-value: &lt; <span class="number">2.2e-16</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建个人博客</title>
    <url>/posts/c442673f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我这个个人博客第一次建立应该是在2019年，当时网页外表比较简陋，内容也不多，之后一直也没怎么更新。最近重新搭建了一次，网页的外在部分都改了，这个就是这次我重建博客的全过程记录。</p>
<p>搭建个人博客的过程还是有意思的，虽然我对于设计网页的这些语言并不了解，往往一个问题或需求可以卡几天，但是最终解决了还是会有成就感的。</p>
<p>最后感谢我现在的女朋友，为了想在见面前把这个网页建好，作为送给她的礼物，我才有足够的动机。不然这事完成的时间可能还得靠后。</p>
<span id="more"></span>
<h1>1 搭建个人博客-基础篇</h1>
<p>B站视频：<a href="https://www.bilibili.com/video/BV1Yb411a7ty">https://www.bilibili.com/video/BV1Yb411a7ty</a></p>
<p>hexo 官网文档：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p>
<p>跟着这个视频就应该没有太大的问题，很详细</p>
<h2 id="1-1-安装-node-js-和-git">1.1 安装 node.js 和 git</h2>
<p>我也不知道node.js 是啥，安装就完事了。</p>
<p>下载地址：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></p>
<p>选择“长期支持版”，下载后一直下一步下一步就行。</p>
<p>安装后会自带一个什么 npm，这也是安装博客必须的。</p>
<p>下载git: <a href="https://git-scm.com/">https://git-scm.com/</a></p>
<h2 id="1-2-安装hexo-windows-系统">1.2 安装hexo - windows 系统</h2>
<p>由于我是用个人电脑安装的，是windows系统，和视频不太一样，下面是我用的命令。</p>
<p><strong>管理员身份进入 cmd</strong> , 之后查看node版本和npm版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">node -v</span></span><br><span class="line">v14.16.0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">npm -v</span></span><br><span class="line">6.14.11</span><br></pre></td></tr></table></figure>
<p>因为npm速度很慢，利用npm安装cnpm（淘宝的版本）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>安装后检查</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;cnpm -v</span><br><span class="line">cnpm@6.1.1 (C:\Users\zhou\AppData\Roaming\npm\node_modules\cnpm\lib\parse_argv.js)</span><br><span class="line">npm@6.14.11 (C:\Users\zhou\AppData\Roaming\npm\node_modules\cnpm\node_modules\npm\lib\npm.js)</span><br><span class="line">node@14.16.0 (C:\Program Files\nodejs\node.exe)</span><br><span class="line">npminstall@3.28.0 (C:\Users\zhou\AppData\Roaming\npm\node_modules\cnpm\node_modules\npminstall\lib\index.js)</span><br><span class="line">prefix&#x3D;C:\Users\zhou\AppData\Roaming\npm</span><br><span class="line">win32 x64 10.0.19041</span><br><span class="line">registry&#x3D;https:&#x2F;&#x2F;r.npm.taobao.org</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用cnpm, 安装 hexo 框架</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>验证hexo是否安装完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;hexo -v</span><br><span class="line">hexo-cli: 4.2.0</span><br><span class="line">os: Windows_NT 10.0.19041 win32 x64</span><br><span class="line">node: 14.16.0</span><br><span class="line">v8: 8.4.371.19-node.18</span><br><span class="line">uv: 1.40.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.9</span><br><span class="line">ares: 1.16.1</span><br><span class="line">modules: 83</span><br><span class="line">nghttp2: 1.41.0</span><br><span class="line">napi: 7</span><br><span class="line">llhttp: 2.1.3</span><br><span class="line">openssl: 1.1.1j</span><br><span class="line">cldr: 37.0</span><br><span class="line">icu: 67.1</span><br><span class="line">tz: 2020a</span><br><span class="line">unicode: 13.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1-3-使用hexo搭建博客">1.3 使用hexo搭建博客</h2>
<p>切换目录，创建blog目录并进入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;d:</span><br><span class="line">&gt;cd desktop</span><br><span class="line">&gt;mkdir blog</span><br><span class="line">&gt;cd blog</span><br></pre></td></tr></table></figure>
<p>初始化博客</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;hexo init</span><br><span class="line">INFO  Cloning hexo-starter https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo-starter.git</span><br><span class="line">[32mINFO [39m Install dependencies</span><br><span class="line">added 190 packages from 159 contributors and audited 196 packages in 115.851s</span><br><span class="line"></span><br><span class="line">15 packages are looking for funding</span><br><span class="line">  run &#96;npm fund&#96; for details</span><br><span class="line"></span><br><span class="line">found 0 vulnerabilities</span><br><span class="line"></span><br><span class="line">INFO  Start blogging with Hexo!</span><br></pre></td></tr></table></figure>
<p>最后显示了，可以开始用 Hexo 写博客了。</p>
<p>启动博客，就是 hexo s（server 的缩写），平常就是在本地做预览用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;hexo s</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">Deprecated as of 10.7.0. highlight(lang, code, ...args) has been deprecated.</span><br><span class="line">Deprecated as of 10.7.0. Please use highlight(code, options) instead.</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;highlightjs&#x2F;highlight.js&#x2F;issues&#x2F;2277</span><br><span class="line">Deprecated as of 10.7.0. highlight(lang, code, ...args) has been deprecated.</span><br><span class="line">Deprecated as of 10.7.0. Please use highlight(code, options) instead.</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;highlightjs&#x2F;highlight.js&#x2F;issues&#x2F;2277</span><br><span class="line">Deprecated as of 10.7.0. highlight(lang, code, ...args) has been deprecated.</span><br><span class="line">Deprecated as of 10.7.0. Please use highlight(code, options) instead.</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;highlightjs&#x2F;highlight.js&#x2F;issues&#x2F;2277</span><br><span class="line">Deprecated as of 10.7.0. highlight(lang, code, ...args) has been deprecated.</span><br><span class="line">Deprecated as of 10.7.0. Please use highlight(code, options) instead.</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;highlightjs&#x2F;highlight.js&#x2F;issues&#x2F;2277</span><br><span class="line">INFO  Hexo is running at http:&#x2F;&#x2F;localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<p>就会在本地的4000端口启动。</p>
<p>在浏览器输入 <code>http://localhost:4000/</code> 看看。</p>
<p>然后可以输入 ctrl + c 断开。</p>
<h2 id="1-4-新建博客">1.4 新建博客</h2>
<p>使用 hexo new (简写为n) 命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;title&quot;</span><br></pre></td></tr></table></figure>
<p>然后在 source/_posts 目录下就有了新建的md文件</p>
<p>在cmd中，当前目录为blog目录下。先清理一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<p>这个命令hexo官网的说法如下：</p>
<blockquote>
<p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p>
<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
</blockquote>
<p>貌似这个清理的命令可以不用每次都输入，只是在输入命令后网页没有改变，才需要清理。从网上看，确实如此。</p>
<blockquote>
<p>#清除缓存，若是网页正常情况下可以忽略这条命令</p>
</blockquote>
<p>然后，生成静态文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>然后再启动一下，看看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<h2 id="1-5-hexo-官方配置">1.5 hexo 官方配置</h2>
<p>这里的配置指的是根目录下的 <strong>_config.yml</strong> 文件的设置</p>
<p>直接看官网资料即可，官网还有小视频。</p>
<p><a href="https://hexo.io/docs">https://hexo.io/docs</a></p>
<h3 id="网站-site">网站 (site)</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">VincereZhou&#x27;s</span> <span class="string">blog</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line"><span class="attr">description:</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Vincere</span> <span class="string">Zhou</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li><strong>title</strong> : 标题</li>
<li><strong>language</strong> :  网站使用的语言。简体中文常见的有 <code>zh-Hans</code>和 <code>zh-CN</code>。（我也搞不清楚这两个区别）</li>
<li><strong>timezone</strong> :  网站时区。中国大陆地区使用 <code>Asia/Shanghai</code>。</li>
</ul>
<p>其他的都不需要。</p>
<h3 id="网址-URL">网址 (URL)</h3>
<p><strong>全部不需要设置</strong>。</p>
<p>其中有一个 <code>permalink</code> ，用来设置文章的<strong>永久链接</strong>格式。每篇文章的网址默认是 <strong>年/月/日/文章名称</strong>。这个也不用改了，如果改了可能会出问题。</p>
<p>下面是我之前的一篇博客的默认网址，后面的乱码其实是文章名称，由于含有中文复制下来就成这样了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;vincere.fun&#x2F;2020&#x2F;01&#x2F;10&#x2F;%E5%8F%8D%E7%BB%8F-%E7%AC%AC%E5%85%AB%E5%8D%B7%E6%9D%82%E8%AF%B4-%E9%92%93%E6%83%85&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="目录-Directory">目录 (Directory)</h3>
<p>全部不需要设置。</p>
<h3 id="文章-Writing">文章 (Writing)</h3>
<h4 id="本地图片插入">本地图片插入</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>使用相对路径插入图片。</p>
<p>Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](image.jpg)</span><br></pre></td></tr></table></figure>
<p>上述是markdown的引用方式，图片只能在文章中显示，但无法在首页中正常显示。</p>
<p>如果希望图片在文章和首页中同时显示，可以使用标签插件语法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img image.jpg This is an image %&#125;</span><br></pre></td></tr></table></figure>
<p>我就是不太清楚，例子里的<code>This is an image</code> 是啥，图片标题？</p>
<p>但是我不用在首页显示图片，所以我用不到这种写法。</p>
<h3 id="分类-标签-Category-Tag">分类 &amp; 标签 (Category &amp; Tag)</h3>
<p>全部不需要设置。</p>
<h3 id="日期-时间格式-Date-Time-format">日期 / 时间格式 (Date / Time format)</h3>
<p>全部不需要设置。</p>
<h3 id="分页-Pagination">分页 (Pagination)</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">per_page:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>每页显示的文章量 (0 = 关闭分页功能)</p>
<h3 id="扩展-Extensions">扩展 (Extensions)</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">ayer</span></span><br></pre></td></tr></table></figure>
<p>当前主题名称。</p>
<h3 id="部署-Deployment">部署 (Deployment)</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="comment"># repo: https://github.com/VincereZhou/VincereZhou.github.io.git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:VincereZhou/VincereZhou.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表示连接上 Github</p>
<h2 id="1-6-hexo命令总结">1.6 hexo命令总结</h2>
<h4 id="常用命令">常用命令</h4>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">hexo</span> <span class="string">new</span> <span class="string">&quot;title&quot;</span> <span class="comment"># 生成新文章</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">generate</span>    <span class="comment"># 生成静态文件          </span></span><br><span class="line"><span class="string">hexo</span> <span class="string">generate</span> <span class="string">-d</span> <span class="comment"># 生成静态文件，同时推到远端</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">server</span>      <span class="comment"># 本地查看</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">deploy</span>      <span class="comment"># 推到远端</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">clean</span>       <span class="comment"># 清楚缓存文件</span></span><br></pre></td></tr></table></figure>
<h4 id="选项">选项</h4>
<p>选项的意思是所有的命令都能携带。</p>
<p>可能用到的选项有两个：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">hexo</span> <span class="string">--safe</span></span><br></pre></td></tr></table></figure>
<p>在<strong>安全模式</strong>下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">hexo</span> <span class="string">--silent</span></span><br></pre></td></tr></table></figure>
<p>简洁模式，隐藏终端信息。</p>
<p>这个简洁模式什么都不会打印出来，但是我担心报错会不会正常显示。</p>
<h2 id="1-7-小技巧">1.7 小技巧</h2>
<h3 id="文章截断">文章截断</h3>
<p>文章截断指在主页那不显示全部的文章内容（因为内容太长了），只显示文章开头的一部分（就类似于只显示摘要）。这样如果读者可以方便地翻阅所有的文章，遇到有兴趣的就点进去看。</p>
<p><a href="https://hopefulnick.github.io/2018/04/01/180401Hexo%E6%96%87%E7%AB%A0%E6%88%AA%E6%96%AD/">https://hopefulnick.github.io/2018/04/01/180401Hexo文章截断/</a></p>
<p>推荐使用在文章中使用<code>&lt;!-- more --&gt;</code>手动进行截断</p>
<h1>2 部署到github</h1>
<p>如果不部署到github，那么你只能在本地上看到你的博客，那么别人就没法看到了。</p>
<p>在你的 <a href="https://github.com/">github</a> 主页上（没有账户就创建一个），创建一个新的 repository，名字必须为自己的用户名+<code>.github.io</code>。以后你博客的所有内容均会放在这个仓库里</p>
<p>回到 cmd 命令行，要装一个 git 部署的插件，windows 命令如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>设置 _config.yml 文件，修改最后的 Deployment 部分，我之前做过了，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;VincereZhou&#x2F;VincereZhou.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>部署到远端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<h2 id="2-0-绑定自己的域名">2.0 绑定自己的域名</h2>
<p>参考网址：<a href="https://oliverqueen.cn/2018/01/25/%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84%E4%BD%BF%E7%94%A8HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/">https://oliverqueen.cn/2018/01/25/%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84%E4%BD%BF%E7%94%A8HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</a></p>
<h3 id="域名解析">域名解析</h3>
<p>我的域名是在阿里云买的，在阿里云-域名控制台，找到自己的域名，新建两个CNAME记录（不要新建A记录了，github的ip地址可能会变，导致github一直给我发邮件说域名失效）</p>
<p>两个记录一条主机记录为@，一条主机记录为www，这样别人访问的时候无论加不加 www. 都能访问到。</p>
<p><img src="7.png" alt="7"></p>
<h3 id="本地操作">本地操作</h3>
<p>在你的本地hexo博客文件的source文件夹下创建一个CNAME文件，记住不要有文件后缀名。编辑CNAME文件，里面写你在第一步申请的域名，例如<a href="https://link.zhihu.com/?target=http%3A//xxxx.cn">http://xxxx.cn</a>，记住不要有www。</p>
<h3 id="github-仓库配置-https协议">github 仓库配置 - https协议</h3>
<p>找到github 仓库，设置的 pages - custom domain ，填上你的个人域名（不加www.）</p>
<p>在pages 里可以勾选<strong>Enforce HTTPS（实施 HTTPS）</strong> ，这样以后就会用 https协议， 谷歌浏览器打开你的网页就不会显示不安全了。如果无法勾选，旁边显示 <em>Unavailable for your site because your domain is not properly configured to support HTTPS</em>, 那就将填在<strong>Custom domain</strong>里的自定义域名清空，保存，然后重新填上自定义域名，再保存。</p>
<p>勾选<strong>Enforce HTTPS</strong>选项以后，别人说这时会提示正在签发证书: <em>Not yet available for your site because the certificate has not finished being issued</em>。（但是我没有显示这些文字）</p>
<p>证书签发成功后，可以使用 https 链接访问自定义域名了。</p>
<p>勾选完，等一段时间才会生效，重新推到远端，之后打开网址就都是 https 了。</p>
<h3 id="生成公钥，并复制到github">生成公钥，并复制到github</h3>
<p>按照下面这个网址进行操作</p>
<p><a href="https://zhuanlan.zhihu.com/p/26625249">https://zhuanlan.zhihu.com/p/26625249</a></p>
<p>检查有没有公钥。先打开 git bash , 然后输入命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>如果提示文件不存在，说明没有生成公钥。生成公钥如下，输入命令后，<strong>连着按三下Enter</strong>即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">&quot;zhuanzhugongxian@sina.com&quot;</span></span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/c/Users/zhou/.ssh/id_rsa): q</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure>
<p>然后复制公钥的全部内容，黏贴到 github 的 ”新建new SSH Key“ 中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>然后再检查一下，公钥是否设置成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -T git@github.com</span></span><br><span class="line">Hi VincereZhou! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>生成这条语句，就说明连接成功。</p>
<p>这一步操作的好处是，<strong>每次更新博客，不用输入昵称和邮箱进行确认了</strong>，一劳永逸。</p>
<h2 id="2-1-推到远端各种报错说明">2.1 推到远端各种报错说明</h2>
<h4 id="推到远端，报错who-you-are">推到远端，报错who you are</h4>
<p>运行下面两条命令，引号内容改成自己的邮箱和昵称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.email &quot;zhuanzhugongxian@sina.com&quot;</span><br><span class="line">git config --global user.name &quot;VincereZhou&quot;</span><br></pre></td></tr></table></figure>
<h4 id="推到远端，报错-OpenSSL-SSL-read">推到远端，报错 OpenSSL SSL_read</h4>
<p>报错信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#39;https:&#x2F;&#x2F;github.com&#x2F;VincereZhou&#x2F;VincereZhou.github.io.git&#x2F;&#39;: OpenSSL SSL_read: Connection was reset, errno 10054</span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (D:\Desktop\blog\node_modules\_hexo-util@2.4.0@hexo-util\lib\spawn.js:51:21)</span><br><span class="line">      at ChildProcess.emit (events.js:315:20)</span><br><span class="line">      at ChildProcess.cp.emit (D:\Desktop\blog\node_modules\_cross-spawn@7.0.3@cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">      at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:277:12) &#123;</span><br><span class="line">    code: 128</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something&#39;s wrong. Maybe you can find the solution here: %s https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;troubleshooting.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个报错貌似很常见，可以重新 <code>hexo d</code> 或过段时间 <code>hexo d</code> 看看，说不定就又好了。</p>
<p>如果还不行，这个网址 <a href="https://github.com/hexojs/hexo/issues/2778">https://github.com/hexojs/hexo/issues/2778</a> 有一个解决办法</p>
<p>根据这个网址的说法，就是把 _config.yml 中的 repo 内容修改一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> repo: https://github.com/VincereZhou/VincereZhou.github.io.git</span></span><br><span class="line">repo: git@github.com:VincereZhou/VincereZhou.github.io.git</span><br></pre></td></tr></table></figure>
<p>然后重新推送一下，就一切正常了。</p>
<h4 id="推断远端，报错没有git">推断远端，报错没有git</h4>
<p>报错信息为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR Deployer not found: git</span><br></pre></td></tr></table></figure>
<p>网上说，是没安装 hexo-deployer-git 插件</p>
<p><a href="https://blog.csdn.net/Java_Mike/article/details/96456318">https://blog.csdn.net/Java_Mike/article/details/96456318</a></p>
<p>可我明明安装了的，那就再装一次试试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>好吧，可以了。我在想，这是不是因为之前安装用的是 cmd ，这次用的是 git bash 的原因。从目前来看完全可以全部用 git bash，更方便。</p>
<h4 id="推到远端，报错-Timed-out">推到远端，报错 Timed out</h4>
<p>报错如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#39;https:&#x2F;&#x2F;github.com&#x2F;VincereZhou&#x2F;VincereZhou.github.io.git&#x2F;&#39;: Failed to connect to github.com port 443: Timed out</span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (D:\Desktop\blog\node_modules\_hexo-util@2.4.0@hexo-util\lib\spawn.js:51:21)</span><br><span class="line">      at ChildProcess.emit (events.js:315:20)</span><br><span class="line">      at ChildProcess.cp.emit (D:\Desktop\blog\node_modules\_cross-spawn@7.0.3@cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">      at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:277:12) &#123;</span><br><span class="line">    code: 128</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something&#39;s wrong. Maybe you can find the solution here: %s https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;troubleshooting.html</span><br></pre></td></tr></table></figure>
<p>这个我的经验是不用管它，重新 <code>hexo d</code> 或过段时间 <code>hexo d</code>就好了。</p>
<h1>3 博客迁移</h1>
<p>当你要把个人博客的文件从一台电脑转移到另一台电脑。我看知乎上说，直接替换文件夹就行了，我之前好像也这么干过。实际情况也说明确实可以，但是我上面的流程都得走完</p>
<p><a href="https://www.zhihu.com/question/21193762">https://www.zhihu.com/question/21193762</a></p>
<blockquote>
<p>不知道楼主说的是不是换了一台新电脑需要重新部署hexo，如果是的话请往下看。<br>
我从windows换到mac上来，用了上面的一些方法都不成功，其实并没有这么复杂。<br>
首先按照网上搭建hexo的过程一步步重新在新电脑上操作，<br>
之后只要用原电脑的scaffolds, source, themes 和 _config.yml替换新生成的文件就行了。<br>
十分简单～<br>
作者：王璐婷链接：<a href="https://www.zhihu.com/question/21193762/answer/105977542%E6%9D%A5%E6%BA%90%EF%BC%9A%E7%9F%A5%E4%B9%8E%E8%91%97%E4%BD%9C%E6%9D%83%E5%BD%92%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E8%81%94%E7%B3%BB%E4%BD%9C%E8%80%85%E8%8E%B7%E5%BE%97%E6%8E%88%E6%9D%83%EF%BC%8C%E9%9D%9E%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E6%B3%A8%E6%98%8E%E5%87%BA%E5%A4%84%E3%80%82">https://www.zhihu.com/question/21193762/answer/105977542来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a></p>
</blockquote>
<h1>4 主题设置 - 进阶</h1>
<p>hexo 默认的网页比较丑，你可以通过更换主题啥的来更改皮肤。</p>
<p>我这次用的 ayer 主题，但是不是用的这个主题的默认的样子，自己也基于这个主题改了很多东西。</p>
<h2 id="4-1-ayer-主题">4.1 ayer 主题</h2>
<p>看作者自己的中文说明</p>
<p><a href="https://shen-yu.gitee.io/2019/ayer/">https://shen-yu.gitee.io/2019/ayer/</a></p>
<p>下载那些就不说了。</p>
<h3 id="4-1-1-安装主题">4.1.1 安装主题</h3>
<p>作者给了了两种方法</p>
<p><strong>方法一：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 国内用户如果速度较慢，可以把github地址替换为：https:&#x2F;&#x2F;gitee.com&#x2F;mirrors&#x2F;ayer.git</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Shen-Yu&#x2F;hexo-theme-ayer.git themes&#x2F;ayer</span><br></pre></td></tr></table></figure>
<p><strong>方法二（hexo &gt;= 5.0）：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm i hexo-theme-ayer -S</span><br></pre></td></tr></table></figure>
<ul>
<li>如果是新安装本主题，安装完成后会在根目录生成一个<code>_config.ayer.yml</code>文件，直接编辑<code>_config.ayer.yml</code>文件进行配置即可。</li>
<li>如果是主题升级，可以使用方法一，也可以将原来的配置文件移动到根目录，并重命名为<code>_config.ayer.yml</code>。</li>
</ul>
<p><strong>我选了方法一</strong>。因为方法二就是在根目录下生成了 <code>_config.ayer.yml</code> 文件，没有生成 <code>/theme/ayer</code> 文件夹 ，不便于我之后修改。</p>
<p>使用方法一，之后可以直接修改 <code>/theme/ayer</code> 文件夹中的配置文件。</p>
<h3 id="4-1-2-安装必须插件">4.1.2 安装必须插件</h3>
<p>第一个插件，用于搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>然后将下面的内容复制到 根目录下的  <code>_config.yml</code> 里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hexo-generator-searchdb</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br></pre></td></tr></table></figure>
<p>另一个插件，用于生成RSS订阅</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>
<p>然后将下面的内容复制到 根目录下的  <code>_config.yml</code> 里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feed:</span><br><span class="line">    type: atom</span><br><span class="line">    path: atom.xml</span><br><span class="line">    limit: 20</span><br><span class="line">    hub:</span><br><span class="line">    content:</span><br><span class="line">    content_limit: 140</span><br><span class="line">    content_limit_delim: &#39; &#39;</span><br><span class="line">    order_by: -date	</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-1-3-“分类”页面">4.1.3 “分类”页面</h3>
<p>运行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<p>然后将以下复制到 /source/categories/index.md 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="4-1-4-“标签”页面">4.1.4 “标签”页面</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>同样配置相应的 <a href="http://index.md">index.md</a> 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">layout: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="4-1-5-友情链接">4.1.5 友情链接</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page friends</span><br></pre></td></tr></table></figure>
<p>然后将以下复制到 /source/friends/index.md 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: friends</span><br><span class="line">type: friends</span><br><span class="line">layout: &quot;friends&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>然后在 ayer 主题目录下的 <code>_config.yml</code> 中（我用第二种方法，修改根目录下的<code>_config.ayer.yml</code>）自定义 <code>friends_link</code> 配置项即可</p>
<h3 id="4-1-6-相册">4.1.6 相册</h3>
<p>这个我感觉根据个人需求吧，我不热爱摄影，所以我没有用这个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page photos</span><br></pre></td></tr></table></figure>
<p>然后将以下复制到 /source/photos/index.md 文件，<code>img_url</code> 替换成图片路径，<code>caption</code> 替换成图片名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Gallery</span><br><span class="line"></span><br><span class="line">albums: [</span><br><span class="line">        [&quot;img_url&quot;,&quot;img_caption&quot;],</span><br><span class="line">        [&quot;img_url&quot;,&quot;img_caption&quot;]</span><br><span class="line">        ]</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="4-1-7-文章目录">4.1.7  文章目录</h3>
<p>用 Tocbot 解析文章标题并生成目录</p>
<ul>
<li>将以下配置复制到你 ayer 主题目录下的 <code>_config.yml</code> 里（默认就有，不用做）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Toc</span><br><span class="line">toc: true</span><br></pre></td></tr></table></figure>
<ul>
<li>当然你可能并不想所有文章都生成悬浮目录，你可以在文章顶部的配置中加一行来进行关闭：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">no_toc: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="4-1-作者博客的设置">4.1. 作者博客的设置</h3>
<h4 id="front-matter">front matter</h4>
<p>以其中一篇文章为例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 大美湘西</span><br><span class="line">date: 2018-11-21 00:13:57</span><br><span class="line">id: xiangxi</span><br><span class="line">tags:</span><br><span class="line">    - 旅行</span><br><span class="line">    - 国内</span><br><span class="line">categories: </span><br><span class="line">    - 旅行</span><br><span class="line">    - 国内</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>id</strong> : 文章URL，这里应该是用了什么插件吧。这篇文章的URL 就是 <code>https://shen-yu.gitee.io/2018/xiangxi/</code></li>
<li><strong>tags</strong>:  标签，多个标签是平行的。</li>
<li><strong>categories</strong>： 目录，多个目录是有<strong>层级</strong>的。这里国内是旅行的子目录。</li>
</ul>
<p>作者写博客的结构是，先写一段总结式的话，然后断开。后面跟着正文。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>
<h4 id="menu">menu</h4>
<p>这里的设置对应的是网页左侧菜单栏的设置。有几个我注意到的地方</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">旅行: &#x2F;tags&#x2F;旅行&#x2F;</span><br><span class="line">摄影: http:&#x2F;&#x2F;shenyu-vip.lofter.com</span><br><span class="line">关于我: &#x2F;2019&#x2F;about</span><br></pre></td></tr></table></figure>
<p>摄影直接是跳到了一个新的网址，不用多说。</p>
<p>关于我，我看了一下，作者是在<code>source/_post</code> 里有一个 <code>about.md</code>，相当于一个博客。而作者在根目录对URL 的设置为 <strong>年/文章题目</strong>，因此这里就是对应 <code>/2019/about</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">permalink: :year&#x2F;:id&#x2F;</span><br></pre></td></tr></table></figure>
<p>旅行其实就是把 tags 中属于<strong>旅行</strong>的部分单独拿了出来，作为单独的一部分，和你自己点击标签-旅行效果一样。点击进去，网址就是（后面是中文，没有显示好）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;shen-yu.gitee.io&#x2F;tags&#x2F;旅行&#x2F;</span><br></pre></td></tr></table></figure>
<p>我感觉，<strong>menu 的设置就是看这个网址的后面跟着的部分</strong>，这里是在官网后面加了 <code>/tags/旅行/</code>，menu 设置就是 <code>旅行: /tags/旅行/</code> 。关于我的网址是 <code>https://shen-yu.gitee.io/2019/about/</code> ，menu 设置就是 <code>/2019/about</code> 。</p>
<p>所以，如果我想把我对只只的页面加到menu中，网址是 <code>http://vincere.fun/posts/ac7827ff/</code>，menu 就应该添加 <code>我的只只: /posts/ac7827ff</code> 。</p>
<h3 id="4-1-8-自己的设置">4.1.8 自己的设置</h3>
<h4 id="添加-关于我">添加&quot;关于我&quot;</h4>
<p><a href="https://durant35.github.io/2016/01/26/hexo_%E6%B7%BB%E5%8A%A0about%E5%AF%BC%E8%88%AA%E6%A0%8F/">https://durant35.github.io/2016/01/26/hexo_添加about导航栏/</a></p>
<p>先新建一个纯页面。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">hexo</span> <span class="string">new</span> <span class="string">page</span> <span class="string">about</span></span><br></pre></td></tr></table></figure>
<p>直接在<code>/source/about/index.md</code>中写入自己的信息。title 改成 <code>title: About Me</code></p>
<p>修改<code>/theme/ayer</code> 的主题配置文件的开头的目录部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">关于我: &#x2F;about</span><br></pre></td></tr></table></figure>
<p>ok，没有问题。</p>
<h4 id="网页底部统计运行天数">网页底部统计运行天数</h4>
<p><a href="https://blog.csdn.net/qq_35982918/article/details/106728754">https://blog.csdn.net/qq_35982918/article/details/106728754</a></p>
<p>找到 <code>\themes\ayer\layout\_partial\footer.ejs</code> 文件，在文件中（我是放在了最后一个 </ul> 的下面）加入下面一段代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 运行天数 --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;&lt;span id&#x3D;&quot;runtime_span&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;         </span><br><span class="line">    function show_runtime() &#123;</span><br><span class="line">        window.setTimeout(&quot;show_runtime()&quot;, 1000);</span><br><span class="line">        X &#x3D; new Date(&quot;08&#x2F;15&#x2F;2019 21:50:56&quot;);</span><br><span class="line">        Y &#x3D; new Date();</span><br><span class="line">        T &#x3D; (Y.getTime() - X.getTime());</span><br><span class="line">        M &#x3D; 24 * 60 * 60 * 1000;</span><br><span class="line">        a &#x3D; T &#x2F; M;</span><br><span class="line">        A &#x3D; Math.floor(a);</span><br><span class="line">        b &#x3D; (a - A) * 24;</span><br><span class="line">        B &#x3D; Math.floor(b);</span><br><span class="line">        c &#x3D; (b - B) * 60;</span><br><span class="line">        C &#x3D; Math.floor((b - B) * 60);</span><br><span class="line">        D &#x3D; Math.floor((c - C) * 60);</span><br><span class="line">        runtime_span.innerHTML &#x3D; &quot;小站在各种崩坏中坚持了: &quot; + A + &quot;天&quot; + B + &quot;小时&quot; + C + &quot;分&quot; + D + &quot;秒&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    show_runtime();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>改成我和只只在一起的时间</p>
<p>这里就是把 runtime_span 改成 lovetime_span</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 与只只在一起天数 --&gt;</span><br><span class="line"> &lt;ul&gt;</span><br><span class="line">     &lt;li&gt;&lt;span id&#x3D;&quot;lovetime_span&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;</span><br><span class="line"> &lt;&#x2F;ul&gt;</span><br><span class="line"> &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;         </span><br><span class="line">     function show_runtime() &#123;</span><br><span class="line">         window.setTimeout(&quot;show_runtime()&quot;, 1000);</span><br><span class="line">         X &#x3D; new Date(&quot;03&#x2F;04&#x2F;2021 22:11:00&quot;);</span><br><span class="line">         Y &#x3D; new Date();</span><br><span class="line">         T &#x3D; (Y.getTime() - X.getTime());</span><br><span class="line">         M &#x3D; 24 * 60 * 60 * 1000;</span><br><span class="line">         a &#x3D; T &#x2F; M;</span><br><span class="line">         A &#x3D; Math.floor(a);</span><br><span class="line">         b &#x3D; (a - A) * 24;</span><br><span class="line">         B &#x3D; Math.floor(b);</span><br><span class="line">         c &#x3D; (b - B) * 60;</span><br><span class="line">         C &#x3D; Math.floor((b - B) * 60);</span><br><span class="line">         D &#x3D; Math.floor((c - C) * 60);</span><br><span class="line">         lovetime_span.innerHTML &#x3D; &quot;只只和周周在一起了 &quot; + A + &quot;天&quot; + B + &quot;小时&quot; + C + &quot;分&quot; + D + &quot;秒&quot;</span><br><span class="line">     &#125;</span><br><span class="line">     show_runtime();</span><br><span class="line"> &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="网页底部取消hexo-和-ayer-推荐">网页底部取消hexo 和 ayer 推荐</h4>
<p>找到 <code>\themes\ayer\layout\_partial\footer.ejs</code> 文件，删除下面这一部分代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;% if (theme.pageFooter)&#123; %&gt;</span><br><span class="line">    &lt;% var hexoLink &#x3D; &#39;&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;hexo.io&quot; target&#x3D;&quot;_blank&quot;&gt;Hexo&lt;&#x2F;a&gt;&#39;; %&gt;</span><br><span class="line">    &lt;% var themeLink &#x3D; &#39;&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;github.com&#x2F;Shen-Yu&#x2F;hexo-theme-ayer&quot; target&#x3D;&quot;_blank&quot;&gt;Ayer&lt;&#x2F;a&gt;&#39;; %&gt;</span><br><span class="line">    &lt;%- __(&#39;powered_by&#39;, hexoLink) %&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;division&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;%- __(&#39;theme&#39;, themeLink) %&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">  &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>
<h4 id="文章置顶">文章置顶</h4>
<p><a href="http://wangwlj.com/2018/01/09/blog_pin_post/">http://wangwlj.com/2018/01/09/blog_pin_post/</a></p>
<p><a href="https://github.com/netcan/hexo-generator-index-pin-top">https://github.com/netcan/hexo-generator-index-pin-top</a></p>
<p>安装插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm uninstall hexo-generator-index --save</span><br><span class="line">cnpm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>
<p>需要置顶的文件 front matter 添加 <code>top: true</code>。</p>
<p>这就可以了。Github 里说还要设置根目录的配置文件，好像不需要。</p>
<h4 id="valine-评论系统">valine 评论系统</h4>
<p><a href="https://www.playpi.org/2019032001.html">https://www.playpi.org/2019032001.html</a></p>
<p>先去 <a href="https://www.leancloud.cn/">leancloud</a> 注册账号，然后<strong>创建一个应用</strong>（我起名为blog）,然后 进入应用-&gt;设置-&gt;应用key，获取你的appid 和 appkey 。</p>
<p>第二步，应用-&gt;设置-&gt;安全中心，将上方<strong>数据存储</strong>以外的服务全部关闭，因为用不到。然后设置下方的 <strong>Web 安全域名</strong>。</p>
<blockquote>
<p><s>里面一定要填写自己站点的域名，并且带上端口号，例如 <code>http</code> 请求的默认端口就是 80，<code>https</code> 请求的默认端口就是 443。这里如果没有配置好，评论的时候也会失败的。</s></p>
</blockquote>
<p>设置端口会出错，不设置端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;vincere.fun</span><br><span class="line">http:&#x2F;&#x2F;www.vincere.fun</span><br></pre></td></tr></table></figure>
<p>如果提示下面这句话，刷新一下，或等待一段时间。（可能是网页接受邮箱验证迟钝）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Invalid access, mismatch xsrf token.</span><br></pre></td></tr></table></figure>
<p>将应用的appid 和 appkey 复制到 ayer的主题配置中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leancloud:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: yHN3kf7fHt5wvleM2DVoHLdY-gzGzoHsz</span><br><span class="line">  app_key: RPIwmdftljIzOtAULwc7JCAp</span><br></pre></td></tr></table></figure>
<h5 id="推到远端报错">推到远端报错</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh: connect to host github.com port 22: Connection timed out</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我感觉是那个 <strong>Web 安全域名</strong> 的80端口设置错了，改成不设置端口。</p>
<p>确实是这个原因，取消端口就没事了。</p>
<h5 id="部分博客取消评论">部分博客取消评论</h5>
<p>设置好 valine 默认所有博客均有评论，如果有些博客不想要评论，那么在 front matter 部分设置一下，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">comments: false</span><br></pre></td></tr></table></figure>
<h5 id="查看leancloud-中的评论数据">查看leancloud 中的评论数据</h5>
<blockquote>
<p>好了，此时可以再回到 <code>Leancloud</code> 系统，看一下评论数据吧。直接在 <strong>存储 -&gt; 数据 -&gt;Comment</strong> 里面，可以看到已经有评论数据了。由于 <code>Valine</code> 是无后端的评论系统，所以数据直接被存储到了 <code>Leancloud</code> 系统的数据库表里面，看看就行了，不方便管理。如果评论数据很多，为了更方便管理评论数据，能收到更友好的邮件通知提醒，可以使用 <code>Valine-Admin</code> 来实现</p>
</blockquote>
<p>不过这里可以全选，删除所有的评论。（用于测试）</p>
<h5 id="Code-403：访问被API域名白名单拒绝，请检查你的安全域名设置">Code 403：访问被API域名白名单拒绝，请检查你的安全域名设置</h5>
<p>我使用了 https协议 之后，评论框就出现了上面的文字。因为是网址变了。</p>
<p>解决办法：在 leancloud 的评论应用&gt;设置&gt;安全中心&gt;Web安全域名中修改新的域名</p>
<h4 id="valine-admin">valine-admin</h4>
<h5 id="快速开始">快速开始</h5>
<p><a href="https://github.com/zhaojun1998/Valine-Admin">https://github.com/zhaojun1998/Valine-Admin</a></p>
<p>首先进入 leancloud 的应用中，本来是这么说的</p>
<blockquote>
<p>点击 <code>云引擎 -&gt; 设置</code> 填写代码库并保存：<code>https://github.com/zhaojun1998/Valine-Admin</code></p>
</blockquote>
<p>但我在这个地方根本没有找到所谓的<strong>代码库</strong>，然后从网上找了一下资料（<a href="https://github.com/DesertsP/Valine-Admin/issues/109%EF%BC%89%EF%BC%8C%E4%BB%96%E4%BB%AC%E8%AF%B4%E5%9C%A8">https://github.com/DesertsP/Valine-Admin/issues/109），他们说在</a><strong>云引擎-web组-部署-部署项目-git部署-配置git</strong>，找到了可以复制的地方，复制上面的路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;zhaojun1998&#x2F;Valine-Admin</span><br></pre></td></tr></table></figure>
<p>然后再次<strong>点击 Git 部署 -&gt; 部署</strong>即可（第一次部署可能会需要些时间。不点击不会生效的）</p>
<h5 id="配置项">配置项</h5>
<p>云引擎-web组-设置中，添加下面的环境变量</p>
<p>必选参数</p>
<ul>
<li><code>SITE_NAME</code> : 网站名称。</li>
<li><code>SITE_URL</code> : 网站地址, <strong>最后不要加 <code>/</code> 。</strong></li>
<li><code>SMTP_USER</code> : SMTP 服务用户名，一般为邮箱地址。</li>
<li><code>SMTP_PASS</code> : SMTP 密码，一般为授权码，而不是邮箱的登陆密码，请自行查询对应邮件服务商的获取方式</li>
<li><code>SMTP_SERVICE</code> : 邮件服务提供商，支持 <code>QQ</code>、<code>163</code>、<code>126</code>、<code>Gmail</code>、<code>&quot;Yahoo&quot;</code>、<code>......</code> ，全部支持请参考 : <a href="https://nodemailer.com/smtp/well-known/#supported-services">Nodemailer Supported services</a>。 — <em>如这里没有你使用的邮件提供商，请查看<a href="https://github.com/zhaojun1998/Valine-Admin/blob/master/%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE.md#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8">自定义邮件服务器</a></em></li>
<li><code>SENDER_NAME</code> : 寄件人名称。</li>
</ul>
<p>如果不能修改，出现下面的提示信息，不要怕，刷新一下网站可能就好了。我也不知道这是什么鬼东东。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Failed to fetch [N&#x2F;A PATCH &#x2F;engine&#x2F;groups&#x2F;web]</span><br></pre></td></tr></table></figure>
<p>这里 SMTP_PASS 用到了授权码，163邮箱获取授权码的方式如下（网页端就可以拿到）：</p>
<p><a href="https://help.mail.163.com/faqDetail.do?code=d7a5dc8471cd0c0e8b4b8f4f8e49998b374173cfe9171305fa1ce630d7f67ac2cda80145a1742516">https://help.mail.163.com/faqDetail.do?code=d7a5dc8471cd0c0e8b4b8f4f8e49998b374173cfe9171305fa1ce630d7f67ac2cda80145a1742516</a></p>
<p><a href="https://github.com/DesertsP/Valine-Admin">https://github.com/DesertsP/Valine-Admin</a></p>
<p>这里提到还有一个必选的变量， SENDER_EMAIL （发件邮箱）</p>
<p>最终设置如下</p>
<p><img src="1.png" alt="1"></p>
<p>修改后记得点击<strong>保存</strong>。</p>
<p>之后再次<strong>点击 Git 部署 -&gt; 部署</strong>，才会生效</p>
<h5 id="查看日志">查看日志</h5>
<p>云引擎 - WEB - 日志</p>
<p>这里可以查看所有的历史，包括部署项目，接收到的评论</p>
<p><img src="2.png" alt="1"></p>
<h5 id="leancloud-休眠策略">leancloud 休眠策略</h5>
<blockquote>
<p>免费版的 LeanCloud 容器，是有强制性休眠策略的，不能 24 小时运行：</p>
<ul>
<li>每天必须休眠 6 个小时</li>
<li>30 分钟内没有外部请求，则休眠。</li>
<li>休眠后如果有新的外部请求实例则马上启动（但激活时此次发送邮件会失败）。</li>
</ul>
<p>分析了一下上方的策略，如果不想付费的话，最佳使用方案就设置定时器，每天 7 - 23 点每 20 分钟访问一次，这样可以保持每天的绝大多数时间邮件服务是正常的。</p>
</blockquote>
<p>这个休眠的影响，貌似是说，休眠期间第一个评论可能不会有邮件提醒。</p>
<p><a href="https://github.com/DesertsP/Valine-Admin">https://github.com/DesertsP/Valine-Admin</a></p>
<p>云引擎 - 定时任务</p>
<p>创建两个定时任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 *&#x2F;30 0-16 * * ?</span><br></pre></td></tr></table></figure>
<p>表示每天早0点到晚16点每隔30分钟访问云引擎</p>
<p><img src="3.png" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 0 * * ?</span><br></pre></td></tr></table></figure>
<p>表示每天0点检查过去24小时内漏发的通知邮件并补发（如果要修改时间，就修改第三个数即可）。</p>
<p><img src="4.png" alt="1"></p>
<p>有的教程说要对于新建的定时任务要点击一下启动，但是我看leancloud页面已经没有启动按钮了，只有正常和暂停，应该就不用做什么了。</p>
<p><img src="5.png" alt="1"></p>
<p>不过，为了保险，我还是重新部署了一下。</p>
<h5 id="评论管理">评论管理</h5>
<p><a href="https://blog.csdn.net/u012208219/article/details/106883083">https://blog.csdn.net/u012208219/article/details/106883083</a></p>
<p>首先，先绑定域名（必须经过备案）。</p>
<p>在leancloud - 设置 - 域名绑定 - 云引擎域名中设置</p>
<p><img src="6.png" alt="1"></p>
<p>之后，这里显示 “正在检查备案信息”。</p>
<p>绑定失败了，我再查一下我的备案信息</p>
<p>如果这一步成功了，下一步进行初始化管理。</p>
<blockquote>
<p>打开绑定的域名+<code>/sign-up</code>，例如我的域名为<code>https://xiaokang.avosapps.us/</code>，那么我访问的地址就是<code>https://xiaokang.avosapps.us/sign-up</code>。</p>
</blockquote>
<p>接下来就可以用刚才的邮箱或者登录名登录了。</p>
<h6 id="没有域名备案，做不了">没有域名备案，做不了</h6>
<p>关于域名备案的问题，这里就说的很清楚了。也就是说，买了域名还要有服务器才能用，我是绑定了 Github，是国外的浏览器，所以不用备案，估计也没法备案了。</p>
<p><a href="https://zhuanlan.zhihu.com/p/33908110">https://zhuanlan.zhihu.com/p/33908110</a></p>
<blockquote>
<p>另外有了只有域名当然是不行的，还需要拥有自己的服务器，但是国内的服务器如阿里云绑定域名后还需要备案才能使用，很麻烦，下面我们利用<a href="https://link.zhihu.com/?target=https%3A//pages.github.com/36fda622.html">Github pages</a>来实现网页表白，因为Github的服务器在国外，所以小伙伴们不用担心备案的问题。</p>
</blockquote>
<h4 id="leancloud-设置失败就刷新一下网页">leancloud 设置失败就刷新一下网页</h4>
<p>说不定就好了。这种情况我碰到了不是一次两次了，开始还以为咋出了问题，后面才知道这玩意就这样，就刷新一下网页再设置一下可能就好了。</p>
<h4 id="文章url链接持久化">文章url链接持久化</h4>
<p><a href="https://www.fadai.cc/posts/fb8c11fe/">https://www.fadai.cc/posts/fb8c11fe/</a></p>
<blockquote>
<p>hexo默认生成的文章是以“年/月/日/文章标题”为路径存储的，这样的url结构超过了3层，对百度等其他搜索引擎的爬虫十分不友好，导致文章迟迟没有收录。我们可以通过安装链接持久化的插件优化我们的文章地址。</p>
</blockquote>
<h5 id="安装hexo-abbrlink-插件">安装<code>hexo-abbrlink</code> 插件</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>
<h5 id="修改根目录的配置文件">修改根目录的配置文件</h5>
<p>首先修改一个地方</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink: posts&#x2F;:abbrlink&#x2F;</span><br></pre></td></tr></table></figure>
<p>然后在文件文件末尾添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># abbrlink config</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32      #支持crc16（默认）和crc32</span><br><span class="line">  rep: hex        #支持dec（默认）和hex</span><br><span class="line">  drafts: false   #（true）处理草稿，（false）不处理草稿。false（默认）</span><br><span class="line">  # 从目录树生成类别</span><br><span class="line">  # depth: 要生成的目录树的最大深度，应大于0</span><br><span class="line">  auto_category:</span><br><span class="line">     enable: true  #true(默认)</span><br><span class="line">     depth:        #3(默认)</span><br><span class="line">     over_write: false </span><br><span class="line">  auto_title: false #启用自动标题，可按路径自动填充标题</span><br><span class="line">  auto_date: false #启用自动日期功能，可以按今天的时间自动填充日期</span><br><span class="line">  force: false #启用强制模式，在此模式下，插件将忽略缓存，并为每个帖子计算abbrlink，即使它已经有了abbrlink。</span><br></pre></td></tr></table></figure>
<p>最后重新推到远端就好了。</p>
<h4 id="添加音乐">添加音乐</h4>
<p><a href="http://yearito.cn/posts/hexo-writing-skills.html">http://yearito.cn/posts/hexo-writing-skills.html</a></p>
<h5 id="网易云音乐">网易云音乐</h5>
<p><a href="http://yearito.cn/posts/hexo-writing-skills.html">http://yearito.cn/posts/hexo-writing-skills.html</a></p>
<p>在<strong>网页版</strong>云音乐中找到歌曲，点击<strong>生成外链播放器</strong>。复制 iframe 插件的 <strong>HTML 代码</strong>。</p>
<p>我这里是飞奔向你的代码（为了让播放器居中，这里使用 <center> 标签）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;center&gt;</span><br><span class="line">&lt;iframe frameborder&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; marginwidth&#x3D;&quot;0&quot; marginheight&#x3D;&quot;0&quot; width&#x3D;330 height&#x3D;86 src&#x3D;&quot;&#x2F;&#x2F;music.163.com&#x2F;outchain&#x2F;player?type&#x3D;2&amp;id&#x3D;1483786045&amp;auto&#x3D;1&amp;height&#x3D;66&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line">&lt;&#x2F;center&gt;</span><br></pre></td></tr></table></figure>
<p>如果播放器宽度将会被拉长占满整个页宽，找到 <code>themes\next\source\js\src\utils.js</code> 这个文件，注释掉 <code>music.163.com</code> ( <strong>//</strong> 注释)</p>
<p>这种方式什么插件都不用（ok，真的可以）。直接把代码复制到markdown中就行（不要用代码框啥的），比如上面的“飞奔向你”</p>
<h5 id="aplayer">aplayer</h5>
<p>安装插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-tag-aplayer --save</span><br></pre></td></tr></table></figure>
<p>可用选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% aplayer title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx] %&#125;</span><br></pre></td></tr></table></figure>
<p>其中，各参数意义如下：</p>
<ul>
<li>title: 曲目标题</li>
<li>author: 曲目作者</li>
<li>url: 音乐文件 URL 地址</li>
<li>picture_url: (可选) 音乐对应的图片地址</li>
<li>narrow: （可选）播放器袖珍风格</li>
<li>autoplay: (可选) 自动播放，移动端浏览器暂时不支持此功能</li>
<li>width:xxx: (可选) 播放器宽度 (默认: 100%)</li>
<li>lrc:xxx: （可选）歌词文件 URL 地址</li>
</ul>
<p>我实际是把歌曲下载了下来，用网址发现没用，实际命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% aplayer &quot;因为你 所以我&quot; &quot;五月天&quot; &quot;&#x2F;images&#x2F;you_than_me.mp3&quot; &quot;&#x2F;images&#x2F;music1.jpg&quot; %&#125;</span><br></pre></td></tr></table></figure>
<h4 id="看板娘">看板娘</h4>
<p>看板娘就是网页中的小动物/人偶形象，具体效果可以通过电脑看我的博客：<a href="https://vincere.fun/">https://vincere.fun/</a></p>
<p><a href="https://blog.csdn.net/qq_35982918/article/details/106728754">https://blog.csdn.net/qq_35982918/article/details/106728754</a></p>
<p>安装插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-helper-live2d  --save</span><br></pre></td></tr></table></figure>
<p>下载模型（预览图 <a href="https://huaji8.top/post/live2d-plugin-2.0/">https://huaji8.top/post/live2d-plugin-2.0/</a> ）</p>
<p>这里我选 wanko ，小狗狗</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install live2d-widget-model-wanko </span><br></pre></td></tr></table></figure>
<p>修改根目录配置文件，添加下面的内容</p>
<p>我关闭手机端显示，因为我发现在手机端有点碍事。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Live2D动画</span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local</span><br><span class="line">  pluginRootPath: live2dw&#x2F;</span><br><span class="line">  pluginJsPath: lib&#x2F;</span><br><span class="line">  pluginModelPath: assets&#x2F;</span><br><span class="line">  tagMode: false</span><br><span class="line">  debug: false</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-wanko </span><br><span class="line">  display:</span><br><span class="line">    position: left</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">    hOffset: 80</span><br><span class="line">    vOffset: -70</span><br><span class="line">  mobile:</span><br><span class="line">    show: false</span><br><span class="line">    scale: 0.5 </span><br></pre></td></tr></table></figure>
<h4 id="为hexo添加上标、下标、脚注等功能">为hexo添加上标、下标、脚注等功能</h4>
<p><a href="https://www.jianshu.com/p/588ab3d22eb8">https://www.jianshu.com/p/588ab3d22eb8</a></p>
<p>使用插件 <strong>hexo-renderer-markdown-it</strong></p>
<p>先卸载旧的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm un hexo-renderer-marked --save</span><br></pre></td></tr></table></figure>
<p>再装新的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm i hexo-renderer-markdown-it --save</span><br></pre></td></tr></table></figure>
<p>在根目录下的目录文件进行配置，只需要进行简单配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Markdown-it config</span><br><span class="line">#markdown: &#39;zero&#39;</span><br><span class="line">#markdown: &#39;default&#39;</span><br><span class="line">markdown: &#39;commonmark&#39;</span><br></pre></td></tr></table></figure>
<p>每种简单配置有其默认的一些设置。更多个性化配置，请参考：高级配置。</p>
<ul>
<li>zero：禁用大多数解析器功能。仅支持斜体和粗体，甚至不支持所有原始Markdown功能。</li>
<li>default（GFM）：解析器的行为类似于github规范。</li>
<li>commonmark：提供比Zero预设更多的功能。 此设置将强制插件使用最新的CommonMark规范。</li>
</ul>
<h5 id="缩写">缩写</h5>
<p><a href="https://www.jianshu.com/p/62f2ded11f8f">https://www.jianshu.com/p/62f2ded11f8f</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;abbr title&#x3D;&quot;residual standard error&quot;&gt;RSE&lt;&#x2F;abbr&gt;</span><br></pre></td></tr></table></figure>
<p>title 写入完整名称。</p>
<h5 id="脚注">脚注</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">basic footnote[^1]</span><br><span class="line">here is an inline footnote[^2](inline footnote)</span><br><span class="line">and another one[^3]</span><br><span class="line">and another one[^4]</span><br><span class="line"></span><br><span class="line">[^1]: basic footnote content</span><br><span class="line">[^3]: paragraph</span><br><span class="line">footnote</span><br><span class="line">content</span><br><span class="line">[^4]: footnote content with some [markdown](https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Markdown)</span><br></pre></td></tr></table></figure>
<p>我估摸着，写法就是文本的地方手动插入脚注[^1]，末尾写入注释内容</p>
<p>[^1]: basic footnote content</p>
<h5 id="下标">下标</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">H~2~0 &#x3D;&gt; H&lt;sub&gt;2&lt;&#x2F;sub&gt;O</span><br></pre></td></tr></table></figure>
<h5 id="上标">上标</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">29^th^ &#x3D;&gt; 29&lt;sup&gt;th&lt;&#x2F;sup&gt;</span><br></pre></td></tr></table></figure>
<h5 id="插入（下划线）">插入（下划线）</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">++inserted++ &#x3D;&gt; &lt;ins&gt;inserted&lt;&#x2F;ins&gt;</span><br></pre></td></tr></table></figure>
<p><ins>inserted</ins></p>
<h3 id="4-1-9-目前所有可用的front-matter">4.1.9 目前所有可用的front matter</h3>
<p>新建一个博客之后，目前所有可用的 front matter 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tags: </span><br><span class="line">categories:</span><br><span class="line">top:       #置顶，默认false</span><br><span class="line">reward:    #是否显示打赏，我这里默认false</span><br><span class="line">comments:  #是否允许评论，默认true</span><br></pre></td></tr></table></figure>
<p>写好 front matter 后，<strong>写一段总结的话</strong>，然后加入阅读更多的截断。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>
<p>之后就是正文，就想怎么写怎么写了</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>linear algebra step by step</title>
    <url>/posts/aec3be7e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这本书的名字就是 ，作者是 Kuldeep Singh。这本书主要是讲解线性代数的基础知识，是我目前看过的关于线代的书中讲的最清楚的。看完这本书，我才有一种恍然大悟的感觉，才有一点线代学通了的感觉。不过我没有记笔记，这里只是安利。</p>
<span id="more"></span>
<p>这本书的电子版可以在<a href="http://libgen.rs/">Library Genesis</a> 下载到。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>模型学习笔记</title>
    <url>/posts/9664406d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>线性模型学习的大杂烩，之后再拆分。</p>
<span id="more"></span>
<h1>Linear Models for the Prediction of Animal Breeding Values</h1>
<h2 id="第一章-基础">第一章 基础</h2>
<h3 id="通过个体自身记录估计育种值">通过个体自身记录估计育种值</h3>
<p><img src="single_record_by_own_performance.png" alt=""></p>
<blockquote>
<p>The corrlelation between the selection criterion, in this case the phenotypic value, and the true breeding value is known as the accuracy of prediction.</p>
</blockquote>
<p>这段话是说在这种情况下，表型和育种值的相关便是预测准确性（the accuracy of prediction）。但是这里的育种值用的就是the true breeding value，也就是平常说的估计育种值？<br>
而某些情况下，对准确性进行平方，称为可靠性（reliability or repeatability,r^2），即相关系数的平方。</p>
<h1>Computing Strategies for Solving Mixed Model Equations</h1>
<p>对大量方程组的求解通常采用迭代技术因为数据太大，使得直接求逆时无法全部储存再内存中。（Solution of a  large set of equations is usually by iteration techniques because they are too large to store in the memory of the com- puter for direct inversion）<br>
虽然BLUP可能是最好的分析线性模型的方法，但是其计算的复杂度使得研究者需要使用简单的模型，或者采用除BLUP外的其他方法。因此，可计算性（computability）非常重要。<br>
本文是单纯<strong>从理论上</strong>比较不同的计算MME的策略</p>
<h2 id="模型">模型</h2>
<p>用的是牛的数据，固定效应为场年季（HYS,herd-year-season)，随机效应为公牛效应。</p>
<h2 id="计算方法">计算方法</h2>
<p>假设有50万个奶牛观测值，均来自于 1万头公牛，5万个场年季水平。假定每个场年季水平包括来自于6头不同的公牛的10个女儿成绩。那么就会有30万个公牛×场年季亚水平。<br>
像数据量这么庞大的情况下，直接求逆是不可能的。</p>
<h2 id="第一种方法-–-直接方法-Straightforward-Approach">第一种方法 – 直接方法(Straightforward  Approach)</h2>
<p>将系数矩阵的所有非0值存储在硬盘中，每一行为所在行id，所在列id，值。(感觉类似为DMU跑出的G阵)。<br>
<strong>y = Wh + Zs + e</strong><br>
MME中<strong>W’W</strong>是包含了50,000个非零元素的对角线矩阵（其中的值为每个场年季水平的重复数）。<strong>Z’Z</strong>也是包含了10,000个非零元素的对角线矩阵（在动物模型中，对角线元素只有0和1，表示有无表型）。<strong>W’Z</strong>和<strong>Z’W</strong>互为转置矩阵，且各包含300,000个非零值（实际为HYS×sire的亚水平的重复数）。那么系数矩阵就总共有600,000个非零元素。Any iterative solution program must read each element once during each round of iteration. Conveniently, unless there are covariates in the model, these nonzero elements are integer variables, but the time to solve the equations depends on the speed with  which  the 660,000 records can be retrieved from disk.（这一段大概说，每一次迭代都要读取每一个数字，因此从硬盘读取的速度和数字大小就影响了计算速度，不知道求逆怎么迭代？）。For example, W’W and Z’Z are diagonal matrices and the diagonals could be stored in program memory rather than disk, and thus, only 600,000   nonzero elements need to be stored on disk（作者给出的意见是，因为W’W和Z’Z是对角线元素，因此可以直接放在内存中，其他还放在硬盘中。）<br>
第四部分还要加上KA^-1^。</p>
<h2 id="第二种方法-Absorption-Approach">第二种方法-- Absorption Approach</h2>
<p>The absorption or elimination technique whereby a large diagonal submatrix can be absorbed into the other equations is frequently used for the solution of large sets of equations. Absorption of HYS equations into sire equations gives Z’MZ and Z’My, where M = I - W(W’W)^-I^W’. The resulting equations to solve are<br>
(Z’MZ + A^-1^k)s^ = Z’My (s^即s估计值）<br>
……<br>
Consequently, even though the absorption approach yields only 10,000 equations, we may have more records to read during each round of iteration, and therefore, <strong>computing costs would increase</strong>. Also, the extra program steps to sort and add together “like” coefficients is a disadvantage of the absorption approach.<br>
看不懂，不过看最后的结语，貌似计算难度还提高了。</p>
<h2 id="第三种方法–Indirect-Approach">第三种方法–Indirect Approach</h2>
<p>In this method data are arranged in HYS by sire subclasses sorted by HYS. Each record consists of HYS and sire identification with the corresponding number of daughters and the sum of daughter Observations in the subclass. Thus, we would have 300,000 subclasses for the example.<br>
If Y~Ij.~ is the subclass total and n~ij~ is the number of daughters for the jth sire in the ith<br>
HYS, then we accumulate the quantity, over sires within HYS:<br>
Y~ij.~ - n~ij~s~j~^</p>
<p>where s~j~^ is the current  solution for sire j. Then the new solution for the i^th^ HYS is<br>
……后面真看不懂</p>
<h2 id="小结">小结</h2>
<p>Prediction error variances of sire evaluations can be approximated in the same manner as<br>
with the absorption approach. The number of effective daughters, or the diagonals of Z’MZ, can be obtained while reading the HYS subclasses,but another vector of length equal to the number of sires would be needed to accumulate the information across HYS.<br>
（<strong>PEV</strong>可以通过第二种方法Absorption Approach近似估计。）<br>
The main advantage of the  indirect approach is that only one relatively simple computer program is necessary to obtain solutions for mixed model equations. At this point,  rate of convergence of the indirect approach compared with other methods is unknown. However, in the sire model  of [1], if the solutions for HYS are close to the mean of records in that HYS, then convergence should be relatively quick because HYS means are the solutions  after  the first iteration. Knowing I’A^-1^s  should be zero can also speed convergence<br>
(没看懂，好像是说第三种间接方法只适用于模型不变时？)</p>
<h1>Indirect Solution of Mixed Model Equations</h1>
<p>Two iterative procedures were investigated, Gauss-Seidel and Jacobi.With a balanced dara set, putting restrictions on fixed effects is not effective for improving convergence ratcs in GaussSeidel but is essential in Jacobi.</p>
<h2 id="引言">引言</h2>
<p>构建MME需要花很长时间。Schaeffer and Kennedy 展示了一种不用构建the system of equations的策略。他们的策略，称之为indirect approach,performs Gauss-Seidel (G-S) or successive overrelaxation (SOR) iteration while reading the data files rather than the matrix of coefficients.The data files, read once per round of iteration, consist of two copies of an observation file, each sorted for a different factor with a large number of levels, and three<br>
copies of a relationship file, also sorted differently.<br>
Misztal (2, 3) proposed another indirect approach using Jacobi (J) iteration (8). Programming<br>
is simpler, because only one unsorted copy of each of the observation and relationship files need to be read per round of iteration.Basic J iteration has a poor convergence rate,especially for models with many factors or with a random factor including t~ numerator relationship matrix. However, putting restrictions on the effects of levels of fixed factors and extending the method to second·order J made it competitive in running time relative to other methods; convergence rate was approximately half ,ha’ of SOR (8)<br>
This paper presents the indirect approach in terms of succesive averaging, investigates its<br>
properties, and describes several computing options.z<br>
还是看不懂，这个真的是纯方法。两种迭代方式。优点就是不用构建MME了。</p>
<h1>python 进行矩阵求解</h1>
<p>宋师兄是从from scipy import linalg，但其实numpy 本身也有这个linalg, 也可以实现相同的功能。<br>
宋师兄python- GBLUP</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> pysnptools.snpreader <span class="keyword">import</span> Bed</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> linalg</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment">###构建G矩阵###</span></span><br><span class="line"><span class="comment"># PLINK bed文件名</span></span><br><span class="line">bed_file = <span class="string">&#x27;plink2&#x27;</span></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">M = Bed(bed_file, count_A1=<span class="literal">False</span>).read()</span><br><span class="line"><span class="comment"># 计算每个位点的等位基因频率</span></span><br><span class="line">freq = np.<span class="built_in">sum</span>(M.val, axis=<span class="number">0</span>) / (<span class="number">2</span> * M.iid_count)</span><br><span class="line"><span class="comment"># 计算标准化因子</span></span><br><span class="line">scale = np.<span class="built_in">sum</span>(<span class="number">2</span> * freq * (<span class="number">1</span> - freq))</span><br><span class="line"><span class="comment"># 计算Z矩阵</span></span><br><span class="line">Z = M.val - <span class="number">2</span> * freq</span><br><span class="line"><span class="comment"># 计算G矩阵</span></span><br><span class="line">G = np.dot(Z, Z.T) / scale</span><br><span class="line"><span class="comment">#对角线向量加0.001</span></span><br><span class="line">d = np.diag(G) + <span class="number">0.001</span></span><br><span class="line"><span class="comment">#替换原来的G矩阵对角线</span></span><br><span class="line">np.fill_diagonal(G, d)</span><br><span class="line"><span class="comment">#求逆</span></span><br><span class="line">Ginv = linalg.inv(G)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#读取数据文件</span></span><br><span class="line">data_file = <span class="string">&#x27;phe&#x27;</span></span><br><span class="line">data = pd.read_table(data_file, header=<span class="number">0</span>, sep = <span class="string">&#x27;\s+&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> data.head()</span><br><span class="line"><span class="comment">#数据文件有6列，ID、mean、sex、age、、phe。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#表型向量</span></span><br><span class="line">y = np.array(data[<span class="string">&#x27;phe&#x27;</span>], dtype = np.<span class="built_in">float</span>)</span><br><span class="line"><span class="comment">#固定效应设计矩阵</span></span><br><span class="line">X = np.array(data.loc[:,<span class="string">&#x27;mean&#x27;</span>:<span class="string">&#x27;treat&#x27;</span>], dtype = np.<span class="built_in">float</span>)</span><br><span class="line">	<span class="comment"># data.loc中表示，提取mean列到treat列的所有行</span></span><br><span class="line">	<span class="comment"># treat没出现在前面，估计是第5列</span></span><br><span class="line">	<span class="comment"># 这个也不符合固定效应关联矩阵的定义啊，搞不懂</span></span><br><span class="line">	<span class="comment"># 反正这里的X阵，应该不是理论上的固定效应设计矩阵，它的行数和表型数目一致，所以下文中，才能对X阵,Z阵按列进行合并，形成什么W阵。</span></span><br><span class="line"><span class="comment">#随机效应矩阵为单位阵</span></span><br><span class="line">num = <span class="built_in">len</span>(y)  <span class="comment">#个体数</span></span><br><span class="line">Z =  np.eye(num) </span><br><span class="line">	<span class="comment">#他这里的Z矩阵是表型个数的单位阵</span></span><br><span class="line">	<span class="comment">#按常规BLUP，Z矩阵是对角阵，但是有表型的是1，没表型的是0</span></span><br><span class="line">	<span class="comment">#难道这里宋师兄都是有表型的个体，不对吧？那预测啥个体啊？</span></span><br><span class="line"><span class="comment">#W矩阵</span></span><br><span class="line">W = np.concatenate((X, Z), axis = <span class="number">1</span>)</span><br><span class="line">	<span class="comment">#concatenate 数组拼接函数 axis=1,是按列合并</span></span><br><span class="line">	<span class="comment">#就是说合并的两个矩阵要有相同的行数。</span></span><br><span class="line">	<span class="comment">#嗯嗯，X和Z行数就是相同的</span></span><br><span class="line"><span class="comment">#构建W’R-1W，由于残差方差是独立同分布的，可以写为</span></span><br><span class="line">C = np.dot(W.T, W)/<span class="number">0.139</span></span><br><span class="line">	<span class="comment">#np.dot 正常的矩阵相乘，这里就是W‘*W。</span></span><br><span class="line">	<span class="comment">#0.139不知道什么意思，是不是残差方差</span></span><br><span class="line">	<span class="comment">#懂了，因为残差矩阵等于单位阵乘以残差方差，因此这里可以作为常数提出来。</span></span><br><span class="line">	<span class="comment">#因为是R逆，所以是1/残差方差。</span></span><br><span class="line"><span class="comment">#加入随机效应部分的方差协方差矩阵的逆，构建系数矩阵</span></span><br><span class="line">C[X.shape[<span class="number">1</span>]:,X.shape[<span class="number">1</span>]:] += Ginv/<span class="number">0.088</span></span><br><span class="line">	<span class="comment">#C里面是X的列数，比如如果是4，就是从第5行，第5列开始。</span></span><br><span class="line">	<span class="comment">#我懂了，这里是把𝐺^(−1)∕𝜎_𝑎^2 加上来，形成一个完整的系数矩阵。</span></span><br><span class="line"><span class="comment">#系数矩阵右手项</span></span><br><span class="line">RHS = np.dot(W.T, y)/ <span class="number">0.139</span></span><br><span class="line"><span class="comment">#求解混合模型方程组</span></span><br><span class="line">effect = linalg.solve(C, RHS)</span><br><span class="line"></span><br><span class="line"><span class="comment">#提取效应</span></span><br><span class="line">fix_eff = effect[:X.shape[<span class="number">1</span>]]  <span class="comment">#固定效应部分</span></span><br><span class="line">ran_eff = effect[X.shape[<span class="number">1</span>]:,] <span class="comment">#随机效应部分</span></span><br><span class="line"><span class="comment">####下面介绍如何对固定效应检验，如何求可靠性</span></span><br><span class="line"><span class="comment">#系数矩阵求逆</span></span><br><span class="line">Ci = linalg.inv(C)</span><br><span class="line"><span class="comment">#固定效应整体检验（包括均值），备择假设为至少有一个显著</span></span><br><span class="line">covi = linalg.inv(Ci[:X.shape[<span class="number">1</span>], :X.shape[<span class="number">1</span>]]) <span class="comment">#估计值方差协方差矩阵的逆</span></span><br><span class="line">chi_val = np.dot(fix_eff.T, np.dot(covi, fix_eff)) <span class="comment">#卡方值</span></span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> chi2 <span class="comment">#加载卡方分布的库</span></span><br><span class="line">p1 = chi2.sf(chi_val, <span class="number">4</span>) <span class="comment">#转化为P值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#育种值的可靠性计算</span></span><br><span class="line">PEV = np.diag(Ci[X.shape[<span class="number">1</span>]:, X.shape[<span class="number">1</span>]:]) <span class="comment">#取系数矩阵随机效应部分的对角线，即为PEV</span></span><br><span class="line">R2 = <span class="number">1</span> - PEV/<span class="number">0.088</span></span><br><span class="line"><span class="comment">#输出可靠性的最大、最小值</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">max</span>(R2), <span class="built_in">min</span>(R2)  <span class="comment">#可靠性比较高，可能由于所有个体都表型</span></span><br></pre></td></tr></table></figure>
<h1>Efficient Methods to Compute Genomic Predictions – VanRaden 2008</h1>
<h2 id="M矩阵（-1，0，1）">M矩阵（-1，0，1）</h2>
<p>M矩阵是n(个体数)*m（snp数）的矩阵，内容为-1，0，1（-1表示Major frequent的纯合子，0表示杂合子，1表示Minor frequent 的纯合子）。<br>
MM’ 的对角线元素为每个个体的纯和子的数目，非对角线元素没有实际意义（实际等于两个个体相同的纯和子数目（如AA与AA）-不同的纯合子数目（AA与TT）,杂合子没影响）（off-diagonals measure the number of alleles shared by relatives.）</p>
<p>M’M 的对角线表示每个位点纯合子的个体数，非对角线元素没有实际意义，计算类上。</p>
<h2 id="P矩阵（2-p-0-5">P矩阵（2*(p-0.5))</h2>
<p>P矩阵也是n<em>m的矩阵，其中每一列的内容都是相同的（对应的是该snp的2</em>(p-0.5)）。<br>
其中p的计算方式是（(1<em>杂合子+2</em>Minor frequent的纯合子)/2n（n为个体数））。</p>
<h2 id="Z矩阵-中心化">Z矩阵 中心化</h2>
<p>Z = M - P (which sets mean values of the allele effects to 0.)<br>
懂了，所谓矩阵中心化就是说，就是减去均值，使数据的均值的为0。<br>
而标准化的过程，是减去均值，然后除以标准差。使数据满足（0，1）的标准正态分布。<br>
为什么减去P矩阵，就能实现中心化呢？<br>
个人理解。<br>
如果所有基因满足<strong>哈温平衡</strong>，那么</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D &#x3D; (1-p)^2  # D 指代的是基因频率大的纯和子</span><br><span class="line">H &#x3D; 2\*(1-p)\*(p)</span><br><span class="line">R &#x3D; p^2</span><br><span class="line">由于D H R 在M矩阵中分别为-1,0,1</span><br><span class="line">那么均值为 -1\*(1-p)^2 + 0\* 2\*(1-p)\*(p) + 1\*p^2 &#x3D; 2(p-0.5)</span><br><span class="line">但是前提是必须满足哈温平衡</span><br></pre></td></tr></table></figure>
<p>文章中也提及了选择的等位基因不能经过<strong>选择</strong>，这也就是从侧面说要满足哈温平衡。</p>
<blockquote>
<p>Allele frequencies  in  P  should  be  from  the  unselected  base  population rather than those that occur after selection or inbreeding.</p>
</blockquote>
<h2 id="G阵">G阵</h2>
<p><img src="G_matrix.png" alt="G_matrix"></p>
<p>除以分母，使得G阵与A阵可比。</p>
<blockquote>
<p>Division by  2(1 )∑−ppii scales  G to  be  analogous(可比的)  to  the  numerator  relationship  matrix  A.</p>
</blockquote>
<h2 id="其他推导G阵的方法">其他推导G阵的方法</h2>
<p>没太看懂，反正好像就第一种用的多。</p>
<h1>model.matrix_R</h1>
<h2 id="分类变量（Factors）：R中用于存储分类数据的类别信息">分类变量（Factors）：R中用于存储分类数据的类别信息</h2>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">f = factor(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="built_in">class</span>(f) <span class="comment"># &quot;factor&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="哑变量">哑变量</h2>
<p>虚拟变量/哑变量（dummy variable) ：量化非数值类型的变量，通常取0/1。例如一个人的性别。</p>
<h2 id="解释变量">解释变量</h2>
<p>解释变量（explanatory variable) : 等同于控制变量/自变量，与之相对的是<strong>被解释变量</strong>（反应变量/因变量）。</p>
<h2 id="设计矩阵">设计矩阵</h2>
<p>设计矩阵（design matrix）: 又叫<strong>模型矩阵</strong>（model matrix) 或者 <strong>回归矩阵</strong>（regressor matrix) 。 由解释变量值组成的矩阵：一行代表一个独立的观测对象（样本），一列代表对应的变量（特征值、元数据），通常记为X。简单理解，就是我们所说的输入矩阵，可以是元数据的，也可以是数据的。</p>
<h1>PH525x series - Biomedical Data Science 网页</h1>
<h2 id="choice-of-design">choice of design</h2>
<p>The choice of design matrix is a critical step in linear modeling since it encodes which coefficients will be fit in the model, as well as the inter-relationship between the samples. A common misunderstanding is that the choice of design follows straightforward from a description of which samples were included in the experiment. This is not the case. The basic information about each sample (whether control or treatment group, experimental batch, etc.) does not imply a single ‘correct’ design matrix. The design matrix additionally encodes various assumptions about how the variables in X explain the observed values in Y, on which the investigator must decide. (这一段都看不太懂，大概意思是系数矩阵的构建需要构建者自身知道，哪些<strong>X</strong>中的因素能够解释<strong>Y</strong>中的观测值。)</p>
<p>model.matrix中使用~号表示开始一个公式（formula）,这个符号右边的变量，指示每个个体在哪个群体中（which tells us which samples are in which group）。</p>
<h2 id="截距（Intercept）的含义">截距（Intercept）的含义</h2>
<p>For the examples we cover here, we use linear models to make comparisons between different groups. Hence, the design matrices that we ultimately work with will have at least two columns: an intercept column, which consists of a column of 1’s, and a second column, which specifies which samples are in a second group. In this case, two coefficients are fit in the linear model: <strong>the intercept, which represents the population average of the first group</strong>, and a second coefficient, which represents the difference between the population averages of the second group and the first group. The latter is typically the coefficient we are interested in when we are performing statistical tests: we want to know if their is a difference between the two groups.</p>
<p>从这段画可以看出，截距是有含义的。这里的模型是Y为老鼠的体重，自变量只有一个，那就是是否接受了高脂肪食物（只有两种状态0和1，0表示没有，1表示接受了高脂肪食物）。这里的截距β就是指当老鼠没有接受高脂肪食物时的平均体重，而β1指的是接受高脂肪食物后体重的平均变化量。</p>
<p>简单的说，也就是截距表示的<strong>group的一种状态（随便那种设为基本状态，R里好像是把碰到的第一个分类给截距）<strong>时的均值。也就是截距就表示了一种状态（状态0）。其他的group的值是在这个基础状态的</strong>变化量</strong>。比如此时β1就是接受高脂肪食物相较于没有接受的体重增加量。</p>
<p>如果不设截距，使用~group-1，此时如果如果Y = βx + e。每个β（两种状态）都是<strong>绝对值</strong>。</p>
<p><img src="Design_Matrix1.png" alt=""></p>
<h2 id="组别为2">组别为2</h2>
<p>Let’s try an example. Suppose we have two groups, control and high fat diet, with two samples each. For illustrative purposes, we will code these with 1 and 2 respectively. <strong>We should first tell R that these values should not be interpreted numerically, but as different levels of a factor.</strong> （在R中，设计矩阵那一列必须设定为<strong>factor</strong>）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">group &lt;- factor(<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">model.matrix(~group)</span><br><span class="line"><span class="comment">#model.matrix(formula(~ group)) #可以省略formula()</span></span><br><span class="line"><span class="comment">## 结果如下，如果不写-1，那么就会有一个截距</span></span><br><span class="line"><span class="comment">## 因为因子化了，这里的group就好像变成0和1了。</span></span><br><span class="line"> (Intercept) group2</span><br><span class="line">1           <span class="number">1</span>      <span class="number">0</span></span><br><span class="line">2           <span class="number">1</span>      <span class="number">0</span></span><br><span class="line">3           <span class="number">1</span>      <span class="number">1</span></span><br><span class="line">4           <span class="number">1</span>      <span class="number">1</span></span><br><span class="line"><span class="built_in">attr</span>(,<span class="string">&quot;assign&quot;</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="built_in">attr</span>(,<span class="string">&quot;contrasts&quot;</span>)</span><br><span class="line"><span class="built_in">attr</span>(,<span class="string">&quot;contrasts&quot;</span>)$group</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;contr.treatment&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="group-1">group - 1</h3>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">group &lt;- factor(<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">model.matrix(~group -<span class="number">1</span> )</span><br><span class="line"><span class="comment">#model.matrix(~group +0 )</span></span><br><span class="line"><span class="comment"># ~group - 1(+0) 这样就没有基础值β0了。</span></span><br><span class="line"><span class="comment"># This group now fits a separate coefficient for each group.</span></span><br><span class="line">  group1 group2</span><br><span class="line">1      <span class="number">1</span>      <span class="number">0</span></span><br><span class="line">2      <span class="number">1</span>      <span class="number">0</span></span><br><span class="line">3      <span class="number">0</span>      <span class="number">1</span></span><br><span class="line">4      <span class="number">0</span>      <span class="number">1</span></span><br><span class="line"><span class="built_in">attr</span>(,<span class="string">&quot;assign&quot;</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="built_in">attr</span>(,<span class="string">&quot;contrasts&quot;</span>)</span><br><span class="line"><span class="built_in">attr</span>(,<span class="string">&quot;contrasts&quot;</span>)$group</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;contr.treatment&quot;</span></span><br><span class="line"></span><br><span class="line">如果我们不设定group为**因子**的话</span><br><span class="line"></span><br><span class="line">```R</span><br><span class="line">group &lt;- c(1,1,2,2)</span><br><span class="line">model.matrix(~group)</span><br><span class="line"></span><br><span class="line">## 结果，这里group是1和2，不符合设计矩阵元素只有0和1</span><br><span class="line">## 所谓设计矩阵，只是一个*indicator*,指示个体所属的group，因此只有0和1，而且一列只有一个1，其他都是0。</span><br><span class="line">## 所以，model.matrix所在列的实际内容无关紧要，是数字也好，字符串也好。都没影响，都只是分类变量，设计矩阵只是提示这个个体属于哪个分类（group）</span><br><span class="line">## 因此，model.matrix前必须进行因子化。</span><br><span class="line">  (Intercept) group</span><br><span class="line">1           1     1</span><br><span class="line">2           1     1</span><br><span class="line">3           1     2</span><br><span class="line">4           1     2</span><br><span class="line">attr(,&quot;assign&quot;)</span><br><span class="line">[1] 0 1</span><br></pre></td></tr></table></figure>
<p>将分类列的内容换成字符串，结果相同</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">group &lt;- factor(<span class="built_in">c</span>(<span class="string">&quot;control&quot;</span>,<span class="string">&quot;control&quot;</span>,<span class="string">&quot;highfat&quot;</span>,<span class="string">&quot;highfat&quot;</span>))</span><br><span class="line">model.matrix(~ group)</span><br><span class="line"></span><br><span class="line"><span class="comment">##   (Intercept) grouphighfat</span></span><br><span class="line"><span class="comment">## 1           1            0</span></span><br><span class="line"><span class="comment">## 2           1            0</span></span><br><span class="line"><span class="comment">## 3           1            1</span></span><br><span class="line"><span class="comment">## 4           1            1</span></span><br><span class="line"><span class="comment">## attr(,&quot;assign&quot;)</span></span><br><span class="line"><span class="comment">## [1] 0 1</span></span><br><span class="line"><span class="comment">## attr(,&quot;contrasts&quot;)</span></span><br><span class="line"><span class="comment">## attr(,&quot;contrasts&quot;)$group</span></span><br><span class="line"><span class="comment">## [1] &quot;contr.treatment&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="More-groups">More groups</h3>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">group &lt;- factor(<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">model.matrix(~ group)</span><br><span class="line"><span class="comment">##   (Intercept) group2 group3</span></span><br><span class="line"><span class="comment">## 1           1      0      0</span></span><br><span class="line"><span class="comment">## 2           1      0      0</span></span><br><span class="line"><span class="comment">## 3           1      1      0</span></span><br><span class="line"><span class="comment">## 4           1      1      0</span></span><br><span class="line"><span class="comment">## 5           1      0      1</span></span><br><span class="line"><span class="comment">## 6           1      0      1</span></span><br><span class="line"><span class="comment">## attr(,&quot;assign&quot;)</span></span><br><span class="line"><span class="comment">## [1] 0 1 1</span></span><br><span class="line"><span class="comment">## attr(,&quot;contrasts&quot;)</span></span><br><span class="line"><span class="comment">## attr(,&quot;contrasts&quot;)$group</span></span><br><span class="line"><span class="comment">## [1] &quot;contr.treatment&quot;</span></span><br></pre></td></tr></table></figure>
<p>Now we have a third column which specifies which samples belong to the third group.（现在我们有了第三列，来表示第三种group）</p>
<h2 id="更多的变量">更多的变量</h2>
<p>这里只考虑了diet，实际情况中一般会有更多的变量。在这里，我们增加了<strong>性别</strong>变量。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">diet &lt;- factor(<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">sex &lt;- factor(<span class="built_in">c</span>(<span class="string">&quot;f&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="string">&quot;m&quot;</span>,<span class="string">&quot;m&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="string">&quot;m&quot;</span>,<span class="string">&quot;m&quot;</span>))</span><br><span class="line">table(diet,sex)</span><br><span class="line"><span class="comment">##     sex</span></span><br><span class="line"><span class="comment">## diet f m</span></span><br><span class="line"><span class="comment">##    1 2 2</span></span><br><span class="line"><span class="comment">##    2 2 2</span></span><br></pre></td></tr></table></figure>
<p>如果我们假设日粮效应对于公鼠和母鼠的效应是相同的（也就是二者没有互作）。那么线性模型为<br>
Y~i~ = β~0~ + β~1~x~i,1~ + β~2~x~2,i~ + e~i~</p>
<p>那么，model.matrix设置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">diet &lt;- factor(c(1,1,1,1,2,2,2,2))</span><br><span class="line">sex &lt;- factor(c(&quot;f&quot;,&quot;f&quot;,&quot;m&quot;,&quot;m&quot;,&quot;f&quot;,&quot;f&quot;,&quot;m&quot;,&quot;m&quot;))</span><br><span class="line">model.matrix(~ diet + sex)</span><br><span class="line">##   (Intercept) diet2 sexm</span><br><span class="line">## 1           1     0    0</span><br><span class="line">## 2           1     0    0</span><br><span class="line">## 3           1     0    1</span><br><span class="line">## 4           1     0    1</span><br><span class="line">## 5           1     1    0</span><br><span class="line">## 6           1     1    0</span><br><span class="line">## 7           1     1    1</span><br><span class="line">## 8           1     1    1</span><br><span class="line">## attr(,&quot;assign&quot;)</span><br><span class="line">## [1] 0 1 2</span><br><span class="line">## attr(,&quot;contrasts&quot;)</span><br><span class="line">## attr(,&quot;contrasts&quot;)$diet</span><br><span class="line">## [1] &quot;contr.treatment&quot;</span><br><span class="line">## </span><br><span class="line">## attr(,&quot;contrasts&quot;)$sex</span><br><span class="line">## [1] &quot;contr.treatment&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果考虑互作效应</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">model.matrix(~ diet + sex + diet:sex)</span><br><span class="line"><span class="comment">#model.matrix(~ diet*sex)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##   (Intercept) diet2 sexm diet2:sexm</span></span><br><span class="line"><span class="comment">## 1           1     0    0          0</span></span><br><span class="line"><span class="comment">## 2           1     0    0          0</span></span><br><span class="line"><span class="comment">## 3           1     0    1          0</span></span><br><span class="line"><span class="comment">## 4           1     0    1          0</span></span><br><span class="line"><span class="comment">## 5           1     1    0          0</span></span><br><span class="line"><span class="comment">## 6           1     1    0          0</span></span><br><span class="line"><span class="comment">## 7           1     1    1          1</span></span><br><span class="line"><span class="comment">## 8           1     1    1          1</span></span><br><span class="line"><span class="comment">## attr(,&quot;assign&quot;)</span></span><br><span class="line"><span class="comment">## [1] 0 1 2 3</span></span><br><span class="line"><span class="comment">## attr(,&quot;contrasts&quot;)</span></span><br><span class="line"><span class="comment">## attr(,&quot;contrasts&quot;)$diet</span></span><br><span class="line"><span class="comment">## [1] &quot;contr.treatment&quot;</span></span><br><span class="line"><span class="comment">## </span></span><br><span class="line"><span class="comment">## attr(,&quot;contrasts&quot;)$sex</span></span><br><span class="line"><span class="comment">## [1] &quot;contr.treatment&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Releveling-设置参考水平，reference-level">Releveling (设置参考水平，<em>reference level</em>)</h3>
<p>The level which is chosen for the reference level is the level which is contrasted against. By default, this is simply the first level alphabetically. We can specify that we want group 2 to be the reference level by either using the <em>relevel</em> function:<br>
翻译一下，所谓reference level（参考水平，也就是截距的水平），即是其他水平与之相比较的水平。默认情况下，参考水平就是<strong>名称按字母排序</strong>的第一个水平。我们可以通过<strong>relevel</strong>函数设定reference level。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">group &lt;- factor(<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">group &lt;- relevel(group, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">model.matrix(~ group)</span><br><span class="line"><span class="comment">##   (Intercept) group1</span></span><br><span class="line"><span class="comment">## 1           1      1</span></span><br><span class="line"><span class="comment">## 2           1      1</span></span><br><span class="line"><span class="comment">## 3           1      0</span></span><br><span class="line"><span class="comment">## 4           1      0</span></span><br><span class="line"><span class="comment">## attr(,&quot;assign&quot;)</span></span><br><span class="line"><span class="comment">## [1] 0 1</span></span><br><span class="line"><span class="comment">## attr(,&quot;contrasts&quot;)</span></span><br><span class="line"><span class="comment">## attr(,&quot;contrasts&quot;)$group</span></span><br><span class="line"><span class="comment">## [1] &quot;contr.treatment&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="连续变量">连续变量</h2>
<p>In this chapter, we focus on models based on indicator values. In certain designs, however, we will be interested in using numeric variables in the design formula, as opposed to converting them to factors first. For example, in the falling object example, time was a continuous variable in the model and time squared was also included:<br>
翻译一下，就是一般设计矩阵都是用于分类变量，当有时我们也会感兴趣一些连续变量。比如在落体运动，时间和时间的平方就应该考虑进入模型中。<br>
连续变量用于设计矩阵，表示的是一种<strong>剂量效应</strong>。此时求解出来的β表示的是每增加一单位的连续变量，y的平均改变量。<br>
这也就是带来了一种连续变量应用的假设或前提，你得知道这个变量对反应变量的影响是<strong>线性</strong>的。不然得出的结果是错的。<br>
以下英文具体阐述了这种观点。例如落体距离与时间的关系，因为有经典的物理的公式，所以我们确信它们之间是<strong>线性关系</strong>。但是对于其他变量，如年龄等可能不是线性关系的变量，我们不鼓励这么使用。<br>
The assumptions imposed by including continuous data as variables are typically hard to defend and motivate than the indicator function variables. Why the indicator variables simply assume a different mean between two groups, continuous variables assume a very specific relationship between the outcome and predictor variables.</p>
<p>In cases like the falling object, we have the theory of gravitation supporting the model. In the father-son height example, because the data is bi variate normal, it follows that there is a linear relationship if we condition. However, we find that continuous variables are included in linear models without justification to “adjust” for variables such as age. We highly discourage this practice unless the data support the model being used.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># I()用于在模型中进行数学转换时。</span></span><br><span class="line"><span class="comment">#因为在模型的定义中，常见的符号+（俩变量）、*（考虑互作）、：（互作）、^(不清楚)有了特殊含义，不再是原来的数学运算符号。</span></span><br><span class="line"><span class="comment">#^符号貌似是考虑互作？ 在模型中，（x+y)^2 表示的是 x + y + x:y</span></span><br><span class="line"><span class="comment">#?fromula 中The ^ operator indicates crossing to the specified degree. For example (a+b+c)^2 is identical to (a+b+c)*(a+b+c) which in turn expands to a formula containing the main effects for a, b and c together with their second-order interactions. </span></span><br><span class="line"><span class="comment">#即(a+b+c)^2 表示 a + b + c + a:b + a:c + b:c。嗯，对的</span></span><br><span class="line"><span class="comment"># -1 或 +0 都表示通过原点，即没有截距。</span></span><br><span class="line"><span class="comment">#变量保护函数（I( )）：放在I内的表达式按照算术意义进行解释</span></span><br><span class="line">	<span class="comment">#a+b 表示变量a和变量b都包含在公式中</span></span><br><span class="line">	<span class="comment">#I(a+b）表示 a+b 这个和应该包含在公式中</span></span><br><span class="line"><span class="comment"># R中关于模型设定的问题，找?formula.</span></span><br><span class="line">tt &lt;- seq(<span class="number">0</span>,<span class="number">3.4</span>,len=<span class="number">4</span>) </span><br><span class="line">model.matrix(~ tt + I(tt^<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">##   (Intercept)       tt   I(tt^2)</span></span><br><span class="line"><span class="comment">## 1           1 0.000000  0.000000</span></span><br><span class="line"><span class="comment">## 2           1 1.133333  1.284444</span></span><br><span class="line"><span class="comment">## 3           1 2.266667  5.137778</span></span><br><span class="line"><span class="comment">## 4           1 3.400000 11.560000</span></span><br><span class="line"><span class="comment">## attr(,&quot;assign&quot;)</span></span><br><span class="line"><span class="comment">## [1] 0 1 2</span></span><br></pre></td></tr></table></figure>
<h1>MME构建与求解-邓飞</h1>
<p>setwd(‘D:\Desktop\R_model’)<br>
ped &lt;- read.table(‘example_ped.txt’,header = F)<br>
dat &lt;- read.table(‘example_dat.txt’,header = F)</p>
<h2 id="处理系谱">处理系谱</h2>
<p>library(nadiv)<br>
pped = prepPed(ped)#给founders也增加一行系谱，然后排序系谱<br>
pped</p>
<h1>输入系谱文件缺失值为NA,0,*</h1>
<h1>输出文件缺失值全未NA</h1>
<h1>A = as.matrix(makeA(pped))</h1>
<h1>A</h1>
<h1>A_inv = solve(A) #solve(A) 即求逆</h1>
<h1>A_inv</h1>
<p>A_inv = makeAinv(pped)$Ainv#可直接求A逆<br>
A_inv<br>
#结果为list<br>
#$Ainv为稀疏矩阵<br>
#$listAinv为三列的格式<br>
#f为近交系数，不计算<br>
#logDet the log determinant of the A matrix<br>
#dii the (non-zero) elements of the diagonal D matrix of the A=TDT’ decomposition.</p>
<h2 id="修要对A逆按照一定顺序重排">修要对A逆按照一定顺序重排</h2>
<p>A_inv = as.matrix(A_inv)<br>
#rownames(A_inv) = as.numeric(rownames(A_inv))<br>
#A_inv的行名为字符串，而且不能改成数字，不知道是为什么。</p>
<p>###使用z_phe A_inv不需要重排<br>
colnames(A_inv) = rownames(A_inv)<br>
new_rowname &lt;- sort(rownames(A_inv))<br>
new_rowname<br>
A_inv<br>
A_inv_new &lt;- A_inv[new_rowname,new_rowname]<br>
#这里用1:8，或者seq(‘1’,‘8’)，都不行，因为是数字<br>
#而实际的行名或列名是字符串。<br>
A_inv_new # 现在与Z_all就一致了。</p>
<p>str(dat)<br>
colnames(dat) &lt;- c(‘id’,‘sex’,‘wwg’) #个体号-性别-初生重<br>
dat$id &lt;- as.factor(dat$id)<br>
dat$sex &lt;- as.factor(dat$sex)<br>
X &lt;- model.matrix(~sex-1,data = dat) #和书上一致<br>
Z_phe &lt;- model.matrix(~id-1,data = dat) # 5*5的单位阵，一致<br>
zero_matrix &lt;- matrix(rep(0,15),nrow = 5)<br>
Z_all &lt;- cbind(zero_matrix,Z_phe)<br>
Z_all # Z_all 为添加了三列的所有个体的Z矩阵。</p>
<p>y = as.vector(dat$wwg)</p>
<h3 id="Z-all-结果">Z_all 结果</h3>
<p>alpha = 2 # alpha设置为2</p>
<p>XpX=crossprod(X) #X’X</p>
<p>XpZ=crossprod(X,Z_all) #X’Z</p>
<p>ZpX=crossprod(Z_all,X) #Z’X</p>
<p>ZpZ=crossprod(Z_all) #Z’Z</p>
<p>Xpy=crossprod(X,y) #X’y</p>
<p>Zpy=crossprod(Z_all,y) #Z’y</p>
<p>LHS=rbind(cbind(XpX,XpZ),cbind(ZpX,ZpZ+A_inv_new*alpha)) #LHS<br>
LHS<br>
LHS_inv1 = solve(LHS)<br>
LHS_inv1</p>
<p>RHS=rbind(Xpy,Zpy) #不需要<br>
RHS</p>
<p>sol=solve(LHS)%*%RHS #MME求解<br>
sol</p>
<h3 id="Z-phe-结果">Z_phe 结果</h3>
<p>a = as.character(dat$id)<br>
A_inv2 = A_inv_new[a,a] #截取4：8个体的逆阵<br>
A_inv2</p>
<p>XpX=crossprod(X) #X’X</p>
<p>XpZ=crossprod(X,Z_phe) #X’Z</p>
<p>ZpX=crossprod(Z_phe,X) #Z’X</p>
<p>ZpZ=crossprod(Z_phe) #Z’Z</p>
<p>Xpy=crossprod(X,y) #X’y</p>
<p>Zpy=crossprod(Z_phe,y) #Z’y</p>
<p>LHS=rbind(cbind(XpX,XpZ),cbind(ZpX,ZpZ+A_inv2*alpha)) #LHS<br>
LHS ##LHS和Z_all一致<br>
LHS_inv2 = solve(LHS)<br>
LHS_inv2 #但是逆矩阵的结果就不一致了。</p>
<p>RHS=rbind(Xpy,Zpy) #不需要<br>
RHS #右手项也是去除了相应的行而已，其他一致</p>
<p>sol=solve(LHS)%*%RHS #MME求解<br>
sol<br>
#结果略有不同。</p>
<p>#小结<br>
#还是应该用所有个体，更方便。也更符合实际评估的情况。<br>
#使用全部个体及有表型个体，获得的LHS是一样的<br>
#仅仅是有表型个体的LHS，从全部个体的LHS中删除了无表型个体的行和列。</p>
<p>#问题<br>
#Z矩阵和A逆的构建问题。<br>
#Z矩阵和表型有关，又和A逆有关。<br>
#还是先构建A逆</p>
<p>#我发现一直对表型和系谱的重编号顺序是错的。<br>
#之前都是先重编号，再追系谱。这样会删掉一部分表型。<br>
#应该先追系谱（这样确保所有表型（参验群体）均在系谱中），再重编号。</p>
<p>#如果按照all的思路，应该是这样。<br>
#从单场重编号结果（从1到n,要确保不间断，即系谱总共就是n个个体）。<br>
#然后没有表型的个体就是n-m(m为表型行数)。<br>
#然后构建Z阵 有n-m列全为0,后面m列为&quot;单位阵&quot;。不对，我做的是两个场。所以后面Z阵再重复一遍，先是n2-m2列全为0，后面m2列为&quot;单位阵&quot;<br>
#得到A逆，重排，按两个场分开，每个场都是前面是没表型的，后面是有表型的。</p>
<p>#另一种思路<br>
#A逆可以不重排，完全根据A逆的顺序构建Z阵<br>
#对于每一个A中的个体，没有表型，则Z中相应的这一列（行）全为0<br>
#如果A逆中的个体有表型，那么找到这个个体在表型中的行数，此时Z中这个个体相应的行数的地方为1，其他为0<br>
#这个在python中用字典可以做到，R感觉不方便。</p>
<p>##第二种all的思路是对的。但是A逆还是要重排，最起码得第一个场的个体都在前面，第二个场的个体堵在后面。<br>
##不能两个场的个体混在一块。</p>
<p>##总结一下，all的思路复杂，在R中不好实现。在python中可能方遍实现。</p>
<p>#Z_phe<br>
#那就得按照表型的顺序挑A逆，即可。<br>
#Z阵就是一个m*m的单位阵（m为两个场的表型总数）<br>
#这种方法非常简单，实用。</p>
<p>#这里有一个潜在的问题是，表型不能再被剔除了。<br>
#也就是说从表型的原始文件到重编号，不能删表型<br>
#也就是要对原始文件提前处理好。</p>
<h1>总的来说，只使用有表型个体的数据简单，目前先用这种方法。</h1>
<h1>现在能通过A阵算出来两个场的LHS逆了，就差临门一脚PEBD了。</h1>
<p>使用实际数据，只考虑有表型个体，通过A阵构建系数矩阵整理如下。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里只用有表型的个体</span></span><br><span class="line"></span><br><span class="line">setwd(<span class="string">&#x27;D:\\Desktop\\R_model\\true_practice\\HAYF19647_HAQG17137&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ped &lt;- read.table(<span class="string">&#x27;pedigree_code&#x27;</span>,header = <span class="built_in">F</span>)</span><br><span class="line">dat &lt;- read.table(<span class="string">&#x27;phe_code&#x27;</span>,header = <span class="built_in">F</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 处理系谱</span></span><br><span class="line">new_ped &lt;- ped[,<span class="number">1</span>:<span class="number">3</span>] <span class="comment">#不要第四列</span></span><br><span class="line"></span><br><span class="line">library(nadiv)</span><br><span class="line">pped = prepPed(new_ped)<span class="comment">#给founders也增加一行系谱，然后排序系谱</span></span><br><span class="line"></span><br><span class="line">A_inv = makeAinv(pped)$Ainv<span class="comment">#可直接求A逆</span></span><br><span class="line"></span><br><span class="line">A_inv = as.matrix(A_inv)</span><br><span class="line"></span><br><span class="line">colnames(A_inv) = rownames(A_inv)</span><br><span class="line"></span><br><span class="line">str(dat)</span><br><span class="line">colnames(dat) &lt;- <span class="built_in">c</span>(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;gu&#x27;</span>,<span class="string">&#x27;wo&#x27;</span>,<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;bf&#x27;</span>)</span><br><span class="line">dat$id &lt;- as.factor(dat$id) </span><br><span class="line">dat$gu &lt;- as.factor(dat$gu)</span><br><span class="line">X &lt;- model.matrix(~gu-<span class="number">1</span>,data = dat) </span><br><span class="line">Z &lt;- model.matrix(~id-<span class="number">1</span>,data = dat) <span class="comment"># Z为单位阵</span></span><br><span class="line"></span><br><span class="line">phe_id = <span class="built_in">as.character</span>(dat$id)</span><br><span class="line">A_inv2 = A_inv[phe_id,phe_id] <span class="comment">#截取表型个体的A逆</span></span><br><span class="line"></span><br><span class="line">alpha = <span class="number">2.09</span> <span class="comment"># alpha由方差组分得来。</span></span><br><span class="line"></span><br><span class="line">XpX=crossprod(X) <span class="comment">#X’X </span></span><br><span class="line"></span><br><span class="line">XpZ=crossprod(X,Z) <span class="comment">#X’Z</span></span><br><span class="line"></span><br><span class="line">ZpX=t(XpZ)</span><br><span class="line"></span><br><span class="line"><span class="comment">#ZpX=crossprod(Z,X) #Z’X</span></span><br><span class="line"></span><br><span class="line">ZpZ=crossprod(Z) <span class="comment">#Z’Z</span></span><br><span class="line"></span><br><span class="line">LHS=rbind(cbind(XpX,XpZ),cbind(ZpX,ZpZ+A_inv2*alpha)) <span class="comment">#LHS</span></span><br><span class="line"></span><br><span class="line">LHS_inv = solve(LHS)</span><br><span class="line"></span><br><span class="line">write.table(LHS,file = <span class="string">&#x27;HAYF_HAQG_LHS.txt&#x27;</span>,<span class="built_in">quote</span> = <span class="literal">FALSE</span>,sep = <span class="string">&quot; &quot;</span>,row.names = <span class="literal">FALSE</span>,col.names = <span class="literal">FALSE</span>)</span><br><span class="line">write.table(LHS_inv,file = <span class="string">&#x27;HAYF_HAQG_LHS_inv.txt&#x27;</span>,<span class="built_in">quote</span> = <span class="literal">FALSE</span>,sep = <span class="string">&quot; &quot;</span>,row.names = <span class="literal">FALSE</span>,col.names = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>Data Analysis for the Life Sciences</h1>
<h2 id="introduction">introduction</h2>
<p>statistical inference(统计推断)：推断就是使用可能性从数据中获取群体特征值（Inference is the use of probability to learn population characteristic from data）。一个典型的例子就是推断两个群体的平均值是否相同。</p>
<h2 id="getting-started">getting started</h2>
<p>主要是介绍了一些R的基础部分和数学基础。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">###第一章 getting started </span></span><br><span class="line">install.packages(<span class="string">&quot;swirl&quot;</span>)</span><br><span class="line">install.packages(<span class="string">&quot;rafalib&quot;</span>)</span><br><span class="line">install.packages(<span class="string">&quot;downloader&quot;</span>)</span><br><span class="line">setwd(<span class="string">&#x27;D:\\Desktop\\下载英文文献\\模型\\R_model&#x27;</span>)</span><br><span class="line">dat &lt;- read.table(<span class="string">&#x27;female_mouse_weights.txt&#x27;</span>,header = <span class="built_in">T</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">###通过downloader直接下载网上的数据</span></span><br><span class="line">library(downloader) <span class="comment">##use install.packages to install ##通过downloader</span></span><br><span class="line">url &lt;- <span class="string">&quot;https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extd\</span></span><br><span class="line"><span class="string">ata/femaleMiceWeights.csv&quot;</span>  <span class="comment">## 数据的完整路径</span></span><br><span class="line">filename &lt;- <span class="string">&quot;femaleMiceWeights.csv&quot;</span></span><br><span class="line">download(url, destfile=filename) <span class="comment">## 下载，后面更的是下载后的名称</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 为了从GitHub 上直接下载文件夹，你需要下载devtools包</span></span><br><span class="line">library(devtools)</span><br><span class="line">install_github(<span class="string">&quot;genomicsclass/dagdata&quot;</span>)</span><br><span class="line"></span><br><span class="line">dir &lt;- system.file(package = <span class="string">&quot;dagdata&quot;</span>) <span class="comment"># 获取文件夹位置</span></span><br><span class="line">dir  <span class="comment">## &quot;D:/software/R/R-3.6.1/library/dagdata&quot;</span></span><br><span class="line">list.files(dir) <span class="comment"># 查看dir下面的文件和子文件夹</span></span><br><span class="line">list.files(dir,<span class="string">&quot;extdata&quot;</span>) <span class="comment"># 查看extdata下的子文件</span></span><br><span class="line">filename&lt;-file.path(dir,<span class="string">&quot;extdata/femaleMiceWeights.csv&quot;</span>) <span class="comment">## 文件的完整路径</span></span><br><span class="line">dat&lt;-read.csv(filename) <span class="comment">## 最终打开文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####初探dplyr </span></span><br><span class="line">library(<span class="string">&quot;dplyr&quot;</span>)</span><br><span class="line"><span class="comment">##dplyr包中filter是进行数据筛选</span></span><br><span class="line">chow &lt;- filter(dat,Diet==<span class="string">&quot;chow&quot;</span>) <span class="comment">## 筛选Diet列中为chow的数据</span></span><br><span class="line">head(chow)</span><br><span class="line"></span><br><span class="line"><span class="comment">## select貌似是选列</span></span><br><span class="line">chowVals &lt;- select(chow,Bodyweight) <span class="comment">## 选择chow中的Bodyweight列</span></span><br><span class="line">head(chowVals)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 还可以使用通道符 %&gt;% denote a pipe </span></span><br><span class="line"><span class="comment">## 因此上述两步可以合成一步</span></span><br><span class="line">chowVals &lt;- filter(dat,Diet==<span class="string">&quot;chow&quot;</span>) %&gt;% select(Bodyweight)</span><br><span class="line">head(chowVals)</span><br><span class="line"><span class="comment">## dplyr接收的是data.frame ，返回的也是data.frame</span></span><br><span class="line"><span class="built_in">class</span>(chowVals) <span class="comment">#data.frame</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 为了使结果为向量，可以使用unlist函数。将list(包括data.frame)转换成numeric vectors. </span></span><br><span class="line">chowVals &lt;- filter(dat,Diet==<span class="string">&quot;chow&quot;</span>) %&gt;% select(Bodyweight) %&gt;% unlist</span><br><span class="line"><span class="comment">## 通道少写一个参数，但是这里的unlist连()都省了</span></span><br><span class="line"><span class="built_in">class</span>(chowVals) <span class="comment">#numeric </span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 不用dplyr的写法</span></span><br><span class="line">chowVals &lt;- dat[dat$Diet==<span class="string">&quot;chow&quot;</span>,<span class="string">&quot;Bodyweight&quot;</span>]</span><br><span class="line">head(chowVals)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 小结，感觉R整理数据就是不太方便。</span></span><br></pre></td></tr></table></figure>
<h2 id="inference">inference</h2>
<p>以下为random variable,  null distribution,  p-value 的 简要介绍。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#inference</span></span><br><span class="line">setwd(<span class="string">&#x27;D:\\Desktop\\下载英文文献\\模型\\R_model&#x27;</span>)</span><br><span class="line">dat &lt;- read.table(<span class="string">&#x27;female_mouse_weights.txt&#x27;</span>,header = <span class="built_in">T</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#####didtribution 的解析</span></span><br><span class="line"><span class="comment">#distribution：可以简单地理解为一堆数。</span></span><br><span class="line"><span class="comment">#比如你测量了一个群体中所有人的身高。</span></span><br><span class="line"><span class="comment">#这个时候你要和其他人不懂的人（such as analien that has never visited Earth）描述这些数字。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#假如以下就是你取得的身高数据</span></span><br><span class="line">library(UsingR)</span><br><span class="line">x &lt;- father.son$fheight</span><br><span class="line"></span><br><span class="line"><span class="comment">#最简单的就是列出来给外星人看</span></span><br><span class="line"><span class="built_in">round</span>(sample(x,<span class="number">10</span>),<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#但这不够充分，我们可以定义一个累积分布函数（Cumulative Distribution Function）</span></span><br><span class="line"><span class="comment">#F(a) == Pr(x&lt;a) #小于等于号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#画图如下</span></span><br><span class="line"><span class="comment"># floor ceiling 是取整用的</span></span><br><span class="line"><span class="comment"># floor 是直接取整数，ceiling 是 “天花板” </span></span><br><span class="line"><span class="comment"># 如 floor(2.99) = 2 ceiling(2.99) = 3</span></span><br><span class="line"><span class="comment"># 用在画图还是挺好的</span></span><br><span class="line"></span><br><span class="line">smallest&lt;-<span class="built_in">floor</span>( <span class="built_in">min</span>(x) )</span><br><span class="line">largest&lt;-<span class="built_in">ceiling</span>( <span class="built_in">max</span>(x) )</span><br><span class="line">values&lt;-seq(smallest, largest,len=<span class="number">300</span>)</span><br><span class="line">heightecdf&lt;-ecdf(x)</span><br><span class="line">plot(values, heightecdf(values), type=<span class="string">&quot;l&quot;</span>,xlab=<span class="string">&quot;a (Height in inches)&quot;</span>,ylab=<span class="string">&quot;Pr(x &lt;= a)&quot;</span>)</span><br><span class="line"><span class="comment"># 但是现在更常见的是画直方图</span></span><br><span class="line"><span class="comment"># 把直方图给外星人一看，基本就很清晰了。</span></span><br><span class="line">hist(x)</span><br><span class="line">bins&lt;-seq(smallest, largest)</span><br><span class="line">hist(x,breaks=bins,xlab=<span class="string">&quot;Height (in inches)&quot;</span>,main=<span class="string">&quot;Adult men heights&quot;</span>)</span><br><span class="line"><span class="comment">#breaks设置中，不用floor,ceiling 画不成图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####回到正题</span></span><br><span class="line">library(dplyr)</span><br><span class="line">control &lt;- filter(dat,Diet==<span class="string">&quot;chow&quot;</span>) %&gt;% select(Bodyweight) %&gt;% unlist</span><br><span class="line">treatment  &lt;- filter(dat,Diet==<span class="string">&quot;hf&quot;</span>) %&gt;% select(Bodyweight) %&gt;% unlist</span><br><span class="line">mean(treatment)</span><br><span class="line">mean(control)</span><br><span class="line">obsdiff &lt;- mean(treatment) - mean(control)</span><br><span class="line">obsdiff</span><br><span class="line"><span class="comment">#[1] 3.020833</span></span><br><span class="line"><span class="comment">#只看均值和差值是不够的</span></span><br><span class="line"><span class="comment">#因为如果你再取24只老鼠重新做试验，每一次都能得到一个新的结果。</span></span><br><span class="line"><span class="comment">#我们把具有这种特性的数据称为随机变量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####更深刻地理解随机变量###########</span></span><br><span class="line"><span class="comment"># 假设我们有所有的control群体，如下</span></span><br><span class="line">library(downloader)</span><br><span class="line">url&lt;-<span class="string">&quot;https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extdata/femaleControlsPopulation.csv&quot;</span></span><br><span class="line">filename&lt;-<span class="string">&quot;femaleControlsPopulation.csv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!file.exists(filename)) download(url,destfile=filename)</span><br><span class="line"><span class="comment">#如果文件不存在则下载</span></span><br><span class="line"></span><br><span class="line">population&lt;-read.csv(filename)</span><br><span class="line"></span><br><span class="line">population &lt;- unlist(population) <span class="comment">#从data.frame 转为 vector</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#从总体中每次随机抽取12只老鼠，重复三次，每次均值均不同</span></span><br><span class="line"></span><br><span class="line">control&lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">mean(control)</span><br><span class="line"><span class="comment">#[1] 23.4925</span></span><br><span class="line"></span><br><span class="line">control&lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">mean(control)</span><br><span class="line"><span class="comment">#[1] 24.96583</span></span><br><span class="line"></span><br><span class="line">control&lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">mean(control)</span><br><span class="line"><span class="comment">#[1] 22.90083</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#因此哪怕同一个群体，抽取不同的样本，之间也是有差异的。</span></span><br><span class="line"><span class="comment">#所以对于上面两个群体的obsdiff，我们存有怀疑，这究竟是不是因为影响因素（diet）造成的</span></span><br><span class="line"><span class="comment">#如果我们给这24只老鼠相同的diet，差异还有有这么大吗？</span></span><br><span class="line"><span class="comment">#出于怀疑精神，一般统计推断的零假设（null hypothesis）会设定为两个群体没有区别。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#由于我们有了control的总体，所以我们可以无限次抽样。</span></span><br><span class="line"><span class="comment">#每次从control的群体中，抽2批12只老鼠，求均值。代码如下</span></span><br><span class="line"></span><br><span class="line">control&lt;-sample(population,<span class="number">12</span>)</span><br><span class="line"><span class="comment">##another 12 control mice that we act as if they were not</span></span><br><span class="line">treatment &lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">print(mean(treatment)-mean(control))</span><br><span class="line"><span class="comment">#[1] -1.175</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#现在让我们重复这一步骤10000次</span></span><br><span class="line"></span><br><span class="line">null &lt;- vector()</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">10000</span>)&#123;</span><br><span class="line">  control&lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">  treatment &lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">  null[i] &lt;- mean(treatment)-mean(control)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在在null中的值我们称之为null distribution</span></span><br><span class="line"></span><br><span class="line">mean(null&gt;=obsdiff)</span><br><span class="line"><span class="comment"># [1] 0.0147</span></span><br><span class="line"><span class="comment">#mean里面的是一个布尔向量，由TRUE和FALSE组成</span></span><br><span class="line"><span class="comment">#但是在计算的过程中，TRUE视为1，FALSE视为0。</span></span><br><span class="line"><span class="comment">#所以这个0.0147是这10000次中差距大于obsdiff的比例。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#因此作为一个怀疑主义者，我们可以得出结论</span></span><br><span class="line"><span class="comment">#如果没有diet effect，我们看到像obsdiff这么的差距的可能性是1.47%</span></span><br><span class="line"><span class="comment">#这就是所谓的P值！</span></span><br><span class="line"><span class="comment">#p值即原假设成立的前提下，此事件发生的概率。</span></span><br><span class="line"><span class="comment">#深入浅出，厉害！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#小结一下，像上述这样计算P值很简单。但是生活中不可行。</span></span><br><span class="line"><span class="comment">#因为你不肯真的把测量整个群体的信息，从而构成null distribution。</span></span><br><span class="line"><span class="comment">#一般也还是通过采样。</span></span><br><span class="line"><span class="comment">#也就是还是只通过数据中的24只老鼠的数据进行判断。</span></span><br></pre></td></tr></table></figure>
<h3 id="population-parameters">population parameters</h3>
<p>统计推断的第一步是弄清楚你感兴趣的群体。作者选这个这个小鼠的数据集的原因之一，是因为作者有所有这种类型的小鼠的体重信息（即这个群体的所有群体）。</p>
<p>如果你能收集你感兴趣的群体的所有数据，那么得到的参数（群体均值、方差、标准差）就被称为群体参数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(downloader)</span><br><span class="line">url&lt;-<span class="string">&quot;https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extdata/mice_pheno.csv&quot;</span></span><br><span class="line">filename&lt;-<span class="string">&quot;mice_pheno.csv&quot;</span> </span><br><span class="line">download(url,destfile=filename)</span><br><span class="line">dat&lt;-read.csv(filename) <span class="comment">#这是所有这个小鼠群体的数据</span></span><br><span class="line"></span><br><span class="line">library(dplyr)</span><br><span class="line">controlPopulation &lt;- filter(dat,Sex==<span class="string">&quot;F&quot;</span>&amp;Diet==<span class="string">&quot;chow&quot;</span>) </span><br><span class="line"><span class="built_in">length</span>(controlPopulation$Bodyweight)</span><br><span class="line"></span><br><span class="line">hfPopulation&lt;-filter(dat,Sex==<span class="string">&quot;F&quot;</span>&amp;Diet==<span class="string">&quot;hf&quot;</span>)</span><br><span class="line"><span class="built_in">length</span>(hfPopulation$Bodyweight)</span><br><span class="line"><span class="comment">#此时群体的均值、方差、标准差等就被称为群体参数（population parameters）</span></span><br><span class="line"><span class="comment">#此时回到我们的问题，两个群体的均值是否相等。</span></span><br><span class="line"><span class="comment">#由于我们拿到了两个群体的所有数据，那么用μy-ux（x:control y:hf）,直接看差值是否为0即可。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是，在实际生活中，我们拿不到群体的所有数据。比如，可能买下一个群体所有的小鼠是很贵的。<br>
因此，我们需要学会如何从样本数据来回答我们的问题。这就是统计推断的本质。</p>
<h3 id="Sample-estimates">Sample estimates</h3>
<p>在之前的章节中，我们从两个群体中各随机抽取了12只小鼠。我们一般用大写字母来表示抽样个体，以此表明他们是随机抽取的。这也是统计中的一种常规做法。因此抽样个体表示为X~1~ ……X~12~ 和 Y~1~ …… Y~12~。<br>
而对于上面的群体中的个体，用的是小写数字。因为这些个体是给定的，不是随机的。<br>
此时，研究目标是两个样本群体均值的差值。<br>
而这个差值也是一个随机变量（random variable）。前面，我们采用一种从原始数据中重复抽样的手段（10000次）。但是，这在实际中（in practice）是不可实现的，比如在我们这个例子中，就是要不断地买24只小鼠做试验。<br>
下面会介绍群体均值差与样本均值差的关系。这涉及到了中心极限定理。</p>
<h3 id="Central-Limit-Theorem-and-t-distribution">Central Limit Theorem and t-distribution</h3>
<p><strong>中心极限定理</strong>：<strong>无论群体总体服从什么分布</strong>，当抽样个体数足够大时（一般认为，每组大于等于30个），抽样群体的均值（Y拔）服从正态分布。其均值为群体均值，其标准差等于群体标准差除以根号N（N 为 simple size）。我们把这个随机变量分布的标准差称为标准误（<em>standard error</em>）。</p>
<ul>
<li>对于一个随机变量，加减常数（X+a），则该随机变量的均值也随之变化（u~X~+a）</li>
<li>对于一个随机变量，乘以一个常数（X*a），则该随机变量的均值和标准差也乘以此常数</li>
<li>对于两个独立的随机变量相加（X+Y），其均值为μ~X~+μ~Y~，其方差为二者之和。如果是两个独立的随机变量相减，其均值为二者之差，其方差仍未<strong>二者之和</strong>。</li>
<li>如果两个随机变量都满足正态分布，那么它们只和仍满足正态分布。</li>
</ul>
<p>在本例中，我们关心的两个群体的均值，由于中心极限定理，服从正态分布。因此它们的差值也服从正态分布，均值为两个随机变量之差，方差为<strong>两个随机变量之和</strong>。由于原假设是不存在差异，那么两个群体的均值的均值应该大致服从一个均值为0，标准差为√（σ2X+σ2Y）/√N的正态分布。<br>
也就是如下式</p>
<p><img src="clt.png" alt="clt"></p>
<p>这个进行了标准化的随机变量应该满足（0，1）的标准正态分布。（深入浅出！）</p>
<p>根据这个公式，我们可以更快地求出P值（已知标准正态分布）。例如，正态分布中大于2的值只有5%（in absolute value，应该是双尾的意思）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">pnorm(-<span class="number">2</span>)+(<span class="number">1</span>-pnorm(<span class="number">2</span>))</span><br><span class="line"><span class="comment">## [1] 0.04550026</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此，我们不用再买更多的小鼠，24只够了。</p>
<p>然而，事情到这一步还没有结束。因为我们不知道群体的标准差，σ~X~和σ~Y~。这些都是不可知的群体参数。但是我们可以用样本标准差去估计群体标准差，称为s~X~ 和 s~Y~。定义如下：</p>
<p><img src="s2.png" alt="s2"></p>
<p>这里是除以M-1 和 N-1（出于理论原因，没解释）。</p>
<p>因此，我们可以把上式改为：</p>
<p><img src="clt_new.png" alt="t_value"></p>
<p>中心极限定理告诉我们，当M,N较大时，这个随机变量服从标准正态分布（零假设下）。因此，我们现在可以计算P值了。</p>
<h3 id="t-分布">t 分布</h3>
<p>中心极限定理需要较大的抽样个体数，这个我们称之为<em>asymptotic results</em>。当这个条件不满足时，还有一种方法可以使用。如果总体数据服从一个均值为0的正态分布，那么对于我们的抽样个体均值，可以计算以下分布，称为t分布：</p>
<p><img src="t-distribution.png" alt="t-distribution"></p>
<p>这里很重要的一点，我们提到的服从正态分布是总体（y1,y2,……yn）服从正态分布，而不是Y拔。虽然无法实际证明，但是我们看一看抽样个体的分布。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">control &lt;- controlPopulation$Bodyweight</span><br><span class="line">hf &lt;- hfPopulation$Bodyweight</span><br><span class="line"><span class="comment"># 直方图</span></span><br><span class="line">op &lt;- par(mfrow = <span class="built_in">c</span>(<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line">hist(control)</span><br><span class="line">hist(hf)</span><br><span class="line">par(op)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更为直观的是，画一个QQ（quantie，分位数）图。分位数的实例之一就是四分位数。QQ图的个人理解为，对于x轴上的一点，能得到x分布中小于等于这个点的概率（比如5%）; 再找到y分布中对应5%概率的实际数值，即y值，这样就得到了一个点（x,y)。</p>
<ul>
<li>如果是离散变量，</li>
</ul>
<blockquote>
<p>在统计学中，QQ图[1] （Q代表分位数Quantile）是一种通过比较两个概率分布的分位数对这两个概率分布进行比较的概率图方法。首先选定分位数的对应概率区间集合，在此概率区间上，点(x,y)对应于第一个分布的一个分位数x和第二个分布在和x相同概率区间上相同的分位数。因此画出的是一条含参数的曲线，参数为概率区间的分割数。</p>
</blockquote>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">op &lt;- par(mfrow = <span class="built_in">c</span>(<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line">qqnorm(hf)</span><br><span class="line">qqline(hf)</span><br><span class="line">qqnorm(control)</span><br><span class="line">qqline(control)</span><br><span class="line">par(op)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在R中，var() 和 sd() 函数都是用于计算样本参数（即除以n-1）。不适用于计算群体参数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x &lt;- control</span><br><span class="line">N &lt;- <span class="built_in">length</span>(x)</span><br><span class="line">populationvar &lt;- mean((x-mean(x))^<span class="number">2</span>)</span><br><span class="line">identical(var(x),populationvar)</span><br><span class="line"><span class="comment">#identical 判断两个值是否相等。</span></span><br><span class="line"><span class="comment">#R中的var() 和 sd() 都是除以n-1。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是实际中，我们没有用到计算总体参数的地方（得不到）。这里为了教学，用了popvar(), popsd() 函数 计算总体参数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(<span class="string">&#x27;rafalib&#x27;</span>)</span><br><span class="line">sd_hf &lt;- popsd(hf)</span><br><span class="line">sd_control &lt;- popsd(control)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一般我们也只能得到样本，如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N &lt;- 12</span><br><span class="line">hf_sample &lt;- sample(hf,<span class="number">12</span>)</span><br><span class="line">control_sample &lt;- sample(control,<span class="number">12</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了 进一步了解中心极限定理，这里采用不同的抽样大小进行抽样</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对不同地抽样个体数，抽样10000次</span></span><br><span class="line"><span class="comment">#sapple 对Ns中的每一个数，执行后面的函数</span></span><br><span class="line">Ns&lt;-<span class="built_in">c</span>(<span class="number">3</span>,<span class="number">12</span>,<span class="number">25</span>,<span class="number">50</span>)</span><br><span class="line">B &lt;-  10000   <span class="comment">#number of simulations</span></span><br><span class="line">res&lt;-sapply(Ns,<span class="keyword">function</span>(n) &#123;</span><br><span class="line">  replicate(B,mean(sample(hf,n))-mean(sample(control,n)))</span><br><span class="line">&#125;)</span><br><span class="line">res</span><br><span class="line"></span><br><span class="line"><span class="comment">## 现在我们可以用qq图看中心极限定理的效果如何</span></span><br><span class="line">op &lt;- par(mfrow=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> seq(along=Ns)) &#123;    <span class="comment"># 等于 seq(length(Ns))</span></span><br><span class="line">  titleavg&lt;-<span class="built_in">signif</span>(mean(res[,i]),<span class="number">3</span>) <span class="comment">#signif和round差不多，不过后面不是小数位数，而是有效数字。</span></span><br><span class="line">  titlesd&lt;-<span class="built_in">signif</span>(popsd(res[,i]),<span class="number">3</span>)</span><br><span class="line">  title&lt;-paste0(<span class="string">&quot;N=&quot;</span>,Ns[i],<span class="string">&quot;Avg=&quot;</span>,titleavg,<span class="string">&quot;SD=&quot;</span>,titlesd)</span><br><span class="line">  qqnorm(res[,i],main=title)</span><br><span class="line">  qqline(res[,i],col=<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#随着抽样数目的增加，标准误越小。基本符合根号N的规律。</span></span><br><span class="line"><span class="comment">#即便抽样数目为3，也基本符合正态分布。</span></span><br><span class="line"><span class="comment">#这和总体分布有关。因为我们这个小鼠体重分布本身就接近正态分布。哪怕采样个体为1，也会符合正态分布。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是在实践中，我们不会只求均值，而是会除以标准差。此时采样个数就重要了</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Ns&lt;-<span class="built_in">c</span>(<span class="number">3</span>,<span class="number">12</span>,<span class="number">25</span>,<span class="number">50</span>)</span><br><span class="line">B&lt;-<span class="number">10000</span><span class="comment">#number of simulations#</span></span><br><span class="line"><span class="comment">#function to compute a t-stat</span></span><br><span class="line">computetstat&lt;-<span class="keyword">function</span>(n) &#123;</span><br><span class="line">  y&lt;-sample(hfPopulation,n)</span><br><span class="line">  x&lt;-sample(controlPopulation,n)</span><br><span class="line">  (mean(y)-mean(x))/<span class="built_in">sqrt</span>(var(y)/n+var(x)/n)</span><br><span class="line">  &#125;</span><br><span class="line">res&lt;-sapply(Ns,<span class="keyword">function</span>(n) &#123;</span><br><span class="line">  replicate(B,computetstat(n))</span><br><span class="line">  &#125;)</span><br><span class="line">op &lt;- par(mfrow=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> seq(along=Ns)) &#123;</span><br><span class="line">  qqnorm(res[,i],main=Ns[i])</span><br><span class="line">  qqline(res[,i],col=<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">#此时N=3已经有些偏离，而N=12只有轻微偏离</span></span><br><span class="line"><span class="comment">#因此N=12已经够了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是这种模拟在实际中无法做到。这里只用于说明CLT的概念和局限。</p>
<h3 id="t-tests-in-Partice">t-tests in Partice</h3>
<p>逻辑线：</p>
<ol>
<li>首先我们得到了两个样本群体的均值差，这本身也是一个随机变量。而且根据零假设，这个变量分布的均值为0。</li>
<li>那么这个均值差分布的标准误（差）呢？</li>
<li>首先我们根据中心极限定理，每个群体均值服从正态分布，标准误为总体标准差（这里直接用样本标准差估计总体标准差）除以根号N。</li>
<li>但这仅仅是每个样本均值的标准误（或者说标准差，其实我觉得这里说标准误和标准差是一回事，标准误就是均值的标准差，所以不还是标准差吗？这里说的均值差的标准误其实也就是均值差的标准差。）</li>
<li>我们根据统计理论，我们知道两个随机变量差值的方差等于这两个随机变量的方差之和（var(x-y)=var(x)+var(y))</li>
<li>因此se = sd( x-y ) = sqrt(var(x)+var(y)) =  sqrt( sd(x)/sqrt(n) + (sd(y)/sqrt(m) )</li>
<li>tstat &lt;- diff(-0)/se</li>
<li>这就是t统计量，由于除以了se，这个统计量的SE为1。</li>
<li>因此我们只要知道这个t统计量的分布，我们就能得到P值。</li>
<li>根据中心极限定理，当<strong>抽样个体数较大</strong>时，两个抽样均值均符合正态分布。根据统计理论，那么这两个随机变量之差也服从正态分布。因此此时这个tstat也是服从<strong>均值为0，方差为1的正态分布</strong></li>
<li>那么计算为了计算P值，我们需要问：在正态分布中，出现diff或比diff（tstat）更极端的值的概率是多大？（ how often does a normally distributed randomvariable exceeddiff?）我们可以通过pnorm()函数进行计算双尾概率。</li>
<li>在本例中，p-value 小于 0.05， 我们认为差异是显著的。（深入理解P值，P值是零假设成立下该事件发生的概率）</li>
<li>但是我们又面临另一个问题。中心极限定理只有在样本量较大时适用，但是12足够大了吗？一般我们认为样本数大于30才比较好。所以我们刚刚计算的P值只有在这个成立时才有效，所以这里可能不适用。然而，除了使用中心极限定理，我们这里有另一种方法。</li>
</ol>
<p>R代码如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dat&lt;-read.csv(<span class="string">&quot;femaleMiceWeights.csv&quot;</span>)<span class="comment">#previously downloaded</span></span><br><span class="line">control&lt;-filter(dat,Diet==<span class="string">&quot;chow&quot;</span>)%&gt;%select(Bodyweight)%&gt;%unlist</span><br><span class="line">treatment&lt;-filter(dat,Diet==<span class="string">&quot;hf&quot;</span>)%&gt;%select(Bodyweight)%&gt;%unlist</span><br><span class="line">diff&lt;-mean(treatment)-mean(control)</span><br><span class="line">print(diff)</span><br><span class="line"><span class="comment">## [1] 3.020833</span></span><br><span class="line"></span><br><span class="line">se&lt;-<span class="built_in">sqrt</span>(</span><br><span class="line">  var(treatment)/<span class="built_in">length</span>(treatment) + </span><br><span class="line">    var(control)/<span class="built_in">length</span>(control)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">tstat&lt;-diff/se</span><br><span class="line"><span class="comment">## [1] 2.055174</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##tstat在标准正态分布中出现的概率(双尾)</span></span><br><span class="line"><span class="comment">##也就是在标准正态分布中出现tstat及比tstat更极端的值的概率</span></span><br><span class="line">righttail&lt;-<span class="number">1</span>-pnorm(<span class="built_in">abs</span>(tstat))</span><br><span class="line">lefttail&lt;-pnorm(-<span class="built_in">abs</span>(tstat))</span><br><span class="line">pval&lt;-lefttail+righttail</span><br><span class="line">print(pval)</span><br><span class="line"></span><br><span class="line"><span class="comment">## [1] 0.0398622</span></span><br></pre></td></tr></table></figure>
<h3 id="The-t-distribution-in-Practice">The t-distribution in Practice</h3>
<p>根据上面的模拟情况和统计理论。 如果<strong>总体的分布是正态的</strong>，那么我们可以<strong>不通过中心极限定理</strong>，而弄清楚t统计量的确切分布。但是如果抽样个体数很少，很难证明总体分布是否符合正态。但是对于体重这种数据，根据经验，我们一般认为总体分布极可能大致符合正态分布，因此我们可以利用这种近似。另外，我们也可以看一下样本的qq图，如下所示。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">op &lt;- par(mfrow=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">qqnorm(treatment)</span><br><span class="line">qqline(treatment,col=<span class="number">2</span>)</span><br><span class="line">qqnorm(control)</span><br><span class="line">qqline(control,col=<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果我们近似认为<strong>总体分布符合正态分布</strong>，那么基于统计理论，tstat服从t分布。相较于正态分布，t分布还有一个自由度的参数。我们直接通过下面的函数求解P值。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">t.test(treatment,control)</span><br><span class="line"></span><br><span class="line">t.test(treatment,control)$p.value <span class="comment">### 直接看P值</span></span><br><span class="line"><span class="comment">## [1] 0.05299888</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>The p-value is slightly bigger now. This is to be expected because our CLT approximation consideredthe denominator oftstatpractically fixed (with large samples it practically is), while the t-distribution approximation takes into account that the denominator (the standard error of thedifference) is a random variable. The smaller the sample size, the more the denominator varies.</p>
</blockquote>
<p>这段话没看太懂，大概理解是：这里用t分布计算出来的p值相较于上面用正态分布计算出来的P值较大。这是因为在CLT中，认为tstat的分母部分是固定的（也就是认为采用了大样本）；而t分布检验中认为tstat的分母部分是随机变量（还不是很懂）。</p>
<p>这可能会让人困惑，怎么会得到两个P值？但是，这在数据分析中是很常见的。通过不同的假设，不同的方法，我们就会得到不同的结果。</p>
<p>其实，基于中心极限定理得到的结果更容易出现<strong>假阳性</strong>，而基于t分布的结果更容易出现<strong>假阴性</strong>。</p>
<h3 id="Confidence-Intervals">Confidence Intervals</h3>
<p>在生命科学中，我们总是需要计算P值。但是我们并不推崇把P值当成唯一的统计指标。原因很简单：统计意义上的显著并不保证科学意义上的显著。当抽样个体数很大时，即便两个群体差异很小，你仍可以检测到一个统计意义上的显著差异。但是这有意义吗？如果只看P值，信息是不够的。还需要给出效应大小（这里是两个群体均值差）。<br>
另一种方法是给出置信区间。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#以control群体均值的置信区间为例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#先看总体的均值</span></span><br><span class="line">dat&lt;-read.csv(<span class="string">&quot;mice_pheno.csv&quot;</span>)</span><br><span class="line">chowPopulation&lt;-dat[dat$Sex==<span class="string">&quot;F&quot;</span>&amp;dat$Diet==<span class="string">&quot;chow&quot;</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">mu_chow&lt;-mean(chowPopulation)</span><br><span class="line">print(mu_chow)</span><br><span class="line"><span class="comment">## [1] 23.89338</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##我们是要估计这个参数，但是我们实际拿不到总体的数据</span></span><br><span class="line"><span class="comment">## 先抽取样本量为30的样本</span></span><br><span class="line"></span><br><span class="line">N&lt;-<span class="number">30</span></span><br><span class="line">chow&lt;-sample(chowPopulation,N)</span><br><span class="line">print(mean(chow))</span><br><span class="line"><span class="comment">## [1] 24.54567</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#我们知道样本均值是一个随机变量</span></span><br><span class="line"><span class="comment">#所以，这个值不是一个完美的估计</span></span><br><span class="line"><span class="comment">#通过置信区间来体现这个随机变量的variability</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#因为样本量为30，我们可以使用CLT。</span></span><br><span class="line"><span class="comment">#中心极限定理告诉我们，样本均值服从一个均值为总体均值，标准差为总体标准差除以根号30的正态分布。</span></span><br><span class="line"></span><br><span class="line">se&lt;-sd(chow)/<span class="built_in">sqrt</span>(N)</span><br><span class="line">print(se)</span><br><span class="line"><span class="comment">## [1] 0.6610814</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>A 95% confidence interval (we can use percentages other than 95%) is a random interval with a95% probability of falling on the parameter we are estimating. Keep in mind that saying 95% ofrandom intervals will fall on the true value (our definition above) isnot the sameas saying there isa 95% chance that the true value falls in our interval.(有点绕，没太懂。懂了，这个置信区间其实也是一个随机变量，你再抽一个样，这个置信区间也会变。所以你只能说置信区间（随机变量）从统计上说有95%的概率包含真值（你要是取10000个样本，计算出10000个置信区间，其中包含总体均值的概率在95%左右）。但是，如果是一个给定的区间(你最后计算出来的区间)，那么真值存在这个区间的概率只有0和1)</p>
</blockquote>
<p>由中心极限定理，我们可以对样本均值进行标准化。然后我们知道标准正态分布的95%区间大致在[-2,2]。因此可以得出下式</p>
<p><img src="confidence_interval.png" alt="confidence_interval"></p>
<p>我们直接得出置信区间</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Q&lt;-qnorm(<span class="number">1</span>-<span class="number">0.05</span>/<span class="number">2</span>)</span><br><span class="line">interval&lt;-<span class="built_in">c</span>(mean(chow)-Q*se, mean(chow)+Q*se )</span><br><span class="line">interval</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>模拟n次置信区间</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(rafalib)</span><br><span class="line">B&lt;-<span class="number">250</span></span><br><span class="line">mypar()</span><br><span class="line">plot(mean(chowPopulation)+<span class="built_in">c</span>(-<span class="number">7</span>,<span class="number">7</span>),<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>),type=<span class="string">&quot;n&quot;</span>,</span><br><span class="line">	xlab=<span class="string">&quot;weight&quot;</span>,ylab=<span class="string">&quot;interval&quot;</span>,ylim=<span class="built_in">c</span>(<span class="number">1</span>,B))</span><br><span class="line">	abline(v=mean(chowPopulation))</span><br><span class="line">	<span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:B) &#123;</span><br><span class="line">	chow&lt;-sample(chowPopulation,N)</span><br><span class="line">	se&lt;-sd(chow)/<span class="built_in">sqrt</span>(N)</span><br><span class="line">	interval&lt;-<span class="built_in">c</span>(mean(chow)-Q*se, mean(chow)+Q*se)</span><br><span class="line">	covered&lt;-</span><br><span class="line">		mean(chowPopulation) &lt;=interval[<span class="number">2</span>]&amp;mean(chowPopulation)&gt;=interval[<span class="number">1</span>]</span><br><span class="line">	color&lt;-ifelse(covered,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">	lines(interval, <span class="built_in">c</span>(i,i),col=color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个代码画出了250次置信区间的图（代码内容没看）。其中大概有5%的置信区间没有包含总体均值。</p>
<p>但是上面是因为抽样个体较多（N = 30），满足了中心极限定理。如果 N = 5，那么这样做也有效吗？我们就模拟这种N =5，使用CLT的情况。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N &lt;- 5</span><br><span class="line">mypar()</span><br><span class="line">plot(mean(chowPopulation)+<span class="built_in">c</span>(-<span class="number">7</span>,<span class="number">7</span>),<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>),type=<span class="string">&quot;n&quot;</span>,</span><br><span class="line">     xlab=<span class="string">&quot;weight&quot;</span>,ylab=<span class="string">&quot;interval&quot;</span>,ylim=<span class="built_in">c</span>(<span class="number">1</span>,B))</span><br><span class="line">abline(v=mean(chowPopulation))</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:B)&#123;</span><br><span class="line">  chow&lt;-sample(chowPopulation,N)</span><br><span class="line">  se&lt;-sd(chow)/<span class="built_in">sqrt</span>(N)</span><br><span class="line">  interval&lt;-<span class="built_in">c</span>(mean(chow)-Q*se, mean(chow)+Q*se)</span><br><span class="line">  covered&lt;- mean(chowPopulation) &lt;=interval[<span class="number">2</span>]&amp;mean(chowPopulation)&gt;=interval[<span class="number">1</span>]</span><br><span class="line">  color &lt;- ifelse(covered,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">  lines(interval, <span class="built_in">c</span>(i,i),col=color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们发现置信区间的宽度增加了，但是没有覆盖真值的情况却多了很多。这是因为这里我们通过CLT错误地认为样本均值符合正态分布，但是实际上相较于正态它两侧的尾巴更大（It has a fatter tail）。这影响到了我们Q值的计算（这里是-2到2）。这种情况下，采用t分布更合适。所以我们只需用qt() 函数来计算Q就可以了，其它不变。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N &lt;- 5</span><br><span class="line">Q&lt;-qt(<span class="number">1</span>-<span class="number">0.05</span>/<span class="number">2</span>, df=<span class="number">4</span>)</span><br><span class="line">mypar()</span><br><span class="line">plot(mean(chowPopulation)+<span class="built_in">c</span>(-<span class="number">7</span>,<span class="number">7</span>),<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>),type=<span class="string">&quot;n&quot;</span>,</span><br><span class="line">     xlab=<span class="string">&quot;weight&quot;</span>,ylab=<span class="string">&quot;interval&quot;</span>,ylim=<span class="built_in">c</span>(<span class="number">1</span>,B))</span><br><span class="line">abline(v=mean(chowPopulation))</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:B)&#123;</span><br><span class="line">  chow&lt;-sample(chowPopulation,N)</span><br><span class="line">  se&lt;-sd(chow)/<span class="built_in">sqrt</span>(N)</span><br><span class="line">  interval&lt;-<span class="built_in">c</span>(mean(chow)-Q*se, mean(chow)+Q*se)</span><br><span class="line">  covered&lt;- mean(chowPopulation) &lt;=interval[<span class="number">2</span>]&amp;mean(chowPopulation)&gt;=interval[<span class="number">1</span>]</span><br><span class="line">  color &lt;- ifelse(covered,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">  lines(interval, <span class="built_in">c</span>(i,i),col=color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们看到置信区间的宽度<strong>进一步</strong>（相较于CLT）增加了（因为t分布尾巴厚，得到的Q值更大），但是基本符合了95%的概率。</p>
<h3 id="置信区间和P值的关系">置信区间和P值的关系</h3>
<p>我们推荐在实际中更多的使用置信区间，而不是P值。</p>
<p>如果你给出P值，我们会问差距是不是真的像你计算或观测出来的值那么大。<strong>因为即便两个群体总体均值为0，得到的样本均值差也有可能出现你计算或观测的结果</strong>。因此，我们可以给出均值差的置信区间，来回答这个问题。</p>
<p>如果均值差的95%的置信区间中不包含0，那么我们可以说差异不显著（0.05水平下），也就是p值肯定小于0.05。（99%的置信区间类似）</p>
<p>t.test的结果中包含了95%的置信区间。</p>
<h3 id="Power-Calculations">Power Calculations</h3>
<p>由于我们有总体信息，我们从总体信息中可以直接得知，这两个群体确实是有差距的，而且按比例大约是10%。<br>
但是我们如果从中取样，然后进行t-test，有的时候P值不总是小于0.05。</p>
<p>所以我们犯错了吗？通过不拒绝原假设，我们要说diet没有影响吗？这个问题的答案是no。All we can say is that we did not reject the null hypothesis. But this does not necessarily imply that the null is true（我们只是说不拒绝原假设，但我们没有说原假设是真的）.</p>
<p>这个问题的本质是这样，在这次的实例中，我们没有得到足够的power（不知道啥意思）。在科学研究中，你很可能需要做某种程度的power calculation。在很多情况下，这是一种道德义务，来避免不必要地牺牲更多小鼠，或者使人们因为你的研究遭遇潜在的风险。</p>
<h4 id="types-of-error">types of error</h4>
<blockquote>
<p>Ⅰ型错误：原假设为真，我们拒绝的概率，等于P值<br>
Ⅱ型错误：原假设为假，没有拒绝原假设的概率</p>
</blockquote>
<p>当我们在进行统计检验时，我们始终需要注意我们很可能会犯错误。这就是为什么我们的p值不是0。在原假设成立的前提下，总是存在一个可能很少，但是可能发生的概率，使得我们拒绝了正确的原假设。如果P值设为0.05，那么这种情况发生的概率也就是0.05。这种错误叫做Ⅰ型错误（typeⅠerror）</p>
<p>Ⅰ型错误会发生<strong>假阳性</strong>。那么我们为什么只设为0.05？不设定一个非常小的值呢？因为还存在另外一种错误，Ⅱ型错误，即原假设为假，没有拒绝原假设的概率，这会造成<strong>假阴性</strong>。像上面我们提到的那种情况，就是犯了二型错误。如果我们把P值提高到0.25，那么上面的例子就能够显著。但是一般情况下我们愿不愿意提高P值到0.25呢？通常我们不会这么做。</p>
<h4 id="0-05或0-01-的-p值-是随意划分的（The-0-05-and-0-01-Cut-offs-Are-Arbitrary）">0.05或0.01 的 p值 是随意划分的（The 0.05 and 0.01 Cut-offs Are Arbitrary）</h4>
<p>很多杂志和监管部门强调要达到0.05或0.01水平的显著。但是这两个数字的设定其实没有特别的，这仅仅是因为最开始的文章用这两个数字作为例子而已。本书的部分目的之一就是让读者对于P值和置信区间有一个更加清晰的认识（受教了）。</p>
<h4 id="Power-Calculation">Power Calculation</h4>
<p>Power is the probability of rejecting the null when the null is false（Power 是指当原假设为假时拒绝原假设的概率）。</p>
<p>下面我们通过R中的实际代码去理解这个概念。</p>
<p>我们仍然假设样本大小为12，显著水平时0.05。由于我们已经两个群体均值有差异，我们可以重复抽样，看每次抽样t检验是否小于0.05</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N&lt;-12</span><br><span class="line">alpha&lt;-0.05</span><br><span class="line">B&lt;-2000</span><br><span class="line"></span><br><span class="line">reject&lt;-function(N, alpha&#x3D;0.05)&#123;</span><br><span class="line">	hf&lt;-sample(hfPopulation,N)</span><br><span class="line">	control&lt;-sample(controlPopulation,N)</span><br><span class="line">	pval&lt;-t.test(hf,control)$p.value</span><br><span class="line">	pval&lt;alpha</span><br><span class="line">&#125;</span><br><span class="line">#reject 给出一次抽样是否小于0.05</span><br><span class="line"></span><br><span class="line">reject(12)</span><br><span class="line">## [1] FALSE</span><br><span class="line"></span><br><span class="line">rejections &lt;- replicate(B,reject(N))</span><br><span class="line">#重复2000次，replicate(n,expr) </span><br><span class="line"></span><br><span class="line">mean(rejetions) # 这就是N&#x3D;12时Power的值</span><br><span class="line">## [1] 0.2215</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这就是为什么当我们知道原假设是错的时，t-test却没有拒绝原假设。当样本大小只有12时，power只有23%。为了降低<strong>假阳性</strong>发生的概率，我们将P值设在0.05水平。其实这个水平有点过高，导致发生<strong>Ⅱ型错误</strong>的概率大大提高。</p>
<blockquote>
<p>power 和 发生Ⅱ型的概率 相加为1。power低，说明发生Ⅱ型错误的概率高。</p>
</blockquote>
<p>接下来，让我们来看看power和抽样大小N的关系。这里我们用到了<strong>sapply(Ns,expr)</strong>，这个函数会对向量中的每一个数执行同样的function。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Ns&lt;-seq(<span class="number">5</span>,<span class="number">50</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># So we use apply() like this</span></span><br><span class="line">power&lt;-sapply(Ns,<span class="keyword">function</span>(N)&#123;</span><br><span class="line">	rejections&lt;-replicate(B, reject(N))</span><br><span class="line">	mean(rejections)</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">plot(Ns,power,type = <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看出，随着N的增加，power不断提高。</p>
<p>我们固定N，看一看alpha的设定对power 的影响</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N&lt;-<span class="number">30</span></span><br><span class="line">alphas&lt;-<span class="built_in">c</span>(<span class="number">0.1</span>,<span class="number">0.05</span>,<span class="number">0.01</span>,<span class="number">0.001</span>,<span class="number">0.0001</span>)</span><br><span class="line">power&lt;-sapply(alphas,<span class="keyword">function</span>(alpha)&#123;</span><br><span class="line">	rejections &lt;- replicate(B,reject(N,alpha=alpha))</span><br><span class="line">	mean(rejections)</span><br><span class="line">&#125;)</span><br><span class="line">plot(alphas, power, xlab=<span class="string">&quot;alpha&quot;</span>, type=<span class="string">&quot;b&quot;</span>, <span class="built_in">log</span>=<span class="string">&quot;x&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看出随着alpha的增加，power也在不断增加。</p>
<blockquote>
<p>There is no “right” power or “right” alpha level, but it is important that you understand what eachmeans.</p>
</blockquote>
<h5 id="p-values-are-Arbitrary-under-the-Alternative-Hypothesis">p-values are Arbitrary under the Alternative Hypothesis</h5>
<blockquote>
<p>Another consequence of what we have learned about power is that p-values are somewhat arbitrarywhen the null hypothesis is not true and therefore thealternativehypothesis is true (the differencebetween the population means is not zero). When the alternative hypothesis is true, we can make a p-value as small as we want simply by increasing the sample size (supposing that we have an infinitepopulation to sample from). We can show this property of p-values by drawing larger and largersamples from our population and calculating p-values. This works because, in our case, we knowthat the alternative hypothesis is true, since we have access to the populations and can calculate thedifference in their means.</p>
</blockquote>
<p>随着样本大小的增加，P值会减小（假设群体无限大）。证明如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">calculatePvalue&lt;-<span class="keyword">function</span>(N) &#123;</span><br><span class="line">	hf&lt;-sample(hfPopulation,N)</span><br><span class="line">	control&lt;-sample(controlPopulation,N)</span><br><span class="line">	t.test(hf,control)$p.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ns&lt;-seq(<span class="number">10</span>,<span class="number">200</span>,by=<span class="number">10</span>)</span><br><span class="line">Ns_rep&lt;-<span class="built_in">rep</span>(Ns, each=<span class="number">10</span>) <span class="comment">#each 的形式是 10 10 10…… 20 ……</span></span><br><span class="line"></span><br><span class="line">pvalues&lt;-sapply(Ns_rep, calculatePvalue)</span><br><span class="line"></span><br><span class="line">plot(Ns_rep, pvalues, <span class="built_in">log</span>=<span class="string">&quot;y&quot;</span>, xlab=<span class="string">&quot;sample size&quot;</span>,</span><br><span class="line">ylab=<span class="string">&quot;p-values&quot;</span>)</span><br><span class="line">abline(h=<span class="built_in">c</span>(<span class="number">.01</span>,<span class="number">.05</span>), col=<span class="string">&quot;red&quot;</span>, lwd=<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>样本量从10增加到200的过程中，p值最低下降到了10^-8^。但是p值太低也不见得是一件很好的事。一旦我们确信了一个reasonable alpha（比如0.05），那么如果我们获得了一个比这个阈值低得多的p值，那就说明<strong>我们用了过量的小鼠</strong>。适当地提高样本量，确实有助于估计的准确性。但是，实际上，随着样本量的增加p值的降低是一件自然的事。</p>
<blockquote>
<p>The p-values get smaller and smaller with increasing sample size because the numerator ofthe t-statistic haspN(for equal sized groups, and a similar effect occurs whenM̸=N). Therefore,if∆is non-zero, the t-statistic will increase with N.</p>
</blockquote>
<p>事实上，随着样本量的增加，t-test得到的p值也会不断降低。这是t统计量中有一个根号N。</p>
<p>算了个Cohen’s d，但没看懂这个统计量到底有啥用？</p>
<blockquote>
<p>This tells us how many standard deviations of the data the mean of the high-fat diet group is from the control group. Under the alternative hypothesis, unlike the t-statistic which is guaranteed to increase, the effect size and Cohen’s d will become more precise.（看不懂）</p>
</blockquote>
<h3 id="Monte-Carlo-Simulation">Monte Carlo Simulation</h3>
<p>电脑可以用来产生伪随机数（pseudo-random numbers），一个最大的好处是我们可以通过模拟数据来证明我们的假设或理论。</p>
<blockquote>
<p>伪随机性（英语：Pseudorandomness）是一个过程似乎是随机的，但实际上并不是。例如伪随机数是使用一个确定性的算法计算出来的似乎是随机的数序，因此伪随机数实际上并不随机。在计算伪随机数时假如使用的开始值不变的话，那么伪随机数的数序也不变。</p>
</blockquote>
<p>Simulations can also be used to check theoretical or analytical results. Also, many of the theoretical results we use in statistics are based on <strong>asymptotics</strong>: they hold when the sample size goes to <a href="http://infinity.In">infinity.In</a> practice, we never have an infinite number of samples so we may want to know how well thetheory works with our actual sample size.</p>
<p>作为例子，我们蒙特卡洛模拟（ Monte Carlo simulation）来比较不同样本大小的情况下CLT和t分布的近似值。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(dplyr)</span><br><span class="line">dat&lt;-read.csv(<span class="string">&quot;mice_pheno.csv&quot;</span>)<span class="comment">#Previously downloaded</span></span><br><span class="line">controlPopulation&lt;-filter(dat,Sex==<span class="string">&quot;F&quot;</span>&amp;Diet==<span class="string">&quot;chow&quot;</span>)%&gt;%select(Bodyweight)%&gt;%unlist</span><br><span class="line"></span><br><span class="line">ttestgenerator&lt;-<span class="keyword">function</span>(n) &#123;</span><br><span class="line">  <span class="comment">#note that here we have a false &quot;high fat&quot; group where we actually</span></span><br><span class="line">  <span class="comment">#sample from the nonsmokers. this is because we are modeling the *null*</span></span><br><span class="line">  cases&lt;-sample(controlPopulation,n)</span><br><span class="line">  controls&lt;-sample(controlPopulation,n)</span><br><span class="line">  tstat&lt;-(mean(cases)-mean(controls))/<span class="built_in">sqrt</span>( var(cases)/n+var(controls)/n ) <span class="comment">#这个t统计量是假设两个群体方差不等</span></span><br><span class="line">  <span class="built_in">return</span>(tstat)</span><br><span class="line">  &#125;</span><br><span class="line">ttests&lt;-replicate(<span class="number">1000</span>, ttestgenerator(<span class="number">10</span>))</span><br><span class="line">hist(ttests)</span><br></pre></td></tr></table></figure>
<p>从直方图中，我们近似看出符合正态分布。但是从上文提到，我们再看一下QQ图</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qqnorm(ttests)</span><br><span class="line">qqline(ttests)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从QQ图中，可以看出近似符合正态分布。这说明在样本数是10的情况下，已经符合正态分布，可以使用中心极限定理了。那么如果样本数为3呢？</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ttests&lt;-replicate(<span class="number">1000</span>, ttestgenerator(<span class="number">3</span>))</span><br><span class="line">qqnorm(ttests)</span><br><span class="line">qqline(ttests)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Now we see that the large quantiles, referred to by statisticians as the tails, are larger than expected(below the line on the left side of the plot and above the line on the right side of the plot).</p>
</blockquote>
<p>我们可以看出QQ图中左侧低于直线，右侧高于直线。这说明两侧的尾巴比正态分布要肥。</p>
<p>在之前的章节中，我们提到，如果<strong>样本数不大</strong> 并且 <strong>总体符合正态分布</strong> ，那么使用t分布是一种更好的近似。证明如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ps&lt;-(seq(<span class="number">0</span>,<span class="number">999</span>)+<span class="number">0.5</span>)/<span class="number">1000</span> <span class="comment">#0到1的均匀分布</span></span><br><span class="line">qqplot(qt(ps,df=<span class="number">2</span>*<span class="number">3</span>-<span class="number">2</span>),ttests,xlim=<span class="built_in">c</span>(-<span class="number">6</span>,<span class="number">6</span>),ylim=<span class="built_in">c</span>(-<span class="number">6</span>,<span class="number">6</span>))</span><br><span class="line"><span class="comment"># qt获得某t分布累积概率的数值</span></span><br><span class="line"><span class="comment"># qqplot比较两个变量分布是否相同</span></span><br><span class="line">abline(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从中我们可以看出，t分布在这种情况下更为近似，但是仍不完美。这是因为<strong>总体并不是很好地符合正态分布</strong>。(从下面总体的QQ图中看出，总体略偏)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qqnorm(controlPopulation)</span><br><span class="line">qqline(controlPopulation)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Parametric-Simulations-for-the-Observations">Parametric Simulations for the Observations</h3>
<p>我们再这里使用蒙特卡洛模拟随机变量和假设检验，这是因为我们有总体数据。这是为了教学的作用，但在实际运用中是不可能的。一般采用蒙特卡洛模拟，主要用于参数估计（如均值和标准差）。</p>
<p>以小鼠体重的例子来说，我们通过先验知识，认识到小鼠的体重均值为24盎司，标准差为3.5盎司，而且小鼠体重近似符合正态分布。通过以上信息，我们可以构建一个总体数据。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">controls&lt;-rnorm(<span class="number">5000</span>, mean=<span class="number">24</span>, sd=<span class="number">3.5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于我们可以重复上述操作。因此我们不需要用到sample()函数了。代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ttestgenerator&lt;-function(n, mean&#x3D;24, sd&#x3D;3.5) &#123;</span><br><span class="line">  cases&lt;-rnorm(n,mean,sd)</span><br><span class="line">  controls&lt;-rnorm(n,mean,sd)</span><br><span class="line">  tstat&lt;-(mean(cases)-mean(controls))&#x2F;sqrt( var(cases)&#x2F;n+var(controls)&#x2F;n )</span><br><span class="line">  return(tstat)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Permutation-Tests">Permutation Tests</h3>
<p>假设我们遇到这样一种情况，没有一种标准的统计量能近似模拟我们的数据。</p>
<p>We have computed a summary statistic, such as the difference in mean, but do not have auseful approximation, such as that provided by the CLT.</p>
<p>这个时候 Permutation Tests 就派上用场了。</p>
<p>让我们回到最开始拿到的样本</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dat=read.csv(<span class="string">&quot;femaleMiceWeights.csv&quot;</span>)</span><br><span class="line">library(dplyr)</span><br><span class="line">control&lt;-filter(dat,Diet==<span class="string">&quot;chow&quot;</span>)%&gt;%select(Bodyweight)%&gt;%unlist</span><br><span class="line">treatment&lt;-filter(dat,Diet==<span class="string">&quot;hf&quot;</span>)%&gt;%select(Bodyweight)%&gt;%unlist</span><br><span class="line">obsdiff&lt;-mean(treatment)-mean(control)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>In previous sections, we showed parametric approaches that helped determine if the observeddifference was significant. Permutation tests take advantage of the fact that if we randomly shufflethe cases and control labels, then the null is true. So we shuffle the cases and control labels andassume that the ensuing distribution approximates the null distribution. Here is how we generate anull distribution by shuffling the data 1,000 times:</p>
</blockquote>
<p>这段话的大意是，之前我们是用带参数的方法（均值，标准差）检验差异是否显著。而这个Permutation tests 认为，如果我们随机洗牌 cases 和 control 的标签，那么零假设应该是正确的。<br>
下面我们洗牌了1000次。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N&lt;-<span class="number">12</span></span><br><span class="line">avgdiff&lt;-replicate(<span class="number">1000</span>, &#123;</span><br><span class="line">  <span class="built_in">all</span>&lt;-sample(<span class="built_in">c</span>(control,treatment))</span><br><span class="line">  newcontrols&lt;-<span class="built_in">all</span>[<span class="number">1</span>:N]</span><br><span class="line">  newtreatments&lt;-<span class="built_in">all</span>[(N+<span class="number">1</span>):(<span class="number">2</span>*N)]</span><br><span class="line">  <span class="built_in">return</span>(mean(newtreatments)-mean(newcontrols))</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">#这个&#123;&#125;好像是不带名称的函数，类似于Python中的lambda</span></span><br><span class="line"><span class="comment">#sample(x)不加n,就是重排（permutation）的意思</span></span><br><span class="line">hist(avgdiff)</span><br><span class="line">abline(v=obsdiff, col=<span class="string">&quot;red&quot;</span>, lwd=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>How many of the null means are bigger than the observed value? That proportion would be thep-value for the null. We add a 1 to the numerator and denominator to account for misestimation ofthe p-value</p>
</blockquote>
<p>在这1000次中，有多少比例大于这个obsdiff，这就是P值。但是，分子分母要都加上一个1。（个人理解实际上是做了1001次，没有算上真实情况）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">sum</span>(<span class="built_in">abs</span>(avgdiff)&gt;<span class="built_in">abs</span>(obsdiff))+<span class="number">1</span>)/(<span class="built_in">length</span>(avgdiff)+<span class="number">1</span>)</span><br><span class="line"><span class="comment">## [1] 0.05594406</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在我们把这个用在样本量更小的数据集，比如样本量为5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N&lt;-5</span><br><span class="line">control&lt;-sample(control,N)</span><br><span class="line">treatment&lt;-sample(treatment,N)</span><br><span class="line">obsdiff&lt;-mean(treatment)-mean(control)</span><br><span class="line"></span><br><span class="line">avgdiff&lt;-replicate(1000, &#123;</span><br><span class="line">  all&lt;-sample(c(control,treatment))</span><br><span class="line">  newcontrols&lt;-all[1:N]</span><br><span class="line">  newtreatments&lt;-all[(N+1):(2*N)]</span><br><span class="line">  return(mean(newtreatments)-mean(newcontrols))</span><br><span class="line">&#125;)</span><br><span class="line">hist(avgdiff)</span><br><span class="line">abline(v&#x3D;obsdiff, col&#x3D;&quot;red&quot;, lwd&#x3D;2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在可以明显看出差距不显著了。</p>
<blockquote>
<p>Now the observed difference is not significant using this approach. Keep in mind that there is notheoretical guarantee that the null distribution estimated from permutations approximates the actualnull distribution. For example, if there is a real difference between the populations, some of the permutations will be unbalanced and will contain some samples that explain this difference. This implies that the null distribution created with permutations will have larger tails than the actualnull distribution. This is why permutations result in conservative p-values. For this reason, whenwe have few samples, we can’t do permutations.</p>
</blockquote>
<p>没看懂，结论是数据量小时，不用这种permutation test</p>
<p>而且permutation test 也有假设：<strong>:samples are assumed to be independentand “exchangeable”</strong> 。 If there is hidden structure in your data, then permutation tests can result in estimated null distributions that underestimate the size of tails because the permutations may destroy the existing structure in the original data.</p>
<h3 id="Association-Tests">Association Tests</h3>
<p>前面的统计分析中，忽略了一类重要的数据，二元或者说分类数据。举个例子，当你有两种疾病的基因型的群体(AA/Aa 与 aa)作为cases 和 control。我们要提出的问题是，这个基因型与疾病是否有关系。<br>
这里疾病状况表示为0和1，那么我们为什么不能用t-test？因为数据要么是0要么是1，很明显不会符合正态分布，因此不能使用t-test。</p>
<p>如果样本数量很大的话，我们可以使用CLT。不然的话，我们就可以使用Association Tests。</p>
<h4 id="二项分布与超几何分布">二项分布与超几何分布</h4>
<p>解释: 我的这种算法是基于二项分布，而Fisher’s exact test是基于超几何分布（hypergeometric distribution）。<br>
二项分布</p>
<ol>
<li>试验次数固定</li>
<li>每一次事件都有两个可能的结果</li>
<li><strong>每次试验中的事件相互独立</strong></li>
<li><strong>每一次成功的概率相等</strong></li>
</ol>
<p>超几何分布 它描述了由<strong>有限个物件中</strong>抽出n个物件，成功抽出指定种类的物件的个数（不归还 （without replacement））。</p>
<p>例如在有N个样本，其中K个是不及格的。超几何分布描述了在该N个样本中抽出n个，其中k个是不及格的概率。</p>
<p>特点：</p>
<ol>
<li>每次抽取也只有两个互斥的结果</li>
<li><strong>每次抽取后成功的概率发生改变</strong>（因为是不放回抽样，这也导致了每次抽取事件不独立）</li>
</ol>
<h4 id="Lady-Tasting-Tea">Lady Tasting Tea</h4>
<p>R.A.Fisher 的一位熟人宣称她能分辨牛奶是早于或晚于茶放入杯中（就是牛奶和茶混合的顺序）。Fisher 就和她做了一个小实验，4次中对了3次。那么，我们能否说明这位女士存在这种特殊的能力呢？这个例子被称为&quot;Lady tasting tea&quot;。<br>
按照之前的经验。一个基本的问题是，如果这位女士仅仅靠猜，她能得到3/4或更高的正确率(即3/4+4/4)的概率是多少？<br>
仍和之前一样，我们需要计算在零假设成立的前提下事情发生的概率。这里的零假设就是这位女士都是猜的。</p>
<blockquote>
<p>he basic question we ask is: if the tester is actually guessing, what are the chances that she gets 3 ormore correct? Just as we have done before, we can compute a probability under the null hypothesisthat she is guessing four of each. If we assume this null hypothesis, we can think of this particularexamples as picking 4 balls out of an urn with 4 green (correct answer) and 4 red (incorrect answer)balls.</p>
</blockquote>
<blockquote>
<p>Under the null hypothesis that she is simply guessing, each ball has the same chance of beingpicked. We can then use combinatorics to figure out each probability. The probability of picking3 is(43)(41)/(84)= 16/70. The probability of picking all 4 correct is(44)(40)/(84)= 1/70. Thus, thechance of observing a 3 or something more extreme, under the null hypothesis, is 0.24. This isthe p-value. The procedure that produced this p-value is calledFisher’s exact testand it uses the hypergeometric distribution.</p>
</blockquote>
<p>它这种算法是8个球里摸4个。我的算法是每次猜对的概率是0.5，那么4次猜对3次的概率是4*0.5^3^*0.5=0.25。这两种结果不一样，我也搞不太清楚。</p>
<p>这里算错了，除了不清晰二项分布与超几何分布，还有一个原因，不清楚这个Lady tasting tea试验。在这个试验中，Fisher准备了8杯茶，每一种（tea first or milk first）都准备了4杯，并且随机拜放位置。试验者需挑出按其中一种方法泡制的4杯。</p>
<p>按Fisher’s exact test 只有当这位女士把4杯都挑出来（p=1/70），他才会承认她有这种能力（但是不能量化）。哪怕如题所示，她挑出来了3杯（p=16/70+1/70=17/70），P值也是不显著。</p>
<blockquote>
<p>当样本量更大时，也可以使用卡方分布。但是，当样本数目很少或数据分布极不平衡（如果某个cell的数目小于5 或小于10）时，卡方分布的估计是不充分的。而与之相反，Fisher 精确检验，正如它的名称，不论样本如何都能保持精确。但是当样本量很大或非常平衡，Fisher 精确检验计算不方便，这时就需要用到卡方分布。</p>
</blockquote>
<p>公式如下：<br>
<img src="Fisher's_exact_test.png" alt="Fisher's_exact_test"></p>
<p>小结：<br>
Fisher 精确检验使用于<strong>检验两个分类变量是否相关</strong>。</p>
<ul>
<li>Fisher 精确检验：适合样本小或不平衡数据</li>
<li>卡方检验：适合样本大、平衡数据</li>
</ul>
<h4 id="Two-By-Two-Tables">Two By Two Tables</h4>
<p>The data from the experiment above can be summarized by a 2 by 2 table:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tab&lt;-matrix(c(3,1,1,3),2,2)</span><br><span class="line">rownames(tab)&lt;-c(&quot;Poured Before&quot;,&quot;Poured After&quot;)</span><br><span class="line">colnames(tab)&lt;-c(&quot;Guessed before&quot;,&quot;Guessed after&quot;)</span><br><span class="line">tab</span><br><span class="line">#The function fisher.test performs the calculations above and can be obtained like this:</span><br><span class="line">fisher.test(tab,alternative&#x3D;&quot;greater&quot;)</span><br><span class="line">##</span><br><span class="line">##Fisher&#39;s Exact Test for Count Data</span><br><span class="line">##</span><br><span class="line">## data:  tab</span><br><span class="line">## p-value &#x3D; 0.2429</span><br><span class="line">## alternative hypothesis: true odds ratio is greater than 1</span><br><span class="line">## 95 percent confidence interval:</span><br><span class="line">##  0.3135693Inf</span><br><span class="line">## sample estimates:</span><br><span class="line">## odds ratio</span><br><span class="line">##   6.408309</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Fisher-精确检验的争议">Fisher 精确检验的争议</h4>
<p>很多人争论Fisher 精确检验结果保守。它的真实的拒绝概率低于名义上的显著水平。The apparent contradiction stems from the combination of a discrete statistic with fixed significance levels.（最明显的矛盾在于它计算出的统计量是分散的，但是显著水平是固定的，如0.05）（如上例，可能出现的P值只有5个（0，1，2，3，4杯））。To avoid the problem, many authors discourage the use of fixed significance levels when dealing with discrete problems.</p>
<h4 id="Chi-square-Test">Chi-square Test</h4>
<p>假设我们有250个个体，其中一部分患有疾病。我们观测到aa基因型的个体中有20%患病；其他基因型的个体中患病比例为10%。如果我们再挑250个个体这种现象会再次发生吗？（这个提问方式等同于问这个位点是否与疾病相关）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">disease=factor(<span class="built_in">c</span>(<span class="built_in">rep</span>(<span class="number">0</span>,<span class="number">180</span>),<span class="built_in">rep</span>(<span class="number">1</span>,<span class="number">20</span>),<span class="built_in">rep</span>(<span class="number">0</span>,<span class="number">40</span>),<span class="built_in">rep</span>(<span class="number">1</span>,<span class="number">10</span>)),labels=<span class="built_in">c</span>(<span class="string">&quot;control&quot;</span>,<span class="string">&quot;cases&quot;</span>))</span><br><span class="line">genotype=factor(<span class="built_in">c</span>(<span class="built_in">rep</span>(<span class="string">&quot;AA/Aa&quot;</span>,<span class="number">200</span>),<span class="built_in">rep</span>(<span class="string">&quot;aa&quot;</span>,<span class="number">50</span>)),levels=<span class="built_in">c</span>(<span class="string">&quot;AA/Aa&quot;</span>,<span class="string">&quot;aa&quot;</span>))</span><br><span class="line">dat&lt;-data.frame(disease, genotype)</span><br><span class="line">dat&lt;-dat[sample(nrow(dat)),]<span class="comment">#shuffle them up</span></span><br><span class="line">head(dat)</span><br><span class="line"></span><br><span class="line"><span class="comment">###统计频数</span></span><br><span class="line">table(genotype)</span><br><span class="line">table(disease)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 双因素统计频数，建立一个2*2表</span></span><br><span class="line">tab &lt;- table(genotype,disease)</span><br><span class="line">tab</span><br><span class="line"><span class="comment">##disease</span></span><br><span class="line"><span class="comment">## genotype control cases</span></span><br><span class="line"><span class="comment">##    AA/Aa     180    20</span></span><br><span class="line"><span class="comment">##    aa		 40    10</span></span><br></pre></td></tr></table></figure>
<p>这里最典型的统计量就是the odds ratio(OR)。). We compute the oddsof having the disease if you are an “aa”: 10/40, the odds of having the disease if you are an “AA/Aa”:20/180, and take the ratio:(10/40)/(20/180)</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">(tab[<span class="number">2</span>,<span class="number">2</span>]/tab[<span class="number">2</span>,<span class="number">1</span>])/(tab[<span class="number">1</span>,<span class="number">2</span>]/tab[<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line"><span class="comment">## [1] 2.25</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了计算P值，我们不直接使用OR。我们假设基因型和疾病没有关系，然后计算出每个cell的期望值。在零假设下，两种基因型的200个体和50个体，患病的概率是相同的。</p>
<p>首先，我们得到群体（200+50=250）的患病概率为</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">p=mean(disease==<span class="string">&quot;cases&quot;</span>)</span><br><span class="line">p</span><br><span class="line"><span class="comment">## [1] 0.12</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此，各cell 的期望值为</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">expected&lt;-rbind(<span class="built_in">c</span>(<span class="number">1</span>-p,p)*<span class="built_in">sum</span>(genotype==<span class="string">&quot;AA/Aa&quot;</span>),<span class="built_in">c</span>(<span class="number">1</span>-p,p)*<span class="built_in">sum</span>(genotype==<span class="string">&quot;aa&quot;</span>))</span><br><span class="line"><span class="built_in">dimnames</span>(expected)&lt;-<span class="built_in">dimnames</span>(tab)</span><br><span class="line">expected</span><br><span class="line"><span class="comment">##disease</span></span><br><span class="line"><span class="comment">## genotype control cases</span></span><br><span class="line"><span class="comment">##    AA/Aa     176    24</span></span><br><span class="line"><span class="comment">##    aa		 44     6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##这里没讲清楚，直接就算出来了</span></span><br><span class="line">chisq.test(tab)$p.value</span><br><span class="line"><span class="comment">## [1] 0.08857435</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Large-Samples-Small-p-values">Large Samples, Small p-values</h4>
<p>如上所述，仅报道P值是不正确的。很多做GWAS的人过于强调P值。他们样本很大，得到的P值很小。但是如果仔细看他们的结果，我们就能看到他们的odds ratios并不高：仅仅比1高一点。在这种情况下，基因型是AA/Aa 或 aa 可能不会改变动物患病的几率，但是这些位点确实是统计意义上显著的。<br>
<strong>odds ratio 和 p-value 并没有一对一的关系</strong>（这一点很重要，这个在effect size 中也专门提到了，效应大小与是否显著没有因果关系。P值只能判断这个效应是不是出于偶然（随机误差），并不能说明效应大小）</p>
<h4 id="Confidence-Intervals-For-The-Odd-Ratio">Confidence Intervals For The Odd Ratio</h4>
<p>计算OR 的置信区间不能直接做到。不像其他统计量，它们都能推导出近似的分布。但是OR仅仅是一个比例。因此，没有简单的方法可以使用，例如CLT。</p>
<p>One approach is to use the theory ofgeneralized linear models which provides estimates of thelog odds ratio, rather than the OR itself, that can be shown to be asymptotically normal.</p>
<p>后面的没看</p>
<h2 id="Exploratory-Data-Analysis">Exploratory Data Analysis</h2>
<p>这个探索性数据分析，没太搞懂</p>
<h3 id="Quantile-Quantile-Plots">Quantile Quantile Plots</h3>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(UsingR)<span class="comment">##available from CRAN</span></span><br><span class="line">library(rafalib)</span><br><span class="line">x&lt;-father.son$fheight</span><br><span class="line"></span><br><span class="line">ps&lt;-( seq(<span class="number">0</span>,<span class="number">99</span>)+<span class="number">0.5</span>)/<span class="number">100</span> <span class="comment">#0.005 0.015 ……</span></span><br><span class="line">qs&lt;-quantile(x, ps) <span class="comment">#获得x中的各分位数</span></span><br><span class="line">normalqs&lt;-qnorm(ps, mean(x), popsd(x)) <span class="comment">#形成以x均值，总体标准差的正态分布的分位数</span></span><br><span class="line">plot(normalqs,qs,xlab=<span class="string">&quot;Normal percentiles&quot;</span>,ylab=<span class="string">&quot;Height percentiles&quot;</span>) </span><br><span class="line"><span class="comment"># 两个分位数向量的散点图即为QQ图</span></span><br><span class="line">abline(<span class="number">0</span>,<span class="number">1</span>)<span class="comment">##identity line</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>简化命令,比上面的手动画图采了更多的点，因此更加准确。<br>
其中由于x轴为标准正态分布，因此添加的qqline的截距为mean(x) , 斜率为popsd(x)</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qqnorm(x)</span><br><span class="line">qqline(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当然，我们也可以看看非正态分布的QQ图，比如t分布，样本数越少，尾巴越肥。体现在QQ图上就是左侧的极端值低于identity line，右侧的极端值高于identity line。</p>
<h3 id="Boxplots">Boxplots</h3>
<p>数据也不是都服从正态分布。比如工资，只告诉均值和标准差根本不足以表现真实情况（not neccessarily informative），因为我们没办法通过这两个参数获取工资的分布情况。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">op &lt;- par(mfrow=<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">hist(exec.pay)<span class="comment">##in UsingR package</span></span><br><span class="line">qqnorm(exec.pay)</span><br><span class="line">qqline(exec.pay)</span><br><span class="line"></span><br><span class="line"><span class="comment">#boxplot</span></span><br><span class="line">boxplot(exec.pay, ylab=<span class="string">&quot;10,000s of dollars&quot;</span>, ylim=<span class="built_in">c</span>(<span class="number">0</span>,<span class="number">400</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Scatterplots-And-Correlation">Scatterplots And Correlation</h3>
<p>上面都是单一变量。我们也经常用到双变量或者更多的变量，比如父亲和儿子的身高。可以先画一个散点图。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(UsingR)</span><br><span class="line">data(<span class="string">&quot;father.son&quot;</span>)</span><br><span class="line">x=father.son$fheight</span><br><span class="line">y=father.son$sheight</span><br><span class="line">plot(x,y,xlab=<span class="string">&quot;Father&#x27;s height in inches&quot;</span>,ylab=<span class="string">&quot;Son&#x27;s height in inches&quot;</span>,main=paste(<span class="string">&quot;correlation =&quot;</span>,<span class="built_in">signif</span>(cor(x,y),<span class="number">2</span>)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从图中看出一个明显的趋势：父亲的身高越高，儿子的身高也越高。一个定量的统计量就是相关系数。</p>
<h4 id="Stratification">Stratification</h4>
<p>如果我们要预测身高为72 inches 的父亲的儿子的身高，我们可以看所有身高为72 inches 的父亲的儿子的情况。因此需要对数据按父亲身高进行分层。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">groups&lt;-split(y,<span class="built_in">round</span>(x))</span><br><span class="line">boxplot(groups)</span><br><span class="line">print(mean(y[ <span class="built_in">round</span>(x)==<span class="number">72</span>]))</span><br><span class="line"><span class="comment">## [1] 70.67719</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Bi-variate-Normal-Distribution">Bi-variate Normal Distribution</h3>
<p>对于两个均服从正态分布的变量的联合分布，我们一般可以设定当X = x时，Y的条件分布。以身高数据为例，我们给出了以下4个层次。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">groups&lt;-split(y,<span class="built_in">round</span>(x))</span><br><span class="line">op &lt;- par(mfrow=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="built_in">c</span>(<span class="number">5</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">14</span>))&#123;</span><br><span class="line">  qqnorm(groups[[i]],main=paste0(<span class="string">&quot;X=&quot;</span>,<span class="built_in">names</span>(groups)[i],<span class="string">&quot;strata&quot;</span>),</span><br><span class="line">         ylim=<span class="built_in">range</span>(y),xlim=<span class="built_in">c</span>(-<span class="number">2.5</span>,<span class="number">2.5</span>))</span><br><span class="line"><span class="comment"># groups 是一个list，用groups[[i]] 获得的是向量</span></span><br><span class="line"><span class="comment"># range() 返回一个包含最小值和最大值的向量</span></span><br><span class="line"><span class="comment"># range(1:10) ## [1]  1 10</span></span><br><span class="line"></span><br><span class="line">  qqline(groups[[i]])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>后面的公式推导没太明白。后面对x,y进行了标准化，然后按x分组求y均值，发现y均值 与 x 呈线性关系，截距为0，斜率为标准化的y与x的相关系数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x=( x-mean(x) )/sd(x)</span><br><span class="line">y=( y-mean(y) )/sd(y)</span><br><span class="line">means=tapply(y, <span class="built_in">round</span>(x*<span class="number">4</span>)/<span class="number">4</span>, mean) <span class="comment">#按round(x*4)/4 给y 分组求均值</span></span><br><span class="line">fatherheights=<span class="built_in">as.numeric</span>(<span class="built_in">names</span>(means))</span><br><span class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">plot(fatherheights, means, ylab=<span class="string">&quot;average of strata of son heights&quot;</span>, ylim=<span class="built_in">range</span>(fatherheights))</span><br><span class="line">abline(<span class="number">0</span>, cor(x,y))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Plots-To-Avoid">Plots To Avoid</h3>
<p>画图的目的是准确而清楚地展示数据。根据 Karl 的说法，不好的画图的标准如下：</p>
<ol>
<li>Display as little information as possible.</li>
<li>Obscure what you do show (with chart junk).</li>
<li>Use pseudo-3D and color gratuitously（免费地）.</li>
<li>Make a pie chart (preferably in color and 3D).</li>
<li>Use a poorly chosen scale.</li>
<li>Ignore significant figures.</li>
</ol>
<h3 id="Pie-charts">Pie charts</h3>
<blockquote>
<p>“Pie charts are a very bad way of displaying information. The eye is good at judginglinear measures and bad at judging relative areas. A bar chart or dot chart is a preferableway of displaying this type of data.”</p>
</blockquote>
<p>饼图是一种很差劲的展示数据的方式。人眼很容易辨别线性方式，但是劣于判断相对区域。一个条形图或散点图 都是更合适的方式。</p>
<p>举例来说，你可以看着饼图，去估计某一部分对应的百分比。你会发现这很困难，除非这个比例很接近25%，50% 或 75%。</p>
<p>这里我们可以用条形图用代替，这里我们每隔10添加了一条水平线</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">pie(browsers,main=<span class="string">&quot;Browser Usage (August 2013)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#条形图</span></span><br><span class="line">barplot(browsers, main=<span class="string">&quot;Browser Usage (August 2013)&quot;</span>, ylim=<span class="built_in">c</span>(<span class="number">0</span>,<span class="number">55</span>))</span><br><span class="line">abline(h=<span class="number">1</span>:<span class="number">5</span>*<span class="number">10</span>)</span><br><span class="line">barplot(browsers, add=<span class="literal">TRUE</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过条形图和y轴的水平线，我们可以很清楚的看到每个值的比例。</p>
<p>尽量不要使用3D图像，因为3D图像添加了看图的障碍，使得更难通过肉眼辨别各项比例。</p>
<h4 id="Barplots-as-data-summaries">Barplots as data summaries</h4>
<p>当条形图用于展示百分比时，很有用。但是，条形图也会被错误地用于<strong>只有两组</strong>的比较。特别当条形图的高度表示均值，上面的小触角表示标准误（standard errors）。</p>
<blockquote>
<p>Much more informative is to summarize with a boxplot. If the number of points is small enough,we might as well add them to the plot. When the number of points is too large for us to see them,just showing a boxplot is preferable. We can even setrange=0inboxplotto avoid drawing manyoutliers when the data is in the range of millions.</p>
</blockquote>
<p>这个时候更适合用箱线图来表示。箱线图展示了更多的信息，中心、分布、离群点。而条形图只展示了均值和标准误，而标准误很大程度上和样本大小有关，和分布无关。</p>
<blockquote>
<p>Notice how much more we see here: the center, spread, range and the points themselves. In thebarplot, we only see the mean and the SE, and the SE has more to do with sample size, than withthe spread of the data.</p>
</blockquote>
<p>问题还不止如此。当数据中的离群点很大（分组数据的尾巴很大）。如下条形图，看似两组区别很大。</p>
<p><img src="barplot1.png" alt="barplot1"></p>
<p>但仔细看数据，这种区别原来主要是因为有两个很大的离群点。将数据进行log以后，更加明朗。</p>
<p>如下箱线图所示，左边为原数据，可以看出二者可能区别不大，有两个非常大的离群点。log后基本展示了基本情况。（个人感觉，那两个离群点实在太大，也可以直接剔除）</p>
<p><img src="boxplot1.png" alt="barplot1"></p>
<h4 id="Show-the-scatter-plot">Show the scatter plot</h4>
<p>很多统计分析都是证明两个变量之间存在关系。相关系数和相应的图可以展示这一点。然而，只展现回归线是不够的，因为这掩饰了散点。</p>
<h4 id="High-correlation-does-not-imply-replication">High correlation does not imply replication</h4>
<p>相关系数很高，不代表重复性很好，这一部分没看懂。之后补上</p>
<h4 id="Barplots-for-paired-data">Barplots for paired data</h4>
<p>当样本数较少且为配对实验时，通常我们会用两种颜色的条形图表示比如实验前和实验后。</p>
<p><img src="pairdata1.png" alt="barplot1"></p>
<p>但是我们有更好的办法。比如散点图，我们可以看到点都是高于identity line（这里应该是y=x）。另一种方法是直接画差值的散点图。</p>
<p><img src="pairdata2.png" alt="barplot1"></p>
<p><img src="pairdata3.png" alt="barplot1"></p>
<h4 id="Gratuitous-3D-（没有必要的3D）">Gratuitous 3D （没有必要的3D）</h4>
<p>以下是一个3D图，你会发现并不清楚。很难去确定其中某一个点对应的数值。</p>
<p>其实这只要不同的颜色来区分三条线就可以了。</p>
<p><img src="3D.png" alt="barplot1"></p>
<p><img src="3D2.png" alt="barplot1"></p>
<h4 id="Too-many-significant-digits">Too many significant digits</h4>
<p>默认情况下，我们会得到很多重要的数字，但我们不是都要放上去。从R中直接复制粘贴是很愚蠢的，这导致你最后显示的不是一张图，而更像是一张表。</p>
<h4 id="Displaying-data-well">Displaying data well</h4>
<p>展示数据的一般准则：</p>
<ul>
<li>Be accurate and clear.</li>
<li>Let the data speak.</li>
<li>Show as much information as possible, taking care not to obscure the message.</li>
<li>Science not sales: avoid unnecessary frills (esp. gratuitous 3D).<br>
(科学不是销售，避免不必要的虚架子，比如3D)</li>
<li>In tables, every digit should be meaningful. Don’t drop ending 0’s.<br>
（表格中，每一个小数位点都有意义）</li>
</ul>
<h3 id="Misunderstanding-Correlation-Advanced">Misunderstanding Correlation (Advanced)</h3>
<p>现在相关系数主要用于体现reproducibility。但是实际上，相关系数不足以体现reproducibility。</p>
<p>最坏的错误是，计算相关系数的数据不是近似服从<strong>二元正态分布</strong>。上面提到，均值，标准差，相关系数都是基于二元正态分布。但是，有很多数据不符合，如基因表达量数据，通常有很肥的右侧尾巴。</p>
<p>计算reproducibility 最直接的方式就是计算两个变量的距离。</p>
<p>The standard way to quantify reproducibility between two sets of replicated measurements, sayx1; : : : ; xnandy1; : : : ; yn, is simply to compute the distance between them。</p>
<p><img src="reproducibility1.png" alt="barplot1"></p>
<p>后面没看，也看不懂。</p>
<p>我连这里的reproducibility是什么意思都不知道。</p>
<h3 id="Robust-Summaries">Robust Summaries</h3>
<p>在分析数据的过程中，我们通常假设数据符合正态分布。但是我们收集数据的过程中，总是不可避免地加入了一些错误的数据点（离群点）。类似这种偏离很大的离群点，会导致分析结果出现很大的偏差。</p>
<p>如下例，我们在0到1之间的数据中，插入一个值为100的离群点。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">set.seed(<span class="number">1</span>)</span><br><span class="line">x=<span class="built_in">c</span>(rnorm(<span class="number">100</span>,<span class="number">0</span>,<span class="number">1</span>))<span class="comment">##real distribution</span></span><br><span class="line">x[<span class="number">23</span>]&lt;-<span class="number">100</span><span class="comment">##mistake made in 23th measurement</span></span><br><span class="line">boxplot(x)</span><br></pre></td></tr></table></figure>
<p>我们看一下均值和标准差，发现偏离很大</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">cat(<span class="string">&quot;The average is&quot;</span>,mean(x),<span class="string">&quot;and the SD is&quot;</span>,sd(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">## The average is 1.108142 and the SD is 10.02938</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="The-median">The median</h4>
<p>这个中位数，对于离群点，是robust的。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">median(x)</span><br><span class="line">[<span class="number">1</span>] <span class="number">0.1684483</span></span><br></pre></td></tr></table></figure>
<h4 id="The-median-absolute-deviation">The median absolute deviation</h4>
<p>![](The median absolute deviation.png)</p>
<h4 id="Spearman-correlation">Spearman correlation</h4>
<p>和前面类似，也是robust 的相关系数。几乎不受离群点的影响。</p>
<h4 id="Symmetry-of-log-ratios">Symmetry of log ratios</h4>
<p>当涉及比值数据时，数据不是对称的，1/32 比 32/1 更接近1。这时候采用log()函数处理一下，就会对称（log(x/y) = log(x) - log(y) ）</p>
<h3 id="Wilcoxon-Rank-Sum-Test">Wilcoxon Rank Sum Test</h3>
<p>从上面知道，样本均值和标准差易受离群点的影响。t检验需要用到这两个数，因此也容易受到影响。这种Wilcoxon Rank Sum Test 就不会受到影响……</p>
<p>后面没看</p>
<h2 id="Effect-size-–-wikipedia">Effect size – wikipedia</h2>
<p>In statistics, an effect size is a quantitative measure of the magnitude of a phenomenon.(这个effect size 不知道咋翻译,效应水平？)。举例说明，包括相关系数，回归系数，均值差。对于大部分的effect size，绝对值越大，往往说明效应越强。</p>
<h3 id="Relationship-to-test-statistics">Relationship to test statistics</h3>
<p>基于采样的effect sizes 和 假设检验的统计检验量不一样。effect sizes 是检验 strength(magnitude ) ；然而假设检验是给出一个显著性水平（P值），反应这个magnitude 或 relationship 是不是出于偶然（随机误差）。effect size 并不直接决定显著性水平，反之亦然。<strong>只要样本量足够大，哪怕effect size 很小，也能得到统计显著结果</strong>。因此，只看p值可能有一定的误导。</p>
<h3 id="Standardized-and-unstandardized-effect-sizes">Standardized and unstandardized effect sizes</h3>
<p>effect sizes 标准化的原因：<br>
1. 变量的单位本身没有意义<br>
2. 结果来自多重结果的合并<br>
3. 不同的结果用了不同的单位<br>
4. it is desired to convey the size of an effect relative to the variability in the population</p>
<h3 id="Types">Types</h3>
<h4 id="Correlation-family">Correlation family</h4>
<ol>
<li>
<p>Pearson r</p>
</li>
<li>
<p>Coefficient of determination (r^2^ or R^2^)<br>
Pearson r 的平方</p>
<blockquote>
<p>In the case of paired data, this is a measure of the proportion of variance shared by the two variables, and varies from 0 to 1. (在配对数据中，一个变量中的方差能被另一个变量解释的比例)</p>
</blockquote>
</li>
</ol>
<h4 id="Difference-family">Difference family</h4>
<p>Effect sizes based on differences between means</p>
<p><img src="Difference_family1.png" alt="Difference_family1"></p>
<p>其中μ1 μ2 是两个群体的均值；σ是基于一个群体或两个群体的标准差。</p>
<p>这种形式很像t统计量，但是t统计量包含了一个因素，根号N。这意味着，对于给定的effect size，显著水平会随着样本量的增加而增加。 Unlike the t-test statistic, the effect size aims to estimate a population parameter and is not affected by the sample size.</p>
<h5 id="Cohen’s-d">Cohen’s d</h5>
<p>![Difference_family1](Cohen’s d.png)</p>
<h2 id="PEVD-kennedy-1993">PEVD -kennedy 1993</h2>
<blockquote>
<p>Unbiased comparisons between animals  can, how- ever, be made if  animals are sampled from a common genetic population, in which case the consequence of “disconnectedness” is reflected   only in the PEV of differences between EBV of animals. The PEV of the individual animal (diagonal element) is unchanged given the same number of animals. The PEV of difference in EBV, however, depends on whether comparisons are within or between management units.</p>
</blockquote>
<p>这是好像最早提及PEVD的文献。但是具体计算的部分，没有提及。只是说现在都最多只提供系数矩阵逆矩阵对角线元素（Misztal 和 Wiggans1988,Meyer,1989），但没有提供非对角线元素的值。</p>
<p>因此PEVD不能计算，然后就给出了三种替代方案。巴拉巴拉。后面对我没作用。</p>
<h1>Changes in connectedness over time in alternative sheep sire referencing schemes - Kuehn 2008</h1>
<p>这是在Yu的文章中提到了一嘴，说PEVD 的 scale ,也就是去除单位，是按照这篇文章的方法。</p>
<p>这篇文章用了两个指标，第一个是 onnectedness correlation (Lewis etal., 1999, 2005)</p>
<p><img src="r.png" alt="r"></p>
<blockquote>
<p>The connectedness corre-lation was calculated and averaged each year for allpairs of ram lambs born in different flocks across all15 flocks (lamb rij)</p>
</blockquote>
<p>还是要两个群体两两配对，再求均值。</p>
<p>有两种算法。一种是这种，还有一种大概意思是直接用场效应,和mathur一致。</p>
<p>scaled PEVD 就是再除以加性方差。</p>
<p>还是两种计算PEVD的算法，一种是用个体，但是要两两配对求均值；一种就是直接用场效应。</p>
<h1>H阵</h1>
<p>mistal 2010 和 2012 的文献中，A下标的1 和 2 是相反的。</p>
<h1>暑假统计遗传学培训班</h1>
<h2 id="矩阵运算（matrix-algebra）">矩阵运算（matrix algebra）</h2>
<ul>
<li>对于对称阵，A’ = A 。（对称阵的转置矩阵为其本身）</li>
<li>（AB)’ = B’A’</li>
<li>方阵的迹（trace）<br>
tr(A) = 对角线元素之和<br>
trA = sum(diag(A))</li>
<li>矩阵的秩（Rank）：矩阵中线性无关的行数或列数<br>
<strong>不满秩的矩阵称为奇异阵（singular）</strong><br>
r &lt;- qr(D)$rank</li>
<li>方阵的<strong>行列式</strong>：如果|A|=0，A 不满秩，即 A 是奇异的<br>
detA &lt;- det(A)</li>
</ul>
<h3 id="求逆">求逆</h3>
<p>对于一个<strong>满秩</strong>的方阵A，必均在其逆矩阵，且唯一。</p>
<blockquote>
<p>（AB)^-1^ = B^-1^ A^-1^<br>
A- = solve(A)</p>
</blockquote>
<p>对角矩阵的逆矩阵</p>
<p><img src="diag_inv.png" alt="diag_inv"></p>
<p><strong>广义逆</strong><br>
AA^-^A = A<br>
如果满秩，那么广义逆和逆相等，解是唯一的。<br>
一个奇异阵可以有无穷多个广义逆矩阵。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">library(MASS)</span><br><span class="line">ginv(D)</span><br></pre></td></tr></table></figure>
<h3 id="正定矩阵（Positive-definite）">正定矩阵（Positive definite）</h3>
<p>没看懂</p>
<p><img src="positive_definite.png" alt="positive_definite"></p>
<h3 id="Cholesky-分解">Cholesky 分解</h3>
<p>任何<strong>对称正定矩阵</strong>都可分解为</p>
<p>** A = TT’ **<br>
其中，T是一个下三角矩阵<br>
T &lt;- chol(A) #注：该函数返回的是一个上三角矩阵</p>
<h3 id="正交矩阵（Orthogonal）">正交矩阵（Orthogonal）</h3>
<p>正交矩阵的转置矩阵和逆矩阵相等</p>
<h3 id="特征值和特征向量">特征值和特征向量</h3>
<p>对于方阵 A, 如果存在一个常量 d 和一个非零向量 u, 它们满足</p>
<p>𝐀𝐮=𝑑𝐮</p>
<p>称 d 是 A 的特征值（eigenvalue）,  u 是与 d 对应的特征向量（eigenvector）</p>
<p>note: 一个矩阵可以有多个特征值和多个对应的特征向量</p>
<p>eigen(A)</p>
<p>特征值和特征向量性质：</p>
<ul>
<li>一个矩阵的所有特征值之和等于其迹</li>
<li>一个矩阵的所有特征值之积等于其行列式</li>
<li>一个矩阵的非零特征值的个数等于其秩</li>
<li>如果一个矩阵的所有特征值均大于0，则该矩阵是正定的</li>
<li>如果一个矩阵的所有特征值均大于或等于0，半正定</li>
<li>如果Q为对称矩阵，则它可分解为<br>
** Q = UDU’ **<br>
D 为对角矩阵，其对角线元素为Q的特征值<br>
U 为正交矩阵，其各列为Q的特征向量</li>
</ul>
<h3 id="矩阵的微分（Differentiation）">矩阵的微分（Differentiation）</h3>
<p><img src="Differentiation.png" alt="Differentiation"></p>
<p><img src="Differentiation2.png" alt="Differentiation2"></p>
<h3 id="随机向量">随机向量</h3>
<p>由随机变量组成的向量</p>
<p><img src="random_vector.png" alt="random_vector"></p>
<p>下一张图不懂</p>
<p><img src="random_vector2.png" alt="random_vector"></p>
<h3 id="PEV-PEVD-是否乘以残差方差">PEV / PEVD 是否乘以残差方差</h3>
<p>如果MME左右两边没有约掉R^-1^，那么就不用乘残差方差；否则就要乘。（我计算都是约掉的，所以要乘）</p>
<p><img src="pev.png" alt="random_vector"></p>
<h3 id="A-1-的计算">A^-1^ 的计算</h3>
<ol>
<li>由于A是对称正定矩阵，因此可以使用 Cholesky 分解，将其分解一个下三角矩阵乘以其转置矩阵。</li>
<li>下三角矩阵矩阵L 可以分解一个新的下三角矩阵（T，对角线元素为1） 乘以 一个对角阵 （D，为L阵的对角线元素）</li>
<li>因此，𝐀=𝐓𝐃𝐃𝐓‘ 。而 <strong>DD</strong> 相同的对角阵相乘仍为对角阵，其元素为原来的平方。</li>
</ol>
<p><img src="A-.png" alt="random_vector"></p>
<p>注：任何一个矩阵（T）右乘以一个对角阵（D），等于原矩阵的第一列乘以d1，第二列乘以d2……以此类推。</p>
<h4 id="YD-yield-deviation">YD (yield deviation)</h4>
<p>应该是指校正表型，指校正了所有固定环境效应的动物个体的（平均）表型值</p>
<h1>矩阵运算实际收获</h1>
<p>对LHS 和 LHS 的上三角矩阵 求逆，结果不一致。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>DMU软件使用笔记</title>
    <url>/posts/59ca09be/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>DMU 是动植物育种领域常用的遗传评估软件，我之前也经常用。这里仅仅是我自己的一个备忘录，将一些疑难的点记录下来。</p>
<span id="more"></span>
<h1>参数卡设置</h1>
<h2 id="NOCOV">NOCOV</h2>
<p>设置模型中最后一个部分，应该是设置没有残差协方差的组分。</p>
<p>比如</p>
<p>1</p>
<p>1 2</p>
<p>就是说有一个组分没有残差协方差，第二行具体指明是哪两个性状，这是是说第一个性状和第二个性状之间没有残差协方差。</p>
<p>育种课的ppt是这么写的：</p>
<blockquote>
<p>多性状分析时，不同的性状可能在不同的个体测得。在这种情况下，性状间剩余值（即残差）相互独立，剩余值协方差通常要约束为0。</p>
</blockquote>
<h1>residual 结果文件</h1>
<p>官方文档。以单性状为例，第二列应该是表型值吧，不是所谓的predicted value 然后之后的三列才是文档说的三个残差。</p>
<p>这个文件的顺序和个数和表型文件一致。</p>
<p><img src="6.png" alt=""></p>
<h1>报错</h1>
<ul>
<li>估计是数据量太大，超出设置的内存总量</li>
</ul>
<p><img src="dmu1.png" alt=""></p>
<p>数据情况：芯片2万7 表型12万6 使用all 选项</p>
<ul>
<li>同时使用80k和50k的参考群，光跑dmu就跑了几天。结果没跑出来，也没报错。看了估计方差组分迭代了49次，估计是迭代次数设置了最多50次。</li>
</ul>
<p><img src="dmu2.png" alt=""></p>
<p><img src="dmu3.png" alt=""></p>
<ul>
<li>报日龄的单性状时报错，<strong>没解决</strong>。截至目前还不知道怎么处理。</li>
</ul>
<p><img src="dmu4.png" alt=""></p>
<ul>
<li>
<p>ssgblup 系谱报错</p>
<p>最后一列没有用行号</p>
</li>
</ul>
<p><img src="5.png" alt=""></p>
<ul>
<li>
<p>性状模型报错</p>
<p>他的意思应该是性状太多，信息不够，跑不出来。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AI or combined AI&#x2F;EM information matrix is not positive definite</span><br><span class="line">    Smallest eigenvalue:                       -7.015359837501943E-017</span><br><span class="line">    Rank:                                               44</span><br><span class="line">    No of co-variance components to estimate:           45</span><br><span class="line"> </span><br><span class="line">    This could be due to a variance component close to 0.0 or</span><br><span class="line">    that there is not enough information in the data for the model</span><br><span class="line"> </span><br><span class="line">    Program terminates</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>DMU</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>遗传育种</tag>
        <tag>DMU</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy学习笔记</title>
    <url>/posts/40de7965/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>numpy 是python的一个包，是处理数组的工具。</p>
<span id="more"></span>
<h1>数组基础</h1>
<p>在numpy中采用array属性创建数组，里面可以传递任何序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">b = np.array((<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">c = np.arange(<span class="number">5</span>)</span><br><span class="line">d = np.linspace(<span class="number">0</span>, <span class="number">2</span>*np.pi, <span class="number">5</span>) <span class="comment"># [0.         1.57079633 3.14159265 4.71238898 6.28318531]</span></span><br><span class="line"><span class="comment"># linspace 表示从开始值到结束值，均匀地创造n个值（包括两端）。</span></span><br><span class="line"><span class="comment"># np.pi 为Π值。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a) </span><br><span class="line"><span class="built_in">print</span>(b) </span><br><span class="line"><span class="built_in">print</span>(c) </span><br><span class="line"><span class="built_in">print</span>(d) </span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">3</span>]) </span><br></pre></td></tr></table></figure>
<ul>
<li>shape 函数查看数组结构（2，3）表示2行3列。</li>
</ul>
<p>其他创建数组的函数：</p>
<ul>
<li>a = np.zeros((2,2))  # 2×2 的 全为0 的矩阵</li>
<li>a = np.ones((1,2))  # 全为1 的矩阵</li>
<li>a = np.full((2,2),7)  # 全为7 的矩阵</li>
<li>a = np.eye(2)    # 2×2 的单位阵</li>
<li>e = np.random.random((2,2))  # 0到1之间的随机元素</li>
</ul>
<h2 id="创建矩阵">创建矩阵</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">              [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span> ,<span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">              [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>,<span class="number">4</span>]) <span class="comment">#索引都是从0开始 </span></span><br></pre></td></tr></table></figure>
<h2 id="数组索引">数组索引</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, <span class="number">1</span>:<span class="number">4</span>]) </span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>:<span class="number">4</span>, <span class="number">0</span>]) </span><br><span class="line"><span class="built_in">print</span>(a[::<span class="number">2</span>,::<span class="number">2</span>]) <span class="comment">#行和列每隔一个qu                  </span></span><br><span class="line"><span class="built_in">print</span>(a[:, <span class="number">1</span>]) </span><br></pre></td></tr></table></figure>
<h2 id="数组属性">数组属性</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">              [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span> ,<span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">              [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a)) <span class="comment"># &gt;&gt;&gt;&lt;class &#x27;numpy.ndarray&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(a.dtype) <span class="comment"># &gt;&gt;&gt;int64</span></span><br><span class="line"><span class="built_in">print</span>(a.size) <span class="comment"># &gt;&gt;&gt;25 总共元素个数</span></span><br><span class="line"><span class="built_in">print</span>(a.shape) <span class="comment"># &gt;&gt;&gt;(5, 5)</span></span><br><span class="line"><span class="built_in">print</span>(a.itemsize) <span class="comment"># &gt;&gt;&gt;8 每个元素的字节数 int64就是8字节</span></span><br><span class="line"><span class="built_in">print</span>(a.ndim) <span class="comment"># &gt;&gt;&gt;2 维度</span></span><br><span class="line"><span class="built_in">print</span>(a.nbytes) <span class="comment"># &gt;&gt;&gt;200 总字节数 25*8=200</span></span><br></pre></td></tr></table></figure>
<h2 id="切片">切片</h2>
<p>np.array 里，如果是矩阵，那么每一个子元素是<strong>一行</strong>。也就是，默认按行排布。切边时也一样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line">b = a[:<span class="number">2</span>,<span class="number">1</span>:<span class="number">3</span>]  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">b[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">77</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>这里，还可以将整数索引和切片索引混合使用。但是这样做，会造成<strong>降维打击</strong>（由矩阵变为向量）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line">row_r1 = a[<span class="number">1</span>,:]</span><br><span class="line">row_r2 = a[<span class="number">1</span>:<span class="number">2</span>,:] <span class="comment">#这样写就不会降维，还是矩阵</span></span><br><span class="line"><span class="built_in">print</span>(row_r1,row_r1.shape) <span class="comment"># （4，）</span></span><br><span class="line"><span class="built_in">print</span>(row_r2,row_r2.shape) <span class="comment"># （1，4）</span></span><br></pre></td></tr></table></figure>
<h3 id="整数数组索引">整数数组索引</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])  <span class="comment">#上下结果相同，就是不同写法。a[[0,1,2],[0,1,0]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.array([a[<span class="number">0</span>, <span class="number">0</span>], a[<span class="number">1</span>, <span class="number">1</span>], a[<span class="number">2</span>, <span class="number">0</span>]]))  </span><br></pre></td></tr></table></figure>
<h3 id="花式索引">花式索引</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>)</span><br><span class="line">indices = [<span class="number">1</span>, <span class="number">5</span>, -<span class="number">1</span>]</span><br><span class="line">b = a[indices]</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &gt;&gt;&gt;[ 0 10 20 30 40 50 60 70 80 90]</span></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># &gt;&gt;&gt;[10 50 90]</span></span><br></pre></td></tr></table></figure>
<h3 id="布尔数组索引">布尔数组索引</h3>
<p>选择满足某些条件的数组元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">bool_idx = (a&gt;<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(bool_idx)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a[bool_idx])</span><br><span class="line"><span class="built_in">print</span>(a[a &gt; <span class="number">2</span>]) <span class="comment"># 结果为向量[3 4 5 6],挑出大于2的元素</span></span><br></pre></td></tr></table></figure>
<h3 id="数据类型">数据类型</h3>
<p>Numpy在创建数组时会猜测数据类型，当也有一个可选参数指定数据类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(x.dtype)</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1.0</span>,<span class="number">2.0</span>])</span><br><span class="line"><span class="built_in">print</span>(x.dtype)</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>],dtype=np.int64)</span><br><span class="line"><span class="built_in">print</span>(x.dtype)</span><br></pre></td></tr></table></figure>
<h3 id="数组中的数学">数组中的数学</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]], dtype=np.float64)</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]], dtype=np.float64)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x + y)</span><br><span class="line"><span class="built_in">print</span>(np.add(x, y))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x - y)</span><br><span class="line"><span class="built_in">print</span>(np.subtract(x, y))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x * y)    <span class="comment">#这里的乘除都不是矩阵点乘，而是元素乘法。也就是第一个元素乘第一个元素。</span></span><br><span class="line"><span class="built_in">print</span>(np.multiply(x, y))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x / y) </span><br><span class="line"><span class="built_in">print</span>(np.divide(x, y))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.sqrt(x))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a ** <span class="number">2</span>) <span class="comment"># a中的每个元素都进行开方</span></span><br></pre></td></tr></table></figure>
<p>点积 dot函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">v = np.array([<span class="number">9</span>,<span class="number">10</span>])</span><br><span class="line">w = np.array([<span class="number">11</span>, <span class="number">12</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(v.dot(w))  <span class="comment">#dot函数向量与向量为点积，为a1b1+a2b2+……</span></span><br><span class="line"><span class="built_in">print</span>(np.dot(v, w))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x.dot(v))  <span class="comment"># dot函数向量与矩阵，不太清楚</span></span><br><span class="line"><span class="built_in">print</span>(np.dot(x, v))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x.dot(y))  <span class="comment"># 矩阵与矩阵，就是正常的矩阵乘法</span></span><br><span class="line"><span class="built_in">print</span>(np.dot(x, y))</span><br></pre></td></tr></table></figure>
<h3 id="SUM函数">SUM函数</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(x))  <span class="comment">#所有元素的和</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(x, axis=<span class="number">0</span>))  <span class="comment">#axis=0 是每一列的和</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(x, axis=<span class="number">1</span>))  </span><br><span class="line"><span class="comment"># min() max()找到最小，最大的元素</span></span><br></pre></td></tr></table></figure>
<h3 id="转置矩阵，T属性">转置矩阵，T属性</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"><span class="built_in">print</span>(x)    </span><br><span class="line">            </span><br><span class="line"><span class="built_in">print</span>(x.T)  </span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(v)    </span><br><span class="line"><span class="built_in">print</span>(v.T)  <span class="comment">#向量没有转置属性</span></span><br></pre></td></tr></table></figure>
<h3 id="广播">广播</h3>
<p>如果我们要向矩阵的每一行添加一个常数向量。我们可以这样做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">y = np.empty_like(x)  <span class="comment"># 建立一个和x维度相同的空矩阵。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    y[i, :] = x[i, :] + v</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure>
<p>这会奏效；但是当矩阵x非常大时，循环会很慢。注意，向矩阵x的每一行添加向量v等同于通过垂直堆叠多个v副本来形成矩阵vv，然后执行元素的求和 x 和 vv。代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">vv = np.tile(v, (<span class="number">4</span>, <span class="number">1</span>))  </span><br><span class="line"><span class="comment"># tile函数复制数组，第一个数字好像是列，第二个是行，就是在y轴方向复制4遍。</span></span><br><span class="line"><span class="built_in">print</span>(vv)                 </span><br><span class="line">                                                                              </span><br><span class="line">y = x + vv  </span><br><span class="line"><span class="built_in">print</span>(y)  </span><br></pre></td></tr></table></figure>
<p>Numpy 广播允许我们在不实际创建 v 的多个副本的情况下执行此计算（这和R是类似的）。代码如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">y = x + v  </span><br><span class="line"><span class="built_in">print</span>(y)  </span><br></pre></td></tr></table></figure>
<p>广播的规则（从网上找的人话），需满足</p>
<ul>
<li>当前维度的值相等</li>
<li>当前维度的值有一个是1</li>
<li>最终的shape是输入数组shape各个轴上的最大值。<br>
下例中 3×1 * 1×2。3×1 会复制成 3×2，1×2 也会复制成 3×2，再进行元素相乘。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">v = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])  </span><br><span class="line">w = np.array([<span class="number">4</span>,<span class="number">5</span>])    </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.reshape(v, (<span class="number">3</span>, <span class="number">1</span>)) * w) <span class="comment">#举例</span></span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x + v)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>((x.T + w).T)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x + np.reshape(w, (<span class="number">2</span>, <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x * <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h2 id="创建Numpy-数组的不同方式">创建Numpy 数组的不同方式</h2>
<p>创建Numpy数组有三种不同的方法：</p>
<ol>
<li>使用Numpy内部功能函数</li>
<li>从列表等其它序列进行转换</li>
<li>使用特殊的库函数</li>
</ol>
<h3 id="使用Numpy-内部功能函数">使用Numpy 内部功能函数</h3>
<h4 id="创建一维数组">创建一维数组</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Numpy <span class="keyword">as</span> np</span><br><span class="line">array = np.arange(<span class="number">20</span>) <span class="comment"># 创建一个从0到19的一维数组</span></span><br><span class="line">array</span><br></pre></td></tr></table></figure>
<p>与python列表不同，Numpy数组的内容是同质的。如果将字符串分配给数据类型为int的元素，则会报错。</p>
<h4 id="创建一个二维数组">创建一个二维数组</h4>
<p>先创建一个一维数组，再使用reshape 函数使其称为二维数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array = np.arange(<span class="number">20</span>).reshape(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">array</span><br></pre></td></tr></table></figure>
<h4 id="其他函数">其他函数</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.zeros((<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line">np.ones((<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line">np.empty((<span class="number">2</span>,<span class="number">4</span>)) <span class="comment"># 随机内容</span></span><br><span class="line">np.full((<span class="number">2</span>,<span class="number">4</span>),<span class="number">3</span>) <span class="comment"># 全为3</span></span><br><span class="line">np.eye(<span class="number">3</span>,<span class="number">3</span>) <span class="comment"># 创建一个3×3的单位阵</span></span><br><span class="line">np.linspace(<span class="number">0</span>,<span class="number">10</span>,<span class="number">4</span>) <span class="comment"># array([ 0., 3.33333333, 6.66666667, 10.])</span></span><br></pre></td></tr></table></figure>
<h3 id="从python列表转换">从python列表转换</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">array = np.array(<span class="built_in">list</span>)</span><br><span class="line">array</span><br></pre></td></tr></table></figure>
<h3 id="使用特殊的库函数">使用特殊的库函数</h3>
<p>使用random函数，创建一个填充0到1之间随机数的数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.random((<span class="number">2</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<h2 id="Numpy-中的矩阵和向量">Numpy 中的矩阵和向量</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = np.array([[<span class="number">1</span>,-<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>]]) <span class="comment"># 创建矩阵</span></span><br><span class="line">v = np.array([[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>]]) </span><br><span class="line"><span class="comment"># 列向量 v = np.transpose(np.array([[1，2,3]]))</span></span><br><span class="line"><span class="comment"># 注意这里是两个方括号</span></span><br></pre></td></tr></table></figure>
<h3 id="用numpy-求解方程组">用numpy 求解方程组</h3>
<p>求解向量x。方程组如下图所示<br>
<img src="equations1.png" alt=""><br>
首先构建A和b的数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = np.array([[<span class="number">2</span>,<span class="number">1</span>,-<span class="number">2</span>],[<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>]]) </span><br><span class="line">b = np.transpose(np.array([[-<span class="number">3</span>,<span class="number">5</span>,-<span class="number">2</span>]])) </span><br></pre></td></tr></table></figure>
<p>为了解决这个系统</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.linalg.solve(A,b)</span><br></pre></td></tr></table></figure>
<h2 id="应用：多元线性回归">应用：多元线性回归</h2>
<p><img src="equations2.png" alt=""><br>
求解python代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.chdir(<span class="string">&#x27;D:\\Desktop\\markdown\\numpy学习笔记&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readData</span>():</span></span><br><span class="line">    X = []</span><br><span class="line">    y = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;Housing.csv&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        rdr = csv.reader(f)</span><br><span class="line">        <span class="comment"># Skip the header row</span></span><br><span class="line">        <span class="built_in">next</span>(rdr) </span><br><span class="line">        <span class="comment"># Read X and y</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> rdr: <span class="comment"># line的格式为[&#x27;1&#x27;,&#x27;2&#x27;……]</span></span><br><span class="line">            xline = [<span class="number">1.0</span>] <span class="comment"># 这个是总平均数的系数1</span></span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> line[:-<span class="number">1</span>]:</span><br><span class="line">                xline.append(<span class="built_in">float</span>(s))</span><br><span class="line">            X.append(xline) <span class="comment"># X是除了最后一列表型外的所有列</span></span><br><span class="line">            y.append(<span class="built_in">float</span>(line[-<span class="number">1</span>])) <span class="comment"># y 是表型</span></span><br><span class="line">    <span class="keyword">return</span> (X,y)</span><br><span class="line"></span><br><span class="line">X0,y0 = readData()</span><br><span class="line"><span class="comment"># Convert all but the last 10 rows of the raw data to numpy arrays</span></span><br><span class="line">d = <span class="built_in">len</span>(X0)-<span class="number">10</span></span><br><span class="line">X = np.array(X0[:d])</span><br><span class="line">y = np.transpose(np.array([y0[:d]]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute beta</span></span><br><span class="line">Xt = np.transpose(X)</span><br><span class="line">XtX = np.dot(Xt,X)</span><br><span class="line">Xty = np.dot(Xt,y)</span><br><span class="line">beta = np.linalg.solve(XtX,Xty)</span><br><span class="line"><span class="built_in">print</span>(beta)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make predictions for the last 10 rows in the data set</span></span><br><span class="line"><span class="keyword">for</span> data,actual <span class="keyword">in</span> <span class="built_in">zip</span>(X0[d:],y0[d:]):</span><br><span class="line">    x = np.array([data])</span><br><span class="line">    prediction = np.dot(x,beta)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;prediction = &#x27;</span>+<span class="built_in">str</span>(prediction[<span class="number">0</span>,<span class="number">0</span>])+<span class="string">&#x27; actual = &#x27;</span>+<span class="built_in">str</span>(actual))</span><br></pre></td></tr></table></figure>
<h3 id="通过where函数替换满足条件的元素">通过where函数替换满足条件的元素</h3>
<p>问题：将0-9的一维数组中的所有奇数替换成-1，而不改变原数组（即创建新数组）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">out = np.where(arr % <span class="number">2</span> == <span class="number">1</span>, -<span class="number">1</span> ,arr) <span class="comment"># 奇数，则替换为-1，否则保持原值不变。</span></span><br></pre></td></tr></table></figure>
<h3 id="通过reshape函数将一维数组转化为二维">通过reshape函数将一维数组转化为二维</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">arr.reshape(<span class="number">2</span>,-<span class="number">1</span>) <span class="comment"># 设置为-1,表示让程序自动决定列的数目</span></span><br></pre></td></tr></table></figure>
<h3 id="如何水平或垂直叠加两个数组？">如何水平或垂直叠加两个数组？</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">10</span>).reshape(<span class="number">2</span>,-<span class="number">1</span>)</span><br><span class="line">b = np.repeat(<span class="number">1</span>, <span class="number">10</span>).reshape(<span class="number">2</span>,-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Answers</span></span><br><span class="line"><span class="comment"># Method 1:</span></span><br><span class="line">np.concatenate([a, b], axis=<span class="number">1</span>) </span><br><span class="line"><span class="comment">#通过调整axis=0或1，确定叠加方式</span></span><br></pre></td></tr></table></figure>
<h3 id="如何交换数组中的两列？">如何交换数组中的两列？</h3>
<p>问题：在数组arr中交换列1和2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">arr[:, [<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>]] <span class="comment">#这样就能实现第一列和第二列的互换。</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>linear model in statistics</title>
    <url>/posts/d51e95ef/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这本书是讲线性模型，但是之前我应该只看了基础部分……</p>
<p>以后接着看再续上</p>
<span id="more"></span>
<h1>Linear Models In Statistics</h1>
<p>本书的目的之一是清晰地阐述；第二个目的是说清楚不同方法的关系。</p>
<p>本书可以作为参考书（reference book），也可以作为教科书（textbook)。</p>
<h2 id="introduce">introduce</h2>
<h3 id="简单的线性回归模型">简单的线性回归模型</h3>
<p>举例，工资与受教育年限的关系，身高和体重的关系，海拔与水沸腾的温度，药剂与效应的关系。模型如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y &#x3D; β0 + β1x + e(这个字母不好打，用e代替) （1.1）</span><br></pre></td></tr></table></figure>
<p>模型符合线性关系是一种假设，除此之外，我们还有其它的假设，比如残差的分布，观测值之间的独立性等等。</p>
<h3 id="MULTIPLE-LINEAR-REGRESSION-MODEL">MULTIPLE  LINEAR  REGRESSION  MODEL</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y &#x3D; β0 + β1x1 + β2x2 + …… + βkxk + e(这个字母不好打，用e代替) （1.2）</span><br></pre></td></tr></table></figure>
<p>The model in (1.2) is linear in the β parameters; it is not necessarily linear in the x variables. Thus models such as</p>
<p><img src="multiple_regression.png" alt="multiple_regression"></p>
<blockquote>
<p>A model provides a theoretical framework for better understanding of a phenomenon  of  interest.  Thus  a  model  is  a  mathematical  construct  that  we  believe  mayrepresent  the  mechanism  that  generated  the  observations  at  hand.  The  postulated model may be an idealized  oversimplification of the  complex real-world situation,but  in  many  such  cases,  empirical  models  provide  useful  approximations  of  therelationships  among  variables.  These  relationships  may  be  either  associative  orcausative.</p>
</blockquote>
<p>上面的话的简单解释。一个好的模型一定是比较符合变量的内部机制的。模型可能因为过度简化了复杂的真实情况而显得理想化，但是大部分情况下，凭借经验建立的模型往往能够有效地说明变量之间的关系，无论它们之间是相关关系还是因果关系。</p>
<p>回归模型可以用于：</p>
<ol>
<li>预测</li>
<li>描述数据</li>
<li>参数估计（β）</li>
<li><strong>变量选择或筛查</strong>：通过回归分析，决定每个自变量对因变量的重要性。能够大量解释y的方差的变量保留，否则剔除。</li>
<li>结果控制。回归模型假定x,y存在因果关系；因此，我们可以通过控制x的范围，来得到我们想要的理想范围的y。</li>
</ol>
<p>这5种目的有本质的区别。对于预测，我们只需要假设当我们用先前的数据得到的关系预测新的数据，仍然成立。我们通过回归模型得到y 与 x存在显著性关系，并不能证明它们之间存在因果关系。</p>
<h3 id="方差分析">方差分析</h3>
<p>方差分析一般用于比较几个群体或几种方法的区别。方差分析也可以理解为一种特别的线性模型，它的x 的值只有0和1。举个例子，某实验人员需要比较4种催化剂的作用。其模型可以设置为如下</p>
<p><img src="ANOVA1.png" alt=""></p>
<p>假设研究人员还想看三种不同温度的影响。对这12种催化剂-温度效应每一种进行n次实验。模型如下：</p>
<p><img src="ANOVA2.png" alt=""></p>
<p>方差分析可以理解为一种特殊的回归模型，但是一般还是把这两者分开比较方便。</p>
<h2 id="Matrix-Algebra">Matrix Algebra</h2>
<p>我们一般用加粗的大写字母表示矩阵；用加粗的小写字母表示列向量（即向量默认为竖着的）。</p>
<p>在矩阵和向量的章节中，一个具体的实数称为标量（scalar）。比如2.5就是一个标量，标量一般用不加粗的小写字母表示。</p>
<p>如果一个矩阵的转置矩阵等于其本身（<strong>A’ = A</strong>）, 那么这个矩阵是对阵矩阵（而且是方阵）。</p>
<p>以下这些公式不用死记，在脑子举个例子过一遍就理解了。</p>
<ul>
<li>**（A + B)’ = A’ + B’ **</li>
<li>一般，** AB 不等于 BA**</li>
<li>** A(B + C) = AB + AC **  （乘法符合分配律）</li>
<li>** (A + B) C = AC + BC **</li>
<li>** (A-B) (C-D) = (A-B) C - (A-B) D = AC - BC - AD + BD ** (进一步扩展)</li>
<li>** (AB)’ = B’A’ **</li>
</ul>
<h3 id="矩阵分段">矩阵分段</h3>
<p>有的时候将矩阵划分为几个子矩阵很方便。比如在矩阵相乘时，<strong>如 A 和 B 矩阵 的结构相同，划分子矩阵的结构也相同</strong>，那么 AB 可以转化为子矩阵的相乘（类似于元素的相乘）</p>
<p><img src="partition1.png" alt=""></p>
<p>如果把<strong>B</strong>换成一个向量<strong>b</strong>，仍然可以划分成子矩阵和子向量。其中A1的列数目等于b1的元素数目</p>
<p><img src="partition2.png" alt=""></p>
<p>更极端地，将<strong>A</strong>的每一列划分为一个子矩阵，将<strong>b</strong>的每一个元素视为一个子向量。例子如下</p>
<p><img src="partition3.png" alt=""></p>
<p>分块矩阵的转置</p>
<p><img src="partition4.png" alt=""></p>
<h3 id="秩">秩</h3>
<p>dependent 的定义如下：对于一系列的向量a1,a2,……，an，如果存在标量 c1,c2,……cn（不全为0），使得</p>
<p><img src="rank1.png" alt=""></p>
<p>那么我们就说是 dependent</p>
<p>如果不存在c1,c2,……cn，那么我们说a1,a2,……，an 是 线性不相关的。反过来，如果存在c1,c2,……cn，那么我们说，至少有一个a~i~ 是其它a向量的线性组合。</p>
<p>秩就是一个矩阵中线性不相关的行或列的数目。</p>
<p>很容易证明矩阵（square or rectangular）中，线性不相关的行的数目 = 线性不相关的列的数目。</p>
<p>在rectangular matrix中，如果是n × p，那么这个矩阵的最大的秩为 min(n,p)。<strong>因此，在一个rectangular matrix中，至少行或列（or both）是线性相关的</strong>。</p>
<p>由于一个矩阵的行或列可能存在线性相关，我们可以创造出 <strong>AB = CB</strong>, 但是 <strong>A</strong> 不等于 <strong>C</strong>。这也就是为什么，在矩阵方程式中，<strong>我们一般不能约掉左右两边共同的矩阵</strong>。但是有两个例外情况：</p>
<ol>
<li><strong>B</strong>是一个满秩的方阵，那么此时<strong>AB=CB</strong>，就意味着<strong>A=C</strong>。</li>
<li>如果对于任何的<strong>B</strong>矩阵都存在<strong>AB=CB</strong>，那么<strong>A=C</strong>。</li>
</ol>
<p>可以给出一个例子。比如<strong>B</strong>是一个2×2的元素均为1的矩阵。A也是一个2×2的矩阵，那么<strong>AB</strong>的第一行元素为a11+a12，第二行元素为a21+a22。对于特定的<strong>AB</strong>，只要保证<strong>A</strong>每行的和相同即可，也就是可以构建出无数的<strong>A</strong>阵。</p>
<p>对于矩阵乘积，秩满足如下条件</p>
<ul>
<li>如果A 和 B <strong>are confromal for multiplication</strong>, 那么 rank(AB) &lt;= rank(A) ;rank(AB) &lt;= ran(B)</li>
<li>左乘或右乘一个满秩的矩阵，不会改变秩的大小。假如 B 和 C 是满秩的方阵，那么 rank(AB) = rank(CA) = rank(A)</li>
<li>对于任何一个矩阵，rank(<strong>A’A</strong>) = rank(<strong>AA’</strong>) = rank(<strong>A’</strong>) = rank(<strong>A</strong>)</li>
</ul>
<h3 id="逆矩阵">逆矩阵</h3>
<p>我们一般把一个满秩的<strong>方</strong>阵叫做非奇异阵（nonsigular），而非奇异阵有一个唯一的逆矩阵。把不满秩的矩阵叫做奇异阵（sigular），奇异阵没有逆矩阵（rectangular matrices 都没有逆矩阵）。<br>
如果<strong>B</strong>是一个非奇异阵，<strong>AB = CB</strong>，那么左右两边都可以乘以<strong>B^-^</strong>，那么就得到了<strong>A=C</strong>。（但是如果B不满秩，或者是rectangular，那么就不能这么做）。</p>
<p>类似的，如果<strong>A</strong>是一个非奇异阵，那么<strong>Ax=c</strong>的求解，等于左右两边均左乘A-1，得到<strong>x=A-1c</strong></p>
<p>逆矩阵性质：</p>
<ol>
<li>如果A为<strong>非奇异阵</strong>，那么**A’**也是一个非奇异阵，并且其逆阵满足：<br>
(A)^-1^ = (A^-1^)’</li>
<li>如果A和B均为非奇异阵且大小相同（方阵能相乘肯定大小相同），那么<strong>AB</strong>也是一个非奇异阵，并且<br>
**(AB)^-1^ = B^-1^A^-1^</li>
</ol>
<p>特殊例子</p>
<p><img src="inverse_special1.png" alt="inverse_special1"></p>
<h3 id="正定矩阵">正定矩阵</h3>
<p>二次型都可以写成<strong>y’Ay</strong>的格式。如下例子，其中的<strong>A</strong>阵其实不唯一，但是如果将<strong>A</strong>表达为对称阵，那么此时A阵是唯一的。</p>
<p><img src="positive_definite1.png" alt=""></p>
<p>如果<strong>A阵</strong>具有这种性质：无论<strong>y</strong>向量是什么（0向量除外），<strong>y’Ay</strong> 均大于0，那么我们说二次型<strong>y’Ay</strong>是正定的（positive definite），<strong>A</strong>是正定矩阵。如果对于所有的<strong>y</strong>，均大于等于0，我们说<strong>A</strong>阵是半正定的（positive semidefinite）</p>
<p>举例</p>
<p><img src="positive_definite2.png" alt=""></p>
<p>性质：</p>
<ol>
<li>正定矩阵的对角线都是正数。</li>
<li>半正定矩阵的对角线元素大于等于0</li>
</ol>
<p>证明：</p>
<ol>
<li>如果存在一个<strong>y’</strong> = (0,……0,1,0,……0)，第i个位置为1，其它为0。那么<strong>y’Ay</strong> = aii &gt; 0</li>
<li>半正定矩阵同理</li>
</ol>
<p>如果<strong>P</strong>是一个非奇异阵：</p>
<ol>
<li>如果<strong>A</strong>是一个正定矩阵，那么<strong>P’AP</strong>也是正定的</li>
<li>如果<strong>A</strong>是一个半正定矩阵，那么<strong>P’AP</strong>也是半正定的</li>
</ol>
<p>证明</p>
<p><img src="positive_definite3.png" alt=""></p>
<p>变种：</p>
<p><img src="positive_definite4.png" alt=""></p>
<p>对于一个<strong>对称矩阵A</strong>，当且仅当存在一个非奇异阵<strong>P</strong>使得 <strong>A=P’P</strong>时，<strong>A</strong>才为正定矩阵。（反过来说，对于一个对称正定矩阵<strong>A</strong>，都可以分解为<strong>A=P’P</strong>）</p>
<p><strong>一个正定矩阵必定是非奇异阵</strong><br>
证明：根据 Cholesky 分解，可以将一个正定矩阵A分解，<strong>A=TT‘</strong>，其中T是一个<strong>非奇异</strong>的下三角矩阵（根据前面的公式，rank(T’T)=rank(T）)</p>
<p>对于任意一个矩阵<strong>B</strong>（square or rectangular）,矩阵<strong>B’B</strong>是<strong>正定</strong> 或 <strong>半正定</strong> 的。</p>
<p>如果<strong>B</strong>是一个 n × p 的矩阵。</p>
<ul>
<li>如果 rank(B) = p， 那么<strong>B’B</strong>是正定的</li>
<li>如果 rank(B) &lt; p， 那么<strong>B’B</strong>是半正定的</li>
</ul>
<p>如果A是正定的，那么其逆矩阵也是正定的。</p>
<h3 id="systems-of-equations">systems of equations</h3>
<p>假设有n个不等式，其中有p个未知量。</p>
<p><img src="equations1.png" alt=""></p>
<p>也可以用矩阵的形式，写为 <strong>Ax = c</strong></p>
<p>如果 n = p 并且A为非奇异阵，那么存在唯一解：x = A-1c 。 如果 n &gt; p， 此方程组无解；如果n &lt; p，此方程组有无穷多解。</p>
<p>如果the system of equations <strong>Ax = c</strong> 存在一个或多个解，那么我们称之为 <em>consistent</em>；否则，我们称之为 <em>inconsistent</em></p>
<p>为了说明consistent system of equations 的结构，我们假设 <strong>A</strong> 是一个 p × p ，秩为 r &lt; p 的矩阵。那么 A 阵的行之间存在线性相关，也就是存在<strong>b</strong>向量，使得</p>
<p><img src="equations2.png" alt=""></p>
<p>因此我们必须使得<strong>b’c</strong>也等于0，不然就无解。也就是说，为了使<strong>Ax = c</strong> 是 consistent，那么<strong>A</strong>中行之间存在的线性关系必须在<strong>c</strong>的相应元素之间也体现出来（比如说，A的其中一行是另一行的两倍，那么<strong>c</strong>中相应元素必须也是两倍）。具体来说就是 rank(<strong>A</strong>) = rank(<strong>(A,c)</strong>) (就是把c作为一列附在A的后面)</p>
<p><strong>定理</strong>：如果<strong>Ax = c</strong>当且仅当rank(<strong>A</strong>) = rank(<strong>(A,c)</strong>)时，才存在至少一个解向量。</p>
<p>举例：</p>
<p><img src="equations3.png" alt=""></p>
<p>这个例子中，很明显第三个式子时多余的。根据前两个式子就能求解。且只有唯一解。</p>
<p>但是，如果第三个式子中的3改为2，那么此时（A，c) 的秩为3，rank(A) 为2，这个方程式无解。</p>
<p>又一个例子</p>
<p><img src="equations4.png" alt=""></p>
<p>其中，第三个式子为前两个式子的和。rank(<strong>A</strong>) = rank(<strong>(A,c)</strong>)=2，有无穷多个解</p>
<p><img src="equations5.png" alt=""></p>
<p>其中 x3 可以取任意值，x1 x2 随 x3的值而定。</p>
<h3 id="广义逆">广义逆</h3>
<p>对于不能求逆的矩阵，我们可以求其广义逆。比如 对于<strong>Ax = c</strong>求解时，其中的一个解可以通过求A的广义逆得到。</p>
<h4 id="广义逆的定义和特性">广义逆的定义和特性</h4>
<p>对于一个 n × p 的矩阵 <strong>A</strong>， 其广义逆满足如下条件</p>
<blockquote>
<p>AA^-^A = A</p>
</blockquote>
<p>广义逆不唯一，除非A是非奇异阵，在这种情况下，A^-^ = A^-1^ 。</p>
<blockquote>
<p>A generalized inverse is also called aconditional inverse</p>
</blockquote>
<p>任何一个矩阵（square or rectangular），都有广义逆。即便是向量，都有广义逆。</p>
<p><strong>定理</strong>：如果 A是  n × p ；那么其广义逆A-均为  p × n</p>
<p><strong>定理</strong>：如果A是  n × p ，其秩为r ，并且A 可以划分为以下子矩阵。其中 A11 是 r × r 的满秩矩阵。那么其逆矩阵如下。</p>
<p><img src="generized_inverse1.png" alt=""></p>
<p>后面的证明我都看懂了，不过确实是拐着弯地证明了。</p>
<p><strong>引申</strong>：同上，A22也成立。<br>
进一步引申如下，对任何一个矩阵求广义逆均可按照以下5步</p>
<ol>
<li>找到一个非奇异的r × r 子矩阵 C。（甚至C中的行或列不用是在A毗邻的）</li>
<li>计算出 <strong>C^-1^</strong> 和**（C^-1^）'**</li>
<li>将<strong>C</strong>中的元素替代为**（C^-1^）'**中的元素</li>
<li>将<strong>A</strong>中的其它元素全部替换为0</li>
<li>转置上一步的结果矩阵</li>
</ol>
<p><strong>定理</strong> 如果A是  n × p ，其秩为r ，它的一个广义逆为A-</p>
<ol>
<li>rank(A^-^A) = rank(AA^-^) = rank(A) = r</li>
<li>(A^-^)’ 是 A‘ 的一个广义逆；即（A’)^-^ = (A^-^)’</li>
</ol>
<p>直接上图吧，太复杂</p>
<p><img src="generized_inverse2.png" alt=""></p>
<p>一个对称矩阵的广义逆不一定是对称的。但是，一个对称矩阵一定能找到对称的广义逆。这本书中，我们假定对称矩阵的广义逆都是对称的。</p>
<p>注：自己查了一下，对称的非奇异阵的逆矩阵也是对称的<br>
证明如下<br>
(A^-1^)’ = (A’)^-1^ = (A)^-1^ = A^-1^</p>
<h4 id="广义逆与方程组求解">广义逆与方程组求解</h4>
<p>如果 <strong>Ax = c</strong> 是 <em>consistent</em>， 而且 A^-^ 是 A 的一个广义逆，那么，<strong>x = A^-^c</strong> 就是方程组的一个解。<br>
证明如下：</p>
<p><img src="generized_inverse3.png" alt=""></p>
<p>采用不同的广义逆，结果有所不同。</p>
<h3 id="行列式（determinant）">行列式（determinant）</h3>
<ul>
<li>奇异矩阵行列式为0；非奇异阵行列式不为0</li>
<li>如果A是正定矩阵，|A| &gt; 0</li>
</ul>
<p>后面没看，就目前看的书，没怎么用到行列式</p>
<h2 id="Random-Vectors-and-Matrices">Random Vectors and Matrices</h2>
<h3 id="introduction">introduction</h3>
<p>当我们使用线性模型时，把数据的观测值以随机向量或随机矩阵的形式表示，是一种很方便的方法。随机向量或随机矩阵指的是其中的元素都是随机变量。</p>
<p>通常来说，我们有两种形式的随机变量：</p>
<ol>
<li>对 n 个不同的个体或实验单位进行相同的测量方法得到的测量值。这里有两个条件，个体的选择是随机的；测量方法或观测方法是一致的。就比如表型观测值就是典型的彼此不相关而且有着相同的方差。</li>
<li>一个个体的 p 的不同的测量值。那么这个随机变量彼此之间是相关的，而且有者不同的方差。</li>
</ol>
<h3 id="均值、方差、协方差和相关">均值、方差、协方差和相关</h3>
<p>在这一章节中，我们会回顾单变量和双变量随机变量的性质。我们以单随机变量y为例。这里我们一般不区分随机变量y 和  y的观测值 。在很多书中，大写字母表示随机变量，而相应的小写字母表示的是一个随机变量的实现（a realization of the random variable），就像表达式 P(Y &lt; y)。这样的写法在单变量中很实用。但是，因为在这里，我们用大写字母表示矩阵，小写字母表示向量，这就会产生冲突。</p>
<p>如果 f(y) 是 随机变量 y 的概率密度曲线，y 的 期望值如下</p>
<p><img src="random_vector1.png" alt=""></p>
<p>不截图看书吧，就是推导总体的均值，方差，等等公式。</p>
<p>对于双随机变量的联合概率密度分布。如果联合概率密度等于两个边缘密度分布的乘积，那么这两个随机变量就是不想关的（independent）</p>
<p><img src="random_vector2.png" alt=""></p>
<p>但是上面3.15的式子反过来不对，也就是说 σij = 0 并不意味着两个变量之间是独立的。</p>
<p>后面涉及条件概率密度的积分，看不懂，得拿本高数来看了。</p>
<p>具体推导用铅笔在书上写了。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Analysis for the Life Sciences</title>
    <url>/posts/3263dd4c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这也是一本数据分析的书籍，用的语言是R，但是貌似我之前没看完……</p>
<span id="more"></span>
<h1>Data Analysis for the Life Sciences</h1>
<h2 id="introduction">introduction</h2>
<p>statistical inference(统计推断)：推断就是使用可能性从数据中获取群体特征值（Inference is the use of probability to learn population characteristic from data）。一个典型的例子就是推断两个群体的平均值是否相同。</p>
<h2 id="getting-started">getting started</h2>
<p>主要是介绍了一些R的基础部分和数学基础。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">###第一章 getting started </span></span><br><span class="line">install.packages(<span class="string">&quot;swirl&quot;</span>)</span><br><span class="line">install.packages(<span class="string">&quot;rafalib&quot;</span>)</span><br><span class="line">install.packages(<span class="string">&quot;downloader&quot;</span>)</span><br><span class="line">setwd(<span class="string">&#x27;D:\\Desktop\\下载英文文献\\模型\\R_model&#x27;</span>)</span><br><span class="line">dat &lt;- read.table(<span class="string">&#x27;female_mouse_weights.txt&#x27;</span>,header = <span class="built_in">T</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">###通过downloader直接下载网上的数据</span></span><br><span class="line">library(downloader) <span class="comment">##use install.packages to install ##通过downloader</span></span><br><span class="line">url &lt;- <span class="string">&quot;https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extd\</span></span><br><span class="line"><span class="string">ata/femaleMiceWeights.csv&quot;</span>  <span class="comment">## 数据的完整路径</span></span><br><span class="line">filename &lt;- <span class="string">&quot;femaleMiceWeights.csv&quot;</span></span><br><span class="line">download(url, destfile=filename) <span class="comment">## 下载，后面更的是下载后的名称</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 为了从GitHub 上直接下载文件夹，你需要下载devtools包</span></span><br><span class="line">library(devtools)</span><br><span class="line">install_github(<span class="string">&quot;genomicsclass/dagdata&quot;</span>)</span><br><span class="line"></span><br><span class="line">dir &lt;- system.file(package = <span class="string">&quot;dagdata&quot;</span>) <span class="comment"># 获取文件夹位置</span></span><br><span class="line">dir  <span class="comment">## &quot;D:/software/R/R-3.6.1/library/dagdata&quot;</span></span><br><span class="line">list.files(dir) <span class="comment"># 查看dir下面的文件和子文件夹</span></span><br><span class="line">list.files(dir,<span class="string">&quot;extdata&quot;</span>) <span class="comment"># 查看extdata下的子文件</span></span><br><span class="line">filename&lt;-file.path(dir,<span class="string">&quot;extdata/femaleMiceWeights.csv&quot;</span>) <span class="comment">## 文件的完整路径</span></span><br><span class="line">dat&lt;-read.csv(filename) <span class="comment">## 最终打开文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####初探dplyr </span></span><br><span class="line">library(<span class="string">&quot;dplyr&quot;</span>)</span><br><span class="line"><span class="comment">##dplyr包中filter是进行数据筛选</span></span><br><span class="line">chow &lt;- filter(dat,Diet==<span class="string">&quot;chow&quot;</span>) <span class="comment">## 筛选Diet列中为chow的数据</span></span><br><span class="line">head(chow)</span><br><span class="line"></span><br><span class="line"><span class="comment">## select貌似是选列</span></span><br><span class="line">chowVals &lt;- select(chow,Bodyweight) <span class="comment">## 选择chow中的Bodyweight列</span></span><br><span class="line">head(chowVals)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 还可以使用通道符 %&gt;% denote a pipe </span></span><br><span class="line"><span class="comment">## 因此上述两步可以合成一步</span></span><br><span class="line">chowVals &lt;- filter(dat,Diet==<span class="string">&quot;chow&quot;</span>) %&gt;% select(Bodyweight)</span><br><span class="line">head(chowVals)</span><br><span class="line"><span class="comment">## dplyr接收的是data.frame ，返回的也是data.frame</span></span><br><span class="line"><span class="built_in">class</span>(chowVals) <span class="comment">#data.frame</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 为了使结果为向量，可以使用unlist函数。将list(包括data.frame)转换成numeric vectors. </span></span><br><span class="line">chowVals &lt;- filter(dat,Diet==<span class="string">&quot;chow&quot;</span>) %&gt;% select(Bodyweight) %&gt;% unlist</span><br><span class="line"><span class="comment">## 通道少写一个参数，但是这里的unlist连()都省了</span></span><br><span class="line"><span class="built_in">class</span>(chowVals) <span class="comment">#numeric </span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 不用dplyr的写法</span></span><br><span class="line">chowVals &lt;- dat[dat$Diet==<span class="string">&quot;chow&quot;</span>,<span class="string">&quot;Bodyweight&quot;</span>]</span><br><span class="line">head(chowVals)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 小结，感觉R整理数据就是不太方便。</span></span><br></pre></td></tr></table></figure>
<h2 id="inference">inference</h2>
<p>以下为random variable,  null distribution,  p-value 的 简要介绍。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#inference</span></span><br><span class="line">setwd(<span class="string">&#x27;D:\\Desktop\\下载英文文献\\模型\\R_model&#x27;</span>)</span><br><span class="line">dat &lt;- read.table(<span class="string">&#x27;female_mouse_weights.txt&#x27;</span>,header = <span class="built_in">T</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#####didtribution 的解析</span></span><br><span class="line"><span class="comment">#distribution：可以简单地理解为一堆数。</span></span><br><span class="line"><span class="comment">#比如你测量了一个群体中所有人的身高。</span></span><br><span class="line"><span class="comment">#这个时候你要和其他人不懂的人（such as analien that has never visited Earth）描述这些数字。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#假如以下就是你取得的身高数据</span></span><br><span class="line">library(UsingR)</span><br><span class="line">x &lt;- father.son$fheight</span><br><span class="line"></span><br><span class="line"><span class="comment">#最简单的就是列出来给外星人看</span></span><br><span class="line"><span class="built_in">round</span>(sample(x,<span class="number">10</span>),<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#但这不够充分，我们可以定义一个累积分布函数（Cumulative Distribution Function）</span></span><br><span class="line"><span class="comment">#F(a) == Pr(x&lt;a) #小于等于号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#画图如下</span></span><br><span class="line"><span class="comment"># floor ceiling 是取整用的</span></span><br><span class="line"><span class="comment"># floor 是直接取整数，ceiling 是 “天花板” </span></span><br><span class="line"><span class="comment"># 如 floor(2.99) = 2 ceiling(2.99) = 3</span></span><br><span class="line"><span class="comment"># 用在画图还是挺好的</span></span><br><span class="line"></span><br><span class="line">smallest&lt;-<span class="built_in">floor</span>( <span class="built_in">min</span>(x) )</span><br><span class="line">largest&lt;-<span class="built_in">ceiling</span>( <span class="built_in">max</span>(x) )</span><br><span class="line">values&lt;-seq(smallest, largest,len=<span class="number">300</span>)</span><br><span class="line">heightecdf&lt;-ecdf(x)</span><br><span class="line">plot(values, heightecdf(values), type=<span class="string">&quot;l&quot;</span>,xlab=<span class="string">&quot;a (Height in inches)&quot;</span>,ylab=<span class="string">&quot;Pr(x &lt;= a)&quot;</span>)</span><br><span class="line"><span class="comment"># 但是现在更常见的是画直方图</span></span><br><span class="line"><span class="comment"># 把直方图给外星人一看，基本就很清晰了。</span></span><br><span class="line">hist(x)</span><br><span class="line">bins&lt;-seq(smallest, largest)</span><br><span class="line">hist(x,breaks=bins,xlab=<span class="string">&quot;Height (in inches)&quot;</span>,main=<span class="string">&quot;Adult men heights&quot;</span>)</span><br><span class="line"><span class="comment">#breaks设置中，不用floor,ceiling 画不成图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####回到正题</span></span><br><span class="line">library(dplyr)</span><br><span class="line">control &lt;- filter(dat,Diet==<span class="string">&quot;chow&quot;</span>) %&gt;% select(Bodyweight) %&gt;% unlist</span><br><span class="line">treatment  &lt;- filter(dat,Diet==<span class="string">&quot;hf&quot;</span>) %&gt;% select(Bodyweight) %&gt;% unlist</span><br><span class="line">mean(treatment)</span><br><span class="line">mean(control)</span><br><span class="line">obsdiff &lt;- mean(treatment) - mean(control)</span><br><span class="line">obsdiff</span><br><span class="line"><span class="comment">#[1] 3.020833</span></span><br><span class="line"><span class="comment">#只看均值和差值是不够的</span></span><br><span class="line"><span class="comment">#因为如果你再取24只老鼠重新做试验，每一次都能得到一个新的结果。</span></span><br><span class="line"><span class="comment">#我们把具有这种特性的数据称为随机变量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####更深刻地理解随机变量###########</span></span><br><span class="line"><span class="comment"># 假设我们有所有的control群体，如下</span></span><br><span class="line">library(downloader)</span><br><span class="line">url&lt;-<span class="string">&quot;https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extdata/femaleControlsPopulation.csv&quot;</span></span><br><span class="line">filename&lt;-<span class="string">&quot;femaleControlsPopulation.csv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!file.exists(filename)) download(url,destfile=filename)</span><br><span class="line"><span class="comment">#如果文件不存在则下载</span></span><br><span class="line"></span><br><span class="line">population&lt;-read.csv(filename)</span><br><span class="line"></span><br><span class="line">population &lt;- unlist(population) <span class="comment">#从data.frame 转为 vector</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#从总体中每次随机抽取12只老鼠，重复三次，每次均值均不同</span></span><br><span class="line"></span><br><span class="line">control&lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">mean(control)</span><br><span class="line"><span class="comment">#[1] 23.4925</span></span><br><span class="line"></span><br><span class="line">control&lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">mean(control)</span><br><span class="line"><span class="comment">#[1] 24.96583</span></span><br><span class="line"></span><br><span class="line">control&lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">mean(control)</span><br><span class="line"><span class="comment">#[1] 22.90083</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#因此哪怕同一个群体，抽取不同的样本，之间也是有差异的。</span></span><br><span class="line"><span class="comment">#所以对于上面两个群体的obsdiff，我们存有怀疑，这究竟是不是因为影响因素（diet）造成的</span></span><br><span class="line"><span class="comment">#如果我们给这24只老鼠相同的diet，差异还有有这么大吗？</span></span><br><span class="line"><span class="comment">#出于怀疑精神，一般统计推断的零假设（null hypothesis）会设定为两个群体没有区别。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#由于我们有了control的总体，所以我们可以无限次抽样。</span></span><br><span class="line"><span class="comment">#每次从control的群体中，抽2批12只老鼠，求均值。代码如下</span></span><br><span class="line"></span><br><span class="line">control&lt;-sample(population,<span class="number">12</span>)</span><br><span class="line"><span class="comment">##another 12 control mice that we act as if they were not</span></span><br><span class="line">treatment &lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">print(mean(treatment)-mean(control))</span><br><span class="line"><span class="comment">#[1] -1.175</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#现在让我们重复这一步骤10000次</span></span><br><span class="line"></span><br><span class="line">null &lt;- vector()</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">10000</span>)&#123;</span><br><span class="line">  control&lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">  treatment &lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">  null[i] &lt;- mean(treatment)-mean(control)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在在null中的值我们称之为null distribution</span></span><br><span class="line"></span><br><span class="line">mean(null&gt;=obsdiff)</span><br><span class="line"><span class="comment"># [1] 0.0147</span></span><br><span class="line"><span class="comment">#mean里面的是一个布尔向量，由TRUE和FALSE组成</span></span><br><span class="line"><span class="comment">#但是在计算的过程中，TRUE视为1，FALSE视为0。</span></span><br><span class="line"><span class="comment">#所以这个0.0147是这10000次中差距大于obsdiff的比例。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#因此作为一个怀疑主义者，我们可以得出结论</span></span><br><span class="line"><span class="comment">#如果没有diet effect，我们看到像obsdiff这么的差距的可能性是1.47%</span></span><br><span class="line"><span class="comment">#这就是所谓的P值！</span></span><br><span class="line"><span class="comment">#p值即原假设成立的前提下，此事件发生的概率。</span></span><br><span class="line"><span class="comment">#深入浅出，厉害！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#小结一下，像上述这样计算P值很简单。但是生活中不可行。</span></span><br><span class="line"><span class="comment">#因为你不肯真的把测量整个群体的信息，从而构成null distribution。</span></span><br><span class="line"><span class="comment">#一般也还是通过采样。</span></span><br><span class="line"><span class="comment">#也就是还是只通过数据中的24只老鼠的数据进行判断。</span></span><br></pre></td></tr></table></figure>
<h3 id="population-parameters">population parameters</h3>
<p>统计推断的第一步是弄清楚你感兴趣的群体。作者选这个这个小鼠的数据集的原因之一，是因为作者有所有这种类型的小鼠的体重信息（即这个群体的所有群体）。</p>
<p>如果你能收集你感兴趣的群体的所有数据，那么得到的参数（群体均值、方差、标准差）就被称为群体参数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(downloader)</span><br><span class="line">url&lt;-<span class="string">&quot;https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extdata/mice_pheno.csv&quot;</span></span><br><span class="line">filename&lt;-<span class="string">&quot;mice_pheno.csv&quot;</span> </span><br><span class="line">download(url,destfile=filename)</span><br><span class="line">dat&lt;-read.csv(filename) <span class="comment">#这是所有这个小鼠群体的数据</span></span><br><span class="line"></span><br><span class="line">library(dplyr)</span><br><span class="line">controlPopulation &lt;- filter(dat,Sex==<span class="string">&quot;F&quot;</span>&amp;Diet==<span class="string">&quot;chow&quot;</span>) </span><br><span class="line"><span class="built_in">length</span>(controlPopulation$Bodyweight)</span><br><span class="line"></span><br><span class="line">hfPopulation&lt;-filter(dat,Sex==<span class="string">&quot;F&quot;</span>&amp;Diet==<span class="string">&quot;hf&quot;</span>)</span><br><span class="line"><span class="built_in">length</span>(hfPopulation$Bodyweight)</span><br><span class="line"><span class="comment">#此时群体的均值、方差、标准差等就被称为群体参数（population parameters）</span></span><br><span class="line"><span class="comment">#此时回到我们的问题，两个群体的均值是否相等。</span></span><br><span class="line"><span class="comment">#由于我们拿到了两个群体的所有数据，那么用μy-ux（x:control y:hf）,直接看差值是否为0即可。</span></span><br></pre></td></tr></table></figure>
<p>但是，在实际生活中，我们拿不到群体的所有数据。比如，可能买下一个群体所有的小鼠是很贵的。<br>
因此，我们需要学会如何从样本数据来回答我们的问题。这就是统计推断的本质。</p>
<h3 id="Sample-estimates">Sample estimates</h3>
<p>在之前的章节中，我们从两个群体中各随机抽取了12只小鼠。我们一般用大写字母来表示抽样个体，以此表明他们是随机抽取的。这也是统计中的一种常规做法。因此抽样个体表示为X~1~ ……X~12~ 和 Y~1~ …… Y~12~。<br>
而对于上面的群体中的个体，用的是小写数字。因为这些个体是给定的，不是随机的。<br>
此时，研究目标是两个样本群体均值的差值。<br>
而这个差值也是一个随机变量（random variable）。前面，我们采用一种从原始数据中重复抽样的手段（10000次）。但是，这在实际中（in practice）是不可实现的，比如在我们这个例子中，就是要不断地买24只小鼠做试验。<br>
下面会介绍群体均值差与样本均值差的关系。这涉及到了中心极限定理。</p>
<h3 id="Central-Limit-Theorem-and-t-distribution">Central Limit Theorem and t-distribution</h3>
<p><strong>中心极限定理</strong>：<strong>无论群体总体服从什么分布</strong>，当抽样个体数足够大时（一般认为，每组大于等于30个），抽样群体的均值（Y拔）服从正态分布。其均值为群体均值，其标准差等于群体标准差除以根号N（N 为 simple size）。我们把这个随机变量分布的标准差称为标准误（<em>standard error</em>）。</p>
<ul>
<li>对于一个随机变量，加减常数（X+a），则该随机变量的均值也随之变化（u~X~+a）</li>
<li>对于一个随机变量，乘以一个常数（X*a），则该随机变量的均值和标准差也乘以此常数</li>
<li>对于两个独立的随机变量相加（X+Y），其均值为μ~X~+μ~Y~，其方差为二者之和。如果是两个独立的随机变量相减，其均值为二者之差，其方差仍未<strong>二者之和</strong>。</li>
<li>如果两个随机变量都满足正态分布，那么它们只和仍满足正态分布。</li>
</ul>
<p>在本例中，我们关心的两个群体的均值，由于中心极限定理，服从正态分布。因此它们的差值也服从正态分布，均值为两个随机变量之差，方差为<strong>两个随机变量之和</strong>。由于原假设是不存在差异，那么两个群体的均值的均值应该大致服从一个均值为0，标准差为√（σ2X+σ2Y）/√N的正态分布。<br>
也就是如下式</p>
<p><img src="clt.png" alt="clt"></p>
<p>这个进行了标准化的随机变量应该满足（0，1）的标准正态分布。（深入浅出！）</p>
<p>根据这个公式，我们可以更快地求出P值（已知标准正态分布）。例如，正态分布中大于2的值只有5%（in absolute value，应该是双尾的意思）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">pnorm(-<span class="number">2</span>)+(<span class="number">1</span>-pnorm(<span class="number">2</span>))</span><br><span class="line"><span class="comment">## [1] 0.04550026</span></span><br></pre></td></tr></table></figure>
<p>因此，我们不用再买更多的小鼠，24只够了。</p>
<p>然而，事情到这一步还没有结束。因为我们不知道群体的标准差，σ~X~和σ~Y~。这些都是不可知的群体参数。但是我们可以用样本标准差去估计群体标准差，称为s~X~ 和 s~Y~。定义如下：</p>
<p><img src="s2.png" alt="s2"></p>
<p>这里是除以M-1 和 N-1（出于理论原因，没解释）。</p>
<p>因此，我们可以把上式改为：</p>
<p><img src="clt_new.png" alt="t_value"></p>
<p>中心极限定理告诉我们，当M,N较大时，这个随机变量服从标准正态分布（零假设下）。因此，我们现在可以计算P值了。</p>
<h3 id="t-分布">t 分布</h3>
<p>中心极限定理需要较大的抽样个体数，这个我们称之为<em>asymptotic results</em>。当这个条件不满足时，还有一种方法可以使用。如果总体数据服从一个均值为0的正态分布，那么对于我们的抽样个体均值，可以计算以下分布，称为t分布：</p>
<p><img src="t-distribution.png" alt="t-distribution"></p>
<p>这里很重要的一点，我们提到的服从正态分布是总体（y1,y2,……yn）服从正态分布，而不是Y拔。虽然无法实际证明，但是我们看一看抽样个体的分布。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">control &lt;- controlPopulation$Bodyweight</span><br><span class="line">hf &lt;- hfPopulation$Bodyweight</span><br><span class="line"><span class="comment"># 直方图</span></span><br><span class="line">op &lt;- par(mfrow = <span class="built_in">c</span>(<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line">hist(control)</span><br><span class="line">hist(hf)</span><br><span class="line">par(op)</span><br></pre></td></tr></table></figure>
<p>更为直观的是，画一个QQ（quantie，分位数）图。分位数的实例之一就是四分位数。QQ图的个人理解为，对于x轴上的一点，能得到x分布中小于等于这个点的概率（比如5%）; 再找到y分布中对应5%概率的实际数值，即y值，这样就得到了一个点（x,y)。</p>
<ul>
<li>如果是离散变量，</li>
</ul>
<blockquote>
<p>在统计学中，QQ图[1] （Q代表分位数Quantile）是一种通过比较两个概率分布的分位数对这两个概率分布进行比较的概率图方法。首先选定分位数的对应概率区间集合，在此概率区间上，点(x,y)对应于第一个分布的一个分位数x和第二个分布在和x相同概率区间上相同的分位数。因此画出的是一条含参数的曲线，参数为概率区间的分割数。</p>
</blockquote>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">op &lt;- par(mfrow = <span class="built_in">c</span>(<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line">qqnorm(hf)</span><br><span class="line">qqline(hf)</span><br><span class="line">qqnorm(control)</span><br><span class="line">qqline(control)</span><br><span class="line">par(op)</span><br></pre></td></tr></table></figure>
<p>在R中，var() 和 sd() 函数都是用于计算样本参数（即除以n-1）。不适用于计算群体参数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x &lt;- control</span><br><span class="line">N &lt;- <span class="built_in">length</span>(x)</span><br><span class="line">populationvar &lt;- mean((x-mean(x))^<span class="number">2</span>)</span><br><span class="line">identical(var(x),populationvar)</span><br><span class="line"><span class="comment">#identical 判断两个值是否相等。</span></span><br><span class="line"><span class="comment">#R中的var() 和 sd() 都是除以n-1。</span></span><br></pre></td></tr></table></figure>
<p>但是实际中，我们没有用到计算总体参数的地方（得不到）。这里为了教学，用了popvar(), popsd() 函数 计算总体参数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(<span class="string">&#x27;rafalib&#x27;</span>)</span><br><span class="line">sd_hf &lt;- popsd(hf)</span><br><span class="line">sd_control &lt;- popsd(control)</span><br></pre></td></tr></table></figure>
<p>一般我们也只能得到样本，如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N &lt;- 12</span><br><span class="line">hf_sample &lt;- sample(hf,<span class="number">12</span>)</span><br><span class="line">control_sample &lt;- sample(control,<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<p>为了 进一步了解中心极限定理，这里采用不同的抽样大小进行抽样</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对不同地抽样个体数，抽样10000次</span></span><br><span class="line"><span class="comment">#sapple 对Ns中的每一个数，执行后面的函数</span></span><br><span class="line">Ns&lt;-<span class="built_in">c</span>(<span class="number">3</span>,<span class="number">12</span>,<span class="number">25</span>,<span class="number">50</span>)</span><br><span class="line">B &lt;-  10000   <span class="comment">#number of simulations</span></span><br><span class="line">res&lt;-sapply(Ns,<span class="keyword">function</span>(n) &#123;</span><br><span class="line">  replicate(B,mean(sample(hf,n))-mean(sample(control,n)))</span><br><span class="line">&#125;)</span><br><span class="line">res</span><br><span class="line"></span><br><span class="line"><span class="comment">## 现在我们可以用qq图看中心极限定理的效果如何</span></span><br><span class="line">op &lt;- par(mfrow=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> seq(along=Ns)) &#123;    <span class="comment"># 等于 seq(length(Ns))</span></span><br><span class="line">  titleavg&lt;-<span class="built_in">signif</span>(mean(res[,i]),<span class="number">3</span>) <span class="comment">#signif和round差不多，不过后面不是小数位数，而是有效数字。</span></span><br><span class="line">  titlesd&lt;-<span class="built_in">signif</span>(popsd(res[,i]),<span class="number">3</span>)</span><br><span class="line">  title&lt;-paste0(<span class="string">&quot;N=&quot;</span>,Ns[i],<span class="string">&quot;Avg=&quot;</span>,titleavg,<span class="string">&quot;SD=&quot;</span>,titlesd)</span><br><span class="line">  qqnorm(res[,i],main=title)</span><br><span class="line">  qqline(res[,i],col=<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#随着抽样数目的增加，标准误越小。基本符合根号N的规律。</span></span><br><span class="line"><span class="comment">#即便抽样数目为3，也基本符合正态分布。</span></span><br><span class="line"><span class="comment">#这和总体分布有关。因为我们这个小鼠体重分布本身就接近正态分布。哪怕采样个体为1，也会符合正态分布。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是在实践中，我们不会只求均值，而是会除以标准差。此时采样个数就重要了</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Ns&lt;-<span class="built_in">c</span>(<span class="number">3</span>,<span class="number">12</span>,<span class="number">25</span>,<span class="number">50</span>)</span><br><span class="line">B&lt;-<span class="number">10000</span><span class="comment">#number of simulations#</span></span><br><span class="line"><span class="comment">#function to compute a t-stat</span></span><br><span class="line">computetstat&lt;-<span class="keyword">function</span>(n) &#123;</span><br><span class="line">  y&lt;-sample(hfPopulation,n)</span><br><span class="line">  x&lt;-sample(controlPopulation,n)</span><br><span class="line">  (mean(y)-mean(x))/<span class="built_in">sqrt</span>(var(y)/n+var(x)/n)</span><br><span class="line">  &#125;</span><br><span class="line">res&lt;-sapply(Ns,<span class="keyword">function</span>(n) &#123;</span><br><span class="line">  replicate(B,computetstat(n))</span><br><span class="line">  &#125;)</span><br><span class="line">op &lt;- par(mfrow=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> seq(along=Ns)) &#123;</span><br><span class="line">  qqnorm(res[,i],main=Ns[i])</span><br><span class="line">  qqline(res[,i],col=<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">#此时N=3已经有些偏离，而N=12只有轻微偏离</span></span><br><span class="line"><span class="comment">#因此N=12已经够了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是这种模拟在实际中无法做到。这里只用于说明CLT的概念和局限。</p>
<h3 id="t-tests-in-Partice">t-tests in Partice</h3>
<p>逻辑线：</p>
<ol>
<li>首先我们得到了两个样本群体的均值差，这本身也是一个随机变量。而且根据零假设，这个变量分布的均值为0。</li>
<li>那么这个均值差分布的标准误（差）呢？</li>
<li>首先我们根据中心极限定理，每个群体均值服从正态分布，标准误为总体标准差（这里直接用样本标准差估计总体标准差）除以根号N。</li>
<li>但这仅仅是每个样本均值的标准误（或者说标准差，其实我觉得这里说标准误和标准差是一回事，标准误就是均值的标准差，所以不还是标准差吗？这里说的均值差的标准误其实也就是均值差的标准差。）</li>
<li>我们根据统计理论，我们知道两个随机变量差值的方差等于这两个随机变量的方差之和（var(x-y)=var(x)+var(y))</li>
<li>因此se = sd( x-y ) = sqrt(var(x)+var(y)) =  sqrt( sd(x)/sqrt(n) + (sd(y)/sqrt(m) )</li>
<li>tstat &lt;- diff(-0)/se</li>
<li>这就是t统计量，由于除以了se，这个统计量的SE为1。</li>
<li>因此我们只要知道这个t统计量的分布，我们就能得到P值。</li>
<li>根据中心极限定理，当<strong>抽样个体数较大</strong>时，两个抽样均值均符合正态分布。根据统计理论，那么这两个随机变量之差也服从正态分布。因此此时这个tstat也是服从<strong>均值为0，方差为1的正态分布</strong></li>
<li>那么计算为了计算P值，我们需要问：在正态分布中，出现diff或比diff（tstat）更极端的值的概率是多大？（ how often does a normally distributed randomvariable exceeddiff?）我们可以通过pnorm()函数进行计算双尾概率。</li>
<li>在本例中，p-value 小于 0.05， 我们认为差异是显著的。（深入理解P值，P值是零假设成立下该事件发生的概率）</li>
<li>但是我们又面临另一个问题。中心极限定理只有在样本量较大时适用，但是12足够大了吗？一般我们认为样本数大于30才比较好。所以我们刚刚计算的P值只有在这个成立时才有效，所以这里可能不适用。然而，除了使用中心极限定理，我们这里有另一种方法。</li>
</ol>
<p>R代码如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dat&lt;-read.csv(<span class="string">&quot;femaleMiceWeights.csv&quot;</span>)<span class="comment">#previously downloaded</span></span><br><span class="line">control&lt;-filter(dat,Diet==<span class="string">&quot;chow&quot;</span>)%&gt;%select(Bodyweight)%&gt;%unlist</span><br><span class="line">treatment&lt;-filter(dat,Diet==<span class="string">&quot;hf&quot;</span>)%&gt;%select(Bodyweight)%&gt;%unlist</span><br><span class="line">diff&lt;-mean(treatment)-mean(control)</span><br><span class="line">print(diff)</span><br><span class="line"><span class="comment">## [1] 3.020833</span></span><br><span class="line"></span><br><span class="line">se&lt;-<span class="built_in">sqrt</span>(</span><br><span class="line">  var(treatment)/<span class="built_in">length</span>(treatment) + </span><br><span class="line">    var(control)/<span class="built_in">length</span>(control)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">tstat&lt;-diff/se</span><br><span class="line"><span class="comment">## [1] 2.055174</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##tstat在标准正态分布中出现的概率(双尾)</span></span><br><span class="line"><span class="comment">##也就是在标准正态分布中出现tstat及比tstat更极端的值的概率</span></span><br><span class="line">righttail&lt;-<span class="number">1</span>-pnorm(<span class="built_in">abs</span>(tstat))</span><br><span class="line">lefttail&lt;-pnorm(-<span class="built_in">abs</span>(tstat))</span><br><span class="line">pval&lt;-lefttail+righttail</span><br><span class="line">print(pval)</span><br><span class="line"></span><br><span class="line"><span class="comment">## [1] 0.0398622</span></span><br></pre></td></tr></table></figure>
<h3 id="The-t-distribution-in-Practice">The t-distribution in Practice</h3>
<p>根据上面的模拟情况和统计理论。 如果<strong>总体的分布是正态的</strong>，那么我们可以<strong>不通过中心极限定理</strong>，而弄清楚t统计量的确切分布。但是如果抽样个体数很少，很难证明总体分布是否符合正态。但是对于体重这种数据，根据经验，我们一般认为总体分布极可能大致符合正态分布，因此我们可以利用这种近似。另外，我们也可以看一下样本的qq图，如下所示。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">op &lt;- par(mfrow=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">qqnorm(treatment)</span><br><span class="line">qqline(treatment,col=<span class="number">2</span>)</span><br><span class="line">qqnorm(control)</span><br><span class="line">qqline(control,col=<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果我们近似认为<strong>总体分布符合正态分布</strong>，那么基于统计理论，tstat服从t分布。相较于正态分布，t分布还有一个自由度的参数。我们直接通过下面的函数求解P值。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">t.test(treatment,control)</span><br><span class="line"></span><br><span class="line">t.test(treatment,control)$p.value <span class="comment">### 直接看P值</span></span><br><span class="line"><span class="comment">## [1] 0.05299888</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>The p-value is slightly bigger now. This is to be expected because our CLT approximation consideredthe denominator oftstatpractically fixed (with large samples it practically is), while the t-distribution approximation takes into account that the denominator (the standard error of thedifference) is a random variable. The smaller the sample size, the more the denominator varies.</p>
</blockquote>
<p>这段话没看太懂，大概理解是：这里用t分布计算出来的p值相较于上面用正态分布计算出来的P值较大。这是因为在CLT中，认为tstat的分母部分是固定的（也就是认为采用了大样本）；而t分布检验中认为tstat的分母部分是随机变量（还不是很懂）。</p>
<p>这可能会让人困惑，怎么会得到两个P值？但是，这在数据分析中是很常见的。通过不同的假设，不同的方法，我们就会得到不同的结果。</p>
<p>其实，基于中心极限定理得到的结果更容易出现<strong>假阳性</strong>，而基于t分布的结果更容易出现<strong>假阴性</strong>。</p>
<h3 id="Confidence-Intervals">Confidence Intervals</h3>
<p>在生命科学中，我们总是需要计算P值。但是我们并不推崇把P值当成唯一的统计指标。原因很简单：统计意义上的显著并不保证科学意义上的显著。当抽样个体数很大时，即便两个群体差异很小，你仍可以检测到一个统计意义上的显著差异。但是这有意义吗？如果只看P值，信息是不够的。还需要给出效应大小（这里是两个群体均值差）。<br>
另一种方法是给出置信区间。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#以control群体均值的置信区间为例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#先看总体的均值</span></span><br><span class="line">dat&lt;-read.csv(<span class="string">&quot;mice_pheno.csv&quot;</span>)</span><br><span class="line">chowPopulation&lt;-dat[dat$Sex==<span class="string">&quot;F&quot;</span>&amp;dat$Diet==<span class="string">&quot;chow&quot;</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">mu_chow&lt;-mean(chowPopulation)</span><br><span class="line">print(mu_chow)</span><br><span class="line"><span class="comment">## [1] 23.89338</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##我们是要估计这个参数，但是我们实际拿不到总体的数据</span></span><br><span class="line"><span class="comment">## 先抽取样本量为30的样本</span></span><br><span class="line"></span><br><span class="line">N&lt;-<span class="number">30</span></span><br><span class="line">chow&lt;-sample(chowPopulation,N)</span><br><span class="line">print(mean(chow))</span><br><span class="line"><span class="comment">## [1] 24.54567</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#我们知道样本均值是一个随机变量</span></span><br><span class="line"><span class="comment">#所以，这个值不是一个完美的估计</span></span><br><span class="line"><span class="comment">#通过置信区间来体现这个随机变量的variability</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#因为样本量为30，我们可以使用CLT。</span></span><br><span class="line"><span class="comment">#中心极限定理告诉我们，样本均值服从一个均值为总体均值，标准差为总体标准差除以根号30的正态分布。</span></span><br><span class="line"></span><br><span class="line">se&lt;-sd(chow)/<span class="built_in">sqrt</span>(N)</span><br><span class="line">print(se)</span><br><span class="line"><span class="comment">## [1] 0.6610814</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>A 95% confidence interval (we can use percentages other than 95%) is a random interval with a95% probability of falling on the parameter we are estimating. Keep in mind that saying 95% ofrandom intervals will fall on the true value (our definition above) isnot the sameas saying there isa 95% chance that the true value falls in our interval.(有点绕，没太懂。懂了，这个置信区间其实也是一个随机变量，你再抽一个样，这个置信区间也会变。所以你只能说置信区间（随机变量）从统计上说有95%的概率包含真值（你要是取10000个样本，计算出10000个置信区间，其中包含总体均值的概率在95%左右）。但是，如果是一个给定的区间(你最后计算出来的区间)，那么真值存在这个区间的概率只有0和1)</p>
</blockquote>
<p>由中心极限定理，我们可以对样本均值进行标准化。然后我们知道标准正态分布的95%区间大致在[-2,2]。因此可以得出下式</p>
<p><img src="confidence_interval.png" alt="confidence_interval"></p>
<p>我们直接得出置信区间</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Q&lt;-qnorm(<span class="number">1</span>-<span class="number">0.05</span>/<span class="number">2</span>)</span><br><span class="line">interval&lt;-<span class="built_in">c</span>(mean(chow)-Q*se, mean(chow)+Q*se )</span><br><span class="line">interval</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>模拟n次置信区间</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(rafalib)</span><br><span class="line">B&lt;-<span class="number">250</span></span><br><span class="line">mypar()</span><br><span class="line">plot(mean(chowPopulation)+<span class="built_in">c</span>(-<span class="number">7</span>,<span class="number">7</span>),<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>),type=<span class="string">&quot;n&quot;</span>,</span><br><span class="line">	xlab=<span class="string">&quot;weight&quot;</span>,ylab=<span class="string">&quot;interval&quot;</span>,ylim=<span class="built_in">c</span>(<span class="number">1</span>,B))</span><br><span class="line">	abline(v=mean(chowPopulation))</span><br><span class="line">	<span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:B) &#123;</span><br><span class="line">	chow&lt;-sample(chowPopulation,N)</span><br><span class="line">	se&lt;-sd(chow)/<span class="built_in">sqrt</span>(N)</span><br><span class="line">	interval&lt;-<span class="built_in">c</span>(mean(chow)-Q*se, mean(chow)+Q*se)</span><br><span class="line">	covered&lt;-</span><br><span class="line">		mean(chowPopulation) &lt;=interval[<span class="number">2</span>]&amp;mean(chowPopulation)&gt;=interval[<span class="number">1</span>]</span><br><span class="line">	color&lt;-ifelse(covered,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">	lines(interval, <span class="built_in">c</span>(i,i),col=color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个代码画出了250次置信区间的图（代码内容没看）。其中大概有5%的置信区间没有包含总体均值。</p>
<p>但是上面是因为抽样个体较多（N = 30），满足了中心极限定理。如果 N = 5，那么这样做也有效吗？我们就模拟这种N =5，使用CLT的情况。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N &lt;- 5</span><br><span class="line">mypar()</span><br><span class="line">plot(mean(chowPopulation)+<span class="built_in">c</span>(-<span class="number">7</span>,<span class="number">7</span>),<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>),type=<span class="string">&quot;n&quot;</span>,</span><br><span class="line">     xlab=<span class="string">&quot;weight&quot;</span>,ylab=<span class="string">&quot;interval&quot;</span>,ylim=<span class="built_in">c</span>(<span class="number">1</span>,B))</span><br><span class="line">abline(v=mean(chowPopulation))</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:B)&#123;</span><br><span class="line">  chow&lt;-sample(chowPopulation,N)</span><br><span class="line">  se&lt;-sd(chow)/<span class="built_in">sqrt</span>(N)</span><br><span class="line">  interval&lt;-<span class="built_in">c</span>(mean(chow)-Q*se, mean(chow)+Q*se)</span><br><span class="line">  covered&lt;- mean(chowPopulation) &lt;=interval[<span class="number">2</span>]&amp;mean(chowPopulation)&gt;=interval[<span class="number">1</span>]</span><br><span class="line">  color &lt;- ifelse(covered,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">  lines(interval, <span class="built_in">c</span>(i,i),col=color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们发现置信区间的宽度增加了，但是没有覆盖真值的情况却多了很多。这是因为这里我们通过CLT错误地认为样本均值符合正态分布，但是实际上相较于正态它两侧的尾巴更大（It has a fatter tail）。这影响到了我们Q值的计算（这里是-2到2）。这种情况下，采用t分布更合适。所以我们只需用qt() 函数来计算Q就可以了，其它不变。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N &lt;- 5</span><br><span class="line">Q&lt;-qt(<span class="number">1</span>-<span class="number">0.05</span>/<span class="number">2</span>, df=<span class="number">4</span>)</span><br><span class="line">mypar()</span><br><span class="line">plot(mean(chowPopulation)+<span class="built_in">c</span>(-<span class="number">7</span>,<span class="number">7</span>),<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>),type=<span class="string">&quot;n&quot;</span>,</span><br><span class="line">     xlab=<span class="string">&quot;weight&quot;</span>,ylab=<span class="string">&quot;interval&quot;</span>,ylim=<span class="built_in">c</span>(<span class="number">1</span>,B))</span><br><span class="line">abline(v=mean(chowPopulation))</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:B)&#123;</span><br><span class="line">  chow&lt;-sample(chowPopulation,N)</span><br><span class="line">  se&lt;-sd(chow)/<span class="built_in">sqrt</span>(N)</span><br><span class="line">  interval&lt;-<span class="built_in">c</span>(mean(chow)-Q*se, mean(chow)+Q*se)</span><br><span class="line">  covered&lt;- mean(chowPopulation) &lt;=interval[<span class="number">2</span>]&amp;mean(chowPopulation)&gt;=interval[<span class="number">1</span>]</span><br><span class="line">  color &lt;- ifelse(covered,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">  lines(interval, <span class="built_in">c</span>(i,i),col=color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们看到置信区间的宽度<strong>进一步</strong>（相较于CLT）增加了（因为t分布尾巴厚，得到的Q值更大），但是基本符合了95%的概率。</p>
<h3 id="置信区间和P值的关系">置信区间和P值的关系</h3>
<p>我们推荐在实际中更多的使用置信区间，而不是P值。</p>
<p>如果你给出P值，我们会问差距是不是真的像你计算或观测出来的值那么大。<strong>因为即便两个群体总体均值为0，得到的样本均值差也有可能出现你计算或观测的结果</strong>。因此，我们可以给出均值差的置信区间，来回答这个问题。</p>
<p>如果均值差的95%的置信区间中不包含0，那么我们可以说差异不显著（0.05水平下），也就是p值肯定小于0.05。（99%的置信区间类似）</p>
<p>t.test的结果中包含了95%的置信区间。</p>
<h3 id="Power-Calculations">Power Calculations</h3>
<p>由于我们有总体信息，我们从总体信息中可以直接得知，这两个群体确实是有差距的，而且按比例大约是10%。<br>
但是我们如果从中取样，然后进行t-test，有的时候P值不总是小于0.05。</p>
<p>所以我们犯错了吗？通过不拒绝原假设，我们要说diet没有影响吗？这个问题的答案是no。All we can say is that we did not reject the null hypothesis. But this does not necessarily imply that the null is true（我们只是说不拒绝原假设，但我们没有说原假设是真的）.</p>
<p>这个问题的本质是这样，在这次的实例中，我们没有得到足够的power（不知道啥意思）。在科学研究中，你很可能需要做某种程度的power calculation。在很多情况下，这是一种道德义务，来避免不必要地牺牲更多小鼠，或者使人们因为你的研究遭遇潜在的风险。</p>
<h4 id="types-of-error">types of error</h4>
<blockquote>
<p>Ⅰ型错误：原假设为真，我们拒绝的概率，等于P值<br>
Ⅱ型错误：原假设为假，没有拒绝原假设的概率</p>
</blockquote>
<p>当我们在进行统计检验时，我们始终需要注意我们很可能会犯错误。这就是为什么我们的p值不是0。在原假设成立的前提下，总是存在一个可能很少，但是可能发生的概率，使得我们拒绝了正确的原假设。如果P值设为0.05，那么这种情况发生的概率也就是0.05。这种错误叫做Ⅰ型错误（typeⅠerror）</p>
<p>Ⅰ型错误会发生<strong>假阳性</strong>。那么我们为什么只设为0.05？不设定一个非常小的值呢？因为还存在另外一种错误，Ⅱ型错误，即原假设为假，没有拒绝原假设的概率，这会造成<strong>假阴性</strong>。像上面我们提到的那种情况，就是犯了二型错误。如果我们把P值提高到0.25，那么上面的例子就能够显著。但是一般情况下我们愿不愿意提高P值到0.25呢？通常我们不会这么做。</p>
<h4 id="0-05或0-01-的-p值-是随意划分的（The-0-05-and-0-01-Cut-offs-Are-Arbitrary）">0.05或0.01 的 p值 是随意划分的（The 0.05 and 0.01 Cut-offs Are Arbitrary）</h4>
<p>很多杂志和监管部门强调要达到0.05或0.01水平的显著。但是这两个数字的设定其实没有特别的，这仅仅是因为最开始的文章用这两个数字作为例子而已。本书的部分目的之一就是让读者对于P值和置信区间有一个更加清晰的认识（受教了）。</p>
<h4 id="Power-Calculation">Power Calculation</h4>
<p>Power is the probability of rejecting the null when the null is false（Power 是指当原假设为假时拒绝原假设的概率）。</p>
<p>下面我们通过R中的实际代码去理解这个概念。</p>
<p>我们仍然假设样本大小为12，显著水平时0.05。由于我们已经两个群体均值有差异，我们可以重复抽样，看每次抽样t检验是否小于0.05</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N&lt;-12</span><br><span class="line">alpha&lt;-0.05</span><br><span class="line">B&lt;-2000</span><br><span class="line"></span><br><span class="line">reject&lt;-function(N, alpha&#x3D;0.05)&#123;</span><br><span class="line">	hf&lt;-sample(hfPopulation,N)</span><br><span class="line">	control&lt;-sample(controlPopulation,N)</span><br><span class="line">	pval&lt;-t.test(hf,control)$p.value</span><br><span class="line">	pval&lt;alpha</span><br><span class="line">&#125;</span><br><span class="line">#reject 给出一次抽样是否小于0.05</span><br><span class="line"></span><br><span class="line">reject(12)</span><br><span class="line">## [1] FALSE</span><br><span class="line"></span><br><span class="line">rejections &lt;- replicate(B,reject(N))</span><br><span class="line">#重复2000次，replicate(n,expr) </span><br><span class="line"></span><br><span class="line">mean(rejetions) # 这就是N&#x3D;12时Power的值</span><br><span class="line">## [1] 0.2215</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这就是为什么当我们知道原假设是错的时，t-test却没有拒绝原假设。当样本大小只有12时，power只有23%。为了降低<strong>假阳性</strong>发生的概率，我们将P值设在0.05水平。其实这个水平有点过高，导致发生<strong>Ⅱ型错误</strong>的概率大大提高。</p>
<blockquote>
<p>power 和 发生Ⅱ型的概率 相加为1。power低，说明发生Ⅱ型错误的概率高。</p>
</blockquote>
<p>接下来，让我们来看看power和抽样大小N的关系。这里我们用到了<strong>sapply(Ns,expr)</strong>，这个函数会对向量中的每一个数执行同样的function。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Ns&lt;-seq(<span class="number">5</span>,<span class="number">50</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># So we use apply() like this</span></span><br><span class="line">power&lt;-sapply(Ns,<span class="keyword">function</span>(N)&#123;</span><br><span class="line">	rejections&lt;-replicate(B, reject(N))</span><br><span class="line">	mean(rejections)</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">plot(Ns,power,type = <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看出，随着N的增加，power不断提高。</p>
<p>我们固定N，看一看alpha的设定对power 的影响</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N&lt;-<span class="number">30</span></span><br><span class="line">alphas&lt;-<span class="built_in">c</span>(<span class="number">0.1</span>,<span class="number">0.05</span>,<span class="number">0.01</span>,<span class="number">0.001</span>,<span class="number">0.0001</span>)</span><br><span class="line">power&lt;-sapply(alphas,<span class="keyword">function</span>(alpha)&#123;</span><br><span class="line">	rejections &lt;- replicate(B,reject(N,alpha=alpha))</span><br><span class="line">	mean(rejections)</span><br><span class="line">&#125;)</span><br><span class="line">plot(alphas, power, xlab=<span class="string">&quot;alpha&quot;</span>, type=<span class="string">&quot;b&quot;</span>, <span class="built_in">log</span>=<span class="string">&quot;x&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看出随着alpha的增加，power也在不断增加。</p>
<blockquote>
<p>There is no “right” power or “right” alpha level, but it is important that you understand what eachmeans.</p>
</blockquote>
<h5 id="p-values-are-Arbitrary-under-the-Alternative-Hypothesis">p-values are Arbitrary under the Alternative Hypothesis</h5>
<blockquote>
<p>Another consequence of what we have learned about power is that p-values are somewhat arbitrarywhen the null hypothesis is not true and therefore thealternativehypothesis is true (the differencebetween the population means is not zero). When the alternative hypothesis is true, we can make a p-value as small as we want simply by increasing the sample size (supposing that we have an infinitepopulation to sample from). We can show this property of p-values by drawing larger and largersamples from our population and calculating p-values. This works because, in our case, we knowthat the alternative hypothesis is true, since we have access to the populations and can calculate thedifference in their means.</p>
</blockquote>
<p>随着样本大小的增加，P值会减小（假设群体无限大）。证明如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">calculatePvalue&lt;-<span class="keyword">function</span>(N) &#123;</span><br><span class="line">	hf&lt;-sample(hfPopulation,N)</span><br><span class="line">	control&lt;-sample(controlPopulation,N)</span><br><span class="line">	t.test(hf,control)$p.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ns&lt;-seq(<span class="number">10</span>,<span class="number">200</span>,by=<span class="number">10</span>)</span><br><span class="line">Ns_rep&lt;-<span class="built_in">rep</span>(Ns, each=<span class="number">10</span>) <span class="comment">#each 的形式是 10 10 10…… 20 ……</span></span><br><span class="line"></span><br><span class="line">pvalues&lt;-sapply(Ns_rep, calculatePvalue)</span><br><span class="line"></span><br><span class="line">plot(Ns_rep, pvalues, <span class="built_in">log</span>=<span class="string">&quot;y&quot;</span>, xlab=<span class="string">&quot;sample size&quot;</span>,</span><br><span class="line">ylab=<span class="string">&quot;p-values&quot;</span>)</span><br><span class="line">abline(h=<span class="built_in">c</span>(<span class="number">.01</span>,<span class="number">.05</span>), col=<span class="string">&quot;red&quot;</span>, lwd=<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>样本量从10增加到200的过程中，p值最低下降到了10^-8^。但是p值太低也不见得是一件很好的事。一旦我们确信了一个reasonable alpha（比如0.05），那么如果我们获得了一个比这个阈值低得多的p值，那就说明<strong>我们用了过量的小鼠</strong>。适当地提高样本量，确实有助于估计的准确性。但是，实际上，随着样本量的增加p值的降低是一件自然的事。</p>
<blockquote>
<p>The p-values get smaller and smaller with increasing sample size because the numerator ofthe t-statistic haspN(for equal sized groups, and a similar effect occurs whenM̸=N). Therefore,if∆is non-zero, the t-statistic will increase with N.</p>
</blockquote>
<p>事实上，随着样本量的增加，t-test得到的p值也会不断降低。这是t统计量中有一个根号N。</p>
<p>算了个Cohen’s d，但没看懂这个统计量到底有啥用？</p>
<blockquote>
<p>This tells us how many standard deviations of the data the mean of the high-fat diet group is from the control group. Under the alternative hypothesis, unlike the t-statistic which is guaranteed to increase, the effect size and Cohen’s d will become more precise.（看不懂）</p>
</blockquote>
<h3 id="Monte-Carlo-Simulation">Monte Carlo Simulation</h3>
<p>电脑可以用来产生伪随机数（pseudo-random numbers），一个最大的好处是我们可以通过模拟数据来证明我们的假设或理论。</p>
<blockquote>
<p>伪随机性（英语：Pseudorandomness）是一个过程似乎是随机的，但实际上并不是。例如伪随机数是使用一个确定性的算法计算出来的似乎是随机的数序，因此伪随机数实际上并不随机。在计算伪随机数时假如使用的开始值不变的话，那么伪随机数的数序也不变。</p>
</blockquote>
<p>Simulations can also be used to check theoretical or analytical results. Also, many of the theoretical results we use in statistics are based on <strong>asymptotics</strong>: they hold when the sample size goes to <a href="http://infinity.In">infinity.In</a> practice, we never have an infinite number of samples so we may want to know how well thetheory works with our actual sample size.</p>
<p>作为例子，我们蒙特卡洛模拟（ Monte Carlo simulation）来比较不同样本大小的情况下CLT和t分布的近似值。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(dplyr)</span><br><span class="line">dat&lt;-read.csv(<span class="string">&quot;mice_pheno.csv&quot;</span>)<span class="comment">#Previously downloaded</span></span><br><span class="line">controlPopulation&lt;-filter(dat,Sex==<span class="string">&quot;F&quot;</span>&amp;Diet==<span class="string">&quot;chow&quot;</span>)%&gt;%select(Bodyweight)%&gt;%unlist</span><br><span class="line"></span><br><span class="line">ttestgenerator&lt;-<span class="keyword">function</span>(n) &#123;</span><br><span class="line">  <span class="comment">#note that here we have a false &quot;high fat&quot; group where we actually</span></span><br><span class="line">  <span class="comment">#sample from the nonsmokers. this is because we are modeling the *null*</span></span><br><span class="line">  cases&lt;-sample(controlPopulation,n)</span><br><span class="line">  controls&lt;-sample(controlPopulation,n)</span><br><span class="line">  tstat&lt;-(mean(cases)-mean(controls))/<span class="built_in">sqrt</span>( var(cases)/n+var(controls)/n ) <span class="comment">#这个t统计量是假设两个群体方差不等</span></span><br><span class="line">  <span class="built_in">return</span>(tstat)</span><br><span class="line">  &#125;</span><br><span class="line">ttests&lt;-replicate(<span class="number">1000</span>, ttestgenerator(<span class="number">10</span>))</span><br><span class="line">hist(ttests)</span><br></pre></td></tr></table></figure>
<p>从直方图中，我们近似看出符合正态分布。但是从上文提到，我们再看一下QQ图</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qqnorm(ttests)</span><br><span class="line">qqline(ttests)</span><br></pre></td></tr></table></figure>
<p>从QQ图中，可以看出近似符合正态分布。这说明在样本数是10的情况下，已经符合正态分布，可以使用中心极限定理了。那么如果样本数为3呢？</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ttests&lt;-replicate(<span class="number">1000</span>, ttestgenerator(<span class="number">3</span>))</span><br><span class="line">qqnorm(ttests)</span><br><span class="line">qqline(ttests)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Now we see that the large quantiles, referred to by statisticians as the tails, are larger than expected(below the line on the left side of the plot and above the line on the right side of the plot).</p>
</blockquote>
<p>我们可以看出QQ图中左侧低于直线，右侧高于直线。这说明两侧的尾巴比正态分布要肥。</p>
<p>在之前的章节中，我们提到，如果<strong>样本数不大</strong> 并且 <strong>总体符合正态分布</strong> ，那么使用t分布是一种更好的近似。证明如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ps&lt;-(seq(<span class="number">0</span>,<span class="number">999</span>)+<span class="number">0.5</span>)/<span class="number">1000</span> <span class="comment">#0到1的均匀分布</span></span><br><span class="line">qqplot(qt(ps,df=<span class="number">2</span>*<span class="number">3</span>-<span class="number">2</span>),ttests,xlim=<span class="built_in">c</span>(-<span class="number">6</span>,<span class="number">6</span>),ylim=<span class="built_in">c</span>(-<span class="number">6</span>,<span class="number">6</span>))</span><br><span class="line"><span class="comment"># qt获得某t分布累积概率的数值</span></span><br><span class="line"><span class="comment"># qqplot比较两个变量分布是否相同</span></span><br><span class="line">abline(<span class="number">0</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>从中我们可以看出，t分布在这种情况下更为近似，但是仍不完美。这是因为<strong>总体并不是很好地符合正态分布</strong>。(从下面总体的QQ图中看出，总体略偏)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qqnorm(controlPopulation)</span><br><span class="line">qqline(controlPopulation)</span><br></pre></td></tr></table></figure>
<h3 id="Parametric-Simulations-for-the-Observations">Parametric Simulations for the Observations</h3>
<p>我们再这里使用蒙特卡洛模拟随机变量和假设检验，这是因为我们有总体数据。这是为了教学的作用，但在实际运用中是不可能的。一般采用蒙特卡洛模拟，主要用于参数估计（如均值和标准差）。</p>
<p>以小鼠体重的例子来说，我们通过先验知识，认识到小鼠的体重均值为24盎司，标准差为3.5盎司，而且小鼠体重近似符合正态分布。通过以上信息，我们可以构建一个总体数据。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">controls&lt;-rnorm(<span class="number">5000</span>, mean=<span class="number">24</span>, sd=<span class="number">3.5</span>)</span><br></pre></td></tr></table></figure>
<p>由于我们可以重复上述操作。因此我们不需要用到sample()函数了。代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ttestgenerator&lt;-function(n, mean&#x3D;24, sd&#x3D;3.5) &#123;</span><br><span class="line">  cases&lt;-rnorm(n,mean,sd)</span><br><span class="line">  controls&lt;-rnorm(n,mean,sd)</span><br><span class="line">  tstat&lt;-(mean(cases)-mean(controls))&#x2F;sqrt( var(cases)&#x2F;n+var(controls)&#x2F;n )</span><br><span class="line">  return(tstat)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Permutation-Tests">Permutation Tests</h3>
<p>假设我们遇到这样一种情况，没有一种标准的统计量能近似模拟我们的数据。</p>
<p>We have computed a summary statistic, such as the difference in mean, but do not have auseful approximation, such as that provided by the CLT.</p>
<p>这个时候 Permutation Tests 就派上用场了。</p>
<p>让我们回到最开始拿到的样本</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dat=read.csv(<span class="string">&quot;femaleMiceWeights.csv&quot;</span>)</span><br><span class="line">library(dplyr)</span><br><span class="line">control&lt;-filter(dat,Diet==<span class="string">&quot;chow&quot;</span>)%&gt;%select(Bodyweight)%&gt;%unlist</span><br><span class="line">treatment&lt;-filter(dat,Diet==<span class="string">&quot;hf&quot;</span>)%&gt;%select(Bodyweight)%&gt;%unlist</span><br><span class="line">obsdiff&lt;-mean(treatment)-mean(control)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>In previous sections, we showed parametric approaches that helped determine if the observeddifference was significant. Permutation tests take advantage of the fact that if we randomly shufflethe cases and control labels, then the null is true. So we shuffle the cases and control labels andassume that the ensuing distribution approximates the null distribution. Here is how we generate anull distribution by shuffling the data 1,000 times:</p>
</blockquote>
<p>这段话的大意是，之前我们是用带参数的方法（均值，标准差）检验差异是否显著。而这个Permutation tests 认为，如果我们随机洗牌 cases 和 control 的标签，那么零假设应该是正确的。<br>
下面我们洗牌了1000次。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N&lt;-<span class="number">12</span></span><br><span class="line">avgdiff&lt;-replicate(<span class="number">1000</span>, &#123;</span><br><span class="line">  <span class="built_in">all</span>&lt;-sample(<span class="built_in">c</span>(control,treatment))</span><br><span class="line">  newcontrols&lt;-<span class="built_in">all</span>[<span class="number">1</span>:N]</span><br><span class="line">  newtreatments&lt;-<span class="built_in">all</span>[(N+<span class="number">1</span>):(<span class="number">2</span>*N)]</span><br><span class="line">  <span class="built_in">return</span>(mean(newtreatments)-mean(newcontrols))</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">#这个&#123;&#125;好像是不带名称的函数，类似于Python中的lambda</span></span><br><span class="line"><span class="comment">#sample(x)不加n,就是重排（permutation）的意思</span></span><br><span class="line">hist(avgdiff)</span><br><span class="line">abline(v=obsdiff, col=<span class="string">&quot;red&quot;</span>, lwd=<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>How many of the null means are bigger than the observed value? That proportion would be thep-value for the null. We add a 1 to the numerator and denominator to account for misestimation ofthe p-value</p>
</blockquote>
<p>在这1000次中，有多少比例大于这个obsdiff，这就是P值。但是，分子分母要都加上一个1。（个人理解实际上是做了1001次，没有算上真实情况）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">sum</span>(<span class="built_in">abs</span>(avgdiff)&gt;<span class="built_in">abs</span>(obsdiff))+<span class="number">1</span>)/(<span class="built_in">length</span>(avgdiff)+<span class="number">1</span>)</span><br><span class="line"><span class="comment">## [1] 0.05594406</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在我们把这个用在样本量更小的数据集，比如样本量为5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N&lt;-5</span><br><span class="line">control&lt;-sample(control,N)</span><br><span class="line">treatment&lt;-sample(treatment,N)</span><br><span class="line">obsdiff&lt;-mean(treatment)-mean(control)</span><br><span class="line"></span><br><span class="line">avgdiff&lt;-replicate(1000, &#123;</span><br><span class="line">  all&lt;-sample(c(control,treatment))</span><br><span class="line">  newcontrols&lt;-all[1:N]</span><br><span class="line">  newtreatments&lt;-all[(N+1):(2*N)]</span><br><span class="line">  return(mean(newtreatments)-mean(newcontrols))</span><br><span class="line">&#125;)</span><br><span class="line">hist(avgdiff)</span><br><span class="line">abline(v&#x3D;obsdiff, col&#x3D;&quot;red&quot;, lwd&#x3D;2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在可以明显看出差距不显著了。</p>
<blockquote>
<p>Now the observed difference is not significant using this approach. Keep in mind that there is notheoretical guarantee that the null distribution estimated from permutations approximates the actualnull distribution. For example, if there is a real difference between the populations, some of the permutations will be unbalanced and will contain some samples that explain this difference. This implies that the null distribution created with permutations will have larger tails than the actualnull distribution. This is why permutations result in conservative p-values. For this reason, whenwe have few samples, we can’t do permutations.</p>
</blockquote>
<p>没看懂，结论是数据量小时，不用这种permutation test</p>
<p>而且permutation test 也有假设：<strong>:samples are assumed to be independentand “exchangeable”</strong> 。 If there is hidden structure in your data, then permutation tests can result in estimated null distributions that underestimate the size of tails because the permutations may destroy the existing structure in the original data.</p>
<h3 id="Association-Tests">Association Tests</h3>
<p>前面的统计分析中，忽略了一类重要的数据，二元或者说分类数据。举个例子，当你有两种疾病的基因型的群体(AA/Aa 与 aa)作为cases 和 control。我们要提出的问题是，这个基因型与疾病是否有关系。<br>
这里疾病状况表示为0和1，那么我们为什么不能用t-test？因为数据要么是0要么是1，很明显不会符合正态分布，因此不能使用t-test。</p>
<p>如果样本数量很大的话，我们可以使用CLT。不然的话，我们就可以使用Association Tests。</p>
<h4 id="二项分布与超几何分布">二项分布与超几何分布</h4>
<p>解释: 我的这种算法是基于二项分布，而Fisher’s exact test是基于超几何分布（hypergeometric distribution）。<br>
二项分布</p>
<ol>
<li>试验次数固定</li>
<li>每一次事件都有两个可能的结果</li>
<li><strong>每次试验中的事件相互独立</strong></li>
<li><strong>每一次成功的概率相等</strong></li>
</ol>
<p>超几何分布 它描述了由<strong>有限个物件中</strong>抽出n个物件，成功抽出指定种类的物件的个数（不归还 （without replacement））。</p>
<p>例如在有N个样本，其中K个是不及格的。超几何分布描述了在该N个样本中抽出n个，其中k个是不及格的概率。</p>
<p>特点：</p>
<ol>
<li>每次抽取也只有两个互斥的结果</li>
<li><strong>每次抽取后成功的概率发生改变</strong>（因为是不放回抽样，这也导致了每次抽取事件不独立）</li>
</ol>
<h4 id="Lady-Tasting-Tea">Lady Tasting Tea</h4>
<p>R.A.Fisher 的一位熟人宣称她能分辨牛奶是早于或晚于茶放入杯中（就是牛奶和茶混合的顺序）。Fisher 就和她做了一个小实验，4次中对了3次。那么，我们能否说明这位女士存在这种特殊的能力呢？这个例子被称为&quot;Lady tasting tea&quot;。<br>
按照之前的经验。一个基本的问题是，如果这位女士仅仅靠猜，她能得到3/4或更高的正确率(即3/4+4/4)的概率是多少？<br>
仍和之前一样，我们需要计算在零假设成立的前提下事情发生的概率。这里的零假设就是这位女士都是猜的。</p>
<blockquote>
<p>he basic question we ask is: if the tester is actually guessing, what are the chances that she gets 3 ormore correct? Just as we have done before, we can compute a probability under the null hypothesisthat she is guessing four of each. If we assume this null hypothesis, we can think of this particularexamples as picking 4 balls out of an urn with 4 green (correct answer) and 4 red (incorrect answer)balls.</p>
</blockquote>
<blockquote>
<p>Under the null hypothesis that she is simply guessing, each ball has the same chance of beingpicked. We can then use combinatorics to figure out each probability. The probability of picking3 is(43)(41)/(84)= 16/70. The probability of picking all 4 correct is(44)(40)/(84)= 1/70. Thus, thechance of observing a 3 or something more extreme, under the null hypothesis, is 0.24. This isthe p-value. The procedure that produced this p-value is calledFisher’s exact testand it uses the hypergeometric distribution.</p>
</blockquote>
<p>它这种算法是8个球里摸4个。我的算法是每次猜对的概率是0.5，那么4次猜对3次的概率是4*0.5^3^*0.5=0.25。这两种结果不一样，我也搞不太清楚。</p>
<p>这里算错了，除了不清晰二项分布与超几何分布，还有一个原因，不清楚这个Lady tasting tea试验。在这个试验中，Fisher准备了8杯茶，每一种（tea first or milk first）都准备了4杯，并且随机拜放位置。试验者需挑出按其中一种方法泡制的4杯。</p>
<p>按Fisher’s exact test 只有当这位女士把4杯都挑出来（p=1/70），他才会承认她有这种能力（但是不能量化）。哪怕如题所示，她挑出来了3杯（p=16/70+1/70=17/70），P值也是不显著。</p>
<blockquote>
<p>当样本量更大时，也可以使用卡方分布。但是，当样本数目很少或数据分布极不平衡（如果某个cell的数目小于5 或小于10）时，卡方分布的估计是不充分的。而与之相反，Fisher 精确检验，正如它的名称，不论样本如何都能保持精确。但是当样本量很大或非常平衡，Fisher 精确检验计算不方便，这时就需要用到卡方分布。</p>
</blockquote>
<p>公式如下：<br>
<img src="Fisher's_exact_test.png" alt="Fisher's_exact_test"></p>
<p>小结：<br>
Fisher 精确检验使用于<strong>检验两个分类变量是否相关</strong>。</p>
<ul>
<li>Fisher 精确检验：适合样本小或不平衡数据</li>
<li>卡方检验：适合样本大、平衡数据</li>
</ul>
<h4 id="Two-By-Two-Tables">Two By Two Tables</h4>
<p>The data from the experiment above can be summarized by a 2 by 2 table:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tab&lt;-matrix(c(3,1,1,3),2,2)</span><br><span class="line">rownames(tab)&lt;-c(&quot;Poured Before&quot;,&quot;Poured After&quot;)</span><br><span class="line">colnames(tab)&lt;-c(&quot;Guessed before&quot;,&quot;Guessed after&quot;)</span><br><span class="line">tab</span><br><span class="line">#The function fisher.test performs the calculations above and can be obtained like this:</span><br><span class="line">fisher.test(tab,alternative&#x3D;&quot;greater&quot;)</span><br><span class="line">##</span><br><span class="line">##Fisher&#39;s Exact Test for Count Data</span><br><span class="line">##</span><br><span class="line">## data:  tab</span><br><span class="line">## p-value &#x3D; 0.2429</span><br><span class="line">## alternative hypothesis: true odds ratio is greater than 1</span><br><span class="line">## 95 percent confidence interval:</span><br><span class="line">##  0.3135693Inf</span><br><span class="line">## sample estimates:</span><br><span class="line">## odds ratio</span><br><span class="line">##   6.408309</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Fisher-精确检验的争议">Fisher 精确检验的争议</h4>
<p>很多人争论Fisher 精确检验结果保守。它的真实的拒绝概率低于名义上的显著水平。The apparent contradiction stems from the combination of a discrete statistic with fixed significance levels.（最明显的矛盾在于它计算出的统计量是分散的，但是显著水平是固定的，如0.05）（如上例，可能出现的P值只有5个（0，1，2，3，4杯））。To avoid the problem, many authors discourage the use of fixed significance levels when dealing with discrete problems.</p>
<h4 id="Chi-square-Test">Chi-square Test</h4>
<p>假设我们有250个个体，其中一部分患有疾病。我们观测到aa基因型的个体中有20%患病；其他基因型的个体中患病比例为10%。如果我们再挑250个个体这种现象会再次发生吗？（这个提问方式等同于问这个位点是否与疾病相关）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">disease=factor(<span class="built_in">c</span>(<span class="built_in">rep</span>(<span class="number">0</span>,<span class="number">180</span>),<span class="built_in">rep</span>(<span class="number">1</span>,<span class="number">20</span>),<span class="built_in">rep</span>(<span class="number">0</span>,<span class="number">40</span>),<span class="built_in">rep</span>(<span class="number">1</span>,<span class="number">10</span>)),labels=<span class="built_in">c</span>(<span class="string">&quot;control&quot;</span>,<span class="string">&quot;cases&quot;</span>))</span><br><span class="line">genotype=factor(<span class="built_in">c</span>(<span class="built_in">rep</span>(<span class="string">&quot;AA/Aa&quot;</span>,<span class="number">200</span>),<span class="built_in">rep</span>(<span class="string">&quot;aa&quot;</span>,<span class="number">50</span>)),levels=<span class="built_in">c</span>(<span class="string">&quot;AA/Aa&quot;</span>,<span class="string">&quot;aa&quot;</span>))</span><br><span class="line">dat&lt;-data.frame(disease, genotype)</span><br><span class="line">dat&lt;-dat[sample(nrow(dat)),]<span class="comment">#shuffle them up</span></span><br><span class="line">head(dat)</span><br><span class="line"></span><br><span class="line"><span class="comment">###统计频数</span></span><br><span class="line">table(genotype)</span><br><span class="line">table(disease)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 双因素统计频数，建立一个2*2表</span></span><br><span class="line">tab &lt;- table(genotype,disease)</span><br><span class="line">tab</span><br><span class="line"><span class="comment">##disease</span></span><br><span class="line"><span class="comment">## genotype control cases</span></span><br><span class="line"><span class="comment">##    AA/Aa     180    20</span></span><br><span class="line"><span class="comment">##    aa		 40    10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里最典型的统计量就是the odds ratio(OR)。). We compute the oddsof having the disease if you are an “aa”: 10/40, the odds of having the disease if you are an “AA/Aa”:20/180, and take the ratio:(10/40)/(20/180)</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">(tab[<span class="number">2</span>,<span class="number">2</span>]/tab[<span class="number">2</span>,<span class="number">1</span>])/(tab[<span class="number">1</span>,<span class="number">2</span>]/tab[<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line"><span class="comment">## [1] 2.25</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了计算P值，我们不直接使用OR。我们假设基因型和疾病没有关系，然后计算出每个cell的期望值。在零假设下，两种基因型的200个体和50个体，患病的概率是相同的。</p>
<p>首先，我们得到群体（200+50=250）的患病概率为</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">p=mean(disease==<span class="string">&quot;cases&quot;</span>)</span><br><span class="line">p</span><br><span class="line"><span class="comment">## [1] 0.12</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此，各cell 的期望值为</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">expected&lt;-rbind(<span class="built_in">c</span>(<span class="number">1</span>-p,p)*<span class="built_in">sum</span>(genotype==<span class="string">&quot;AA/Aa&quot;</span>),<span class="built_in">c</span>(<span class="number">1</span>-p,p)*<span class="built_in">sum</span>(genotype==<span class="string">&quot;aa&quot;</span>))</span><br><span class="line"><span class="built_in">dimnames</span>(expected)&lt;-<span class="built_in">dimnames</span>(tab)</span><br><span class="line">expected</span><br><span class="line"><span class="comment">##disease</span></span><br><span class="line"><span class="comment">## genotype control cases</span></span><br><span class="line"><span class="comment">##    AA/Aa     176    24</span></span><br><span class="line"><span class="comment">##    aa		 44     6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##这里没讲清楚，直接就算出来了</span></span><br><span class="line">chisq.test(tab)$p.value</span><br><span class="line"><span class="comment">## [1] 0.08857435</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Large-Samples-Small-p-values">Large Samples, Small p-values</h4>
<p>如上所述，仅报道P值是不正确的。很多做GWAS的人过于强调P值。他们样本很大，得到的P值很小。但是如果仔细看他们的结果，我们就能看到他们的odds ratios并不高：仅仅比1高一点。在这种情况下，基因型是AA/Aa 或 aa 可能不会改变动物患病的几率，但是这些位点确实是统计意义上显著的。<br>
<strong>odds ratio 和 p-value 并没有一对一的关系</strong>（这一点很重要，这个在effect size 中也专门提到了，效应大小与是否显著没有因果关系。P值只能判断这个效应是不是出于偶然（随机误差），并不能说明效应大小）</p>
<h4 id="Confidence-Intervals-For-The-Odd-Ratio">Confidence Intervals For The Odd Ratio</h4>
<p>计算OR 的置信区间不能直接做到。不像其他统计量，它们都能推导出近似的分布。但是OR仅仅是一个比例。因此，没有简单的方法可以使用，例如CLT。</p>
<p>One approach is to use the theory ofgeneralized linear models which provides estimates of thelog odds ratio, rather than the OR itself, that can be shown to be asymptotically normal.</p>
<p>后面的没看</p>
<h2 id="Exploratory-Data-Analysis">Exploratory Data Analysis</h2>
<p>这个探索性数据分析，没太搞懂</p>
<h3 id="Quantile-Quantile-Plots">Quantile Quantile Plots</h3>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(UsingR)<span class="comment">##available from CRAN</span></span><br><span class="line">library(rafalib)</span><br><span class="line">x&lt;-father.son$fheight</span><br><span class="line"></span><br><span class="line">ps&lt;-( seq(<span class="number">0</span>,<span class="number">99</span>)+<span class="number">0.5</span>)/<span class="number">100</span> <span class="comment">#0.005 0.015 ……</span></span><br><span class="line">qs&lt;-quantile(x, ps) <span class="comment">#获得x中的各分位数</span></span><br><span class="line">normalqs&lt;-qnorm(ps, mean(x), popsd(x)) <span class="comment">#形成以x均值，总体标准差的正态分布的分位数</span></span><br><span class="line">plot(normalqs,qs,xlab=<span class="string">&quot;Normal percentiles&quot;</span>,ylab=<span class="string">&quot;Height percentiles&quot;</span>) </span><br><span class="line"><span class="comment"># 两个分位数向量的散点图即为QQ图</span></span><br><span class="line">abline(<span class="number">0</span>,<span class="number">1</span>)<span class="comment">##identity line</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>简化命令,比上面的手动画图采了更多的点，因此更加准确。<br>
其中由于x轴为标准正态分布，因此添加的qqline的截距为mean(x) , 斜率为popsd(x)</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qqnorm(x)</span><br><span class="line">qqline(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当然，我们也可以看看非正态分布的QQ图，比如t分布，样本数越少，尾巴越肥。体现在QQ图上就是左侧的极端值低于identity line，右侧的极端值高于identity line。</p>
<h3 id="Boxplots">Boxplots</h3>
<p>数据也不是都服从正态分布。比如工资，只告诉均值和标准差根本不足以表现真实情况（not neccessarily informative），因为我们没办法通过这两个参数获取工资的分布情况。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">op &lt;- par(mfrow=<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">hist(exec.pay)<span class="comment">##in UsingR package</span></span><br><span class="line">qqnorm(exec.pay)</span><br><span class="line">qqline(exec.pay)</span><br><span class="line"></span><br><span class="line"><span class="comment">#boxplot</span></span><br><span class="line">boxplot(exec.pay, ylab=<span class="string">&quot;10,000s of dollars&quot;</span>, ylim=<span class="built_in">c</span>(<span class="number">0</span>,<span class="number">400</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Scatterplots-And-Correlation">Scatterplots And Correlation</h3>
<p>上面都是单一变量。我们也经常用到双变量或者更多的变量，比如父亲和儿子的身高。可以先画一个散点图。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(UsingR)</span><br><span class="line">data(<span class="string">&quot;father.son&quot;</span>)</span><br><span class="line">x=father.son$fheight</span><br><span class="line">y=father.son$sheight</span><br><span class="line">plot(x,y,xlab=<span class="string">&quot;Father&#x27;s height in inches&quot;</span>,ylab=<span class="string">&quot;Son&#x27;s height in inches&quot;</span>,main=paste(<span class="string">&quot;correlation =&quot;</span>,<span class="built_in">signif</span>(cor(x,y),<span class="number">2</span>)))</span><br></pre></td></tr></table></figure>
<p>从图中看出一个明显的趋势：父亲的身高越高，儿子的身高也越高。一个定量的统计量就是相关系数。</p>
<h4 id="Stratification">Stratification</h4>
<p>如果我们要预测身高为72 inches 的父亲的儿子的身高，我们可以看所有身高为72 inches 的父亲的儿子的情况。因此需要对数据按父亲身高进行分层。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">groups&lt;-split(y,<span class="built_in">round</span>(x))</span><br><span class="line">boxplot(groups)</span><br><span class="line">print(mean(y[ <span class="built_in">round</span>(x)==<span class="number">72</span>]))</span><br><span class="line"><span class="comment">## [1] 70.67719</span></span><br></pre></td></tr></table></figure>
<h3 id="Bi-variate-Normal-Distribution">Bi-variate Normal Distribution</h3>
<p>对于两个均服从正态分布的变量的联合分布，我们一般可以设定当X = x时，Y的条件分布。以身高数据为例，我们给出了以下4个层次。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">groups&lt;-split(y,<span class="built_in">round</span>(x))</span><br><span class="line">op &lt;- par(mfrow=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="built_in">c</span>(<span class="number">5</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">14</span>))&#123;</span><br><span class="line">  qqnorm(groups[[i]],main=paste0(<span class="string">&quot;X=&quot;</span>,<span class="built_in">names</span>(groups)[i],<span class="string">&quot;strata&quot;</span>),</span><br><span class="line">         ylim=<span class="built_in">range</span>(y),xlim=<span class="built_in">c</span>(-<span class="number">2.5</span>,<span class="number">2.5</span>))</span><br><span class="line"><span class="comment"># groups 是一个list，用groups[[i]] 获得的是向量</span></span><br><span class="line"><span class="comment"># range() 返回一个包含最小值和最大值的向量</span></span><br><span class="line"><span class="comment"># range(1:10) ## [1]  1 10</span></span><br><span class="line"></span><br><span class="line">  qqline(groups[[i]])</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>后面的公式推导没太明白。后面对x,y进行了标准化，然后按x分组求y均值，发现y均值 与 x 呈线性关系，截距为0，斜率为标准化的y与x的相关系数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x=( x-mean(x) )/sd(x)</span><br><span class="line">y=( y-mean(y) )/sd(y)</span><br><span class="line">means=tapply(y, <span class="built_in">round</span>(x*<span class="number">4</span>)/<span class="number">4</span>, mean) <span class="comment">#按round(x*4)/4 给y 分组求均值</span></span><br><span class="line">fatherheights=<span class="built_in">as.numeric</span>(<span class="built_in">names</span>(means))</span><br><span class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">plot(fatherheights, means, ylab=<span class="string">&quot;average of strata of son heights&quot;</span>, ylim=<span class="built_in">range</span>(fatherheights))</span><br><span class="line">abline(<span class="number">0</span>, cor(x,y))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Plots-To-Avoid">Plots To Avoid</h3>
<p>画图的目的是准确而清楚地展示数据。根据 Karl 的说法，不好的画图的标准如下：</p>
<ol>
<li>Display as little information as possible.</li>
<li>Obscure what you do show (with chart junk).</li>
<li>Use pseudo-3D and color gratuitously（免费地）.</li>
<li>Make a pie chart (preferably in color and 3D).</li>
<li>Use a poorly chosen scale.</li>
<li>Ignore significant figures.</li>
</ol>
<h3 id="Pie-charts">Pie charts</h3>
<blockquote>
<p>“Pie charts are a very bad way of displaying information. The eye is good at judginglinear measures and bad at judging relative areas. A bar chart or dot chart is a preferableway of displaying this type of data.”</p>
</blockquote>
<p>饼图是一种很差劲的展示数据的方式。人眼很容易辨别线性方式，但是劣于判断相对区域。一个条形图或散点图 都是更合适的方式。</p>
<p>举例来说，你可以看着饼图，去估计某一部分对应的百分比。你会发现这很困难，除非这个比例很接近25%，50% 或 75%。</p>
<p>这里我们可以用条形图用代替，这里我们每隔10添加了一条水平线</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">pie(browsers,main=<span class="string">&quot;Browser Usage (August 2013)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#条形图</span></span><br><span class="line">barplot(browsers, main=<span class="string">&quot;Browser Usage (August 2013)&quot;</span>, ylim=<span class="built_in">c</span>(<span class="number">0</span>,<span class="number">55</span>))</span><br><span class="line">abline(h=<span class="number">1</span>:<span class="number">5</span>*<span class="number">10</span>)</span><br><span class="line">barplot(browsers, add=<span class="literal">TRUE</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过条形图和y轴的水平线，我们可以很清楚的看到每个值的比例。</p>
<p>尽量不要使用3D图像，因为3D图像添加了看图的障碍，使得更难通过肉眼辨别各项比例。</p>
<h4 id="Barplots-as-data-summaries">Barplots as data summaries</h4>
<p>当条形图用于展示百分比时，很有用。但是，条形图也会被错误地用于<strong>只有两组</strong>的比较。特别当条形图的高度表示均值，上面的小触角表示标准误（standard errors）。</p>
<blockquote>
<p>Much more informative is to summarize with a boxplot. If the number of points is small enough,we might as well add them to the plot. When the number of points is too large for us to see them,just showing a boxplot is preferable. We can even setrange=0inboxplotto avoid drawing manyoutliers when the data is in the range of millions.</p>
</blockquote>
<p>这个时候更适合用箱线图来表示。箱线图展示了更多的信息，中心、分布、离群点。而条形图只展示了均值和标准误，而标准误很大程度上和样本大小有关，和分布无关。</p>
<blockquote>
<p>Notice how much more we see here: the center, spread, range and the points themselves. In thebarplot, we only see the mean and the SE, and the SE has more to do with sample size, than withthe spread of the data.</p>
</blockquote>
<p>问题还不止如此。当数据中的离群点很大（分组数据的尾巴很大）。如下条形图，看似两组区别很大。</p>
<p><img src="barplot1.png" alt="barplot1"></p>
<p>但仔细看数据，这种区别原来主要是因为有两个很大的离群点。将数据进行log以后，更加明朗。</p>
<p>如下箱线图所示，左边为原数据，可以看出二者可能区别不大，有两个非常大的离群点。log后基本展示了基本情况。（个人感觉，那两个离群点实在太大，也可以直接剔除）</p>
<p><img src="boxplot1.png" alt="barplot1"></p>
<h4 id="Show-the-scatter-plot">Show the scatter plot</h4>
<p>很多统计分析都是证明两个变量之间存在关系。相关系数和相应的图可以展示这一点。然而，只展现回归线是不够的，因为这掩饰了散点。</p>
<h4 id="High-correlation-does-not-imply-replication">High correlation does not imply replication</h4>
<p>相关系数很高，不代表重复性很好，这一部分没看懂。之后补上</p>
<h4 id="Barplots-for-paired-data">Barplots for paired data</h4>
<p>当样本数较少且为配对实验时，通常我们会用两种颜色的条形图表示比如实验前和实验后。</p>
<p><img src="pairdata1.png" alt="barplot1"></p>
<p>但是我们有更好的办法。比如散点图，我们可以看到点都是高于identity line（这里应该是y=x）。另一种方法是直接画差值的散点图。</p>
<p><img src="pairdata2.png" alt="barplot1"></p>
<p><img src="pairdata3.png" alt="barplot1"></p>
<h4 id="Gratuitous-3D-（没有必要的3D）">Gratuitous 3D （没有必要的3D）</h4>
<p>以下是一个3D图，你会发现并不清楚。很难去确定其中某一个点对应的数值。</p>
<p>其实这只要不同的颜色来区分三条线就可以了。</p>
<p><img src="3D.png" alt="barplot1"></p>
<p><img src="3D2.png" alt="barplot1"></p>
<h4 id="Too-many-significant-digits">Too many significant digits</h4>
<p>默认情况下，我们会得到很多重要的数字，但我们不是都要放上去。从R中直接复制粘贴是很愚蠢的，这导致你最后显示的不是一张图，而更像是一张表。</p>
<h4 id="Displaying-data-well">Displaying data well</h4>
<p>展示数据的一般准则：</p>
<ul>
<li>Be accurate and clear.</li>
<li>Let the data speak.</li>
<li>Show as much information as possible, taking care not to obscure the message.</li>
<li>Science not sales: avoid unnecessary frills (esp. gratuitous 3D).<br>
(科学不是销售，避免不必要的虚架子，比如3D)</li>
<li>In tables, every digit should be meaningful. Don’t drop ending 0’s.<br>
（表格中，每一个小数位点都有意义）</li>
</ul>
<h3 id="Misunderstanding-Correlation-Advanced">Misunderstanding Correlation (Advanced)</h3>
<p>现在相关系数主要用于体现reproducibility。但是实际上，相关系数不足以体现reproducibility。</p>
<p>最坏的错误是，计算相关系数的数据不是近似服从<strong>二元正态分布</strong>。上面提到，均值，标准差，相关系数都是基于二元正态分布。但是，有很多数据不符合，如基因表达量数据，通常有很肥的右侧尾巴。</p>
<p>计算reproducibility 最直接的方式就是计算两个变量的距离。</p>
<p>The standard way to quantify reproducibility between two sets of replicated measurements, sayx1; : : : ; xnandy1; : : : ; yn, is simply to compute the distance between them。</p>
<p><img src="reproducibility1.png" alt="barplot1"></p>
<p>后面没看，也看不懂。</p>
<p>我连这里的reproducibility是什么意思都不知道。</p>
<h3 id="Robust-Summaries">Robust Summaries</h3>
<p>在分析数据的过程中，我们通常假设数据符合正态分布。但是我们收集数据的过程中，总是不可避免地加入了一些错误的数据点（离群点）。类似这种偏离很大的离群点，会导致分析结果出现很大的偏差。</p>
<p>如下例，我们在0到1之间的数据中，插入一个值为100的离群点。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">set.seed(<span class="number">1</span>)</span><br><span class="line">x=<span class="built_in">c</span>(rnorm(<span class="number">100</span>,<span class="number">0</span>,<span class="number">1</span>))<span class="comment">##real distribution</span></span><br><span class="line">x[<span class="number">23</span>]&lt;-<span class="number">100</span><span class="comment">##mistake made in 23th measurement</span></span><br><span class="line">boxplot(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们看一下均值和标准差，发现偏离很大</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">cat(<span class="string">&quot;The average is&quot;</span>,mean(x),<span class="string">&quot;and the SD is&quot;</span>,sd(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">## The average is 1.108142 and the SD is 10.02938</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="The-median">The median</h4>
<p>这个中位数，对于离群点，是robust的。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">median(x)</span><br><span class="line">[<span class="number">1</span>] <span class="number">0.1684483</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="The-median-absolute-deviation">The median absolute deviation</h4>
<p>![](The median absolute deviation.png)</p>
<h4 id="Spearman-correlation">Spearman correlation</h4>
<p>和前面类似，也是robust 的相关系数。几乎不受离群点的影响。</p>
<h4 id="Symmetry-of-log-ratios">Symmetry of log ratios</h4>
<p>当涉及比值数据时，数据不是对称的，1/32 比 32/1 更接近1。这时候采用log()函数处理一下，就会对称（log(x/y) = log(x) - log(y) ）</p>
<h3 id="Wilcoxon-Rank-Sum-Test">Wilcoxon Rank Sum Test</h3>
<p>从上面知道，样本均值和标准差易受离群点的影响。t检验需要用到这两个数，因此也容易受到影响。这种Wilcoxon Rank Sum Test 就不会受到影响……</p>
<p>后面没看</p>
<h2 id="Matrix-Algebra">Matrix Algebra</h2>
<h3 id="自由落体实验">自由落体实验</h3>
<p>假设你是伽利略，你需要描述物体自由下落的速度。通过实验你获得了如下的25个数据，使用R模拟如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">set.seed(<span class="number">1</span>)</span><br><span class="line">g&lt;-<span class="number">9.8</span><span class="comment">##meters per second</span></span><br><span class="line">n&lt;-<span class="number">25</span></span><br><span class="line">tt&lt;-seq(<span class="number">0</span>,<span class="number">3.4</span>,len=n)<span class="comment">##time in secs, note: we use tt because t is a base function</span></span><br><span class="line">d&lt;-<span class="number">56.67</span>-<span class="number">0.5</span>*g*tt^<span class="number">2</span>+rnorm(n,sd=<span class="number">1</span>)<span class="comment">##meters</span></span><br><span class="line"><span class="comment">#rnorm 生成25个服从(0,1) 分布的随机数，模拟随机残差</span></span><br><span class="line"></span><br><span class="line">plot(tt,d,ylab=<span class="string">&quot;Distance in meters&quot;</span>,xlab=<span class="string">&quot;Time in seconds&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你不知道高度与时间的准确的关系式，但是你根据图片，推断可能符合的模型如下：</p>
<p><img src="falling_objects1.png" alt=""></p>
<h3 id="父亲和儿子的身高">父亲和儿子的身高</h3>
<p>现在假设你是19世纪的Francis Galton ，然后你获得了成对的父亲与儿子的身高数据。你假设身高是受遗传影响的。</p>
<p>你拿到的数据如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(UsingR)</span><br><span class="line">x=father.son$fheight</span><br><span class="line">y=father.son$sheight</span><br><span class="line">plot(x,y,xlab=<span class="string">&quot;Father&#x27;s height&quot;</span>,ylab=<span class="string">&quot;Son&#x27;s height&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>貌似是符合一元线性模型。于是，你设计出的模型如下：</p>
<p><img src="father_son1.png" alt=""></p>
<h3 id="从多个群体中随机抽样">从多个群体中随机抽样</h3>
<p>现在我们重新读取小鼠的体重数据。我们感兴趣的是diet是否对体重有影响。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dat&lt;-read.csv(<span class="string">&quot;femaleMiceWeights.csv&quot;</span>)</span><br><span class="line">stripchart(Bodyweight~Diet,data=dat,vertical=<span class="literal">TRUE</span>,method=<span class="string">&quot;jitter&quot;</span>,pch=<span class="number">1</span>,main=<span class="string">&quot;Mice weights&quot;</span>)</span><br><span class="line"><span class="comment">##stripchart 成串的散点图，当数据量较少时，是箱线图的有效代替</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们已经证明了如何使用t检验和置信区间来证明两个群体的平均体重是否有差异。但是，用线性模型也可以做到。</p>
<p><img src="liner_model_mice1.png" alt=""></p>
<p>这里的β0表示 chow diet 的平均体重，β1 表示两个群体均值的差异，当i 采用 high fat diet 时xi = 1 ；当 i 采用 chow diet 时 xi =0 。</p>
<h3 id="一般的线性模型">一般的线性模型</h3>
<p><img src="general_linear_model.png" alt=""></p>
<h3 id="估计参数">估计参数</h3>
<p>只有我们能够估计出 β s，线性模型才能起作用。</p>
<p>一般估计参数的方法都是使用最小二乘法（least squares LS）。</p>
<p><img src="LS.png" alt=""></p>
<p>一旦我们找到了最小值，我们就称他们为 least squares estimates (LSE) , 表示为β帽。获得最小二乘的统计量称之为 the residual sum of squares (RSS) 。因为这个统计量决定于 Y 这个随机变量。因此 β帽 也是一个随机变量。</p>
<h3 id="lm-函数">lm 函数</h3>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tt2&lt;-tt^<span class="number">2</span></span><br><span class="line">fit&lt;-lm(d~tt+tt2)</span><br><span class="line">summary(fit)$coef</span><br></pre></td></tr></table></figure>
<p>通过lm()函数，我们可以知道得到LSE，和它的标准误 和 p 值。</p>
<h3 id="LSE">LSE</h3>
<p>我们可以写个计算LSE的函数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">rss&lt;-<span class="keyword">function</span>(Beta0,Beta1,Beta2)&#123;</span><br><span class="line">  r&lt;- d-(Beta0+Beta1*tt+Beta2*tt^<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">return</span>(<span class="built_in">sum</span>(r^<span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#固定两个参数，观察beta2对rss的影响</span></span><br><span class="line">Beta2s&lt;-seq(-<span class="number">10</span>,<span class="number">0</span>,len=<span class="number">100</span>)</span><br><span class="line">plot(Beta2s,sapply(Beta2s,rss,Beta0=<span class="number">55</span>,Beta1=<span class="number">0</span>),ylab=<span class="string">&quot;RSS&quot;</span>,xlab=<span class="string">&quot;Beta2&quot;</span>,type=<span class="string">&quot;l&quot;</span>)</span><br><span class="line"><span class="comment">##Let&#x27;s add another curve fixing another pair:</span></span><br><span class="line">Beta2s&lt;-seq(-<span class="number">10</span>,<span class="number">0</span>,len=<span class="number">100</span>)</span><br><span class="line">lines(Beta2s,sapply(Beta2s,rss,Beta0=<span class="number">65</span>,Beta1=<span class="number">0</span>),col=<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>估计参数这里需要用到微积分。当然，如果参数众多，那么估计起来也很麻烦。</p>
<h3 id="More-on-Galton-父子身高">More on Galton (父子身高)</h3>
<h3 id="solving-system-of-equations">solving system of equations</h3>
<p>线性代数是被用来解决 systems of linear equations，如下：</p>
<p><img src="linear_equations1.png" alt=""></p>
<p>线性代数给我们提供了非常简便的一般方法解决这些问题。比如上例中，可以这么求解</p>
<p><img src="linear_equations2.png" alt=""></p>
<h3 id="The-inverse">The inverse</h3>
<p>我们可以通过R中的solve()函数求逆。但是注意，solve()函数并不总是numerically stable。</p>
<p>crossprod(A，B)  = t(A) %*% B</p>
<p>crossprod(A) = t(A) %*% A</p>
<h3 id="liner-model">liner model</h3>
<p>我们可以重新定义父子身高的矩阵形式</p>
<p><img src="linear_model_height1.png" alt=""></p>
<p>因此该线性模型为：</p>
<p><img src="linear_model_height2.png" alt=""></p>
<p>最小二乘统计量为</p>
<p><img src="linear_model_height3.png" alt=""></p>
<h3 id="advanced-使用求导求最小二乘">advanced:使用求导求最小二乘</h3>
<p><img src="LSE2.png" alt=""></p>
<p>由于最小二乘也是一个平方值，所以，类似于 f(x)^2^ 的求导为 2f(x)f’(x)</p>
<p>具体没太搞懂</p>
<h2 id="Linear-Models">Linear Models</h2>
<blockquote>
<p>“Linear”” here does not refer to lines, but rather to linear combinations.</p>
</blockquote>
<p>这句话的意思是，线性模型指的不是一条线（y=x+x^2^ 就是曲线），而是指的是影响因素的线性组合。</p>
<p>model matrix 来求出 LSE，我们称之为 fitting the model 。 我们在R中可以直接使用 lm() 函数，但是其实 lm() 函数内部也是使用了model.matrix()函数。</p>
<p>design matrix 至少包含两列（第一列全是1，表示截距）。但是我觉得，也可以不要截距。比如diet 对 小鼠体重的影响，截距是 chow diet 的平均体重，另一个是high fat - chow fat 的差值。也可以设置为，第一列是chow diet ，第二列是 high fat 。不过最少还是需要两列。</p>
<p>使用model.matrix() 函数前必须<strong>因子化</strong></p>
<p>所谓因子（factor），它们的具体名称不重要（字符串或者数值），重要的是order（把同一类的归到一组）</p>
<p>model.matrix() 中 +0 或 -1 不要截距，这样每一个水平都有一个单独的系数。</p>
<h3 id="Releveling-（实际没什么用）">Releveling （实际没什么用）</h3>
<p>参考水平（reference level，也就是截距所在的水平）一般是<strong>名称按字母排序</strong>的第一个水平，可以通过relevel 改变</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">group &lt;- factor(<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">group &lt;- relevel(group, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">model.matrix(~ group)</span><br><span class="line"><span class="comment">##   (Intercept) group1</span></span><br><span class="line"><span class="comment">## 1           1      1</span></span><br><span class="line"><span class="comment">## 2           1      1</span></span><br><span class="line"><span class="comment">## 3           1      0</span></span><br><span class="line"><span class="comment">## 4           1      0</span></span><br><span class="line"></span><br><span class="line">model.matrix(~ group-<span class="number">1</span>)</span><br><span class="line"><span class="comment">##          group2 group1</span></span><br><span class="line"><span class="comment">## 1           0      1</span></span><br><span class="line"><span class="comment">## 2           0      1</span></span><br><span class="line"><span class="comment">## 3           1      0</span></span><br><span class="line"><span class="comment">## 4           1      0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以直接在factor() 函数中说明顺序</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">group &lt;- factor(<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>),levels = <span class="built_in">c</span>(<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;1&#x27;</span>))</span><br><span class="line">model.matrix(~group-<span class="number">1</span>)</span><br><span class="line"><span class="comment">##  group3 group2 group1</span></span><br><span class="line"><span class="comment">## 1      0      0      1</span></span><br><span class="line"><span class="comment">## 2      0      0      1</span></span><br><span class="line"><span class="comment">## 3      0      1      0</span></span><br><span class="line"><span class="comment">## 4      0      1      0</span></span><br><span class="line"><span class="comment">## 5      1      0      0</span></span><br><span class="line"><span class="comment">## 6      1      0      0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是如果水平数很多，这样做就太麻烦了。</p>
<p>不如一开始就按照需要的顺序从1到n 重编号就好了。</p>
<h3 id="连续变量">连续变量</h3>
<p>在实际的使用中，除了分类变量。我们可能还会将连续的数字变量转化为design matrix。比如在自由落体实验中，时间和时间的平方就包含在了模型中。它们也要转化为model.matrix</p>
<p>连续变量不用因子化，也不能因子化。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tt&lt;-seq(<span class="number">0</span>,<span class="number">3.4</span>,len=<span class="number">4</span>)</span><br><span class="line">model.matrix(~tt+I(tt^<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">  (Intercept)       tt   I(tt^<span class="number">2</span>)</span><br><span class="line">1           <span class="number">1</span> <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line">2           <span class="number">1</span> <span class="number">1.133333</span>  <span class="number">1.284444</span></span><br><span class="line">3           <span class="number">1</span> <span class="number">2.266667</span>  <span class="number">5.137778</span></span><br><span class="line">4           <span class="number">1</span> <span class="number">3.400000</span> <span class="number">11.560000</span></span><br><span class="line"><span class="built_in">attr</span>(,<span class="string">&quot;assign&quot;</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>生命科学中经常需要考虑<strong>剂量效应</strong>，这也是一种连续变量。</p>
<p>但是，添加连续变量的假设<strong>难以辩护</strong>，因为分类变量仅仅是比较两个群体的均值之间是否有差异，而连续变量却意味着观测值与这个连续变量之间存在特别的关系。</p>
<p>比如落体试验中，这是因为我们以及知道了重力的公式。父子身高试验，我们能明显地看出来线性关系。但是如果你把年龄（age）也加入到身高的模型中，这就不对了。</p>
<p>因此，你的数据必须要能支持你把这个连续变量加入到模型中。即添加连续变量要小心。</p>
<h3 id="小鼠数据举例">小鼠数据举例</h3>
<p>在小鼠的数据中，我们之前是使用了t-test，其实我这里也可以使用线性模型，二者其实是<strong>异曲同工</strong>的。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dat&lt;-read.csv(<span class="string">&quot;femaleMiceWeights.csv&quot;</span>)</span><br><span class="line"><span class="comment">#没有设置stringsAsFactor，Diet已经是因子了</span></span><br><span class="line">levels(dat$Diet) </span><br><span class="line">X&lt;-model.matrix(~Diet, data=dat)</span><br><span class="line">head(X)</span><br><span class="line"></span><br><span class="line">Y&lt;-dat$Bodyweight</span><br><span class="line">X&lt;-model.matrix(~Diet, data=dat)</span><br><span class="line">solve(t(X)%*%X)%*%t(X)%*%Y</span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">                 [,<span class="number">1</span>]</span><br><span class="line">(Intercept) <span class="number">23.813333</span></span><br><span class="line">Diethf       <span class="number">3.020833</span></span><br></pre></td></tr></table></figure>
<p>查看均值、均值差，一致</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">s&lt;-split(dat$Bodyweight, dat$Diet)</span><br><span class="line"><span class="comment">#split() 按照分组因子，分类，形成一个列表</span></span><br><span class="line"><span class="comment">#有点实用啊</span></span><br><span class="line"></span><br><span class="line">mean(s[[<span class="string">&quot;chow&quot;</span>]])</span><br><span class="line"><span class="comment">## [1] 23.81333</span></span><br><span class="line"></span><br><span class="line">mean(s[[<span class="string">&quot;hf&quot;</span>]])-mean(s[[<span class="string">&quot;chow&quot;</span>]])</span><br><span class="line"><span class="comment">## [1] 3.020833</span></span><br></pre></td></tr></table></figure>
<p>使用lm() 函数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fit&lt;-lm(Bodyweight~Diet, data=dat)</span><br><span class="line">summary(fit)$coef</span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">             Estimate Std. Error   t value     Pr(&gt;|t|)</span><br><span class="line">(Intercept) <span class="number">23.813333</span>   <span class="number">1.039353</span> <span class="number">22.911684</span> <span class="number">7.642256e-17</span></span><br><span class="line">Diethf       <span class="number">3.020833</span>   <span class="number">1.469867</span>  <span class="number">2.055174</span> <span class="number">5.192480e-02</span></span><br></pre></td></tr></table></figure>
<p>t分布，当方差相等时结果一致。t分布的方差（标准差）一致等于线性模型中的残差分布一致。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">t.test(s[[<span class="string">&quot;chow&quot;</span>]],s[[<span class="string">&#x27;hf&#x27;</span>]],var.equal = <span class="built_in">T</span>)$p.value</span><br><span class="line"><span class="comment">## [1] 0.0519248</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Standard-Errors">Standard Errors</h3>
<p>实际我们得到的参数估计值仍然是一个<strong>随机变量</strong>，因此需要提供<strong>标准误</strong>才是有效的。</p>
<p>对于自由落体试验，我们可以采用Monte Carlo simulation</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">set.seed(<span class="number">1</span>)</span><br><span class="line">B&lt;-<span class="number">10000</span></span><br><span class="line">h0&lt;-<span class="number">56.67</span></span><br><span class="line">v0&lt;-<span class="number">0</span></span><br><span class="line">g&lt;-<span class="number">9.8</span><span class="comment">##meters per second</span></span><br><span class="line">n&lt;-<span class="number">25</span></span><br><span class="line">tt&lt;-seq(<span class="number">0</span>,<span class="number">3.4</span>,len=n)<span class="comment">##time in secs, t is a base function</span></span><br><span class="line">X&lt;-cbind(<span class="number">1</span>,tt,tt^<span class="number">2</span>)</span><br><span class="line"><span class="comment">##create X&#x27;X^-1 X&#x27;</span></span><br><span class="line">A&lt;-solve(crossprod(X))%*%t(X)</span><br><span class="line">betahat&lt;-replicate(B,&#123;</span><br><span class="line">  y&lt;-h0+v0*tt-<span class="number">0.5</span>*g*tt^<span class="number">2</span>+rnorm(n,sd=<span class="number">1</span>)</span><br><span class="line">  betahats&lt;-A%*%y</span><br><span class="line">  <span class="built_in">return</span>(betahats[<span class="number">3</span>])</span><br><span class="line">&#125;)</span><br><span class="line">head(betahat)</span><br><span class="line"><span class="comment"># [1] -5.038646 -4.894362 -5.143756 -5.220960 -5.063322</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每次得到的估计都不同</p>
<p>我们可以观察一下估计值的分布。发现符合正态，这是因为参数估计值是观测值的线性组合。因此，只要<strong>观测值符合正态分布</strong>，那么参数也符合正态分布</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(rafalib)</span><br><span class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">hist(betahat)</span><br><span class="line">qqnorm(betahat)</span><br><span class="line">qqline(betahat)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以得到参数均值和标准误的估计值</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="built_in">round</span>(mean(betahat),<span class="number">1</span>)</span><br><span class="line"><span class="comment">## [1] -4.9</span></span><br><span class="line"></span><br><span class="line">sd(betahat)</span><br><span class="line"><span class="comment">## [1] 0.2129976</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在父子身高的试验中，randomness 主要是我们是随机采样的父子对（father and son pairs）。为了说明，我们假设下面的就是整个群体的数据</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(UsingR)</span><br><span class="line">x&lt;-father.son$fheight</span><br><span class="line">y&lt;-father.son$sheight</span><br><span class="line">n&lt;-<span class="built_in">length</span>(y)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来我们采用Monte Carlo simulation，这里我们设定样本大小为50，然后重复抽样。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N&lt;-<span class="number">50</span></span><br><span class="line">B&lt;-<span class="number">1000</span></span><br><span class="line">betahat&lt;-replicate(B,&#123;</span><br><span class="line">  index&lt;-sample(n,N)</span><br><span class="line">  sampledat&lt;-father.son[index,]</span><br><span class="line">  x&lt;-sampledat$fheight</span><br><span class="line">  y&lt;-sampledat$sheight</span><br><span class="line">  lm(y~x)$coef</span><br><span class="line">  &#125;)</span><br><span class="line">betahat&lt;-t(betahat) <span class="comment">#have estimates in two columns</span></span><br><span class="line"></span><br><span class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">qqnorm(betahat[,<span class="number">1</span>])</span><br><span class="line">qqline(betahat[,<span class="number">1</span>])</span><br><span class="line">qqnorm(betahat[,<span class="number">2</span>])</span><br><span class="line">qqline(betahat[,<span class="number">2</span>])</span><br><span class="line"><span class="comment">#符合正态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#lm() 两个参数的相关</span></span><br><span class="line">cor(betahat[,<span class="number">1</span>],betahat[,<span class="number">2</span>])</span><br><span class="line"><span class="comment">## [1] -0.9991099</span></span><br></pre></td></tr></table></figure>
<h3 id="方差-协方差矩阵">方差-协方差矩阵</h3>
<p>我们用一个类似求和的符号表示协方差矩阵。</p>
<p><img src="variance1.png" alt=""></p>
<p>以观测值 Y 向量为例，由于来自于同一个群体，所以我们认为所有Yi 有着共同的方差，而且由于个体间互相独立，因此非对角线元素全为0。因此观测值 Y 向量的方差-协方差矩阵只有两种元素。</p>
<p><img src="variance2.png" alt=""></p>
<p><img src="variance3.png" alt=""></p>
<p>根据上面的公式，我们可以求出LSE的标准误（也就是标准差）</p>
<p><img src="variance4.png" alt=""></p>
<p>为了得到参数估计的标准误，我们需要估计群体的标准差。</p>
<p>这里我们采用下面方法估计群体的标准差（具体推导不了解）</p>
<p><img src="variance5.png" alt=""></p>
<p>采用R代码如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">n&lt;-nrow(father.son)</span><br><span class="line">N&lt;-<span class="number">50</span></span><br><span class="line">index&lt;-sample(n,N)</span><br><span class="line">sampledat&lt;-father.son[index,]</span><br><span class="line">x&lt;-sampledat$fheight</span><br><span class="line">y&lt;-sampledat$sheight</span><br><span class="line">X&lt;-model.matrix(~x)</span><br><span class="line"></span><br><span class="line">N&lt;-nrow(X)</span><br><span class="line">p&lt;-ncol(X)</span><br><span class="line"></span><br><span class="line">XtXinv&lt;-solve(crossprod(X))</span><br><span class="line"></span><br><span class="line">resid&lt;-y-X%*%XtXinv%*%crossprod(X,y)</span><br><span class="line"></span><br><span class="line">s&lt;-<span class="built_in">sqrt</span>( <span class="built_in">sum</span>(resid^<span class="number">2</span>)/(N-p))</span><br><span class="line"></span><br><span class="line">ses&lt;-<span class="built_in">sqrt</span>(diag(XtXinv))*s</span><br><span class="line"></span><br><span class="line"><span class="comment">## Let’s compare to whatlmprovides:</span></span><br><span class="line"></span><br><span class="line">summary(lm(y~x))$coef[,<span class="number">2</span>]</span><br><span class="line"><span class="comment">## (Intercept)           x </span></span><br><span class="line"><span class="comment">##   9.1642841   0.1359242 </span></span><br><span class="line"></span><br><span class="line">ses</span><br><span class="line"><span class="comment">## (Intercept)           x </span></span><br><span class="line"><span class="comment">##   9.1642841   0.1359242 </span></span><br></pre></td></tr></table></figure>
<p>后面一部分都没看懂</p>
<blockquote>
<p>They are identical because they are doing the same thing.</p>
</blockquote>
<p>192页后面没看</p>
<h3 id="The-QR-Factorization">The QR Factorization</h3>
<p>solve <strong>is numerically unstable</strong></p>
<p>例如，在求LSE中，需要求（X’X）^-1^</p>
<h4 id="分解（）">分解（）</h4>
<p>任何满秩的 N × p 矩阵X（如果不是方阵，哪来的满秩？？），都可以如下分解：</p>
<p><img src="factorization1.png" alt=""></p>
<h4 id="用QR求LSE">用QR求LSE</h4>
<p><img src="qr1.png" alt=""></p>
<p>R 代码如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">n&lt;-<span class="number">50</span>;M&lt;-<span class="number">500</span></span><br><span class="line">x&lt;-seq(<span class="number">1</span>,M,len=n)</span><br><span class="line">X&lt;-cbind(<span class="number">1</span>,x,x^<span class="number">2</span>,x^<span class="number">3</span>)</span><br><span class="line">colnames(X)&lt;-<span class="built_in">c</span>(<span class="string">&quot;Intercept&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&quot;x2&quot;</span>,<span class="string">&quot;x3&quot;</span>)</span><br><span class="line">beta&lt;-matrix(<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),<span class="number">4</span>,<span class="number">1</span>)</span><br><span class="line">set.seed(<span class="number">1</span>)</span><br><span class="line">y&lt;-X%*%beta+rnorm(n,sd=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">QR&lt;-qr(X)</span><br><span class="line">Q&lt;-qr.Q( QR )</span><br><span class="line">R&lt;-qr.R( QR )</span><br><span class="line">(betahat&lt;-backsolve(R, crossprod(Q,y) ) )</span><br><span class="line"></span><br><span class="line"><span class="comment">##也可以直接通过solve函数</span></span><br><span class="line"></span><br><span class="line">QR&lt;-qr(X)</span><br><span class="line">(betahat&lt;-solve.qr(QR, y))</span><br><span class="line"></span><br><span class="line"><span class="comment">##              [,1]</span></span><br><span class="line"><span class="comment">## Intercept 0.9038372</span></span><br><span class="line"><span class="comment">## x         1.0066440</span></span><br><span class="line"><span class="comment">## x2        0.9999622</span></span><br><span class="line"><span class="comment">## x3        1.0000001</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>理论学习</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>理论学习</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分课程第二部分学习笔记</title>
    <url>/posts/9e4272e7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是微积分课程的第二部分，后面还有，但是我没有做笔记了。</p>
<p>这里是微积分的<a href="https://vincere.fun/posts/b445140c/">第一部分笔记</a>，微积分第二部分的资料见<a href="https://tutorial.math.lamar.edu/Classes/CalcII/CalcII.aspx">官网</a></p>
<span id="more"></span>
<h1>Intergration Techniques</h1>
<p><img src="parts1.png" alt=""></p>
<p><img src="parts2.png" alt=""></p>
<p><img src="parts3.png" alt=""></p>
<h2 id="Integrals-involving-trig-functions">Integrals involving trig functions</h2>
<p><img src="trigs1.png" alt=""></p>
<p><img src="trigs2.png" alt=""></p>
<p>关于tan(x) 和 sec(x) 的关系</p>
<p><img src="trigs3.png" alt=""></p>
<p><img src="trigs6.png" alt=""></p>
<h2 id="Trig-Substitutions">Trig Substitutions</h2>
<p>将正常函数转化为三角函数。如下例</p>
<p><img src="trigs5.png" alt=""></p>
<p><img src="trigs7.png" alt=""></p>
<p><img src="trigs8.png" alt=""></p>
<h2 id="Partial-Fractions">Partial Fractions</h2>
<p>对于分母与分子都是二项式的式子，如果<strong>分子的最高项低于分母</strong>，可以将这个式子先进行分解，再积分。、</p>
<p>下面这个图没看懂？</p>
<p><img src="parts4.png" alt=""></p>
<p><img src="parts5.png" alt=""></p>
<h2 id="Integrals-Involving-Roots">Integrals Involving Roots</h2>
<p><img src="parts6.png" alt=""></p>
<h2 id="Integrals-involving-quadratics">Integrals involving quadratics</h2>
<p>如果有不符合以上规则的多项式（最多为二次）（即首先分子不是分母导数的倍数；分母不能因式分解），还想要使用三角函数。那么就需要先提取出x 的平方的函数。如下。</p>
<p><img src="parts7.png" alt=""></p>
<h2 id="Integration-Strategy">Integration Strategy</h2>
<h2 id="Imporper-Integrals">Imporper Integrals</h2>
<h3 id="Infinite-interval">Infinite interval</h3>
<p>当定积分的一侧或两侧是无穷大时，正确的做法用一个字母代替无穷大，然后求其极限值。</p>
<p><img src="parts8.png" alt=""></p>
<p>如果这种积分<strong>存在</strong>并且是一个常数，我们就说这个被积变量是<strong>convergent</strong>；反之，如果积分<strong>不存在</strong>或是<strong>无穷大</strong>，那么我们就说这个被积变量是<strong>divergent</strong>。</p>
<h3 id="Distontinuous-Integrand">Distontinuous Integrand</h3>
<p><img src="parts9.png" alt=""></p>
<p><img src="parts10.png" alt=""></p>
<h2 id="Comparison-Test-for-Improper-Integrals">Comparison Test for Improper Integrals</h2>
<p>如果不容易求积分，可以通过下面这个式子判断函数是否<strong>coverge</strong>。</p>
<p><img src="parts11.png" alt=""></p>
<p>很容易理解，因为积分是面积。</p>
<h2 id="Approximating-Definite-Integrals">Approximating Definite Integrals</h2>
<p>不是所有的被积变量都能求出原函数。因此有时需要<strong>近似估计定积分</strong>的值。</p>
<p>就是把定积分看成是<strong>求面积</strong>的问题。</p>
<h3 id="Midpoint-Rule">Midpoint Rule</h3>
<p>将[a,b]区间平均取n等分，每个小区间取<strong>中间点</strong>的值作为每个<strong>小矩形</strong>的高。</p>
<p><img src="parts12.png" alt=""></p>
<h3 id="Trapezoid-Rule">Trapezoid Rule</h3>
<p>一样是n等分，不同是算每个<strong>梯形</strong>的面积。</p>
<p><img src="parts13.png" alt=""></p>
<p><img src="parts14.png" alt=""></p>
<h3 id="Simpson’s-Rule">Simpson’s Rule</h3>
<p>同上 n等分。不过n必须为<strong>偶数</strong>。</p>
<p>类似于上一条，不过上一条是取直线。而这里是每两个区间（有3个点），求其<strong>二次式</strong>。这里用的是曲线。</p>
<p><img src="parts15.png" alt=""></p>
<p>下面每两个区间的面积不知道是咋推的。（未证明）</p>
<p>我不知道三条边是直线，一条边是曲线，怎么求面积。</p>
<p><img src="parts16.png" alt=""></p>
<p>这三种方法中，第三种方法一般<strong>误差最小</strong>。</p>
<h1>Applications of Integrals</h1>
<h2 id="Arc-length">Arc length</h2>
<p><img src="arc1.png" alt=""></p>
<h2 id="Surface-Area">Surface Area</h2>
<p>求旋转体的表面积。由于没有看Calculus I 的求旋转体的体积，因此跳过。</p>
<h2 id="Center-of-Mass">Center of Mass</h2>
<p>求平均分布的薄板的质心。就是只支撑这一点能维持水平的地方。</p>
<p>公式没看懂。首先假设这个物体的上下边缘分别是一个函数。</p>
<p><img src="mass1.png" alt=""></p>
<p><img src="mass2.png" alt=""></p>
<p><img src="mass3.png" alt=""></p>
<h2 id="Hydrostatic-Pressure-and-Force">Hydrostatic Pressure and Force</h2>
<p>涉及流体力学。求流体静力，貌似是等于水压乘面积。但是水压随着水深的变化而变化，因此需要用到微积分。</p>
<p>自己推理计算，对了。</p>
<p>但是不严谨，没有严格按照定积分的公式。</p>
<h2 id="Probability">Probability</h2>
<p>根据概率密度曲线，求连续分布的随机变量在某区间取值的概率。</p>
<p><img src="prob1.png" alt=""></p>
<p><img src="prob2.png" alt=""></p>
<h1>Parametric Equations and Polar Coordinates</h1>
<h2 id="Parametric-Equations-and-Curves">Parametric Equations and Curves</h2>
<p>有的时候，我们得不到 y = f(x) 或 x = h(y) 这两种形式的函数。例如圆的式子。但是有时我们可以得到一个 x = f(t) 和 y = g(t) 的形式。根据t 的定义域，每一个t，就能得到一个点(f(t),g(t))。这些点连起来得到的曲线就是<strong>parametric curve</strong>。</p>
<p>注意 parametric curve 是有方向的，是t 不断增大的方向。</p>
<h2 id="Tangents-with-Parametric-Equations">Tangents with Parametric Equations</h2>
<p><img src="tang1.png" alt=""></p>
<p>感觉这个式子，可以用速度的例子。一个是水平的运动，一个是竖直方向的运动。</p>
<p><img src="tang2.png" alt=""></p>
<p><img src="tang3.png" alt=""></p>
<p><img src="tang4.png" alt=""></p>
<h2 id="Area-with-Parametric-Equations">Area with Parametric Equations</h2>
<p>求面积（积分），设 x = f(t) ; y = g(t)</p>
<p><img src="area1.png" alt=""></p>
<h2 id="Arc-Length-with-Parametric-Equations">Arc Length with Parametric Equations</h2>
<p>推导省略，下面少了一个条件，即 dx/dt &gt; 0 。即 t 要保持从左往右走。</p>
<p><img src="arc2.png" alt=""></p>
<p>不如用原来的函数。</p>
<p><img src="arc3.png" alt=""></p>
<p>懂了，如果<strong>不考虑方向</strong>（也就是路程，而不是位移），那么可以直接用省略的公式。考虑方向，那么省略公式如果 dx/dt &gt; 0 时用原公式，如果 dx/dt &lt; 0 时原公式加一个负号。</p>
<h2 id="Surface-Area-with-Parametric-Equations">Surface Area with Parametric Equations</h2>
<p>求Parametric Curve 旋转体的表面积。之前这部分没看，跳过。</p>
<h2 id="Polar-Coordinates">Polar Coordinates</h2>
<p><img src="polar1.png" alt=""></p>
<h3 id="Area-with-Polar-Coordinates">Area with Polar Coordinates</h3>
<p><img src="polar2.png" alt=""></p>
<p>应该是根据了圆弧求面积的公式。利用积分的思想。</p>
<p><img src="polar3.png" alt=""></p>
<p>注意：定积分中的 α 和 β ，要保持顺时针转动。</p>
<h3 id="Arc-Length-with-Polar-Coordinates">Arc Length with Polar Coordinates</h3>
<p>这里指的还是单纯的长度，不看方向。所以一直用的是 ds。</p>
<p><img src="polar4.png" alt=""></p>
<h3 id="Surface-Area-with-Polar-Coordinates">Surface Area with Polar Coordinates</h3>
<p>没看</p>
<h1>Series &amp; Sequence</h1>
<p><img src="seq1.png" alt=""></p>
<p>如果当n 趋于无穷，序列极限存在且为定值，那么我们就说这个序列是<strong>convergent</strong>；如果序列极限<strong>不存在</strong>或极限是<strong>无穷</strong>，那么我们就说这个序列是<strong>divergent</strong>。</p>
<p>求序列极限的方法</p>
<p><img src="seq2.png" alt=""></p>
<p>根据函数极限性质，推导出以下序列极限的特性。</p>
<p><img src="seq3.png" alt=""></p>
<p><img src="seq4.png" alt=""></p>
<p>注意：下面的定理2 只有在极限为0时适用。</p>
<p><img src="seq5.png" alt=""></p>
<p><img src="seq6.png" alt=""></p>
<p>下面这个定理很好证。n 只能取奇数和偶数，而奇数和偶数都为L。那么这个序列的极限就肯定是L了。</p>
<p><img src="seq7.png" alt=""></p>
<h2 id="More-on-Sequences">More on Sequences</h2>
<p><img src="seq8.png" alt=""></p>
<p><img src="seq9.png" alt=""></p>
<h2 id="Series-The-Basics">Series - The Basics</h2>
<p>没搞清楚这个series 的概念。</p>
<p><img src="seq10.png" alt=""></p>
<p>series 好像仅仅是一个数。懂了，其实series 只是上图中的 Sn。图里仅仅是推导步骤。</p>
<p><img src="seq11.png" alt=""></p>
<p>这个定理只是说 an 的极限为0 是其收敛的必要条件，并不是说 an 极限为0 就一定会收敛。</p>
<p><img src="seq12.png" alt=""></p>
<p>下面这个定理，很简单。就是从逻辑学里转换过来。</p>
<p><img src="seq13.png" alt=""></p>
<h2 id="Special-Series">Special Series</h2>
<p>后面的很多都是高中知识。</p>
<p>Integral Test 条件是 an 必须递减且为正数。</p>
<p><img src="series1.png" alt=""></p>
<p>通过相同函数的积分只能看是否收敛，而不能求出series的<strong>值</strong>。</p>
<p><img src="series2.png" alt=""></p>
<p><img src="series3.png" alt=""></p>
<p><img src="series4.png" alt=""></p>
<p><img src="series5.png" alt=""></p>
<h2 id="Absolute-Convergence-Divergence">Absolute Convergence/Divergence</h2>
<p><img src="series6.png" alt=""></p>
<p><img src="series7.png" alt=""></p>
<p>下面这条未证明</p>
<p><img src="series8.png" alt=""></p>
<h2 id="Ratio-Test">Ratio Test</h2>
<p><img src="series9.png" alt=""></p>
<h2 id="Root-Test">Root Test</h2>
<p><img src="series10.png" alt=""></p>
<p>下面未证明</p>
<p><img src="series11.png" alt=""></p>
<h2 id="Strategy-for-Series">Strategy for Series</h2>
<h2 id="Estimating-the-Value-of-a-Series">Estimating the Value of a Series</h2>
<p>计算 Series 的值很多时候很困难，因此这里是<strong>估计</strong>Series 的值。而且下面都需要指定 n 的大小，其实就是说把 1(0) - n 的 sn 视为真值(?) ，后面的 Rn 视为误差项(?) 。</p>
<p>如果 an 一直是正数且递减</p>
<p><img src="series12.png" alt=""></p>
<p>这里的n 越大，就越准。</p>
<h3 id="Comparison-Test">Comparison Test</h3>
<p><img src="series13.png" alt=""></p>
<p>这种估计的准确性，取决于你使用的用于对比的函数。</p>
<h3 id="Alternating-Series-Test">Alternating Series Test</h3>
<p>没看懂，没证明。</p>
<p><img src="series14.png" alt=""></p>
<h3 id="Ratio-Test-2">Ratio Test</h3>
<p>这里需要假设series terms （即 an）都是正数。而且series 收敛，即 L &lt; 1。</p>
<p><img src="series15.png" alt=""></p>
<p><img src="series16.png" alt=""></p>
<h2 id="Power-Series">Power Series</h2>
<p><img src="series17.png" alt=""></p>
<p><img src="series18.png" alt=""></p>
<h2 id="Power-Series-and-Functions">Power Series and Functions</h2>
<p><img src="series19.png" alt=""></p>
<p><img src="series20.png" alt=""></p>
<p><img src="series21.png" alt=""></p>
<p>这节有点不会用</p>
<h2 id="Taylor-Series">Taylor Series</h2>
<p>泰勒公式的 a 是自己给的，而且只是<strong>假设</strong> f(x) 可以转化为 下面的这个 series。</p>
<p>我懂了，泰勒公式里的a 取啥值都行，都成立，不过 一般取a=0 更简单。</p>
<p>泰勒公式不过是把一个函数换成了一个series。</p>
<p><img src="series22.png" alt=""></p>
<p>如果将 a 设为0 ，即得到下面这个式子。</p>
<p><img src="series23.png" alt=""></p>
<p>下面的式子没看懂，貌似是求收敛的区间？</p>
<p><img src="series24.png" alt=""></p>
<p>几个重要的泰勒公式（a=0）</p>
<p><img src="series25.png" alt=""></p>
<h2 id="Applications-of-Series">Applications of Series</h2>
<ol>
<li>当原函数不能直接求积分时，可以使用泰勒公式进行<strong>转换</strong>。</li>
<li>使用<strong>n阶泰勒公式</strong>近似估计函数值。</li>
</ol>
<h2 id="Binomial-Series">Binomial Series</h2>
<p><img src="series26.png" alt=""></p>
<p>下面的定理没有证明，没看懂。（k是任意数，比如k=0.5,下面的阶乘怎么算的）</p>
<p><img src="series27.png" alt=""></p>
<h1>Vectors</h1>
<h2 id="Vectors-The-Basics">Vectors - The Basics</h2>
<p>向量只需要<strong>大小</strong>和<strong>方向</strong>，和起始位置<strong>无关</strong>。所以下图都是<strong>同一向量</strong>。</p>
<p><img src="vector1.png" alt=""></p>
<p><img src="vector2.png" alt=""></p>
<h3 id="Dot-Product">Dot Product</h3>
<p><img src="vector3.png" alt=""></p>
<p>下面这个式子往往用于求两向量的<strong>夹角</strong>，多维同样适用。</p>
<p><img src="vector4.png" alt=""></p>
<h3 id="projections-（投影）">projections （投影）</h3>
<p>b向量 在 a 向量的投影为：</p>
<p><img src="vector5.png" alt=""></p>
<p><img src="vector6.png" alt=""></p>
<h3 id="Direction-Cosines">Direction Cosines</h3>
<p>三维空间下，向量与x , y , z 轴形成的夹角的cosine。</p>
<p><img src="vector7.png" alt=""></p>
<p>下面均易证</p>
<p><img src="vector8.png" alt=""></p>
<h2 id="Cross-Product">Cross Product</h2>
<ul>
<li>点乘的结果是一个<strong>标量</strong></li>
<li>叉乘的结果是一个<strong>向量</strong></li>
</ul>
<p><img src="vector9.png" alt=""></p>
<p>实际是3×3的行列式的结果</p>
<p><img src="vector10.png" alt=""></p>
<p><img src="vector11.png" alt=""></p>
<p>叉乘的大小和方向如下：（方向符合**右手准则，**从a到b旋转）</p>
<p><img src="vector12.png" alt=""></p>
<p><img src="vector13.png" alt=""></p>
<p>从图可知，叉乘<strong>垂直</strong>于两个向量，或者说垂直这两个向量构成的平面。</p>
<p>如果 a 和 b 平行（夹角为0或180度）, 那么其叉乘大小为0，即为0向量。</p>
<p><img src="vector14.png" alt=""></p>
<p><img src="vector15.png" alt=""></p>
<p>下面的性质不太懂，未证明</p>
<p><img src="vector16.png" alt=""></p>
<h3 id="叉乘的几何性质">叉乘的几何性质</h3>
<p>叉乘本身是两个向量形成的平行四边形的<strong>面积</strong></p>
<p>但是下面的<strong>体积</strong>计算没看懂</p>
<p><img src="vector17.png" alt=""></p>
<h1>3-Dimensional Space</h1>
<h2 id="Equations-of-Lines">Equations of Lines</h2>
<p><img src="vector18.png" alt=""></p>
<p><img src="vector19.png" alt=""></p>
<p>另一种形式</p>
<p><img src="vector20.png" alt=""></p>
<h2 id="Equations-of-Planes">Equations of Planes</h2>
<p>n向量是法线（normal vector）</p>
<p><img src="vector21.png" alt=""></p>
<p><img src="vector22.png" alt=""></p>
<p><img src="vector23.png" alt=""></p>
<h2 id="Quadric-Surfaces">Quadric Surfaces</h2>
<p>没细看。</p>
<p>351页后都没看。2020年前就先到这了。我看calculus Ⅲ还涉及这一部分，估计之后还得看。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分课程第一部分学习笔记</title>
    <url>/posts/b445140c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是根据美国拉马尔大学 <em>Paul Dawkins</em> 老师的<strong>微积分</strong>教学材料写的笔记。</p>
<p>网址为：<a href="https://tutorial.math.lamar.edu/Classes/CalcI/CalcI.aspx">https://tutorial.math.lamar.edu/Classes/CalcI/CalcI.aspx</a>  （点击网页右上角的 download，选择 complete book 即可下载 pdf 格式的书籍 ）</p>
<p>我发现很多英文教材很适合自学，而且言语恳切，不嫌啰嗦，生怕你看不懂，不理解。这本书的特点也是如此，写的非常仔细，完全可以根据作者提供的pdf 自学。</p>
<span id="more"></span>
<h1>Review</h1>
<p>radical 根数</p>
<h2 id="逆函数（inverse-function）">逆函数（inverse function）</h2>
<p>如果两个不同的x值不会对应同一个y值，那么我们称这个函数是一对一的（<strong>one to one</strong>）。</p>
<p>但是证明函数是一对一的，可能很困难。因此我们一般都是假设函数不是一对一的，或者我们严格限定定义域（<strong>domain</strong>）使得函数符合一对一的性质。</p>
<p>现在让我们来定义<strong>逆函数</strong></p>
<blockquote>
<p><strong>逆函数</strong>：如果有两个满足<strong>一对一</strong>的函数 f(x) 和 g(x) ，如果满足以下式子，我们就称它们互为逆函数，记为 f^-1^(x) 或  g^-1^(x)</p>
</blockquote>
<p><img src="inverse_function1.png" alt=""></p>
<p>找出逆函数的五个步骤。相比我之前的认识，就是增加了第五步，复合函数的证明。</p>
<p><img src="inverse_function2.png" alt=""></p>
<p>第5步从理论上讲需要证明两种复合函数都等于x。</p>
<p>一个函数与其逆函数<strong>关于y=x对称</strong>。</p>
<p>三角函数中 角度为degree 弧度为 radian 。单位弧度定义为圆弧长度等于半径时的圆心角。</p>
<ul>
<li>sin(-x) = -sin(x)  ; tan(-x) = -tan(x)</li>
<li>cos(-x) = cos(x)</li>
</ul>
<h1>limits</h1>
<p><img src="limits1.png" alt=""></p>
<p>这种定义是通俗的定义方式，不是使用数学式子严格表示的定义。</p>
<p>要点：</p>
<ol>
<li>极限是需要从<strong>左右两边靠近</strong>均成立的。（<strong>both sides</strong>）</li>
<li>极限<strong>不需要</strong> x 真的取到 a值 。</li>
</ol>
<p>判断极限存不存在，简单地说，就是随着x 越来越接近 a (<strong>from two sides</strong>) ，f(x) <strong>must</strong> 越来越接近 L 。</p>
<p>另外，极限的定义里不包括 <strong>x = a</strong>，极限的值和 ** x = a ** 的值是<strong>不相关</strong>的。极限只和 点a 附近的函数值有关。</p>
<p>重申：有的时候函数的定义域可能不包括a，但是这也不影响其极限的存在。</p>
<blockquote>
<p>We are <strong>NOT</strong> asking what y value the graph takes at the point in question.  In other words, we are asking what the graph is doing <strong>around</strong> the point x = a.</p>
</blockquote>
<h2 id="one-sided-limits">one-sided limits</h2>
<p><img src="limits2.png" alt=""></p>
<p>one-sided limits 与 normal limits 的区别就是<strong>单边</strong>与<strong>双边</strong>。</p>
<p>单边极限与双边极限的关系如下：</p>
<p><img src="limits3.png" alt=""></p>
<h2 id="limit-Properties">limit Properties</h2>
<p>极限的性质如下：</p>
<p><img src="limits4.png" alt=""></p>
<p>这些性质对<strong>单边</strong>极限也适用。</p>
<p>对于多项式，其某点的极限值等于其函数值。</p>
<p>目前学过的大部分函数都是“nice enough&quot; ，在其定义域内，其极限值都等于函数值。其组合函数一般也是”nice enough&quot;。</p>
<p>定理：</p>
<p><img src="limits5.png" alt=""></p>
<p>由此引出<strong>夹逼定理</strong>（<strong>Squeeze Theorem</strong>）</p>
<p><img src="squeeze_theorem1.png" alt=""></p>
<p>看一个图，一下就明白（这里假设三个函数是nice enough，但实际夹逼定理不需要满足这一点）</p>
<p><img src="squeeze_theorem2.png" alt=""></p>
<h2 id="infinite-Limits">infinite Limits</h2>
<p>无穷大的定义：</p>
<p><img src="infinite_limits1.png" alt=""></p>
<p>垂直渐进线定义：</p>
<p><img src="vertical_asympotote1.png" alt=""></p>
<h2 id="limits-at-infinity">limits at infinity</h2>
<p>这个是当x 为无穷大时的极限。</p>
<p>对于多项式，其正无穷或负无穷处的极限值等于其最高项的极限值。</p>
<p><img src="limits_at_infinity1.png" alt=""></p>
<p>水平渐进线（horizontal asymptote）定义：</p>
<p><img src="horizontal_asymptote1.png" alt=""></p>
<p>对于多项式求极限，一个最重要的地方就在于找到<strong>最大项</strong>，然后提取出来。这里的最大项指的是<strong>与0偏离最远</strong>的项</p>
<p>如果是分式，那么只看<strong>分母</strong>的<strong>最大项</strong>。</p>
<h2 id="continuity">continuity</h2>
<p>在前面的章节中，我们一直用 ” nice enough &quot; 来定义一个函数其极限值等于函数值的性质。现在我们来定义什么叫做 ” nice enough &quot;。</p>
<p>连续性定义：</p>
<p><img src="continuity1.png" alt=""></p>
<p>反过来说也成立。也就是说如果再这一点 极限值等于函数值，那么函数在这一点具有连续性。反之也成立。</p>
<p><img src="continuity2.png" alt=""></p>
<p>常见的非连续性如下，第一种称为 jump discontinuity ，第二种称为 removable discontinuity 。</p>
<p><img src="continuity3.png" alt=""></p>
<p>如果我们简单地定义连续性，一个函数如果在某一区间具有连续性，我们用铅笔画出这一段从开始到结束的函数图像，中间不需要拿起铅笔（without ever once picking up our pencil ）。也就是能一气呵成的画完这一段。</p>
<p>另外一种解释，如果函数图像 没有 breaks 或 holes（指空心点） ，我们就说它在这一段是连续的。</p>
<h3 id="求复合函数（满足连续）的极限定理（重要）">求复合函数（满足连续）的极限定理（<strong>重要</strong>）</h3>
<p><img src="continuity4.png" alt=""></p>
<h3 id="介值定理（intermediate-value-theorem）">介值定理（intermediate value theorem）</h3>
<p><img src="continuity5.png" alt=""></p>
<p>介值定理的主要应用为，证明函数在某个区间有根。但是介值定理没办法告诉我们具体位置，也没办法证明是几个根。</p>
<p>注意，如果一个值不在两个端点的区间上，不能反推函数在这个区间不存在这个值。</p>
<h3 id="The-Definition-of-the-Limit">The Definition of the Limit</h3>
<p>极限的准确定义：</p>
<p><img src="limit_definition1.png" alt=""></p>
<p>再次重申，极限的定义只是 around a ，而不包括 x = a。我们不关心 x = a 时的情况。</p>
<p>左右极限定义如下：</p>
<p><img src="limit_definition2.png" alt=""></p>
<p><img src="limit_definition3.png" alt=""></p>
<p>极限为正无穷和负无穷的定义如下：</p>
<p><img src="limit_definition4.png" alt=""></p>
<p>x 趋于正负无穷的定义：</p>
<p><img src="limit_definition5.png" alt=""></p>
<p>再次重申：极限一定是不断<strong>趋近</strong>的。</p>
<p>使用极限的精确定义来定义<strong>连续</strong>。注意：连续的定义中 x = a 必须在定义域内，与之前的极限定义不同。</p>
<p><img src="limit_definition6.png" alt=""></p>
<h1>Derivatives</h1>
<p>导数定义：</p>
<p><img src="derivative1.png" alt=""></p>
<p>导数可能并不存在。如果f’(x) 在 x = a 处存在，那么我们称 f(x) 在 x=a 处是<strong>可导</strong>的（<strong>differentiable</strong>）。</p>
<p>如果 f(x) 在 x = a 处可导，那么 f(x) 在 x = a 处是连续的。但反过来并不成立。</p>
<h2 id="Differentiation-Formulas">Differentiation Formulas</h2>
<p><img src="derivative2.png" alt=""></p>
<p><img src="derivative3.png" alt=""></p>
<h2 id="函数乘积和商的求导（product-and-quotient-rule）">函数乘积和商的求导（product and quotient rule）</h2>
<p><img src="derivative4.png" alt=""></p>
<p><img src="derivative5.png" alt=""></p>
<p>多个函数的乘积公式为</p>
<p><img src="derivative6.png" alt=""></p>
<h2 id="Derivatives-of-trig-functions">Derivatives of trig functions</h2>
<p><img src="derivative7.png" alt=""></p>
<p>第二个式子可以通过第一个式子证明，写在书上了。主要应用 1 - cos(x) = sin^2^(x/2)</p>
<p>三角函数求导公式如下。注意，<strong>sec(x) = 1/cos(x)</strong> ; <strong>csc(x) = 1/sin(x)</strong> 。不要搞错了</p>
<p><img src="derivative8.png" alt=""></p>
<h2 id="Derivatives-of-Exponential-and-Logarithm-Functions">Derivatives of Exponential and Logarithm Functions</h2>
<p>自然对数底数e 的定义：</p>
<p><img src="derivative9.png" alt=""></p>
<p>指数函数求导公式（已证明，见后）</p>
<p><img src="derivative10.png" alt=""></p>
<p>逆函数求导公式（已证明）</p>
<p><img src="derivative11.png" alt=""></p>
<p>通过逆函数求导公式，指数函数和对数函数互为逆函数，因此推导出(lnx)’ = 1/x 。</p>
<p><img src="derivative12.png" alt=""></p>
<p>小结一下</p>
<p><img src="derivative13.png" alt=""></p>
<p>注意区分指数函数的求导和多次函数（不知道这个咋称呼）的求导</p>
<p><img src="derivative14.png" alt=""></p>
<h2 id="Derivatives-of-Inverse-Trig-Functions">Derivatives of Inverse Trig Functions</h2>
<p><img src="derivative15.png" alt=""></p>
<h2 id="Derivatives-of-Hyperbolic-Functions">Derivatives of Hyperbolic Functions</h2>
<p>有六种常见的双曲线函数（目前无用，且求导易证明）</p>
<p><img src="derivative16.png" alt=""></p>
<h2 id="Chain-Rule">Chain Rule</h2>
<p>复合函数的求导规则（未证明）</p>
<p>说复合函数不是很准确，这里给出的公式只嵌套了一层，实际可以嵌套n层。所以才叫<strong>Chain Rulu</strong>。求多层嵌套的复合函数需要多加小心，可以不用一步完成，分几步拆解。</p>
<p><img src="derivative17.png" alt=""></p>
<p>我们可以使用Chain Rule 和 (e^x^)’ = e^x^ 证明  (a^x^)’ = a^x^ ln(a)</p>
<h2 id="Implict-Differentiation">Implict Differentiation</h2>
<p>并不是所有的函数都能写成 y = f(x) 。</p>
<p>对于<strong>implict function</strong>，首先要记住，y 或 y(x) 其实是 x 的函数。第二步就是两边同时对x求导。</p>
<p><strong>implict function</strong> 的求导结果往往还包含y。</p>
<h2 id="Related-Rates">Related Rates</h2>
<p>当式子中存在两种函数时，如 x(t) 和 y(t) 。如果其中一个x’(t) 已知，那么就能求出y’(t) 。</p>
<p>在求解包含两种相关的函数的导数时，最重要的是要找到包含两个<strong>related rates</strong>的式子。</p>
<p>如果式子中含有更多的其它函数，需要进行<strong>消元</strong>。</p>
<h2 id="Higher-Order-Derivatives">Higher Order Derivatives</h2>
<p><strong>first derivative</strong> 和 <strong>second derivative</strong></p>
<p>对于多项式，如果其最高项的degree为n，那么其n+1阶求导及其后均为0。</p>
<p><img src="derivative18.png" alt=""></p>
<p>注意多阶导数和函数的n次方写法的区别</p>
<p><img src="derivative19.png" alt=""></p>
<p>高阶导数的写法</p>
<p><img src="derivative20.png" alt=""></p>
<h2 id="Logarithmic-Differentiation">Logarithmic Differentiation</h2>
<p>有时，通过log函数能够简化运算(一般使用<strong>ln()</strong>)。</p>
<p>适用场景</p>
<ol>
<li>式子可以分解为多个式子<strong>相乘</strong>或<strong>相除</strong></li>
<li>y = (f(x))^g(x)^ 。例如 y = x^x^</li>
</ol>
<p>最后，总结一下不同的带有指数的求导公式</p>
<p><img src="derivative21.png" alt=""></p>
<h1>Applications of Derivatives</h1>
<p>求导不仅仅是为了求导，是为了解决实际问题的。</p>
<h2 id="Rates-of-Change">Rates of Change</h2>
<p>复习上一章</p>
<h2 id="Critical-Points">Critical Points</h2>
<p>f(x) 的 Critical Points 的定义：</p>
<p><img src="derivative22.png" alt=""></p>
<p>注意前提中是 f© 必须存在，这个前提很重要但也容易被忽略。</p>
<h2 id="Minimum-and-Maximum-Values">Minimum and Maximum Values</h2>
<p>首先，存在绝对极值和相对极值。很好理解，绝对的极值即在整个定义域内均为最大或最小，而相对的极值仅在某区域内。</p>
<p><img src="derivative23.png" alt=""></p>
<p>一图以蔽之</p>
<p><img src="derivative24.png" alt=""></p>
<p>对于定义域两端的函数值能否成为相对极值，这一点一直有争议。本文中设定定义域两端的函数值不能成为相对极值。</p>
<p>绝对极值只能出现在<strong>相对极值</strong>和<strong>定义域两端的函数值</strong>中。</p>
<p>如果是连续函数，取一闭区间，则必存在绝对最大值和绝对最小值。定理表述如下</p>
<p><img src="derivative25.png" alt=""></p>
<p>但是，这条定理并没有告诉我们绝对极值出现在哪，或者会出现几次。我们知道绝对极值一定存在。</p>
<p>但是定理中规定了要取一闭区间。如果不取区间，那么可能不存在绝对极值。函数在闭区间的连续性也是一个重要的前提。</p>
<p>取到<strong>相对</strong>极值的条件是 Critical Point。定理如下</p>
<p><img src="derivative26.png" alt=""></p>
<p>但是反过来说并不成立，也就是说不是所有的Critical Point 都是相对极值。也就是说相对极值肯定是Critical Point ，Critical Points 是 all possible relative extreme 。</p>
<p>这个定理没说全。如果f’© 不存在，也是Critical Point ，也是 possible relative extreme。</p>
<p>重申一遍，我们说possible relative extreme 也就是说不是所有的Critical Point 都是相对极值。但是我们把所有的Critical Point 都找出来，那么所有的relative extreme 就肯定都在里面了，不会有缺漏。用俗话说，就是宁肯杀错一千，不可放过一个。</p>
<h2 id="Finding-Absolute-Extreme">Finding Absolute Extreme</h2>
<p>书中没说，但感觉这些定理的条件中几乎都需要函数满足<strong>连续性</strong>（continuous)。但是一般用到的函数基本都满足连续性。</p>
<p>首先我们需要根据前面的Extreme Value Theorem 确定函数在给定的闭区间<strong>存在</strong>绝对极值。再根据前面的Fermat’s Theorem ，所有的Critical Points 是 all possible relative extremes 。而根据我们之前的认识，所有的绝对极值只会出现在相对极值或函数区间两端的值中。</p>
<p>因此，所有的Critical Points 加上 函数区间两端的函数值 即是 all possible absolute extremes。</p>
<p>找绝对极值的一般步骤。记得要剔除不在闭区间的Critical Points。</p>
<p><img src="derivative27.png" alt=""></p>
<h2 id="The-shape-of-a-graph-part-I">The shape of a graph,part I</h2>
<p>首先，我们确认<strong>递增</strong>和<strong>递减</strong>的定义</p>
<p><img src="derivative28.png" alt=""></p>
<p>用一阶导数来定义则如下</p>
<p><img src="derivative29.png" alt=""></p>
<p>之前这步其实做过了。</p>
<p>首先确定函数的<strong>连续性</strong>。然后确认Critical Points 。在分割的每个区间内取一点，该点f’(x) (注意不是原函数)的符号即是此区间的符号。</p>
<p>重申：Critical Points 也包括了f’(x) 不存在的情况。这种情况下，f’(x) 也可能改变符号。</p>
<p>知道 f(x) 在哪些区间递增或递减，那么就能画出 f(x) 的草图。</p>
<p>判断Critical Point 是否是相对极值：</p>
<p><img src="derivative30.png" alt=""></p>
<h2 id="The-shape-of-a-graph-part-2">The shape of a graph, part 2</h2>
<p>这里需要用到<strong>二阶导数</strong>，主要是考虑函数的凹凸性(concavity)。如图所示。用书上的话说，函数如果趋于&quot;open up&quot; ，那么就是 Concave Up；如果趋于 &quot; open down &quot; ，那么就是 Concave down。</p>
<p><img src="derivative31.png" alt=""></p>
<p>数学定义：切线在函数上方或下方</p>
<p><img src="derivative32.png" alt=""></p>
<p>concavity 与函数的增减毫无关系。</p>
<p>inflection point 的定义</p>
<p><img src="derivative33.png" alt=""></p>
<p><img src="derivative34.png" alt=""></p>
<p>这里应该写错了，f’'(x) &lt; 0 应该是 concave down 。</p>
<p>因此，infection point 应该是 f’‘(x) = 0  或者 <strong>不存在</strong>的地方。 但是并不是 f’'(x) = 0 或者不存在的地方，就一定是 infection point 。</p>
<p>我们只有通过确认这个点两侧的凹凸性情况，我们才能确认infection point 。</p>
<p>这和前面的相对极值是类似的。所有的相对极值都是critical points ，但是不是所有的 critical points 都是 相对极值。只有确认了这个点两侧的递增递减情况，我们才能确认这个点是不是相对极值。</p>
<p>通过确定凹凸性我们能画出更精细的草图。</p>
<p>根据f&quot;(x) 的符号能确定 Critical point （只适用于f’(x) = 0 ，不适用于不存在）是否是相对极值。定理如下</p>
<p><img src="derivative35.png" alt=""></p>
<p>注意，这里没有说f’(x) 不存在的critical point 的情况。注意第三种情况下如果f’‘(x) = 0 , 那么可能是任何情况。那么就要使用 first derivative test 判断这个 critical point 两侧的f’(x) 的符号。</p>
<h2 id="The-Mean-Value-Theorem">The Mean Value Theorem</h2>
<p>Rolle’s Theorem ：满足一定条件的函数f’(x) ，两个相等的函数值之间一定存在一个点，其f’(x) = 0。</p>
<p><img src="derivative36.png" alt=""></p>
<p>The mean value theorem 如下</p>
<p><img src="derivative37.png" alt=""></p>
<p>一样的，这个定理没有告诉我们 c 在哪 , 只是说至少有一个 c。</p>
<p>Rolle’s Theorem 只是 mean value theorem 的一个特例。</p>
<h2 id="Optimization">Optimization</h2>
<p>求解极值的一般方法：</p>
<ol>
<li>
<p>通过<strong>Finding Absolute Extreme</strong> 方法。从critical points 和 endpoints 中找。需要满足两个条件：闭区间和连续性。</p>
</li>
<li>
<p>通过<strong>First Derivative Test</strong>方法。根据此方法，如果一个点两侧f’(x) 符号不同，则此点为相对极值。要求连续性。 如果只有一个Critical points , 易知如下定理。</p>
<p><img src="derivative38.png" alt=""></p>
</li>
<li>
<p>通过二阶求导。二阶求导的使用主要包括以下方面。一是去除一些critical points ，通过求critical points 的 二阶导数，我们能得知其是否是相对极值。二是如果只有一个critical point，判断其是否是我们要的绝对极值，这和第二点一致。</p>
<p><img src="derivative39.png" alt=""></p>
</li>
</ol>
<h2 id="More-Optimization-Problems">More Optimization Problems</h2>
<p>就是更多的题目。</p>
<p>一个小点：如果 求式子 A = B时，由于有根式，两边平方，A^2^=B^2^，此时求出的解不一定是真的解，需要带入原式进行后验。</p>
<p>证明：A^2^=B^2^ 其解可能是 A =B , 也可能是 A = -B。</p>
<h2 id="Indeterminate-forms-and-L’Hospital’s-Rule">Indeterminate forms and L’Hospital’s Rule</h2>
<p><img src="derivative40.png" alt=""></p>
<p>如果是0/0 或 无穷/无穷，那么其极限等于其一阶导数之商的极限。</p>
<p>对于其它类型的indeterminate forms（不确定形式），可以转换为上述的两种形式。</p>
<p><img src="derivative41.png" alt=""></p>
<h2 id="Linear-Approximations">Linear Approximations</h2>
<p>对于某一点的切线方程，可以用于近似估计附近点的函数值。</p>
<h2 id="Differentials">Differentials</h2>
<p>这里的Differentials 就是指 dy 和 dx</p>
<p>dy = f’(x) dx</p>
<p>dy dx 就是当x变化很小时，x 的变化量和 y 的变化量。</p>
<h2 id="Newton’s-Method">Newton’s Method</h2>
<p>这个方法目前没什么意义了。</p>
<p>估计f(x) 的根</p>
<p><img src="derivative42.png" alt=""></p>
<h2 id="Business-Applications">Business Applications</h2>
<p>商业中的实例。</p>
<h1>Integrals</h1>
<h2 id="Indefinite-Integrals">Indefinite Integrals</h2>
<p>首先我们要知道如何从导数函数反推原函数，注意需要加一个 常数c 。因为常数的导数是0。所以，实际上，如果只知道导数函数，求解出的原函数有无数个（因为c不确定）。</p>
<p>一些基础定义</p>
<p><img src="integral1.png" alt=""></p>
<p>不定积分的部分性质</p>
<p><img src="integral2.png" alt=""></p>
<p><img src="integral3.png" alt=""></p>
<p>积分对于变量之间的<strong>乘</strong>或<strong>除</strong>没有公式。</p>
<p>求解后，可以求导，看是否与被积函数一致。</p>
<h2 id="Computing-Indefinite-Integrals">Computing Indefinite Integrals</h2>
<p>其实和求导公式一致，不过是反过来。</p>
<h2 id="Substitution-Rule-for-Indefinite-Integrals">Substitution Rule for Indefinite Integrals</h2>
<p><img src="integral4.png" alt=""></p>
<p>容易得到，因为 d(g(x)) = g’(x) d(x) 。</p>
<p>替换后积分式子中不能再有x ，要全变成 u 表示的式子。</p>
<h2 id="More-Substitution-Rule">More Substitution Rule</h2>
<h2 id="Area-Problem">Area Problem</h2>
<h2 id="The-Definition-of-the-Definite-Integral">The Definition of the Definite Integral</h2>
<p><img src="integral5.png" alt=""></p>
<p>这里的定义没有说清楚每个小长方形的高选用哪个点的函数值。</p>
<p><img src="integral6.png" alt=""></p>
<p>对定积分的解释之一是，定积分是f(x) 在 x 轴上的<strong>净面积</strong>（net area) 。是原函数从 a 到 b 的变化量。</p>
<p><img src="integral7.png" alt=""></p>
<p><img src="integral8.png" alt=""></p>
<p><img src="integral9.png" alt=""></p>
<p><img src="integral10.png" alt=""></p>
<p>注意，不定积分要求在[a,b]间具有<strong>连续性</strong></p>
<h2 id="Substitution-Rule-for-Definite-Integrals">Substitution Rule for Definite Integrals</h2>
<p>不定积分换元的问题在于，原来的不定积分上下限都是针对x的，而不是u。</p>
<p>有两种策略：1. 最后将u 替换回 x  ; 2. 将原来的上下极限换成u的上下极限。我感觉第二种更方便。</p>
<h1>Applications of Integrals</h1>
<h2 id="Average-Function-Value">Average Function Value</h2>
<p><img src="integral11.png" alt=""></p>
<p><img src="integral12.png" alt=""></p>
<h2 id="Volumes-of-Solids-of-Revolution-Method-of-Rings">Volumes of Solids of Revolution / Method of Rings</h2>
<p>求旋转体的体积，不想看了，以后再看。</p>
<h1>Extras</h1>
<p>其实最后一部分附录是<strong>精华</strong>，看懂这些证明过程很重要。但是人生苦短，我急于初步完成这本书，因此只能先到这了，这一部分没看。2019年12月20号。</p>
<h2 id="Proof-of-Various-Limit-Properties">Proof of Various Limit Properties</h2>
<p>这一部分的证明都是严格根据极限的数学定义证明的，严谨但是繁琐，没看。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第八卷杂说-诡信</title>
    <url>/posts/e52a7502/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>【议曰：“ 代有诡诈反为忠信者也。” 抑亦通变，适时所为、见机而作而不俟终日者。】</p>
<p>孔子曰：“ 君子贞而不谅。” 又曰：“ 近逝于义，言可复也。” 由是观之，唯义所在，不在信也。【议曰：微哉！微哉！天下之事也，不有所废则无以兴。若忠于斯，必不诚于彼，自然之理矣。由是观之，则我之所谓忠，则彼之所谓诈也。然则忠之与诈，将何所取定哉？抑我闻之：夫臣主有大义，上下有定分，此百代不易之道也。故欲行忠，观臣主之义定；欲行信，顾上下之分明。苟分义不愆于躬，虽谲而不正可也。】何以明之？</p>
<p>叶公问孔子曰：“ 吾党有直躬者，其父攘羊而其子证之。” 孔子曰：“ 吾党之直者异于是，父为子隐，子为父隐，直在其中矣。”</p>
<p>楚子围宋，宋求救于晋。晋侯使解扬如宋，使无降楚，曰：“ 晋师悉起，将至矣。” 郑人囚而献诸楚，楚子厚赂之，使反其言。许之。登诸楼车，使呼宋人而告之，遂致其君命。楚子将杀之，使与之言曰：“ 尔既许不谷而反之，何故？非我无信，尔其弃之，速即尔刑！” 对曰：“ 臣闻之，君能制命为义，臣能承命为信。信载义而行之有利，谋不失利，以卫社稷，民之主也。义无二信，信无二命。君之赂臣，不知命也。受命以出，有死无殒，又何赂乎？臣之许君，以成命也。死而成命，臣之禄也！寡君有信臣，下臣获考，死又何求！” 楚之舍之以归。</p>
<p>【韩子曰：“ 楚有直躬者，其父窃羊而讦之，令尹曰：” 必杀之！“ 以为直于君而曲于父，执其子而罪之。由是观之，夫君之直臣，父之暴子也。鲁人从君战，三战三北，仲尼问其故，对曰：” 吾有老父，死莫之养也。“ 仲尼以为孝，誉而用之。以是观之，夫父之孝子，君之北人也。故令尹诛而楚奸不止，闻仲尼赏之，鲁人易降。此上下之利，若是其异也，而人主兼誉匹夫之行，而求致社稷之福，必不几矣。】</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第八卷杂说-钓情</title>
    <url>/posts/ed6fb8cc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>孔子曰：“ 未见颜色而言曰瞽”，又曰：“ 未信则以为谤己。” 孙卿曰：“ 语而当，智也，默而当，智也。” 尸子曰：“ 听言，耳目不惧，视听不深，则善言不往焉。” 是知将语者，必先钓于人情，自古然矣。</p>
<p>韩子曰：“ 夫说之难也，在知所说之心可以吾说当之。说之以厚利，则见下节而遇 卑贱，必弃远矣【所说实为厚利则阴用其言而显弃其身，此不可不知也】。说之以名高，则见无心而远事情，必不收矣【所谓实为名高而阳收其身而实疏之。此不可不知也】。事以密成，语以泄败，未必其身泄之也，而说及其所匿之事，如是者身危【周泽未渥也，而语极知，说行而有功则德亡，说不行而有败则见疑，如是者身危】。贵人有过端，而说者明言善议以推其恶者身危。贵人或得计而欲自己为功，说者与知焉则身危。强之以其所不为，止之以其所不能已者身危。“ 又曰：” 与之论大人，则以为间己，与之论细人，则以为鬻权。论其所爱，则以为借资，论其所憎，则以为尝已。顺事陈意则曰怯懦而不尽，虑事广肆，则曰草野而居侮，此不可不知也……彼自智其计，则勿以其失当之，自勇其断，则勿以其敌怒之。“ 【凡说须旷日弥久，周泽而不凝，交争而不罪，乃明计利害，以致其功。直指是非，以饰其身。以此相持，此说之成也。】</p>
<p>荀悦曰：” 夫臣下所以难言者，何也？言出乎身则咎悔及之矣。“ 故曰：举过揭非，则有干忤之咎，劝励教诲，则有侠上之议。言而当，则耻其胜己也，言而不当，则贱其愚也。先己而同，则恶其夺己明也，后己而同，则以为从顺也。违下从上，则以为谄谀也，违上从下，则以为雷同也。言而浅露，则简而薄之，深妙弘远，则不知而非之。特见独智，则众恶其盖己也，虽是而不见称，与众同智，则以为附随也，虽得之不以为功。谦让不争，则以为易容，言而不尽，则以为怀隐，进说竭情，则以为不知量。言而不效，则受其怨责，言而事效，则以为固当。利于上不利于下，或便于左则不便于右，或合于前而忤于后，此下情所以常不通。仲尼发愤，称”予欲无言“者，盖为语之难也。何以明其难也？</p>
<p>昔宋有富人，天雨坏墙，其子曰：” 不筑，且有盗。“ 其邻人亦云。暮而果大亡，其家智其子而疑邻人之父。郑武公欲伐胡，乃以其子妻之，因问群臣：” 吾欲用兵，谁可伐者？“ 关其思曰：” 胡可伐。“ 乃戮关其思，曰：” 胡，兄弟之国也，子言伐之，何也？“ 胡君闻之，以为郑为亲己而不备郑，郑人袭胡，取之。此二说者，其智皆当矣，然而甚者为戮，薄者见疑，非智之难也，处智则难。</p>
<p>卫人迎新妇，妇上车，问：” 骖马，谁马也？“ 御者：” 借之。“ 新妇谓仆曰：” 拊骖，无苦服。“ 车至门，拔教：” 逆母，灭橹，将失火。“ 入室，见臼，曰：” 徙牖下，妨往来者。“ 主人大笑之。此三言，皆要言也，然而不免为笑者，早晚之时失矣。此说之难也。</p>
<p>说者知其难也，故语必有钓，以取人情。何以明之？</p>
<p>昔齐王后死，欲置后而未定，使群臣议。薛公田婴欲中王之意，因献其珥而美其一，旦日因问美珥所在，因劝立以为后，齐王大悦，遂重薛公。此情可以物钓也。</p>
<p>申不害始合于韩王，然未知王之所欲也，恐言而未必中于王也。王问申子曰：“吾谁与而可？” 对曰：“ 此安危之要，国家之大事也，臣请深惟而苦思之。” 乃微请赵卓、韩冕曰：“ 子，皆国之辩士也，夫为人臣者，言何必同？尽忠而已矣。” 二人各进议于王以事。申子微视王之所悦，以言于王，王大悦之。此情可以言钓也。</p>
<p>吴伐越，越栖于会稽，勾践喟然叹曰：“吾终此乎？” 大夫种曰：“汤系夏台，文王囚姜里，重耳奔翟，齐小白奔莒，其卒霸王。由是观之，何遽不为福乎？” 勾践既得免，务报吴。大夫种曰：“ 吾观吴王政骄矣，请尝之。” 乃贷粟以卜其事。子胥谏勿与，王遂与之。子胥曰：“ 王不听谏，后三年，吴其墟矣！” 太宰嚭闻之，馋曰：“ 伍员貌忠而实忍人。” 吴杀子胥，此情可以事钓也。</p>
<p>客以淳于髡见梁惠王，惠王屏左右，再见之，终无言，王怪之，让客。客谓淳于髡，髡曰：“ 吾前见王，王志在驰逐，后复见王，王志在音色，是以默然。” 客具以报王，王大骇曰：“ 淳于先生，诚圣人也。前有善献马者，寡人未及试，会生来。后有献讴者，未及试，又会生至。寡人虽屏人，然私心在彼。” 此情可以志钓也。</p>
<p>智伯从韩魏之君伐赵，韩魏用赵臣张孟谈之计，阴谋叛智伯。张孟谈因朝智伯，遇智果于辕门之外。智果入见智伯，曰：“ 二主殆将有变，臣遇张孟谈，察其志矜而行高，见二君色动而变，必背君矣。” 智伯不从，智果出，遂更其姓曰辅氏。张孟谈见赵襄子曰：“ 臣遇智果于辕门之外，其视有疑臣之心。入见智伯而更其族，今暮不击，必后之矣。” 襄子曰：“诺！” 因与韩魏杀守堤之吏，决水灌智伯军，此情可以视钓也。</p>
<p>殷浩仕晋，有盛名，时人观其出处，以卜江左兴亡，此情可以贤钓也。【 《吕氏春秋》曰：“ 夫国之将亡，有道者先去。”】</p>
<p>【《易》曰：“将叛者，其辞惭，中心疑者，其辞枝。吉人之辞寡，躁人之辞多。诬善之人，其辞游，失其守者，其辞屈。” 】</p>
<p>由是观之，夫人情必见于物。【昔者晋公好色，骊姬乘色以壅之。吴王好广地，太宰陈伐以壅之。桓公好味，易牙蒸子以壅之。沉冥无端，甚可畏也。故知人主之好恶，不可见于外。所好恶见于外，则臣妾乘其所好恶以行壅制焉。故曰：人君无意见则为下饵。此之谓也。】能知此者，可以纳说于人主矣。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第三卷权变-正论</title>
    <url>/posts/6a24346d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>【议曰：“反经”、“是非”、“适变” 三篇，虽博辩利害，然其弊流遁漫，羡无所归。故作“正论”以质之。】</p>
<p>孔子曰：“六艺于治一也。《礼》以节人，《乐》以发和，《书》以导事，《诗》以达意，《易》以神化，《春秋》以义。”</p>
<p>【班固曰：“ 乐者，圣人之所以乐也，而可以善人心，其感人也深。故先王著其教焉。夫人又血气心知之性，而无衰乐喜怒之常。应感而动，然后心术形焉。故纤微憔悴之音作，而民思忧；阐谐慢易之音作，而民康乐；粗厉猛奋之音作，而民刚毅；廉直正诚之音作，而民肃静；宽裕顺和之音作，而民慈爱；流僻邪散之音作，而民淫乱。先王耻其乱也，故制《雅》、《颂》之声。本之情性，稽之度数，制之礼义，合生气之和，导五常之行，使之阳而不散，阴而不集，刚气不怒，柔气不摄，四畅交于中，而发作于外。足以感人之善心，而不使邪气得接焉。是先王立乐之方也。”</p>
<p>班固曰：“人涵天地阴阳之气，有喜怒哀乐之情，天禀其性而不节也，圣人能为之节而不能绝也。故像天地而制礼乐，所以通神明，立人伦，正情性，节万事也。……。故孔子曰：‘ 安于治人，莫善于礼；风易俗，莫善于乐。揖让而治天下者，礼乐之谓也。’ ”】</p>
<p>【司马谈曰：“ 儒者，博而寡要，劳而少功，是以其事难尽从，然其 叙君臣父子之礼，列夫妇长幼之别，不可易也。夫儒者，以‘六艺’为法，经传以千万，累世不能通其学，当年不能究其礼，故曰‘ 博而寡要，劳而少功 ’ 。若夫列君臣父子之礼，叙夫妇长幼之别，虽百家勿能易也。”</p>
<p>司马谈曰：“ 阴阳之术，大详而众忌讳，使人拘而多畏，然其叙四时之大顺，不可失也。夫阴阳四时，八位十二度，二十四节，各有教令。曰顺之者昌，逆之者亡，未必然也。故曰使人拘而多忌。夫春生夏长，秋收冬藏，此天下之大经，弗顺则无以为天下纪纲。故曰叙四时之大顺，不可失也。”</p>
<p>司马谈曰：“ 法家严而少恩；然正君臣上下之分，不可改也。夫法家不别亲疏，不殊贵贱，一断于法，则亲亲尊尊之恩绝矣。可使行一时之计，而不可长用也。故‘ 严而少恩 ’。至于尊主卑臣，明职分不相逾越，虽百家不能改也。”</p>
<p>司马谈曰：“ 墨家俭而难遵，是以其事不可偏循。然其强本节用，不可废也。】</p>
</blockquote>
<blockquote>
<p>数子之言，当世得失，皆悉究矣。然多谬通方之训，好申一隅之说。贵清净者，以席上为腐论；束名实者，以柱下为诞辞。或推前王之风，可行于当年，有引救弊之规，宜流于长世。稽之笃论，将为弊矣。由此言之，故知有法无法，因时为业，时止则止，时行则行，动不失其时，其道光明。非至精者，孰能通于变哉？</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第三章权变-适变</title>
    <url>/posts/1e7152bf/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>昔先王当时而立法度，临务而制事，法宜其时则理，事适其务故有功。今时移而法不变，务易而事以古，是则法与时诡，而事与务易，是以法立而时益乱，务无而事益废。此圣人之理国也，不法古，不修今，当时而立功，在难而能免。</p>
<p>【秦孝公用卫鞅。鞅欲变法，孝公恐天下议己，疑之。卫鞅曰：“疑行无名，疑事无功。夫有高人之行者，固见非于世；有独智之虑者，必见教于人。愚者暗于成事，智者见于未萌。人不可与虑始，而可与乐成。论至德者，不和于俗；成大功者，不谋于众。是以圣人苟可以强国，不法其故；苟可以利人，不循其礼。” 孝公曰：“ 善。” 甘龙曰：“ 不然。圣人不易人而教，智者不变法而治。因人而教，不劳而功成。缘法而理，吏习而人安。” 卫鞅曰：“ 龙之所言，世俗之言。常人安于习俗，学者溺于所闻。以此两者居官守法可也，非所以与论于法之外也。三代不同礼而王；五霸不同法而霸。智者作法，愚者制焉。贤者更礼，不肖者拘焉。” 杜贽曰：“ 利不百，不变法；功不十，不易器。法古无过，修礼无邪。” 卫鞅又曰：“ 治代不一道，便国不法故。故汤武不循古而王，夏殷不易礼而亡。反古者不可非，而循礼者不足多。” 孝公曰：“ 善。” 遂变法也。】</p>
<p>由是言之，故知若人者，各因其时而建功立德焉。【孟子曰：“ 虽有磁基，不如遇时；虽有智慧，不如逢代。” 范蠡曰：“ 时不至，不可强生；事不究，不可强成。” 《语》 曰：“ 圣人修备以待时也。” 】</p>
<p>何以知其然耶？桓子曰：“ 三皇以道治，五帝用德化，三王由仁义，五伯用权智。” 【说曰：无制令刑罚谓之皇，有制令，无刑罚谓之义；赏善诛恶，朝诸侯，朝事，谓之王；兴兵众，立约盟，以信义矫代谓之伯。文子曰：“ 帝者，贵其德也；王者，尚其义也；霸者，迫其理也。道狭然后任智，德薄然后任刑，明浅然后任察。议曰：夫建国立功，其政不同也如此。】</p>
<p>五帝以上久远，经传无事，唯王霸二盛之类，以定古今之理焉。【秦汉居帝王之位，所行者霸事也。故以为德之次。】</p>
<p>夫王道之治，先除人害，而足其衣食。</p>
<p>【论曰：” 五亩之宅，树之以桑，匹妇蚕之，年五十者，可以衣帛矣。百亩之田，数口之家，耕稼修理，可以无饥矣。鸡豚狗彘之畜，不失其时，老者可以食肉矣。夫上无贪欲之求，下无奢淫之人，藉税省少而徭役不繁，其仕者，食禄而已，不与人争利焉。是以产业均而贫富不能相悬也。“ 】</p>
<p>然后教以礼仪。</p>
<p>【故明王审己正统，慎乃其位。宫室舆服不逾礼制，九女正序于内，三公分职于外。制井田以齐之，设诸侯以牧之，使饶不溢侈，少不匮乏，然后申以辟雍之化，示以揖让之容，是以和气四塞，祸乱不生，此圣王之教也。】</p>
<p>而威以刑诛，使知好恶去就。</p>
<p>是故大化四凑，天下安乐，此王者之术。</p>
<p>【王者，父天母地，调和阴阳，顺四时而理五行，养黎元而育群生，故王之为言往也。盖言其惠泽，优游善养润天下，天下归往之，故曰王也。】</p>
<p>霸功之大者，尊君卑臣，权统由一，政不二门，赏罚必信，法令著明，百官修理，威令必行。</p>
<p>【夫霸君亦为人除难兴利以富国强兵，或承衰乱之后，或兴兵征伐。皆未得，遵法度，申文理，度代而制，因时施宜，以从便善之计，而务在于立功也。】此霸者之术。</p>
<p>【王道纯而任德，霸道驳而任法。此优劣之差也。】</p>
<p>《道德经》曰：” 我无为而人自化。“ 《文子》曰：” 所谓无为者，非谓引之不来，推之不往，谓其循理而举事，因资而立功，推自然之势也。“ 【故曰：” 智而好问者圣；勇而好问者胜。乘众人之智，即无不任也；用众人之力，即无不胜也。故圣人举事，未尝不因其资而用也。】 故曰：汤武，圣主也，而不能与越人乘舲舟，泛江湖。伊尹，贤相也，而不能与胡人骑原马，服**。孔、墨，博通也，而不能与山居者入榛薄，出险阻。</p>
<p>由是观之，人智于物，浅矣，而欲以昭海内，存万物，不因道理之数，而专己之能，则其穷不远。故智不足以为理，勇不足以为强，明矣。然而君人者，在庙堂之上而知四海之外者，因物以识物，因人以知人也。</p>
<p>【《吕氏春秋》曰：“ 是天无形而万物以成，大圣无事而千官尽能，此谓不教之教，无言之昭业。” 】</p>
<p>夫冬日之阳，夏日之阴，万物归之，而莫之使。至精之感，弗召自来。待目而昭见，待言而使令，其于理难矣。</p>
<p>【《文子》曰：“ 三月婴儿，未知利害，而慈母之忧喻焉者，情也。” 故曰：“ 言之用者小，不言之用者大。又曰：不言而信，不施而仁，不怒而威，是以天心动化者也。施而仁，言而信，怒而威，是以精诚为之者也。施而不仁，言而不信，怒而不威，是以外貌为之也。】</p>
<p>【庄子曰：” 天地有大美而不言，四时有明法而不议，万物有成理而不说。圣人无为，大圣不作，观于天地之谓也。】</p>
<p>不言之令，不视之见，圣人所以为师。此黄老之术也。</p>
<p>六经之理，贵于未乱；兵家之胜，贵于未战。</p>
<p>此孔氏之术也。【议曰：孔氏之训，务德行义，盖王道也。】</p>
<p>墨子曰：“ 古之人未知为宫室，就陵阜而居，穴而处，故圣王作为宫室。为宫室之法，高足以避润湿，边足以圉风寒。宫墙之高，足以别男女之礼。谨此则止，不以为观乐也。故天下之人，财用可得而足也。当今之王为宫室则与此异矣。必厚敛于百姓以为宫室，台榭曲直之望，青黄刻镂之饰，为宫室若此，故左右皆法而象之。是以财不足以待凶饥，振孤寡，故国贫而难理也。为宫室不可不节。【议曰：此节宫室者。】</p>
<p>古之人未知为衣服，时衣皮带茭，冬则不轻而暖，夏则不轻而清。圣王以为不中人之情，故圣人作，诲妇人，以为人衣。为衣服之法，冬则练帛，足以为轻暖，夏则絺绤，足以为轻清，谨此则止，非为荣耳目，观于人也。是以其人用俭约而易治，其君用财节而易赡也。当今之王，其为衣服，则与此异矣。必厚敛于百姓，以为文彩靡曼之衣，铸金以为钩，珠玉以为佩。由此观之，其为衣服，非为身体，皆为观好耶。是以其人淫僻而难治，其君奢侈而难谏。夫以奢侈之君，御淫僻之人，欲国无乱，不可得也。为衣服不可不节。”【 议曰：此节衣服也。】</p>
<p>此墨翟之术也。【议曰：墨家之议，去奢节用，盖强本道。】</p>
<p>商子曰：“ 法令者，人之命也，为治之本。【慎子曰：” 君人者，舍法而以身治，则受赏者虽当，望多无穷；受罚者虽当，望轻无已。君舍法而以心裁轻重，怨之所由生也。是以分马者之用策，分田者之用钩，非以钩策为过人之智也，所以去私塞怨也。故曰：夫君任法而不躬为，则怨不生而上下和也。“ 】 一兔走，百人逐之，非以兔可分为百，由名分之未定也。卖兔满市，盗不敢取者，由名分已定也。故名分未定，虽尧舜禹汤，且皆加务而逐之。名分之定，则贫盗不敢取。故尧舜圣人之为法令也，置官也，置吏也，所以定分也。名分定则大诈贞信，巨盗原悫，而各自治也。” 【《尹文子》曰：“ 名定则物不竞，分明则私不行。物不竞，非无心，由名定，故无所措其心；私不行，非无欲，由分明，故无所措其欲。然则心欲人人有之，而得同于无心无欲者，在制之有道故也。” 】</p>
<p>申子曰：“ 君如身，臣如手，君设其本，臣操其末。为人君者，操契以责其名。名者，天地之网，圣人之符。张天地之网，用圣人之符，则万物无所逃矣。”</p>
<p>此商鞅、申、韩之术也。</p>
<p>【恒范曰：“ 夫商鞅申韩之徒，贵尚谲诈，务行苛刻。废礼义之教，任刑名之教，不师古，始败俗伤化。此则伊尹、周公之罪人也。然其尊君卑臣，富国强兵，守法持术，有可取焉。逮至汉兴，有宁成，郅都之辈，仿商、韩之治，专以杀伐残暴为能，顺人主之意，希旨之行，要时趋利，敢行败祸，此又商、韩之罪人也。然其抑强族，抚孤弱，清己禁奸，背私立公，亦有取焉。至于晚代之所谓能者，乃犯公家之法，赴私门之势，废百姓之务，趋人间之事，决烦理务，临时苛辩，使官无谴负之累，不省下人之冤，复是申、韩、宁、郅之罪人也。”】</p>
<p>由是观之，故知治天下者，有王霸焉，有黄老焉，有孔墨焉，有申商焉，此所以异也，虽经纬殊制，救弊不同，然康济群生，皆有以矣。今议者或引长代之法，诘救弊之言【议曰：救弊为夏人尚忠，殷人尚敬，周人尚文者】；或引帝王之风，讥霸者之政，不论时变，而务以饰说。故是非之论，纷然作矣。言伪而辩，顺非而泽，此罪人也。故君子禁之。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第三卷权变-反经</title>
    <url>/posts/7d0687a0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>《韩诗外传》曰：“夫士有五反，有势尊贵不以爱人行义理，而反以暴傲。” ——【 反贵也。古语曰：” 富能富人者，欲贫不可得；贵能贵人者，欲贱不可得；达能达人者，欲穷不可得。“ 梅福曰：“ 存人所以自立也；壅人所以自塞也。” 】</p>
<p>家富厚不以振穷救不足，而反以侈靡无度。 —— 【反富也。】</p>
<p>资勇悍不以卫上攻战，而反以侵凌私斗。 —— 【反勇也。凡将帅轻去就者，不可使镇边，使仁德守之则安矣。】</p>
<p>心智慧不以端计教，而反以事奸饰非。 —— 【反智慧也。《说苑》曰：“ 君子之权谋正，小人之权谋邪。” 】</p>
<p>貌美好不以统朝莅人，而反以盅女从欲。 —— 【反貌也。】</p>
<p>此五者，所谓士失其美质。</p>
</blockquote>
<blockquote>
<p>太公曰：“明罚使人畏慑，人畏慑则变故出。 —— 【反明罚也。】 明察使人扰，人扰则人徙，人徙则不安其处，易以成变。” —— 【反明察也。】 太公曰：“ 明赏则不足，不足则怨长。明王理人，不知所好，而知所恶；不知所归，而知所去。使人各安其所生，而天下静矣。”</p>
<p>晋刘颂曰：“ 凡监司欲举大而略小，何则？ 夫细过微阙，谬忘之失，此人情所必有，所固不许在不犯之地，而悉纠以法，则朝野无立人。此所谓以治而乱也。”</p>
<p>韩子曰：“儒者以文乱法，侠者以武犯禁。“</p>
<p>慎子曰：” 忠未足以救乱代而适足以重非。** 。然则孝子不生慈父之义【六亲不和有孝慈】，而忠臣不生于圣君之下【国家昏乱有忠臣】。故明主之使其臣也，忠不得过职，而职不得过官。 —— 【反忠也]</p>
</blockquote>
<p>这段话我的理解，如果不是因为国家昏乱，则个人的忠名不显。而个人的忠名越显，反而越彰显出国家昏乱（如果只是敢于进言而无助于事），因此“适足以重非”。</p>
<blockquote>
<p>跖之徒问于跖曰：“盗亦有道乎？” 跖曰：” 何适而无有道耶？夫妄意室中之藏，圣也。入先，勇也。出后，义也。知可否，智也。分均，仁也。五者不备而能成大盗者，天下未之有也。“</p>
</blockquote>
<blockquote>
<p>由是观之，善人不得圣人之道不立，盗跖不得圣人之道不行。天下之善人少而不善人多，则圣人之利天下也少而害天下也多矣。 —— 【反仁义也。】</p>
</blockquote>
<blockquote>
<p>汉武时，河间献王来朝，造次必于仁义。武帝色然难之，谓曰：” 汤以七十里，文王以百里，王其勉之！” 王知其意，归即纵酒。</p>
<p>由是言之，夫仁义兼济，必有分乃可。故尸子曰：“ 君臣父子，上下长幼，贵贱亲疏，皆得其分理。爱得分曰仁。施得分曰义。虑得分曰智。动得分曰适。言得分曰信。皆得其分而后为成人。”</p>
<p>由是言之，跖徒之仁义非其分矣。</p>
</blockquote>
<blockquote>
<p>由是言之，夫仁义礼乐、名法刑赏、忠孝贤智之道，文武明察之端，无隐于人，而常存于代，非自昭于尧汤之时，非故逃于桀纣之朝。用得其道则天下理，用失其道则天下乱。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第二卷德行-德表</title>
    <url>/posts/9c3a31d9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>孔子曰：“性相近也，习相远也。” 言嗜欲之本同，而迁染之途异也。夫刻意则行不肆，牵物则其志流。是以圣人导人理性，裁抑流宕，慎其所与，节其所偏。故《传》曰：“ 审好恶，理情性，则王道毕矣。” 治性之道，必审己之所有余，而强其所不足。盖聪明流通者，戒于太察；寡言少见者，戒于壅蔽；勇猛刚强者，戒于太暴；仁爱温良者，戒于无断；湛静安舒者，戒于后时；广心浩大者，戒于遗忘。</p>
</blockquote>
<blockquote>
<p>此拘亢之材，非中庸之德也。</p>
</blockquote>
<blockquote>
<p>文子曰：“ 凡人之道，心欲小，志欲大，智欲圆，行欲方，能欲多，事欲少。” 所谓“心小”者，虑患未生，戒祸慎微，不敢纵其欲也；“ 志大” 者，兼包万国，一齐殊俗，是非辐辏，中之为毂也；“智圆” 者，终始无端，方流四远，深泉而不竭也；“行方”者，直立而不挠，素白而不污，穷不易操，达不肆志也；“能多” 者，文武具备，动静中仪也；“事少” 者，执约以治广，处静以待躁也。</p>
<p>夫天道极即反，盈即损。故聪明广智，守以愚；多闻博辩，守以俭；武力毅勇，守以畏；富贵广大，守以狭；德施天下，守以让。此五者，先王所以守天下也。</p>
<p>《传》曰：“无始乱，无怙富，无恃宠，无违同，无傲礼，无骄能，无复怒，无谋非德，无犯非义。“  此九言，古人所以立身也。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>说文解字第四册笔记</title>
    <url>/posts/da100df3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>羁</strong>：<br>
羁，马络头也。<br>
原义是马络头。进而延申指用笼头系住马头。<br>
由络马头延申为束缚。例如“放荡不羁”。</p>
<p><strong>益</strong>：<br>
益，饶也。<br>
甲骨文从皿，“皿”上有很多“水”，会水太多而流出盆外之意。</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>说文解字</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>说文解字第三册笔记</title>
    <url>/posts/259f533d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>逮</strong>：<br>
逮，及也。<br>
金文似右手揪住一条尾巴的样子。</p>
<p><strong>族</strong>：<br>
族，矢锋也。束之族族也。<br>
族，原义是箭头。</p>
<p><strong>感</strong>：<br>
感，动人心也。<br>
感的原义是人心受到外界影响而触动。</p>
<p><strong>意</strong>：<br>
意，志也。从心察言而知意也。<br>
意，意向。用心去考察别人的言语就知道他的意向。</p>
<p><strong>期</strong>：<br>
期，会也。<br>
期，约会。</p>
<p><strong>拜</strong>：<br>
拜，手至地也。<br>
拜，两手至地。<br>
甲骨文似双手捧禾麦奉献给神祖之行，会向神祖拜祭祈祷之意。</p>
<p>​</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>说文解字</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第二卷德行-臣行</title>
    <url>/posts/6feddce9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>没有细看，取其大略。</p>
<blockquote>
<p>夫人臣萌芽未动，形兆未见，昭然独见存亡之机，得失之要，豫禁乎未然之前，使主超然立乎显荣之处，如此者，圣臣也。</p>
<p>虚心尽意，日进善道，勉主以礼义，谕主以长策，将顺其美，匡救其恶，如此者，大臣也。</p>
<p>夙兴夜寐，进贤不懈，数称往古之行事，以厉主意，如此者，忠臣也。</p>
<p>明察成败，早防而救之，塞其间，绝其源，转祸以为福，君终己无忧，如此者，智臣也。</p>
<p>依文奉法，任官职事，不受馈赠，食饮节俭，如此者，贞臣也。</p>
<p>国家昏乱，所为不谀，敢犯主之严颜，而言主之过失，如此者，直臣也。</p>
<p>是谓六正。</p>
</blockquote>
<blockquote>
<p>安官贪禄，不务公事，与世沉浮，左右观望，如此者，具臣也。</p>
<p>主所言皆曰“善”，主所为皆曰“可”，隐而求主之所好而进之，以快主之耳目。偷合苟容，与主为乐，不顾后害，如此者，谀臣也。</p>
<p>中实险诐，外貌小谨，巧言令色，又心疾贤。所欲进则明其美，隐其恶；所欲退则彰其过，匿其美，使主赏罚不当，号令不行，如此者，奸臣也。</p>
<p>智足以饰非，辩足以行说，内离骨肉之亲，外妒乱于朝廷，如此者，馋臣也。</p>
<p>专权擅势，以轻为重；私门成党，以富其家；擅矫主命，以自显贵，如此者，贼臣也。</p>
<p>谄主以佞邪，坠主于不义，朋党比周，以蔽主明，使白黑无别，是非无闻；使主恶布于境内，闻于四邻，如此者，亡国之臣也。</p>
<p>是谓六邪。</p>
</blockquote>
<blockquote>
<p>议曰：夫圣人德全，器无不备。中庸已降，才则好偏。故曰：柴也愚，参也鲁，师也辟，由也喭。由此观之，全德者鲜矣！全德既鲜，则资矫情而力善矣！然世恶矫伪，而人贤任真。使其真贪愚而亦任之，可为贤乎？对曰：吁！何为其然？夫肖貌天地，负阴抱阳，虽清浊贤愚，其性则异，而趋走嗜欲，所规则同。故靡颜腻理，人所悦也；乘坚驱良，人所爱也；哭心贞节，人所难也；徇公灭私，人所苦也。不以礼教节之，则荡而不制，安肯攻苦食淡，贞洁公方，临财廉而取与义乎？故《礼》曰：”欲不可纵，志不可满。“ 古语云：” 廉士非不爱财，取之有道。“ 诗云：” 如切如蹉，如琢如磨。“ 皆矫伪之谓也。 若肆其愚态，随其鄙情，名曰任真而贤之，此先王之罪之也。故吾以为矫伪者，礼义之端；任真者，贪鄙之主。夫强仁者，庸可诬乎？</p>
</blockquote>
<blockquote>
<p>或曰：”长平之事，白起坑赵卒四十万，可为奇将乎？“</p>
<p>何晏曰：”白起之降赵卒，诈而坑其四十万，其徒酷暴之谓乎？ 后亦难以重得其志矣！ 向使众人预知降之必死，则张虚拳，犹可畏也。况于四十万披坚执锐哉？天下见降秦之将头颅依山，归秦之众骸积成丘，则后日之战，死当死耳，何众肯服，何城肯下乎？是为虽能裁四十万之命，而适足以强天下之战。欲以一期之功，而乃更坚诸侯之守。故兵进而自伐其势，军胜而还丧其计，何者？设使赵众复合，马服更生，则后日之战，必非前日之对也，况今皆使天下为后日乎！其所以终不敢复加兵于邯郸者，非但忧平原之补缝，患诸侯之救至也，徒讳之而不言耳。且长平之事，秦人十五以上，皆荷戟而向赵矣。夫以秦之强，而十五以上，死伤过半，此为破赵之功小，伤秦之败大也。又何称奇哉？“</p>
<p>议曰：黄石公称柔者能制刚，弱者能制强。柔者德也，刚者贼也。柔者人之所助，刚者怨之所居。是故纣之百克而卒无后，项羽兵强，终失天下。故随何曰：” 使楚胜，则诸侯自危惧而相救。夫楚之强，适足以致天下兵耳。“ 由是观之，若天下已定，借一战之胜，诈之可也。若海内纷纷，雌雄未决而失信于天下，败亡之道也。当亡国之时，诸侯尚强，而白起乃坑赵降卒，使诸侯畏之而合纵。诸侯合纵，非秦之利，为战胜而反败。何晏之论当矣。</p>
</blockquote>
<p>有意思！长平之战或胜于军事，但输于政治。</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>说文解字第二册笔记</title>
    <url>/posts/c3d58b1a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>绝</strong>：<br>
绝，断丝也。<br>
绝，用刀断丝为二。</p>
<p><strong>怕</strong>：<br>
怕，无为也。</p>
<p><strong>守</strong>：<br>
守，守官也。<br>
“守”，金文是屋子里的一只手，由手在屋内掌管职责之意。<br>
原义是掌管职守。</p>
<p><strong>安</strong>：<br>
安，静也。<br>
女子坐在房中，会平安、安适之意。</p>
<p><strong>家</strong>：<br>
家，居也。<br>
“屋里有豕”为“家”。</p>
<p><strong>圣</strong>：<br>
圣，通也。<br>
圣，双耳畅通。<br>
甲骨文从耳，从口。<br>
原义是通达，延申指聪明、才智超群。在很早的时候人们传播知识、交流经验主要通过口耳相传，于是，只有善于聆听的人才能得到这么多的知识，故“圣”延申指博学多闻的人。</p>
<p><strong>拯</strong>：<br>
抍，上举也。<br>
原义是向上举，延申为援助、救济。</p>
<p><strong>报</strong>：<br>
报，当罪人也。<br>
报，判决罪人。甲骨文和金文左边是一个刑具，右边是一只手抓住一个人给其加上刑具的样子，会给人治罪之意。<br>
“报”的原义是按律判决罪人。例如《韩非子》：“报而罪之。” 意思是判决而治他的罪。判决罪人需要告知上级审批，故延申指告诉、告知。例如“通报”、“报警”。也引申为报答，例如”投桃报李“。<br>
好的回报是报答，但恶的回报就是报复了，所以”报“又指报复。例如”报仇雪耻“。也引申指由某种行为得到的结果。例如”善有善报“。</p>
<p><strong>莠</strong>：<br>
莠，禾粟下生莠。<br>
莠，是在禾粟之间生长的似禾非禾的东西叫“莠”。<br>
“莠”的原义是一种田间生长的外形似禾苗的杂草，其穗上似狗尾巴的毛，也叫狗尾巴草。例如《诗经》：“惟莠骄骄。” 意思是只有莠草长得十分茂盛。莠会妨碍禾苗生长，故延申成恶草的通称。也引申为坏、恶。例如“良莠不齐”。</p>
<p><strong>英</strong>：<br>
英，草荣而不实者。<br>
英，草只开花却不结实。<br>
“英”的原义是花。如《桃花源记》：“芳草鲜美，落英缤纷。”<br>
花是美好的，厮役延申成美好、杰出、优异。</p>
<p><strong>萌</strong>：<br>
萌，草芽也。<br>
“萌”的原义是草木的芽。延申指发芽；又引喻事情刚刚显露的发展趋势或者情况、开端。例如《韩非子》：“圣人见微以知萌，见端以知末。” 又指开始发生。例如“萌动”。</p>
<p><strong>大</strong>：<br>
大，天大，地大，人亦大。故大象人形。<br>
“大”是象形字。甲骨文、金文、小篆的形状全部似一个正面站立、张开双手双脚的人的形象。<br>
“大”的原义是人。人为“万物之灵”，上古以人为大，故延申为“大小”之“大”。也引申表示重要、重大。</p>
<p><strong>太</strong>：<br>
“太”是象形字。甲骨文中的“太”字就是“大”形，似正面站立的人形。金文下面增加了一个曲笔，以与“大”相区别。隶变以后楷书写成“太”。<br>
“太”是在“大”的基础上再加了一点而形成的，故延申成过于。如杜甫《新婚别》：“暮婚晨告别，无乃太匆忙！” 延申为最、极。进而延申指身份最高或者辈分更高的。例如”太公“、”太后“。</p>
<p><strong>天</strong>：<br>
天，颠也。至高无上，从一大<br>
天，头顶。<br>
”天“的原义是人的头顶；两眉之间，称为”天庭“。人至高无上的部分为”天“（头），自然界至高无上的部分也为“天”。</p>
<p><strong>夫</strong>：<br>
夫，丈夫也。从大，一以象簪也。周制以八寸为尺、十尺为丈。人长八尺，故曰丈夫。<br>
夫，成年男子。从大，一用以似成年男子头发上的簪子之形。</p>
<p><strong>君</strong>：<br>
君，尊也。从尹，发号，故从口。</p>
<p><strong>混</strong>：<br>
混，丰流也。从水昆声。<br>
混，盛大的水流。<br>
“混”的原义是水势盛大。水大则泥多，容易浑浊，故延申指浑浊，水多泥、多杂质而不清澈。进而延申指糊涂、不懂事。</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>说文解字</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-政体</title>
    <url>/posts/a3353214/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>【议曰：夫政理，得人则心，失人则毁。故首简才，次论政体也。】</p>
</blockquote>
<blockquote>
<p>措国于不倾之地，有德也。</p>
</blockquote>
<blockquote>
<p>积於不涸之仓，务五谷也。</p>
</blockquote>
<blockquote>
<p>下令于流水之原，以顺人心也。</p>
<p>尉缭子曰：“令，所以一众心也。不审所出，则数变，数变则令虽出，众不信也。出令之法虽有小过，无更，则众不二听，即令行矣。”</p>
</blockquote>
<blockquote>
<p>使士于不诤之官，使人各为其所长也</p>
<p>孙卿曰：“相高下，序五谷，君子不如农人；通财货，辩贵贱，君子不如贾人；设规矩，便备用，君子不如工人。若夫论德而定次，量能而授官，言必当理，事必当务，然后君子之所长。”</p>
<p>文子曰：“力胜其任即举之，不重也；能务其事则为之，不难也。”</p>
</blockquote>
<p>这里的“诤” 解释为不争夺权势，个人感觉根据下文说不通，解释为不让人争论更好，即举官应该做到让人无法非议。</p>
<blockquote>
<p>明必死之路，严刑罚也。</p>
<p>议曰：孔子曰：“上失其道而杀其下，非礼也。” 故三军大败，不斩；狱*不治，不可刑。何也？上教之不行，罪不在人故也。夫慢令致诛，贼也；征敛无时，暴也；不诫责成，虐也。政无此三者，然后刑，即可也。陈道德以先服之，犹不可，则尚贤以劝之，又不可，则废。不能以惮之，而犹有邪人不从化者，然后待之以刑矣。“</p>
</blockquote>
<blockquote>
<p>开必得之门，信庆赏也。</p>
</blockquote>
<blockquote>
<p>不为不可成，量人力也。</p>
<p>文子曰：”夫债少易偿也，职寡易守也，任轻易劝也。上操约少之分，下效易为之功，是以为君为臣久而不相厌也。末世之法，高为量而罪不及，重为任而罚不胜，危为难而诛不敢。人困于三责，即饰智以诈上，虽峻法严刑，不能禁其奸也。“</p>
</blockquote>
<blockquote>
<p>不求不可得，不强人以其所恶也。</p>
<p>故其称曰：”政“者，政之所行，在顺人心，政之所废，在逆人心。夫人恶忧劳，我逸乐之；人恶贫贱，我富贵之；人恶危坠，我存安之；人恶绝灭，我生育之。能逸乐之，则人为之忧劳；能富贵之，则人为之贫贱；能存安之，则人为之危坠；能生育之，则人为之绝灭。故从其四欲，则远者自亲，行其四恶，则近者亦叛。</p>
</blockquote>
<blockquote>
<p>不处不可久，不偷取一世宜也。</p>
</blockquote>
<blockquote>
<p>知时者，可立以为长。</p>
<p>范蠡曰：” 时不至不可强生，事不容不可强成。“ 管子曰：” 圣人能辅时，不能违时。“ 《语》曰：”圣人修备以待时也。“</p>
</blockquote>
<blockquote>
<p>审于时，察于用，而能备官者，可奉以为君。</p>
<p>管仲曰：” 大位不仁，不可授以国柄；见贤不让，不可与尊位；罚避亲戚，不可使主兵；不好本事，不可与都邑。“ 又曰：” 使贤者食于能，则上尊崇；斗士食于功，则卒轻死。使二者设于国，则天下理。“</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-论士</title>
    <url>/posts/b8f1ee07/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>《书》曰：“能自得师者王。” 何以明之？齐宣王见颜触曰：“触前。” 触亦曰：“王前。” 宣王作色曰：“王者贵乎？士者贵乎” ……</p>
<p>宣王左右曰：“大王据千乘之地，而建千石之钟，东西南北，莫敢不服。今夫士之高者，乃称匹夫，徒步而处于农亩，下则鄙野、监门、闾里。士之贱也，亦甚矣。” 触曰：“古大禹之时，诸侯万国。舜起农亩而为天子。及汤之时，诸侯三千。当今之世，南面称寡人则，乃四世。由此观之，非得失之策与？稍稍诛灭，灭亡无族之时，欲为监门、闾里，安可得哉？《易传》不云乎：‘居上位，未得其实。’ 故无其实而喜居名者削；无其德而望其福者约；无其功而受其禄者辱，祸必掘。故曰：‘ 矜功不立，虚愿不至。’ 至皆夸其名华而无其实德也。是以尧有九佐，舜有十友，禹有五丞，汤有三辅，自古及今，而能虚成名于天下者，无有。是以君王无羞亟问，不愧下学，而成其道。老子曰：‘ 虽贵，必以贱为本；虽高，必以下为基。’ 是以侯王称孤、寡人、不谷。夫孤寡者，困贱、下位者也，而侯王以是谓，岂非下人而尊贵士与？夫尧传舜，舜传禹，周成王传周公旦，而世世称名，实以明乎士之贵也。“</p>
<p>谚曰：”浴不必江海，要之去垢；马不必骐骥，要之善走；士不必贤也，要之知道；女不必贵种，要之贞好。“ 何以明之？淳于髡谓齐宣王曰：”古者好马，王亦好马；古者好味，王亦好味；古者好色，王亦好色；古者好士，王独不好。“ 王曰：” 国无士耳。有则寡人亦悦之。“ 髡曰：” 古有骅骝，今之无有，王选于众，王好马矣；古有豹像之胎，今之无有，王选于众，王好味矣；古有毛嫱、西施，今之无有，王选于众，王好色矣；王必待尧舜禹汤之士，而后好之，则尧舜禹汤之士，亦不好王矣。“</p>
<p>《淮南》曰：”待腰袅、飞兔而后驾，则世莫乘车矣；待西施、洛浦而后妃，则终身不家矣。然不待古之英隽而自足者，因其所有而遂用之也。“</p>
<p>郭隗说燕昭王曰：” 帝者与师处，王者与友处，霸者与臣处，亡国与厮役处。诎指而事之，北面受学，则百己者至；先趋而后息，先问而后默，则什己者至；人趋己趋，则若己者至；凭几据杖，眄视指使，则厮役之人至；恣睢奋击，呴藉叱咄，则徒隶之人至矣。“此乃古之服道致士者也。</p>
<p>黄石公曰：”礼者，士之所归；赏者，士之所死。招其所归，示其所死，则所求者至矣。“</p>
</blockquote>
<blockquote>
<p>【议曰：世之善恶，难得而知，苟非其人，莫见其际，何者？夫文章为武人所嗤，未必鄙也；为扬、马所嗤，此真鄙也。夫人臣为桀、纣所毁，未必为愚也；必若尧舜所毁，此真愚也。世之毁誉不足信也。故曰：不夜出，安知有夜行人？太公曰：“ 智与众同，非人师也；伎与众同，非国工。” 老子曰：“下士闻道，大笑之，不笑不足以为道。” 故曰：凡人所贱，圣人所贵。信矣哉！】</p>
</blockquote>
<blockquote>
<p>《语》曰：”知人未易，人未易知。“</p>
</blockquote>
<blockquote>
<p>《语》曰：”夫有国之主，不可谓举国无深谋之臣，合朝无智策之士，在听察所考精与不精，审与不审耳。“ …… 天下之国，莫不皆有忠臣谋士也。</p>
<p>议曰：天下无灾害，虽有贤德，无所施材。老子曰：”大道废，有仁义；国家混乱，有忠诚。《淮南子》曰：”未有其功而知其贤者，唯尧之知舜也；功成事立而知其贤者，市人之知舜也。“ …… 故曰：“贤、不肖者，才也；遇与不遇者，时也。” 诚哉，是言也。</p>
</blockquote>
<blockquote>
<p>黄石公曰：”罗其英雄，则敌国穷。夫英雄者，国家之干；士民者，国家之半。得其干，收其半，则政行而无怨。知人者哲，唯帝难之。“ 慎哉！</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-察相</title>
    <url>/posts/3e46a22e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这里的“相”除了长相，骨骼等，还指的是人的形态、举止。</p>
<blockquote>
<p>富贵在于骨法，忧喜在于容色，成败在于决断。由此参之，万不失一。</p>
</blockquote>
<blockquote>
<p>言性灵者存乎容止。斯其大体。</p>
</blockquote>
<blockquote>
<p>夫人有六贱：<br>
头小身大，为一贱 【又曰：额角陷缺，天中洼下，亦为一贱。】<br>
目无光泽，为二贱【又曰：胸背俱薄，亦为二贱。《经》曰：陷胸薄尻及猴目，皆穷相也】。<br>
举动不使，为三贱【又曰：声音雌散，亦为三贱。夫人不笑似笑，不嗔似嗔，不喜似喜，不畏似畏，不醉似醉，常如宿醒，不愁似愁，常如忧戚，容貌缺乏，如经痫病，神色凄怆，常如有失，举止张皇，恒如趋急，言语涩缩，若有隐藏，体貌低催，如遭凌辱，此并神不足者也。神不足者，多牢狱厄。有官隐藏而失，有位贬逐而黜者也。<br>
鼻不成就，准向前低，为四贱<br>
脚长腰短，为五贱<br>
文策不成，唇细横长，为六贱。【又曰：多言少信，亦为六贱。<br>
此贵贱存乎骨骼者也。</p>
</blockquote>
<p>译文解释：相面要从身体结构的整体上把握，绝不能只见树木、不见森林。大凡人的姿容，都以“整”为贵。这个“整”指的并不是整齐划一，而是人体的各个部位都要匀称、均衡，从而构成一个和谐有机的整体。比如个子矮的人不能太胖；个子高的人不能太瘦，不然就像一根茅草或电线杆。背部应该浑圆而厚实，腹部应该突出而平坦，手部应该温润而柔软，脚应该丰厚而饱满，足心应该虚能藏蛋 – 这也是所谓的“整”。</p>
<blockquote>
<p>昔姑布之卿谓子贡曰：“郑东门有一人，其长九尺六寸，河目而龙颜，其头似尧，其颈似皋陶，其肩似子产，然自腰以下不及禹三寸，垒然若丧家之犬。”</p>
</blockquote>
<p>译文：郑国东门的这个人虽然有尧一样的头颅，皋陶一样的脖颈，子产一样的肩膀，然而由于腿太短，所以像一只丧家之犬。这就是因为此人的相貌违反了“整”的原则。</p>
<blockquote>
<p>夫命之与相，犹声之与响也。声动乎几响，穷乎应，必然之理也。虽云以言信行，失之宰予，以貌度性，失之子羽。然《传》称：“无忧而戚，忧必及之；无庆而乐，乐必还之。” 此心有先动而神有先知，则色有先见。故扁鹊见桓公，知其将亡；申叔见巫臣，知其窃妻。或跃马膳珍，或飞而食肉，或早隶晚侯，或初刑末王。铜岩无饱生，玉馔终乎饿死。则彼度表扪骨，指色摘理，不可诬也。故列云尔。</p>
</blockquote>
<p>这一篇我原来当作糟粕，现在想想也很有道理的。长相、身高等确实是天生，但是形态、举止等是可以后天改变的，是可以教化的。按峰老师的说法，以貌取人仍然是最简单最直接的方法。人的内心的情志一定会通过外貌和举止来体现出来，而且更多的时候我们也只能通过人的外貌、形态和举止对其它人做出一个判断。</p>
<p>比如目光无泽、举动不使（译文，行为举止看着力不从心）就说明这个人意志薄弱（神不足）。就像这种情况，就完全是可以通过增强意志、锻炼身体等方式进行改变的。</p>
<p>其实这篇对我的意义在于，一是说明了以貌取人虽然不见得对，但是仍然是有道理的；二是要认识到自身形态举止的缺点，进行针对性的改造，以最大实现“整体”的和谐。</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-知人</title>
    <url>/posts/2dee69f0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>臣闻主将之法，务览英雄之心。然人未易知，知人未易。 汉光武聪听之主也，谬于庞萌；曹孟德知人之哲也，弊于张邈。何则？夫物类者，世之惑乱也。故曰：狙者类智而非智也，愚者类君子而非君子也，戆者类勇而非勇也。亡国之主似智；亡国之臣似忠；幽莠之幼似禾；骊牛之黄似虎；白骨疑象；碔砆类玉。此皆似是而非也。</p>
<p>《人物志》曰：”轻诺似烈而寡信；多易似能而无效；进锐似精而去速；诃者似察而事烦；许施似惠而无终；面从似忠而退违。此似是而非者也。亦有似非而是者：大权似奸而有功；大智似愚而内明；博爱似虚而实厚；正言似讦而情忠。非天下之至精，孰能得其实也？“</p>
</blockquote>
<blockquote>
<p>孔子曰：”凡人心险于山川，难知于天。天犹有春夏秋冬旦暮之期，人者厚貌深情，故有貌愿而益，有长若不肖，有顺怀而达，有坚而缦，有缓而钅干。“ 太公曰：”士有严而不肖者，有温良而为盗者，有外貌恭敬中心欺慢者，有精精而无情者，有威威而无成者，有如敢断而不能断者，有恍恍惚惚而反忠实者，有倭倭拖拖而有效者，有貌勇狠而内怯者，有梦梦而反易人者。无使不至，无使不遂，天下所贱，圣人所贵，凡人莫知，惟有大明，乃见其际。“ 此士之外貌不与中情相应者也。</p>
</blockquote>
<blockquote>
<p>知士者而有水焉。微察问之，以观其辞；穷之以辞，以观其变，与之间谋，以观其诚；明白显问，以观其德；远使以财，以观其廉；试之以色，以观其贞；告之以难，以观其勇；<strong>醉之以酒，以观其态</strong>。</p>
</blockquote>
<blockquote>
<p>《庄子》曰：”远使之而观其忠；近使之而观其敬；<strong>烦使之而观其能</strong>；<strong>卒然问焉而观其智</strong>；急与之期而观其信；杂之以处而观其色。</p>
</blockquote>
<p>简单地说，就是需要通过实践来验证一个人的才能和品格。</p>
<blockquote>
<p>桓范曰：“夫务名者不能出己之后，是故性同而材倾则相援而相赖也，性同而势均则相竞而相害也。” 此为同体之变，不可不察也。</p>
</blockquote>
<blockquote>
<p>夫圣贤所美，莫美乎聪明。聪明之所贵，莫贵乎知人。知人识智，则众材得其序，而庶绩之业兴矣。…… 察其所安，观其所由，以知居止之行。率此道也，人焉庾哉，人焉庾哉？</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>说文解字第一册笔记</title>
    <url>/posts/27938e11/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>果然是书非借不能读也。说文解字这一套书买来就没怎么看过了。哈哈哈，类似了买了健身卡就感觉自己锻炼了一样。</p>
<p><strong>才</strong>：<br>
才，草木之初也。<br>
象形字，上面一横表示土地，植物嫩芽刚刚出土而枝叶尚未出土的样子。<br>
原义是草木初生。延申为木料或木料的质性，人或物的质性。</p>
<p><strong>奉</strong>：<br>
奉，承也。<br>
金文似用双手捧着禾麦奉献给神祖之行，会向神祖拜祭祷告、祈求丰收之意。</p>
<p><strong>与</strong>：<br>
与，赐予也。一勺为与。<br>
一双手把器物交给一双手的意思。<br>
原义是赐给、给予。授人以物，除了是对对方的肯定之外，甚至还可能想跟对方结交，所以延申出赞许、嘉奖、交往、结交之意。</p>
<p><strong>本</strong>：<br>
本，木下曰本<br>
根本，根本，本就是根。</p>
<p><strong>考</strong>：<br>
考，老也。<br>
甲骨文为老人扶杖之形。</p>
<p><strong>北</strong>：<br>
北，乖也。从二人相背。<br>
两个人背靠背，是”背“的本字。<br>
打了败仗逃跑时总是以背对敌，”北“由此延申指败、败逃。例如败北。<br>
古代君主面朝南坐，臣子面君时则面朝北，所以对人称臣为”北面“</p>
<p><strong>卑</strong>：<br>
卑，贱也。<strong>执事</strong>也。<br>
金文似左手持一粗糙的酒器之形，会执事供役使之意。后延申为地位低微</p>
<p><strong>夭</strong>：</p>
<p>​	夭，屈也。</p>
<p>​	甲骨文字形似一个人弯曲双臂摆动的样子。</p>
<p>夭的原义是屈。但是屈过头了，就会折断。由此引申为折、短命，如“夭折”。</p>
<p>夭的字形，好似在跳舞的样子，所以也形容女子美丽姣好，也表示花开茂盛。</p>
<p><strong>州</strong>：<br>
州,水中可居曰州，周绕其旁，从重川。昔尧遭洪水，民居水中高土，或者曰九州。</p>
<pre><code>州，水中陆地。后来大禹将其领域划分为九州，之后九州就泛指天下。
</code></pre>
<p><strong>乡</strong>：<br>
甲骨文似两个人对着盛有食物的器皿，会两人相对而食之意。<br>
原义是两人相对而食。延申泛指用酒食款待别人。</p>
<p><strong>习</strong>：<br>
习，数飞也。<br>
甲骨文为鸟儿在日光下练习飞翔之意。<br>
后引申为反复练习、钻研。</p>
<p><strong>承</strong>：<br>
承，奉也，受也。<br>
甲骨文似一个屈膝的人作授物之形，下有一双手做出接受的样子。<br>
原义是<strong>捧</strong>，也延申为继承，如“汉承秦制”。<br>
承还可以表示顺从、侍奉。如“承欢膝下”。</p>
<p><strong>民</strong>：<br>
民，众萌也。<br>
众人懵懂无知的样子。<br>
金文似以锐物刺左目之形。古时候，俘获敌人则刺瞎其左眼用为奴。所以“民”的原义是奴隶。</p>
<p><strong>卒</strong>：<br>
卒，隶人给事者衣为卒。<br>
原指带有标记的衣服（叉号），也特指穿这种衣服供役使的隶役。也特指士兵。</p>
<p><strong>真</strong>：<br>
甲骨文为人从鼎中取食美味之意。<br>
原义指美食，由美食的原质原味延申为本质、本性。</p>
<p><strong>协</strong>：<br>
协，众之同和也。<br>
甲骨文似三耒并耕之形，会合力耕种之意。</p>
<p><strong>企</strong>：<br>
企，举踵也。<br>
踮起脚尖的意思。如“企盼”，“企鹅”，“企及”</p>
<p><strong>位</strong>：<br>
位，列中庭之左右谓之位。<br>
位，排列在朝廷中的左右位置叫做位。原义是朝廷中群臣排班所处的序列、地方。延申指所处的官职、级别。还特指封建君主的统治地位。“即位” 就是指登上帝位，“在位”就是居于帝王之位。<br>
位也延申指人在某一社会领域中所处的位置或者等级。例如“岗位”、”学位“<br>
位还指抽象的名分、地位。</p>
<p><strong>仔</strong>：<br>
原义是人背子，甲骨文是人背小孩的样子。</p>
<p><strong>保</strong>：<br>
保，养也<br>
甲骨文士大人手臂向后抱一小儿。</p>
<p><strong>儿</strong>；<br>
儿，孺子也。<br>
甲骨文是一个向左站着的大头娃娃，头顶中间是开口的，表示婴儿脑囟骨还没有长在一起。<br>
【原来婴儿出生后颅骨之间结合不紧密，存有空隙，长见识了。】</p>
<p><strong>先</strong>：<br>
先，前进也。<br>
甲骨文像是一个走路的样子。“先”的原义是在前引导，走在前面。</p>
<p><strong>公</strong>：<br>
公，平分也。<br>
甲骨文是平分器皿中的东西之意。<br>
原义是无私，延申为公正。</p>
<p><strong>周</strong>：<br>
周，密也。<br>
“周”是象形字。甲骨文似在玉片上雕刻出纹饰，四点则象征雕刻的图画和花纹有疏密。</p>
<p><strong>友</strong>：<br>
友，同志为友。<br>
甲骨文和金文都是方向相同的两只右手靠在一起的样子，会志同道合地做一件事情之意。</p>
<p><strong>冤</strong>：<br>
冤，屈也。<br>
兔子在覆罩之下不能跑。</p>
<p><strong>危</strong>：<br>
危，在高而惧也。<br>
人站在高处有危险而感到害怕之意。</p>
<p><strong>孝</strong>：<br>
孝，善事父母者<br>
甲骨文似长者长头发的老人，金文似孩子背着老人的样子。</p>
<p><strong>奴</strong>：<br>
“奴”是会意字。金文字形左为“女”，右下为“又”（手）向她抓去，会抓住了人之意。</p>
<p><strong>驳</strong>：<br>
驳，马色不纯。<br>
甲骨文为马身上有交错的花纹之意。<br>
原指马的毛色不纯，延申成混杂、杂乱、庞杂。</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>说文解字</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-量才</title>
    <url>/posts/c7a98fc8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>孙武曰：“主孰有道？”</p>
<p>昔汉王见围荥阳，谓陈平曰：“天下纷纷，何时定乎？“ 平曰：”项王为人恭敬爱人，士之廉节好礼者多归之。至于行功赏爵邑，重之，士亦以此不附。今大王慢人少礼，士之愚钝嗜利无耻者亦多归汉。诚宜各去两短，集其两长，天下指麾即定矣。“</p>
<p>魏太祖谓郭嘉曰：”袁本初地广兵强，吾欲讨之，力不能敌，何如？“ 嘉对曰：”刘，项之不敌，公所知也，汉祖惟智胜。项羽虽强，终为所擒。嘉窃料之，绍有十败，公有十胜，虽兵强，无能为也。绍繁礼多仪，公体任自然。此道胜一也。绍虽兵强，绍以逆动，公奉顺以率天下，此义胜二也。汉末政失于宽，绍以宽济，故不摄；公纠之以猛，而上下，而上下知制，此治胜三也。绍外宽内忌，用人而旋疑之，所任唯亲戚子弟耳；公外简易而内机明，用人无疑，唯才能所宜，不问远近，此度胜四也。绍多计少决，失在事后；公策得辄行，应变无穷，此谋胜五也。绍因累世之资，高议揖让，以收名誉，士之好言饰外者多归之；公至心待人，推诚而行之，不为虚美，以俭率下，与有功者无所吝，士之忠正远见而有实者皆愿为用，此德胜六也。绍见人饥寒，恤念之情形于颜色，其所不见，虑或不及，所谓妇人之仁耳；公于目前小事，时有所忽，至于大事，于四海相接，恩之所加，皆过其望，虽所不见，虑之所周，无不济也，此仁胜七也。绍大臣争权，谗言惑乱；公御下以道，浸润而行，此明胜八也。绍是非不可知；公所是进之以礼，所不是正之以法，以文胜九也。绍好为虚势，不知兵要；公以少克众，用兵如神，军人恃之，敌人畏之，此武胜十也。“ 曹公曰：”吾知之，绍为人志大而智小，色厉而胆薄，忌刻而少威，兵多而分画不明，将骄而政令不一，土地虽广，粮食虽丰，适所以谓吾奉也。“ 杨阜曰：”袁公宽而不断，好谋而少决。不断而无威，少决则后事。今虽强，终为所擒。曹公有雄才远略，决机无疑，法一兵精，必能济大事也。“</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷p大政-品目</title>
    <url>/posts/a8d66a27/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>夫天下重器，王者大统，莫不劳聪明于品材，或安逸于任使。故孔子曰：“人有五仪：有庸人，有士人，有君子，有圣，有贤。审此五者，则治道毕矣。”</p>
<p>所谓庸人者，心不存慎终之规，口不吐训格之言，不择贤以托身，不力行以自定，见小暗大而不知所务，从物如流而不知所执。此则庸人也。</p>
<p>所谓士人者，心有所定，计有所守。虽不能尽道术之术，必有率也；虽不能遍百善之美，必有处也。是故智不务多，务审其所知；言不务多，务审其所谓【所谓，言之要也】；行不务多，务审其所由。智既知之，言既得之【得其要也】，行既由之，则若性命形骸之不可易也。富贵不足以益，贫贱不足以损，此则士人也。</p>
<p>所谓君子者，言必忠信而心不忌【忌，怨害也】，仁义在身而色不伐，思虑通明而辞不专，笃行信道，自强不息，油然若将可越而终不及者。此君子也。【孙卿曰：“夫君子能为可贵，不能使人必贵己；能为可信，不能使人必信己；能为可用，不能使人必用己。故君子耻不修，不耻见污；耻不信，不耻不见信；耻不能，不耻不见用。不诱于誉，不怨于诽，率道而行，端然正己，谓之君子也。”】</p>
<p>所谓贤者，德不逾闲【闲，法也】，行中规绳，言足法于天下而不伤于其身【言满天下，无口过也】，道足化于百姓而不伤于本【本亦身也】，富则天下无菀财【菀：积】，施则天下无病贫。此谓贤者也。</p>
<p>所谓圣者，德合天地，变通无方，究万物之终始，协庶品之自然，敷其大道而遂成情性，明立日月，化行若神，下民不知其德，睹者不识其邻。此圣者也。</p>
</blockquote>
<blockquote>
<p>清节之流，不能弘恕，好尚讥诃，分别是非，是谓臧否。子夏之徒是也。法家之流，不能创思图远，而能受一官之任，错意施巧，是为伎俩。张敞、赵广汉是也。术家之流，不能创制垂则，而能遭变用权。权智有余，公正不足，是谓智意。陈平、韩安国是也。能文著述，是谓文章，司马迁、班固是也。能传圣人之业，而不能干事施政，是谓儒学。毛公、贯公是也。辩不入道，而应对给资，是谓口辩。乐毅、曹丘生是也。胆力绝众，才略过人，是谓骁雄。白起、韩信是也。</p>
</blockquote>
<blockquote>
<p>《家语》曰：“昔者明王必尽知天下良士之名，既知其名，又知其实，然后用天下之爵以尊之，则天下理也。”此之谓矣。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-任长</title>
    <url>/posts/4553ed87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>臣闻料才核能，治世之要。自非圣人，谁能兼兹百行，备贯众理乎？故舜合群司，随才授位；汉述功臣，三杰异称。况非此俦，而可备责耶？</p>
</blockquote>
<blockquote>
<p>夫刚略之人，不能理微，故其论大体则弘略而高远，历纤理微则宕往而疏越；亢厉之人，不能回挠，其论法直则括据而公正，说变通则否戾而不入；宽恕之人，不能速捷，论仁义则弘详而长雅，趋时务则迟缓而不及；好奇之人，横逸而求异，造诡谲则倜傥而瑰壮，案清道则诡常而恢迂。</p>
<p>又曰：王化之政，宜于统大，以之理小则迂；策术之政，宜于理难，以之理平则无奇；矫亢之政，宜于治侈，以之治弊则残；公刻之政，宜于纠奸，以之治边则失其众；威猛之政，宜于讨乱，以之治善则暴；伎俩之政，宜于治富，以之治贫则民劳而下困。此已上皆偏材也。</p>
</blockquote>
<blockquote>
<p>魏武诏曰：“进取之士，未必能有行。有行之士，未必能进取。陈平岂笃行，苏秦岂守信耶？而陈平定汉业，苏秦济弱燕者，任其长也。”</p>
<p>由此观之，使韩信下帏，仲舒当戎，于公驰说，陆贾听讼，必无曩时之勋，而显今日之名也。故“任长”之道，不可不察。</p>
</blockquote>
<blockquote>
<p>议曰：魏恒范云：“帝王用人，度世授才。争夺之时，书策为先。分定之后，忠义为首。故晋文行舅犯之计而赏雍季之言，高祖用陈平之智而托后于周勃。” 古语云：“守文之代，德高者位尊；仓促之时，功多者赏厚。”  诸葛亮曰：“老子长于养性，不可以临危难；商鞅长于理法，不可以从教化。苏张长于驰辞，不可以结盟誓；白起长于攻取，不可以广众；子胥长于图敌，不可以谋身；尾生长于守信，不可以应变；王嘉长于遇明君，不可以事暗主；许子将长于明臧否，不可以养人物。”  此任长之术也。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-原序</title>
    <url>/posts/48e2ba4b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>匠臣舆者，忧人不贵；做箭者，恐人不伤。彼其有爱憎哉？实技业驱之然耳。是知当代之士、驰骛之曹，书读纵横，则思诸侯之变；艺长奇正，则念风尘之会。此亦向时之论，必然之理矣。故先师孔子深探其本、忧其末，遂作《春秋》，大乎工道；制《孝经》，美乎德行。防萌杜渐，预有所抑。</p>
<p>斯圣人制作之本意也。</p>
<p>然作法于理，其弊必乱。若至于乱，将焉救之？是以御世理人，罕闻沿袭。三代不同礼，五霸不同法。非其相反，盖以救弊也。是故国容一致，而忠文之道必殊；圣哲同风，而皇王之名或异。岂非随时投教沿乎此，因物成务牵乎彼？沿乎此者，醇薄继于所遭；牵乎彼者，王霸存于所遇。故古之理者，其政有三：王者之政化之；霸者之政威之；强国之政胁之。各有所施，不可易也。管子曰：“圣人能辅时不能违时。智者善谋，不如当时。”邹之曰：“政教文质，所以匡救也。当时则用之，过则舍之。”由此观之，当霸者之朝而行王者之化，则悖矣。当强国之世而行霸者之威，则乖矣。若时逢狙诈，正道陵夷，欲宪章先王，广陈德化，是犹待越客以拯溺，白大人以救火（等待水性好的人来救溺水者，请求尊贵的人来救火）。善则善矣，岂所谓通于时变欤？</p>
<p>夫霸者， 驳道也，盖白黑杂合，不纯用德焉。期于所成，不问所以；论于大体，不守小节。虽称仁引义不及三王，扶颠定倾，其归一揆。恐儒者溺于所闻，不知王霸殊略，故叙以长短术，以经论通变者，并立题目总六十有三篇，合为十卷，名曰《反经》。大旨在乎宁固根蒂，革易时弊，兴亡治乱。</p>
<p>具载诸篇，为沿袭之远图，作经济之至道，非欲矫世夸欲，希声慕名。辄露见闻，逗机来哲。凡厥有位，幸望详焉。</p>
</blockquote>
<p>《反经》是我最喜欢的古文书，这篇序就很先声夺人，不明觉厉。拜服老祖宗的智慧！</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-大体</title>
    <url>/posts/112d874c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>臣闻老子曰：“以正理国，以奇用兵，以无事取天下。”荀卿曰：“人主者，以官人为能者也；匹夫者，以自能为能也。”</p>
</blockquote>
<blockquote>
<p>《人物志》曰：“夫一官之任，以一味协五味；一国之政，以无味协五味。故臣以自任为能；君以能用人为能。臣以能言为能；君以能听为能。臣以能行为能；君以能赏罚为能。所以不同，故能君众能也。”</p>
</blockquote>
<blockquote>
<p>故曰，知人者，王道也；知事者，臣道也；无形者，物之君也；无端者，事之本也。鼓不预五音，而为五音主；有道者，不为五官之事，而为理事之主。君守其道，官知其事，有自来矣。</p>
<p>先王知其如此也，故用非其有如己有之，通乎君道者也。</p>
</blockquote>
<blockquote>
<p>议曰：《淮南子》云：“巧匠为宫室，为圆必以规，为方必以矩，为平直必以准绳。功已就矣，而不知规矩准绳，而赏巧匠。宫室已成，不知巧匠，而皆曰某君某王之宫室也。”</p>
<p>孙卿曰：“夫人主故欲得善射中微，则莫若使羿；欲得善御致远，则莫若使王良；欲得调一天下，则莫若聪明君子矣。其用智甚简，其为事不劳，而功名甚大。”此能用其非其有如已有者也。</p>
</blockquote>
<blockquote>
<p>人主不通主道者则不然。自为之则不能任贤，不能任贤，则贤者恶之，此功名之所以伤，国家之所以危。</p>
</blockquote>
<blockquote>
<p>议曰：“《申之》云：君知其道也，臣知其事也。十言十当，百言百当者，人臣之事也，非人君之道也。”《尸子》云：“人臣者，以进贤为功也；君者，以用贤为功也。”</p>
</blockquote>
<blockquote>
<p>汤武一日而尽有夏商之财，以其地封，而天下莫敢不悦服；以其财赏，而天下皆竞劝，通乎用非其有也。</p>
</blockquote>
<blockquote>
<p>议曰：孙卿曰：“修礼者王，为政者强，取人者安，聚敛者亡。故王者富人；霸者富士；仅存之国富大夫；亡国者富筐箧、实府库。是谓上溢下漏。” 又曰：“天子不言多少，诸侯不言利害，大夫不言得失。”</p>
</blockquote>
<blockquote>
<p>魏文侯御廪灾，素服避正殿，群臣皆哭。公子成夫趋入贺曰：“臣闻天子藏于四海；诸侯藏于境内。非其所藏，必有火灾，必有人患。幸无人患，不亦善乎。”  孔子曰：“百姓足，君孰与不足？” 由此言之，夫圣王以其地封，以其财赏，不与人争利，乃能通于主道，是用非其有者也。</p>
</blockquote>
<blockquote>
<p>故称，设官分职，君之体也；委任责成，君之体也；好谋无倦，君之体也；宽以得众，君之体也；含垢藏疾，君之体也。君有君人之体，其臣畏而爱之，此帝王所以成业也。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>win10快捷键</title>
    <url>/posts/26dc69f9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="虚拟桌面">虚拟桌面</h2>
<p>win + ctrl+ D：** 创建虚拟桌面**<br>
win + ctrl + 左右箭头：** 切换虚拟桌面**<br>
win + ctrl + F4: <strong>关闭当前虚拟桌面</strong></p>
<h2 id="应用管理">应用管理</h2>
<p>win + M: <strong>最小化所有应用</strong><br>
ctrl + alt + tab(或win + tab) : <strong>显示所有打开应用</strong><br>
win + 1-9: 快速打开应用</p>
<h2 id="当电脑卡死时">当电脑卡死时</h2>
<p>ctrl + shift + esc: <strong>打开任务管理器</strong>（关闭卡死的程序，<strong>实用</strong>）<br>
ctrl + alt + delete: windows救命三键<br>
win + R后输入[ shutdown -r ]重启 或 [ shutdown -s ] 关机</p>
<h2 id="打开文件夹">打开文件夹</h2>
<p>win + E: 资源管理器</p>
<p>shift + delete : 永久删除文件</p>
<h2 id="锁屏">锁屏</h2>
<p>win + l</p>
<h2 id="查看剪贴板">查看剪贴板</h2>
<p>win + v</p>
<h2 id="参考网页">参考网页</h2>
<p><a href="https://www.bilibili.com/video/av64127316">https://www.bilibili.com/video/av64127316</a><br>
<a href="https://baike.baidu.com/item/Windows%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/407192?fr=aladdin">https://baike.baidu.com/item/Windows快捷键大全/407192?fr=aladdin</a></p>
]]></content>
      <tags>
        <tag>软件学习</tag>
      </tags>
  </entry>
  <entry>
    <title>notpad++学习笔记</title>
    <url>/posts/897384da/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>notpad++是一款功能强大的文本编辑器。我一开始用的就是这个软件，感觉基本能满足我的所有需求。</p>
<h1>快捷键</h1>
<h2 id="常规快捷键">常规快捷键</h2>
<ul>
<li>ctrl + Z  &amp; ctrl + Y ** 撤销与恢复**</li>
<li>ctrl + F  &amp; ctrl + H <strong>查找与替换</strong></li>
<li>ctrl + D 复制并黏贴当行（光标所在行）</li>
<li>ctrl + D 复制并快速黏贴多行（光标选中多行）</li>
<li>ctrl + L 删除当前行</li>
<li>shift + tab 删除缩进</li>
<li>ctrl + G <strong>快速跳到某一行</strong></li>
<li>ctrl + tab 多个文件中切换（与谷歌一致）</li>
</ul>
<h2 id="文件操作快捷键">文件操作快捷键</h2>
<ul>
<li>ctrl + S 保存当前文档</li>
<li>ctrl + alt + S 另存为</li>
<li>ctrl + shift + S <strong>保存所有文件</strong></li>
<li>ctrl + w 关闭当前</li>
<li>ctrl + p 打印（转为pdf）</li>
</ul>
<h2 id="文本编辑">文本编辑</h2>
<ul>
<li>Alt + C <strong>列编辑</strong>模式（在某一列插入相同的文字或数字）</li>
<li>ctrl + k <strong>注释</strong>（可选中多行，而且notpad++会根据文件类型添加相符合的注释符号）</li>
<li>ctrl + shift + k 取消注释</li>
</ul>
<h2 id="其他快捷键">其他快捷键</h2>
<ul>
<li><strong>块匹配</strong>：选择一个括号，按ctrl+b会跳转到与它对应的另外一半括号处。</li>
</ul>
<h1>其他功能</h1>
<h2 id="颜色标记">颜色标记</h2>
<p>就是给内容用不同的颜色做标记，用法就是选择要标记的文本然后点击右键-&gt;Style token，选择一个标记即可。也可以通过点击右键选择删除颜色标记Remove style。</p>
<h2 id="将tab转换成空格">将tab转换成空格</h2>
<blockquote>
<p>编程中一般都不允许使用Tab键作为缩进而是使用空格，但是Tab键确实方便。<br>
在首选项-&gt;语 言页面可以选择“以空格代替Tab”，同时可以配置一个Tab键替换成几个空格。</p>
</blockquote>
<h2 id="显示符号">显示符号</h2>
<p>在视图-显示符号中，可以显示空格、制表键、换行等。空格显示为**.<strong>，制表键显示为向右的箭头。linux格式的换行符显示为LF，windows格式的换行符显示为</strong>CRLF**。</p>
<h2 id="备份">备份</h2>
<p>这个比较实用。在设置-首选项-备份-备份与自动完成，选择<strong>简单备份</strong>。这样notpad++在编辑一个文件，会默认生成一个同名的<strong>bak</strong>文件。</p>
<h2 id="插件">插件</h2>
<p>notpad++有很多相应的插件，比如一款TextFX的插件，可以删除文件中的空行、插入行号或删除行号等。</p>
<h1>tips</h1>
<ul>
<li>notpad++通过后缀名判断文件类型，并实现<strong>代码高亮</strong>。如果文件无后缀，那么也无法实现自动代码高亮。可通过设置<strong>语言</strong>选项，实现未知类型文件的语法高亮。</li>
<li>通过<strong>格式</strong>选项，可查看和转换当前文件字符编码。</li>
<li>在其他地方修改文件后，notpad++会自动更新文件，并通知<strong>此文件已被其他程序修改了，是否重新加载</strong>。在首选项-其他中，勾选<strong>自动更新文件</strong>，关闭该通知。</li>
</ul>
<h1>参考网页</h1>
<p><a href="http://shouce.jb51.net/notepad_book/">http://shouce.jb51.net/notepad_book/</a><br>
<a href="https://blog.51cto.com/caochun/1530273">https://blog.51cto.com/caochun/1530273</a></p>
]]></content>
      <tags>
        <tag>软件学习</tag>
      </tags>
  </entry>
  <entry>
    <title>谷歌浏览器常用快捷键</title>
    <url>/posts/31e31a23/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>官方网址 [Chrome 键盘快捷键]（<a href="https://support.google.com/chrome/answer/157179?hl=zh-Hans%EF%BC%89">https://support.google.com/chrome/answer/157179?hl=zh-Hans）</a></p>
<h2 id="标签页和宽口快捷键">标签页和宽口快捷键</h2>
<ul>
<li>ctrl+n  打开新窗口</li>
<li>ctrl+t  打开新的标签页</li>
<li>ctrl+tab 跳到下一个标签页</li>
<li>ctrl+w 关闭当前标签页（等于鼠标中键点击标签页）</li>
<li>ctrl+shift+w 关闭当前窗口</li>
</ul>
<h2 id="功能快捷键">功能快捷键</h2>
<ul>
<li>ctrl+shift+o 打开书签</li>
<li>ctrl+h 历史</li>
<li>ctrl+j 下载</li>
<li>F5 刷新</li>
<li>F11 全屏（如看文献时）</li>
</ul>
<h2 id="地址栏快捷键">地址栏快捷键</h2>
<ul>
<li>ctrl+l 跳到地址栏</li>
<li>ctrl+enter <a href="http://xn--www-c88dx8l94buznxdx09to89cnbjl99b.xn--0tr.com">为输入地址默认添加www.和.com</a></li>
</ul>
<h2 id="网页快捷键">网页快捷键</h2>
<p>ctrl+d 将当前页面保存为书签<br>
ctrl+p 打印当前页面（可以将当前页面保存为pdf）<br>
ctrl+u 显示html源代码</p>
]]></content>
      <tags>
        <tag>软件学习</tag>
      </tags>
  </entry>
  <entry>
    <title>一份（不太）简短的LaTex介绍学习笔记</title>
    <url>/posts/9ab4ff8e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>第一章 LaTeX 须知</h1>
<p>本书的别名叫做106分钟了解LaTeX，但是要看完根本不止106分钟，更别说理解了。暂时先看到第四章。</p>
<h3 id="Tex">Tex</h3>
<blockquote>
<p>TEX是高德纳(Donald E.Knuth)开发的、以排版文字和数学公式为目的的一个计算机软件。高德纳从1977年开始开发TEX，以发掘当时开始用于出版工业的数字印刷设备的潜力。正在编写著作《计算机程序设计艺术》的高德纳，意图扭转排版质量每况愈下的状况，以免影响他的出书。TEX排版引擎发布于1982年，在1989年又加以改进以更好地支持8-bit字符和多语言排版。TEX以其卓越的稳定性、跨平台、几乎没有Bug而著称。TEX的版本号不断趋近于π，当前为3.141592653</p>
</blockquote>
<h3 id="LaTex">LaTex</h3>
<blockquote>
<p>LATEX为TEX基础上的一套格式，令作者能够使用预定义的专业格式以较高质量排版和印刷他们的作品。LATEX的最初开发者为Leslie Lamport博士。LATEX使用TEX程序作为自己的排版引擎。当前LATEX由LATEX3工作组1维护。</p>
</blockquote>
<h3 id="引擎、格式和编译命令">引擎、格式和编译命令</h3>
<ul>
<li><strong>引擎</strong>     是编译源代码并生成文档的程序，如pdfTeX，XeTeX等。有时也称为编译器。</li>
<li><strong>格式</strong>    是定义了一组命令的代码集，最广泛应用的一个格式就是latex，另外，还有一个简版的plain tex</li>
<li><strong>编译命令</strong> 是实际调用的，结合了引擎和格式的命令，如xelatex和pdflatex。</li>
</ul>
<h3 id="latex用到的文件">latex用到的文件</h3>
<ul>
<li><strong>.sty</strong> 宏包文件</li>
<li><strong>.cls</strong> 文档类文件</li>
<li><strong>.bib</strong> 参考文献数据库文件</li>
<li><strong>.bst</strong> 参考文献格式模板</li>
</ul>
<h3 id="latex编译中生成的文件">latex编译中生成的文件</h3>
<ul>
<li><strong>.log</strong> 日志</li>
<li><strong>.aux</strong> 主辅助文件，记录交叉引用、目录和参考文献的引用等。</li>
<li><strong>.toc</strong> 目录记录文件</li>
<li><strong>.lof</strong> 图片目录记录文件</li>
<li><strong>.lotLATEX</strong> 生成的表格目录记录文件。</li>
<li>.bbl  BIBTEX生成的参考文献记录文件。</li>
<li>.blg  BIBTEX生成的日志文件。</li>
<li>.idx  LATEX生成的供makeindex处理的索引记录文件。</li>
<li>.ind  makeindex 处理.idx生成的用于排版的格式化索引文件。</li>
<li>.ilg  makeindex生成的日志文件。</li>
<li>.out  hyperref宏包生成的PDF书签记录文件。</li>
</ul>
<h3 id="include-与-input">\include 与 \input</h3>
<ul>
<li>\include{ <em>filename</em> }  插入其他文件（不在同一目录需加路径），<strong>会另起一页</strong>。</li>
<li>\input{ <em>filename</em>} 一样，但是不会另起一页。</li>
</ul>
<h1>用LaTeX 排版文字</h1>
<p>作者对排版中文文档的建议是，使用ctex文档类型、源代码保存为<strong>UTF-8</strong>编码、编译时使用<strong>xelatex</strong>命令</p>
<h3 id="字符编码">字符编码</h3>
<p>latex命令和pdflatex命令下，可以使用<strong>inputenc</strong>宏包支持UTF-8编码：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>[utf8]&#123;inputenc&#125;</span><br></pre></td></tr></table></figure>
<p>xelatex和lualatex命令原生支持UTF-8编码。</p>
<h3 id="排版中文">排版中文</h3>
<p>ctex 文档包括ctexart 、ctexrep、ctexbook，是目前最新的排版中文的方式（老的我不太想知道了）。</p>
<h3 id="空格">空格</h3>
<ul>
<li>多个连续空格或tab键均视为一个空格。</li>
<li>每行开头的空格忽略不计、</li>
<li><strong>行末的回车</strong>视为一个空格</li>
</ul>
<h3 id="分段">分段</h3>
<ul>
<li>连续<strong>两个回车</strong>，也就是空一行，会分段。</li>
<li>多个空行仍视为一个空行</li>
<li><strong>\par</strong>命名分段</li>
</ul>
<h3 id="注释">注释</h3>
<ul>
<li><strong>%</strong></li>
</ul>
<h3 id="特殊字符">特殊字符</h3>
<p>以下字符具有特殊用途，如需直接输入这些字符，需使用 *<em>*</em> 转义<br>
# $ % &amp; { } _ ^ ~ \</p>
<p>注： \为手动换行，因此输入反斜线为**\textbackslash**</p>
<h3 id="标点符号">标点符号</h3>
<ul>
<li>中文标点符号直接输入即可</li>
<li>英文双引号输入<strong>两个单引号</strong></li>
<li>连字符
<ul>
<li>单个连字符**-**就是自身</li>
<li>两个连字符**–**连接数字表示范围</li>
<li>三个连字符**—**作为破折号—使用</li>
</ul>
</li>
<li>省略号 <strong>\ldots</strong> 和 <strong>\dots</strong> 表示输入三个点。</li>
<li>波浪号 <strong>-</strong> <strong>\sim</strong></li>
</ul>
<h3 id="文字强调">文字强调</h3>
<ul>
<li>\underline{} 下划线</li>
<li>\emph{}        斜体</li>
</ul>
<h3 id="断行">断行</h3>
<ul>
<li><strong>\</strong> 进行断行。</li>
<li>用**-**插入不会断行的空格（高德纳称之为tie），常用于英文人名、图表名称等。</li>
</ul>
<h3 id="断页">断页</h3>
<ul>
<li><strong>\newpage</strong>  <strong>\clearpage</strong></li>
</ul>
<h1>文档元素</h1>
<h3 id="章节题目">章节题目</h3>
<ul>
<li>\chapter{} <strong>只在 book 和 report 文档类有定义</strong></li>
<li>\section{}  \subsection{} \subsubsection{} \paragraph{} \subparagraph{}</li>
<li>命令变体
<ul>
<li>带可选参数的变体：\section[short title]{title}<br>
标题使用title 参数，在目录和页眉页脚中使用short title参数</li>
<li>带星号的变体：\section*{title}<br>
标题不带编号，也不生成目录项和页眉页脚</li>
</ul>
</li>
<li>article 文档类<strong>带编号</strong>的层级为 \section \subsection \subsubsection 三项</li>
<li>report/book 文档类<strong>带编号</strong>的层级为 \chapter \section \subsection</li>
</ul>
<h3 id="目录">目录</h3>
<ul>
<li>使用命令**\tableofcontents** 生成目录</li>
<li>正确生成目录，一般需要编译两次源代码</li>
</ul>
<h3 id="标题页">标题页</h3>
<p>latex 支持生成简单的标题页。首先需要给定标题和作者等信息：前两个命令必需，date命令可选。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\title</span>&#123;⟨title⟩&#125;   <span class="keyword">\author</span>&#123;⟨author⟩&#125;   <span class="keyword">\date</span>&#123;⟨date⟩&#125;</span><br></pre></td></tr></table></figure>
<p>之后就可以使用 \maketitle 生成一个简单的标题页了。<br>
article 文档类的标题默认不单独成页。</p>
<h3 id="交叉引用">交叉引用</h3>
<p>在能够被交叉引用的地方，如章节、公式、图表、定理等位置使用\label命令：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\label</span>&#123;⟨label-name⟩&#125;</span><br></pre></td></tr></table></figure>
<p>之后，可以在别处使用\ref和\pageref命令，分别生成交叉引用的编号和页码：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\ref</span>&#123;⟨label-name⟩&#125;   <span class="keyword">\pageref</span>&#123;⟨label-name⟩&#125;</span><br></pre></td></tr></table></figure>
<p>为了生成正确的交叉引用，一般需要<strong>多次编译源代码</strong>。<br>
对于使用不记编号的命令形式（\section*,\caption），<strong>不要使用\label命令</strong>，否则生成的引用编号不正确。</p>
<h3 id="脚注">脚注</h3>
<p>脚注就是在页脚的位置写上注释，一般使用\footnote命令。</p>
<h1>特殊环境</h1>
<h2 id="列表">列表</h2>
<h3 id="有序列表">有序列表</h3>
<p>基本命令是enumerate。item中包含一个可选参数，将列表符号改成自定义的符号，如\item[*]。<br>
列表可以嵌套使用，最多嵌套四层。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;</span><br><span class="line">	<span class="keyword">\item</span>. . .</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无序列表">无序列表</h3>
<p>无序列表的基本命令为itemize，格式同上。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line">	<span class="keyword">\item</span>. . .</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对齐环境">对齐环境</h2>
<p>文本对齐方式可用以下命令分别生成居中、左对齐和右对齐的文本环境。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;center&#125;. . .<span class="keyword">\end</span>&#123;center&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;flushleft&#125;. . .<span class="keyword">\end</span>&#123;flushleft&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;flushright&#125;. . .<span class="keyword">\end</span>&#123;flushright&#125;</span><br></pre></td></tr></table></figure>
<p>另外，如果只改变一句文本的对齐方式，可直接使用以下命令</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\centering</span>   <span class="keyword">\raggedright</span>   <span class="keyword">\raggedleft</span></span><br></pre></td></tr></table></figure>
<h2 id="引用环境">引用环境</h2>
<ul>
<li><strong>quote</strong>环境用于引用较短的文字，首行不缩进。</li>
<li><strong>quotation</strong>环境用于引用若干段文字，首行缩进。</li>
<li>不论是quote或quotation,引用环境相较于一般文字均有额外的左右缩进。</li>
</ul>
<h2 id="代码环境">代码环境</h2>
<p>有时我们需要将一段代码原样输出，这时需用到代码环境verbatim。</p>
<ul>
<li>verbatim* 环境会将空格显示为␣</li>
<li>只排版一行代码，可使用\verb命令，delim表明代码的边界，习惯使用|符号。</li>
</ul>
 <figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\verb</span>⟨<span class="string">delim⟩</span>⟨code⟩⟨delim⟩</span><br></pre></td></tr></table></figure>
<h2 id="表格环境">表格环境</h2>
<p>latex直接排版表格感觉比较复杂，不是很实用。大量的表格排版还是需要R语言相应的函数包的支持。<br>
最基本的tabular环境用法如下，其中⟨column-spec⟩是列格式标记（通常使用|c|表示居中）；&amp;用来分隔单元格；\用来换行；\hline用来在行与行之间绘制横线。<br>
注意：表格中每行的单元格数目不能多于列格式里l/c/r(左/居中/右对齐)的总数（可以少于这个总数）。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tablular&#125;&#123;&lt;column-spec&gt;&#125;</span><br><span class="line">&lt;item1&gt; <span class="built_in">&amp;</span> &lt;item2&gt; <span class="built_in">&amp;</span> ... <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span> </span><br><span class="line">&lt;item1&gt; <span class="built_in">&amp;</span> &lt;item2&gt; <span class="built_in">&amp;</span> ... <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图片">图片</h2>
<p>LaTex本身不支持插图功能，需要调用graphicx宏包辅助支持。<br>
各种编译方式支持的图片格式如下图（xelatex最好）<br>
<img src="graphicx.png" alt=""><br>
在调用了graphicx宏包后，就可以使用以下命令加载图片了。其中filename为文件名，不在同一路径时，需使用相对路径或绝对路径。可选参数如下图。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\includegraphics</span>[⟨options⟩]&#123;⟨filename⟩&#125;</span><br></pre></td></tr></table></figure>
<p><img src="includegraphics.png" alt=""></p>
<h1>排版数学公式</h1>
]]></content>
      <tags>
        <tag>LaTex</tag>
      </tags>
  </entry>
  <entry>
    <title>鸟叔的linux私房菜学习笔记</title>
    <url>/posts/e552a718/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>个人感觉，鸟叔讲得很细，但是这本书很难坚持看下去，本人都是挑着看的。</p>
<h1>第零章、计算机概论</h1>
<p>中央处理器（Central Processing Unit,cpu ）,主要工作是<strong>管理</strong>和<strong>运算</strong>，cpu读取的所有数据均来自于内存，处理后的数据也必须先写回内存。<br>
cpu 32位与64位：内存每次传给CPU的数据量，32bit 还是 64bit。所以说64位比32位，内存传给CPU的数据量翻了一倍。<br>
<strong>双通道</strong>：一条总线的带宽是64位，那么两个就是128位，所以双内存更快。最好两个内存的型号都完全一致。有的主板四条内存插槽的颜色不一样，需要两根容量相同的内存插在相同颜色的插槽当中，才能启用双通道。<br>
<strong>CPU第二层高速缓存内存</strong>：对于一些很常用的程序或数据可以放置在CPU内部，那么CPU就不用去内存读取数据了，这就是CPU第二层高速缓存的设计概念。</p>
<h3 id="字符编码">字符编码</h3>
<p>鸟叔的这张图相当形象了。<br>
<img src="encoding.png" alt=""></p>
<h3 id="机器语言与高阶程序语言">机器语言与高阶程序语言</h3>
<p><img src="bianyi.png" alt=""></p>
<h1>linux是什么与如何学习</h1>
<blockquote>
<p>鸟哥上课时，常常有学生问到：“老师，到底要听过你的课几次之后，才能学的会？”鸟 哥的标准答案是：“你永远学不会！”。<strong>因为你是用“听”的，没有动手做</strong>，那么永远不会知道“经 验”两个字怎么写!<br>
windows救命三键（Ctrl+Alt+Delete）</p>
</blockquote>
<h1>首次登录</h1>
<ul>
<li>shell中通过<strong>空格</strong>来区分命令，但是多个空格仍只会视为一个空格。</li>
<li><strong>tab</strong>：一次tab键<strong>命令补全</strong>，两次tab显示所有以输入字符开头的命令</li>
<li>ctrl+c：结束正在运行的命令</li>
<li><strong>ctrl+d</strong>：直接离开命令行（相当于exit)</li>
<li>shift+pageUp/pageDown：返回上次命令输出结果（相当于用鼠标滑轮）。</li>
</ul>
<h3 id="帮助文档">帮助文档</h3>
<ul>
<li>date <strong>–help</strong>: 简短说明</li>
<li><strong>man</strong> date: 详细说明。输入**/string**，向下搜寻string这个字符串。输入**?string**，向上搜索。</li>
</ul>
<h3 id="文件权限">文件权限</h3>
<ul>
<li>r(read) : 可读取此文件的内容</li>
<li>w(write): 可以修改文件内容（但不能删除该文件）</li>
<li>x(execute): 可以被系统执行</li>
</ul>
<h3 id="目录权限">目录权限</h3>
<ul>
<li>
<p>r(read) : 可读取该目录结构，即查询该目录下的文件名数据，可以使用ls命令。</p>
</li>
<li>
<p><strong>w(write)</strong>：可执行操作如下</p>
<ul>
<li>创建新的文件和目录</li>
<li><strong>删除</strong>已存在的文件或目录</li>
<li>将已存在的文件或目录进行更名</li>
<li>移动该目录下的文件、目录位置</li>
</ul>
</li>
<li>
<p>x(execute): 能否进入该目录，使之成为工作目录<br>
目录当然没有所谓的<strong>执行</strong>能力，这里的执行权限是指能不能直接进入该目录，用命令来说，就是能不能cd到该目录。<strong>如果不给x权限，w权限也没办法实现</strong></p>
</li>
</ul>
<h3 id="权限管理总结">权限管理总结</h3>
<p>需要给别人浏览的文件，<strong>目录</strong>需要提供<strong>r</strong>和<strong>x</strong>权限，<strong>文件</strong>需提供<strong>r</strong>权限。<strong>w</strong>权限需谨慎开放。</p>
<h1>Linux文件与目录管理</h1>
<h2 id="环境变量">环境变量</h2>
<p>通过<strong>echo $PATH</strong> 查看环境变量。设置环境变量的作用：运行程序时不用加路径，比如直接写plink，而不用写./plink。</p>
<ul>
<li>所有用户在PATH变量中都有/bin 或 /usr/bin 这个目录。这两个目录是一样的，因为/bin 是 /usr/bin的链接。</li>
<li>环境变量有<strong>顺序</strong>的区别，系统会按照顺序依次查找各个文件夹</li>
<li>添加环境目录
<ul>
<li>把当前的目录放入环境变量中。参考以下网页<a href="https://blog.csdn.net/yi412/article/details/11523525">linux 环境变量设置（临时 + 永久）</a>。</li>
<li>将程序或链接放在已在环境变量的目录中。个人常用，感觉更简单。</li>
</ul>
</li>
</ul>
<h2 id="查找文件">查找文件</h2>
<ul>
<li><strong>which</strong> 在PATH变量中搜索，并返回第一个搜索结果。 -a 列出所有结果</li>
<li><strong>whereis</strong> 只在特定的几个目录查找文件，感觉不实用。可以通过whereis -l 查看whereis查看的目录名称。</li>
<li><strong>locate</strong> 在数据库中查找，速度很快。但是数据库每天更新一次，因此最新创建的文件可能找不到，需要更新数据库（使用命令updatedb，需要root权限）。</li>
<li><strong>find</strong> 直接查找硬盘，速度慢。最后指定查找目录，缩小查找范围。</li>
</ul>
<h1>vim编辑器</h1>
<p>基本上 vi/vim 共分为三种模式，分别是一般模式或命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。但其实底线命令模式也是在一般模式下输入的。</p>
<h2 id="一般模式（命令模式）">一般模式（命令模式）</h2>
<ul>
<li><strong>/word</strong> <strong>向下</strong>寻找word（?word，向上）；通过<strong>n/N</strong>切换下（上）一个</li>
<li>:n1,n2s/word1/word2/g  从n1行到n2行查找word1,并替换为word2</li>
<li>1,$s/word1/word2/g   从第一行到最后一行查找替换</li>
</ul>
<h2 id="一般指令模式切换到编辑模式的可用的按钮说明">一般指令模式切换到编辑模式的可用的按钮说明</h2>
<ul>
<li>:wq</li>
<li>:wq! 强制写入</li>
<li>:w [filename] 另存为</li>
<li>set nu/nonu  显示/不显示行号</li>
</ul>
<h1>认识和学习BASH</h1>
<h2 id="万用字符（wildcard）">万用字符（wildcard）</h2>
<p>bash 支持万用字符（和正则表达式有区别），如用在ls命令中。<br>
<img src="wildcard.png" alt=""></p>
<h2 id="数据流重导向">数据流重导向</h2>
<p>standard output（标准输出）和 standard error output （标准错误输出）<strong>默认打印在屏幕上</strong>。</p>
<ul>
<li>标准输入，输出，错误输出代码分别为0，1，2。</li>
<li>
<blockquote>
<blockquote>
<p>追加，当文件不存在时主动创建，存在时追加。</p>
</blockquote>
</blockquote>
</li>
</ul>
<p><img src="standard.png" alt=""></p>
<h2 id="与">&amp;&amp; 与 ||</h2>
<p><img src="&amp;&amp;.png" alt=""></p>
<h2 id="管道命令">管道命令</h2>
<p>管道命令仅会处理standard output，对于 standard error output 会予以忽略。<br>
<img src="pipe.png" alt=""></p>
<h1>shell 编程</h1>
<p>shell 编程主要是用在<strong>系统管理</strong>上，不适合复杂的数据处理。</p>
<ul>
<li>多个空格视为一个空格</li>
<li>赋值（=）前后不能有空格</li>
<li>第一行必须为**/#!/bin/bash**，表明这个文件内的语法使用bash的语法</li>
<li>运行shell程序
<ul>
<li>直接运行（首先具有rx权限）
<ul>
<li>绝对路径：/home/dmtsai/shell.sh</li>
<li>相对路径：./shell.sh</li>
<li>PATH路径中：<a href="http://shell.sh">shell.sh</a></li>
</ul>
</li>
<li>以bash程序来执行（不需要权限，更方便）
<ul>
<li>bash <a href="http://shell.sh">shell.sh</a> 或 sh <a href="http://shell.sh">shell.sh</a></li>
</ul>
</li>
</ul>
</li>
<li>运行shell程序其实是在<strong>子程序</strong>的bash内执行的。（通过sourse命令在父程序中直接运行）<br>
<img src="sh.png" alt=""></li>
</ul>
<h1>账号管理</h1>
<h2 id="切换账号">切换账号</h2>
<ul>
<li>su - 切换为root账号</li>
<li>su zhouzw 切换为普通账号</li>
</ul>
<h1>程序管理</h1>
<h2 id="工作管理（job-control）">工作管理（job control）</h2>
<p>通过<strong>jobs -l</strong> 可以查看使用&amp;放入后台的程序的PID，然后就可以用kill命令杀掉后台程序。kill命令一般不建议使用-9选项强制关闭。</p>
]]></content>
      <tags>
        <tag>软件学习</tag>
      </tags>
  </entry>
  <entry>
    <title>word排版学习笔记</title>
    <url>/posts/821c2099/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前用word里包含十几个表，排版简直要吐血！而且更变态的是，不知道为什么，你调整其中的一个表，其他的表的格式却莫名其妙地乱了（一脸懵逼）。更让我难以接受的是，有的时候word报错其中一个表格已损坏，然后如果你没有备份的话，就一夜回到解放前。<br>
以上种种，让我已经坚定了要抛弃word的想法，用latex和markdown替代它。不过最近还是在B站看到了word排版的学习视频，那还是学一下吧！<br>
本文学习视频来自于<a href="https://www.bilibili.com/video/av64031582">word论文排版技巧</a></p>
<h1>快速设置三线表</h1>
<p>在一个表格内选择，在表格工具设计工具栏新建<strong>样式</strong>。修改样式名称，在格式应用于<strong>整个表格</strong>，修改右下角<strong>格式</strong>的边框属性、字体、<strong>边框和底纹</strong>（上下框线）。之后，将格式应用于<strong>标题行</strong>，修改<strong>格式</strong>的边框和底纹（下框线，上框线需要重新设置）。</p>
<ul>
<li>使用时，选中表格，点击该样式</li>
<li>右击该样式，可将该设置为默认，<strong>实用</strong>（这样把表格复制过来就是三线表）。</li>
<li>还需要手动调节表格工具-布局-对齐方式（<strong>文字居中</strong>），或<strong>自动调整</strong><br>
<img src="yangshi.png" alt=""></li>
</ul>
<h1>样式的概念</h1>
<blockquote>
<p>开始工具栏中右键<strong>样式</strong>-修改，可修改所有应用该样式的文本。<br>
另一种快捷方式是，修改某一个应用该样式的文本，右击样式，更新 ** 以匹配所选内容</p>
</blockquote>
<h1>标题的自动编号</h1>
<p>自动编号的好处是如果后面需要增删章节，不用手动修改。</p>
<ul>
<li>先写好文章标题和内容，标题不要写前缀，第一章或1.1什么的。点击段落中的多级列表（默认为1级，可点击<strong>更改列表级别</strong>）。然后右击样式，更新 ** 以匹配所选内容</li>
<li>修改编号：点击<strong>定义新的多级列表</strong> ，可以在输入编号的格式中添加文字，此级别的编号样式可以选择简体中文。<br>
<img src="many_list.png" alt=""></li>
</ul>
<h1>正文样式</h1>
<p>直接修改正文样式可能会导致标题等样式的改变，右击标题样式-修改，发现样式基础是正文。<br>
作者给出的解决方法是新建一个样式，命名为<strong>0_正文</strong>，将所有的正文在这里进行修改。</p>
<ul>
<li>行距最好使用倍数，而尽量不用多少磅，不然图片显示可能出问题。</li>
</ul>
<h1>图名、表明的设置与引用 7P</h1>
<p>比较复杂，放弃写了。打算自己以后直接看视频，这还比较简单。见谅。</p>
<h1>分页符与分节符 8P</h1>
<p>分页符，固定分页，比如下一章<br>
分节符，使不同节的<strong>页眉</strong>可以不一致。</p>
<h1>目录 9P</h1>
<h1>页眉与页脚的设置 10P</h1>
<h1>公式的编号与引用</h1>
<p>mathtype 插件</p>
<h1>参考文献-NE</h1>
<ul>
<li>插入多篇文献：在NE中使用shift或ctrl选中多篇文献</li>
<li>修改后更新编号：点击格式化</li>
<li>清除域代码前备份一份。<strong>必须保留一份含有域代码的文件</strong>，清除域代码的文件仅作为上交材料。</li>
</ul>
]]></content>
      <tags>
        <tag>软件学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel学习笔记</title>
    <url>/posts/438c10d4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>个人对Excel的态度经历过几次转变。研究生入学前后学了点excel的一些高级函数（vlookup啥的），录制点宏啥的，感觉excel还是蛮方便的。等到自己实际处理数据时，发现只要数据破万，excel做起来就很慢，右下角显示%4、%5，慢慢等待，也干不了别的，甚至有的时候显示未响应，又得重头来，这时候就可能在心里默默地喊一句excel垃圾。之后学了些python啥的，就开始逐渐抛弃excel了，基本不用excel做任何复杂处理，主要就是显示数据。现在逐渐感觉，每种语言或工具还是有它的独到之处，没有什么最优秀之说，只有适不适合。当数据量小，而且只做一些比较简单的处理或分析时，excel依然时最快的。<br>
本部分均是学习刘伟老师的Excel的系列课程，本文是根据本人的知识情况进行整理，详细可前往B站或其他网站观看视频课程。</p>
<h1>Excel 2016基础</h1>
<p>这里我个人觉得比较简单，就提取了一些之前不知道的点。</p>
<h2 id="快捷键">快捷键</h2>
<ul>
<li>ctrl+滑轮     改变excel显示比例。发现这个同样适用浏览器和其他软件</li>
<li>ctrl+enter  区域填充。先选中要填充的区域，在第一个单元格输入公式或数据后，按此快捷键。</li>
<li>alt+enter   单元格内换行</li>
<li>ctrl+A        选中区域。鼠标放在某个数据区域内，一次ctrl+A选中区域，两次ctrl+A选中工作表。</li>
<li>ctrl+G        定位快捷键。</li>
</ul>
<h2 id="其他快捷操作">其他快捷操作</h2>
<ul>
<li><strong>快速填充</strong> 。第一个单元格输入值后填充，右下选择快速填充，excel会比较<strong>智能</strong>地根据第一个单元格的形式填充。如下图所示，点击快速填充后即可提取个体号中的场代码。<br>
<img src="quick_tianchong.png" alt=""></li>
<li>公式迅速转为数值：鼠标<strong>右键</strong>该列右边框，向右边移动一列，再移回来，在弹出的对话框里显示仅复制数值。</li>
<li>对区域进行自动求和，选中包括数据和预计求和空白区域的区域，点击开始菜单栏的自动求和，即可看见空白区域为每行每列的和。有点绕，见下图<br>
<img src="area_sum.png" alt=""></li>
</ul>
<h2 id="小知识">小知识</h2>
<ul>
<li>excel显示的值与真实值可以不一样，但是实际运算是按照真实值计算的。
<ul>
<li>例如对数字1.23456，选择单元格形式为数值（小数点保留2位），可以看到单元格已经显示为1.23，但是你点击该单元格，上方的编辑栏依然显示为1.23456</li>
<li>只有使用ROUND函数，才是真正改变了数值。</li>
</ul>
</li>
<li>数值型数字与文本型数字
<ul>
<li>数值型数字：最长15位，超过15位后多余的位数在excel中自动变0，并用科学计数法表示</li>
<li>文本型数字：一般用于身份证号码等，只能计数，不能参与运算。</li>
<li>最简单的区别是对齐方式，文本格式数据<strong>靠左对齐</strong>，数值型数据<strong>靠右对齐</strong></li>
</ul>
</li>
<li>Excel 自动恢复并不靠谱，仅能在Excel本身出故障时起到一点作用，还是需要手动保存。这里，推荐一个VBA代码，可以直接保存打开的所有excel工作簿：<a href="https://www.extendoffice.com/zh-CN/documents/excel/2971-excel-save-all-open-files.html">一键保存所有打开工作簿</a>。</li>
<li>excel中日期的本质也是数字，将1900/01/01设为1，1900/01/02为2。一天是1，一个小时是1/24，以此类推。</li>
</ul>
<h1>Excel 公式与函数</h1>
<p>Excel个人感觉掌握几个用的比较多的函数就够了，比如VLOOKUP，SUMIF，COUNTIF。太复杂的函数或函数嵌套，个人感觉没有必要学，有点鸡肋。</p>
<h2 id="小知识-2">小知识</h2>
<ul>
<li>函数中需要引用字符串时，只能使用<strong>双引号</strong>，不能使用单引号。</li>
<li>在逻辑判断中，所有<strong>非0数值</strong>均认为是<strong>TRUE</strong>，只有0表示FALSE。</li>
<li>ctrl+左键选择多列后，右键插入下一行，会在列与列之间插入空行。</li>
<li>多条件判断。个人比较喜欢用第二种方式
<ul>
<li>AND(条件1，条件2)  = 条件1 * 条件2</li>
<li>OR（条件1，条件2）=条件1 + 条件2</li>
</ul>
</li>
<li>删除空格：使用替换，原值输入一个空格，替换的值什么也不输入即可。</li>
</ul>
<h2 id="vlookup">vlookup</h2>
<p>vlookup 最后一个参数，</p>
<blockquote>
<p>如果选择TRUE（模糊匹配），那么要求查找区域必须按<strong>升序</strong>排列。如果匹配不到原值，那么查找区域会匹配比原值<strong>小</strong>的最大值。这种情况比较适合查找值为数字，例如纳税，5000-6000是x，那高于5000低于6000的纳税比例都是x。<br>
如果选择FALSE（精确匹配），此时查找区域无需排序，必须匹配原值。个人主要是用精确匹配。</p>
</blockquote>
<h2 id="countif-s-与-sumif-s">countif(s) 与 sumif(s)</h2>
<p>按条件计数或求和，加s可以按多条件匹配，很实用。</p>
<h2 id="find-left-mid-right">find + left/mid/right</h2>
<p>find与search函数几乎是一样的，都是返回查找字符的索引（从1开始计数）,唯一区别就是<strong>find区分大小写</strong>，而search不区分大小写。<br>
估计find函数的使用也就是配合 left/mid/right这三个函数提取子字符串。如下，提取A1单元格（地址）的省份信息（光用left不够，因为不同省份字数不同，比如黑龙江就三个字）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B1&#x3D;LEFT(A1,FIND(&quot;省&quot;,A1))</span><br></pre></td></tr></table></figure>
<h2 id="英文处理">英文处理</h2>
<ul>
<li>proper 函数： 英文首字母大写</li>
<li>upper  函数：一律大写</li>
<li>lower   函数：一律小写</li>
</ul>
<h2 id="判断单元格类型">判断单元格类型</h2>
<ul>
<li>ISTEXT：        是否为文本</li>
<li>ISNUMBER：是否为数值</li>
</ul>
<h2 id="数组计算">数组计算</h2>
<ul>
<li><strong>F9</strong> 显示数组计算时的值（个人用于合并单元格内容）</li>
<li><strong>ctrl+shift+enter</strong> 数组计算</li>
</ul>
<h1>Excel 宏</h1>
<p>宏和VBA在实质上是相通的。个人感觉VBA有点鸡肋，对我而言，现在不太需要录制宏了。原因很简单，我不用Excel进行复杂的操作，自动也用不上宏了。</p>
<h2 id="小知识-3">小知识</h2>
<ul>
<li>
<p>相对引用与绝对引用。录制宏的时候可按需要切换引用方式。</p>
</li>
<li>
<p>录制宏与选择区域的顺序问题</p>
<ul>
<li><strong>先选择区域，再录制宏</strong>：一般这么做</li>
<li>先录制宏，再选择区域：无法更改选择区域，死的。</li>
</ul>
</li>
<li>
<p>逐条语句运行</p>
<ul>
<li>选择VBA界面的<strong>调试</strong>中的逐语句</li>
<li>F8快捷键</li>
</ul>
</li>
<li>
<p>屏蔽宏运行过程</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">application.screenupdating &#x3D; False</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据分析</tag>
        <tag>软件学习</tag>
      </tags>
  </entry>
  <entry>
    <title>plink学习笔记</title>
    <url>/posts/def937d0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近看到一个个人网站，里面有句话如下。</p>
<blockquote>
<p>为什么我最近更新得这么勤，因为我在不断充电。</p>
</blockquote>
<p>嗯，保持充电确实很重要啊！记录并总结自己的学习过程也很重要！我之前学东西都是记在笔记本或者脑子里，但是都不牢靠。纸质的东西总是易于损坏、丢失的，人脑的记忆能力也是有限的，而且我写的字也很难看。这个时候，将笔记什么的电子化就很有优势了。我在想，与其先记在本子上，再转到电子形式，不如从现在就训练自己用直接markdown写东西、记东西。</p>
<p>本文主要是学习了plink1.07的官方文档  <a href="http://zzz.bwh.harvard.edu/plink/dist/plink-doc-1.07.pdf">plink-doc-1.07.pdf</a>，有些内容因为个人暂时用不上，就跳过了，详细内容可直接阅读该文档。</p>
<span id="more"></span>
<h1>第一部分 plink 入门 —— 前三章</h1>
<p>ped文件前六列为家系ID，个体ID，父亲ID，母亲ID，性别（公1母2，其他为未知），表型（数量性状或疾病性状）。从第7列开始为基因型。ped不能有标题行。plink通过<strong>家系ID和个体ID</strong>来区分不同个体，即家系ID和个体ID不能都相同（但一般情况下要保持个体ID的唯一性）。<br>
map文件由四列组成，第一列为染色体（常染色体从1开始编号，性染色体是X或Y，0表示未知），第二列是SNP名称，第三列是遗传图谱（摩尔根距离，单位是厘摩，cm，大部分分析都用不上），第四列是物理图谱（真实距离，单位是bp，正整数，低于人的染色体长度。如果为负数，该SNP将被plink剔除)。–map3选项表示map文件中没有第三列遗传图谱。</p>
<h2 id="ped表型格式-phenotype">ped表型格式 phenotype</h2>
<p>疾病性状默认-9或0表示缺失，1表示未感染，2表示感染。可以使用–1选项，将-9认为缺失，0认为未感染，1认为感染。plink将性别不明的个体的表型也设置为缺失，可使用 --allow-no-sex禁止该现象。通过 --missing-phenotype -99 设置缺失表型值。<br>
如果ped文件中的一个个体的两个标记之间没有空格（例AG，而不是A G），那么在读取数据时可使用–compound-genotypes选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;plink --file mydata --compound-genotypes &lt;&#x2F;tt&gt;</span><br></pre></td></tr></table></figure>
<p>plink支持以标准输入流形式读取ped文件（用-替代ped文件名），但是不适用map文件。代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.... | .&#x2F;plink --ped - --map mymap.map --make-bed</span><br></pre></td></tr></table></figure>
<h2 id="ped基因型格式-genotype">ped基因型格式 genotype</h2>
<p>plink软件可以支持任何形式的SNP的编码，ATGC或1234都适用。plink 基因型缺失值格式默认为0，可通过–missing-genotype 修改缺失值。所有的标记都必须为<strong>双等位基因</strong>。<br>
可以通过–output-missing-phenotype 和 --output-missing-genotype修改plink输出文件的默认缺失值格式<br>
但需要输出新文件时（如生成二进制ped），plink通常会保留所有的基因型信息（即保持转换前后实际内容不变）。但是当使用plink进行统计和数据分析是，plink会对基因型数据进行筛选，将一部分基因型数据自动设置为缺失并剔除。</p>
<p>–file 需要ped和map文件名称相同。如果不加–out选项，默认名称均为plink。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file hapmap1</span><br></pre></td></tr></table></figure>
<h2 id="其他芯片文件格式-——-Transposed-filesets">其他芯片文件格式 ——  Transposed filesets</h2>
<p>文档中提到有一种转置的ped文件类型，由tped文件和tfam文件构成。tped文件每一行是一个snp，前4列是map文件的内容，后面每两列是一个个体该SNP的基因型。tfam文件是原ped文件的前六列。<br>
该文件可通过 --tfile 或 --tped --tfam读取，通过 --transpose 生成.<br>
<img src="/images/transpose_ped.png" alt=""></p>
<h2 id="其他芯片文件格式-——-Long-format-filesets">其他芯片文件格式 —— Long-format filesets</h2>
<p>该格式包括三个文件lgen文件，map文件（同上），fam文件（原ped文件的前六列）。lgen文件由5列组成，分别为家系ID，个体ID，snp名称，该snp的第一个等位基因，第二个等位基因。<br>
该文件可以通过 --lfile 命令读取，并使用 --recode 转换为标准的ped文件。根据说明文档，目前plink不支持输出这种格式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --lfile test --recode</span><br></pre></td></tr></table></figure>
<p><img src="/images/lgen_ped.png" alt=""></p>
<h2 id="额外的表型文件">额外的表型文件</h2>
<p>除了在ped文件（或fam文件）中的第六列准备表型，plink还支持输入一个单独的表型文件（–pheno）。表型文件应包含三列，家系ID，个体ID，表型。但是ped文件中依然不能缺少第六列（虽然此时没有作用了）。</p>
<ul>
<li>如果ped中的个体没有出现在表型文件中，那么plink会将该个体的表型设为缺失。</li>
<li>表型文件中个体的顺序不需要按照ped文件的顺序。</li>
<li>如果表型文件表型文件中不止一列表型，此时使用–mpheno N命令来明确使用的是第N列表型。如下代码所示，pheno2.txt共7列（即有5列表型，暂命名为A,B,C,D,E），那么这里用的是第4列表型，即表型D。</li>
<li>表型文件默认没有标题行，如果有，那么前两个标题必须为FID和IID，此时指定表型列可直接使用标题，如 --pheno-name age</li>
<li>表型文件中所有表型必须为数值，缺失值默认为-9（可以通过–missing-phenotype设置）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file mydata --pheno pheno2.txt --mpheno 4</span><br></pre></td></tr></table></figure>
<h2 id="生成二进制文件">生成二进制文件</h2>
<p>–make-bed 生成二进制ped文件，压缩数据大小，加快分析速度。该命令生成二进制文件时，不会根据missing rates或等位基因频率清洗任何SNP位点或个体。<br>
该命令生成三个文件，bed文件为二进制的ped文件，bim为扩展的map文件（相较于原map文件，增加了两列，为每个SNP的等位基因名称），fam文件（ped文件的前六列）。这三个文件是配套的，<strong>不能修改bim文件和fam文件</strong>，否则可能会导致错误。<br>
读取二进制文件，使用–bfile替代–file。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file val --make-bed</span><br></pre></td></tr></table></figure>
<h2 id="统计缺失率或基因分型率">统计缺失率或基因分型率</h2>
<p>生成二进制文件后，可直接使用二进制文件来进行分析（–bfile），如通过–missing分析基因分型率call rate（或missing rate）。<br>
生成missing_data.imiss和missing_data.lmiss文件（分别为个体的缺失情况文件和SNP位点的缺失情况文件，i和l为individual的individual和locus的缩写）。imiss文件中N_MISS列为该个体未测出的SNP数目，N_GENO为总的SNP数目，F_MISS为未检出的SNP所占比例。同样地，lmiss的最后三列分别为所有个体中该位点未检出个数，个体数，该位点未检出比例。<br>
（注，plink会首先联网查找更新，如果服务器没联网或者运行时不需要联网，需要添加命令 --noweb。）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile plink --missing --out missing_data</span><br></pre></td></tr></table></figure>
<p>–chr 1 按不同染色体去运行plink命令。减少运算量。</p>
<h2 id="统计等位基因频率">统计等位基因频率</h2>
<p>–freq 统计等位基因频率，生成frq文件。其中MAF为该snp位点最小等位基因频率<br>
（在plink中，将基因频率较小的叫做A1，将基因频率较大的叫做A2）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --noweb --bfile plink --freq --out freq_stat</span><br></pre></td></tr></table></figure>
<p>对有群体分层现象的不同群体进行等位基因频率分析。下面pop.phe描述了不同个体所属的群体（cluster）情况，三列（家系ID，个体ID，所属群体）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --noweb --bfile plink --freq --within pop.phe --out freq_stat</span><br></pre></td></tr></table></figure>
<p>–snp rs1891905 选择特定的SNP进行分析。–window kb --from --to 选择一堆snp进行分析。</p>
<h2 id="基本关联分析">基本关联分析</h2>
<p>基本关联分析 --assoc。（后面有关关联分析的内容没看，本人用不上。）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile plink --assoc --out as1</span><br></pre></td></tr></table></figure>
<h2 id="读取plink命令文件">读取plink命令文件</h2>
<p>当plink命令较长时，可将plink命令写入一个文件中。运行 --script命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --script myscript1.txt</span><br></pre></td></tr></table></figure>
<p>myscript1.txt内容如下，每一行一个命令，以–开始。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--ped ..\data\version1\50K\allsamples.ped</span><br><span class="line">--map ..\data\allmapfiles\finalversion\autosomal.map</span><br><span class="line">--out ..\results\working\sample-missingness-v1.22</span><br><span class="line">--from rs66537222</span><br><span class="line">--to rs8837323</span><br><span class="line">--geno 0.25</span><br><span class="line">--maf 0.02</span><br><span class="line">--missing</span><br></pre></td></tr></table></figure>
<h1>第二部分 plink 数据管理</h1>
<h2 id="recode">recode</h2>
<p>对于ped文件，使用–recode命令，生成的文件与原文件内容相同，仅仅按snp所在染色体及真实位置进行了排序。个人理解，如果要重新生成ped格式的芯片文件，那么就需要使用–recode命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --noweb --file val --recode</span><br></pre></td></tr></table></figure>
<p>plink支持将二进制文件重新转为普通ped文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile mydata --recode</span><br></pre></td></tr></table></figure>
<p>使用–recode12 命令将会使基因型重编码为1和2（0依然表示未知）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --noweb --file val --recode12</span><br></pre></td></tr></table></figure>
<p>将ped基因型从ATGC转到1234，使用–allele1234（相反则用–alleleACGT）。注意，–allele1234必须配合–recode 或 --make-bed等生成文件命令或其他分析命令使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file val --recode --allele1234</span><br></pre></td></tr></table></figure>
<h2 id="生成snp-list文件">生成snp list文件</h2>
<p>按SNP的基因型排列 --list，生成list文件，格式为染色体-snp名称-基因型（双）-第一个个体的家系ID-第一个个体的个体ID-第二个个体……。可配合–snp命令，查看某个snp的基因型情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file val --list</span><br></pre></td></tr></table></figure>
<h2 id="更新covariate文件">更新covariate文件</h2>
<p>重新生成covariate文件，当–covar 配合生成文件命令（–recode 或 --make-bed）。好处是当covariate文件包含个体多于芯片，或顺序不一致时，生成的新文件与芯片文件保持一致。(–write-cluster类似,形成新的cluster文件)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --covar myfile.txt --recode</span><br></pre></td></tr></table></figure>
<h2 id="翻转部分的SNP-例A变成T-改为等位基因基因型">翻转部分的SNP(例A变成T,改为等位基因基因型)</h2>
<p>准备一个snp名称文件(只有一列,为需要转换的snp名称),list.txt。flip命令需配合–recode等生成文件命令使用。适用于当芯片出现正反链问题时。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --flip list.txt --recode</span><br></pre></td></tr></table></figure>
<p>当只对芯片中的一部分个体进行转换时，增加–flip-subset选项。mylist.txt为个体ID。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --flip list.txt --flip-subset mylist.txt --recode</span><br></pre></td></tr></table></figure>
<h2 id="合并两个芯片文件">合并两个芯片文件</h2>
<p>合并两个芯片文件(merge 后面必须是ped map；–recode是必需的)。merge合并文件时，两个芯片文件的标记和个体之间可以是完全重合、部分重合甚至没有重合。文档中举例，如果一个snp只出现在第二个芯片文件中，那么第一个芯片文件中的个体（没出现在第二个文件）合并后该snp均为缺失。个人理解是，merge合并的文件应该会按照个体数最多、标记数最多的原则，所有不知道的位点全部设为缺失。<br>
第二，在第一个文件中已经存在的标记数据，默认情况下不会被第二个文件覆盖。例如第一个文件某个体某snp为AA，第二个文件该个体该SNP为AG，最终合并文件中还是AA。覆盖情况可以通过–merge-mode调整。<br>
第三，两个map同一个snp的物理位置需保持一致。<br>
第四，两个芯片文件的snp编码方式要保持一致，不能一个ATGC，一个123。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data1 --merge data2.ped data2.map --recode --out merge</span><br></pre></td></tr></table></figure>
<p>merge命令可用于二进制文件，此时需用–bmerge，输出需用–make-bed</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile data1 --bmerge data2.bed data2.bim data2.fam --make-bed --out merge</span><br></pre></td></tr></table></figure>
<h2 id="合并多个芯片文件">合并多个芯片文件</h2>
<p>使用–merge-list命令，需要准备文件，后面每一个芯片文件一行（可以为普通格式，也可以是二进制格式）。例如合并fA到fH的芯片文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file fA --merge-list allfiles.txt --recode --out mynewdata</span><br></pre></td></tr></table></figure>
<p>allfiles.txt格式如下图<br>
<img src="/images/merge_list.png" alt=""></p>
<h2 id="提取SNPs的子集">提取SNPs的子集</h2>
<h3 id="基于染色体">基于染色体</h3>
<p>以下命令会默认生成6号染色体的二进制芯片文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --chr 6</span><br></pre></td></tr></table></figure>
<p>如果想生成正常格式的芯片文件，增加recode命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --recode --chr 6 --out chr1</span><br></pre></td></tr></table></figure>
<h3 id="基于snp范围">基于snp范围</h3>
<p>如果是挑一个范围内的所有标记（必须在同一条染色体）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile mydata --from rs273744 --to rs89883</span><br></pre></td></tr></table></figure>
<p>基于某个snp的上下游范围（–snp 和 --window)。以下命令将挑出rs652423上下游20kb的所有snp。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile mydata --snp rs652423 --window 20</span><br></pre></td></tr></table></figure>
<h3 id="基于染色体的物理位置（–from-kb-to-kb）">基于染色体的物理位置（–from-kb --to-kb）</h3>
<p>以下命令为挑选2号染色体上5000kb到10000kb的所有snp。类似选项有–from-bp,–from-mb</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile mydata --chr 2 --from-kb 5000 --to-kb 10000</span><br></pre></td></tr></table></figure>
<h2 id="随机采样-thin">随机采样 --thin</h2>
<p>–thin 0.2 表示随机抽取20%的snp。</p>
<h2 id="基于给定文件挑选snp">基于给定文件挑选snp</h2>
<p>以下命令中，mysnps.txt为snp名称，仅一列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file --extract mysnps.txt --recode</span><br></pre></td></tr></table></figure>
<p>当添加–range命令时，此时添加的文件格式是染色体（空格）起始物理位置（单位bp）（空格）结束物理位置(单位bp) （空格）该范围名称。每一行（4列）表示一个范围。如下图所示。<br>
<img src="/images/extract_range.png" alt=""></p>
<h2 id="剔除部分snps-exclude">剔除部分snps --exclude</h2>
<p>mysnps.txt为不需要的snp名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --exclude mysnps.txt --recode</span><br></pre></td></tr></table></figure>
<p>另外一种剔除方式是，在map文件中snp的物理位置设为负数（不适用于二进制文件）。</p>
<h2 id="挑出或移除部分个体">挑出或移除部分个体</h2>
<p>以下命令中，mylist.txt前两列为家系号 个体号（后面可以有其他列，plink会忽视）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --keep mylist.txt --recode</span><br></pre></td></tr></table></figure>
<p>移除个体使用–remove命令，文件格式与上述一致。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --remove mylist.txt --recode</span><br></pre></td></tr></table></figure>
<h3 id="通过其他文件内容筛选个体">通过其他文件内容筛选个体</h3>
<p>以下命令为挑选myfile.raw中第三列为1的个体。myfile.raw格式为三列，与表型文件、cluster文件格式一致，分别为家系ID 个体ID 自定义（如表型）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --filter myfile.raw 1 --freq</span><br></pre></td></tr></table></figure>
<p>如果给定文件中有多列，可以通过–mfilter指定列。以下命令便指定为fam文件中的表型（4表示前两列之后的第四列）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile data --filter data.fam2 --mfilter 4</span><br></pre></td></tr></table></figure>
<p>plink 中衍生出各种filter的命令，提取不同条件的个体，如–filter-cases、–filter-controls、–filter-males、–filter-females、–filter-founders、–filter-nonfounders。</p>
<h3 id="通过其他文件内容筛选snp">通过其他文件内容筛选snp</h3>
<p>类似上述，准备一个snp属性文件，第一列为snp名称，第二列及之后列为属性（空格分开，自定义）。</p>
<blockquote>
<p>一个snp可以有多个属性,也可以不接属性(即只有snp名称)<br>
属性文件中不用包括所有的snp,也可以包含不在map中的snp(plink会忽视)<br>
文件内容不需要顺序<br>
每个snp只能占一行(即不能重复)<br>
属性名称使用一个横杠,表示否定(exclude).可同时挑选多个属性,以逗号隔开.</p>
</blockquote>
<blockquote>
<p>多个属性条件时,默认是OR(或)逻辑;正负属性之间是and逻辑.<br>
以下命令即为挑选含有exonic属性,但是不含有failed属性的snp</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--attrib snps.txt exonic,-failed</span><br></pre></td></tr></table></figure>
<h1>第三部分 数据分析</h1>
<h2 id="基因型缺失">基因型缺失</h2>
<p>基本命令–missing<br>
<s>注意，结果文件lmiss和imiss文件都事先剔除了基因分型率小于90%的snp和个体（plink默认,可使用–mind 1保留所有个体）。如下图，imiss文件中N_GENO为50683（原map为50697个位点），这说明有14个snp位点因为分型率低于90%而被剔除。</s><br>
之前说错了，plink新版本（1.04以后）已经不会默认按基因分型检出率或MAF剔除个体或snp了。后面检查，发现删除的14个snp均是Y染色体上的，具体原因不是很清晰（猜测是因为我用的ped性别一列均是0（实际都是母猪），plink估计会将这种性别未知或母猪的Y染色体的snp删除掉）。屏幕上打印的信息如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Warning: Nonmissing nonmale Y chromosome genotype(s) present; many commands treat these as missing.</span><br></pre></td></tr></table></figure>
<p><img src="/images/imiss.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --missing</span><br></pre></td></tr></table></figure>
<h2 id="bligatory-missing-genotypes">bligatory missing genotypes</h2>
<p>这个不好翻译,文档中解释是有些snp位点不是因为基因分型失败,而是根本没检测。对于这种位点，我们可能希望不要删除这些位点（–geno）、或者因此而删除个体(–geno)。这个个人感觉还是比较实用，比如在合并不同map的芯片文件进行质控时。<br>
以下命令中，test.clst为正常的三列cluster文件，三列（cluster名称自定义）。test.oblig文件指定缺失的snp,两列，第一列是snp名称，第二列是cluster名称，如下图。按文档的例子，个人理解为，cluster文件只需指定有指定缺失snp的个体即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file test --missing --oblig-missing test.oblig --oblig-clusters test.clst</span><br></pre></td></tr></table></figure>
<p><img src="/images/oblig.png" alt=""><br>
注意</p>
<blockquote>
<p>该命令只对质控操作（–mind --geno）有效果，其他分析无效。<br>
如果设定为缺失的snp实际有基因型，仍会设为缺失。</p>
</blockquote>
<h2 id="哈温平衡">哈温平衡</h2>
<p>以下命令生成plink.hwe文件，格式如下图。最后四列是三种基因型的数目，观察到的杂合子频率，通过哈温平衡计算得到的理论杂合子概率，哈温平衡检验的p值。<br>
文档中提出，只有founders（个人理解是系谱里的最古老的个体）才会进行哈温平衡。但是我们一般ped文件中父母都是未知（0），所以所有个体都会进行哈温平衡检验。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --hardy</span><br></pre></td></tr></table></figure>
<p><img src="/images/hwe.png" alt=""></p>
<h2 id="等位基因频率">等位基因频率</h2>
<p>这个入门部分也有，使用–freq命令，生成frq文件，含有5列，分别为染色体、snp名称、A1(基因频率较小)、A2(等位基因频率较大)、MAF、无缺失的总的等位基因个数（小于等于2n,n为个体数）。</p>
<h2 id="孟德尔误差（Mendel-errors）">孟德尔误差（Mendel errors）</h2>
<p>本人对这个概念不是很清晰，从文档说明来看，大概是指根据父母的基因型推断的后代基因型与后代真实的基因型不符的情形，如父母都是AA，后代却是AB。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --mendel</span><br></pre></td></tr></table></figure>
<h2 id="性别确认">性别确认</h2>
<p>通过X染色体的基因型数据确认ped文件中的性别列是否有误。结果文件sexcheck文件有6列，分别为家系ID，个体ID，ped文件中的性别（公1母2），通过X染色体确认的性别，匹配状态（PROBLEM or OK）,F(The actual X chromosome inbreeding (homozygosity) estimate)。</p>
<blockquote>
<p>如果ped文件中性别是0，也会显示不匹配（PROBLEM）<br>
F如果大于0.8认为性别为公，如果小于0.2认为母（不懂F的概念）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile data --check-sex</span><br></pre></td></tr></table></figure>
<p>–impute-sex命令可将基于SNP数据的性别修改ped文件中的性别，需要配合输出文件命令使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile data --impute-sex --make-bed --out newfile </span><br></pre></td></tr></table></figure>
<h2 id="PCA分析">PCA分析</h2>
<p><a href="https://www.cog-genomics.org/plink/1.9/strat#pca">https://www.cog-genomics.org/plink/1.9/strat#pca</a></p>
<p>plink 用于作PCA分析，命令相当简单，就是加一个 --pca 就完事了</p>
<p>默认会输出20个主成分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--pca [count] [&#39;header&#39;] [&#39;tabs&#39;] [&#39;var-wts&#39;]</span><br><span class="line"></span><br><span class="line">--pca-cluster-names &lt;name(s)...&gt;</span><br><span class="line">--pca-clusters &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>count: 输出几个主成分，如 --pca 3 ，就是只要前3个主成分</li>
<li>header: eigenvec 文件加标题</li>
<li>tabs: 用tab 代替空格</li>
<li>var-wts:  You can request variant weights with the ‘<strong>var-wts</strong>’ modifier（不懂）</li>
</ul>
<p>第二个和第三个命令是当聚类后，你可以只挑出某几个cluster的个体做分析，二者的区别在于–pca-cluster-names 后面直接跟cluster的名称（以空格分开），–pca-culsters 后面接cluster名称的文件名</p>
<h1>第四部分 质控（QC）</h1>
<p>这一节对应文档的第6章，Inculsion thresholds，个人理解其实就是质控。这一节和上一节的数据分析的命令是有关联的，文档中用了一个图片说明，这里用一个表格说明。</p>
<table>
<thead>
<tr>
<th style="text-align:center">功能</th>
<th style="text-align:center">分析命令</th>
<th style="text-align:center">质控命令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">个体基因分型缺失率</td>
<td style="text-align:center">–missing</td>
<td style="text-align:center">–mind N</td>
</tr>
<tr>
<td style="text-align:center">SNP基因分型缺失</td>
<td style="text-align:center">–missing</td>
<td style="text-align:center">–geno N</td>
</tr>
<tr>
<td style="text-align:center">等位基因频率</td>
<td style="text-align:center">–freq</td>
<td style="text-align:center">–mat N</td>
</tr>
<tr>
<td style="text-align:center">哈温平衡</td>
<td style="text-align:center">–hardy</td>
<td style="text-align:center">–hwe N</td>
</tr>
<tr>
<td style="text-align:center">孟德尔误差比例</td>
<td style="text-align:center">–mendel</td>
<td style="text-align:center">–me N M</td>
</tr>
</tbody>
</table>
<h2 id="默认质控">默认质控</h2>
<p>高版本的plink（如1.9）已不会默认对个体或snp根据基因分型检出率或MAF进行质控。<br>
–all 不剔除任何个体或SNP，等于–mind 1 --geno 1 --maf 0</p>
<h2 id="个体基因检出率">个体基因检出率</h2>
<p>–mind 0.1 即剔除缺失率高于0.1的个体，或者说保留检出率高于0.9的个体。如果有个体被剔除，其个体信息保存在irem文件中<br>
–mind 1 即不剔除任何个体。使用该命令载入数据时不会计算个体的检出率，提高plink读取文件速度。</p>
<h2 id="snp基因检出率">snp基因检出率</h2>
<p>–geno 0.1 即剔除缺失率高于0.1的SNP，或者说保留检出率高于0.9的SNP。<br>
注意：–geno 和 --maf命令执行优先程度低于–mind，也就是同用–mind和–geno时，会先剔除缺失率较高的个体，再计算SNP检出率。</p>
<h2 id="最小等位基因频率">最小等位基因频率</h2>
<p>–maf 0.01 剔除MAF小于0.01的SNP</p>
<h2 id="哈温平衡-2">哈温平衡</h2>
<p>–hwe 0.001 如果需要剔除不满足哈温平衡的位点，使用该选项。p值小于0.001的个体被剔除，具体信息可见控制台（屏幕打印出的信息）或log文件。</p>
<h2 id="孟德尔误差比例（Mendel-error-rate）">孟德尔误差比例（Mendel error rate）</h2>
<p>只适用于family-based data。<br>
–me 0.05 0.1 第一个参数表示孟德尔误差超过5%的家系会被剔除；第二个参数表示孟德尔误差超过10%的SNP会被剔除。目前plink是同时计算家系和SNP的孟德尔误差比例，未来可能有所修改。</p>
<h1>第五部分 plink群体分层分析（Stratification analysis）和聚类分析（cluster analysis）</h1>
<h2 id="一般聚类">一般聚类</h2>
<p>根据IBS（identity-by-state,同态相同）进行聚类分析。基本命令如下，生成cluster0、cluster1、cluster2、cluster3四个文件，这四个文件内容一致，但格式不同（一般只用cluster1和cluster2）。</p>
<blockquote>
<p>cluster1文件是最直接的cluster结果文件，每一行是一个cluster，第一列SOL-0(估计是plink起的cluster名称)，后面就是每个cluster的个体（家系号_个体号）。<br>
cluster2文件是用来给plink读取的（使用–within *.cluster2）。格式为标准的三列，家系ID，个体ID，所属cluster。<br>
聚类时间与个体数有关。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile plink --cluster</span><br></pre></td></tr></table></figure>
<h2 id="加限制条件">加限制条件</h2>
<p>–cluster --mc 每个cluster最大的个体数量<br>
–ppc 0.05（pairwise population concordance） 当两个个体之间属于相同组的概率小于0.05时不进行合并（即设定P值）。<br>
结果文件是cluster1文件，每一行是一个cluster。第一列SOL-0什么的不用管，后面就是每个cluster的个体（家系号和个体号）。cluster2和cluster1内容一样，格式不同，cluster有三列，分别为家系号、个体号、所属cluster（cluster2 用于plink读取，–within plink）。<br>
可以通过–K（大写）选项设定cluster 的数目。但是这时不能再设定ppc。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --noweb --bfile plink --cluster --mc 10 --ppc 0.05 --out str1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --noweb --bfile plink --cluster --K 2 --out str2</span><br></pre></td></tr></table></figure>
<p>如果个体比较多，而且需要按不同条件进行多次聚类时，可按如下命令操作，节约时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile mydata --genome --out mydata</span><br><span class="line">plink --bfile mydata --read-genome mydata.genome --cluster --ppc 0.01</span><br><span class="line">plink --bfile mydata --read-genome mydata.genome --cluster --mc 2 --ibm 0.01</span><br></pre></td></tr></table></figure>
<h2 id="IBS-similarity-matrix">IBS similarity matrix</h2>
<p>添加–matrix命令，生成mibs文件，为方阵形式，内容为所有个体两两之间的同态相同的比例（0-1）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file mydata --cluster --matrix</span><br></pre></td></tr></table></figure>
<p>通过R画图来具体描述群体结构（适合芯片中存在几个群体的情况，手册中是前45个个体是中国人，后44个是日本人）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --noweb --bfile plink --cluster --matrix --out ibd_view</span><br></pre></td></tr></table></figure>
<p>生成ibd_view.mibs文件（手册上写的是mdist文件)，在R中读取该文件，画图步骤如下。<br>
个人尝试了一下，使用这种方式画图，和PCA画图结果差不多。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">m &lt;- as.matrix(read.table(<span class="string">&quot;ibd_view.mibs&quot;</span>))</span><br><span class="line">mds &lt;- cmdscale(as.dist(<span class="number">1</span>-m))</span><br><span class="line">k &lt;- <span class="built_in">c</span>( <span class="built_in">rep</span>(<span class="string">&quot;green&quot;</span>,<span class="number">100</span>) , <span class="built_in">rep</span>(<span class="string">&quot;blue&quot;</span>,<span class="number">222</span>) )</span><br><span class="line">plot(mds,pch=<span class="number">20</span>,col=k)</span><br></pre></td></tr></table></figure>
<h1>第六部分 IBS/IBD 估计</h1>
<p>通过估计芯片个体间的IBS和IBD情况，可以用来检测测序时样品污染，重复样一致性，系谱错误以及发现未知的亲缘关系。</p>
<h2 id="配对的IBD估计">配对的IBD估计</h2>
<p>上一章说了个体间IBS的估计以及根据IBS划分cluster，我们可以检测个体间的IBD情况。以下命令生成genome文件，文件格式如下图。需要关注的是PI_HAT（这个指标就是两个个体IBD相同的大小），<br>
使用–Z-genome会生成压缩文件plink.genome.gz，–read-genome也可以直接读取压缩的genome文件。<br>
注意：IBD分析前需要进行群体分层分析。而且ped文件中的家系ID、父本ID、母本ID应该要完整。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file mydata --genome</span><br></pre></td></tr></table></figure>
<p><img src="/images/genome.png" alt=""><br>
如果只计算同一个家系的IBD（家系按照ped文件中的系谱划分），使用命令–rel-check，会大大加快速度，不用每两个个体都要计算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file mydata --genome --rel-check</span><br></pre></td></tr></table></figure>
<p>通过–min x挑选结果中PI_HAT大于x的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file mydata --genome --min 0.05</span><br></pre></td></tr></table></figure>
<h2 id="估计近交系数">估计近交系数</h2>
<p>不是很清楚原理，文档中说based on the observed versus expected number of homozygous genotypes<br>
以下命令生成het文件，格式如下图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file mydata --het</span><br></pre></td></tr></table></figure>
<p><img src="/images/het.png" alt=""></p>
]]></content>
      <tags>
        <tag>数据分析</tag>
        <tag>软件学习</tag>
        <tag>生物信息</tag>
      </tags>
  </entry>
  <entry>
    <title>序 - 构建个人博客的原因和过程</title>
    <url>/posts/7ce416b6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>为什么开通个人博客？</h1>
<p>我在B站关注了一位up主，名字叫codesheep（程序羊），他是华科出来的硕士（自称”资质平平“，感觉自己都不用活了）。自称看了他的视频，才产生了构建个人博客的想法。我看他宣传开通个人博客的视频，应该是在去葫芦岛旅游前（2019年7月27号）。按照大佬的说法，开通个人博客，有百利而无一害，比如避免自己重复掉坑、能够吸引一点关注、可能对其他人有帮助、结交同性朋友等。我想了想，感觉说得都很对，我没办法反驳，心里就种下了种子。等从葫芦岛回来，有空余时间的时候就可以动手做了。<br>
本科毕业的时候，我从一件事情上吸取到了一个教训。那时候我发现我有很多买回来的书，就一直放着，很多都没看，就一直放着，直到毕业。最后，我感觉实在有点累赘，就或卖或送打发了。这些买回来的书，如果一开始没去看，可能我永远都不会去翻他。其他事情应该也是一样的吧。对于想做的事，一开始不着手去做的话，这辈子都不会做了吧。毕竟，一辈子其实想想也没有多长。</p>
<h1>开通个人博客的过程</h1>
<p>当时好像程序羊还没有发布详细的构建个人博客的视频，我就从知网找了个教程，看着比较详细，那上面第一步就说要有个域名。然后，我就去了阿里云上去查找注册域名，本来想注册自己的名字 <a href="https://www.zhouzw.com">zhouzw</a>，没想到已经被注册了。然后我就不知道用啥英文了，毕竟我没有正儿八经起过英文名。我就找到了我的词汇课的课件，第一个词根是-vict（胜利的意思），一查也被注册了。后面对这个词根的注解上说，来自于希腊语vincere，就用了这个不是英文单词的词。之后我发现阿里云上域名都是按年买的，我感觉这是不是坑我（我刚开始以为应该是注册了就是终生的）。谷歌了一下，才发现域名都是按年买的，逾期不付费会回收，尴尬。为什么选.fun这个后缀呢，当然是希望自己开开心心（假的，因为便宜，我一次性买了10年才花了179，<a href="http://xn--6iq8fuf485iowl.com">相比于什么.com</a>,.cn这种正规后缀，真的是好便宜！)<br>
然后按照知乎的流程去走（其实什么软件、命令都不懂），从4点到了将近7点（我一般5点多去吃饭），并没有弄通。整个人就有点不太好，虽然其实也没搞多长时间。后来又是看了程序羊的视频，才算是最终构建好了。  搭建好了个人博客，当时发了个微信。然后到现在又过了一个多礼拜，这期间主要是其它事和学习shell编程啥的。我总是想先把手头的东西弄完或学完，再弄别的事。然后就一直到了今天。</p>
<h1>用个人博客做什么</h1>
<p>现在初步打算把自己一年多的学习的东西，总结提取重点，发到这个个人博客上来。当然都是一些很基础的东西。参考别人的博客，我对我这个博客的设定为总结，总结自己学习的东西，总结自己遇到的坑，总结一些实践经验（如果有的话），偶尔总结一下自己矫情的感想。</p>
]]></content>
  </entry>
</search>
