<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DMU软件使用笔记</title>
    <url>/posts/59ca09be/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>DMU 是动植物育种领域常用的遗传评估软件，我之前也经常用。这里仅仅是我自己的一个备忘录，将一些疑难的点记录下来。</p>
<span id="more"></span>
<h1>参数卡设置</h1>
<h2 id="NOCOV">NOCOV</h2>
<p>设置模型中最后一个部分，应该是设置没有残差协方差的组分。</p>
<p>比如</p>
<p>1</p>
<p>1 2</p>
<p>就是说有一个组分没有残差协方差，第二行具体指明是哪两个性状，这是是说第一个性状和第二个性状之间没有残差协方差。</p>
<p>育种课的ppt是这么写的：</p>
<blockquote>
<p>多性状分析时，不同的性状可能在不同的个体测得。在这种情况下，性状间剩余值（即残差）相互独立，剩余值协方差通常要约束为0。</p>
</blockquote>
<h1>residual 结果文件</h1>
<p>官方文档。以单性状为例，第二列应该是表型值吧，不是所谓的predicted value 然后之后的三列才是文档说的三个残差。</p>
<p>这个文件的顺序和个数和表型文件一致。</p>
<p><img src="6.png" alt=""></p>
<h1>报错</h1>
<ul>
<li>估计是数据量太大，超出设置的内存总量</li>
</ul>
<p><img src="dmu1.png" alt=""></p>
<p>数据情况：芯片2万7 表型12万6 使用all 选项</p>
<ul>
<li>同时使用80k和50k的参考群，光跑dmu就跑了几天。结果没跑出来，也没报错。看了估计方差组分迭代了49次，估计是迭代次数设置了最多50次。</li>
</ul>
<p><img src="dmu2.png" alt=""></p>
<p><img src="dmu3.png" alt=""></p>
<ul>
<li>报日龄的单性状时报错，<strong>没解决</strong>。截至目前还不知道怎么处理。</li>
</ul>
<p><img src="dmu4.png" alt=""></p>
<ul>
<li>
<p>ssgblup 系谱报错</p>
<p>最后一列没有用行号</p>
</li>
</ul>
<p><img src="5.png" alt=""></p>
<ul>
<li>
<p>性状模型报错</p>
<p>他的意思应该是性状太多，信息不够，跑不出来。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AI or combined AI&#x2F;EM information matrix is not positive definite</span><br><span class="line">    Smallest eigenvalue:                       -7.015359837501943E-017</span><br><span class="line">    Rank:                                               44</span><br><span class="line">    No of co-variance components to estimate:           45</span><br><span class="line"> </span><br><span class="line">    This could be due to a variance component close to 0.0 or</span><br><span class="line">    that there is not enough information in the data for the model</span><br><span class="line"> </span><br><span class="line">    Program terminates</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>DMU</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>遗传育种</tag>
        <tag>DMU</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel学习笔记</title>
    <url>/posts/438c10d4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>个人对Excel的态度经历过几次转变。研究生入学前后学了点excel的一些高级函数（vlookup啥的），录制点宏啥的，感觉excel还是蛮方便的。等到自己实际处理数据时，发现只要数据破万，excel做起来就很慢，右下角显示%4、%5，慢慢等待，也干不了别的，甚至有的时候显示未响应，又得重头来，这时候就可能在心里默默地喊一句excel垃圾。之后学了些python啥的，就开始逐渐抛弃excel了，基本不用excel做任何复杂处理，主要就是显示数据。现在逐渐感觉，每种语言或工具还是有它的独到之处，没有什么最优秀之说，只有适不适合。当数据量小，而且只做一些比较简单的处理或分析时，excel依然时最快的。<br>
本部分均是学习刘伟老师的Excel的系列课程，本文是根据本人的知识情况进行整理，详细可前往B站或其他网站观看视频课程。</p>
<h1>Excel 2016基础</h1>
<p>这里我个人觉得比较简单，就提取了一些之前不知道的点。</p>
<h2 id="快捷键">快捷键</h2>
<ul>
<li>ctrl+滑轮     改变excel显示比例。发现这个同样适用浏览器和其他软件</li>
<li>ctrl+enter  区域填充。先选中要填充的区域，在第一个单元格输入公式或数据后，按此快捷键。</li>
<li>alt+enter   单元格内换行</li>
<li>ctrl+A        选中区域。鼠标放在某个数据区域内，一次ctrl+A选中区域，两次ctrl+A选中工作表。</li>
<li>ctrl+G        定位快捷键。</li>
</ul>
<h2 id="其他快捷操作">其他快捷操作</h2>
<ul>
<li><strong>快速填充</strong> 。第一个单元格输入值后填充，右下选择快速填充，excel会比较<strong>智能</strong>地根据第一个单元格的形式填充。如下图所示，点击快速填充后即可提取个体号中的场代码。<br>
<img src="quick_tianchong.png" alt=""></li>
<li>公式迅速转为数值：鼠标<strong>右键</strong>该列右边框，向右边移动一列，再移回来，在弹出的对话框里显示仅复制数值。</li>
<li>对区域进行自动求和，选中包括数据和预计求和空白区域的区域，点击开始菜单栏的自动求和，即可看见空白区域为每行每列的和。有点绕，见下图<br>
<img src="area_sum.png" alt=""></li>
</ul>
<h2 id="小知识">小知识</h2>
<ul>
<li>excel显示的值与真实值可以不一样，但是实际运算是按照真实值计算的。
<ul>
<li>例如对数字1.23456，选择单元格形式为数值（小数点保留2位），可以看到单元格已经显示为1.23，但是你点击该单元格，上方的编辑栏依然显示为1.23456</li>
<li>只有使用ROUND函数，才是真正改变了数值。</li>
</ul>
</li>
<li>数值型数字与文本型数字
<ul>
<li>数值型数字：最长15位，超过15位后多余的位数在excel中自动变0，并用科学计数法表示</li>
<li>文本型数字：一般用于身份证号码等，只能计数，不能参与运算。</li>
<li>最简单的区别是对齐方式，文本格式数据<strong>靠左对齐</strong>，数值型数据<strong>靠右对齐</strong></li>
</ul>
</li>
<li>Excel 自动恢复并不靠谱，仅能在Excel本身出故障时起到一点作用，还是需要手动保存。这里，推荐一个VBA代码，可以直接保存打开的所有excel工作簿：<a href="https://www.extendoffice.com/zh-CN/documents/excel/2971-excel-save-all-open-files.html">一键保存所有打开工作簿</a>。</li>
<li>excel中日期的本质也是数字，将1900/01/01设为1，1900/01/02为2。一天是1，一个小时是1/24，以此类推。</li>
</ul>
<h1>Excel 公式与函数</h1>
<p>Excel个人感觉掌握几个用的比较多的函数就够了，比如VLOOKUP，SUMIF，COUNTIF。太复杂的函数或函数嵌套，个人感觉没有必要学，有点鸡肋。</p>
<h2 id="小知识-2">小知识</h2>
<ul>
<li>函数中需要引用字符串时，只能使用<strong>双引号</strong>，不能使用单引号。</li>
<li>在逻辑判断中，所有<strong>非0数值</strong>均认为是<strong>TRUE</strong>，只有0表示FALSE。</li>
<li>ctrl+左键选择多列后，右键插入下一行，会在列与列之间插入空行。</li>
<li>多条件判断。个人比较喜欢用第二种方式
<ul>
<li>AND(条件1，条件2)  = 条件1 * 条件2</li>
<li>OR（条件1，条件2）=条件1 + 条件2</li>
</ul>
</li>
<li>删除空格：使用替换，原值输入一个空格，替换的值什么也不输入即可。</li>
</ul>
<h2 id="vlookup">vlookup</h2>
<p>vlookup 最后一个参数，</p>
<blockquote>
<p>如果选择TRUE（模糊匹配），那么要求查找区域必须按<strong>升序</strong>排列。如果匹配不到原值，那么查找区域会匹配比原值<strong>小</strong>的最大值。这种情况比较适合查找值为数字，例如纳税，5000-6000是x，那高于5000低于6000的纳税比例都是x。<br>
如果选择FALSE（精确匹配），此时查找区域无需排序，必须匹配原值。个人主要是用精确匹配。</p>
</blockquote>
<h2 id="countif-s-与-sumif-s">countif(s) 与 sumif(s)</h2>
<p>按条件计数或求和，加s可以按多条件匹配，很实用。</p>
<h2 id="find-left-mid-right">find + left/mid/right</h2>
<p>find与search函数几乎是一样的，都是返回查找字符的索引（从1开始计数）,唯一区别就是<strong>find区分大小写</strong>，而search不区分大小写。<br>
估计find函数的使用也就是配合 left/mid/right这三个函数提取子字符串。如下，提取A1单元格（地址）的省份信息（光用left不够，因为不同省份字数不同，比如黑龙江就三个字）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B1&#x3D;LEFT(A1,FIND(&quot;省&quot;,A1))</span><br></pre></td></tr></table></figure>
<h2 id="英文处理">英文处理</h2>
<ul>
<li>proper 函数： 英文首字母大写</li>
<li>upper  函数：一律大写</li>
<li>lower   函数：一律小写</li>
</ul>
<h2 id="判断单元格类型">判断单元格类型</h2>
<ul>
<li>ISTEXT：        是否为文本</li>
<li>ISNUMBER：是否为数值</li>
</ul>
<h2 id="数组计算">数组计算</h2>
<ul>
<li><strong>F9</strong> 显示数组计算时的值（个人用于合并单元格内容）</li>
<li><strong>ctrl+shift+enter</strong> 数组计算</li>
</ul>
<h1>Excel 宏</h1>
<p>宏和VBA在实质上是相通的。个人感觉VBA有点鸡肋，对我而言，现在不太需要录制宏了。原因很简单，我不用Excel进行复杂的操作，自动也用不上宏了。</p>
<h2 id="小知识-3">小知识</h2>
<ul>
<li>
<p>相对引用与绝对引用。录制宏的时候可按需要切换引用方式。</p>
</li>
<li>
<p>录制宏与选择区域的顺序问题</p>
<ul>
<li><strong>先选择区域，再录制宏</strong>：一般这么做</li>
<li>先录制宏，再选择区域：无法更改选择区域，死的。</li>
</ul>
</li>
<li>
<p>逐条语句运行</p>
<ul>
<li>选择VBA界面的<strong>调试</strong>中的逐语句</li>
<li>F8快捷键</li>
</ul>
</li>
<li>
<p>屏蔽宏运行过程</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">application.screenupdating &#x3D; False</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据分析</tag>
        <tag>软件学习</tag>
      </tags>
  </entry>
  <entry>
    <title>linear algebra step by step</title>
    <url>/posts/aec3be7e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这本书的名字就是 ，作者是 Kuldeep Singh。这本书主要是讲解线性代数的基础知识，是我目前看过的关于线代的书中讲的最清楚的。看完这本书，我才有一种恍然大悟的感觉，才有一点线代学通了的感觉。不过我没有记笔记，这里只是安利。</p>
<span id="more"></span>
<p>这本书的电子版可以在<a href="http://libgen.rs/">Library Genesis</a> 下载到。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>linear model in statistics</title>
    <url>/posts/d51e95ef/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这本书是讲线性模型，但是之前我应该只看了基础部分……</p>
<p>以后接着看再续上</p>
<span id="more"></span>
<h1>Linear Models In Statistics</h1>
<p>本书的目的之一是清晰地阐述；第二个目的是说清楚不同方法的关系。</p>
<p>本书可以作为参考书（reference book），也可以作为教科书（textbook)。</p>
<h2 id="introduce">introduce</h2>
<h3 id="简单的线性回归模型">简单的线性回归模型</h3>
<p>举例，工资与受教育年限的关系，身高和体重的关系，海拔与水沸腾的温度，药剂与效应的关系。模型如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y &#x3D; β0 + β1x + e(这个字母不好打，用e代替) （1.1）</span><br></pre></td></tr></table></figure>
<p>模型符合线性关系是一种假设，除此之外，我们还有其它的假设，比如残差的分布，观测值之间的独立性等等。</p>
<h3 id="MULTIPLE-LINEAR-REGRESSION-MODEL">MULTIPLE  LINEAR  REGRESSION  MODEL</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y &#x3D; β0 + β1x1 + β2x2 + …… + βkxk + e(这个字母不好打，用e代替) （1.2）</span><br></pre></td></tr></table></figure>
<p>The model in (1.2) is linear in the β parameters; it is not necessarily linear in the x variables. Thus models such as</p>
<p><img src="multiple_regression.png" alt="multiple_regression"></p>
<blockquote>
<p>A model provides a theoretical framework for better understanding of a phenomenon  of  interest.  Thus  a  model  is  a  mathematical  construct  that  we  believe  mayrepresent  the  mechanism  that  generated  the  observations  at  hand.  The  postulated model may be an idealized  oversimplification of the  complex real-world situation,but  in  many  such  cases,  empirical  models  provide  useful  approximations  of  therelationships  among  variables.  These  relationships  may  be  either  associative  orcausative.</p>
</blockquote>
<p>上面的话的简单解释。一个好的模型一定是比较符合变量的内部机制的。模型可能因为过度简化了复杂的真实情况而显得理想化，但是大部分情况下，凭借经验建立的模型往往能够有效地说明变量之间的关系，无论它们之间是相关关系还是因果关系。</p>
<p>回归模型可以用于：</p>
<ol>
<li>预测</li>
<li>描述数据</li>
<li>参数估计（β）</li>
<li><strong>变量选择或筛查</strong>：通过回归分析，决定每个自变量对因变量的重要性。能够大量解释y的方差的变量保留，否则剔除。</li>
<li>结果控制。回归模型假定x,y存在因果关系；因此，我们可以通过控制x的范围，来得到我们想要的理想范围的y。</li>
</ol>
<p>这5种目的有本质的区别。对于预测，我们只需要假设当我们用先前的数据得到的关系预测新的数据，仍然成立。我们通过回归模型得到y 与 x存在显著性关系，并不能证明它们之间存在因果关系。</p>
<h3 id="方差分析">方差分析</h3>
<p>方差分析一般用于比较几个群体或几种方法的区别。方差分析也可以理解为一种特别的线性模型，它的x 的值只有0和1。举个例子，某实验人员需要比较4种催化剂的作用。其模型可以设置为如下</p>
<p><img src="ANOVA1.png" alt=""></p>
<p>假设研究人员还想看三种不同温度的影响。对这12种催化剂-温度效应每一种进行n次实验。模型如下：</p>
<p><img src="ANOVA2.png" alt=""></p>
<p>方差分析可以理解为一种特殊的回归模型，但是一般还是把这两者分开比较方便。</p>
<h2 id="Matrix-Algebra">Matrix Algebra</h2>
<p>我们一般用加粗的大写字母表示矩阵；用加粗的小写字母表示列向量（即向量默认为竖着的）。</p>
<p>在矩阵和向量的章节中，一个具体的实数称为标量（scalar）。比如2.5就是一个标量，标量一般用不加粗的小写字母表示。</p>
<p>如果一个矩阵的转置矩阵等于其本身（<strong>A’ = A</strong>）, 那么这个矩阵是对阵矩阵（而且是方阵）。</p>
<p>以下这些公式不用死记，在脑子举个例子过一遍就理解了。</p>
<ul>
<li>**（A + B)’ = A’ + B’ **</li>
<li>一般，** AB 不等于 BA**</li>
<li>** A(B + C) = AB + AC **  （乘法符合分配律）</li>
<li>** (A + B) C = AC + BC **</li>
<li>** (A-B) (C-D) = (A-B) C - (A-B) D = AC - BC - AD + BD ** (进一步扩展)</li>
<li>** (AB)’ = B’A’ **</li>
</ul>
<h3 id="矩阵分段">矩阵分段</h3>
<p>有的时候将矩阵划分为几个子矩阵很方便。比如在矩阵相乘时，<strong>如 A 和 B 矩阵 的结构相同，划分子矩阵的结构也相同</strong>，那么 AB 可以转化为子矩阵的相乘（类似于元素的相乘）</p>
<p><img src="partition1.png" alt=""></p>
<p>如果把<strong>B</strong>换成一个向量<strong>b</strong>，仍然可以划分成子矩阵和子向量。其中A1的列数目等于b1的元素数目</p>
<p><img src="partition2.png" alt=""></p>
<p>更极端地，将<strong>A</strong>的每一列划分为一个子矩阵，将<strong>b</strong>的每一个元素视为一个子向量。例子如下</p>
<p><img src="partition3.png" alt=""></p>
<p>分块矩阵的转置</p>
<p><img src="partition4.png" alt=""></p>
<h3 id="秩">秩</h3>
<p>dependent 的定义如下：对于一系列的向量a1,a2,……，an，如果存在标量 c1,c2,……cn（不全为0），使得</p>
<p><img src="rank1.png" alt=""></p>
<p>那么我们就说是 dependent</p>
<p>如果不存在c1,c2,……cn，那么我们说a1,a2,……，an 是 线性不相关的。反过来，如果存在c1,c2,……cn，那么我们说，至少有一个a~i~ 是其它a向量的线性组合。</p>
<p>秩就是一个矩阵中线性不相关的行或列的数目。</p>
<p>很容易证明矩阵（square or rectangular）中，线性不相关的行的数目 = 线性不相关的列的数目。</p>
<p>在rectangular matrix中，如果是n × p，那么这个矩阵的最大的秩为 min(n,p)。<strong>因此，在一个rectangular matrix中，至少行或列（or both）是线性相关的</strong>。</p>
<p>由于一个矩阵的行或列可能存在线性相关，我们可以创造出 <strong>AB = CB</strong>, 但是 <strong>A</strong> 不等于 <strong>C</strong>。这也就是为什么，在矩阵方程式中，<strong>我们一般不能约掉左右两边共同的矩阵</strong>。但是有两个例外情况：</p>
<ol>
<li><strong>B</strong>是一个满秩的方阵，那么此时<strong>AB=CB</strong>，就意味着<strong>A=C</strong>。</li>
<li>如果对于任何的<strong>B</strong>矩阵都存在<strong>AB=CB</strong>，那么<strong>A=C</strong>。</li>
</ol>
<p>可以给出一个例子。比如<strong>B</strong>是一个2×2的元素均为1的矩阵。A也是一个2×2的矩阵，那么<strong>AB</strong>的第一行元素为a11+a12，第二行元素为a21+a22。对于特定的<strong>AB</strong>，只要保证<strong>A</strong>每行的和相同即可，也就是可以构建出无数的<strong>A</strong>阵。</p>
<p>对于矩阵乘积，秩满足如下条件</p>
<ul>
<li>如果A 和 B <strong>are confromal for multiplication</strong>, 那么 rank(AB) &lt;= rank(A) ;rank(AB) &lt;= ran(B)</li>
<li>左乘或右乘一个满秩的矩阵，不会改变秩的大小。假如 B 和 C 是满秩的方阵，那么 rank(AB) = rank(CA) = rank(A)</li>
<li>对于任何一个矩阵，rank(<strong>A’A</strong>) = rank(<strong>AA’</strong>) = rank(<strong>A’</strong>) = rank(<strong>A</strong>)</li>
</ul>
<h3 id="逆矩阵">逆矩阵</h3>
<p>我们一般把一个满秩的<strong>方</strong>阵叫做非奇异阵（nonsigular），而非奇异阵有一个唯一的逆矩阵。把不满秩的矩阵叫做奇异阵（sigular），奇异阵没有逆矩阵（rectangular matrices 都没有逆矩阵）。<br>
如果<strong>B</strong>是一个非奇异阵，<strong>AB = CB</strong>，那么左右两边都可以乘以<strong>B^-^</strong>，那么就得到了<strong>A=C</strong>。（但是如果B不满秩，或者是rectangular，那么就不能这么做）。</p>
<p>类似的，如果<strong>A</strong>是一个非奇异阵，那么<strong>Ax=c</strong>的求解，等于左右两边均左乘A-1，得到<strong>x=A-1c</strong></p>
<p>逆矩阵性质：</p>
<ol>
<li>如果A为<strong>非奇异阵</strong>，那么**A’**也是一个非奇异阵，并且其逆阵满足：<br>
(A)^-1^ = (A^-1^)’</li>
<li>如果A和B均为非奇异阵且大小相同（方阵能相乘肯定大小相同），那么<strong>AB</strong>也是一个非奇异阵，并且<br>
**(AB)^-1^ = B^-1^A^-1^</li>
</ol>
<p>特殊例子</p>
<p><img src="inverse_special1.png" alt="inverse_special1"></p>
<h3 id="正定矩阵">正定矩阵</h3>
<p>二次型都可以写成<strong>y’Ay</strong>的格式。如下例子，其中的<strong>A</strong>阵其实不唯一，但是如果将<strong>A</strong>表达为对称阵，那么此时A阵是唯一的。</p>
<p><img src="positive_definite1.png" alt=""></p>
<p>如果<strong>A阵</strong>具有这种性质：无论<strong>y</strong>向量是什么（0向量除外），<strong>y’Ay</strong> 均大于0，那么我们说二次型<strong>y’Ay</strong>是正定的（positive definite），<strong>A</strong>是正定矩阵。如果对于所有的<strong>y</strong>，均大于等于0，我们说<strong>A</strong>阵是半正定的（positive semidefinite）</p>
<p>举例</p>
<p><img src="positive_definite2.png" alt=""></p>
<p>性质：</p>
<ol>
<li>正定矩阵的对角线都是正数。</li>
<li>半正定矩阵的对角线元素大于等于0</li>
</ol>
<p>证明：</p>
<ol>
<li>如果存在一个<strong>y’</strong> = (0,……0,1,0,……0)，第i个位置为1，其它为0。那么<strong>y’Ay</strong> = aii &gt; 0</li>
<li>半正定矩阵同理</li>
</ol>
<p>如果<strong>P</strong>是一个非奇异阵：</p>
<ol>
<li>如果<strong>A</strong>是一个正定矩阵，那么<strong>P’AP</strong>也是正定的</li>
<li>如果<strong>A</strong>是一个半正定矩阵，那么<strong>P’AP</strong>也是半正定的</li>
</ol>
<p>证明</p>
<p><img src="positive_definite3.png" alt=""></p>
<p>变种：</p>
<p><img src="positive_definite4.png" alt=""></p>
<p>对于一个<strong>对称矩阵A</strong>，当且仅当存在一个非奇异阵<strong>P</strong>使得 <strong>A=P’P</strong>时，<strong>A</strong>才为正定矩阵。（反过来说，对于一个对称正定矩阵<strong>A</strong>，都可以分解为<strong>A=P’P</strong>）</p>
<p><strong>一个正定矩阵必定是非奇异阵</strong><br>
证明：根据 Cholesky 分解，可以将一个正定矩阵A分解，<strong>A=TT‘</strong>，其中T是一个<strong>非奇异</strong>的下三角矩阵（根据前面的公式，rank(T’T)=rank(T）)</p>
<p>对于任意一个矩阵<strong>B</strong>（square or rectangular）,矩阵<strong>B’B</strong>是<strong>正定</strong> 或 <strong>半正定</strong> 的。</p>
<p>如果<strong>B</strong>是一个 n × p 的矩阵。</p>
<ul>
<li>如果 rank(B) = p， 那么<strong>B’B</strong>是正定的</li>
<li>如果 rank(B) &lt; p， 那么<strong>B’B</strong>是半正定的</li>
</ul>
<p>如果A是正定的，那么其逆矩阵也是正定的。</p>
<h3 id="systems-of-equations">systems of equations</h3>
<p>假设有n个不等式，其中有p个未知量。</p>
<p><img src="equations1.png" alt=""></p>
<p>也可以用矩阵的形式，写为 <strong>Ax = c</strong></p>
<p>如果 n = p 并且A为非奇异阵，那么存在唯一解：x = A-1c 。 如果 n &gt; p， 此方程组无解；如果n &lt; p，此方程组有无穷多解。</p>
<p>如果the system of equations <strong>Ax = c</strong> 存在一个或多个解，那么我们称之为 <em>consistent</em>；否则，我们称之为 <em>inconsistent</em></p>
<p>为了说明consistent system of equations 的结构，我们假设 <strong>A</strong> 是一个 p × p ，秩为 r &lt; p 的矩阵。那么 A 阵的行之间存在线性相关，也就是存在<strong>b</strong>向量，使得</p>
<p><img src="equations2.png" alt=""></p>
<p>因此我们必须使得<strong>b’c</strong>也等于0，不然就无解。也就是说，为了使<strong>Ax = c</strong> 是 consistent，那么<strong>A</strong>中行之间存在的线性关系必须在<strong>c</strong>的相应元素之间也体现出来（比如说，A的其中一行是另一行的两倍，那么<strong>c</strong>中相应元素必须也是两倍）。具体来说就是 rank(<strong>A</strong>) = rank(<strong>(A,c)</strong>) (就是把c作为一列附在A的后面)</p>
<p><strong>定理</strong>：如果<strong>Ax = c</strong>当且仅当rank(<strong>A</strong>) = rank(<strong>(A,c)</strong>)时，才存在至少一个解向量。</p>
<p>举例：</p>
<p><img src="equations3.png" alt=""></p>
<p>这个例子中，很明显第三个式子时多余的。根据前两个式子就能求解。且只有唯一解。</p>
<p>但是，如果第三个式子中的3改为2，那么此时（A，c) 的秩为3，rank(A) 为2，这个方程式无解。</p>
<p>又一个例子</p>
<p><img src="equations4.png" alt=""></p>
<p>其中，第三个式子为前两个式子的和。rank(<strong>A</strong>) = rank(<strong>(A,c)</strong>)=2，有无穷多个解</p>
<p><img src="equations5.png" alt=""></p>
<p>其中 x3 可以取任意值，x1 x2 随 x3的值而定。</p>
<h3 id="广义逆">广义逆</h3>
<p>对于不能求逆的矩阵，我们可以求其广义逆。比如 对于<strong>Ax = c</strong>求解时，其中的一个解可以通过求A的广义逆得到。</p>
<h4 id="广义逆的定义和特性">广义逆的定义和特性</h4>
<p>对于一个 n × p 的矩阵 <strong>A</strong>， 其广义逆满足如下条件</p>
<blockquote>
<p>AA^-^A = A</p>
</blockquote>
<p>广义逆不唯一，除非A是非奇异阵，在这种情况下，A^-^ = A^-1^ 。</p>
<blockquote>
<p>A generalized inverse is also called aconditional inverse</p>
</blockquote>
<p>任何一个矩阵（square or rectangular），都有广义逆。即便是向量，都有广义逆。</p>
<p><strong>定理</strong>：如果 A是  n × p ；那么其广义逆A-均为  p × n</p>
<p><strong>定理</strong>：如果A是  n × p ，其秩为r ，并且A 可以划分为以下子矩阵。其中 A11 是 r × r 的满秩矩阵。那么其逆矩阵如下。</p>
<p><img src="generized_inverse1.png" alt=""></p>
<p>后面的证明我都看懂了，不过确实是拐着弯地证明了。</p>
<p><strong>引申</strong>：同上，A22也成立。<br>
进一步引申如下，对任何一个矩阵求广义逆均可按照以下5步</p>
<ol>
<li>找到一个非奇异的r × r 子矩阵 C。（甚至C中的行或列不用是在A毗邻的）</li>
<li>计算出 <strong>C^-1^</strong> 和**（C^-1^）'**</li>
<li>将<strong>C</strong>中的元素替代为**（C^-1^）'**中的元素</li>
<li>将<strong>A</strong>中的其它元素全部替换为0</li>
<li>转置上一步的结果矩阵</li>
</ol>
<p><strong>定理</strong> 如果A是  n × p ，其秩为r ，它的一个广义逆为A-</p>
<ol>
<li>rank(A^-^A) = rank(AA^-^) = rank(A) = r</li>
<li>(A^-^)’ 是 A‘ 的一个广义逆；即（A’)^-^ = (A^-^)’</li>
</ol>
<p>直接上图吧，太复杂</p>
<p><img src="generized_inverse2.png" alt=""></p>
<p>一个对称矩阵的广义逆不一定是对称的。但是，一个对称矩阵一定能找到对称的广义逆。这本书中，我们假定对称矩阵的广义逆都是对称的。</p>
<p>注：自己查了一下，对称的非奇异阵的逆矩阵也是对称的<br>
证明如下<br>
(A^-1^)’ = (A’)^-1^ = (A)^-1^ = A^-1^</p>
<h4 id="广义逆与方程组求解">广义逆与方程组求解</h4>
<p>如果 <strong>Ax = c</strong> 是 <em>consistent</em>， 而且 A^-^ 是 A 的一个广义逆，那么，<strong>x = A^-^c</strong> 就是方程组的一个解。<br>
证明如下：</p>
<p><img src="generized_inverse3.png" alt=""></p>
<p>采用不同的广义逆，结果有所不同。</p>
<h3 id="行列式（determinant）">行列式（determinant）</h3>
<ul>
<li>奇异矩阵行列式为0；非奇异阵行列式不为0</li>
<li>如果A是正定矩阵，|A| &gt; 0</li>
</ul>
<p>后面没看，就目前看的书，没怎么用到行列式</p>
<h2 id="Random-Vectors-and-Matrices">Random Vectors and Matrices</h2>
<h3 id="introduction">introduction</h3>
<p>当我们使用线性模型时，把数据的观测值以随机向量或随机矩阵的形式表示，是一种很方便的方法。随机向量或随机矩阵指的是其中的元素都是随机变量。</p>
<p>通常来说，我们有两种形式的随机变量：</p>
<ol>
<li>对 n 个不同的个体或实验单位进行相同的测量方法得到的测量值。这里有两个条件，个体的选择是随机的；测量方法或观测方法是一致的。就比如表型观测值就是典型的彼此不相关而且有着相同的方差。</li>
<li>一个个体的 p 的不同的测量值。那么这个随机变量彼此之间是相关的，而且有者不同的方差。</li>
</ol>
<h3 id="均值、方差、协方差和相关">均值、方差、协方差和相关</h3>
<p>在这一章节中，我们会回顾单变量和双变量随机变量的性质。我们以单随机变量y为例。这里我们一般不区分随机变量y 和  y的观测值 。在很多书中，大写字母表示随机变量，而相应的小写字母表示的是一个随机变量的实现（a realization of the random variable），就像表达式 P(Y &lt; y)。这样的写法在单变量中很实用。但是，因为在这里，我们用大写字母表示矩阵，小写字母表示向量，这就会产生冲突。</p>
<p>如果 f(y) 是 随机变量 y 的概率密度曲线，y 的 期望值如下</p>
<p><img src="random_vector1.png" alt=""></p>
<p>不截图看书吧，就是推导总体的均值，方差，等等公式。</p>
<p>对于双随机变量的联合概率密度分布。如果联合概率密度等于两个边缘密度分布的乘积，那么这两个随机变量就是不想关的（independent）</p>
<p><img src="random_vector2.png" alt=""></p>
<p>但是上面3.15的式子反过来不对，也就是说 σij = 0 并不意味着两个变量之间是独立的。</p>
<p>后面涉及条件概率密度的积分，看不懂，得拿本高数来看了。</p>
<p>具体推导用铅笔在书上写了。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>notpad++学习笔记</title>
    <url>/posts/897384da/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>notpad++是一款功能强大的文本编辑器。我一开始用的就是这个软件，感觉基本能满足我的所有需求。</p>
<h1>快捷键</h1>
<h2 id="常规快捷键">常规快捷键</h2>
<ul>
<li>ctrl + Z  &amp; ctrl + Y ** 撤销与恢复**</li>
<li>ctrl + F  &amp; ctrl + H <strong>查找与替换</strong></li>
<li>ctrl + D 复制并黏贴当行（光标所在行）</li>
<li>ctrl + D 复制并快速黏贴多行（光标选中多行）</li>
<li>ctrl + L 删除当前行</li>
<li>shift + tab 删除缩进</li>
<li>ctrl + G <strong>快速跳到某一行</strong></li>
<li>ctrl + tab 多个文件中切换（与谷歌一致）</li>
</ul>
<h2 id="文件操作快捷键">文件操作快捷键</h2>
<ul>
<li>ctrl + S 保存当前文档</li>
<li>ctrl + alt + S 另存为</li>
<li>ctrl + shift + S <strong>保存所有文件</strong></li>
<li>ctrl + w 关闭当前</li>
<li>ctrl + p 打印（转为pdf）</li>
</ul>
<h2 id="文本编辑">文本编辑</h2>
<ul>
<li>Alt + C <strong>列编辑</strong>模式（在某一列插入相同的文字或数字）</li>
<li>ctrl + k <strong>注释</strong>（可选中多行，而且notpad++会根据文件类型添加相符合的注释符号）</li>
<li>ctrl + shift + k 取消注释</li>
</ul>
<h2 id="其他快捷键">其他快捷键</h2>
<ul>
<li><strong>块匹配</strong>：选择一个括号，按ctrl+b会跳转到与它对应的另外一半括号处。</li>
</ul>
<h1>其他功能</h1>
<h2 id="颜色标记">颜色标记</h2>
<p>就是给内容用不同的颜色做标记，用法就是选择要标记的文本然后点击右键-&gt;Style token，选择一个标记即可。也可以通过点击右键选择删除颜色标记Remove style。</p>
<h2 id="将tab转换成空格">将tab转换成空格</h2>
<blockquote>
<p>编程中一般都不允许使用Tab键作为缩进而是使用空格，但是Tab键确实方便。<br>
在首选项-&gt;语 言页面可以选择“以空格代替Tab”，同时可以配置一个Tab键替换成几个空格。</p>
</blockquote>
<h2 id="显示符号">显示符号</h2>
<p>在视图-显示符号中，可以显示空格、制表键、换行等。空格显示为**.<strong>，制表键显示为向右的箭头。linux格式的换行符显示为LF，windows格式的换行符显示为</strong>CRLF**。</p>
<h2 id="备份">备份</h2>
<p>这个比较实用。在设置-首选项-备份-备份与自动完成，选择<strong>简单备份</strong>。这样notpad++在编辑一个文件，会默认生成一个同名的<strong>bak</strong>文件。</p>
<h2 id="插件">插件</h2>
<p>notpad++有很多相应的插件，比如一款TextFX的插件，可以删除文件中的空行、插入行号或删除行号等。</p>
<h1>tips</h1>
<ul>
<li>notpad++通过后缀名判断文件类型，并实现<strong>代码高亮</strong>。如果文件无后缀，那么也无法实现自动代码高亮。可通过设置<strong>语言</strong>选项，实现未知类型文件的语法高亮。</li>
<li>通过<strong>格式</strong>选项，可查看和转换当前文件字符编码。</li>
<li>在其他地方修改文件后，notpad++会自动更新文件，并通知<strong>此文件已被其他程序修改了，是否重新加载</strong>。在首选项-其他中，勾选<strong>自动更新文件</strong>，关闭该通知。</li>
</ul>
<h1>参考网页</h1>
<p><a href="http://shouce.jb51.net/notepad_book/">http://shouce.jb51.net/notepad_book/</a><br>
<a href="https://blog.51cto.com/caochun/1530273">https://blog.51cto.com/caochun/1530273</a></p>
]]></content>
      <tags>
        <tag>软件学习</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy学习笔记</title>
    <url>/posts/40de7965/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>numpy 是python的一个包，是处理数组的工具。</p>
<span id="more"></span>
<h1>数组基础</h1>
<p>在numpy中采用array属性创建数组，里面可以传递任何序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">b = np.array((<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">c = np.arange(<span class="number">5</span>)</span><br><span class="line">d = np.linspace(<span class="number">0</span>, <span class="number">2</span>*np.pi, <span class="number">5</span>) <span class="comment"># [0.         1.57079633 3.14159265 4.71238898 6.28318531]</span></span><br><span class="line"><span class="comment"># linspace 表示从开始值到结束值，均匀地创造n个值（包括两端）。</span></span><br><span class="line"><span class="comment"># np.pi 为Π值。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a) </span><br><span class="line"><span class="built_in">print</span>(b) </span><br><span class="line"><span class="built_in">print</span>(c) </span><br><span class="line"><span class="built_in">print</span>(d) </span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">3</span>]) </span><br></pre></td></tr></table></figure>
<ul>
<li>shape 函数查看数组结构（2，3）表示2行3列。</li>
</ul>
<p>其他创建数组的函数：</p>
<ul>
<li>a = np.zeros((2,2))  # 2×2 的 全为0 的矩阵</li>
<li>a = np.ones((1,2))  # 全为1 的矩阵</li>
<li>a = np.full((2,2),7)  # 全为7 的矩阵</li>
<li>a = np.eye(2)    # 2×2 的单位阵</li>
<li>e = np.random.random((2,2))  # 0到1之间的随机元素</li>
</ul>
<h2 id="创建矩阵">创建矩阵</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">              [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span> ,<span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">              [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>,<span class="number">4</span>]) <span class="comment">#索引都是从0开始 </span></span><br></pre></td></tr></table></figure>
<h2 id="数组索引">数组索引</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, <span class="number">1</span>:<span class="number">4</span>]) </span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>:<span class="number">4</span>, <span class="number">0</span>]) </span><br><span class="line"><span class="built_in">print</span>(a[::<span class="number">2</span>,::<span class="number">2</span>]) <span class="comment">#行和列每隔一个qu                  </span></span><br><span class="line"><span class="built_in">print</span>(a[:, <span class="number">1</span>]) </span><br></pre></td></tr></table></figure>
<h2 id="数组属性">数组属性</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">              [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span> ,<span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">              [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a)) <span class="comment"># &gt;&gt;&gt;&lt;class &#x27;numpy.ndarray&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(a.dtype) <span class="comment"># &gt;&gt;&gt;int64</span></span><br><span class="line"><span class="built_in">print</span>(a.size) <span class="comment"># &gt;&gt;&gt;25 总共元素个数</span></span><br><span class="line"><span class="built_in">print</span>(a.shape) <span class="comment"># &gt;&gt;&gt;(5, 5)</span></span><br><span class="line"><span class="built_in">print</span>(a.itemsize) <span class="comment"># &gt;&gt;&gt;8 每个元素的字节数 int64就是8字节</span></span><br><span class="line"><span class="built_in">print</span>(a.ndim) <span class="comment"># &gt;&gt;&gt;2 维度</span></span><br><span class="line"><span class="built_in">print</span>(a.nbytes) <span class="comment"># &gt;&gt;&gt;200 总字节数 25*8=200</span></span><br></pre></td></tr></table></figure>
<h2 id="切片">切片</h2>
<p>np.array 里，如果是矩阵，那么每一个子元素是<strong>一行</strong>。也就是，默认按行排布。切边时也一样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line">b = a[:<span class="number">2</span>,<span class="number">1</span>:<span class="number">3</span>]  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">b[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">77</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>这里，还可以将整数索引和切片索引混合使用。但是这样做，会造成<strong>降维打击</strong>（由矩阵变为向量）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line">row_r1 = a[<span class="number">1</span>,:]</span><br><span class="line">row_r2 = a[<span class="number">1</span>:<span class="number">2</span>,:] <span class="comment">#这样写就不会降维，还是矩阵</span></span><br><span class="line"><span class="built_in">print</span>(row_r1,row_r1.shape) <span class="comment"># （4，）</span></span><br><span class="line"><span class="built_in">print</span>(row_r2,row_r2.shape) <span class="comment"># （1，4）</span></span><br></pre></td></tr></table></figure>
<h3 id="整数数组索引">整数数组索引</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])  <span class="comment">#上下结果相同，就是不同写法。a[[0,1,2],[0,1,0]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.array([a[<span class="number">0</span>, <span class="number">0</span>], a[<span class="number">1</span>, <span class="number">1</span>], a[<span class="number">2</span>, <span class="number">0</span>]]))  </span><br></pre></td></tr></table></figure>
<h3 id="花式索引">花式索引</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>)</span><br><span class="line">indices = [<span class="number">1</span>, <span class="number">5</span>, -<span class="number">1</span>]</span><br><span class="line">b = a[indices]</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &gt;&gt;&gt;[ 0 10 20 30 40 50 60 70 80 90]</span></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># &gt;&gt;&gt;[10 50 90]</span></span><br></pre></td></tr></table></figure>
<h3 id="布尔数组索引">布尔数组索引</h3>
<p>选择满足某些条件的数组元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">bool_idx = (a&gt;<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(bool_idx)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a[bool_idx])</span><br><span class="line"><span class="built_in">print</span>(a[a &gt; <span class="number">2</span>]) <span class="comment"># 结果为向量[3 4 5 6],挑出大于2的元素</span></span><br></pre></td></tr></table></figure>
<h3 id="数据类型">数据类型</h3>
<p>Numpy在创建数组时会猜测数据类型，当也有一个可选参数指定数据类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(x.dtype)</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1.0</span>,<span class="number">2.0</span>])</span><br><span class="line"><span class="built_in">print</span>(x.dtype)</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>],dtype=np.int64)</span><br><span class="line"><span class="built_in">print</span>(x.dtype)</span><br></pre></td></tr></table></figure>
<h3 id="数组中的数学">数组中的数学</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]], dtype=np.float64)</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]], dtype=np.float64)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x + y)</span><br><span class="line"><span class="built_in">print</span>(np.add(x, y))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x - y)</span><br><span class="line"><span class="built_in">print</span>(np.subtract(x, y))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x * y)    <span class="comment">#这里的乘除都不是矩阵点乘，而是元素乘法。也就是第一个元素乘第一个元素。</span></span><br><span class="line"><span class="built_in">print</span>(np.multiply(x, y))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x / y) </span><br><span class="line"><span class="built_in">print</span>(np.divide(x, y))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.sqrt(x))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a ** <span class="number">2</span>) <span class="comment"># a中的每个元素都进行开方</span></span><br></pre></td></tr></table></figure>
<p>点积 dot函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">v = np.array([<span class="number">9</span>,<span class="number">10</span>])</span><br><span class="line">w = np.array([<span class="number">11</span>, <span class="number">12</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(v.dot(w))  <span class="comment">#dot函数向量与向量为点积，为a1b1+a2b2+……</span></span><br><span class="line"><span class="built_in">print</span>(np.dot(v, w))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x.dot(v))  <span class="comment"># dot函数向量与矩阵，不太清楚</span></span><br><span class="line"><span class="built_in">print</span>(np.dot(x, v))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x.dot(y))  <span class="comment"># 矩阵与矩阵，就是正常的矩阵乘法</span></span><br><span class="line"><span class="built_in">print</span>(np.dot(x, y))</span><br></pre></td></tr></table></figure>
<h3 id="SUM函数">SUM函数</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(x))  <span class="comment">#所有元素的和</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(x, axis=<span class="number">0</span>))  <span class="comment">#axis=0 是每一列的和</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(x, axis=<span class="number">1</span>))  </span><br><span class="line"><span class="comment"># min() max()找到最小，最大的元素</span></span><br></pre></td></tr></table></figure>
<h3 id="转置矩阵，T属性">转置矩阵，T属性</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"><span class="built_in">print</span>(x)    </span><br><span class="line">            </span><br><span class="line"><span class="built_in">print</span>(x.T)  </span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(v)    </span><br><span class="line"><span class="built_in">print</span>(v.T)  <span class="comment">#向量没有转置属性</span></span><br></pre></td></tr></table></figure>
<h3 id="广播">广播</h3>
<p>如果我们要向矩阵的每一行添加一个常数向量。我们可以这样做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">y = np.empty_like(x)  <span class="comment"># 建立一个和x维度相同的空矩阵。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    y[i, :] = x[i, :] + v</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure>
<p>这会奏效；但是当矩阵x非常大时，循环会很慢。注意，向矩阵x的每一行添加向量v等同于通过垂直堆叠多个v副本来形成矩阵vv，然后执行元素的求和 x 和 vv。代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">vv = np.tile(v, (<span class="number">4</span>, <span class="number">1</span>))  </span><br><span class="line"><span class="comment"># tile函数复制数组，第一个数字好像是列，第二个是行，就是在y轴方向复制4遍。</span></span><br><span class="line"><span class="built_in">print</span>(vv)                 </span><br><span class="line">                                                                              </span><br><span class="line">y = x + vv  </span><br><span class="line"><span class="built_in">print</span>(y)  </span><br></pre></td></tr></table></figure>
<p>Numpy 广播允许我们在不实际创建 v 的多个副本的情况下执行此计算（这和R是类似的）。代码如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">y = x + v  </span><br><span class="line"><span class="built_in">print</span>(y)  </span><br></pre></td></tr></table></figure>
<p>广播的规则（从网上找的人话），需满足</p>
<ul>
<li>当前维度的值相等</li>
<li>当前维度的值有一个是1</li>
<li>最终的shape是输入数组shape各个轴上的最大值。<br>
下例中 3×1 * 1×2。3×1 会复制成 3×2，1×2 也会复制成 3×2，再进行元素相乘。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">v = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])  </span><br><span class="line">w = np.array([<span class="number">4</span>,<span class="number">5</span>])    </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.reshape(v, (<span class="number">3</span>, <span class="number">1</span>)) * w) <span class="comment">#举例</span></span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x + v)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>((x.T + w).T)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x + np.reshape(w, (<span class="number">2</span>, <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x * <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h2 id="创建Numpy-数组的不同方式">创建Numpy 数组的不同方式</h2>
<p>创建Numpy数组有三种不同的方法：</p>
<ol>
<li>使用Numpy内部功能函数</li>
<li>从列表等其它序列进行转换</li>
<li>使用特殊的库函数</li>
</ol>
<h3 id="使用Numpy-内部功能函数">使用Numpy 内部功能函数</h3>
<h4 id="创建一维数组">创建一维数组</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Numpy <span class="keyword">as</span> np</span><br><span class="line">array = np.arange(<span class="number">20</span>) <span class="comment"># 创建一个从0到19的一维数组</span></span><br><span class="line">array</span><br></pre></td></tr></table></figure>
<p>与python列表不同，Numpy数组的内容是同质的。如果将字符串分配给数据类型为int的元素，则会报错。</p>
<h4 id="创建一个二维数组">创建一个二维数组</h4>
<p>先创建一个一维数组，再使用reshape 函数使其称为二维数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array = np.arange(<span class="number">20</span>).reshape(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">array</span><br></pre></td></tr></table></figure>
<h4 id="其他函数">其他函数</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.zeros((<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line">np.ones((<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line">np.empty((<span class="number">2</span>,<span class="number">4</span>)) <span class="comment"># 随机内容</span></span><br><span class="line">np.full((<span class="number">2</span>,<span class="number">4</span>),<span class="number">3</span>) <span class="comment"># 全为3</span></span><br><span class="line">np.eye(<span class="number">3</span>,<span class="number">3</span>) <span class="comment"># 创建一个3×3的单位阵</span></span><br><span class="line">np.linspace(<span class="number">0</span>,<span class="number">10</span>,<span class="number">4</span>) <span class="comment"># array([ 0., 3.33333333, 6.66666667, 10.])</span></span><br></pre></td></tr></table></figure>
<h3 id="从python列表转换">从python列表转换</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">array = np.array(<span class="built_in">list</span>)</span><br><span class="line">array</span><br></pre></td></tr></table></figure>
<h3 id="使用特殊的库函数">使用特殊的库函数</h3>
<p>使用random函数，创建一个填充0到1之间随机数的数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.random((<span class="number">2</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<h2 id="Numpy-中的矩阵和向量">Numpy 中的矩阵和向量</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = np.array([[<span class="number">1</span>,-<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>]]) <span class="comment"># 创建矩阵</span></span><br><span class="line">v = np.array([[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>]]) </span><br><span class="line"><span class="comment"># 列向量 v = np.transpose(np.array([[1，2,3]]))</span></span><br><span class="line"><span class="comment"># 注意这里是两个方括号</span></span><br></pre></td></tr></table></figure>
<h3 id="用numpy-求解方程组">用numpy 求解方程组</h3>
<p>求解向量x。方程组如下图所示<br>
<img src="equations1.png" alt=""><br>
首先构建A和b的数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = np.array([[<span class="number">2</span>,<span class="number">1</span>,-<span class="number">2</span>],[<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>]]) </span><br><span class="line">b = np.transpose(np.array([[-<span class="number">3</span>,<span class="number">5</span>,-<span class="number">2</span>]])) </span><br></pre></td></tr></table></figure>
<p>为了解决这个系统</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.linalg.solve(A,b)</span><br></pre></td></tr></table></figure>
<h2 id="应用：多元线性回归">应用：多元线性回归</h2>
<p><img src="equations2.png" alt=""><br>
求解python代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.chdir(<span class="string">&#x27;D:\\Desktop\\markdown\\numpy学习笔记&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readData</span>():</span></span><br><span class="line">    X = []</span><br><span class="line">    y = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;Housing.csv&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        rdr = csv.reader(f)</span><br><span class="line">        <span class="comment"># Skip the header row</span></span><br><span class="line">        <span class="built_in">next</span>(rdr) </span><br><span class="line">        <span class="comment"># Read X and y</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> rdr: <span class="comment"># line的格式为[&#x27;1&#x27;,&#x27;2&#x27;……]</span></span><br><span class="line">            xline = [<span class="number">1.0</span>] <span class="comment"># 这个是总平均数的系数1</span></span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> line[:-<span class="number">1</span>]:</span><br><span class="line">                xline.append(<span class="built_in">float</span>(s))</span><br><span class="line">            X.append(xline) <span class="comment"># X是除了最后一列表型外的所有列</span></span><br><span class="line">            y.append(<span class="built_in">float</span>(line[-<span class="number">1</span>])) <span class="comment"># y 是表型</span></span><br><span class="line">    <span class="keyword">return</span> (X,y)</span><br><span class="line"></span><br><span class="line">X0,y0 = readData()</span><br><span class="line"><span class="comment"># Convert all but the last 10 rows of the raw data to numpy arrays</span></span><br><span class="line">d = <span class="built_in">len</span>(X0)-<span class="number">10</span></span><br><span class="line">X = np.array(X0[:d])</span><br><span class="line">y = np.transpose(np.array([y0[:d]]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute beta</span></span><br><span class="line">Xt = np.transpose(X)</span><br><span class="line">XtX = np.dot(Xt,X)</span><br><span class="line">Xty = np.dot(Xt,y)</span><br><span class="line">beta = np.linalg.solve(XtX,Xty)</span><br><span class="line"><span class="built_in">print</span>(beta)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make predictions for the last 10 rows in the data set</span></span><br><span class="line"><span class="keyword">for</span> data,actual <span class="keyword">in</span> <span class="built_in">zip</span>(X0[d:],y0[d:]):</span><br><span class="line">    x = np.array([data])</span><br><span class="line">    prediction = np.dot(x,beta)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;prediction = &#x27;</span>+<span class="built_in">str</span>(prediction[<span class="number">0</span>,<span class="number">0</span>])+<span class="string">&#x27; actual = &#x27;</span>+<span class="built_in">str</span>(actual))</span><br></pre></td></tr></table></figure>
<h3 id="通过where函数替换满足条件的元素">通过where函数替换满足条件的元素</h3>
<p>问题：将0-9的一维数组中的所有奇数替换成-1，而不改变原数组（即创建新数组）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">out = np.where(arr % <span class="number">2</span> == <span class="number">1</span>, -<span class="number">1</span> ,arr) <span class="comment"># 奇数，则替换为-1，否则保持原值不变。</span></span><br></pre></td></tr></table></figure>
<h3 id="通过reshape函数将一维数组转化为二维">通过reshape函数将一维数组转化为二维</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">arr.reshape(<span class="number">2</span>,-<span class="number">1</span>) <span class="comment"># 设置为-1,表示让程序自动决定列的数目</span></span><br></pre></td></tr></table></figure>
<h3 id="如何水平或垂直叠加两个数组？">如何水平或垂直叠加两个数组？</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">10</span>).reshape(<span class="number">2</span>,-<span class="number">1</span>)</span><br><span class="line">b = np.repeat(<span class="number">1</span>, <span class="number">10</span>).reshape(<span class="number">2</span>,-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Answers</span></span><br><span class="line"><span class="comment"># Method 1:</span></span><br><span class="line">np.concatenate([a, b], axis=<span class="number">1</span>) </span><br><span class="line"><span class="comment">#通过调整axis=0或1，确定叠加方式</span></span><br></pre></td></tr></table></figure>
<h3 id="如何交换数组中的两列？">如何交换数组中的两列？</h3>
<p>问题：在数组arr中交换列1和2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">arr</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution</span></span><br><span class="line">arr[:, [<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>]] <span class="comment">#这样就能实现第一列和第二列的互换。</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>word排版学习笔记</title>
    <url>/posts/821c2099/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前用word里包含十几个表，排版简直要吐血！而且更变态的是，不知道为什么，你调整其中的一个表，其他的表的格式却莫名其妙地乱了（一脸懵逼）。更让我难以接受的是，有的时候word报错其中一个表格已损坏，然后如果你没有备份的话，就一夜回到解放前。<br>
以上种种，让我已经坚定了要抛弃word的想法，用latex和markdown替代它。不过最近还是在B站看到了word排版的学习视频，那还是学一下吧！<br>
本文学习视频来自于<a href="https://www.bilibili.com/video/av64031582">word论文排版技巧</a></p>
<h1>快速设置三线表</h1>
<p>在一个表格内选择，在表格工具设计工具栏新建<strong>样式</strong>。修改样式名称，在格式应用于<strong>整个表格</strong>，修改右下角<strong>格式</strong>的边框属性、字体、<strong>边框和底纹</strong>（上下框线）。之后，将格式应用于<strong>标题行</strong>，修改<strong>格式</strong>的边框和底纹（下框线，上框线需要重新设置）。</p>
<ul>
<li>使用时，选中表格，点击该样式</li>
<li>右击该样式，可将该设置为默认，<strong>实用</strong>（这样把表格复制过来就是三线表）。</li>
<li>还需要手动调节表格工具-布局-对齐方式（<strong>文字居中</strong>），或<strong>自动调整</strong><br>
<img src="yangshi.png" alt=""></li>
</ul>
<h1>样式的概念</h1>
<blockquote>
<p>开始工具栏中右键<strong>样式</strong>-修改，可修改所有应用该样式的文本。<br>
另一种快捷方式是，修改某一个应用该样式的文本，右击样式，更新 ** 以匹配所选内容</p>
</blockquote>
<h1>标题的自动编号</h1>
<p>自动编号的好处是如果后面需要增删章节，不用手动修改。</p>
<ul>
<li>先写好文章标题和内容，标题不要写前缀，第一章或1.1什么的。点击段落中的多级列表（默认为1级，可点击<strong>更改列表级别</strong>）。然后右击样式，更新 ** 以匹配所选内容</li>
<li>修改编号：点击<strong>定义新的多级列表</strong> ，可以在输入编号的格式中添加文字，此级别的编号样式可以选择简体中文。<br>
<img src="many_list.png" alt=""></li>
</ul>
<h1>正文样式</h1>
<p>直接修改正文样式可能会导致标题等样式的改变，右击标题样式-修改，发现样式基础是正文。<br>
作者给出的解决方法是新建一个样式，命名为<strong>0_正文</strong>，将所有的正文在这里进行修改。</p>
<ul>
<li>行距最好使用倍数，而尽量不用多少磅，不然图片显示可能出问题。</li>
</ul>
<h1>图名、表明的设置与引用 7P</h1>
<p>比较复杂，放弃写了。打算自己以后直接看视频，这还比较简单。见谅。</p>
<h1>分页符与分节符 8P</h1>
<p>分页符，固定分页，比如下一章<br>
分节符，使不同节的<strong>页眉</strong>可以不一致。</p>
<h1>目录 9P</h1>
<h1>页眉与页脚的设置 10P</h1>
<h1>公式的编号与引用</h1>
<p>mathtype 插件</p>
<h1>参考文献-NE</h1>
<ul>
<li>插入多篇文献：在NE中使用shift或ctrl选中多篇文献</li>
<li>修改后更新编号：点击格式化</li>
<li>清除域代码前备份一份。<strong>必须保留一份含有域代码的文件</strong>，清除域代码的文件仅作为上交材料。</li>
</ul>
]]></content>
      <tags>
        <tag>软件学习</tag>
      </tags>
  </entry>
  <entry>
    <title>win10快捷键</title>
    <url>/posts/26dc69f9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="虚拟桌面">虚拟桌面</h2>
<p>win + ctrl+ D：** 创建虚拟桌面**<br>
win + ctrl + 左右箭头：** 切换虚拟桌面**<br>
win + ctrl + F4: <strong>关闭当前虚拟桌面</strong></p>
<h2 id="应用管理">应用管理</h2>
<p>win + M: <strong>最小化所有应用</strong><br>
ctrl + alt + tab(或win + tab) : <strong>显示所有打开应用</strong><br>
win + 1-9: 快速打开应用</p>
<h2 id="当电脑卡死时">当电脑卡死时</h2>
<p>ctrl + shift + esc: <strong>打开任务管理器</strong>（关闭卡死的程序，<strong>实用</strong>）<br>
ctrl + alt + delete: windows救命三键<br>
win + R后输入[ shutdown -r ]重启 或 [ shutdown -s ] 关机</p>
<h2 id="打开文件夹">打开文件夹</h2>
<p>win + E: 资源管理器</p>
<p>shift + delete : 永久删除文件</p>
<h2 id="锁屏">锁屏</h2>
<p>win + l</p>
<h2 id="查看剪贴板">查看剪贴板</h2>
<p>win + v</p>
<h2 id="参考网页">参考网页</h2>
<p><a href="https://www.bilibili.com/video/av64127316">https://www.bilibili.com/video/av64127316</a><br>
<a href="https://baike.baidu.com/item/Windows%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/407192?fr=aladdin">https://baike.baidu.com/item/Windows快捷键大全/407192?fr=aladdin</a></p>
]]></content>
      <tags>
        <tag>软件学习</tag>
      </tags>
  </entry>
  <entry>
    <title>一份（不太）简短的LaTex介绍学习笔记</title>
    <url>/posts/9ab4ff8e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>第一章 LaTeX 须知</h1>
<p>本书的别名叫做106分钟了解LaTeX，但是要看完根本不止106分钟，更别说理解了。暂时先看到第四章。</p>
<h3 id="Tex">Tex</h3>
<blockquote>
<p>TEX是高德纳(Donald E.Knuth)开发的、以排版文字和数学公式为目的的一个计算机软件。高德纳从1977年开始开发TEX，以发掘当时开始用于出版工业的数字印刷设备的潜力。正在编写著作《计算机程序设计艺术》的高德纳，意图扭转排版质量每况愈下的状况，以免影响他的出书。TEX排版引擎发布于1982年，在1989年又加以改进以更好地支持8-bit字符和多语言排版。TEX以其卓越的稳定性、跨平台、几乎没有Bug而著称。TEX的版本号不断趋近于π，当前为3.141592653</p>
</blockquote>
<h3 id="LaTex">LaTex</h3>
<blockquote>
<p>LATEX为TEX基础上的一套格式，令作者能够使用预定义的专业格式以较高质量排版和印刷他们的作品。LATEX的最初开发者为Leslie Lamport博士。LATEX使用TEX程序作为自己的排版引擎。当前LATEX由LATEX3工作组1维护。</p>
</blockquote>
<h3 id="引擎、格式和编译命令">引擎、格式和编译命令</h3>
<ul>
<li><strong>引擎</strong>     是编译源代码并生成文档的程序，如pdfTeX，XeTeX等。有时也称为编译器。</li>
<li><strong>格式</strong>    是定义了一组命令的代码集，最广泛应用的一个格式就是latex，另外，还有一个简版的plain tex</li>
<li><strong>编译命令</strong> 是实际调用的，结合了引擎和格式的命令，如xelatex和pdflatex。</li>
</ul>
<h3 id="latex用到的文件">latex用到的文件</h3>
<ul>
<li><strong>.sty</strong> 宏包文件</li>
<li><strong>.cls</strong> 文档类文件</li>
<li><strong>.bib</strong> 参考文献数据库文件</li>
<li><strong>.bst</strong> 参考文献格式模板</li>
</ul>
<h3 id="latex编译中生成的文件">latex编译中生成的文件</h3>
<ul>
<li><strong>.log</strong> 日志</li>
<li><strong>.aux</strong> 主辅助文件，记录交叉引用、目录和参考文献的引用等。</li>
<li><strong>.toc</strong> 目录记录文件</li>
<li><strong>.lof</strong> 图片目录记录文件</li>
<li><strong>.lotLATEX</strong> 生成的表格目录记录文件。</li>
<li>.bbl  BIBTEX生成的参考文献记录文件。</li>
<li>.blg  BIBTEX生成的日志文件。</li>
<li>.idx  LATEX生成的供makeindex处理的索引记录文件。</li>
<li>.ind  makeindex 处理.idx生成的用于排版的格式化索引文件。</li>
<li>.ilg  makeindex生成的日志文件。</li>
<li>.out  hyperref宏包生成的PDF书签记录文件。</li>
</ul>
<h3 id="include-与-input">\include 与 \input</h3>
<ul>
<li>\include{ <em>filename</em> }  插入其他文件（不在同一目录需加路径），<strong>会另起一页</strong>。</li>
<li>\input{ <em>filename</em>} 一样，但是不会另起一页。</li>
</ul>
<h1>用LaTeX 排版文字</h1>
<p>作者对排版中文文档的建议是，使用ctex文档类型、源代码保存为<strong>UTF-8</strong>编码、编译时使用<strong>xelatex</strong>命令</p>
<h3 id="字符编码">字符编码</h3>
<p>latex命令和pdflatex命令下，可以使用<strong>inputenc</strong>宏包支持UTF-8编码：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>[utf8]&#123;inputenc&#125;</span><br></pre></td></tr></table></figure>
<p>xelatex和lualatex命令原生支持UTF-8编码。</p>
<h3 id="排版中文">排版中文</h3>
<p>ctex 文档包括ctexart 、ctexrep、ctexbook，是目前最新的排版中文的方式（老的我不太想知道了）。</p>
<h3 id="空格">空格</h3>
<ul>
<li>多个连续空格或tab键均视为一个空格。</li>
<li>每行开头的空格忽略不计、</li>
<li><strong>行末的回车</strong>视为一个空格</li>
</ul>
<h3 id="分段">分段</h3>
<ul>
<li>连续<strong>两个回车</strong>，也就是空一行，会分段。</li>
<li>多个空行仍视为一个空行</li>
<li><strong>\par</strong>命名分段</li>
</ul>
<h3 id="注释">注释</h3>
<ul>
<li><strong>%</strong></li>
</ul>
<h3 id="特殊字符">特殊字符</h3>
<p>以下字符具有特殊用途，如需直接输入这些字符，需使用 *<em>*</em> 转义<br>
# $ % &amp; { } _ ^ ~ \</p>
<p>注： \为手动换行，因此输入反斜线为**\textbackslash**</p>
<h3 id="标点符号">标点符号</h3>
<ul>
<li>中文标点符号直接输入即可</li>
<li>英文双引号输入<strong>两个单引号</strong></li>
<li>连字符
<ul>
<li>单个连字符**-**就是自身</li>
<li>两个连字符**–**连接数字表示范围</li>
<li>三个连字符**—**作为破折号—使用</li>
</ul>
</li>
<li>省略号 <strong>\ldots</strong> 和 <strong>\dots</strong> 表示输入三个点。</li>
<li>波浪号 <strong>-</strong> <strong>\sim</strong></li>
</ul>
<h3 id="文字强调">文字强调</h3>
<ul>
<li>\underline{} 下划线</li>
<li>\emph{}        斜体</li>
</ul>
<h3 id="断行">断行</h3>
<ul>
<li><strong>\</strong> 进行断行。</li>
<li>用**-**插入不会断行的空格（高德纳称之为tie），常用于英文人名、图表名称等。</li>
</ul>
<h3 id="断页">断页</h3>
<ul>
<li><strong>\newpage</strong>  <strong>\clearpage</strong></li>
</ul>
<h1>文档元素</h1>
<h3 id="章节题目">章节题目</h3>
<ul>
<li>\chapter{} <strong>只在 book 和 report 文档类有定义</strong></li>
<li>\section{}  \subsection{} \subsubsection{} \paragraph{} \subparagraph{}</li>
<li>命令变体
<ul>
<li>带可选参数的变体：\section[short title]{title}<br>
标题使用title 参数，在目录和页眉页脚中使用short title参数</li>
<li>带星号的变体：\section*{title}<br>
标题不带编号，也不生成目录项和页眉页脚</li>
</ul>
</li>
<li>article 文档类<strong>带编号</strong>的层级为 \section \subsection \subsubsection 三项</li>
<li>report/book 文档类<strong>带编号</strong>的层级为 \chapter \section \subsection</li>
</ul>
<h3 id="目录">目录</h3>
<ul>
<li>使用命令**\tableofcontents** 生成目录</li>
<li>正确生成目录，一般需要编译两次源代码</li>
</ul>
<h3 id="标题页">标题页</h3>
<p>latex 支持生成简单的标题页。首先需要给定标题和作者等信息：前两个命令必需，date命令可选。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\title</span>&#123;⟨title⟩&#125;   <span class="keyword">\author</span>&#123;⟨author⟩&#125;   <span class="keyword">\date</span>&#123;⟨date⟩&#125;</span><br></pre></td></tr></table></figure>
<p>之后就可以使用 \maketitle 生成一个简单的标题页了。<br>
article 文档类的标题默认不单独成页。</p>
<h3 id="交叉引用">交叉引用</h3>
<p>在能够被交叉引用的地方，如章节、公式、图表、定理等位置使用\label命令：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\label</span>&#123;⟨label-name⟩&#125;</span><br></pre></td></tr></table></figure>
<p>之后，可以在别处使用\ref和\pageref命令，分别生成交叉引用的编号和页码：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\ref</span>&#123;⟨label-name⟩&#125;   <span class="keyword">\pageref</span>&#123;⟨label-name⟩&#125;</span><br></pre></td></tr></table></figure>
<p>为了生成正确的交叉引用，一般需要<strong>多次编译源代码</strong>。<br>
对于使用不记编号的命令形式（\section*,\caption），<strong>不要使用\label命令</strong>，否则生成的引用编号不正确。</p>
<h3 id="脚注">脚注</h3>
<p>脚注就是在页脚的位置写上注释，一般使用\footnote命令。</p>
<h1>特殊环境</h1>
<h2 id="列表">列表</h2>
<h3 id="有序列表">有序列表</h3>
<p>基本命令是enumerate。item中包含一个可选参数，将列表符号改成自定义的符号，如\item[*]。<br>
列表可以嵌套使用，最多嵌套四层。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;</span><br><span class="line">	<span class="keyword">\item</span>. . .</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无序列表">无序列表</h3>
<p>无序列表的基本命令为itemize，格式同上。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line">	<span class="keyword">\item</span>. . .</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对齐环境">对齐环境</h2>
<p>文本对齐方式可用以下命令分别生成居中、左对齐和右对齐的文本环境。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;center&#125;. . .<span class="keyword">\end</span>&#123;center&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;flushleft&#125;. . .<span class="keyword">\end</span>&#123;flushleft&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;flushright&#125;. . .<span class="keyword">\end</span>&#123;flushright&#125;</span><br></pre></td></tr></table></figure>
<p>另外，如果只改变一句文本的对齐方式，可直接使用以下命令</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\centering</span>   <span class="keyword">\raggedright</span>   <span class="keyword">\raggedleft</span></span><br></pre></td></tr></table></figure>
<h2 id="引用环境">引用环境</h2>
<ul>
<li><strong>quote</strong>环境用于引用较短的文字，首行不缩进。</li>
<li><strong>quotation</strong>环境用于引用若干段文字，首行缩进。</li>
<li>不论是quote或quotation,引用环境相较于一般文字均有额外的左右缩进。</li>
</ul>
<h2 id="代码环境">代码环境</h2>
<p>有时我们需要将一段代码原样输出，这时需用到代码环境verbatim。</p>
<ul>
<li>verbatim* 环境会将空格显示为␣</li>
<li>只排版一行代码，可使用\verb命令，delim表明代码的边界，习惯使用|符号。</li>
</ul>
 <figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\verb</span>⟨<span class="string">delim⟩</span>⟨code⟩⟨delim⟩</span><br></pre></td></tr></table></figure>
<h2 id="表格环境">表格环境</h2>
<p>latex直接排版表格感觉比较复杂，不是很实用。大量的表格排版还是需要R语言相应的函数包的支持。<br>
最基本的tabular环境用法如下，其中⟨column-spec⟩是列格式标记（通常使用|c|表示居中）；&amp;用来分隔单元格；\用来换行；\hline用来在行与行之间绘制横线。<br>
注意：表格中每行的单元格数目不能多于列格式里l/c/r(左/居中/右对齐)的总数（可以少于这个总数）。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;tablular&#125;&#123;&lt;column-spec&gt;&#125;</span><br><span class="line">&lt;item1&gt; <span class="built_in">&amp;</span> &lt;item2&gt; <span class="built_in">&amp;</span> ... <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span> </span><br><span class="line">&lt;item1&gt; <span class="built_in">&amp;</span> &lt;item2&gt; <span class="built_in">&amp;</span> ... <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图片">图片</h2>
<p>LaTex本身不支持插图功能，需要调用graphicx宏包辅助支持。<br>
各种编译方式支持的图片格式如下图（xelatex最好）<br>
<img src="graphicx.png" alt=""><br>
在调用了graphicx宏包后，就可以使用以下命令加载图片了。其中filename为文件名，不在同一路径时，需使用相对路径或绝对路径。可选参数如下图。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\includegraphics</span>[⟨options⟩]&#123;⟨filename⟩&#125;</span><br></pre></td></tr></table></figure>
<p><img src="includegraphics.png" alt=""></p>
<h1>排版数学公式</h1>
]]></content>
      <tags>
        <tag>LaTex</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-任长</title>
    <url>/posts/4553ed87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>臣闻料才核能，治世之要。自非圣人，谁能兼兹百行，备贯众理乎？故舜合群司，随才授位；汉述功臣，三杰异称。况非此俦，而可备责耶？</p>
</blockquote>
<blockquote>
<p>夫刚略之人，不能理微，故其论大体则弘略而高远，历纤理微则宕往而疏越；亢厉之人，不能回挠，其论法直则括据而公正，说变通则否戾而不入；宽恕之人，不能速捷，论仁义则弘详而长雅，趋时务则迟缓而不及；好奇之人，横逸而求异，造诡谲则倜傥而瑰壮，案清道则诡常而恢迂。</p>
<p>又曰：王化之政，宜于统大，以之理小则迂；策术之政，宜于理难，以之理平则无奇；矫亢之政，宜于治侈，以之治弊则残；公刻之政，宜于纠奸，以之治边则失其众；威猛之政，宜于讨乱，以之治善则暴；伎俩之政，宜于治富，以之治贫则民劳而下困。此已上皆偏材也。</p>
</blockquote>
<blockquote>
<p>魏武诏曰：“进取之士，未必能有行。有行之士，未必能进取。陈平岂笃行，苏秦岂守信耶？而陈平定汉业，苏秦济弱燕者，任其长也。”</p>
<p>由此观之，使韩信下帏，仲舒当戎，于公驰说，陆贾听讼，必无曩时之勋，而显今日之名也。故“任长”之道，不可不察。</p>
</blockquote>
<blockquote>
<p>议曰：魏恒范云：“帝王用人，度世授才。争夺之时，书策为先。分定之后，忠义为首。故晋文行舅犯之计而赏雍季之言，高祖用陈平之智而托后于周勃。” 古语云：“守文之代，德高者位尊；仓促之时，功多者赏厚。”  诸葛亮曰：“老子长于养性，不可以临危难；商鞅长于理法，不可以从教化。苏张长于驰辞，不可以结盟誓；白起长于攻取，不可以广众；子胥长于图敌，不可以谋身；尾生长于守信，不可以应变；王嘉长于遇明君，不可以事暗主；许子将长于明臧否，不可以养人物。”  此任长之术也。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-原序</title>
    <url>/posts/48e2ba4b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>匠臣舆者，忧人不贵；做箭者，恐人不伤。彼其有爱憎哉？实技业驱之然耳。是知当代之士、驰骛之曹，书读纵横，则思诸侯之变；艺长奇正，则念风尘之会。此亦向时之论，必然之理矣。故先师孔子深探其本、忧其末，遂作《春秋》，大乎工道；制《孝经》，美乎德行。防萌杜渐，预有所抑。</p>
<p>斯圣人制作之本意也。</p>
<p>然作法于理，其弊必乱。若至于乱，将焉救之？是以御世理人，罕闻沿袭。三代不同礼，五霸不同法。非其相反，盖以救弊也。是故国容一致，而忠文之道必殊；圣哲同风，而皇王之名或异。岂非随时投教沿乎此，因物成务牵乎彼？沿乎此者，醇薄继于所遭；牵乎彼者，王霸存于所遇。故古之理者，其政有三：王者之政化之；霸者之政威之；强国之政胁之。各有所施，不可易也。管子曰：“圣人能辅时不能违时。智者善谋，不如当时。”邹之曰：“政教文质，所以匡救也。当时则用之，过则舍之。”由此观之，当霸者之朝而行王者之化，则悖矣。当强国之世而行霸者之威，则乖矣。若时逢狙诈，正道陵夷，欲宪章先王，广陈德化，是犹待越客以拯溺，白大人以救火（等待水性好的人来救溺水者，请求尊贵的人来救火）。善则善矣，岂所谓通于时变欤？</p>
<p>夫霸者， 驳道也，盖白黑杂合，不纯用德焉。期于所成，不问所以；论于大体，不守小节。虽称仁引义不及三王，扶颠定倾，其归一揆。恐儒者溺于所闻，不知王霸殊略，故叙以长短术，以经论通变者，并立题目总六十有三篇，合为十卷，名曰《反经》。大旨在乎宁固根蒂，革易时弊，兴亡治乱。</p>
<p>具载诸篇，为沿袭之远图，作经济之至道，非欲矫世夸欲，希声慕名。辄露见闻，逗机来哲。凡厥有位，幸望详焉。</p>
</blockquote>
<p>《反经》是我最喜欢的古文书，这篇序就很先声夺人，不明觉厉。拜服老祖宗的智慧！</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷p大政-品目</title>
    <url>/posts/a8d66a27/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>夫天下重器，王者大统，莫不劳聪明于品材，或安逸于任使。故孔子曰：“人有五仪：有庸人，有士人，有君子，有圣，有贤。审此五者，则治道毕矣。”</p>
<p>所谓庸人者，心不存慎终之规，口不吐训格之言，不择贤以托身，不力行以自定，见小暗大而不知所务，从物如流而不知所执。此则庸人也。</p>
<p>所谓士人者，心有所定，计有所守。虽不能尽道术之术，必有率也；虽不能遍百善之美，必有处也。是故智不务多，务审其所知；言不务多，务审其所谓【所谓，言之要也】；行不务多，务审其所由。智既知之，言既得之【得其要也】，行既由之，则若性命形骸之不可易也。富贵不足以益，贫贱不足以损，此则士人也。</p>
<p>所谓君子者，言必忠信而心不忌【忌，怨害也】，仁义在身而色不伐，思虑通明而辞不专，笃行信道，自强不息，油然若将可越而终不及者。此君子也。【孙卿曰：“夫君子能为可贵，不能使人必贵己；能为可信，不能使人必信己；能为可用，不能使人必用己。故君子耻不修，不耻见污；耻不信，不耻不见信；耻不能，不耻不见用。不诱于誉，不怨于诽，率道而行，端然正己，谓之君子也。”】</p>
<p>所谓贤者，德不逾闲【闲，法也】，行中规绳，言足法于天下而不伤于其身【言满天下，无口过也】，道足化于百姓而不伤于本【本亦身也】，富则天下无菀财【菀：积】，施则天下无病贫。此谓贤者也。</p>
<p>所谓圣者，德合天地，变通无方，究万物之终始，协庶品之自然，敷其大道而遂成情性，明立日月，化行若神，下民不知其德，睹者不识其邻。此圣者也。</p>
</blockquote>
<blockquote>
<p>清节之流，不能弘恕，好尚讥诃，分别是非，是谓臧否。子夏之徒是也。法家之流，不能创思图远，而能受一官之任，错意施巧，是为伎俩。张敞、赵广汉是也。术家之流，不能创制垂则，而能遭变用权。权智有余，公正不足，是谓智意。陈平、韩安国是也。能文著述，是谓文章，司马迁、班固是也。能传圣人之业，而不能干事施政，是谓儒学。毛公、贯公是也。辩不入道，而应对给资，是谓口辩。乐毅、曹丘生是也。胆力绝众，才略过人，是谓骁雄。白起、韩信是也。</p>
</blockquote>
<blockquote>
<p>《家语》曰：“昔者明王必尽知天下良士之名，既知其名，又知其实，然后用天下之爵以尊之，则天下理也。”此之谓矣。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-大体</title>
    <url>/posts/112d874c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>臣闻老子曰：“以正理国，以奇用兵，以无事取天下。”荀卿曰：“人主者，以官人为能者也；匹夫者，以自能为能也。”</p>
</blockquote>
<blockquote>
<p>《人物志》曰：“夫一官之任，以一味协五味；一国之政，以无味协五味。故臣以自任为能；君以能用人为能。臣以能言为能；君以能听为能。臣以能行为能；君以能赏罚为能。所以不同，故能君众能也。”</p>
</blockquote>
<blockquote>
<p>故曰，知人者，王道也；知事者，臣道也；无形者，物之君也；无端者，事之本也。鼓不预五音，而为五音主；有道者，不为五官之事，而为理事之主。君守其道，官知其事，有自来矣。</p>
<p>先王知其如此也，故用非其有如己有之，通乎君道者也。</p>
</blockquote>
<blockquote>
<p>议曰：《淮南子》云：“巧匠为宫室，为圆必以规，为方必以矩，为平直必以准绳。功已就矣，而不知规矩准绳，而赏巧匠。宫室已成，不知巧匠，而皆曰某君某王之宫室也。”</p>
<p>孙卿曰：“夫人主故欲得善射中微，则莫若使羿；欲得善御致远，则莫若使王良；欲得调一天下，则莫若聪明君子矣。其用智甚简，其为事不劳，而功名甚大。”此能用其非其有如已有者也。</p>
</blockquote>
<blockquote>
<p>人主不通主道者则不然。自为之则不能任贤，不能任贤，则贤者恶之，此功名之所以伤，国家之所以危。</p>
</blockquote>
<blockquote>
<p>议曰：“《申之》云：君知其道也，臣知其事也。十言十当，百言百当者，人臣之事也，非人君之道也。”《尸子》云：“人臣者，以进贤为功也；君者，以用贤为功也。”</p>
</blockquote>
<blockquote>
<p>汤武一日而尽有夏商之财，以其地封，而天下莫敢不悦服；以其财赏，而天下皆竞劝，通乎用非其有也。</p>
</blockquote>
<blockquote>
<p>议曰：孙卿曰：“修礼者王，为政者强，取人者安，聚敛者亡。故王者富人；霸者富士；仅存之国富大夫；亡国者富筐箧、实府库。是谓上溢下漏。” 又曰：“天子不言多少，诸侯不言利害，大夫不言得失。”</p>
</blockquote>
<blockquote>
<p>魏文侯御廪灾，素服避正殿，群臣皆哭。公子成夫趋入贺曰：“臣闻天子藏于四海；诸侯藏于境内。非其所藏，必有火灾，必有人患。幸无人患，不亦善乎。”  孔子曰：“百姓足，君孰与不足？” 由此言之，夫圣王以其地封，以其财赏，不与人争利，乃能通于主道，是用非其有者也。</p>
</blockquote>
<blockquote>
<p>故称，设官分职，君之体也；委任责成，君之体也；好谋无倦，君之体也；宽以得众，君之体也；含垢藏疾，君之体也。君有君人之体，其臣畏而爱之，此帝王所以成业也。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-察相</title>
    <url>/posts/3e46a22e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这里的“相”除了长相，骨骼等，还指的是人的形态、举止。</p>
<blockquote>
<p>富贵在于骨法，忧喜在于容色，成败在于决断。由此参之，万不失一。</p>
</blockquote>
<blockquote>
<p>言性灵者存乎容止。斯其大体。</p>
</blockquote>
<blockquote>
<p>夫人有六贱：<br>
头小身大，为一贱 【又曰：额角陷缺，天中洼下，亦为一贱。】<br>
目无光泽，为二贱【又曰：胸背俱薄，亦为二贱。《经》曰：陷胸薄尻及猴目，皆穷相也】。<br>
举动不使，为三贱【又曰：声音雌散，亦为三贱。夫人不笑似笑，不嗔似嗔，不喜似喜，不畏似畏，不醉似醉，常如宿醒，不愁似愁，常如忧戚，容貌缺乏，如经痫病，神色凄怆，常如有失，举止张皇，恒如趋急，言语涩缩，若有隐藏，体貌低催，如遭凌辱，此并神不足者也。神不足者，多牢狱厄。有官隐藏而失，有位贬逐而黜者也。<br>
鼻不成就，准向前低，为四贱<br>
脚长腰短，为五贱<br>
文策不成，唇细横长，为六贱。【又曰：多言少信，亦为六贱。<br>
此贵贱存乎骨骼者也。</p>
</blockquote>
<p>译文解释：相面要从身体结构的整体上把握，绝不能只见树木、不见森林。大凡人的姿容，都以“整”为贵。这个“整”指的并不是整齐划一，而是人体的各个部位都要匀称、均衡，从而构成一个和谐有机的整体。比如个子矮的人不能太胖；个子高的人不能太瘦，不然就像一根茅草或电线杆。背部应该浑圆而厚实，腹部应该突出而平坦，手部应该温润而柔软，脚应该丰厚而饱满，足心应该虚能藏蛋 – 这也是所谓的“整”。</p>
<blockquote>
<p>昔姑布之卿谓子贡曰：“郑东门有一人，其长九尺六寸，河目而龙颜，其头似尧，其颈似皋陶，其肩似子产，然自腰以下不及禹三寸，垒然若丧家之犬。”</p>
</blockquote>
<p>译文：郑国东门的这个人虽然有尧一样的头颅，皋陶一样的脖颈，子产一样的肩膀，然而由于腿太短，所以像一只丧家之犬。这就是因为此人的相貌违反了“整”的原则。</p>
<blockquote>
<p>夫命之与相，犹声之与响也。声动乎几响，穷乎应，必然之理也。虽云以言信行，失之宰予，以貌度性，失之子羽。然《传》称：“无忧而戚，忧必及之；无庆而乐，乐必还之。” 此心有先动而神有先知，则色有先见。故扁鹊见桓公，知其将亡；申叔见巫臣，知其窃妻。或跃马膳珍，或飞而食肉，或早隶晚侯，或初刑末王。铜岩无饱生，玉馔终乎饿死。则彼度表扪骨，指色摘理，不可诬也。故列云尔。</p>
</blockquote>
<p>这一篇我原来当作糟粕，现在想想也很有道理的。长相、身高等确实是天生，但是形态、举止等是可以后天改变的，是可以教化的。按峰老师的说法，以貌取人仍然是最简单最直接的方法。人的内心的情志一定会通过外貌和举止来体现出来，而且更多的时候我们也只能通过人的外貌、形态和举止对其它人做出一个判断。</p>
<p>比如目光无泽、举动不使（译文，行为举止看着力不从心）就说明这个人意志薄弱（神不足）。就像这种情况，就完全是可以通过增强意志、锻炼身体等方式进行改变的。</p>
<p>其实这篇对我的意义在于，一是说明了以貌取人虽然不见得对，但是仍然是有道理的；二是要认识到自身形态举止的缺点，进行针对性的改造，以最大实现“整体”的和谐。</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-知人</title>
    <url>/posts/2dee69f0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>臣闻主将之法，务览英雄之心。然人未易知，知人未易。 汉光武聪听之主也，谬于庞萌；曹孟德知人之哲也，弊于张邈。何则？夫物类者，世之惑乱也。故曰：狙者类智而非智也，愚者类君子而非君子也，戆者类勇而非勇也。亡国之主似智；亡国之臣似忠；幽莠之幼似禾；骊牛之黄似虎；白骨疑象；碔砆类玉。此皆似是而非也。</p>
<p>《人物志》曰：”轻诺似烈而寡信；多易似能而无效；进锐似精而去速；诃者似察而事烦；许施似惠而无终；面从似忠而退违。此似是而非者也。亦有似非而是者：大权似奸而有功；大智似愚而内明；博爱似虚而实厚；正言似讦而情忠。非天下之至精，孰能得其实也？“</p>
</blockquote>
<blockquote>
<p>孔子曰：”凡人心险于山川，难知于天。天犹有春夏秋冬旦暮之期，人者厚貌深情，故有貌愿而益，有长若不肖，有顺怀而达，有坚而缦，有缓而钅干。“ 太公曰：”士有严而不肖者，有温良而为盗者，有外貌恭敬中心欺慢者，有精精而无情者，有威威而无成者，有如敢断而不能断者，有恍恍惚惚而反忠实者，有倭倭拖拖而有效者，有貌勇狠而内怯者，有梦梦而反易人者。无使不至，无使不遂，天下所贱，圣人所贵，凡人莫知，惟有大明，乃见其际。“ 此士之外貌不与中情相应者也。</p>
</blockquote>
<blockquote>
<p>知士者而有水焉。微察问之，以观其辞；穷之以辞，以观其变，与之间谋，以观其诚；明白显问，以观其德；远使以财，以观其廉；试之以色，以观其贞；告之以难，以观其勇；<strong>醉之以酒，以观其态</strong>。</p>
</blockquote>
<blockquote>
<p>《庄子》曰：”远使之而观其忠；近使之而观其敬；<strong>烦使之而观其能</strong>；<strong>卒然问焉而观其智</strong>；急与之期而观其信；杂之以处而观其色。</p>
</blockquote>
<p>简单地说，就是需要通过实践来验证一个人的才能和品格。</p>
<blockquote>
<p>桓范曰：“夫务名者不能出己之后，是故性同而材倾则相援而相赖也，性同而势均则相竞而相害也。” 此为同体之变，不可不察也。</p>
</blockquote>
<blockquote>
<p>夫圣贤所美，莫美乎聪明。聪明之所贵，莫贵乎知人。知人识智，则众材得其序，而庶绩之业兴矣。…… 察其所安，观其所由，以知居止之行。率此道也，人焉庾哉，人焉庾哉？</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-政体</title>
    <url>/posts/a3353214/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>【议曰：夫政理，得人则心，失人则毁。故首简才，次论政体也。】</p>
</blockquote>
<blockquote>
<p>措国于不倾之地，有德也。</p>
</blockquote>
<blockquote>
<p>积於不涸之仓，务五谷也。</p>
</blockquote>
<blockquote>
<p>下令于流水之原，以顺人心也。</p>
<p>尉缭子曰：“令，所以一众心也。不审所出，则数变，数变则令虽出，众不信也。出令之法虽有小过，无更，则众不二听，即令行矣。”</p>
</blockquote>
<blockquote>
<p>使士于不诤之官，使人各为其所长也</p>
<p>孙卿曰：“相高下，序五谷，君子不如农人；通财货，辩贵贱，君子不如贾人；设规矩，便备用，君子不如工人。若夫论德而定次，量能而授官，言必当理，事必当务，然后君子之所长。”</p>
<p>文子曰：“力胜其任即举之，不重也；能务其事则为之，不难也。”</p>
</blockquote>
<p>这里的“诤” 解释为不争夺权势，个人感觉根据下文说不通，解释为不让人争论更好，即举官应该做到让人无法非议。</p>
<blockquote>
<p>明必死之路，严刑罚也。</p>
<p>议曰：孔子曰：“上失其道而杀其下，非礼也。” 故三军大败，不斩；狱*不治，不可刑。何也？上教之不行，罪不在人故也。夫慢令致诛，贼也；征敛无时，暴也；不诫责成，虐也。政无此三者，然后刑，即可也。陈道德以先服之，犹不可，则尚贤以劝之，又不可，则废。不能以惮之，而犹有邪人不从化者，然后待之以刑矣。“</p>
</blockquote>
<blockquote>
<p>开必得之门，信庆赏也。</p>
</blockquote>
<blockquote>
<p>不为不可成，量人力也。</p>
<p>文子曰：”夫债少易偿也，职寡易守也，任轻易劝也。上操约少之分，下效易为之功，是以为君为臣久而不相厌也。末世之法，高为量而罪不及，重为任而罚不胜，危为难而诛不敢。人困于三责，即饰智以诈上，虽峻法严刑，不能禁其奸也。“</p>
</blockquote>
<blockquote>
<p>不求不可得，不强人以其所恶也。</p>
<p>故其称曰：”政“者，政之所行，在顺人心，政之所废，在逆人心。夫人恶忧劳，我逸乐之；人恶贫贱，我富贵之；人恶危坠，我存安之；人恶绝灭，我生育之。能逸乐之，则人为之忧劳；能富贵之，则人为之贫贱；能存安之，则人为之危坠；能生育之，则人为之绝灭。故从其四欲，则远者自亲，行其四恶，则近者亦叛。</p>
</blockquote>
<blockquote>
<p>不处不可久，不偷取一世宜也。</p>
</blockquote>
<blockquote>
<p>知时者，可立以为长。</p>
<p>范蠡曰：” 时不至不可强生，事不容不可强成。“ 管子曰：” 圣人能辅时，不能违时。“ 《语》曰：”圣人修备以待时也。“</p>
</blockquote>
<blockquote>
<p>审于时，察于用，而能备官者，可奉以为君。</p>
<p>管仲曰：” 大位不仁，不可授以国柄；见贤不让，不可与尊位；罚避亲戚，不可使主兵；不好本事，不可与都邑。“ 又曰：” 使贤者食于能，则上尊崇；斗士食于功，则卒轻死。使二者设于国，则天下理。“</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-论士</title>
    <url>/posts/b8f1ee07/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>《书》曰：“能自得师者王。” 何以明之？齐宣王见颜触曰：“触前。” 触亦曰：“王前。” 宣王作色曰：“王者贵乎？士者贵乎” ……</p>
<p>宣王左右曰：“大王据千乘之地，而建千石之钟，东西南北，莫敢不服。今夫士之高者，乃称匹夫，徒步而处于农亩，下则鄙野、监门、闾里。士之贱也，亦甚矣。” 触曰：“古大禹之时，诸侯万国。舜起农亩而为天子。及汤之时，诸侯三千。当今之世，南面称寡人则，乃四世。由此观之，非得失之策与？稍稍诛灭，灭亡无族之时，欲为监门、闾里，安可得哉？《易传》不云乎：‘居上位，未得其实。’ 故无其实而喜居名者削；无其德而望其福者约；无其功而受其禄者辱，祸必掘。故曰：‘ 矜功不立，虚愿不至。’ 至皆夸其名华而无其实德也。是以尧有九佐，舜有十友，禹有五丞，汤有三辅，自古及今，而能虚成名于天下者，无有。是以君王无羞亟问，不愧下学，而成其道。老子曰：‘ 虽贵，必以贱为本；虽高，必以下为基。’ 是以侯王称孤、寡人、不谷。夫孤寡者，困贱、下位者也，而侯王以是谓，岂非下人而尊贵士与？夫尧传舜，舜传禹，周成王传周公旦，而世世称名，实以明乎士之贵也。“</p>
<p>谚曰：”浴不必江海，要之去垢；马不必骐骥，要之善走；士不必贤也，要之知道；女不必贵种，要之贞好。“ 何以明之？淳于髡谓齐宣王曰：”古者好马，王亦好马；古者好味，王亦好味；古者好色，王亦好色；古者好士，王独不好。“ 王曰：” 国无士耳。有则寡人亦悦之。“ 髡曰：” 古有骅骝，今之无有，王选于众，王好马矣；古有豹像之胎，今之无有，王选于众，王好味矣；古有毛嫱、西施，今之无有，王选于众，王好色矣；王必待尧舜禹汤之士，而后好之，则尧舜禹汤之士，亦不好王矣。“</p>
<p>《淮南》曰：”待腰袅、飞兔而后驾，则世莫乘车矣；待西施、洛浦而后妃，则终身不家矣。然不待古之英隽而自足者，因其所有而遂用之也。“</p>
<p>郭隗说燕昭王曰：” 帝者与师处，王者与友处，霸者与臣处，亡国与厮役处。诎指而事之，北面受学，则百己者至；先趋而后息，先问而后默，则什己者至；人趋己趋，则若己者至；凭几据杖，眄视指使，则厮役之人至；恣睢奋击，呴藉叱咄，则徒隶之人至矣。“此乃古之服道致士者也。</p>
<p>黄石公曰：”礼者，士之所归；赏者，士之所死。招其所归，示其所死，则所求者至矣。“</p>
</blockquote>
<blockquote>
<p>【议曰：世之善恶，难得而知，苟非其人，莫见其际，何者？夫文章为武人所嗤，未必鄙也；为扬、马所嗤，此真鄙也。夫人臣为桀、纣所毁，未必为愚也；必若尧舜所毁，此真愚也。世之毁誉不足信也。故曰：不夜出，安知有夜行人？太公曰：“ 智与众同，非人师也；伎与众同，非国工。” 老子曰：“下士闻道，大笑之，不笑不足以为道。” 故曰：凡人所贱，圣人所贵。信矣哉！】</p>
</blockquote>
<blockquote>
<p>《语》曰：”知人未易，人未易知。“</p>
</blockquote>
<blockquote>
<p>《语》曰：”夫有国之主，不可谓举国无深谋之臣，合朝无智策之士，在听察所考精与不精，审与不审耳。“ …… 天下之国，莫不皆有忠臣谋士也。</p>
<p>议曰：天下无灾害，虽有贤德，无所施材。老子曰：”大道废，有仁义；国家混乱，有忠诚。《淮南子》曰：”未有其功而知其贤者，唯尧之知舜也；功成事立而知其贤者，市人之知舜也。“ …… 故曰：“贤、不肖者，才也；遇与不遇者，时也。” 诚哉，是言也。</p>
</blockquote>
<blockquote>
<p>黄石公曰：”罗其英雄，则敌国穷。夫英雄者，国家之干；士民者，国家之半。得其干，收其半，则政行而无怨。知人者哲，唯帝难之。“ 慎哉！</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-量才</title>
    <url>/posts/c7a98fc8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>孙武曰：“主孰有道？”</p>
<p>昔汉王见围荥阳，谓陈平曰：“天下纷纷，何时定乎？“ 平曰：”项王为人恭敬爱人，士之廉节好礼者多归之。至于行功赏爵邑，重之，士亦以此不附。今大王慢人少礼，士之愚钝嗜利无耻者亦多归汉。诚宜各去两短，集其两长，天下指麾即定矣。“</p>
<p>魏太祖谓郭嘉曰：”袁本初地广兵强，吾欲讨之，力不能敌，何如？“ 嘉对曰：”刘，项之不敌，公所知也，汉祖惟智胜。项羽虽强，终为所擒。嘉窃料之，绍有十败，公有十胜，虽兵强，无能为也。绍繁礼多仪，公体任自然。此道胜一也。绍虽兵强，绍以逆动，公奉顺以率天下，此义胜二也。汉末政失于宽，绍以宽济，故不摄；公纠之以猛，而上下，而上下知制，此治胜三也。绍外宽内忌，用人而旋疑之，所任唯亲戚子弟耳；公外简易而内机明，用人无疑，唯才能所宜，不问远近，此度胜四也。绍多计少决，失在事后；公策得辄行，应变无穷，此谋胜五也。绍因累世之资，高议揖让，以收名誉，士之好言饰外者多归之；公至心待人，推诚而行之，不为虚美，以俭率下，与有功者无所吝，士之忠正远见而有实者皆愿为用，此德胜六也。绍见人饥寒，恤念之情形于颜色，其所不见，虑或不及，所谓妇人之仁耳；公于目前小事，时有所忽，至于大事，于四海相接，恩之所加，皆过其望，虽所不见，虑之所周，无不济也，此仁胜七也。绍大臣争权，谗言惑乱；公御下以道，浸润而行，此明胜八也。绍是非不可知；公所是进之以礼，所不是正之以法，以文胜九也。绍好为虚势，不知兵要；公以少克众，用兵如神，军人恃之，敌人畏之，此武胜十也。“ 曹公曰：”吾知之，绍为人志大而智小，色厉而胆薄，忌刻而少威，兵多而分画不明，将骄而政令不一，土地虽广，粮食虽丰，适所以谓吾奉也。“ 杨阜曰：”袁公宽而不断，好谋而少决。不断而无威，少决则后事。今虽强，终为所擒。曹公有雄才远略，决机无疑，法一兵精，必能济大事也。“</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第三卷权变-反经</title>
    <url>/posts/7d0687a0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>《韩诗外传》曰：“夫士有五反，有势尊贵不以爱人行义理，而反以暴傲。” ——【 反贵也。古语曰：” 富能富人者，欲贫不可得；贵能贵人者，欲贱不可得；达能达人者，欲穷不可得。“ 梅福曰：“ 存人所以自立也；壅人所以自塞也。” 】</p>
<p>家富厚不以振穷救不足，而反以侈靡无度。 —— 【反富也。】</p>
<p>资勇悍不以卫上攻战，而反以侵凌私斗。 —— 【反勇也。凡将帅轻去就者，不可使镇边，使仁德守之则安矣。】</p>
<p>心智慧不以端计教，而反以事奸饰非。 —— 【反智慧也。《说苑》曰：“ 君子之权谋正，小人之权谋邪。” 】</p>
<p>貌美好不以统朝莅人，而反以盅女从欲。 —— 【反貌也。】</p>
<p>此五者，所谓士失其美质。</p>
</blockquote>
<blockquote>
<p>太公曰：“明罚使人畏慑，人畏慑则变故出。 —— 【反明罚也。】 明察使人扰，人扰则人徙，人徙则不安其处，易以成变。” —— 【反明察也。】 太公曰：“ 明赏则不足，不足则怨长。明王理人，不知所好，而知所恶；不知所归，而知所去。使人各安其所生，而天下静矣。”</p>
<p>晋刘颂曰：“ 凡监司欲举大而略小，何则？ 夫细过微阙，谬忘之失，此人情所必有，所固不许在不犯之地，而悉纠以法，则朝野无立人。此所谓以治而乱也。”</p>
<p>韩子曰：“儒者以文乱法，侠者以武犯禁。“</p>
<p>慎子曰：” 忠未足以救乱代而适足以重非。** 。然则孝子不生慈父之义【六亲不和有孝慈】，而忠臣不生于圣君之下【国家昏乱有忠臣】。故明主之使其臣也，忠不得过职，而职不得过官。 —— 【反忠也]</p>
</blockquote>
<p>这段话我的理解，如果不是因为国家昏乱，则个人的忠名不显。而个人的忠名越显，反而越彰显出国家昏乱（如果只是敢于进言而无助于事），因此“适足以重非”。</p>
<blockquote>
<p>跖之徒问于跖曰：“盗亦有道乎？” 跖曰：” 何适而无有道耶？夫妄意室中之藏，圣也。入先，勇也。出后，义也。知可否，智也。分均，仁也。五者不备而能成大盗者，天下未之有也。“</p>
</blockquote>
<blockquote>
<p>由是观之，善人不得圣人之道不立，盗跖不得圣人之道不行。天下之善人少而不善人多，则圣人之利天下也少而害天下也多矣。 —— 【反仁义也。】</p>
</blockquote>
<blockquote>
<p>汉武时，河间献王来朝，造次必于仁义。武帝色然难之，谓曰：” 汤以七十里，文王以百里，王其勉之！” 王知其意，归即纵酒。</p>
<p>由是言之，夫仁义兼济，必有分乃可。故尸子曰：“ 君臣父子，上下长幼，贵贱亲疏，皆得其分理。爱得分曰仁。施得分曰义。虑得分曰智。动得分曰适。言得分曰信。皆得其分而后为成人。”</p>
<p>由是言之，跖徒之仁义非其分矣。</p>
</blockquote>
<blockquote>
<p>由是言之，夫仁义礼乐、名法刑赏、忠孝贤智之道，文武明察之端，无隐于人，而常存于代，非自昭于尧汤之时，非故逃于桀纣之朝。用得其道则天下理，用失其道则天下乱。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第三卷权变-正论</title>
    <url>/posts/6a24346d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>【议曰：“反经”、“是非”、“适变” 三篇，虽博辩利害，然其弊流遁漫，羡无所归。故作“正论”以质之。】</p>
<p>孔子曰：“六艺于治一也。《礼》以节人，《乐》以发和，《书》以导事，《诗》以达意，《易》以神化，《春秋》以义。”</p>
<p>【班固曰：“ 乐者，圣人之所以乐也，而可以善人心，其感人也深。故先王著其教焉。夫人又血气心知之性，而无衰乐喜怒之常。应感而动，然后心术形焉。故纤微憔悴之音作，而民思忧；阐谐慢易之音作，而民康乐；粗厉猛奋之音作，而民刚毅；廉直正诚之音作，而民肃静；宽裕顺和之音作，而民慈爱；流僻邪散之音作，而民淫乱。先王耻其乱也，故制《雅》、《颂》之声。本之情性，稽之度数，制之礼义，合生气之和，导五常之行，使之阳而不散，阴而不集，刚气不怒，柔气不摄，四畅交于中，而发作于外。足以感人之善心，而不使邪气得接焉。是先王立乐之方也。”</p>
<p>班固曰：“人涵天地阴阳之气，有喜怒哀乐之情，天禀其性而不节也，圣人能为之节而不能绝也。故像天地而制礼乐，所以通神明，立人伦，正情性，节万事也。……。故孔子曰：‘ 安于治人，莫善于礼；风易俗，莫善于乐。揖让而治天下者，礼乐之谓也。’ ”】</p>
<p>【司马谈曰：“ 儒者，博而寡要，劳而少功，是以其事难尽从，然其 叙君臣父子之礼，列夫妇长幼之别，不可易也。夫儒者，以‘六艺’为法，经传以千万，累世不能通其学，当年不能究其礼，故曰‘ 博而寡要，劳而少功 ’ 。若夫列君臣父子之礼，叙夫妇长幼之别，虽百家勿能易也。”</p>
<p>司马谈曰：“ 阴阳之术，大详而众忌讳，使人拘而多畏，然其叙四时之大顺，不可失也。夫阴阳四时，八位十二度，二十四节，各有教令。曰顺之者昌，逆之者亡，未必然也。故曰使人拘而多忌。夫春生夏长，秋收冬藏，此天下之大经，弗顺则无以为天下纪纲。故曰叙四时之大顺，不可失也。”</p>
<p>司马谈曰：“ 法家严而少恩；然正君臣上下之分，不可改也。夫法家不别亲疏，不殊贵贱，一断于法，则亲亲尊尊之恩绝矣。可使行一时之计，而不可长用也。故‘ 严而少恩 ’。至于尊主卑臣，明职分不相逾越，虽百家不能改也。”</p>
<p>司马谈曰：“ 墨家俭而难遵，是以其事不可偏循。然其强本节用，不可废也。】</p>
</blockquote>
<blockquote>
<p>数子之言，当世得失，皆悉究矣。然多谬通方之训，好申一隅之说。贵清净者，以席上为腐论；束名实者，以柱下为诞辞。或推前王之风，可行于当年，有引救弊之规，宜流于长世。稽之笃论，将为弊矣。由此言之，故知有法无法，因时为业，时止则止，时行则行，动不失其时，其道光明。非至精者，孰能通于变哉？</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第三章权变-适变</title>
    <url>/posts/1e7152bf/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>昔先王当时而立法度，临务而制事，法宜其时则理，事适其务故有功。今时移而法不变，务易而事以古，是则法与时诡，而事与务易，是以法立而时益乱，务无而事益废。此圣人之理国也，不法古，不修今，当时而立功，在难而能免。</p>
<p>【秦孝公用卫鞅。鞅欲变法，孝公恐天下议己，疑之。卫鞅曰：“疑行无名，疑事无功。夫有高人之行者，固见非于世；有独智之虑者，必见教于人。愚者暗于成事，智者见于未萌。人不可与虑始，而可与乐成。论至德者，不和于俗；成大功者，不谋于众。是以圣人苟可以强国，不法其故；苟可以利人，不循其礼。” 孝公曰：“ 善。” 甘龙曰：“ 不然。圣人不易人而教，智者不变法而治。因人而教，不劳而功成。缘法而理，吏习而人安。” 卫鞅曰：“ 龙之所言，世俗之言。常人安于习俗，学者溺于所闻。以此两者居官守法可也，非所以与论于法之外也。三代不同礼而王；五霸不同法而霸。智者作法，愚者制焉。贤者更礼，不肖者拘焉。” 杜贽曰：“ 利不百，不变法；功不十，不易器。法古无过，修礼无邪。” 卫鞅又曰：“ 治代不一道，便国不法故。故汤武不循古而王，夏殷不易礼而亡。反古者不可非，而循礼者不足多。” 孝公曰：“ 善。” 遂变法也。】</p>
<p>由是言之，故知若人者，各因其时而建功立德焉。【孟子曰：“ 虽有磁基，不如遇时；虽有智慧，不如逢代。” 范蠡曰：“ 时不至，不可强生；事不究，不可强成。” 《语》 曰：“ 圣人修备以待时也。” 】</p>
<p>何以知其然耶？桓子曰：“ 三皇以道治，五帝用德化，三王由仁义，五伯用权智。” 【说曰：无制令刑罚谓之皇，有制令，无刑罚谓之义；赏善诛恶，朝诸侯，朝事，谓之王；兴兵众，立约盟，以信义矫代谓之伯。文子曰：“ 帝者，贵其德也；王者，尚其义也；霸者，迫其理也。道狭然后任智，德薄然后任刑，明浅然后任察。议曰：夫建国立功，其政不同也如此。】</p>
<p>五帝以上久远，经传无事，唯王霸二盛之类，以定古今之理焉。【秦汉居帝王之位，所行者霸事也。故以为德之次。】</p>
<p>夫王道之治，先除人害，而足其衣食。</p>
<p>【论曰：” 五亩之宅，树之以桑，匹妇蚕之，年五十者，可以衣帛矣。百亩之田，数口之家，耕稼修理，可以无饥矣。鸡豚狗彘之畜，不失其时，老者可以食肉矣。夫上无贪欲之求，下无奢淫之人，藉税省少而徭役不繁，其仕者，食禄而已，不与人争利焉。是以产业均而贫富不能相悬也。“ 】</p>
<p>然后教以礼仪。</p>
<p>【故明王审己正统，慎乃其位。宫室舆服不逾礼制，九女正序于内，三公分职于外。制井田以齐之，设诸侯以牧之，使饶不溢侈，少不匮乏，然后申以辟雍之化，示以揖让之容，是以和气四塞，祸乱不生，此圣王之教也。】</p>
<p>而威以刑诛，使知好恶去就。</p>
<p>是故大化四凑，天下安乐，此王者之术。</p>
<p>【王者，父天母地，调和阴阳，顺四时而理五行，养黎元而育群生，故王之为言往也。盖言其惠泽，优游善养润天下，天下归往之，故曰王也。】</p>
<p>霸功之大者，尊君卑臣，权统由一，政不二门，赏罚必信，法令著明，百官修理，威令必行。</p>
<p>【夫霸君亦为人除难兴利以富国强兵，或承衰乱之后，或兴兵征伐。皆未得，遵法度，申文理，度代而制，因时施宜，以从便善之计，而务在于立功也。】此霸者之术。</p>
<p>【王道纯而任德，霸道驳而任法。此优劣之差也。】</p>
<p>《道德经》曰：” 我无为而人自化。“ 《文子》曰：” 所谓无为者，非谓引之不来，推之不往，谓其循理而举事，因资而立功，推自然之势也。“ 【故曰：” 智而好问者圣；勇而好问者胜。乘众人之智，即无不任也；用众人之力，即无不胜也。故圣人举事，未尝不因其资而用也。】 故曰：汤武，圣主也，而不能与越人乘舲舟，泛江湖。伊尹，贤相也，而不能与胡人骑原马，服**。孔、墨，博通也，而不能与山居者入榛薄，出险阻。</p>
<p>由是观之，人智于物，浅矣，而欲以昭海内，存万物，不因道理之数，而专己之能，则其穷不远。故智不足以为理，勇不足以为强，明矣。然而君人者，在庙堂之上而知四海之外者，因物以识物，因人以知人也。</p>
<p>【《吕氏春秋》曰：“ 是天无形而万物以成，大圣无事而千官尽能，此谓不教之教，无言之昭业。” 】</p>
<p>夫冬日之阳，夏日之阴，万物归之，而莫之使。至精之感，弗召自来。待目而昭见，待言而使令，其于理难矣。</p>
<p>【《文子》曰：“ 三月婴儿，未知利害，而慈母之忧喻焉者，情也。” 故曰：“ 言之用者小，不言之用者大。又曰：不言而信，不施而仁，不怒而威，是以天心动化者也。施而仁，言而信，怒而威，是以精诚为之者也。施而不仁，言而不信，怒而不威，是以外貌为之也。】</p>
<p>【庄子曰：” 天地有大美而不言，四时有明法而不议，万物有成理而不说。圣人无为，大圣不作，观于天地之谓也。】</p>
<p>不言之令，不视之见，圣人所以为师。此黄老之术也。</p>
<p>六经之理，贵于未乱；兵家之胜，贵于未战。</p>
<p>此孔氏之术也。【议曰：孔氏之训，务德行义，盖王道也。】</p>
<p>墨子曰：“ 古之人未知为宫室，就陵阜而居，穴而处，故圣王作为宫室。为宫室之法，高足以避润湿，边足以圉风寒。宫墙之高，足以别男女之礼。谨此则止，不以为观乐也。故天下之人，财用可得而足也。当今之王为宫室则与此异矣。必厚敛于百姓以为宫室，台榭曲直之望，青黄刻镂之饰，为宫室若此，故左右皆法而象之。是以财不足以待凶饥，振孤寡，故国贫而难理也。为宫室不可不节。【议曰：此节宫室者。】</p>
<p>古之人未知为衣服，时衣皮带茭，冬则不轻而暖，夏则不轻而清。圣王以为不中人之情，故圣人作，诲妇人，以为人衣。为衣服之法，冬则练帛，足以为轻暖，夏则絺绤，足以为轻清，谨此则止，非为荣耳目，观于人也。是以其人用俭约而易治，其君用财节而易赡也。当今之王，其为衣服，则与此异矣。必厚敛于百姓，以为文彩靡曼之衣，铸金以为钩，珠玉以为佩。由此观之，其为衣服，非为身体，皆为观好耶。是以其人淫僻而难治，其君奢侈而难谏。夫以奢侈之君，御淫僻之人，欲国无乱，不可得也。为衣服不可不节。”【 议曰：此节衣服也。】</p>
<p>此墨翟之术也。【议曰：墨家之议，去奢节用，盖强本道。】</p>
<p>商子曰：“ 法令者，人之命也，为治之本。【慎子曰：” 君人者，舍法而以身治，则受赏者虽当，望多无穷；受罚者虽当，望轻无已。君舍法而以心裁轻重，怨之所由生也。是以分马者之用策，分田者之用钩，非以钩策为过人之智也，所以去私塞怨也。故曰：夫君任法而不躬为，则怨不生而上下和也。“ 】 一兔走，百人逐之，非以兔可分为百，由名分之未定也。卖兔满市，盗不敢取者，由名分已定也。故名分未定，虽尧舜禹汤，且皆加务而逐之。名分之定，则贫盗不敢取。故尧舜圣人之为法令也，置官也，置吏也，所以定分也。名分定则大诈贞信，巨盗原悫，而各自治也。” 【《尹文子》曰：“ 名定则物不竞，分明则私不行。物不竞，非无心，由名定，故无所措其心；私不行，非无欲，由分明，故无所措其欲。然则心欲人人有之，而得同于无心无欲者，在制之有道故也。” 】</p>
<p>申子曰：“ 君如身，臣如手，君设其本，臣操其末。为人君者，操契以责其名。名者，天地之网，圣人之符。张天地之网，用圣人之符，则万物无所逃矣。”</p>
<p>此商鞅、申、韩之术也。</p>
<p>【恒范曰：“ 夫商鞅申韩之徒，贵尚谲诈，务行苛刻。废礼义之教，任刑名之教，不师古，始败俗伤化。此则伊尹、周公之罪人也。然其尊君卑臣，富国强兵，守法持术，有可取焉。逮至汉兴，有宁成，郅都之辈，仿商、韩之治，专以杀伐残暴为能，顺人主之意，希旨之行，要时趋利，敢行败祸，此又商、韩之罪人也。然其抑强族，抚孤弱，清己禁奸，背私立公，亦有取焉。至于晚代之所谓能者，乃犯公家之法，赴私门之势，废百姓之务，趋人间之事，决烦理务，临时苛辩，使官无谴负之累，不省下人之冤，复是申、韩、宁、郅之罪人也。”】</p>
<p>由是观之，故知治天下者，有王霸焉，有黄老焉，有孔墨焉，有申商焉，此所以异也，虽经纬殊制，救弊不同，然康济群生，皆有以矣。今议者或引长代之法，诘救弊之言【议曰：救弊为夏人尚忠，殷人尚敬，周人尚文者】；或引帝王之风，讥霸者之政，不论时变，而务以饰说。故是非之论，纷然作矣。言伪而辩，顺非而泽，此罪人也。故君子禁之。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第二卷德行-德表</title>
    <url>/posts/9c3a31d9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>孔子曰：“性相近也，习相远也。” 言嗜欲之本同，而迁染之途异也。夫刻意则行不肆，牵物则其志流。是以圣人导人理性，裁抑流宕，慎其所与，节其所偏。故《传》曰：“ 审好恶，理情性，则王道毕矣。” 治性之道，必审己之所有余，而强其所不足。盖聪明流通者，戒于太察；寡言少见者，戒于壅蔽；勇猛刚强者，戒于太暴；仁爱温良者，戒于无断；湛静安舒者，戒于后时；广心浩大者，戒于遗忘。</p>
</blockquote>
<blockquote>
<p>此拘亢之材，非中庸之德也。</p>
</blockquote>
<blockquote>
<p>文子曰：“ 凡人之道，心欲小，志欲大，智欲圆，行欲方，能欲多，事欲少。” 所谓“心小”者，虑患未生，戒祸慎微，不敢纵其欲也；“ 志大” 者，兼包万国，一齐殊俗，是非辐辏，中之为毂也；“智圆” 者，终始无端，方流四远，深泉而不竭也；“行方”者，直立而不挠，素白而不污，穷不易操，达不肆志也；“能多” 者，文武具备，动静中仪也；“事少” 者，执约以治广，处静以待躁也。</p>
<p>夫天道极即反，盈即损。故聪明广智，守以愚；多闻博辩，守以俭；武力毅勇，守以畏；富贵广大，守以狭；德施天下，守以让。此五者，先王所以守天下也。</p>
<p>《传》曰：“无始乱，无怙富，无恃宠，无违同，无傲礼，无骄能，无复怒，无谋非德，无犯非义。“  此九言，古人所以立身也。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第二卷德行-臣行</title>
    <url>/posts/6feddce9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>没有细看，取其大略。</p>
<blockquote>
<p>夫人臣萌芽未动，形兆未见，昭然独见存亡之机，得失之要，豫禁乎未然之前，使主超然立乎显荣之处，如此者，圣臣也。</p>
<p>虚心尽意，日进善道，勉主以礼义，谕主以长策，将顺其美，匡救其恶，如此者，大臣也。</p>
<p>夙兴夜寐，进贤不懈，数称往古之行事，以厉主意，如此者，忠臣也。</p>
<p>明察成败，早防而救之，塞其间，绝其源，转祸以为福，君终己无忧，如此者，智臣也。</p>
<p>依文奉法，任官职事，不受馈赠，食饮节俭，如此者，贞臣也。</p>
<p>国家昏乱，所为不谀，敢犯主之严颜，而言主之过失，如此者，直臣也。</p>
<p>是谓六正。</p>
</blockquote>
<blockquote>
<p>安官贪禄，不务公事，与世沉浮，左右观望，如此者，具臣也。</p>
<p>主所言皆曰“善”，主所为皆曰“可”，隐而求主之所好而进之，以快主之耳目。偷合苟容，与主为乐，不顾后害，如此者，谀臣也。</p>
<p>中实险诐，外貌小谨，巧言令色，又心疾贤。所欲进则明其美，隐其恶；所欲退则彰其过，匿其美，使主赏罚不当，号令不行，如此者，奸臣也。</p>
<p>智足以饰非，辩足以行说，内离骨肉之亲，外妒乱于朝廷，如此者，馋臣也。</p>
<p>专权擅势，以轻为重；私门成党，以富其家；擅矫主命，以自显贵，如此者，贼臣也。</p>
<p>谄主以佞邪，坠主于不义，朋党比周，以蔽主明，使白黑无别，是非无闻；使主恶布于境内，闻于四邻，如此者，亡国之臣也。</p>
<p>是谓六邪。</p>
</blockquote>
<blockquote>
<p>议曰：夫圣人德全，器无不备。中庸已降，才则好偏。故曰：柴也愚，参也鲁，师也辟，由也喭。由此观之，全德者鲜矣！全德既鲜，则资矫情而力善矣！然世恶矫伪，而人贤任真。使其真贪愚而亦任之，可为贤乎？对曰：吁！何为其然？夫肖貌天地，负阴抱阳，虽清浊贤愚，其性则异，而趋走嗜欲，所规则同。故靡颜腻理，人所悦也；乘坚驱良，人所爱也；哭心贞节，人所难也；徇公灭私，人所苦也。不以礼教节之，则荡而不制，安肯攻苦食淡，贞洁公方，临财廉而取与义乎？故《礼》曰：”欲不可纵，志不可满。“ 古语云：” 廉士非不爱财，取之有道。“ 诗云：” 如切如蹉，如琢如磨。“ 皆矫伪之谓也。 若肆其愚态，随其鄙情，名曰任真而贤之，此先王之罪之也。故吾以为矫伪者，礼义之端；任真者，贪鄙之主。夫强仁者，庸可诬乎？</p>
</blockquote>
<blockquote>
<p>或曰：”长平之事，白起坑赵卒四十万，可为奇将乎？“</p>
<p>何晏曰：”白起之降赵卒，诈而坑其四十万，其徒酷暴之谓乎？ 后亦难以重得其志矣！ 向使众人预知降之必死，则张虚拳，犹可畏也。况于四十万披坚执锐哉？天下见降秦之将头颅依山，归秦之众骸积成丘，则后日之战，死当死耳，何众肯服，何城肯下乎？是为虽能裁四十万之命，而适足以强天下之战。欲以一期之功，而乃更坚诸侯之守。故兵进而自伐其势，军胜而还丧其计，何者？设使赵众复合，马服更生，则后日之战，必非前日之对也，况今皆使天下为后日乎！其所以终不敢复加兵于邯郸者，非但忧平原之补缝，患诸侯之救至也，徒讳之而不言耳。且长平之事，秦人十五以上，皆荷戟而向赵矣。夫以秦之强，而十五以上，死伤过半，此为破赵之功小，伤秦之败大也。又何称奇哉？“</p>
<p>议曰：黄石公称柔者能制刚，弱者能制强。柔者德也，刚者贼也。柔者人之所助，刚者怨之所居。是故纣之百克而卒无后，项羽兵强，终失天下。故随何曰：” 使楚胜，则诸侯自危惧而相救。夫楚之强，适足以致天下兵耳。“ 由是观之，若天下已定，借一战之胜，诈之可也。若海内纷纷，雌雄未决而失信于天下，败亡之道也。当亡国之时，诸侯尚强，而白起乃坑赵降卒，使诸侯畏之而合纵。诸侯合纵，非秦之利，为战胜而反败。何晏之论当矣。</p>
</blockquote>
<p>有意思！长平之战或胜于军事，但输于政治。</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第八卷杂说-诡信</title>
    <url>/posts/e52a7502/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>【议曰：“ 代有诡诈反为忠信者也。” 抑亦通变，适时所为、见机而作而不俟终日者。】</p>
<p>孔子曰：“ 君子贞而不谅。” 又曰：“ 近逝于义，言可复也。” 由是观之，唯义所在，不在信也。【议曰：微哉！微哉！天下之事也，不有所废则无以兴。若忠于斯，必不诚于彼，自然之理矣。由是观之，则我之所谓忠，则彼之所谓诈也。然则忠之与诈，将何所取定哉？抑我闻之：夫臣主有大义，上下有定分，此百代不易之道也。故欲行忠，观臣主之义定；欲行信，顾上下之分明。苟分义不愆于躬，虽谲而不正可也。】何以明之？</p>
<p>叶公问孔子曰：“ 吾党有直躬者，其父攘羊而其子证之。” 孔子曰：“ 吾党之直者异于是，父为子隐，子为父隐，直在其中矣。”</p>
<p>楚子围宋，宋求救于晋。晋侯使解扬如宋，使无降楚，曰：“ 晋师悉起，将至矣。” 郑人囚而献诸楚，楚子厚赂之，使反其言。许之。登诸楼车，使呼宋人而告之，遂致其君命。楚子将杀之，使与之言曰：“ 尔既许不谷而反之，何故？非我无信，尔其弃之，速即尔刑！” 对曰：“ 臣闻之，君能制命为义，臣能承命为信。信载义而行之有利，谋不失利，以卫社稷，民之主也。义无二信，信无二命。君之赂臣，不知命也。受命以出，有死无殒，又何赂乎？臣之许君，以成命也。死而成命，臣之禄也！寡君有信臣，下臣获考，死又何求！” 楚之舍之以归。</p>
<p>【韩子曰：“ 楚有直躬者，其父窃羊而讦之，令尹曰：” 必杀之！“ 以为直于君而曲于父，执其子而罪之。由是观之，夫君之直臣，父之暴子也。鲁人从君战，三战三北，仲尼问其故，对曰：” 吾有老父，死莫之养也。“ 仲尼以为孝，誉而用之。以是观之，夫父之孝子，君之北人也。故令尹诛而楚奸不止，闻仲尼赏之，鲁人易降。此上下之利，若是其异也，而人主兼誉匹夫之行，而求致社稷之福，必不几矣。】</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第八卷杂说-钓情</title>
    <url>/posts/ed6fb8cc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>孔子曰：“ 未见颜色而言曰瞽”，又曰：“ 未信则以为谤己。” 孙卿曰：“ 语而当，智也，默而当，智也。” 尸子曰：“ 听言，耳目不惧，视听不深，则善言不往焉。” 是知将语者，必先钓于人情，自古然矣。</p>
<p>韩子曰：“ 夫说之难也，在知所说之心可以吾说当之。说之以厚利，则见下节而遇 卑贱，必弃远矣【所说实为厚利则阴用其言而显弃其身，此不可不知也】。说之以名高，则见无心而远事情，必不收矣【所谓实为名高而阳收其身而实疏之。此不可不知也】。事以密成，语以泄败，未必其身泄之也，而说及其所匿之事，如是者身危【周泽未渥也，而语极知，说行而有功则德亡，说不行而有败则见疑，如是者身危】。贵人有过端，而说者明言善议以推其恶者身危。贵人或得计而欲自己为功，说者与知焉则身危。强之以其所不为，止之以其所不能已者身危。“ 又曰：” 与之论大人，则以为间己，与之论细人，则以为鬻权。论其所爱，则以为借资，论其所憎，则以为尝已。顺事陈意则曰怯懦而不尽，虑事广肆，则曰草野而居侮，此不可不知也……彼自智其计，则勿以其失当之，自勇其断，则勿以其敌怒之。“ 【凡说须旷日弥久，周泽而不凝，交争而不罪，乃明计利害，以致其功。直指是非，以饰其身。以此相持，此说之成也。】</p>
<p>荀悦曰：” 夫臣下所以难言者，何也？言出乎身则咎悔及之矣。“ 故曰：举过揭非，则有干忤之咎，劝励教诲，则有侠上之议。言而当，则耻其胜己也，言而不当，则贱其愚也。先己而同，则恶其夺己明也，后己而同，则以为从顺也。违下从上，则以为谄谀也，违上从下，则以为雷同也。言而浅露，则简而薄之，深妙弘远，则不知而非之。特见独智，则众恶其盖己也，虽是而不见称，与众同智，则以为附随也，虽得之不以为功。谦让不争，则以为易容，言而不尽，则以为怀隐，进说竭情，则以为不知量。言而不效，则受其怨责，言而事效，则以为固当。利于上不利于下，或便于左则不便于右，或合于前而忤于后，此下情所以常不通。仲尼发愤，称”予欲无言“者，盖为语之难也。何以明其难也？</p>
<p>昔宋有富人，天雨坏墙，其子曰：” 不筑，且有盗。“ 其邻人亦云。暮而果大亡，其家智其子而疑邻人之父。郑武公欲伐胡，乃以其子妻之，因问群臣：” 吾欲用兵，谁可伐者？“ 关其思曰：” 胡可伐。“ 乃戮关其思，曰：” 胡，兄弟之国也，子言伐之，何也？“ 胡君闻之，以为郑为亲己而不备郑，郑人袭胡，取之。此二说者，其智皆当矣，然而甚者为戮，薄者见疑，非智之难也，处智则难。</p>
<p>卫人迎新妇，妇上车，问：” 骖马，谁马也？“ 御者：” 借之。“ 新妇谓仆曰：” 拊骖，无苦服。“ 车至门，拔教：” 逆母，灭橹，将失火。“ 入室，见臼，曰：” 徙牖下，妨往来者。“ 主人大笑之。此三言，皆要言也，然而不免为笑者，早晚之时失矣。此说之难也。</p>
<p>说者知其难也，故语必有钓，以取人情。何以明之？</p>
<p>昔齐王后死，欲置后而未定，使群臣议。薛公田婴欲中王之意，因献其珥而美其一，旦日因问美珥所在，因劝立以为后，齐王大悦，遂重薛公。此情可以物钓也。</p>
<p>申不害始合于韩王，然未知王之所欲也，恐言而未必中于王也。王问申子曰：“吾谁与而可？” 对曰：“ 此安危之要，国家之大事也，臣请深惟而苦思之。” 乃微请赵卓、韩冕曰：“ 子，皆国之辩士也，夫为人臣者，言何必同？尽忠而已矣。” 二人各进议于王以事。申子微视王之所悦，以言于王，王大悦之。此情可以言钓也。</p>
<p>吴伐越，越栖于会稽，勾践喟然叹曰：“吾终此乎？” 大夫种曰：“汤系夏台，文王囚姜里，重耳奔翟，齐小白奔莒，其卒霸王。由是观之，何遽不为福乎？” 勾践既得免，务报吴。大夫种曰：“ 吾观吴王政骄矣，请尝之。” 乃贷粟以卜其事。子胥谏勿与，王遂与之。子胥曰：“ 王不听谏，后三年，吴其墟矣！” 太宰嚭闻之，馋曰：“ 伍员貌忠而实忍人。” 吴杀子胥，此情可以事钓也。</p>
<p>客以淳于髡见梁惠王，惠王屏左右，再见之，终无言，王怪之，让客。客谓淳于髡，髡曰：“ 吾前见王，王志在驰逐，后复见王，王志在音色，是以默然。” 客具以报王，王大骇曰：“ 淳于先生，诚圣人也。前有善献马者，寡人未及试，会生来。后有献讴者，未及试，又会生至。寡人虽屏人，然私心在彼。” 此情可以志钓也。</p>
<p>智伯从韩魏之君伐赵，韩魏用赵臣张孟谈之计，阴谋叛智伯。张孟谈因朝智伯，遇智果于辕门之外。智果入见智伯，曰：“ 二主殆将有变，臣遇张孟谈，察其志矜而行高，见二君色动而变，必背君矣。” 智伯不从，智果出，遂更其姓曰辅氏。张孟谈见赵襄子曰：“ 臣遇智果于辕门之外，其视有疑臣之心。入见智伯而更其族，今暮不击，必后之矣。” 襄子曰：“诺！” 因与韩魏杀守堤之吏，决水灌智伯军，此情可以视钓也。</p>
<p>殷浩仕晋，有盛名，时人观其出处，以卜江左兴亡，此情可以贤钓也。【 《吕氏春秋》曰：“ 夫国之将亡，有道者先去。”】</p>
<p>【《易》曰：“将叛者，其辞惭，中心疑者，其辞枝。吉人之辞寡，躁人之辞多。诬善之人，其辞游，失其守者，其辞屈。” 】</p>
<p>由是观之，夫人情必见于物。【昔者晋公好色，骊姬乘色以壅之。吴王好广地，太宰陈伐以壅之。桓公好味，易牙蒸子以壅之。沉冥无端，甚可畏也。故知人主之好恶，不可见于外。所好恶见于外，则臣妾乘其所好恶以行壅制焉。故曰：人君无意见则为下饵。此之谓也。】能知此者，可以纳说于人主矣。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>只只和男朋友</title>
    <url>/posts/ac7827ff/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录只只和男朋友的日常。</p>
<span id="more"></span>
<center>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=544056531&auto=1&height=66"></iframe>
</center>
<h1>我们的时间线</h1>
<p>2007年左右：初识</p>
<p>2021年2月16日：再次见面</p>
<p>2021年3月4日22时11分 ： 确定恋爱关系</p>
<p>2021年3月25日：只只的第一次生气</p>
<p>2021年4月3日： 确定恋爱关系后第一次见面</p>
<p>2021年4月9日23时：只只第一次为我哭泣</p>
<p>……</p>
<h1>我们的语录</h1>
<blockquote>
<p>时间 不详</p>
<p>只只：谈恋爱不就和吃饭喝水一样嘛</p>
</blockquote>
<blockquote>
<p>时间 2021年3月2日</p>
<p>周周：那怎么称呼？</p>
<p>只只：啊？我没想过 我朋友都叫我全名</p>
<p>只只：你简直问到我了</p>
<p>周周：茴茴？哈哈哈</p>
<p>只只：啊 我不知道唉 因为我们口音不一样啊</p>
</blockquote>
<blockquote>
<p>时间 2021年3月3日</p>
<p>只只：不过我们现在算什么关系啊</p>
<p>只只：****聊天？哈哈哈</p>
<p>周周：浅了</p>
<p>周周：不行</p>
<p>……</p>
<p>只只：那你要好好追我哦</p>
<p>只只：哈哈哈</p>
<p>周周：好哦</p>
<p>只只：那就改变称呼吧</p>
<p>只只：叫我只只</p>
</blockquote>
<blockquote>
<p>时间 2021年3月4日</p>
<p>只只：小周 小周</p>
<p>只只：你怎么还不出现啊</p>
<p>只只：给你10分钟哦</p>
<p>六分钟后</p>
<p>周周：出现了，出现了</p>
<p>周周：刚刚洗澡去了</p>
<p>只只：哈哈哈</p>
<p>……</p>
<p>只只：那你有啥要问我的</p>
<p>周周：没有啥要问的</p>
<p>只只：公平起见 我之前问了你的 现在到你了</p>
<p>只只：那好吧</p>
<p>周周：我不问，你也会说的</p>
<p>周周：何必费那事</p>
<p>……</p>
<p>只只：那就今天开始谈恋爱吧</p>
<p>周周：先恋爱后追求啊</p>
<p>只只：反正你表白了</p>
<p>只只：嗯嗯</p>
<p>周周：我们好特殊啊</p>
<p>时间：2021年4月9日</p>
<p>只只：刚刚我们生气的时候</p>
<p>只只：就我哭的时候</p>
<p>只只：我突然想到如果你不是我男朋友了</p>
<p>只只：我就好难过</p>
<p>周周：你这么说，我就好很多了。比你说的有点应该强一千万倍。</p>
<p>只只：因为你刺激到我了</p>
<p>只只：我的感觉一下就出来了</p>
<p>只只：之前抑制的感情一下就出来了</p>
<p>时间：2021年4月10日</p>
<p>只只：我喜欢喝甜甜的东西</p>
<p>周周：就像我们的恋爱吗？</p>
<p>……</p>
<p>只只：我对你的感觉是安全感，信任感，成熟感。有时候会想和你聊天，会想和你分享，有时候会想你。</p>
<p>周周：那这不是喜欢是什么</p>
<p>只只：是</p>
<p>周周：嗯？</p>
<p>只只：是</p>
<p>周周：是什么？</p>
<p>只只：你的结论是对的</p>
<p>周周：把我的结论再说一遍</p>
<p>只只：是喜欢</p>
<p>周周：主谓宾，把主语和宾语加上</p>
<p>只只：我喜欢你</p>
<p>周周：我也喜欢你</p>
<p>时间：2021年4月14日</p>
<p>周周：如果你驯养了我，我们就互相不可缺少了。对我来说，你就是世界上唯一的了；我对你来说，也是世界上唯一的了。</p>
<p>只只：驯养是相互的，不是单方向的，是双方向的。你驯养了我，我也驯养了你。</p>
<p>只只：温暖是互相给的。</p>
</blockquote>
<h1>我们一起做的事</h1>
<h2 id="电影《悬崖之上》-2021年5月万年">电影《悬崖之上》-2021年5月万年</h2>
<p><img src="movie1.jpg" alt=""></p>
<h1>我们的相册</h1>
<h2 id="仙女湖之旅-2021年4月新余">仙女湖之旅-2021年4月新余</h2>
<p>仙女湖位于新余，誉为“中国七夕情人节”的发源地。我和只只上午去的，可是等滴滴就等了一个小时……</p>
<p>门口有很多小花花，还有很多风车。</p>
<p><img src="xiannvhu3.jpg" alt=""></p>
<p><img src="xiannvhu6.jpg" alt=""></p>
<p>逛的时候发现的“鹊桥”</p>
<p><img src="xiannvhu4.jpg" alt=""></p>
<p>里面有一些书法，勉强能看懂，都是一些情诗。</p>
<p><img src="xiannvhu1.jpg" alt=""></p>
<p><img src="xiannvhu7.jpg" alt=""></p>
<p>然后，最最重要的是，我们一块买了四只说不上名字的鸟，只只一开始说是企鹅，确实有一点像，毕竟都是圆鼓鼓的。左边那两只现在在只只那里，我们起名叫 “周大胖”，“周小胖”；右边那两只现在在我这，我们起名叫“程大胖”，“程小胖”。哈哈哈！</p>
<p>不过，这四只胖胖以后还是会放在一块的。</p>
<p><img src="xiannvhu5.jpg" alt=""></p>
<p>在景区吃的饭，仙女湖的鱼和藕条。我们一致觉得鱼不行，但我觉得藕条还行。悄悄地说一句，某人只要觉得不好吃就吃得很少，难养哦。</p>
<p><img src="xiannvhu2.jpg" alt=""></p>
<p>我走的那天送只只的玫瑰。周边其实没有花店，当时正好碰到了一个花店老板给别人送花，我就叫住了她，买了一束花，让她送过来。</p>
<p><img src="xiannvhu8.jpg" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>序 - 构建个人博客的原因和过程</title>
    <url>/posts/7ce416b6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>为什么开通个人博客？</h1>
<p>我在B站关注了一位up主，名字叫codesheep（程序羊），他是华科出来的硕士（自称”资质平平“，感觉自己都不用活了）。自称看了他的视频，才产生了构建个人博客的想法。我看他宣传开通个人博客的视频，应该是在去葫芦岛旅游前（2019年7月27号）。按照大佬的说法，开通个人博客，有百利而无一害，比如避免自己重复掉坑、能够吸引一点关注、可能对其他人有帮助、结交同性朋友等。我想了想，感觉说得都很对，我没办法反驳，心里就种下了种子。等从葫芦岛回来，有空余时间的时候就可以动手做了。<br>
本科毕业的时候，我从一件事情上吸取到了一个教训。那时候我发现我有很多买回来的书，就一直放着，很多都没看，就一直放着，直到毕业。最后，我感觉实在有点累赘，就或卖或送打发了。这些买回来的书，如果一开始没去看，可能我永远都不会去翻他。其他事情应该也是一样的吧。对于想做的事，一开始不着手去做的话，这辈子都不会做了吧。毕竟，一辈子其实想想也没有多长。</p>
<h1>开通个人博客的过程</h1>
<p>当时好像程序羊还没有发布详细的构建个人博客的视频，我就从知网找了个教程，看着比较详细，那上面第一步就说要有个域名。然后，我就去了阿里云上去查找注册域名，本来想注册自己的名字 <a href="https://www.zhouzw.com">zhouzw</a>，没想到已经被注册了。然后我就不知道用啥英文了，毕竟我没有正儿八经起过英文名。我就找到了我的词汇课的课件，第一个词根是-vict（胜利的意思），一查也被注册了。后面对这个词根的注解上说，来自于希腊语vincere，就用了这个不是英文单词的词。之后我发现阿里云上域名都是按年买的，我感觉这是不是坑我（我刚开始以为应该是注册了就是终生的）。谷歌了一下，才发现域名都是按年买的，逾期不付费会回收，尴尬。为什么选.fun这个后缀呢，当然是希望自己开开心心（假的，因为便宜，我一次性买了10年才花了179，<a href="http://xn--6iq8fuf485iowl.com">相比于什么.com</a>,.cn这种正规后缀，真的是好便宜！)<br>
然后按照知乎的流程去走（其实什么软件、命令都不懂），从4点到了将近7点（我一般5点多去吃饭），并没有弄通。整个人就有点不太好，虽然其实也没搞多长时间。后来又是看了程序羊的视频，才算是最终构建好了。  搭建好了个人博客，当时发了个微信。然后到现在又过了一个多礼拜，这期间主要是其它事和学习shell编程啥的。我总是想先把手头的东西弄完或学完，再弄别的事。然后就一直到了今天。</p>
<h1>用个人博客做什么</h1>
<p>现在初步打算把自己一年多的学习的东西，总结提取重点，发到这个个人博客上来。当然都是一些很基础的东西。参考别人的博客，我对我这个博客的设定为总结，总结自己学习的东西，总结自己遇到的坑，总结一些实践经验（如果有的话），偶尔总结一下自己矫情的感想。</p>
]]></content>
  </entry>
  <entry>
    <title>微积分课程第二部分学习笔记</title>
    <url>/posts/9e4272e7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是微积分课程的第二部分，后面还有，但是我没有做笔记了。</p>
<p>这里是微积分的<a href="https://vincere.fun/posts/b445140c/">第一部分笔记</a>，微积分第二部分的资料见<a href="https://tutorial.math.lamar.edu/Classes/CalcII/CalcII.aspx">官网</a></p>
<span id="more"></span>
<h1>Intergration Techniques</h1>
<p><img src="parts1.png" alt=""></p>
<p><img src="parts2.png" alt=""></p>
<p><img src="parts3.png" alt=""></p>
<h2 id="Integrals-involving-trig-functions">Integrals involving trig functions</h2>
<p><img src="trigs1.png" alt=""></p>
<p><img src="trigs2.png" alt=""></p>
<p>关于tan(x) 和 sec(x) 的关系</p>
<p><img src="trigs3.png" alt=""></p>
<p><img src="trigs6.png" alt=""></p>
<h2 id="Trig-Substitutions">Trig Substitutions</h2>
<p>将正常函数转化为三角函数。如下例</p>
<p><img src="trigs5.png" alt=""></p>
<p><img src="trigs7.png" alt=""></p>
<p><img src="trigs8.png" alt=""></p>
<h2 id="Partial-Fractions">Partial Fractions</h2>
<p>对于分母与分子都是二项式的式子，如果<strong>分子的最高项低于分母</strong>，可以将这个式子先进行分解，再积分。、</p>
<p>下面这个图没看懂？</p>
<p><img src="parts4.png" alt=""></p>
<p><img src="parts5.png" alt=""></p>
<h2 id="Integrals-Involving-Roots">Integrals Involving Roots</h2>
<p><img src="parts6.png" alt=""></p>
<h2 id="Integrals-involving-quadratics">Integrals involving quadratics</h2>
<p>如果有不符合以上规则的多项式（最多为二次）（即首先分子不是分母导数的倍数；分母不能因式分解），还想要使用三角函数。那么就需要先提取出x 的平方的函数。如下。</p>
<p><img src="parts7.png" alt=""></p>
<h2 id="Integration-Strategy">Integration Strategy</h2>
<h2 id="Imporper-Integrals">Imporper Integrals</h2>
<h3 id="Infinite-interval">Infinite interval</h3>
<p>当定积分的一侧或两侧是无穷大时，正确的做法用一个字母代替无穷大，然后求其极限值。</p>
<p><img src="parts8.png" alt=""></p>
<p>如果这种积分<strong>存在</strong>并且是一个常数，我们就说这个被积变量是<strong>convergent</strong>；反之，如果积分<strong>不存在</strong>或是<strong>无穷大</strong>，那么我们就说这个被积变量是<strong>divergent</strong>。</p>
<h3 id="Distontinuous-Integrand">Distontinuous Integrand</h3>
<p><img src="parts9.png" alt=""></p>
<p><img src="parts10.png" alt=""></p>
<h2 id="Comparison-Test-for-Improper-Integrals">Comparison Test for Improper Integrals</h2>
<p>如果不容易求积分，可以通过下面这个式子判断函数是否<strong>coverge</strong>。</p>
<p><img src="parts11.png" alt=""></p>
<p>很容易理解，因为积分是面积。</p>
<h2 id="Approximating-Definite-Integrals">Approximating Definite Integrals</h2>
<p>不是所有的被积变量都能求出原函数。因此有时需要<strong>近似估计定积分</strong>的值。</p>
<p>就是把定积分看成是<strong>求面积</strong>的问题。</p>
<h3 id="Midpoint-Rule">Midpoint Rule</h3>
<p>将[a,b]区间平均取n等分，每个小区间取<strong>中间点</strong>的值作为每个<strong>小矩形</strong>的高。</p>
<p><img src="parts12.png" alt=""></p>
<h3 id="Trapezoid-Rule">Trapezoid Rule</h3>
<p>一样是n等分，不同是算每个<strong>梯形</strong>的面积。</p>
<p><img src="parts13.png" alt=""></p>
<p><img src="parts14.png" alt=""></p>
<h3 id="Simpson’s-Rule">Simpson’s Rule</h3>
<p>同上 n等分。不过n必须为<strong>偶数</strong>。</p>
<p>类似于上一条，不过上一条是取直线。而这里是每两个区间（有3个点），求其<strong>二次式</strong>。这里用的是曲线。</p>
<p><img src="parts15.png" alt=""></p>
<p>下面每两个区间的面积不知道是咋推的。（未证明）</p>
<p>我不知道三条边是直线，一条边是曲线，怎么求面积。</p>
<p><img src="parts16.png" alt=""></p>
<p>这三种方法中，第三种方法一般<strong>误差最小</strong>。</p>
<h1>Applications of Integrals</h1>
<h2 id="Arc-length">Arc length</h2>
<p><img src="arc1.png" alt=""></p>
<h2 id="Surface-Area">Surface Area</h2>
<p>求旋转体的表面积。由于没有看Calculus I 的求旋转体的体积，因此跳过。</p>
<h2 id="Center-of-Mass">Center of Mass</h2>
<p>求平均分布的薄板的质心。就是只支撑这一点能维持水平的地方。</p>
<p>公式没看懂。首先假设这个物体的上下边缘分别是一个函数。</p>
<p><img src="mass1.png" alt=""></p>
<p><img src="mass2.png" alt=""></p>
<p><img src="mass3.png" alt=""></p>
<h2 id="Hydrostatic-Pressure-and-Force">Hydrostatic Pressure and Force</h2>
<p>涉及流体力学。求流体静力，貌似是等于水压乘面积。但是水压随着水深的变化而变化，因此需要用到微积分。</p>
<p>自己推理计算，对了。</p>
<p>但是不严谨，没有严格按照定积分的公式。</p>
<h2 id="Probability">Probability</h2>
<p>根据概率密度曲线，求连续分布的随机变量在某区间取值的概率。</p>
<p><img src="prob1.png" alt=""></p>
<p><img src="prob2.png" alt=""></p>
<h1>Parametric Equations and Polar Coordinates</h1>
<h2 id="Parametric-Equations-and-Curves">Parametric Equations and Curves</h2>
<p>有的时候，我们得不到 y = f(x) 或 x = h(y) 这两种形式的函数。例如圆的式子。但是有时我们可以得到一个 x = f(t) 和 y = g(t) 的形式。根据t 的定义域，每一个t，就能得到一个点(f(t),g(t))。这些点连起来得到的曲线就是<strong>parametric curve</strong>。</p>
<p>注意 parametric curve 是有方向的，是t 不断增大的方向。</p>
<h2 id="Tangents-with-Parametric-Equations">Tangents with Parametric Equations</h2>
<p><img src="tang1.png" alt=""></p>
<p>感觉这个式子，可以用速度的例子。一个是水平的运动，一个是竖直方向的运动。</p>
<p><img src="tang2.png" alt=""></p>
<p><img src="tang3.png" alt=""></p>
<p><img src="tang4.png" alt=""></p>
<h2 id="Area-with-Parametric-Equations">Area with Parametric Equations</h2>
<p>求面积（积分），设 x = f(t) ; y = g(t)</p>
<p><img src="area1.png" alt=""></p>
<h2 id="Arc-Length-with-Parametric-Equations">Arc Length with Parametric Equations</h2>
<p>推导省略，下面少了一个条件，即 dx/dt &gt; 0 。即 t 要保持从左往右走。</p>
<p><img src="arc2.png" alt=""></p>
<p>不如用原来的函数。</p>
<p><img src="arc3.png" alt=""></p>
<p>懂了，如果<strong>不考虑方向</strong>（也就是路程，而不是位移），那么可以直接用省略的公式。考虑方向，那么省略公式如果 dx/dt &gt; 0 时用原公式，如果 dx/dt &lt; 0 时原公式加一个负号。</p>
<h2 id="Surface-Area-with-Parametric-Equations">Surface Area with Parametric Equations</h2>
<p>求Parametric Curve 旋转体的表面积。之前这部分没看，跳过。</p>
<h2 id="Polar-Coordinates">Polar Coordinates</h2>
<p><img src="polar1.png" alt=""></p>
<h3 id="Area-with-Polar-Coordinates">Area with Polar Coordinates</h3>
<p><img src="polar2.png" alt=""></p>
<p>应该是根据了圆弧求面积的公式。利用积分的思想。</p>
<p><img src="polar3.png" alt=""></p>
<p>注意：定积分中的 α 和 β ，要保持顺时针转动。</p>
<h3 id="Arc-Length-with-Polar-Coordinates">Arc Length with Polar Coordinates</h3>
<p>这里指的还是单纯的长度，不看方向。所以一直用的是 ds。</p>
<p><img src="polar4.png" alt=""></p>
<h3 id="Surface-Area-with-Polar-Coordinates">Surface Area with Polar Coordinates</h3>
<p>没看</p>
<h1>Series &amp; Sequence</h1>
<p><img src="seq1.png" alt=""></p>
<p>如果当n 趋于无穷，序列极限存在且为定值，那么我们就说这个序列是<strong>convergent</strong>；如果序列极限<strong>不存在</strong>或极限是<strong>无穷</strong>，那么我们就说这个序列是<strong>divergent</strong>。</p>
<p>求序列极限的方法</p>
<p><img src="seq2.png" alt=""></p>
<p>根据函数极限性质，推导出以下序列极限的特性。</p>
<p><img src="seq3.png" alt=""></p>
<p><img src="seq4.png" alt=""></p>
<p>注意：下面的定理2 只有在极限为0时适用。</p>
<p><img src="seq5.png" alt=""></p>
<p><img src="seq6.png" alt=""></p>
<p>下面这个定理很好证。n 只能取奇数和偶数，而奇数和偶数都为L。那么这个序列的极限就肯定是L了。</p>
<p><img src="seq7.png" alt=""></p>
<h2 id="More-on-Sequences">More on Sequences</h2>
<p><img src="seq8.png" alt=""></p>
<p><img src="seq9.png" alt=""></p>
<h2 id="Series-The-Basics">Series - The Basics</h2>
<p>没搞清楚这个series 的概念。</p>
<p><img src="seq10.png" alt=""></p>
<p>series 好像仅仅是一个数。懂了，其实series 只是上图中的 Sn。图里仅仅是推导步骤。</p>
<p><img src="seq11.png" alt=""></p>
<p>这个定理只是说 an 的极限为0 是其收敛的必要条件，并不是说 an 极限为0 就一定会收敛。</p>
<p><img src="seq12.png" alt=""></p>
<p>下面这个定理，很简单。就是从逻辑学里转换过来。</p>
<p><img src="seq13.png" alt=""></p>
<h2 id="Special-Series">Special Series</h2>
<p>后面的很多都是高中知识。</p>
<p>Integral Test 条件是 an 必须递减且为正数。</p>
<p><img src="series1.png" alt=""></p>
<p>通过相同函数的积分只能看是否收敛，而不能求出series的<strong>值</strong>。</p>
<p><img src="series2.png" alt=""></p>
<p><img src="series3.png" alt=""></p>
<p><img src="series4.png" alt=""></p>
<p><img src="series5.png" alt=""></p>
<h2 id="Absolute-Convergence-Divergence">Absolute Convergence/Divergence</h2>
<p><img src="series6.png" alt=""></p>
<p><img src="series7.png" alt=""></p>
<p>下面这条未证明</p>
<p><img src="series8.png" alt=""></p>
<h2 id="Ratio-Test">Ratio Test</h2>
<p><img src="series9.png" alt=""></p>
<h2 id="Root-Test">Root Test</h2>
<p><img src="series10.png" alt=""></p>
<p>下面未证明</p>
<p><img src="series11.png" alt=""></p>
<h2 id="Strategy-for-Series">Strategy for Series</h2>
<h2 id="Estimating-the-Value-of-a-Series">Estimating the Value of a Series</h2>
<p>计算 Series 的值很多时候很困难，因此这里是<strong>估计</strong>Series 的值。而且下面都需要指定 n 的大小，其实就是说把 1(0) - n 的 sn 视为真值(?) ，后面的 Rn 视为误差项(?) 。</p>
<p>如果 an 一直是正数且递减</p>
<p><img src="series12.png" alt=""></p>
<p>这里的n 越大，就越准。</p>
<h3 id="Comparison-Test">Comparison Test</h3>
<p><img src="series13.png" alt=""></p>
<p>这种估计的准确性，取决于你使用的用于对比的函数。</p>
<h3 id="Alternating-Series-Test">Alternating Series Test</h3>
<p>没看懂，没证明。</p>
<p><img src="series14.png" alt=""></p>
<h3 id="Ratio-Test-2">Ratio Test</h3>
<p>这里需要假设series terms （即 an）都是正数。而且series 收敛，即 L &lt; 1。</p>
<p><img src="series15.png" alt=""></p>
<p><img src="series16.png" alt=""></p>
<h2 id="Power-Series">Power Series</h2>
<p><img src="series17.png" alt=""></p>
<p><img src="series18.png" alt=""></p>
<h2 id="Power-Series-and-Functions">Power Series and Functions</h2>
<p><img src="series19.png" alt=""></p>
<p><img src="series20.png" alt=""></p>
<p><img src="series21.png" alt=""></p>
<p>这节有点不会用</p>
<h2 id="Taylor-Series">Taylor Series</h2>
<p>泰勒公式的 a 是自己给的，而且只是<strong>假设</strong> f(x) 可以转化为 下面的这个 series。</p>
<p>我懂了，泰勒公式里的a 取啥值都行，都成立，不过 一般取a=0 更简单。</p>
<p>泰勒公式不过是把一个函数换成了一个series。</p>
<p><img src="series22.png" alt=""></p>
<p>如果将 a 设为0 ，即得到下面这个式子。</p>
<p><img src="series23.png" alt=""></p>
<p>下面的式子没看懂，貌似是求收敛的区间？</p>
<p><img src="series24.png" alt=""></p>
<p>几个重要的泰勒公式（a=0）</p>
<p><img src="series25.png" alt=""></p>
<h2 id="Applications-of-Series">Applications of Series</h2>
<ol>
<li>当原函数不能直接求积分时，可以使用泰勒公式进行<strong>转换</strong>。</li>
<li>使用<strong>n阶泰勒公式</strong>近似估计函数值。</li>
</ol>
<h2 id="Binomial-Series">Binomial Series</h2>
<p><img src="series26.png" alt=""></p>
<p>下面的定理没有证明，没看懂。（k是任意数，比如k=0.5,下面的阶乘怎么算的）</p>
<p><img src="series27.png" alt=""></p>
<h1>Vectors</h1>
<h2 id="Vectors-The-Basics">Vectors - The Basics</h2>
<p>向量只需要<strong>大小</strong>和<strong>方向</strong>，和起始位置<strong>无关</strong>。所以下图都是<strong>同一向量</strong>。</p>
<p><img src="vector1.png" alt=""></p>
<p><img src="vector2.png" alt=""></p>
<h3 id="Dot-Product">Dot Product</h3>
<p><img src="vector3.png" alt=""></p>
<p>下面这个式子往往用于求两向量的<strong>夹角</strong>，多维同样适用。</p>
<p><img src="vector4.png" alt=""></p>
<h3 id="projections-（投影）">projections （投影）</h3>
<p>b向量 在 a 向量的投影为：</p>
<p><img src="vector5.png" alt=""></p>
<p><img src="vector6.png" alt=""></p>
<h3 id="Direction-Cosines">Direction Cosines</h3>
<p>三维空间下，向量与x , y , z 轴形成的夹角的cosine。</p>
<p><img src="vector7.png" alt=""></p>
<p>下面均易证</p>
<p><img src="vector8.png" alt=""></p>
<h2 id="Cross-Product">Cross Product</h2>
<ul>
<li>点乘的结果是一个<strong>标量</strong></li>
<li>叉乘的结果是一个<strong>向量</strong></li>
</ul>
<p><img src="vector9.png" alt=""></p>
<p>实际是3×3的行列式的结果</p>
<p><img src="vector10.png" alt=""></p>
<p><img src="vector11.png" alt=""></p>
<p>叉乘的大小和方向如下：（方向符合**右手准则，**从a到b旋转）</p>
<p><img src="vector12.png" alt=""></p>
<p><img src="vector13.png" alt=""></p>
<p>从图可知，叉乘<strong>垂直</strong>于两个向量，或者说垂直这两个向量构成的平面。</p>
<p>如果 a 和 b 平行（夹角为0或180度）, 那么其叉乘大小为0，即为0向量。</p>
<p><img src="vector14.png" alt=""></p>
<p><img src="vector15.png" alt=""></p>
<p>下面的性质不太懂，未证明</p>
<p><img src="vector16.png" alt=""></p>
<h3 id="叉乘的几何性质">叉乘的几何性质</h3>
<p>叉乘本身是两个向量形成的平行四边形的<strong>面积</strong></p>
<p>但是下面的<strong>体积</strong>计算没看懂</p>
<p><img src="vector17.png" alt=""></p>
<h1>3-Dimensional Space</h1>
<h2 id="Equations-of-Lines">Equations of Lines</h2>
<p><img src="vector18.png" alt=""></p>
<p><img src="vector19.png" alt=""></p>
<p>另一种形式</p>
<p><img src="vector20.png" alt=""></p>
<h2 id="Equations-of-Planes">Equations of Planes</h2>
<p>n向量是法线（normal vector）</p>
<p><img src="vector21.png" alt=""></p>
<p><img src="vector22.png" alt=""></p>
<p><img src="vector23.png" alt=""></p>
<h2 id="Quadric-Surfaces">Quadric Surfaces</h2>
<p>没细看。</p>
<p>351页后都没看。2020年前就先到这了。我看calculus Ⅲ还涉及这一部分，估计之后还得看。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建个人博客</title>
    <url>/posts/c442673f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>尚未整理……</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>说文解字第一册笔记</title>
    <url>/posts/27938e11/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>果然是书非借不能读也。说文解字这一套书买来就没怎么看过了。哈哈哈，类似了买了健身卡就感觉自己锻炼了一样。</p>
<p><strong>才</strong>：<br>
才，草木之初也。<br>
象形字，上面一横表示土地，植物嫩芽刚刚出土而枝叶尚未出土的样子。<br>
原义是草木初生。延申为木料或木料的质性，人或物的质性。</p>
<p><strong>奉</strong>：<br>
奉，承也。<br>
金文似用双手捧着禾麦奉献给神祖之行，会向神祖拜祭祷告、祈求丰收之意。</p>
<p><strong>与</strong>：<br>
与，赐予也。一勺为与。<br>
一双手把器物交给一双手的意思。<br>
原义是赐给、给予。授人以物，除了是对对方的肯定之外，甚至还可能想跟对方结交，所以延申出赞许、嘉奖、交往、结交之意。</p>
<p><strong>本</strong>：<br>
本，木下曰本<br>
根本，根本，本就是根。</p>
<p><strong>考</strong>：<br>
考，老也。<br>
甲骨文为老人扶杖之形。</p>
<p><strong>北</strong>：<br>
北，乖也。从二人相背。<br>
两个人背靠背，是”背“的本字。<br>
打了败仗逃跑时总是以背对敌，”北“由此延申指败、败逃。例如败北。<br>
古代君主面朝南坐，臣子面君时则面朝北，所以对人称臣为”北面“</p>
<p><strong>卑</strong>：<br>
卑，贱也。<strong>执事</strong>也。<br>
金文似左手持一粗糙的酒器之形，会执事供役使之意。后延申为地位低微</p>
<p><strong>夭</strong>：</p>
<p>​	夭，屈也。</p>
<p>​	甲骨文字形似一个人弯曲双臂摆动的样子。</p>
<p>夭的原义是屈。但是屈过头了，就会折断。由此引申为折、短命，如“夭折”。</p>
<p>夭的字形，好似在跳舞的样子，所以也形容女子美丽姣好，也表示花开茂盛。</p>
<p><strong>州</strong>：<br>
州,水中可居曰州，周绕其旁，从重川。昔尧遭洪水，民居水中高土，或者曰九州。</p>
<pre><code>州，水中陆地。后来大禹将其领域划分为九州，之后九州就泛指天下。
</code></pre>
<p><strong>乡</strong>：<br>
甲骨文似两个人对着盛有食物的器皿，会两人相对而食之意。<br>
原义是两人相对而食。延申泛指用酒食款待别人。</p>
<p><strong>习</strong>：<br>
习，数飞也。<br>
甲骨文为鸟儿在日光下练习飞翔之意。<br>
后引申为反复练习、钻研。</p>
<p><strong>承</strong>：<br>
承，奉也，受也。<br>
甲骨文似一个屈膝的人作授物之形，下有一双手做出接受的样子。<br>
原义是<strong>捧</strong>，也延申为继承，如“汉承秦制”。<br>
承还可以表示顺从、侍奉。如“承欢膝下”。</p>
<p><strong>民</strong>：<br>
民，众萌也。<br>
众人懵懂无知的样子。<br>
金文似以锐物刺左目之形。古时候，俘获敌人则刺瞎其左眼用为奴。所以“民”的原义是奴隶。</p>
<p><strong>卒</strong>：<br>
卒，隶人给事者衣为卒。<br>
原指带有标记的衣服（叉号），也特指穿这种衣服供役使的隶役。也特指士兵。</p>
<p><strong>真</strong>：<br>
甲骨文为人从鼎中取食美味之意。<br>
原义指美食，由美食的原质原味延申为本质、本性。</p>
<p><strong>协</strong>：<br>
协，众之同和也。<br>
甲骨文似三耒并耕之形，会合力耕种之意。</p>
<p><strong>企</strong>：<br>
企，举踵也。<br>
踮起脚尖的意思。如“企盼”，“企鹅”，“企及”</p>
<p><strong>位</strong>：<br>
位，列中庭之左右谓之位。<br>
位，排列在朝廷中的左右位置叫做位。原义是朝廷中群臣排班所处的序列、地方。延申指所处的官职、级别。还特指封建君主的统治地位。“即位” 就是指登上帝位，“在位”就是居于帝王之位。<br>
位也延申指人在某一社会领域中所处的位置或者等级。例如“岗位”、”学位“<br>
位还指抽象的名分、地位。</p>
<p><strong>仔</strong>：<br>
原义是人背子，甲骨文是人背小孩的样子。</p>
<p><strong>保</strong>：<br>
保，养也<br>
甲骨文士大人手臂向后抱一小儿。</p>
<p><strong>儿</strong>；<br>
儿，孺子也。<br>
甲骨文是一个向左站着的大头娃娃，头顶中间是开口的，表示婴儿脑囟骨还没有长在一起。<br>
【原来婴儿出生后颅骨之间结合不紧密，存有空隙，长见识了。】</p>
<p><strong>先</strong>：<br>
先，前进也。<br>
甲骨文像是一个走路的样子。“先”的原义是在前引导，走在前面。</p>
<p><strong>公</strong>：<br>
公，平分也。<br>
甲骨文是平分器皿中的东西之意。<br>
原义是无私，延申为公正。</p>
<p><strong>周</strong>：<br>
周，密也。<br>
“周”是象形字。甲骨文似在玉片上雕刻出纹饰，四点则象征雕刻的图画和花纹有疏密。</p>
<p><strong>友</strong>：<br>
友，同志为友。<br>
甲骨文和金文都是方向相同的两只右手靠在一起的样子，会志同道合地做一件事情之意。</p>
<p><strong>冤</strong>：<br>
冤，屈也。<br>
兔子在覆罩之下不能跑。</p>
<p><strong>危</strong>：<br>
危，在高而惧也。<br>
人站在高处有危险而感到害怕之意。</p>
<p><strong>孝</strong>：<br>
孝，善事父母者<br>
甲骨文似长者长头发的老人，金文似孩子背着老人的样子。</p>
<p><strong>奴</strong>：<br>
“奴”是会意字。金文字形左为“女”，右下为“又”（手）向她抓去，会抓住了人之意。</p>
<p><strong>驳</strong>：<br>
驳，马色不纯。<br>
甲骨文为马身上有交错的花纹之意。<br>
原指马的毛色不纯，延申成混杂、杂乱、庞杂。</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>说文解字</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>说文解字第三册笔记</title>
    <url>/posts/259f533d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>逮</strong>：<br>
逮，及也。<br>
金文似右手揪住一条尾巴的样子。</p>
<p><strong>族</strong>：<br>
族，矢锋也。束之族族也。<br>
族，原义是箭头。</p>
<p><strong>感</strong>：<br>
感，动人心也。<br>
感的原义是人心受到外界影响而触动。</p>
<p><strong>意</strong>：<br>
意，志也。从心察言而知意也。<br>
意，意向。用心去考察别人的言语就知道他的意向。</p>
<p><strong>期</strong>：<br>
期，会也。<br>
期，约会。</p>
<p><strong>拜</strong>：<br>
拜，手至地也。<br>
拜，两手至地。<br>
甲骨文似双手捧禾麦奉献给神祖之行，会向神祖拜祭祈祷之意。</p>
<p>​</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>说文解字</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>说文解字第二册笔记</title>
    <url>/posts/c3d58b1a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>绝</strong>：<br>
绝，断丝也。<br>
绝，用刀断丝为二。</p>
<p><strong>怕</strong>：<br>
怕，无为也。</p>
<p><strong>守</strong>：<br>
守，守官也。<br>
“守”，金文是屋子里的一只手，由手在屋内掌管职责之意。<br>
原义是掌管职守。</p>
<p><strong>安</strong>：<br>
安，静也。<br>
女子坐在房中，会平安、安适之意。</p>
<p><strong>家</strong>：<br>
家，居也。<br>
“屋里有豕”为“家”。</p>
<p><strong>圣</strong>：<br>
圣，通也。<br>
圣，双耳畅通。<br>
甲骨文从耳，从口。<br>
原义是通达，延申指聪明、才智超群。在很早的时候人们传播知识、交流经验主要通过口耳相传，于是，只有善于聆听的人才能得到这么多的知识，故“圣”延申指博学多闻的人。</p>
<p><strong>拯</strong>：<br>
抍，上举也。<br>
原义是向上举，延申为援助、救济。</p>
<p><strong>报</strong>：<br>
报，当罪人也。<br>
报，判决罪人。甲骨文和金文左边是一个刑具，右边是一只手抓住一个人给其加上刑具的样子，会给人治罪之意。<br>
“报”的原义是按律判决罪人。例如《韩非子》：“报而罪之。” 意思是判决而治他的罪。判决罪人需要告知上级审批，故延申指告诉、告知。例如“通报”、“报警”。也引申为报答，例如”投桃报李“。<br>
好的回报是报答，但恶的回报就是报复了，所以”报“又指报复。例如”报仇雪耻“。也引申指由某种行为得到的结果。例如”善有善报“。</p>
<p><strong>莠</strong>：<br>
莠，禾粟下生莠。<br>
莠，是在禾粟之间生长的似禾非禾的东西叫“莠”。<br>
“莠”的原义是一种田间生长的外形似禾苗的杂草，其穗上似狗尾巴的毛，也叫狗尾巴草。例如《诗经》：“惟莠骄骄。” 意思是只有莠草长得十分茂盛。莠会妨碍禾苗生长，故延申成恶草的通称。也引申为坏、恶。例如“良莠不齐”。</p>
<p><strong>英</strong>：<br>
英，草荣而不实者。<br>
英，草只开花却不结实。<br>
“英”的原义是花。如《桃花源记》：“芳草鲜美，落英缤纷。”<br>
花是美好的，厮役延申成美好、杰出、优异。</p>
<p><strong>萌</strong>：<br>
萌，草芽也。<br>
“萌”的原义是草木的芽。延申指发芽；又引喻事情刚刚显露的发展趋势或者情况、开端。例如《韩非子》：“圣人见微以知萌，见端以知末。” 又指开始发生。例如“萌动”。</p>
<p><strong>大</strong>：<br>
大，天大，地大，人亦大。故大象人形。<br>
“大”是象形字。甲骨文、金文、小篆的形状全部似一个正面站立、张开双手双脚的人的形象。<br>
“大”的原义是人。人为“万物之灵”，上古以人为大，故延申为“大小”之“大”。也引申表示重要、重大。</p>
<p><strong>太</strong>：<br>
“太”是象形字。甲骨文中的“太”字就是“大”形，似正面站立的人形。金文下面增加了一个曲笔，以与“大”相区别。隶变以后楷书写成“太”。<br>
“太”是在“大”的基础上再加了一点而形成的，故延申成过于。如杜甫《新婚别》：“暮婚晨告别，无乃太匆忙！” 延申为最、极。进而延申指身份最高或者辈分更高的。例如”太公“、”太后“。</p>
<p><strong>天</strong>：<br>
天，颠也。至高无上，从一大<br>
天，头顶。<br>
”天“的原义是人的头顶；两眉之间，称为”天庭“。人至高无上的部分为”天“（头），自然界至高无上的部分也为“天”。</p>
<p><strong>夫</strong>：<br>
夫，丈夫也。从大，一以象簪也。周制以八寸为尺、十尺为丈。人长八尺，故曰丈夫。<br>
夫，成年男子。从大，一用以似成年男子头发上的簪子之形。</p>
<p><strong>君</strong>：<br>
君，尊也。从尹，发号，故从口。</p>
<p><strong>混</strong>：<br>
混，丰流也。从水昆声。<br>
混，盛大的水流。<br>
“混”的原义是水势盛大。水大则泥多，容易浑浊，故延申指浑浊，水多泥、多杂质而不清澈。进而延申指糊涂、不懂事。</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>说文解字</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>说文解字第四册笔记</title>
    <url>/posts/da100df3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>羁</strong>：<br>
羁，马络头也。<br>
原义是马络头。进而延申指用笼头系住马头。<br>
由络马头延申为束缚。例如“放荡不羁”。</p>
<p><strong>益</strong>：<br>
益，饶也。<br>
甲骨文从皿，“皿”上有很多“水”，会水太多而流出盆外之意。</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>说文解字</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>谷歌浏览器常用快捷键</title>
    <url>/posts/31e31a23/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>官方网址 [Chrome 键盘快捷键]（<a href="https://support.google.com/chrome/answer/157179?hl=zh-Hans%EF%BC%89">https://support.google.com/chrome/answer/157179?hl=zh-Hans）</a></p>
<h2 id="标签页和宽口快捷键">标签页和宽口快捷键</h2>
<ul>
<li>ctrl+n  打开新窗口</li>
<li>ctrl+t  打开新的标签页</li>
<li>ctrl+tab 跳到下一个标签页</li>
<li>ctrl+w 关闭当前标签页（等于鼠标中键点击标签页）</li>
<li>ctrl+shift+w 关闭当前窗口</li>
</ul>
<h2 id="功能快捷键">功能快捷键</h2>
<ul>
<li>ctrl+shift+o 打开书签</li>
<li>ctrl+h 历史</li>
<li>ctrl+j 下载</li>
<li>F5 刷新</li>
<li>F11 全屏（如看文献时）</li>
</ul>
<h2 id="地址栏快捷键">地址栏快捷键</h2>
<ul>
<li>ctrl+l 跳到地址栏</li>
<li>ctrl+enter <a href="http://xn--www-c88dx8l94buznxdx09to89cnbjl99b.xn--0tr.com">为输入地址默认添加www.和.com</a></li>
</ul>
<h2 id="网页快捷键">网页快捷键</h2>
<p>ctrl+d 将当前页面保存为书签<br>
ctrl+p 打印当前页面（可以将当前页面保存为pdf）<br>
ctrl+u 显示html源代码</p>
]]></content>
      <tags>
        <tag>软件学习</tag>
      </tags>
  </entry>
  <entry>
    <title>鸟叔的linux私房菜学习笔记</title>
    <url>/posts/e552a718/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>个人感觉，鸟叔讲得很细，但是这本书很难坚持看下去，本人都是挑着看的。</p>
<h1>第零章、计算机概论</h1>
<p>中央处理器（Central Processing Unit,cpu ）,主要工作是<strong>管理</strong>和<strong>运算</strong>，cpu读取的所有数据均来自于内存，处理后的数据也必须先写回内存。<br>
cpu 32位与64位：内存每次传给CPU的数据量，32bit 还是 64bit。所以说64位比32位，内存传给CPU的数据量翻了一倍。<br>
<strong>双通道</strong>：一条总线的带宽是64位，那么两个就是128位，所以双内存更快。最好两个内存的型号都完全一致。有的主板四条内存插槽的颜色不一样，需要两根容量相同的内存插在相同颜色的插槽当中，才能启用双通道。<br>
<strong>CPU第二层高速缓存内存</strong>：对于一些很常用的程序或数据可以放置在CPU内部，那么CPU就不用去内存读取数据了，这就是CPU第二层高速缓存的设计概念。</p>
<h3 id="字符编码">字符编码</h3>
<p>鸟叔的这张图相当形象了。<br>
<img src="encoding.png" alt=""></p>
<h3 id="机器语言与高阶程序语言">机器语言与高阶程序语言</h3>
<p><img src="bianyi.png" alt=""></p>
<h1>linux是什么与如何学习</h1>
<blockquote>
<p>鸟哥上课时，常常有学生问到：“老师，到底要听过你的课几次之后，才能学的会？”鸟 哥的标准答案是：“你永远学不会！”。<strong>因为你是用“听”的，没有动手做</strong>，那么永远不会知道“经 验”两个字怎么写!<br>
windows救命三键（Ctrl+Alt+Delete）</p>
</blockquote>
<h1>首次登录</h1>
<ul>
<li>shell中通过<strong>空格</strong>来区分命令，但是多个空格仍只会视为一个空格。</li>
<li><strong>tab</strong>：一次tab键<strong>命令补全</strong>，两次tab显示所有以输入字符开头的命令</li>
<li>ctrl+c：结束正在运行的命令</li>
<li><strong>ctrl+d</strong>：直接离开命令行（相当于exit)</li>
<li>shift+pageUp/pageDown：返回上次命令输出结果（相当于用鼠标滑轮）。</li>
</ul>
<h3 id="帮助文档">帮助文档</h3>
<ul>
<li>date <strong>–help</strong>: 简短说明</li>
<li><strong>man</strong> date: 详细说明。输入**/string**，向下搜寻string这个字符串。输入**?string**，向上搜索。</li>
</ul>
<h3 id="文件权限">文件权限</h3>
<ul>
<li>r(read) : 可读取此文件的内容</li>
<li>w(write): 可以修改文件内容（但不能删除该文件）</li>
<li>x(execute): 可以被系统执行</li>
</ul>
<h3 id="目录权限">目录权限</h3>
<ul>
<li>
<p>r(read) : 可读取该目录结构，即查询该目录下的文件名数据，可以使用ls命令。</p>
</li>
<li>
<p><strong>w(write)</strong>：可执行操作如下</p>
<ul>
<li>创建新的文件和目录</li>
<li><strong>删除</strong>已存在的文件或目录</li>
<li>将已存在的文件或目录进行更名</li>
<li>移动该目录下的文件、目录位置</li>
</ul>
</li>
<li>
<p>x(execute): 能否进入该目录，使之成为工作目录<br>
目录当然没有所谓的<strong>执行</strong>能力，这里的执行权限是指能不能直接进入该目录，用命令来说，就是能不能cd到该目录。<strong>如果不给x权限，w权限也没办法实现</strong></p>
</li>
</ul>
<h3 id="权限管理总结">权限管理总结</h3>
<p>需要给别人浏览的文件，<strong>目录</strong>需要提供<strong>r</strong>和<strong>x</strong>权限，<strong>文件</strong>需提供<strong>r</strong>权限。<strong>w</strong>权限需谨慎开放。</p>
<h1>Linux文件与目录管理</h1>
<h2 id="环境变量">环境变量</h2>
<p>通过<strong>echo $PATH</strong> 查看环境变量。设置环境变量的作用：运行程序时不用加路径，比如直接写plink，而不用写./plink。</p>
<ul>
<li>所有用户在PATH变量中都有/bin 或 /usr/bin 这个目录。这两个目录是一样的，因为/bin 是 /usr/bin的链接。</li>
<li>环境变量有<strong>顺序</strong>的区别，系统会按照顺序依次查找各个文件夹</li>
<li>添加环境目录
<ul>
<li>把当前的目录放入环境变量中。参考以下网页<a href="https://blog.csdn.net/yi412/article/details/11523525">linux 环境变量设置（临时 + 永久）</a>。</li>
<li>将程序或链接放在已在环境变量的目录中。个人常用，感觉更简单。</li>
</ul>
</li>
</ul>
<h2 id="查找文件">查找文件</h2>
<ul>
<li><strong>which</strong> 在PATH变量中搜索，并返回第一个搜索结果。 -a 列出所有结果</li>
<li><strong>whereis</strong> 只在特定的几个目录查找文件，感觉不实用。可以通过whereis -l 查看whereis查看的目录名称。</li>
<li><strong>locate</strong> 在数据库中查找，速度很快。但是数据库每天更新一次，因此最新创建的文件可能找不到，需要更新数据库（使用命令updatedb，需要root权限）。</li>
<li><strong>find</strong> 直接查找硬盘，速度慢。最后指定查找目录，缩小查找范围。</li>
</ul>
<h1>vim编辑器</h1>
<p>基本上 vi/vim 共分为三种模式，分别是一般模式或命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。但其实底线命令模式也是在一般模式下输入的。</p>
<h2 id="一般模式（命令模式）">一般模式（命令模式）</h2>
<ul>
<li><strong>/word</strong> <strong>向下</strong>寻找word（?word，向上）；通过<strong>n/N</strong>切换下（上）一个</li>
<li>:n1,n2s/word1/word2/g  从n1行到n2行查找word1,并替换为word2</li>
<li>1,$s/word1/word2/g   从第一行到最后一行查找替换</li>
</ul>
<h2 id="一般指令模式切换到编辑模式的可用的按钮说明">一般指令模式切换到编辑模式的可用的按钮说明</h2>
<ul>
<li>:wq</li>
<li>:wq! 强制写入</li>
<li>:w [filename] 另存为</li>
<li>set nu/nonu  显示/不显示行号</li>
</ul>
<h1>认识和学习BASH</h1>
<h2 id="万用字符（wildcard）">万用字符（wildcard）</h2>
<p>bash 支持万用字符（和正则表达式有区别），如用在ls命令中。<br>
<img src="wildcard.png" alt=""></p>
<h2 id="数据流重导向">数据流重导向</h2>
<p>standard output（标准输出）和 standard error output （标准错误输出）<strong>默认打印在屏幕上</strong>。</p>
<ul>
<li>标准输入，输出，错误输出代码分别为0，1，2。</li>
<li>
<blockquote>
<blockquote>
<p>追加，当文件不存在时主动创建，存在时追加。</p>
</blockquote>
</blockquote>
</li>
</ul>
<p><img src="standard.png" alt=""></p>
<h2 id="与">&amp;&amp; 与 ||</h2>
<p><img src="&amp;&amp;.png" alt=""></p>
<h2 id="管道命令">管道命令</h2>
<p>管道命令仅会处理standard output，对于 standard error output 会予以忽略。<br>
<img src="pipe.png" alt=""></p>
<h1>shell 编程</h1>
<p>shell 编程主要是用在<strong>系统管理</strong>上，不适合复杂的数据处理。</p>
<ul>
<li>多个空格视为一个空格</li>
<li>赋值（=）前后不能有空格</li>
<li>第一行必须为**/#!/bin/bash**，表明这个文件内的语法使用bash的语法</li>
<li>运行shell程序
<ul>
<li>直接运行（首先具有rx权限）
<ul>
<li>绝对路径：/home/dmtsai/shell.sh</li>
<li>相对路径：./shell.sh</li>
<li>PATH路径中：<a href="http://shell.sh">shell.sh</a></li>
</ul>
</li>
<li>以bash程序来执行（不需要权限，更方便）
<ul>
<li>bash <a href="http://shell.sh">shell.sh</a> 或 sh <a href="http://shell.sh">shell.sh</a></li>
</ul>
</li>
</ul>
</li>
<li>运行shell程序其实是在<strong>子程序</strong>的bash内执行的。（通过sourse命令在父程序中直接运行）<br>
<img src="sh.png" alt=""></li>
</ul>
<h1>账号管理</h1>
<h2 id="切换账号">切换账号</h2>
<ul>
<li>su - 切换为root账号</li>
<li>su zhouzw 切换为普通账号</li>
</ul>
<h1>程序管理</h1>
<h2 id="工作管理（job-control）">工作管理（job control）</h2>
<p>通过<strong>jobs -l</strong> 可以查看使用&amp;放入后台的程序的PID，然后就可以用kill命令杀掉后台程序。kill命令一般不建议使用-9选项强制关闭。</p>
]]></content>
      <tags>
        <tag>软件学习</tag>
      </tags>
  </entry>
  <entry>
    <title>plink学习笔记</title>
    <url>/posts/def937d0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近看到一个个人网站，里面有句话如下。</p>
<blockquote>
<p>为什么我最近更新得这么勤，因为我在不断充电。</p>
</blockquote>
<p>嗯，保持充电确实很重要啊！记录并总结自己的学习过程也很重要！我之前学东西都是记在笔记本或者脑子里，但是都不牢靠。纸质的东西总是易于损坏、丢失的，人脑的记忆能力也是有限的，而且我写的字也很难看。这个时候，将笔记什么的电子化就很有优势了。我在想，与其先记在本子上，再转到电子形式，不如从现在就训练自己用直接markdown写东西、记东西。</p>
<p>本文主要是学习了plink1.07的官方文档  <a href="http://zzz.bwh.harvard.edu/plink/dist/plink-doc-1.07.pdf">plink-doc-1.07.pdf</a>，有些内容因为个人暂时用不上，就跳过了，详细内容可直接阅读该文档。</p>
<h1>第一部分 plink 入门 —— 前三章</h1>
<p>ped文件前六列为家系ID，个体ID，父亲ID，母亲ID，性别（公1母2，其他为未知），表型（数量性状或疾病性状）。从第7列开始为基因型。ped不能有标题行。plink通过<strong>家系ID和个体ID</strong>来区分不同个体，即家系ID和个体ID不能都相同（但一般情况下要保持个体ID的唯一性）。<br>
map文件由四列组成，第一列为染色体（常染色体从1开始编号，性染色体是X或Y，0表示未知），第二列是SNP名称，第三列是遗传图谱（摩尔根距离，单位是厘摩，cm，大部分分析都用不上），第四列是物理图谱（真实距离，单位是bp，正整数，低于人的染色体长度。如果为负数，该SNP将被plink剔除)。–map3选项表示map文件中没有第三列遗传图谱。</p>
<h2 id="ped表型格式-phenotype">ped表型格式 phenotype</h2>
<p>疾病性状默认-9或0表示缺失，1表示未感染，2表示感染。可以使用–1选项，将-9认为缺失，0认为未感染，1认为感染。plink将性别不明的个体的表型也设置为缺失，可使用 --allow-no-sex禁止该现象。通过 --missing-phenotype -99 设置缺失表型值。<br>
如果ped文件中的一个个体的两个标记之间没有空格（例AG，而不是A G），那么在读取数据时可使用–compound-genotypes选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;plink --file mydata --compound-genotypes &lt;&#x2F;tt&gt;</span><br></pre></td></tr></table></figure>
<p>plink支持以标准输入流形式读取ped文件（用-替代ped文件名），但是不适用map文件。代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.... | .&#x2F;plink --ped - --map mymap.map --make-bed</span><br></pre></td></tr></table></figure>
<h2 id="ped基因型格式-genotype">ped基因型格式 genotype</h2>
<p>plink软件可以支持任何形式的SNP的编码，ATGC或1234都适用。plink 基因型缺失值格式默认为0，可通过–missing-genotype 修改缺失值。所有的标记都必须为<strong>双等位基因</strong>。<br>
可以通过–output-missing-phenotype 和 --output-missing-genotype修改plink输出文件的默认缺失值格式<br>
但需要输出新文件时（如生成二进制ped），plink通常会保留所有的基因型信息（即保持转换前后实际内容不变）。但是当使用plink进行统计和数据分析是，plink会对基因型数据进行筛选，将一部分基因型数据自动设置为缺失并剔除。</p>
<p>–file 需要ped和map文件名称相同。如果不加–out选项，默认名称均为plink。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file hapmap1</span><br></pre></td></tr></table></figure>
<h2 id="其他芯片文件格式-——-Transposed-filesets">其他芯片文件格式 ——  Transposed filesets</h2>
<p>文档中提到有一种转置的ped文件类型，由tped文件和tfam文件构成。tped文件每一行是一个snp，前4列是map文件的内容，后面每两列是一个个体该SNP的基因型。tfam文件是原ped文件的前六列。<br>
该文件可通过 --tfile 或 --tped --tfam读取，通过 --transpose 生成.<br>
<img src="/images/transpose_ped.png" alt=""></p>
<h2 id="其他芯片文件格式-——-Long-format-filesets">其他芯片文件格式 —— Long-format filesets</h2>
<p>该格式包括三个文件lgen文件，map文件（同上），fam文件（原ped文件的前六列）。lgen文件由5列组成，分别为家系ID，个体ID，snp名称，该snp的第一个等位基因，第二个等位基因。<br>
该文件可以通过 --lfile 命令读取，并使用 --recode 转换为标准的ped文件。根据说明文档，目前plink不支持输出这种格式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --lfile test --recode</span><br></pre></td></tr></table></figure>
<p><img src="/images/lgen_ped.png" alt=""></p>
<h2 id="额外的表型文件">额外的表型文件</h2>
<p>除了在ped文件（或fam文件）中的第六列准备表型，plink还支持输入一个单独的表型文件（–pheno）。表型文件应包含三列，家系ID，个体ID，表型。但是ped文件中依然不能缺少第六列（虽然此时没有作用了）。</p>
<ul>
<li>如果ped中的个体没有出现在表型文件中，那么plink会将该个体的表型设为缺失。</li>
<li>表型文件中个体的顺序不需要按照ped文件的顺序。</li>
<li>如果表型文件表型文件中不止一列表型，此时使用–mpheno N命令来明确使用的是第N列表型。如下代码所示，pheno2.txt共7列（即有5列表型，暂命名为A,B,C,D,E），那么这里用的是第4列表型，即表型D。</li>
<li>表型文件默认没有标题行，如果有，那么前两个标题必须为FID和IID，此时指定表型列可直接使用标题，如 --pheno-name age</li>
<li>表型文件中所有表型必须为数值，缺失值默认为-9（可以通过–missing-phenotype设置）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file mydata --pheno pheno2.txt --mpheno 4</span><br></pre></td></tr></table></figure>
<h2 id="生成二进制文件">生成二进制文件</h2>
<p>–make-bed 生成二进制ped文件，压缩数据大小，加快分析速度。该命令生成二进制文件时，不会根据missing rates或等位基因频率清洗任何SNP位点或个体。<br>
该命令生成三个文件，bed文件为二进制的ped文件，bim为扩展的map文件（相较于原map文件，增加了两列，为每个SNP的等位基因名称），fam文件（ped文件的前六列）。这三个文件是配套的，<strong>不能修改bim文件和fam文件</strong>，否则可能会导致错误。<br>
读取二进制文件，使用–bfile替代–file。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file val --make-bed</span><br></pre></td></tr></table></figure>
<h2 id="统计缺失率或基因分型率">统计缺失率或基因分型率</h2>
<p>生成二进制文件后，可直接使用二进制文件来进行分析（–bfile），如通过–missing分析基因分型率call rate（或missing rate）。<br>
生成missing_data.imiss和missing_data.lmiss文件（分别为个体的缺失情况文件和SNP位点的缺失情况文件，i和l为individual的individual和locus的缩写）。imiss文件中N_MISS列为该个体未测出的SNP数目，N_GENO为总的SNP数目，F_MISS为未检出的SNP所占比例。同样地，lmiss的最后三列分别为所有个体中该位点未检出个数，个体数，该位点未检出比例。<br>
（注，plink会首先联网查找更新，如果服务器没联网或者运行时不需要联网，需要添加命令 --noweb。）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile plink --missing --out missing_data</span><br></pre></td></tr></table></figure>
<p>–chr 1 按不同染色体去运行plink命令。减少运算量。</p>
<h2 id="统计等位基因频率">统计等位基因频率</h2>
<p>–freq 统计等位基因频率，生成frq文件。其中MAF为该snp位点最小等位基因频率<br>
（在plink中，将基因频率较小的叫做A1，将基因频率较大的叫做A2）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --noweb --bfile plink --freq --out freq_stat</span><br></pre></td></tr></table></figure>
<p>对有群体分层现象的不同群体进行等位基因频率分析。下面pop.phe描述了不同个体所属的群体（cluster）情况，三列（家系ID，个体ID，所属群体）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --noweb --bfile plink --freq --within pop.phe --out freq_stat</span><br></pre></td></tr></table></figure>
<p>–snp rs1891905 选择特定的SNP进行分析。–window kb --from --to 选择一堆snp进行分析。</p>
<h2 id="基本关联分析">基本关联分析</h2>
<p>基本关联分析 --assoc。（后面有关关联分析的内容没看，本人用不上。）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile plink --assoc --out as1</span><br></pre></td></tr></table></figure>
<h2 id="读取plink命令文件">读取plink命令文件</h2>
<p>当plink命令较长时，可将plink命令写入一个文件中。运行 --script命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --script myscript1.txt</span><br></pre></td></tr></table></figure>
<p>myscript1.txt内容如下，每一行一个命令，以–开始。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--ped ..\data\version1\50K\allsamples.ped</span><br><span class="line">--map ..\data\allmapfiles\finalversion\autosomal.map</span><br><span class="line">--out ..\results\working\sample-missingness-v1.22</span><br><span class="line">--from rs66537222</span><br><span class="line">--to rs8837323</span><br><span class="line">--geno 0.25</span><br><span class="line">--maf 0.02</span><br><span class="line">--missing</span><br></pre></td></tr></table></figure>
<h1>第二部分 plink 数据管理</h1>
<h2 id="recode">recode</h2>
<p>对于ped文件，使用–recode命令，生成的文件与原文件内容相同，仅仅按snp所在染色体及真实位置进行了排序。个人理解，如果要重新生成ped格式的芯片文件，那么就需要使用–recode命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --noweb --file val --recode</span><br></pre></td></tr></table></figure>
<p>plink支持将二进制文件重新转为普通ped文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile mydata --recode</span><br></pre></td></tr></table></figure>
<p>使用–recode12 命令将会使基因型重编码为1和2（0依然表示未知）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --noweb --file val --recode12</span><br></pre></td></tr></table></figure>
<p>将ped基因型从ATGC转到1234，使用–allele1234（相反则用–alleleACGT）。注意，–allele1234必须配合–recode 或 --make-bed等生成文件命令或其他分析命令使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file val --recode --allele1234</span><br></pre></td></tr></table></figure>
<h2 id="生成snp-list文件">生成snp list文件</h2>
<p>按SNP的基因型排列 --list，生成list文件，格式为染色体-snp名称-基因型（双）-第一个个体的家系ID-第一个个体的个体ID-第二个个体……。可配合–snp命令，查看某个snp的基因型情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file val --list</span><br></pre></td></tr></table></figure>
<h2 id="更新covariate文件">更新covariate文件</h2>
<p>重新生成covariate文件，当–covar 配合生成文件命令（–recode 或 --make-bed）。好处是当covariate文件包含个体多于芯片，或顺序不一致时，生成的新文件与芯片文件保持一致。(–write-cluster类似,形成新的cluster文件)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --covar myfile.txt --recode</span><br></pre></td></tr></table></figure>
<h2 id="翻转部分的SNP-例A变成T-改为等位基因基因型">翻转部分的SNP(例A变成T,改为等位基因基因型)</h2>
<p>准备一个snp名称文件(只有一列,为需要转换的snp名称),list.txt。flip命令需配合–recode等生成文件命令使用。适用于当芯片出现正反链问题时。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --flip list.txt --recode</span><br></pre></td></tr></table></figure>
<p>当只对芯片中的一部分个体进行转换时，增加–flip-subset选项。mylist.txt为个体ID。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --flip list.txt --flip-subset mylist.txt --recode</span><br></pre></td></tr></table></figure>
<h2 id="合并两个芯片文件">合并两个芯片文件</h2>
<p>合并两个芯片文件(merge 后面必须是ped map；–recode是必需的)。merge合并文件时，两个芯片文件的标记和个体之间可以是完全重合、部分重合甚至没有重合。文档中举例，如果一个snp只出现在第二个芯片文件中，那么第一个芯片文件中的个体（没出现在第二个文件）合并后该snp均为缺失。个人理解是，merge合并的文件应该会按照个体数最多、标记数最多的原则，所有不知道的位点全部设为缺失。<br>
第二，在第一个文件中已经存在的标记数据，默认情况下不会被第二个文件覆盖。例如第一个文件某个体某snp为AA，第二个文件该个体该SNP为AG，最终合并文件中还是AA。覆盖情况可以通过–merge-mode调整。<br>
第三，两个map同一个snp的物理位置需保持一致。<br>
第四，两个芯片文件的snp编码方式要保持一致，不能一个ATGC，一个123。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data1 --merge data2.ped data2.map --recode --out merge</span><br></pre></td></tr></table></figure>
<p>merge命令可用于二进制文件，此时需用–bmerge，输出需用–make-bed</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile data1 --bmerge data2.bed data2.bim data2.fam --make-bed --out merge</span><br></pre></td></tr></table></figure>
<h2 id="合并多个芯片文件">合并多个芯片文件</h2>
<p>使用–merge-list命令，需要准备文件，后面每一个芯片文件一行（可以为普通格式，也可以是二进制格式）。例如合并fA到fH的芯片文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file fA --merge-list allfiles.txt --recode --out mynewdata</span><br></pre></td></tr></table></figure>
<p>allfiles.txt格式如下图<br>
<img src="/images/merge_list.png" alt=""></p>
<h2 id="提取SNPs的子集">提取SNPs的子集</h2>
<h3 id="基于染色体">基于染色体</h3>
<p>以下命令会默认生成6号染色体的二进制芯片文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --chr 6</span><br></pre></td></tr></table></figure>
<p>如果想生成正常格式的芯片文件，增加recode命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --recode --chr 6 --out chr1</span><br></pre></td></tr></table></figure>
<h3 id="基于snp范围">基于snp范围</h3>
<p>如果是挑一个范围内的所有标记（必须在同一条染色体）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile mydata --from rs273744 --to rs89883</span><br></pre></td></tr></table></figure>
<p>基于某个snp的上下游范围（–snp 和 --window)。以下命令将挑出rs652423上下游20kb的所有snp。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile mydata --snp rs652423 --window 20</span><br></pre></td></tr></table></figure>
<h3 id="基于染色体的物理位置（–from-kb-to-kb）">基于染色体的物理位置（–from-kb --to-kb）</h3>
<p>以下命令为挑选2号染色体上5000kb到10000kb的所有snp。类似选项有–from-bp,–from-mb</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile mydata --chr 2 --from-kb 5000 --to-kb 10000</span><br></pre></td></tr></table></figure>
<h2 id="随机采样-thin">随机采样 --thin</h2>
<p>–thin 0.2 表示随机抽取20%的snp。</p>
<h2 id="基于给定文件挑选snp">基于给定文件挑选snp</h2>
<p>以下命令中，mysnps.txt为snp名称，仅一列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file --extract mysnps.txt --recode</span><br></pre></td></tr></table></figure>
<p>当添加–range命令时，此时添加的文件格式是染色体（空格）起始物理位置（单位bp）（空格）结束物理位置(单位bp) （空格）该范围名称。每一行（4列）表示一个范围。如下图所示。<br>
<img src="/images/extract_range.png" alt=""></p>
<h2 id="剔除部分snps-exclude">剔除部分snps --exclude</h2>
<p>mysnps.txt为不需要的snp名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --exclude mysnps.txt --recode</span><br></pre></td></tr></table></figure>
<p>另外一种剔除方式是，在map文件中snp的物理位置设为负数（不适用于二进制文件）。</p>
<h2 id="挑出或移除部分个体">挑出或移除部分个体</h2>
<p>以下命令中，mylist.txt前两列为家系号 个体号（后面可以有其他列，plink会忽视）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --keep mylist.txt --recode</span><br></pre></td></tr></table></figure>
<p>移除个体使用–remove命令，文件格式与上述一致。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --remove mylist.txt --recode</span><br></pre></td></tr></table></figure>
<h3 id="通过其他文件内容筛选个体">通过其他文件内容筛选个体</h3>
<p>以下命令为挑选myfile.raw中第三列为1的个体。myfile.raw格式为三列，与表型文件、cluster文件格式一致，分别为家系ID 个体ID 自定义（如表型）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --filter myfile.raw 1 --freq</span><br></pre></td></tr></table></figure>
<p>如果给定文件中有多列，可以通过–mfilter指定列。以下命令便指定为fam文件中的表型（4表示前两列之后的第四列）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile data --filter data.fam2 --mfilter 4</span><br></pre></td></tr></table></figure>
<p>plink 中衍生出各种filter的命令，提取不同条件的个体，如–filter-cases、–filter-controls、–filter-males、–filter-females、–filter-founders、–filter-nonfounders。</p>
<h3 id="通过其他文件内容筛选snp">通过其他文件内容筛选snp</h3>
<p>类似上述，准备一个snp属性文件，第一列为snp名称，第二列及之后列为属性（空格分开，自定义）。</p>
<blockquote>
<p>一个snp可以有多个属性,也可以不接属性(即只有snp名称)<br>
属性文件中不用包括所有的snp,也可以包含不在map中的snp(plink会忽视)<br>
文件内容不需要顺序<br>
每个snp只能占一行(即不能重复)<br>
属性名称使用一个横杠,表示否定(exclude).可同时挑选多个属性,以逗号隔开.</p>
</blockquote>
<blockquote>
<p>多个属性条件时,默认是OR(或)逻辑;正负属性之间是and逻辑.<br>
以下命令即为挑选含有exonic属性,但是不含有failed属性的snp</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--attrib snps.txt exonic,-failed</span><br></pre></td></tr></table></figure>
<h1>第三部分 数据分析</h1>
<h2 id="基因型缺失">基因型缺失</h2>
<p>基本命令–missing<br>
<s>注意，结果文件lmiss和imiss文件都事先剔除了基因分型率小于90%的snp和个体（plink默认,可使用–mind 1保留所有个体）。如下图，imiss文件中N_GENO为50683（原map为50697个位点），这说明有14个snp位点因为分型率低于90%而被剔除。</s><br>
之前说错了，plink新版本（1.04以后）已经不会默认按基因分型检出率或MAF剔除个体或snp了。后面检查，发现删除的14个snp均是Y染色体上的，具体原因不是很清晰（猜测是因为我用的ped性别一列均是0（实际都是母猪），plink估计会将这种性别未知或母猪的Y染色体的snp删除掉）。屏幕上打印的信息如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Warning: Nonmissing nonmale Y chromosome genotype(s) present; many commands treat these as missing.</span><br></pre></td></tr></table></figure>
<p><img src="/images/imiss.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --missing</span><br></pre></td></tr></table></figure>
<h2 id="bligatory-missing-genotypes">bligatory missing genotypes</h2>
<p>这个不好翻译,文档中解释是有些snp位点不是因为基因分型失败,而是根本没检测。对于这种位点，我们可能希望不要删除这些位点（–geno）、或者因此而删除个体(–geno)。这个个人感觉还是比较实用，比如在合并不同map的芯片文件进行质控时。<br>
以下命令中，test.clst为正常的三列cluster文件，三列（cluster名称自定义）。test.oblig文件指定缺失的snp,两列，第一列是snp名称，第二列是cluster名称，如下图。按文档的例子，个人理解为，cluster文件只需指定有指定缺失snp的个体即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file test --missing --oblig-missing test.oblig --oblig-clusters test.clst</span><br></pre></td></tr></table></figure>
<p><img src="/images/oblig.png" alt=""><br>
注意</p>
<blockquote>
<p>该命令只对质控操作（–mind --geno）有效果，其他分析无效。<br>
如果设定为缺失的snp实际有基因型，仍会设为缺失。</p>
</blockquote>
<h2 id="哈温平衡">哈温平衡</h2>
<p>以下命令生成plink.hwe文件，格式如下图。最后四列是三种基因型的数目，观察到的杂合子频率，通过哈温平衡计算得到的理论杂合子概率，哈温平衡检验的p值。<br>
文档中提出，只有founders（个人理解是系谱里的最古老的个体）才会进行哈温平衡。但是我们一般ped文件中父母都是未知（0），所以所有个体都会进行哈温平衡检验。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --hardy</span><br></pre></td></tr></table></figure>
<p><img src="/images/hwe.png" alt=""></p>
<h2 id="等位基因频率">等位基因频率</h2>
<p>这个入门部分也有，使用–freq命令，生成frq文件，含有5列，分别为染色体、snp名称、A1(基因频率较小)、A2(等位基因频率较大)、MAF、无缺失的总的等位基因个数（小于等于2n,n为个体数）。</p>
<h2 id="孟德尔误差（Mendel-errors）">孟德尔误差（Mendel errors）</h2>
<p>本人对这个概念不是很清晰，从文档说明来看，大概是指根据父母的基因型推断的后代基因型与后代真实的基因型不符的情形，如父母都是AA，后代却是AB。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file data --mendel</span><br></pre></td></tr></table></figure>
<h2 id="性别确认">性别确认</h2>
<p>通过X染色体的基因型数据确认ped文件中的性别列是否有误。结果文件sexcheck文件有6列，分别为家系ID，个体ID，ped文件中的性别（公1母2），通过X染色体确认的性别，匹配状态（PROBLEM or OK）,F(The actual X chromosome inbreeding (homozygosity) estimate)。</p>
<blockquote>
<p>如果ped文件中性别是0，也会显示不匹配（PROBLEM）<br>
F如果大于0.8认为性别为公，如果小于0.2认为母（不懂F的概念）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile data --check-sex</span><br></pre></td></tr></table></figure>
<p>–impute-sex命令可将基于SNP数据的性别修改ped文件中的性别，需要配合输出文件命令使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile data --impute-sex --make-bed --out newfile </span><br></pre></td></tr></table></figure>
<h2 id="PCA分析">PCA分析</h2>
<p><a href="https://www.cog-genomics.org/plink/1.9/strat#pca">https://www.cog-genomics.org/plink/1.9/strat#pca</a></p>
<p>plink 用于作PCA分析，命令相当简单，就是加一个 --pca 就完事了</p>
<p>默认会输出20个主成分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--pca [count] [&#39;header&#39;] [&#39;tabs&#39;] [&#39;var-wts&#39;]</span><br><span class="line"></span><br><span class="line">--pca-cluster-names &lt;name(s)...&gt;</span><br><span class="line">--pca-clusters &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>count: 输出几个主成分，如 --pca 3 ，就是只要前3个主成分</li>
<li>header: eigenvec 文件加标题</li>
<li>tabs: 用tab 代替空格</li>
<li>var-wts:  You can request variant weights with the ‘<strong>var-wts</strong>’ modifier（不懂）</li>
</ul>
<p>第二个和第三个命令是当聚类后，你可以只挑出某几个cluster的个体做分析，二者的区别在于–pca-cluster-names 后面直接跟cluster的名称（以空格分开），–pca-culsters 后面接cluster名称的文件名</p>
<h1>第四部分 质控（QC）</h1>
<p>这一节对应文档的第6章，Inculsion thresholds，个人理解其实就是质控。这一节和上一节的数据分析的命令是有关联的，文档中用了一个图片说明，这里用一个表格说明。</p>
<table>
<thead>
<tr>
<th style="text-align:center">功能</th>
<th style="text-align:center">分析命令</th>
<th style="text-align:center">质控命令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">个体基因分型缺失率</td>
<td style="text-align:center">–missing</td>
<td style="text-align:center">–mind N</td>
</tr>
<tr>
<td style="text-align:center">SNP基因分型缺失</td>
<td style="text-align:center">–missing</td>
<td style="text-align:center">–geno N</td>
</tr>
<tr>
<td style="text-align:center">等位基因频率</td>
<td style="text-align:center">–freq</td>
<td style="text-align:center">–mat N</td>
</tr>
<tr>
<td style="text-align:center">哈温平衡</td>
<td style="text-align:center">–hardy</td>
<td style="text-align:center">–hwe N</td>
</tr>
<tr>
<td style="text-align:center">孟德尔误差比例</td>
<td style="text-align:center">–mendel</td>
<td style="text-align:center">–me N M</td>
</tr>
</tbody>
</table>
<h2 id="默认质控">默认质控</h2>
<p>高版本的plink（如1.9）已不会默认对个体或snp根据基因分型检出率或MAF进行质控。<br>
–all 不剔除任何个体或SNP，等于–mind 1 --geno 1 --maf 0</p>
<h2 id="个体基因检出率">个体基因检出率</h2>
<p>–mind 0.1 即剔除缺失率高于0.1的个体，或者说保留检出率高于0.9的个体。如果有个体被剔除，其个体信息保存在irem文件中<br>
–mind 1 即不剔除任何个体。使用该命令载入数据时不会计算个体的检出率，提高plink读取文件速度。</p>
<h2 id="snp基因检出率">snp基因检出率</h2>
<p>–geno 0.1 即剔除缺失率高于0.1的SNP，或者说保留检出率高于0.9的SNP。<br>
注意：–geno 和 --maf命令执行优先程度低于–mind，也就是同用–mind和–geno时，会先剔除缺失率较高的个体，再计算SNP检出率。</p>
<h2 id="最小等位基因频率">最小等位基因频率</h2>
<p>–maf 0.01 剔除MAF小于0.01的SNP</p>
<h2 id="哈温平衡-2">哈温平衡</h2>
<p>–hwe 0.001 如果需要剔除不满足哈温平衡的位点，使用该选项。p值小于0.001的个体被剔除，具体信息可见控制台（屏幕打印出的信息）或log文件。</p>
<h2 id="孟德尔误差比例（Mendel-error-rate）">孟德尔误差比例（Mendel error rate）</h2>
<p>只适用于family-based data。<br>
–me 0.05 0.1 第一个参数表示孟德尔误差超过5%的家系会被剔除；第二个参数表示孟德尔误差超过10%的SNP会被剔除。目前plink是同时计算家系和SNP的孟德尔误差比例，未来可能有所修改。</p>
<h1>第五部分 plink群体分层分析（Stratification analysis）和聚类分析（cluster analysis）</h1>
<h2 id="一般聚类">一般聚类</h2>
<p>根据IBS（identity-by-state,同态相同）进行聚类分析。基本命令如下，生成cluster0、cluster1、cluster2、cluster3四个文件，这四个文件内容一致，但格式不同（一般只用cluster1和cluster2）。</p>
<blockquote>
<p>cluster1文件是最直接的cluster结果文件，每一行是一个cluster，第一列SOL-0(估计是plink起的cluster名称)，后面就是每个cluster的个体（家系号_个体号）。<br>
cluster2文件是用来给plink读取的（使用–within *.cluster2）。格式为标准的三列，家系ID，个体ID，所属cluster。<br>
聚类时间与个体数有关。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile plink --cluster</span><br></pre></td></tr></table></figure>
<h2 id="加限制条件">加限制条件</h2>
<p>–cluster --mc 每个cluster最大的个体数量<br>
–ppc 0.05（pairwise population concordance） 当两个个体之间属于相同组的概率小于0.05时不进行合并（即设定P值）。<br>
结果文件是cluster1文件，每一行是一个cluster。第一列SOL-0什么的不用管，后面就是每个cluster的个体（家系号和个体号）。cluster2和cluster1内容一样，格式不同，cluster有三列，分别为家系号、个体号、所属cluster（cluster2 用于plink读取，–within plink）。<br>
可以通过–K（大写）选项设定cluster 的数目。但是这时不能再设定ppc。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --noweb --bfile plink --cluster --mc 10 --ppc 0.05 --out str1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --noweb --bfile plink --cluster --K 2 --out str2</span><br></pre></td></tr></table></figure>
<p>如果个体比较多，而且需要按不同条件进行多次聚类时，可按如下命令操作，节约时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --bfile mydata --genome --out mydata</span><br><span class="line">plink --bfile mydata --read-genome mydata.genome --cluster --ppc 0.01</span><br><span class="line">plink --bfile mydata --read-genome mydata.genome --cluster --mc 2 --ibm 0.01</span><br></pre></td></tr></table></figure>
<h2 id="IBS-similarity-matrix">IBS similarity matrix</h2>
<p>添加–matrix命令，生成mibs文件，为方阵形式，内容为所有个体两两之间的同态相同的比例（0-1）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file mydata --cluster --matrix</span><br></pre></td></tr></table></figure>
<p>通过R画图来具体描述群体结构（适合芯片中存在几个群体的情况，手册中是前45个个体是中国人，后44个是日本人）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --noweb --bfile plink --cluster --matrix --out ibd_view</span><br></pre></td></tr></table></figure>
<p>生成ibd_view.mibs文件（手册上写的是mdist文件)，在R中读取该文件，画图步骤如下。<br>
个人尝试了一下，使用这种方式画图，和PCA画图结果差不多。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">m &lt;- as.matrix(read.table(<span class="string">&quot;ibd_view.mibs&quot;</span>))</span><br><span class="line">mds &lt;- cmdscale(as.dist(<span class="number">1</span>-m))</span><br><span class="line">k &lt;- <span class="built_in">c</span>( <span class="built_in">rep</span>(<span class="string">&quot;green&quot;</span>,<span class="number">100</span>) , <span class="built_in">rep</span>(<span class="string">&quot;blue&quot;</span>,<span class="number">222</span>) )</span><br><span class="line">plot(mds,pch=<span class="number">20</span>,col=k)</span><br></pre></td></tr></table></figure>
<h1>第六部分 IBS/IBD 估计</h1>
<p>通过估计芯片个体间的IBS和IBD情况，可以用来检测测序时样品污染，重复样一致性，系谱错误以及发现未知的亲缘关系。</p>
<h2 id="配对的IBD估计">配对的IBD估计</h2>
<p>上一章说了个体间IBS的估计以及根据IBS划分cluster，我们可以检测个体间的IBD情况。以下命令生成genome文件，文件格式如下图。需要关注的是PI_HAT（这个指标就是两个个体IBD相同的大小），<br>
使用–Z-genome会生成压缩文件plink.genome.gz，–read-genome也可以直接读取压缩的genome文件。<br>
注意：IBD分析前需要进行群体分层分析。而且ped文件中的家系ID、父本ID、母本ID应该要完整。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file mydata --genome</span><br></pre></td></tr></table></figure>
<p><img src="/images/genome.png" alt=""><br>
如果只计算同一个家系的IBD（家系按照ped文件中的系谱划分），使用命令–rel-check，会大大加快速度，不用每两个个体都要计算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file mydata --genome --rel-check</span><br></pre></td></tr></table></figure>
<p>通过–min x挑选结果中PI_HAT大于x的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file mydata --genome --min 0.05</span><br></pre></td></tr></table></figure>
<h2 id="估计近交系数">估计近交系数</h2>
<p>不是很清楚原理，文档中说based on the observed versus expected number of homozygous genotypes<br>
以下命令生成het文件，格式如下图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plink --file mydata --het</span><br></pre></td></tr></table></figure>
<p><img src="/images/het.png" alt=""></p>
]]></content>
      <tags>
        <tag>数据分析</tag>
        <tag>软件学习</tag>
        <tag>生物信息</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分课程第一部分学习笔记</title>
    <url>/posts/b445140c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是根据美国拉马尔大学 <em>Paul Dawkins</em> 老师的<strong>微积分</strong>教学材料写的笔记。</p>
<p>网址为：<a href="https://tutorial.math.lamar.edu/Classes/CalcI/CalcI.aspx">https://tutorial.math.lamar.edu/Classes/CalcI/CalcI.aspx</a>  （点击网页右上角的 download，选择 complete book 即可下载 pdf 格式的书籍 ）</p>
<p>我发现很多英文教材很适合自学，而且言语恳切，不嫌啰嗦，生怕你看不懂，不理解。这本书的特点也是如此，写的非常仔细，完全可以根据作者提供的pdf 自学。</p>
<span id="more"></span>
<h1>Review</h1>
<p>radical 根数</p>
<h2 id="逆函数（inverse-function）">逆函数（inverse function）</h2>
<p>如果两个不同的x值不会对应同一个y值，那么我们称这个函数是一对一的（<strong>one to one</strong>）。</p>
<p>但是证明函数是一对一的，可能很困难。因此我们一般都是假设函数不是一对一的，或者我们严格限定定义域（<strong>domain</strong>）使得函数符合一对一的性质。</p>
<p>现在让我们来定义<strong>逆函数</strong></p>
<blockquote>
<p><strong>逆函数</strong>：如果有两个满足<strong>一对一</strong>的函数 f(x) 和 g(x) ，如果满足以下式子，我们就称它们互为逆函数，记为 f^-1^(x) 或  g^-1^(x)</p>
</blockquote>
<p><img src="inverse_function1.png" alt=""></p>
<p>找出逆函数的五个步骤。相比我之前的认识，就是增加了第五步，复合函数的证明。</p>
<p><img src="inverse_function2.png" alt=""></p>
<p>第5步从理论上讲需要证明两种复合函数都等于x。</p>
<p>一个函数与其逆函数<strong>关于y=x对称</strong>。</p>
<p>三角函数中 角度为degree 弧度为 radian 。单位弧度定义为圆弧长度等于半径时的圆心角。</p>
<ul>
<li>sin(-x) = -sin(x)  ; tan(-x) = -tan(x)</li>
<li>cos(-x) = cos(x)</li>
</ul>
<h1>limits</h1>
<p><img src="limits1.png" alt=""></p>
<p>这种定义是通俗的定义方式，不是使用数学式子严格表示的定义。</p>
<p>要点：</p>
<ol>
<li>极限是需要从<strong>左右两边靠近</strong>均成立的。（<strong>both sides</strong>）</li>
<li>极限<strong>不需要</strong> x 真的取到 a值 。</li>
</ol>
<p>判断极限存不存在，简单地说，就是随着x 越来越接近 a (<strong>from two sides</strong>) ，f(x) <strong>must</strong> 越来越接近 L 。</p>
<p>另外，极限的定义里不包括 <strong>x = a</strong>，极限的值和 ** x = a ** 的值是<strong>不相关</strong>的。极限只和 点a 附近的函数值有关。</p>
<p>重申：有的时候函数的定义域可能不包括a，但是这也不影响其极限的存在。</p>
<blockquote>
<p>We are <strong>NOT</strong> asking what y value the graph takes at the point in question.  In other words, we are asking what the graph is doing <strong>around</strong> the point x = a.</p>
</blockquote>
<h2 id="one-sided-limits">one-sided limits</h2>
<p><img src="limits2.png" alt=""></p>
<p>one-sided limits 与 normal limits 的区别就是<strong>单边</strong>与<strong>双边</strong>。</p>
<p>单边极限与双边极限的关系如下：</p>
<p><img src="limits3.png" alt=""></p>
<h2 id="limit-Properties">limit Properties</h2>
<p>极限的性质如下：</p>
<p><img src="limits4.png" alt=""></p>
<p>这些性质对<strong>单边</strong>极限也适用。</p>
<p>对于多项式，其某点的极限值等于其函数值。</p>
<p>目前学过的大部分函数都是“nice enough&quot; ，在其定义域内，其极限值都等于函数值。其组合函数一般也是”nice enough&quot;。</p>
<p>定理：</p>
<p><img src="limits5.png" alt=""></p>
<p>由此引出<strong>夹逼定理</strong>（<strong>Squeeze Theorem</strong>）</p>
<p><img src="squeeze_theorem1.png" alt=""></p>
<p>看一个图，一下就明白（这里假设三个函数是nice enough，但实际夹逼定理不需要满足这一点）</p>
<p><img src="squeeze_theorem2.png" alt=""></p>
<h2 id="infinite-Limits">infinite Limits</h2>
<p>无穷大的定义：</p>
<p><img src="infinite_limits1.png" alt=""></p>
<p>垂直渐进线定义：</p>
<p><img src="vertical_asympotote1.png" alt=""></p>
<h2 id="limits-at-infinity">limits at infinity</h2>
<p>这个是当x 为无穷大时的极限。</p>
<p>对于多项式，其正无穷或负无穷处的极限值等于其最高项的极限值。</p>
<p><img src="limits_at_infinity1.png" alt=""></p>
<p>水平渐进线（horizontal asymptote）定义：</p>
<p><img src="horizontal_asymptote1.png" alt=""></p>
<p>对于多项式求极限，一个最重要的地方就在于找到<strong>最大项</strong>，然后提取出来。这里的最大项指的是<strong>与0偏离最远</strong>的项</p>
<p>如果是分式，那么只看<strong>分母</strong>的<strong>最大项</strong>。</p>
<h2 id="continuity">continuity</h2>
<p>在前面的章节中，我们一直用 ” nice enough &quot; 来定义一个函数其极限值等于函数值的性质。现在我们来定义什么叫做 ” nice enough &quot;。</p>
<p>连续性定义：</p>
<p><img src="continuity1.png" alt=""></p>
<p>反过来说也成立。也就是说如果再这一点 极限值等于函数值，那么函数在这一点具有连续性。反之也成立。</p>
<p><img src="continuity2.png" alt=""></p>
<p>常见的非连续性如下，第一种称为 jump discontinuity ，第二种称为 removable discontinuity 。</p>
<p><img src="continuity3.png" alt=""></p>
<p>如果我们简单地定义连续性，一个函数如果在某一区间具有连续性，我们用铅笔画出这一段从开始到结束的函数图像，中间不需要拿起铅笔（without ever once picking up our pencil ）。也就是能一气呵成的画完这一段。</p>
<p>另外一种解释，如果函数图像 没有 breaks 或 holes（指空心点） ，我们就说它在这一段是连续的。</p>
<h3 id="求复合函数（满足连续）的极限定理（重要）">求复合函数（满足连续）的极限定理（<strong>重要</strong>）</h3>
<p><img src="continuity4.png" alt=""></p>
<h3 id="介值定理（intermediate-value-theorem）">介值定理（intermediate value theorem）</h3>
<p><img src="continuity5.png" alt=""></p>
<p>介值定理的主要应用为，证明函数在某个区间有根。但是介值定理没办法告诉我们具体位置，也没办法证明是几个根。</p>
<p>注意，如果一个值不在两个端点的区间上，不能反推函数在这个区间不存在这个值。</p>
<h3 id="The-Definition-of-the-Limit">The Definition of the Limit</h3>
<p>极限的准确定义：</p>
<p><img src="limit_definition1.png" alt=""></p>
<p>再次重申，极限的定义只是 around a ，而不包括 x = a。我们不关心 x = a 时的情况。</p>
<p>左右极限定义如下：</p>
<p><img src="limit_definition2.png" alt=""></p>
<p><img src="limit_definition3.png" alt=""></p>
<p>极限为正无穷和负无穷的定义如下：</p>
<p><img src="limit_definition4.png" alt=""></p>
<p>x 趋于正负无穷的定义：</p>
<p><img src="limit_definition5.png" alt=""></p>
<p>再次重申：极限一定是不断<strong>趋近</strong>的。</p>
<p>使用极限的精确定义来定义<strong>连续</strong>。注意：连续的定义中 x = a 必须在定义域内，与之前的极限定义不同。</p>
<p><img src="limit_definition6.png" alt=""></p>
<h1>Derivatives</h1>
<p>导数定义：</p>
<p><img src="derivative1.png" alt=""></p>
<p>导数可能并不存在。如果f’(x) 在 x = a 处存在，那么我们称 f(x) 在 x=a 处是<strong>可导</strong>的（<strong>differentiable</strong>）。</p>
<p>如果 f(x) 在 x = a 处可导，那么 f(x) 在 x = a 处是连续的。但反过来并不成立。</p>
<h2 id="Differentiation-Formulas">Differentiation Formulas</h2>
<p><img src="derivative2.png" alt=""></p>
<p><img src="derivative3.png" alt=""></p>
<h2 id="函数乘积和商的求导（product-and-quotient-rule）">函数乘积和商的求导（product and quotient rule）</h2>
<p><img src="derivative4.png" alt=""></p>
<p><img src="derivative5.png" alt=""></p>
<p>多个函数的乘积公式为</p>
<p><img src="derivative6.png" alt=""></p>
<h2 id="Derivatives-of-trig-functions">Derivatives of trig functions</h2>
<p><img src="derivative7.png" alt=""></p>
<p>第二个式子可以通过第一个式子证明，写在书上了。主要应用 1 - cos(x) = sin^2^(x/2)</p>
<p>三角函数求导公式如下。注意，<strong>sec(x) = 1/cos(x)</strong> ; <strong>csc(x) = 1/sin(x)</strong> 。不要搞错了</p>
<p><img src="derivative8.png" alt=""></p>
<h2 id="Derivatives-of-Exponential-and-Logarithm-Functions">Derivatives of Exponential and Logarithm Functions</h2>
<p>自然对数底数e 的定义：</p>
<p><img src="derivative9.png" alt=""></p>
<p>指数函数求导公式（已证明，见后）</p>
<p><img src="derivative10.png" alt=""></p>
<p>逆函数求导公式（已证明）</p>
<p><img src="derivative11.png" alt=""></p>
<p>通过逆函数求导公式，指数函数和对数函数互为逆函数，因此推导出(lnx)’ = 1/x 。</p>
<p><img src="derivative12.png" alt=""></p>
<p>小结一下</p>
<p><img src="derivative13.png" alt=""></p>
<p>注意区分指数函数的求导和多次函数（不知道这个咋称呼）的求导</p>
<p><img src="derivative14.png" alt=""></p>
<h2 id="Derivatives-of-Inverse-Trig-Functions">Derivatives of Inverse Trig Functions</h2>
<p><img src="derivative15.png" alt=""></p>
<h2 id="Derivatives-of-Hyperbolic-Functions">Derivatives of Hyperbolic Functions</h2>
<p>有六种常见的双曲线函数（目前无用，且求导易证明）</p>
<p><img src="derivative16.png" alt=""></p>
<h2 id="Chain-Rule">Chain Rule</h2>
<p>复合函数的求导规则（未证明）</p>
<p>说复合函数不是很准确，这里给出的公式只嵌套了一层，实际可以嵌套n层。所以才叫<strong>Chain Rulu</strong>。求多层嵌套的复合函数需要多加小心，可以不用一步完成，分几步拆解。</p>
<p><img src="derivative17.png" alt=""></p>
<p>我们可以使用Chain Rule 和 (e^x^)’ = e^x^ 证明  (a^x^)’ = a^x^ ln(a)</p>
<h2 id="Implict-Differentiation">Implict Differentiation</h2>
<p>并不是所有的函数都能写成 y = f(x) 。</p>
<p>对于<strong>implict function</strong>，首先要记住，y 或 y(x) 其实是 x 的函数。第二步就是两边同时对x求导。</p>
<p><strong>implict function</strong> 的求导结果往往还包含y。</p>
<h2 id="Related-Rates">Related Rates</h2>
<p>当式子中存在两种函数时，如 x(t) 和 y(t) 。如果其中一个x’(t) 已知，那么就能求出y’(t) 。</p>
<p>在求解包含两种相关的函数的导数时，最重要的是要找到包含两个<strong>related rates</strong>的式子。</p>
<p>如果式子中含有更多的其它函数，需要进行<strong>消元</strong>。</p>
<h2 id="Higher-Order-Derivatives">Higher Order Derivatives</h2>
<p><strong>first derivative</strong> 和 <strong>second derivative</strong></p>
<p>对于多项式，如果其最高项的degree为n，那么其n+1阶求导及其后均为0。</p>
<p><img src="derivative18.png" alt=""></p>
<p>注意多阶导数和函数的n次方写法的区别</p>
<p><img src="derivative19.png" alt=""></p>
<p>高阶导数的写法</p>
<p><img src="derivative20.png" alt=""></p>
<h2 id="Logarithmic-Differentiation">Logarithmic Differentiation</h2>
<p>有时，通过log函数能够简化运算(一般使用<strong>ln()</strong>)。</p>
<p>适用场景</p>
<ol>
<li>式子可以分解为多个式子<strong>相乘</strong>或<strong>相除</strong></li>
<li>y = (f(x))^g(x)^ 。例如 y = x^x^</li>
</ol>
<p>最后，总结一下不同的带有指数的求导公式</p>
<p><img src="derivative21.png" alt=""></p>
<h1>Applications of Derivatives</h1>
<p>求导不仅仅是为了求导，是为了解决实际问题的。</p>
<h2 id="Rates-of-Change">Rates of Change</h2>
<p>复习上一章</p>
<h2 id="Critical-Points">Critical Points</h2>
<p>f(x) 的 Critical Points 的定义：</p>
<p><img src="derivative22.png" alt=""></p>
<p>注意前提中是 f© 必须存在，这个前提很重要但也容易被忽略。</p>
<h2 id="Minimum-and-Maximum-Values">Minimum and Maximum Values</h2>
<p>首先，存在绝对极值和相对极值。很好理解，绝对的极值即在整个定义域内均为最大或最小，而相对的极值仅在某区域内。</p>
<p><img src="derivative23.png" alt=""></p>
<p>一图以蔽之</p>
<p><img src="derivative24.png" alt=""></p>
<p>对于定义域两端的函数值能否成为相对极值，这一点一直有争议。本文中设定定义域两端的函数值不能成为相对极值。</p>
<p>绝对极值只能出现在<strong>相对极值</strong>和<strong>定义域两端的函数值</strong>中。</p>
<p>如果是连续函数，取一闭区间，则必存在绝对最大值和绝对最小值。定理表述如下</p>
<p><img src="derivative25.png" alt=""></p>
<p>但是，这条定理并没有告诉我们绝对极值出现在哪，或者会出现几次。我们知道绝对极值一定存在。</p>
<p>但是定理中规定了要取一闭区间。如果不取区间，那么可能不存在绝对极值。函数在闭区间的连续性也是一个重要的前提。</p>
<p>取到<strong>相对</strong>极值的条件是 Critical Point。定理如下</p>
<p><img src="derivative26.png" alt=""></p>
<p>但是反过来说并不成立，也就是说不是所有的Critical Point 都是相对极值。也就是说相对极值肯定是Critical Point ，Critical Points 是 all possible relative extreme 。</p>
<p>这个定理没说全。如果f’© 不存在，也是Critical Point ，也是 possible relative extreme。</p>
<p>重申一遍，我们说possible relative extreme 也就是说不是所有的Critical Point 都是相对极值。但是我们把所有的Critical Point 都找出来，那么所有的relative extreme 就肯定都在里面了，不会有缺漏。用俗话说，就是宁肯杀错一千，不可放过一个。</p>
<h2 id="Finding-Absolute-Extreme">Finding Absolute Extreme</h2>
<p>书中没说，但感觉这些定理的条件中几乎都需要函数满足<strong>连续性</strong>（continuous)。但是一般用到的函数基本都满足连续性。</p>
<p>首先我们需要根据前面的Extreme Value Theorem 确定函数在给定的闭区间<strong>存在</strong>绝对极值。再根据前面的Fermat’s Theorem ，所有的Critical Points 是 all possible relative extremes 。而根据我们之前的认识，所有的绝对极值只会出现在相对极值或函数区间两端的值中。</p>
<p>因此，所有的Critical Points 加上 函数区间两端的函数值 即是 all possible absolute extremes。</p>
<p>找绝对极值的一般步骤。记得要剔除不在闭区间的Critical Points。</p>
<p><img src="derivative27.png" alt=""></p>
<h2 id="The-shape-of-a-graph-part-I">The shape of a graph,part I</h2>
<p>首先，我们确认<strong>递增</strong>和<strong>递减</strong>的定义</p>
<p><img src="derivative28.png" alt=""></p>
<p>用一阶导数来定义则如下</p>
<p><img src="derivative29.png" alt=""></p>
<p>之前这步其实做过了。</p>
<p>首先确定函数的<strong>连续性</strong>。然后确认Critical Points 。在分割的每个区间内取一点，该点f’(x) (注意不是原函数)的符号即是此区间的符号。</p>
<p>重申：Critical Points 也包括了f’(x) 不存在的情况。这种情况下，f’(x) 也可能改变符号。</p>
<p>知道 f(x) 在哪些区间递增或递减，那么就能画出 f(x) 的草图。</p>
<p>判断Critical Point 是否是相对极值：</p>
<p><img src="derivative30.png" alt=""></p>
<h2 id="The-shape-of-a-graph-part-2">The shape of a graph, part 2</h2>
<p>这里需要用到<strong>二阶导数</strong>，主要是考虑函数的凹凸性(concavity)。如图所示。用书上的话说，函数如果趋于&quot;open up&quot; ，那么就是 Concave Up；如果趋于 &quot; open down &quot; ，那么就是 Concave down。</p>
<p><img src="derivative31.png" alt=""></p>
<p>数学定义：切线在函数上方或下方</p>
<p><img src="derivative32.png" alt=""></p>
<p>concavity 与函数的增减毫无关系。</p>
<p>inflection point 的定义</p>
<p><img src="derivative33.png" alt=""></p>
<p><img src="derivative34.png" alt=""></p>
<p>这里应该写错了，f’'(x) &lt; 0 应该是 concave down 。</p>
<p>因此，infection point 应该是 f’‘(x) = 0  或者 <strong>不存在</strong>的地方。 但是并不是 f’'(x) = 0 或者不存在的地方，就一定是 infection point 。</p>
<p>我们只有通过确认这个点两侧的凹凸性情况，我们才能确认infection point 。</p>
<p>这和前面的相对极值是类似的。所有的相对极值都是critical points ，但是不是所有的 critical points 都是 相对极值。只有确认了这个点两侧的递增递减情况，我们才能确认这个点是不是相对极值。</p>
<p>通过确定凹凸性我们能画出更精细的草图。</p>
<p>根据f&quot;(x) 的符号能确定 Critical point （只适用于f’(x) = 0 ，不适用于不存在）是否是相对极值。定理如下</p>
<p><img src="derivative35.png" alt=""></p>
<p>注意，这里没有说f’(x) 不存在的critical point 的情况。注意第三种情况下如果f’‘(x) = 0 , 那么可能是任何情况。那么就要使用 first derivative test 判断这个 critical point 两侧的f’(x) 的符号。</p>
<h2 id="The-Mean-Value-Theorem">The Mean Value Theorem</h2>
<p>Rolle’s Theorem ：满足一定条件的函数f’(x) ，两个相等的函数值之间一定存在一个点，其f’(x) = 0。</p>
<p><img src="derivative36.png" alt=""></p>
<p>The mean value theorem 如下</p>
<p><img src="derivative37.png" alt=""></p>
<p>一样的，这个定理没有告诉我们 c 在哪 , 只是说至少有一个 c。</p>
<p>Rolle’s Theorem 只是 mean value theorem 的一个特例。</p>
<h2 id="Optimization">Optimization</h2>
<p>求解极值的一般方法：</p>
<ol>
<li>
<p>通过<strong>Finding Absolute Extreme</strong> 方法。从critical points 和 endpoints 中找。需要满足两个条件：闭区间和连续性。</p>
</li>
<li>
<p>通过<strong>First Derivative Test</strong>方法。根据此方法，如果一个点两侧f’(x) 符号不同，则此点为相对极值。要求连续性。 如果只有一个Critical points , 易知如下定理。</p>
<p><img src="derivative38.png" alt=""></p>
</li>
<li>
<p>通过二阶求导。二阶求导的使用主要包括以下方面。一是去除一些critical points ，通过求critical points 的 二阶导数，我们能得知其是否是相对极值。二是如果只有一个critical point，判断其是否是我们要的绝对极值，这和第二点一致。</p>
<p><img src="derivative39.png" alt=""></p>
</li>
</ol>
<h2 id="More-Optimization-Problems">More Optimization Problems</h2>
<p>就是更多的题目。</p>
<p>一个小点：如果 求式子 A = B时，由于有根式，两边平方，A^2^=B^2^，此时求出的解不一定是真的解，需要带入原式进行后验。</p>
<p>证明：A^2^=B^2^ 其解可能是 A =B , 也可能是 A = -B。</p>
<h2 id="Indeterminate-forms-and-L’Hospital’s-Rule">Indeterminate forms and L’Hospital’s Rule</h2>
<p><img src="derivative40.png" alt=""></p>
<p>如果是0/0 或 无穷/无穷，那么其极限等于其一阶导数之商的极限。</p>
<p>对于其它类型的indeterminate forms（不确定形式），可以转换为上述的两种形式。</p>
<p><img src="derivative41.png" alt=""></p>
<h2 id="Linear-Approximations">Linear Approximations</h2>
<p>对于某一点的切线方程，可以用于近似估计附近点的函数值。</p>
<h2 id="Differentials">Differentials</h2>
<p>这里的Differentials 就是指 dy 和 dx</p>
<p>dy = f’(x) dx</p>
<p>dy dx 就是当x变化很小时，x 的变化量和 y 的变化量。</p>
<h2 id="Newton’s-Method">Newton’s Method</h2>
<p>这个方法目前没什么意义了。</p>
<p>估计f(x) 的根</p>
<p><img src="derivative42.png" alt=""></p>
<h2 id="Business-Applications">Business Applications</h2>
<p>商业中的实例。</p>
<h1>Integrals</h1>
<h2 id="Indefinite-Integrals">Indefinite Integrals</h2>
<p>首先我们要知道如何从导数函数反推原函数，注意需要加一个 常数c 。因为常数的导数是0。所以，实际上，如果只知道导数函数，求解出的原函数有无数个（因为c不确定）。</p>
<p>一些基础定义</p>
<p><img src="integral1.png" alt=""></p>
<p>不定积分的部分性质</p>
<p><img src="integral2.png" alt=""></p>
<p><img src="integral3.png" alt=""></p>
<p>积分对于变量之间的<strong>乘</strong>或<strong>除</strong>没有公式。</p>
<p>求解后，可以求导，看是否与被积函数一致。</p>
<h2 id="Computing-Indefinite-Integrals">Computing Indefinite Integrals</h2>
<p>其实和求导公式一致，不过是反过来。</p>
<h2 id="Substitution-Rule-for-Indefinite-Integrals">Substitution Rule for Indefinite Integrals</h2>
<p><img src="integral4.png" alt=""></p>
<p>容易得到，因为 d(g(x)) = g’(x) d(x) 。</p>
<p>替换后积分式子中不能再有x ，要全变成 u 表示的式子。</p>
<h2 id="More-Substitution-Rule">More Substitution Rule</h2>
<h2 id="Area-Problem">Area Problem</h2>
<h2 id="The-Definition-of-the-Definite-Integral">The Definition of the Definite Integral</h2>
<p><img src="integral5.png" alt=""></p>
<p>这里的定义没有说清楚每个小长方形的高选用哪个点的函数值。</p>
<p><img src="integral6.png" alt=""></p>
<p>对定积分的解释之一是，定积分是f(x) 在 x 轴上的<strong>净面积</strong>（net area) 。是原函数从 a 到 b 的变化量。</p>
<p><img src="integral7.png" alt=""></p>
<p><img src="integral8.png" alt=""></p>
<p><img src="integral9.png" alt=""></p>
<p><img src="integral10.png" alt=""></p>
<p>注意，不定积分要求在[a,b]间具有<strong>连续性</strong></p>
<h2 id="Substitution-Rule-for-Definite-Integrals">Substitution Rule for Definite Integrals</h2>
<p>不定积分换元的问题在于，原来的不定积分上下限都是针对x的，而不是u。</p>
<p>有两种策略：1. 最后将u 替换回 x  ; 2. 将原来的上下极限换成u的上下极限。我感觉第二种更方便。</p>
<h1>Applications of Integrals</h1>
<h2 id="Average-Function-Value">Average Function Value</h2>
<p><img src="integral11.png" alt=""></p>
<p><img src="integral12.png" alt=""></p>
<h2 id="Volumes-of-Solids-of-Revolution-Method-of-Rings">Volumes of Solids of Revolution / Method of Rings</h2>
<p>求旋转体的体积，不想看了，以后再看。</p>
<h1>Extras</h1>
<p>其实最后一部分附录是<strong>精华</strong>，看懂这些证明过程很重要。但是人生苦短，我急于初步完成这本书，因此只能先到这了，这一部分没看。2019年12月20号。</p>
<h2 id="Proof-of-Various-Limit-Properties">Proof of Various Limit Properties</h2>
<p>这一部分的证明都是严格根据极限的数学定义证明的，严谨但是繁琐，没看。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Analysis for the Life Sciences</title>
    <url>/posts/3263dd4c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这也是一本数据分析的书籍，用的语言是R，但是貌似我之前没看完……</p>
<span id="more"></span>
<h1>Data Analysis for the Life Sciences</h1>
<h2 id="introduction">introduction</h2>
<p>statistical inference(统计推断)：推断就是使用可能性从数据中获取群体特征值（Inference is the use of probability to learn population characteristic from data）。一个典型的例子就是推断两个群体的平均值是否相同。</p>
<h2 id="getting-started">getting started</h2>
<p>主要是介绍了一些R的基础部分和数学基础。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">###第一章 getting started </span></span><br><span class="line">install.packages(<span class="string">&quot;swirl&quot;</span>)</span><br><span class="line">install.packages(<span class="string">&quot;rafalib&quot;</span>)</span><br><span class="line">install.packages(<span class="string">&quot;downloader&quot;</span>)</span><br><span class="line">setwd(<span class="string">&#x27;D:\\Desktop\\下载英文文献\\模型\\R_model&#x27;</span>)</span><br><span class="line">dat &lt;- read.table(<span class="string">&#x27;female_mouse_weights.txt&#x27;</span>,header = <span class="built_in">T</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">###通过downloader直接下载网上的数据</span></span><br><span class="line">library(downloader) <span class="comment">##use install.packages to install ##通过downloader</span></span><br><span class="line">url &lt;- <span class="string">&quot;https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extd\</span></span><br><span class="line"><span class="string">ata/femaleMiceWeights.csv&quot;</span>  <span class="comment">## 数据的完整路径</span></span><br><span class="line">filename &lt;- <span class="string">&quot;femaleMiceWeights.csv&quot;</span></span><br><span class="line">download(url, destfile=filename) <span class="comment">## 下载，后面更的是下载后的名称</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 为了从GitHub 上直接下载文件夹，你需要下载devtools包</span></span><br><span class="line">library(devtools)</span><br><span class="line">install_github(<span class="string">&quot;genomicsclass/dagdata&quot;</span>)</span><br><span class="line"></span><br><span class="line">dir &lt;- system.file(package = <span class="string">&quot;dagdata&quot;</span>) <span class="comment"># 获取文件夹位置</span></span><br><span class="line">dir  <span class="comment">## &quot;D:/software/R/R-3.6.1/library/dagdata&quot;</span></span><br><span class="line">list.files(dir) <span class="comment"># 查看dir下面的文件和子文件夹</span></span><br><span class="line">list.files(dir,<span class="string">&quot;extdata&quot;</span>) <span class="comment"># 查看extdata下的子文件</span></span><br><span class="line">filename&lt;-file.path(dir,<span class="string">&quot;extdata/femaleMiceWeights.csv&quot;</span>) <span class="comment">## 文件的完整路径</span></span><br><span class="line">dat&lt;-read.csv(filename) <span class="comment">## 最终打开文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####初探dplyr </span></span><br><span class="line">library(<span class="string">&quot;dplyr&quot;</span>)</span><br><span class="line"><span class="comment">##dplyr包中filter是进行数据筛选</span></span><br><span class="line">chow &lt;- filter(dat,Diet==<span class="string">&quot;chow&quot;</span>) <span class="comment">## 筛选Diet列中为chow的数据</span></span><br><span class="line">head(chow)</span><br><span class="line"></span><br><span class="line"><span class="comment">## select貌似是选列</span></span><br><span class="line">chowVals &lt;- select(chow,Bodyweight) <span class="comment">## 选择chow中的Bodyweight列</span></span><br><span class="line">head(chowVals)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 还可以使用通道符 %&gt;% denote a pipe </span></span><br><span class="line"><span class="comment">## 因此上述两步可以合成一步</span></span><br><span class="line">chowVals &lt;- filter(dat,Diet==<span class="string">&quot;chow&quot;</span>) %&gt;% select(Bodyweight)</span><br><span class="line">head(chowVals)</span><br><span class="line"><span class="comment">## dplyr接收的是data.frame ，返回的也是data.frame</span></span><br><span class="line"><span class="built_in">class</span>(chowVals) <span class="comment">#data.frame</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 为了使结果为向量，可以使用unlist函数。将list(包括data.frame)转换成numeric vectors. </span></span><br><span class="line">chowVals &lt;- filter(dat,Diet==<span class="string">&quot;chow&quot;</span>) %&gt;% select(Bodyweight) %&gt;% unlist</span><br><span class="line"><span class="comment">## 通道少写一个参数，但是这里的unlist连()都省了</span></span><br><span class="line"><span class="built_in">class</span>(chowVals) <span class="comment">#numeric </span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 不用dplyr的写法</span></span><br><span class="line">chowVals &lt;- dat[dat$Diet==<span class="string">&quot;chow&quot;</span>,<span class="string">&quot;Bodyweight&quot;</span>]</span><br><span class="line">head(chowVals)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 小结，感觉R整理数据就是不太方便。</span></span><br></pre></td></tr></table></figure>
<h2 id="inference">inference</h2>
<p>以下为random variable,  null distribution,  p-value 的 简要介绍。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#inference</span></span><br><span class="line">setwd(<span class="string">&#x27;D:\\Desktop\\下载英文文献\\模型\\R_model&#x27;</span>)</span><br><span class="line">dat &lt;- read.table(<span class="string">&#x27;female_mouse_weights.txt&#x27;</span>,header = <span class="built_in">T</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#####didtribution 的解析</span></span><br><span class="line"><span class="comment">#distribution：可以简单地理解为一堆数。</span></span><br><span class="line"><span class="comment">#比如你测量了一个群体中所有人的身高。</span></span><br><span class="line"><span class="comment">#这个时候你要和其他人不懂的人（such as analien that has never visited Earth）描述这些数字。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#假如以下就是你取得的身高数据</span></span><br><span class="line">library(UsingR)</span><br><span class="line">x &lt;- father.son$fheight</span><br><span class="line"></span><br><span class="line"><span class="comment">#最简单的就是列出来给外星人看</span></span><br><span class="line"><span class="built_in">round</span>(sample(x,<span class="number">10</span>),<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#但这不够充分，我们可以定义一个累积分布函数（Cumulative Distribution Function）</span></span><br><span class="line"><span class="comment">#F(a) == Pr(x&lt;a) #小于等于号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#画图如下</span></span><br><span class="line"><span class="comment"># floor ceiling 是取整用的</span></span><br><span class="line"><span class="comment"># floor 是直接取整数，ceiling 是 “天花板” </span></span><br><span class="line"><span class="comment"># 如 floor(2.99) = 2 ceiling(2.99) = 3</span></span><br><span class="line"><span class="comment"># 用在画图还是挺好的</span></span><br><span class="line"></span><br><span class="line">smallest&lt;-<span class="built_in">floor</span>( <span class="built_in">min</span>(x) )</span><br><span class="line">largest&lt;-<span class="built_in">ceiling</span>( <span class="built_in">max</span>(x) )</span><br><span class="line">values&lt;-seq(smallest, largest,len=<span class="number">300</span>)</span><br><span class="line">heightecdf&lt;-ecdf(x)</span><br><span class="line">plot(values, heightecdf(values), type=<span class="string">&quot;l&quot;</span>,xlab=<span class="string">&quot;a (Height in inches)&quot;</span>,ylab=<span class="string">&quot;Pr(x &lt;= a)&quot;</span>)</span><br><span class="line"><span class="comment"># 但是现在更常见的是画直方图</span></span><br><span class="line"><span class="comment"># 把直方图给外星人一看，基本就很清晰了。</span></span><br><span class="line">hist(x)</span><br><span class="line">bins&lt;-seq(smallest, largest)</span><br><span class="line">hist(x,breaks=bins,xlab=<span class="string">&quot;Height (in inches)&quot;</span>,main=<span class="string">&quot;Adult men heights&quot;</span>)</span><br><span class="line"><span class="comment">#breaks设置中，不用floor,ceiling 画不成图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####回到正题</span></span><br><span class="line">library(dplyr)</span><br><span class="line">control &lt;- filter(dat,Diet==<span class="string">&quot;chow&quot;</span>) %&gt;% select(Bodyweight) %&gt;% unlist</span><br><span class="line">treatment  &lt;- filter(dat,Diet==<span class="string">&quot;hf&quot;</span>) %&gt;% select(Bodyweight) %&gt;% unlist</span><br><span class="line">mean(treatment)</span><br><span class="line">mean(control)</span><br><span class="line">obsdiff &lt;- mean(treatment) - mean(control)</span><br><span class="line">obsdiff</span><br><span class="line"><span class="comment">#[1] 3.020833</span></span><br><span class="line"><span class="comment">#只看均值和差值是不够的</span></span><br><span class="line"><span class="comment">#因为如果你再取24只老鼠重新做试验，每一次都能得到一个新的结果。</span></span><br><span class="line"><span class="comment">#我们把具有这种特性的数据称为随机变量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####更深刻地理解随机变量###########</span></span><br><span class="line"><span class="comment"># 假设我们有所有的control群体，如下</span></span><br><span class="line">library(downloader)</span><br><span class="line">url&lt;-<span class="string">&quot;https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extdata/femaleControlsPopulation.csv&quot;</span></span><br><span class="line">filename&lt;-<span class="string">&quot;femaleControlsPopulation.csv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!file.exists(filename)) download(url,destfile=filename)</span><br><span class="line"><span class="comment">#如果文件不存在则下载</span></span><br><span class="line"></span><br><span class="line">population&lt;-read.csv(filename)</span><br><span class="line"></span><br><span class="line">population &lt;- unlist(population) <span class="comment">#从data.frame 转为 vector</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#从总体中每次随机抽取12只老鼠，重复三次，每次均值均不同</span></span><br><span class="line"></span><br><span class="line">control&lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">mean(control)</span><br><span class="line"><span class="comment">#[1] 23.4925</span></span><br><span class="line"></span><br><span class="line">control&lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">mean(control)</span><br><span class="line"><span class="comment">#[1] 24.96583</span></span><br><span class="line"></span><br><span class="line">control&lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">mean(control)</span><br><span class="line"><span class="comment">#[1] 22.90083</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#因此哪怕同一个群体，抽取不同的样本，之间也是有差异的。</span></span><br><span class="line"><span class="comment">#所以对于上面两个群体的obsdiff，我们存有怀疑，这究竟是不是因为影响因素（diet）造成的</span></span><br><span class="line"><span class="comment">#如果我们给这24只老鼠相同的diet，差异还有有这么大吗？</span></span><br><span class="line"><span class="comment">#出于怀疑精神，一般统计推断的零假设（null hypothesis）会设定为两个群体没有区别。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#由于我们有了control的总体，所以我们可以无限次抽样。</span></span><br><span class="line"><span class="comment">#每次从control的群体中，抽2批12只老鼠，求均值。代码如下</span></span><br><span class="line"></span><br><span class="line">control&lt;-sample(population,<span class="number">12</span>)</span><br><span class="line"><span class="comment">##another 12 control mice that we act as if they were not</span></span><br><span class="line">treatment &lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">print(mean(treatment)-mean(control))</span><br><span class="line"><span class="comment">#[1] -1.175</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#现在让我们重复这一步骤10000次</span></span><br><span class="line"></span><br><span class="line">null &lt;- vector()</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">10000</span>)&#123;</span><br><span class="line">  control&lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">  treatment &lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">  null[i] &lt;- mean(treatment)-mean(control)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在在null中的值我们称之为null distribution</span></span><br><span class="line"></span><br><span class="line">mean(null&gt;=obsdiff)</span><br><span class="line"><span class="comment"># [1] 0.0147</span></span><br><span class="line"><span class="comment">#mean里面的是一个布尔向量，由TRUE和FALSE组成</span></span><br><span class="line"><span class="comment">#但是在计算的过程中，TRUE视为1，FALSE视为0。</span></span><br><span class="line"><span class="comment">#所以这个0.0147是这10000次中差距大于obsdiff的比例。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#因此作为一个怀疑主义者，我们可以得出结论</span></span><br><span class="line"><span class="comment">#如果没有diet effect，我们看到像obsdiff这么的差距的可能性是1.47%</span></span><br><span class="line"><span class="comment">#这就是所谓的P值！</span></span><br><span class="line"><span class="comment">#p值即原假设成立的前提下，此事件发生的概率。</span></span><br><span class="line"><span class="comment">#深入浅出，厉害！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#小结一下，像上述这样计算P值很简单。但是生活中不可行。</span></span><br><span class="line"><span class="comment">#因为你不肯真的把测量整个群体的信息，从而构成null distribution。</span></span><br><span class="line"><span class="comment">#一般也还是通过采样。</span></span><br><span class="line"><span class="comment">#也就是还是只通过数据中的24只老鼠的数据进行判断。</span></span><br></pre></td></tr></table></figure>
<h3 id="population-parameters">population parameters</h3>
<p>统计推断的第一步是弄清楚你感兴趣的群体。作者选这个这个小鼠的数据集的原因之一，是因为作者有所有这种类型的小鼠的体重信息（即这个群体的所有群体）。</p>
<p>如果你能收集你感兴趣的群体的所有数据，那么得到的参数（群体均值、方差、标准差）就被称为群体参数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(downloader)</span><br><span class="line">url&lt;-<span class="string">&quot;https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extdata/mice_pheno.csv&quot;</span></span><br><span class="line">filename&lt;-<span class="string">&quot;mice_pheno.csv&quot;</span> </span><br><span class="line">download(url,destfile=filename)</span><br><span class="line">dat&lt;-read.csv(filename) <span class="comment">#这是所有这个小鼠群体的数据</span></span><br><span class="line"></span><br><span class="line">library(dplyr)</span><br><span class="line">controlPopulation &lt;- filter(dat,Sex==<span class="string">&quot;F&quot;</span>&amp;Diet==<span class="string">&quot;chow&quot;</span>) </span><br><span class="line"><span class="built_in">length</span>(controlPopulation$Bodyweight)</span><br><span class="line"></span><br><span class="line">hfPopulation&lt;-filter(dat,Sex==<span class="string">&quot;F&quot;</span>&amp;Diet==<span class="string">&quot;hf&quot;</span>)</span><br><span class="line"><span class="built_in">length</span>(hfPopulation$Bodyweight)</span><br><span class="line"><span class="comment">#此时群体的均值、方差、标准差等就被称为群体参数（population parameters）</span></span><br><span class="line"><span class="comment">#此时回到我们的问题，两个群体的均值是否相等。</span></span><br><span class="line"><span class="comment">#由于我们拿到了两个群体的所有数据，那么用μy-ux（x:control y:hf）,直接看差值是否为0即可。</span></span><br></pre></td></tr></table></figure>
<p>但是，在实际生活中，我们拿不到群体的所有数据。比如，可能买下一个群体所有的小鼠是很贵的。<br>
因此，我们需要学会如何从样本数据来回答我们的问题。这就是统计推断的本质。</p>
<h3 id="Sample-estimates">Sample estimates</h3>
<p>在之前的章节中，我们从两个群体中各随机抽取了12只小鼠。我们一般用大写字母来表示抽样个体，以此表明他们是随机抽取的。这也是统计中的一种常规做法。因此抽样个体表示为X~1~ ……X~12~ 和 Y~1~ …… Y~12~。<br>
而对于上面的群体中的个体，用的是小写数字。因为这些个体是给定的，不是随机的。<br>
此时，研究目标是两个样本群体均值的差值。<br>
而这个差值也是一个随机变量（random variable）。前面，我们采用一种从原始数据中重复抽样的手段（10000次）。但是，这在实际中（in practice）是不可实现的，比如在我们这个例子中，就是要不断地买24只小鼠做试验。<br>
下面会介绍群体均值差与样本均值差的关系。这涉及到了中心极限定理。</p>
<h3 id="Central-Limit-Theorem-and-t-distribution">Central Limit Theorem and t-distribution</h3>
<p><strong>中心极限定理</strong>：<strong>无论群体总体服从什么分布</strong>，当抽样个体数足够大时（一般认为，每组大于等于30个），抽样群体的均值（Y拔）服从正态分布。其均值为群体均值，其标准差等于群体标准差除以根号N（N 为 simple size）。我们把这个随机变量分布的标准差称为标准误（<em>standard error</em>）。</p>
<ul>
<li>对于一个随机变量，加减常数（X+a），则该随机变量的均值也随之变化（u~X~+a）</li>
<li>对于一个随机变量，乘以一个常数（X*a），则该随机变量的均值和标准差也乘以此常数</li>
<li>对于两个独立的随机变量相加（X+Y），其均值为μ~X~+μ~Y~，其方差为二者之和。如果是两个独立的随机变量相减，其均值为二者之差，其方差仍未<strong>二者之和</strong>。</li>
<li>如果两个随机变量都满足正态分布，那么它们只和仍满足正态分布。</li>
</ul>
<p>在本例中，我们关心的两个群体的均值，由于中心极限定理，服从正态分布。因此它们的差值也服从正态分布，均值为两个随机变量之差，方差为<strong>两个随机变量之和</strong>。由于原假设是不存在差异，那么两个群体的均值的均值应该大致服从一个均值为0，标准差为√（σ2X+σ2Y）/√N的正态分布。<br>
也就是如下式</p>
<p><img src="clt.png" alt="clt"></p>
<p>这个进行了标准化的随机变量应该满足（0，1）的标准正态分布。（深入浅出！）</p>
<p>根据这个公式，我们可以更快地求出P值（已知标准正态分布）。例如，正态分布中大于2的值只有5%（in absolute value，应该是双尾的意思）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">pnorm(-<span class="number">2</span>)+(<span class="number">1</span>-pnorm(<span class="number">2</span>))</span><br><span class="line"><span class="comment">## [1] 0.04550026</span></span><br></pre></td></tr></table></figure>
<p>因此，我们不用再买更多的小鼠，24只够了。</p>
<p>然而，事情到这一步还没有结束。因为我们不知道群体的标准差，σ~X~和σ~Y~。这些都是不可知的群体参数。但是我们可以用样本标准差去估计群体标准差，称为s~X~ 和 s~Y~。定义如下：</p>
<p><img src="s2.png" alt="s2"></p>
<p>这里是除以M-1 和 N-1（出于理论原因，没解释）。</p>
<p>因此，我们可以把上式改为：</p>
<p><img src="clt_new.png" alt="t_value"></p>
<p>中心极限定理告诉我们，当M,N较大时，这个随机变量服从标准正态分布（零假设下）。因此，我们现在可以计算P值了。</p>
<h3 id="t-分布">t 分布</h3>
<p>中心极限定理需要较大的抽样个体数，这个我们称之为<em>asymptotic results</em>。当这个条件不满足时，还有一种方法可以使用。如果总体数据服从一个均值为0的正态分布，那么对于我们的抽样个体均值，可以计算以下分布，称为t分布：</p>
<p><img src="t-distribution.png" alt="t-distribution"></p>
<p>这里很重要的一点，我们提到的服从正态分布是总体（y1,y2,……yn）服从正态分布，而不是Y拔。虽然无法实际证明，但是我们看一看抽样个体的分布。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">control &lt;- controlPopulation$Bodyweight</span><br><span class="line">hf &lt;- hfPopulation$Bodyweight</span><br><span class="line"><span class="comment"># 直方图</span></span><br><span class="line">op &lt;- par(mfrow = <span class="built_in">c</span>(<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line">hist(control)</span><br><span class="line">hist(hf)</span><br><span class="line">par(op)</span><br></pre></td></tr></table></figure>
<p>更为直观的是，画一个QQ（quantie，分位数）图。分位数的实例之一就是四分位数。QQ图的个人理解为，对于x轴上的一点，能得到x分布中小于等于这个点的概率（比如5%）; 再找到y分布中对应5%概率的实际数值，即y值，这样就得到了一个点（x,y)。</p>
<ul>
<li>如果是离散变量，</li>
</ul>
<blockquote>
<p>在统计学中，QQ图[1] （Q代表分位数Quantile）是一种通过比较两个概率分布的分位数对这两个概率分布进行比较的概率图方法。首先选定分位数的对应概率区间集合，在此概率区间上，点(x,y)对应于第一个分布的一个分位数x和第二个分布在和x相同概率区间上相同的分位数。因此画出的是一条含参数的曲线，参数为概率区间的分割数。</p>
</blockquote>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">op &lt;- par(mfrow = <span class="built_in">c</span>(<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line">qqnorm(hf)</span><br><span class="line">qqline(hf)</span><br><span class="line">qqnorm(control)</span><br><span class="line">qqline(control)</span><br><span class="line">par(op)</span><br></pre></td></tr></table></figure>
<p>在R中，var() 和 sd() 函数都是用于计算样本参数（即除以n-1）。不适用于计算群体参数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x &lt;- control</span><br><span class="line">N &lt;- <span class="built_in">length</span>(x)</span><br><span class="line">populationvar &lt;- mean((x-mean(x))^<span class="number">2</span>)</span><br><span class="line">identical(var(x),populationvar)</span><br><span class="line"><span class="comment">#identical 判断两个值是否相等。</span></span><br><span class="line"><span class="comment">#R中的var() 和 sd() 都是除以n-1。</span></span><br></pre></td></tr></table></figure>
<p>但是实际中，我们没有用到计算总体参数的地方（得不到）。这里为了教学，用了popvar(), popsd() 函数 计算总体参数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(<span class="string">&#x27;rafalib&#x27;</span>)</span><br><span class="line">sd_hf &lt;- popsd(hf)</span><br><span class="line">sd_control &lt;- popsd(control)</span><br></pre></td></tr></table></figure>
<p>一般我们也只能得到样本，如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N &lt;- 12</span><br><span class="line">hf_sample &lt;- sample(hf,<span class="number">12</span>)</span><br><span class="line">control_sample &lt;- sample(control,<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<p>为了 进一步了解中心极限定理，这里采用不同的抽样大小进行抽样</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对不同地抽样个体数，抽样10000次</span></span><br><span class="line"><span class="comment">#sapple 对Ns中的每一个数，执行后面的函数</span></span><br><span class="line">Ns&lt;-<span class="built_in">c</span>(<span class="number">3</span>,<span class="number">12</span>,<span class="number">25</span>,<span class="number">50</span>)</span><br><span class="line">B &lt;-  10000   <span class="comment">#number of simulations</span></span><br><span class="line">res&lt;-sapply(Ns,<span class="keyword">function</span>(n) &#123;</span><br><span class="line">  replicate(B,mean(sample(hf,n))-mean(sample(control,n)))</span><br><span class="line">&#125;)</span><br><span class="line">res</span><br><span class="line"></span><br><span class="line"><span class="comment">## 现在我们可以用qq图看中心极限定理的效果如何</span></span><br><span class="line">op &lt;- par(mfrow=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> seq(along=Ns)) &#123;    <span class="comment"># 等于 seq(length(Ns))</span></span><br><span class="line">  titleavg&lt;-<span class="built_in">signif</span>(mean(res[,i]),<span class="number">3</span>) <span class="comment">#signif和round差不多，不过后面不是小数位数，而是有效数字。</span></span><br><span class="line">  titlesd&lt;-<span class="built_in">signif</span>(popsd(res[,i]),<span class="number">3</span>)</span><br><span class="line">  title&lt;-paste0(<span class="string">&quot;N=&quot;</span>,Ns[i],<span class="string">&quot;Avg=&quot;</span>,titleavg,<span class="string">&quot;SD=&quot;</span>,titlesd)</span><br><span class="line">  qqnorm(res[,i],main=title)</span><br><span class="line">  qqline(res[,i],col=<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#随着抽样数目的增加，标准误越小。基本符合根号N的规律。</span></span><br><span class="line"><span class="comment">#即便抽样数目为3，也基本符合正态分布。</span></span><br><span class="line"><span class="comment">#这和总体分布有关。因为我们这个小鼠体重分布本身就接近正态分布。哪怕采样个体为1，也会符合正态分布。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是在实践中，我们不会只求均值，而是会除以标准差。此时采样个数就重要了</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Ns&lt;-<span class="built_in">c</span>(<span class="number">3</span>,<span class="number">12</span>,<span class="number">25</span>,<span class="number">50</span>)</span><br><span class="line">B&lt;-<span class="number">10000</span><span class="comment">#number of simulations#</span></span><br><span class="line"><span class="comment">#function to compute a t-stat</span></span><br><span class="line">computetstat&lt;-<span class="keyword">function</span>(n) &#123;</span><br><span class="line">  y&lt;-sample(hfPopulation,n)</span><br><span class="line">  x&lt;-sample(controlPopulation,n)</span><br><span class="line">  (mean(y)-mean(x))/<span class="built_in">sqrt</span>(var(y)/n+var(x)/n)</span><br><span class="line">  &#125;</span><br><span class="line">res&lt;-sapply(Ns,<span class="keyword">function</span>(n) &#123;</span><br><span class="line">  replicate(B,computetstat(n))</span><br><span class="line">  &#125;)</span><br><span class="line">op &lt;- par(mfrow=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> seq(along=Ns)) &#123;</span><br><span class="line">  qqnorm(res[,i],main=Ns[i])</span><br><span class="line">  qqline(res[,i],col=<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">#此时N=3已经有些偏离，而N=12只有轻微偏离</span></span><br><span class="line"><span class="comment">#因此N=12已经够了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是这种模拟在实际中无法做到。这里只用于说明CLT的概念和局限。</p>
<h3 id="t-tests-in-Partice">t-tests in Partice</h3>
<p>逻辑线：</p>
<ol>
<li>首先我们得到了两个样本群体的均值差，这本身也是一个随机变量。而且根据零假设，这个变量分布的均值为0。</li>
<li>那么这个均值差分布的标准误（差）呢？</li>
<li>首先我们根据中心极限定理，每个群体均值服从正态分布，标准误为总体标准差（这里直接用样本标准差估计总体标准差）除以根号N。</li>
<li>但这仅仅是每个样本均值的标准误（或者说标准差，其实我觉得这里说标准误和标准差是一回事，标准误就是均值的标准差，所以不还是标准差吗？这里说的均值差的标准误其实也就是均值差的标准差。）</li>
<li>我们根据统计理论，我们知道两个随机变量差值的方差等于这两个随机变量的方差之和（var(x-y)=var(x)+var(y))</li>
<li>因此se = sd( x-y ) = sqrt(var(x)+var(y)) =  sqrt( sd(x)/sqrt(n) + (sd(y)/sqrt(m) )</li>
<li>tstat &lt;- diff(-0)/se</li>
<li>这就是t统计量，由于除以了se，这个统计量的SE为1。</li>
<li>因此我们只要知道这个t统计量的分布，我们就能得到P值。</li>
<li>根据中心极限定理，当<strong>抽样个体数较大</strong>时，两个抽样均值均符合正态分布。根据统计理论，那么这两个随机变量之差也服从正态分布。因此此时这个tstat也是服从<strong>均值为0，方差为1的正态分布</strong></li>
<li>那么计算为了计算P值，我们需要问：在正态分布中，出现diff或比diff（tstat）更极端的值的概率是多大？（ how often does a normally distributed randomvariable exceeddiff?）我们可以通过pnorm()函数进行计算双尾概率。</li>
<li>在本例中，p-value 小于 0.05， 我们认为差异是显著的。（深入理解P值，P值是零假设成立下该事件发生的概率）</li>
<li>但是我们又面临另一个问题。中心极限定理只有在样本量较大时适用，但是12足够大了吗？一般我们认为样本数大于30才比较好。所以我们刚刚计算的P值只有在这个成立时才有效，所以这里可能不适用。然而，除了使用中心极限定理，我们这里有另一种方法。</li>
</ol>
<p>R代码如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dat&lt;-read.csv(<span class="string">&quot;femaleMiceWeights.csv&quot;</span>)<span class="comment">#previously downloaded</span></span><br><span class="line">control&lt;-filter(dat,Diet==<span class="string">&quot;chow&quot;</span>)%&gt;%select(Bodyweight)%&gt;%unlist</span><br><span class="line">treatment&lt;-filter(dat,Diet==<span class="string">&quot;hf&quot;</span>)%&gt;%select(Bodyweight)%&gt;%unlist</span><br><span class="line">diff&lt;-mean(treatment)-mean(control)</span><br><span class="line">print(diff)</span><br><span class="line"><span class="comment">## [1] 3.020833</span></span><br><span class="line"></span><br><span class="line">se&lt;-<span class="built_in">sqrt</span>(</span><br><span class="line">  var(treatment)/<span class="built_in">length</span>(treatment) + </span><br><span class="line">    var(control)/<span class="built_in">length</span>(control)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">tstat&lt;-diff/se</span><br><span class="line"><span class="comment">## [1] 2.055174</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##tstat在标准正态分布中出现的概率(双尾)</span></span><br><span class="line"><span class="comment">##也就是在标准正态分布中出现tstat及比tstat更极端的值的概率</span></span><br><span class="line">righttail&lt;-<span class="number">1</span>-pnorm(<span class="built_in">abs</span>(tstat))</span><br><span class="line">lefttail&lt;-pnorm(-<span class="built_in">abs</span>(tstat))</span><br><span class="line">pval&lt;-lefttail+righttail</span><br><span class="line">print(pval)</span><br><span class="line"></span><br><span class="line"><span class="comment">## [1] 0.0398622</span></span><br></pre></td></tr></table></figure>
<h3 id="The-t-distribution-in-Practice">The t-distribution in Practice</h3>
<p>根据上面的模拟情况和统计理论。 如果<strong>总体的分布是正态的</strong>，那么我们可以<strong>不通过中心极限定理</strong>，而弄清楚t统计量的确切分布。但是如果抽样个体数很少，很难证明总体分布是否符合正态。但是对于体重这种数据，根据经验，我们一般认为总体分布极可能大致符合正态分布，因此我们可以利用这种近似。另外，我们也可以看一下样本的qq图，如下所示。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">op &lt;- par(mfrow=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">qqnorm(treatment)</span><br><span class="line">qqline(treatment,col=<span class="number">2</span>)</span><br><span class="line">qqnorm(control)</span><br><span class="line">qqline(control,col=<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果我们近似认为<strong>总体分布符合正态分布</strong>，那么基于统计理论，tstat服从t分布。相较于正态分布，t分布还有一个自由度的参数。我们直接通过下面的函数求解P值。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">t.test(treatment,control)</span><br><span class="line"></span><br><span class="line">t.test(treatment,control)$p.value <span class="comment">### 直接看P值</span></span><br><span class="line"><span class="comment">## [1] 0.05299888</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>The p-value is slightly bigger now. This is to be expected because our CLT approximation consideredthe denominator oftstatpractically fixed (with large samples it practically is), while the t-distribution approximation takes into account that the denominator (the standard error of thedifference) is a random variable. The smaller the sample size, the more the denominator varies.</p>
</blockquote>
<p>这段话没看太懂，大概理解是：这里用t分布计算出来的p值相较于上面用正态分布计算出来的P值较大。这是因为在CLT中，认为tstat的分母部分是固定的（也就是认为采用了大样本）；而t分布检验中认为tstat的分母部分是随机变量（还不是很懂）。</p>
<p>这可能会让人困惑，怎么会得到两个P值？但是，这在数据分析中是很常见的。通过不同的假设，不同的方法，我们就会得到不同的结果。</p>
<p>其实，基于中心极限定理得到的结果更容易出现<strong>假阳性</strong>，而基于t分布的结果更容易出现<strong>假阴性</strong>。</p>
<h3 id="Confidence-Intervals">Confidence Intervals</h3>
<p>在生命科学中，我们总是需要计算P值。但是我们并不推崇把P值当成唯一的统计指标。原因很简单：统计意义上的显著并不保证科学意义上的显著。当抽样个体数很大时，即便两个群体差异很小，你仍可以检测到一个统计意义上的显著差异。但是这有意义吗？如果只看P值，信息是不够的。还需要给出效应大小（这里是两个群体均值差）。<br>
另一种方法是给出置信区间。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#以control群体均值的置信区间为例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#先看总体的均值</span></span><br><span class="line">dat&lt;-read.csv(<span class="string">&quot;mice_pheno.csv&quot;</span>)</span><br><span class="line">chowPopulation&lt;-dat[dat$Sex==<span class="string">&quot;F&quot;</span>&amp;dat$Diet==<span class="string">&quot;chow&quot;</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">mu_chow&lt;-mean(chowPopulation)</span><br><span class="line">print(mu_chow)</span><br><span class="line"><span class="comment">## [1] 23.89338</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##我们是要估计这个参数，但是我们实际拿不到总体的数据</span></span><br><span class="line"><span class="comment">## 先抽取样本量为30的样本</span></span><br><span class="line"></span><br><span class="line">N&lt;-<span class="number">30</span></span><br><span class="line">chow&lt;-sample(chowPopulation,N)</span><br><span class="line">print(mean(chow))</span><br><span class="line"><span class="comment">## [1] 24.54567</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#我们知道样本均值是一个随机变量</span></span><br><span class="line"><span class="comment">#所以，这个值不是一个完美的估计</span></span><br><span class="line"><span class="comment">#通过置信区间来体现这个随机变量的variability</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#因为样本量为30，我们可以使用CLT。</span></span><br><span class="line"><span class="comment">#中心极限定理告诉我们，样本均值服从一个均值为总体均值，标准差为总体标准差除以根号30的正态分布。</span></span><br><span class="line"></span><br><span class="line">se&lt;-sd(chow)/<span class="built_in">sqrt</span>(N)</span><br><span class="line">print(se)</span><br><span class="line"><span class="comment">## [1] 0.6610814</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>A 95% confidence interval (we can use percentages other than 95%) is a random interval with a95% probability of falling on the parameter we are estimating. Keep in mind that saying 95% ofrandom intervals will fall on the true value (our definition above) isnot the sameas saying there isa 95% chance that the true value falls in our interval.(有点绕，没太懂。懂了，这个置信区间其实也是一个随机变量，你再抽一个样，这个置信区间也会变。所以你只能说置信区间（随机变量）从统计上说有95%的概率包含真值（你要是取10000个样本，计算出10000个置信区间，其中包含总体均值的概率在95%左右）。但是，如果是一个给定的区间(你最后计算出来的区间)，那么真值存在这个区间的概率只有0和1)</p>
</blockquote>
<p>由中心极限定理，我们可以对样本均值进行标准化。然后我们知道标准正态分布的95%区间大致在[-2,2]。因此可以得出下式</p>
<p><img src="confidence_interval.png" alt="confidence_interval"></p>
<p>我们直接得出置信区间</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Q&lt;-qnorm(<span class="number">1</span>-<span class="number">0.05</span>/<span class="number">2</span>)</span><br><span class="line">interval&lt;-<span class="built_in">c</span>(mean(chow)-Q*se, mean(chow)+Q*se )</span><br><span class="line">interval</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>模拟n次置信区间</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(rafalib)</span><br><span class="line">B&lt;-<span class="number">250</span></span><br><span class="line">mypar()</span><br><span class="line">plot(mean(chowPopulation)+<span class="built_in">c</span>(-<span class="number">7</span>,<span class="number">7</span>),<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>),type=<span class="string">&quot;n&quot;</span>,</span><br><span class="line">	xlab=<span class="string">&quot;weight&quot;</span>,ylab=<span class="string">&quot;interval&quot;</span>,ylim=<span class="built_in">c</span>(<span class="number">1</span>,B))</span><br><span class="line">	abline(v=mean(chowPopulation))</span><br><span class="line">	<span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:B) &#123;</span><br><span class="line">	chow&lt;-sample(chowPopulation,N)</span><br><span class="line">	se&lt;-sd(chow)/<span class="built_in">sqrt</span>(N)</span><br><span class="line">	interval&lt;-<span class="built_in">c</span>(mean(chow)-Q*se, mean(chow)+Q*se)</span><br><span class="line">	covered&lt;-</span><br><span class="line">		mean(chowPopulation) &lt;=interval[<span class="number">2</span>]&amp;mean(chowPopulation)&gt;=interval[<span class="number">1</span>]</span><br><span class="line">	color&lt;-ifelse(covered,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">	lines(interval, <span class="built_in">c</span>(i,i),col=color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个代码画出了250次置信区间的图（代码内容没看）。其中大概有5%的置信区间没有包含总体均值。</p>
<p>但是上面是因为抽样个体较多（N = 30），满足了中心极限定理。如果 N = 5，那么这样做也有效吗？我们就模拟这种N =5，使用CLT的情况。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N &lt;- 5</span><br><span class="line">mypar()</span><br><span class="line">plot(mean(chowPopulation)+<span class="built_in">c</span>(-<span class="number">7</span>,<span class="number">7</span>),<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>),type=<span class="string">&quot;n&quot;</span>,</span><br><span class="line">     xlab=<span class="string">&quot;weight&quot;</span>,ylab=<span class="string">&quot;interval&quot;</span>,ylim=<span class="built_in">c</span>(<span class="number">1</span>,B))</span><br><span class="line">abline(v=mean(chowPopulation))</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:B)&#123;</span><br><span class="line">  chow&lt;-sample(chowPopulation,N)</span><br><span class="line">  se&lt;-sd(chow)/<span class="built_in">sqrt</span>(N)</span><br><span class="line">  interval&lt;-<span class="built_in">c</span>(mean(chow)-Q*se, mean(chow)+Q*se)</span><br><span class="line">  covered&lt;- mean(chowPopulation) &lt;=interval[<span class="number">2</span>]&amp;mean(chowPopulation)&gt;=interval[<span class="number">1</span>]</span><br><span class="line">  color &lt;- ifelse(covered,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">  lines(interval, <span class="built_in">c</span>(i,i),col=color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们发现置信区间的宽度增加了，但是没有覆盖真值的情况却多了很多。这是因为这里我们通过CLT错误地认为样本均值符合正态分布，但是实际上相较于正态它两侧的尾巴更大（It has a fatter tail）。这影响到了我们Q值的计算（这里是-2到2）。这种情况下，采用t分布更合适。所以我们只需用qt() 函数来计算Q就可以了，其它不变。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N &lt;- 5</span><br><span class="line">Q&lt;-qt(<span class="number">1</span>-<span class="number">0.05</span>/<span class="number">2</span>, df=<span class="number">4</span>)</span><br><span class="line">mypar()</span><br><span class="line">plot(mean(chowPopulation)+<span class="built_in">c</span>(-<span class="number">7</span>,<span class="number">7</span>),<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>),type=<span class="string">&quot;n&quot;</span>,</span><br><span class="line">     xlab=<span class="string">&quot;weight&quot;</span>,ylab=<span class="string">&quot;interval&quot;</span>,ylim=<span class="built_in">c</span>(<span class="number">1</span>,B))</span><br><span class="line">abline(v=mean(chowPopulation))</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:B)&#123;</span><br><span class="line">  chow&lt;-sample(chowPopulation,N)</span><br><span class="line">  se&lt;-sd(chow)/<span class="built_in">sqrt</span>(N)</span><br><span class="line">  interval&lt;-<span class="built_in">c</span>(mean(chow)-Q*se, mean(chow)+Q*se)</span><br><span class="line">  covered&lt;- mean(chowPopulation) &lt;=interval[<span class="number">2</span>]&amp;mean(chowPopulation)&gt;=interval[<span class="number">1</span>]</span><br><span class="line">  color &lt;- ifelse(covered,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">  lines(interval, <span class="built_in">c</span>(i,i),col=color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们看到置信区间的宽度<strong>进一步</strong>（相较于CLT）增加了（因为t分布尾巴厚，得到的Q值更大），但是基本符合了95%的概率。</p>
<h3 id="置信区间和P值的关系">置信区间和P值的关系</h3>
<p>我们推荐在实际中更多的使用置信区间，而不是P值。</p>
<p>如果你给出P值，我们会问差距是不是真的像你计算或观测出来的值那么大。<strong>因为即便两个群体总体均值为0，得到的样本均值差也有可能出现你计算或观测的结果</strong>。因此，我们可以给出均值差的置信区间，来回答这个问题。</p>
<p>如果均值差的95%的置信区间中不包含0，那么我们可以说差异不显著（0.05水平下），也就是p值肯定小于0.05。（99%的置信区间类似）</p>
<p>t.test的结果中包含了95%的置信区间。</p>
<h3 id="Power-Calculations">Power Calculations</h3>
<p>由于我们有总体信息，我们从总体信息中可以直接得知，这两个群体确实是有差距的，而且按比例大约是10%。<br>
但是我们如果从中取样，然后进行t-test，有的时候P值不总是小于0.05。</p>
<p>所以我们犯错了吗？通过不拒绝原假设，我们要说diet没有影响吗？这个问题的答案是no。All we can say is that we did not reject the null hypothesis. But this does not necessarily imply that the null is true（我们只是说不拒绝原假设，但我们没有说原假设是真的）.</p>
<p>这个问题的本质是这样，在这次的实例中，我们没有得到足够的power（不知道啥意思）。在科学研究中，你很可能需要做某种程度的power calculation。在很多情况下，这是一种道德义务，来避免不必要地牺牲更多小鼠，或者使人们因为你的研究遭遇潜在的风险。</p>
<h4 id="types-of-error">types of error</h4>
<blockquote>
<p>Ⅰ型错误：原假设为真，我们拒绝的概率，等于P值<br>
Ⅱ型错误：原假设为假，没有拒绝原假设的概率</p>
</blockquote>
<p>当我们在进行统计检验时，我们始终需要注意我们很可能会犯错误。这就是为什么我们的p值不是0。在原假设成立的前提下，总是存在一个可能很少，但是可能发生的概率，使得我们拒绝了正确的原假设。如果P值设为0.05，那么这种情况发生的概率也就是0.05。这种错误叫做Ⅰ型错误（typeⅠerror）</p>
<p>Ⅰ型错误会发生<strong>假阳性</strong>。那么我们为什么只设为0.05？不设定一个非常小的值呢？因为还存在另外一种错误，Ⅱ型错误，即原假设为假，没有拒绝原假设的概率，这会造成<strong>假阴性</strong>。像上面我们提到的那种情况，就是犯了二型错误。如果我们把P值提高到0.25，那么上面的例子就能够显著。但是一般情况下我们愿不愿意提高P值到0.25呢？通常我们不会这么做。</p>
<h4 id="0-05或0-01-的-p值-是随意划分的（The-0-05-and-0-01-Cut-offs-Are-Arbitrary）">0.05或0.01 的 p值 是随意划分的（The 0.05 and 0.01 Cut-offs Are Arbitrary）</h4>
<p>很多杂志和监管部门强调要达到0.05或0.01水平的显著。但是这两个数字的设定其实没有特别的，这仅仅是因为最开始的文章用这两个数字作为例子而已。本书的部分目的之一就是让读者对于P值和置信区间有一个更加清晰的认识（受教了）。</p>
<h4 id="Power-Calculation">Power Calculation</h4>
<p>Power is the probability of rejecting the null when the null is false（Power 是指当原假设为假时拒绝原假设的概率）。</p>
<p>下面我们通过R中的实际代码去理解这个概念。</p>
<p>我们仍然假设样本大小为12，显著水平时0.05。由于我们已经两个群体均值有差异，我们可以重复抽样，看每次抽样t检验是否小于0.05</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N&lt;-12</span><br><span class="line">alpha&lt;-0.05</span><br><span class="line">B&lt;-2000</span><br><span class="line"></span><br><span class="line">reject&lt;-function(N, alpha&#x3D;0.05)&#123;</span><br><span class="line">	hf&lt;-sample(hfPopulation,N)</span><br><span class="line">	control&lt;-sample(controlPopulation,N)</span><br><span class="line">	pval&lt;-t.test(hf,control)$p.value</span><br><span class="line">	pval&lt;alpha</span><br><span class="line">&#125;</span><br><span class="line">#reject 给出一次抽样是否小于0.05</span><br><span class="line"></span><br><span class="line">reject(12)</span><br><span class="line">## [1] FALSE</span><br><span class="line"></span><br><span class="line">rejections &lt;- replicate(B,reject(N))</span><br><span class="line">#重复2000次，replicate(n,expr) </span><br><span class="line"></span><br><span class="line">mean(rejetions) # 这就是N&#x3D;12时Power的值</span><br><span class="line">## [1] 0.2215</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这就是为什么当我们知道原假设是错的时，t-test却没有拒绝原假设。当样本大小只有12时，power只有23%。为了降低<strong>假阳性</strong>发生的概率，我们将P值设在0.05水平。其实这个水平有点过高，导致发生<strong>Ⅱ型错误</strong>的概率大大提高。</p>
<blockquote>
<p>power 和 发生Ⅱ型的概率 相加为1。power低，说明发生Ⅱ型错误的概率高。</p>
</blockquote>
<p>接下来，让我们来看看power和抽样大小N的关系。这里我们用到了<strong>sapply(Ns,expr)</strong>，这个函数会对向量中的每一个数执行同样的function。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Ns&lt;-seq(<span class="number">5</span>,<span class="number">50</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># So we use apply() like this</span></span><br><span class="line">power&lt;-sapply(Ns,<span class="keyword">function</span>(N)&#123;</span><br><span class="line">	rejections&lt;-replicate(B, reject(N))</span><br><span class="line">	mean(rejections)</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">plot(Ns,power,type = <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看出，随着N的增加，power不断提高。</p>
<p>我们固定N，看一看alpha的设定对power 的影响</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N&lt;-<span class="number">30</span></span><br><span class="line">alphas&lt;-<span class="built_in">c</span>(<span class="number">0.1</span>,<span class="number">0.05</span>,<span class="number">0.01</span>,<span class="number">0.001</span>,<span class="number">0.0001</span>)</span><br><span class="line">power&lt;-sapply(alphas,<span class="keyword">function</span>(alpha)&#123;</span><br><span class="line">	rejections &lt;- replicate(B,reject(N,alpha=alpha))</span><br><span class="line">	mean(rejections)</span><br><span class="line">&#125;)</span><br><span class="line">plot(alphas, power, xlab=<span class="string">&quot;alpha&quot;</span>, type=<span class="string">&quot;b&quot;</span>, <span class="built_in">log</span>=<span class="string">&quot;x&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看出随着alpha的增加，power也在不断增加。</p>
<blockquote>
<p>There is no “right” power or “right” alpha level, but it is important that you understand what eachmeans.</p>
</blockquote>
<h5 id="p-values-are-Arbitrary-under-the-Alternative-Hypothesis">p-values are Arbitrary under the Alternative Hypothesis</h5>
<blockquote>
<p>Another consequence of what we have learned about power is that p-values are somewhat arbitrarywhen the null hypothesis is not true and therefore thealternativehypothesis is true (the differencebetween the population means is not zero). When the alternative hypothesis is true, we can make a p-value as small as we want simply by increasing the sample size (supposing that we have an infinitepopulation to sample from). We can show this property of p-values by drawing larger and largersamples from our population and calculating p-values. This works because, in our case, we knowthat the alternative hypothesis is true, since we have access to the populations and can calculate thedifference in their means.</p>
</blockquote>
<p>随着样本大小的增加，P值会减小（假设群体无限大）。证明如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">calculatePvalue&lt;-<span class="keyword">function</span>(N) &#123;</span><br><span class="line">	hf&lt;-sample(hfPopulation,N)</span><br><span class="line">	control&lt;-sample(controlPopulation,N)</span><br><span class="line">	t.test(hf,control)$p.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ns&lt;-seq(<span class="number">10</span>,<span class="number">200</span>,by=<span class="number">10</span>)</span><br><span class="line">Ns_rep&lt;-<span class="built_in">rep</span>(Ns, each=<span class="number">10</span>) <span class="comment">#each 的形式是 10 10 10…… 20 ……</span></span><br><span class="line"></span><br><span class="line">pvalues&lt;-sapply(Ns_rep, calculatePvalue)</span><br><span class="line"></span><br><span class="line">plot(Ns_rep, pvalues, <span class="built_in">log</span>=<span class="string">&quot;y&quot;</span>, xlab=<span class="string">&quot;sample size&quot;</span>,</span><br><span class="line">ylab=<span class="string">&quot;p-values&quot;</span>)</span><br><span class="line">abline(h=<span class="built_in">c</span>(<span class="number">.01</span>,<span class="number">.05</span>), col=<span class="string">&quot;red&quot;</span>, lwd=<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>样本量从10增加到200的过程中，p值最低下降到了10^-8^。但是p值太低也不见得是一件很好的事。一旦我们确信了一个reasonable alpha（比如0.05），那么如果我们获得了一个比这个阈值低得多的p值，那就说明<strong>我们用了过量的小鼠</strong>。适当地提高样本量，确实有助于估计的准确性。但是，实际上，随着样本量的增加p值的降低是一件自然的事。</p>
<blockquote>
<p>The p-values get smaller and smaller with increasing sample size because the numerator ofthe t-statistic haspN(for equal sized groups, and a similar effect occurs whenM̸=N). Therefore,if∆is non-zero, the t-statistic will increase with N.</p>
</blockquote>
<p>事实上，随着样本量的增加，t-test得到的p值也会不断降低。这是t统计量中有一个根号N。</p>
<p>算了个Cohen’s d，但没看懂这个统计量到底有啥用？</p>
<blockquote>
<p>This tells us how many standard deviations of the data the mean of the high-fat diet group is from the control group. Under the alternative hypothesis, unlike the t-statistic which is guaranteed to increase, the effect size and Cohen’s d will become more precise.（看不懂）</p>
</blockquote>
<h3 id="Monte-Carlo-Simulation">Monte Carlo Simulation</h3>
<p>电脑可以用来产生伪随机数（pseudo-random numbers），一个最大的好处是我们可以通过模拟数据来证明我们的假设或理论。</p>
<blockquote>
<p>伪随机性（英语：Pseudorandomness）是一个过程似乎是随机的，但实际上并不是。例如伪随机数是使用一个确定性的算法计算出来的似乎是随机的数序，因此伪随机数实际上并不随机。在计算伪随机数时假如使用的开始值不变的话，那么伪随机数的数序也不变。</p>
</blockquote>
<p>Simulations can also be used to check theoretical or analytical results. Also, many of the theoretical results we use in statistics are based on <strong>asymptotics</strong>: they hold when the sample size goes to <a href="http://infinity.In">infinity.In</a> practice, we never have an infinite number of samples so we may want to know how well thetheory works with our actual sample size.</p>
<p>作为例子，我们蒙特卡洛模拟（ Monte Carlo simulation）来比较不同样本大小的情况下CLT和t分布的近似值。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(dplyr)</span><br><span class="line">dat&lt;-read.csv(<span class="string">&quot;mice_pheno.csv&quot;</span>)<span class="comment">#Previously downloaded</span></span><br><span class="line">controlPopulation&lt;-filter(dat,Sex==<span class="string">&quot;F&quot;</span>&amp;Diet==<span class="string">&quot;chow&quot;</span>)%&gt;%select(Bodyweight)%&gt;%unlist</span><br><span class="line"></span><br><span class="line">ttestgenerator&lt;-<span class="keyword">function</span>(n) &#123;</span><br><span class="line">  <span class="comment">#note that here we have a false &quot;high fat&quot; group where we actually</span></span><br><span class="line">  <span class="comment">#sample from the nonsmokers. this is because we are modeling the *null*</span></span><br><span class="line">  cases&lt;-sample(controlPopulation,n)</span><br><span class="line">  controls&lt;-sample(controlPopulation,n)</span><br><span class="line">  tstat&lt;-(mean(cases)-mean(controls))/<span class="built_in">sqrt</span>( var(cases)/n+var(controls)/n ) <span class="comment">#这个t统计量是假设两个群体方差不等</span></span><br><span class="line">  <span class="built_in">return</span>(tstat)</span><br><span class="line">  &#125;</span><br><span class="line">ttests&lt;-replicate(<span class="number">1000</span>, ttestgenerator(<span class="number">10</span>))</span><br><span class="line">hist(ttests)</span><br></pre></td></tr></table></figure>
<p>从直方图中，我们近似看出符合正态分布。但是从上文提到，我们再看一下QQ图</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qqnorm(ttests)</span><br><span class="line">qqline(ttests)</span><br></pre></td></tr></table></figure>
<p>从QQ图中，可以看出近似符合正态分布。这说明在样本数是10的情况下，已经符合正态分布，可以使用中心极限定理了。那么如果样本数为3呢？</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ttests&lt;-replicate(<span class="number">1000</span>, ttestgenerator(<span class="number">3</span>))</span><br><span class="line">qqnorm(ttests)</span><br><span class="line">qqline(ttests)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Now we see that the large quantiles, referred to by statisticians as the tails, are larger than expected(below the line on the left side of the plot and above the line on the right side of the plot).</p>
</blockquote>
<p>我们可以看出QQ图中左侧低于直线，右侧高于直线。这说明两侧的尾巴比正态分布要肥。</p>
<p>在之前的章节中，我们提到，如果<strong>样本数不大</strong> 并且 <strong>总体符合正态分布</strong> ，那么使用t分布是一种更好的近似。证明如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ps&lt;-(seq(<span class="number">0</span>,<span class="number">999</span>)+<span class="number">0.5</span>)/<span class="number">1000</span> <span class="comment">#0到1的均匀分布</span></span><br><span class="line">qqplot(qt(ps,df=<span class="number">2</span>*<span class="number">3</span>-<span class="number">2</span>),ttests,xlim=<span class="built_in">c</span>(-<span class="number">6</span>,<span class="number">6</span>),ylim=<span class="built_in">c</span>(-<span class="number">6</span>,<span class="number">6</span>))</span><br><span class="line"><span class="comment"># qt获得某t分布累积概率的数值</span></span><br><span class="line"><span class="comment"># qqplot比较两个变量分布是否相同</span></span><br><span class="line">abline(<span class="number">0</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>从中我们可以看出，t分布在这种情况下更为近似，但是仍不完美。这是因为<strong>总体并不是很好地符合正态分布</strong>。(从下面总体的QQ图中看出，总体略偏)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qqnorm(controlPopulation)</span><br><span class="line">qqline(controlPopulation)</span><br></pre></td></tr></table></figure>
<h3 id="Parametric-Simulations-for-the-Observations">Parametric Simulations for the Observations</h3>
<p>我们再这里使用蒙特卡洛模拟随机变量和假设检验，这是因为我们有总体数据。这是为了教学的作用，但在实际运用中是不可能的。一般采用蒙特卡洛模拟，主要用于参数估计（如均值和标准差）。</p>
<p>以小鼠体重的例子来说，我们通过先验知识，认识到小鼠的体重均值为24盎司，标准差为3.5盎司，而且小鼠体重近似符合正态分布。通过以上信息，我们可以构建一个总体数据。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">controls&lt;-rnorm(<span class="number">5000</span>, mean=<span class="number">24</span>, sd=<span class="number">3.5</span>)</span><br></pre></td></tr></table></figure>
<p>由于我们可以重复上述操作。因此我们不需要用到sample()函数了。代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ttestgenerator&lt;-function(n, mean&#x3D;24, sd&#x3D;3.5) &#123;</span><br><span class="line">  cases&lt;-rnorm(n,mean,sd)</span><br><span class="line">  controls&lt;-rnorm(n,mean,sd)</span><br><span class="line">  tstat&lt;-(mean(cases)-mean(controls))&#x2F;sqrt( var(cases)&#x2F;n+var(controls)&#x2F;n )</span><br><span class="line">  return(tstat)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Permutation-Tests">Permutation Tests</h3>
<p>假设我们遇到这样一种情况，没有一种标准的统计量能近似模拟我们的数据。</p>
<p>We have computed a summary statistic, such as the difference in mean, but do not have auseful approximation, such as that provided by the CLT.</p>
<p>这个时候 Permutation Tests 就派上用场了。</p>
<p>让我们回到最开始拿到的样本</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dat=read.csv(<span class="string">&quot;femaleMiceWeights.csv&quot;</span>)</span><br><span class="line">library(dplyr)</span><br><span class="line">control&lt;-filter(dat,Diet==<span class="string">&quot;chow&quot;</span>)%&gt;%select(Bodyweight)%&gt;%unlist</span><br><span class="line">treatment&lt;-filter(dat,Diet==<span class="string">&quot;hf&quot;</span>)%&gt;%select(Bodyweight)%&gt;%unlist</span><br><span class="line">obsdiff&lt;-mean(treatment)-mean(control)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>In previous sections, we showed parametric approaches that helped determine if the observeddifference was significant. Permutation tests take advantage of the fact that if we randomly shufflethe cases and control labels, then the null is true. So we shuffle the cases and control labels andassume that the ensuing distribution approximates the null distribution. Here is how we generate anull distribution by shuffling the data 1,000 times:</p>
</blockquote>
<p>这段话的大意是，之前我们是用带参数的方法（均值，标准差）检验差异是否显著。而这个Permutation tests 认为，如果我们随机洗牌 cases 和 control 的标签，那么零假设应该是正确的。<br>
下面我们洗牌了1000次。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N&lt;-<span class="number">12</span></span><br><span class="line">avgdiff&lt;-replicate(<span class="number">1000</span>, &#123;</span><br><span class="line">  <span class="built_in">all</span>&lt;-sample(<span class="built_in">c</span>(control,treatment))</span><br><span class="line">  newcontrols&lt;-<span class="built_in">all</span>[<span class="number">1</span>:N]</span><br><span class="line">  newtreatments&lt;-<span class="built_in">all</span>[(N+<span class="number">1</span>):(<span class="number">2</span>*N)]</span><br><span class="line">  <span class="built_in">return</span>(mean(newtreatments)-mean(newcontrols))</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">#这个&#123;&#125;好像是不带名称的函数，类似于Python中的lambda</span></span><br><span class="line"><span class="comment">#sample(x)不加n,就是重排（permutation）的意思</span></span><br><span class="line">hist(avgdiff)</span><br><span class="line">abline(v=obsdiff, col=<span class="string">&quot;red&quot;</span>, lwd=<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>How many of the null means are bigger than the observed value? That proportion would be thep-value for the null. We add a 1 to the numerator and denominator to account for misestimation ofthe p-value</p>
</blockquote>
<p>在这1000次中，有多少比例大于这个obsdiff，这就是P值。但是，分子分母要都加上一个1。（个人理解实际上是做了1001次，没有算上真实情况）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">sum</span>(<span class="built_in">abs</span>(avgdiff)&gt;<span class="built_in">abs</span>(obsdiff))+<span class="number">1</span>)/(<span class="built_in">length</span>(avgdiff)+<span class="number">1</span>)</span><br><span class="line"><span class="comment">## [1] 0.05594406</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在我们把这个用在样本量更小的数据集，比如样本量为5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N&lt;-5</span><br><span class="line">control&lt;-sample(control,N)</span><br><span class="line">treatment&lt;-sample(treatment,N)</span><br><span class="line">obsdiff&lt;-mean(treatment)-mean(control)</span><br><span class="line"></span><br><span class="line">avgdiff&lt;-replicate(1000, &#123;</span><br><span class="line">  all&lt;-sample(c(control,treatment))</span><br><span class="line">  newcontrols&lt;-all[1:N]</span><br><span class="line">  newtreatments&lt;-all[(N+1):(2*N)]</span><br><span class="line">  return(mean(newtreatments)-mean(newcontrols))</span><br><span class="line">&#125;)</span><br><span class="line">hist(avgdiff)</span><br><span class="line">abline(v&#x3D;obsdiff, col&#x3D;&quot;red&quot;, lwd&#x3D;2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在可以明显看出差距不显著了。</p>
<blockquote>
<p>Now the observed difference is not significant using this approach. Keep in mind that there is notheoretical guarantee that the null distribution estimated from permutations approximates the actualnull distribution. For example, if there is a real difference between the populations, some of the permutations will be unbalanced and will contain some samples that explain this difference. This implies that the null distribution created with permutations will have larger tails than the actualnull distribution. This is why permutations result in conservative p-values. For this reason, whenwe have few samples, we can’t do permutations.</p>
</blockquote>
<p>没看懂，结论是数据量小时，不用这种permutation test</p>
<p>而且permutation test 也有假设：<strong>:samples are assumed to be independentand “exchangeable”</strong> 。 If there is hidden structure in your data, then permutation tests can result in estimated null distributions that underestimate the size of tails because the permutations may destroy the existing structure in the original data.</p>
<h3 id="Association-Tests">Association Tests</h3>
<p>前面的统计分析中，忽略了一类重要的数据，二元或者说分类数据。举个例子，当你有两种疾病的基因型的群体(AA/Aa 与 aa)作为cases 和 control。我们要提出的问题是，这个基因型与疾病是否有关系。<br>
这里疾病状况表示为0和1，那么我们为什么不能用t-test？因为数据要么是0要么是1，很明显不会符合正态分布，因此不能使用t-test。</p>
<p>如果样本数量很大的话，我们可以使用CLT。不然的话，我们就可以使用Association Tests。</p>
<h4 id="二项分布与超几何分布">二项分布与超几何分布</h4>
<p>解释: 我的这种算法是基于二项分布，而Fisher’s exact test是基于超几何分布（hypergeometric distribution）。<br>
二项分布</p>
<ol>
<li>试验次数固定</li>
<li>每一次事件都有两个可能的结果</li>
<li><strong>每次试验中的事件相互独立</strong></li>
<li><strong>每一次成功的概率相等</strong></li>
</ol>
<p>超几何分布 它描述了由<strong>有限个物件中</strong>抽出n个物件，成功抽出指定种类的物件的个数（不归还 （without replacement））。</p>
<p>例如在有N个样本，其中K个是不及格的。超几何分布描述了在该N个样本中抽出n个，其中k个是不及格的概率。</p>
<p>特点：</p>
<ol>
<li>每次抽取也只有两个互斥的结果</li>
<li><strong>每次抽取后成功的概率发生改变</strong>（因为是不放回抽样，这也导致了每次抽取事件不独立）</li>
</ol>
<h4 id="Lady-Tasting-Tea">Lady Tasting Tea</h4>
<p>R.A.Fisher 的一位熟人宣称她能分辨牛奶是早于或晚于茶放入杯中（就是牛奶和茶混合的顺序）。Fisher 就和她做了一个小实验，4次中对了3次。那么，我们能否说明这位女士存在这种特殊的能力呢？这个例子被称为&quot;Lady tasting tea&quot;。<br>
按照之前的经验。一个基本的问题是，如果这位女士仅仅靠猜，她能得到3/4或更高的正确率(即3/4+4/4)的概率是多少？<br>
仍和之前一样，我们需要计算在零假设成立的前提下事情发生的概率。这里的零假设就是这位女士都是猜的。</p>
<blockquote>
<p>he basic question we ask is: if the tester is actually guessing, what are the chances that she gets 3 ormore correct? Just as we have done before, we can compute a probability under the null hypothesisthat she is guessing four of each. If we assume this null hypothesis, we can think of this particularexamples as picking 4 balls out of an urn with 4 green (correct answer) and 4 red (incorrect answer)balls.</p>
</blockquote>
<blockquote>
<p>Under the null hypothesis that she is simply guessing, each ball has the same chance of beingpicked. We can then use combinatorics to figure out each probability. The probability of picking3 is(43)(41)/(84)= 16/70. The probability of picking all 4 correct is(44)(40)/(84)= 1/70. Thus, thechance of observing a 3 or something more extreme, under the null hypothesis, is 0.24. This isthe p-value. The procedure that produced this p-value is calledFisher’s exact testand it uses the hypergeometric distribution.</p>
</blockquote>
<p>它这种算法是8个球里摸4个。我的算法是每次猜对的概率是0.5，那么4次猜对3次的概率是4*0.5^3^*0.5=0.25。这两种结果不一样，我也搞不太清楚。</p>
<p>这里算错了，除了不清晰二项分布与超几何分布，还有一个原因，不清楚这个Lady tasting tea试验。在这个试验中，Fisher准备了8杯茶，每一种（tea first or milk first）都准备了4杯，并且随机拜放位置。试验者需挑出按其中一种方法泡制的4杯。</p>
<p>按Fisher’s exact test 只有当这位女士把4杯都挑出来（p=1/70），他才会承认她有这种能力（但是不能量化）。哪怕如题所示，她挑出来了3杯（p=16/70+1/70=17/70），P值也是不显著。</p>
<blockquote>
<p>当样本量更大时，也可以使用卡方分布。但是，当样本数目很少或数据分布极不平衡（如果某个cell的数目小于5 或小于10）时，卡方分布的估计是不充分的。而与之相反，Fisher 精确检验，正如它的名称，不论样本如何都能保持精确。但是当样本量很大或非常平衡，Fisher 精确检验计算不方便，这时就需要用到卡方分布。</p>
</blockquote>
<p>公式如下：<br>
<img src="Fisher's_exact_test.png" alt="Fisher's_exact_test"></p>
<p>小结：<br>
Fisher 精确检验使用于<strong>检验两个分类变量是否相关</strong>。</p>
<ul>
<li>Fisher 精确检验：适合样本小或不平衡数据</li>
<li>卡方检验：适合样本大、平衡数据</li>
</ul>
<h4 id="Two-By-Two-Tables">Two By Two Tables</h4>
<p>The data from the experiment above can be summarized by a 2 by 2 table:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tab&lt;-matrix(c(3,1,1,3),2,2)</span><br><span class="line">rownames(tab)&lt;-c(&quot;Poured Before&quot;,&quot;Poured After&quot;)</span><br><span class="line">colnames(tab)&lt;-c(&quot;Guessed before&quot;,&quot;Guessed after&quot;)</span><br><span class="line">tab</span><br><span class="line">#The function fisher.test performs the calculations above and can be obtained like this:</span><br><span class="line">fisher.test(tab,alternative&#x3D;&quot;greater&quot;)</span><br><span class="line">##</span><br><span class="line">##Fisher&#39;s Exact Test for Count Data</span><br><span class="line">##</span><br><span class="line">## data:  tab</span><br><span class="line">## p-value &#x3D; 0.2429</span><br><span class="line">## alternative hypothesis: true odds ratio is greater than 1</span><br><span class="line">## 95 percent confidence interval:</span><br><span class="line">##  0.3135693Inf</span><br><span class="line">## sample estimates:</span><br><span class="line">## odds ratio</span><br><span class="line">##   6.408309</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Fisher-精确检验的争议">Fisher 精确检验的争议</h4>
<p>很多人争论Fisher 精确检验结果保守。它的真实的拒绝概率低于名义上的显著水平。The apparent contradiction stems from the combination of a discrete statistic with fixed significance levels.（最明显的矛盾在于它计算出的统计量是分散的，但是显著水平是固定的，如0.05）（如上例，可能出现的P值只有5个（0，1，2，3，4杯））。To avoid the problem, many authors discourage the use of fixed significance levels when dealing with discrete problems.</p>
<h4 id="Chi-square-Test">Chi-square Test</h4>
<p>假设我们有250个个体，其中一部分患有疾病。我们观测到aa基因型的个体中有20%患病；其他基因型的个体中患病比例为10%。如果我们再挑250个个体这种现象会再次发生吗？（这个提问方式等同于问这个位点是否与疾病相关）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">disease=factor(<span class="built_in">c</span>(<span class="built_in">rep</span>(<span class="number">0</span>,<span class="number">180</span>),<span class="built_in">rep</span>(<span class="number">1</span>,<span class="number">20</span>),<span class="built_in">rep</span>(<span class="number">0</span>,<span class="number">40</span>),<span class="built_in">rep</span>(<span class="number">1</span>,<span class="number">10</span>)),labels=<span class="built_in">c</span>(<span class="string">&quot;control&quot;</span>,<span class="string">&quot;cases&quot;</span>))</span><br><span class="line">genotype=factor(<span class="built_in">c</span>(<span class="built_in">rep</span>(<span class="string">&quot;AA/Aa&quot;</span>,<span class="number">200</span>),<span class="built_in">rep</span>(<span class="string">&quot;aa&quot;</span>,<span class="number">50</span>)),levels=<span class="built_in">c</span>(<span class="string">&quot;AA/Aa&quot;</span>,<span class="string">&quot;aa&quot;</span>))</span><br><span class="line">dat&lt;-data.frame(disease, genotype)</span><br><span class="line">dat&lt;-dat[sample(nrow(dat)),]<span class="comment">#shuffle them up</span></span><br><span class="line">head(dat)</span><br><span class="line"></span><br><span class="line"><span class="comment">###统计频数</span></span><br><span class="line">table(genotype)</span><br><span class="line">table(disease)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 双因素统计频数，建立一个2*2表</span></span><br><span class="line">tab &lt;- table(genotype,disease)</span><br><span class="line">tab</span><br><span class="line"><span class="comment">##disease</span></span><br><span class="line"><span class="comment">## genotype control cases</span></span><br><span class="line"><span class="comment">##    AA/Aa     180    20</span></span><br><span class="line"><span class="comment">##    aa		 40    10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里最典型的统计量就是the odds ratio(OR)。). We compute the oddsof having the disease if you are an “aa”: 10/40, the odds of having the disease if you are an “AA/Aa”:20/180, and take the ratio:(10/40)/(20/180)</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">(tab[<span class="number">2</span>,<span class="number">2</span>]/tab[<span class="number">2</span>,<span class="number">1</span>])/(tab[<span class="number">1</span>,<span class="number">2</span>]/tab[<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line"><span class="comment">## [1] 2.25</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了计算P值，我们不直接使用OR。我们假设基因型和疾病没有关系，然后计算出每个cell的期望值。在零假设下，两种基因型的200个体和50个体，患病的概率是相同的。</p>
<p>首先，我们得到群体（200+50=250）的患病概率为</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">p=mean(disease==<span class="string">&quot;cases&quot;</span>)</span><br><span class="line">p</span><br><span class="line"><span class="comment">## [1] 0.12</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此，各cell 的期望值为</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">expected&lt;-rbind(<span class="built_in">c</span>(<span class="number">1</span>-p,p)*<span class="built_in">sum</span>(genotype==<span class="string">&quot;AA/Aa&quot;</span>),<span class="built_in">c</span>(<span class="number">1</span>-p,p)*<span class="built_in">sum</span>(genotype==<span class="string">&quot;aa&quot;</span>))</span><br><span class="line"><span class="built_in">dimnames</span>(expected)&lt;-<span class="built_in">dimnames</span>(tab)</span><br><span class="line">expected</span><br><span class="line"><span class="comment">##disease</span></span><br><span class="line"><span class="comment">## genotype control cases</span></span><br><span class="line"><span class="comment">##    AA/Aa     176    24</span></span><br><span class="line"><span class="comment">##    aa		 44     6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##这里没讲清楚，直接就算出来了</span></span><br><span class="line">chisq.test(tab)$p.value</span><br><span class="line"><span class="comment">## [1] 0.08857435</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Large-Samples-Small-p-values">Large Samples, Small p-values</h4>
<p>如上所述，仅报道P值是不正确的。很多做GWAS的人过于强调P值。他们样本很大，得到的P值很小。但是如果仔细看他们的结果，我们就能看到他们的odds ratios并不高：仅仅比1高一点。在这种情况下，基因型是AA/Aa 或 aa 可能不会改变动物患病的几率，但是这些位点确实是统计意义上显著的。<br>
<strong>odds ratio 和 p-value 并没有一对一的关系</strong>（这一点很重要，这个在effect size 中也专门提到了，效应大小与是否显著没有因果关系。P值只能判断这个效应是不是出于偶然（随机误差），并不能说明效应大小）</p>
<h4 id="Confidence-Intervals-For-The-Odd-Ratio">Confidence Intervals For The Odd Ratio</h4>
<p>计算OR 的置信区间不能直接做到。不像其他统计量，它们都能推导出近似的分布。但是OR仅仅是一个比例。因此，没有简单的方法可以使用，例如CLT。</p>
<p>One approach is to use the theory ofgeneralized linear models which provides estimates of thelog odds ratio, rather than the OR itself, that can be shown to be asymptotically normal.</p>
<p>后面的没看</p>
<h2 id="Exploratory-Data-Analysis">Exploratory Data Analysis</h2>
<p>这个探索性数据分析，没太搞懂</p>
<h3 id="Quantile-Quantile-Plots">Quantile Quantile Plots</h3>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(UsingR)<span class="comment">##available from CRAN</span></span><br><span class="line">library(rafalib)</span><br><span class="line">x&lt;-father.son$fheight</span><br><span class="line"></span><br><span class="line">ps&lt;-( seq(<span class="number">0</span>,<span class="number">99</span>)+<span class="number">0.5</span>)/<span class="number">100</span> <span class="comment">#0.005 0.015 ……</span></span><br><span class="line">qs&lt;-quantile(x, ps) <span class="comment">#获得x中的各分位数</span></span><br><span class="line">normalqs&lt;-qnorm(ps, mean(x), popsd(x)) <span class="comment">#形成以x均值，总体标准差的正态分布的分位数</span></span><br><span class="line">plot(normalqs,qs,xlab=<span class="string">&quot;Normal percentiles&quot;</span>,ylab=<span class="string">&quot;Height percentiles&quot;</span>) </span><br><span class="line"><span class="comment"># 两个分位数向量的散点图即为QQ图</span></span><br><span class="line">abline(<span class="number">0</span>,<span class="number">1</span>)<span class="comment">##identity line</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>简化命令,比上面的手动画图采了更多的点，因此更加准确。<br>
其中由于x轴为标准正态分布，因此添加的qqline的截距为mean(x) , 斜率为popsd(x)</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qqnorm(x)</span><br><span class="line">qqline(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当然，我们也可以看看非正态分布的QQ图，比如t分布，样本数越少，尾巴越肥。体现在QQ图上就是左侧的极端值低于identity line，右侧的极端值高于identity line。</p>
<h3 id="Boxplots">Boxplots</h3>
<p>数据也不是都服从正态分布。比如工资，只告诉均值和标准差根本不足以表现真实情况（not neccessarily informative），因为我们没办法通过这两个参数获取工资的分布情况。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">op &lt;- par(mfrow=<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">hist(exec.pay)<span class="comment">##in UsingR package</span></span><br><span class="line">qqnorm(exec.pay)</span><br><span class="line">qqline(exec.pay)</span><br><span class="line"></span><br><span class="line"><span class="comment">#boxplot</span></span><br><span class="line">boxplot(exec.pay, ylab=<span class="string">&quot;10,000s of dollars&quot;</span>, ylim=<span class="built_in">c</span>(<span class="number">0</span>,<span class="number">400</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Scatterplots-And-Correlation">Scatterplots And Correlation</h3>
<p>上面都是单一变量。我们也经常用到双变量或者更多的变量，比如父亲和儿子的身高。可以先画一个散点图。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(UsingR)</span><br><span class="line">data(<span class="string">&quot;father.son&quot;</span>)</span><br><span class="line">x=father.son$fheight</span><br><span class="line">y=father.son$sheight</span><br><span class="line">plot(x,y,xlab=<span class="string">&quot;Father&#x27;s height in inches&quot;</span>,ylab=<span class="string">&quot;Son&#x27;s height in inches&quot;</span>,main=paste(<span class="string">&quot;correlation =&quot;</span>,<span class="built_in">signif</span>(cor(x,y),<span class="number">2</span>)))</span><br></pre></td></tr></table></figure>
<p>从图中看出一个明显的趋势：父亲的身高越高，儿子的身高也越高。一个定量的统计量就是相关系数。</p>
<h4 id="Stratification">Stratification</h4>
<p>如果我们要预测身高为72 inches 的父亲的儿子的身高，我们可以看所有身高为72 inches 的父亲的儿子的情况。因此需要对数据按父亲身高进行分层。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">groups&lt;-split(y,<span class="built_in">round</span>(x))</span><br><span class="line">boxplot(groups)</span><br><span class="line">print(mean(y[ <span class="built_in">round</span>(x)==<span class="number">72</span>]))</span><br><span class="line"><span class="comment">## [1] 70.67719</span></span><br></pre></td></tr></table></figure>
<h3 id="Bi-variate-Normal-Distribution">Bi-variate Normal Distribution</h3>
<p>对于两个均服从正态分布的变量的联合分布，我们一般可以设定当X = x时，Y的条件分布。以身高数据为例，我们给出了以下4个层次。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">groups&lt;-split(y,<span class="built_in">round</span>(x))</span><br><span class="line">op &lt;- par(mfrow=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="built_in">c</span>(<span class="number">5</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">14</span>))&#123;</span><br><span class="line">  qqnorm(groups[[i]],main=paste0(<span class="string">&quot;X=&quot;</span>,<span class="built_in">names</span>(groups)[i],<span class="string">&quot;strata&quot;</span>),</span><br><span class="line">         ylim=<span class="built_in">range</span>(y),xlim=<span class="built_in">c</span>(-<span class="number">2.5</span>,<span class="number">2.5</span>))</span><br><span class="line"><span class="comment"># groups 是一个list，用groups[[i]] 获得的是向量</span></span><br><span class="line"><span class="comment"># range() 返回一个包含最小值和最大值的向量</span></span><br><span class="line"><span class="comment"># range(1:10) ## [1]  1 10</span></span><br><span class="line"></span><br><span class="line">  qqline(groups[[i]])</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>后面的公式推导没太明白。后面对x,y进行了标准化，然后按x分组求y均值，发现y均值 与 x 呈线性关系，截距为0，斜率为标准化的y与x的相关系数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x=( x-mean(x) )/sd(x)</span><br><span class="line">y=( y-mean(y) )/sd(y)</span><br><span class="line">means=tapply(y, <span class="built_in">round</span>(x*<span class="number">4</span>)/<span class="number">4</span>, mean) <span class="comment">#按round(x*4)/4 给y 分组求均值</span></span><br><span class="line">fatherheights=<span class="built_in">as.numeric</span>(<span class="built_in">names</span>(means))</span><br><span class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">plot(fatherheights, means, ylab=<span class="string">&quot;average of strata of son heights&quot;</span>, ylim=<span class="built_in">range</span>(fatherheights))</span><br><span class="line">abline(<span class="number">0</span>, cor(x,y))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Plots-To-Avoid">Plots To Avoid</h3>
<p>画图的目的是准确而清楚地展示数据。根据 Karl 的说法，不好的画图的标准如下：</p>
<ol>
<li>Display as little information as possible.</li>
<li>Obscure what you do show (with chart junk).</li>
<li>Use pseudo-3D and color gratuitously（免费地）.</li>
<li>Make a pie chart (preferably in color and 3D).</li>
<li>Use a poorly chosen scale.</li>
<li>Ignore significant figures.</li>
</ol>
<h3 id="Pie-charts">Pie charts</h3>
<blockquote>
<p>“Pie charts are a very bad way of displaying information. The eye is good at judginglinear measures and bad at judging relative areas. A bar chart or dot chart is a preferableway of displaying this type of data.”</p>
</blockquote>
<p>饼图是一种很差劲的展示数据的方式。人眼很容易辨别线性方式，但是劣于判断相对区域。一个条形图或散点图 都是更合适的方式。</p>
<p>举例来说，你可以看着饼图，去估计某一部分对应的百分比。你会发现这很困难，除非这个比例很接近25%，50% 或 75%。</p>
<p>这里我们可以用条形图用代替，这里我们每隔10添加了一条水平线</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">pie(browsers,main=<span class="string">&quot;Browser Usage (August 2013)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#条形图</span></span><br><span class="line">barplot(browsers, main=<span class="string">&quot;Browser Usage (August 2013)&quot;</span>, ylim=<span class="built_in">c</span>(<span class="number">0</span>,<span class="number">55</span>))</span><br><span class="line">abline(h=<span class="number">1</span>:<span class="number">5</span>*<span class="number">10</span>)</span><br><span class="line">barplot(browsers, add=<span class="literal">TRUE</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过条形图和y轴的水平线，我们可以很清楚的看到每个值的比例。</p>
<p>尽量不要使用3D图像，因为3D图像添加了看图的障碍，使得更难通过肉眼辨别各项比例。</p>
<h4 id="Barplots-as-data-summaries">Barplots as data summaries</h4>
<p>当条形图用于展示百分比时，很有用。但是，条形图也会被错误地用于<strong>只有两组</strong>的比较。特别当条形图的高度表示均值，上面的小触角表示标准误（standard errors）。</p>
<blockquote>
<p>Much more informative is to summarize with a boxplot. If the number of points is small enough,we might as well add them to the plot. When the number of points is too large for us to see them,just showing a boxplot is preferable. We can even setrange=0inboxplotto avoid drawing manyoutliers when the data is in the range of millions.</p>
</blockquote>
<p>这个时候更适合用箱线图来表示。箱线图展示了更多的信息，中心、分布、离群点。而条形图只展示了均值和标准误，而标准误很大程度上和样本大小有关，和分布无关。</p>
<blockquote>
<p>Notice how much more we see here: the center, spread, range and the points themselves. In thebarplot, we only see the mean and the SE, and the SE has more to do with sample size, than withthe spread of the data.</p>
</blockquote>
<p>问题还不止如此。当数据中的离群点很大（分组数据的尾巴很大）。如下条形图，看似两组区别很大。</p>
<p><img src="barplot1.png" alt="barplot1"></p>
<p>但仔细看数据，这种区别原来主要是因为有两个很大的离群点。将数据进行log以后，更加明朗。</p>
<p>如下箱线图所示，左边为原数据，可以看出二者可能区别不大，有两个非常大的离群点。log后基本展示了基本情况。（个人感觉，那两个离群点实在太大，也可以直接剔除）</p>
<p><img src="boxplot1.png" alt="barplot1"></p>
<h4 id="Show-the-scatter-plot">Show the scatter plot</h4>
<p>很多统计分析都是证明两个变量之间存在关系。相关系数和相应的图可以展示这一点。然而，只展现回归线是不够的，因为这掩饰了散点。</p>
<h4 id="High-correlation-does-not-imply-replication">High correlation does not imply replication</h4>
<p>相关系数很高，不代表重复性很好，这一部分没看懂。之后补上</p>
<h4 id="Barplots-for-paired-data">Barplots for paired data</h4>
<p>当样本数较少且为配对实验时，通常我们会用两种颜色的条形图表示比如实验前和实验后。</p>
<p><img src="pairdata1.png" alt="barplot1"></p>
<p>但是我们有更好的办法。比如散点图，我们可以看到点都是高于identity line（这里应该是y=x）。另一种方法是直接画差值的散点图。</p>
<p><img src="pairdata2.png" alt="barplot1"></p>
<p><img src="pairdata3.png" alt="barplot1"></p>
<h4 id="Gratuitous-3D-（没有必要的3D）">Gratuitous 3D （没有必要的3D）</h4>
<p>以下是一个3D图，你会发现并不清楚。很难去确定其中某一个点对应的数值。</p>
<p>其实这只要不同的颜色来区分三条线就可以了。</p>
<p><img src="3D.png" alt="barplot1"></p>
<p><img src="3D2.png" alt="barplot1"></p>
<h4 id="Too-many-significant-digits">Too many significant digits</h4>
<p>默认情况下，我们会得到很多重要的数字，但我们不是都要放上去。从R中直接复制粘贴是很愚蠢的，这导致你最后显示的不是一张图，而更像是一张表。</p>
<h4 id="Displaying-data-well">Displaying data well</h4>
<p>展示数据的一般准则：</p>
<ul>
<li>Be accurate and clear.</li>
<li>Let the data speak.</li>
<li>Show as much information as possible, taking care not to obscure the message.</li>
<li>Science not sales: avoid unnecessary frills (esp. gratuitous 3D).<br>
(科学不是销售，避免不必要的虚架子，比如3D)</li>
<li>In tables, every digit should be meaningful. Don’t drop ending 0’s.<br>
（表格中，每一个小数位点都有意义）</li>
</ul>
<h3 id="Misunderstanding-Correlation-Advanced">Misunderstanding Correlation (Advanced)</h3>
<p>现在相关系数主要用于体现reproducibility。但是实际上，相关系数不足以体现reproducibility。</p>
<p>最坏的错误是，计算相关系数的数据不是近似服从<strong>二元正态分布</strong>。上面提到，均值，标准差，相关系数都是基于二元正态分布。但是，有很多数据不符合，如基因表达量数据，通常有很肥的右侧尾巴。</p>
<p>计算reproducibility 最直接的方式就是计算两个变量的距离。</p>
<p>The standard way to quantify reproducibility between two sets of replicated measurements, sayx1; : : : ; xnandy1; : : : ; yn, is simply to compute the distance between them。</p>
<p><img src="reproducibility1.png" alt="barplot1"></p>
<p>后面没看，也看不懂。</p>
<p>我连这里的reproducibility是什么意思都不知道。</p>
<h3 id="Robust-Summaries">Robust Summaries</h3>
<p>在分析数据的过程中，我们通常假设数据符合正态分布。但是我们收集数据的过程中，总是不可避免地加入了一些错误的数据点（离群点）。类似这种偏离很大的离群点，会导致分析结果出现很大的偏差。</p>
<p>如下例，我们在0到1之间的数据中，插入一个值为100的离群点。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">set.seed(<span class="number">1</span>)</span><br><span class="line">x=<span class="built_in">c</span>(rnorm(<span class="number">100</span>,<span class="number">0</span>,<span class="number">1</span>))<span class="comment">##real distribution</span></span><br><span class="line">x[<span class="number">23</span>]&lt;-<span class="number">100</span><span class="comment">##mistake made in 23th measurement</span></span><br><span class="line">boxplot(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们看一下均值和标准差，发现偏离很大</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">cat(<span class="string">&quot;The average is&quot;</span>,mean(x),<span class="string">&quot;and the SD is&quot;</span>,sd(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">## The average is 1.108142 and the SD is 10.02938</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="The-median">The median</h4>
<p>这个中位数，对于离群点，是robust的。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">median(x)</span><br><span class="line">[<span class="number">1</span>] <span class="number">0.1684483</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="The-median-absolute-deviation">The median absolute deviation</h4>
<p>![](The median absolute deviation.png)</p>
<h4 id="Spearman-correlation">Spearman correlation</h4>
<p>和前面类似，也是robust 的相关系数。几乎不受离群点的影响。</p>
<h4 id="Symmetry-of-log-ratios">Symmetry of log ratios</h4>
<p>当涉及比值数据时，数据不是对称的，1/32 比 32/1 更接近1。这时候采用log()函数处理一下，就会对称（log(x/y) = log(x) - log(y) ）</p>
<h3 id="Wilcoxon-Rank-Sum-Test">Wilcoxon Rank Sum Test</h3>
<p>从上面知道，样本均值和标准差易受离群点的影响。t检验需要用到这两个数，因此也容易受到影响。这种Wilcoxon Rank Sum Test 就不会受到影响……</p>
<p>后面没看</p>
<h2 id="Matrix-Algebra">Matrix Algebra</h2>
<h3 id="自由落体实验">自由落体实验</h3>
<p>假设你是伽利略，你需要描述物体自由下落的速度。通过实验你获得了如下的25个数据，使用R模拟如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">set.seed(<span class="number">1</span>)</span><br><span class="line">g&lt;-<span class="number">9.8</span><span class="comment">##meters per second</span></span><br><span class="line">n&lt;-<span class="number">25</span></span><br><span class="line">tt&lt;-seq(<span class="number">0</span>,<span class="number">3.4</span>,len=n)<span class="comment">##time in secs, note: we use tt because t is a base function</span></span><br><span class="line">d&lt;-<span class="number">56.67</span>-<span class="number">0.5</span>*g*tt^<span class="number">2</span>+rnorm(n,sd=<span class="number">1</span>)<span class="comment">##meters</span></span><br><span class="line"><span class="comment">#rnorm 生成25个服从(0,1) 分布的随机数，模拟随机残差</span></span><br><span class="line"></span><br><span class="line">plot(tt,d,ylab=<span class="string">&quot;Distance in meters&quot;</span>,xlab=<span class="string">&quot;Time in seconds&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>你不知道高度与时间的准确的关系式，但是你根据图片，推断可能符合的模型如下：</p>
<p><img src="falling_objects1.png" alt=""></p>
<h3 id="父亲和儿子的身高">父亲和儿子的身高</h3>
<p>现在假设你是19世纪的Francis Galton ，然后你获得了成对的父亲与儿子的身高数据。你假设身高是受遗传影响的。</p>
<p>你拿到的数据如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(UsingR)</span><br><span class="line">x=father.son$fheight</span><br><span class="line">y=father.son$sheight</span><br><span class="line">plot(x,y,xlab=<span class="string">&quot;Father&#x27;s height&quot;</span>,ylab=<span class="string">&quot;Son&#x27;s height&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>貌似是符合一元线性模型。于是，你设计出的模型如下：</p>
<p><img src="father_son1.png" alt=""></p>
<h3 id="从多个群体中随机抽样">从多个群体中随机抽样</h3>
<p>现在我们重新读取小鼠的体重数据。我们感兴趣的是diet是否对体重有影响。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dat&lt;-read.csv(<span class="string">&quot;femaleMiceWeights.csv&quot;</span>)</span><br><span class="line">stripchart(Bodyweight~Diet,data=dat,vertical=<span class="literal">TRUE</span>,method=<span class="string">&quot;jitter&quot;</span>,pch=<span class="number">1</span>,main=<span class="string">&quot;Mice weights&quot;</span>)</span><br><span class="line"><span class="comment">##stripchart 成串的散点图，当数据量较少时，是箱线图的有效代替</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们已经证明了如何使用t检验和置信区间来证明两个群体的平均体重是否有差异。但是，用线性模型也可以做到。</p>
<p><img src="liner_model_mice1.png" alt=""></p>
<p>这里的β0表示 chow diet 的平均体重，β1 表示两个群体均值的差异，当i 采用 high fat diet 时xi = 1 ；当 i 采用 chow diet 时 xi =0 。</p>
<h3 id="一般的线性模型">一般的线性模型</h3>
<p><img src="general_linear_model.png" alt=""></p>
<h3 id="估计参数">估计参数</h3>
<p>只有我们能够估计出 β s，线性模型才能起作用。</p>
<p>一般估计参数的方法都是使用最小二乘法（least squares LS）。</p>
<p><img src="LS.png" alt=""></p>
<p>一旦我们找到了最小值，我们就称他们为 least squares estimates (LSE) , 表示为β帽。获得最小二乘的统计量称之为 the residual sum of squares (RSS) 。因为这个统计量决定于 Y 这个随机变量。因此 β帽 也是一个随机变量。</p>
<h3 id="lm-函数">lm 函数</h3>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tt2&lt;-tt^<span class="number">2</span></span><br><span class="line">fit&lt;-lm(d~tt+tt2)</span><br><span class="line">summary(fit)$coef</span><br></pre></td></tr></table></figure>
<p>通过lm()函数，我们可以知道得到LSE，和它的标准误 和 p 值。</p>
<h3 id="LSE">LSE</h3>
<p>我们可以写个计算LSE的函数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">rss&lt;-<span class="keyword">function</span>(Beta0,Beta1,Beta2)&#123;</span><br><span class="line">  r&lt;- d-(Beta0+Beta1*tt+Beta2*tt^<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">return</span>(<span class="built_in">sum</span>(r^<span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#固定两个参数，观察beta2对rss的影响</span></span><br><span class="line">Beta2s&lt;-seq(-<span class="number">10</span>,<span class="number">0</span>,len=<span class="number">100</span>)</span><br><span class="line">plot(Beta2s,sapply(Beta2s,rss,Beta0=<span class="number">55</span>,Beta1=<span class="number">0</span>),ylab=<span class="string">&quot;RSS&quot;</span>,xlab=<span class="string">&quot;Beta2&quot;</span>,type=<span class="string">&quot;l&quot;</span>)</span><br><span class="line"><span class="comment">##Let&#x27;s add another curve fixing another pair:</span></span><br><span class="line">Beta2s&lt;-seq(-<span class="number">10</span>,<span class="number">0</span>,len=<span class="number">100</span>)</span><br><span class="line">lines(Beta2s,sapply(Beta2s,rss,Beta0=<span class="number">65</span>,Beta1=<span class="number">0</span>),col=<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>估计参数这里需要用到微积分。当然，如果参数众多，那么估计起来也很麻烦。</p>
<h3 id="More-on-Galton-父子身高">More on Galton (父子身高)</h3>
<h3 id="solving-system-of-equations">solving system of equations</h3>
<p>线性代数是被用来解决 systems of linear equations，如下：</p>
<p><img src="linear_equations1.png" alt=""></p>
<p>线性代数给我们提供了非常简便的一般方法解决这些问题。比如上例中，可以这么求解</p>
<p><img src="linear_equations2.png" alt=""></p>
<h3 id="The-inverse">The inverse</h3>
<p>我们可以通过R中的solve()函数求逆。但是注意，solve()函数并不总是numerically stable。</p>
<p>crossprod(A，B)  = t(A) %*% B</p>
<p>crossprod(A) = t(A) %*% A</p>
<h3 id="liner-model">liner model</h3>
<p>我们可以重新定义父子身高的矩阵形式</p>
<p><img src="linear_model_height1.png" alt=""></p>
<p>因此该线性模型为：</p>
<p><img src="linear_model_height2.png" alt=""></p>
<p>最小二乘统计量为</p>
<p><img src="linear_model_height3.png" alt=""></p>
<h3 id="advanced-使用求导求最小二乘">advanced:使用求导求最小二乘</h3>
<p><img src="LSE2.png" alt=""></p>
<p>由于最小二乘也是一个平方值，所以，类似于 f(x)^2^ 的求导为 2f(x)f’(x)</p>
<p>具体没太搞懂</p>
<h2 id="Linear-Models">Linear Models</h2>
<blockquote>
<p>“Linear”” here does not refer to lines, but rather to linear combinations.</p>
</blockquote>
<p>这句话的意思是，线性模型指的不是一条线（y=x+x^2^ 就是曲线），而是指的是影响因素的线性组合。</p>
<p>model matrix 来求出 LSE，我们称之为 fitting the model 。 我们在R中可以直接使用 lm() 函数，但是其实 lm() 函数内部也是使用了model.matrix()函数。</p>
<p>design matrix 至少包含两列（第一列全是1，表示截距）。但是我觉得，也可以不要截距。比如diet 对 小鼠体重的影响，截距是 chow diet 的平均体重，另一个是high fat - chow fat 的差值。也可以设置为，第一列是chow diet ，第二列是 high fat 。不过最少还是需要两列。</p>
<p>使用model.matrix() 函数前必须<strong>因子化</strong></p>
<p>所谓因子（factor），它们的具体名称不重要（字符串或者数值），重要的是order（把同一类的归到一组）</p>
<p>model.matrix() 中 +0 或 -1 不要截距，这样每一个水平都有一个单独的系数。</p>
<h3 id="Releveling-（实际没什么用）">Releveling （实际没什么用）</h3>
<p>参考水平（reference level，也就是截距所在的水平）一般是<strong>名称按字母排序</strong>的第一个水平，可以通过relevel 改变</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">group &lt;- factor(<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">group &lt;- relevel(group, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">model.matrix(~ group)</span><br><span class="line"><span class="comment">##   (Intercept) group1</span></span><br><span class="line"><span class="comment">## 1           1      1</span></span><br><span class="line"><span class="comment">## 2           1      1</span></span><br><span class="line"><span class="comment">## 3           1      0</span></span><br><span class="line"><span class="comment">## 4           1      0</span></span><br><span class="line"></span><br><span class="line">model.matrix(~ group-<span class="number">1</span>)</span><br><span class="line"><span class="comment">##          group2 group1</span></span><br><span class="line"><span class="comment">## 1           0      1</span></span><br><span class="line"><span class="comment">## 2           0      1</span></span><br><span class="line"><span class="comment">## 3           1      0</span></span><br><span class="line"><span class="comment">## 4           1      0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以直接在factor() 函数中说明顺序</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">group &lt;- factor(<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>),levels = <span class="built_in">c</span>(<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;1&#x27;</span>))</span><br><span class="line">model.matrix(~group-<span class="number">1</span>)</span><br><span class="line"><span class="comment">##  group3 group2 group1</span></span><br><span class="line"><span class="comment">## 1      0      0      1</span></span><br><span class="line"><span class="comment">## 2      0      0      1</span></span><br><span class="line"><span class="comment">## 3      0      1      0</span></span><br><span class="line"><span class="comment">## 4      0      1      0</span></span><br><span class="line"><span class="comment">## 5      1      0      0</span></span><br><span class="line"><span class="comment">## 6      1      0      0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是如果水平数很多，这样做就太麻烦了。</p>
<p>不如一开始就按照需要的顺序从1到n 重编号就好了。</p>
<h3 id="连续变量">连续变量</h3>
<p>在实际的使用中，除了分类变量。我们可能还会将连续的数字变量转化为design matrix。比如在自由落体实验中，时间和时间的平方就包含在了模型中。它们也要转化为model.matrix</p>
<p>连续变量不用因子化，也不能因子化。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tt&lt;-seq(<span class="number">0</span>,<span class="number">3.4</span>,len=<span class="number">4</span>)</span><br><span class="line">model.matrix(~tt+I(tt^<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">  (Intercept)       tt   I(tt^<span class="number">2</span>)</span><br><span class="line">1           <span class="number">1</span> <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line">2           <span class="number">1</span> <span class="number">1.133333</span>  <span class="number">1.284444</span></span><br><span class="line">3           <span class="number">1</span> <span class="number">2.266667</span>  <span class="number">5.137778</span></span><br><span class="line">4           <span class="number">1</span> <span class="number">3.400000</span> <span class="number">11.560000</span></span><br><span class="line"><span class="built_in">attr</span>(,<span class="string">&quot;assign&quot;</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>生命科学中经常需要考虑<strong>剂量效应</strong>，这也是一种连续变量。</p>
<p>但是，添加连续变量的假设<strong>难以辩护</strong>，因为分类变量仅仅是比较两个群体的均值之间是否有差异，而连续变量却意味着观测值与这个连续变量之间存在特别的关系。</p>
<p>比如落体试验中，这是因为我们以及知道了重力的公式。父子身高试验，我们能明显地看出来线性关系。但是如果你把年龄（age）也加入到身高的模型中，这就不对了。</p>
<p>因此，你的数据必须要能支持你把这个连续变量加入到模型中。即添加连续变量要小心。</p>
<h3 id="小鼠数据举例">小鼠数据举例</h3>
<p>在小鼠的数据中，我们之前是使用了t-test，其实我这里也可以使用线性模型，二者其实是<strong>异曲同工</strong>的。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dat&lt;-read.csv(<span class="string">&quot;femaleMiceWeights.csv&quot;</span>)</span><br><span class="line"><span class="comment">#没有设置stringsAsFactor，Diet已经是因子了</span></span><br><span class="line">levels(dat$Diet) </span><br><span class="line">X&lt;-model.matrix(~Diet, data=dat)</span><br><span class="line">head(X)</span><br><span class="line"></span><br><span class="line">Y&lt;-dat$Bodyweight</span><br><span class="line">X&lt;-model.matrix(~Diet, data=dat)</span><br><span class="line">solve(t(X)%*%X)%*%t(X)%*%Y</span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">                 [,<span class="number">1</span>]</span><br><span class="line">(Intercept) <span class="number">23.813333</span></span><br><span class="line">Diethf       <span class="number">3.020833</span></span><br></pre></td></tr></table></figure>
<p>查看均值、均值差，一致</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">s&lt;-split(dat$Bodyweight, dat$Diet)</span><br><span class="line"><span class="comment">#split() 按照分组因子，分类，形成一个列表</span></span><br><span class="line"><span class="comment">#有点实用啊</span></span><br><span class="line"></span><br><span class="line">mean(s[[<span class="string">&quot;chow&quot;</span>]])</span><br><span class="line"><span class="comment">## [1] 23.81333</span></span><br><span class="line"></span><br><span class="line">mean(s[[<span class="string">&quot;hf&quot;</span>]])-mean(s[[<span class="string">&quot;chow&quot;</span>]])</span><br><span class="line"><span class="comment">## [1] 3.020833</span></span><br></pre></td></tr></table></figure>
<p>使用lm() 函数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fit&lt;-lm(Bodyweight~Diet, data=dat)</span><br><span class="line">summary(fit)$coef</span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">             Estimate Std. Error   t value     Pr(&gt;|t|)</span><br><span class="line">(Intercept) <span class="number">23.813333</span>   <span class="number">1.039353</span> <span class="number">22.911684</span> <span class="number">7.642256e-17</span></span><br><span class="line">Diethf       <span class="number">3.020833</span>   <span class="number">1.469867</span>  <span class="number">2.055174</span> <span class="number">5.192480e-02</span></span><br></pre></td></tr></table></figure>
<p>t分布，当方差相等时结果一致。t分布的方差（标准差）一致等于线性模型中的残差分布一致。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">t.test(s[[<span class="string">&quot;chow&quot;</span>]],s[[<span class="string">&#x27;hf&#x27;</span>]],var.equal = <span class="built_in">T</span>)$p.value</span><br><span class="line"><span class="comment">## [1] 0.0519248</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Standard-Errors">Standard Errors</h3>
<p>实际我们得到的参数估计值仍然是一个<strong>随机变量</strong>，因此需要提供<strong>标准误</strong>才是有效的。</p>
<p>对于自由落体试验，我们可以采用Monte Carlo simulation</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">set.seed(<span class="number">1</span>)</span><br><span class="line">B&lt;-<span class="number">10000</span></span><br><span class="line">h0&lt;-<span class="number">56.67</span></span><br><span class="line">v0&lt;-<span class="number">0</span></span><br><span class="line">g&lt;-<span class="number">9.8</span><span class="comment">##meters per second</span></span><br><span class="line">n&lt;-<span class="number">25</span></span><br><span class="line">tt&lt;-seq(<span class="number">0</span>,<span class="number">3.4</span>,len=n)<span class="comment">##time in secs, t is a base function</span></span><br><span class="line">X&lt;-cbind(<span class="number">1</span>,tt,tt^<span class="number">2</span>)</span><br><span class="line"><span class="comment">##create X&#x27;X^-1 X&#x27;</span></span><br><span class="line">A&lt;-solve(crossprod(X))%*%t(X)</span><br><span class="line">betahat&lt;-replicate(B,&#123;</span><br><span class="line">  y&lt;-h0+v0*tt-<span class="number">0.5</span>*g*tt^<span class="number">2</span>+rnorm(n,sd=<span class="number">1</span>)</span><br><span class="line">  betahats&lt;-A%*%y</span><br><span class="line">  <span class="built_in">return</span>(betahats[<span class="number">3</span>])</span><br><span class="line">&#125;)</span><br><span class="line">head(betahat)</span><br><span class="line"><span class="comment"># [1] -5.038646 -4.894362 -5.143756 -5.220960 -5.063322</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每次得到的估计都不同</p>
<p>我们可以观察一下估计值的分布。发现符合正态，这是因为参数估计值是观测值的线性组合。因此，只要<strong>观测值符合正态分布</strong>，那么参数也符合正态分布</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(rafalib)</span><br><span class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">hist(betahat)</span><br><span class="line">qqnorm(betahat)</span><br><span class="line">qqline(betahat)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以得到参数均值和标准误的估计值</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="built_in">round</span>(mean(betahat),<span class="number">1</span>)</span><br><span class="line"><span class="comment">## [1] -4.9</span></span><br><span class="line"></span><br><span class="line">sd(betahat)</span><br><span class="line"><span class="comment">## [1] 0.2129976</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在父子身高的试验中，randomness 主要是我们是随机采样的父子对（father and son pairs）。为了说明，我们假设下面的就是整个群体的数据</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(UsingR)</span><br><span class="line">x&lt;-father.son$fheight</span><br><span class="line">y&lt;-father.son$sheight</span><br><span class="line">n&lt;-<span class="built_in">length</span>(y)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来我们采用Monte Carlo simulation，这里我们设定样本大小为50，然后重复抽样。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N&lt;-<span class="number">50</span></span><br><span class="line">B&lt;-<span class="number">1000</span></span><br><span class="line">betahat&lt;-replicate(B,&#123;</span><br><span class="line">  index&lt;-sample(n,N)</span><br><span class="line">  sampledat&lt;-father.son[index,]</span><br><span class="line">  x&lt;-sampledat$fheight</span><br><span class="line">  y&lt;-sampledat$sheight</span><br><span class="line">  lm(y~x)$coef</span><br><span class="line">  &#125;)</span><br><span class="line">betahat&lt;-t(betahat) <span class="comment">#have estimates in two columns</span></span><br><span class="line"></span><br><span class="line">mypar(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">qqnorm(betahat[,<span class="number">1</span>])</span><br><span class="line">qqline(betahat[,<span class="number">1</span>])</span><br><span class="line">qqnorm(betahat[,<span class="number">2</span>])</span><br><span class="line">qqline(betahat[,<span class="number">2</span>])</span><br><span class="line"><span class="comment">#符合正态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#lm() 两个参数的相关</span></span><br><span class="line">cor(betahat[,<span class="number">1</span>],betahat[,<span class="number">2</span>])</span><br><span class="line"><span class="comment">## [1] -0.9991099</span></span><br></pre></td></tr></table></figure>
<h3 id="方差-协方差矩阵">方差-协方差矩阵</h3>
<p>我们用一个类似求和的符号表示协方差矩阵。</p>
<p><img src="variance1.png" alt=""></p>
<p>以观测值 Y 向量为例，由于来自于同一个群体，所以我们认为所有Yi 有着共同的方差，而且由于个体间互相独立，因此非对角线元素全为0。因此观测值 Y 向量的方差-协方差矩阵只有两种元素。</p>
<p><img src="variance2.png" alt=""></p>
<p><img src="variance3.png" alt=""></p>
<p>根据上面的公式，我们可以求出LSE的标准误（也就是标准差）</p>
<p><img src="variance4.png" alt=""></p>
<p>为了得到参数估计的标准误，我们需要估计群体的标准差。</p>
<p>这里我们采用下面方法估计群体的标准差（具体推导不了解）</p>
<p><img src="variance5.png" alt=""></p>
<p>采用R代码如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">n&lt;-nrow(father.son)</span><br><span class="line">N&lt;-<span class="number">50</span></span><br><span class="line">index&lt;-sample(n,N)</span><br><span class="line">sampledat&lt;-father.son[index,]</span><br><span class="line">x&lt;-sampledat$fheight</span><br><span class="line">y&lt;-sampledat$sheight</span><br><span class="line">X&lt;-model.matrix(~x)</span><br><span class="line"></span><br><span class="line">N&lt;-nrow(X)</span><br><span class="line">p&lt;-ncol(X)</span><br><span class="line"></span><br><span class="line">XtXinv&lt;-solve(crossprod(X))</span><br><span class="line"></span><br><span class="line">resid&lt;-y-X%*%XtXinv%*%crossprod(X,y)</span><br><span class="line"></span><br><span class="line">s&lt;-<span class="built_in">sqrt</span>( <span class="built_in">sum</span>(resid^<span class="number">2</span>)/(N-p))</span><br><span class="line"></span><br><span class="line">ses&lt;-<span class="built_in">sqrt</span>(diag(XtXinv))*s</span><br><span class="line"></span><br><span class="line"><span class="comment">## Let’s compare to whatlmprovides:</span></span><br><span class="line"></span><br><span class="line">summary(lm(y~x))$coef[,<span class="number">2</span>]</span><br><span class="line"><span class="comment">## (Intercept)           x </span></span><br><span class="line"><span class="comment">##   9.1642841   0.1359242 </span></span><br><span class="line"></span><br><span class="line">ses</span><br><span class="line"><span class="comment">## (Intercept)           x </span></span><br><span class="line"><span class="comment">##   9.1642841   0.1359242 </span></span><br></pre></td></tr></table></figure>
<p>后面一部分都没看懂</p>
<blockquote>
<p>They are identical because they are doing the same thing.</p>
</blockquote>
<p>192页后面没看</p>
<h3 id="The-QR-Factorization">The QR Factorization</h3>
<p>solve <strong>is numerically unstable</strong></p>
<p>例如，在求LSE中，需要求（X’X）^-1^</p>
<h4 id="分解（）">分解（）</h4>
<p>任何满秩的 N × p 矩阵X（如果不是方阵，哪来的满秩？？），都可以如下分解：</p>
<p><img src="factorization1.png" alt=""></p>
<h4 id="用QR求LSE">用QR求LSE</h4>
<p><img src="qr1.png" alt=""></p>
<p>R 代码如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">n&lt;-<span class="number">50</span>;M&lt;-<span class="number">500</span></span><br><span class="line">x&lt;-seq(<span class="number">1</span>,M,len=n)</span><br><span class="line">X&lt;-cbind(<span class="number">1</span>,x,x^<span class="number">2</span>,x^<span class="number">3</span>)</span><br><span class="line">colnames(X)&lt;-<span class="built_in">c</span>(<span class="string">&quot;Intercept&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&quot;x2&quot;</span>,<span class="string">&quot;x3&quot;</span>)</span><br><span class="line">beta&lt;-matrix(<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),<span class="number">4</span>,<span class="number">1</span>)</span><br><span class="line">set.seed(<span class="number">1</span>)</span><br><span class="line">y&lt;-X%*%beta+rnorm(n,sd=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">QR&lt;-qr(X)</span><br><span class="line">Q&lt;-qr.Q( QR )</span><br><span class="line">R&lt;-qr.R( QR )</span><br><span class="line">(betahat&lt;-backsolve(R, crossprod(Q,y) ) )</span><br><span class="line"></span><br><span class="line"><span class="comment">##也可以直接通过solve函数</span></span><br><span class="line"></span><br><span class="line">QR&lt;-qr(X)</span><br><span class="line">(betahat&lt;-solve.qr(QR, y))</span><br><span class="line"></span><br><span class="line"><span class="comment">##              [,1]</span></span><br><span class="line"><span class="comment">## Intercept 0.9038372</span></span><br><span class="line"><span class="comment">## x         1.0066440</span></span><br><span class="line"><span class="comment">## x2        0.9999622</span></span><br><span class="line"><span class="comment">## x3        1.0000001</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>理论学习</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>理论学习</tag>
      </tags>
  </entry>
  <entry>
    <title>模型学习笔记</title>
    <url>/posts/9664406d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>线性模型学习的大杂烩，之后再拆分。</p>
<span id="more"></span>
<h1>Linear Models for the Prediction of Animal Breeding Values</h1>
<h2 id="第一章-基础">第一章 基础</h2>
<h3 id="通过个体自身记录估计育种值">通过个体自身记录估计育种值</h3>
<p><img src="single_record_by_own_performance.png" alt=""></p>
<blockquote>
<p>The corrlelation between the selection criterion, in this case the phenotypic value, and the true breeding value is known as the accuracy of prediction.</p>
</blockquote>
<p>这段话是说在这种情况下，表型和育种值的相关便是预测准确性（the accuracy of prediction）。但是这里的育种值用的就是the true breeding value，也就是平常说的估计育种值？<br>
而某些情况下，对准确性进行平方，称为可靠性（reliability or repeatability,r^2），即相关系数的平方。</p>
<h1>Computing Strategies for Solving Mixed Model Equations</h1>
<p>对大量方程组的求解通常采用迭代技术因为数据太大，使得直接求逆时无法全部储存再内存中。（Solution of a  large set of equations is usually by iteration techniques because they are too large to store in the memory of the com- puter for direct inversion）<br>
虽然BLUP可能是最好的分析线性模型的方法，但是其计算的复杂度使得研究者需要使用简单的模型，或者采用除BLUP外的其他方法。因此，可计算性（computability）非常重要。<br>
本文是单纯<strong>从理论上</strong>比较不同的计算MME的策略</p>
<h2 id="模型">模型</h2>
<p>用的是牛的数据，固定效应为场年季（HYS,herd-year-season)，随机效应为公牛效应。</p>
<h2 id="计算方法">计算方法</h2>
<p>假设有50万个奶牛观测值，均来自于 1万头公牛，5万个场年季水平。假定每个场年季水平包括来自于6头不同的公牛的10个女儿成绩。那么就会有30万个公牛×场年季亚水平。<br>
像数据量这么庞大的情况下，直接求逆是不可能的。</p>
<h2 id="第一种方法-–-直接方法-Straightforward-Approach">第一种方法 – 直接方法(Straightforward  Approach)</h2>
<p>将系数矩阵的所有非0值存储在硬盘中，每一行为所在行id，所在列id，值。(感觉类似为DMU跑出的G阵)。<br>
<strong>y = Wh + Zs + e</strong><br>
MME中<strong>W’W</strong>是包含了50,000个非零元素的对角线矩阵（其中的值为每个场年季水平的重复数）。<strong>Z’Z</strong>也是包含了10,000个非零元素的对角线矩阵（在动物模型中，对角线元素只有0和1，表示有无表型）。<strong>W’Z</strong>和<strong>Z’W</strong>互为转置矩阵，且各包含300,000个非零值（实际为HYS×sire的亚水平的重复数）。那么系数矩阵就总共有600,000个非零元素。Any iterative solution program must read each element once during each round of iteration. Conveniently, unless there are covariates in the model, these nonzero elements are integer variables, but the time to solve the equations depends on the speed with  which  the 660,000 records can be retrieved from disk.（这一段大概说，每一次迭代都要读取每一个数字，因此从硬盘读取的速度和数字大小就影响了计算速度，不知道求逆怎么迭代？）。For example, W’W and Z’Z are diagonal matrices and the diagonals could be stored in program memory rather than disk, and thus, only 600,000   nonzero elements need to be stored on disk（作者给出的意见是，因为W’W和Z’Z是对角线元素，因此可以直接放在内存中，其他还放在硬盘中。）<br>
第四部分还要加上KA^-1^。</p>
<h2 id="第二种方法-Absorption-Approach">第二种方法-- Absorption Approach</h2>
<p>The absorption or elimination technique whereby a large diagonal submatrix can be absorbed into the other equations is frequently used for the solution of large sets of equations. Absorption of HYS equations into sire equations gives Z’MZ and Z’My, where M = I - W(W’W)^-I^W’. The resulting equations to solve are<br>
(Z’MZ + A^-1^k)s^ = Z’My (s^即s估计值）<br>
……<br>
Consequently, even though the absorption approach yields only 10,000 equations, we may have more records to read during each round of iteration, and therefore, <strong>computing costs would increase</strong>. Also, the extra program steps to sort and add together “like” coefficients is a disadvantage of the absorption approach.<br>
看不懂，不过看最后的结语，貌似计算难度还提高了。</p>
<h2 id="第三种方法–Indirect-Approach">第三种方法–Indirect Approach</h2>
<p>In this method data are arranged in HYS by sire subclasses sorted by HYS. Each record consists of HYS and sire identification with the corresponding number of daughters and the sum of daughter Observations in the subclass. Thus, we would have 300,000 subclasses for the example.<br>
If Y~Ij.~ is the subclass total and n~ij~ is the number of daughters for the jth sire in the ith<br>
HYS, then we accumulate the quantity, over sires within HYS:<br>
Y~ij.~ - n~ij~s~j~^</p>
<p>where s~j~^ is the current  solution for sire j. Then the new solution for the i^th^ HYS is<br>
……后面真看不懂</p>
<h2 id="小结">小结</h2>
<p>Prediction error variances of sire evaluations can be approximated in the same manner as<br>
with the absorption approach. The number of effective daughters, or the diagonals of Z’MZ, can be obtained while reading the HYS subclasses,but another vector of length equal to the number of sires would be needed to accumulate the information across HYS.<br>
（<strong>PEV</strong>可以通过第二种方法Absorption Approach近似估计。）<br>
The main advantage of the  indirect approach is that only one relatively simple computer program is necessary to obtain solutions for mixed model equations. At this point,  rate of convergence of the indirect approach compared with other methods is unknown. However, in the sire model  of [1], if the solutions for HYS are close to the mean of records in that HYS, then convergence should be relatively quick because HYS means are the solutions  after  the first iteration. Knowing I’A^-1^s  should be zero can also speed convergence<br>
(没看懂，好像是说第三种间接方法只适用于模型不变时？)</p>
<h1>Indirect Solution of Mixed Model Equations</h1>
<p>Two iterative procedures were investigated, Gauss-Seidel and Jacobi.With a balanced dara set, putting restrictions on fixed effects is not effective for improving convergence ratcs in GaussSeidel but is essential in Jacobi.</p>
<h2 id="引言">引言</h2>
<p>构建MME需要花很长时间。Schaeffer and Kennedy 展示了一种不用构建the system of equations的策略。他们的策略，称之为indirect approach,performs Gauss-Seidel (G-S) or successive overrelaxation (SOR) iteration while reading the data files rather than the matrix of coefficients.The data files, read once per round of iteration, consist of two copies of an observation file, each sorted for a different factor with a large number of levels, and three<br>
copies of a relationship file, also sorted differently.<br>
Misztal (2, 3) proposed another indirect approach using Jacobi (J) iteration (8). Programming<br>
is simpler, because only one unsorted copy of each of the observation and relationship files need to be read per round of iteration.Basic J iteration has a poor convergence rate,especially for models with many factors or with a random factor including t~ numerator relationship matrix. However, putting restrictions on the effects of levels of fixed factors and extending the method to second·order J made it competitive in running time relative to other methods; convergence rate was approximately half ,ha’ of SOR (8)<br>
This paper presents the indirect approach in terms of succesive averaging, investigates its<br>
properties, and describes several computing options.z<br>
还是看不懂，这个真的是纯方法。两种迭代方式。优点就是不用构建MME了。</p>
<h1>python 进行矩阵求解</h1>
<p>宋师兄是从from scipy import linalg，但其实numpy 本身也有这个linalg, 也可以实现相同的功能。<br>
宋师兄python- GBLUP</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> pysnptools.snpreader <span class="keyword">import</span> Bed</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> linalg</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment">###构建G矩阵###</span></span><br><span class="line"><span class="comment"># PLINK bed文件名</span></span><br><span class="line">bed_file = <span class="string">&#x27;plink2&#x27;</span></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">M = Bed(bed_file, count_A1=<span class="literal">False</span>).read()</span><br><span class="line"><span class="comment"># 计算每个位点的等位基因频率</span></span><br><span class="line">freq = np.<span class="built_in">sum</span>(M.val, axis=<span class="number">0</span>) / (<span class="number">2</span> * M.iid_count)</span><br><span class="line"><span class="comment"># 计算标准化因子</span></span><br><span class="line">scale = np.<span class="built_in">sum</span>(<span class="number">2</span> * freq * (<span class="number">1</span> - freq))</span><br><span class="line"><span class="comment"># 计算Z矩阵</span></span><br><span class="line">Z = M.val - <span class="number">2</span> * freq</span><br><span class="line"><span class="comment"># 计算G矩阵</span></span><br><span class="line">G = np.dot(Z, Z.T) / scale</span><br><span class="line"><span class="comment">#对角线向量加0.001</span></span><br><span class="line">d = np.diag(G) + <span class="number">0.001</span></span><br><span class="line"><span class="comment">#替换原来的G矩阵对角线</span></span><br><span class="line">np.fill_diagonal(G, d)</span><br><span class="line"><span class="comment">#求逆</span></span><br><span class="line">Ginv = linalg.inv(G)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#读取数据文件</span></span><br><span class="line">data_file = <span class="string">&#x27;phe&#x27;</span></span><br><span class="line">data = pd.read_table(data_file, header=<span class="number">0</span>, sep = <span class="string">&#x27;\s+&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> data.head()</span><br><span class="line"><span class="comment">#数据文件有6列，ID、mean、sex、age、、phe。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#表型向量</span></span><br><span class="line">y = np.array(data[<span class="string">&#x27;phe&#x27;</span>], dtype = np.<span class="built_in">float</span>)</span><br><span class="line"><span class="comment">#固定效应设计矩阵</span></span><br><span class="line">X = np.array(data.loc[:,<span class="string">&#x27;mean&#x27;</span>:<span class="string">&#x27;treat&#x27;</span>], dtype = np.<span class="built_in">float</span>)</span><br><span class="line">	<span class="comment"># data.loc中表示，提取mean列到treat列的所有行</span></span><br><span class="line">	<span class="comment"># treat没出现在前面，估计是第5列</span></span><br><span class="line">	<span class="comment"># 这个也不符合固定效应关联矩阵的定义啊，搞不懂</span></span><br><span class="line">	<span class="comment"># 反正这里的X阵，应该不是理论上的固定效应设计矩阵，它的行数和表型数目一致，所以下文中，才能对X阵,Z阵按列进行合并，形成什么W阵。</span></span><br><span class="line"><span class="comment">#随机效应矩阵为单位阵</span></span><br><span class="line">num = <span class="built_in">len</span>(y)  <span class="comment">#个体数</span></span><br><span class="line">Z =  np.eye(num) </span><br><span class="line">	<span class="comment">#他这里的Z矩阵是表型个数的单位阵</span></span><br><span class="line">	<span class="comment">#按常规BLUP，Z矩阵是对角阵，但是有表型的是1，没表型的是0</span></span><br><span class="line">	<span class="comment">#难道这里宋师兄都是有表型的个体，不对吧？那预测啥个体啊？</span></span><br><span class="line"><span class="comment">#W矩阵</span></span><br><span class="line">W = np.concatenate((X, Z), axis = <span class="number">1</span>)</span><br><span class="line">	<span class="comment">#concatenate 数组拼接函数 axis=1,是按列合并</span></span><br><span class="line">	<span class="comment">#就是说合并的两个矩阵要有相同的行数。</span></span><br><span class="line">	<span class="comment">#嗯嗯，X和Z行数就是相同的</span></span><br><span class="line"><span class="comment">#构建W’R-1W，由于残差方差是独立同分布的，可以写为</span></span><br><span class="line">C = np.dot(W.T, W)/<span class="number">0.139</span></span><br><span class="line">	<span class="comment">#np.dot 正常的矩阵相乘，这里就是W‘*W。</span></span><br><span class="line">	<span class="comment">#0.139不知道什么意思，是不是残差方差</span></span><br><span class="line">	<span class="comment">#懂了，因为残差矩阵等于单位阵乘以残差方差，因此这里可以作为常数提出来。</span></span><br><span class="line">	<span class="comment">#因为是R逆，所以是1/残差方差。</span></span><br><span class="line"><span class="comment">#加入随机效应部分的方差协方差矩阵的逆，构建系数矩阵</span></span><br><span class="line">C[X.shape[<span class="number">1</span>]:,X.shape[<span class="number">1</span>]:] += Ginv/<span class="number">0.088</span></span><br><span class="line">	<span class="comment">#C里面是X的列数，比如如果是4，就是从第5行，第5列开始。</span></span><br><span class="line">	<span class="comment">#我懂了，这里是把𝐺^(−1)∕𝜎_𝑎^2 加上来，形成一个完整的系数矩阵。</span></span><br><span class="line"><span class="comment">#系数矩阵右手项</span></span><br><span class="line">RHS = np.dot(W.T, y)/ <span class="number">0.139</span></span><br><span class="line"><span class="comment">#求解混合模型方程组</span></span><br><span class="line">effect = linalg.solve(C, RHS)</span><br><span class="line"></span><br><span class="line"><span class="comment">#提取效应</span></span><br><span class="line">fix_eff = effect[:X.shape[<span class="number">1</span>]]  <span class="comment">#固定效应部分</span></span><br><span class="line">ran_eff = effect[X.shape[<span class="number">1</span>]:,] <span class="comment">#随机效应部分</span></span><br><span class="line"><span class="comment">####下面介绍如何对固定效应检验，如何求可靠性</span></span><br><span class="line"><span class="comment">#系数矩阵求逆</span></span><br><span class="line">Ci = linalg.inv(C)</span><br><span class="line"><span class="comment">#固定效应整体检验（包括均值），备择假设为至少有一个显著</span></span><br><span class="line">covi = linalg.inv(Ci[:X.shape[<span class="number">1</span>], :X.shape[<span class="number">1</span>]]) <span class="comment">#估计值方差协方差矩阵的逆</span></span><br><span class="line">chi_val = np.dot(fix_eff.T, np.dot(covi, fix_eff)) <span class="comment">#卡方值</span></span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> chi2 <span class="comment">#加载卡方分布的库</span></span><br><span class="line">p1 = chi2.sf(chi_val, <span class="number">4</span>) <span class="comment">#转化为P值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#育种值的可靠性计算</span></span><br><span class="line">PEV = np.diag(Ci[X.shape[<span class="number">1</span>]:, X.shape[<span class="number">1</span>]:]) <span class="comment">#取系数矩阵随机效应部分的对角线，即为PEV</span></span><br><span class="line">R2 = <span class="number">1</span> - PEV/<span class="number">0.088</span></span><br><span class="line"><span class="comment">#输出可靠性的最大、最小值</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">max</span>(R2), <span class="built_in">min</span>(R2)  <span class="comment">#可靠性比较高，可能由于所有个体都表型</span></span><br></pre></td></tr></table></figure>
<h1>Efficient Methods to Compute Genomic Predictions – VanRaden 2008</h1>
<h2 id="M矩阵（-1，0，1）">M矩阵（-1，0，1）</h2>
<p>M矩阵是n(个体数)*m（snp数）的矩阵，内容为-1，0，1（-1表示Major frequent的纯合子，0表示杂合子，1表示Minor frequent 的纯合子）。<br>
MM’ 的对角线元素为每个个体的纯和子的数目，非对角线元素没有实际意义（实际等于两个个体相同的纯和子数目（如AA与AA）-不同的纯合子数目（AA与TT）,杂合子没影响）（off-diagonals measure the number of alleles shared by relatives.）</p>
<p>M’M 的对角线表示每个位点纯合子的个体数，非对角线元素没有实际意义，计算类上。</p>
<h2 id="P矩阵（2-p-0-5">P矩阵（2*(p-0.5))</h2>
<p>P矩阵也是n<em>m的矩阵，其中每一列的内容都是相同的（对应的是该snp的2</em>(p-0.5)）。<br>
其中p的计算方式是（(1<em>杂合子+2</em>Minor frequent的纯合子)/2n（n为个体数））。</p>
<h2 id="Z矩阵-中心化">Z矩阵 中心化</h2>
<p>Z = M - P (which sets mean values of the allele effects to 0.)<br>
懂了，所谓矩阵中心化就是说，就是减去均值，使数据的均值的为0。<br>
而标准化的过程，是减去均值，然后除以标准差。使数据满足（0，1）的标准正态分布。<br>
为什么减去P矩阵，就能实现中心化呢？<br>
个人理解。<br>
如果所有基因满足<strong>哈温平衡</strong>，那么</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D &#x3D; (1-p)^2  # D 指代的是基因频率大的纯和子</span><br><span class="line">H &#x3D; 2\*(1-p)\*(p)</span><br><span class="line">R &#x3D; p^2</span><br><span class="line">由于D H R 在M矩阵中分别为-1,0,1</span><br><span class="line">那么均值为 -1\*(1-p)^2 + 0\* 2\*(1-p)\*(p) + 1\*p^2 &#x3D; 2(p-0.5)</span><br><span class="line">但是前提是必须满足哈温平衡</span><br></pre></td></tr></table></figure>
<p>文章中也提及了选择的等位基因不能经过<strong>选择</strong>，这也就是从侧面说要满足哈温平衡。</p>
<blockquote>
<p>Allele frequencies  in  P  should  be  from  the  unselected  base  population rather than those that occur after selection or inbreeding.</p>
</blockquote>
<h2 id="G阵">G阵</h2>
<p><img src="G_matrix.png" alt="G_matrix"></p>
<p>除以分母，使得G阵与A阵可比。</p>
<blockquote>
<p>Division by  2(1 )∑−ppii scales  G to  be  analogous(可比的)  to  the  numerator  relationship  matrix  A.</p>
</blockquote>
<h2 id="其他推导G阵的方法">其他推导G阵的方法</h2>
<p>没太看懂，反正好像就第一种用的多。</p>
<h1>model.matrix_R</h1>
<h2 id="分类变量（Factors）：R中用于存储分类数据的类别信息">分类变量（Factors）：R中用于存储分类数据的类别信息</h2>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">f = factor(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="built_in">class</span>(f) <span class="comment"># &quot;factor&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="哑变量">哑变量</h2>
<p>虚拟变量/哑变量（dummy variable) ：量化非数值类型的变量，通常取0/1。例如一个人的性别。</p>
<h2 id="解释变量">解释变量</h2>
<p>解释变量（explanatory variable) : 等同于控制变量/自变量，与之相对的是<strong>被解释变量</strong>（反应变量/因变量）。</p>
<h2 id="设计矩阵">设计矩阵</h2>
<p>设计矩阵（design matrix）: 又叫<strong>模型矩阵</strong>（model matrix) 或者 <strong>回归矩阵</strong>（regressor matrix) 。 由解释变量值组成的矩阵：一行代表一个独立的观测对象（样本），一列代表对应的变量（特征值、元数据），通常记为X。简单理解，就是我们所说的输入矩阵，可以是元数据的，也可以是数据的。</p>
<h1>PH525x series - Biomedical Data Science 网页</h1>
<h2 id="choice-of-design">choice of design</h2>
<p>The choice of design matrix is a critical step in linear modeling since it encodes which coefficients will be fit in the model, as well as the inter-relationship between the samples. A common misunderstanding is that the choice of design follows straightforward from a description of which samples were included in the experiment. This is not the case. The basic information about each sample (whether control or treatment group, experimental batch, etc.) does not imply a single ‘correct’ design matrix. The design matrix additionally encodes various assumptions about how the variables in X explain the observed values in Y, on which the investigator must decide. (这一段都看不太懂，大概意思是系数矩阵的构建需要构建者自身知道，哪些<strong>X</strong>中的因素能够解释<strong>Y</strong>中的观测值。)</p>
<p>model.matrix中使用~号表示开始一个公式（formula）,这个符号右边的变量，指示每个个体在哪个群体中（which tells us which samples are in which group）。</p>
<h2 id="截距（Intercept）的含义">截距（Intercept）的含义</h2>
<p>For the examples we cover here, we use linear models to make comparisons between different groups. Hence, the design matrices that we ultimately work with will have at least two columns: an intercept column, which consists of a column of 1’s, and a second column, which specifies which samples are in a second group. In this case, two coefficients are fit in the linear model: <strong>the intercept, which represents the population average of the first group</strong>, and a second coefficient, which represents the difference between the population averages of the second group and the first group. The latter is typically the coefficient we are interested in when we are performing statistical tests: we want to know if their is a difference between the two groups.</p>
<p>从这段画可以看出，截距是有含义的。这里的模型是Y为老鼠的体重，自变量只有一个，那就是是否接受了高脂肪食物（只有两种状态0和1，0表示没有，1表示接受了高脂肪食物）。这里的截距β就是指当老鼠没有接受高脂肪食物时的平均体重，而β1指的是接受高脂肪食物后体重的平均变化量。</p>
<p>简单的说，也就是截距表示的<strong>group的一种状态（随便那种设为基本状态，R里好像是把碰到的第一个分类给截距）<strong>时的均值。也就是截距就表示了一种状态（状态0）。其他的group的值是在这个基础状态的</strong>变化量</strong>。比如此时β1就是接受高脂肪食物相较于没有接受的体重增加量。</p>
<p>如果不设截距，使用~group-1，此时如果如果Y = βx + e。每个β（两种状态）都是<strong>绝对值</strong>。</p>
<p><img src="Design_Matrix1.png" alt=""></p>
<h2 id="组别为2">组别为2</h2>
<p>Let’s try an example. Suppose we have two groups, control and high fat diet, with two samples each. For illustrative purposes, we will code these with 1 and 2 respectively. <strong>We should first tell R that these values should not be interpreted numerically, but as different levels of a factor.</strong> （在R中，设计矩阵那一列必须设定为<strong>factor</strong>）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">group &lt;- factor(<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">model.matrix(~group)</span><br><span class="line"><span class="comment">#model.matrix(formula(~ group)) #可以省略formula()</span></span><br><span class="line"><span class="comment">## 结果如下，如果不写-1，那么就会有一个截距</span></span><br><span class="line"><span class="comment">## 因为因子化了，这里的group就好像变成0和1了。</span></span><br><span class="line"> (Intercept) group2</span><br><span class="line">1           <span class="number">1</span>      <span class="number">0</span></span><br><span class="line">2           <span class="number">1</span>      <span class="number">0</span></span><br><span class="line">3           <span class="number">1</span>      <span class="number">1</span></span><br><span class="line">4           <span class="number">1</span>      <span class="number">1</span></span><br><span class="line"><span class="built_in">attr</span>(,<span class="string">&quot;assign&quot;</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="built_in">attr</span>(,<span class="string">&quot;contrasts&quot;</span>)</span><br><span class="line"><span class="built_in">attr</span>(,<span class="string">&quot;contrasts&quot;</span>)$group</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;contr.treatment&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="group-1">group - 1</h3>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">group &lt;- factor(<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">model.matrix(~group -<span class="number">1</span> )</span><br><span class="line"><span class="comment">#model.matrix(~group +0 )</span></span><br><span class="line"><span class="comment"># ~group - 1(+0) 这样就没有基础值β0了。</span></span><br><span class="line"><span class="comment"># This group now fits a separate coefficient for each group.</span></span><br><span class="line">  group1 group2</span><br><span class="line">1      <span class="number">1</span>      <span class="number">0</span></span><br><span class="line">2      <span class="number">1</span>      <span class="number">0</span></span><br><span class="line">3      <span class="number">0</span>      <span class="number">1</span></span><br><span class="line">4      <span class="number">0</span>      <span class="number">1</span></span><br><span class="line"><span class="built_in">attr</span>(,<span class="string">&quot;assign&quot;</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="built_in">attr</span>(,<span class="string">&quot;contrasts&quot;</span>)</span><br><span class="line"><span class="built_in">attr</span>(,<span class="string">&quot;contrasts&quot;</span>)$group</span><br><span class="line">[<span class="number">1</span>] <span class="string">&quot;contr.treatment&quot;</span></span><br><span class="line"></span><br><span class="line">如果我们不设定group为**因子**的话</span><br><span class="line"></span><br><span class="line">```R</span><br><span class="line">group &lt;- c(1,1,2,2)</span><br><span class="line">model.matrix(~group)</span><br><span class="line"></span><br><span class="line">## 结果，这里group是1和2，不符合设计矩阵元素只有0和1</span><br><span class="line">## 所谓设计矩阵，只是一个*indicator*,指示个体所属的group，因此只有0和1，而且一列只有一个1，其他都是0。</span><br><span class="line">## 所以，model.matrix所在列的实际内容无关紧要，是数字也好，字符串也好。都没影响，都只是分类变量，设计矩阵只是提示这个个体属于哪个分类（group）</span><br><span class="line">## 因此，model.matrix前必须进行因子化。</span><br><span class="line">  (Intercept) group</span><br><span class="line">1           1     1</span><br><span class="line">2           1     1</span><br><span class="line">3           1     2</span><br><span class="line">4           1     2</span><br><span class="line">attr(,&quot;assign&quot;)</span><br><span class="line">[1] 0 1</span><br></pre></td></tr></table></figure>
<p>将分类列的内容换成字符串，结果相同</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">group &lt;- factor(<span class="built_in">c</span>(<span class="string">&quot;control&quot;</span>,<span class="string">&quot;control&quot;</span>,<span class="string">&quot;highfat&quot;</span>,<span class="string">&quot;highfat&quot;</span>))</span><br><span class="line">model.matrix(~ group)</span><br><span class="line"></span><br><span class="line"><span class="comment">##   (Intercept) grouphighfat</span></span><br><span class="line"><span class="comment">## 1           1            0</span></span><br><span class="line"><span class="comment">## 2           1            0</span></span><br><span class="line"><span class="comment">## 3           1            1</span></span><br><span class="line"><span class="comment">## 4           1            1</span></span><br><span class="line"><span class="comment">## attr(,&quot;assign&quot;)</span></span><br><span class="line"><span class="comment">## [1] 0 1</span></span><br><span class="line"><span class="comment">## attr(,&quot;contrasts&quot;)</span></span><br><span class="line"><span class="comment">## attr(,&quot;contrasts&quot;)$group</span></span><br><span class="line"><span class="comment">## [1] &quot;contr.treatment&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="More-groups">More groups</h3>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">group &lt;- factor(<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">model.matrix(~ group)</span><br><span class="line"><span class="comment">##   (Intercept) group2 group3</span></span><br><span class="line"><span class="comment">## 1           1      0      0</span></span><br><span class="line"><span class="comment">## 2           1      0      0</span></span><br><span class="line"><span class="comment">## 3           1      1      0</span></span><br><span class="line"><span class="comment">## 4           1      1      0</span></span><br><span class="line"><span class="comment">## 5           1      0      1</span></span><br><span class="line"><span class="comment">## 6           1      0      1</span></span><br><span class="line"><span class="comment">## attr(,&quot;assign&quot;)</span></span><br><span class="line"><span class="comment">## [1] 0 1 1</span></span><br><span class="line"><span class="comment">## attr(,&quot;contrasts&quot;)</span></span><br><span class="line"><span class="comment">## attr(,&quot;contrasts&quot;)$group</span></span><br><span class="line"><span class="comment">## [1] &quot;contr.treatment&quot;</span></span><br></pre></td></tr></table></figure>
<p>Now we have a third column which specifies which samples belong to the third group.（现在我们有了第三列，来表示第三种group）</p>
<h2 id="更多的变量">更多的变量</h2>
<p>这里只考虑了diet，实际情况中一般会有更多的变量。在这里，我们增加了<strong>性别</strong>变量。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">diet &lt;- factor(<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">sex &lt;- factor(<span class="built_in">c</span>(<span class="string">&quot;f&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="string">&quot;m&quot;</span>,<span class="string">&quot;m&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="string">&quot;m&quot;</span>,<span class="string">&quot;m&quot;</span>))</span><br><span class="line">table(diet,sex)</span><br><span class="line"><span class="comment">##     sex</span></span><br><span class="line"><span class="comment">## diet f m</span></span><br><span class="line"><span class="comment">##    1 2 2</span></span><br><span class="line"><span class="comment">##    2 2 2</span></span><br></pre></td></tr></table></figure>
<p>如果我们假设日粮效应对于公鼠和母鼠的效应是相同的（也就是二者没有互作）。那么线性模型为<br>
Y~i~ = β~0~ + β~1~x~i,1~ + β~2~x~2,i~ + e~i~</p>
<p>那么，model.matrix设置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">diet &lt;- factor(c(1,1,1,1,2,2,2,2))</span><br><span class="line">sex &lt;- factor(c(&quot;f&quot;,&quot;f&quot;,&quot;m&quot;,&quot;m&quot;,&quot;f&quot;,&quot;f&quot;,&quot;m&quot;,&quot;m&quot;))</span><br><span class="line">model.matrix(~ diet + sex)</span><br><span class="line">##   (Intercept) diet2 sexm</span><br><span class="line">## 1           1     0    0</span><br><span class="line">## 2           1     0    0</span><br><span class="line">## 3           1     0    1</span><br><span class="line">## 4           1     0    1</span><br><span class="line">## 5           1     1    0</span><br><span class="line">## 6           1     1    0</span><br><span class="line">## 7           1     1    1</span><br><span class="line">## 8           1     1    1</span><br><span class="line">## attr(,&quot;assign&quot;)</span><br><span class="line">## [1] 0 1 2</span><br><span class="line">## attr(,&quot;contrasts&quot;)</span><br><span class="line">## attr(,&quot;contrasts&quot;)$diet</span><br><span class="line">## [1] &quot;contr.treatment&quot;</span><br><span class="line">## </span><br><span class="line">## attr(,&quot;contrasts&quot;)$sex</span><br><span class="line">## [1] &quot;contr.treatment&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果考虑互作效应</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">model.matrix(~ diet + sex + diet:sex)</span><br><span class="line"><span class="comment">#model.matrix(~ diet*sex)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##   (Intercept) diet2 sexm diet2:sexm</span></span><br><span class="line"><span class="comment">## 1           1     0    0          0</span></span><br><span class="line"><span class="comment">## 2           1     0    0          0</span></span><br><span class="line"><span class="comment">## 3           1     0    1          0</span></span><br><span class="line"><span class="comment">## 4           1     0    1          0</span></span><br><span class="line"><span class="comment">## 5           1     1    0          0</span></span><br><span class="line"><span class="comment">## 6           1     1    0          0</span></span><br><span class="line"><span class="comment">## 7           1     1    1          1</span></span><br><span class="line"><span class="comment">## 8           1     1    1          1</span></span><br><span class="line"><span class="comment">## attr(,&quot;assign&quot;)</span></span><br><span class="line"><span class="comment">## [1] 0 1 2 3</span></span><br><span class="line"><span class="comment">## attr(,&quot;contrasts&quot;)</span></span><br><span class="line"><span class="comment">## attr(,&quot;contrasts&quot;)$diet</span></span><br><span class="line"><span class="comment">## [1] &quot;contr.treatment&quot;</span></span><br><span class="line"><span class="comment">## </span></span><br><span class="line"><span class="comment">## attr(,&quot;contrasts&quot;)$sex</span></span><br><span class="line"><span class="comment">## [1] &quot;contr.treatment&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Releveling-设置参考水平，reference-level">Releveling (设置参考水平，<em>reference level</em>)</h3>
<p>The level which is chosen for the reference level is the level which is contrasted against. By default, this is simply the first level alphabetically. We can specify that we want group 2 to be the reference level by either using the <em>relevel</em> function:<br>
翻译一下，所谓reference level（参考水平，也就是截距的水平），即是其他水平与之相比较的水平。默认情况下，参考水平就是<strong>名称按字母排序</strong>的第一个水平。我们可以通过<strong>relevel</strong>函数设定reference level。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">group &lt;- factor(<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">group &lt;- relevel(group, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">model.matrix(~ group)</span><br><span class="line"><span class="comment">##   (Intercept) group1</span></span><br><span class="line"><span class="comment">## 1           1      1</span></span><br><span class="line"><span class="comment">## 2           1      1</span></span><br><span class="line"><span class="comment">## 3           1      0</span></span><br><span class="line"><span class="comment">## 4           1      0</span></span><br><span class="line"><span class="comment">## attr(,&quot;assign&quot;)</span></span><br><span class="line"><span class="comment">## [1] 0 1</span></span><br><span class="line"><span class="comment">## attr(,&quot;contrasts&quot;)</span></span><br><span class="line"><span class="comment">## attr(,&quot;contrasts&quot;)$group</span></span><br><span class="line"><span class="comment">## [1] &quot;contr.treatment&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="连续变量">连续变量</h2>
<p>In this chapter, we focus on models based on indicator values. In certain designs, however, we will be interested in using numeric variables in the design formula, as opposed to converting them to factors first. For example, in the falling object example, time was a continuous variable in the model and time squared was also included:<br>
翻译一下，就是一般设计矩阵都是用于分类变量，当有时我们也会感兴趣一些连续变量。比如在落体运动，时间和时间的平方就应该考虑进入模型中。<br>
连续变量用于设计矩阵，表示的是一种<strong>剂量效应</strong>。此时求解出来的β表示的是每增加一单位的连续变量，y的平均改变量。<br>
这也就是带来了一种连续变量应用的假设或前提，你得知道这个变量对反应变量的影响是<strong>线性</strong>的。不然得出的结果是错的。<br>
以下英文具体阐述了这种观点。例如落体距离与时间的关系，因为有经典的物理的公式，所以我们确信它们之间是<strong>线性关系</strong>。但是对于其他变量，如年龄等可能不是线性关系的变量，我们不鼓励这么使用。<br>
The assumptions imposed by including continuous data as variables are typically hard to defend and motivate than the indicator function variables. Why the indicator variables simply assume a different mean between two groups, continuous variables assume a very specific relationship between the outcome and predictor variables.</p>
<p>In cases like the falling object, we have the theory of gravitation supporting the model. In the father-son height example, because the data is bi variate normal, it follows that there is a linear relationship if we condition. However, we find that continuous variables are included in linear models without justification to “adjust” for variables such as age. We highly discourage this practice unless the data support the model being used.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># I()用于在模型中进行数学转换时。</span></span><br><span class="line"><span class="comment">#因为在模型的定义中，常见的符号+（俩变量）、*（考虑互作）、：（互作）、^(不清楚)有了特殊含义，不再是原来的数学运算符号。</span></span><br><span class="line"><span class="comment">#^符号貌似是考虑互作？ 在模型中，（x+y)^2 表示的是 x + y + x:y</span></span><br><span class="line"><span class="comment">#?fromula 中The ^ operator indicates crossing to the specified degree. For example (a+b+c)^2 is identical to (a+b+c)*(a+b+c) which in turn expands to a formula containing the main effects for a, b and c together with their second-order interactions. </span></span><br><span class="line"><span class="comment">#即(a+b+c)^2 表示 a + b + c + a:b + a:c + b:c。嗯，对的</span></span><br><span class="line"><span class="comment"># -1 或 +0 都表示通过原点，即没有截距。</span></span><br><span class="line"><span class="comment">#变量保护函数（I( )）：放在I内的表达式按照算术意义进行解释</span></span><br><span class="line">	<span class="comment">#a+b 表示变量a和变量b都包含在公式中</span></span><br><span class="line">	<span class="comment">#I(a+b）表示 a+b 这个和应该包含在公式中</span></span><br><span class="line"><span class="comment"># R中关于模型设定的问题，找?formula.</span></span><br><span class="line">tt &lt;- seq(<span class="number">0</span>,<span class="number">3.4</span>,len=<span class="number">4</span>) </span><br><span class="line">model.matrix(~ tt + I(tt^<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">##   (Intercept)       tt   I(tt^2)</span></span><br><span class="line"><span class="comment">## 1           1 0.000000  0.000000</span></span><br><span class="line"><span class="comment">## 2           1 1.133333  1.284444</span></span><br><span class="line"><span class="comment">## 3           1 2.266667  5.137778</span></span><br><span class="line"><span class="comment">## 4           1 3.400000 11.560000</span></span><br><span class="line"><span class="comment">## attr(,&quot;assign&quot;)</span></span><br><span class="line"><span class="comment">## [1] 0 1 2</span></span><br></pre></td></tr></table></figure>
<h1>MME构建与求解-邓飞</h1>
<p>setwd(‘D:\Desktop\R_model’)<br>
ped &lt;- read.table(‘example_ped.txt’,header = F)<br>
dat &lt;- read.table(‘example_dat.txt’,header = F)</p>
<h2 id="处理系谱">处理系谱</h2>
<p>library(nadiv)<br>
pped = prepPed(ped)#给founders也增加一行系谱，然后排序系谱<br>
pped</p>
<h1>输入系谱文件缺失值为NA,0,*</h1>
<h1>输出文件缺失值全未NA</h1>
<h1>A = as.matrix(makeA(pped))</h1>
<h1>A</h1>
<h1>A_inv = solve(A) #solve(A) 即求逆</h1>
<h1>A_inv</h1>
<p>A_inv = makeAinv(pped)$Ainv#可直接求A逆<br>
A_inv<br>
#结果为list<br>
#$Ainv为稀疏矩阵<br>
#$listAinv为三列的格式<br>
#f为近交系数，不计算<br>
#logDet the log determinant of the A matrix<br>
#dii the (non-zero) elements of the diagonal D matrix of the A=TDT’ decomposition.</p>
<h2 id="修要对A逆按照一定顺序重排">修要对A逆按照一定顺序重排</h2>
<p>A_inv = as.matrix(A_inv)<br>
#rownames(A_inv) = as.numeric(rownames(A_inv))<br>
#A_inv的行名为字符串，而且不能改成数字，不知道是为什么。</p>
<p>###使用z_phe A_inv不需要重排<br>
colnames(A_inv) = rownames(A_inv)<br>
new_rowname &lt;- sort(rownames(A_inv))<br>
new_rowname<br>
A_inv<br>
A_inv_new &lt;- A_inv[new_rowname,new_rowname]<br>
#这里用1:8，或者seq(‘1’,‘8’)，都不行，因为是数字<br>
#而实际的行名或列名是字符串。<br>
A_inv_new # 现在与Z_all就一致了。</p>
<p>str(dat)<br>
colnames(dat) &lt;- c(‘id’,‘sex’,‘wwg’) #个体号-性别-初生重<br>
dat$id &lt;- as.factor(dat$id)<br>
dat$sex &lt;- as.factor(dat$sex)<br>
X &lt;- model.matrix(~sex-1,data = dat) #和书上一致<br>
Z_phe &lt;- model.matrix(~id-1,data = dat) # 5*5的单位阵，一致<br>
zero_matrix &lt;- matrix(rep(0,15),nrow = 5)<br>
Z_all &lt;- cbind(zero_matrix,Z_phe)<br>
Z_all # Z_all 为添加了三列的所有个体的Z矩阵。</p>
<p>y = as.vector(dat$wwg)</p>
<h3 id="Z-all-结果">Z_all 结果</h3>
<p>alpha = 2 # alpha设置为2</p>
<p>XpX=crossprod(X) #X’X</p>
<p>XpZ=crossprod(X,Z_all) #X’Z</p>
<p>ZpX=crossprod(Z_all,X) #Z’X</p>
<p>ZpZ=crossprod(Z_all) #Z’Z</p>
<p>Xpy=crossprod(X,y) #X’y</p>
<p>Zpy=crossprod(Z_all,y) #Z’y</p>
<p>LHS=rbind(cbind(XpX,XpZ),cbind(ZpX,ZpZ+A_inv_new*alpha)) #LHS<br>
LHS<br>
LHS_inv1 = solve(LHS)<br>
LHS_inv1</p>
<p>RHS=rbind(Xpy,Zpy) #不需要<br>
RHS</p>
<p>sol=solve(LHS)%*%RHS #MME求解<br>
sol</p>
<h3 id="Z-phe-结果">Z_phe 结果</h3>
<p>a = as.character(dat$id)<br>
A_inv2 = A_inv_new[a,a] #截取4：8个体的逆阵<br>
A_inv2</p>
<p>XpX=crossprod(X) #X’X</p>
<p>XpZ=crossprod(X,Z_phe) #X’Z</p>
<p>ZpX=crossprod(Z_phe,X) #Z’X</p>
<p>ZpZ=crossprod(Z_phe) #Z’Z</p>
<p>Xpy=crossprod(X,y) #X’y</p>
<p>Zpy=crossprod(Z_phe,y) #Z’y</p>
<p>LHS=rbind(cbind(XpX,XpZ),cbind(ZpX,ZpZ+A_inv2*alpha)) #LHS<br>
LHS ##LHS和Z_all一致<br>
LHS_inv2 = solve(LHS)<br>
LHS_inv2 #但是逆矩阵的结果就不一致了。</p>
<p>RHS=rbind(Xpy,Zpy) #不需要<br>
RHS #右手项也是去除了相应的行而已，其他一致</p>
<p>sol=solve(LHS)%*%RHS #MME求解<br>
sol<br>
#结果略有不同。</p>
<p>#小结<br>
#还是应该用所有个体，更方便。也更符合实际评估的情况。<br>
#使用全部个体及有表型个体，获得的LHS是一样的<br>
#仅仅是有表型个体的LHS，从全部个体的LHS中删除了无表型个体的行和列。</p>
<p>#问题<br>
#Z矩阵和A逆的构建问题。<br>
#Z矩阵和表型有关，又和A逆有关。<br>
#还是先构建A逆</p>
<p>#我发现一直对表型和系谱的重编号顺序是错的。<br>
#之前都是先重编号，再追系谱。这样会删掉一部分表型。<br>
#应该先追系谱（这样确保所有表型（参验群体）均在系谱中），再重编号。</p>
<p>#如果按照all的思路，应该是这样。<br>
#从单场重编号结果（从1到n,要确保不间断，即系谱总共就是n个个体）。<br>
#然后没有表型的个体就是n-m(m为表型行数)。<br>
#然后构建Z阵 有n-m列全为0,后面m列为&quot;单位阵&quot;。不对，我做的是两个场。所以后面Z阵再重复一遍，先是n2-m2列全为0，后面m2列为&quot;单位阵&quot;<br>
#得到A逆，重排，按两个场分开，每个场都是前面是没表型的，后面是有表型的。</p>
<p>#另一种思路<br>
#A逆可以不重排，完全根据A逆的顺序构建Z阵<br>
#对于每一个A中的个体，没有表型，则Z中相应的这一列（行）全为0<br>
#如果A逆中的个体有表型，那么找到这个个体在表型中的行数，此时Z中这个个体相应的行数的地方为1，其他为0<br>
#这个在python中用字典可以做到，R感觉不方便。</p>
<p>##第二种all的思路是对的。但是A逆还是要重排，最起码得第一个场的个体都在前面，第二个场的个体堵在后面。<br>
##不能两个场的个体混在一块。</p>
<p>##总结一下，all的思路复杂，在R中不好实现。在python中可能方遍实现。</p>
<p>#Z_phe<br>
#那就得按照表型的顺序挑A逆，即可。<br>
#Z阵就是一个m*m的单位阵（m为两个场的表型总数）<br>
#这种方法非常简单，实用。</p>
<p>#这里有一个潜在的问题是，表型不能再被剔除了。<br>
#也就是说从表型的原始文件到重编号，不能删表型<br>
#也就是要对原始文件提前处理好。</p>
<h1>总的来说，只使用有表型个体的数据简单，目前先用这种方法。</h1>
<h1>现在能通过A阵算出来两个场的LHS逆了，就差临门一脚PEBD了。</h1>
<p>使用实际数据，只考虑有表型个体，通过A阵构建系数矩阵整理如下。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里只用有表型的个体</span></span><br><span class="line"></span><br><span class="line">setwd(<span class="string">&#x27;D:\\Desktop\\R_model\\true_practice\\HAYF19647_HAQG17137&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ped &lt;- read.table(<span class="string">&#x27;pedigree_code&#x27;</span>,header = <span class="built_in">F</span>)</span><br><span class="line">dat &lt;- read.table(<span class="string">&#x27;phe_code&#x27;</span>,header = <span class="built_in">F</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 处理系谱</span></span><br><span class="line">new_ped &lt;- ped[,<span class="number">1</span>:<span class="number">3</span>] <span class="comment">#不要第四列</span></span><br><span class="line"></span><br><span class="line">library(nadiv)</span><br><span class="line">pped = prepPed(new_ped)<span class="comment">#给founders也增加一行系谱，然后排序系谱</span></span><br><span class="line"></span><br><span class="line">A_inv = makeAinv(pped)$Ainv<span class="comment">#可直接求A逆</span></span><br><span class="line"></span><br><span class="line">A_inv = as.matrix(A_inv)</span><br><span class="line"></span><br><span class="line">colnames(A_inv) = rownames(A_inv)</span><br><span class="line"></span><br><span class="line">str(dat)</span><br><span class="line">colnames(dat) &lt;- <span class="built_in">c</span>(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;gu&#x27;</span>,<span class="string">&#x27;wo&#x27;</span>,<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;bf&#x27;</span>)</span><br><span class="line">dat$id &lt;- as.factor(dat$id) </span><br><span class="line">dat$gu &lt;- as.factor(dat$gu)</span><br><span class="line">X &lt;- model.matrix(~gu-<span class="number">1</span>,data = dat) </span><br><span class="line">Z &lt;- model.matrix(~id-<span class="number">1</span>,data = dat) <span class="comment"># Z为单位阵</span></span><br><span class="line"></span><br><span class="line">phe_id = <span class="built_in">as.character</span>(dat$id)</span><br><span class="line">A_inv2 = A_inv[phe_id,phe_id] <span class="comment">#截取表型个体的A逆</span></span><br><span class="line"></span><br><span class="line">alpha = <span class="number">2.09</span> <span class="comment"># alpha由方差组分得来。</span></span><br><span class="line"></span><br><span class="line">XpX=crossprod(X) <span class="comment">#X’X </span></span><br><span class="line"></span><br><span class="line">XpZ=crossprod(X,Z) <span class="comment">#X’Z</span></span><br><span class="line"></span><br><span class="line">ZpX=t(XpZ)</span><br><span class="line"></span><br><span class="line"><span class="comment">#ZpX=crossprod(Z,X) #Z’X</span></span><br><span class="line"></span><br><span class="line">ZpZ=crossprod(Z) <span class="comment">#Z’Z</span></span><br><span class="line"></span><br><span class="line">LHS=rbind(cbind(XpX,XpZ),cbind(ZpX,ZpZ+A_inv2*alpha)) <span class="comment">#LHS</span></span><br><span class="line"></span><br><span class="line">LHS_inv = solve(LHS)</span><br><span class="line"></span><br><span class="line">write.table(LHS,file = <span class="string">&#x27;HAYF_HAQG_LHS.txt&#x27;</span>,<span class="built_in">quote</span> = <span class="literal">FALSE</span>,sep = <span class="string">&quot; &quot;</span>,row.names = <span class="literal">FALSE</span>,col.names = <span class="literal">FALSE</span>)</span><br><span class="line">write.table(LHS_inv,file = <span class="string">&#x27;HAYF_HAQG_LHS_inv.txt&#x27;</span>,<span class="built_in">quote</span> = <span class="literal">FALSE</span>,sep = <span class="string">&quot; &quot;</span>,row.names = <span class="literal">FALSE</span>,col.names = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>Data Analysis for the Life Sciences</h1>
<h2 id="introduction">introduction</h2>
<p>statistical inference(统计推断)：推断就是使用可能性从数据中获取群体特征值（Inference is the use of probability to learn population characteristic from data）。一个典型的例子就是推断两个群体的平均值是否相同。</p>
<h2 id="getting-started">getting started</h2>
<p>主要是介绍了一些R的基础部分和数学基础。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">###第一章 getting started </span></span><br><span class="line">install.packages(<span class="string">&quot;swirl&quot;</span>)</span><br><span class="line">install.packages(<span class="string">&quot;rafalib&quot;</span>)</span><br><span class="line">install.packages(<span class="string">&quot;downloader&quot;</span>)</span><br><span class="line">setwd(<span class="string">&#x27;D:\\Desktop\\下载英文文献\\模型\\R_model&#x27;</span>)</span><br><span class="line">dat &lt;- read.table(<span class="string">&#x27;female_mouse_weights.txt&#x27;</span>,header = <span class="built_in">T</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">###通过downloader直接下载网上的数据</span></span><br><span class="line">library(downloader) <span class="comment">##use install.packages to install ##通过downloader</span></span><br><span class="line">url &lt;- <span class="string">&quot;https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extd\</span></span><br><span class="line"><span class="string">ata/femaleMiceWeights.csv&quot;</span>  <span class="comment">## 数据的完整路径</span></span><br><span class="line">filename &lt;- <span class="string">&quot;femaleMiceWeights.csv&quot;</span></span><br><span class="line">download(url, destfile=filename) <span class="comment">## 下载，后面更的是下载后的名称</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 为了从GitHub 上直接下载文件夹，你需要下载devtools包</span></span><br><span class="line">library(devtools)</span><br><span class="line">install_github(<span class="string">&quot;genomicsclass/dagdata&quot;</span>)</span><br><span class="line"></span><br><span class="line">dir &lt;- system.file(package = <span class="string">&quot;dagdata&quot;</span>) <span class="comment"># 获取文件夹位置</span></span><br><span class="line">dir  <span class="comment">## &quot;D:/software/R/R-3.6.1/library/dagdata&quot;</span></span><br><span class="line">list.files(dir) <span class="comment"># 查看dir下面的文件和子文件夹</span></span><br><span class="line">list.files(dir,<span class="string">&quot;extdata&quot;</span>) <span class="comment"># 查看extdata下的子文件</span></span><br><span class="line">filename&lt;-file.path(dir,<span class="string">&quot;extdata/femaleMiceWeights.csv&quot;</span>) <span class="comment">## 文件的完整路径</span></span><br><span class="line">dat&lt;-read.csv(filename) <span class="comment">## 最终打开文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####初探dplyr </span></span><br><span class="line">library(<span class="string">&quot;dplyr&quot;</span>)</span><br><span class="line"><span class="comment">##dplyr包中filter是进行数据筛选</span></span><br><span class="line">chow &lt;- filter(dat,Diet==<span class="string">&quot;chow&quot;</span>) <span class="comment">## 筛选Diet列中为chow的数据</span></span><br><span class="line">head(chow)</span><br><span class="line"></span><br><span class="line"><span class="comment">## select貌似是选列</span></span><br><span class="line">chowVals &lt;- select(chow,Bodyweight) <span class="comment">## 选择chow中的Bodyweight列</span></span><br><span class="line">head(chowVals)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 还可以使用通道符 %&gt;% denote a pipe </span></span><br><span class="line"><span class="comment">## 因此上述两步可以合成一步</span></span><br><span class="line">chowVals &lt;- filter(dat,Diet==<span class="string">&quot;chow&quot;</span>) %&gt;% select(Bodyweight)</span><br><span class="line">head(chowVals)</span><br><span class="line"><span class="comment">## dplyr接收的是data.frame ，返回的也是data.frame</span></span><br><span class="line"><span class="built_in">class</span>(chowVals) <span class="comment">#data.frame</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 为了使结果为向量，可以使用unlist函数。将list(包括data.frame)转换成numeric vectors. </span></span><br><span class="line">chowVals &lt;- filter(dat,Diet==<span class="string">&quot;chow&quot;</span>) %&gt;% select(Bodyweight) %&gt;% unlist</span><br><span class="line"><span class="comment">## 通道少写一个参数，但是这里的unlist连()都省了</span></span><br><span class="line"><span class="built_in">class</span>(chowVals) <span class="comment">#numeric </span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 不用dplyr的写法</span></span><br><span class="line">chowVals &lt;- dat[dat$Diet==<span class="string">&quot;chow&quot;</span>,<span class="string">&quot;Bodyweight&quot;</span>]</span><br><span class="line">head(chowVals)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 小结，感觉R整理数据就是不太方便。</span></span><br></pre></td></tr></table></figure>
<h2 id="inference">inference</h2>
<p>以下为random variable,  null distribution,  p-value 的 简要介绍。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#inference</span></span><br><span class="line">setwd(<span class="string">&#x27;D:\\Desktop\\下载英文文献\\模型\\R_model&#x27;</span>)</span><br><span class="line">dat &lt;- read.table(<span class="string">&#x27;female_mouse_weights.txt&#x27;</span>,header = <span class="built_in">T</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#####didtribution 的解析</span></span><br><span class="line"><span class="comment">#distribution：可以简单地理解为一堆数。</span></span><br><span class="line"><span class="comment">#比如你测量了一个群体中所有人的身高。</span></span><br><span class="line"><span class="comment">#这个时候你要和其他人不懂的人（such as analien that has never visited Earth）描述这些数字。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#假如以下就是你取得的身高数据</span></span><br><span class="line">library(UsingR)</span><br><span class="line">x &lt;- father.son$fheight</span><br><span class="line"></span><br><span class="line"><span class="comment">#最简单的就是列出来给外星人看</span></span><br><span class="line"><span class="built_in">round</span>(sample(x,<span class="number">10</span>),<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#但这不够充分，我们可以定义一个累积分布函数（Cumulative Distribution Function）</span></span><br><span class="line"><span class="comment">#F(a) == Pr(x&lt;a) #小于等于号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#画图如下</span></span><br><span class="line"><span class="comment"># floor ceiling 是取整用的</span></span><br><span class="line"><span class="comment"># floor 是直接取整数，ceiling 是 “天花板” </span></span><br><span class="line"><span class="comment"># 如 floor(2.99) = 2 ceiling(2.99) = 3</span></span><br><span class="line"><span class="comment"># 用在画图还是挺好的</span></span><br><span class="line"></span><br><span class="line">smallest&lt;-<span class="built_in">floor</span>( <span class="built_in">min</span>(x) )</span><br><span class="line">largest&lt;-<span class="built_in">ceiling</span>( <span class="built_in">max</span>(x) )</span><br><span class="line">values&lt;-seq(smallest, largest,len=<span class="number">300</span>)</span><br><span class="line">heightecdf&lt;-ecdf(x)</span><br><span class="line">plot(values, heightecdf(values), type=<span class="string">&quot;l&quot;</span>,xlab=<span class="string">&quot;a (Height in inches)&quot;</span>,ylab=<span class="string">&quot;Pr(x &lt;= a)&quot;</span>)</span><br><span class="line"><span class="comment"># 但是现在更常见的是画直方图</span></span><br><span class="line"><span class="comment"># 把直方图给外星人一看，基本就很清晰了。</span></span><br><span class="line">hist(x)</span><br><span class="line">bins&lt;-seq(smallest, largest)</span><br><span class="line">hist(x,breaks=bins,xlab=<span class="string">&quot;Height (in inches)&quot;</span>,main=<span class="string">&quot;Adult men heights&quot;</span>)</span><br><span class="line"><span class="comment">#breaks设置中，不用floor,ceiling 画不成图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####回到正题</span></span><br><span class="line">library(dplyr)</span><br><span class="line">control &lt;- filter(dat,Diet==<span class="string">&quot;chow&quot;</span>) %&gt;% select(Bodyweight) %&gt;% unlist</span><br><span class="line">treatment  &lt;- filter(dat,Diet==<span class="string">&quot;hf&quot;</span>) %&gt;% select(Bodyweight) %&gt;% unlist</span><br><span class="line">mean(treatment)</span><br><span class="line">mean(control)</span><br><span class="line">obsdiff &lt;- mean(treatment) - mean(control)</span><br><span class="line">obsdiff</span><br><span class="line"><span class="comment">#[1] 3.020833</span></span><br><span class="line"><span class="comment">#只看均值和差值是不够的</span></span><br><span class="line"><span class="comment">#因为如果你再取24只老鼠重新做试验，每一次都能得到一个新的结果。</span></span><br><span class="line"><span class="comment">#我们把具有这种特性的数据称为随机变量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####更深刻地理解随机变量###########</span></span><br><span class="line"><span class="comment"># 假设我们有所有的control群体，如下</span></span><br><span class="line">library(downloader)</span><br><span class="line">url&lt;-<span class="string">&quot;https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extdata/femaleControlsPopulation.csv&quot;</span></span><br><span class="line">filename&lt;-<span class="string">&quot;femaleControlsPopulation.csv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!file.exists(filename)) download(url,destfile=filename)</span><br><span class="line"><span class="comment">#如果文件不存在则下载</span></span><br><span class="line"></span><br><span class="line">population&lt;-read.csv(filename)</span><br><span class="line"></span><br><span class="line">population &lt;- unlist(population) <span class="comment">#从data.frame 转为 vector</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#从总体中每次随机抽取12只老鼠，重复三次，每次均值均不同</span></span><br><span class="line"></span><br><span class="line">control&lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">mean(control)</span><br><span class="line"><span class="comment">#[1] 23.4925</span></span><br><span class="line"></span><br><span class="line">control&lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">mean(control)</span><br><span class="line"><span class="comment">#[1] 24.96583</span></span><br><span class="line"></span><br><span class="line">control&lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">mean(control)</span><br><span class="line"><span class="comment">#[1] 22.90083</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#因此哪怕同一个群体，抽取不同的样本，之间也是有差异的。</span></span><br><span class="line"><span class="comment">#所以对于上面两个群体的obsdiff，我们存有怀疑，这究竟是不是因为影响因素（diet）造成的</span></span><br><span class="line"><span class="comment">#如果我们给这24只老鼠相同的diet，差异还有有这么大吗？</span></span><br><span class="line"><span class="comment">#出于怀疑精神，一般统计推断的零假设（null hypothesis）会设定为两个群体没有区别。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#由于我们有了control的总体，所以我们可以无限次抽样。</span></span><br><span class="line"><span class="comment">#每次从control的群体中，抽2批12只老鼠，求均值。代码如下</span></span><br><span class="line"></span><br><span class="line">control&lt;-sample(population,<span class="number">12</span>)</span><br><span class="line"><span class="comment">##another 12 control mice that we act as if they were not</span></span><br><span class="line">treatment &lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">print(mean(treatment)-mean(control))</span><br><span class="line"><span class="comment">#[1] -1.175</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#现在让我们重复这一步骤10000次</span></span><br><span class="line"></span><br><span class="line">null &lt;- vector()</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">10000</span>)&#123;</span><br><span class="line">  control&lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">  treatment &lt;-sample(population,<span class="number">12</span>)</span><br><span class="line">  null[i] &lt;- mean(treatment)-mean(control)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在在null中的值我们称之为null distribution</span></span><br><span class="line"></span><br><span class="line">mean(null&gt;=obsdiff)</span><br><span class="line"><span class="comment"># [1] 0.0147</span></span><br><span class="line"><span class="comment">#mean里面的是一个布尔向量，由TRUE和FALSE组成</span></span><br><span class="line"><span class="comment">#但是在计算的过程中，TRUE视为1，FALSE视为0。</span></span><br><span class="line"><span class="comment">#所以这个0.0147是这10000次中差距大于obsdiff的比例。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#因此作为一个怀疑主义者，我们可以得出结论</span></span><br><span class="line"><span class="comment">#如果没有diet effect，我们看到像obsdiff这么的差距的可能性是1.47%</span></span><br><span class="line"><span class="comment">#这就是所谓的P值！</span></span><br><span class="line"><span class="comment">#p值即原假设成立的前提下，此事件发生的概率。</span></span><br><span class="line"><span class="comment">#深入浅出，厉害！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#小结一下，像上述这样计算P值很简单。但是生活中不可行。</span></span><br><span class="line"><span class="comment">#因为你不肯真的把测量整个群体的信息，从而构成null distribution。</span></span><br><span class="line"><span class="comment">#一般也还是通过采样。</span></span><br><span class="line"><span class="comment">#也就是还是只通过数据中的24只老鼠的数据进行判断。</span></span><br></pre></td></tr></table></figure>
<h3 id="population-parameters">population parameters</h3>
<p>统计推断的第一步是弄清楚你感兴趣的群体。作者选这个这个小鼠的数据集的原因之一，是因为作者有所有这种类型的小鼠的体重信息（即这个群体的所有群体）。</p>
<p>如果你能收集你感兴趣的群体的所有数据，那么得到的参数（群体均值、方差、标准差）就被称为群体参数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(downloader)</span><br><span class="line">url&lt;-<span class="string">&quot;https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extdata/mice_pheno.csv&quot;</span></span><br><span class="line">filename&lt;-<span class="string">&quot;mice_pheno.csv&quot;</span> </span><br><span class="line">download(url,destfile=filename)</span><br><span class="line">dat&lt;-read.csv(filename) <span class="comment">#这是所有这个小鼠群体的数据</span></span><br><span class="line"></span><br><span class="line">library(dplyr)</span><br><span class="line">controlPopulation &lt;- filter(dat,Sex==<span class="string">&quot;F&quot;</span>&amp;Diet==<span class="string">&quot;chow&quot;</span>) </span><br><span class="line"><span class="built_in">length</span>(controlPopulation$Bodyweight)</span><br><span class="line"></span><br><span class="line">hfPopulation&lt;-filter(dat,Sex==<span class="string">&quot;F&quot;</span>&amp;Diet==<span class="string">&quot;hf&quot;</span>)</span><br><span class="line"><span class="built_in">length</span>(hfPopulation$Bodyweight)</span><br><span class="line"><span class="comment">#此时群体的均值、方差、标准差等就被称为群体参数（population parameters）</span></span><br><span class="line"><span class="comment">#此时回到我们的问题，两个群体的均值是否相等。</span></span><br><span class="line"><span class="comment">#由于我们拿到了两个群体的所有数据，那么用μy-ux（x:control y:hf）,直接看差值是否为0即可。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是，在实际生活中，我们拿不到群体的所有数据。比如，可能买下一个群体所有的小鼠是很贵的。<br>
因此，我们需要学会如何从样本数据来回答我们的问题。这就是统计推断的本质。</p>
<h3 id="Sample-estimates">Sample estimates</h3>
<p>在之前的章节中，我们从两个群体中各随机抽取了12只小鼠。我们一般用大写字母来表示抽样个体，以此表明他们是随机抽取的。这也是统计中的一种常规做法。因此抽样个体表示为X~1~ ……X~12~ 和 Y~1~ …… Y~12~。<br>
而对于上面的群体中的个体，用的是小写数字。因为这些个体是给定的，不是随机的。<br>
此时，研究目标是两个样本群体均值的差值。<br>
而这个差值也是一个随机变量（random variable）。前面，我们采用一种从原始数据中重复抽样的手段（10000次）。但是，这在实际中（in practice）是不可实现的，比如在我们这个例子中，就是要不断地买24只小鼠做试验。<br>
下面会介绍群体均值差与样本均值差的关系。这涉及到了中心极限定理。</p>
<h3 id="Central-Limit-Theorem-and-t-distribution">Central Limit Theorem and t-distribution</h3>
<p><strong>中心极限定理</strong>：<strong>无论群体总体服从什么分布</strong>，当抽样个体数足够大时（一般认为，每组大于等于30个），抽样群体的均值（Y拔）服从正态分布。其均值为群体均值，其标准差等于群体标准差除以根号N（N 为 simple size）。我们把这个随机变量分布的标准差称为标准误（<em>standard error</em>）。</p>
<ul>
<li>对于一个随机变量，加减常数（X+a），则该随机变量的均值也随之变化（u~X~+a）</li>
<li>对于一个随机变量，乘以一个常数（X*a），则该随机变量的均值和标准差也乘以此常数</li>
<li>对于两个独立的随机变量相加（X+Y），其均值为μ~X~+μ~Y~，其方差为二者之和。如果是两个独立的随机变量相减，其均值为二者之差，其方差仍未<strong>二者之和</strong>。</li>
<li>如果两个随机变量都满足正态分布，那么它们只和仍满足正态分布。</li>
</ul>
<p>在本例中，我们关心的两个群体的均值，由于中心极限定理，服从正态分布。因此它们的差值也服从正态分布，均值为两个随机变量之差，方差为<strong>两个随机变量之和</strong>。由于原假设是不存在差异，那么两个群体的均值的均值应该大致服从一个均值为0，标准差为√（σ2X+σ2Y）/√N的正态分布。<br>
也就是如下式</p>
<p><img src="clt.png" alt="clt"></p>
<p>这个进行了标准化的随机变量应该满足（0，1）的标准正态分布。（深入浅出！）</p>
<p>根据这个公式，我们可以更快地求出P值（已知标准正态分布）。例如，正态分布中大于2的值只有5%（in absolute value，应该是双尾的意思）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">pnorm(-<span class="number">2</span>)+(<span class="number">1</span>-pnorm(<span class="number">2</span>))</span><br><span class="line"><span class="comment">## [1] 0.04550026</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此，我们不用再买更多的小鼠，24只够了。</p>
<p>然而，事情到这一步还没有结束。因为我们不知道群体的标准差，σ~X~和σ~Y~。这些都是不可知的群体参数。但是我们可以用样本标准差去估计群体标准差，称为s~X~ 和 s~Y~。定义如下：</p>
<p><img src="s2.png" alt="s2"></p>
<p>这里是除以M-1 和 N-1（出于理论原因，没解释）。</p>
<p>因此，我们可以把上式改为：</p>
<p><img src="clt_new.png" alt="t_value"></p>
<p>中心极限定理告诉我们，当M,N较大时，这个随机变量服从标准正态分布（零假设下）。因此，我们现在可以计算P值了。</p>
<h3 id="t-分布">t 分布</h3>
<p>中心极限定理需要较大的抽样个体数，这个我们称之为<em>asymptotic results</em>。当这个条件不满足时，还有一种方法可以使用。如果总体数据服从一个均值为0的正态分布，那么对于我们的抽样个体均值，可以计算以下分布，称为t分布：</p>
<p><img src="t-distribution.png" alt="t-distribution"></p>
<p>这里很重要的一点，我们提到的服从正态分布是总体（y1,y2,……yn）服从正态分布，而不是Y拔。虽然无法实际证明，但是我们看一看抽样个体的分布。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">control &lt;- controlPopulation$Bodyweight</span><br><span class="line">hf &lt;- hfPopulation$Bodyweight</span><br><span class="line"><span class="comment"># 直方图</span></span><br><span class="line">op &lt;- par(mfrow = <span class="built_in">c</span>(<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line">hist(control)</span><br><span class="line">hist(hf)</span><br><span class="line">par(op)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更为直观的是，画一个QQ（quantie，分位数）图。分位数的实例之一就是四分位数。QQ图的个人理解为，对于x轴上的一点，能得到x分布中小于等于这个点的概率（比如5%）; 再找到y分布中对应5%概率的实际数值，即y值，这样就得到了一个点（x,y)。</p>
<ul>
<li>如果是离散变量，</li>
</ul>
<blockquote>
<p>在统计学中，QQ图[1] （Q代表分位数Quantile）是一种通过比较两个概率分布的分位数对这两个概率分布进行比较的概率图方法。首先选定分位数的对应概率区间集合，在此概率区间上，点(x,y)对应于第一个分布的一个分位数x和第二个分布在和x相同概率区间上相同的分位数。因此画出的是一条含参数的曲线，参数为概率区间的分割数。</p>
</blockquote>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">op &lt;- par(mfrow = <span class="built_in">c</span>(<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line">qqnorm(hf)</span><br><span class="line">qqline(hf)</span><br><span class="line">qqnorm(control)</span><br><span class="line">qqline(control)</span><br><span class="line">par(op)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在R中，var() 和 sd() 函数都是用于计算样本参数（即除以n-1）。不适用于计算群体参数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x &lt;- control</span><br><span class="line">N &lt;- <span class="built_in">length</span>(x)</span><br><span class="line">populationvar &lt;- mean((x-mean(x))^<span class="number">2</span>)</span><br><span class="line">identical(var(x),populationvar)</span><br><span class="line"><span class="comment">#identical 判断两个值是否相等。</span></span><br><span class="line"><span class="comment">#R中的var() 和 sd() 都是除以n-1。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是实际中，我们没有用到计算总体参数的地方（得不到）。这里为了教学，用了popvar(), popsd() 函数 计算总体参数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(<span class="string">&#x27;rafalib&#x27;</span>)</span><br><span class="line">sd_hf &lt;- popsd(hf)</span><br><span class="line">sd_control &lt;- popsd(control)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一般我们也只能得到样本，如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N &lt;- 12</span><br><span class="line">hf_sample &lt;- sample(hf,<span class="number">12</span>)</span><br><span class="line">control_sample &lt;- sample(control,<span class="number">12</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了 进一步了解中心极限定理，这里采用不同的抽样大小进行抽样</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对不同地抽样个体数，抽样10000次</span></span><br><span class="line"><span class="comment">#sapple 对Ns中的每一个数，执行后面的函数</span></span><br><span class="line">Ns&lt;-<span class="built_in">c</span>(<span class="number">3</span>,<span class="number">12</span>,<span class="number">25</span>,<span class="number">50</span>)</span><br><span class="line">B &lt;-  10000   <span class="comment">#number of simulations</span></span><br><span class="line">res&lt;-sapply(Ns,<span class="keyword">function</span>(n) &#123;</span><br><span class="line">  replicate(B,mean(sample(hf,n))-mean(sample(control,n)))</span><br><span class="line">&#125;)</span><br><span class="line">res</span><br><span class="line"></span><br><span class="line"><span class="comment">## 现在我们可以用qq图看中心极限定理的效果如何</span></span><br><span class="line">op &lt;- par(mfrow=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> seq(along=Ns)) &#123;    <span class="comment"># 等于 seq(length(Ns))</span></span><br><span class="line">  titleavg&lt;-<span class="built_in">signif</span>(mean(res[,i]),<span class="number">3</span>) <span class="comment">#signif和round差不多，不过后面不是小数位数，而是有效数字。</span></span><br><span class="line">  titlesd&lt;-<span class="built_in">signif</span>(popsd(res[,i]),<span class="number">3</span>)</span><br><span class="line">  title&lt;-paste0(<span class="string">&quot;N=&quot;</span>,Ns[i],<span class="string">&quot;Avg=&quot;</span>,titleavg,<span class="string">&quot;SD=&quot;</span>,titlesd)</span><br><span class="line">  qqnorm(res[,i],main=title)</span><br><span class="line">  qqline(res[,i],col=<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#随着抽样数目的增加，标准误越小。基本符合根号N的规律。</span></span><br><span class="line"><span class="comment">#即便抽样数目为3，也基本符合正态分布。</span></span><br><span class="line"><span class="comment">#这和总体分布有关。因为我们这个小鼠体重分布本身就接近正态分布。哪怕采样个体为1，也会符合正态分布。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是在实践中，我们不会只求均值，而是会除以标准差。此时采样个数就重要了</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Ns&lt;-<span class="built_in">c</span>(<span class="number">3</span>,<span class="number">12</span>,<span class="number">25</span>,<span class="number">50</span>)</span><br><span class="line">B&lt;-<span class="number">10000</span><span class="comment">#number of simulations#</span></span><br><span class="line"><span class="comment">#function to compute a t-stat</span></span><br><span class="line">computetstat&lt;-<span class="keyword">function</span>(n) &#123;</span><br><span class="line">  y&lt;-sample(hfPopulation,n)</span><br><span class="line">  x&lt;-sample(controlPopulation,n)</span><br><span class="line">  (mean(y)-mean(x))/<span class="built_in">sqrt</span>(var(y)/n+var(x)/n)</span><br><span class="line">  &#125;</span><br><span class="line">res&lt;-sapply(Ns,<span class="keyword">function</span>(n) &#123;</span><br><span class="line">  replicate(B,computetstat(n))</span><br><span class="line">  &#125;)</span><br><span class="line">op &lt;- par(mfrow=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> seq(along=Ns)) &#123;</span><br><span class="line">  qqnorm(res[,i],main=Ns[i])</span><br><span class="line">  qqline(res[,i],col=<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">#此时N=3已经有些偏离，而N=12只有轻微偏离</span></span><br><span class="line"><span class="comment">#因此N=12已经够了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是这种模拟在实际中无法做到。这里只用于说明CLT的概念和局限。</p>
<h3 id="t-tests-in-Partice">t-tests in Partice</h3>
<p>逻辑线：</p>
<ol>
<li>首先我们得到了两个样本群体的均值差，这本身也是一个随机变量。而且根据零假设，这个变量分布的均值为0。</li>
<li>那么这个均值差分布的标准误（差）呢？</li>
<li>首先我们根据中心极限定理，每个群体均值服从正态分布，标准误为总体标准差（这里直接用样本标准差估计总体标准差）除以根号N。</li>
<li>但这仅仅是每个样本均值的标准误（或者说标准差，其实我觉得这里说标准误和标准差是一回事，标准误就是均值的标准差，所以不还是标准差吗？这里说的均值差的标准误其实也就是均值差的标准差。）</li>
<li>我们根据统计理论，我们知道两个随机变量差值的方差等于这两个随机变量的方差之和（var(x-y)=var(x)+var(y))</li>
<li>因此se = sd( x-y ) = sqrt(var(x)+var(y)) =  sqrt( sd(x)/sqrt(n) + (sd(y)/sqrt(m) )</li>
<li>tstat &lt;- diff(-0)/se</li>
<li>这就是t统计量，由于除以了se，这个统计量的SE为1。</li>
<li>因此我们只要知道这个t统计量的分布，我们就能得到P值。</li>
<li>根据中心极限定理，当<strong>抽样个体数较大</strong>时，两个抽样均值均符合正态分布。根据统计理论，那么这两个随机变量之差也服从正态分布。因此此时这个tstat也是服从<strong>均值为0，方差为1的正态分布</strong></li>
<li>那么计算为了计算P值，我们需要问：在正态分布中，出现diff或比diff（tstat）更极端的值的概率是多大？（ how often does a normally distributed randomvariable exceeddiff?）我们可以通过pnorm()函数进行计算双尾概率。</li>
<li>在本例中，p-value 小于 0.05， 我们认为差异是显著的。（深入理解P值，P值是零假设成立下该事件发生的概率）</li>
<li>但是我们又面临另一个问题。中心极限定理只有在样本量较大时适用，但是12足够大了吗？一般我们认为样本数大于30才比较好。所以我们刚刚计算的P值只有在这个成立时才有效，所以这里可能不适用。然而，除了使用中心极限定理，我们这里有另一种方法。</li>
</ol>
<p>R代码如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dat&lt;-read.csv(<span class="string">&quot;femaleMiceWeights.csv&quot;</span>)<span class="comment">#previously downloaded</span></span><br><span class="line">control&lt;-filter(dat,Diet==<span class="string">&quot;chow&quot;</span>)%&gt;%select(Bodyweight)%&gt;%unlist</span><br><span class="line">treatment&lt;-filter(dat,Diet==<span class="string">&quot;hf&quot;</span>)%&gt;%select(Bodyweight)%&gt;%unlist</span><br><span class="line">diff&lt;-mean(treatment)-mean(control)</span><br><span class="line">print(diff)</span><br><span class="line"><span class="comment">## [1] 3.020833</span></span><br><span class="line"></span><br><span class="line">se&lt;-<span class="built_in">sqrt</span>(</span><br><span class="line">  var(treatment)/<span class="built_in">length</span>(treatment) + </span><br><span class="line">    var(control)/<span class="built_in">length</span>(control)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">tstat&lt;-diff/se</span><br><span class="line"><span class="comment">## [1] 2.055174</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##tstat在标准正态分布中出现的概率(双尾)</span></span><br><span class="line"><span class="comment">##也就是在标准正态分布中出现tstat及比tstat更极端的值的概率</span></span><br><span class="line">righttail&lt;-<span class="number">1</span>-pnorm(<span class="built_in">abs</span>(tstat))</span><br><span class="line">lefttail&lt;-pnorm(-<span class="built_in">abs</span>(tstat))</span><br><span class="line">pval&lt;-lefttail+righttail</span><br><span class="line">print(pval)</span><br><span class="line"></span><br><span class="line"><span class="comment">## [1] 0.0398622</span></span><br></pre></td></tr></table></figure>
<h3 id="The-t-distribution-in-Practice">The t-distribution in Practice</h3>
<p>根据上面的模拟情况和统计理论。 如果<strong>总体的分布是正态的</strong>，那么我们可以<strong>不通过中心极限定理</strong>，而弄清楚t统计量的确切分布。但是如果抽样个体数很少，很难证明总体分布是否符合正态。但是对于体重这种数据，根据经验，我们一般认为总体分布极可能大致符合正态分布，因此我们可以利用这种近似。另外，我们也可以看一下样本的qq图，如下所示。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">op &lt;- par(mfrow=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line">qqnorm(treatment)</span><br><span class="line">qqline(treatment,col=<span class="number">2</span>)</span><br><span class="line">qqnorm(control)</span><br><span class="line">qqline(control,col=<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果我们近似认为<strong>总体分布符合正态分布</strong>，那么基于统计理论，tstat服从t分布。相较于正态分布，t分布还有一个自由度的参数。我们直接通过下面的函数求解P值。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">t.test(treatment,control)</span><br><span class="line"></span><br><span class="line">t.test(treatment,control)$p.value <span class="comment">### 直接看P值</span></span><br><span class="line"><span class="comment">## [1] 0.05299888</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>The p-value is slightly bigger now. This is to be expected because our CLT approximation consideredthe denominator oftstatpractically fixed (with large samples it practically is), while the t-distribution approximation takes into account that the denominator (the standard error of thedifference) is a random variable. The smaller the sample size, the more the denominator varies.</p>
</blockquote>
<p>这段话没看太懂，大概理解是：这里用t分布计算出来的p值相较于上面用正态分布计算出来的P值较大。这是因为在CLT中，认为tstat的分母部分是固定的（也就是认为采用了大样本）；而t分布检验中认为tstat的分母部分是随机变量（还不是很懂）。</p>
<p>这可能会让人困惑，怎么会得到两个P值？但是，这在数据分析中是很常见的。通过不同的假设，不同的方法，我们就会得到不同的结果。</p>
<p>其实，基于中心极限定理得到的结果更容易出现<strong>假阳性</strong>，而基于t分布的结果更容易出现<strong>假阴性</strong>。</p>
<h3 id="Confidence-Intervals">Confidence Intervals</h3>
<p>在生命科学中，我们总是需要计算P值。但是我们并不推崇把P值当成唯一的统计指标。原因很简单：统计意义上的显著并不保证科学意义上的显著。当抽样个体数很大时，即便两个群体差异很小，你仍可以检测到一个统计意义上的显著差异。但是这有意义吗？如果只看P值，信息是不够的。还需要给出效应大小（这里是两个群体均值差）。<br>
另一种方法是给出置信区间。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#以control群体均值的置信区间为例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#先看总体的均值</span></span><br><span class="line">dat&lt;-read.csv(<span class="string">&quot;mice_pheno.csv&quot;</span>)</span><br><span class="line">chowPopulation&lt;-dat[dat$Sex==<span class="string">&quot;F&quot;</span>&amp;dat$Diet==<span class="string">&quot;chow&quot;</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">mu_chow&lt;-mean(chowPopulation)</span><br><span class="line">print(mu_chow)</span><br><span class="line"><span class="comment">## [1] 23.89338</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##我们是要估计这个参数，但是我们实际拿不到总体的数据</span></span><br><span class="line"><span class="comment">## 先抽取样本量为30的样本</span></span><br><span class="line"></span><br><span class="line">N&lt;-<span class="number">30</span></span><br><span class="line">chow&lt;-sample(chowPopulation,N)</span><br><span class="line">print(mean(chow))</span><br><span class="line"><span class="comment">## [1] 24.54567</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#我们知道样本均值是一个随机变量</span></span><br><span class="line"><span class="comment">#所以，这个值不是一个完美的估计</span></span><br><span class="line"><span class="comment">#通过置信区间来体现这个随机变量的variability</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#因为样本量为30，我们可以使用CLT。</span></span><br><span class="line"><span class="comment">#中心极限定理告诉我们，样本均值服从一个均值为总体均值，标准差为总体标准差除以根号30的正态分布。</span></span><br><span class="line"></span><br><span class="line">se&lt;-sd(chow)/<span class="built_in">sqrt</span>(N)</span><br><span class="line">print(se)</span><br><span class="line"><span class="comment">## [1] 0.6610814</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>A 95% confidence interval (we can use percentages other than 95%) is a random interval with a95% probability of falling on the parameter we are estimating. Keep in mind that saying 95% ofrandom intervals will fall on the true value (our definition above) isnot the sameas saying there isa 95% chance that the true value falls in our interval.(有点绕，没太懂。懂了，这个置信区间其实也是一个随机变量，你再抽一个样，这个置信区间也会变。所以你只能说置信区间（随机变量）从统计上说有95%的概率包含真值（你要是取10000个样本，计算出10000个置信区间，其中包含总体均值的概率在95%左右）。但是，如果是一个给定的区间(你最后计算出来的区间)，那么真值存在这个区间的概率只有0和1)</p>
</blockquote>
<p>由中心极限定理，我们可以对样本均值进行标准化。然后我们知道标准正态分布的95%区间大致在[-2,2]。因此可以得出下式</p>
<p><img src="confidence_interval.png" alt="confidence_interval"></p>
<p>我们直接得出置信区间</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Q&lt;-qnorm(<span class="number">1</span>-<span class="number">0.05</span>/<span class="number">2</span>)</span><br><span class="line">interval&lt;-<span class="built_in">c</span>(mean(chow)-Q*se, mean(chow)+Q*se )</span><br><span class="line">interval</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>模拟n次置信区间</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(rafalib)</span><br><span class="line">B&lt;-<span class="number">250</span></span><br><span class="line">mypar()</span><br><span class="line">plot(mean(chowPopulation)+<span class="built_in">c</span>(-<span class="number">7</span>,<span class="number">7</span>),<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>),type=<span class="string">&quot;n&quot;</span>,</span><br><span class="line">	xlab=<span class="string">&quot;weight&quot;</span>,ylab=<span class="string">&quot;interval&quot;</span>,ylim=<span class="built_in">c</span>(<span class="number">1</span>,B))</span><br><span class="line">	abline(v=mean(chowPopulation))</span><br><span class="line">	<span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:B) &#123;</span><br><span class="line">	chow&lt;-sample(chowPopulation,N)</span><br><span class="line">	se&lt;-sd(chow)/<span class="built_in">sqrt</span>(N)</span><br><span class="line">	interval&lt;-<span class="built_in">c</span>(mean(chow)-Q*se, mean(chow)+Q*se)</span><br><span class="line">	covered&lt;-</span><br><span class="line">		mean(chowPopulation) &lt;=interval[<span class="number">2</span>]&amp;mean(chowPopulation)&gt;=interval[<span class="number">1</span>]</span><br><span class="line">	color&lt;-ifelse(covered,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">	lines(interval, <span class="built_in">c</span>(i,i),col=color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个代码画出了250次置信区间的图（代码内容没看）。其中大概有5%的置信区间没有包含总体均值。</p>
<p>但是上面是因为抽样个体较多（N = 30），满足了中心极限定理。如果 N = 5，那么这样做也有效吗？我们就模拟这种N =5，使用CLT的情况。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N &lt;- 5</span><br><span class="line">mypar()</span><br><span class="line">plot(mean(chowPopulation)+<span class="built_in">c</span>(-<span class="number">7</span>,<span class="number">7</span>),<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>),type=<span class="string">&quot;n&quot;</span>,</span><br><span class="line">     xlab=<span class="string">&quot;weight&quot;</span>,ylab=<span class="string">&quot;interval&quot;</span>,ylim=<span class="built_in">c</span>(<span class="number">1</span>,B))</span><br><span class="line">abline(v=mean(chowPopulation))</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:B)&#123;</span><br><span class="line">  chow&lt;-sample(chowPopulation,N)</span><br><span class="line">  se&lt;-sd(chow)/<span class="built_in">sqrt</span>(N)</span><br><span class="line">  interval&lt;-<span class="built_in">c</span>(mean(chow)-Q*se, mean(chow)+Q*se)</span><br><span class="line">  covered&lt;- mean(chowPopulation) &lt;=interval[<span class="number">2</span>]&amp;mean(chowPopulation)&gt;=interval[<span class="number">1</span>]</span><br><span class="line">  color &lt;- ifelse(covered,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">  lines(interval, <span class="built_in">c</span>(i,i),col=color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们发现置信区间的宽度增加了，但是没有覆盖真值的情况却多了很多。这是因为这里我们通过CLT错误地认为样本均值符合正态分布，但是实际上相较于正态它两侧的尾巴更大（It has a fatter tail）。这影响到了我们Q值的计算（这里是-2到2）。这种情况下，采用t分布更合适。所以我们只需用qt() 函数来计算Q就可以了，其它不变。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N &lt;- 5</span><br><span class="line">Q&lt;-qt(<span class="number">1</span>-<span class="number">0.05</span>/<span class="number">2</span>, df=<span class="number">4</span>)</span><br><span class="line">mypar()</span><br><span class="line">plot(mean(chowPopulation)+<span class="built_in">c</span>(-<span class="number">7</span>,<span class="number">7</span>),<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>),type=<span class="string">&quot;n&quot;</span>,</span><br><span class="line">     xlab=<span class="string">&quot;weight&quot;</span>,ylab=<span class="string">&quot;interval&quot;</span>,ylim=<span class="built_in">c</span>(<span class="number">1</span>,B))</span><br><span class="line">abline(v=mean(chowPopulation))</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:B)&#123;</span><br><span class="line">  chow&lt;-sample(chowPopulation,N)</span><br><span class="line">  se&lt;-sd(chow)/<span class="built_in">sqrt</span>(N)</span><br><span class="line">  interval&lt;-<span class="built_in">c</span>(mean(chow)-Q*se, mean(chow)+Q*se)</span><br><span class="line">  covered&lt;- mean(chowPopulation) &lt;=interval[<span class="number">2</span>]&amp;mean(chowPopulation)&gt;=interval[<span class="number">1</span>]</span><br><span class="line">  color &lt;- ifelse(covered,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">  lines(interval, <span class="built_in">c</span>(i,i),col=color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们看到置信区间的宽度<strong>进一步</strong>（相较于CLT）增加了（因为t分布尾巴厚，得到的Q值更大），但是基本符合了95%的概率。</p>
<h3 id="置信区间和P值的关系">置信区间和P值的关系</h3>
<p>我们推荐在实际中更多的使用置信区间，而不是P值。</p>
<p>如果你给出P值，我们会问差距是不是真的像你计算或观测出来的值那么大。<strong>因为即便两个群体总体均值为0，得到的样本均值差也有可能出现你计算或观测的结果</strong>。因此，我们可以给出均值差的置信区间，来回答这个问题。</p>
<p>如果均值差的95%的置信区间中不包含0，那么我们可以说差异不显著（0.05水平下），也就是p值肯定小于0.05。（99%的置信区间类似）</p>
<p>t.test的结果中包含了95%的置信区间。</p>
<h3 id="Power-Calculations">Power Calculations</h3>
<p>由于我们有总体信息，我们从总体信息中可以直接得知，这两个群体确实是有差距的，而且按比例大约是10%。<br>
但是我们如果从中取样，然后进行t-test，有的时候P值不总是小于0.05。</p>
<p>所以我们犯错了吗？通过不拒绝原假设，我们要说diet没有影响吗？这个问题的答案是no。All we can say is that we did not reject the null hypothesis. But this does not necessarily imply that the null is true（我们只是说不拒绝原假设，但我们没有说原假设是真的）.</p>
<p>这个问题的本质是这样，在这次的实例中，我们没有得到足够的power（不知道啥意思）。在科学研究中，你很可能需要做某种程度的power calculation。在很多情况下，这是一种道德义务，来避免不必要地牺牲更多小鼠，或者使人们因为你的研究遭遇潜在的风险。</p>
<h4 id="types-of-error">types of error</h4>
<blockquote>
<p>Ⅰ型错误：原假设为真，我们拒绝的概率，等于P值<br>
Ⅱ型错误：原假设为假，没有拒绝原假设的概率</p>
</blockquote>
<p>当我们在进行统计检验时，我们始终需要注意我们很可能会犯错误。这就是为什么我们的p值不是0。在原假设成立的前提下，总是存在一个可能很少，但是可能发生的概率，使得我们拒绝了正确的原假设。如果P值设为0.05，那么这种情况发生的概率也就是0.05。这种错误叫做Ⅰ型错误（typeⅠerror）</p>
<p>Ⅰ型错误会发生<strong>假阳性</strong>。那么我们为什么只设为0.05？不设定一个非常小的值呢？因为还存在另外一种错误，Ⅱ型错误，即原假设为假，没有拒绝原假设的概率，这会造成<strong>假阴性</strong>。像上面我们提到的那种情况，就是犯了二型错误。如果我们把P值提高到0.25，那么上面的例子就能够显著。但是一般情况下我们愿不愿意提高P值到0.25呢？通常我们不会这么做。</p>
<h4 id="0-05或0-01-的-p值-是随意划分的（The-0-05-and-0-01-Cut-offs-Are-Arbitrary）">0.05或0.01 的 p值 是随意划分的（The 0.05 and 0.01 Cut-offs Are Arbitrary）</h4>
<p>很多杂志和监管部门强调要达到0.05或0.01水平的显著。但是这两个数字的设定其实没有特别的，这仅仅是因为最开始的文章用这两个数字作为例子而已。本书的部分目的之一就是让读者对于P值和置信区间有一个更加清晰的认识（受教了）。</p>
<h4 id="Power-Calculation">Power Calculation</h4>
<p>Power is the probability of rejecting the null when the null is false（Power 是指当原假设为假时拒绝原假设的概率）。</p>
<p>下面我们通过R中的实际代码去理解这个概念。</p>
<p>我们仍然假设样本大小为12，显著水平时0.05。由于我们已经两个群体均值有差异，我们可以重复抽样，看每次抽样t检验是否小于0.05</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N&lt;-12</span><br><span class="line">alpha&lt;-0.05</span><br><span class="line">B&lt;-2000</span><br><span class="line"></span><br><span class="line">reject&lt;-function(N, alpha&#x3D;0.05)&#123;</span><br><span class="line">	hf&lt;-sample(hfPopulation,N)</span><br><span class="line">	control&lt;-sample(controlPopulation,N)</span><br><span class="line">	pval&lt;-t.test(hf,control)$p.value</span><br><span class="line">	pval&lt;alpha</span><br><span class="line">&#125;</span><br><span class="line">#reject 给出一次抽样是否小于0.05</span><br><span class="line"></span><br><span class="line">reject(12)</span><br><span class="line">## [1] FALSE</span><br><span class="line"></span><br><span class="line">rejections &lt;- replicate(B,reject(N))</span><br><span class="line">#重复2000次，replicate(n,expr) </span><br><span class="line"></span><br><span class="line">mean(rejetions) # 这就是N&#x3D;12时Power的值</span><br><span class="line">## [1] 0.2215</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这就是为什么当我们知道原假设是错的时，t-test却没有拒绝原假设。当样本大小只有12时，power只有23%。为了降低<strong>假阳性</strong>发生的概率，我们将P值设在0.05水平。其实这个水平有点过高，导致发生<strong>Ⅱ型错误</strong>的概率大大提高。</p>
<blockquote>
<p>power 和 发生Ⅱ型的概率 相加为1。power低，说明发生Ⅱ型错误的概率高。</p>
</blockquote>
<p>接下来，让我们来看看power和抽样大小N的关系。这里我们用到了<strong>sapply(Ns,expr)</strong>，这个函数会对向量中的每一个数执行同样的function。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Ns&lt;-seq(<span class="number">5</span>,<span class="number">50</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># So we use apply() like this</span></span><br><span class="line">power&lt;-sapply(Ns,<span class="keyword">function</span>(N)&#123;</span><br><span class="line">	rejections&lt;-replicate(B, reject(N))</span><br><span class="line">	mean(rejections)</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">plot(Ns,power,type = <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看出，随着N的增加，power不断提高。</p>
<p>我们固定N，看一看alpha的设定对power 的影响</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N&lt;-<span class="number">30</span></span><br><span class="line">alphas&lt;-<span class="built_in">c</span>(<span class="number">0.1</span>,<span class="number">0.05</span>,<span class="number">0.01</span>,<span class="number">0.001</span>,<span class="number">0.0001</span>)</span><br><span class="line">power&lt;-sapply(alphas,<span class="keyword">function</span>(alpha)&#123;</span><br><span class="line">	rejections &lt;- replicate(B,reject(N,alpha=alpha))</span><br><span class="line">	mean(rejections)</span><br><span class="line">&#125;)</span><br><span class="line">plot(alphas, power, xlab=<span class="string">&quot;alpha&quot;</span>, type=<span class="string">&quot;b&quot;</span>, <span class="built_in">log</span>=<span class="string">&quot;x&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看出随着alpha的增加，power也在不断增加。</p>
<blockquote>
<p>There is no “right” power or “right” alpha level, but it is important that you understand what eachmeans.</p>
</blockquote>
<h5 id="p-values-are-Arbitrary-under-the-Alternative-Hypothesis">p-values are Arbitrary under the Alternative Hypothesis</h5>
<blockquote>
<p>Another consequence of what we have learned about power is that p-values are somewhat arbitrarywhen the null hypothesis is not true and therefore thealternativehypothesis is true (the differencebetween the population means is not zero). When the alternative hypothesis is true, we can make a p-value as small as we want simply by increasing the sample size (supposing that we have an infinitepopulation to sample from). We can show this property of p-values by drawing larger and largersamples from our population and calculating p-values. This works because, in our case, we knowthat the alternative hypothesis is true, since we have access to the populations and can calculate thedifference in their means.</p>
</blockquote>
<p>随着样本大小的增加，P值会减小（假设群体无限大）。证明如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">calculatePvalue&lt;-<span class="keyword">function</span>(N) &#123;</span><br><span class="line">	hf&lt;-sample(hfPopulation,N)</span><br><span class="line">	control&lt;-sample(controlPopulation,N)</span><br><span class="line">	t.test(hf,control)$p.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ns&lt;-seq(<span class="number">10</span>,<span class="number">200</span>,by=<span class="number">10</span>)</span><br><span class="line">Ns_rep&lt;-<span class="built_in">rep</span>(Ns, each=<span class="number">10</span>) <span class="comment">#each 的形式是 10 10 10…… 20 ……</span></span><br><span class="line"></span><br><span class="line">pvalues&lt;-sapply(Ns_rep, calculatePvalue)</span><br><span class="line"></span><br><span class="line">plot(Ns_rep, pvalues, <span class="built_in">log</span>=<span class="string">&quot;y&quot;</span>, xlab=<span class="string">&quot;sample size&quot;</span>,</span><br><span class="line">ylab=<span class="string">&quot;p-values&quot;</span>)</span><br><span class="line">abline(h=<span class="built_in">c</span>(<span class="number">.01</span>,<span class="number">.05</span>), col=<span class="string">&quot;red&quot;</span>, lwd=<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>样本量从10增加到200的过程中，p值最低下降到了10^-8^。但是p值太低也不见得是一件很好的事。一旦我们确信了一个reasonable alpha（比如0.05），那么如果我们获得了一个比这个阈值低得多的p值，那就说明<strong>我们用了过量的小鼠</strong>。适当地提高样本量，确实有助于估计的准确性。但是，实际上，随着样本量的增加p值的降低是一件自然的事。</p>
<blockquote>
<p>The p-values get smaller and smaller with increasing sample size because the numerator ofthe t-statistic haspN(for equal sized groups, and a similar effect occurs whenM̸=N). Therefore,if∆is non-zero, the t-statistic will increase with N.</p>
</blockquote>
<p>事实上，随着样本量的增加，t-test得到的p值也会不断降低。这是t统计量中有一个根号N。</p>
<p>算了个Cohen’s d，但没看懂这个统计量到底有啥用？</p>
<blockquote>
<p>This tells us how many standard deviations of the data the mean of the high-fat diet group is from the control group. Under the alternative hypothesis, unlike the t-statistic which is guaranteed to increase, the effect size and Cohen’s d will become more precise.（看不懂）</p>
</blockquote>
<h3 id="Monte-Carlo-Simulation">Monte Carlo Simulation</h3>
<p>电脑可以用来产生伪随机数（pseudo-random numbers），一个最大的好处是我们可以通过模拟数据来证明我们的假设或理论。</p>
<blockquote>
<p>伪随机性（英语：Pseudorandomness）是一个过程似乎是随机的，但实际上并不是。例如伪随机数是使用一个确定性的算法计算出来的似乎是随机的数序，因此伪随机数实际上并不随机。在计算伪随机数时假如使用的开始值不变的话，那么伪随机数的数序也不变。</p>
</blockquote>
<p>Simulations can also be used to check theoretical or analytical results. Also, many of the theoretical results we use in statistics are based on <strong>asymptotics</strong>: they hold when the sample size goes to <a href="http://infinity.In">infinity.In</a> practice, we never have an infinite number of samples so we may want to know how well thetheory works with our actual sample size.</p>
<p>作为例子，我们蒙特卡洛模拟（ Monte Carlo simulation）来比较不同样本大小的情况下CLT和t分布的近似值。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(dplyr)</span><br><span class="line">dat&lt;-read.csv(<span class="string">&quot;mice_pheno.csv&quot;</span>)<span class="comment">#Previously downloaded</span></span><br><span class="line">controlPopulation&lt;-filter(dat,Sex==<span class="string">&quot;F&quot;</span>&amp;Diet==<span class="string">&quot;chow&quot;</span>)%&gt;%select(Bodyweight)%&gt;%unlist</span><br><span class="line"></span><br><span class="line">ttestgenerator&lt;-<span class="keyword">function</span>(n) &#123;</span><br><span class="line">  <span class="comment">#note that here we have a false &quot;high fat&quot; group where we actually</span></span><br><span class="line">  <span class="comment">#sample from the nonsmokers. this is because we are modeling the *null*</span></span><br><span class="line">  cases&lt;-sample(controlPopulation,n)</span><br><span class="line">  controls&lt;-sample(controlPopulation,n)</span><br><span class="line">  tstat&lt;-(mean(cases)-mean(controls))/<span class="built_in">sqrt</span>( var(cases)/n+var(controls)/n ) <span class="comment">#这个t统计量是假设两个群体方差不等</span></span><br><span class="line">  <span class="built_in">return</span>(tstat)</span><br><span class="line">  &#125;</span><br><span class="line">ttests&lt;-replicate(<span class="number">1000</span>, ttestgenerator(<span class="number">10</span>))</span><br><span class="line">hist(ttests)</span><br></pre></td></tr></table></figure>
<p>从直方图中，我们近似看出符合正态分布。但是从上文提到，我们再看一下QQ图</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qqnorm(ttests)</span><br><span class="line">qqline(ttests)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从QQ图中，可以看出近似符合正态分布。这说明在样本数是10的情况下，已经符合正态分布，可以使用中心极限定理了。那么如果样本数为3呢？</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ttests&lt;-replicate(<span class="number">1000</span>, ttestgenerator(<span class="number">3</span>))</span><br><span class="line">qqnorm(ttests)</span><br><span class="line">qqline(ttests)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Now we see that the large quantiles, referred to by statisticians as the tails, are larger than expected(below the line on the left side of the plot and above the line on the right side of the plot).</p>
</blockquote>
<p>我们可以看出QQ图中左侧低于直线，右侧高于直线。这说明两侧的尾巴比正态分布要肥。</p>
<p>在之前的章节中，我们提到，如果<strong>样本数不大</strong> 并且 <strong>总体符合正态分布</strong> ，那么使用t分布是一种更好的近似。证明如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ps&lt;-(seq(<span class="number">0</span>,<span class="number">999</span>)+<span class="number">0.5</span>)/<span class="number">1000</span> <span class="comment">#0到1的均匀分布</span></span><br><span class="line">qqplot(qt(ps,df=<span class="number">2</span>*<span class="number">3</span>-<span class="number">2</span>),ttests,xlim=<span class="built_in">c</span>(-<span class="number">6</span>,<span class="number">6</span>),ylim=<span class="built_in">c</span>(-<span class="number">6</span>,<span class="number">6</span>))</span><br><span class="line"><span class="comment"># qt获得某t分布累积概率的数值</span></span><br><span class="line"><span class="comment"># qqplot比较两个变量分布是否相同</span></span><br><span class="line">abline(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从中我们可以看出，t分布在这种情况下更为近似，但是仍不完美。这是因为<strong>总体并不是很好地符合正态分布</strong>。(从下面总体的QQ图中看出，总体略偏)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qqnorm(controlPopulation)</span><br><span class="line">qqline(controlPopulation)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Parametric-Simulations-for-the-Observations">Parametric Simulations for the Observations</h3>
<p>我们再这里使用蒙特卡洛模拟随机变量和假设检验，这是因为我们有总体数据。这是为了教学的作用，但在实际运用中是不可能的。一般采用蒙特卡洛模拟，主要用于参数估计（如均值和标准差）。</p>
<p>以小鼠体重的例子来说，我们通过先验知识，认识到小鼠的体重均值为24盎司，标准差为3.5盎司，而且小鼠体重近似符合正态分布。通过以上信息，我们可以构建一个总体数据。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">controls&lt;-rnorm(<span class="number">5000</span>, mean=<span class="number">24</span>, sd=<span class="number">3.5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于我们可以重复上述操作。因此我们不需要用到sample()函数了。代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ttestgenerator&lt;-function(n, mean&#x3D;24, sd&#x3D;3.5) &#123;</span><br><span class="line">  cases&lt;-rnorm(n,mean,sd)</span><br><span class="line">  controls&lt;-rnorm(n,mean,sd)</span><br><span class="line">  tstat&lt;-(mean(cases)-mean(controls))&#x2F;sqrt( var(cases)&#x2F;n+var(controls)&#x2F;n )</span><br><span class="line">  return(tstat)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Permutation-Tests">Permutation Tests</h3>
<p>假设我们遇到这样一种情况，没有一种标准的统计量能近似模拟我们的数据。</p>
<p>We have computed a summary statistic, such as the difference in mean, but do not have auseful approximation, such as that provided by the CLT.</p>
<p>这个时候 Permutation Tests 就派上用场了。</p>
<p>让我们回到最开始拿到的样本</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dat=read.csv(<span class="string">&quot;femaleMiceWeights.csv&quot;</span>)</span><br><span class="line">library(dplyr)</span><br><span class="line">control&lt;-filter(dat,Diet==<span class="string">&quot;chow&quot;</span>)%&gt;%select(Bodyweight)%&gt;%unlist</span><br><span class="line">treatment&lt;-filter(dat,Diet==<span class="string">&quot;hf&quot;</span>)%&gt;%select(Bodyweight)%&gt;%unlist</span><br><span class="line">obsdiff&lt;-mean(treatment)-mean(control)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>In previous sections, we showed parametric approaches that helped determine if the observeddifference was significant. Permutation tests take advantage of the fact that if we randomly shufflethe cases and control labels, then the null is true. So we shuffle the cases and control labels andassume that the ensuing distribution approximates the null distribution. Here is how we generate anull distribution by shuffling the data 1,000 times:</p>
</blockquote>
<p>这段话的大意是，之前我们是用带参数的方法（均值，标准差）检验差异是否显著。而这个Permutation tests 认为，如果我们随机洗牌 cases 和 control 的标签，那么零假设应该是正确的。<br>
下面我们洗牌了1000次。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">N&lt;-<span class="number">12</span></span><br><span class="line">avgdiff&lt;-replicate(<span class="number">1000</span>, &#123;</span><br><span class="line">  <span class="built_in">all</span>&lt;-sample(<span class="built_in">c</span>(control,treatment))</span><br><span class="line">  newcontrols&lt;-<span class="built_in">all</span>[<span class="number">1</span>:N]</span><br><span class="line">  newtreatments&lt;-<span class="built_in">all</span>[(N+<span class="number">1</span>):(<span class="number">2</span>*N)]</span><br><span class="line">  <span class="built_in">return</span>(mean(newtreatments)-mean(newcontrols))</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">#这个&#123;&#125;好像是不带名称的函数，类似于Python中的lambda</span></span><br><span class="line"><span class="comment">#sample(x)不加n,就是重排（permutation）的意思</span></span><br><span class="line">hist(avgdiff)</span><br><span class="line">abline(v=obsdiff, col=<span class="string">&quot;red&quot;</span>, lwd=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>How many of the null means are bigger than the observed value? That proportion would be thep-value for the null. We add a 1 to the numerator and denominator to account for misestimation ofthe p-value</p>
</blockquote>
<p>在这1000次中，有多少比例大于这个obsdiff，这就是P值。但是，分子分母要都加上一个1。（个人理解实际上是做了1001次，没有算上真实情况）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">sum</span>(<span class="built_in">abs</span>(avgdiff)&gt;<span class="built_in">abs</span>(obsdiff))+<span class="number">1</span>)/(<span class="built_in">length</span>(avgdiff)+<span class="number">1</span>)</span><br><span class="line"><span class="comment">## [1] 0.05594406</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在我们把这个用在样本量更小的数据集，比如样本量为5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N&lt;-5</span><br><span class="line">control&lt;-sample(control,N)</span><br><span class="line">treatment&lt;-sample(treatment,N)</span><br><span class="line">obsdiff&lt;-mean(treatment)-mean(control)</span><br><span class="line"></span><br><span class="line">avgdiff&lt;-replicate(1000, &#123;</span><br><span class="line">  all&lt;-sample(c(control,treatment))</span><br><span class="line">  newcontrols&lt;-all[1:N]</span><br><span class="line">  newtreatments&lt;-all[(N+1):(2*N)]</span><br><span class="line">  return(mean(newtreatments)-mean(newcontrols))</span><br><span class="line">&#125;)</span><br><span class="line">hist(avgdiff)</span><br><span class="line">abline(v&#x3D;obsdiff, col&#x3D;&quot;red&quot;, lwd&#x3D;2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在可以明显看出差距不显著了。</p>
<blockquote>
<p>Now the observed difference is not significant using this approach. Keep in mind that there is notheoretical guarantee that the null distribution estimated from permutations approximates the actualnull distribution. For example, if there is a real difference between the populations, some of the permutations will be unbalanced and will contain some samples that explain this difference. This implies that the null distribution created with permutations will have larger tails than the actualnull distribution. This is why permutations result in conservative p-values. For this reason, whenwe have few samples, we can’t do permutations.</p>
</blockquote>
<p>没看懂，结论是数据量小时，不用这种permutation test</p>
<p>而且permutation test 也有假设：<strong>:samples are assumed to be independentand “exchangeable”</strong> 。 If there is hidden structure in your data, then permutation tests can result in estimated null distributions that underestimate the size of tails because the permutations may destroy the existing structure in the original data.</p>
<h3 id="Association-Tests">Association Tests</h3>
<p>前面的统计分析中，忽略了一类重要的数据，二元或者说分类数据。举个例子，当你有两种疾病的基因型的群体(AA/Aa 与 aa)作为cases 和 control。我们要提出的问题是，这个基因型与疾病是否有关系。<br>
这里疾病状况表示为0和1，那么我们为什么不能用t-test？因为数据要么是0要么是1，很明显不会符合正态分布，因此不能使用t-test。</p>
<p>如果样本数量很大的话，我们可以使用CLT。不然的话，我们就可以使用Association Tests。</p>
<h4 id="二项分布与超几何分布">二项分布与超几何分布</h4>
<p>解释: 我的这种算法是基于二项分布，而Fisher’s exact test是基于超几何分布（hypergeometric distribution）。<br>
二项分布</p>
<ol>
<li>试验次数固定</li>
<li>每一次事件都有两个可能的结果</li>
<li><strong>每次试验中的事件相互独立</strong></li>
<li><strong>每一次成功的概率相等</strong></li>
</ol>
<p>超几何分布 它描述了由<strong>有限个物件中</strong>抽出n个物件，成功抽出指定种类的物件的个数（不归还 （without replacement））。</p>
<p>例如在有N个样本，其中K个是不及格的。超几何分布描述了在该N个样本中抽出n个，其中k个是不及格的概率。</p>
<p>特点：</p>
<ol>
<li>每次抽取也只有两个互斥的结果</li>
<li><strong>每次抽取后成功的概率发生改变</strong>（因为是不放回抽样，这也导致了每次抽取事件不独立）</li>
</ol>
<h4 id="Lady-Tasting-Tea">Lady Tasting Tea</h4>
<p>R.A.Fisher 的一位熟人宣称她能分辨牛奶是早于或晚于茶放入杯中（就是牛奶和茶混合的顺序）。Fisher 就和她做了一个小实验，4次中对了3次。那么，我们能否说明这位女士存在这种特殊的能力呢？这个例子被称为&quot;Lady tasting tea&quot;。<br>
按照之前的经验。一个基本的问题是，如果这位女士仅仅靠猜，她能得到3/4或更高的正确率(即3/4+4/4)的概率是多少？<br>
仍和之前一样，我们需要计算在零假设成立的前提下事情发生的概率。这里的零假设就是这位女士都是猜的。</p>
<blockquote>
<p>he basic question we ask is: if the tester is actually guessing, what are the chances that she gets 3 ormore correct? Just as we have done before, we can compute a probability under the null hypothesisthat she is guessing four of each. If we assume this null hypothesis, we can think of this particularexamples as picking 4 balls out of an urn with 4 green (correct answer) and 4 red (incorrect answer)balls.</p>
</blockquote>
<blockquote>
<p>Under the null hypothesis that she is simply guessing, each ball has the same chance of beingpicked. We can then use combinatorics to figure out each probability. The probability of picking3 is(43)(41)/(84)= 16/70. The probability of picking all 4 correct is(44)(40)/(84)= 1/70. Thus, thechance of observing a 3 or something more extreme, under the null hypothesis, is 0.24. This isthe p-value. The procedure that produced this p-value is calledFisher’s exact testand it uses the hypergeometric distribution.</p>
</blockquote>
<p>它这种算法是8个球里摸4个。我的算法是每次猜对的概率是0.5，那么4次猜对3次的概率是4*0.5^3^*0.5=0.25。这两种结果不一样，我也搞不太清楚。</p>
<p>这里算错了，除了不清晰二项分布与超几何分布，还有一个原因，不清楚这个Lady tasting tea试验。在这个试验中，Fisher准备了8杯茶，每一种（tea first or milk first）都准备了4杯，并且随机拜放位置。试验者需挑出按其中一种方法泡制的4杯。</p>
<p>按Fisher’s exact test 只有当这位女士把4杯都挑出来（p=1/70），他才会承认她有这种能力（但是不能量化）。哪怕如题所示，她挑出来了3杯（p=16/70+1/70=17/70），P值也是不显著。</p>
<blockquote>
<p>当样本量更大时，也可以使用卡方分布。但是，当样本数目很少或数据分布极不平衡（如果某个cell的数目小于5 或小于10）时，卡方分布的估计是不充分的。而与之相反，Fisher 精确检验，正如它的名称，不论样本如何都能保持精确。但是当样本量很大或非常平衡，Fisher 精确检验计算不方便，这时就需要用到卡方分布。</p>
</blockquote>
<p>公式如下：<br>
<img src="Fisher's_exact_test.png" alt="Fisher's_exact_test"></p>
<p>小结：<br>
Fisher 精确检验使用于<strong>检验两个分类变量是否相关</strong>。</p>
<ul>
<li>Fisher 精确检验：适合样本小或不平衡数据</li>
<li>卡方检验：适合样本大、平衡数据</li>
</ul>
<h4 id="Two-By-Two-Tables">Two By Two Tables</h4>
<p>The data from the experiment above can be summarized by a 2 by 2 table:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tab&lt;-matrix(c(3,1,1,3),2,2)</span><br><span class="line">rownames(tab)&lt;-c(&quot;Poured Before&quot;,&quot;Poured After&quot;)</span><br><span class="line">colnames(tab)&lt;-c(&quot;Guessed before&quot;,&quot;Guessed after&quot;)</span><br><span class="line">tab</span><br><span class="line">#The function fisher.test performs the calculations above and can be obtained like this:</span><br><span class="line">fisher.test(tab,alternative&#x3D;&quot;greater&quot;)</span><br><span class="line">##</span><br><span class="line">##Fisher&#39;s Exact Test for Count Data</span><br><span class="line">##</span><br><span class="line">## data:  tab</span><br><span class="line">## p-value &#x3D; 0.2429</span><br><span class="line">## alternative hypothesis: true odds ratio is greater than 1</span><br><span class="line">## 95 percent confidence interval:</span><br><span class="line">##  0.3135693Inf</span><br><span class="line">## sample estimates:</span><br><span class="line">## odds ratio</span><br><span class="line">##   6.408309</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Fisher-精确检验的争议">Fisher 精确检验的争议</h4>
<p>很多人争论Fisher 精确检验结果保守。它的真实的拒绝概率低于名义上的显著水平。The apparent contradiction stems from the combination of a discrete statistic with fixed significance levels.（最明显的矛盾在于它计算出的统计量是分散的，但是显著水平是固定的，如0.05）（如上例，可能出现的P值只有5个（0，1，2，3，4杯））。To avoid the problem, many authors discourage the use of fixed significance levels when dealing with discrete problems.</p>
<h4 id="Chi-square-Test">Chi-square Test</h4>
<p>假设我们有250个个体，其中一部分患有疾病。我们观测到aa基因型的个体中有20%患病；其他基因型的个体中患病比例为10%。如果我们再挑250个个体这种现象会再次发生吗？（这个提问方式等同于问这个位点是否与疾病相关）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">disease=factor(<span class="built_in">c</span>(<span class="built_in">rep</span>(<span class="number">0</span>,<span class="number">180</span>),<span class="built_in">rep</span>(<span class="number">1</span>,<span class="number">20</span>),<span class="built_in">rep</span>(<span class="number">0</span>,<span class="number">40</span>),<span class="built_in">rep</span>(<span class="number">1</span>,<span class="number">10</span>)),labels=<span class="built_in">c</span>(<span class="string">&quot;control&quot;</span>,<span class="string">&quot;cases&quot;</span>))</span><br><span class="line">genotype=factor(<span class="built_in">c</span>(<span class="built_in">rep</span>(<span class="string">&quot;AA/Aa&quot;</span>,<span class="number">200</span>),<span class="built_in">rep</span>(<span class="string">&quot;aa&quot;</span>,<span class="number">50</span>)),levels=<span class="built_in">c</span>(<span class="string">&quot;AA/Aa&quot;</span>,<span class="string">&quot;aa&quot;</span>))</span><br><span class="line">dat&lt;-data.frame(disease, genotype)</span><br><span class="line">dat&lt;-dat[sample(nrow(dat)),]<span class="comment">#shuffle them up</span></span><br><span class="line">head(dat)</span><br><span class="line"></span><br><span class="line"><span class="comment">###统计频数</span></span><br><span class="line">table(genotype)</span><br><span class="line">table(disease)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 双因素统计频数，建立一个2*2表</span></span><br><span class="line">tab &lt;- table(genotype,disease)</span><br><span class="line">tab</span><br><span class="line"><span class="comment">##disease</span></span><br><span class="line"><span class="comment">## genotype control cases</span></span><br><span class="line"><span class="comment">##    AA/Aa     180    20</span></span><br><span class="line"><span class="comment">##    aa		 40    10</span></span><br></pre></td></tr></table></figure>
<p>这里最典型的统计量就是the odds ratio(OR)。). We compute the oddsof having the disease if you are an “aa”: 10/40, the odds of having the disease if you are an “AA/Aa”:20/180, and take the ratio:(10/40)/(20/180)</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">(tab[<span class="number">2</span>,<span class="number">2</span>]/tab[<span class="number">2</span>,<span class="number">1</span>])/(tab[<span class="number">1</span>,<span class="number">2</span>]/tab[<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line"><span class="comment">## [1] 2.25</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了计算P值，我们不直接使用OR。我们假设基因型和疾病没有关系，然后计算出每个cell的期望值。在零假设下，两种基因型的200个体和50个体，患病的概率是相同的。</p>
<p>首先，我们得到群体（200+50=250）的患病概率为</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">p=mean(disease==<span class="string">&quot;cases&quot;</span>)</span><br><span class="line">p</span><br><span class="line"><span class="comment">## [1] 0.12</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因此，各cell 的期望值为</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">expected&lt;-rbind(<span class="built_in">c</span>(<span class="number">1</span>-p,p)*<span class="built_in">sum</span>(genotype==<span class="string">&quot;AA/Aa&quot;</span>),<span class="built_in">c</span>(<span class="number">1</span>-p,p)*<span class="built_in">sum</span>(genotype==<span class="string">&quot;aa&quot;</span>))</span><br><span class="line"><span class="built_in">dimnames</span>(expected)&lt;-<span class="built_in">dimnames</span>(tab)</span><br><span class="line">expected</span><br><span class="line"><span class="comment">##disease</span></span><br><span class="line"><span class="comment">## genotype control cases</span></span><br><span class="line"><span class="comment">##    AA/Aa     176    24</span></span><br><span class="line"><span class="comment">##    aa		 44     6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##这里没讲清楚，直接就算出来了</span></span><br><span class="line">chisq.test(tab)$p.value</span><br><span class="line"><span class="comment">## [1] 0.08857435</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Large-Samples-Small-p-values">Large Samples, Small p-values</h4>
<p>如上所述，仅报道P值是不正确的。很多做GWAS的人过于强调P值。他们样本很大，得到的P值很小。但是如果仔细看他们的结果，我们就能看到他们的odds ratios并不高：仅仅比1高一点。在这种情况下，基因型是AA/Aa 或 aa 可能不会改变动物患病的几率，但是这些位点确实是统计意义上显著的。<br>
<strong>odds ratio 和 p-value 并没有一对一的关系</strong>（这一点很重要，这个在effect size 中也专门提到了，效应大小与是否显著没有因果关系。P值只能判断这个效应是不是出于偶然（随机误差），并不能说明效应大小）</p>
<h4 id="Confidence-Intervals-For-The-Odd-Ratio">Confidence Intervals For The Odd Ratio</h4>
<p>计算OR 的置信区间不能直接做到。不像其他统计量，它们都能推导出近似的分布。但是OR仅仅是一个比例。因此，没有简单的方法可以使用，例如CLT。</p>
<p>One approach is to use the theory ofgeneralized linear models which provides estimates of thelog odds ratio, rather than the OR itself, that can be shown to be asymptotically normal.</p>
<p>后面的没看</p>
<h2 id="Exploratory-Data-Analysis">Exploratory Data Analysis</h2>
<p>这个探索性数据分析，没太搞懂</p>
<h3 id="Quantile-Quantile-Plots">Quantile Quantile Plots</h3>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(UsingR)<span class="comment">##available from CRAN</span></span><br><span class="line">library(rafalib)</span><br><span class="line">x&lt;-father.son$fheight</span><br><span class="line"></span><br><span class="line">ps&lt;-( seq(<span class="number">0</span>,<span class="number">99</span>)+<span class="number">0.5</span>)/<span class="number">100</span> <span class="comment">#0.005 0.015 ……</span></span><br><span class="line">qs&lt;-quantile(x, ps) <span class="comment">#获得x中的各分位数</span></span><br><span class="line">normalqs&lt;-qnorm(ps, mean(x), popsd(x)) <span class="comment">#形成以x均值，总体标准差的正态分布的分位数</span></span><br><span class="line">plot(normalqs,qs,xlab=<span class="string">&quot;Normal percentiles&quot;</span>,ylab=<span class="string">&quot;Height percentiles&quot;</span>) </span><br><span class="line"><span class="comment"># 两个分位数向量的散点图即为QQ图</span></span><br><span class="line">abline(<span class="number">0</span>,<span class="number">1</span>)<span class="comment">##identity line</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>简化命令,比上面的手动画图采了更多的点，因此更加准确。<br>
其中由于x轴为标准正态分布，因此添加的qqline的截距为mean(x) , 斜率为popsd(x)</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">qqnorm(x)</span><br><span class="line">qqline(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当然，我们也可以看看非正态分布的QQ图，比如t分布，样本数越少，尾巴越肥。体现在QQ图上就是左侧的极端值低于identity line，右侧的极端值高于identity line。</p>
<h3 id="Boxplots">Boxplots</h3>
<p>数据也不是都服从正态分布。比如工资，只告诉均值和标准差根本不足以表现真实情况（not neccessarily informative），因为我们没办法通过这两个参数获取工资的分布情况。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">op &lt;- par(mfrow=<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">hist(exec.pay)<span class="comment">##in UsingR package</span></span><br><span class="line">qqnorm(exec.pay)</span><br><span class="line">qqline(exec.pay)</span><br><span class="line"></span><br><span class="line"><span class="comment">#boxplot</span></span><br><span class="line">boxplot(exec.pay, ylab=<span class="string">&quot;10,000s of dollars&quot;</span>, ylim=<span class="built_in">c</span>(<span class="number">0</span>,<span class="number">400</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Scatterplots-And-Correlation">Scatterplots And Correlation</h3>
<p>上面都是单一变量。我们也经常用到双变量或者更多的变量，比如父亲和儿子的身高。可以先画一个散点图。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(UsingR)</span><br><span class="line">data(<span class="string">&quot;father.son&quot;</span>)</span><br><span class="line">x=father.son$fheight</span><br><span class="line">y=father.son$sheight</span><br><span class="line">plot(x,y,xlab=<span class="string">&quot;Father&#x27;s height in inches&quot;</span>,ylab=<span class="string">&quot;Son&#x27;s height in inches&quot;</span>,main=paste(<span class="string">&quot;correlation =&quot;</span>,<span class="built_in">signif</span>(cor(x,y),<span class="number">2</span>)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从图中看出一个明显的趋势：父亲的身高越高，儿子的身高也越高。一个定量的统计量就是相关系数。</p>
<h4 id="Stratification">Stratification</h4>
<p>如果我们要预测身高为72 inches 的父亲的儿子的身高，我们可以看所有身高为72 inches 的父亲的儿子的情况。因此需要对数据按父亲身高进行分层。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">groups&lt;-split(y,<span class="built_in">round</span>(x))</span><br><span class="line">boxplot(groups)</span><br><span class="line">print(mean(y[ <span class="built_in">round</span>(x)==<span class="number">72</span>]))</span><br><span class="line"><span class="comment">## [1] 70.67719</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Bi-variate-Normal-Distribution">Bi-variate Normal Distribution</h3>
<p>对于两个均服从正态分布的变量的联合分布，我们一般可以设定当X = x时，Y的条件分布。以身高数据为例，我们给出了以下4个层次。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">groups&lt;-split(y,<span class="built_in">round</span>(x))</span><br><span class="line">op &lt;- par(mfrow=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="built_in">c</span>(<span class="number">5</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">14</span>))&#123;</span><br><span class="line">  qqnorm(groups[[i]],main=paste0(<span class="string">&quot;X=&quot;</span>,<span class="built_in">names</span>(groups)[i],<span class="string">&quot;strata&quot;</span>),</span><br><span class="line">         ylim=<span class="built_in">range</span>(y),xlim=<span class="built_in">c</span>(-<span class="number">2.5</span>,<span class="number">2.5</span>))</span><br><span class="line"><span class="comment"># groups 是一个list，用groups[[i]] 获得的是向量</span></span><br><span class="line"><span class="comment"># range() 返回一个包含最小值和最大值的向量</span></span><br><span class="line"><span class="comment"># range(1:10) ## [1]  1 10</span></span><br><span class="line"></span><br><span class="line">  qqline(groups[[i]])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>后面的公式推导没太明白。后面对x,y进行了标准化，然后按x分组求y均值，发现y均值 与 x 呈线性关系，截距为0，斜率为标准化的y与x的相关系数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x=( x-mean(x) )/sd(x)</span><br><span class="line">y=( y-mean(y) )/sd(y)</span><br><span class="line">means=tapply(y, <span class="built_in">round</span>(x*<span class="number">4</span>)/<span class="number">4</span>, mean) <span class="comment">#按round(x*4)/4 给y 分组求均值</span></span><br><span class="line">fatherheights=<span class="built_in">as.numeric</span>(<span class="built_in">names</span>(means))</span><br><span class="line">mypar(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">plot(fatherheights, means, ylab=<span class="string">&quot;average of strata of son heights&quot;</span>, ylim=<span class="built_in">range</span>(fatherheights))</span><br><span class="line">abline(<span class="number">0</span>, cor(x,y))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Plots-To-Avoid">Plots To Avoid</h3>
<p>画图的目的是准确而清楚地展示数据。根据 Karl 的说法，不好的画图的标准如下：</p>
<ol>
<li>Display as little information as possible.</li>
<li>Obscure what you do show (with chart junk).</li>
<li>Use pseudo-3D and color gratuitously（免费地）.</li>
<li>Make a pie chart (preferably in color and 3D).</li>
<li>Use a poorly chosen scale.</li>
<li>Ignore significant figures.</li>
</ol>
<h3 id="Pie-charts">Pie charts</h3>
<blockquote>
<p>“Pie charts are a very bad way of displaying information. The eye is good at judginglinear measures and bad at judging relative areas. A bar chart or dot chart is a preferableway of displaying this type of data.”</p>
</blockquote>
<p>饼图是一种很差劲的展示数据的方式。人眼很容易辨别线性方式，但是劣于判断相对区域。一个条形图或散点图 都是更合适的方式。</p>
<p>举例来说，你可以看着饼图，去估计某一部分对应的百分比。你会发现这很困难，除非这个比例很接近25%，50% 或 75%。</p>
<p>这里我们可以用条形图用代替，这里我们每隔10添加了一条水平线</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">pie(browsers,main=<span class="string">&quot;Browser Usage (August 2013)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#条形图</span></span><br><span class="line">barplot(browsers, main=<span class="string">&quot;Browser Usage (August 2013)&quot;</span>, ylim=<span class="built_in">c</span>(<span class="number">0</span>,<span class="number">55</span>))</span><br><span class="line">abline(h=<span class="number">1</span>:<span class="number">5</span>*<span class="number">10</span>)</span><br><span class="line">barplot(browsers, add=<span class="literal">TRUE</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过条形图和y轴的水平线，我们可以很清楚的看到每个值的比例。</p>
<p>尽量不要使用3D图像，因为3D图像添加了看图的障碍，使得更难通过肉眼辨别各项比例。</p>
<h4 id="Barplots-as-data-summaries">Barplots as data summaries</h4>
<p>当条形图用于展示百分比时，很有用。但是，条形图也会被错误地用于<strong>只有两组</strong>的比较。特别当条形图的高度表示均值，上面的小触角表示标准误（standard errors）。</p>
<blockquote>
<p>Much more informative is to summarize with a boxplot. If the number of points is small enough,we might as well add them to the plot. When the number of points is too large for us to see them,just showing a boxplot is preferable. We can even setrange=0inboxplotto avoid drawing manyoutliers when the data is in the range of millions.</p>
</blockquote>
<p>这个时候更适合用箱线图来表示。箱线图展示了更多的信息，中心、分布、离群点。而条形图只展示了均值和标准误，而标准误很大程度上和样本大小有关，和分布无关。</p>
<blockquote>
<p>Notice how much more we see here: the center, spread, range and the points themselves. In thebarplot, we only see the mean and the SE, and the SE has more to do with sample size, than withthe spread of the data.</p>
</blockquote>
<p>问题还不止如此。当数据中的离群点很大（分组数据的尾巴很大）。如下条形图，看似两组区别很大。</p>
<p><img src="barplot1.png" alt="barplot1"></p>
<p>但仔细看数据，这种区别原来主要是因为有两个很大的离群点。将数据进行log以后，更加明朗。</p>
<p>如下箱线图所示，左边为原数据，可以看出二者可能区别不大，有两个非常大的离群点。log后基本展示了基本情况。（个人感觉，那两个离群点实在太大，也可以直接剔除）</p>
<p><img src="boxplot1.png" alt="barplot1"></p>
<h4 id="Show-the-scatter-plot">Show the scatter plot</h4>
<p>很多统计分析都是证明两个变量之间存在关系。相关系数和相应的图可以展示这一点。然而，只展现回归线是不够的，因为这掩饰了散点。</p>
<h4 id="High-correlation-does-not-imply-replication">High correlation does not imply replication</h4>
<p>相关系数很高，不代表重复性很好，这一部分没看懂。之后补上</p>
<h4 id="Barplots-for-paired-data">Barplots for paired data</h4>
<p>当样本数较少且为配对实验时，通常我们会用两种颜色的条形图表示比如实验前和实验后。</p>
<p><img src="pairdata1.png" alt="barplot1"></p>
<p>但是我们有更好的办法。比如散点图，我们可以看到点都是高于identity line（这里应该是y=x）。另一种方法是直接画差值的散点图。</p>
<p><img src="pairdata2.png" alt="barplot1"></p>
<p><img src="pairdata3.png" alt="barplot1"></p>
<h4 id="Gratuitous-3D-（没有必要的3D）">Gratuitous 3D （没有必要的3D）</h4>
<p>以下是一个3D图，你会发现并不清楚。很难去确定其中某一个点对应的数值。</p>
<p>其实这只要不同的颜色来区分三条线就可以了。</p>
<p><img src="3D.png" alt="barplot1"></p>
<p><img src="3D2.png" alt="barplot1"></p>
<h4 id="Too-many-significant-digits">Too many significant digits</h4>
<p>默认情况下，我们会得到很多重要的数字，但我们不是都要放上去。从R中直接复制粘贴是很愚蠢的，这导致你最后显示的不是一张图，而更像是一张表。</p>
<h4 id="Displaying-data-well">Displaying data well</h4>
<p>展示数据的一般准则：</p>
<ul>
<li>Be accurate and clear.</li>
<li>Let the data speak.</li>
<li>Show as much information as possible, taking care not to obscure the message.</li>
<li>Science not sales: avoid unnecessary frills (esp. gratuitous 3D).<br>
(科学不是销售，避免不必要的虚架子，比如3D)</li>
<li>In tables, every digit should be meaningful. Don’t drop ending 0’s.<br>
（表格中，每一个小数位点都有意义）</li>
</ul>
<h3 id="Misunderstanding-Correlation-Advanced">Misunderstanding Correlation (Advanced)</h3>
<p>现在相关系数主要用于体现reproducibility。但是实际上，相关系数不足以体现reproducibility。</p>
<p>最坏的错误是，计算相关系数的数据不是近似服从<strong>二元正态分布</strong>。上面提到，均值，标准差，相关系数都是基于二元正态分布。但是，有很多数据不符合，如基因表达量数据，通常有很肥的右侧尾巴。</p>
<p>计算reproducibility 最直接的方式就是计算两个变量的距离。</p>
<p>The standard way to quantify reproducibility between two sets of replicated measurements, sayx1; : : : ; xnandy1; : : : ; yn, is simply to compute the distance between them。</p>
<p><img src="reproducibility1.png" alt="barplot1"></p>
<p>后面没看，也看不懂。</p>
<p>我连这里的reproducibility是什么意思都不知道。</p>
<h3 id="Robust-Summaries">Robust Summaries</h3>
<p>在分析数据的过程中，我们通常假设数据符合正态分布。但是我们收集数据的过程中，总是不可避免地加入了一些错误的数据点（离群点）。类似这种偏离很大的离群点，会导致分析结果出现很大的偏差。</p>
<p>如下例，我们在0到1之间的数据中，插入一个值为100的离群点。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">set.seed(<span class="number">1</span>)</span><br><span class="line">x=<span class="built_in">c</span>(rnorm(<span class="number">100</span>,<span class="number">0</span>,<span class="number">1</span>))<span class="comment">##real distribution</span></span><br><span class="line">x[<span class="number">23</span>]&lt;-<span class="number">100</span><span class="comment">##mistake made in 23th measurement</span></span><br><span class="line">boxplot(x)</span><br></pre></td></tr></table></figure>
<p>我们看一下均值和标准差，发现偏离很大</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">cat(<span class="string">&quot;The average is&quot;</span>,mean(x),<span class="string">&quot;and the SD is&quot;</span>,sd(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">## The average is 1.108142 and the SD is 10.02938</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="The-median">The median</h4>
<p>这个中位数，对于离群点，是robust的。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">median(x)</span><br><span class="line">[<span class="number">1</span>] <span class="number">0.1684483</span></span><br></pre></td></tr></table></figure>
<h4 id="The-median-absolute-deviation">The median absolute deviation</h4>
<p>![](The median absolute deviation.png)</p>
<h4 id="Spearman-correlation">Spearman correlation</h4>
<p>和前面类似，也是robust 的相关系数。几乎不受离群点的影响。</p>
<h4 id="Symmetry-of-log-ratios">Symmetry of log ratios</h4>
<p>当涉及比值数据时，数据不是对称的，1/32 比 32/1 更接近1。这时候采用log()函数处理一下，就会对称（log(x/y) = log(x) - log(y) ）</p>
<h3 id="Wilcoxon-Rank-Sum-Test">Wilcoxon Rank Sum Test</h3>
<p>从上面知道，样本均值和标准差易受离群点的影响。t检验需要用到这两个数，因此也容易受到影响。这种Wilcoxon Rank Sum Test 就不会受到影响……</p>
<p>后面没看</p>
<h2 id="Effect-size-–-wikipedia">Effect size – wikipedia</h2>
<p>In statistics, an effect size is a quantitative measure of the magnitude of a phenomenon.(这个effect size 不知道咋翻译,效应水平？)。举例说明，包括相关系数，回归系数，均值差。对于大部分的effect size，绝对值越大，往往说明效应越强。</p>
<h3 id="Relationship-to-test-statistics">Relationship to test statistics</h3>
<p>基于采样的effect sizes 和 假设检验的统计检验量不一样。effect sizes 是检验 strength(magnitude ) ；然而假设检验是给出一个显著性水平（P值），反应这个magnitude 或 relationship 是不是出于偶然（随机误差）。effect size 并不直接决定显著性水平，反之亦然。<strong>只要样本量足够大，哪怕effect size 很小，也能得到统计显著结果</strong>。因此，只看p值可能有一定的误导。</p>
<h3 id="Standardized-and-unstandardized-effect-sizes">Standardized and unstandardized effect sizes</h3>
<p>effect sizes 标准化的原因：<br>
1. 变量的单位本身没有意义<br>
2. 结果来自多重结果的合并<br>
3. 不同的结果用了不同的单位<br>
4. it is desired to convey the size of an effect relative to the variability in the population</p>
<h3 id="Types">Types</h3>
<h4 id="Correlation-family">Correlation family</h4>
<ol>
<li>
<p>Pearson r</p>
</li>
<li>
<p>Coefficient of determination (r^2^ or R^2^)<br>
Pearson r 的平方</p>
<blockquote>
<p>In the case of paired data, this is a measure of the proportion of variance shared by the two variables, and varies from 0 to 1. (在配对数据中，一个变量中的方差能被另一个变量解释的比例)</p>
</blockquote>
</li>
</ol>
<h4 id="Difference-family">Difference family</h4>
<p>Effect sizes based on differences between means</p>
<p><img src="Difference_family1.png" alt="Difference_family1"></p>
<p>其中μ1 μ2 是两个群体的均值；σ是基于一个群体或两个群体的标准差。</p>
<p>这种形式很像t统计量，但是t统计量包含了一个因素，根号N。这意味着，对于给定的effect size，显著水平会随着样本量的增加而增加。 Unlike the t-test statistic, the effect size aims to estimate a population parameter and is not affected by the sample size.</p>
<h5 id="Cohen’s-d">Cohen’s d</h5>
<p>![Difference_family1](Cohen’s d.png)</p>
<h2 id="PEVD-kennedy-1993">PEVD -kennedy 1993</h2>
<blockquote>
<p>Unbiased comparisons between animals  can, how- ever, be made if  animals are sampled from a common genetic population, in which case the consequence of “disconnectedness” is reflected   only in the PEV of differences between EBV of animals. The PEV of the individual animal (diagonal element) is unchanged given the same number of animals. The PEV of difference in EBV, however, depends on whether comparisons are within or between management units.</p>
</blockquote>
<p>这是好像最早提及PEVD的文献。但是具体计算的部分，没有提及。只是说现在都最多只提供系数矩阵逆矩阵对角线元素（Misztal 和 Wiggans1988,Meyer,1989），但没有提供非对角线元素的值。</p>
<p>因此PEVD不能计算，然后就给出了三种替代方案。巴拉巴拉。后面对我没作用。</p>
<h1>Changes in connectedness over time in alternative sheep sire referencing schemes - Kuehn 2008</h1>
<p>这是在Yu的文章中提到了一嘴，说PEVD 的 scale ,也就是去除单位，是按照这篇文章的方法。</p>
<p>这篇文章用了两个指标，第一个是 onnectedness correlation (Lewis etal., 1999, 2005)</p>
<p><img src="r.png" alt="r"></p>
<blockquote>
<p>The connectedness corre-lation was calculated and averaged each year for allpairs of ram lambs born in different flocks across all15 flocks (lamb rij)</p>
</blockquote>
<p>还是要两个群体两两配对，再求均值。</p>
<p>有两种算法。一种是这种，还有一种大概意思是直接用场效应,和mathur一致。</p>
<p>scaled PEVD 就是再除以加性方差。</p>
<p>还是两种计算PEVD的算法，一种是用个体，但是要两两配对求均值；一种就是直接用场效应。</p>
<h1>H阵</h1>
<p>mistal 2010 和 2012 的文献中，A下标的1 和 2 是相反的。</p>
<h1>暑假统计遗传学培训班</h1>
<h2 id="矩阵运算（matrix-algebra）">矩阵运算（matrix algebra）</h2>
<ul>
<li>对于对称阵，A’ = A 。（对称阵的转置矩阵为其本身）</li>
<li>（AB)’ = B’A’</li>
<li>方阵的迹（trace）<br>
tr(A) = 对角线元素之和<br>
trA = sum(diag(A))</li>
<li>矩阵的秩（Rank）：矩阵中线性无关的行数或列数<br>
<strong>不满秩的矩阵称为奇异阵（singular）</strong><br>
r &lt;- qr(D)$rank</li>
<li>方阵的<strong>行列式</strong>：如果|A|=0，A 不满秩，即 A 是奇异的<br>
detA &lt;- det(A)</li>
</ul>
<h3 id="求逆">求逆</h3>
<p>对于一个<strong>满秩</strong>的方阵A，必均在其逆矩阵，且唯一。</p>
<blockquote>
<p>（AB)^-1^ = B^-1^ A^-1^<br>
A- = solve(A)</p>
</blockquote>
<p>对角矩阵的逆矩阵</p>
<p><img src="diag_inv.png" alt="diag_inv"></p>
<p><strong>广义逆</strong><br>
AA^-^A = A<br>
如果满秩，那么广义逆和逆相等，解是唯一的。<br>
一个奇异阵可以有无穷多个广义逆矩阵。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">library(MASS)</span><br><span class="line">ginv(D)</span><br></pre></td></tr></table></figure>
<h3 id="正定矩阵（Positive-definite）">正定矩阵（Positive definite）</h3>
<p>没看懂</p>
<p><img src="positive_definite.png" alt="positive_definite"></p>
<h3 id="Cholesky-分解">Cholesky 分解</h3>
<p>任何<strong>对称正定矩阵</strong>都可分解为</p>
<p>** A = TT’ **<br>
其中，T是一个下三角矩阵<br>
T &lt;- chol(A) #注：该函数返回的是一个上三角矩阵</p>
<h3 id="正交矩阵（Orthogonal）">正交矩阵（Orthogonal）</h3>
<p>正交矩阵的转置矩阵和逆矩阵相等</p>
<h3 id="特征值和特征向量">特征值和特征向量</h3>
<p>对于方阵 A, 如果存在一个常量 d 和一个非零向量 u, 它们满足</p>
<p>𝐀𝐮=𝑑𝐮</p>
<p>称 d 是 A 的特征值（eigenvalue）,  u 是与 d 对应的特征向量（eigenvector）</p>
<p>note: 一个矩阵可以有多个特征值和多个对应的特征向量</p>
<p>eigen(A)</p>
<p>特征值和特征向量性质：</p>
<ul>
<li>一个矩阵的所有特征值之和等于其迹</li>
<li>一个矩阵的所有特征值之积等于其行列式</li>
<li>一个矩阵的非零特征值的个数等于其秩</li>
<li>如果一个矩阵的所有特征值均大于0，则该矩阵是正定的</li>
<li>如果一个矩阵的所有特征值均大于或等于0，半正定</li>
<li>如果Q为对称矩阵，则它可分解为<br>
** Q = UDU’ **<br>
D 为对角矩阵，其对角线元素为Q的特征值<br>
U 为正交矩阵，其各列为Q的特征向量</li>
</ul>
<h3 id="矩阵的微分（Differentiation）">矩阵的微分（Differentiation）</h3>
<p><img src="Differentiation.png" alt="Differentiation"></p>
<p><img src="Differentiation2.png" alt="Differentiation2"></p>
<h3 id="随机向量">随机向量</h3>
<p>由随机变量组成的向量</p>
<p><img src="random_vector.png" alt="random_vector"></p>
<p>下一张图不懂</p>
<p><img src="random_vector2.png" alt="random_vector"></p>
<h3 id="PEV-PEVD-是否乘以残差方差">PEV / PEVD 是否乘以残差方差</h3>
<p>如果MME左右两边没有约掉R^-1^，那么就不用乘残差方差；否则就要乘。（我计算都是约掉的，所以要乘）</p>
<p><img src="pev.png" alt="random_vector"></p>
<h3 id="A-1-的计算">A^-1^ 的计算</h3>
<ol>
<li>由于A是对称正定矩阵，因此可以使用 Cholesky 分解，将其分解一个下三角矩阵乘以其转置矩阵。</li>
<li>下三角矩阵矩阵L 可以分解一个新的下三角矩阵（T，对角线元素为1） 乘以 一个对角阵 （D，为L阵的对角线元素）</li>
<li>因此，𝐀=𝐓𝐃𝐃𝐓‘ 。而 <strong>DD</strong> 相同的对角阵相乘仍为对角阵，其元素为原来的平方。</li>
</ol>
<p><img src="A-.png" alt="random_vector"></p>
<p>注：任何一个矩阵（T）右乘以一个对角阵（D），等于原矩阵的第一列乘以d1，第二列乘以d2……以此类推。</p>
<h4 id="YD-yield-deviation">YD (yield deviation)</h4>
<p>应该是指校正表型，指校正了所有固定环境效应的动物个体的（平均）表型值</p>
<h1>矩阵运算实际收获</h1>
<p>对LHS 和 LHS 的上三角矩阵 求逆，结果不一致。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归与R代码实现</title>
    <url>/posts/6cb58071/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>线性回归是最基础的统计模型，也应该是应用最广泛的应用模型。线性回归的因变量必须为连续变量；自变量可以为连续变量，也可以为分类变量（转化为哑变量/虚拟变量）</p>
<p>这里是我通过看资料对线性回归的总结。</p>
<span id="more"></span>
<h1>参考资料</h1>
<p><a href="https://www.statlearning.com/">An Introduction to Statistical Learning</a>，下文简称 <strong>ISL</strong></p>
<h1>线性回归的假设</h1>
<h2 id="1-自变量和因变量线性相关">1 自变量和因变量线性相关</h2>
<p>线性相关的意思是，无论自变量多大，自变量每增加一个单位，因变量都会产生固定的变化。</p>
<h2 id="2-多个自变量之间具有可加性">2 多个自变量之间具有可加性</h2>
<p>无论 X1 多大，X2 每增加一个单位，因变量都会产生固定的变化。如果满足这个条件，说明 X1和X2 之间具有可加性。否则说明 X1 和 X2 之间存在<strong>互作</strong>效应。用图表示如下（左图两条线平行说明不存在互作，右图不平行说明存在互作）：</p>
<p><img src="12.png" alt="1"></p>
<h2 id="3-多个自变量之间彼此独立">3 多个自变量之间彼此独立</h2>
<p>多个自变量之间不能存在<strong>相关</strong>关系。相关关系分为两种，一种是简单的两两之间的相关，这个通过相关系数矩阵就能看出来是否存在两个变量之间的明显的相关（看绝对值）；第二种是多重线性相关（Multicollinearity），例如 X1 = a + bX2 + cX3，一个自变量可以用其他的多个自变量来解释，就说明存在多重线性相关。</p>
<h2 id="4-观测值的误差项之间互相独立">4 观测值的误差项之间互相独立</h2>
<p>误差项即实际值 - 预测值。如果观测值之间存在我们没有添加到模型中的其他影响因素，那么误差项之间就可能存在相关关系，比如有些样本搜集自同一个家庭的成员，而我们没有把家庭这个因素加入到模型中。</p>
<h2 id="5-误差项（ε）呈正态分布，期望为0，方差为定值">5 误差项（ε）呈正态分布，期望为0，方差为定值</h2>
<blockquote>
<p>这里其实分为两个假设。第一个假设：误差项服从均值为0的正态分布。第二个假设：误差项的方差为定值（不变）。这两个假设是为了保证回归模型在小样本下能够顺利进行假设检验。正态分布假设仅在小样本的情况下需要，大样本的情况下则不需要，因为有中心极限定理做正态性的支撑。而方差齐性则保证最小二乘法估计出来的统计量具有最小的方差。如果违反了这个假设，置信区间会变宽，这称之为<strong>异方差性（heteroscedasticity）</strong>。当异方差性出现的时候，如果仍采用最小二乘法估计参数，会导致参数的t检验值被高估，可能造成本来不显著的某些参数变为显著，使假设检验失去意义。</p>
<p><a href="https://www.cnblogs.com/HuZihu/p/10142737.html">https://www.cnblogs.com/HuZihu/p/10142737.html</a></p>
</blockquote>
<h2 id="6-自变量和误差项之间互相独立">6 自变量和误差项之间互相独立</h2>
<blockquote>
<p>模型中一个或多个自变量与随机误差项存在相关关系，这称之为<strong>内生性（endogeneity）</strong>。内生性通常由于遗漏变量而导致的，因此是一个普遍存在的问题。内生性会导致模型参数估计不准确。</p>
<p><a href="https://www.cnblogs.com/HuZihu/p/10142737.html">https://www.cnblogs.com/HuZihu/p/10142737.html</a></p>
</blockquote>
<h1>简单线性回归</h1>
<h2 id="β0-β1-参数估计-最小二乘法">β0, β1 参数估计 - 最小二乘法</h2>
<p>最小二乘的思路是，查找使得<strong>误差平方和</strong>或<strong>均方误差</strong>最小的参数。</p>
<p>我们首先知道，<strong>误差 = 实际值 - 预测值</strong>，我们的目的实际是想要所有观察值的总体的误差最小，因为误差有正有负，如果采用误差项直接相加会互相抵消，因为我们采用误差的平方进行相加，得到误差平方和 (<abbr title="residual sum of squares">RSS</abbr>)。</p>
<p><img src="1.png" alt="1"></p>
<p>或者写成</p>
<p><img src="2.png" alt="1"></p>
<p>除以总共的样本数 n，便得到<abbr title="mean square error, MSE"><strong>均方误差</strong></abbr>，使得 RSS/MSE 最小的参数便是最小二乘的最优解。写成公式如下（缺推导过程）：</p>
<p><img src="3.png" alt="1"></p>
<p>画成等高图如下（作图横纵坐标为β0和β1，图中一圈表示相同的RSS，数字即为 RSS 大小），我们可以看到这是向下凹的图形，只有一个点RSS 最小。</p>
<p><img src="4.png" alt="1"></p>
<h3 id="为什么不用残差的绝对值？">为什么不用残差的绝对值？</h3>
<p>我上统计课的时候就有这个问题，就一直有这个疑问，如果因为残差有方向，不能直接求和，那为什么不直接用绝对值呢？这不是更直接的更贴近残差本质的思路吗？</p>
<p>后来上了吴恩达老师的机器学习课，知道了代价函数的概念，寻找代价函数最小值的最简单的方法就是<strong>求导</strong>。最小二乘法的代价函数就是 RSS/MSE，由于这里采用平方和（二次函数），<strong>求导会直接变成一次函数</strong>。而如果使用残差的绝对值的和，根本无法进行简单的求导，就无法简单地得到最优解的公式。</p>
<p>所以，目前我个人的理解是使用平方和<strong>简化了运算</strong>。</p>
<h2 id="参数估计准确性">参数估计准确性</h2>
<p>我们使用的模型为</p>
<p><img src="5.png" alt="1"></p>
<p>这里的<strong>残差项包含了所有我们模型中没有考虑到的地方</strong>，比如Y 和 X 的关系不是线性的，还有其他的影响因素，存在测量误差等等。</p>
<p>为了估计参数的估计值与真实值之间的误差，我们需要计算两个参数估计值的标准误，使用下列公式（缺证明）</p>
<p><img src="6.png" alt="1"></p>
<p>这里 σ2 是残差方差，是未知的。残差标准差 σ 可以用 RSE (residual standard error) 来估计（缺证明）。</p>
<p><img src="7.png" alt="1"></p>
<p>知道了标准误，我们可以计算<strong>β0、β1的置信区间</strong>，例如 β1 的 95%的置信区间为：</p>
<p><img src="8.png" alt="1"></p>
<p>如果  β1 的 95%的置信区间 <strong>包含 0</strong>，那说明不能拒绝  β1  = 0 的原假设，我们认为不存在线性相关。</p>
<p>我们也可以通过 t 检验得到 P值。构建 t 统计量如下（自由度 n-2）：</p>
<p><img src="9.png" alt="1"></p>
<p>同理可以检验β0 估计值的P值（零假设：β0 = 0），但实际上截距的显著性没啥大的意义，主要还是看 β1。如果  β1 的 P值小于 0.05，我们认为  β1 ≠ 0。</p>
<h2 id="模型准确性">模型准确性</h2>
<p>上面是得到估计的两个参数的准确性，这里我们想知道，我们构建的简单线性模型与数据的契合程度（<em>which the model fits the data</em>）。</p>
<p>线性模型一般用两个指标， <em>residual standard error</em>(RSE) 和 R<sup>2</sup> 。</p>
<h3 id="RSE">RSE</h3>
<p><img src="7.png" alt="1"></p>
<p>RSE 是<strong>残差的标准误的估计值</strong>，它表示<strong>预测值与真实值的平均偏差量</strong>（这句话需要理解标准误的概念：标准误是样本统计量的标准差，均值为真值，结合标准差的公式，可知标准误就是预测值与真实值的平均偏差量（绝对值），所以一般提供参数估计值的时候，都会写成 参数估计值±<strong>标准误</strong>的形式）。</p>
<p>RSE 是最直接说明模型准确性的统计量，它的缺点是有单位，是一个绝对值，仅仅是RSE你不知道到底是大还是小，所以你还得和因变量的均值啥的进行比较才知道相对大小。</p>
<h3 id="R-sup-2-sup">R<sup>2</sup></h3>
<p>R<sup>2</sup> 指的是因变量方差能够被线性模型解释的比例，始终在0和1之间，是一个相对值，越大越好。公式如下：</p>
<p><img src="10.png" alt="1"></p>
<p>其中<abbr title="total sum of squares">TSS</abbr> 计算如下，表示因变量的总的方差。</p>
<p><img src="11.png" alt="1"></p>
<p>R<sup>2</sup> 比 RSE 更容易解释，因此更常用，但是还是面临一个问题，<strong>R<sup>2</sup> 多大才算结果很好呢？<strong>这可能得根据实际情况来定，在我们一般的实验中，实际上往往还有很多</strong>未测量的影响因素</strong>，所以 RSS 可能比较大，这时可能 R<sup>2</sup> 哪怕比较小可能也说明有用。</p>
<h1>多重线性回归</h1>
<p>简单线性回归只有一个自变量，但在实际情况中，我们往往有多个自变量（即生活中其实几乎不存在简单线性回归的应用场景）。例如，如果我们有三个影响因素，我们如何同时分析这三个影响因素呢？</p>
<p>一种思路是我们分别做上次简单的线性回归，但是这种思路无法令人满意。首先，如果给定一组三个自变量的值，我们无法给出因变量的预测值；其次，每一次简单回归都忽视了其他两个影响因素的作用，这可能会带来严重的误判。更好的解决思路是同时将多个自变量均放到线性回归的模型中。</p>
<p>ISL 书中提到了一个例子，销量和三种媒体预算的回归分析。在简单线性回归下，报纸的作用是显著的，如下图。</p>
<p><img src="13.png" alt="1"></p>
<p>但是，同时考虑三种媒体后，报纸的P值是不显著的。这说明简单线性回归和多重线性回归的结果是不一样的。这种差距的出现的原因是，简单回归得到的<strong>斜率</strong>是不考虑其他因素（TV 和 radio）下得到的，而多重回归得到的<strong>斜率</strong>是<strong>保持 TV 和 radio 固定不变</strong>的基础上计算得到的。</p>
<p><img src="14.png" alt="1"></p>
<p>这种情况说明了什么呢，说明这三个自变量之间并不是互相独立的，通过下面的相关矩阵我们可以看到，radio 和 newspaper 的相关系数为0.35，表示当投资人在 radio advertising 花更多的钱的同时，存在一种趋势在 newspaper advertising 上也花更多的钱。因此，我们对 newspaper 进行简单回归时得到的显著性，<strong>实际不是 newspaper 的作用，而是 radio 因素的作用</strong>。</p>
<p>这样的例子实际上比比皆是。ISL 提了一个离谱的例子来说明这一点。如果我们计算<strong>沙滩冰淇淋销量</strong>对<strong>鲨鱼伤人事件的数量</strong>求回归，我们应该能得到一个正向的关系，类似于上面的 newpaper 的例子。但是这实际是很荒谬的，这两个事件不存在因果关系，<strong>你无法通过禁止销售冰淇淋来减少鲨鱼伤人的事件</strong>。实际上是高温天气促使了人们去海边，从而导致更多的冰淇淋销量和鲨鱼伤人事件。<strong>如果你同时考虑冰淇淋销量和天气，对鲨鱼伤人事件做多重回归，你就会发现冰淇淋销量不再是一个显著的影响因素</strong>。</p>
<h2 id="决定重要的影响因素">决定重要的影响因素</h2>
<p>当我们有多个影响因素时，很有可能所有的影响因素都和因变量是有联系的，但是因变量可能仅仅是由其中的一小部分自变量决定的（相关不等于因果，比如上面的冰淇淋销量的例子）。我们把如何挑选自变量的过程称为 <em>variable selection</em>。</p>
<p>理想情况下，我们可以通过<strong>穷举</strong>所有的模型，每种模型均包含一部分的自变量。通过对比所有模型的表现，我们就可以得到最佳的自变量的集合。例如假如我们手上总共有2个可选的自变量X1 X2，那么总共就有4种可能的模型，（1）不包含任何自变量 ；（2）包含X1 ；（3）包含X2；（4）包含X1和X2。但是我们用什么指标来判断不同模型的优劣呢？<strong>这里有很多的判定模型优劣的统计量，比如<abbr title="Akaike information criterion">AIC</abbr>， <abbr title="Bayesian information criterion">BIC</abbr>  , 校正后R<sup>2</sup> 等。</strong></p>
<h3 id="为什么使用校正后的R-sup-2-sup">为什么使用校正后的R<sup>2</sup></h3>
<p>我们看R<sup>2</sup> 的计算公式，可以看到 TSS 是固定值。如果你增加了变量后（比如原来只包含X1，到包含X1和X2），<strong>残差平方和只会减少</strong>（这就是overfitting的原理，哪怕仅仅是增加了无关变量，也会造成与本次数据的拟合程度“变好”）。这导致增加了变量后，R<sup>2</sup>只会进一步增加。</p>
<p><img src="10.png" alt="1"></p>
<p>校正后的R<sup>2</sup>的公式如下，考虑了自变量个数的影响。可以看到，校正后的R<sup>2</sup> 随着自变量个数的增加而降低，并且始终低于未校正的R<sup>2</sup>。</p>
<p><img src="15.png" alt="1"></p>
<p>ISL 还提到了了使用 RSE 来校正自变量个数的影响。</p>
<p><img src="7.png" alt="1"></p>
<h3 id="三种经典的挑选变量的思路">三种经典的挑选变量的思路</h3>
<ul>
<li><em>Forward selection</em>:  先从<em>null model</em> (没有任何变量的模型)出发，对所有的候选因素（假设 <em>p</em> 个）各做一次简单回归，然后挑选结果中 RSS 最低的变量加入到模型中。然后我们将剩下的 <em>p</em>-1 个候选因素，挨个加入到目前的模型中，再挑选结果中 RSS 最低的变量加入到模型中。一直循环下去，知道达到了某个终止条件。</li>
<li><em>Backward selection</em>:  首先将所有的变量均加入到模型中，然后移除其中 P值最大的变量，我们就得到了一个 <em>p</em>-1个变量的模型。循环往复直到达到终止条件（比如所有剩下的变量的P值均低于某个值）。</li>
<li><em>Mixed selection</em>: 结合了上述的两个方法，我们先从空的模型出发，就像第一种方法的示例，不停地往里加变量，直到最佳。在加变量的过程中，我们观察有没有变量的P值变大并且超出了我们设定的阈值，如果存在这种现象，我们就从模型中移除这个变量（backward）。我们一直重复这种添加变量和删除变量的操作，直到最终实现<strong>所有剩下的变量的P值均很低，所有剔除的变量只要加入到模型中就会有一个很大的P值</strong>。</li>
</ul>
<p>如果变量的个数超过了记录数，那么我们无法用 <em>Backward selection</em> (因为将所有变量均加入到模型中，会发生<a href="https://zh.wikipedia.org/wiki/%E7%BB%B4%E6%95%B0%E7%81%BE%E9%9A%BE">维数灾难</a>)，此时 <em>Forward selection</em> 是可用的。但是<strong><em>Forward selection</em> 是一种贪婪算法</strong>，早期加入的变量可能是多余的，而  <em>Mixed selection</em> 算法修正了这一点。</p>
<h2 id="变量之间是否存在互作">变量之间是否存在互作</h2>
<p>还是采用上面三种媒介的例子，我们已经确定了 newpaper 没有作用， TV  和 radio 对 sales 有作用，那是不是模型就是下面的形式呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Y &#x3D; β0 + β1*TV + β2*radio + e</span><br></pre></td></tr></table></figure>
<p>我们可以通过这个模型画出一个三维图，图中的平面为预测值。我们可以看到当主要的钱都投向一种媒体时，销量会低于预测值；而如果我们均衡投资这两种媒体，销量会高于预测值（虽然我没有很好的看懂这个三维图）。这说明<strong>TV 和 radio 这两个因素之间存在互作。</strong></p>
<p><img src="16.png" alt="1"></p>
<h2 id="预测的不确定性">预测的不确定性</h2>
<p>一旦我们得到了最终的多重线性回归模型，我们就可以基于一套自变量的值来预测反应变量的值。但是，我们所做的预测至少存在三种不确定性。</p>
<ol>
<li>
<p>我们得到的仅仅是 β0, β1, β2……等参数的估计值。这些参数的估计值与真实值存在差距，这种差距是<strong>可消除误差(<em>reducible error</em>)</strong> 的一种。我们统计计算一个 <em><strong>confidence interval</strong></em> 来决定估计参数得到的预测值与真实参数得到的预测值的差距。</p>
</li>
<li>
<p>第二种不确定性是由于线性模型仅仅是对实际数据的一个近似，这种带来的错误我们称之为<em><strong>model bias</strong></em> 。</p>
</li>
<li>
<p>即使我们知道真实的模型 f(x)（我们知道所有参数的真实值），我们也不能完全精确地预测因变量，因为还存在<strong>随机误差(<em>random error</em>)</strong>，这种属于<strong>不可消除误差(<em>irreducible error</em>)</strong>。真实模型的预测值与真实值之间的差距，用<em><strong>prediction intervals</strong></em> 来评价。<em>prediction intervals</em> 通常比 <em>confidence intervals</em> 更宽， 因为 <em>prediction intervals</em> 不仅包括了可消除误差，也包含了不可预测误差（ <em>prediction intervals</em> 包含了 <em>confidence interval</em> ）。下面这段话解释地更明确一点：</p>
<p><img src="27.png" alt="1"></p>
</li>
</ol>
<h1>线性回归潜在的问题</h1>
<h2 id="1-自变量与因变量之间为非线性关系">1 自变量与因变量之间为非线性关系</h2>
<p>线性回归假设因变量与自变量之间存在直接的线性关系。如果因变量与自变量之间不是线性关系，那么线性回归的准确性会显著降低。</p>
<p>我们一般通过<strong>残差图</strong>来确定非线性关系。如果是简单线性回归，横坐标可以是自变量X，纵坐标是残差e；但是如果是多重线性回归，由于存在多个自变量，横坐标改为因变量的预测值。</p>
<p>下边左图为简单线性回归的残差图，可以看到残差不是均匀地分布在均值为0这条线地上下两侧，说明存在非线性关系。右图通过<strong>多项式回归</strong>，残差图的结果变好了很多，虽然看上去还是有一点非随机分布。</p>
<p><img src="17.png" alt="1"></p>
<h2 id="2-残差项的相关">2 残差项的相关</h2>
<p>线性回归的一个重要的假设是残差项，e<sub>1</sub>,e<sub>2</sub>,e<sub>3</sub>…… e<sub>n</sub> 之间是不相关的。这句话的含义是，如果残差项是不相关的，那么某一个残差项的值不受其他残差项的影响。ISL 原文如下：</p>
<blockquote>
<p>For instance, if the errors are uncorrelated, then the fact that ε<sub>i</sub> is positive provides little or no information about the sign of ε<sub>i+1</sub>.</p>
</blockquote>
<p>预测参数或预测值的<strong>标准误</strong>都是基于残差不相关的假设计算得到的。<strong>如果实际上残差项之间存在相关，那么标准误倾向于被低估</strong>（缺解释），因此置信区间也会比正常情况下更窄，因此 p值会更低，容易出现<strong>假阳性</strong>。</p>
<p>下面这段话举了个例子，但是我没理解。这里假如我们不小心把数据重复了一遍（本来是n条数据，现在是2n条数据），参数估计的置信区间会缩减 √2 。</p>
<p><img src="18.png" alt="1"></p>
<p>**什么时候会出现残差项的相关？**这种情况频繁出现在 <em>time series</em> 数据，也有在不同的时间点去观测得到的数据。在很多情况下，相邻时间观测到的记录之间会有正相关的残差项。为了确定这种情况，我们可以画一个横坐标是时间的残差图，如果残差项之间是不相关的，你就不会观测到明显的模式（残差应该是忽上忽下）；相反，如果残差项之间是正相反的，你可以会发现相邻时间的残差会倾向于有相似的值。</p>
<p>下图就体现了这一点，最上面是没有残差相关的图，越往下残差相关越高，我们可以看到很清晰的模式 - 相邻的点之间倾向于有相似的值。</p>
<p><img src="19.png" alt="1"></p>
<p>除了  <em>time series</em> 数据以外，其他数据也可能出现残差相关。举个例子，假设我们有一个研究通过体重去预测一个人的身高。如果有一些研究个体来自于相同的家庭，或吃相同的饮食，又或者面临某些相同的环境因素，那么残差不相关的假设就可能被打破。</p>
<p>一般来说，<strong>残差不相关</strong>的假设对于线性回归和其他统计方法是非常重要的。<strong>良好的实验设计</strong>对于减少残差不相关的风险至关重要。</p>
<h3 id="为什么会出现残差相关？">为什么会出现残差相关？</h3>
<p>因为<strong>残差是个筐，啥都往里装</strong>。我们的模型中所有没有考虑到的影响因素都会包含在这个残差里。实际上我们的模型不可能包含所有的影响因素，我们也不可能收集到所有影响因素的数据，所以我感觉残差相关是不可能完全避免的，或多或少有一点，只要不是很严重。</p>
<p>所以<strong>实验设计</strong>很重要，你要事先把重要的影响因素考虑到，而且把这些数据收集到。如果没有收集到相应的数据，貌似都无法发现残差相关，比如上面的 <em>time series</em> 数据，如果你没有搜集每个数据的时间信息，你都没法画上面的残差图。你不知道就等于没有了。</p>
<h2 id="3-残差方差不齐性">3 残差方差不齐性</h2>
<p>线性回归的另一个重要的假设是所有残差项均有一个固定的方差。我们计算标准误、置信区间等都依赖于这个假设。</p>
<p>但不幸地是，残差项的方差不是固定的，才是通常的情况。比如，残差方差可能会随着因变量值的提高而提高。我们可以通过残差图来发现这一点，比如下图的左图。<strong>当面临这种情况时，一个可能的解决思路是将反应变量Y 转换为 log(Y)  或 √Y</strong> ，这两个函数对于较大的值都会有一个很好的收缩效应，从而导致方差不齐性的改善。下图的右图就展示了转换后的残差图，我们可以看到方差不齐性的结果大大改善了（残差的宽度都差不多了），但是存在轻微的非线性关系。</p>
<p><img src="20.png" alt="1"></p>
<h2 id="4-Outliers">4 Outliers</h2>
<p><strong>Outliers 的定义是这个点的真实值与预测值偏差很大</strong>。Outliers 出现的原因有很多，比如错误记录。</p>
<p>下图中的红点（观测值为20）就是一个典型的Outlier。左边图中的红线是包含了Outlier的回归线，蓝色虚线是剔除了Outlier的回归线，我们可以看到移除或不移除这个Outlier对参数估计的影响很小。</p>
<p>但是Outliers 还会造成另外的问题。比如，在这个例子中，如果包括Outlier 计算得到的 RSE 为 1.09 ，如果剔除Outlier 得到的 RSE 为 0.77 。因为 RSE 在计算置信区间和 p值时均会用到，这样因为一个点导致RSE剧增会影响到回归方差拟合效果的解释。相似地，加入这个 Outlier， R<sup>2</sup> 从 0.892 降低到 0.805。</p>
<p>我们可以通过残差图来找到Outlier。在本例中我们轻松地找到这个Outlier，但是在实际应用中，我们很难决定到底偏离多少才可以视为一个 Outlier。为了解决这个问题，我们可以画图<em><strong>studentized residuals</strong></em> 图，纵坐标时残差除以它的标准误估计值。如果学生残差超过3，我们一般就认为可能是Outlier。在下图的右图中，我们发现这个Outlier的学生残差超过了6，而其他点均在 -2 与 2 之间。</p>
<p>如果你相信Outlier的出现是由于<strong>数据记录或收集时出错</strong>，那么解决办法就是移除这个观测值。但是你需要担心，Outlier的出现也可能是说明你的<strong>模型不完善</strong>，比如缺了一个影响因子。</p>
<p><img src="21.png" alt="1"></p>
<h2 id="5-High-Leverage-Points">5 High Leverage Points</h2>
<p><em><strong>High Leverage Points</strong></em> 仅指<strong>拥有异常的 x<sub>i</sub> 的观测值</strong>。例如，下图中的观测值 41 就是一个 <em>High Leverage Point</em>。 左图中的红线为包含这个点的回归直线，蓝色虚线是剔除了这个点的回归直线。我们可以看到， <em>High Leverage Point</em> 的影响很大，因此找 <em>High Leverage Point</em> 很重要。</p>
<p>对于简单线性回归， <em>High Leverage Point</em> 很容易找到，我们可以直接从 X-Y 图中直接看出。但是多重线性回归存在多个因变量，有可能一个观测值的<strong>所有的自变量单独看都在合理的范围</strong>，但是<strong>这一组自变量的组合是异常的</strong>。下图中间的图就显示了这一点，这是一个有两个自变量(X1, X2)的回归。很多观测值的两个自变量均落在蓝色虚线框定的椭圆中，但是这个红色的点不在这个范围内，虽然这个点的 X1 和 X2 值单独看都不是异常的值。**因此对于多重回归，如果仅仅看单个自变量是否存在 <em>High Leverage Point</em>，我们可能会漏掉一些 <em>High Leverage Point</em>。 ** 但是对于超过2个变量的多重回归模型，如果能够同时查看多个自变量组合的 <em>High Leverage Point</em>  就是一个问题，因为你没法针对2维以上的变量进行画图。</p>
<p><img src="22.png" alt="1"></p>
<p>为了确定一个观测值的 leverage，我们可以计算一个 <em>leverage statistic</em> 。这个值越大说明 leverage 程度越高。对于一个简单线性回归，公式如下（多重回归的公式未给）：</p>
<p><img src="23.png" alt="1"></p>
<p>这个统计量的值在 1/n 与 1 之间，而且所有的观测值的  <em>leverage statistic</em> 的均值是 (p+1)/n 。所以如果一个观测值的  <em>leverage statistic</em> 远超均值，我们就可以怀疑这是一个  <em>High Leverage Point</em></p>
<p>上图 3.13 中的右图是 学生残差 vs h<sub>i</sub>  的散点图。观测值41 的 h<sub>i</sub> 和 学生残差均特别高，说明**这个点即是   <em>High Leverage Point</em>  ，也是一个 outlier ** 。这种情况是非常危险的组合，会对回归结果造成很大的影响，相比之下观测值20 虽然是一个 outlier, 但是 leverage 很低，最起码对回归方程没什么影响。</p>
<h2 id="6-Collinearity">6  Collinearity</h2>
<p><em>Collinearity</em> 表示<strong>两个或更多个自变量之间具有紧密的相关关系</strong>。<em>Collinearity</em> 可以用下图来表示，左图中的两个变量之间表现出来没有明显的关系，而右图的两个变量之间存在<strong>高度</strong>的相关关系（我不知道这个等高图为什么可以这么解释）。</p>
<p><img src="24.png" alt="1"></p>
<p><em>Collinearity</em> 的影响在于无非区分开多个自变量对因变量的影响程度。比如右图中，RSS最低的（β<sub>Limit</sub> , β<sub>Rating</sub>）有很多个，他们在一个狭长的椭圆当中，这导致了参数估计的不确定性。</p>
<p><em>Collinearity</em> 会降低回归参数估计的准确性，导致斜率估计的标准误增加，因此 P 值会增加，会导致 power（正确地拒绝原假设的概率） 降低。下图就是两次回归得到的回归系数和 P值，我们可以看到由于存在 <em>Collinearity</em> ，导致 limit 因素第二次分析时变得不显著。</p>
<p><img src="25.png" alt="1"></p>
<p>因此<strong>我们需要在进行回归分析前进行 <em>Collinearity</em> 的检测</strong>。一个简单的思路是看<strong>自变量之间的相关矩阵</strong>，看是否存在相关系数很高的情况。但是有可能存在一种情况，就是自变量之间不存在两两之间的强相关，但是存在三个及以上的变量之间的相关（例如 X1 = a + bX2 + cX3）。我们把这种情况称为 <em><strong>multicollinearity</strong></em> 。因此我们不采用自变量的相关矩阵，我们引入了一个新的统计量来检测 <em>Collinearity</em>，就是 <abbr title="variance inflation factor">VIF</abbr> 。定义如下：</p>
<blockquote>
<p>The VIF is  the ratio of the variance of ˆβ<sub>j</sub> when fitting the full model divided by the variance of ˆβ<sub>j</sub> if fit on its own.</p>
</blockquote>
<p>VIF 的最小值为1， 说明完全没有<em>Collinearity</em> ，一般来说自变量之间存在一定的 <em>Collinearity</em> , 一般我们认为 VIF 超过 5 或 10 就说明存在严重的 <em>Collinearity</em> 。对于每个变量的 VIF 计算公式为</p>
<p><img src="26.png" alt="1"></p>
<p>在上面的例子中，对 age, rating  和 limit 这三个变量做 VIF 分析，计算结果分别为 1.01， 160.67 和 160.59 。</p>
<p>如果面临 <em>Collinearity</em>  的问题，有两个简单的思路：<strong>一是删除其中一个变量</strong>，这通常不会导致模型拟合程度的降低，因为变量之间的信息是冗余的；<strong>二是合并共显性的变量为一个变量</strong>。</p>
<h1>R代码实现</h1>
<h2 id="简单线性回归">简单线性回归</h2>
<p>回归分析</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简单回归</span></span><br><span class="line">library(MASS)</span><br><span class="line">library(ISLR)</span><br><span class="line"><span class="comment">## 采用MASS包的Boston数据集</span></span><br><span class="line">lm.fit = lm(medv~lstat, data = Boston)</span><br><span class="line">summary(lm.fit) <span class="comment">#各种回归的信息</span></span><br></pre></td></tr></table></figure>
<p>回归分析结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Call:</span><br><span class="line">lm(formula &#x3D; medv ~ lstat, data &#x3D; Boston)</span><br><span class="line"></span><br><span class="line">Residuals:</span><br><span class="line">    Min      1Q  Median      3Q     Max </span><br><span class="line">-15.168  -3.990  -1.318   2.034  24.500 </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">            Estimate Std. Error t value Pr(&gt;|t|)    </span><br><span class="line">(Intercept) 34.55384    0.56263   61.41   &lt;2e-16 ***</span><br><span class="line">lstat       -0.95005    0.03873  -24.53   &lt;2e-16 ***</span><br><span class="line">---</span><br><span class="line">Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1</span><br><span class="line"></span><br><span class="line">Residual standard error: 6.216 on 504 degrees of freedom</span><br><span class="line">Multiple R-squared:  0.5441,	Adjusted R-squared:  0.5432 </span><br><span class="line">F-statistic: 601.6 on 1 and 504 DF,  p-value: &lt; 2.2e-16</span><br></pre></td></tr></table></figure>
<p>只看系数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; coef(lm.fit)</span><br><span class="line">(Intercept)       lstat </span><br><span class="line"> <span class="number">34.5538409</span>  -<span class="number">0.9500494</span> </span><br></pre></td></tr></table></figure>
<p>查看系数的置信区间（confidence interval ）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; confint(lm.fit)</span><br><span class="line">                <span class="number">2.5</span> %     97.5 %</span><br><span class="line">(Intercept) <span class="number">33.448457</span> <span class="number">35.6592247</span></span><br><span class="line">lstat       -<span class="number">1.026148</span> -<span class="number">0.8739505</span></span><br></pre></td></tr></table></figure>
<p>画 x-y 散点图，并添加回归线</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot(Boston$lstat, Boston$medv)</span><br><span class="line">abline(lm.fit)</span><br></pre></td></tr></table></figure>
<p>我们可以查看检查线性回归是否正常的图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">par(mfrow&#x3D;c(2,2))</span><br><span class="line">plot(lm.fit) # 直接画4副图</span><br></pre></td></tr></table></figure>
<p>绘图如下：上方左图就是正常的残差图，可以查看<strong>非线性</strong>，<strong>残差异方差</strong>等，我们可以看到这里存在非线性关系；上方右图就是QQ图，用于<strong>检验残差是否符合正态分布</strong>；下方左图也是一个残差图，不过就是把纵坐标改成了 <em><strong>standardized residuals</strong></em>（缺公式）；下方右图用于判断 <em>Outlier</em> 和  <em>High Leverage Point</em>  ，横坐标是 leverage， 通常大于 4/n (n 是样本点的数目)，就算 <em>High Leverage Point</em> ； 纵轴是residuals，通常小样本大于2，大样本大于4的算作outliers 。</p>
<p><img src="28.png" alt="1"></p>
<h2 id="多重线性回归">多重线性回归</h2>
<p>看一下数据结构</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; str(Boston)</span><br><span class="line"><span class="string">&#x27;data.frame&#x27;</span>:	<span class="number">506</span> obs. of  <span class="number">14</span> variables:</span><br><span class="line"> $ crim   : num  <span class="number">0.00632</span> <span class="number">0.02731</span> <span class="number">0.02729</span> <span class="number">0.03237</span> <span class="number">0.06905</span> ...</span><br><span class="line"> $ zn     : num  <span class="number">18</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">12.5</span> <span class="number">12.5</span> <span class="number">12.5</span> <span class="number">12.5</span> ...</span><br><span class="line"> $ indus  : num  <span class="number">2.31</span> <span class="number">7.07</span> <span class="number">7.07</span> <span class="number">2.18</span> <span class="number">2.18</span> <span class="number">2.18</span> <span class="number">7.87</span> <span class="number">7.87</span> <span class="number">7.87</span> <span class="number">7.87</span> ...</span><br><span class="line"> $ chas   : int  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> ...</span><br><span class="line"> $ nox    : num  <span class="number">0.538</span> <span class="number">0.469</span> <span class="number">0.469</span> <span class="number">0.458</span> <span class="number">0.458</span> <span class="number">0.458</span> <span class="number">0.524</span> <span class="number">0.524</span> <span class="number">0.524</span> <span class="number">0.524</span> ...</span><br><span class="line"> $ rm     : num  <span class="number">6.58</span> <span class="number">6.42</span> <span class="number">7.18</span> <span class="number">7</span> <span class="number">7.15</span> ...</span><br><span class="line"> $ age    : num  <span class="number">65.2</span> <span class="number">78.9</span> <span class="number">61.1</span> <span class="number">45.8</span> <span class="number">54.2</span> <span class="number">58.7</span> <span class="number">66.6</span> <span class="number">96.1</span> <span class="number">100</span> <span class="number">85.9</span> ...</span><br><span class="line"> $ dis    : num  <span class="number">4.09</span> <span class="number">4.97</span> <span class="number">4.97</span> <span class="number">6.06</span> <span class="number">6.06</span> ...</span><br><span class="line"> $ rad    : int  <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> ...</span><br><span class="line"> $ tax    : num  <span class="number">296</span> <span class="number">242</span> <span class="number">242</span> <span class="number">222</span> <span class="number">222</span> <span class="number">222</span> <span class="number">311</span> <span class="number">311</span> <span class="number">311</span> <span class="number">311</span> ...</span><br><span class="line"> $ ptratio: num  <span class="number">15.3</span> <span class="number">17.8</span> <span class="number">17.8</span> <span class="number">18.7</span> <span class="number">18.7</span> <span class="number">18.7</span> <span class="number">15.2</span> <span class="number">15.2</span> <span class="number">15.2</span> <span class="number">15.2</span> ...</span><br><span class="line"> $ black  : num  <span class="number">397</span> <span class="number">397</span> <span class="number">393</span> <span class="number">395</span> <span class="number">397</span> ...</span><br><span class="line"> $ lstat  : num  <span class="number">4.98</span> <span class="number">9.14</span> <span class="number">4.03</span> <span class="number">2.94</span> <span class="number">5.33</span> ...</span><br><span class="line"> $ medv   : num  <span class="number">24</span> <span class="number">21.6</span> <span class="number">34.7</span> <span class="number">33.4</span> <span class="number">36.2</span> <span class="number">28.7</span> <span class="number">22.9</span> <span class="number">27.1</span> <span class="number">16.5</span> <span class="number">18.9</span> ...</span><br></pre></td></tr></table></figure>
<p>两个回归因素，lstat 和 age</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; lm.fit=lm(medv~lstat+age,data=Boston)</span><br><span class="line">&gt; summary(lm.fit)</span><br><span class="line"></span><br><span class="line">Call:</span><br><span class="line">lm(formula = medv ~ lstat + age, data = Boston)</span><br><span class="line"></span><br><span class="line">Residuals:</span><br><span class="line">    Min      <span class="number">1</span>Q  Median      <span class="number">3</span>Q     Max </span><br><span class="line">-<span class="number">15.981</span>  -<span class="number">3.978</span>  -<span class="number">1.283</span>   <span class="number">1.968</span>  <span class="number">23.158</span> </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">            Estimate Std. Error t value Pr(&gt;|t|)    </span><br><span class="line">(Intercept) <span class="number">33.22276</span>    <span class="number">0.73085</span>  <span class="number">45.458</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">lstat       -<span class="number">1.03207</span>    <span class="number">0.04819</span> -<span class="number">21.416</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">age          <span class="number">0.03454</span>    <span class="number">0.01223</span>   <span class="number">2.826</span>  <span class="number">0.00491</span> ** </span><br><span class="line">---</span><br><span class="line">Signif. codes:  <span class="number">0</span> ‘***’ <span class="number">0.001</span> ‘**’ <span class="number">0.01</span> ‘*’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error: <span class="number">6.173</span> on <span class="number">503</span> degrees of freedom</span><br><span class="line">Multiple R-squared:  <span class="number">0.5513</span>,	Adjusted R-squared:  <span class="number">0.5495</span> </span><br><span class="line"><span class="built_in">F</span>-statistic:   <span class="number">309</span> on <span class="number">2</span> and <span class="number">503</span> DF,  p-value: &lt; <span class="number">2.2e-16</span></span><br></pre></td></tr></table></figure>
<p>Boston 数据集总共有 13 个自变量，我们可以通过这种简写方式，直接使用所有的自变量（前提是除了因变量以外，其他全是自变量）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; lm.fit=lm(medv~.,data=Boston)</span><br><span class="line">&gt; summary(lm.fit)</span><br><span class="line"></span><br><span class="line">Call:</span><br><span class="line">lm(formula = medv ~ ., data = Boston)</span><br><span class="line"></span><br><span class="line">Residuals:</span><br><span class="line">    Min      <span class="number">1</span>Q  Median      <span class="number">3</span>Q     Max </span><br><span class="line">-<span class="number">15.595</span>  -<span class="number">2.730</span>  -<span class="number">0.518</span>   <span class="number">1.777</span>  <span class="number">26.199</span> </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">              Estimate Std. Error t value Pr(&gt;|t|)    </span><br><span class="line">(Intercept)  <span class="number">3.646e+01</span>  <span class="number">5.103e+00</span>   <span class="number">7.144</span> <span class="number">3.28e-12</span> ***</span><br><span class="line">crim        -<span class="number">1.080e-01</span>  <span class="number">3.286e-02</span>  -<span class="number">3.287</span> <span class="number">0.001087</span> ** </span><br><span class="line">zn           <span class="number">4.642e-02</span>  <span class="number">1.373e-02</span>   <span class="number">3.382</span> <span class="number">0.000778</span> ***</span><br><span class="line">indus        <span class="number">2.056e-02</span>  <span class="number">6.150e-02</span>   <span class="number">0.334</span> <span class="number">0.738288</span>    </span><br><span class="line">chas         <span class="number">2.687e+00</span>  <span class="number">8.616e-01</span>   <span class="number">3.118</span> <span class="number">0.001925</span> ** </span><br><span class="line">nox         -<span class="number">1.777e+01</span>  <span class="number">3.820e+00</span>  -<span class="number">4.651</span> <span class="number">4.25e-06</span> ***</span><br><span class="line">rm           <span class="number">3.810e+00</span>  <span class="number">4.179e-01</span>   <span class="number">9.116</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">age          <span class="number">6.922e-04</span>  <span class="number">1.321e-02</span>   <span class="number">0.052</span> <span class="number">0.958229</span>    </span><br><span class="line">dis         -<span class="number">1.476e+00</span>  <span class="number">1.995e-01</span>  -<span class="number">7.398</span> <span class="number">6.01e-13</span> ***</span><br><span class="line">rad          <span class="number">3.060e-01</span>  <span class="number">6.635e-02</span>   <span class="number">4.613</span> <span class="number">5.07e-06</span> ***</span><br><span class="line">tax         -<span class="number">1.233e-02</span>  <span class="number">3.760e-03</span>  -<span class="number">3.280</span> <span class="number">0.001112</span> ** </span><br><span class="line">ptratio     -<span class="number">9.527e-01</span>  <span class="number">1.308e-01</span>  -<span class="number">7.283</span> <span class="number">1.31e-12</span> ***</span><br><span class="line">black        <span class="number">9.312e-03</span>  <span class="number">2.686e-03</span>   <span class="number">3.467</span> <span class="number">0.000573</span> ***</span><br><span class="line">lstat       -<span class="number">5.248e-01</span>  <span class="number">5.072e-02</span> -<span class="number">10.347</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">---</span><br><span class="line">Signif. codes:  <span class="number">0</span> ‘***’ <span class="number">0.001</span> ‘**’ <span class="number">0.01</span> ‘*’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error: <span class="number">4.745</span> on <span class="number">492</span> degrees of freedom</span><br><span class="line">Multiple R-squared:  <span class="number">0.7406</span>,	Adjusted R-squared:  <span class="number">0.7338</span> </span><br><span class="line"><span class="built_in">F</span>-statistic: <span class="number">108.1</span> on <span class="number">13</span> and <span class="number">492</span> DF,  p-value: &lt; <span class="number">2.2e-16</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以通过car包的 vif() 函数计算 各个因子的VIF，这里可以看到 rad 和 tax 这两个因素的 VIF 比较高。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; library(car)</span><br><span class="line">载入需要的程辑包：carData</span><br><span class="line">Registered S3 methods overwritten by <span class="string">&#x27;tibble&#x27;</span>:</span><br><span class="line">  method     from  </span><br><span class="line">  format.tbl pillar</span><br><span class="line">  print.tbl  pillar</span><br><span class="line">Warning messages:</span><br><span class="line">1: 程辑包‘car’是用R版本<span class="number">4.0</span>.3 来建造的 </span><br><span class="line">2: 程辑包‘carData’是用R版本<span class="number">4.0</span>.3 来建造的 </span><br><span class="line">&gt; vif(lm.fit)</span><br><span class="line">    crim       zn    indus     chas      nox       rm      age      dis      rad      tax </span><br><span class="line">1.792192 <span class="number">2.298758</span> <span class="number">3.991596</span> <span class="number">1.073995</span> <span class="number">4.393720</span> <span class="number">1.933744</span> <span class="number">3.100826</span> <span class="number">3.955945</span> <span class="number">7.484496</span> <span class="number">9.008554</span> </span><br><span class="line"> ptratio    black    lstat </span><br><span class="line">1.799084 <span class="number">1.348521</span> <span class="number">2.941491</span> </span><br></pre></td></tr></table></figure>
<p>使用除了某一个因子外的其他所有因子的回归（采用 - 号），例如剔除 age 因子。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt;lm.fit1 = lm(medv∼.-age,data=Boston)</span><br><span class="line">&gt;summary(lm.fit1)</span><br></pre></td></tr></table></figure>
<h2 id="互作项">互作项</h2>
<p>回归模型中 ， <code>lstat:black</code> 表示新增一个 <code>lstat</code> 和 <code>black</code> 的互作项。<code>lstat*age</code> 表示同时<code>lstat</code>, <code>age</code> 和他们之间的互作项，是 <code>lstat+age+lstat:age</code> 的简写。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; summary(lm(medv~lstat*age,data=Boston))</span><br><span class="line"></span><br><span class="line">Call:</span><br><span class="line">lm(formula = medv ~ lstat * age, data = Boston)</span><br><span class="line"></span><br><span class="line">Residuals:</span><br><span class="line">    Min      <span class="number">1</span>Q  Median      <span class="number">3</span>Q     Max </span><br><span class="line">-<span class="number">15.806</span>  -<span class="number">4.045</span>  -<span class="number">1.333</span>   <span class="number">2.085</span>  <span class="number">27.552</span> </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">              Estimate Std. Error t value Pr(&gt;|t|)    </span><br><span class="line">(Intercept) <span class="number">36.0885359</span>  <span class="number">1.4698355</span>  <span class="number">24.553</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">lstat       -<span class="number">1.3921168</span>  <span class="number">0.1674555</span>  -<span class="number">8.313</span> <span class="number">8.78e-16</span> ***</span><br><span class="line">age         -<span class="number">0.0007209</span>  <span class="number">0.0198792</span>  -<span class="number">0.036</span>   <span class="number">0.9711</span>    </span><br><span class="line">lstat:age    <span class="number">0.0041560</span>  <span class="number">0.0018518</span>   <span class="number">2.244</span>   <span class="number">0.0252</span> *  </span><br><span class="line">---</span><br><span class="line">Signif. codes:  <span class="number">0</span> ‘***’ <span class="number">0.001</span> ‘**’ <span class="number">0.01</span> ‘*’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error: <span class="number">6.149</span> on <span class="number">502</span> degrees of freedom</span><br><span class="line">Multiple R-squared:  <span class="number">0.5557</span>,	Adjusted R-squared:  <span class="number">0.5531</span> </span><br><span class="line"><span class="built_in">F</span>-statistic: <span class="number">209.3</span> on <span class="number">3</span> and <span class="number">502</span> DF,  p-value: &lt; <span class="number">2.2e-16</span></span><br></pre></td></tr></table></figure>
<h2 id="自变量的非线性转换">自变量的非线性转换</h2>
<p>我们可以创建一个新的自变量 X<sup>2</sup>，采用 <code>I(X^2)</code> 函数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; lm.fit2 = lm(medv~lstat+I(lstat^<span class="number">2</span>), data = Boston)</span><br><span class="line">&gt; summary(lm.fit2)</span><br><span class="line"></span><br><span class="line">Call:</span><br><span class="line">lm(formula = medv ~ lstat + I(lstat^<span class="number">2</span>), data = Boston)</span><br><span class="line"></span><br><span class="line">Residuals:</span><br><span class="line">     Min       <span class="number">1</span>Q   Median       <span class="number">3</span>Q      Max </span><br><span class="line">-<span class="number">15.2834</span>  -<span class="number">3.8313</span>  -<span class="number">0.5295</span>   <span class="number">2.3095</span>  <span class="number">25.4148</span> </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">             Estimate Std. Error t value Pr(&gt;|t|)    </span><br><span class="line">(Intercept) <span class="number">42.862007</span>   <span class="number">0.872084</span>   <span class="number">49.15</span>   &lt;<span class="number">2e-16</span> ***</span><br><span class="line">lstat       -<span class="number">2.332821</span>   <span class="number">0.123803</span>  -<span class="number">18.84</span>   &lt;<span class="number">2e-16</span> ***</span><br><span class="line">I(lstat^<span class="number">2</span>)   <span class="number">0.043547</span>   <span class="number">0.003745</span>   <span class="number">11.63</span>   &lt;<span class="number">2e-16</span> ***</span><br><span class="line">---</span><br><span class="line">Signif. codes:  <span class="number">0</span> ‘***’ <span class="number">0.001</span> ‘**’ <span class="number">0.01</span> ‘*’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error: <span class="number">5.524</span> on <span class="number">503</span> degrees of freedom</span><br><span class="line">Multiple R-squared:  <span class="number">0.6407</span>,	Adjusted R-squared:  <span class="number">0.6393</span> </span><br><span class="line"><span class="built_in">F</span>-statistic: <span class="number">448.5</span> on <span class="number">2</span> and <span class="number">503</span> DF,  p-value: &lt; <span class="number">2.2e-16</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看到二次项的P值也是显著的，说明模型拟合结果有所改善。我们可以使用 <code>anova()</code> 函数来比对两个模型。</p>
<p>这里 Model 1 表示原来的线性模型，Model 2 表示二次项回归模型。这个  <code>anova()</code> 函数执行了一个比对两个模型的假设检验，零假设是两个模型拟合程度一致，备择假设是更全的模型更好。这里F统计量是135， 相应的 P值也很低，说明二次项模型拟合程度更好。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; lm.fit = lm(medv~lstat, data=Boston)</span><br><span class="line">&gt; anova(lm.fit, lm.fit2)</span><br><span class="line">Analysis of Variance Table</span><br><span class="line"></span><br><span class="line">Model <span class="number">1</span>: medv ~ lstat</span><br><span class="line">Model <span class="number">2</span>: medv ~ lstat + I(lstat^<span class="number">2</span>)</span><br><span class="line">  Res.Df   RSS Df Sum of Sq     <span class="built_in">F</span>    Pr(&gt;<span class="built_in">F</span>)    </span><br><span class="line">1    <span class="number">504</span> <span class="number">19472</span>                                 </span><br><span class="line">2    <span class="number">503</span> <span class="number">15347</span>  <span class="number">1</span>    <span class="number">4125.1</span> <span class="number">135.2</span> &lt; <span class="number">2.2e-16</span> ***</span><br><span class="line">---</span><br><span class="line">Signif. codes:  <span class="number">0</span> ‘***’ <span class="number">0.001</span> ‘**’ <span class="number">0.01</span> ‘*’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如果要建立<strong>三次型</strong>方程，我们可以新增一个变量 <code>I(X^3)</code> 。但是，这种写法比较啰嗦。一个更好的写法是使用**<code>poly()</code>** 函数来创建一个多项式。比如下面就会创建一个自由度为5的二次型拟合</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; lm.fit5 = lm(medv~poly(lstat,<span class="number">5</span>),data=Boston)</span><br><span class="line">&gt; summary(lm.fit5)</span><br><span class="line"></span><br><span class="line">Call:</span><br><span class="line">lm(formula = medv ~ poly(lstat, <span class="number">5</span>), data = Boston)</span><br><span class="line"></span><br><span class="line">Residuals:</span><br><span class="line">     Min       <span class="number">1</span>Q   Median       <span class="number">3</span>Q      Max </span><br><span class="line">-<span class="number">13.5433</span>  -<span class="number">3.1039</span>  -<span class="number">0.7052</span>   <span class="number">2.0844</span>  <span class="number">27.1153</span> </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">                 Estimate Std. Error t value Pr(&gt;|t|)    </span><br><span class="line">(Intercept)       <span class="number">22.5328</span>     <span class="number">0.2318</span>  <span class="number">97.197</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">poly(lstat, <span class="number">5</span>)<span class="number">1</span> -<span class="number">152.4595</span>     <span class="number">5.2148</span> -<span class="number">29.236</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">poly(lstat, <span class="number">5</span>)<span class="number">2</span>   <span class="number">64.2272</span>     <span class="number">5.2148</span>  <span class="number">12.316</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">poly(lstat, <span class="number">5</span>)<span class="number">3</span>  -<span class="number">27.0511</span>     <span class="number">5.2148</span>  -<span class="number">5.187</span> <span class="number">3.10e-07</span> ***</span><br><span class="line">poly(lstat, <span class="number">5</span>)<span class="number">4</span>   <span class="number">25.4517</span>     <span class="number">5.2148</span>   <span class="number">4.881</span> <span class="number">1.42e-06</span> ***</span><br><span class="line">poly(lstat, <span class="number">5</span>)<span class="number">5</span>  -<span class="number">19.2524</span>     <span class="number">5.2148</span>  -<span class="number">3.692</span> <span class="number">0.000247</span> ***</span><br><span class="line">---</span><br><span class="line">Signif. codes:  <span class="number">0</span> ‘***’ <span class="number">0.001</span> ‘**’ <span class="number">0.01</span> ‘*’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error: <span class="number">5.215</span> on <span class="number">500</span> degrees of freedom</span><br><span class="line">Multiple R-squared:  <span class="number">0.6817</span>,	Adjusted R-squared:  <span class="number">0.6785</span> </span><br><span class="line"><span class="built_in">F</span>-statistic: <span class="number">214.2</span> on <span class="number">5</span> and <span class="number">500</span> DF,  p-value: &lt; <span class="number">2.2e-16</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里说明如果增加二次项，加到5， 可以增加模型的拟合程度。但是，进一步研究会发现，如果增加超过项数超过5的项，这些超过5的项的p值均不显著。</p>
<p>当然，除了使用二次项以外，我们还可以使用其他转换函数，比如<strong>log函数</strong>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">summary(lm(medv~<span class="built_in">log</span>(rm), data=Boston))</span><br></pre></td></tr></table></figure>
<h2 id="分类因子">分类因子</h2>
<p>这里我们用 <code>ISLR</code> 包的 <code>Carseats</code> 数据集。我们想要预测的变量是 <em>Sales</em></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; library(ISLR)</span><br><span class="line">&gt; fix(Carseats)</span><br><span class="line">&gt; str(Carseats)</span><br><span class="line"><span class="string">&#x27;data.frame&#x27;</span>:	<span class="number">400</span> obs. of  <span class="number">11</span> variables:</span><br><span class="line"> $ Sales      : num  <span class="number">9.5</span> <span class="number">11.22</span> <span class="number">10.06</span> <span class="number">7.4</span> <span class="number">4.15</span> ...</span><br><span class="line"> $ CompPrice  : num  <span class="number">138</span> <span class="number">111</span> <span class="number">113</span> <span class="number">117</span> <span class="number">141</span> <span class="number">124</span> <span class="number">115</span> <span class="number">136</span> <span class="number">132</span> <span class="number">132</span> ...</span><br><span class="line"> $ Income     : num  <span class="number">73</span> <span class="number">48</span> <span class="number">35</span> <span class="number">100</span> <span class="number">64</span> <span class="number">113</span> <span class="number">105</span> <span class="number">81</span> <span class="number">110</span> <span class="number">113</span> ...</span><br><span class="line"> $ Advertising: num  <span class="number">11</span> <span class="number">16</span> <span class="number">10</span> <span class="number">4</span> <span class="number">3</span> <span class="number">13</span> <span class="number">0</span> <span class="number">15</span> <span class="number">0</span> <span class="number">0</span> ...</span><br><span class="line"> $ Population : num  <span class="number">276</span> <span class="number">260</span> <span class="number">269</span> <span class="number">466</span> <span class="number">340</span> <span class="number">501</span> <span class="number">45</span> <span class="number">425</span> <span class="number">108</span> <span class="number">131</span> ...</span><br><span class="line"> $ Price      : num  <span class="number">120</span> <span class="number">83</span> <span class="number">80</span> <span class="number">97</span> <span class="number">128</span> <span class="number">72</span> <span class="number">108</span> <span class="number">120</span> <span class="number">124</span> <span class="number">124</span> ...</span><br><span class="line"> $ ShelveLoc  : Factor w/ <span class="number">3</span> levels <span class="string">&quot;Bad&quot;</span>,<span class="string">&quot;Good&quot;</span>,<span class="string">&quot;Medium&quot;</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> ...</span><br><span class="line"> $ Age        : num  <span class="number">42</span> <span class="number">65</span> <span class="number">59</span> <span class="number">55</span> <span class="number">38</span> <span class="number">78</span> <span class="number">71</span> <span class="number">67</span> <span class="number">76</span> <span class="number">76</span> ...</span><br><span class="line"> $ Education  : num  <span class="number">17</span> <span class="number">10</span> <span class="number">12</span> <span class="number">14</span> <span class="number">13</span> <span class="number">16</span> <span class="number">15</span> <span class="number">10</span> <span class="number">10</span> <span class="number">17</span> ...</span><br><span class="line"> $ Urban      : Factor w/ <span class="number">2</span> levels <span class="string">&quot;No&quot;</span>,<span class="string">&quot;Yes&quot;</span>: <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> ...</span><br><span class="line"> $ US         : Factor w/ <span class="number">2</span> levels <span class="string">&quot;No&quot;</span>,<span class="string">&quot;Yes&quot;</span>: <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> ...</span><br></pre></td></tr></table></figure>
<p>这里包含了类似于 <code>ShelveLoc</code> 的分类变量。如果使用分类变量，R会<strong>自动转变为哑变量</strong>。下面我们进行包含了一些互作项的多重回归模型。</p>
<p>这里  <code>ShelveLoc</code>  生成了两个哑变量 ShelveLocGood 和 ShelveLocMedium ，Bad 水平视为基础水平。我们可以看到 Good 和 Medium 水平的斜率都是正数，且均显著，说明 Good 和 Medium 水平的因变量的均值均比 Bad 水平要高。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; lm.fit=lm(Sales~.+Income:Advertising +Price:Age,data=Carseats)</span><br><span class="line">&gt; summary(lm.fit)</span><br><span class="line"></span><br><span class="line">Call:</span><br><span class="line">lm(formula = Sales ~ . + Income:Advertising + Price:Age, data = Carseats)</span><br><span class="line"></span><br><span class="line">Residuals:</span><br><span class="line">    Min      <span class="number">1</span>Q  Median      <span class="number">3</span>Q     Max </span><br><span class="line">-<span class="number">2.9208</span> -<span class="number">0.7503</span>  <span class="number">0.0177</span>  <span class="number">0.6754</span>  <span class="number">3.3413</span> </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">                     Estimate Std. Error t value Pr(&gt;|t|)    </span><br><span class="line">(Intercept)         <span class="number">6.5755654</span>  <span class="number">1.0087470</span>   <span class="number">6.519</span> <span class="number">2.22e-10</span> ***</span><br><span class="line">CompPrice           <span class="number">0.0929371</span>  <span class="number">0.0041183</span>  <span class="number">22.567</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">Income              <span class="number">0.0108940</span>  <span class="number">0.0026044</span>   <span class="number">4.183</span> <span class="number">3.57e-05</span> ***</span><br><span class="line">Advertising         <span class="number">0.0702462</span>  <span class="number">0.0226091</span>   <span class="number">3.107</span> <span class="number">0.002030</span> ** </span><br><span class="line">Population          <span class="number">0.0001592</span>  <span class="number">0.0003679</span>   <span class="number">0.433</span> <span class="number">0.665330</span>    </span><br><span class="line">Price              -<span class="number">0.1008064</span>  <span class="number">0.0074399</span> -<span class="number">13.549</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">ShelveLocGood       <span class="number">4.8486762</span>  <span class="number">0.1528378</span>  <span class="number">31.724</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">ShelveLocMedium     <span class="number">1.9532620</span>  <span class="number">0.1257682</span>  <span class="number">15.531</span>  &lt; <span class="number">2e-16</span> ***</span><br><span class="line">Age                -<span class="number">0.0579466</span>  <span class="number">0.0159506</span>  -<span class="number">3.633</span> <span class="number">0.000318</span> ***</span><br><span class="line">Education          -<span class="number">0.0208525</span>  <span class="number">0.0196131</span>  -<span class="number">1.063</span> <span class="number">0.288361</span>    </span><br><span class="line">UrbanYes            <span class="number">0.1401597</span>  <span class="number">0.1124019</span>   <span class="number">1.247</span> <span class="number">0.213171</span>    </span><br><span class="line">USYes              -<span class="number">0.1575571</span>  <span class="number">0.1489234</span>  -<span class="number">1.058</span> <span class="number">0.290729</span>    </span><br><span class="line">Income:Advertising  <span class="number">0.0007510</span>  <span class="number">0.0002784</span>   <span class="number">2.698</span> <span class="number">0.007290</span> ** </span><br><span class="line">Price:Age           <span class="number">0.0001068</span>  <span class="number">0.0001333</span>   <span class="number">0.801</span> <span class="number">0.423812</span>    </span><br><span class="line">---</span><br><span class="line">Signif. codes:  <span class="number">0</span> ‘***’ <span class="number">0.001</span> ‘**’ <span class="number">0.01</span> ‘*’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error: <span class="number">1.011</span> on <span class="number">386</span> degrees of freedom</span><br><span class="line">Multiple R-squared:  <span class="number">0.8761</span>,	Adjusted R-squared:  <span class="number">0.8719</span> </span><br><span class="line"><span class="built_in">F</span>-statistic:   <span class="number">210</span> on <span class="number">13</span> and <span class="number">386</span> DF,  p-value: &lt; <span class="number">2.2e-16</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
</search>
