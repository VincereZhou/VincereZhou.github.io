<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>R包-ggpubr</title>
    <url>/posts/4168b428/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>ggpubr 是用于可视化的一个 R 包。</p>
<span id="more"></span>
<h1>散点图</h1>
<p>ggpubr 散点图是使用 <code>ggscatter</code> 函数，但是貌似没法调节透明度（alpha)，因此没办法用于数据量较大有重叠的散点图。</p>
<p>因此这里我感觉不如直接使用其它包 ，比如我就用 ggplot2 和 scatterplot3d 画 PCA 的二维和三维图。</p>
<p>使用  <code>ggscatter</code> 函数的一个简单例子如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data<span class="punctuation">(</span><span class="string">&quot;mtcars&quot;</span><span class="punctuation">)</span></span><br><span class="line">df <span class="operator">&lt;-</span> mtcars</span><br><span class="line">df<span class="operator">$</span>cyl <span class="operator">&lt;-</span> as.factor<span class="punctuation">(</span>df<span class="operator">$</span>cyl<span class="punctuation">)</span></span><br><span class="line">p1 <span class="operator">&lt;-</span> ggscatter<span class="punctuation">(</span>df<span class="punctuation">,</span> x <span class="operator">=</span> <span class="string">&quot;wt&quot;</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="string">&quot;mpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">                color <span class="operator">=</span> <span class="string">&quot;cyl&quot;</span><span class="punctuation">)</span></span><br><span class="line">p1</span><br></pre></td></tr></table></figure>
<p><img src="1.png" alt=""></p>
<p>你可以在图中对每一个点添加标签（适合点比较少的情况），如下。其中 ：</p>
<ul>
<li><code>label = &quot;name&quot;</code>： 指定标签列</li>
<li><code>repel = TRUE</code> :       避免标签重叠</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">df<span class="operator">$</span>name <span class="operator">&lt;-</span> rownames<span class="punctuation">(</span>df<span class="punctuation">)</span></span><br><span class="line">ggscatter<span class="punctuation">(</span>df<span class="punctuation">,</span> x <span class="operator">=</span> <span class="string">&quot;wt&quot;</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="string">&quot;mpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">          color <span class="operator">=</span> <span class="string">&quot;cyl&quot;</span><span class="punctuation">,</span> palette <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;#00AFBB&quot;</span><span class="punctuation">,</span> <span class="string">&quot;#E7B800&quot;</span><span class="punctuation">,</span> <span class="string">&quot;#FC4E07&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">          label <span class="operator">=</span> <span class="string">&quot;name&quot;</span><span class="punctuation">,</span> repel <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img src="2.png" alt=""></p>
<h1>折线图</h1>
<p>折线图比较简单，如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">df4 <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>sex<span class="operator">=</span>factor<span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;F&quot;</span><span class="punctuation">,</span><span class="string">&quot;M&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span>each<span class="operator">=</span><span class="number">10</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span>year <span class="operator">=</span> factor<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span>seq<span class="punctuation">(</span><span class="number">10</span><span class="punctuation">,</span><span class="number">19</span><span class="punctuation">)</span><span class="punctuation">,</span>seq<span class="punctuation">(</span><span class="number">10</span><span class="punctuation">,</span><span class="number">19</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> weight<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>rnorm<span class="punctuation">(</span><span class="number">10</span><span class="punctuation">,</span><span class="number">20</span><span class="punctuation">)</span><span class="punctuation">,</span>rnorm<span class="punctuation">(</span><span class="number">10</span><span class="punctuation">,</span><span class="number">40</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">ggline<span class="punctuation">(</span>df4<span class="punctuation">,</span> x<span class="operator">=</span><span class="string">&quot;year&quot;</span><span class="punctuation">,</span> y<span class="operator">=</span><span class="string">&quot;weight&quot;</span><span class="punctuation">,</span>  color <span class="operator">=</span> <span class="string">&quot;sex&quot;</span><span class="punctuation">,</span> </span><br><span class="line">       shape <span class="operator">=</span> <span class="string">&quot;sex&quot;</span><span class="punctuation">,</span> linetype<span class="operator">=</span><span class="string">&quot;sex&quot;</span><span class="punctuation">,</span> <span class="comment"># 设置点的形状，线的形状</span></span><br><span class="line">       position <span class="operator">=</span> position_dodge<span class="punctuation">(</span><span class="number">1.0</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># 避免点与点重叠在一块</span></span><br><span class="line">       palette <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;#00AFBB&quot;</span><span class="punctuation">,</span> <span class="string">&quot;#E7B800&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># 调色板</span></span><br><span class="line">       legend.title <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="comment"># 取消图例标题</span></span><br><span class="line">       legend<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.94</span><span class="punctuation">,</span><span class="number">0.18</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># 设置图例位置，手动调节</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img src="17.png" alt=""></p>
<h1>条形图</h1>
<p>条形图使用 <code>ggbarplot</code> 函数。</p>
<p>首先我们看一个简单的例子，按照纵坐标大小排序绘图。如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggbarplot<span class="punctuation">(</span>df<span class="punctuation">,</span> x<span class="operator">=</span><span class="string">&quot;name&quot;</span><span class="punctuation">,</span> y<span class="operator">=</span><span class="string">&quot;mpg&quot;</span><span class="punctuation">,</span> fill <span class="operator">=</span> <span class="string">&quot;cyl&quot;</span><span class="punctuation">,</span> color <span class="operator">=</span> <span class="string">&quot;white&quot;</span><span class="punctuation">,</span></span><br><span class="line">          palette <span class="operator">=</span> <span class="string">&quot;jco&quot;</span><span class="punctuation">,</span><span class="comment">#杂志jco的配色</span></span><br><span class="line">          sort.val <span class="operator">=</span> <span class="string">&quot;desc&quot;</span><span class="punctuation">,</span><span class="comment">#按照纵坐标大小下降排序</span></span><br><span class="line">          sort.by.groups<span class="operator">=</span><span class="literal">FALSE</span><span class="punctuation">,</span><span class="comment">#不按组排序</span></span><br><span class="line">          x.text.angle<span class="operator">=</span><span class="number">60</span><span class="punctuation">)</span> <span class="comment">#x坐标文字角度</span></span><br></pre></td></tr></table></figure>
<p><img src="3.png" alt=""></p>
<p>如果我们按组进行排序，则设置 <code>sort.by.groups=TRUE</code> ，如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggbarplot<span class="punctuation">(</span>df<span class="punctuation">,</span> x<span class="operator">=</span><span class="string">&quot;name&quot;</span><span class="punctuation">,</span> y<span class="operator">=</span><span class="string">&quot;mpg&quot;</span><span class="punctuation">,</span> fill <span class="operator">=</span> <span class="string">&quot;cyl&quot;</span><span class="punctuation">,</span> color <span class="operator">=</span> <span class="string">&quot;white&quot;</span><span class="punctuation">,</span></span><br><span class="line">          palette <span class="operator">=</span> <span class="string">&quot;jco&quot;</span><span class="punctuation">,</span><span class="comment">#杂志jco的配色</span></span><br><span class="line">          sort.val <span class="operator">=</span> <span class="string">&quot;desc&quot;</span><span class="punctuation">,</span><span class="comment">#按照纵坐标大小下降排序</span></span><br><span class="line">          sort.by.groups<span class="operator">=</span><span class="literal">TRUE</span><span class="punctuation">,</span><span class="comment">#按组排序</span></span><br><span class="line">          x.text.angle<span class="operator">=</span><span class="number">60</span><span class="punctuation">)</span> <span class="comment">#x坐标文字角度</span></span><br></pre></td></tr></table></figure>
<p><img src="4.png" alt=""></p>
<p>我们可以通过设置 <code>rotate=TRUE</code> 来翻转 X 轴和 Y 轴 (此时不用设置 <code>x.text.angle</code> ) 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ggbarplot(df, x=&quot;name&quot;, y=&quot;mpg&quot;, fill = &quot;cyl&quot;, color = &quot;white&quot;,</span><br><span class="line">          palette = &quot;jco&quot;,#杂志jco的配色</span><br><span class="line">          sort.val = &quot;desc&quot;,#按照纵坐标大小下降排序</span><br><span class="line">          sort.by.groups=TRUE,#按组排序</span><br><span class="line">          rotate=TRUE) </span><br></pre></td></tr></table></figure>
<p><img src="5.png" alt=""></p>
<h2 id="棒棒糖图">棒棒糖图</h2>
<p>棒棒图可以视为条形图的一种变体，用线条和点来替换了条形图中的长方形，如下。</p>
<p>这里 <code>ggdotchart</code> 函数默认就是画一个点图，因此必须设置 <code>add = &quot;segments&quot;</code> 在点图基础上添加棒子（柱状线条）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggdotchart<span class="punctuation">(</span>df<span class="punctuation">,</span> x<span class="operator">=</span><span class="string">&quot;name&quot;</span><span class="punctuation">,</span> y<span class="operator">=</span><span class="string">&quot;mpg&quot;</span><span class="punctuation">,</span> color <span class="operator">=</span> <span class="string">&quot;cyl&quot;</span><span class="punctuation">,</span> </span><br><span class="line">           palette <span class="operator">=</span> <span class="string">&quot;jco&quot;</span><span class="punctuation">,</span> sorting <span class="operator">=</span> <span class="string">&quot;desc&quot;</span><span class="punctuation">,</span></span><br><span class="line">           dot.size <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span> <span class="comment"># 点的大小</span></span><br><span class="line">           add <span class="operator">=</span> <span class="string">&quot;segments&quot;</span><span class="punctuation">,</span> <span class="comment"># 在点图基础上添加棒子（柱状线条）</span></span><br><span class="line">           add.params <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>color <span class="operator">=</span> <span class="string">&quot;cyl&quot;</span><span class="punctuation">,</span> size <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># 棒子的参数，颜色设置与点相同</span></span><br><span class="line">          <span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img src="6.png" alt=""></p>
<p>如果需要按组排序，则设置 <code>group = &quot;cyl&quot;</code> ，如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggdotchart<span class="punctuation">(</span>df<span class="punctuation">,</span> x<span class="operator">=</span><span class="string">&quot;name&quot;</span><span class="punctuation">,</span> y<span class="operator">=</span><span class="string">&quot;mpg&quot;</span><span class="punctuation">,</span> color <span class="operator">=</span> <span class="string">&quot;cyl&quot;</span><span class="punctuation">,</span> </span><br><span class="line">           palette <span class="operator">=</span> <span class="string">&quot;jco&quot;</span><span class="punctuation">,</span> sorting <span class="operator">=</span> <span class="string">&quot;desc&quot;</span><span class="punctuation">,</span></span><br><span class="line">           dot.size <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span> <span class="comment"># 点的大小</span></span><br><span class="line">           add <span class="operator">=</span> <span class="string">&quot;segments&quot;</span><span class="punctuation">,</span> <span class="comment"># 在点图基础上添加棒子（柱状线条）</span></span><br><span class="line">           add.params <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>color <span class="operator">=</span> <span class="string">&quot;cyl&quot;</span><span class="punctuation">,</span> size <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># 棒子的参数，颜色设置与点相同</span></span><br><span class="line">           group <span class="operator">=</span> <span class="string">&quot;cyl&quot;</span><span class="punctuation">,</span>  <span class="comment"># 按组排序</span></span><br><span class="line">          <span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img src="7.png" alt=""></p>
<p>如果需要在点上显示数值，则加上标签<code>label = round(df$mpg)</code> ，<code>font.label = list(color=&quot;white&quot;, size=9, vjust=0.5)</code> 这一句用于设置标签上的文字，这里的<code>vjust=0.5</code>就是使得标签文字出现在点的中心部位（参考<a href="https://blog.csdn.net/SThranduil/article/details/60572564">R语言 hjust = 0, vjust = 1属性设置</a>） 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ggdotchart(df, x=&quot;name&quot;, y=&quot;mpg&quot;, color = &quot;cyl&quot;, </span><br><span class="line">           palette = &quot;jco&quot;, sorting = &quot;desc&quot;,</span><br><span class="line">           dot.size = 6, # 点的大小</span><br><span class="line">           add = &quot;segments&quot;, # 在点图基础上添加棒子（柱状线条）</span><br><span class="line">           add.params = list(color = &quot;cyl&quot;, size = 0.5), # 棒子的参数，颜色设置与点相同</span><br><span class="line">           group = &quot;cyl&quot;,  # 按组排序</span><br><span class="line">           label = round(df$mpg), # 添加标签</span><br><span class="line">           font.label = list(color=&quot;white&quot;, size=9, vjust=0.5)) # 设置标签</span><br></pre></td></tr></table></figure>
<p><img src="8.png" alt=""></p>
<p>最后，你可以使用 <code>rotate = TRUE</code> 来翻转坐标轴，如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggdotchart<span class="punctuation">(</span>df<span class="punctuation">,</span> x<span class="operator">=</span><span class="string">&quot;name&quot;</span><span class="punctuation">,</span> y<span class="operator">=</span><span class="string">&quot;mpg&quot;</span><span class="punctuation">,</span> color <span class="operator">=</span> <span class="string">&quot;cyl&quot;</span><span class="punctuation">,</span> </span><br><span class="line">           palette <span class="operator">=</span> <span class="string">&quot;jco&quot;</span><span class="punctuation">,</span> sorting <span class="operator">=</span> <span class="string">&quot;desc&quot;</span><span class="punctuation">,</span></span><br><span class="line">           dot.size <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span> <span class="comment"># 点的大小</span></span><br><span class="line">           add <span class="operator">=</span> <span class="string">&quot;segments&quot;</span><span class="punctuation">,</span> <span class="comment"># 在点图基础上添加棒子（柱状线条）</span></span><br><span class="line">           add.params <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>color <span class="operator">=</span> <span class="string">&quot;cyl&quot;</span><span class="punctuation">,</span> size <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># 棒子的参数，颜色设置与点相同</span></span><br><span class="line">           group <span class="operator">=</span> <span class="string">&quot;cyl&quot;</span><span class="punctuation">,</span>  <span class="comment"># 按组排序</span></span><br><span class="line">           label <span class="operator">=</span> <span class="built_in">round</span><span class="punctuation">(</span>df<span class="operator">$</span>mpg<span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># 添加标签</span></span><br><span class="line">           font.label <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>color<span class="operator">=</span><span class="string">&quot;white&quot;</span><span class="punctuation">,</span> size<span class="operator">=</span><span class="number">9</span><span class="punctuation">,</span> vjust<span class="operator">=</span><span class="number">0.5</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># 设置标签</span></span><br><span class="line">           rotate <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span> <span class="comment"># 翻转坐标轴  </span></span><br></pre></td></tr></table></figure>
<p><img src="9.png" alt=""></p>
<h1>描述数据分布</h1>
<h2 id="直方图">直方图</h2>
<p>直方图比较简单，通过设置<code>rug = TRUE</code>可以添加<strong>边际地毯线</strong>，通过设置<code>add = &quot;mean&quot;</code> 可以添加均值线。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">df2 <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>sex<span class="operator">=</span>factor<span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;F&quot;</span><span class="punctuation">,</span><span class="string">&quot;M&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span>each<span class="operator">=</span><span class="number">200</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span>weight<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>rnorm<span class="punctuation">(</span><span class="number">200</span><span class="punctuation">,</span><span class="number">55</span><span class="punctuation">)</span><span class="punctuation">,</span>rnorm<span class="punctuation">(</span><span class="number">200</span><span class="punctuation">,</span><span class="number">58</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">gghistogram<span class="punctuation">(</span>df2<span class="punctuation">,</span> x<span class="operator">=</span><span class="string">&quot;weight&quot;</span><span class="punctuation">,</span>  color <span class="operator">=</span> <span class="string">&quot;sex&quot;</span><span class="punctuation">,</span> fill <span class="operator">=</span> <span class="string">&quot;sex&quot;</span><span class="punctuation">,</span> </span><br><span class="line">            add <span class="operator">=</span> <span class="string">&quot;mean&quot;</span><span class="punctuation">,</span> rug <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> <span class="comment"># 添加均值线和边际地毯</span></span><br><span class="line">            palette <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;#00AFBB&quot;</span><span class="punctuation">,</span> <span class="string">&quot;#E7B800&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># 调色板</span></span><br><span class="line">            bins <span class="operator">=</span> <span class="punctuation">(</span>nrow<span class="punctuation">(</span>df2<span class="punctuation">)</span><span class="operator">%/%</span><span class="number">10</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># 区间数目等于行数整除10</span></span><br><span class="line">            alpha <span class="operator">=</span> <span class="number">0.4</span><span class="punctuation">,</span> <span class="comment"># 设置透明度</span></span><br><span class="line">            legend.title <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="comment"># 取消图例标题</span></span><br><span class="line">            <span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img src="10.png" alt=""></p>
<h2 id="密度分布图">密度分布图</h2>
<p>密度分布图和直方图的设置基本一样，不多解释。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggdensity<span class="punctuation">(</span>df2<span class="punctuation">,</span> x<span class="operator">=</span><span class="string">&quot;weight&quot;</span><span class="punctuation">,</span>  color <span class="operator">=</span> <span class="string">&quot;sex&quot;</span><span class="punctuation">,</span> fill <span class="operator">=</span> <span class="string">&quot;sex&quot;</span><span class="punctuation">,</span> </span><br><span class="line">            add <span class="operator">=</span> <span class="string">&quot;mean&quot;</span><span class="punctuation">,</span> rug <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> <span class="comment"># 添加均值线和边际地毯</span></span><br><span class="line">            palette <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;#00AFBB&quot;</span><span class="punctuation">,</span> <span class="string">&quot;#E7B800&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># 调色板</span></span><br><span class="line">            alpha <span class="operator">=</span> <span class="number">0.4</span><span class="punctuation">,</span> <span class="comment"># 设置透明度</span></span><br><span class="line">            legend.title <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="comment"># 取消图例标题</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img src="11.png" alt=""></p>
<h2 id="箱线图">箱线图</h2>
<p>首先我们画一个正常的箱线图，如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data<span class="punctuation">(</span><span class="string">&quot;ToothGrowth&quot;</span><span class="punctuation">)</span></span><br><span class="line">df3 <span class="operator">&lt;-</span> ToothGrowth</span><br><span class="line"></span><br><span class="line">ggboxplot<span class="punctuation">(</span>df3<span class="punctuation">,</span> x<span class="operator">=</span><span class="string">&quot;dose&quot;</span><span class="punctuation">,</span> y<span class="operator">=</span><span class="string">&quot;len&quot;</span><span class="punctuation">,</span> color <span class="operator">=</span> <span class="string">&quot;dose&quot;</span><span class="punctuation">,</span></span><br><span class="line">          palette <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;#00AFBB&quot;</span><span class="punctuation">,</span> <span class="string">&quot;#E7B800&quot;</span><span class="punctuation">,</span> <span class="string">&quot;#FC4E07&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img src="12.png" alt=""></p>
<p>我们可以在箱线图上显示所有的数据点，如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">p <span class="operator">&lt;-</span> ggboxplot<span class="punctuation">(</span>df3<span class="punctuation">,</span> x<span class="operator">=</span><span class="string">&quot;dose&quot;</span><span class="punctuation">,</span> y<span class="operator">=</span><span class="string">&quot;len&quot;</span><span class="punctuation">,</span> color <span class="operator">=</span> <span class="string">&quot;dose&quot;</span><span class="punctuation">,</span></span><br><span class="line">          palette <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;#00AFBB&quot;</span><span class="punctuation">,</span> <span class="string">&quot;#E7B800&quot;</span><span class="punctuation">,</span> <span class="string">&quot;#FC4E07&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">          add <span class="operator">=</span> <span class="string">&quot;jitter&quot;</span><span class="punctuation">,</span> shape<span class="operator">=</span><span class="string">&quot;dose&quot;</span><span class="punctuation">,</span> <span class="comment"># 添加所有数据点，设置数据点的性状</span></span><br><span class="line">          <span class="punctuation">)</span></span><br><span class="line">p</span><br></pre></td></tr></table></figure>
<p><img src="13.png" alt=""></p>
<p>我们还可以进一步显示组间比较的 P 值，这里 <code>stat_compare_means(label.y = 50)</code> 这句应该是添加总的 P 值，通过 <code>label.y = 50</code> 设置其结果放在 <code>y=50</code> 的位置。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">my_comparisons <span class="operator">&lt;-</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;0.5&quot;</span><span class="punctuation">,</span> <span class="string">&quot;1&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span> <span class="string">&quot;2&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;0.5&quot;</span><span class="punctuation">,</span> <span class="string">&quot;2&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">p <span class="operator">+</span> stat_compare_means<span class="punctuation">(</span>comparisons <span class="operator">=</span> my_comparisons<span class="punctuation">)</span><span class="operator">+</span> stat_compare_means<span class="punctuation">(</span>label.y <span class="operator">=</span> <span class="number">50</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img src="14.png" alt=""></p>
<p>这里在 <code>stat_compare_means</code> 中添加 <code>label = &quot;p.signif&quot;</code> ，将显示的 p 值改为星号 。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">p <span class="operator">+</span> stat_compare_means<span class="punctuation">(</span>comparisons <span class="operator">=</span> my_comparisons<span class="punctuation">,</span> label <span class="operator">=</span> <span class="string">&quot;p.signif&quot;</span><span class="punctuation">)</span><span class="operator">+</span> stat_compare_means<span class="punctuation">(</span>label.y <span class="operator">=</span> <span class="number">50</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img src="16.png" alt=""></p>
<h2 id="小提琴图">小提琴图</h2>
<p>类似于箱线图，如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">p <span class="operator">&lt;-</span> ggviolin<span class="punctuation">(</span>df3<span class="punctuation">,</span> x<span class="operator">=</span><span class="string">&quot;dose&quot;</span><span class="punctuation">,</span> y<span class="operator">=</span><span class="string">&quot;len&quot;</span><span class="punctuation">,</span> fill <span class="operator">=</span> <span class="string">&quot;dose&quot;</span><span class="punctuation">,</span></span><br><span class="line">               palette <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;#00AFBB&quot;</span><span class="punctuation">,</span> <span class="string">&quot;#E7B800&quot;</span><span class="punctuation">,</span> <span class="string">&quot;#FC4E07&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">               add <span class="operator">=</span> <span class="string">&quot;boxplot&quot;</span><span class="punctuation">,</span> add.params<span class="operator">=</span><span class="built_in">list</span><span class="punctuation">(</span>fill<span class="operator">=</span><span class="string">&quot;white&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># 添加箱线图，设置箱线图填充颜色</span></span><br><span class="line">              <span class="punctuation">)</span></span><br><span class="line">p</span><br><span class="line">my_comparisons <span class="operator">&lt;-</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;0.5&quot;</span><span class="punctuation">,</span> <span class="string">&quot;1&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span> <span class="string">&quot;2&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;0.5&quot;</span><span class="punctuation">,</span> <span class="string">&quot;2&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">p <span class="operator">+</span> stat_compare_means<span class="punctuation">(</span>comparisons <span class="operator">=</span> my_comparisons<span class="punctuation">)</span><span class="operator">+</span> stat_compare_means<span class="punctuation">(</span>label.y <span class="operator">=</span> <span class="number">50</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img src="15.png" alt=""></p>
<h1>其它设置</h1>
<h2 id="标题及坐标轴设置">标题及坐标轴设置</h2>
<p>具体见 <code>ggpar()</code> 函数的说明文档，常见设置如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">p2 <span class="operator">&lt;-</span> ggpar<span class="punctuation">(</span>p<span class="punctuation">,</span></span><br><span class="line">            title <span class="operator">=</span> <span class="string">&quot;Box plot created with ggpubr&quot;</span><span class="punctuation">,</span> <span class="comment">#标题</span></span><br><span class="line">            subtitle <span class="operator">=</span> <span class="string">&quot;Length by dose&quot;</span><span class="punctuation">,</span>  <span class="comment">#副标题</span></span><br><span class="line">            xlab <span class="operator">=</span> <span class="string">&quot;Dose (mg)&quot;</span><span class="punctuation">,</span> <span class="comment"># 横坐标名称</span></span><br><span class="line">            ylab <span class="operator">=</span> <span class="string">&quot;Teeth length&quot;</span><span class="punctuation">,</span> <span class="comment"># 纵坐标名称</span></span><br><span class="line">            legend.title <span class="operator">=</span> <span class="string">&quot;Dose (mg)&quot;</span><span class="punctuation">,</span>  <span class="comment">#图例名称</span></span><br><span class="line">            legend <span class="operator">=</span> <span class="string">&#x27;right&#x27;</span><span class="punctuation">,</span>  <span class="comment">#图例位置</span></span><br><span class="line">            legend <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.95</span><span class="punctuation">,</span><span class="number">0.2</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment">#图例在图上的相对位置</span></span><br><span class="line">		<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h2 id="调色板">调色板</h2>
<p>调色板就是使用的颜色模板，常用的专业期刊调色板如下</p>
<blockquote>
<p>“npg”, “aaas”, “lancet”, “jco”, “ucscgb”, “uchicago”, “simpsons”,  “rickandmorty”</p>
</blockquote>
<h1>参考文献</h1>
<ol>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/33093479">https://zhuanlan.zhihu.com/p/33093479</a></p>
</li>
<li>
<p><a href="https://liuyang0681.github.io/2019/11/15/%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E5%8F%91%E8%A1%A8%E7%BA%A7%E5%9B%BE%E7%89%87ggplot2%E6%99%BA%E8%83%BD%E7%89%88ggpubr%E5%8C%85%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">https://liuyang0681.github.io/2019/11/15/快速绘制发表级图片ggplot2智能版ggpubr包学习总结/</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>R</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>R</tag>
        <tag>ggpubr</tag>
      </tags>
  </entry>
  <entry>
    <title>R包-rrBLUP</title>
    <url>/posts/8e8c3017/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>使用 rrBLUP 包计算 SNP 效用的方法。</p>
<span id="more"></span>
<h1>表型和基因型处理</h1>
<ol>
<li>
<p>表型文件中必须剔除存在缺失的行。</p>
</li>
<li>
<p>基因型质控填充，将位点编码必须为 {-1,0,1} 。</p>
</li>
<li>
<p>表型文件和基因型文件中的个体顺序必须保持一致（只能使用既有表型又有基因型的个体数据）。</p>
</li>
</ol>
<h1>求解</h1>
<p>这里我们主要用到的就是 <code>rrBLUP</code> 包中的 <code>mixed.solve</code> 函数，这里还可以手动填充固定效应（必须列满秩），用法如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mixed.solve<span class="punctuation">(</span>y<span class="punctuation">,</span> Z<span class="operator">=</span><span class="literal">NULL</span><span class="punctuation">,</span> K<span class="operator">=</span><span class="literal">NULL</span><span class="punctuation">,</span> X<span class="operator">=</span><span class="literal">NULL</span><span class="punctuation">,</span> method<span class="operator">=</span><span class="string">&quot;REML&quot;</span><span class="punctuation">,</span></span><br><span class="line">			bounds<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1e-09</span><span class="punctuation">,</span> <span class="number">1e+09</span><span class="punctuation">)</span><span class="punctuation">,</span> SE<span class="operator">=</span><span class="literal">FALSE</span><span class="punctuation">,</span> return.Hinv<span class="operator">=</span><span class="literal">FALSE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>参数：</p>
<p>y:  <img src="https://math.now.sh?inline=n%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 的表型向量，不能有缺失 （NA），必须与 X 和 Z 的行顺序保持一致。</p>
<p>Z: <img src="https://math.now.sh?inline=n%20%5Ctimes%20m" style="display:inline-block;margin: 0;"/> 的随机效应矩阵，如果不设置，默认为单位矩阵。</p>
<p>K: <img src="https://math.now.sh?inline=m%20%5Ctimes%20m" style="display:inline-block;margin: 0;"/> 的随机效应协方差矩阵，必须为半正定矩阵。如果不设置，默认为单位矩阵。</p>
<p>X: <img src="https://math.now.sh?inline=n%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的固定效应设计矩阵，如果不设置，则为 1 向量。<strong>X 必须为列满秩序矩阵</strong>。</p>
<p>method: “ML”, “REML”</p>
<p>bounds: 两个元素的数组，表明 ridge 参数的下限和上限。</p>
<p>SE ：如果 TRUE , 则计算标准误</p>
<p>return.Hinv: 如果 TRUE,  返回 reverse of  <img src="https://math.now.sh?inline=H%20%3D%20ZKZ'%20%2B%20%5Clambda%20I" style="display:inline-block;margin: 0;"/> ，这对 GWAS 有用。</p>
<p>正常来说，如果固定效应为均值，那么就只需要设置 y 和 Z (填充后的基因型矩阵，由**{-1,0,1}**构成)即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">out &lt;- mixed.solve(y, Z=marker)</span><br></pre></td></tr></table></figure>
<p>返回值如下， 其中我们需要的 <strong>snp 效应就是$u</strong>。</p>
<p><img src="1.png" alt="1"></p>
<h1>举例</h1>
<p>下面是一个实际应用的脚本例子。</p>
<p>这里的两个输入文件 <code>rrblup.phe</code> 与 <code>rrblup.raw</code> 是事先处理好的，二者中的个体顺序保持一致。 而 <code>rrblup.raw</code> 中的内容是通过 plink 软件的 <code>--recodeA</code> 选项生成的。</p>
<p>输出文件夹 <code>rrblup_results</code> 中的每一个文件表示一个结果，其中 <code>u.csv</code> 就是我们需要的 SNP 效应值。</p>
<p>经过手动比较，<code>rrBLUP</code> 和 <code>GBLUP</code> 计算得到的个体 GEBV 相关系数为 1， 没有问题。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行 rrblup</span></span><br><span class="line">library<span class="punctuation">(</span><span class="string">&quot;rrBLUP&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">raw_file <span class="operator">=</span> read.table<span class="punctuation">(</span><span class="string">&quot;rrblup.raw&quot;</span><span class="punctuation">,</span> header<span class="operator">=</span><span class="built_in">T</span><span class="punctuation">)</span></span><br><span class="line">phe_file <span class="operator">=</span> read.table<span class="punctuation">(</span><span class="string">&quot;rrblup.phe&quot;</span><span class="punctuation">,</span> header<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 表型</span></span><br><span class="line">y <span class="operator">=</span> phe_file<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基因型</span></span><br><span class="line">X <span class="operator">=</span> as.matrix<span class="punctuation">(</span>raw_file<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">7</span><span class="operator">:</span>ncol<span class="punctuation">(</span>raw_file<span class="punctuation">)</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">X <span class="operator">=</span> X <span class="operator">-</span><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rrblup</span></span><br><span class="line">out <span class="operator">&lt;-</span> mixed.solve<span class="punctuation">(</span>y<span class="punctuation">,</span> Z<span class="operator">=</span>X<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">dir.create<span class="punctuation">(</span><span class="string">&quot;rrblup_results&quot;</span><span class="punctuation">,</span> showWarnings <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span> </span><br><span class="line">setwd<span class="punctuation">(</span><span class="string">&quot;rrblup_results&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span>i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="built_in">length</span><span class="punctuation">(</span>out<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">    list_name <span class="operator">=</span> <span class="built_in">names</span><span class="punctuation">(</span>out<span class="punctuation">)</span><span class="punctuation">[</span>i<span class="punctuation">]</span></span><br><span class="line">    out_file_name <span class="operator">=</span> paste0<span class="punctuation">(</span>list_name<span class="punctuation">,</span><span class="string">&quot;.csv&quot;</span><span class="punctuation">)</span>   </span><br><span class="line">    write.csv<span class="punctuation">(</span>out<span class="punctuation">[</span>i<span class="punctuation">]</span><span class="punctuation">,</span>file<span class="operator">=</span>out_file_name<span class="punctuation">,</span><span class="built_in">quote</span> <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> row.names<span class="operator">=</span><span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据分析</category>
        <category>R</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>R</tag>
        <tag>rrBLUP</tag>
      </tags>
  </entry>
  <entry>
    <title>参考基因组下载及illumina芯片注释文件下载方法</title>
    <url>/posts/3a38b14d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>从 Ensembl 和 NCBI 下载参考基因组，以及下载 illumina 芯片的注释文件的教程。</p>
<span id="more"></span>
<h1>Ensembl 基因组下载方法</h1>
<p>首先进入到  <a href="http://ensembl.org/index.html">Ensembl</a> 官网，如果是植物则进入 <a href="https://plants.ensembl.org/index.html">plants.ensembl</a> 。</p>
<p>这里我们以猪的 11.1 版本为例，看看如何下载其参考基因组文件，进入官网后，点击下图中的 <code>view full list of all species</code> 。</p>
<p><img src="3.png" alt="1"></p>
<p>在下一个页面中，在下图的窗口中输入 pig （拉丁文应该也可以），得到以下结果。这里第三个就是我们想要的，点进去。</p>
<p><img src="4.png" alt="1"></p>
<p>进入下面的页面，左上角标注的部分已经告诉你这是猪的 11.1 版本的参考基因组，点击右下红框处下载 FASTA 文件和其它基因组注释文件。</p>
<p>一般 Ensembl 显示的都是最新的参考基因组版本，如果你要查找一些旧版本的参考基因组，图中左下方的红框就是其它可用的参考基因组，比如这里就是 10.2 版本的参考基因组。</p>
<p><img src="5.png" alt="1"></p>
<p>假设你点了下载 FASTA 的链接，在下一个页面中你会看到一堆的 FASTA 压缩文件，一般我们就是下载红框中的文件，其后缀就是 <code>dna.toplevel.fa.gz</code> 。</p>
<p>在这个文件夹的上面的一堆文件实际是每条染色体的文件，这个文件是所有染色体汇总的文件。</p>
<p><img src="6.png" alt="1"></p>
<p>但是你往下拉的话，你还能看到后缀为 <code>dna_rm.toplevel.fa.gz</code> 和 <code>dna_sm.toplevel.fa.gz</code> ，这几个文件有什么区别呢？</p>
<p>这三者的区别主要在于对重复序列的处理不同，如下：</p>
<ul>
<li>’dna’ - unmasked genomic DNA sequences.</li>
<li>‘dna_rm’ - masked genomic DNA 。通过RepeatMasker软件检测弥散的重复序列和低复杂度的区域，并将重复序列使用N替代。</li>
<li>‘dna_sm’ - soft-masked genomic DNA 。指Soft-masked的DNA序列，其中的重复序列和低复杂度的区域会用其相应碱基的小写字母来表示</li>
</ul>
<h1>NCBI 基因组下载方法</h1>
<p>首先进入到 <a href="https://www.ncbi.nlm.nih.gov/">NCBI</a> 官网，在坐标的复选框中选择 Assembly ，然后右边框中输入物种名称，还是以猪为例，输入 pig （拉丁文更好）。</p>
<p><img src="7.png" alt="1"></p>
<p>在上面的搜索结果中，找到相应的参考基因组版本，比如我们这里第一个就是 11.1 版本的参考基因组，点进去。</p>
<p><img src="8.png" alt="1"></p>
<p>然后点击右侧的 <code>FTP directory for RefSeq assembly</code>，进入FTP下载界面。</p>
<p><img src="9.png" alt="1"></p>
<p>还是在这个页面，往下拉，你可以得到 NCBI 中 RefSeq 中的序列名称与染色体的对应关系，因此下面在FTP下载界面下载的文件中染色体名称用的都是 RefSeq 中的序列名称，需要用到这个对应关系改回正常的染色体。</p>
<p><img src="11.png" alt="1"></p>
<p>在FTP下载界面，其中 <code>genomic.fna.gz</code> 就是相应的 FASTA 文件， <code>genomic.gff.gz</code> 就是相应的 GFF3 文件。</p>
<p><img src="10.png" alt="1"></p>
<h1>利用 Filezilla 下载参考基因组</h1>
<p>进入 Filezilla 官网，下载软件 Filezilla 。</p>
<p>打开Filezilla，在主机添加 ftp地址， ncbi 和 ensembl 的 ftp 地址如下。其它均不用填写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#例如ncbi的ftp地址为:</span><br><span class="line">ftp://ftp.ncbi.nlm.nih.gov/</span><br><span class="line">#ensembl的ftp地址为：</span><br><span class="line">ftp://ftp.ensembl.org/pub/</span><br><span class="line">#ensembl植物地址</span><br><span class="line">ftp://ftp.ensemblgenomes.org/pub/</span><br></pre></td></tr></table></figure>
<p>然后你就可以像windows系统的资源管理器一样，用这种文件夹的方式查找文件。找到了需要的文件后，直接拖拽到本地就会自动下载。</p>
<p>但是我发现有些时候 Filezilla 下载的文件是不完整的，所以用这种方式下载后最好还是通过 md5 校验一下下载的文件有无问题。</p>
<h1>查找 illumina 芯片的注释文件</h1>
<p>进入<a href="https://www.illumina.com.cn/products/selection-tools/gene-panel-finder.html#/">illumina官网</a> (貌似现在进不去了)，一步步查找。</p>
<p>进入某个芯片的主页后，点击 <a href="https://support.illumina.com/array/array_kits/bovinesnp50-beadchip-kit/downloads.html">View Manifest (Array Content) Files</a> 。我估计这个 <code>Manifest</code> 就是注释文件的意思。</p>
<p>在下一个页面，选择相应的注释文件下载。</p>
<p><img src="2.png" alt="1"></p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>生物信息</category>
      </categories>
  </entry>
  <entry>
    <title>测序技术基础知识学习</title>
    <url>/posts/d6ae1355/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>学习一代测序和二代测序的基础原理。</p>
<span id="more"></span>
<h1>一代测序 - Sanger 测序</h1>
<p><a href="https://zhuanlan.zhihu.com/p/75408383">https://zhuanlan.zhihu.com/p/75408383</a></p>
<p>采用 ddNTP，均不含羟基，如果合成了一个 ddNTP之后，DNA合成过程就中止了。</p>
<p>一代测序需要4个 DNA 合成反应体系（A C G T 各一个），原理如下图</p>
<p><img src="1.jpg" alt="1"></p>
<p>优点：</p>
<ul>
<li>测序读长可达1,000bp</li>
<li>准确性高达99.999%</li>
</ul>
<p>缺点：</p>
<ul>
<li>成本高</li>
<li>通量低</li>
</ul>
<h1>二代测序</h1>
<p><a href="https://zhuanlan.zhihu.com/p/20702684">https://zhuanlan.zhihu.com/p/20702684</a></p>
<p>优酷视频</p>
<p><a href="https://v.youku.com/v_show/id_XNzEzNzk1NTA0.html">https://v.youku.com/v_show/id_XNzEzNzk1NTA0.html</a></p>
<p>二代测序目前的主流是 illumina 测序</p>
<h2 id="建库">建库</h2>
<p>由于Illumina测序策略本身的问题，导致其测序长度不可能太长。</p>
<p>所谓的建库就是把基因组打断成一定长度的片段。</p>
<p>打断后，补齐末端，然后再3‘段添加一个碱基A，之后再加上 adapter</p>
<h2 id="桥式PCR">桥式PCR</h2>
<p>这个看视频更形象一点。</p>
<p>最终就是在 flowcell 中 形成了一个具有完全相同序列的簇，一般叫 cluster</p>
<h2 id="测序">测序</h2>
<p>这个也是看视频更形象一点。</p>
<p>它是边合成，边测序。</p>
<p>它用于测序的碱基有两个特殊的地方，一是脱氧核糖3号位加入了叠氮基团而不是常规的羟基，类似于一代测序的ddNTP，保证一次只能添加一个碱基；二是碱基部分添加了荧光基团，不同的碱基有不同的颜色。</p>
<p>在测序过程中，每1轮测序，保证只有1个碱基加入的当前测序链。这时候测序仪会发出激发光，并扫描荧光。因为一个cluster中所有的序列是一样的，所以理论上，这时候cluster中发出的荧光应该颜色一致。一个测序扫描图片如下：</p>
<p><img src="2.jpg" alt="1"></p>
<p>然后洗脱多余的没有附着上的脱氧核糖和聚合酶，加入特殊试剂，将脱氧核糖3号位的—N2改变成—OH，然后切掉部分荧光基团，使其在下一轮反应中，不再发出荧光。</p>
<p>如此反复，测出所有reads每个位置的序列。</p>
<h2 id="为什么Illumina测序会有长度限制呢">为什么Illumina测序会有长度限制呢</h2>
<blockquote>
<ol>
<li>测序时，经过长时间的PCR，会有不同步的情况。通俗一点讲，比如一开始1个cluster中是100个完全一样的DNA链，但是经过1轮增加碱基，其中99个都加入了1个碱基，显示了红色，另外1个没有加入碱基，不显示颜色。这时候整体为红色，我们可以顺利得到结果。随后，在第2轮再加入碱基进行合成的时候，就变成了，之前没有加入的加入了1个碱基显示红色，剩下的99个显示绿色，这个时候就会出现杂信号。当测序长度不断延长，这个杂信号会越来越多，最后很有可能出现，50个红，50个绿色，这时候我们判断不出来到底是什么碱基被合成。</li>
<li>测序过程中，使用的碱基是特殊处理的，有一个非常大的荧光基团修饰。在使用DNA ploymerase的时候，酶的状态也会受到底物的影响，越来越差。</li>
</ol>
</blockquote>
<p>这一方面应该也说明了，每条 read 最开始的分型质量是最好的，越往后质量越差。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>生物信息</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>生物信息</tag>
        <tag>测序技术</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Colleau算法构建A22矩阵</title>
    <url>/posts/d4853f4c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在 ssGBLUP 中需要构建 A22 矩阵，通过 Colleau 算法可以避免直接构建 A 矩阵，节约内存和时间。</p>
<span id="more"></span>
<h1>A 阵分解</h1>
<p>我们可以将 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 分解为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%3D%20%5Cmathbf%7B%28I-P%29%5E%7B-1%7DD(I-P)%5E%7B-1%5Cprime%7D%7D" style="display:inline-block;margin: 0;"/> （要求系谱按照出生日期顺序排序）。</p>
<p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D" style="display:inline-block;margin: 0;"/> 是一个对角矩阵，其元素计算公式如下，其中 <img src="https://math.now.sh?inline=F_%7Bi%7D" style="display:inline-block;margin: 0;"/> 是近交系数。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AD_%7Bii%7D%20%26%20%20%3D%200.5%20-%200.25%28F_%7Bs_%7Bi%7D%7D%20%2B%20F_%7Bd_%7Bi%7D%7D%29%20%5Cquad%20%5Ctext%7B%E5%BD%93%20i%20%E7%9A%84%E7%88%B6%E6%AF%8D%E5%9D%87%E5%B7%B2%E7%9F%A5%7D%5C%5C%0A%26%20%20%3D%200.75%20-%200.25%20F_%7Bp_%7Bi%7D%7D%20%20%5Cquad%20%5Ctext%7B%E5%BD%93%20i%20%E7%9A%84%E5%8D%95%E4%B8%AA%E4%BA%B2%E6%9C%AC%E5%B7%B2%E7%9F%A5%7D%5C%5C%0A%26%20%3D%201%20%5Cquad%20%5Ctext%7B%E5%BD%93%20i%20%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%BA%B2%E6%9C%AC%E5%9D%87%E6%9C%AA%E7%9F%A5%7D%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D" style="display:inline-block;margin: 0;"/> 是一个下三角矩阵，对角线元素为 0，非对角线只有亲子间为 0.5，其余元素也为 0 。</p>
<p><img src="https://math.now.sh?inline=%5Cmathbf%7BI-P%7D" style="display:inline-block;margin: 0;"/> 矩阵举例如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccccc%7D%0A1%20%26%20%26%20%26%20%26%20%26%20%5C%5C%0A0%20%26%201%20%26%20%26%20%26%20%5C%5C%0A-0.5%20%26%200%20%26%201%20%26%20%26%20%5C%5C%0A-0.5%20%26%20-0.5%20%26%200%20%26%201%20%26%20%5C%5C%0A0%20%26%200%20%26%20-0.5%20%26%20-0.5%20%26%201%20%26%20%5C%5C%0A-0.5%20%26%200%20%26%200%20%26%20-0.5%20%26%200%20%26%201%20%5C%5C%0A0%20%26%200%20%26%200%20%26%200%20%26%20-0.5%20%26%20-0.5%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><h1>Colleau 算法</h1>
<p>Colleau (2002) 年证明 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵与一个向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Bt%7D" style="display:inline-block;margin: 0;"/> 的乘积可以在一个线性的时间内计算完成，如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bv%7D%20%3D%20%5Cmathbf%7BAt%7D%20%3D%20%5Cmathbf%7B%28I-P%29%5E%7B-1%7DD%5B(I-P)%5E%7B-1%5Cprime%7Dt%5D%7D%0A" /></p><p>这里我们可以分步骤进行计算：</p>
<ul>
<li>
<p>首先我们定义 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%20%3D%20%5Cmathbf%7B%28I-P%29%5E%7B-1%5Cprime%7Dt%7D" style="display:inline-block;margin: 0;"/> ，转换一下我们可以通过求解三角方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7B%28I-P%29%5E%7B%5Cprime%7Dr%3Dt%7D" style="display:inline-block;margin: 0;"/> 得到 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D" style="display:inline-block;margin: 0;"/> 。</p>
</li>
<li>
<p>然后我们得到 <img src="https://math.now.sh?inline=%5Cmathbf%7Bv%7D%20%3D%20%20%5Cmathbf%7B%28I-P%29%5E%7B-1%7DDr%7D" style="display:inline-block;margin: 0;"/> ，转换一下我们可以通过求解三角方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7B%28I-P%29v%3DDr%7D" style="display:inline-block;margin: 0;"/> 得到 <img src="https://math.now.sh?inline=%5Cmathbf%7Bv%7D" style="display:inline-block;margin: 0;"/> 。</p>
</li>
</ul>
<p>标量公式如下（第一行是采用 <strong>outer-product</strong> 的原理；第二行是采用向量内积的原理）</p>
<p style=""><img src="https://math.now.sh?from=r_%7Bi%7D%20%3D%20r_%7Bi%7D%2Bt_%7Bi%7D%3B%20%5Cquad%20r_%7Bsi%7D%20%3D%20r_%7Bsi%7D%20%2B%20r_%7Bi%7D%2F2%3B%20%5Cquad%20r_%7Bdi%7D%20%3D%20r_%7Bdi%7D%20%2B%20r_%7Bi%7D%2F2%3B%20%5Cquad%20i%3Dn%2C%5Ccdots%2C1%0A" /></p><p style=""><img src="https://math.now.sh?from=v_%7Bi%7D%20%3D%20d_%7Bi%7Dr_%7Bi%7D%2B%20%28v_%7Bsi%7D%2Bv_%7Bdi%7D%29%2F2%2C%20%5Cquad%20i%20%3D%201%2C%5Ccdots%2Cn%0A" /></p><p>这里的 <img src="https://math.now.sh?inline=si" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=di" style="display:inline-block;margin: 0;"/> 表示个体 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 的父母本。</p>
<p>通过 Colleau 算法可以用于计算子矩阵，举个例子，下面展示了如何计算 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B11%7D%5Cmathbf%7Bq%7D" style="display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B21%7D%5Cmathbf%7Bq%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BA%7D_%7B11%7D%20%26%20%5Cmathbf%7BA%7D_%7B12%7D%20%5C%5C%0A%5Cmathbf%7BA%7D_%7B21%7D%20%26%20%5Cmathbf%7BA%7D_%7B22%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%0A%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7Bq%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%0A%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BA%7D_%7B11%7D%20%5Cmathbf%7Bq%7D%20%5C%5C%0A%5Cmathbf%7BA%7D_%7B21%7D%20%5Cmathbf%7Bq%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><h1>构建 A22 矩阵</h1>
<p>这里需要注意的是，构建 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵时是按照出生日期顺序排序，但是我们提取A22 矩阵要求按照无基因型个体在前，有基因型个体在后的顺序排列，因此我们还要对原始的 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵的行和列进行重新重排。我们设相应的置换矩阵为 <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D" style="display:inline-block;margin: 0;"/> ，重排后按照无基因型个体在前，有基因型个体在后的顺序的矩阵称为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 矩阵，则有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%5E%7B*%7D%20%3D%20%5Cmathbf%7BQAQ%5E%7B%5Cprime%7D%7D%20%3D%20%5Cmathbf%7BQ%28I-P%29%5E%7B-1%7DD(I-P)%5E%7B-1%5Cprime%7DQ%5E%7B%5Cprime%7D%7D%0A" /></p><p>此时我们逐列提取 A22 矩阵的每一列，举个例子，假如基因型个体在 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 矩阵中的位置是 80 到 100，那么我们构建第一个 <img src="https://math.now.sh?inline=%5Cmathbf%7Bt%7D" style="display:inline-block;margin: 0;"/> 向量就是在 80位置为1，其它位置为0；构建第二个 <img src="https://math.now.sh?inline=%5Cmathbf%7Bt%7D" style="display:inline-block;margin: 0;"/> 向量就是在 81位置为1，其它位置为0 …以此类推。</p>
<p>通过  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B*%7D%5Cmathbf%7Bt%7D" style="display:inline-block;margin: 0;"/> 便可以得到 A22 矩阵个体的一列，其计算公式为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bv%7D%5E%7B*%7D%20%3D%20%5Cmathbf%7BA%7D%5E%7B*%7D%5Cmathbf%7Bt%7D%20%3D%20%5Cmathbf%7BQ%28I-P%29%5E%7B-1%7DD(I-P)%5E%7B-1%5Cprime%7DQ%5E%7B%5Cprime%7Dt%7D%0A" /></p><p>这里我们可以同样分步骤进行计算：</p>
<ul>
<li>
<p>首先计算 <img src="https://math.now.sh?inline=%5Cmathbf%7Bt%7D%5E%7B*%7D%20%3D%20%5Cmathbf%7BQ%5E%7B%5Cprime%7Dt%7D" style="display:inline-block;margin: 0;"/></p>
</li>
<li>
<p>我们定义 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%20%3D%20%5Cmathbf%7B%28I-P%29%5E%7B-1%5Cprime%7Dt%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> ，转换一下我们可以通过求解三角方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7B%28I-P%29%5E%7B%5Cprime%7Dr%3Dt%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> 得到 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D" style="display:inline-block;margin: 0;"/> 。</p>
</li>
<li>
<p>然后我们得到 <img src="https://math.now.sh?inline=%5Cmathbf%7Bv%7D%20%3D%20%20%5Cmathbf%7B%28I-P%29%5E%7B-1%7DDr%7D" style="display:inline-block;margin: 0;"/> ，转换一下我们可以通过求解三角方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7B%28I-P%29v%3DDr%7D" style="display:inline-block;margin: 0;"/> 得到 <img src="https://math.now.sh?inline=%5Cmathbf%7Bv%7D" style="display:inline-block;margin: 0;"/> 。</p>
</li>
<li>
<p>然后我们通过 <img src="https://math.now.sh?inline=%5Cmathbf%7Bv%7D%5E%7B*%7D%20%3D%20%5Cmathbf%7BQv%7D" style="display:inline-block;margin: 0;"/> 得到 <img src="https://math.now.sh?inline=%5Cmathbf%7Bv%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 。</p>
</li>
</ul>
<p>最后这里得到的 <img src="https://math.now.sh?inline=%5Cmathbf%7Bv%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 还包含一些无关元素，按照上例，还需要从  <img src="https://math.now.sh?inline=%5Cmathbf%7Bv%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 提取从 80 到 100 的位置的元素，这才是真正的 A22 矩阵的一列元素。</p>
<h1>参考文献</h1>
<ol>
<li>
<p>Colleau J J. An indirect approach to the extensive calculation of relationship coefficients[J]. Genetics Selection Evolution, 2002, 34(4): 409.</p>
</li>
<li>
<p>Misztal I, Aguilar I, Legarra A, et al. A unified approach to utilize phenotypic, full pedigree, andgenomic information for genetic evaluation[C]//9. World Congress on Genetics Applied to Livestock Production. 2010.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>STR个体识别指标</title>
    <url>/posts/dafd850d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>利用微卫星标记 (STR) 可以进行个体识别的指标介绍。</p>
<span id="more"></span>
<h1>个体识别能力</h1>
<p>个体识别能力 (discrimination power, DP) 是指<strong>针对某个遗传标记</strong>，从调查群体中随机抽取两个个体，两个个体的基因型不相同的概率，是衡量遗传标记系统识别不同个体效能大小的指标，常见计算公式如下：</p>
<p style=""><img src="https://math.now.sh?from=DP%20%3D%201-%20Pm%20%3D%201%20-%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20f_%7Bi%7D%5E%7B2%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> 为基因型数目，<img src="https://math.now.sh?inline=f_%7Bi%7D" style="display:inline-block;margin: 0;"/> 是第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 个基因型的频率，<img src="https://math.now.sh?inline=Pm" style="display:inline-block;margin: 0;"/>（probability of matching,  <strong>随机匹配概率</strong>） 是指调查群体中随机抽取两个无关个体在某一个基因座上二者表型纯粹由于机会而一致的概率（定义与 DP 相反，二者之和为 1）。</p>
<p>如果我们假设哈温平衡，那么个体识别能力也可以基于等位基因频率进行计算，纯合子的 <img src="https://math.now.sh?inline=Pm" style="display:inline-block;margin: 0;"/> 值为 <img src="https://math.now.sh?inline=%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%28p_%7Bi%7D%5E%7B2%7D%29%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，杂合子的  <img src="https://math.now.sh?inline=Pm" style="display:inline-block;margin: 0;"/> 值为 <img src="https://math.now.sh?inline=%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Csum_%7Bj%3Di%2B1%7D%5E%7Bn%7D%282p_%7Bi%7Dp_%7Bj%7D%29%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，因此我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0ADP%20%26%3D%201%20-%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%28p_%7Bi%7D%5E%7B2%7D%29%5E%7B2%7D%20-%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Csum_%7Bj%3Di%2B1%7D%5E%7Bn%7D(2p_%7Bi%7Dp_%7Bj%7D)%5E%7B2%7D%20%5C%5C%0A%26%3D%201-2%20%5Ctimes%20%5Cleft(%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20p_%7Bi%7D%5E%7B2%7D%5Cright)%5E%7B2%7D%20%2B%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20p_%7Bi%7D%5E%7B4%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>上面的公式是对于单个遗传标记而言的，对于一组遗传标记，其累积个体识别能力 (total discrimination power, TDP)  计算公式如下</p>
<p style=""><img src="https://math.now.sh?from=TDP%20%3D%201%20-%20%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%281-DP_%7BK%7D%29%0A" /></p><p>其中 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 为标记数目。</p>
<p>相似的，我们定义累积匹配概率 (cumulative match probability, CPM) 如下</p>
<p style=""><img src="https://math.now.sh?from=CPM%20%3D%20%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%281-DP_%7BK%7D%29%0A" /></p><h1>似然率计算</h1>
<p>个体识别的似然率，或者称为似然比（likelihood ratio, LR）计算公式如下</p>
<p style=""><img src="https://math.now.sh?from=LR%20%3D%20%5Cfrac%7BPr%28E%7CHp%29%7D%7BPr(E%7CHd)%7D%0A" /></p><p>这里 E 表示出现这个个体基因型的事件，Hp 表示是同一个个体的假设，Hd 表示是随机个体的假设。</p>
<p>例如，我们假设现场血痕DNA和一名嫌疑人血样DNA表型组合均为E，如果是同一个人的话，那么出现这种事件的概率就为1，即 <img src="https://math.now.sh?inline=Pr%28E%7CHp%29%20%3D%201" style="display:inline-block;margin: 0;"/> ；如果是随机个体偶然基因型完全一样，这种概率 <img src="https://math.now.sh?inline=Pr%28E%7CHd%29%20%3D%20CPM" style="display:inline-block;margin: 0;"/> ，因此我们得到似然比的实际计算公式为</p>
<p style=""><img src="https://math.now.sh?from=LR%20%3D%20%5Cfrac%7B1%7D%7BCPM%7D%0A" /></p><p>统计学上似然比超过 1 则支持假设 <img src="https://math.now.sh?inline=Hp" style="display:inline-block;margin: 0;"/> ，反之则支持假设 <img src="https://math.now.sh?inline=Hd" style="display:inline-block;margin: 0;"/> 。在法医学个体识别实践 中，当LR在数值上超过全球人口总数时，表明证据有足够强度支持原告假设（Hp）。</p>
<h1>鉴定意见</h1>
<ul>
<li>如果存在分型不一致，则判定为“排除两者来自同一个体”</li>
<li>如果<strong>分型完全一致</strong>，则进一步计算 LR ，鉴定意见可表述为“支持两者来源于同一个体，LR 值为 XXX”。</li>
</ul>
<h1>参考文献</h1>
<ol>
<li>
<p>SF/Z JD0105012——2018 《个体识别技术规范》</p>
</li>
<li>
<p>SF/Z JD0105010——2018 《常染色体 STR 基因座的法医学参数计算规范》</p>
</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>亲子鉴定</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>个体识别</tag>
      </tags>
  </entry>
  <entry>
    <title>方差组分估计方法五之AI-REML</title>
    <url>/posts/ca519947/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这是方差组分估计方法的第五篇博客，也是最后一篇，介绍 AI-REML 算法。</p>
<span id="more"></span>
<h1>AI-REML</h1>
<p>首先我们看 Newton-Raphson 算法，其迭代公式为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Ctheta%7D%5E%7B%28t%2B1%29%7D%3D%5Cboldsymbol%7B%5Ctheta%7D%5E%7B(t)%7D-%5Cleft(%5Cmathbf%7BH%7D%5E%7B(t)%7D%5Cright)%5E%7B-1%7D%20%5Cfrac%7B%5Cpartial%20L%7D%7B%5Cpartial%20%5Cboldsymbol%7B%5Ctheta%7D%7D%20%5Cmid%20%5Cboldsymbol%7B%5Ctheta%7D%5E%7B(t)%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=L" style="display:inline-block;margin: 0;"/> 是需要最大化的原函数；<img src="https://math.now.sh?inline=%5Cfrac%7B%5Cpartial%20L%7D%7B%5Cpartial%20%5Cboldsymbol%7B%5Ctheta%7D%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=L" style="display:inline-block;margin: 0;"/> 函数关于参数 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Ctheta%7D" style="display:inline-block;margin: 0;"/> 的一阶偏导数向量；  <img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=L" style="display:inline-block;margin: 0;"/> 函数关于参数 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Ctheta%7D" style="display:inline-block;margin: 0;"/> 的二阶偏导数矩阵，即 Hessian 矩阵，举例如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7BH%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cfrac%7B%5Cpartial%5E%7B2%7D%20L%7D%7B%5Cpartial%20%5Ctheta_%7B1%7D%5E%7B2%7D%7D%20%26%20%5Cfrac%7B%5Cpartial%5E%7B2%7D%20L%7D%7B%5Cpartial%20%5Ctheta_%7B1%7D%20%5Cpartial%20%5Ctheta_%7B2%7D%7D%20%26%20%5Ccdots%20%26%20%5Cfrac%7B%5Cpartial%5E%7B2%7D%20L%7D%7B%5Cpartial%20%5Ctheta_%7B1%7D%20%5Cpartial%20%5Ctheta_%7Bk%7D%7D%20%5C%5C%0A%5Cfrac%7B%5Cpartial%5E%7B2%7D%20L%7D%7B%5Cpartial%20%5Ctheta_%7B1%7D%20%5Cpartial%20%5Ctheta_%7B2%7D%7D%20%26%20%5Cfrac%7B%5Cpartial%5E%7B2%7D%20L%7D%7B%5Cpartial%20%5Ctheta_%7B2%7D%5E%7B2%7D%7D%20%26%20%5Ccdots%20%26%20%5Cfrac%7B%5Cpartial%5E%7B2%7D%20L%7D%7B%5Cpartial%20%5Ctheta_%7B2%7D%20%5Cpartial%20%5Ctheta_%7Bk%7D%7D%20%5C%5C%0A%5Cvdots%20%26%20%5Cvdots%20%26%20%26%20%5Cvdots%20%5C%5C%0A%5Cfrac%7B%5Cpartial%5E%7B2%7D%20L%7D%7B%5Cpartial%20%5Ctheta_%7B1%7D%20%5Cpartial%20%5Ctheta_%7Bk%7D%7D%20%26%20%5Cfrac%7B%5Cpartial%5E%7B2%7D%20L%7D%7B%5Cpartial%20%5Ctheta_%7B2%7D%20%5Cpartial%20%5Ctheta_%7Bk%7D%7D%20%26%20%5Ccdots%20%26%20%5Cfrac%7B%5Cpartial%5E%7B2%7D%20L%7D%7B%5Cpartial%20%5Ctheta_%7Bk%7D%5E%7B2%7D%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>由于计算 <img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D" style="display:inline-block;margin: 0;"/> 矩阵的计算量较大，scoring 方法采用以下迭代公式，即采用  <img src="https://math.now.sh?inline=%5Cmathbf%7BF%7D" style="display:inline-block;margin: 0;"/> 矩阵替换  <img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D" style="display:inline-block;margin: 0;"/> 矩阵。 <img src="https://math.now.sh?inline=%5Cmathbf%7BF%7D" style="display:inline-block;margin: 0;"/> 矩阵是  <img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D" style="display:inline-block;margin: 0;"/> 矩阵的数学期望，即 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BF%7D%3DE%28%5Cboldsymbol%7BH%7D%29" style="display:inline-block;margin: 0;"/> ；  <img src="https://math.now.sh?inline=-%20%5Cmathbf%7BF%7D" style="display:inline-block;margin: 0;"/> 矩阵则称为 Fisher 信息矩阵</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Ctheta%7D%5E%7B%28t%2B1%29%7D%3D%5Cboldsymbol%7B%5Ctheta%7D%5E%7B(t)%7D-%5Cleft(%5Cmathbf%7BF%7D%5E%7B(t)%7D%5Cright)%5E%7B-1%7D%20%5Cfrac%7B%5Cpartial%20L%7D%7B%5Cpartial%20%5Cboldsymbol%7B%5Ctheta%7D%7D%20%5Cmid%20%5Cboldsymbol%7B%5Ctheta%7D%5E%7B(t)%7D%0A" /></p><p>所谓平均信息算法，就是将期望信息 (<img src="https://math.now.sh?inline=-%20%5Cmathbf%7BF%7D" style="display:inline-block;margin: 0;"/>) 和观察信息 (<img src="https://math.now.sh?inline=-%20%5Cmathbf%7BH%7D" style="display:inline-block;margin: 0;"/>) 平均起来，得到一个平均信息矩阵</p>
<p style=""><img src="https://math.now.sh?from=A%20%5Cboldsymbol%7BI%7D%3D%5Cfrac%7B-%5Cboldsymbol%7BF%7D%2B%28-%5Cboldsymbol%7BH%7D%29%7D%7B2%7D%0A" /></p><p>此时相应的迭代公式为</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Ctheta%7D%5E%7B%28t%2B1%29%7D%3D%5Cboldsymbol%7B%5Ctheta%7D%5E%7B(t)%7D%2B%5Cleft(%5Cmathbf%7BAI%7D%5E%7B(t)%7D%5Cright)%5E%7B-1%7D%20%5Cfrac%7B%5Cpartial%20L%7D%7B%5Cpartial%20%5Cboldsymbol%7B%5Ctheta%7D%7D%20%5Cmid%20%5Cboldsymbol%7B%5Ctheta%7D%5E%7B(t)%7D%0A" /></p><p>在前面的推导中，我们已知 REML 方法的似然函数为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cln%20L%5Cleft%28%5Csigma_%7B0%7D%5E%7B2%7D%2C%20%5Cldots%2C%20%5Csigma_%7Bm%7D%5E%7B2%7D%5Cright%29%3D%26%20%5Cfrac%7Bn-r%7D%7B2%7D%20%5Cln%20(2%20%5Cpi)-%5Cfrac%7B1%7D%7B2%7D%20%5Cln%20%5Cleft%7C%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright%7C-%5Cfrac%7B1%7D%7B2%7D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BK%7D%20%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%20%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BK%5E%7B%5Cprime%7D%20y%7D%20%5C%5C%0A%3D%26%20%5Cfrac%7Bn-r%7D%7B2%7D%20%5Cln%20(2%20%5Cpi)-%5Cfrac%7B1%7D%7B2%7D%20%5Cln%20%5Cleft%7C%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%5Cleft(%5Csum_%7Bi%3D0%7D%5E%7Bm%7D%20%5Csigma_%7Bi%7D%5E%7B2%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cright)%20%5Cmathbf%7BK%7D%20%5Cright%7C%20%5C%5C%0A%26-%5Cfrac%7B1%7D%7B2%7D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BK%7D%20%5Cleft%5B%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%5Cleft(%5Csum_%7Bi%3D0%7D%5E%7Bm%7D%20%5Csigma_%7Bi%7D%5E%7B2%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cright)%20%5Cmathbf%7BK%7D%5Cright%5D%5E%7B-1%7D%20%5Cmathbf%7BK%5E%7B%5Cprime%7D%20y%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>之前我们推导证明：</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%5Cpartial%5E2%20I_%7BR%7D%7D%7B%5Cpartial%20%5Csigma_i%5E2%20%5Cpartial%20%5Csigma_j%5E2%7D%20%0A%20%3D%5Cfrac%7B1%7D%7B2%7D%20%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BP%20%7D%20%5Cmathbf%7BV%7D_j%20%5Cmathbf%7BP%20%7D%20%5Cmathbf%7BV%7D_i%5Cright%29-%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D_j%20%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D_i%20%20%5Cmathbf%7BP%20y%7D%0A" /></p><p>举个例子，假设模型中随机效应只有加性效应（<img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D%20%3D%20%5Cmathbf%7BA%7D%20%5Csigma%5E%7B2%7D_%7Ba%7D" style="display:inline-block;margin: 0;"/> ）和残差 (<img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D%20%3D%20%5Cmathbf%7BI%7D%20%5Csigma%5E%7B2%7D_%7Be%7D" style="display:inline-block;margin: 0;"/>)，此时  <img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D" style="display:inline-block;margin: 0;"/> 矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BH%7D%20%26%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cfrac%7B%5Cpartial%5E%7B2%7D%20L%7D%7B%5Cpartial%5Cleft%28%5Csigma_%7Ba%7D%5E%7B2%7D%5Cright%29%5E%7B2%7D%7D%20%26%20%5Cfrac%7B%5Cpartial%20%5Ccdot%7D%7B%5Cpartial%20%5Csigma_%7Ba%7D%5E%7B2%7D%20%5Cpartial%20%5Csigma_%7Be%7D%5E%7B2%7D%7D%20%5C%5C%0A%5Cfrac%7B%5Cpartial%5E%7B2%7D%20L%7D%7B%5Cpartial%20%5Csigma_%7B%5Cmathrm%7Ba%7D%7D%5E%7B2%7D%20%5Cpartial%20%5Csigma_%7Be%7D%5E%7B2%7D%7D%20%26%20%5Cfrac%7B%5Cpartial%5E%7B2%7D%20L%7D%7B%5Cpartial%5Cleft(%5Csigma_%7Be%7D%5E%7B2%7D%5Cright)%5E%7B2%7D%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7B2%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D_%7Ba%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D_%7Ba%7D%5Cright)-2%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D_%7Ba%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D_%7Ba%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7By%7D%20%26%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D_%7Ba%7D%20%5Cmathbf%7BP%7D%5Cright)-2%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D_%7Ba%7D%20%5Cmathbf%7BP%20P%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D_%7Ba%7D%20%5Cmathbf%7BP%7D%5Cright)-2%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D_%7Ba%7D%20%5Cmathbf%7BP%20P%7D%20%5Cmathbf%7By%7D%20%26%20%5Coperatorname%7Btr%7D(%5Cmathbf%7BP%20P%7D)-2%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%20P%20P%7D%20%5Cmathbf%7By%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A%5Cend%7Baligned%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D_%7Ba%7D%20%3D%20%5Cmathbf%7BZAZ'%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>同样地，我们之前推导得到：</p>
<p style=""><img src="https://math.now.sh?from=-%5Cmathrm%7BE%7D%5Cleft%28%5Cfrac%7B%5Cpartial%5E2%20l_%7B%5Cmathbf%7BR%7D%7D%7D%7B%5Cpartial%20%5Csigma_i%5E2%20%5Csigma_j%5E2%7D%5Cright%29%0A%3D%5Cfrac%7B1%7D%7B2%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D_j%20%5Cmathbf%7BP%20V%7D_i%20%5Cright)%0A" /></p><p>采用上面的例子，此时 <img src="https://math.now.sh?inline=%5Cmathbf%7BF%7D" style="display:inline-block;margin: 0;"/> 矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BF%7D%3D%5Cmathrm%7BE%7D%28%5Cmathbf%7BH%7D%29%3D-%5Cfrac%7B1%7D%7B2%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D_%7Ba%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D%20_%7Ba%7D%5Cright)%20%26%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D_%7Ba%7D%20%5Cmathbf%7BP%7D%5Cright)%20%5C%5C%0A%5Coperatorname%7Btr%7D(%5Cmathbf%7BP%20V%7D_%7Ba%7D%20%5Cmathbf%7BP%7D)%20%26%20%5Coperatorname%7Btr%7D(%5Cmathbf%7BP%20P%7D)%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>此时平均信息矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BAI%7D_%7Bij%7D%20%26%3D%20%5Cfrac%7B-%5Cmathbf%7BF%7D_%7Bij%7D%2B%28-%5Cmathbf%7BH%7D_%7Bij%7D%29%7D%7B2%7D%20%5C%5C%0A%26%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cleft(%5Cfrac%7B1%7D%7B2%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D_j%20%5Cmathbf%7BP%20V%7D_i%20%5Cright)%20-%5Cfrac%7B1%7D%7B2%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BP%20%7D%20%5Cmathbf%7BV%7D_j%20%5Cmathbf%7BP%20%7D%20%5Cmathbf%7BV%7D_i%5Cright)%2B%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D_j%20%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D_i%20%20%5Cmathbf%7BP%20y%7D%20%5Cright)%20%5C%5C%0A%26%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D_j%20%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D_i%20%20%5Cmathbf%7BP%20y%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>采用上面的例子，此时 <img src="https://math.now.sh?inline=%5Cmathbf%7BAI%7D" style="display:inline-block;margin: 0;"/> 矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BAI%7D%3D%5Cfrac%7B-%5Cmathbf%7BF%7D%2B%28-%5Cmathbf%7BH%7D%29%7D%7B2%7D%20%3D%20%5Cfrac%7B1%7D%7B2%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D_%7Ba%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D_%7Ba%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7By%7D%20%26%20%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D_%7Ba%7D%20%5Cmathbf%7BP%20P%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D_%7Ba%7D%20%5Cmathbf%7BP%20P%7D%20%5Cmathbf%7By%7D%20%26%20%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%20P%20P%7D%20%5Cmathbf%7By%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>此时在 AI 算法中，不涉及迹函数的运算，计算难度相对低一点。</p>
<p>如果我们设 <img src="https://math.now.sh?inline=%5Cmathbf%7Bq%7D_%7B%5Ckappa_%7Bi%7D%7D%20%3D%20%5Cmathbf%7B%5Cdot%7BV%7D%7D_%7Bi%7D%5Cmathbf%7BPy%7D" style="display:inline-block;margin: 0;"/> ，定义 <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D%20%3D%20%5Cleft%5B%20%5Cmathbf%7Bq%7D_%7B%5Ckappa_%7B1%7D%7D%20%5Ccdots%20%5Cmathbf%7Bq%7D_%7B%5Ckappa_%7Bk%7D%7D%5Cright%5D" style="display:inline-block;margin: 0;"/> ，则我们可以得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BAI%7D%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cmathbf%7BQ%7D%5E%7B%5Cprime%7D%5Cmathbf%7BP%7D%5Cmathbf%7BQ%7D%0A" /></p><p>对于某一个随机效应的方差组分 <img src="https://math.now.sh?inline=%5Cgamma_%7Bij%7D" style="display:inline-block;margin: 0;"/> ，我们有 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Cdot%7BV%7D%7D_%7Bi%20j%7D%20%3D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bij%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，则有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7Bq%7D_%7B%5Cgamma_%7Bij%7D%7D%20%26%3D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bij%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BPy%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bij%7D%20%5Cmathbf%7BG%7D_%7Bi%7D%5E%7B-1%7D%20%5Cmathbf%7BG%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BPy%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bij%7D%20%5Cmathbf%7BG%7D_%7Bi%7D%5E%7B-1%7D%20%5Cmathbf%7Bu%7D_%7Bi%7D%20%5Cquad%20%5Cbecause%20%20%5Cmathbf%7Bu%7D_%7Bi%7D%20%3D%20%5Cmathbf%7BG%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BPy%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>对于残差的方差组分 <img src="https://math.now.sh?inline=%5Cphi_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，我们有 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Cdot%7BV%7D%7D_%7Bi%7D%20%3D%20%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，则有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7Bq%7D_%7B%5Cphi_%7Bi%7D%7D%20%26%3D%20%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bi%7D%20%5Cmathbf%7BPy%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bi%7D%20%5Cmathbf%7BR%5E%7B-1%7De%7D%20%5Cquad%20%5Cbecause%20%5Cmathbf%7BPy%7D%20%3D%20%20%5Cmathbf%7BR%5E%7B-1%7De%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bi%7D%20%5Cmathbf%7B%5CSigma%5E%7B-1%7De%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>对于中间的 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D" style="display:inline-block;margin: 0;"/> 矩阵，我们采用公式 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D%20%3D%20%5Cmathbf%7BR%5E%7B-1%7D-R%5E%7B-1%7DWC%5E%7B-1%7DW%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> 进行计算。</p>
<p>我们也可以通过高斯消元得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BAI%7D" style="display:inline-block;margin: 0;"/> 矩阵，首先我们构建增广矩阵如下 (用 <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D" style="display:inline-block;margin: 0;"/> 代替 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> )</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%20%26%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BQ%7D%20%5C%5C%0A%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%20%26%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BQ%7D%20%5C%5C%0A%5Cmathbf%7BQ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BQ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%20%26%20%5Cmathbf%7BQ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BQ%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BC%7D%20%26%20%5Cmathbf%7Ba%7D%20%5C%5C%0A%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%26%20%20%5Cmathbf%7BQ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BQ%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>将 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 吸收进入 <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BQ%7D" style="display:inline-block;margin: 0;"/> 得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cmathbf%7BQ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BQ%7D%20-%20%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%5Cmathbf%7BC%7D%5E%7B-1%7D%5Cmathbf%7Ba%7D%5C%5C%0A%26%3D%20%5Cmathbf%7BQ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BQ%7D%20-%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%20%5Cmathbf%7BQ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BQ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%20%5Cend%7Barray%7D%5Cright%5D%20%5Cmathbf%7BC%7D%5E%7B-1%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BQ%7D%20%5C%5C%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BQ%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BQ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BQ%7D%20-%20%20%5Cmathbf%7BQ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%5E%7B-1%7DXC%5E%7B-1%7DX%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%20%5Cmathbf%7BQ%7D%20%20-%20%20%5Cmathbf%7BQ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%5E%7B-1%7DZC%5E%7B-1%7DZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%20%5Cmathbf%7BQ%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BQ%7D%5E%7B%5Cprime%7D%28%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20-%20%5Cmathbf%7BR%5E%7B-1%7DXC%5E%7B-1%7DX%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%20%20-%5Cmathbf%7BR%5E%7B-1%7DZC%5E%7B-1%7DZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%29%5Cmathbf%7BQ%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BQ%7D%5E%7B%5Cprime%7D(%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20-%20%5Cmathbf%7BR%5E%7B-1%7DWC%5E%7B-1%7DW%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%20)%5Cmathbf%7BQ%7D%20%5Cquad%20%5Cbecause%20%5Cmathbf%7BW%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BZ%7D%20%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BQ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BQ%7D%0A%5Cend%7Baligned%7D%0A" /></p><h2 id="第二种计算方法">第二种计算方法</h2>
<p>我们现在逐个计算  <img src="https://math.now.sh?inline=%5Cmathbf%7BAI%7D" style="display:inline-block;margin: 0;"/> 矩阵的元素  <img src="https://math.now.sh?inline=%5Cmathbf%7BAI%7D_%7Bij%7D%3D%5Cfrac%7B1%7D%7B2%7D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D_j%20%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D_i%20%20%5Cmathbf%7BP%20y%7D%3D%5Cfrac%7B1%7D%7B2%7D%20%5Cmathbf%7Bq%7D_%7B%5Ckappa_%7Bj%7D%7D%5E%7B%5Cprime%7D%20%20%5Cmathbf%7BP%7D%20%5Cmathbf%7Bq%7D_%7B%5Ckappa_%7Bi%7D%7D" style="display:inline-block;margin: 0;"/> ，这里我们先忽略 1/2 这个常数项，推导如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cmathbf%7Bq%7D_%7B%5Ckappa_%7Bj%7D%7D%5E%7B%5Cprime%7D%20%20%5Cmathbf%7BP%7D%20%5Cmathbf%7Bq%7D_%7B%5Ckappa_%7Bi%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7Bq%7D_%7B%5Ckappa_%7Bj%7D%7D%5E%7B%5Cprime%7D%20%20%5Cleft%28%20%5Cmathbf%7BR%5E%7B-1%7D-R%5E%7B-1%7DWC%5E%7B-1%7DW%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%20%5Cright%29%20%5Cmathbf%7Bq%7D_%7B%5Ckappa_%7Bi%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7Bq%7D_%7B%5Ckappa_%7Bj%7D%7D%5E%7B%5Cprime%7D%5Cmathbf%7BR%5E%7B-1%7D%7D%20%5Cmathbf%7Bq%7D_%7B%5Ckappa_%7Bi%7D%7D%20-%20%20%20%5Cmathbf%7Bq%7D_%7B%5Ckappa_%7Bj%7D%7D%5E%7B%5Cprime%7D%20%20%20%5Cmathbf%7BR%5E%7B-1%7DWC%5E%7B-1%7DW%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%5Cmathbf%7Bq%7D_%7B%5Ckappa_%7Bi%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7Bq%7D_%7B%5Ckappa_%7Bj%7D%7D%5E%7B%5Cprime%7D%5Cmathbf%7BR%5E%7B-1%7D%7D%20%5Cmathbf%7Bq%7D_%7B%5Ckappa_%7Bi%7D%7D%20-%20%20%20%5Cmathbf%7BT%7D%5E%7B%5Cprime%7D%20%20%20%5Cmathbf%7BW%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%5Cmathbf%7Bq%7D_%7B%5Ckappa_%7Bi%7D%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>这里我们设 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D%20%3D%20%5Cmathbf%7BC%5E%7B-1%7DW%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%5Cmathbf%7Bq%7D_%7B%5Ckappa_%7Bj%7D%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>这里的第一项容易计算，第二项我们将 <img src="https://math.now.sh?inline=%5Cmathbf%7Bq%7D_%7B%5Ckappa_%7Bj%7D%7D" style="display:inline-block;margin: 0;"/> 替换 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 构建混合模型方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7BCT%3DW%5E%7B%5Cprime%7DR%5E%7B-1%7D%5Cmathbf%7Bq%7D_%7B%5Ckappa_%7Bj%7D%7D%7D" style="display:inline-block;margin: 0;"/> ，此时 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%5E%7B%5Cprime%7DR%5E%7B-1%7D%5Cmathbf%7Bq%7D_%7B%5Ckappa_%7Bj%7D%7D%7D" style="display:inline-block;margin: 0;"/> 是右手项，<img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D" style="display:inline-block;margin: 0;"/> 是相应的解。</p>
<h1>参考文献</h1>
<ol>
<li>
<p>Knight E. Improved iterative schemes for REML estimation of variance parameters in linear mixed models[D]. , 2008.</p>
</li>
<li>
<p>Gilmour A R, Thompson R, Cullis B R. Average information REML: an efficient algorithm for variance parameter estimation in linear mixed models[J]. Biometrics, 1995: 1440-1450.</p>
</li>
<li>
<p>Smith S P, Graser H U. Estimating variance components in a class of mixed models by restricted maximum likelihood[J]. Journal of Dairy Science, 1986, 69(4): 1156-1165.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
        <tag>方差组分</tag>
        <tag>REML</tag>
      </tags>
  </entry>
  <entry>
    <title>方差组分估计方法四之EM-REML</title>
    <url>/posts/68754596/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这是方差组分估计方法的第四篇博客，介绍 EM-REML 算法。</p>
<span id="more"></span>
<h1>混合线性模型的一般式子</h1>
<p>我们将混合线性模型写为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%20%3D%20%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cmathbf%7BZu%7D%2B%5Cmathbf%7Be%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Be%7D" style="display:inline-block;margin: 0;"/> 的联合分布为</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7Bu%7D%20%5C%5C%0A%5Cmathbf%7Be%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5Csim%20%5Cmathrm%7BN%7D%5Cleft%28%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%0A%5Cend%7Barray%7D%5Cright%5D%2C%20%5Ctheta%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BG%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BR%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cright%29%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D%20%3D%20%5Cmathbf%7BG%7D%28%5Cboldsymbol%7B%5Cgamma%7D%29" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D%20%3D%20%5Csigma%5E%7B2%7D%20%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D%20%3D%20%5Cmathbf%7B%5CSigma%7D%28%5Cboldsymbol%7B%5Cphi%7D%29" style="display:inline-block;margin: 0;"/> 。这里我们假定这三个矩阵均为<strong>正定</strong>矩阵。</p>
<p>这里的 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cgamma%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cphi%7D" style="display:inline-block;margin: 0;"/> 是与随机效应 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Be%7D" style="display:inline-block;margin: 0;"/> 相关的方差组分的向量，而标量参数  <img src="https://math.now.sh?inline=%5Csigma%5E%7B2%7D" style="display:inline-block;margin: 0;"/>  和 <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/> 是与残差和全部方差组分的缩放系数。因此我们需要估计的方差参数为 <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Ckappa%7D%20%3D%20%28%5Cboldsymbol%7B%5Cgamma%7D%5E%7B%5Cprime%7D%2C%20%20%5Csigma%5E%7B2%7D%2C%20%5Cboldsymbol%7B%5Cphi%7D%5E%7B%5Cprime%7D%20%29%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>因为 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的分布为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%20%5Csim%20%5Cmathrm%7BN%7D%28%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D%2C%20%5Ctheta%5Cmathbf%7BH%7D%29%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D%20%3D%20%5Cmathbf%7BZGZ%5E%7B%5Cprime%7D%7D%2B%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> 是一个正定矩阵。</p>
<p>这里的标量参数 <img src="https://math.now.sh?inline=%5Csigma%5E%7B2%7D" style="display:inline-block;margin: 0;"/>  和  <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/>  均是用于缩放的参数，我们发现如果我们同时包含这两个参数，那么这两个参数的值便均无法确定，因为此时 <img src="https://math.now.sh?inline=%5Cmathrm%7BVar%7D%28%5Cmathbf%7Bu%7D%29%20%3D%20%5Ctheta%20%5Cmathbf%7BG%7D(%5Cboldsymbol%7B%5Cgamma%7D)" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathrm%7BVar%7D%28%5Cmathbf%7Be%7D%29%20%3D%20%5Ctheta%20%5Csigma%5E%7B2%7D%20%5Cmathbf%7B%5CSigma%7D(%5Cboldsymbol%7B%5Cphi%7D)" style="display:inline-block;margin: 0;"/>  。实际上我们至少会将其中一个参数设定为 1 。</p>
<p>按照育种模型的一般思路，这里我将  <img src="https://math.now.sh?inline=%5Csigma%5E%7B2%7D" style="display:inline-block;margin: 0;"/>  和  <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/> 均设为 1， 此时 <img src="https://math.now.sh?inline=%5Cmathrm%7BVar%7D%28%5Cmathbf%7By%7D%29%20%3D%20%5Cmathbf%7BV%7D%20%3D%20%20%5Cmathbf%7BZGZ%5E%7B%5Cprime%7D%7D%2B%5Cmathbf%7BR%7D%20%3D%20%20%5Cmathbf%7BZG(%5Cboldsymbol%7B%5Cgamma%7D)Z%5E%7B%5Cprime%7D%7D%2B%5Cmathbf%7B%5CSigma%7D(%5Cboldsymbol%7B%5Cphi%7D)" style="display:inline-block;margin: 0;"/> ，我们需要估计的参数为  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Ckappa%7D%20%3D%20%28%5Cboldsymbol%7B%5Cgamma%7D%5E%7B%5Cprime%7D%2C%20%5Cboldsymbol%7B%5Cphi%7D%5E%7B%5Cprime%7D%20%29%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/>  。</p>
<p>假设我们有 <img src="https://math.now.sh?inline=s" style="display:inline-block;margin: 0;"/> 个随机效应，即 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D%20%3D%20%28%5Cmathbf%7Bu%7D_%7B1%7D%5E%7B%5Cprime%7D%2C%20%5Cmathbf%7Bu%7D_%7B2%7D%5E%7B%5Cprime%7D%2C%20%5Ccdots%2C%20%5Cmathbf%7Bu%7D_%7Bs%7D%5E%7B%5Cprime%7D%29%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，因此此时随机效应的协方差矩阵可以写为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BG%7D%20%3D%20%5Coplus_%7Bi%3D1%7D%5E%7Bs%7D%5Cmathbf%7BG%7D_%7Bi%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bccccc%7D%0A%5Cmathbf%7BG%7D_1%20%26%20%5Cmathbf%7B0%7D%20%26%20%5Ccdots%20%26%20%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BG%7D_2%20%26%20%5Ccdots%20%26%20%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cddots%20%26%20%5Cvdots%20%26%20%5Cvdots%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%26%20%5Cldots%20%26%20%5Cmathbf%7BG%7D_%7Bs-1%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%26%20%5Ccdots%20%26%20%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BG%7D_s%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>此时的方差组分 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cgamma%7D" style="display:inline-block;margin: 0;"/> 也可以进行相应的分块，例如 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7Bi%7D%20%3D%20%5Cmathbf%7BG%7D_%7Bi%7D%28%5Cboldsymbol%7B%5Cgamma%7D_%7Bi%7D%29" style="display:inline-block;margin: 0;"/> ，因此我们有 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cgamma%7D%20%3D%20%28%5Cboldsymbol%7B%5Cgamma%7D_%7B1%7D%5E%7B%5Cprime%7D%2C%20%5Cboldsymbol%7B%5Cgamma%7D_%7B2%7D%5E%7B%5Cprime%7D%2C%20%5Ccdots%2C%20%5Cboldsymbol%7B%5Cgamma%7D_%7Bs%7D%5E%7B%5Cprime%7D%29%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>但是对于残差，我们通常还是认为所有数据来自与一个数据集，即残差是均质的，其协方差矩阵不用分块。</p>
<h1>推导 C 逆矩阵</h1>
<p>假设 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵满秩，则混合线性模型的系数矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 可逆。</p>
<p>我们将原始的系数矩阵分块为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BC%7D%20%26%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BC%7D_%7B11%7D%20%26%20%5Cmathbf%7BC%7D_%7B12%7D%20%5C%5C%0A%5Cmathbf%7BC%7D_%7B21%7D%20%26%20%5Cmathbf%7BC%7D_%7B22%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BX%5E%7B%5Cprime%7DR%5E%7B-1%7DX%7D%20%26%20%5Cmathbf%7BX%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%7D%20%5C%5C%0A%5Cmathbf%7BZ%5E%7B%5Cprime%7DR%5E%7B-1%7DX%7D%20%26%20%5Cmathbf%7BZ%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>根据舒尔补公式，系数矩阵逆矩阵可以写为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BC%7D%5E%7B-1%7D%20%26%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BC%7D%5E%7B11%7D%20%26%20%5Cmathbf%7BC%7D%5E%7B12%7D%20%5C%5C%0A%5Cmathbf%7BC%7D%5E%7B21%7D%20%26%20%5Cmathbf%7BC%7D%5E%7B22%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%28%5Cmathbf%7BC%7D_%7B11%7D%20%20-%20%5Cmathbf%7BC%7D_%7B12%7D%5Cmathbf%7BC%7D_%7B22%7D%5E%7B-1%7D%5Cmathbf%7BC%7D_%7B21%7D%29%5E%7B-1%7D%20%26%20-(%5Cmathbf%7BC%7D_%7B11%7D%20%20-%20%5Cmathbf%7BC%7D_%7B12%7D%5Cmathbf%7BC%7D_%7B22%7D%5E%7B-1%7D%5Cmathbf%7BC%7D_%7B21%7D)%5E%7B-1%7D%5Cmathbf%7BC%7D_%7B12%7D%5Cmathbf%7BC%7D_%7B22%7D%5E%7B-1%7D%20%5C%5C%0A-%5Cmathbf%7BC%7D_%7B22%7D%5E%7B-1%7D%5Cmathbf%7BC%7D_%7B21%7D(%5Cmathbf%7BC%7D_%7B11%7D%20%20-%20%5Cmathbf%7BC%7D_%7B12%7D%5Cmathbf%7BC%7D_%7B22%7D%5E%7B-1%7D%5Cmathbf%7BC%7D_%7B21%7D)%5E%7B-1%7D%20%26%20%5Cmathbf%7BC%7D_%7B22%7D%5E%7B-1%7D%2B%5Cmathbf%7BC%7D_%7B22%7D%5E%7B-1%7D%5Cmathbf%7BC%7D_%7B21%7D(%5Cmathbf%7BC%7D_%7B11%7D%20%20-%20%5Cmathbf%7BC%7D_%7B12%7D%5Cmathbf%7BC%7D_%7B22%7D%5E%7B-1%7D%5Cmathbf%7BC%7D_%7B21%7D)%5E%7B-1%7D%5Cmathbf%7BC%7D_%7B12%7D%5Cmathbf%7BC%7D_%7B22%7D%5E%7B-1%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BC%7D%5E%7B11%7D%20%26%20-%5Cmathbf%7BC%7D%5E%7B11%7D%5Cmathbf%7BC%7D_%7B12%7D%5Cmathbf%7BC%7D_%7B22%7D%5E%7B-1%7D%20%5C%5C%0A-%5Cmathbf%7BC%7D_%7B22%7D%5E%7B-1%7D%5Cmathbf%7BC%7D_%7B21%7D%5Cmathbf%7BC%7D%5E%7B11%7D%20%26%20%5Cmathbf%7BC%7D_%7B22%7D%5E%7B-1%7D%2B%5Cmathbf%7BC%7D_%7B22%7D%5E%7B-1%7D%5Cmathbf%7BC%7D_%7B21%7D%5Cmathbf%7BC%7D%5E%7B11%7D%5Cmathbf%7BC%7D_%7B12%7D%5Cmathbf%7BC%7D_%7B22%7D%5E%7B-1%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>在之前的推导中，我们已经得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BC%5E%7B11%7D%7D%20%3D%20%28%5Cmathbf%7BC%7D_%7B11%7D%20%20-%20%5Cmathbf%7BC%7D_%7B12%7D%5Cmathbf%7BC%7D_%7B22%7D%5E%7B-1%7D%5Cmathbf%7BC%7D_%7B21%7D%29%5E%7B-1%7D%20%3D%20(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%0A" /></p><p>根据附录1，我们有 <img src="https://math.now.sh?inline=%5Cmathbf%7B%28Z%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D%29%5E%7B-1%7DZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%20%3D%20%5Cmathbf%7BGZ%5E%7B%5Cprime%7D(R%2BZGZ%5E%7B%5Cprime%7D)%5E%7B-1%7D%7D%3D%20%5Cmathbf%7BGZ%5E%7B%5Cprime%7DV%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> ，因此其它分块子矩阵推导如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BC%7D%5E%7B12%7D%20%26%3D%20-%5Cmathbf%7BC%7D%5E%7B11%7D%5Cmathbf%7BC%7D_%7B12%7D%5Cmathbf%7BC%7D_%7B22%7D%5E%7B-1%7D%20%20%5C%5C%0A%26%3D%20-%28%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D%29%5E%7B-1%7D%20%20%5Cmathbf%7BX%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%7D(%5Cmathbf%7BZ%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D%7D)%5E%7B-1%7D%20%5C%5C%0A%26%3D%20-(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%20%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cmathbf%7BV%5E%7B-1%7DZG%7D%20%5C%5C%0A%5Cmathbf%7BC%7D%5E%7B21%7D%20%26%3D%20(%5Cmathbf%7BC%7D%5E%7B12%7D)%5E%7B%5Cprime%7D%20%5C%5C%0A%26%3D%20-%5Cmathbf%7BGZ%5E%7B%5Cprime%7DV%5E%7B-1%7D%7D%20%5Cmathbf%7BX%7D%20(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%20%20%20%5C%5C%0A%5Cmathbf%7BC%7D%5E%7B22%7D%20%26%3D%20%5Cmathbf%7BC%7D_%7B22%7D%5E%7B-1%7D%2B%5Cmathbf%7BC%7D_%7B22%7D%5E%7B-1%7D%5Cmathbf%7BC%7D_%7B21%7D%5Cmathbf%7BC%7D%5E%7B11%7D%5Cmathbf%7BC%7D_%7B12%7D%5Cmathbf%7BC%7D_%7B22%7D%5E%7B-1%7D%20%5C%5C%0A%26%3D%20(%5Cmathbf%7BZ%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D%7D)%5E%7B-1%7D%2B(%5Cmathbf%7BZ%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D%7D)%5E%7B-1%7D%5Cmathbf%7BZ%5E%7B%5Cprime%7DR%5E%7B-1%7DX%7D(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%5Cmathbf%7BX%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%7D%20(%5Cmathbf%7BZ%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D%7D)%5E%7B-1%7D%20%5C%5C%0A%26%3D(%5Cmathbf%7BZ%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D%7D)%5E%7B-1%7D%2B%20%5Cmathbf%7BGZ%5E%7B%5Cprime%7DV%5E%7B-1%7D%7D%5Cmathbf%7BX%7D(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%5Cmathbf%7BX%5E%7B%5Cprime%7D%7D%20%5Cmathbf%7BV%5E%7B-1%7DZG%7D%20%5C%5C%0A%26%3D(%5Cmathbf%7BZ%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D%7D)%5E%7B-1%7D%2B%20%5Cmathbf%7BGZ%5E%7B%5Cprime%7D%7D%5Cmathbf%7B(V%5E%7B-1%7D-P)%7D%20%5Cmathbf%7BZG%7D%20%5Cquad%20%5Cbecause%20%5Cmathbf%7BP%7D%3D%5Cmathbf%7BV%7D%5E%7B-1%7D-%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5C%5C%0A%26%3D(%5Cmathbf%7BZ%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D%7D)%5E%7B-1%7D%2B%20%5Cmathbf%7BGZ%5E%7B%5Cprime%7D%7D%5Cmathbf%7BV%5E%7B-1%7D%7D%20%5Cmathbf%7BZG%7D-%20%5Cmathbf%7BGZ%5E%7B%5Cprime%7D%7D%5Cmathbf%7BP%7D%20%5Cmathbf%7BZG%7D%20%5C%5C%0A%26%3D(%5Cmathbf%7BZ%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D%7D)%5E%7B-1%7D%2B%20%5Cmathbf%7B(Z%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D)%5E%7B-1%7DZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%20%20%5Cmathbf%7BZG%7D-%20%5Cmathbf%7BGZ%5E%7B%5Cprime%7D%7D%5Cmathbf%7BP%7D%20%5Cmathbf%7BZG%7D%20%5C%5C%0A%26%3D(%5Cmathbf%7BZ%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D%7D)%5E%7B-1%7D(%5Cmathbf%7BI%7D%2B%5Cmathbf%7BZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%20%20%5Cmathbf%7BZG%7D)-%20%5Cmathbf%7BGZ%5E%7B%5Cprime%7D%7D%5Cmathbf%7BP%7D%20%5Cmathbf%7BZG%7D%20%5C%5C%0A%26%3D(%5Cmathbf%7BZ%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D%7D)%5E%7B-1%7D(%5Cmathbf%7BG%7D%5E%7B-1%7D%2B%5Cmathbf%7BZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%20%20%5Cmathbf%7BZ%7D)%5Cmathbf%7BG%7D-%20%5Cmathbf%7BGZ%5E%7B%5Cprime%7D%7D%5Cmathbf%7BP%7D%20%5Cmathbf%7BZG%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BG%7D-%20%5Cmathbf%7BGZ%5E%7B%5Cprime%7D%7D%5Cmathbf%7BP%7D%20%5Cmathbf%7BZG%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BC%7D%5E%7B-1%7D%20%26%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BC%7D%5E%7B11%7D%20%26%20%5Cmathbf%7BC%7D%5E%7B12%7D%20%5C%5C%0A%5Cmathbf%7BC%7D%5E%7B21%7D%20%26%20%5Cmathbf%7BC%7D%5E%7B22%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%20%26%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%28%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D%29%5E%7B-1%7D%20%26%20%20-(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%20%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cmathbf%7BV%5E%7B-1%7DZG%7D%20%5C%5C%0A-%5Cmathbf%7BGZ%5E%7B%5Cprime%7DV%5E%7B-1%7D%7D%20%5Cmathbf%7BX%7D%20(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%20%26%20%5Cmathbf%7BG%7D-%20%5Cmathbf%7BGZ%5E%7B%5Cprime%7D%7D%5Cmathbf%7BP%7D%20%5Cmathbf%7BZG%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><h1>推导 P 矩阵</h1>
<p>之前我们得到了两个 P 矩阵的式子，如下（<img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D" style="display:inline-block;margin: 0;"/> 为满足 <img src="https://math.now.sh?inline=%5Cmathbf%7BK'X%7D%3D0" style="display:inline-block;margin: 0;"/> 的一个矩阵）</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BP%7D%3D%5Cmathbf%7BV%7D%5E%7B-1%7D-%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%3D%5Cmathbf%7BK%7D%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%0A" /></p><p>这里我们推导第三个式子</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BP%7D%20%3D%20%5Cmathbf%7BR%5E%7B-1%7D-R%5E%7B-1%7DWC%5E%7B-1%7DW%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BZ%7D%20%5Cend%7Barray%7D%5Cright%5D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 为系数矩阵。</p>
<h2 id="证明过程">证明过程</h2>
<p>根据下面的附录1，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BR%5E%7B-1%7DZ%28Z%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D%29%5E%7B-1%7D%7D%20%3D%20%5Cmathbf%7B(R%2BZGZ%5E%7B%5Cprime%7D)%5E%7B-1%7DZG%7D%0A" /></p><p>我们可以将其写为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BR%5E%7B-1%7DZM%7D%20%3D%20%5Cmathbf%7BV%5E%7B-1%7DZG%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D%3D%5Cmathbf%7B%28Z%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D%29%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>我们也可以用 <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D" style="display:inline-block;margin: 0;"/> 来表示 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/></p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BV%5E%7B-1%7D%7D%20%20%26%3D%20%5Cmathbf%7BR%5E%7B-1%7D-R%5E%7B-1%7DZ%28Z%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D%29%5E%7B-1%7DZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BR%5E%7B-1%7D-R%5E%7B-1%7DZMZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>我们同样可以用  <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D" style="display:inline-block;margin: 0;"/> 来表示 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 矩阵的元素</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BC%7D%5E%7B12%7D%20%26%3D%20-%28%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D%29%5E%7B-1%7D%20%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cmathbf%7BV%5E%7B-1%7DZG%7D%20%5C%5C%0A%26%3D%20-(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%20%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cmathbf%7BR%5E%7B-1%7DZM%7D%20%5C%5C%0A%5Cmathbf%7BC%7D%5E%7B21%7D%20%26%3D%20%20-%5Cmathbf%7BMZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%5Cmathbf%7BX%7D(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%20%5C%5C%0A%5Cmathbf%7BC%7D%5E%7B22%7D%20%26%3D(%5Cmathbf%7BZ%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D%7D)%5E%7B-1%7D%2B%20%5Cmathbf%7BGZ%5E%7B%5Cprime%7DV%5E%7B-1%7D%7D%5Cmathbf%7BX%7D(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%5Cmathbf%7BX%5E%7B%5Cprime%7D%7D%20%5Cmathbf%7BV%5E%7B-1%7DZG%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BM%7D%2B%20%5Cmathbf%7BMZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%5Cmathbf%7BX%7D(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%5Cmathbf%7BX%5E%7B%5Cprime%7D%7D%20%5Cmathbf%7BR%5E%7B-1%7DZM%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>因此系数矩阵逆矩阵可以表示为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BC%7D%5E%7B-1%7D%20%0A%20%26%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%28%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D%29%5E%7B-1%7D%20%26%20%20-(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%20%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cmathbf%7BR%5E%7B-1%7DZM%7D%20%5C%5C%0A%20-%5Cmathbf%7BMZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%5Cmathbf%7BX%7D(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%20%20%26%20%5Cmathbf%7BM%7D%2B%20%5Cmathbf%7BMZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%5Cmathbf%7BX%7D(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%5Cmathbf%7BX%5E%7B%5Cprime%7D%7D%20%5Cmathbf%7BR%5E%7B-1%7DZM%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BWC%5E%7B-1%7DW%5E%7B%5Cprime%7D%20%7D%0A%20%26%3D%20%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BZ%7D%20%5Cend%7Barray%7D%5Cright%5D%0A%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%28%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D%29%5E%7B-1%7D%20%26%20%20-(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%20%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cmathbf%7BR%5E%7B-1%7DZM%7D%20%5C%5C%0A%20-%5Cmathbf%7BMZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%5Cmathbf%7BX%7D(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%20%20%26%20%5Cmathbf%7BM%7D%2B%20%5Cmathbf%7BMZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%5Cmathbf%7BX%7D(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%5Cmathbf%7BX%5E%7B%5Cprime%7D%7D%20%5Cmathbf%7BR%5E%7B-1%7DZM%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%0A%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5C%5C%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%20%26%3D%20%20%5Cmathbf%7BX%7D%20(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20-%20%5Cmathbf%7BX%7D%20(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%20%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cmathbf%7BR%5E%7B-1%7DZM%7D%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20-%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7BMZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%5Cmathbf%7BX%7D(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5C%5C%0A%20%26%20%5Cquad%20%2B%20%5Cmathbf%7BZ%7D%5Cmathbf%7BM%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%2B%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7BMZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%5Cmathbf%7BX%7D(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%5Cmathbf%7BX%5E%7B%5Cprime%7D%7D%20%5Cmathbf%7BR%5E%7B-1%7DZM%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因此</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cmathbf%7BR%5E%7B-1%7D-R%5E%7B-1%7DWC%5E%7B-1%7DW%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%20%5C%5C%0A%26%3D%20%20%5Cmathbf%7BR%5E%7B-1%7D%7D%20-%5Cmathbf%7BR%5E%7B-1%7D%7D%20%5Cmathbf%7BX%7D%20%28%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D%29%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%5E%7B-1%7D%7D%20%2B%20%5Cmathbf%7BR%5E%7B-1%7D%7D%20%5Cmathbf%7BX%7D%20(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%20%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cmathbf%7BR%5E%7B-1%7DZM%7D%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%5E%7B-1%7D%7D%20%2B%20%5Cmathbf%7BR%5E%7B-1%7D%7D%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7BMZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%5Cmathbf%7BX%7D(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%5E%7B-1%7D%7D%20%5C%5C%0A%20%26%20%5Cquad%20-%20%5Cmathbf%7BR%5E%7B-1%7D%7D%20%5Cmathbf%7BZ%7D%5Cmathbf%7BM%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%5E%7B-1%7D%7D%20-%20%5Cmathbf%7BR%5E%7B-1%7D%7D%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7BMZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%5Cmathbf%7BX%7D(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%5Cmathbf%7BX%5E%7B%5Cprime%7D%7D%20%5Cmathbf%7BR%5E%7B-1%7DZM%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%5E%7B-1%7D%7D%20%5C%5C%0A%20%26%3D%20%20%5Cmathbf%7BR%5E%7B-1%7D%7D%20-%20%5Cmathbf%7BR%5E%7B-1%7D%7D%20%5Cmathbf%7BZ%7D%5Cmathbf%7BM%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%5E%7B-1%7D%7D%20-%20(%5Cmathbf%7BR%5E%7B-1%7D%7D-%5Cmathbf%7BR%5E%7B-1%7D%7D%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7BMZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%20)%20%5Cmathbf%7BX%7D%20(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%5E%7B-1%7D%7D%5C%5C%0A%20%26%2B%20(%5Cmathbf%7BR%5E%7B-1%7D%7D-%5Cmathbf%7BR%5E%7B-1%7D%7D%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7BMZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D)%20%5Cmathbf%7BX%7D%20(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%20%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cmathbf%7BR%5E%7B-1%7DZM%7D%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%5E%7B-1%7D%7D%0A%5C%5C%20%0A%0A%20%20%26%3D%20%20%5Cmathbf%7BR%5E%7B-1%7D%7D%20-%20%5Cmathbf%7BR%5E%7B-1%7D%7D%20%5Cmathbf%7BZ%7D%5Cmathbf%7BM%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%5E%7B-1%7D%7D%20%5C%5C%0A%20%26%20-%20(%5Cmathbf%7BR%5E%7B-1%7D%7D-%5Cmathbf%7BR%5E%7B-1%7D%7D%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7BMZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%20)%20%5Cmathbf%7BX%7D%20(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20(%5Cmathbf%7BR%5E%7B-1%7D%7D%20-%5Cmathbf%7BR%5E%7B-1%7DZM%7D%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%5E%7B-1%7D%7D%20)%5C%5C%0A%20%26%3D%20%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%0A%20%20-%20%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%20%5Cmathbf%7BX%7D%20(%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BP%7D%0A%20%0A%5Cend%7Baligned%7D%0A" /></p><p>证明完毕</p>
<h1>EM-REML</h1>
<p>在之前的DF-REML 推导中，我们得到 REML 的一个似然函数的式子如下：</p>
<p style=""><img src="https://math.now.sh?from=l%28%5Cmathbf%7By%7D_%7B2%7D%29%20%0A%3D%20-%5Cfrac%7B1%7D%7B2%7D%5Cleft(%20%5Cln%20%7C%5Cmathbf%7BV%7D%7C%20%2B%20%5Cln%20%7C%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D%7C%2B%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7By%7D%20%5Cright)%0A" /></p><p>对于某个参数 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Ckappa%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 进行求导，如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AU%28%5Ckappa_%7Bi%7D%29%20%26%3D%20%5Cfrac%7B%5Cpartial%7Bl_%7BR%7D(%5Cmathbf%7By%7D_%7B2%7D)%7D%7D%7B%5Cpartial%7B%5Ckappa_%7Bi%7D%7D%7D%20%5C%5C%0A%26%3D%20-%5Cfrac%7B1%7D%7B2%7D%5Cleft(%20%5Cfrac%7B%5Cpartial%5Cln%20%7C%5Cmathbf%7BV%7D%7C%7D%7B%5Cpartial%7B%5Ckappa_%7Bi%7D%7D%7D%20%2B%20%5Cfrac%7B%5Cpartial%5Cln%20%7C%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D%7C%7D%7B%5Cpartial%7B%5Ckappa_%7Bi%7D%7D%7D%2B%5Cfrac%7B%5Cpartial%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7By%7D%20%7D%7B%5Cpartial%7B%5Ckappa_%7Bi%7D%7D%7D%20%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>我们定义 <img src="https://math.now.sh?inline=%5Cdot%7B%5Cmathbf%7BV%7D%7D_%7Bi%7D%20%3D%20%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BV%7D%7D%7B%5Cpartial%20%5Ckappa_%7Bi%7D%7D" style="display:inline-block;margin: 0;"/> ，并且使用下面的求导公式</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cfrac%7B%5Cpartial%20%5Clog%20%7C%5Cmathbf%7BV%7D%7C%7D%7B%5Cpartial%20%5Ckappa_i%7D%20%26%20%3D%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cdot%7B%5Cmathbf%7BV%7D%7D_i%5Cright%29%20%5C%5C%0A%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BV%7D%5E%7B-1%7D%7D%7B%5Cpartial%20%5Ckappa_i%7D%20%26%20%3D-%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cdot%7B%5Cmathbf%7BV%7D%7D_i%20%5Cmathbf%7BV%7D%5E%7B-1%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因此我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%20%5Cfrac%7B%5Cpartial%20%5Clog%20%7C%5Cmathbf%7BV%7D%7C%7D%7B%5Cpartial%20%5Ckappa_i%7D%2B%5Cfrac%7B%5Cpartial%20%5Clog%20%5Cleft%7C%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cright%7C%7D%7B%5Cpartial%20%5Ckappa_i%7D%20%5C%5C%0A%26%20%3D%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cdot%7B%5Cmathbf%7BV%7D%7D_i%5Cright%29-%5Coperatorname%7Btr%7D%5Cleft(%5Cleft(%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cdot%7B%5Cmathbf%7BV%7D%7D_i%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cright)%20%5C%5C%0A%26%20%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cdot%7B%5Cmathbf%7BV%7D%7D_i-%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cleft(%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cdot%7B%5Cmathbf%7BV%7D%7D_i%5Cright)%20%5C%5C%0A%26%20%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7BP%7D%20%5Cdot%7B%5Cmathbf%7BV%7D%7D_i%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cfrac%7B%5Cpartial%20%5Cboldsymbol%7By%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BP%7D%20%5Cboldsymbol%7By%7D%7D%7B%5Cpartial%20%5Ckappa_i%7D%20%26%20%3D%5Cboldsymbol%7By%7D%5E%7B%5Cprime%7D%20%5Cfrac%7B%5Cpartial%20%5Cboldsymbol%7BP%7D%7D%7B%5Cpartial%20%5Ckappa_i%7D%20%5Cboldsymbol%7By%7D%20%5C%5C%0A%26%20%3D-%5Cboldsymbol%7By%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BP%7D%20%5Cdot%7B%5Cboldsymbol%7BV%7D%7D_i%20%5Cboldsymbol%7BP%7D%20%5Cboldsymbol%7By%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因此我们得到 REML score 式子：</p>
<p style=""><img src="https://math.now.sh?from=U%28%5Ckappa_%7Bi%7D%29%20%3D%20-%20%5Cfrac%7B1%7D%7B2%7D%20%5CBig(%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BP%7D%20%5Cdot%7B%5Cmathbf%7BV%7D%7D_%7Bi%7D%5Cright)-%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cdot%7B%5Cmathbf%7BV%7D%7D_%7Bi%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7By%7D%20%5CBig)%0A" /></p><p>下面我们要考虑 REML score 对于 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cgamma%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cphi%7D" style="display:inline-block;margin: 0;"/> 的具体式子。</p>
<p>对于一个与 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 相关的方差组分 <img src="https://math.now.sh?inline=%5Cgamma_%7Bij%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D_%7Bij%7D" style="display:inline-block;margin: 0;"/> 推导如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cboldsymbol%7BV%7D_%7Bi%20j%7D%20%26%20%3D%5Cfrac%7B%5Cpartial%20%5Cboldsymbol%7BV%7D%7D%7B%5Cpartial%20%5Cgamma_%7Bi%20j%7D%7D%20%5C%5C%0A%26%20%3D%5Cfrac%7B%5Cpartial%20%5Cboldsymbol%7BZ%20G%20Z%7D%5E%7B%5Cprime%7D%7D%7B%5Cpartial%20%5Cgamma_%7Bi%20j%7D%7D%20%5C%5C%0A%26%20%3D%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Cgamma_%7Bi%20j%7D%7D%5Cleft%28%5Cboldsymbol%7BZ%7D_1%20%5Cboldsymbol%7BG%7D_1%20%5Cboldsymbol%7BZ%7D_1%5E%7B%5Cprime%7D%2B%5Cldots%2B%5Cboldsymbol%7BZ%7D_i%20%5Cboldsymbol%7BG%7D_i%20%5Cboldsymbol%7BZ%7D_i%5E%7B%5Cprime%7D%2B%5Cldots%20%5Cboldsymbol%7BZ%7D_s%20%5Cboldsymbol%7BG%7D_s%20%5Cboldsymbol%7BZ%7D_s%5E%7B%5Cprime%7D%5Cright%29%20%5C%5C%0A%26%20%3D%5Cboldsymbol%7BZ%7D_i%20%5Cfrac%7B%5Cpartial%20%5Cboldsymbol%7BG%7D_i%7D%7B%5Cpartial%20%5Cgamma_%7Bi%20j%7D%7D%20%5Cboldsymbol%7BZ%7D_i%5E%7B%5Cprime%7D%20%5C%5C%0A%26%20%3D%5Cboldsymbol%7BZ%7D_i%20%5Cdot%7B%5Cboldsymbol%7BG%7D%7D_%7Bi%20j%7D%20%5Cboldsymbol%7BZ%7D_i%5E%7B%5Cprime%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cdot%7B%5Cmathbf%7BG%7D%7D_%7Bi%20j%7D%20%3D%20%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BG%7D_i%7D%7B%5Cpartial%20%5Cgamma_%7Bi%20j%7D%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>如果模型中只有一个随机组分，则有：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cboldsymbol%7BV%7D_%7Bi%7D%20%26%20%3D%5Cfrac%7B%5Cpartial%20%5Cboldsymbol%7BV%7D%7D%7B%5Cpartial%20%5Cgamma_%7Bi%7D%7D%20%5C%5C%0A%0A%26%20%3D%5Cboldsymbol%7BZ%7D%20%5Cfrac%7B%5Cpartial%20%5Cboldsymbol%7BG%7D_i%7D%7B%5Cpartial%20%5Cgamma_%7Bi%7D%7D%20%5Cboldsymbol%7BZ%7D%5E%7B%5Cprime%7D%20%5C%5C%0A%26%20%3D%5Cboldsymbol%7BZ%7D%20%5Cdot%7B%5Cboldsymbol%7BG%7D%7D_%7Bi%7D%20%5Cboldsymbol%7BZ%7D%5E%7B%5Cprime%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>对于残差的方差组分 <img src="https://math.now.sh?inline=%5Cphi_%7Bi%7D" style="display:inline-block;margin: 0;"/> 则有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cfrac%7B%5Cpartial%20%5Cboldsymbol%7BV%7D%7D%7B%5Cpartial%20%5Cphi_%7Bi%7D%7D%20%5C%5C%0A%26%20%3D%20%5Cfrac%7B%5Cpartial%20%5Cboldsymbol%7B%5CSigma%7D%7D%7B%5Cpartial%20%5Cphi_%7Bi%7D%7D%20%5C%5C%0A%26%20%3D%20%5Cdot%7B%5Cboldsymbol%7B%5CSigma%7D%7D_%7Bi%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因此我们得到对于 <img src="https://math.now.sh?inline=%5Cgamma_%7Bij%7D" style="display:inline-block;margin: 0;"/> 的 REML score 式子为：</p>
<p style=""><img src="https://math.now.sh?from=U%28%5Cgamma_%7Bij%7D%29%20%3D%20-%20%5Cfrac%7B1%7D%7B2%7D%20%5CBig(%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BP%7D%20%5Cmathbf%7BZ%7D_i%20%5Cdot%7B%5Cmathbf%7BG%7D%7D_%7Bi%20j%7D%20%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%5Cright)-%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BZ%7D_i%20%5Cdot%7B%5Cmathbf%7BG%7D%7D_%7Bi%20j%7D%20%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7By%7D%20%5CBig)%0A" /></p><p>我们定义 <img src="https://math.now.sh?inline=%5Cmathbf%7BS%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=%28p%2Bq%29%20%5Ctimes%20q_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的矩阵（<img src="https://math.now.sh?inline=p%2Cq" style="display:inline-block;margin: 0;"/> 为所有固定因子和所有随机因子的水平数目，<img src="https://math.now.sh?inline=q_%7Bi%7D" style="display:inline-block;margin: 0;"/> 是第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 个随机因子的水平数目 ），并且满足 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D%5Cmathbf%7BS%7D_%7Bi%7D%3D%5Cmathbf%7BZ%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，因此  <img src="https://math.now.sh?inline=%5Cmathbf%7BS%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 中只有对应 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 在 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D" style="display:inline-block;margin: 0;"/> 中的位置存在一个单位矩阵，其它元素全是 0 （因为矩阵向量乘积可以理解为矩阵的列的线性组合，因此   <img src="https://math.now.sh?inline=%5Cmathbf%7BS%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 每一列只有一个对应 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的列号的元素为1，其它为0 ）。</p>
<p>我们将系数矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 写为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BC%7D%20%3D%20%5Cmathbf%7BW%5E%7B%5Cprime%7DR%5E%7B-1%7DW%7D%20%2B%20%5Cmathbf%7BG%7D%5E%7B*%7D%0A" /></p><p>其中</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BG%7D%5E%7B*%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>我们对上面式子进一步推导，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Coperatorname%7Btr%7D%5Cleft%28%20%5Cmathbf%7BPZ_%7Bi%7D%5Cdot%7B%5Cmathbf%7BG%7D%7D_%7Bi%20j%7DZ_%7Bi%7D%5E%7B%5Cprime%7D%7D%5Cright%29%20%5C%5C%0A%26%3D%20%5Coperatorname%7Btr%7D%5Cleft(%20%5Cmathbf%7B%5Cdot%7BG%7D_%7Bi%20j%7DZ_%7Bi%7D%5E%7B%5Cprime%7DPZ_%7Bi%7D%7D%5Cright)%20%5C%5C%0A%26%3D%20%5Coperatorname%7Btr%7D%5Cleft(%20%5Cmathbf%7B%5Cdot%7BG%7D_%7Bi%20j%7DS_%7Bi%7D%5E%7B%5Cprime%7DW%5E%7B%5Cprime%7DPWS_%7Bi%7D%7D%5Cright)%20%5C%5C%0A%26%3D%20%5Coperatorname%7Btr%7D%5Cleft(%20%5Cmathbf%7B%5Cdot%7BG%7D_%7Bi%20j%7DS_%7Bi%7D%5E%7B%5Cprime%7DW%5E%7B%5Cprime%7D(R%5E%7B-1%7D-R%5E%7B-1%7DWC%5E%7B-1%7DW%5E%7B%5Cprime%7DR%5E%7B-1%7D)WS_%7Bi%7D%7D%5Cright)%20%5C%5C%0A%26%3D%20%5Coperatorname%7Btr%7D%5Cleft(%20%5Cmathbf%7B%5Cdot%7BG%7D_%7Bi%20j%7DS_%7Bi%7D%5E%7B%5Cprime%7D(W%5E%7B%5Cprime%7DR%5E%7B-1%7DW-W%5E%7B%5Cprime%7DR%5E%7B-1%7DWC%5E%7B-1%7DW%5E%7B%5Cprime%7DR%5E%7B-1%7DW)S_%7Bi%7D%7D%5Cright)%20%5C%5C%0A%26%3D%20%5Coperatorname%7Btr%7D%5Cleft(%20%5Cmathbf%7B%5Cdot%7BG%7D_%7Bi%20j%7DS_%7Bi%7D%5E%7B%5Cprime%7DW%5E%7B%5Cprime%7DR%5E%7B-1%7DWC%5E%7B-1%7D(C-W%5E%7B%5Cprime%7DR%5E%7B-1%7DW)S_%7Bi%7D%7D%5Cright)%20%5C%5C%0A%26%3D%20%5Coperatorname%7Btr%7D%5Cleft(%20%5Cmathbf%7B%5Cdot%7BG%7D_%7Bi%20j%7DS_%7Bi%7D%5E%7B%5Cprime%7D(C-G%5E%7B*%7D)C%5E%7B-1%7DG%5E%7B*%7DS_%7Bi%7D%7D%5Cright)%20%5C%5C%0A%26%3D%20%5Coperatorname%7Btr%7D%5Cleft(%20%5Cmathbf%7B%5Cdot%7BG%7D_%7Bi%20j%7DS_%7Bi%7D%5E%7B%5Cprime%7DG%5E%7B*%7DS_%7Bi%7D%7D%5Cright)%20-%20%5Coperatorname%7Btr%7D%5Cleft(%20%5Cmathbf%7B%5Cdot%7BG%7D_%7Bi%20j%7DS_%7Bi%7D%5E%7B%5Cprime%7DG%5E%7B*%7DC%5E%7B-1%7DG%5E%7B*%7DS_%7Bi%7D%7D%5Cright)%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%5E%7B*%7DC%5E%7B-1%7DG%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> 可以写为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BG%5E%7B*%7DC%5E%7B-1%7DG%5E%7B*%7D%7D%20%26%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BC%7D%5E%7BXX%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BXZ%7D%20%5C%5C%0A%5Cmathbf%7BC%7D%5E%7BZX%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BZZ%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%5E%7BZZ%7D%20%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D%5E%7BZZ%7D" style="display:inline-block;margin: 0;"/> 就是<img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 中对应着随机效应的部分，由于我们可以有多个随机效应 ，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D%5E%7BZZ%7D" style="display:inline-block;margin: 0;"/> 可以进一步分块为（其中 <img src="https://math.now.sh?inline=s" style="display:inline-block;margin: 0;"/> 为随机效应数目）：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BC%7D%5E%7BZZ%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BC%7D%5E%7BZ_%7B1%7DZ_%7B1%7D%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BZ_%7B1%7DZ_%7B2%7D%7D%20%26%20%5Ccdots%20%26%20%5Cmathbf%7BC%7D%5E%7BZ_%7B1%7DZ_%7Bs%7D%7D%20%5C%5C%0A%5Cmathbf%7BC%7D%5E%7BZ_%7B2%7DZ_%7B1%7D%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BZ_%7B2%7DZ_%7B2%7D%7D%20%26%20%5Ccdots%20%26%20%5Cmathbf%7BC%7D%5E%7BZ_%7B2%7DZ_%7Bs%7D%7D%20%5C%5C%0A%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cddots%20%26%5Cvdots%20%5C%5C%0A%5Cmathbf%7BC%7D%5E%7BZ_%7Bs%7DZ_%7B1%7D%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BZ_%7Bs%7DZ_%7B2%7D%7D%20%26%20%5Ccdots%20%26%20%5Cmathbf%7BC%7D%5E%7BZ_%7Bs%7DZ_%7Bs%7D%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D%5E%7BZ_%7Bi%7DZ_%7Bi%7D%7D" style="display:inline-block;margin: 0;"/> 就是对应着第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 个随机效应 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的部分。</p>
<p>同样的道理，我们可以将 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵分块为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BG%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BG%7D_%7B1%7D%20%26%20%5Cmathbf%7B0%7D%20%26%20%5Ccdots%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BG%7D_%7B2%7D%20%26%20%5Ccdots%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cddots%20%26%5Cvdots%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%26%20%5Ccdots%20%26%20%5Cmathbf%7BG%7D_%7Bs%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>因此我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cmathbf%7BC%7D%5E%7BZZ%7D%5Cmathbf%7BG%7D%5E%7B-1%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BG%7D_%7B1%7D%5E%7B-1%7D%5Cmathbf%7BC%7D%5E%7BZ_%7B1%7DZ_%7B1%7D%7D%5Cmathbf%7BG%7D_%7B1%7D%5E%7B-1%7D%20%26%20%5Cmathbf%7BG%7D_%7B1%7D%5E%7B-1%7D%5Cmathbf%7BC%7D%5E%7BZ_%7B1%7DZ_%7B2%7D%7D%5Cmathbf%7BG%7D_%7B2%7D%5E%7B-1%7D%20%26%20%5Ccdots%20%26%20%5Cmathbf%7BG%7D_%7B1%7D%5E%7B-1%7D%5Cmathbf%7BC%7D%5E%7BZ_%7B1%7DZ_%7Bs%7D%7D%5Cmathbf%7BG%7D_%7Bs%7D%5E%7B-1%7D%20%5C%5C%0A%5Cmathbf%7BG%7D_%7B2%7D%5E%7B-1%7D%5Cmathbf%7BC%7D%5E%7BZ_%7B2%7DZ_%7B1%7D%7D%5Cmathbf%7BG%7D_%7B1%7D%5E%7B-1%7D%20%26%20%5Cmathbf%7BG%7D_%7B2%7D%5E%7B-1%7D%5Cmathbf%7BC%7D%5E%7BZ_%7B2%7DZ_%7B2%7D%7D%5Cmathbf%7BG%7D_%7B2%7D%5E%7B-1%7D%20%26%20%5Ccdots%20%26%20%5Cmathbf%7BG%7D_%7B2%7D%5E%7B-1%7D%5Cmathbf%7BC%7D%5E%7BZ_%7B2%7DZ_%7Bs%7D%7D%5Cmathbf%7BG%7D_%7Bs%7D%5E%7B-1%7D%20%5C%5C%0A%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cddots%20%26%5Cvdots%20%5C%5C%0A%5Cmathbf%7BG%7D_%7Bs%7D%5E%7B-1%7D%5Cmathbf%7BC%7D%5E%7BZ_%7Bs%7DZ_%7B1%7D%7D%5Cmathbf%7BG%7D_%7B1%7D%5E%7B-1%7D%20%26%20%5Cmathbf%7BG%7D_%7Bs%7D%5E%7B-1%7D%5Cmathbf%7BC%7D%5E%7BZ_%7Bs%7DZ_%7B2%7D%7D%5Cmathbf%7BG%7D_%7B2%7D%5E%7B-1%7D%20%26%20%5Ccdots%20%26%20%5Cmathbf%7BG%7D_%7Bs%7D%5E%7B-1%7D%5Cmathbf%7BC%7D%5E%7BZ_%7Bs%7DZ_%7Bs%7D%7D%5Cmathbf%7BG%7D_%7Bs%7D%5E%7B-1%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>因为   <img src="https://math.now.sh?inline=%5Cmathbf%7BS%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 中只有对应 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 在 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D" style="display:inline-block;margin: 0;"/> 中的位置存在一个单位矩阵，其它元素全是 0 ，因此我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BS%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7BG%5E%7B*%7DC%5E%7B-1%7DG%5E%7B*%7D%7D%5Cmathbf%7BS%7D_%7Bi%7D%20%3D%20%5Cmathbf%7BG%7D_%7Bi%7D%5E%7B-1%7D%5Cmathbf%7BC%7D%5E%7BZ_%7Bi%7DZ_%7Bi%7D%7D%5Cmathbf%7BG%7D_%7Bi%7D%5E%7B-1%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BS%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7BG%7D%5E%7B*%7D%5Cmathbf%7BS%7D_%7Bi%7D%20%3D%20%5Cmathbf%7BG%7D_%7Bi%7D%5E%7B-1%7D%0A" /></p><p>因此，<img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28%20%5Cmathbf%7BPZ_%7Bi%7D%5Cdot%7B%5Cmathbf%7BG%7D%7D_%7Bi%20j%7DZ_%7Bi%7D%5E%7B%5Cprime%7D%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 可以进一步推导得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Coperatorname%7Btr%7D%5Cleft%28%20%5Cmathbf%7BPZ_%7Bi%7D%5Cdot%7B%5Cmathbf%7BG%7D%7D_%7Bi%20j%7DZ_%7Bi%7D%5E%7B%5Cprime%7D%7D%5Cright%29%5C%5C%0A%26%3D%20%5Coperatorname%7Btr%7D%5Cleft(%20%5Cmathbf%7B%5Cdot%7BG%7D_%7Bi%20j%7DS_%7Bi%7D%5E%7B%5Cprime%7DG%5E%7B*%7DS_%7Bi%7D%7D%5Cright)%20-%20%5Coperatorname%7Btr%7D%5Cleft(%20%5Cmathbf%7B%5Cdot%7BG%7D_%7Bi%20j%7DS_%7Bi%7D%5E%7B%5Cprime%7DG%5E%7B*%7DC%5E%7B-1%7DG%5E%7B*%7DS_%7Bi%7D%7D%5Cright)%20%5C%5C%0A%26%3D%20%5Coperatorname%7Btr%7D%5Cleft(%20%5Cmathbf%7B%5Cdot%7BG%7D_%7Bi%20j%7DG%5E%7B-1%7D_%7Bi%7D%7D%5Cright)%20-%20%5Coperatorname%7Btr%7D%5Cleft(%20%5Cmathbf%7B%5Cdot%7BG%7D_%7Bi%20j%7D%7D%5Cmathbf%7BG%7D_%7Bi%7D%5E%7B-1%7D%5Cmathbf%7BC%7D%5E%7BZ_%7Bi%7DZ_%7Bi%7D%7D%5Cmathbf%7BG%7D_%7Bi%7D%5E%7B-1%7D%5Cright)%20%5C%5C%0A%26%3D%20%5Coperatorname%7Btr%7D%5Cleft(%20%5Cmathbf%7B%5Cdot%7BG%7D_%7Bi%20j%7DG%5E%7B-1%7D_%7Bi%7D%7D%5Cright)%20-%20%5Coperatorname%7Btr%7D%5Cleft(%20%5Cmathbf%7B%5Cdot%7BG%7D_%7Bi%20j%7D%7D%5Cmathbf%7BG%7D_%7Bi%7D%5E%7B-1%7D%5Cmathbf%7BC%7D%5E%7BZ_%7Bi%7DZ_%7Bi%7D%7D%5Cmathbf%7BG%7D_%7Bi%7D%5E%7B-1%7D%5Cright)%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>对第二个式子推导前，我们先用 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D" style="display:inline-block;margin: 0;"/> 得到随机效应 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> 的式子，根据BLUP方法，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bu%7D%3D%5Cmathbf%7BGZ%5E%7B%5Cprime%7DV%5E%7B-1%7D%28y-X%5Cboldsymbol%7B%5Cbeta%7D%29%7D%0A" /></p><p>同时我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BPy%7D%20%3D%20%5Cmathbf%7BV%5E%7B-1%7D%28y-X%5Cboldsymbol%7B%5Cbeta%7D%29%7D%0A" /></p><p>因此，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7Bu%7D%26%3D%5Cmathbf%7BGZ%5E%7B%5Cprime%7DPy%7D%20%5C%5C%0A%26%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BG%7D_%7B1%7D%20%26%20%5Cmathbf%7B0%7D%20%26%20%5Ccdots%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BG%7D_%7B2%7D%20%26%20%5Ccdots%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cddots%20%26%5Cvdots%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%26%20%5Ccdots%20%26%20%5Cmathbf%7BG%7D_%7Bs%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BZ%7D_%7B1%7D%5E%7B%5Cprime%7D%20%20%5C%5C%0A%5Cmathbf%7BZ%7D_%7B2%7D%5E%7B%5Cprime%7D%20%20%5C%5C%0A%5Cvdots%20%5C%5C%0A%5Cmathbf%7BZ%7D_%7Bs%7D%5E%7B%5Cprime%7D%20%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%5Cmathbf%7BPy%7D%20%5C%5C%0A%26%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BG%7D_%7B1%7D%5Cmathbf%7BZ%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BPy%7D%20%5C%5C%0A%5Cmathbf%7BG%7D_%7B2%7D%5Cmathbf%7BZ%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BPy%7D%20%5C%5C%0A%5Cvdots%20%5C%5C%0A%5Cmathbf%7BG%7D_%7Bs%7D%5Cmathbf%7BZ%7D_%7Bs%7D%5E%7B%5Cprime%7D%5Cmathbf%7BPy%7D%20%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>我们同时得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bu%7D_%7Bi%7D%20%3D%20%5Cmathbf%7BG%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BPy%7D%0A" /></p><p>因此，对右手项推导得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cdot%7B%5Cmathbf%7BG%7D%7D_%7Bi%20j%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BG%7D_%7Bi%7D%20%5Cmathbf%7BG%7D_%7Bi%7D%5E%7B-1%7D%20%5Cdot%7B%5Cmathbf%7BG%7D%7D_%7Bi%20j%7D%20%5Cmathbf%7BG%7D_%7Bi%7D%5E%7B-1%7D%20%5Cmathbf%7BG%7D_%7Bi%7D%20%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7Bu%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BG%7D_%7Bi%7D%5E%7B-1%7D%20%5Cdot%7B%5Cmathbf%7BG%7D%7D_%7Bi%20j%7D%20%5Cmathbf%7BG%7D_%7Bi%7D%5E%7B-1%7D%20%5Cmathbf%7Bu%7D_%7Bi%7D%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们得到对于 <img src="https://math.now.sh?inline=%5Cgamma_%7Bij%7D" style="display:inline-block;margin: 0;"/> 的 REML score 式子可以写为：</p>
<p style=""><img src="https://math.now.sh?from=U%28%5Cgamma_%7Bij%7D%29%20%3D%20-%20%5Cfrac%7B1%7D%7B2%7D%20%5CBig(%20%5Coperatorname%7Btr%7D%5Cleft(%20%5Cmathbf%7BG%5E%7B-1%7D_%7Bi%7D%5Cdot%7BG%7D_%7Bi%20j%7D%7D%5Cright)%20-%20%5Coperatorname%7Btr%7D%5Cleft(%20%5Cmathbf%7BC%7D%5E%7BZ_%7Bi%7DZ_%7Bi%7D%7D%5Cmathbf%7BG%7D_%7Bi%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7BG%7D_%7Bi%20j%7D%7D%5Cmathbf%7BG%7D_%7Bi%7D%5E%7B-1%7D%5Cright)-%5Cmathbf%7Bu%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BG%7D_%7Bi%7D%5E%7B-1%7D%20%5Cdot%7B%5Cmathbf%7BG%7D%7D_%7Bi%20j%7D%20%5Cmathbf%7BG%7D_%7Bi%7D%5E%7B-1%7D%20%5Cmathbf%7Bu%7D_%7Bi%7D%20%5CBig)%0A" /></p><p>如果模型中只有一个随机效应，则有</p>
<p style=""><img src="https://math.now.sh?from=U%28%5Cgamma_%7Bi%7D%29%20%3D%20-%20%5Cfrac%7B1%7D%7B2%7D%20%5CBig(%20%5Coperatorname%7Btr%7D%5Cleft(%20%5Cmathbf%7BG%5E%7B-1%7D%5Cdot%7BG%7D_%7Bi%20%7D%7D%5Cright)%20-%20%5Coperatorname%7Btr%7D%5Cleft(%20%5Cmathbf%7BC%7D%5E%7BZZ%7D%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7BG%7D_%7Bi%7D%7D%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright)-%5Cmathbf%7Bu%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5Cdot%7B%5Cmathbf%7BG%7D%7D_%7Bi%7D%20%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5Cmathbf%7Bu%7D%20%5CBig)%0A" /></p><p>对于残差的方差组分 <img src="https://math.now.sh?inline=%5Cphi_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，我们将 <img src="https://math.now.sh?inline=%5Cdot%7B%5Cmathbf%7BV%7D%7D_%7Bi%7D%20%3D%20%5Cdot%7B%5Cmathbf%7B%5CSigma%7D%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/>  代入 <img src="https://math.now.sh?inline=U%28%5Ckappa_%7Bi%7D%29%20%3D%20-%20%5Cfrac%7B1%7D%7B2%7D%20%5CBig(%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BP%7D%20%5Cdot%7B%5Cmathbf%7BV%7D%7D_%7Bi%7D%5Cright)-%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cdot%7B%5Cmathbf%7BV%7D%7D_%7Bi%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7By%7D%20%5CBig)" style="display:inline-block;margin: 0;"/> 得到</p>
<p style=""><img src="https://math.now.sh?from=U%28%5Cphi_%7Bi%7D%29%20%3D%20-%20%5Cfrac%7B1%7D%7B2%7D%20%5CBig(%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BP%7D%20%5Cdot%7B%5Cmathbf%7B%5CSigma%7D%7D_%7Bi%7D%5Cright)-%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cdot%7B%5Cmathbf%7B%5CSigma%7D%7D_%7Bi%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7By%7D%20%5CBig)%0A" /></p><p>我们对其进行推导得到：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BP%7D%20%5Cdot%7B%5Cmathbf%7B%5CSigma%7D%7D_%7Bi%7D%5Cright%29%20%5C%5C%0A%26%3D%20%5Coperatorname%7Btr%7D%20%5Cleft(%20%5Cleft(%5Cmathbf%7BR%5E%7B-1%7D-R%5E%7B-1%7DWC%5E%7B-1%7DW%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%20%5Cright)%20%5Cdot%7B%5Cmathbf%7B%5CSigma%7D%7D_%7Bi%7D%5Cright)%20%5C%5C%0A%26%3D%20%5Coperatorname%7Btr%7D%20%5Cleft(%20%5Cleft(%5Cmathbf%7B%5CSigma%5E%7B-1%7D-%5CSigma%5E%7B-1%7DWC%5E%7B-1%7DW%5E%7B%5Cprime%7D%5CSigma%5E%7B-1%7D%7D%20%5Cright)%20%5Cdot%7B%5Cmathbf%7B%5CSigma%7D%7D_%7Bi%7D%5Cright)%20%5C%5C%0A%26%3D%20%5Coperatorname%7Btr%7D%20%20%5Cleft(%5Cmathbf%7B%5CSigma%5E%7B-1%7D%5Cdot%7B%5Cmathbf%7B%5CSigma%7D%7D_%7Bi%7D-%5CSigma%5E%7B-1%7DWC%5E%7B-1%7DW%5E%7B%5Cprime%7D%5CSigma%5E%7B-1%7D%7D%5Cdot%7B%5Cmathbf%7B%5CSigma%7D%7D_%7Bi%7D%20%5Cright)%20%20%5C%5C%0A%26%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>对于第二个式子，首先我们推导 <img src="https://math.now.sh?inline=%5Cmathbf%7BPy%7D%3D%5Cmathbf%7BR%5E%7B-1%7De%7D" style="display:inline-block;margin: 0;"/> ，如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cmathbf%7BPy%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BV%5E%7B-1%7D%7D%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D%29%20%5C%5C%0A%26%3D%20%5Cleft(%20%5Cmathbf%7BR%5E%7B-1%7D-R%5E%7B-1%7DZ%5Cleft(Z%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D%5Cright)%5E%7B-1%7DZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%20%5Cright)(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D)%20%5C%5C%0A%26%3D%20%5Cmathbf%7BR%5E%7B-1%7D%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D)-%20%5Cmathbf%7BR%5E%7B-1%7DZ%5Cleft(Z%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D%5Cright)%5E%7B-1%7DZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D)%20%5C%5C%0A%26%3D%20%5Cmathbf%7BR%5E%7B-1%7D%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D)-%20%5Cmathbf%7BR%5E%7B-1%7DZ%7D%5Cmathbf%7Bu%7D%20%5Cquad%20%5Cbecause%20%5Cmathbf%7Bu%7D%20%3D%5Cleft(%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%20%20%5C%5C%0A%26%3D%20%5Cmathbf%7BR%5E%7B-1%7D%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D%20-%5Cmathbf%7BZ%7D%5Cmathbf%7Bu%7D)%20%5C%5C%0A%26%3D%20%5Cmathbf%7BR%5E%7B-1%7D%7D%5Cmathbf%7Be%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7B%5CSigma%5E%7B-1%7D%7D%5Cmathbf%7Be%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cdot%7B%5Cmathbf%7B%5CSigma%7D%7D_%7Bi%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7By%7D%20%0A%3D%20%5Cmathbf%7Be%7D%5E%7B%5Cprime%7D%5Cmathbf%7B%5CSigma%5E%7B-1%7D%7D%20%5Cdot%7B%5Cmathbf%7B%5CSigma%7D%7D_%7Bi%7D%5Cmathbf%7B%5CSigma%5E%7B-1%7D%7D%5Cmathbf%7Be%7D%0A" /></p><p>因此我们得到关于 <img src="https://math.now.sh?inline=%5Cphi_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的 REML score 式子如下</p>
<p style=""><img src="https://math.now.sh?from=U%28%5Cphi_%7Bi%7D%29%20%3D%20-%20%5Cfrac%7B1%7D%7B2%7D%20%5CBig(%20%5Coperatorname%7Btr%7D%20%20%5Cleft(%5Cmathbf%7B%5CSigma%5E%7B-1%7D%5Cdot%7B%5Cmathbf%7B%5CSigma%7D%7D_%7Bi%7D%7D%5Cright)%20-%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BC%5E%7B-1%7DW%5E%7B%5Cprime%7D%5CSigma%5E%7B-1%7D%7D%5Cdot%7B%5Cmathbf%7B%5CSigma%7D%7D_%7Bi%7D%5Cmathbf%7B%5CSigma%5E%7B-1%7DW%7D%20%5Cright)-%5Cmathbf%7Be%7D%5E%7B%5Cprime%7D%5Cmathbf%7B%5CSigma%5E%7B-1%7D%7D%20%5Cdot%7B%5Cmathbf%7B%5CSigma%7D%7D_%7Bi%7D%5Cmathbf%7B%5CSigma%5E%7B-1%7D%7D%5Cmathbf%7Be%7D%20%5CBig)%0A" /></p><h1>单性状模型的迭代公式</h1>
<p>对于单性状模型（<strong>假设所有随机因子之间均不存在相关</strong>），我们将 <img src="https://math.now.sh?inline=U%28%5Cgamma_%7Bij%7D%29" style="display:inline-block;margin: 0;"/> 设为 0， 推导一下，我们得到：</p>
<p style=""><img src="https://math.now.sh?from=q_%7Bi%7D%2F%5Csigma_%7Bi%7D%5E%7B2%7D%20-%20%5Coperatorname%7Btr%7D%5Cleft%28%20%5Cmathbf%7BC%7D%5E%7BZ_%7Bi%7DZ_%7Bi%7D%7D%5Cmathbf%7BA%7D_%7Bi%7D%5E%7B-1%7D%5Cright%29%2F%5Csigma_%7Bi%7D%5E%7B4%7D%20%3D%20%5Cmathbf%7Bu%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BA%7D_%7Bi%7D%5E%7B-1%7D%20%5Cmathbf%7Bu%7D_%7Bi%7D%2F%5Csigma_%7Bi%7D%5E%7B4%7D%0A" /></p><p>整理一下，我们得到（其中 <img src="https://math.now.sh?inline=q_%7Bi%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=u_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的水平数目，或者说是  <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的列数）</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D%3D%5Cleft%28%5Chat%7B%5Cmathbf%7Bu%7D%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BA%7D_%7Bi%7D%5E%7B-1%7D%20%5Chat%7B%5Cmathbf%7Bu%7D%7D_%7Bi%7D%2B%5Coperatorname%7Btr%7D%5Cleft(%20%5Cmathbf%7BC%7D%5E%7BZ_%7Bi%7DZ_%7Bi%7D%7D%5Cmathbf%7BA%7D_%7Bi%7D%5E%7B-1%7D%5Cright%29%5Cright)%20%2F%20q_%7Bi%7D%0A" /></p><p>一个收敛更快的迭代公式为</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D%3D%5Cfrac%7B%5Chat%7B%5Cmathbf%7Bu%7D%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BA%7D_%7Bi%7D%5E%7B-1%7D%20%5Chat%7B%5Cmathbf%7Bu%7D%7D_%7Bi%7D%7D%7Bq_%7Bi%7D-%20%5Coperatorname%7Btr%7D%5Cleft%28%20%5Cmathbf%7BC%7D%5E%7BZ_%7Bi%7DZ_%7Bi%7D%7D%5Cmathbf%7BA%7D_%7Bi%7D%5E%7B-1%7D%5Cright%29%2F%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D%20%7D%0A" /></p><p>联合使用之前推导得到的残差计算公式(其中 <strong><img src="https://math.now.sh?inline=N" style="display:inline-block;margin: 0;"/> 是表型数目，<img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的秩</strong>，只适合单性状模型)，我们便得到了完整的 EM-REML 估计公式</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Csigma%7D_%7B0%7D%5E%7B2%7D%3D%5Cleft%28%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D-%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D-%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D%20%5Chat%7B%5Cmathbf%7Bu%7D%7D%5Cright%29%20%2F(N-r)%0A" /></p><p>这里我们还有残差的另外两种推导公式，如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Csigma_%7B0%7D%5E%7B2%7D%20%26%3D%20%5Cfrac%7B1%7D%7Bn%7D%28%5Cmathbf%7Be%7D%5E%7B%5Cprime%7D%5Cmathbf%7Be%7D%2B%20%5Coperatorname%7Btr%7D(%5Cmathbf%7BWC%5E%7B-1%7DW%5E%7B%5Cprime%7D%7D%29)%20%5C%5C%0A%5Ctext%7Bor%7D%26%5C%5C%0A%5Csigma_%7B0%7D%5E%7B2%7D%20%26%3D%20%5Cfrac%7B1%7D%7Bn%7D%5Cleft(%5Csigma_%7B0%7D%5E%7B2%7D%5Cleft(p%2Bq%5Cright)-%20%5Csigma_%7B0%7D%5E%7B2%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BG%5E%7B-1%7DC%5E%7BZZ%7D%7D%5Cright)%20%2B%20%5Cmathbf%7Be%7D%5E%7B%5Cprime%7D%5Cmathbf%7Be%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>将 <img src="https://math.now.sh?inline=U%28%5Cphi_%7Bi%7D%29" style="display:inline-block;margin: 0;"/> 设为0，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7Bn%7D%7B%5Csigma_%7B0%7D%5E%7B2%7D%7D-%5Cfrac%7B%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BWC%5E%7B-1%7DW%5E%7B%5Cprime%7D%7D%20%5Cright%29%7D%7B%5Csigma_%7B0%7D%5E%7B4%7D%7D%20%3D%20%5Cfrac%7B%5Cmathbf%7Be%5E%7B%5Cprime%7De%7D%7D%7B%5Csigma_%7B0%7D%5E%7B4%7D%7D%0A" /></p><p>因此可以得到第一个式子，我们对其中 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BWC%5E%7B-1%7DW%5E%7B%5Cprime%7D%7D%20%5Cright%29%2F%5Csigma_%7B0%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 推导如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BWC%5E%7B-1%7DW%5E%7B%5Cprime%7D%7D%20%5Cright%29%2F%5Csigma_%7B0%7D%5E%7B2%7D%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BW%5E%7B%5Cprime%7DR%5E%7B-1%7DWC%5E%7B-1%7D%7D%20%5Cright)%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7B(C-G%5E%7B*%7D)C%5E%7B-1%7D%7D%20%5Cright)%20%5Cquad%20%5Cbecause%20%5Cmathbf%7BC%7D%20%3D%20%5Cmathbf%7BW%5E%7B%5Cprime%7DR%5E%7B-1%7DW%7D%20%2B%20%5Cmathbf%7BG%7D%5E%7B*%7D%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BI_%7Bp%2Bq%7D-G%5E%7B*%7DC%5E%7B-1%7D%7D%20%5Cright)%5C%5C%0A%26%3D%20p%2Bq-%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BG%5E%7B*%7DC%5E%7B-1%7D%7D%20%5Cright)%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>对于 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%5E%7B*%7DC%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> ，我们对其推导得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BG%5E%7B*%7DC%5E%7B-1%7D%7D%20%26%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BC%7D%5E%7BXX%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BXZ%7D%20%5C%5C%0A%5Cmathbf%7BC%7D%5E%7BZX%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BZZ%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cmathbf%7BC%7D%5E%7BZX%7D%20%26%20%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cmathbf%7BC%7D%5E%7BZZ%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%28%5Cmathbf%7BG%5E%7B*%7DC%5E%7B-1%7D%7D%29%20%3D%20%5Coperatorname%7Btr%7D(%5Cmathbf%7BG%5E%7B-1%7DC%5E%7BZZ%7D%7D)%0A" /></p><p>因此我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BWC%5E%7B-1%7DW%5E%7B%5Cprime%7D%7D%20%5Cright%29%2F%5Csigma_%7B0%7D%5E%7B2%7D%20%3D%20p%2Bq-%5Coperatorname%7Btr%7D(%5Cmathbf%7BG%5E%7B-1%7DC%5E%7BZZ%7D%7D)%0A" /></p><p>代入上式，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7Bn-p-q%2B%5Coperatorname%7Btr%7D%28%5Cmathbf%7BG%5E%7B-1%7DC%5E%7BZZ%7D%7D%29%7D%7B%5Csigma_%7B0%7D%5E%7B2%7D%7D%20%3D%20%5Cfrac%7B%5Cmathbf%7Be%5E%7B%5Cprime%7De%7D%7D%7B%5Csigma_%7B0%7D%5E%7B4%7D%7D%0A" /></p><p>因此可以得到第二个式子。</p>
<h1>多性状模型的迭代公式</h1>
<h2 id="随机效应">随机效应</h2>
<p>对于多性状模型，假设只有一个随机因子（其实多个因子同理，只是这样不用写 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵的下标了，符号更加清晰），按照性状排序， 则有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BG%7D%20%3D%20%20%5Cmathbf%7BG%7D_%7Bk%7D%20%5Cotimes%20%20%5Cmathbf%7BA%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7Bk%7D" style="display:inline-block;margin: 0;"/> 就是相应的方差组分的矩阵形式，如下所示，即反过来 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cgamma%7D%20%3D%20%5Cmathrm%7Bvec%7D%28%5Cmathbf%7BG%7D_%7Bk%7D%29" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 为性状数目。</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7BG%7D_k%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cgamma_%7B11%7D%20%26%20%5Cgamma_%7B12%7D%20%26%20%5Ccdots%20%26%20%5Cgamma_%7B1%20k%7D%20%5C%5C%0A%5Cgamma_%7B12%7D%20%26%20%5Cgamma_%7B22%7D%20%26%20%5Ccdots%20%26%20%5Cgamma_%7B2%20k%7D%20%5C%5C%0A%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cddots%20%26%20%5Cvdots%20%5C%5C%0A%5Cgamma_%7B1%20k%7D%20%26%20%5Cgamma_%7B2%20k%7D%20%26%20%5Ccdots%20%26%20%5Cgamma_%7Bk%20k%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>对于随机因子 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> ，假设对于<strong>每个性状的随机因子水平数目均为 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/></strong> ，则 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> 也可以表示为一个 <img src="https://math.now.sh?inline=m%20%5Ctimes%20k" style="display:inline-block;margin: 0;"/> 的矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> ，其中每一列代表一个性状的所有水平，如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BU%7D%20%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0Au_%7B11%7D%20%26%20u_%7B12%7D%20%26%20%5Ccdots%20%26%20u_%7B1%20k%7D%20%5C%5C%0Au_%7B21%7D%20%26%20u_%7B22%7D%20%26%20%5Ccdots%20%26%20u_%7B2%20k%7D%20%5C%5C%0A%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cddots%20%26%20%5Cvdots%20%5C%5C%0Au_%7Bm1%7D%20%26%20u_%7Bm2%7D%20%26%20%5Ccdots%20%26%20u_%7Bm%20k%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cmathbf%7Bu%7D_%7B1%7D%20%26%20%5Cmathbf%7Bu%7D_%7B2%7D%20%26%20%5Ccdots%20%26%20%5Cmathbf%7Bu%7D_%7B%20k%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>反过来则有 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D%20%3D%20%5Cmathrm%7Bvec%7D%20%28%5Cmathbf%7BU%7D%29" style="display:inline-block;margin: 0;"/> 。</p>
<p>对于 <img src="https://math.now.sh?inline=%5Cgamma_%7Bij%7D" style="display:inline-block;margin: 0;"/> ，我们有公式</p>
<p style=""><img src="https://math.now.sh?from=U%28%5Cgamma_%7Bij%7D%29%20%3D%20-%20%5Cfrac%7B1%7D%7B2%7D%20%5CBig(%20%5Coperatorname%7Btr%7D%5Cleft(%20%5Cmathbf%7BG%5E%7B-1%7D%5Cdot%7BG%7D_%7Bi%20j%7D%7D%5Cright)%20-%20%5Coperatorname%7Btr%7D%5Cleft(%20%5Cmathbf%7BC%7D%5E%7BZZ%7D%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7BG%7D_%7Bi%20j%7D%7D%5Cmathbf%7BG%7D_%7Bi%7D%5E%7B-1%7D%5Cright)-%5Cmathbf%7Bu%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5Cdot%7B%5Cmathbf%7BG%7D%7D_%7Bi%20j%7D%20%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5Cmathbf%7Bu%7D%20%5CBig)%0A" /></p><p>因为  <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Cdot%7BG%7D_%7Bi%20j%7D%7D" style="display:inline-block;margin: 0;"/> 相应 <img src="https://math.now.sh?inline=%28m%2Cn%29" style="display:inline-block;margin: 0;"/> 位置的元素 就是 <img src="https://math.now.sh?inline=%5Cpartial%20g_%7Bmn%7D%20%2F%20%5Cpartial%20%5Cgamma_%7Bij%7D" style="display:inline-block;margin: 0;"/> ，所有易得 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Cdot%7BG%7D_%7Bi%20j%7D%7D%20%3D%20%5Cmathbf%7B%5Cdot%7BG%7D_%7Bk_%7Bi%20j%7D%7D%7D%20%5Cotimes%20%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Cdot%7BG%7D_%7Bk_%7Bi%20j%7D%7D%7D%20%3D%20%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BG%7D_%7Bk%7D%7D%7B%5Cpartial%20%5Cgamma_%7Bij%7D%7D" style="display:inline-block;margin: 0;"/>  。</p>
<p>因此，我们推导得到。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%20%5Cmathbf%7BG%5E%7B-1%7D%5Cdot%7BG%7D_%7Bi%20j%7D%7D%20%5C%5C%0A%26%3D%20%5Cleft%28%20%20%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cright%29%20%5Cleft(%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%20%5Cotimes%20%5Cmathbf%7BA%7D%5Cright)%20%5C%5C%0A%26%3D%20%5Cleft(%20%20%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%20%5Cotimes%20%5Cmathbf%7BI%7D_%7Bm%7D%20%5Cright)%20%0A%26%5C%5C%0A%26%5C%5C%0A%26%20%5Coperatorname%7Btr%7D%20(%5Cmathbf%7BG%5E%7B-1%7D%5Cdot%7BG%7D_%7Bi%20j%7D%7D)%20%5C%5C%0A%26%3D%20%5Coperatorname%7Btr%7D%5Cleft(%20%20%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%20%5Cotimes%20%5Cmathbf%7BI%7D_%7Bm%7D%20%5Cright)%20%5C%5C%0A%26%3D%20m%20%5Coperatorname%7Btr%7D%5Cleft(%20%20%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%20%5Cright)%20%5C%5C%0A%26%5C%5C%0A%26%5C%5C%0A%26%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5Cdot%7B%5Cmathbf%7BG%7D%7D_%7Bi%20j%7D%20%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5C%5C%0A%26%3D%20%5Cleft(%20%20%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cright)%20%5Cleft(%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%20%5Cotimes%20%5Cmathbf%7BA%7D%5Cright)%20%5Cleft(%20%20%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cright)%5C%5C%0A%26%3D%20%5Cleft(%20%20%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cright)%20%0A%0A%26%5C%5C%0A%26%5C%5C%0A%26%5Cmathbf%7Bu%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5Cdot%7B%5Cmathbf%7BG%7D%7D_%7Bi%20j%7D%20%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5Cmathbf%7Bu%7D%20%5C%5C%0A%26%3D%20%5Cmathrm%7Bvec%7D(%5Cmathbf%7BU%7D)%5E%7B%5Cprime%7D%20%5Cleft(%20%20%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cright)%20%5Cmathrm%7Bvec%7D(%5Cmathbf%7BU%7D)%20%5C%5C%0A%0A%26%3D%20%5Cmathrm%7Btr%7D(%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7BU%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cmathbf%7BU%7D)%20%5Cquad%20%5Cbecause%20%5Cmathrm%7Bvec%7D(%5Cmathbf%7BA%7D)%5E%7B%5Cprime%7D%20(%5Cmathbf%7BB%7D%20%5Cotimes%20%5Cmathbf%7BC%7D)%20%5Cmathrm%7Bvec%7D(%5Cmathbf%7BA%7D)%20%3D%20%5Cmathrm%7Btr%7D(%5Cmathbf%7BB%5E%7B%5Cprime%7DA%5E%7B%5Cprime%7DCA%7D)%20%5C%5C%0A%26%3D%20%5Cmathrm%7Btr%7D(%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5CDelta%7D%20)%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>最后一个式子中，我们设 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CDelta%7D%20%3D%20%5Cmathbf%7BU%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>代入 <img src="https://math.now.sh?inline=U%28%5Cgamma_%7Bij%7D%29" style="display:inline-block;margin: 0;"/> 得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AU%28%5Cgamma_%7Bij%7D%29%20%26%3D%20-%20%5Cfrac%7B1%7D%7B2%7D%20%5CBig(%20m%20%5Coperatorname%7Btr%7D%5Cleft(%20%20%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%20%5Cright)%20-%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BC%7D%5E%7BZZ%7D%20%5Cleft(%20%20%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cright)%20%5Cright)-%5Cmathrm%7Btr%7D(%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5CDelta%7D%20)%20%20%5CBig)%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>我们需要对这个式子进一步简化，我们知道  <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7Bk%7D" style="display:inline-block;margin: 0;"/> 是一个对称矩阵，因此  <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 也是一个对称矩阵，  我们将   <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 中的元素表示为 <img src="https://math.now.sh?inline=%5Cgamma%5E%7Bij%7D" style="display:inline-block;margin: 0;"/> (<img src="https://math.now.sh?inline=i%20%5Cleq%20j" style="display:inline-block;margin: 0;"/> ) 。</p>
<p>首先我们考虑 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28%20%20%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%20%5Cright%29" style="display:inline-block;margin: 0;"/> 这一项，当  <img src="https://math.now.sh?inline=i%3Dj" style="display:inline-block;margin: 0;"/> 时，矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D" style="display:inline-block;margin: 0;"/> 只有 <img src="https://math.now.sh?inline=%28i%2Ci%29" style="display:inline-block;margin: 0;"/> 位置元素为1，其它位置元素均为 0 。因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D" style="display:inline-block;margin: 0;"/> 只有第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 列元素为 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 的第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 列元素，其它元素为 0 。因此，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%28%20%20%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%20%5Cright%29%20%3D%20%5Cgamma%5E%7Bii%7D%0A" /></p><p>当   <img src="https://math.now.sh?inline=i%20%5Cneq%20j" style="display:inline-block;margin: 0;"/>  时, 矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D" style="display:inline-block;margin: 0;"/> 只有 <img src="https://math.now.sh?inline=%28i%2Cj%29" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%28j%2Ci%29" style="display:inline-block;margin: 0;"/> 位置为 1，其它位置元素为 0 。因此  <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D" style="display:inline-block;margin: 0;"/> 其第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 列为 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 的第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/>  列， 其第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 列为 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 的第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/>  列，其它位置元素为 0 。因此我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%28%20%20%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%20%5Cright%29%20%3D%20%5Cgamma%5E%7Bij%7D%20%2B%20%5Cgamma%5E%7Bji%7D%20%3D%202%20%5Cgamma%5E%7Bij%7D%0A" /></p><p>即我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%28%5Cboldsymbol%7BG%7D_k%5E%7B-1%7D%20%5Cdot%7B%5Cboldsymbol%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cright%29%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cgamma%5E%7Bi%20i%7D%2C%20%26%20i%3Dj%20%5C%5C%0A2%20%5Cgamma%5E%7Bi%20j%7D%2C%20%26%20i%20%5Cneq%20j%0A%5Cend%7Barray%7D%5Cright.%0A" /></p><p>我们现在考虑第三项，如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathrm%7Btr%7D%28%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5CDelta%7D%29%20%26%20%3D%20%5Cmathrm%7Btr%7D(%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5CDelta%7D%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D)%20%5C%5C%0A%26%20%3D%20%5Cmathrm%7Btr%7D(%5Cmathbf%7B%5CDelta%7D%5E%7B*%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D)%20%20%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>其中我们设 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CDelta%7D%5E%7B*%7D%20%3D%20%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5CDelta%7D%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%3D%20%5C%7B%20%5Cdelta_%7Bij%7D%5E%7B*%7D%5C%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>当 <img src="https://math.now.sh?inline=i%3Dj" style="display:inline-block;margin: 0;"/>  时，矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CDelta%7D%5E%7B*%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D" style="display:inline-block;margin: 0;"/> 只有第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 列元素为 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CDelta%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 的第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 列元素 ，其它位置元素为 0 。因此，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7Btr%7D%28%5Cmathbf%7B%5CDelta%7D%5E%7B*%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%29%20%3D%20%5Cdelta_%7Bii%7D%5E%7B*%7D%0A" /></p><p>当   <img src="https://math.now.sh?inline=i%20%5Cneq%20j" style="display:inline-block;margin: 0;"/>  时, 矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CDelta%7D%5E%7B*%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D" style="display:inline-block;margin: 0;"/> 其第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 列为 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CDelta%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 的第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/>  列， 其第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 列为 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CDelta%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 的第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/>  列，其它位置元素为 0 。因此，我们得到 (因为  <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CDelta%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 对称)</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7Btr%7D%28%5Cmathbf%7B%5CDelta%7D%5E%7B*%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%29%20%3D%20%5Cdelta_%7Bij%7D%5E%7B*%7D%20%2B%20%5Cdelta_%7Bji%7D%5E%7B*%7D%20%3D%202%20%5Cdelta_%7Bij%7D%5E%7B*%7D%0A" /></p><p>综上，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7Btr%7D%28%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5CDelta%7D%29%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cdelta%5E%7B*%7D_%7Bi%20i%7D%2C%20%26%20i%3Dj%20%5C%5C%0A2%20%5Cdelta%5E%7B*%7D_%7Bi%20j%7D%2C%20%26%20i%20%5Cneq%20j%0A%5Cend%7Barray%7D%5Cright.%0A" /></p><p>我们现在考虑第二项，我们将 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D%5E%7BZZ%7D" style="display:inline-block;margin: 0;"/> 按照性状分块为 <img src="https://math.now.sh?inline=k%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 个 <img src="https://math.now.sh?inline=m%20%5Ctimes%20m" style="display:inline-block;margin: 0;"/> 的子矩阵，如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BC%7D%5E%7BZZ%7D%20%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7B11%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7B12%7D%20%26%20%5Ccdots%20%26%20%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7B1%20k%7D%20%5C%5C%0A%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7B21%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7B22%7D%20%26%20%5Ccdots%20%26%20%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7B2%20k%7D%20%5C%5C%0A%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cddots%20%26%20%5Cvdots%20%5C%5C%0A%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bk1%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bk2%7D%20%26%20%5Ccdots%20%26%20%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bk%20k%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>处于简化的目的，我们这里考虑 <img src="https://math.now.sh?inline=k%3D3" style="display:inline-block;margin: 0;"/> 的情况（这个不影响推导出来的结果），根据矩阵乘法，当 <img src="https://math.now.sh?inline=i%3Dj" style="display:inline-block;margin: 0;"/>  时，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cgamma%5E%7B1i%7D%5Cgamma%5E%7Bi1%7D%20%26%20%5Cgamma%5E%7B1i%7D%5Cgamma%5E%7Bi2%7D%20%26%20%5Cgamma%5E%7B1i%7D%5Cgamma%5E%7Bi3%7D%20%5C%5C%0A%5Cgamma%5E%7B2i%7D%5Cgamma%5E%7Bi1%7D%20%26%20%5Cgamma%5E%7B2i%7D%5Cgamma%5E%7Bi2%7D%20%26%20%5Cgamma%5E%7B2i%7D%5Cgamma%5E%7Bi3%7D%20%5C%5C%0A%5Cgamma%5E%7B3i%7D%5Cgamma%5E%7Bi1%7D%20%26%20%5Cgamma%5E%7B3i%7D%5Cgamma%5E%7Bi2%7D%20%26%20%5Cgamma%5E%7B3i%7D%5Cgamma%5E%7Bi3%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>因此，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%20%5Cmathbf%7BC%7D%5E%7BZZ%7D%20%5Cleft%28%20%20%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cright%29%20%5C%5C%0A%26%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7B11%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7B12%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7B1%203%7D%20%5C%5C%0A%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7B21%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7B22%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7B2%203%7D%20%5C%5C%0A%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7B31%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7B32%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7B3%203%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cgamma%5E%7B1i%7D%5Cgamma%5E%7Bi1%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%20%26%20%5Cgamma%5E%7B1i%7D%5Cgamma%5E%7Bi2%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%26%20%5Cgamma%5E%7B1i%7D%5Cgamma%5E%7Bi3%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%5C%5C%0A%5Cgamma%5E%7B2i%7D%5Cgamma%5E%7Bi1%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%26%20%5Cgamma%5E%7B2i%7D%5Cgamma%5E%7Bi2%7D%5Cmathbf%7BA%7D%5E%7B-1%7D%20%26%20%5Cgamma%5E%7B2i%7D%5Cgamma%5E%7Bi3%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%5C%5C%0A%5Cgamma%5E%7B3i%7D%5Cgamma%5E%7Bi1%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%26%20%5Cgamma%5E%7B3i%7D%5Cgamma%5E%7Bi2%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%20%26%20%5Cgamma%5E%7B3i%7D%5Cgamma%5E%7Bi3%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>利用迹函数的性质，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BC%7D%5E%7BZZ%7D%20%5Cleft(%20%20%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cright%29%20%5Cright)%20%26%3D%20%5Csum_%7Bs%3D1%7D%5E%7B3%7D%5Csum_%7Bt%3D1%7D%5E%7B3%7D%20%5Coperatorname%7Btr%7D%20(%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bst%7D%20%5Cgamma%5E%7Bti%7D%5Cgamma%5E%7Bis%7D%5Cmathbf%7BA%7D%5E%7B-1%7D)%20%5C%5C%0A%26%3D%20%5Csum_%7Bs%3D1%7D%5E%7B3%7D%5Csum_%7Bt%3D1%7D%5E%7B3%7D%5Cgamma%5E%7Bit%7D%5Cgamma%5E%7Bsi%7D%20%5Coperatorname%7Btr%7D%20(%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bst%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D)%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>当 <img src="https://math.now.sh?inline=i%20%5Cneq%20j" style="display:inline-block;margin: 0;"/>  时, 我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cgamma%5E%7B1j%7D%5Cgamma%5E%7Bi1%7D%2B%5Cgamma%5E%7B1i%7D%5Cgamma%5E%7Bj1%7D%20%26%20%5Cgamma%5E%7B1j%7D%5Cgamma%5E%7Bi2%7D%2B%5Cgamma%5E%7B1i%7D%5Cgamma%5E%7Bj2%7D%20%26%20%5Cgamma%5E%7B1j%7D%5Cgamma%5E%7Bi3%7D%2B%5Cgamma%5E%7B1i%7D%5Cgamma%5E%7Bj3%7D%20%5C%5C%0A%5Cgamma%5E%7B2j%7D%5Cgamma%5E%7Bi1%7D%2B%5Cgamma%5E%7B2i%7D%5Cgamma%5E%7Bj1%7D%20%26%20%5Cgamma%5E%7B2j%7D%5Cgamma%5E%7Bi2%7D%2B%5Cgamma%5E%7B2i%7D%5Cgamma%5E%7Bj2%7D%20%26%20%5Cgamma%5E%7B2j%7D%5Cgamma%5E%7Bi3%7D%2B%5Cgamma%5E%7B2i%7D%5Cgamma%5E%7Bj3%7D%20%5C%5C%0A%5Cgamma%5E%7B3j%7D%5Cgamma%5E%7Bi1%7D%2B%5Cgamma%5E%7B3i%7D%5Cgamma%5E%7Bj1%7D%20%26%20%5Cgamma%5E%7B3j%7D%5Cgamma%5E%7Bi2%7D%2B%5Cgamma%5E%7B3i%7D%5Cgamma%5E%7Bj2%7D%20%26%20%5Cgamma%5E%7B3j%7D%5Cgamma%5E%7Bi3%7D%2B%5Cgamma%5E%7B3i%7D%5Cgamma%5E%7Bj3%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>因此</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%20%5Cmathbf%7BC%7D%5E%7BZZ%7D%20%5Cleft%28%20%20%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cright%29%20%5C%5C%0A%26%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7B11%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7B12%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7B1%203%7D%20%5C%5C%0A%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7B21%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7B22%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7B2%203%7D%20%5C%5C%0A%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7B31%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7B32%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7B3%203%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%20%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0A(%5Cgamma%5E%7B1j%7D%5Cgamma%5E%7Bi1%7D%2B%5Cgamma%5E%7B1i%7D%5Cgamma%5E%7Bj1%7D)%5Cmathbf%7BA%7D%5E%7B-1%7D%20%26%20(%5Cgamma%5E%7B1j%7D%5Cgamma%5E%7Bi2%7D%2B%5Cgamma%5E%7B1i%7D%5Cgamma%5E%7Bj2%7D)%5Cmathbf%7BA%7D%5E%7B-1%7D%20%26%20(%5Cgamma%5E%7B1j%7D%5Cgamma%5E%7Bi3%7D%2B%5Cgamma%5E%7B1i%7D%5Cgamma%5E%7Bj3%7D)%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5C%5C%0A(%5Cgamma%5E%7B2j%7D%5Cgamma%5E%7Bi1%7D%2B%5Cgamma%5E%7B2i%7D%5Cgamma%5E%7Bj1%7D)%5Cmathbf%7BA%7D%5E%7B-1%7D%20%26%20(%5Cgamma%5E%7B2j%7D%5Cgamma%5E%7Bi2%7D%2B%5Cgamma%5E%7B2i%7D%5Cgamma%5E%7Bj2%7D)%5Cmathbf%7BA%7D%5E%7B-1%7D%20%26%20(%5Cgamma%5E%7B2j%7D%5Cgamma%5E%7Bi3%7D%2B%5Cgamma%5E%7B2i%7D%5Cgamma%5E%7Bj3%7D)%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5C%5C%0A(%5Cgamma%5E%7B3j%7D%5Cgamma%5E%7Bi1%7D%2B%5Cgamma%5E%7B3i%7D%5Cgamma%5E%7Bj1%7D)%5Cmathbf%7BA%7D%5E%7B-1%7D%20%26%20(%5Cgamma%5E%7B3j%7D%5Cgamma%5E%7Bi2%7D%2B%5Cgamma%5E%7B3i%7D%5Cgamma%5E%7Bj2%7D)%5Cmathbf%7BA%7D%5E%7B-1%7D%20%26%20(%5Cgamma%5E%7B3j%7D%5Cgamma%5E%7Bi3%7D%2B%5Cgamma%5E%7B3i%7D%5Cgamma%5E%7Bj3%7D)%5Cmathbf%7BA%7D%5E%7B-1%7D%20%0A%5Cend%7Barray%7D%5Cright%5D%0A%0A%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BC%7D%5E%7BZZ%7D%20%5Cleft(%20%20%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cright%29%20%5Cright)%20%26%3D%20%5Csum_%7Bs%3D1%7D%5E%7B3%7D%5Csum_%7Bt%3D1%7D%5E%7B3%7D%20%5Coperatorname%7Btr%7D%20%5Cleft(%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bst%7D%20%5Cleft(%5Cgamma%5E%7Btj%7D%5Cgamma%5E%7Bis%7D%2B%5Cgamma%5E%7Bti%7D%5Cgamma%5E%7Bjs%7D%5Cright)%5Cmathbf%7BA%7D%5E%7B-1%7D%5Cright)%20%5C%5C%0A%26%3D%20%5Csum_%7Bs%3D1%7D%5E%7B3%7D%5Csum_%7Bt%3D1%7D%5E%7B3%7D%20%5Cleft(%5Cgamma%5E%7Btj%7D%5Cgamma%5E%7Bis%7D%2B%5Cgamma%5E%7Bti%7D%5Cgamma%5E%7Bjs%7D%5Cright)%20%5Coperatorname%7Btr%7D%20%5Cleft(%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bst%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%5Cright)%20%5C%5C%0A%26%3D%20%5Csum_%7Bs%3D1%7D%5E%7B3%7D%5Csum_%7Bt%3D1%7D%5E%7B3%7D%5Cgamma%5E%7Btj%7D%5Cgamma%5E%7Bis%7D%5Coperatorname%7Btr%7D%20%5Cleft(%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bst%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%5Cright)%20%2B%20%20%5Csum_%7Bs%3D1%7D%5E%7B3%7D%5Csum_%7Bt%3D1%7D%5E%7B3%7D%5Cgamma%5E%7Bti%7D%5Cgamma%5E%7Bjs%7D%5Coperatorname%7Btr%7D%20%5Cleft(%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bst%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%5Cright)%20%20%0A%5Cend%7Baligned%7D%0A" /></p><p>我们对需要求和的第一项交换 <img src="https://math.now.sh?inline=s" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=t" style="display:inline-block;margin: 0;"/> ，并且我们知道 <img src="https://math.now.sh?inline=%5Cgamma%5E%7Bij%7D%20%3D%20%5Cgamma%5E%7Bji%7D" style="display:inline-block;margin: 0;"/> , <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bst%7D%20%3D%20%28%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bts%7D%29%5E%7BT%7D" style="display:inline-block;margin: 0;"/>  ，因此我们继续推导得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BC%7D%5E%7BZZ%7D%20%5Cleft(%20%20%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cright%29%20%5Cright)%20%0A%26%3D%20%5Csum_%7Bs%3D1%7D%5E%7B3%7D%5Csum_%7Bt%3D1%7D%5E%7B3%7D%5Cgamma%5E%7Btj%7D%5Cgamma%5E%7Bis%7D%5Coperatorname%7Btr%7D%20%5Cleft(%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bst%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%5Cright)%20%2B%20%20%5Csum_%7Bs%3D1%7D%5E%7B3%7D%5Csum_%7Bt%3D1%7D%5E%7B3%7D%5Cgamma%5E%7Bti%7D%5Cgamma%5E%7Bjs%7D%5Coperatorname%7Btr%7D%20%5Cleft(%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bst%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%5Cright)%20%20%5C%5C%0A%26%20%3D%20%5Csum_%7Bt%3D1%7D%5E%7B3%7D%5Csum_%7Bs%3D1%7D%5E%7B3%7D%5Cgamma%5E%7Bsj%7D%5Cgamma%5E%7Bit%7D%5Coperatorname%7Btr%7D%20%5Cleft(%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bts%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%5Cright)%20%2B%20%20%5Csum_%7Bs%3D1%7D%5E%7B3%7D%5Csum_%7Bt%3D1%7D%5E%7B3%7D%5Cgamma%5E%7Bti%7D%5Cgamma%5E%7Bjs%7D%5Coperatorname%7Btr%7D%20%5Cleft(%5Cmathbf%7BA%7D%5E%7B-1%7D%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bts%7D%20%5Cright)%20%20%5C%5C%0A%26%20%3D%20%5Csum_%7Bs%3D1%7D%5E%7B3%7D%5Csum_%7Bt%3D1%7D%5E%7B3%7D%5Cgamma%5E%7Bsj%7D%5Cgamma%5E%7Bit%7D%5Coperatorname%7Btr%7D%20%5Cleft(%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bts%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%5Cright)%20%2B%20%20%5Csum_%7Bs%3D1%7D%5E%7B3%7D%5Csum_%7Bt%3D1%7D%5E%7B3%7D%5Cgamma%5E%7Bti%7D%5Cgamma%5E%7Bjs%7D%5Coperatorname%7Btr%7D%20%5Cleft(%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bts%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%5Cright)%20%20%5C%5C%0A%26%20%3D%202%5Csum_%7Bs%3D1%7D%5E%7B3%7D%5Csum_%7Bt%3D1%7D%5E%7B3%7D%5Cgamma%5E%7Bit%7D%5Cgamma%5E%7Bsj%7D%5Coperatorname%7Btr%7D%20%5Cleft(%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bts%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%5Cright)%20%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>综上，我们将 <img src="https://math.now.sh?inline=k%3D3" style="display:inline-block;margin: 0;"/> 改为一般的 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> ，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BC%7D%5E%7BZZ%7D%20%5Cleft(%20%20%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cright%29%20%5Cright)%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Csum_%7Bs%3D1%7D%5E%7Bk%7D%5Csum_%7Bt%3D1%7D%5E%7Bk%7D%5Cgamma%5E%7Bit%7D%5Cgamma%5E%7Bsi%7D%20%5Coperatorname%7Btr%7D%20(%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bst%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D)%2C%20%26%20i%3Dj%20%5C%5C%0A2%5Csum_%7Bs%3D1%7D%5E%7Bk%7D%5Csum_%7Bt%3D1%7D%5E%7Bk%7D%5Cgamma%5E%7Bit%7D%5Cgamma%5E%7Bsj%7D%5Coperatorname%7Btr%7D%20%5Cleft(%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bst%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%5Cright)%2C%20%26%20i%20%5Cneq%20j%0A%5Cend%7Barray%7D%5Cright.%0A" /></p><p>现在我们定义 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CPsi%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=k%20%5Ctimes%20k" style="display:inline-block;margin: 0;"/> 的矩阵，其元素为 <img src="https://math.now.sh?inline=%5CPsi_%7Bij%7D%20%3D%20%5Coperatorname%7Btr%7D%28%5Cmathbf%7BC%7D_%7Bij%7D%5E%7BZZ%7D%5Cmathbf%7BA%7D%5E%7B-1%7D%29" style="display:inline-block;margin: 0;"/> ，根据矩阵乘法性质（假设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%2CB%2CC%7D" style="display:inline-block;margin: 0;"/> 均为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵，则 <img src="https://math.now.sh?inline=%5Cmathbf%7BABC%7D%20%3D%20%5C%7B%5Csum_%7Bs%3D1%7D%5E%7Bn%7D%5Csum_%7Bt%3D1%7D%5E%7Bn%7Da_%7Bit%7Db_%7Bts%7Dc_%7Bsj%7D%5C%7D" style="display:inline-block;margin: 0;"/> ），我们发现</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5CPsi%7D%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%26%3D%20%5Cleft%20%5C%7B%5Csum_%7Bs%3D1%7D%5E%7Bk%7D%5Csum_%7Bt%3D1%7D%5E%7Bk%7D%5Cgamma%5E%7Bit%7D%5Coperatorname%7Btr%7D%28%5Cmathbf%7BC%7D_%7Bts%7D%5E%7BZZ%7D%5Cmathbf%7BA%7D%5E%7B-1%7D%29%5Cgamma%5E%7Bsj%7D%20%5Cright%5C%7D%5C%5C%0A%26%3D%20%5Cleft%20%5C%7B%5Csum_%7Bs%3D1%7D%5E%7Bk%7D%5Csum_%7Bt%3D1%7D%5E%7Bk%7D%5Cgamma%5E%7Bit%7D%5Cgamma%5E%7Bsj%7D%5Coperatorname%7Btr%7D(%5Cmathbf%7BC%7D_%7Bts%7D%5E%7BZZ%7D%5Cmathbf%7BA%7D%5E%7B-1%7D)%20%5Cright%5C%7D%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>我们定义 <img src="https://math.now.sh?inline=%5Cpsi_%7Bij%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CPsi%7D%5E%7B*%7D%20%3D%20%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5CPsi%7D%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 的元素，即 <img src="https://math.now.sh?inline=%5Cpsi_%7Bij%7D%5E%7B*%7D%20%3D%20%5Cleft%5C%7B%20%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5CPsi%7D%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%5Cright%5C%7D_%7Bij%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>因此，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BC%7D%5E%7BZZ%7D%20%5Cleft(%20%20%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7BG%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cright%29%20%5Cright)%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cpsi_%7Bii%7D%5E%7B*%7D%2C%20%26%20i%3Dj%20%5C%5C%0A2%5Cpsi_%7Bij%7D%5E%7B*%7D%2C%20%26%20i%20%5Cneq%20j%0A%5Cend%7Barray%7D%5Cright.%0A" /></p><p>将上面的式子代入 <img src="https://math.now.sh?inline=U%28%5Cgamma_%7Bij%7D%29" style="display:inline-block;margin: 0;"/> ，进一步简化得到</p>
<p style=""><img src="https://math.now.sh?from=U%28%5Cgamma_%7Bij%7D%29%20%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bcc%7D%0A%20-%20%5Cfrac%7B1%7D%7B2%7D%20%5CBig(m%5Cgamma%5E%7Bii%7D%20-%20%5Cpsi_%7Bii%7D%5E%7B*%7D-%20%5Cdelta_%7Bii%7D%5E%7B*%7D%20%5Cbig)%2C%20%26%20i%3Dj%20%5C%5C%0A-%20%5Cfrac%7B1%7D%7B2%7D%20%5CBig(2m%5Cgamma%5E%7Bij%7D%20-%202%5Cpsi_%7Bij%7D%5E%7B*%7D-%202%5Cdelta_%7Bij%7D%5E%7B*%7D%20%5Cbig)%2C%20%26%20i%20%5Cneq%20j%0A%5Cend%7Barray%7D%5Cright.%0A" /></p><p>将之设为0， 对 <img src="https://math.now.sh?inline=%5Cgamma%5E%7Bij%7D" style="display:inline-block;margin: 0;"/> 求解得到 EM 推导公式</p>
<p style=""><img src="https://math.now.sh?from=m%5Cgamma%5E%7Bij%7D%20%3D%20%5Cpsi_%7Bij%7D%5E%7B*%7D%20%2B%20%5Cdelta_%7Bij%7D%5E%7B*%7D%0A" /></p><p>使用矩阵格式，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Am%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%26%3D%20%5Cmathbf%7B%5CPsi%7D%5E%7B*%7D%20%2B%20%5Cmathbf%7B%5CDelta%7D%5E%7B*%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5CPsi%7D%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%2B%20%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5CDelta%7D%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>左右均乘以 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7Bk%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> ，得到</p>
<p style=""><img src="https://math.now.sh?from=m%5Cmathbf%7BG%7D_%7Bk%7D%3D%20%20%5Cmathbf%7B%5CPsi%7D%20%2B%20%20%5Cmathbf%7B%5CDelta%7D%0A" /></p><p>因此，我们得到 EM 推导公式</p>
<p style=""><img src="https://math.now.sh?from=m%5Cgamma_%7Bij%7D%5E%7B%28m%2B1%29%7D%20%3D%20%5Cpsi_%7Bij%7D%5E%7B(m)%7D%20%2B%20%5Cdelta_%7Bij%7D%5E%7B(m)%7D%0A" /></p><p>因为  <img src="https://math.now.sh?inline=%5Cpsi_%7Bij%7D%20%3D%20%5Coperatorname%7Btr%7D%28%5Cmathbf%7BC%7D_%7Bij%7D%5E%7BZZ%7D%5Cmathbf%7BA%7D%5E%7B-1%7D%29" style="display:inline-block;margin: 0;"/> ，  <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CDelta%7D%20%3D%20%5Cmathbf%7BU%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/>  可以进一步分块为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%5CDelta%7D%20%3D%20%5Cmathbf%7BU%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cmathbf%7BU%7D%20%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cmathbf%7Bu%7D_%7B1%7D%5E%7B%5Cprime%7D%5Cmathbf%7BA%7D%5E%7B-1%7D%5Cmathbf%7Bu%7D_%7B1%7D%20%26%20%5Cmathbf%7Bu%7D_%7B1%7D%5E%7B%5Cprime%7D%5Cmathbf%7BA%7D%5E%7B-1%7D%5Cmathbf%7Bu%7D_%7B2%7D%20%26%20%5Ccdots%20%26%20%5Cmathbf%7Bu%7D_%7B1%7D%5E%7B%5Cprime%7D%5Cmathbf%7BA%7D%5E%7B-1%7D%5Cmathbf%7Bu%7D_%7Bk%7D%20%5C%5C%0A%5Cmathbf%7Bu%7D_%7B2%7D%5E%7B%5Cprime%7D%5Cmathbf%7BA%7D%5E%7B-1%7D%5Cmathbf%7Bu%7D_%7B1%7D%20%26%20%5Cmathbf%7Bu%7D_%7B2%7D%5E%7B%5Cprime%7D%5Cmathbf%7BA%7D%5E%7B-1%7D%5Cmathbf%7Bu%7D_%7B2%7D%20%26%20%5Ccdots%20%26%20%5Cmathbf%7Bu%7D_%7B2%7D%5E%7B%5Cprime%7D%5Cmathbf%7BA%7D%5E%7B-1%7D%5Cmathbf%7Bu%7D_%7Bk%7D%20%5C%5C%0A%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cddots%20%26%20%5Cvdots%20%5C%5C%0A%5Cmathbf%7Bu%7D_%7Bk%7D%5E%7B%5Cprime%7D%5Cmathbf%7BA%7D%5E%7B-1%7D%5Cmathbf%7Bu%7D_%7B1%7D%20%26%20%5Cmathbf%7Bu%7D_%7Bk%7D%5E%7B%5Cprime%7D%5Cmathbf%7BA%7D%5E%7B-1%7D%5Cmathbf%7Bu%7D_%7B2%7D%20%26%20%5Ccdots%20%26%20%5Cmathbf%7Bu%7D_%7Bk%7D%5E%7B%5Cprime%7D%5Cmathbf%7BA%7D%5E%7B-1%7D%5Cmathbf%7Bu%7D_%7Bk%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>因此 <img src="https://math.now.sh?inline=%5Cdelta_%7Bij%7D%20%3D%20%5Cmathbf%7Bu%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7BA%7D%5E%7B-1%7D%5Cmathbf%7Bu%7D_%7Bj%7D" style="display:inline-block;margin: 0;"/> 。因此上面的 EM 推导公式可以写为</p>
<p style=""><img src="https://math.now.sh?from=%5Cgamma_%7Bij%7D%5E%7B%28m%2B1%29%7D%20%3D%20%5Cfrac%7B1%7D%7Bm%7D%20%5Cleft(%5Coperatorname%7Btr%7D(%5Cmathbf%7BC%7D_%7Bij%7D%5E%7BZZ%5E%7B(m)%7D%7D%5Cmathbf%7BA%7D%5E%7B-1%7D)%20%2B%20%5Cmathbf%7Bu%7D_%7Bi%7D%5E%7B(m)%5E%7B%5Cprime%7D%7D%5Cmathbf%7BA%7D%5E%7B-1%7D%5Cmathbf%7Bu%7D_%7Bj%7D%5E%7B(m)%7D%20%5Cright)%0A" /></p><p>这个式子和单性状模型的推导公式正好具有相同的格式。</p>
<h2 id="残差">残差</h2>
<p>按照性状排序， 此时我们有下式成立，其中 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 为表型行数，<img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D_%7Bk%7D" style="display:inline-block;margin: 0;"/> 为需要估计的协方差组分的矩阵。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%5CSigma%7D%20%3D%20%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%20%5Cotimes%20%20%5Cmathbf%7BI%7D_%7Bn%7D%0A" /></p><p><img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D_%7Bk%7D" style="display:inline-block;margin: 0;"/> 形式如下（这里我们使用 <img src="https://math.now.sh?inline=%5Cphi_%7Bij%7D" style="display:inline-block;margin: 0;"/> ，与上面的随机效应格式相同 ）。</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5CSigma%7D_k%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cphi_%7B11%7D%20%26%20%5Cphi_%7B12%7D%20%26%20%5Ccdots%20%26%20%5Cphi_%7B1%20k%7D%20%5C%5C%0A%5Cphi_%7B12%7D%20%26%20%5Cphi_%7B22%7D%20%26%20%5Ccdots%20%26%20%5Cphi_%7B2%20k%7D%20%5C%5C%0A%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cddots%20%26%20%5Cvdots%20%5C%5C%0A%5Cphi_%7B1%20k%7D%20%26%20%5Cphi_%7B2%20k%7D%20%26%20%5Ccdots%20%26%20%5Cphi_%7Bk%20k%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>对于随机因子 <img src="https://math.now.sh?inline=%5Cmathbf%7Be%7D" style="display:inline-block;margin: 0;"/> ，同上，<img src="https://math.now.sh?inline=%5Cmathbf%7Be%7D" style="display:inline-block;margin: 0;"/> 也可以表示为一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20k" style="display:inline-block;margin: 0;"/> 的矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BE%7D" style="display:inline-block;margin: 0;"/> ，其中每一列代表一个性状的所有残差，如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BE%7D%20%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0Ae_%7B11%7D%20%26%20e_%7B12%7D%20%26%20%5Ccdots%20%26%20e_%7B1%20k%7D%20%5C%5C%0Ae_%7B21%7D%20%26%20e_%7B22%7D%20%26%20%5Ccdots%20%26%20e_%7B2%20k%7D%20%5C%5C%0A%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cddots%20%26%20%5Cvdots%20%5C%5C%0Ae_%7Bn1%7D%20%26%20e_%7Bn2%7D%20%26%20%5Ccdots%20%26%20e_%7Bn%20k%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cmathbf%7Be%7D_%7B1%7D%20%26%20%5Cmathbf%7Be%7D_%7B2%7D%20%26%20%5Ccdots%20%26%20%5Cmathbf%7Be%7D_%7B%20k%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>反过来则有 <img src="https://math.now.sh?inline=%5Cmathbf%7Be%7D%20%3D%20%5Cmathrm%7Bvec%7D%20%28%5Cmathbf%7BE%7D%29" style="display:inline-block;margin: 0;"/> 。</p>
<p>对于 <img src="https://math.now.sh?inline=%5Cphi_%7Bij%7D" style="display:inline-block;margin: 0;"/> ，我们有公式</p>
<p style=""><img src="https://math.now.sh?from=U%28%5Cphi_%7Bij%7D%29%20%3D%20-%20%5Cfrac%7B1%7D%7B2%7D%20%5CBig(%20%5Coperatorname%7Btr%7D%20%20%5Cleft(%5Cmathbf%7B%5CSigma%5E%7B-1%7D%5Cdot%7B%5Cmathbf%7B%5CSigma%7D%7D_%7Bij%7D%7D%5Cright)%20-%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BC%5E%7B-1%7DW%5E%7B%5Cprime%7D%5CSigma%5E%7B-1%7D%7D%5Cdot%7B%5Cmathbf%7B%5CSigma%7D%7D_%7Bij%7D%5Cmathbf%7B%5CSigma%5E%7B-1%7DW%7D%20%5Cright)-%5Cmathbf%7Be%7D%5E%7B%5Cprime%7D%5Cmathbf%7B%5CSigma%5E%7B-1%7D%7D%20%5Cdot%7B%5Cmathbf%7B%5CSigma%7D%7D_%7Bij%7D%5Cmathbf%7B%5CSigma%5E%7B-1%7D%7D%5Cmathbf%7Be%7D%20%5CBig)%0A" /></p><p>易得 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Cdot%7B%5CSigma%7D_%7Bi%20j%7D%7D%20%3D%20%5Cmathbf%7B%5Cdot%7B%5CSigma%7D_%7Bk_%7Bi%20j%7D%7D%7D%20%5Cotimes%20%5Cmathbf%7BI%7D_%7Bn%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Cdot%7B%5CSigma%7D_%7Bk_%7Bi%20j%7D%7D%7D%20%3D%20%5Cfrac%7B%5Cpartial%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%7D%7B%5Cpartial%20%5Cphi_%7Bij%7D%7D" style="display:inline-block;margin: 0;"/>  。</p>
<p>因此，我们推导得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%20%5Cmathbf%7B%5CSigma%5E%7B-1%7D%5Cdot%7B%5CSigma%7D_%7Bi%20j%7D%7D%20%5C%5C%0A%26%3D%20%5Cleft%28%20%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BI%7D%5E%7B-1%7D%20%5Cright%29%20%5Cleft(%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%20%5Cotimes%20%5Cmathbf%7BI%7D%5Cright)%20%5C%5C%0A%26%3D%20%5Cleft(%20%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%20%5Cotimes%20%5Cmathbf%7BI%7D_%7Bn%7D%20%5Cright)%20%0A%26%5C%5C%0A%26%5C%5C%0A%26%20%5Coperatorname%7Btr%7D%20(%5Cmathbf%7B%5CSigma%5E%7B-1%7D%5Cdot%7B%5CSigma%7D_%7Bi%20j%7D%7D)%20%5C%5C%0A%26%3D%20%5Coperatorname%7Btr%7D%5Cleft(%20%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%20%5Cotimes%20%5Cmathbf%7BI%7D_%7Bn%7D%20%5Cright)%20%5C%5C%0A%26%3D%20n%20%5Coperatorname%7Btr%7D%5Cleft(%20%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%20%5Cright)%20%5C%5C%0A%26%5C%5C%0A%26%5C%5C%0A%26%5Cmathbf%7B%5CSigma%7D%5E%7B-1%7D%20%5Cdot%7B%5Cmathbf%7B%5CSigma%7D%7D_%7Bi%20j%7D%20%5Cmathbf%7B%5CSigma%7D%5E%7B-1%7D%20%5C%5C%0A%26%3D%20%5Cleft(%20%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BI%7D%5E%7B-1%7D%20%5Cright)%20%5Cleft(%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%20%5Cotimes%20%5Cmathbf%7BI%7D%5Cright)%20%5Cleft(%20%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BI%7D%5E%7B-1%7D%20%5Cright)%5C%5C%0A%26%3D%20%5Cleft(%20%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BI%7D%20%5Cright)%20%0A%0A%26%5C%5C%0A%26%5C%5C%0A%26%5Cmathbf%7Be%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7B%5CSigma%7D%5E%7B-1%7D%20%5Cdot%7B%5Cmathbf%7B%5CSigma%7D%7D_%7Bi%20j%7D%20%5Cmathbf%7B%5CSigma%7D%5E%7B-1%7D%20%5Cmathbf%7Be%7D%20%5C%5C%0A%26%3D%20%5Cmathrm%7Bvec%7D(%5Cmathbf%7BE%7D)%5E%7B%5Cprime%7D%20%5Cleft(%20%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BI%7D%20%5Cright)%20%5Cmathrm%7Bvec%7D(%5Cmathbf%7BE%7D)%20%5C%5C%0A%26%3D%20%5Cmathrm%7Btr%7D(%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7BE%7D%5E%7B%5Cprime%7D%20%20%5Cmathbf%7BE%7D)%20%5Cquad%20%5Cbecause%20%5Cmathrm%7Bvec%7D(%5Cmathbf%7BA%7D)%5E%7B%5Cprime%7D%20(%5Cmathbf%7BB%7D%20%5Cotimes%20%5Cmathbf%7BC%7D)%20%5Cmathrm%7Bvec%7D(%5Cmathbf%7BA%7D)%20%3D%20%5Cmathrm%7Btr%7D(%5Cmathbf%7BB%5E%7B%5Cprime%7DA%5E%7B%5Cprime%7DCA%7D)%20%5C%5C%0A%26%3D%20%5Cmathrm%7Btr%7D(%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5CDelta%7D%20)%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>最后一个式子中，我们设 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CDelta%7D%20%3D%20%5Cmathbf%7BE%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BE%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>代入 <img src="https://math.now.sh?inline=U%28%5Cphi_%7Bij%7D%29" style="display:inline-block;margin: 0;"/> 得到</p>
<p style=""><img src="https://math.now.sh?from=U%28%5Cphi_%7Bij%7D%29%20%3D%20-%20%5Cfrac%7B1%7D%7B2%7D%20%5CBig(%20n%20%5Coperatorname%7Btr%7D%5Cleft(%20%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%20%5Cright)%20-%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BC%5E%7B-1%7DW%5E%7B%5Cprime%7D%5Cleft(%20%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BI%7D%20%5Cright)%20W%7D%20%5Cright)-%5Cmathrm%7Btr%7D(%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5CDelta%7D%20)%20%5CBig)%0A" /></p><p>我们需要对这个式子进一步简化，我们知道  <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D_%7Bk%7D" style="display:inline-block;margin: 0;"/> 是一个对称矩阵，因此  <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 也是一个对称矩阵，  我们将   <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 中的元素表示为 <img src="https://math.now.sh?inline=%5Cphi%5E%7Bij%7D" style="display:inline-block;margin: 0;"/> (<img src="https://math.now.sh?inline=i%20%5Cleq%20j" style="display:inline-block;margin: 0;"/> ) 。</p>
<p>首先我们考虑第一项 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28%20%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%20%5Cright%29" style="display:inline-block;margin: 0;"/> ，同上，我们可以得到</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%28%5Cboldsymbol%7B%5CSigma%7D_k%5E%7B-1%7D%20%5Cdot%7B%5Cboldsymbol%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cright%29%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cphi%5E%7Bi%20i%7D%2C%20%26%20i%3Dj%20%5C%5C%0A2%20%5Cphi%5E%7Bi%20j%7D%2C%20%26%20i%20%5Cneq%20j%0A%5Cend%7Barray%7D%5Cright.%0A" /></p><p>我们现在考虑第三项，如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathrm%7Btr%7D%28%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5CDelta%7D%29%20%26%20%3D%20%5Cmathrm%7Btr%7D(%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5CDelta%7D%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D)%20%5C%5C%0A%26%20%3D%20%5Cmathrm%7Btr%7D(%5Cmathbf%7B%5CDelta%7D%5E%7B*%7D%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D)%20%20%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>其中我们设 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CDelta%7D%5E%7B*%7D%20%3D%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5CDelta%7D%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%3D%20%5C%7B%20%5Cdelta_%7Bij%7D%5E%7B*%7D%5C%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>当 <img src="https://math.now.sh?inline=i%3Dj" style="display:inline-block;margin: 0;"/>  时，矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CDelta%7D%5E%7B*%7D%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D" style="display:inline-block;margin: 0;"/> 只有第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 列元素为 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CDelta%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 的第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 列元素 ，其它位置元素为 0 。因此，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7Btr%7D%28%5Cmathbf%7B%5CDelta%7D%5E%7B*%7D%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%29%20%3D%20%5Cdelta_%7Bii%7D%5E%7B*%7D%0A" /></p><p>当   <img src="https://math.now.sh?inline=i%20%5Cneq%20j" style="display:inline-block;margin: 0;"/>  时, 矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CDelta%7D%5E%7B*%7D%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D" style="display:inline-block;margin: 0;"/> 其第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 列为 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CDelta%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 的第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/>  列， 其第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 列为 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CDelta%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 的第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/>  列，其它位置元素为 0 。因此，我们得到 (因为  <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CDelta%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 对称)</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7Btr%7D%28%5Cmathbf%7B%5CDelta%7D%5E%7B*%7D%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%29%20%3D%20%5Cdelta_%7Bij%7D%5E%7B*%7D%20%2B%20%5Cdelta_%7Bji%7D%5E%7B*%7D%20%3D%202%20%5Cdelta_%7Bij%7D%5E%7B*%7D%0A" /></p><p>综上，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7Btr%7D%28%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5CDelta%7D%29%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cdelta%5E%7B*%7D_%7Bi%20i%7D%2C%20%26%20i%3Dj%20%5C%5C%0A2%20%5Cdelta%5E%7B*%7D_%7Bi%20j%7D%2C%20%26%20i%20%5Cneq%20j%0A%5Cend%7Barray%7D%5Cright.%0A" /></p><p>对于第二项，首先我们对 <img src="https://math.now.sh?inline=%5Cmathbf%7BWC%5E%7B-1%7DW%5E%7B%5Cprime%7D%7D" style="display:inline-block;margin: 0;"/> 进行推导如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cmathbf%7BWC%5E%7B-1%7DW%5E%7B%5Cprime%7D%7D%5C%5C%0A%26%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BZ%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BC%7D%5E%7BXX%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BXZ%7D%20%5C%5C%0A%5Cmathbf%7BC%7D%5E%7BZX%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BZZ%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5C%5C%0A%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%3D%5Cmathbf%7BX%7D%5Cmathbf%7BC%7D%5E%7BXX%7D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7BX%7D%5Cmathbf%7BC%7D%5E%7BXZ%7D%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7BZ%7D%5Cmathbf%7BC%7D%5E%7BZX%7D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7BZ%7D%5Cmathbf%7BC%7D%5E%7BZZ%7D%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，第二项推导得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BC%5E%7B-1%7DW%5E%7B%5Cprime%7D%5Cleft(%20%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BI%7D%20%5Cright%29%20W%7D%20%5Cright)%20%5C%5C%0A%26%3D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BWC%5E%7B-1%7DW%5E%7B%5Cprime%7D%5Cleft(%20%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BI%7D%20%5Cright)%20%7D%20%5Cright)%20%5C%5C%0A%26%3D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BX%7D%5Cmathbf%7BC%7D%5E%7BXX%7D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cleft(%20%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BI%7D%20%5Cright)%20%20%5Cright)%20%2B%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BX%7D%5Cmathbf%7BC%7D%5E%7BXZ%7D%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%5Cleft(%20%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BI%7D%20%5Cright)%20%20%5Cright)%20%2B%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BZ%7D%5Cmathbf%7BC%7D%5E%7BZX%7D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cleft(%20%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BI%7D%20%5Cright)%20%20%5Cright)%20%2B%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BZ%7D%5Cmathbf%7BC%7D%5E%7BZZ%7D%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%5Cleft(%20%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BI%7D%20%5Cright)%20%20%5Cright)%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>对于第二项的第一项进行推导（其余项同理可得），假设 <img src="https://math.now.sh?inline=k%3D3" style="display:inline-block;margin: 0;"/>  ，则 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5Cmathbf%7BC%7D%5E%7BXX%7D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/>  可以分解为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cmathbf%7BX%7D%5Cmathbf%7BC%7D%5E%7BXX%7D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5C%5C%0A%26%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cmathbf%7BX%7D_%7B1%7D%20%26%20%5Cmathbf%7B0%7D%20%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BX%7D_%7B2%7D%20%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%20%26%20%5Cmathbf%7BX%7D_%7B3%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%0A%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cmathbf%7BC%7D%5E%7BXX%7D_%7B11%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BXX%7D_%7B12%7D%20%20%26%20%5Cmathbf%7BC%7D%5E%7BXX%7D_%7B13%7D%20%5C%5C%0A%5Cmathbf%7BC%7D%5E%7BXX%7D_%7B21%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BXX%7D_%7B22%7D%20%20%26%20%5Cmathbf%7BC%7D%5E%7BXX%7D_%7B23%7D%20%5C%5C%0A%5Cmathbf%7BC%7D%5E%7BXX%7D_%7B31%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BXX%7D_%7B32%7D%20%20%26%20%5Cmathbf%7BC%7D%5E%7BXX%7D_%7B33%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cmathbf%7BX%7D_%7B1%7D%5E%7B%5Cprime%7D%20%26%20%5Cmathbf%7B0%7D%20%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BX%7D_%7B2%7D%5E%7B%5Cprime%7D%20%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%20%26%20%5Cmathbf%7BX%7D_%7B3%7D%5E%7B%5Cprime%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cmathbf%7BX%7D_%7B1%7D%5Cmathbf%7BC%7D%5E%7BXX%7D_%7B11%7D%5Cmathbf%7BX%7D_%7B1%7D%5E%7B%5Cprime%7D%20%26%20%5Cmathbf%7BX%7D_%7B1%7D%5Cmathbf%7BC%7D%5E%7BXX%7D_%7B12%7D%5Cmathbf%7BX%7D_%7B2%7D%5E%7B%5Cprime%7D%20%20%26%20%5Cmathbf%7BX%7D_%7B1%7D%5Cmathbf%7BC%7D%5E%7BXX%7D_%7B13%7D%5Cmathbf%7BX%7D_%7B3%7D%5E%7B%5Cprime%7D%20%5C%5C%0A%5Cmathbf%7BX%7D_%7B2%7D%5Cmathbf%7BC%7D%5E%7BXX%7D_%7B21%7D%5Cmathbf%7BX%7D_%7B1%7D%5E%7B%5Cprime%7D%20%26%20%5Cmathbf%7BX%7D_%7B2%7D%5Cmathbf%7BC%7D%5E%7BXX%7D_%7B22%7D%5Cmathbf%7BX%7D_%7B2%7D%5E%7B%5Cprime%7D%20%20%26%20%5Cmathbf%7BX%7D_%7B2%7D%5Cmathbf%7BC%7D%5E%7BXX%7D_%7B23%7D%5Cmathbf%7BX%7D_%7B3%7D%5E%7B%5Cprime%7D%20%5C%5C%0A%5Cmathbf%7BX%7D_%7B3%7D%5Cmathbf%7BC%7D%5E%7BXX%7D_%7B31%7D%5Cmathbf%7BX%7D_%7B1%7D%5E%7B%5Cprime%7D%20%26%20%5Cmathbf%7BX%7D_%7B3%7D%5Cmathbf%7BC%7D%5E%7BXX%7D_%7B32%7D%5Cmathbf%7BX%7D_%7B2%7D%5E%7B%5Cprime%7D%20%20%26%20%5Cmathbf%7BX%7D_%7B3%7D%5Cmathbf%7BC%7D%5E%7BXX%7D_%7B33%7D%5Cmathbf%7BX%7D_%7B3%7D%5E%7B%5Cprime%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%0A%5Cend%7Baligned%7D%0A" /></p><p>类似与随机效应，我们可以得到（推导过程略）</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BX%7D%5Cmathbf%7BC%7D%5E%7BXX%7D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cleft(%20%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BI%7D%20%5Cright%29%20%20%5Cright)%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Csum_%7Bs%3D1%7D%5E%7Bk%7D%5Csum_%7Bt%3D1%7D%5E%7Bk%7D%5Cphi%5E%7Bit%7D%5Cphi%5E%7Bsi%7D%20%5Coperatorname%7Btr%7D%20(%5Cmathbf%7BX%7D_%7Bs%7D%5Cmathbf%7BC%7D%5E%7BXX%7D_%7Bst%7D%5Cmathbf%7BX%7D_%7Bt%7D%5E%7B%5Cprime%7D%20)%2C%20%26%20i%3Dj%20%5C%5C%0A%5Csum_%7Bs%3D1%7D%5E%7Bk%7D%5Csum_%7Bt%3D1%7D%5E%7Bk%7D%5Cphi%5E%7Bit%7D%5Cphi%5E%7Bsj%7D%20%5Cleft(%20%5Coperatorname%7Btr%7D%20%5Cleft(%5Cmathbf%7BX%7D_%7Bs%7D%5Cmathbf%7BC%7D%5E%7BXX%7D_%7Bst%7D%5Cmathbf%7BX%7D_%7Bt%7D%5E%7B%5Cprime%7D%5Cright)%20%2B%20%20%5Coperatorname%7Btr%7D%20%5Cleft(%5Cmathbf%7BX%7D_%7Bt%7D%5Cmathbf%7BC%7D%5E%7BXX%7D_%7Bts%7D%5Cmathbf%7BX%7D_%7Bs%7D%5E%7B%5Cprime%7D%5Cright)%5Cright)%20%2C%20%26%20i%20%5Cneq%20j%0A%5Cend%7Barray%7D%5Cright.%0A" /></p><p>因此，我们得到（同上，我们有 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D%5E%7BAB%7D_%7Bst%7D%20%3D%20%28%5Cmathbf%7BC%7D%5E%7BBA%7D_%7Bts%7D%29%5E%7BT%7D" style="display:inline-block;margin: 0;"/>  ）</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BC%5E%7B-1%7DW%5E%7B%5Cprime%7D%5Cleft(%20%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BI%7D%20%5Cright%29%20W%7D%20%5Cright)%5C%5C%0A%26%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Csum_%7Bs%3D1%7D%5E%7Bk%7D%5Csum_%7Bt%3D1%7D%5E%7Bk%7D%5Cphi%5E%7Bit%7D%5Cphi%5E%7Bsi%7D%20%5Coperatorname%7Btr%7D%20(%5Cmathbf%7BX%7D_%7Bs%7D%5Cmathbf%7BC%7D%5E%7BXX%7D_%7Bst%7D%5Cmathbf%7BX%7D_%7Bt%7D%5E%7B%5Cprime%7D%20%2B%20%5Cmathbf%7BX%7D_%7Bs%7D%5Cmathbf%7BC%7D%5E%7BXZ%7D_%7Bst%7D%5Cmathbf%7BZ%7D_%7Bt%7D%5E%7B%5Cprime%7D%20%2B%20%5Cmathbf%7BZ%7D_%7Bs%7D%5Cmathbf%7BC%7D%5E%7BZX%7D_%7Bst%7D%5Cmathbf%7BX%7D_%7Bt%7D%5E%7B%5Cprime%7D%20%2B%20%5Cmathbf%7BZ%7D_%7Bs%7D%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bst%7D%5Cmathbf%7BZ%7D_%7Bt%7D%5E%7B%5Cprime%7D%20)%2C%20%26%20i%3Dj%20%5C%5C%0A%5Csum_%7Bs%3D1%7D%5E%7Bk%7D%5Csum_%7Bt%3D1%7D%5E%7Bk%7D%5Cphi%5E%7Bit%7D%5Cphi%5E%7Bsj%7D%20%5Cleft(%20%5Coperatorname%7Btr%7D%20%5Cleft(%5Cmathbf%7BX%7D_%7Bs%7D%5Cmathbf%7BC%7D%5E%7BXX%7D_%7Bst%7D%5Cmathbf%7BX%7D_%7Bt%7D%5E%7B%5Cprime%7D%20%2B%20%5Cmathbf%7BX%7D_%7Bs%7D%5Cmathbf%7BC%7D%5E%7BXZ%7D_%7Bst%7D%5Cmathbf%7BZ%7D_%7Bt%7D%5E%7B%5Cprime%7D%20%2B%5Cmathbf%7BZ%7D_%7Bs%7D%5Cmathbf%7BC%7D%5E%7BZX%7D_%7Bst%7D%5Cmathbf%7BX%7D_%7Bt%7D%5E%7B%5Cprime%7D%20%2B%5Cmathbf%7BZ%7D_%7Bs%7D%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bst%7D%5Cmathbf%7BZ%7D_%7Bt%7D%5E%7B%5Cprime%7D%20%5Cright)%20%2B%20%5Coperatorname%7Btr%7D%20%5Cleft(%5Cmathbf%7BX%7D_%7Bt%7D%5Cmathbf%7BC%7D%5E%7BXX%7D_%7Bts%7D%5Cmathbf%7BX%7D_%7Bs%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7BX%7D_%7Bt%7D%5Cmathbf%7BC%7D%5E%7BXZ%7D_%7Bts%7D%5Cmathbf%7BZ%7D_%7Bs%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7BZ%7D_%7Bt%7D%5Cmathbf%7BC%7D%5E%7BZX%7D_%7Bts%7D%5Cmathbf%7BX%7D_%7Bs%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7BZ%7D_%7Bt%7D%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bts%7D%5Cmathbf%7BZ%7D_%7Bs%7D%5E%7B%5Cprime%7D%5Cright)%20%5Cright)%2C%20%26%20i%20%5Cneq%20j%0A%5Cend%7Barray%7D%5Cright.%20%5C%5C%0A%26%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Csum_%7Bs%3D1%7D%5E%7Bk%7D%5Csum_%7Bt%3D1%7D%5E%7Bk%7D%5Cphi%5E%7Bit%7D%5Cphi%5E%7Bsi%7D%20%5Coperatorname%7Btr%7D%20(%5Cmathbf%7BX%7D_%7Bs%7D%5Cmathbf%7BC%7D%5E%7BXX%7D_%7Bst%7D%5Cmathbf%7BX%7D_%7Bt%7D%5E%7B%5Cprime%7D%20%2B%20%5Cmathbf%7BX%7D_%7Bs%7D%5Cmathbf%7BC%7D%5E%7BXZ%7D_%7Bst%7D%5Cmathbf%7BZ%7D_%7Bt%7D%5E%7B%5Cprime%7D%20%2B%20%5Cmathbf%7BZ%7D_%7Bs%7D%5Cmathbf%7BC%7D%5E%7BZX%7D_%7Bst%7D%5Cmathbf%7BX%7D_%7Bt%7D%5E%7B%5Cprime%7D%20%2B%20%5Cmathbf%7BZ%7D_%7Bs%7D%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bst%7D%5Cmathbf%7BZ%7D_%7Bt%7D%5E%7B%5Cprime%7D%20)%2C%20%26%20i%3Dj%20%5C%5C%0A%5Csum_%7Bs%3D1%7D%5E%7Bk%7D%5Csum_%7Bt%3D1%7D%5E%7Bk%7D%5Cphi%5E%7Bit%7D%5Cphi%5E%7Bsj%7D%202%20%5Coperatorname%7Btr%7D%20%5Cleft(%5Cmathbf%7BX%7D_%7Bs%7D%5Cmathbf%7BC%7D%5E%7BXX%7D_%7Bst%7D%5Cmathbf%7BX%7D_%7Bt%7D%5E%7B%5Cprime%7D%20%2B%20%5Cmathbf%7BX%7D_%7Bs%7D%5Cmathbf%7BC%7D%5E%7BXZ%7D_%7Bst%7D%5Cmathbf%7BZ%7D_%7Bt%7D%5E%7B%5Cprime%7D%20%2B%5Cmathbf%7BZ%7D_%7Bs%7D%5Cmathbf%7BC%7D%5E%7BZX%7D_%7Bst%7D%5Cmathbf%7BX%7D_%7Bt%7D%5E%7B%5Cprime%7D%20%2B%5Cmathbf%7BZ%7D_%7Bs%7D%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bst%7D%5Cmathbf%7BZ%7D_%7Bt%7D%5E%7B%5Cprime%7D%20%20%5Cright)%2C%20%26%20i%20%5Cneq%20j%0A%5Cend%7Barray%7D%5Cright.%20%5C%5C%0A%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>现在我们定义 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CPsi%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=k%20%5Ctimes%20k" style="display:inline-block;margin: 0;"/> 的矩阵，其元素为 <img src="https://math.now.sh?inline=%5Cpsi_%7Bij%7D%20%3D%20%20%5Coperatorname%7Btr%7D%20%5Cleft%28%5Cmathbf%7BX%7D_%7Bi%7D%5Cmathbf%7BC%7D%5E%7BXX%7D_%7Bij%7D%5Cmathbf%7BX%7D_%7Bj%7D%5E%7B%5Cprime%7D%20%2B%20%5Cmathbf%7BX%7D_%7Bi%7D%5Cmathbf%7BC%7D%5E%7BXZ%7D_%7Bij%7D%5Cmathbf%7BZ%7D_%7Bj%7D%5E%7B%5Cprime%7D%20%2B%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BC%7D%5E%7BZX%7D_%7Bij%7D%5Cmathbf%7BX%7D_%7Bj%7D%5E%7B%5Cprime%7D%20%2B%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bij%7D%5Cmathbf%7BZ%7D_%7Bj%7D%5E%7B%5Cprime%7D%20%20%5Cright%29" style="display:inline-block;margin: 0;"/>，根据矩阵乘法性质（假设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%2CB%2CC%7D" style="display:inline-block;margin: 0;"/> 均为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵，则 <img src="https://math.now.sh?inline=%5Cmathbf%7BABC%7D%20%3D%20%5C%7B%5Csum_%7Bs%3D1%7D%5E%7Bn%7D%5Csum_%7Bt%3D1%7D%5E%7Bn%7Da_%7Bit%7Db_%7Bts%7Dc_%7Bsj%7D%5C%7D" style="display:inline-block;margin: 0;"/> ），我们发现</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5CPsi%7D%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%26%3D%20%5Cleft%20%5C%7B%5Csum_%7Bs%3D1%7D%5E%7Bk%7D%5Csum_%7Bt%3D1%7D%5E%7Bk%7D%5Cphi%5E%7Bit%7D%5Coperatorname%7Btr%7D%20%5Cleft%28%5Cmathbf%7BX%7D_%7Bt%7D%5Cmathbf%7BC%7D%5E%7BXX%7D_%7Bts%7D%5Cmathbf%7BX%7D_%7Bs%7D%5E%7B%5Cprime%7D%20%2B%20%5Cmathbf%7BX%7D_%7Bt%7D%5Cmathbf%7BC%7D%5E%7BXZ%7D_%7Bts%7D%5Cmathbf%7BZ%7D_%7Bs%7D%5E%7B%5Cprime%7D%20%2B%5Cmathbf%7BZ%7D_%7Bt%7D%5Cmathbf%7BC%7D%5E%7BZX%7D_%7Bts%7D%5Cmathbf%7BX%7D_%7Bs%7D%5E%7B%5Cprime%7D%20%2B%5Cmathbf%7BZ%7D_%7Bt%7D%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bts%7D%5Cmathbf%7BZ%7D_%7Bs%7D%5E%7B%5Cprime%7D%20%20%5Cright%29%5Cphi%5E%7Bsj%7D%20%5Cright%5C%7D%5C%5C%0A%26%3D%20%5Cleft%20%5C%7B%5Csum_%7Bs%3D1%7D%5E%7Bk%7D%5Csum_%7Bt%3D1%7D%5E%7Bk%7D%5Cphi%5E%7Bit%7D%5Cphi%5E%7Bsj%7D%5Coperatorname%7Btr%7D%20%5Cleft(%5Cmathbf%7BX%7D_%7Bt%7D%5Cmathbf%7BC%7D%5E%7BXX%7D_%7Bts%7D%5Cmathbf%7BX%7D_%7Bs%7D%5E%7B%5Cprime%7D%20%2B%20%5Cmathbf%7BX%7D_%7Bt%7D%5Cmathbf%7BC%7D%5E%7BXZ%7D_%7Bts%7D%5Cmathbf%7BZ%7D_%7Bs%7D%5E%7B%5Cprime%7D%20%2B%5Cmathbf%7BZ%7D_%7Bt%7D%5Cmathbf%7BC%7D%5E%7BZX%7D_%7Bts%7D%5Cmathbf%7BX%7D_%7Bs%7D%5E%7B%5Cprime%7D%20%2B%5Cmathbf%7BZ%7D_%7Bt%7D%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bts%7D%5Cmathbf%7BZ%7D_%7Bs%7D%5E%7B%5Cprime%7D%20%20%5Cright)%5Cright%5C%7D%5C%5C%0A%26%3D%20%5Cleft%20%5C%7B%5Csum_%7Bs%3D1%7D%5E%7Bk%7D%5Csum_%7Bt%3D1%7D%5E%7Bk%7D%5Cphi%5E%7Bit%7D%5Cphi%5E%7Bsj%7D%5Coperatorname%7Btr%7D%20%5Cleft(%5Cmathbf%7BX%7D_%7Bs%7D%5Cmathbf%7BC%7D%5E%7BXX%7D_%7Bst%7D%5Cmathbf%7BX%7D_%7Bt%7D%5E%7B%5Cprime%7D%20%2B%20%5Cmathbf%7BX%7D_%7Bs%7D%5Cmathbf%7BC%7D%5E%7BXZ%7D_%7Bst%7D%5Cmathbf%7BZ%7D_%7Bt%7D%5E%7B%5Cprime%7D%20%2B%5Cmathbf%7BZ%7D_%7Bs%7D%5Cmathbf%7BC%7D%5E%7BZX%7D_%7Bst%7D%5Cmathbf%7BX%7D_%7Bt%7D%5E%7B%5Cprime%7D%20%2B%5Cmathbf%7BZ%7D_%7Bs%7D%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bst%7D%5Cmathbf%7BZ%7D_%7Bt%7D%5E%7B%5Cprime%7D%20%20%5Cright)%5Cright%5C%7D%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>我们定义 <img src="https://math.now.sh?inline=%5Cpsi_%7Bij%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CPsi%7D%5E%7B*%7D%20%3D%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5CPsi%7D%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 的元素，即 <img src="https://math.now.sh?inline=%5Cpsi_%7Bij%7D%5E%7B*%7D%20%3D%20%5Cleft%5C%7B%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5CPsi%7D%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%5Cright%5C%7D_%7Bij%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>因此，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BC%5E%7B-1%7DW%5E%7B%5Cprime%7D%5Cleft(%20%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%5Cmathbf%7B%5Cdot%7B%5CSigma%7D%7D_%7Bk_%7Bi%20j%7D%7D%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%20%5Cotimes%20%5Cmathbf%7BI%7D%20%5Cright%29%20W%7D%20%5Cright)%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cpsi_%7Bii%7D%5E%7B*%7D%2C%20%26%20i%3Dj%20%5C%5C%0A2%5Cpsi_%7Bij%7D%5E%7B*%7D%2C%20%26%20i%20%5Cneq%20j%0A%5Cend%7Barray%7D%5Cright.%0A" /></p><p>将上面的式子代入 <img src="https://math.now.sh?inline=U%28%5Cphi_%7Bij%7D%29" style="display:inline-block;margin: 0;"/> ，进一步简化得到</p>
<p style=""><img src="https://math.now.sh?from=U%28%5Cphi_%7Bij%7D%29%20%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bcc%7D%0A%20-%20%5Cfrac%7B1%7D%7B2%7D%20%5CBig(n%5Cphi%5E%7Bii%7D%20-%20%5Cpsi_%7Bii%7D%5E%7B*%7D-%20%5Cdelta_%7Bii%7D%5E%7B*%7D%20%5Cbig)%2C%20%26%20i%3Dj%20%5C%5C%0A-%20%5Cfrac%7B1%7D%7B2%7D%20%5CBig(2n%5Cphi%5E%7Bij%7D%20-%202%5Cpsi_%7Bij%7D%5E%7B*%7D-%202%5Cdelta_%7Bij%7D%5E%7B*%7D%20%5Cbig)%2C%20%26%20i%20%5Cneq%20j%0A%5Cend%7Barray%7D%5Cright.%0A" /></p><p>将之设为0， 对 <img src="https://math.now.sh?inline=%5Cgamma%5E%7Bij%7D" style="display:inline-block;margin: 0;"/> 求解得到 EM 推导公式</p>
<p style=""><img src="https://math.now.sh?from=n%5Cphi%5E%7Bij%7D%20%3D%20%5Cpsi_%7Bij%7D%5E%7B*%7D%20%2B%20%5Cdelta_%7Bij%7D%5E%7B*%7D%0A" /></p><p>使用矩阵格式，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0An%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%26%3D%20%5Cmathbf%7B%5CPsi%7D%5E%7B*%7D%20%2B%20%5Cmathbf%7B%5CDelta%7D%5E%7B*%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5CPsi%7D%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%2B%20%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%20%5Cmathbf%7B%5CDelta%7D%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%5E%7B-1%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>左右均乘以 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D_%7Bk%7D" style="display:inline-block;margin: 0;"/> ，得到</p>
<p style=""><img src="https://math.now.sh?from=n%5Cmathbf%7B%5CSigma%7D_%7Bk%7D%3D%20%20%5Cmathbf%7B%5CPsi%7D%20%2B%20%20%5Cmathbf%7B%5CDelta%7D%0A" /></p><p>因此，我们得到</p>
<p style=""><img src="https://math.now.sh?from=n%5Cphi_%7Bij%7D%20%3D%20%5Cpsi_%7Bij%7D%20%2B%20%5Cdelta_%7Bij%7D%0A" /></p><p>因为  <img src="https://math.now.sh?inline=%5Cpsi_%7Bij%7D%20%3D%20%5Coperatorname%7Btr%7D%20%5Cleft%28%5Cmathbf%7BX%7D_%7Bi%7D%5Cmathbf%7BC%7D%5E%7BXX%7D_%7Bij%7D%5Cmathbf%7BX%7D_%7Bj%7D%5E%7B%5Cprime%7D%20%2B%20%5Cmathbf%7BX%7D_%7Bi%7D%5Cmathbf%7BC%7D%5E%7BXZ%7D_%7Bij%7D%5Cmathbf%7BZ%7D_%7Bj%7D%5E%7B%5Cprime%7D%20%2B%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BC%7D%5E%7BZX%7D_%7Bij%7D%5Cmathbf%7BX%7D_%7Bj%7D%5E%7B%5Cprime%7D%20%2B%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bij%7D%5Cmathbf%7BZ%7D_%7Bj%7D%5E%7B%5Cprime%7D%20%20%5Cright%29" style="display:inline-block;margin: 0;"/> ，  <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CDelta%7D%20%3D%20%5Cmathbf%7BE%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BE%7D" style="display:inline-block;margin: 0;"/>  可以进一步分块为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%5CDelta%7D%20%3D%20%5Cmathbf%7BE%7D%5E%7B%5Cprime%7D%20%20%5Cmathbf%7BE%7D%20%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cmathbf%7Be%7D_%7B1%7D%5E%7B%5Cprime%7D%5Cmathbf%7Be%7D_%7B1%7D%20%26%20%5Cmathbf%7Be%7D_%7B1%7D%5E%7B%5Cprime%7D%5Cmathbf%7Be%7D_%7B2%7D%20%26%20%5Ccdots%20%26%20%5Cmathbf%7Be%7D_%7B1%7D%5E%7B%5Cprime%7D%5Cmathbf%7Be%7D_%7Bk%7D%20%5C%5C%0A%5Cmathbf%7Be%7D_%7B2%7D%5E%7B%5Cprime%7D%5Cmathbf%7Be%7D_%7B1%7D%20%26%20%5Cmathbf%7Be%7D_%7B2%7D%5E%7B%5Cprime%7D%5Cmathbf%7Be%7D_%7B2%7D%20%26%20%5Ccdots%20%26%20%5Cmathbf%7Be%7D_%7B2%7D%5E%7B%5Cprime%7D%5Cmathbf%7Be%7D_%7Bk%7D%20%5C%5C%0A%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cddots%20%26%20%5Cvdots%20%5C%5C%0A%5Cmathbf%7Be%7D_%7Bk%7D%5E%7B%5Cprime%7D%5Cmathbf%7Be%7D_%7B1%7D%20%26%20%5Cmathbf%7Be%7D_%7Bk%7D%5E%7B%5Cprime%7D%5Cmathbf%7Be%7D_%7B2%7D%20%26%20%5Ccdots%20%26%20%5Cmathbf%7Be%7D_%7Bk%7D%5E%7B%5Cprime%7D%5Cmathbf%7Be%7D_%7Bk%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>因此 <img src="https://math.now.sh?inline=%5Cdelta_%7Bij%7D%20%3D%20%5Cmathbf%7Be%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7Be%7D_%7Bj%7D" style="display:inline-block;margin: 0;"/> 。因此上面的 EM 推导公式可以写为</p>
<p style=""><img src="https://math.now.sh?from=%5Cphi_%7Bij%7D%20%3D%20%5Cfrac%7B1%7D%7Bn%7D%20%5Cleft%28%5Coperatorname%7Btr%7D%20%5Cleft(%5Cmathbf%7BX%7D_%7Bi%7D%5Cmathbf%7BC%7D%5E%7BXX%7D_%7Bij%7D%5Cmathbf%7BX%7D_%7Bj%7D%5E%7B%5Cprime%7D%20%2B%20%5Cmathbf%7BX%7D_%7Bi%7D%5Cmathbf%7BC%7D%5E%7BXZ%7D_%7Bij%7D%5Cmathbf%7BZ%7D_%7Bj%7D%5E%7B%5Cprime%7D%20%2B%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BC%7D%5E%7BZX%7D_%7Bij%7D%5Cmathbf%7BX%7D_%7Bj%7D%5E%7B%5Cprime%7D%20%2B%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bij%7D%5Cmathbf%7BZ%7D_%7Bj%7D%5E%7B%5Cprime%7D%20%20%5Cright%29%20%2B%20%5Cmathbf%7Be%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7Be%7D_%7Bj%7D%20%5Cright)%0A" /></p><p>如果我们设 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D_%7Bi%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BX%7D_%7Bi%7D%20%26%20%5Cmathbf%7BZ%7D_%7Bi%7D%0A%5Cend%7Barray%7D%5Cright%5D" style="display:inline-block;margin: 0;"/> ,   <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D_%7Bj%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BX%7D_%7Bj%7D%20%26%20%5Cmathbf%7BZ%7D_%7Bj%7D%0A%5Cend%7Barray%7D%5Cright%5D" style="display:inline-block;margin: 0;"/> ,  <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D%5E%7Bij%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BC%7D%5E%7BXX%7D_%7Bij%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BXZ%7D_%7Bij%7D%20%5C%5C%0A%5Cmathbf%7BC%7D%5E%7BZX%7D_%7Bij%7D%20%26%20%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bij%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D" style="display:inline-block;margin: 0;"/> ，则我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cpsi_%7Bij%7D%20%3D%20%5Coperatorname%7Btr%7D%20%5Cleft%28%5Cmathbf%7BX%7D_%7Bi%7D%5Cmathbf%7BC%7D%5E%7BXX%7D_%7Bij%7D%5Cmathbf%7BX%7D_%7Bj%7D%5E%7B%5Cprime%7D%20%2B%20%5Cmathbf%7BX%7D_%7Bi%7D%5Cmathbf%7BC%7D%5E%7BXZ%7D_%7Bij%7D%5Cmathbf%7BZ%7D_%7Bj%7D%5E%7B%5Cprime%7D%20%2B%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BC%7D%5E%7BZX%7D_%7Bij%7D%5Cmathbf%7BX%7D_%7Bj%7D%5E%7B%5Cprime%7D%20%2B%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BC%7D%5E%7BZZ%7D_%7Bij%7D%5Cmathbf%7BZ%7D_%7Bj%7D%5E%7B%5Cprime%7D%20%20%5Cright%29%20%3D%20%5Coperatorname%7Btr%7D%20%5Cleft(%20%5Cmathbf%7BW%7D_%7Bi%7D%20%5Cmathbf%7BC%7D%5E%7Bij%7D%20%5Cmathbf%7BW%7D_%7Bj%7D%5E%7B%5Cprime%7D%20%5Cright)%0A" /></p><p>则 <img src="https://math.now.sh?inline=%5Cphi_%7Bij%7D" style="display:inline-block;margin: 0;"/> 的 EM 推导公式可以写为</p>
<p style=""><img src="https://math.now.sh?from=%5Cphi_%7Bij%7D%20%3D%20%5Cfrac%7B1%7D%7Bn%7D%20%5Cleft%28%5Coperatorname%7Btr%7D%20%5Cleft(%20%5Cmathbf%7BW%7D_%7Bi%7D%20%5Cmathbf%7BC%7D%5E%7Bij%7D%20%5Cmathbf%7BW%7D_%7Bj%7D%5E%7B%5Cprime%7D%20%5Cright%29%20%2B%20%5Cmathbf%7Be%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7Be%7D_%7Bj%7D%20%5Cright)%0A" /></p><h1>附录1: V逆相关推导</h1>
<p>根据舒尔补公式 <img src="https://math.now.sh?inline=%5Cmathbf%7B%28D%2BCA%5E%7B-1%7DB%29%5E%7B-1%7D%3DD%5E%7B-1%7D-D%5E%7B-1%7DC(A%2BBD%5E%7B-1%7DC)%5E%7B-1%7DBD%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> ， 我们可以得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BV%5E%7B-1%7D%7D%20%20%3D%20%5Cmathbf%7B%28R%2BZGZ%5E%7B%5Cprime%7D%29%5E%7B-1%7D%7D%20%3D%20%5Cmathbf%7BR%5E%7B-1%7D-R%5E%7B-1%7DZ(Z%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D)%5E%7B-1%7DZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%0A" /></p><p>两边左乘 <img src="https://math.now.sh?inline=%5Cmathbf%7BGZ%5E%7B%5Cprime%7D%7D" style="display:inline-block;margin: 0;"/> 得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%20%5Cquad%20%5Cmathbf%7BGZ%5E%7B%5Cprime%7D%28R%2BZGZ%5E%7B%5Cprime%7D%29%5E%7B-1%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BGZ%5E%7B%5Cprime%7DR%5E%7B-1%7D-GZ%5E%7B%5Cprime%7DR%5E%7B-1%7DZ(Z%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D)%5E%7B-1%7DZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%5C%5C%0A%26%3D%20%5Cmathbf%7BGZ%5E%7B%5Cprime%7DR%5E%7B-1%7D-G(Z%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D)(Z%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D)%5E%7B-1%7DZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%2B(Z%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D)%5E%7B-1%7DZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BGZ%5E%7B%5Cprime%7DR%5E%7B-1%7D-GZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%2B(Z%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D)%5E%7B-1%7DZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7B(Z%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D)%5E%7B-1%7DZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%28Z%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D%29%5E%7B-1%7DZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%20%3D%20%5Cmathbf%7BGZ%5E%7B%5Cprime%7D(R%2BZGZ%5E%7B%5Cprime%7D)%5E%7B-1%7D%7D%0A" /></p><p>转置一下，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BR%5E%7B-1%7DZ%28Z%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D%29%5E%7B-1%7D%7D%20%3D%20%5Cmathbf%7B(R%2BZGZ%5E%7B%5Cprime%7D)%5E%7B-1%7DZG%7D%0A" /></p><h1>附录2：P 矩阵对方差组分的导数</h1>
<p>我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%5Cpartial%20%5Cboldsymbol%7BP%7D%7D%7B%5Cpartial%20%5Ckappa_i%7D%3D-%5Cboldsymbol%7BP%7D%20%5Cboldsymbol%7BV%7D_i%20%5Cboldsymbol%7BP%7D%0A" /></p><p>证明如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cfrac%7B%5Cpartial%20%5Cboldsymbol%7BP%7D%7D%7B%5Cpartial%20%5Ckappa_i%7D%3D%20%26%20%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Ckappa_i%7D%5Cleft%28%5Cboldsymbol%7BV%7D%5E%7B-1%7D-%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cleft(%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cright%29%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%5Cright)%20%5C%5C%0A%3D%20%26%20%5Cfrac%7B%5Cpartial%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%7D%7B%5Cpartial%20%5Ckappa_i%7D-%5Cfrac%7B%5Cpartial%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%7D%7B%5Cpartial%20%5Ckappa_i%7D%20%5Cboldsymbol%7BX%7D%5Cleft(%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D-%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%20%5Cfrac%7B%5Cpartial%5Cleft(%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cright)%5E%7B-1%7D%7D%7B%5Cpartial%20%5Ckappa_i%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5C%5C%0A%26%20%5Cquad-%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cleft(%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cfrac%7B%5Cpartial%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%7D%7B%5Cpartial%20%5Ckappa_i%7D%20%5C%5C%0A%3D%20%26%20-%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BV%7D_i%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%2B%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BV%7D_i%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cleft(%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5C%5C%0A%26%20%5Cquad-%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cleft(%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BV%7D_i%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cleft(%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5C%5C%0A%26%20%5Cquad%2B%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cleft(%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BV%7D_i%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5C%5C%0A%3D%20%26%20-%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BV%7D_i%5Cleft(%5Cboldsymbol%7BV%7D%5E%7B-1%7D-%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cleft(%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%5Cright)%5Cright.%20%5C%5C%0A%26%20%5Cquad%2B%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cleft(%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BV%7D_i%5Cleft(%5Cboldsymbol%7BV%7D%5E%7B-1%7D-%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cleft(%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%5Cright)%20%5C%5C%0A%3D%20%26%20-%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BV%7D_i%20%5Cboldsymbol%7BP%7D%2B%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%5Cleft(%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BV%7D_i%20%5Cboldsymbol%7BP%7D%20%5C%5C%0A%3D%20%26%20-%5Cleft(%5Cboldsymbol%7BV%7D%5E%7B-1%7D-%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cleft(%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7BV%7D%5E%7B-1%7D%5Cright)%20%5Cboldsymbol%7BV%7D_i%20%5Cboldsymbol%7BP%7D%20%5C%5C%0A%3D%20%26%20-%5Cboldsymbol%7BP%7D%20%5Cboldsymbol%7BV%7D_i%20%5Cboldsymbol%7BP%7D%0A%5Cend%7Baligned%7D%0A" /></p><h1>参考文献</h1>
<ol>
<li>Knight E. Improved iterative schemes for REML estimation of variance parameters in linear mixed models[D]. , 2008.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
        <tag>方差组分</tag>
        <tag>REML</tag>
      </tags>
  </entry>
  <entry>
    <title>方差组分估计方法三之DF-REML</title>
    <url>/posts/e0661366/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这是方差组分估计方法的第三篇博客，介绍非求导算法 (deritative free REML, DF-REML) 算法。非求导算法顾名思义即不计算导数，对于不同的参数直接计算似然函数值，从中找到使得似然函数最大的一组参数。不过我这里主要是介绍如何进一步推导似然函数。</p>
<span id="more"></span>
<h1>推导 REML 似然函数</h1>
<p>这里只是进一步推导REML的似然函数。</p>
<p>对于表型 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，其对数似然函数如下（忽略常数项）</p>
<p style=""><img src="https://math.now.sh?from=l%3D-%5Cfrac%7B1%7D%7B2%7D%5Cleft%28%20%5Cln%20%7C%5Cmathbf%7BV%7D%7C%2B(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cbeta%29%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cbeta)%5Cright)%0A" /></p><p>Verbyla (1990) 提出一个非奇异矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D%20%3D%20%5B%5Cmathbf%7BL%7D_%7B1%7D%20%5C%20%5Cmathbf%7BL%7D_%7B2%7D%20%5D" style="display:inline-block;margin: 0;"/> ， 其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> 分别为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=n%20%5Ctimes%20%28n-p%29" style="display:inline-block;margin: 0;"/> 的矩阵（<img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 为表型数目，<img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的列数，<strong>假设 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 满秩</strong>，如果不满秩可以提取其中一个满秩的子矩阵 ），并且满足</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BL%7D_%7B1%7D%5E%7B%5Cprime%7D%5Cmathbf%7BX%7D%20%26%3D%20%5Cmathbf%7BI%7D_%7Bp%7D%20%5C%5C%0A%5Cmathbf%7BL%7D_%7B2%7D%5E%7B%5Cprime%7D%5Cmathbf%7BX%7D%20%26%3D%20%5Cmathbf%7B0%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>我们对表型  <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/>  进行线性转换得到：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BL%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BL%7D_1%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%5Cmathbf%7BL%7D_2%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7By%7D_1%20%5C%5C%0A%5Cmathbf%7By%7D_2%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>转换后的数据服从分布：</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7By%7D_1%20%5C%5C%0A%5Cmathbf%7By%7D_2%0A%5Cend%7Barray%7D%5Cright%5D%20%5Csim%20%5Cmathrm%7BN%7D%5Cleft%28%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cboldsymbol%7B%5Cbeta%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%0A%5Cend%7Barray%7D%5Cright%5D%2C%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BL%7D_1%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BL%7D_1%20%26%20%5Cmathbf%7BL%7D_1%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BL%7D_2%20%5C%5C%0A%5Cmathbf%7BL%7D_2%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BL%7D_1%20%26%20%5Cmathbf%7BL%7D_2%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BL%7D_2%0A%5Cend%7Barray%7D%5Cright%5D%5Cright%29%0A" /></p><p>根据概率统计公式，我没有 <img src="https://math.now.sh?inline=f%28%5Cmathbf%7BL%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%29%20%3D%20f(%5Cmathbf%7By%7D_%7B1%7D%2C%5Cmathbf%7By%7D_%7B2%7D)%20%3D%20f(%5Cmathbf%7By%7D_%7B1%7D%7C%5Cmathbf%7By%7D_%7B2%7D)f(%5Cmathbf%7By%7D_%7B2%7D)" style="display:inline-block;margin: 0;"/>  ，因此其对数似然函数满足</p>
<p style=""><img src="https://math.now.sh?from=l%28%5Cmathbf%7BL%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%29%20%20%3D%20l(%5Cmathbf%7By%7D_%7B1%7D%7C%5Cmathbf%7By%7D_%7B2%7D)%20%2B%20l(%5Cmathbf%7By%7D_%7B2%7D)%0A" /></p><p>首先对于 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，我们有</p>
<p style=""><img src="https://math.now.sh?from=l%28%5Cmathbf%7BL%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%29%3D-%5Cfrac%7B1%7D%7B2%7D%5Cleft(%20%5Cln%20%7C%5Cmathbf%7B%5Cmathbf%7BL%7D%5E%7B%5Cprime%7DV%5Cmathbf%7BL%7D%7D%7C%2B%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cleft(%5Cmathbf%7By%7D_1-%5Cboldsymbol%7B%5Cbeta%7D%5Cright)%5E%7B%5Cprime%7D%20%26%20%5Cmathbf%7By%7D_2%5E%7B%5Cprime%7D%20%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cmathbf%7BL%7D%5E%7B%5Cprime%7D%5Cmathbf%7BV%7D%5Cmathbf%7BL%7D%5Cright%5D%5E%7B-1%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7By%7D_1-%5Cboldsymbol%7B%5Cbeta%7D%20%5C%5C%0A%5Cmathbf%7By%7D_2%0A%5Cend%7Barray%7D%5Cright%5D%5Cright)%0A" /></p><p>对于 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> ，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Al%28%5Cmathbf%7By%7D_%7B2%7D%29%20%26%3D%20-%5Cfrac%7B1%7D%7B2%7D%5Cleft(%20%5Cln%20%7C%5Cmathbf%7BL_%7B2%7D%5E%7B%5Cprime%7DVL_%7B2%7D%7D%7C%2B%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BL%7D_%7B2%7D%20%5Cleft(%5Cmathbf%7BL_%7B2%7D%5E%7B%5Cprime%7DVL_%7B2%7D%7D%5Cright)%5E%7B-1%7D%5Cmathbf%7BL%7D_%7B2%7D%5E%7B%5Cprime%7D%5Cmathbf%7By%7D%20%5Cright)%20%5C%5C%0A%26%3D%20-%5Cfrac%7B1%7D%7B2%7D%5Cleft(%20%5Cln%20%7C%5Cmathbf%7BL_%7B2%7D%5E%7B%5Cprime%7DVL_%7B2%7D%7D%7C%2B%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7By%7D%20%5Cright)%20%5Cquad%20%5Cbecause%20%20%5Cmathbf%7BP%7D%20%3D%20%5Cmathbf%7BL%7D_%7B2%7D%20%5Cleft(%5Cmathbf%7BL_%7B2%7D%5E%7B%5Cprime%7DVL_%7B2%7D%7D%5Cright)%5E%7B-1%7D%5Cmathbf%7BL%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>根据正态分布的条件分布公式</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%28%5Cmathbf%7By%7D%20%5Cmid%20%5Cmathbf%7Bx%7D%29%20%26%20%3D%5Cboldsymbol%7B%5Cmu%7D_y%2B%5Cboldsymbol%7B%5CSigma%7D_%7By%20x%7D%20%5Cboldsymbol%7B%5CSigma%7D_%7Bx%20x%7D%5E%7B-1%7D%5Cleft(%5Cmathbf%7Bx%7D-%5Cboldsymbol%7B%5Cmu%7D_x%5Cright)%20%5C%5C%0A%5Coperatorname%7Bcov%7D(%5Cmathbf%7By%7D%20%5Cmid%20%5Cmathbf%7Bx%7D)%20%26%20%3D%5Cboldsymbol%7B%5CSigma%7D_%7By%20y%7D-%5Cboldsymbol%7B%5CSigma%7D_%7By%20x%7D%20%5Cboldsymbol%7B%5CSigma%7D_%7Bx%20x%7D%5E%7B-1%7D%20%5Cboldsymbol%7B%5CSigma%7D_%7Bx%20y%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D_1%20%5Cmid%20%5Cmathbf%7By%7D_2%20%5Csim%20%5Cmathrm%7BN%7D%5Cleft%28%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cmathbf%7BL%7D_1%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BL%7D_2%5Cleft(%5Cmathbf%7BL%7D_2%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BL%7D_2%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7By%7D_2%2C%20%5Cmathbf%7BL%7D_1%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BL%7D_1-%5Cmathbf%7BL%7D_1%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BL%7D_2%5Cleft(%5Cmathbf%7BL%7D_2%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BL%7D_2%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BL%7D_2%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BL%7D_1%5Cright)%0A" /></p><p>其协方差部分可以进一步推导：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%20%5Cquad%20%5Cmathbf%7BL%7D_1%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BL%7D_1-%5Cmathbf%7BL%7D_1%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BL%7D_2%5Cleft%28%5Cmathbf%7BL%7D_2%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BL%7D_2%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BL%7D_2%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BL%7D_1%20%5C%5C%0A%26%3D%20%5Cmathbf%7BL%7D_1%5E%7B%5Cprime%7D%20%5Cleft(%5Cmathbf%7BV%7D%20-%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BL%7D_2%5Cleft(%5Cmathbf%7BL%7D_2%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BL%7D_2%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BL%7D_2%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cright)%5Cmathbf%7BL%7D_1%20%5C%5C%0A%26%3D%20%5Cmathbf%7BL%7D_1%5E%7B%5Cprime%7D%20%5Cleft(%5Cmathbf%7BV%7D%20-%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D%20%5Cright)%5Cmathbf%7BL%7D_1%20%5C%5C%0A%26%3D%20%5Cmathbf%7BL%7D_1%5E%7B%5Cprime%7D%20%5Cleft(%5Cmathbf%7BV%7D%20-%20%5Cmathbf%7BV%7D%20%5Cleft(%5Cmathbf%7BV%7D%5E%7B-1%7D-%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cright)%20%5Cmathbf%7BV%7D%20%5Cright)%5Cmathbf%7BL%7D_1%20%5C%5C%0A%26%3D%20%5Cmathbf%7BL%7D_1%5E%7B%5Cprime%7D%20%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%20%5Cmathbf%7BL%7D_1%20%5C%5C%0A%26%3D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cquad%20%5Cbecause%20%5Cmathbf%7BL%7D_%7B1%7D%5E%7B%5Cprime%7D%5Cmathbf%7BX%7D%20%3D%20%5Cmathbf%7BI%7D_%7Bp%7D%20%5C%5C%20%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D_1%20%5Cmid%20%5Cmathbf%7By%7D_2%20%5Csim%20%5Cmathrm%7BN%7D%5Cleft%28%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cmathbf%7By%7D_2%5E%7B*%7D%2C%20%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-1%7D%5Cright)%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D_2%5E%7B*%7D%20%3D%20%5Cmathbf%7BL%7D_1%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BL%7D_2%5Cleft%28%5Cmathbf%7BL%7D_2%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BL%7D_2%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7By%7D_2" style="display:inline-block;margin: 0;"/> 。</p>
<p>因此 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D_1%20%5Cmid%20%5Cmathbf%7By%7D_2" style="display:inline-block;margin: 0;"/> 的对数似然值可以写成</p>
<p style=""><img src="https://math.now.sh?from=l%28%5Cmathbf%7By%7D_1%20%5Cmid%20%5Cmathbf%7By%7D_2%29%20%3D%20%20-%5Cfrac%7B1%7D%7B2%7D%5Cleft(%20%5Cln%20%7C%5Cmathbf%7B(X%5E%7B%5Cprime%7DV%5E%7B-1%7DX)%7D%5E%7B-1%7D%7C%2B%5Cleft(%5Cmathbf%7By%7D_%7B1%7D-%5Cboldsymbol%7B%5Cbeta%7D-%5Cmathbf%7By%7D_2%5E%7B*%7D%5Cright)%5E%7B%5Cprime%7D%5Cmathbf%7B(X%5E%7B%5Cprime%7DV%5E%7B-1%7DX)%7D%20%5Cleft(%5Cmathbf%7By%7D_%7B1%7D-%5Cboldsymbol%7B%5Cbeta%7D-%5Cmathbf%7By%7D_2%5E%7B*%7D%5Cright)%20%5Cright)%0A" /></p><p>因为 <img src="https://math.now.sh?inline=l%28%5Cmathbf%7BL%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%29%20%20%3D%20l(%5Cmathbf%7By%7D_%7B1%7D%7C%5Cmathbf%7By%7D_%7B2%7D)%20%2B%20l(%5Cmathbf%7By%7D_%7B2%7D)" style="display:inline-block;margin: 0;"/> ，因此<strong>左右两边的对数项也相等</strong>，得到：</p>
<p style=""><img src="https://math.now.sh?from=%5Cln%20%7C%5Cmathbf%7B%5Cmathbf%7BL%7D%5E%7B%5Cprime%7DV%5Cmathbf%7BL%7D%7D%7C%20%3D%20%5Cln%20%7C%5Cmathbf%7BL_%7B2%7D%5E%7B%5Cprime%7DVL_%7B2%7D%7D%7C%20%2B%20%5Cln%20%7C%5Cmathbf%7B%28X%5E%7B%5Cprime%7DV%5E%7B-1%7DX%29%7D%5E%7B-1%7D%7C%0A" /></p><p>化简得到 (因为 <img src="https://math.now.sh?inline=%5Cln%20%7C%5Cmathbf%7B%5Cmathbf%7BL%7D%5E%7B%5Cprime%7DV%5Cmathbf%7BL%7D%7D%7C%20%3D%20%5Cln%20%7C%5Cmathbf%7BL%7D%5E%7B%5Cprime%7D%7C%20%5Cln%20%7C%20%5Cmathbf%7BV%7D%20%7C%20%5Cln%20%7C%5Cmathbf%7BL%7D%7C%20%3D%20%5Cln%20%7C%5Cmathbf%7B%5Cmathbf%7BL%7D%5E%7B%5Cprime%7D%5Cmathbf%7BL%7D%7D%7C%20%2B%20%5Cln%20%7C%5Cmathbf%7BV%7D%7C" style="display:inline-block;margin: 0;"/> )</p>
<p style=""><img src="https://math.now.sh?from=%5Cln%20%7C%5Cmathbf%7BL_%7B2%7D%5E%7B%5Cprime%7DVL_%7B2%7D%7D%7C%20%3D%20%5Cln%20%7C%5Cmathbf%7B%5Cmathbf%7BL%7D%5E%7B%5Cprime%7D%5Cmathbf%7BL%7D%7D%7C%20%2B%20%5Cln%20%7C%5Cmathbf%7BV%7D%7C%20%2B%20%5Cln%20%7C%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D%7C%0A" /></p><p>因此 REML （ <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> ）的对数似然函数可以写为（忽略常数项 <img src="https://math.now.sh?inline=%5Cln%20%7C%5Cmathbf%7B%5Cmathbf%7BL%7D%5E%7B%5Cprime%7D%5Cmathbf%7BL%7D%7D%7C" style="display:inline-block;margin: 0;"/> ）</p>
<p style=""><img src="https://math.now.sh?from=l%28%5Cmathbf%7By%7D_%7B2%7D%29%20%0A%3D%20-%5Cfrac%7B1%7D%7B2%7D%5Cleft(%20%5Cln%20%7C%5Cmathbf%7BV%7D%7C%20%2B%20%5Cln%20%7C%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D%7C%2B%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7By%7D%20%5Cright)%0A" /></p><p>根据舒尔补公式，系数矩阵的行列式可以写为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%7C%5Cmathbf%7BC%7D%7C%20%26%20%3D%5Cleft%7C%5Cmathbf%7BC%7D_%7BZ%20Z%7D%5Cright%7C%5Cleft%7C%5Cmathbf%7BC%7D_%7BX%20X%7D-%5Cmathbf%7BC%7D_%7BX%20Z%7D%20%5Cmathbf%7BC%7D_%7BZ%20Z%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D_%7BZ%20X%7D%5Cright%7C%20%5C%5C%0A%26%20%3D%5Cleft%7C%5Cmathbf%7BZ%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright%7C%5Cleft%7C%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%5Cmathbf%7BX%7D-%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%5Cmathbf%7BZ%7D%28%5Cmathbf%7BZ%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%29%5E%7B-1%7D%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%5Cmathbf%7BX%7D%5Cright%7C%20%5C%5C%0A%0A%26%20%3D%5Cleft%7C%5Cmathbf%7BZ%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright%7C%5Cleft%7C%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cleft(%5Cmathbf%7BR%5E%7B-1%7D-R%5E%7B-1%7DZ(Z%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D)%5E%7B-1%7DZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%20%5Cright)%20%5Cmathbf%7BX%7D%5Cright%7C%20%5C%5C%0A%26%20%3D%5Cleft%7C%5Cmathbf%7BZ%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright%7C%5Cleft%7C%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%7C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们得到 <img src="https://math.now.sh?inline=%5Cln%20%7C%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D%7C%20%3D%20%5Cln%20%7C%5Cmathbf%7BC%7D%7C%20-%20%5Cleft%7C%5Cmathbf%7BZ%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright%7C" style="display:inline-block;margin: 0;"/></p>
<p>对于 <img src="https://math.now.sh?inline=%7C%5Cmathbf%7BV%7D%7C" style="display:inline-block;margin: 0;"/> ，我们进行推导得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%7C%5Cmathbf%7BV%7D%7C%20%26%3D%20%7C%5Cmathbf%7BR%2BZGZ%5E%7B%5Cprime%7D%7D%7C%20%5C%5C%0A%26%3D%20%7C%5Cmathbf%7BR%7D%7C%7C%5Cmathbf%7BI_%7Bp%7D%2BZ%5E%7B%5Cprime%7DR%5E%7B-1%7DZG%7D%7C%20%5Cquad%20%5Cbecause%20%7C%5Cmathbf%7BA%7D%2B%5Cmathbf%7BB%7D%20%5Cmathbf%7BC%7D%7C%3D%7C%5Cmathbf%7BA%7D%7C%5Cleft%7C%5Cmathbf%7BI%7D_n%2B%5Cmathbf%7BC%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cmathbf%7BB%7D%5Cright%7C%20%5Cquad%20%5Ctext%7B%E8%A7%81%E9%99%84%E5%BD%951%7D%5C%5C%0A%26%3D%20%7C%5Cmathbf%7BR%7D%7C%7C%5Cmathbf%7BG%5E%7B-1%7D%2BZ%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%7D%7C%7C%5Cmathbf%7BG%7D%7C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此 <img src="https://math.now.sh?inline=%5Cln%20%7C%5Cmathbf%7BV%7D%7C%20%3D%20%5Cln%20%7C%5Cmathbf%7BR%7D%7C%20%2B%20%5Cln%7C%5Cmathbf%7BG%5E%7B-1%7D%2BZ%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%7D%7C%2B%5Cln%7C%5Cmathbf%7BG%7D%7C" style="display:inline-block;margin: 0;"/></p>
<p>将上面两个式子代入 <img src="https://math.now.sh?inline=l%28%5Cmathbf%7By%7D_%7B2%7D%29" style="display:inline-block;margin: 0;"/> 得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Al%28%5Cmathbf%7By%7D_%7B2%7D%29%20%0A%26%3D%20-%5Cfrac%7B1%7D%7B2%7D%5Cleft(%20%5Cln%20%7C%5Cmathbf%7BV%7D%7C%20%2B%20%5Cln%20%7C%5Cmathbf%7BX%5E%7B%5Cprime%7DV%5E%7B-1%7DX%7D%7C%2B%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7By%7D%20%5Cright)%20%5C%5C%0A%26%3D%20-%5Cfrac%7B1%7D%7B2%7D%5Cleft(%20%5Cln%20%7C%5Cmathbf%7BR%7D%7C%20%2B%20%5Cln%7C%5Cmathbf%7BG%5E%7B-1%7D%2BZ%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%7D%7C%2B%5Cln%7C%5Cmathbf%7BG%7D%7C%20%2B%5Cln%20%7C%5Cmathbf%7BC%7D%7C%20-%20%5Cleft%7C%5Cmathbf%7BZ%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright%7C%2B%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7By%7D%20%5Cright)%20%5C%5C%0A%26%3D%20-%5Cfrac%7B1%7D%7B2%7D%5Cleft(%20%5Cln%20%7C%5Cmathbf%7BR%7D%7C%20%2B%5Cln%7C%5Cmathbf%7BG%7D%7C%20%2B%5Cln%20%7C%5Cmathbf%7BC%7D%7C%2B%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7By%7D%20%5Cright)%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>左右乘以 -2  ，得到</p>
<p style=""><img src="https://math.now.sh?from=-2l%20%3D%20%5Cln%20%7C%5Cmathbf%7BR%7D%7C%20%2B%5Cln%7C%5Cmathbf%7BG%7D%7C%20%2B%5Cln%20%7C%5Cmathbf%7BC%7D%7C%2B%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7By%7D%0A" /></p><h1>ln|C|和 y’Py 的计算</h1>
<p>这里有两种方法可以计算 <img src="https://math.now.sh?inline=%5Cln%20%7C%5Cmathbf%7BC%7D%7C" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，第一种是是使用高斯消去法，我们建立混合线性模型方程组的增广矩阵如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BM%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%20%26%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%20%26%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%20%26%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BC%7D%20%26%20%5Cmathbf%7Br%7D%20%5C%5C%0A%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%26%20%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>利用高斯消去法消除其对角线下方的元素，将其变成一个上三角矩阵，此时最后一行的对角线元素就等于  <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 。因为我们可以用等价的方式，将 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 吸收近  <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，具体方式就是第二行子矩阵减去 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%5Cmathbf%7BC%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 乘以第一行（类似于元素级别的高斯消元，根据矩阵乘法的定义，这个行为是增广矩阵行之间的线性组合，和高斯消去法原理一样），得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BC%7D%20%26%20%5Cmathbf%7Br%7D%20%5C%5C%0A%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%26%20%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%26%5Cunderrightarrow%7B%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%7D%20%0A%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BC%7D%20%26%20%5Cmathbf%7Br%7D%20%5C%5C%0A%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D-%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%5Cmathbf%7BC%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%26%20%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%20-%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%5Cmathbf%7BC%7D%5E%7B-1%7D%20%5Cmathbf%7Br%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%20%5Cquad%20%5Cquad%20%20%3D%0A%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BC%7D%20%26%20%5Cmathbf%7Br%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%26%20%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%20-%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%5Cmathbf%7BC%7D%5E%7B-1%7D%20%5Cmathbf%7Br%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>其中右下角元素进一步推导得到（根据之前 REML 公式的推导，我们得到 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%5Cmathbf%7BPVPy%7D%20%3D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%28%5Cmathbf%7By%7D%20-%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20-%20%5Cmathbf%7BZ%7D%5Cmathbf%7Bu%7D%29" style="display:inline-block;margin: 0;"/> ）。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%20-%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%5Cmathbf%7BC%7D%5E%7B-1%7D%20%5Cmathbf%7Br%7D%20%26%3D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%20-%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bs%7D%20%5Cquad%20%5Cbecause%20%5Cmathbf%7BCs%3Dr%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%20-%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%20%5Cend%7Barray%7D%5Cright%5D%20%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20%5C%5C%20%5Cmathbf%7Bu%7D%20%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%3D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%28%5Cmathbf%7By%7D%20-%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20-%20%5Cmathbf%7BZ%7D%5Cmathbf%7Bu%7D%29%20%5C%5C%0A%26%3D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%5Cmathbf%7BPVPy%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%5Cmathbf%7BPy%7D%20%5Cquad%20%5Cbecause%20%5Cmathbf%7BPVP%3DP%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>高斯消元后， <img src="https://math.now.sh?inline=%5Cln%20%7C%5Cmathbf%7BC%7D%7C" style="display:inline-block;margin: 0;"/>  就是其前 n 个对角线元素的对数值之和，即</p>
<p style=""><img src="https://math.now.sh?from=%5Cln%20%7C%5Cmathbf%7BC%7D%7C%20%3D%20%5Cln%20U_%7B11%7D%20%2B%20%5Cln%20U_%7B22%7D%20%2B%20%5Ccdots%20%2B%20%5Cln%20U_%7Bnn%7D%0A" /></p><p>第二种方法是使用 Cholesky 分解，我们对系数矩阵进行分解，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BC%7D%20%3D%20%5Cmathbf%7BL%7D%5Cmathbf%7BL%7D%5E%7B%5Cprime%7D%0A" /></p><p>通过三角方程组求解，我们可以很容易地求解，得到 <img src="https://math.now.sh?inline=%5Cmathbf%7Bs%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>通过推导，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cmathbf%7BPy%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BV%5E%7B-1%7D%7D%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D%29%20%5C%5C%0A%26%3D%20%5Cleft(%20%5Cmathbf%7BR%5E%7B-1%7D-R%5E%7B-1%7DZ%5Cleft(Z%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D%5Cright)%5E%7B-1%7DZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%20%5Cright)(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D)%20%5C%5C%0A%26%3D%20%5Cmathbf%7BR%5E%7B-1%7D%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D)-%20%5Cmathbf%7BR%5E%7B-1%7DZ%5Cleft(Z%5E%7B%5Cprime%7DR%5E%7B-1%7DZ%2BG%5E%7B-1%7D%5Cright)%5E%7B-1%7DZ%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D)%20%5C%5C%0A%26%3D%20%5Cmathbf%7BR%5E%7B-1%7D%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D)-%20%5Cmathbf%7BR%5E%7B-1%7DZ%7D%5Cmathbf%7Bu%7D%20%5Cquad%20%5Cbecause%20%5Cmathbf%7Bu%7D%20%3D%5Cleft(%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%20%20%5C%5C%0A%26%3D%20%5Cmathbf%7BR%5E%7B-1%7D%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D%20-%5Cmathbf%7BZ%7D%5Cmathbf%7Bu%7D)%20%5C%5C%0A%26%3D%20%5Cmathbf%7BR%5E%7B-1%7D%7D%5Cmathbf%7Be%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>此时我们可以通过 <img src="https://math.now.sh?inline=%5Cmathbf%7By%5E%7B%5Cprime%7DR%5E%7B-1%7D%7D%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%20-%5Cmathbf%7BZ%7D%5Cmathbf%7B%5Chat%7Bu%7D%7D%29" style="display:inline-block;margin: 0;"/> 计算   <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/>  。对于  <img src="https://math.now.sh?inline=%5Cln%20%7C%5Cmathbf%7BC%7D%7C" style="display:inline-block;margin: 0;"/>   ，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cln%20%7C%5Cmathbf%7BC%7D%7C%20%3D%202%5Cln%20%7C%5Cmathbf%7BL%7D%7C%0A" /></p><p>如果我们对增广矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D" style="display:inline-block;margin: 0;"/> 进行 Cholesky 分解，则有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cln%20%7C%5Cmathbf%7BC%7D%7C%20%26%3D%202%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Cln%20l_%7Bii%7D%20%5C%5C%0A%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7By%7D%20%26%3D%20l_%7B%28n%2B1%29%2C(n%2B1)%7D%5E%7B2%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>第一条证明略，第二条证明如下，根据舒尔补公式，我们有</p>
<p style=""><img src="https://math.now.sh?from=%7C%5Cmathbf%7BM%7D%7C%20%3D%20%7C%5Cmathbf%7BC%7D%7C%7C%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%20-%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%5Cmathbf%7BC%7D%5E%7B-1%7D%20%5Cmathbf%7Br%7D%7C%20%3D%7C%5Cmathbf%7BC%7D%7C%7C%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7By%7D%7C%20%3D%20%7C%5Cmathbf%7BC%7D%7C%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7By%7D%20%0A" /></p><p>根据Cholesky 分解，我们有</p>
<p style=""><img src="https://math.now.sh?from=%7C%5Cmathbf%7BM%7D%7C%20%3D%20%5Cprod_%7Bi%3D1%7D%5E%7Bn%2B1%7D%20%20l_%7Bii%7D%5E%7B2%7D%0A" /></p><p>因此我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7By%7D%20%20%3D%20%5Cfrac%7B%5Cprod_%7Bi%3D1%7D%5E%7Bn%2B1%7D%20%20l_%7Bii%7D%5E%7B2%7D%7D%7B%5Cprod_%7Bi%3D1%7D%5E%7Bn%7D%20%20l_%7Bii%7D%5E%7B2%7D%7D%20%3D%20l_%7B%28n%2B1%29%2C(n%2B1)%7D%5E%7B2%7D%20%0A" /></p><h1>DF-REML</h1>
<p>非求导算法 (deritative-free, DF) 顾名思义即不计算导数对于不同的参数直接计算似然函数值，从中找到使得似然函数最大的一组参数。比如最简单的算法是将整个参数空间划分成 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个网格，每个网格中取一个点，然后计算一次似然函数值，找出最大值。</p>
<p>目前DFREML 中推荐的方法主要是 Simplex 法，其基本思想如下，假设需要估计的方差组分数目为 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> ，那么我们首先选择 <img src="https://math.now.sh?inline=p%2B1" style="display:inline-block;margin: 0;"/> 组方差组分初始值，每一组初始值就相当于 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> 维空间中的一个点，这里也称为一个 Simplex ，然后我们通过比较这  <img src="https://math.now.sh?inline=p%2B1" style="display:inline-block;margin: 0;"/> 组方差组分的似然函数值，淘汰其中最差的一个点，并通过某种方式产生一个新的点加入其中，如此不停迭代下去，不断向最大值运行，最终收敛于最大值。</p>
<p>当需要估计的方差组分数目较少时，DF-REML 算法较为适用，反之其收敛较慢。</p>
<h1>附录1：行列式性质</h1>
<p>对于矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7Bm%20%5Ctimes%20m%7D%2C%20%5Cmathbf%7BB%7D_%7Bm%20%5Ctimes%20n%7D%2C%20%5Cmathbf%7BC%7D_%7Bn%20%5Ctimes%20m%7D" style="display:inline-block;margin: 0;"/>, 其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 可逆，则存在</p>
<p style=""><img src="https://math.now.sh?from=%7C%5Cmathbf%7BA%7D%2B%5Cmathbf%7BB%7D%20%5Cmathbf%7BC%7D%7C%3D%7C%5Cmathbf%7BA%7D%7C%5Cleft%7C%5Cmathbf%7BI%7D_m%2B%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cmathbf%7BB%7D%20%5Cmathbf%7BC%7D%5Cright%7C%3D%7C%5Cmathbf%7BA%7D%7C%5Cleft%7C%5Cmathbf%7BI%7D_n%2B%5Cmathbf%7BC%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cmathbf%7BB%7D%5Cright%7C%0A" /></p><p>第一个等式不用证明，我们证明第二个等式。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%7C%5Cmathbf%7BA%7D%2B%5Cmathbf%7BB%7D%20%5Cmathbf%7BC%7D%7C%20%26%3D%20%5Cleft%7C%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BI%7D_%7Bn%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7BB%7D%20%26%20%5Cmathbf%7BI%7D_%7Bm%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BI%7D_%7Bn%7D%20%26%20-%5Cmathbf%7BC%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BA%2BBC%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cright%7C%20%5C%5C%0A%26%3D%20%5Cleft%7C%20%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BI%7D_%7Bn%7D%20%26%20-%5Cmathbf%7BC%7D%20%5C%5C%0A%5Cmathbf%7BB%7D%20%26%20%5Cmathbf%7BA%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cright%7C%20%5C%5C%0A%26%3D%7C%5Cmathbf%7BA%7D%7C%5Cleft%7C%5Cmathbf%7BI%7D_n%2B%5Cmathbf%7BC%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cmathbf%7BB%7D%5Cright%7C%20%5Cquad%20%5Cbecause%20%5Ctext%7B%E8%88%92%E5%B0%94%E8%A1%A5%E5%85%AC%E5%BC%8F%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>证明完毕。</p>
<h1>参考文献</h1>
<ol>
<li>
<p>Knight E. Improved iterative schemes for REML estimation of variance parameters in linear mixed models[D]. , 2008.</p>
</li>
<li>
<p>Verbyla A P. A conditional derivation of residual maximum likelihood[J]. Australian Journal of Statistics, 1990, 32(2): 227-230.</p>
</li>
<li>
<p><a href="https://ccjou.wordpress.com/2013/06/07/%E5%88%86%E5%A1%8A%E7%9F%A9%E9%99%A3%E7%9A%84%E8%A1%8C%E5%88%97%E5%BC%8F/">分块矩阵的行列式</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
        <tag>方差组分</tag>
        <tag>REML</tag>
      </tags>
  </entry>
  <entry>
    <title>方差组分估计方法二之ML和REML</title>
    <url>/posts/eba70c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这是方差组分估计方法的第二篇博客，介绍ML和REML两种方法及一些很早之前的算法。</p>
<span id="more"></span>
<h1>ML</h1>
<p>在最大似然方法中，我们需要新增分布假设，一般我们都采用<strong>正态假设</strong>，因此模型假设为 (这里假设所有随机效应的协方差矩阵均为对角矩阵)</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%20%5Ctext%20%7B%20is%20%7D%20N_%7Bn%7D%28%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2C%20%5Cmathbf%7BV%7D%29%2C%20%5Cquad%20%5Ctext%20%7B%20where%20%7D%20%5Cquad%20%5Cmathbf%7BV%7D%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Csigma_%7Bi%7D%5E%7B2%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%2B%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D_%7Bn%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 并且秩为 <img src="https://math.now.sh?inline=r%20%5Cleq%20p" style="display:inline-block;margin: 0;"/> 的矩阵。<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cmathbf%7BV%7D%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的<strong>正定</strong>矩阵。为了方便书写，我们记 <img src="https://math.now.sh?inline=%5Csigma_%7B0%7D%5E%7B2%7D%3D%5Csigma%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D_%7B0%7D%3D%5Cmathbf%7BI%7D_%7Bn%7D" style="display:inline-block;margin: 0;"/> ，因此协方差矩阵变成 (假设随机向量之间互不相关)</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BV%7D%3D%5Csum_%7Bi%3D0%7D%5E%7Bm%7D%20%5Csigma_%7Bi%7D%5E%7B2%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%0A" /></p><p>随机向量 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的联合分布密度函数，即似然函数为</p>
<p style=""><img src="https://math.now.sh?from=L%28%5Cmathbf%7By%7D%29%3D%5Cfrac%7B1%7D%7B(2%20%5Cpi)%5E%7Bn%20%2F%202%7D%7C%5Cmathbf%7BV%7D%7C%5E%7B1%20%2F%202%7D%7D%20%5Cexp%20%5Cleft%5C%7B-0.5(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cbeta)%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cbeta)%5Cright%5C%7D%0A" /></p><p>其对数为</p>
<p style=""><img src="https://math.now.sh?from=l%3D-0.5%20n%20%5Ctimes%20%5Cln%20%282%20%5Cpi%29-0.5%20%5Cln%20%7C%5Cmathbf%7BV%7D%7C-0.5(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cbeta)%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cbeta)%0A" /></p><p>对他求未知参数 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cboldsymbol%7B%5Ctheta%7D%7D%5E%7B%5Cprime%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Blllll%7D%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%5Cprime%7D%20%26%20%5Csigma_%7B0%7D%5E%7B2%7D%20%26%20%5Csigma_%7B1%7D%5E%7B2%7D%20%26%20%5Ccdots%20%26%20%5Csigma_%7Bm%7D%5E%7B2%7D%5Cend%7Barray%7D%5Cright%5D'" style="display:inline-block;margin: 0;"/> 的偏导数如下（证明略）</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cfrac%7B%5Cpartial%20l%7D%7B%5Cpartial%20%5Cboldsymbol%7B%5Cbeta%7D%7D%3D-%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D-%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%5Cright%29%20%5C%5C%0A%26%5Cfrac%7B%5Cpartial%20l%7D%7B%5Cpartial%20%5Csigma_%7Bi%7D%5E%7B2%7D%7D%3D-%5Cfrac%7B1%7D%7B2%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BV%7D%7D%7B%5Cpartial%20%5Csigma_%7Bi%7D%5E%7B2%7D%7D%5Cright)%2B%5Cfrac%7B1%7D%7B2%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BV%7D%7D%7B%5Cpartial%20%5Csigma_%7Bi%7D%5E%7B2%7D%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%20%5C%5C%0A%26%5Cleft(%5Cbecause%20%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Csigma_%7Bi%7D%5E%7B2%7D%7D%20%5Cln%20%7C%5Cmathbf%7BV%7D%7C%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BV%7D%7D%7B%5Cpartial%20%5Csigma_%7Bi%7D%5E%7B2%7D%7D%5Cright)%2C%20%5Cquad%20%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Csigma_%7Bi%7D%5E%7B2%7D%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%3D-%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BV%7D%7D%7B%5Cpartial%20%5Csigma_%7Bi%7D%5E%7B2%7D%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%5Cright)%20%5Cquad%20%5Ctext%7B%E5%8F%82%E8%80%83%20linear%20models%20in%20statistics%20%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>令上面两式为0，我们设 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D_%7Bi%7D%3D%20%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BV%7D%7D%7B%5Cpartial%20%5Csigma_%7Bi%7D%5E%7B2%7D%7D%3D%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%20%26%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%5Coperatorname%7Btr%7D%5Cleft%28%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%5Cright%29%20%26%3D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%20%5C%5C%0A%26%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%7B%5Cmathbf%7By%7D%7D%20%0A%5Cend%7Baligned%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Chat%7B%5Cmathbf%7BP%7D%7D%3D%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D-%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> ，因为下式成立</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7By%7D%20%26%3D%5Cleft%28%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D-%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%5Cright)%20%5Cmathbf%7By%7D%20%5C%5C%0A%26%3D%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%5Cleft(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%5Cright)%20%5C%5C%0A%26%3D%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%0A%5Cend%7Baligned%7D%0A" /></p><p>因为</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%28%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%5Cright%29%3D%5Coperatorname%7Btr%7D%5Cleft(%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5Cright)%3D%5Csum_%7Bj%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BV%7D_%7Bj%7D%20%5Chat%7B%5Csigma%7D_%7Bj%7D%5E%7B2%7D%5Cright)%0A" /></p><p>故有 ML 的估计方程为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Csum_%7Bj%7D%20%5Cleft%5C%7B%5Coperatorname%7Btr%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BV%7D_%7Bj%7D%5Cright%5C%7D%5Cleft%5C%7B%5Chat%7B%5Csigma%7D_%7Bj%7D%5E%7B2%7D%5Cright%5C%7D%3D%5Cleft%5C%7B%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7By%7D%5Cright%5C%7D%20%5C%5C%0A%26i%2C%20j%3D0%2C1%2C%20%5Ccdots%2C%20m%0A%5Cend%7Baligned%7D%0A" /></p><p>这个式子还可以换一种形式，对于左手项：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%20%5Csum_%7Bj%7D%20%5Cleft%5C%7B%5Coperatorname%7Btr%7D%20%5Cleft%28%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BV%7D_%7Bj%7D%20%5Cright%29%20%5Cright%5C%7D%5Cleft%5C%7B%5Chat%7B%5Csigma%7D_%7Bj%7D%5E%7B2%7D%5Cright%5C%7D%20%5C%5C%0A%26%3D%5Csum_%7Bj%7D%20%5Cleft%5C%7B%5Coperatorname%7Btr%7D%20%5Cleft(%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%20%5Cmathbf%7BZ%7D_%7Bj%7D%5Cmathbf%7BZ%7D_%7Bj%7D%5E%7B%5Cprime%7D%20%5Cright)%5Cright%5C%7D%5Cleft%5C%7B%5Chat%7B%5Csigma%7D_%7Bj%7D%5E%7B2%7D%5Cright%5C%7D%20%5C%5C%0A%26%20%3D%20%5Csum_%7Bj%7D%20%5Cleft%5C%7B%5Coperatorname%7Btr%7D%20%20%5Cleft(%20%5Cmathbf%7BZ%7D_%7Bj%7D%5E%7B%5Cprime%7D%20(%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bj%7D)%5Cright)%5Cright%5C%7D%5Cleft%5C%7B%5Chat%7B%5Csigma%7D_%7Bj%7D%5E%7B2%7D%5Cright%5C%7D%20%5C%5C%0A%26%20%3D%20%5Csum_%7Bj%7D%20%5Cleft%5C%7B%5Coperatorname%7Btr%7D%5Cleft(%20%20(%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bj%7D)%5E%7B%5Cprime%7D%20(%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bj%7D)%5Cright)%5Cright%5C%7D%5Cleft%5C%7B%5Chat%7B%5Csigma%7D_%7Bj%7D%5E%7B2%7D%5Cright%5C%7D%20%5C%5C%0A%26%20%3D%20%5Csum_%7Bj%7D%20%5Cleft%5C%7B%20%5Cmathrm%7Bsesq%7D%20(%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bj%7D)%5Cright%5C%7D%5Cleft%5C%7B%5Chat%7B%5Csigma%7D_%7Bj%7D%5E%7B2%7D%5Cright%5C%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>这里的 <img src="https://math.now.sh?inline=%5Cmathrm%7Bsesq%7D%28%5Cmathbf%7BA%7D%29" style="display:inline-block;margin: 0;"/> 就是矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 所有元素的平方和。</p>
<p>同理右手项可以写为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7By%7D%20%3D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7By%7D%20%3D%20%5Cmathrm%7Bsesq%7D%28%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7By%7D%29%0A" /></p><p>因此，上面的式子可以写为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Csum_%7Bj%7D%20%5Cleft%5C%7B%20%5Cmathrm%7Bsesq%7D%20%28%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bj%7D%29%5Cright%5C%7D%5Cleft%5C%7B%5Chat%7B%5Csigma%7D_%7Bj%7D%5E%7B2%7D%5Cright%5C%7D%3D%5Cmathrm%7Bsesq%7D(%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7By%7D)%20%5C%5C%0A%26i%2C%20j%3D0%2C1%2C%20%5Ccdots%2C%20m%0A%5Cend%7Baligned%7D%0A" /></p><p>很显然这个式子不是 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Csigma%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 的线性方程组，左手项的 <img src="https://math.now.sh?inline=%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 和右手项的 <img src="https://math.now.sh?inline=%5Chat%7B%5Cmathbf%7BP%7D%7D" style="display:inline-block;margin: 0;"/> 均包含<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Csigma%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 。根据此式子，我们显然找不到闭式解，还需要采用迭代的方式求解。我们可以设置  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Chat%7B%5Csigma%7D%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 的一个初始值，然后得到 <img src="https://math.now.sh?inline=%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Chat%7B%5Cmathbf%7BP%7D%7D" style="display:inline-block;margin: 0;"/> ，此时上面的方程组就变成了线性方程组，就可以求解得到一组新的   <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Chat%7B%5Csigma%7D%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>似然法的一个缺点式，当数据量比较小时，其估计值时有偏的。而且随着固定效应水平数目的增加和随机效应水平数目的减少，其偏差会愈加严重。</p>
<h2 id="估计值的方差">估计值的方差</h2>
<p>由于 ML 估计值必须通过迭代求解得到，因此不可能求得估计值的准确的抽样方差，但当样本数目较大时，可以求得估计值的近似方差（称为<strong>大样本方差</strong>）。这个方差是借助参数的<strong>信息矩阵</strong>来求得的，参数 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Ctheta%7D" style="display:inline-block;margin: 0;"/> 的信息矩阵用 <img src="https://math.now.sh?inline=%5Cmathbf%7BI%7D%28%5Cboldsymbol%7B%5Ctheta%7D%29" style="display:inline-block;margin: 0;"/> 表示，其定义为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BI%7D%28%5Cboldsymbol%7B%5Ctheta%7D%29%20%3D%20-%20%5Coperatorname%7BE%7D%5Cleft%5C%7B%20%5Cfrac%7B%5Cpartial%5E%7B2%7D%20l%7D%7B%5Cpartial%20%5Cboldsymbol%7B%5Ctheta%7D%20%5Cpartial%20%5Cboldsymbol%7B%5Ctheta%7D%5E%7B%5Cprime%7D%20%7D%20%5Cright%5C%7D%0A" /></p><p>其为二阶导的数学期望的负值。</p>
<p>Searle (1970) 证明，当样本数目足够大时，参数 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Ctheta%7D" style="display:inline-block;margin: 0;"/> 的 ML 估计值  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Chat%7B%5Ctheta%7D%7D" style="display:inline-block;margin: 0;"/> 的方差近似为：</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Bvar%7D%20%28%5Cboldsymbol%7B%5Chat%7B%5Ctheta%7D%7D%29%20%5Capprox%20%5Cleft%5B%5Cmathbf%7BI%7D(%5Cboldsymbol%7B%5Ctheta%7D)%20%5Cright%5D%5E%7B-1%7D%0A" /></p><p>注意这式子本身并不需要 ML 估计值   <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Chat%7B%5Ctheta%7D%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>ML 估计值的信息矩阵写为下式，其中 <img src="https://math.now.sh?inline=l_%7B%5Cboldsymbol%7B%5Cbeta%7D%20%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 表示 <img src="https://math.now.sh?inline=%5Cpartial%5E%7B2%7D%20l%2F%5Cpartial%20%5Cboldsymbol%7B%5Cbeta%7D%20%5Cpartial%20%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，其余式子类似。</p>
<p style=""><img src="https://math.now.sh?from=I%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cboldsymbol%7B%5Cbeta%7D%20%5C%5C%0A%5Cboldsymbol%7B%5Csigma%7D%5E2%0A%5Cend%7Barray%7D%5Cright%5D%3D-E%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0Al_%7B%5Cboldsymbol%7B%5Cbeta%7D%20%5Cboldsymbol%7B%5Cbeta%7D%7D%20%26%20l_%7B%5Cboldsymbol%7B%5Cbeta%7D%20%5Cboldsymbol%7B%5Csigma%7D%5E2%7D%20%5C%5C%0Al_%7B%5Cboldsymbol%7B%5Csigma%7D%5E2%20%5Cboldsymbol%7B%5Cbeta%7D%7D%20%26%20l_%7B%5Cboldsymbol%7B%5Csigma%7D%5E2%20%5Cboldsymbol%7B%5Csigma%7D%5E2%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>因为我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%5Cpartial%20l%7D%7B%5Cpartial%20%5Cboldsymbol%7B%5Cbeta%7D%7D%3D-%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D-%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%5Cright%29%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Csigma_%7Bi%7D%5E%7B2%7D%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%3D-%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BV%7D%7D%7B%5Cpartial%20%5Csigma_%7Bi%7D%5E%7B2%7D%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%3D%20-%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%0A" /></p><p>因此，推导得到</p>
<p style=""><img src="https://math.now.sh?from=l_%7B%5Cboldsymbol%7B%5Cbeta%7D%20%5Cboldsymbol%7B%5Cbeta%7D%7D%20%3D%20-%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%0A" /></p><p style=""><img src="https://math.now.sh?from=l_%7B%5Cboldsymbol%7B%5Cbeta%7D%20%5Cboldsymbol%7B%5Csigma%7D_%7Bi%7D%5E2%7D%20%3D%20-%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cmathbf%7BV%7D%5E%7B-1%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7BV%7D%5E%7B-1%7D%28%5Cmathbf%7By%7D%20-%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%29%0A" /></p><p>同时我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%5Cpartial%20l%7D%7B%5Cpartial%20%5Csigma_%7Bi%7D%5E%7B2%7D%7D%3D-%5Cfrac%7B1%7D%7B2%7D%20%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cright%29%2B%5Cfrac%7B1%7D%7B2%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%0A" /></p><p>因此，推导得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Al_%7B%5Cboldsymbol%7B%5Csigma%7D_%7Bi%7D%5E2%20%5Cboldsymbol%7B%5Csigma%7D_%7Bj%7D%5E2%7D%20%26%3D%20%5Cfrac%7B1%7D%7B2%7D%5Coperatorname%7Btr%7D%28%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bj%7D%5Cmathbf%7BZ%7D_%7Bj%7D%5E%7B%5Cprime%7D%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%29%20-%20%5Cfrac%7B1%7D%7B2%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bj%7D%5Cmathbf%7BZ%7D_%7Bj%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%20%5C%5C%0A%26%20%5Cquad%20-%20%5Cfrac%7B1%7D%7B2%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bj%7D%5Cmathbf%7BZ%7D_%7Bj%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%20%5C%5C%0A%26%3D%20%5Cfrac%7B1%7D%7B2%7D%5Coperatorname%7Btr%7D(%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bj%7D%5Cmathbf%7BZ%7D_%7Bj%7D%5E%7B%5Cprime%7D%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D)%20-%20(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bj%7D%5Cmathbf%7BZ%7D_%7Bj%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>然后再计算期望，我们已知 <img src="https://math.now.sh?inline=%5Coperatorname%7BE%7D%28%5Cmathbf%7By%7D%29%20%3D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> ，即 <img src="https://math.now.sh?inline=%5Coperatorname%7BE%7D%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%29%20%3D%20%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/>。我们再利用一个公式 <img src="https://math.now.sh?inline=%5Coperatorname%7BE%7D%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%29%5E%7B%5Cprime%7D%20%5Cmathbf%7BT%7D%20(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%20%3D%20%5Coperatorname%7Btr%7D%20(%5Cmathbf%7BTV%7D)" style="display:inline-block;margin: 0;"/> ,  其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D" style="display:inline-block;margin: 0;"/> 是一个非随机的矩阵。</p>
<p>证明过程如下，将 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 改成为 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cmu%7D" style="display:inline-block;margin: 0;"/></p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Coperatorname%7BE%7D%28%5Cmathbf%7By%7D-%5Cboldsymbol%7B%5Cmu%7D%29%5E%7B%5Cprime%7D%20%5Cmathbf%7BT%7D%20(%5Cmathbf%7By%7D-%5Cboldsymbol%7B%5Cmu%7D)%20%5C%5C%0A%26%3D%20%5Coperatorname%7BE%7D(%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%5Cmathbf%7BT%7D-%5Cboldsymbol%7B%5Cmu%7D%5E%7B%5Cprime%7D%5Cmathbf%7BT%7D)%20%20(%5Cmathbf%7By%7D-%5Cboldsymbol%7B%5Cmu%7D)%20%5C%5C%0A%26%3D%20%5Coperatorname%7BE%7D(%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%5Cmathbf%7BT%7D%5Cmathbf%7By%7D-%5Cboldsymbol%7B%5Cmu%7D%5E%7B%5Cprime%7D%5Cmathbf%7BT%7D%5Cmathbf%7By%7D%20-%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%5Cmathbf%7BT%7D%5Cboldsymbol%7B%5Cmu%7D%20%2B%20%5Cboldsymbol%7B%5Cmu%7D%5E%7B%5Cprime%7D%5Cmathbf%7BT%7D%20%5Cboldsymbol%7B%5Cmu%7D)%20%5C%5C%0A%26%3D%20%5Coperatorname%7BE%7D(%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%5Cmathbf%7BT%7D%5Cmathbf%7By%7D)-%5Coperatorname%7BE%7D(%5Cboldsymbol%7B%5Cmu%7D%5E%7B%5Cprime%7D%5Cmathbf%7BT%7D%5Cmathbf%7By%7D)%20-%20%5Coperatorname%7BE%7D(%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%5Cmathbf%7BT%7D%5Cboldsymbol%7B%5Cmu%7D)%20%2B%20%5Coperatorname%7BE%7D(%5Cboldsymbol%7B%5Cmu%7D%5E%7B%5Cprime%7D%5Cmathbf%7BT%7D%20%5Cboldsymbol%7B%5Cmu%7D)%20%5C%5C%0A%26%3D%20%5Coperatorname%7BE%7D(%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%5Cmathbf%7BT%7D%5Cmathbf%7By%7D)-%5Cboldsymbol%7B%5Cmu%7D%5E%7B%5Cprime%7D%5Cmathbf%7BT%7D%5Coperatorname%7BE%7D(%5Cmathbf%7By%7D)%20-%20%5Coperatorname%7BE%7D(%5Cmathbf%7By%7D%5E%7B%5Cprime%7D)%5Cmathbf%7BT%7D%5Cboldsymbol%7B%5Cmu%7D%20%2B%20%5Cboldsymbol%7B%5Cmu%7D%5E%7B%5Cprime%7D%5Cmathbf%7BT%7D%20%5Cboldsymbol%7B%5Cmu%7D%20%5C%5C%0A%26%3D%20%5Coperatorname%7BE%7D(%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%5Cmathbf%7BT%7D%5Cmathbf%7By%7D)-%5Cboldsymbol%7B%5Cmu%7D%5E%7B%5Cprime%7D%5Cmathbf%7BT%7D%20%5Cboldsymbol%7B%5Cmu%7D%20%5C%5C%0A%26%3D%20%5Coperatorname%7Btr%7D%20(%5Cmathbf%7BTV%7D)%2B%5Cboldsymbol%7B%5Cmu%7D%5E%7B%5Cprime%7D%5Cmathbf%7BT%7D%20%5Cboldsymbol%7B%5Cmu%7D-%5Cboldsymbol%7B%5Cmu%7D%5E%7B%5Cprime%7D%5Cmathbf%7BT%7D%20%5Cboldsymbol%7B%5Cmu%7D%20%5Cquad%20%5Cbecause%20%5Coperatorname%7BE%7D(%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%5Cmathbf%7BT%7D%5Cmathbf%7By%7D)%20%3D%20%5Coperatorname%7Btr%7D%20(%5Cmathbf%7BTV%7D)%2B%5Cboldsymbol%7B%5Cmu%7D%5E%7B%5Cprime%7D%5Cmathbf%7BT%7D%20%5Cboldsymbol%7B%5Cmu%7D%20%5C%5C%0A%0A%26%3D%20%5Coperatorname%7Btr%7D%20(%5Cmathbf%7BTV%7D)%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此我们得到：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A-E%20l_%7B%5Cboldsymbol%7B%5Cbeta%7D%20%5Cboldsymbol%7B%5Cbeta%7D%7D%20%26%20%3DE%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%29%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%2C%20%5C%5C%0A-E%20l_%7B%5Cboldsymbol%7B%5Cbeta%7D%20%5Csigma_i%5E2%7D%20%26%20%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_i%20%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20E(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%3D%5Cmathbf%7B0%7D%20%5C%5C%0A-E%20l_%7B%5Csigma_i%5E2%20%5Csigma_j%5E2%7D%20%26%20%3D-%5Cfrac%7B1%7D%7B2%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_i%20%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_j%20%5Cmathbf%7BZ%7D_j%5E%7B%5Cprime%7D%5Cright)%2B%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_i%20%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_j%20%5Cmathbf%7BZ%7D_j%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BV%7D%5Cright)%20%5C%5C%0A%26%20%3D%5Cfrac%7B1%7D%7B2%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_i%20%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_j%20%5Cmathbf%7BZ%7D_j%5E%7B%5Cprime%7D%5Cright)%20%0A%5Cend%7Baligned%7D%0A" /></p><p>因此信息矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BI%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cboldsymbol%7B%5Cbeta%7D%20%5C%5C%0A%5Cboldsymbol%7B%5Csigma%7D%5E2%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cfrac%7B1%7D%7B2%7D%5Cleft%5C%7B_%5Cmathrm%7Bm%7D%20%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_i%20%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_j%20%5Cmathbf%7BZ%7D_j%5E%7B%5Cprime%7D%5Cright%29%5Cright%5C%7D_%7Bi%2C%20j%3D0%7D%0A%5Cend%7Barray%7D%5Cright%5D%20.%0A" /></p><p>因此估计值的协方差矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Bvar%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cboldsymbol%7B%5Cbeta%7D%20%5C%5C%0A%5Ctilde%7B%5Csigma%7D%5E2%0A%5Cend%7Barray%7D%5Cright%5D%20%26%20%5Csimeq%5Cleft%28%5Cmathbf%7BI%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cboldsymbol%7B%5Cbeta%7D%20%5C%5C%0A%5Cboldsymbol%7B%5Csigma%7D%5E2%0A%5Cend%7Barray%7D%5Cright%5D%5Cright%29%5E%7B-1%7D%20%5C%5C%0A%26%20%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%202%5Cleft%5B%5Cleft%5C%7B%5Cmathrm%7B~m%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_i%20%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_j%20%5Cmathbf%7BZ%7D_j%5E%7B%5Cprime%7D%5Cright)%5Cright%5C%7D_%7Bi%2C%20j%3D0%7D%5Er%5Cright%5D%5E%7B-1%7D%0A%5Cend%7Barray%7D%5Cright%5D%2C%0A%5Cend%7Baligned%7D%0A" /></p><h2 id="The-Hartley-Rao-form">The Hartley-Rao form</h2>
<p>Hartley 和 Rao 在 1967 年提出了基于 <img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D" style="display:inline-block;margin: 0;"/> 矩阵的似然函数，其中  <img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D" style="display:inline-block;margin: 0;"/> 矩阵定义为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BV%7D%20%3D%20%5Cmathbf%7BH%7D%20%5Csigma_%7Be%7D%5E%7B2%7D%20%5Cqquad%20%5Ctext%7Bwith%7D%20%5Cqquad%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%3D%20%5Cmathbf%7BH%7D%5E%7B-1%7D%2F%20%5Csigma_%7Be%7D%5E%7B2%7D%0A" /></p><p>因此  <img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D" style="display:inline-block;margin: 0;"/> 矩阵和  <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D" style="display:inline-block;margin: 0;"/> 矩阵具有相同的形式，不过 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D" style="display:inline-block;margin: 0;"/> 矩阵中的 <img src="https://math.now.sh?inline=%5Csigma_%7Be%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 变成了1，而  <img src="https://math.now.sh?inline=%5Csigma_%7Bi%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 变成了 <img src="https://math.now.sh?inline=%5Cgamma_%7Bi%7D%20%3D%20%5Csigma_%7Bi%7D%5E%7B2%7D%2F%5Csigma_%7Be%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，这意味着此时需要估计的参数为 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Csigma_%7Be%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cgamma_%7B1%7D%2C%20%5Ccdots%2C%20%5Cgamma_%7Br%7D" style="display:inline-block;margin: 0;"/> (这里的 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> 就是上面的 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> ，随机效应数目)，此时我们将 <img src="https://math.now.sh?inline=%5Csigma_%7Be%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 单独拎了出来。</p>
<p>我们从之前的公式 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cright%29%20%0A%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%7B%5Cmathbf%7By%7D%7D" style="display:inline-block;margin: 0;"/> 出发进行推导，首先，当 <img src="https://math.now.sh?inline=i%3D0" style="display:inline-block;margin: 0;"/> 时，此时 <img src="https://math.now.sh?inline=%5Csigma_%7B0%7D%5E%7B2%7D%20%3D%20%5Csigma_%7Be%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D_%7B0%7D%20%3D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ，因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%28%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cright%29%20%0A%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%5E%7B2%7D%20%7B%5Cmathbf%7By%7D%7D%20%3D%20(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-2%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%0A" /></p><p>代入 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D%5E%7B-1%7D%20%3D%20%5Cmathbf%7BH%7D%5E%7B-1%7D%2F%20%5Csigma_%7Be%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%28%5Chat%7B%5Cmathbf%7BH%7D%7D%5E%7B-1%7D%20%5Cright%29%20%0A%3D%20(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BH%7D%7D%5E%7B-2%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%2F%20%5Chat%7B%5Csigma%7D_%7Be%7D%5E%7B2%7D%0A" /></p><p>因此</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Csigma%7D_%7Be%7D%5E%7B2%7D%20%3D%20%5Cfrac%7B%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BH%7D%7D%5E%7B-2%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%7D%7B%5Coperatorname%7Btr%7D%5Cleft(%5Chat%7B%5Cmathbf%7BH%7D%7D%5E%7B-1%7D%20%5Cright)%7D%0A" /></p><p>然后我们继续看其它方差组分 (<img src="https://math.now.sh?inline=i%3D1%2C%5Ccdots%2Cr" style="display:inline-block;margin: 0;"/>) 的式子，对于公式 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cright%29%20%0A%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%7B%5Cmathbf%7By%7D%7D" style="display:inline-block;margin: 0;"/> ，左右乘以  <img src="https://math.now.sh?inline=%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 并对 <img src="https://math.now.sh?inline=i%3D1%2C%5Ccdots%2Cr" style="display:inline-block;margin: 0;"/> 的式子求和得到：</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%28%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Csum_%7Bi%3D1%7D%5E%7Br%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D%20%5Cright%29%20%0A%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Br%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D%20%5Cright)%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%7B%5Cmathbf%7By%7D%7D%0A" /></p><p>代入<img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D%5E%7B-1%7D%20%3D%20%5Cmathbf%7BH%7D%5E%7B-1%7D%2F%20%5Csigma_%7Be%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7By%7D%20%0A%3D%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29" style="display:inline-block;margin: 0;"/> 以及 <img src="https://math.now.sh?inline=%5Csum_%7Bi%3D1%7D%5E%7Br%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D%20%3D%20%5Cmathbf%7BV%7D%20-%20%5Csigma_%7Be%7D%5E%7B2%7D%5Cmathbf%7BI%7D%3D%20%28%5Cmathbf%7BH%7D%20-%20%5Cmathbf%7BI%7D%29%5Csigma_%7Be%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%28(%5Cmathbf%7B%5Chat%7BH%7D%7D%5E%7B-1%7D%2F%5Chat%7B%5Csigma%7D_%7Be%7D%5E%7B2%7D%29%20%20(%5Cmathbf%7B%5Chat%7BH%7D%7D%20-%20%5Cmathbf%7BI%7D)%5Chat%7B%5Csigma%7D_%7Be%7D%5E%7B2%7D%20%5Cright)%20%0A%3D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%5E%7B%5Cprime%7D%20%5Cmathbf%7B%5Chat%7BH%7D%7D%5E%7B-1%7D%2F%20%5Chat%7B%5Csigma%7D_%7Be%7D%5E%7B2%7D%20(%5Cmathbf%7B%5Chat%7BH%7D%7D%20-%20%5Cmathbf%7BI%7D)%5Chat%7B%5Csigma%7D_%7Be%7D%5E%7B2%7D%20%5Cmathbf%7B%5Chat%7BH%7D%7D%5E%7B-1%7D%2F%20%5Chat%7B%5Csigma%7D_%7Be%7D%5E%7B2%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%0A" /></p><p>化简得到</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BI%7D%20-%20%5Cmathbf%7B%5Chat%7BH%7D%7D%5E%7B-1%7D%20%5Cright%29%20%0A%3D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%5E%7B%5Cprime%7D%20%20(%5Cmathbf%7B%5Chat%7BH%7D%7D%5E%7B-1%7D%20-%20%5Cmathbf%7B%5Chat%7BH%7D%7D%5E%7B-2%7D)%20(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%2F%5Chat%7B%5Csigma%7D_%7Be%7D%5E%7B2%7D%0A" /></p><p>等价于</p>
<p style=""><img src="https://math.now.sh?from=N%5Chat%7B%5Csigma%7D_%7Be%7D%5E%7B2%7D%20%3D%20%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29%5E%7B%5Cprime%7D%20%20%5Cmathbf%7B%5Chat%7BH%7D%7D%5E%7B-1%7D%20(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%20%2B%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7B%5Chat%7BH%7D%7D%5E%7B-1%7D%20%5Cright)%20%5Cleft%5B%20%5Chat%7B%5Csigma%7D_%7Be%7D%5E%7B2%7D%20-%20%5Cfrac%7B(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%5E%7B%5Cprime%7D%20%20%5Cmathbf%7B%5Chat%7BH%7D%7D%5E%7B-2%7D%20(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%7D%7B%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7B%5Chat%7BH%7D%7D%5E%7B-1%7D%20%5Cright)%7D%20%20%5Cright%5D%0A" /></p><p>根据上面的推导公式，方括号内的值为 0，因此我们得到 <img src="https://math.now.sh?inline=%5Chat%7B%5Csigma%7D_%7Be%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 的计算公式</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Csigma%7D_%7Be%7D%5E%7B2%7D%20%3D%20%5Cfrac%7B%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29%5E%7B%5Cprime%7D%20%20%5Cmathbf%7B%5Chat%7BH%7D%7D%5E%7B-1%7D%20(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%7D%7BN%7D%0A" /></p><p>对于公式 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cright%29%20%0A%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%7B%5Cmathbf%7By%7D%7D" style="display:inline-block;margin: 0;"/> ，化简得到</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%28%5Chat%7B%5Cmathbf%7BH%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cright%29%20%0A%3D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%5E%7B%5Cprime%7D%20%5Cmathbf%7B%5Chat%7BH%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7B%5Chat%7BH%7D%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%2F%5Chat%7B%5Csigma%7D_%7Be%7D%5E%7B2%7D%0A" /></p><p>汇总一下，Hartley 和 Rao 方法中设计的方程组为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%20%26%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%5Chat%7B%5Csigma%7D_%7Be%7D%5E%7B2%7D%20%26%3D%20%5Cfrac%7B%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29%5E%7B%5Cprime%7D%20%20%5Cmathbf%7B%5Chat%7BH%7D%7D%5E%7B-1%7D%20(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%7D%7BN%7D%20%5C%5C%0A%26%5Ctext%7Band%7D%20%5C%5C%0A%5Coperatorname%7Btr%7D%5Cleft(%5Chat%7B%5Cmathbf%7BH%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cright)%20%0A%26%3D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%5E%7B%5Cprime%7D%20%5Cmathbf%7B%5Chat%7BH%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7B%5Chat%7BH%7D%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%2F%5Chat%7B%5Csigma%7D_%7Be%7D%5E%7B2%7D%20%5C%5C%0A%26i%3D1%2C%20%5Ccdots%2C%20r%0A%0A%5Cend%7Baligned%7D%0A" /></p><h2 id="EM-算法">EM 算法</h2>
<p>混合详细模型如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%20%3D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20%2B%20%5Cmathbf%7BZ%7D%5Cmathbf%7Bu%7D%20%2B%20%5Cmathbf%7Be%7D%0A" /></p><p>对于公式 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%5Cright%29%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%7B%5Cmathbf%7By%7D%7D" style="display:inline-block;margin: 0;"/> ，我们在等式两边同乘以 <img src="https://math.now.sh?inline=%5Chat%7B%5Csigma%7D%5E%7B2%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，并求总和，得到：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Btr%7D%5Cleft%28%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Csum%20%5Cmathbf%7B%5Chat%7BV%7D%7D_%7Bi%7D%20%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D%5Cright%29%20%26%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Csum%20%5Cmathbf%7BV%7D_%7Bi%7D%20%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%5Cmathbf%7By%7D%20%5C%5C%0AN%20%26%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7B%5Chat%7BV%7D%7D%20%20%5Chat%7B%5Cmathbf%7BP%7D%7D%5Cmathbf%7By%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=N" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D" style="display:inline-block;margin: 0;"/> 矩阵维度，即表型数目。</p>
<p>我们再看右手项，在之前 ML 的推导中，我们知道 <img src="https://math.now.sh?inline=%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7By%7D%20%3D%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29" style="display:inline-block;margin: 0;"/> ，因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7B%5Chat%7BV%7D%7D%20%20%5Chat%7B%5Cmathbf%7BP%7D%7D%5Cmathbf%7By%7D%0A%26%3D%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%5C%5C%0A%0A%26%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%20%20-%20%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5E%7B%5Cprime%7D%20%5Cleft(%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%20-%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%20%5Cright)%5C%5C%0A%0A%26%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%20%5Cquad%5Cleft(%5Cbecause%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%5Cright)%5C%5C%0A%26%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%5Cleft%5B%5Chat%7B%5Cmathbf%7BR%7D%7D%5E%7B-1%7D-%5Chat%7B%5Cmathbf%7BR%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5Cleft(%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BR%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Chat%7B%5Cmathbf%7BG%7D%7D%5E%7B-1%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BR%7D%7D%5E%7B-1%7D%5Cright%5D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%5C%5C%0A%26%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BR%7D%7D%5E%7B-1%7D%5Cleft%5B(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)-%5Cmathbf%7BZ%7D%5Cleft(%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BR%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Chat%7B%5Cmathbf%7BG%7D%7D%5E%7B-1%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BR%7D%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%5Cright%5D%5C%5C%0A%26%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BR%7D%7D%5E%7B-1%7D%5B(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)-%5Cmathbf%7BZ%7D%20%5Chat%7B%5Cmathbf%7Bu%7D%7D%5D%5C%5C%0A%26%5Cleft(%5Cbecause%20%5Chat%7B%5Cmathbf%7Bu%7D%7D%3D%5Cleft(%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright)%5E%7B-1%7D%5Cleft(%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D-%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5Cright)%5Cright)%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7B%5Chat%7B%5Csigma%7D_%7B0%7D%5E%7B2%7D%7D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D-%5Cmathbf%7BZ%7D%20%5Chat%7B%5Cmathbf%7Bu%7D%7D)%20%5Cquad%20%5Cbecause%20%5Ctext%7B%E5%81%87%E8%AE%BE%E4%B8%BA%E5%8D%95%E6%80%A7%E7%8A%B6%E6%A8%A1%E5%9E%8B%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Csigma%7D_%7B0%7D%5E%7B2%7D%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D-%5Cmathbf%7BZ%7D%20%5Chat%7B%5Cmathbf%7Bu%7D%7D%29%20%2FN%0A" /></p><p>其它方差组分公式的证明过程如下</p>
<p>首先我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Bvar%7D%28%5Cmathbf%7Be%7D%29%20%3D%20%5Cmathbf%7BR%7D%20%3D%20%5Csigma_%7Be%7D%5E%7B2%7D%5Cmathbf%7BI%7D_%7BN%7D%20%5Cquad%20%5Ctext%7Band%7D%20%5Cquad%20%5Coperatorname%7Bvar%7D(%5Cmathbf%7Bu%7D)%20%3D%20%5Cmathbf%7BG%7D%20%3D%20%5Cleft%5C%7B_%7Bd%7D%20%5Csigma_%7Bi%7D%5E%7B2%7D%20%5Cmathbf%7BI%7D_%7Bq_%7Bi%7D%7D%20%5Cright%5C%7D_%7Bi%3D1%7D%5E%7Br%7D%0A" /></p><p>这里我们进一步提出两个矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BF%7D_%7Bii%7D" style="display:inline-block;margin: 0;"/> 矩阵，第一个矩阵如下，其中 <img src="https://math.now.sh?inline=q_%7B.%7D%20%3D%20%5Csum_%7Bi%3D1%7D%5E%7Br%7D%20q_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，即所有随机效应水平总数。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BW%7D%20%3D%20%28%5Cmathbf%7BI%2BZ'R%5E%7B-1%7DZG%7D%29%5E%7B-1%7D%20%3D%20%5Cleft%5C%7B%20%5Cmathbf%7BW%7D_%7Bij%7D%20%5Cright%5C%7D_%7Bi%2Cj%3D1%7D%5E%7Br%7D%20%5Cquad%20%5Ctext%7Bwith%7D%20%5Cquad%20%5Cmathbf%7BW%7D%5E%7B-1%7D%20-%20%5Cmathbf%7BI%7D_%7Bq_%7B.%7D%7D%20%3D%20%5Cmathbf%7BZ'R%5E%7B-1%7DZG%7D%0A" /></p><p>第二个矩阵是 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵的变体， <img src="https://math.now.sh?inline=%5Cmathbf%7BF%7D_%7Bii%7D" style="display:inline-block;margin: 0;"/> 是将 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵中的所有 <img src="https://math.now.sh?inline=%5Csigma_%7Bi%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 替换为 1，而其它 <img src="https://math.now.sh?inline=%5Csigma_%7Bj%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> (<img src="https://math.now.sh?inline=j%20%5Cneq%20i" style="display:inline-block;margin: 0;"/> ) 替换为0 （注意这里的  <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵是一个对角矩阵），因此我没有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BG%7D%5Cmathbf%7BF%7D_%7Bii%7D%20%3D%20%5Csigma_%7Bi%7D%5E%7B2%7D%5Cmathbf%7BF%7D_%7Bii%7D%20%5Cquad%20%5Ctext%7Band%7D%20%5Cquad%20%5Cmathbf%7BF%7D_%7Bii%7D%20%3D%20%5Cmathbf%7BG%7D%5Cmathbf%7BF%7D_%7Bii%7D%2F%5Csigma_%7Bi%7D%5E%7B2%7D%0A" /></p><p>举个例子，假设 <img src="https://math.now.sh?inline=q_%7B1%7D%3D2%2C%20q_%7B2%7D%3D3%2Cq_%7B3%7D%3D4" style="display:inline-block;margin: 0;"/> ，那么我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BF_%7B22%7D%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D%0A%5Cmathbf%7B0%7D_%7B2%20%5Ctimes%202%7D%20%26%20%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B1%7D_%7B3%20%5Ctimes%203%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D_%7B4%20%5Ctimes%204%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5Ctext%20%7B.%20%7D%0A" /></p><p>根据 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 公式，我们可以推导出</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BV%7D%5E%7B-1%7D%20%26%3D%20%5Cmathbf%7BR%7D%5E%7B-1%7D-%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5Cleft%28%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5C%5C%0A%26%3D%20%20%5Cmathbf%7BR%7D%5E%7B-1%7D-%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5Cleft(%5Cleft(%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7BG%7D%20%2B%20%5Cmathbf%7BI%7D%20%5Cright)%20%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5C%5C%0A%26%3D%20%20%5Cmathbf%7BR%7D%5E%7B-1%7D-%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5Cmathbf%7BG%7D%5Cleft(%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7BG%7D%20%2B%20%5Cmathbf%7BI%7D%20%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5C%5C%0A%26%3D%20%20%5Cmathbf%7BR%7D%5E%7B-1%7D-%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5Cmathbf%7BG%7D%5Cmathbf%7BW%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>对于其它方程组分我们有  <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cright%29%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%7B%5Cmathbf%7By%7D%7D" style="display:inline-block;margin: 0;"/> 的左手项，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Btr%7D%5Cleft%28%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cright%29%20%26%3D%20%5Coperatorname%7Btr%7D%5Cleft(%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cleft(%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7BF%7D_%7Bii%7D%5Cright)%20%5Cleft(%20%5Cmathbf%7BF%7D_%7Bii%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cright)%5Cright)%20%5C%5C%0A%20%26%3D%20%5Coperatorname%7Btr%7D%5Cleft(%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7BF%7D_%7Bii%7D%5E%7B2%7D%20%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%5Cright)%20%5C%5C%0A%20%20%26%3D%20%5Coperatorname%7Btr%7D%5Cleft(%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7BF%7D_%7Bii%7D%20%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%5Cright)%20%5C%5C%0A%20%20%26%3D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7BF%7D_%7Bii%7D%20%20%5Cright)%20%5C%5C%0A%20%20%26%3D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%5Cleft%5B%5Cmathbf%7B%5Chat%7BR%7D%7D%5E%7B-1%7D-%5Cmathbf%7B%5Chat%7BR%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5Cmathbf%7B%5Chat%7BG%7D%7D%5Cmathbf%7BW%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7B%5Chat%7BR%7D%7D%5E%7B-1%7D%20%5Cright%5D%20%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7BF%7D_%7Bii%7D%20%20%5Cright)%20%5C%5C%0A%20%20%26%3D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cleft%5B%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7B%5Chat%7BR%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7B%5Chat%7BG%7D%7D%20-%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7B%5Chat%7BR%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5Cmathbf%7B%5Chat%7BG%7D%7D%5Cmathbf%7BW%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7B%5Chat%7BR%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5Cmathbf%7B%5Chat%7BG%7D%7D%20%5Cright%5D%20%20%5Cmathbf%7BF%7D_%7Bii%7D%2F%5Csigma_%7Bi%7D%5E%7B2%7D%20%20%5Cright)%20%5Cquad%20%5Cbecause%20%5Cmathbf%7BF%7D_%7Bii%7D%20%3D%20%5Cmathbf%7BG%7D%5Cmathbf%7BF%7D_%7Bii%7D%2F%5Csigma_%7Bi%7D%5E%7B2%7D%20%5C%5C%0A%26%3D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cleft%5B%20%5Cmathbf%7BW%7D%5E%7B-1%7D%20-%20%5Cmathbf%7BI%7D%20-%5Cleft(%20%5Cmathbf%7BW%7D%5E%7B-1%7D%20-%20%5Cmathbf%7BI%7D%20%5Cright)%5Cmathbf%7BW%7D%20%5Cleft(%20%5Cmathbf%7BW%7D%5E%7B-1%7D%20-%20%5Cmathbf%7BI%7D%20%5Cright)%20%5Cright%5D%20%20%5Cmathbf%7BF%7D_%7Bii%7D%2F%5Csigma_%7Bi%7D%5E%7B2%7D%20%20%5Cright)%20%20%5C%5C%0A%26%3D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cleft(%20%5Cmathbf%7BI%7D%20-%20%5Cmathbf%7BW%7D%20%5Cright)%20%20%5Cmathbf%7BF%7D_%7Bii%7D%2F%5Csigma_%7Bi%7D%5E%7B2%7D%20%20%5Cright)%20%20%5C%5C%0A%26%3D%20%5Coperatorname%7Btr%7D%5Cleft(%20%5Cmathbf%7BF%7D_%7Bii%7D%20-%20%5Cmathbf%7BW%7D%20%20%20%5Cmathbf%7BF%7D_%7Bii%7D%20%20%5Cright)%20%2F%5Csigma_%7Bi%7D%5E%7B2%7D%20%5C%5C%0A%26%3D%20%5Cfrac%7B%20%5Cmathbf%7Bq%7D_%7Bi%7D%20-%20%5Coperatorname%7Btr%7D%20%5Cleft(%5Cmathbf%7BW%7D_%7Bii%7D%5Cright)%7D%20%7B%5Csigma_%7Bi%7D%5E%7B2%7D%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D_%7Bii%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D" style="display:inline-block;margin: 0;"/> 矩阵中第 <img src="https://math.now.sh?inline=%28i%2Ci%29" style="display:inline-block;margin: 0;"/> 个子矩阵。</p>
<p>右手项可以写为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%7B%5Cmathbf%7By%7D%7D%0A%26%20%3D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7BF%7D_%7Bii%7D%20%5Cmathbf%7BF%7D_%7Bii%7D%5E%7B%5Cprime%7D%20%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%7B%5Cmathbf%7By%7D%7D%20%5C%5C%0A%26%20%3D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BZ%7D%20%5Chat%7B%5Cmathbf%7BG%7D%7D%20%5Cmathbf%7BF%7D_%7Bii%7D%20%5Cmathbf%7BF%7D_%7Bii%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BG%7D%7D%5E%7B%5Cprime%7D%20%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%7B%5Cmathbf%7By%7D%7D%20%2F%20%5Csigma_%7Bi%7D%5E%7B4%7D%20%5C%5C%0A%26%20%3D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BZ%7D%20%5Chat%7B%5Cmathbf%7BG%7D%7D%20%5Cmathbf%7BF%7D_%7Bii%7D%20%20%5Chat%7B%5Cmathbf%7BG%7D%7D%20%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%7B%5Cmathbf%7By%7D%7D%20%2F%20%5Csigma_%7Bi%7D%5E%7B4%7D%20%5C%5C%0A%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>因为 <img src="https://math.now.sh?inline=%5Chat%7B%5Cmathbf%7BG%7D%7D%20%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%7B%5Cmathbf%7By%7D%7D%20%3D%20%5Chat%7B%5Cmathbf%7BG%7D%7D%20%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%7B%5Cmathbf%7By%7D%7D%20%3D%20%5Chat%7B%5Cmathbf%7BG%7D%7D%20%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29%20%3D%20%5Chat%7B%5Cmathbf%7Bu%7D%7D" style="display:inline-block;margin: 0;"/></p>
<p>因此右手项可以继续写为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%7B%5Cmathbf%7By%7D%7D%20%3D%20%20%5Cfrac%7B%5Chat%7B%5Cmathbf%7Bu%7D%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BF%7D_%7Bii%7D%20%5Chat%7B%5Cmathbf%7Bu%7D%7D%7D%20%7B%5Csigma_%7Bi%7D%5E%7B4%7D%7D%20%3D%20%5Cfrac%7B%5Chat%7B%5Cmathbf%7Bu%7D%7D%5E%7B%5Cprime%7D_%7Bi%7D%20%20%5Chat%7B%5Cmathbf%7Bu%7D%7D_%7Bi%7D%7D%20%7B%5Csigma_%7Bi%7D%5E%7B4%7D%7D%0A" /></p><p>因此我们将   <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cright%29%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%7B%5Cmathbf%7By%7D%7D" style="display:inline-block;margin: 0;"/>  改写为下式</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%20%5Cmathbf%7Bq%7D_%7Bi%7D%20-%20%5Coperatorname%7Btr%7D%20%5Cleft%28%5Cmathbf%7BW%7D_%7Bii%7D%5Cright%29%7D%20%7B%5Csigma_%7Bi%7D%5E%7B2%7D%7D%20%3D%20%5Cfrac%7B%5Chat%7B%5Cmathbf%7Bu%7D%7D%5E%7B%5Cprime%7D_%7Bi%7D%20%20%5Chat%7B%5Cmathbf%7Bu%7D%7D_%7Bi%7D%7D%20%7B%5Csigma_%7Bi%7D%5E%7B4%7D%7D%0A" /></p><p>因此我们得到了两个迭代公式</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D%3D%5Cfrac%7B%5Chat%7B%5Cmathbf%7Bu%7D%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7Bu%7D%7D_%7Bi%7D%2B%20%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D%20%5Coperatorname%7Btr%7D%20%5Cleft%28%5Cmathbf%7BW%7D_%7Bii%7D%5Cright%29%20%7D%20%7Bq_%7Bi%7D%7D%0A" /></p><p>或者</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D%3D%5Cfrac%7B%5Chat%7B%5Cmathbf%7Bu%7D%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%20%5Chat%7B%5Cmathbf%7Bu%7D%7D_%7Bi%7D%7D%7Bq_%7Bi%7D-%20%5Coperatorname%7Btr%7D%20%5Cleft%28%5Cmathbf%7BW%7D_%7Bii%7D%5Cright%29%20%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=q_%7Bi%7D" style="display:inline-block;margin: 0;"/> 是第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 个随机效应的水平数目；<img src="https://math.now.sh?inline=%5Chat%7B%5Cmathbf%7Bu%7D%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 是第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 个随机效应的预测值。</p>
<p>同时使用公式</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Csigma%7D_%7B0%7D%5E%7B2%7D%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D-%5Cmathbf%7BZ%7D%20%5Chat%7B%5Cmathbf%7Bu%7D%7D%29%20%2FN%0A" /></p><h3 id="额外证明">额外证明</h3>
<ol>
<li>
<p><img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D%20%3D%20%28%5Cmathbf%7BI%2BZ'R%5E%7B-1%7DZG%7D%29%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 矩阵存在，因为 <img src="https://math.now.sh?inline=%5Cmathbf%7BI%2BZ'R%5E%7B-1%7DZG%7D" style="display:inline-block;margin: 0;"/> 的行列式等于 <img src="https://math.now.sh?inline=%7C%5Cmathbf%7BR%7D%5E%7B-1%7D%7C%7C%5Cmathbf%7BV%7D%7C%20%5Cneq%200" style="display:inline-block;margin: 0;"/> 。</p>
<p>不会证明。</p>
</li>
<li>
<p><img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BW%7D_%7Bii%7D%20%5Cright%29%20%3E%200" style="display:inline-block;margin: 0;"/></p>
<p>证明：</p>
<p>因为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BG%7D%5E%7B1%2F2%7D%5Cmathbf%7BW%7D%5E%7B-1%7D%20%3D%20%5Cleft%28%5Cmathbf%7BI%7D%20%2B%20%5Cmathbf%7BG%7D%5E%7B1%2F2%7D%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7BG%7D%5E%7B1%2F2%7D%20%5Cright%29%20%5Cmathbf%7BG%7D%5E%7B1%2F2%7D%0A" /></p><p>其逆矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BW%7D%5Cmathbf%7BG%7D%5E%7B-1%2F2%7D%20%3D%5Cmathbf%7BG%7D%5E%7B-1%2F2%7D%20%5Cleft%28%5Cmathbf%7BI%7D%20%2B%20%5Cmathbf%7BG%7D%5E%7B1%2F2%7D%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7BG%7D%5E%7B1%2F2%7D%20%5Cright%29%5E%7B-1%7D%0A" /></p><p>左右均乘以 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D%5E%7B1%2F2%7D" style="display:inline-block;margin: 0;"/> 得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BG%7D%5E%7B1%2F2%7D%5Cmathbf%7BW%7D%20%3D%20%5Cleft%28%5Cmathbf%7BI%7D%20%2B%20%5Cmathbf%7BG%7D%5E%7B1%2F2%7D%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7BG%7D%5E%7B1%2F2%7D%20%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BG%7D%5E%7B1%2F2%7D%20%3D%20%5Cleft(%5Cmathbf%7BI%7D%20%2B%20%5Cmathbf%7BT%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BT%7D%20%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BG%7D%5E%7B1%2F2%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D%20%3D%20%5Cmathbf%7BR%7D%5E%7B-1%2F2%7D%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7BG%7D%5E%7B1%2F2%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BI%7D%20%2B%20%5Cmathbf%7BT%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BT%7D" style="display:inline-block;margin: 0;"/> 是一个正定矩阵，因为其二次型 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D%5E%7B%5Cprime%7D%20%5Cleft%28%20%20%5Cmathbf%7BI%7D%20%2B%20%5Cmathbf%7BT%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BT%7D%20%5Cright%29%20%5Cmathbf%7Bx%7D%20%3D%20%5Cmathbf%7Bx%7D%5E%7B%5Cprime%7D%5Cmathbf%7Bx%7D%20%2B%20(%5Cmathbf%7BT%7D%20%5Cmathbf%7Bx%7D)%5E%7B%5Cprime%7D%20(%5Cmathbf%7BT%7D%20%5Cmathbf%7Bx%7D)%20%3E%200" style="display:inline-block;margin: 0;"/> ，因此其逆矩阵   <img src="https://math.now.sh?inline=%28%5Cmathbf%7BI%7D%20%2B%20%5Cmathbf%7BT%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BT%7D%29%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 也是正定矩阵，其对角线元素均大于 0。<strong>因为 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D%5E%7B1%2F2%7D" style="display:inline-block;margin: 0;"/> 是一个对角矩阵</strong>，根据上面的公式 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D%5E%7B1%2F2%7D%5Cmathbf%7BW%7D%20%3D%20%5Cleft%28%5Cmathbf%7BI%7D%20%2B%20%5Cmathbf%7BT%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BT%7D%20%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BG%7D%5E%7B1%2F2%7D" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D" style="display:inline-block;margin: 0;"/> 矩阵的对角线元素也均大于 0， 因此  <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D" style="display:inline-block;margin: 0;"/> 矩阵正定，因此 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BW%7D_%7Bii%7D%20%5Cright%29%20%3E%200" style="display:inline-block;margin: 0;"/>  。</p>
</li>
<li>
<p><img src="https://math.now.sh?inline=q_%7Bi%7D-%20%5Coperatorname%7Btr%7D%20%5Cleft%28%5Cmathbf%7BW%7D_%7Bii%7D%5Cright%29%20%5Cgeq%200" style="display:inline-block;margin: 0;"/></p>
<p>证明：根据上面的公式，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%20%5Cmathbf%7Bq%7D_%7Bi%7D%20-%20%5Coperatorname%7Btr%7D%20%5Cleft%28%5Cmathbf%7BW%7D_%7Bii%7D%5Cright%29%7D%20%7B%5Csigma_%7Bi%7D%5E%7B2%7D%7D%20%3D%20%5Coperatorname%7Btr%7D%5Cleft(%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cright)%20%3D%20%5Coperatorname%7Btr%7D%5Cleft(%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cright)%20%3D%20%5Coperatorname%7Btr%7D%5Cleft(%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cright)%20%3D%20%5Coperatorname%7Bvar%7D(%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D)%20%5Cgeq%200%0A" /></p><p>因此我们可以看出每一轮迭代产生的 <img src="https://math.now.sh?inline=%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 均为正数，即均在参数空间中。（不知道如何证明 <img src="https://math.now.sh?inline=%5Chat%7B%5Csigma%7D_%7B0%7D%5E%7B2%7D%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D-%5Cmathbf%7BZ%7D%20%5Chat%7B%5Cmathbf%7Bu%7D%7D%29%20%2FN" style="display:inline-block;margin: 0;"/> 大于 0  ）</p>
</li>
</ol>
<h1>REML</h1>
<p><strong>限制性最大似然</strong> (<em>restricted (residual) maximum likelihood</em>, REML) ，由  Patterson 和 Thompson 在 1971 年提出。我们强调 REML 方法的原因是在标准的线性模型中，样本方差 <img src="https://math.now.sh?inline=s%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 也是 REML 的估计值。同时，REML 是一种一般的方法，比如 REML 在不平衡数据中也可以使用。在某些平衡数据中，REML 可能有解析解 (闭式解)。REML 同时是<strong>最佳二次无偏估计值</strong>。</p>
<p>REML 的思想是对数据 <img src="https://math.now.sh?inline=%5Cmathbf%7BK'y%7D" style="display:inline-block;margin: 0;"/> 进行最大似然估计，而不是 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 是我们人为挑选的，以使得  <img src="https://math.now.sh?inline=%5Cmathbf%7BK'y%7D" style="display:inline-block;margin: 0;"/> 的分布只包含方差组分，而不包含 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 。为了实现这一点，矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 需要满足 <img src="https://math.now.sh?inline=%5Cmathbf%7BK'%20X%7D%3D%5Cmathbf%7BO%7D" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=E%28%5Cmathbf%7BK'%20y%7D%29%3D%5Cmathbf%7BK'%20X%7D%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> 。为了方便，我们同时要求  <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 是一个<strong>满秩</strong>矩阵。我们同时要求  <img src="https://math.now.sh?inline=%5Cmathbf%7BK'y%7D" style="display:inline-block;margin: 0;"/>  尽可能包含最多的关于方程组分的信息，因此  <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 必须有最大的行数。</p>
<p><strong>定理</strong>：  <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 是一个满秩矩阵，满足 <img src="https://math.now.sh?inline=%5Cmathbf%7BK'%20X%7D%3D%5Cmathbf%7BO%7D" style="display:inline-block;margin: 0;"/> ，但是同时拥有最大的行数，因此它是一个 <img src="https://math.now.sh?inline=%28n-r%29%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵 (<img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的秩)。进一步地说，<img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 矩阵的形式必须为 <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%3D%5Cmathbf%7BC%7D%28%5Cmathbf%7BI%7D-%5Cmathbf%7BH%7D%29%3D%5Cmathbf%7BC%7D%5Cleft%5B%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D" style="display:inline-block;margin: 0;"/> ，这里  <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=%28n-r%29%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/>  的满秩矩阵。</p>
<p><strong>证明</strong>：<img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 的行 <img src="https://math.now.sh?inline=%5Cmathbf%7Bk%7D_%7Bi%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 满足等式 <img src="https://math.now.sh?inline=%5Cmathbf%7Bk%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cmathbf%7B0%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，转置得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bk%7D_%7Bi%7D%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> （注意这里出现了符号重叠问题，这里的 <img src="https://math.now.sh?inline=%5Cmathbf%7Bk%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 是第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行元素组成的列向量）。根据定理， <strong>如果线性方程组 <img src="https://math.now.sh?inline=Ax%20%3D%20c" style="display:inline-block;margin: 0;"/> 是相容的</strong>，那么所有可能的解为  <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D%3D%5Cmathbf%7BA%7D%5E%7B-%7D%20%5Cmathbf%7Bc%7D%2B%5Cleft%28%5Cmathbf%7BI%7D-%5Cmathbf%7BA%7D%5E%7B-%7D%20%5Cmathbf%7BA%7D%5Cright%29%20%5Cmathbf%7Bh%7D" style="display:inline-block;margin: 0;"/>  ，这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 是某个特定的广义逆， <img src="https://math.now.sh?inline=h" style="display:inline-block;margin: 0;"/> 为所有可能的值组成的向量。因此，这里的方程组的解为 <img src="https://math.now.sh?inline=%5Cmathbf%7Bk%7D_%7Bi%7D%3D%5Cleft%28%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5E%7B-'%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%29%20%5Cmathbf%7Bc%7D" style="display:inline-block;margin: 0;"/> （书中有笔误，书里是 <img src="https://math.now.sh?inline=%5Cmathbf%7Bk%7D_%7Bi%7D%3D%5Cleft%28%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5E%7B-%7D%20%5Cmathbf%7BX%7D%5Cright%29%20%5Cmathbf%7Bc%7D" style="display:inline-block;margin: 0;"/> ，这里又有符号重叠问题，这里的 <img src="https://math.now.sh?inline=%5Cmathbf%7Bc%7D" style="display:inline-block;margin: 0;"/> 就是上面定理中的 <img src="https://math.now.sh?inline=%5Cmathbf%7Bh%7D" style="display:inline-block;margin: 0;"/> ，为所有可能的 <img src="https://math.now.sh?inline=n%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 的向量） ，因此  <img src="https://math.now.sh?inline=%5Cmathbf%7Bk%7D_%7Bi%7D%5E%7B%5Cprime%7D%3D%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cleft%28%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cmathbf%7BX%7D%5E%7B-%7D%5Cright%29" style="display:inline-block;margin: 0;"/> ，也就是说 <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 的行 <img src="https://math.now.sh?inline=%5Cmathbf%7Bk%7D_%7Bi%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cmathbf%7BX%7D%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 的行的所有可能的线性组合。</p>
<p>我们知道  <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%5Cleft%28%5Cmathbf%7BX%7D%5Cmathbf%7BX%7D%5E%7B-%7D%5Cright%29%3D%5Coperatorname%7Brank%7D(%5Cmathbf%7BX%7D)%3Dr" style="display:inline-block;margin: 0;"/> ，并且 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cmathbf%7BX%7D%5E%7B-%7D%5Cright%29%5E%7B2%7D%20%3D%20%5Cmathbf%7BI%7D-2%5Cmathbf%7BX%7D%20%5Cmathbf%7BX%7D%5E%7B-%7D%2B%5Cmathbf%7BX%7D%20%5Cmathbf%7BX%7D%5E%7B-%7D%3D%20%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%20%5Cmathbf%7BX%7D%5E%7B-%7D" style="display:inline-block;margin: 0;"/>  ，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cmathbf%7BX%7D%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 是一个<strong>幂等</strong>矩阵，因此 <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%5Cleft%28%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cmathbf%7BX%7D%5E%7B-%7D%5Cright%29%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cmathbf%7BX%7D%5E%7B-%7D%5Cright)%3D%5Coperatorname%7Btr%7D(%5Cmathbf%7BI%7D)-%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BX%7D%5Cmathbf%7BX%7D%5E%7B-%7D%5Cright)%3Dn-r" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cmathbf%7BX%7D%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 的行的张成空间的维度为 <img src="https://math.now.sh?inline=n-r" style="display:inline-block;margin: 0;"/> ，因此最多有  <img src="https://math.now.sh?inline=n-r" style="display:inline-block;margin: 0;"/>  个线性无关的向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Bk%7D_%7Bi%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，也就是说 <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 矩阵的行数最大为 <img src="https://math.now.sh?inline=n-r" style="display:inline-block;margin: 0;"/> 。</p>
<p>因为   <img src="https://math.now.sh?inline=%5Cmathbf%7Bk%7D_%7Bi%7D%5E%7B%5Cprime%7D%3D%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cleft%28%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cmathbf%7BX%7D%5E%7B-%7D%5Cright%29" style="display:inline-block;margin: 0;"/>  ，那么一定存在一个  <img src="https://math.now.sh?inline=%28n-r%29%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/>  的满秩矩阵   <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/>  ，使得  <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 矩阵可以表示为 <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%3D%5Cmathbf%7BC%7D%5Cleft%28%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cmathbf%7BX%7D%5E%7B-%7D%5Cright%29" style="display:inline-block;margin: 0;"/> ，其中  <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 矩阵的每一行均是  <img src="https://math.now.sh?inline=%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cmathbf%7BX%7D%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 的行的线性组合，并且由于 <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 矩阵满秩， 因此选择 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 矩阵的标准是必须使得  <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 矩阵的行之间线性无关。根据广义逆的性质，我们知道 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的一个广义逆，因此我们可以这里的 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 可以选择为  <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，因此此时  <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 矩阵可以表示为 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D%28%5Cmathbf%7BI%7D-%5Cmathbf%7BH%7D%29%3D%5Cmathbf%7BC%7D%5Cleft%5B%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D" style="display:inline-block;margin: 0;"/> 。</p>
<p>满足要求的  <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 矩阵有无数个，但是这不影响我们使用。同时我们注意到校正固定效应的残差为 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cvarepsilon%7D%7D%20%3D%20%28%5Cmathbf%7BI%7D-%5Cmathbf%7BH%7D%29%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，因此</p>
<p><img src="https://math.now.sh?inline=%5Cmathbf%7BK'%20y%7D%3D%5Cmathbf%7BC%7D%28%5Cmathbf%7BI%7D-%5Cmathbf%7BH%7D%29%20%5Cmathbf%7By%7D%20%3D%20%5Cmathbf%7BC%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cvarepsilon%7D%7D" style="display:inline-block;margin: 0;"/> 的每个元素都是所有残差的线性组合，这也是 <code>residual maximum likelihood</code> 这个名称的由来。</p>
<p>而 <img src="https://math.now.sh?inline=%5Cmathbf%7BK'%20y%7D" style="display:inline-block;margin: 0;"/> 的分布见下面的定理。</p>
<p><strong>定理</strong>：在混合线性模型中，假设 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%20%5Csim%20N_%7Bn%7D%28%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2C%20%5Cmathbf%7BV%7D%29" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D%3D%5Csum_%7Bi%3D0%7D%5E%7Bm%7D%20%5Csigma_%7Bi%7D%5E%7B2%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，那么</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BK'%20y%7D%20%5Csim%20%20N_%7Bn-r%7D%5Cleft%28%5Cmathbf%7B0%7D%2C%20%5Cmathbf%7BK'%20%5Cmathbf%7BV%7D%7D%20%5Cmathbf%7BK%7D%5Cright%29%0A" /></p><p>证明很简单，因为  <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 满足正态，所以 <img src="https://math.now.sh?inline=%5Cmathbf%7BK'%20y%7D" style="display:inline-block;margin: 0;"/> 也满足正态，同时根据  <img src="https://math.now.sh?inline=%5Cmathbf%7BK'%20X%7D%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> 易得 <img src="https://math.now.sh?inline=%5Cmathbf%7BK'%20y%7D" style="display:inline-block;margin: 0;"/> 的均值为 <img src="https://math.now.sh?inline=%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> , 其方差为 <img src="https://math.now.sh?inline=%5Cmathbf%7BK%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%7D%20%5Cmathbf%7BK%7D" style="display:inline-block;margin: 0;"/> ，得证。</p>
<p>因此  <img src="https://math.now.sh?inline=%5Cmathbf%7BK%5E%7B%5Cprime%7D%20y%7D" style="display:inline-block;margin: 0;"/> 的分布只与 <img src="https://math.now.sh?inline=m%2B1" style="display:inline-block;margin: 0;"/> 个方差组分有关。为了估计方差组分，REML 的下一步是针对这些方差组分最大化  <img src="https://math.now.sh?inline=%5Cmathbf%7BK%5E%7B%5Cprime%7D%20y%7D" style="display:inline-block;margin: 0;"/> 的似然值。</p>
<p>对似然函数求偏导，使之为零，我们得到下面的定理。</p>
<p><strong>定理</strong>：在上面的模型中， <img src="https://math.now.sh?inline=m%2B1" style="display:inline-block;margin: 0;"/> 个方差组分 <img src="https://math.now.sh?inline=%5Csigma_%7B0%7D%5E%7B2%7D%2C%20%5Cldots%2C%20%5Csigma_%7Bm%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 的估计值满足下面的方程组，其中 <img src="https://math.now.sh?inline=i%3D0%2C%20%5Cldots%2C%20m" style="display:inline-block;margin: 0;"/></p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%5B%5Cmathbf%7BK%7D%5Cleft%28%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BK%5E%7B%5Cprime%7D%20Z%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cright%5D%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BK%7D%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BK%5E%7B%5Cprime%7D%20Z%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BK%7D%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A" /></p><p><strong>证明</strong>：因为 <img src="https://math.now.sh?inline=E%28%5Cmathbf%7BK%5E%7B%5Cprime%7D%20y%7D%29%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathbf%7BK%5E%7B%5Cprime%7D%20y%7D" style="display:inline-block;margin: 0;"/> 的对数似然值为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cln%20L%5Cleft%28%5Csigma_%7B0%7D%5E%7B2%7D%2C%20%5Cldots%2C%20%5Csigma_%7Bm%7D%5E%7B2%7D%5Cright%29%3D%26%20%5Cfrac%7Bn-r%7D%7B2%7D%20%5Cln%20(2%20%5Cpi)-%5Cfrac%7B1%7D%7B2%7D%20%5Cln%20%5Cleft%7C%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright%7C-%5Cfrac%7B1%7D%7B2%7D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BK%7D%20%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%20%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BK%5E%7B%5Cprime%7D%20y%7D%20%5C%5C%0A%3D%26%20%5Cfrac%7Bn-r%7D%7B2%7D%20%5Cln%20(2%20%5Cpi)-%5Cfrac%7B1%7D%7B2%7D%20%5Cln%20%5Cleft%7C%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%5Cleft(%5Csum_%7Bi%3D0%7D%5E%7Bm%7D%20%5Csigma_%7Bi%7D%5E%7B2%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cright)%20%5Cmathbf%7BK%7D%20%5Cright%7C%20%5C%5C%0A%26-%5Cfrac%7B1%7D%7B2%7D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BK%7D%20%5Cleft%5B%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%5Cleft(%5Csum_%7Bi%3D0%7D%5E%7Bm%7D%20%5Csigma_%7Bi%7D%5E%7B2%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cright)%20%5Cmathbf%7BK%7D%5Cright%5D%5E%7B-1%7D%20%5Cmathbf%7BK%5E%7B%5Cprime%7D%20y%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>根据矩阵求导的性质，假设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的<strong>非奇异矩阵</strong>，其元素 <img src="https://math.now.sh?inline=a_%7Bij%7D" style="display:inline-block;margin: 0;"/> 是关于标量 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 的函数。我们定义  <img src="https://math.now.sh?inline=%5Cpartial%20%5Cmathbf%7BA%7D%20%2F%20%5Cpartial%20x" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵，其元素为 <img src="https://math.now.sh?inline=%5Cpartial%20a_%7Bi%20j%7D%20%2F%20%5Cpartial%20x" style="display:inline-block;margin: 0;"/> 。那么存在</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BA%7D%5E%7B-1%7D%7D%7B%5Cpartial%20x%7D%3D-%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BA%7D%7D%7B%5Cpartial%20x%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%0A" /></p><p>和</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%5Cpartial%20%5Clog%20%7C%5Cmathbf%7BA%7D%7C%7D%7B%5Cpartial%20x%7D%3D%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BA%7D%7D%7B%5Cpartial%20x%7D%5Cright%29%0A" /></p><p>利用这两条性质，我们求 <img src="https://math.now.sh?inline=%5Cln%20L%5Cleft%28%5Csigma_%7B0%7D%5E%7B2%7D%2C%20%5Cldots%2C%20%5Csigma_%7Bm%7D%5E%7B2%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 对每一个 <img src="https://math.now.sh?inline=%5Csigma_%7Bi%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 的偏导数，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Csigma_%7Bi%7D%5E%7B2%7D%7D%20%5Cln%20L%5Cleft%28%5Csigma_%7B0%7D%5E%7B2%7D%2C%20%5Cldots%2C%20%5Csigma_%7Bm%7D%5E%7B2%7D%5Cright%29%3D%26-%5Cfrac%7B1%7D%7B2%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cleft(%5Cmathbf%7BK%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%7D%20%5Cmathbf%7BK%7D%5Cright)%5E%7B-1%7D%5Cleft%5B%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Csigma_%7Bi%7D%5E%7B2%7D%7D%5Cleft(%5Cmathbf%7BK%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%7D%20%5Cmathbf%7BK%7D%5Cright)%5Cright%5D%5Cright)%20%5C%5C%0A%26%2B%5Cfrac%7B1%7D%7B2%7D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BK%7D%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright)%5E%7B-1%7D%5Cleft%5B%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Csigma_%7Bi%7D%5E%7B2%7D%7D%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright)%5Cright%5D%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BK%5E%7B%5Cprime%7D%20y%7D%20%5C%5C%0A%3D%26-%5Cfrac%7B1%7D%7B2%7D%20%5Coperatorname%7Btr%7D%5Cleft%5B%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BK%5E%7B%5Cprime%7D%20Z%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BK%7D%5Cright%5D%20%5C%5C%0A%26%2B%5Cfrac%7B1%7D%7B2%7D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BK%7D%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BK%5E%7B%5Cprime%7D%20Z%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BK%7D%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%3D%26-%5Cfrac%7B1%7D%7B2%7D%20%5Coperatorname%7Btr%7D%5Cleft%5B%5Cmathbf%7BK%7D%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BK%5E%7B%5Cprime%7D%20Z%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cright%5D%20%5C%5C%0A%26%2B%5Cfrac%7B1%7D%7B2%7D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BK%7D%20%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BK%5E%7B%5Cprime%7D%20Z%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BK%7D%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>将这个式子设为0，得到上面的结果。</p>
<p>证毕。</p>
<p>有一点很有意思，根据二次型的期望公式 <img src="https://math.now.sh?inline=E%5Cleft%28%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BA%20y%7D%5Cright%29%3D%5Coperatorname%7Btr%7D(%5Cmathbf%7BA%7D%20%5Cmathbf%7BV%7D)%2B%5Cboldsymbol%7B%5Cmu%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BA%7D%20%5Cboldsymbol%7B%5Cmu%7D" style="display:inline-block;margin: 0;"/> ，上面式子的右手项的期望 (这里设期望公式里的 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 是  <img src="https://math.now.sh?inline=%5Cmathbf%7BK%5E%7B%5Cprime%7Dy%7D" style="display:inline-block;margin: 0;"/>  ，<img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%3D%20%5Cleft%28%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%20%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BK%5E%7B%5Cprime%7D%20Z%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BK%7D%20%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright)%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> )  正好是左手项。</p>
<p>SEARLE (1979) 证明</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BK%7D%20%5Cleft%28%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%20K%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%3D%5Cmathbf%7BP%7D%0A" /></p><p>证明如下：</p>
<p><img src="https://math.now.sh?inline=%5Cmathbf%7BK%20K%7D%5E%7B%2B%7D%3D%5Cmathbf%7BK%7D%5Cleft%28%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BK%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/>  和 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%20X%7D%5E%7B%2B%7D%3D%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B%2B%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 是对称幂等矩阵，对称证明略，幂等证明如下，<img src="https://math.now.sh?inline=%28%5Cmathbf%7BK%20K%7D%5E%7B%2B%7D%29%5E%7B2%7D%20%3D%20%5Cmathbf%7BK%20K%7D%5E%7B%2B%7D%20%5Cmathbf%7BK%20K%7D%5E%7B%2B%7D%20%20%3D%20%5Cmathbf%7BK%20K%7D%5E%7B%2B%7D" style="display:inline-block;margin: 0;"/> 。我们已知 <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BK%20K%7D%5E%7B%2B%7D%20%5Cmathbf%7BX%7D%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> 并且 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%20X%7D%5E%7B%2B%7D%20%5Cmathbf%7BK%7D%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> 。因此</p>
<p><img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D%3D%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%20%5Cmathbf%7BX%7D%5E%7B%2B%7D-%5Cmathbf%7BK%7D%20%5Cmathbf%7BK%7D%5E%7B%2B%7D" style="display:inline-block;margin: 0;"/> 是一个对称幂等矩阵，幂等证明如下（其实直接根据对称幂等矩阵的性质即可证明，如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 对称幂等，那么 <img src="https://math.now.sh?inline=%5Cmathbf%7BI-A%7D" style="display:inline-block;margin: 0;"/> 对称幂等 ）：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cleft%28%20%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%20%5Cmathbf%7BX%7D%5E%7B%2B%7D-%5Cmathbf%7BK%7D%20%5Cmathbf%7BK%7D%5E%7B%2B%7D%20%5Cright%29%5Cleft(%20%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%20%5Cmathbf%7BX%7D%5E%7B%2B%7D-%5Cmathbf%7BK%7D%20%5Cmathbf%7BK%7D%5E%7B%2B%7D%20%5Cright)%20%5C%5C%0A%26%3D%20%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%20%5Cmathbf%7BX%7D%5E%7B%2B%7D-%5Cmathbf%7BK%7D%20%5Cmathbf%7BK%7D%5E%7B%2B%7D%20-%5Cmathbf%7BX%7D%20%5Cmathbf%7BX%7D%5E%7B%2B%7D%20%2B%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BX%7D%5E%7B%2B%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BX%7D%5E%7B%2B%7D%20%2B%5Cmathbf%7BK%7D%20%5Cmathbf%7BK%7D%5E%7B%2B%7D%20%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BX%7D%5E%7B%2B%7D%20-%20%5Cmathbf%7BK%7D%20%5Cmathbf%7BK%7D%5E%7B%2B%7D%20%2B%20%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BX%7D%5E%7B%2B%7D%20%5Cmathbf%7BK%7D%20%5Cmathbf%7BK%7D%5E%7B%2B%7D%20%20%2B%20%5Cmathbf%7BK%7D%20%5Cmathbf%7BK%7D%5E%7B%2B%7D%20%5Cmathbf%7BK%7D%20%5Cmathbf%7BK%7D%5E%7B%2B%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%20%5Cmathbf%7BX%7D%5E%7B%2B%7D-%5Cmathbf%7BK%7D%20%5Cmathbf%7BK%7D%5E%7B%2B%7D%20-%5Cmathbf%7BX%7D%20%5Cmathbf%7BX%7D%5E%7B%2B%7D%20%2B%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BX%7D%5E%7B%2B%7D%20%20-%20%5Cmathbf%7BK%7D%20%5Cmathbf%7BK%7D%5E%7B%2B%7D%20%20%20%2B%20%5Cmathbf%7BK%7D%20%5Cmathbf%7BK%7D%5E%7B%2B%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%20%5Cmathbf%7BX%7D%5E%7B%2B%7D-%5Cmathbf%7BK%7D%20%5Cmathbf%7BK%7D%5E%7B%2B%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BT%20T%7D%5E%7B%5Cprime%7D%5Cright%29%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BT%7D%5E%7B2%7D%5Cright)%3D%5Coperatorname%7Btr%7D(%5Cmathbf%7BT%7D)%20%26%3D%5Coperatorname%7Btr%7D(%5Cmathbf%7BI%7D)-%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BX%20X%7D%5E%7B%2B%7D%5Cright)-%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BK%20K%7D%5E%7B%2B%7D%5Cright)%20%5C%5C%0A%26%3DN-r_%7B%5Cmathbf%7BX%7D%7D-r_%7B%5Cmathbf%7BK%7D%7D%20%5C%5C%0A%26%3DN-r_%7B%5Cmathbf%7BX%7D%7D-%5Cleft(N-r_%7B%5Cmathbf%7BX%7D%7D%5Cright)%20%5C%5C%0A%26%3D0%0A%5Cend%7Baligned%7D%0A" /></p><p>根据幂等矩阵的性质，我们知道幂等矩阵的秩等于迹，因此  <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28%5Cmathbf%7BT%7D%29%20%3D%200" style="display:inline-block;margin: 0;"/> ，说明 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> （只有零矩阵的秩为 0）。因此，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BI%7D-%5Cmathbf%7BX%20X%7D%5E%7B%2B%7D%3D%5Cmathbf%7BK%20K%7D%5E%7B%2B%7D%0A" /></p><p><strong>因为 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D" style="display:inline-block;margin: 0;"/> 是一个正定矩阵</strong>，因此总是存在 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D%5E%7B1%2F2%7D" style="display:inline-block;margin: 0;"/> 矩阵使得 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D%20%3D%20%28%5Cmathbf%7BV%7D%5E%7B1%2F2%7D%29%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 。那么由于  <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/>  ，那么我们知道 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BV%7D%5E%7B1%2F2%7D%20%5Cmathbf%7BK%7D%5Cright%29%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%2F2%7D%20%5Cmathbf%7BX%7D%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> ，之前适应 <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的结果均适用于 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D%5E%7B1%2F2%7D%20%5Cmathbf%7BK%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D%5E%7B-1%2F2%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 。我们替换 <img src="https://math.now.sh?inline=%5Cmathbf%7BI%7D-%5Cmathbf%7BX%20X%7D%5E%7B%2B%7D%3D%5Cmathbf%7BK%20K%7D%5E%7B%2B%7D" style="display:inline-block;margin: 0;"/> 中的MP逆矩阵，我们得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B%2B%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%3D%5Cmathbf%7BK%7D%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BK%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 。将  <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D%5E%7B1%2F2%7D%20%5Cmathbf%7BK%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D%5E%7B-1%2F2%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/>  带入得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BI%7D-%5Cmathbf%7BV%7D%5E%7B-1%2F2%7D%20%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B%2B%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%2F2%7D%3D%5Cmathbf%7BV%7D%5E%7B1%2F2%7D%20%5Cmathbf%7BK%7D%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B1%2F2%7D%0A" /></p><p>因此 （<strong>注意下面的 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 是 MP 逆</strong> ）</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BP%7D%3D%5Cmathbf%7BV%7D%5E%7B-1%7D-%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%3D%5Cmathbf%7BK%7D%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%0A" /></p><p>得证。</p>
<p>其中 <img src="https://math.now.sh?inline=%5Chat%7B%5Cmathbf%7BP%7D%7D%3D%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D-%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/>  ，将该式带入，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%28%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%5Cright%29%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%7B%5Cmathbf%7By%7D%7D%0A" /></p><p>注意最大似然法的估计公式为 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%5Cright%29%20%0A%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%7B%5Cmathbf%7By%7D%7D" style="display:inline-block;margin: 0;"/> ，因此 <strong>REML 方法相比与 ML 方法就是将左手项的 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Chat%7BV%7D%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 替换为 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Chat%7BP%7D%7D" style="display:inline-block;margin: 0;"/> 。</strong></p>
<p>我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BPVP%7D%20%26%3D%20%5Cleft%28%5Cmathbf%7BV%7D%5E%7B-1%7D-%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cright)%20%5Cmathbf%7BV%7D%20%5Cleft(%5Cmathbf%7BV%7D%5E%7B-1%7D-%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cright)%20%5C%5C%0A%0A%26%3D%20%5Cleft(%5Cmathbf%7BI%7D-%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%20%5Cright)%20%5Cleft(%5Cmathbf%7BV%7D%5E%7B-1%7D-%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cright)%20%5C%5C%0A%0A%26%3D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20-%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20-%20%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%2B%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5C%5C%0A%0A%26%3D%20%5Cmathbf%7BP%7D%20%5Cquad%20%5Cbecause%20%20%5Ctext%7B%E8%AE%BE%7D%20%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Ctext%7B%E6%98%AF%E8%87%AA%E5%8F%8D%E5%B9%BF%E4%B9%89%E9%80%86%E7%9F%A9%E9%98%B5%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Btr%7D%5Cleft%28%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%5Cright%29%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%20%5Cmathbf%7BV%7D_%7Bi%7D%5Cright)%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%20%5Cmathbf%7BP%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5Cright)%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Csum_%7Bj%3D0%7D%5E%7Bm%7D%20%5Cmathbf%7BV%7D_%7Bj%7D%5Cright)%20%5Chat%7B%5Csigma%7D_%7Bj%7D%5E%7B2%7D%20%5C%5C%0A%26%3D%5Csum_%7Bj%3D0%7D%5E%7Bm%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BV%7D_%7Bj%7D%5Cright)%20%5Chat%7B%5Csigma%7D_%7Bj%7D%5E%7B2%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因而，对于 <img src="https://math.now.sh?inline=i%2Cj%20%3D%200%2C1%2C%5Ccdots%2C%20m" style="display:inline-block;margin: 0;"/> ，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bj%3D0%7D%5E%7Bm%7D%5Cleft%5C%7B%5Coperatorname%7Btr%7D%5Cleft%28%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%7B%5Cmathbf%7BV%7D_%7Bj%7D%7D%5Cright%29%5Cright%5C%7D%5Cleft%5C%7B%5Chat%7B%5Csigma%7D_%7Bj%7D%5E%7B2%7D%5Cright%5C%7D%3D%5Cleft%5C%7B%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7By%7D%5Cright%5C%7D%0A" /></p><p>这就是 REML 的估计方程，它也必须通过迭代求解。</p>
<p>根据这个定理，我们可以得到 <img src="https://math.now.sh?inline=m%2B1" style="display:inline-block;margin: 0;"/> 个方程，而我们总共有 <img src="https://math.now.sh?inline=m%2B1" style="display:inline-block;margin: 0;"/> 个未知数。在某些情况下，这些方程组可以进一步简化从而得到闭式解。但是在大多数情况下，这些方程组是无法直接求解的。</p>
<p>我们一般会用一些迭代的方法来进行估计 (Rao 1997 pp. 104 – 105, McCulloch and Searle 2001, pp. 265 – 269)。我们注意到上面定理中的 <img src="https://math.now.sh?inline=m%20%2B1" style="display:inline-block;margin: 0;"/> 个方程组成的方程组可以写为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BM%7D%20%5Cboldsymbol%7B%5Csigma%7D%3D%5Cmathbf%7Bq%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Csigma%7D%3D%5Cleft%28%5Csigma_%7B0%7D%5E%7B2%7D%2C%20%5Csigma_%7B1%7D%5E%7B2%7D%2C%20%5Ccdots%2C%20%5Csigma_%7Bm%7D%5E%7B2%7D%5Cright%29%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D" style="display:inline-block;margin: 0;"/> 是一个<strong>非奇异</strong>的  <img src="https://math.now.sh?inline=%28m%2B1%29%20%5Ctimes(m%2B1)" style="display:inline-block;margin: 0;"/> 的矩阵，其中的元素 <img src="https://math.now.sh?inline=M_%7Bij%7D%3D%5Coperatorname%7Btr%7D%5Cleft%28%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%7B%5Cmathbf%7BV%7D_%7Bj%7D%7D%5Cright%29" style="display:inline-block;margin: 0;"/> ，然后 <img src="https://math.now.sh?inline=%5Cmathbf%7Bq%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=%28m%2B1%29%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 的向量，其中的元素  <img src="https://math.now.sh?inline=q_%7Bi%7D%20%3D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>我们注意到 <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D%20%5Cboldsymbol%7B%5Csigma%7D%3D%5Cmathbf%7Bq%7D" style="display:inline-block;margin: 0;"/> 这个式子貌似更加复杂，因为 <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D" style="display:inline-block;margin: 0;"/>  和 <img src="https://math.now.sh?inline=%5Cmathbf%7Bq%7D" style="display:inline-block;margin: 0;"/> 中都含有未知数 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Csigma%7D" style="display:inline-block;margin: 0;"/> 。然而，这个方程组对于我们从一个初始值 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Csigma%7D_%7B%281%29%7D" style="display:inline-block;margin: 0;"/> 逐步迭代来估计的方式而言很有用。我们在第 <img src="https://math.now.sh?inline=t" style="display:inline-block;margin: 0;"/> 步可以用 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Csigma%7D_%7B%28t%29%7D" style="display:inline-block;margin: 0;"/> 来计算  <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D_%7B%28t%29%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Bq%7D_%7B%28t%29%7D" style="display:inline-block;margin: 0;"/> ，那么 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Csigma%7D_%7B%28t%2B1%29%7D%3D%5Cmathbf%7BM%7D_%7B(t)%7D%5E%7B-1%7D%20%5Cmathbf%7Bq%7D_%7B(t)%7D" style="display:inline-block;margin: 0;"/> ，然后一直迭代直到收敛。</p>
<h2 id="估计值的方差-2">估计值的方差</h2>
<p>首先我们证明</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BP%7D%7D%7B%5Cpartial%20%5Csigma_i%5E2%7D%20%26%20%3D%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Csigma_i%5E2%7D%20%5Cmathbf%7BK%7D%5Cleft%28%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5C%5C%0A%26%20%3D%5Cmathbf%7BK%7D%20%5Cleft(%20%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Csigma_i%5E2%7D%20%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright)%5E%7B-1%7D%20%5Cright)%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cquad%20%5Cbecause%20%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BA%7D%20%5Cmathbf%7BQ%7D%20%7D%7B%5Cpartial%20x%7D%20%20%3D%20%5Cmathbf%7BP%7D%20%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BA%7D%7D%7B%5Cpartial%20x%7D%20%5Cmathbf%7BQ%7D%20%5C%5C%0A%26%20%3D-%5Cmathbf%7BK%7D%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%20%5Cright)%5E%7B-1%7D%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%7D%7B%5Cpartial%20%5Csigma_i%5E2%7D%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cquad%20%5Cbecause%20%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BA%7D%5E%7B-1%7D%7D%7B%5Cpartial%20x%7D%3D-%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BA%7D%7D%7B%5Cpartial%20x%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%5C%5C%0A%26%20%3D-%5Cmathbf%7BK%7D%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BV%7D%7D%7B%5Cpartial%20%5Csigma_i%5E2%7D%20%5Cmathbf%7BK%7D%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%20K%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5C%5C%0A%26%20%3D-%5Cmathbf%7BP%7D%20%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BV%7D%7D%7B%5Cpartial%20%5Csigma_i%5E2%7D%20%5Cmathbf%7BP%7D%5C%5C%0A%26%3D-%5Cmathbf%7BP%7D%20%5Cmathbf%7BZ%7D_i%20%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>我们已知</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cfrac%7B%5Cpartial%20l_%7B%5Cmathbf%7BR%7D%7D%7D%7B%5Cpartial%20%5Csigma_i%5E2%7D%20%0A%26%3D-%5Cfrac%7B1%7D%7B2%7D%20%5Coperatorname%7Btr%7D%5Cleft%5B%5Cmathbf%7BK%7D%5Cleft%28%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BK%5E%7B%5Cprime%7D%20Z%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cright%5D%20%5C%5C%0A%26%2B%5Cfrac%7B1%7D%7B2%7D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BK%7D%20%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BK%5E%7B%5Cprime%7D%20Z%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BK%7D%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5C%5C%0A%0A%26%20%3D-%5Cfrac%7B1%7D%7B2%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BP%7D%5Cmathbf%7BZ%7D_i%20%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%5Cright)%2B%5Cfrac%7B1%7D%7B2%7D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BZ%7D_i%20%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%20y%7D%20%0A%5Cend%7Baligned%7D%0A" /></p><p>求二阶导得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cfrac%7B%5Cpartial%5E2%20I_%7BR%7D%7D%7B%5Cpartial%20%5Csigma_i%5E2%20%5Cpartial%20%5Csigma_j%5E2%7D%20%26%20%3D%5Cfrac%7B1%7D%7B2%7D%20%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BP%20Z%7D_j%20%5Cmathbf%7BZ%7D_j%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%5Cmathbf%7BZ%7D_i%20%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%5Cright%29-%5Cfrac%7B1%7D%7B2%7D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BZ%7D_j%5Cmathbf%7BZ%7D_j%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BZ%7D_i%20%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%20y%7D-%5Cfrac%7B1%7D%7B2%7D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BZ%7D_i%20%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%20%7D%5Cmathbf%7BZ%7D_j%20%5Cmathbf%7BZ%7D_j%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%20y%7D%20%5C%5C%0A%26%20%3D%5Cfrac%7B1%7D%7B2%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BP%20Z%7D_j%20%5Cmathbf%7BZ%7D_j%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%20%7D%20%5Cmathbf%7BZ%7D_i%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%5Cright)-%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BZ%7D_j%20%5Cmathbf%7BZ%7D_j%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BZ%7D_i%20%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%20y%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>这里利用了两个性质：<img src="https://math.now.sh?inline=%5Cfrac%7B%5Cpartial%20%5Coperatorname%7Btr%7D%20%28%5Cmathbf%7BA%7D%20%5Cmathbf%7BB%7D%29%20%7D%7B%5Cpartial%20x%7D%20%20%3D%20%5Coperatorname%7Btr%7D%20(%5Cmathbf%7BA%7D%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BB%7D%20%7D%7B%5Cpartial%20x%7D)%20%2B%20%5Coperatorname%7Btr%7D%20(%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BA%7D%20%7D%7B%5Cpartial%20x%7D%5Cmathbf%7BB%7D)" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BA%7D_%7B1%7D%20%5Cmathbf%7BA%7D_%7B2%7D%20%5Ccdots%20%5Cmathbf%7BA%7D_%7Bn%7D%20%7D%7B%5Cpartial%20x%7D%20%20%3D%20%28%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BA%7D_%7B1%7D%7D%7B%5Cpartial%20x%7D%20%5Cmathbf%7BA%7D_%7B2%7D%20%5Ccdots%20%5Cmathbf%7BA%7D_%7Bn%7D%29%2B%5Ccdots%2B(%20%5Cmathbf%7BA%7D_%7B1%7D%20%5Cmathbf%7BA%7D_%7B2%7D%20%5Ccdots%20%5Cfrac%7B%5Cpartial%20%5Cmathbf%7BA%7D_%7Bn%7D%7D%7B%5Cpartial%20x%7D)" style="display:inline-block;margin: 0;"/> ，证明过程参考 Linear models in statistics 。</p>
<p>再求期望得到信息矩阵， 这里利用二次型的期望公式 <img src="https://math.now.sh?inline=E%5Cleft%28%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BA%20y%7D%5Cright%29%3D%5Coperatorname%7Btr%7D(%5Cmathbf%7BA%7D%20%5Cmathbf%7BV%7D)%2B%5Cboldsymbol%7B%5Cmu%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BA%7D%20%5Cboldsymbol%7B%5Cmu%7D%20." style="display:inline-block;margin: 0;"/></p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%20-E%5Cleft%28%5Cfrac%7B%5Cpartial%5E2%20l_%7B%5Cmathbf%7BR%7D%7D%7D%7B%5Cpartial%20%5Csigma_i%5E2%20%5Csigma_j%5E2%7D%5Cright%29%5C%5C%0A%26%3D-%5Cfrac%7B1%7D%7B2%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BP%20Z%7D_j%20%5Cmathbf%7BZ%7D_j%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%20Z_%7B%20i%20%7D%7D%20%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%5Cright)%2B%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BP%20Z%7D_j%20%5Cmathbf%7BZ%7D_j%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%20%7D%5Cmathbf%7BZ%7D_i%20%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%20V%7D%5Cright)-%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%20%7D%20%5Cmathbf%7BZ%7D_j%5Cmathbf%7BZ%7D_j%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%20Z%20_%20%7B%20i%20%7D%7D%20%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%20X%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20%5C%5C%0A%26%20%3D-%5Cfrac%7B1%7D%7B2%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BP%20Z%7D_j%20%5Cmathbf%7BZ%7D_j%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%20Z%20_%20%7B%20i%20%7D%7D%20%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%5Cright)%2B%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BZ%7D_j%20%5Cmathbf%7BZ%7D_j%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%20Z%7D_i%20%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%20V%20P%7D%5Cright)%2B%5Cmathbf%7B0%7D%20%5Cquad%20%5Ctext%20%7B%2C%20because%20%7D%20%5Cmathbf%7BP%20X%7D%3D%20%5Cmathbf%7BK%7D%20%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%20K%7D%5Cright)%5E%7B-1%7D%20(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D)%3D%5Cmathbf%7B0%7D%20%5Ctext%20%7B%2C%20%7D%20%5C%5C%0A%26%20%3D%5Cfrac%7B1%7D%7B2%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BP%20Z%7D_j%20%5Cmathbf%7BZ%7D_j%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%20Z%7D_i%20%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%5Cright)%20%5Cquad%20%20%5Ctext%20%7B%2C%20because%20%7D%20%5Cmathbf%7BP%20V%20P%7D%3D%5Cmathbf%7BP%7D%20.%20%5C%5C%0A%26%0A%5Cend%7Baligned%7D%0A" /></p><p>因此估计值的协方差矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Bvar%7D%5Cleft%28%5Ctilde%7B%5Csigma%7D_%7B%5Cmathrm%7BREML%7D%7D%5E2%5Cright%29%20%26%20%5Csimeq%202%5Cleft%5B%5Cleft%5C%7B_%7B%5Cmathrm%7Bm%7D%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BP%7D%20%5Cmathbf%7BZ%7D_i%20%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BZ%7D_j%20%5Cmathbf%7BZ%7D_j%5E%7B%5Cprime%7D%5Cright)%5Cright%5C%7D_%7Bi%2C%20j%3D0%7D%5Er%5Cright%5D%5E%7B-1%7D%20%5C%5C%0A%26%20%5Csimeq%202%5Cleft%5B%5Cleft%5C%7B_%7B%5Cmathrm%7Bm%7D%7D%20%5Coperatorname%7Bsesq%7D%5Cleft(%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BZ%7D_j%5Cright)%5Cright%5C%7D_%7Bi%2C%20j%3D0%7D%5Er%5Cright%5D%5E%7B-1%7D%2C%0A%5Cend%7Baligned%7D%0A" /></p><p>这和 ML 的式子格式相同，只是将 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 替换成了 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D" style="display:inline-block;margin: 0;"/> 。</p>
<h2 id="EM-算法-2">EM 算法</h2>
<p>混合详细模型如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%20%3D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20%2B%20%5Cmathbf%7BZ%7D%5Cmathbf%7Bu%7D%20%2B%20%5Cmathbf%7Be%7D%0A" /></p><p>对于公式 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%5Cright%29%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%7B%5Cmathbf%7By%7D%7D" style="display:inline-block;margin: 0;"/> ，我们在等式两边同乘以 <img src="https://math.now.sh?inline=%5Chat%7B%5Csigma%7D%5E%7B2%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，并求总和，得到：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Btr%7D%5Cleft%28%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Csum%20%5Cmathbf%7B%5Chat%7BV%7D%7D_%7Bi%7D%20%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D%5Cright%29%20%26%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Csum%20%5Cmathbf%7BV%7D_%7Bi%7D%20%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%5Cmathbf%7By%7D%20%5C%5C%0A%5Coperatorname%7Btr%7D%5Cleft(%5Chat%7B%5Cmathbf%7BP%7D%7D%20%20%5Cmathbf%7B%5Chat%7BV%7D%7D%5Cright)%20%26%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7B%5Chat%7BV%7D%7D%20%20%5Chat%7B%5Cmathbf%7BP%7D%7D%5Cmathbf%7By%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>我们先看左手项 (下面的 <strong><img src="https://math.now.sh?inline=N" style="display:inline-block;margin: 0;"/> 是表型数目，<img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的秩</strong>)</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Btr%7D%28%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%29%20%26%3D%5Coperatorname%7Btr%7D%5Cleft%5B%5Cleft(%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D-%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%5Cright)%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5Cright%5D%20%5C%5C%0A%0A%26%3D%5Coperatorname%7Btr%7D(%5Cmathbf%7BI%7D)-%5Coperatorname%7Btr%7D%5Cleft%5B%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cright%5D%20%5C%5C%0A%0A%26%3D%5Coperatorname%7Btr%7D(%5Cmathbf%7BI%7D)-%5Coperatorname%7Btr%7D%5Cleft%5B%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%5D%20%5Cquad%20%5Cbecause%20%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%5Ctext%7B%20%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E7%A7%B0%E5%B9%82%E7%AD%89%E7%9F%A9%E9%98%B5%7D%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D(%5Cmathbf%7BI%7D)-%5Coperatorname%7BRank%7D%5Cleft%5B%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%5D%20%20%5C%5C%0A%26%3DN-r%0A%5Cend%7Baligned%7D%0A" /></p><p>我们再看右手项，在之前 ML 的推导中，我们知道 <img src="https://math.now.sh?inline=%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7By%7D%20%3D%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29" style="display:inline-block;margin: 0;"/> ，因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BP%7D%7D%20%5Cmathbf%7B%5Chat%7BV%7D%7D%20%20%5Chat%7B%5Cmathbf%7BP%7D%7D%5Cmathbf%7By%7D%0A%26%3D%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%5C%5C%0A%0A%26%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%20%20-%20%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5E%7B%5Cprime%7D%20%5Cleft(%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%20-%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%20%5Cright)%5C%5C%0A%0A%26%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%20%5Cquad%5Cleft(%5Cbecause%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%5Cright)%5C%5C%0A%26%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%5Cleft%5B%5Chat%7B%5Cmathbf%7BR%7D%7D%5E%7B-1%7D-%5Chat%7B%5Cmathbf%7BR%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5Cleft(%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BR%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Chat%7B%5Cmathbf%7BG%7D%7D%5E%7B-1%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BR%7D%7D%5E%7B-1%7D%5Cright%5D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%5C%5C%0A%26%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BR%7D%7D%5E%7B-1%7D%5Cleft%5B(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)-%5Cmathbf%7BZ%7D%5Cleft(%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BR%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Chat%7B%5Cmathbf%7BG%7D%7D%5E%7B-1%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BR%7D%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%5Cright%5D%5C%5C%0A%26%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7BR%7D%7D%5E%7B-1%7D%5B(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)-%5Cmathbf%7BZ%7D%20%5Chat%7B%5Cmathbf%7Bu%7D%7D%5D%5C%5C%0A%26%5Cleft(%5Cbecause%20%5Chat%7B%5Cmathbf%7Bu%7D%7D%3D%5Cleft(%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright)%5E%7B-1%7D%5Cleft(%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D-%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5Cright)%5Cright)%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7B%5Chat%7B%5Csigma%7D_%7B0%7D%5E%7B2%7D%7D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D-%5Cmathbf%7BZ%7D%20%5Chat%7B%5Cmathbf%7Bu%7D%7D)%20%5Cquad%20%5Cbecause%20%5Ctext%7B%E5%81%87%E8%AE%BE%E4%B8%BA%E5%8D%95%E6%80%A7%E7%8A%B6%E6%A8%A1%E5%9E%8B%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Csigma%7D_%7B0%7D%5E%7B2%7D%3D%5Cleft%28%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D-%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D-%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D%20%5Chat%7B%5Cmathbf%7Bu%7D%7D%5Cright%29%20%2F(N-r)%0A" /></p><p>对于某个随机因子的方差组分 <img src="https://math.now.sh?inline=%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，其迭代公式推导如下。</p>
<p>首先我们需要证明一个引理，因为 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D%20%3D%20%5Cmathbf%7BZ%7D%5Cmathbf%7BG%7D%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> ，如果我们将 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D%20%3D%20%20%5Cmathbf%7BV%7D%5E%7B-1%7D-%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/>  中设置 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> ，将新的式子定义为 <img src="https://math.now.sh?inline=%5Cmathbf%7BS%7D" style="display:inline-block;margin: 0;"/> ，得到：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BS%7D%20%3D%20%20%5Cmathbf%7BR%7D%5E%7B-1%7D-%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%0A" /></p><p>那么我们有下面的引理。</p>
<p><strong>引理</strong>：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BP%7D%3D%5Cmathbf%7BS-S%20Z%5Cleft%28D%5E%7B-1%7D%2BZ%5E%7B%5Cprime%7D%20S%20Z%5Cright%29%5E%7B-1%7D%20Z%5E%7B%5Cprime%7D%20S%7D%0A" /></p><p>证明：因为我们有 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D%20%3D%20%5Cmathbf%7BK%7D%20%5Cleft%28%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%20K%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，代入  <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> 得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BS%7D%20%3D%20%5Cmathbf%7BK%7D%20%5Cleft%28%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%20K%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%0A" /></p><p>因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BP%7D%3D%20%26%20%5Cmathbf%7BK%7D%5Cleft%5B%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%28%5Cmathbf%7BZ%20G%20Z%5E%7B%5Cprime%7D%7D%2B%5Cmathbf%7BR%7D%29%20%5Cmathbf%7BK%7D%5Cright%5D%5E%7B-1%7D%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%3D%5Cmathbf%7BK%7D%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%20K%7D%2B%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%20G%20Z%5E%7B%5Cprime%7D%7D%20%5Cmathbf%7BK%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5C%5C%0A%3D%20%26%20%5Cmathbf%7BK%7D%5Cleft%5C%7B%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%20K%7D%5Cright)%5E%7B-1%7D-%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%20K%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%20G%7D%5Cleft%5B%5Cmathbf%7BI%7D%2B%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BK%7D%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%20K%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%20G%7D%5Cright%5D%5E%7B-1%7D%5Cright.%20%5C%5C%0A%26%20%5Cleft.%5Ctimes%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BK%7D%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%20K%7D%5Cright)%5E%7B-1%7D%5Cright%5C%7D%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%2C%20%5Ctext%20%7B%20%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%88%92%E5%B0%94%E8%A1%A5%E5%85%AC%E5%BC%8F%20%7D%5C%5C%0A%3D%20%26%20%5Cmathbf%7BS%7D-%5Cmathbf%7BS%20Z%20G%7D%5Cleft(%5Cmathbf%7BI%7D%2B%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BS%20Z%20G%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BS%7D%20%5C%5C%0A%3D%20%26%20%5Cmathbf%7BS%7D-%5Cmathbf%7BS%20Z%7D%5Cleft(%5Cmathbf%7BG%7D%5E%7B-1%7D%2B%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BS%20Z%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BS%7D%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>注意这个公式和 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 有着相似的格式，只是其中的 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 替换成了 <img src="https://math.now.sh?inline=%5Cmathbf%7BS%7D" style="display:inline-block;margin: 0;"/></p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BV%7D%5E%7B-1%7D%20%3D%20%5Cmathbf%7BR%7D%5E%7B-1%7D-%5Cmathbf%7BR%5E%7B-1%7D%20Z%7D%5Cleft%28%5Cmathbf%7BG%7D%5E%7B-1%7D%2B%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%5E%7B-1%7D%20Z%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%0A" /></p><p>舒尔补公式说明如下，如果一个非奇异分块矩阵中，如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 可逆，则其逆矩阵可以表示为</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BA%7D%20%26%20%5Cmathbf%7BB%7D%20%5C%5C%0A%5Cmathbf%7BC%7D%20%26%20%5Cmathbf%7BD%7D%0A%5Cend%7Barray%7D%5Cright%5D%5E%7B-1%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BA%7D%5E%7B-1%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%0A%5Cend%7Barray%7D%5Cright%5D%2B%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A-%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cmathbf%7BB%7D%20%5C%5C%0A%5Cmathbf%7BI%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%28%5Cmathbf%7BD%7D-%5Cmathbf%7BC%20A%7D%5E%7B-1%7D%20%5Cmathbf%7BB%7D%5Cright%29%5E%7B-1%7D%5Cleft%5B-%5Cmathbf%7BC%20A%7D%5E%7B-1%7D%20%5Cquad%20%5Cmathbf%7BI%7D%5Cright%5D%0A" /></p><p>其中矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D-%5Cmathbf%7BC%20A%7D%5E%7B-1%7D%20%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 称为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的舒尔补，Marsaglia 和 Styan (1974a,b) 给出了两个重要公式，分别为（第二个式子可以理解为将 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 替换成了  <img src="https://math.now.sh?inline=%5Cmathbf%7B-A%7D" style="display:inline-block;margin: 0;"/> ）。</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cmathbf%7BD%7D-%5Cmathbf%7BC%20A%7D%5E%7B-1%7D%20%5Cmathbf%7BB%7D%5Cright%29%5E%7B-1%7D%3D%5Cmathbf%7BD%7D%5E%7B-1%7D%2B%5Cmathbf%7BD%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%5Cleft(%5Cmathbf%7BA%7D-%5Cmathbf%7BB%20D%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BB%20D%7D%5E%7B-1%7D%2C%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cmathbf%7BD%7D%2B%5Cmathbf%7BC%20A%7D%5E%7B-1%7D%20%5Cmathbf%7BB%7D%5Cright%29%5E%7B-1%7D%3D%5Cmathbf%7BD%7D%5E%7B-1%7D-%5Cmathbf%7BD%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%5Cleft(%5Cmathbf%7BA%7D%2B%5Cmathbf%7BB%20D%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BB%20D%7D%5E%7B-1%7D%20%5Ctext%20%7B%2C%20%7D%0A" /></p><p>我们再看公式 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BP%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cright%29%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%20%5Cmathbf%7BV%7D_%7Bi%7D%20%5Cmathbf%7BP%7D%20%7B%5Cmathbf%7By%7D%7D" style="display:inline-block;margin: 0;"/> 的左手项 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BP%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cright%29" style="display:inline-block;margin: 0;"/> ，之前在 ML 的 EM 算法推导中，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_i%20%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%5Cright%29%3D%5Cleft%5Bq_i-%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BW%7D_%7Bii%7D%5Cright)%5Cright%5D%20%2F%20%5Csigma_i%5E2%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D_%7Bii%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D%3D%5Cleft%28%5Cmathbf%7BI%7D%2B%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7BG%7D%5Cright%29%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 的第 <img src="https://math.now.sh?inline=%28i%2Ci%29" style="display:inline-block;margin: 0;"/> 个子矩阵。</p>
<p>因为 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 的差别就是将 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 替换成了 <img src="https://math.now.sh?inline=%5Cmathbf%7BS%7D" style="display:inline-block;margin: 0;"/>， 因此我们得到：</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BP%20Z%7D_i%20%5Cmathbf%7BZ%7D_i%5E%7B%5Cprime%7D%5Cright%29%3D%5Cleft%5Bq_i-%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BT%7D_%7Bii%7D%5Cright)%5Cright%5D%20%2F%20%5Csigma_i%5E2%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D_%7Bii%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D" style="display:inline-block;margin: 0;"/> 中将 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 替换成了 <img src="https://math.now.sh?inline=%5Cmathbf%7BS%7D" style="display:inline-block;margin: 0;"/> 的子矩阵，我们标记为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BT%7D%3D%5Cleft%28%5Cmathbf%7BI%7D%2B%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BS%7D%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7BG%7D%5Cright%29%5E%7B-1%7D%0A" /></p><p>因为 REML 公式和 ML 公式的右手项不变，因此我们得到：</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D%3D%5Cfrac%7B%5Chat%7B%5Cmathbf%7Bu%7D%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cmathbf%7Bu%7D%7D_%7Bi%7D%2B%20%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D%20%5Coperatorname%7Btr%7D%20%5Cleft%28%5Cmathbf%7BT%7D_%7Bii%7D%5Cright%29%20%7D%20%7Bq_%7Bi%7D%7D%0A" /></p><p>或者</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D%3D%5Cfrac%7B%5Chat%7B%5Cmathbf%7Bu%7D%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%20%5Chat%7B%5Cmathbf%7Bu%7D%7D_%7Bi%7D%7D%7Bq_%7Bi%7D-%20%5Coperatorname%7Btr%7D%20%5Cleft%28%5Cmathbf%7BT%7D_%7Bii%7D%5Cright%29%20%7D%0A" /></p><p>通过上面这两个公式我们得到了 REML 的 EM 算法。在计算时，我们先给出一组初始的 <img src="https://math.now.sh?inline=%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 值，由混合模型方程组求出相应的 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/>  和 <img src="https://math.now.sh?inline=%5Chat%7B%5Cmathbf%7Bu%7D%7D" style="display:inline-block;margin: 0;"/> ，以及相应的系数矩阵逆矩阵元素；再由上面的两个公式求出一组新的  <img src="https://math.now.sh?inline=%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 值，如此迭代下去，知道两次迭代得到的   <img src="https://math.now.sh?inline=%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 值得差异小于给定阈值时，迭代收敛。</p>
<p>而且根据上面两个公式，可以得到 <img src="https://math.now.sh?inline=%5Chat%7B%5Csigma%7D_%7B0%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 都比大于0，因此 EM 算法一定满足参数空间的要求。</p>
<h1>EM 算法</h1>
<p>EM 算法的全名为 expectation-maximization ，因为它在计算条件期望值和最大化简化的似然函数值间不断跳转。<strong>EM算法只会计算估计值，而不会计算估计值的方差</strong>。</p>
<p>EM 算法用于当数据增加时会简化问题难度的最大似然估计，应用 EM 算法的核心在于决定什么是完整数据（观测数据+未观测到的数据）。实际数据（观测数据）在 EM 算法中一般称为不完整的数据。因此在方差组分估计中，我们将表型 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 视为不完整的数据，完整数据为表型 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 加上未观测的随机效应 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> (<img src="https://math.now.sh?inline=i%3D1%2C2%2C%5Ccdots%2Cr" style="display:inline-block;margin: 0;"/>) 。</p>
<p>如果我们知道随机效应 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的值，我们可以用其平方和均值估计随机效应的方差，该式为基于完整数据的最大似然估计值。</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D%20%3D%20%5Cmathbf%7Bu%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7Bu%7D_%7Bi%7D%2Fq_%7Bi%7D%0A" /></p><p>但是，实际上我们并不知道随机效应 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的值，但是 EM 算法给了我们一种基于 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 估计 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的方法。首先我们采用一组参数的初始值，我们之后基于  <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 计算 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7Bu%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的条件期望（E 步, expectation step），然后利用其条件期望值使用<strong>最大似然法</strong>得到一组新的参数估计值（M 步， maximization step）。然后不断循环这两步直到收敛。</p>
<p>EM 算法的一个重要特征是，因为 EM 算法对完整数据执行最大似然估计，因此每一次迭代得到的估计值均在参数空间中。</p>
<h2 id="联合分布">联合分布</h2>
<p>因为我们需要计算给定  <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 条件下 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7Bu%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的条件期望，因此我们需要 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D%20%3D%20%5Cleft%5B%20%5Cmathbf%7Bu%7D_%7B1%7D%5E%7B%5Cprime%7D%2C%20%5Cmathbf%7Bu%7D_%7B2%7D%5E%7B%5Cprime%7D%2C%20%5Ccdots%2C%20%5Cmathbf%7Bu%7D_%7Br%7D%5E%7B%5Cprime%7D%20%5Cright%5D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 的联合分布。</p>
<p>我们有下面的式子</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7By%7D%20%26%3D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20%2B%20%5Csum_%7Bi%3D1%7D%5E%7Br%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7Bu%7D_%7Bi%7D%20%2B%20%5Cmathbf%7Be%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20%2B%20%5Csum_%7Bi%3D0%7D%5E%7Br%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7Bu%7D_%7Bi%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D_%7B0%7D%20%3D%20%5Cmathbf%7Be%7D" style="display:inline-block;margin: 0;"/> , <img src="https://math.now.sh?inline=q_%7B0%7D%20%3D%20N" style="display:inline-block;margin: 0;"/> , <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D_%7B0%7D%20%3D%20%5Cmathbf%7BI%7D_%7Bn%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Bcov%7D%28%5Cmathbf%7By%7D%2C%20%5Cmathbf%7Bu%7D_%7Bj%7D%5E%7B%5Cprime%7D%29%20%3D%20%5Coperatorname%7Bcov%7D%20%5Cleft(%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20%2B%20%5Csum_%7Bi%3D0%7D%5E%7Br%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7Bu%7D_%7Bi%7D%2C%20%5Cmathbf%7Bu%7D_%7Bj%7D%5E%7B%5Cprime%7D%20%5Cright)%20%3D%20%5Cmathbf%7BZ%7D_%7Bj%7D%20%5Coperatorname%7Bcov%7D%20(%5Cmathbf%7Bu%7D_%7Bj%7D%2C%20%5Cmathbf%7Bu%7D_%7Bj%7D%5E%7B%5Cprime%7D)%20%3D%20%5Csigma_%7Bj%7D%5E%7B2%7D%20%5Cmathbf%7BZ%7D_%7Bj%7D%0A" /></p><p>同时我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BV%7D%20%3D%20%5Coperatorname%7Bcov%7D%20%28%5Cmathbf%7By%7D%29%20%3D%20%5Csum_%7Bi%3D0%7D%5E%7Br%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Csigma_%7Bi%7D%5E%7B2%7D%20%3D%20%5Csum_%7Bi%3D1%7D%5E%7Br%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Csigma_%7Bi%7D%5E%7B2%7D%20%2B%20%5Csigma_%7B0%7D%5E%7B2%7D%20%5Cmathbf%7BI%7D_%7BN%7D%0A" /></p><p>因此 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> 的联合分布为 <img src="https://math.now.sh?inline=N%28%5Cboldsymbol%7B%5Cmu%7D%2C%20%5Cboldsymbol%7B%5CSigma%7D%29" style="display:inline-block;margin: 0;"/> ，其中</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Cmu%7D%20%3D%5Cleft%5B%20%5Cbegin%7Barray%7D%20%7Bc%7D%0A%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cvdots%20%5C%5C%0A%5Cmathbf%7B0%7D%5C%5C%0A%20%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5CSigma%7D%20%3D%5Cleft%5B%20%5Cbegin%7Barray%7D%20%7Bcc%7D%0A%5Cmathbf%7BV%7D%20%26%20%5Cleft%5C%7B_%7Br%7D%5Csigma_%7Bi%7D%5E%7B2%7D%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cright%5C%7D_%7Bi%3D1%7D%5E%7Br%7D%20%5C%5C%0A%20%5Cleft%5C%7B_%7Bc%7D%5Csigma_%7Bi%7D%5E%7B2%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cright%5C%7D_%7Bi%3D1%7D%5E%7Br%7D%20%26%20%20%5Cleft%5C%7B_%7Bd%7D%20%5Csigma_%7Bi%7D%5E%7B2%7D%5Cmathbf%7BI%7D_%7Bq_%7Bi%7D%7D%20%5Cright%5C%7D_%7Bi%3D1%7D%5E%7Br%7D%5C%5C%0A%20%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>因此我们有概率密度函数</p>
<p style=""><img src="https://math.now.sh?from=f_%7B%5Cmathbf%7By%7D%2C%20%5Cboldsymbol%7B%5Cmu%7D%7D%28%5Cmathbf%7By%7D%2C%20%5Cboldsymbol%7B%5Cmu%7D%29%3D%20(2%5Cpi)%5E%7B-%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bi%3D0%7D%5E%7Br%7Dq_%7Bi%7D%7D%20%20%7C%5Cmathbf%7B%5CSigma%7D%7C%5E%7B-%5Cfrac%7B1%7D%7B2%7D%7D%20%5Cexp%20%5Cleft%5C%7B-%20%5Cfrac%7B1%7D%7B2%7D%20%5Cmathbf%7BQ%7D%20%5Cright%5C%7D%0A" /></p><p>其中</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BQ%7D%20%3D%20%5Cleft%5B%20%28%5Cmathbf%7By-X%7D%5Cboldsymbol%7B%5Cbeta%7D%29%5E%7B%5Cprime%7D%20%5Cquad%20%5Cmathbf%7Bu%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cquad%20%5Cmathbf%7Bu%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cquad%20%5Ccdots%20%5Cquad%20%5Cquad%20%5Cmathbf%7Bu%7D_%7Br%7D%5E%7B%5Cprime%7D%20%5Cright%5D%20%5Cmathbf%7B%5CSigma%7D%5E%7B-1%7D%20%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A(%5Cmathbf%7By-X%7D%5Cboldsymbol%7B%5Cbeta%7D)%20%5C%5C%0A%5Cmathbf%7Bu%7D_%7B1%7D%20%5C%5C%0A%5Cmathbf%7Bu%7D_%7B2%7D%20%5C%5C%0A%5Cvdots%20%5C%5C%0A%5Cmathbf%7Bu%7D_%7Br%7D%20%5Cend%7Barray%7D%20%5Cright%5D%0A" /></p><p>根据舒尔补，我们有公式</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%7C%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BA%7D%20%26%20%5Cmathbf%7BB%7D%5C%5C%0A%5Cmathbf%7BC%7D%20%26%20%5Cmathbf%7BD%7D%5C%5C%0A%0A%5Cend%7Barray%7D%20%5Cright%7C%20%3D%20%7C%5Cmathbf%7BD%7D%7C%5Cmathbf%7BA-BD%5E%7B-1%7DC%7D%7C%0A" /></p><p>我们推导得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%7C%5Cmathbf%7B%5CSigma%7D%7C%20%26%3D%20%7C%5Cleft%5C%7B_%7Bd%7D%20%5Csigma_%7Bi%7D%5E%7B2%7D%5Cmathbf%7BI%7D_%7Bq_%7Bi%7D%7D%20%5Cright%5C%7D_%7Bi%3D1%7D%5E%7Br%7D%7C%5Cmathbf%7BV%7D%20-%20%5Cleft%5C%7B_%7Br%7D%5Csigma_%7Bi%7D%5E%7B2%7D%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cright%5C%7D_%7Bi%3D1%7D%5E%7Br%7D%20%5Cleft%5C%7B_%7Bd%7D%20%28%5Csigma_%7Bi%7D%5E%7B2%7D%29%5E%7B-1%7D%5Cmathbf%7BI%7D_%7Bq_%7Bi%7D%7D%20%5Cright%5C%7D_%7Bi%3D1%7D%5E%7Br%7D%20%5Cleft%5C%7B_%7Bc%7D%5Csigma_%7Bi%7D%5E%7B2%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cright%5C%7D_%7Bi%3D1%7D%5E%7Br%7D%20%7C%20%5C%5C%0A%26%3D%5Cprod_%7Bi%3D1%7D%5E%7Br%7D(%5Csigma_%7Bi%7D%5E%7B2%7D)%5E%7Bq_%7Bi%7D%7D%20%7C%5Cmathbf%7BV%7D%20-%20%5Csum_%7Bi%3D1%7D%5E%7Br%7D%5Csigma_%7Bi%7D%5E%7B2%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%7C%20%5C%5C%0A%26%3D%5Cprod_%7Bi%3D1%7D%5E%7Br%7D(%5Csigma_%7Bi%7D%5E%7B2%7D)%5E%7Bq_%7Bi%7D%7D%20%7C%5Csigma_%7B0%7D%5E%7B2%7D%5Cmathbf%7BI%7D_%7BN%7D%7C%20%5C%5C%0A%26%3D%5Cprod_%7Bi%3D1%7D%5E%7Br%7D(%5Csigma_%7Bi%7D%5E%7B2%7D)%5E%7Bq_%7Bi%7D%7D%20(%5Csigma_%7B0%7D%5E%7B2%7D)%5E%7BN%7D%20%5C%5C%0A%26%3D%5Cprod_%7Bi%3D0%7D%5E%7Br%7D(%5Csigma_%7Bi%7D%5E%7B2%7D)%5E%7Bq_%7Bi%7D%7D%20%5C%5C%0A%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>同时根据舒尔补公式</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BA%7D%20%26%20%5Cmathbf%7BB%7D%20%5C%5C%0A%5Cmathbf%7BC%7D%20%26%20%5Cmathbf%7BD%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%5E%7B-1%7D%20%3D%20%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BD%7D%5E%7B-1%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%2B%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BI%7D%20%5C%5C%0A-%5Cmathbf%7BD%7D%5E%7B-1%7D%5Cmathbf%7BC%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%28%5Cmathbf%7BA%7D-%5Cmathbf%7BB%20D%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%29%5E%7B-1%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BI%7D%20%26%20%5Cmathbf%7B-BD%5E%7B-1%7D%7D%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%5CSigma%7D%5E%7B-1%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%20%5Cleft%5C%7B_%7Bd%7D%20%5Csigma_%7Bi%7D%5E%7B-2%7D%5Cmathbf%7BI%7D_%7Bq_%7Bi%7D%7D%20%5Cright%5C%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%2B%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BI%7D%20%5C%5C%0A-%5Cleft%5C%7B_%7Bc%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cright%5C%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%5Csigma_%7B0%7D%5E%7B-2%7D%5Cmathbf%7BI%7D_%7BN%7D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BI%7D%20%26%20-%5Cleft%5C%7B_%7Br%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cright%5C%7D%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>因此</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BQ%7D%20%26%3D%20%5Cleft%5B%20%28%5Cmathbf%7By-X%7D%5Cboldsymbol%7B%5Cbeta%7D%29%5E%7B%5Cprime%7D%20%5Cquad%20%5Cmathbf%7Bu%7D%5E%7B%5Cprime%7D%20%20%5Cright%5D%20%5Cmathbf%7B%5CSigma%7D%5E%7B-1%7D%20%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A(%5Cmathbf%7By-X%7D%5Cboldsymbol%7B%5Cbeta%7D)%20%5C%5C%0A%5Cmathbf%7Bu%7D%20%5C%5C%20%5Cend%7Barray%7D%20%5Cright%5D%20%5C%5C%0A%26%3D%20%5Csum_%7Bi%3D1%7D%5E%7Br%7D%20%5Cfrac%7B%5Cmathbf%7Bu%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7Bu%7D_%7Bi%7D%7D%7B%5Csigma_%7Bi%7D%5E%7B2%7D%7D%20%2B%20%20(%5Cmathbf%7By-X%7D%5Cboldsymbol%7B%5Cbeta%7D-%5Csum_%7Bi%3D1%7D%5E%7Br%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7Bu%7D_%7Bi%7D)%5E%7B%5Cprime%7D%20(%5Cmathbf%7By-X%7D%5Cboldsymbol%7B%5Cbeta%7D-%5Csum_%7Bi%3D1%7D%5E%7Br%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7Bu%7D_%7Bi%7D)%2F%5Csigma_%7B0%7D%5E%7B2%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，将上面的式子代入基于完全数据的对数似然函数（概率密度函数），得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Al%20%26%20%3D%20-%20%5Cfrac%7B1%7D%7B2%7D%20%5Cleft%28%20%5Csum_%7Bi%3D0%7D%5E%7Br%7D%20q_%7Bi%7D%20%5Cright%29%20%5Cln%202%20%5Cpi-%20%5Cfrac%7B1%7D%7B2%7D%20%20%5Csum_%7Bi%3D0%7D%5E%7Br%7D%20q_%7Bi%7D%20%5Cln%20%5Csigma_%7Bi%7D%5E%7B2%7D%20-%20%5Cfrac%7B1%7D%7B2%7D%5Csum_%7Bi%3D1%7D%5E%7Br%7D%20%5Cfrac%7B%5Cmathbf%7Bu%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7Bu%7D_%7Bi%7D%7D%7B%5Csigma_%7Bi%7D%5E%7B2%7D%7D%20%5C%5C%0A%0A%26%20%5Cquad%20-%20%5Cfrac%7B1%7D%7B2%7D%20(%5Cmathbf%7By-X%7D%5Cboldsymbol%7B%5Cbeta%7D-%5Csum_%7Bi%3D1%7D%5E%7Br%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7Bu%7D_%7Bi%7D)%5E%7B%5Cprime%7D%20(%5Cmathbf%7By-X%7D%5Cboldsymbol%7B%5Cbeta%7D-%5Csum_%7Bi%3D1%7D%5E%7Br%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7Bu%7D_%7Bi%7D)%2F%5Csigma_%7B0%7D%5E%7B2%7D%20%5C%5C%0A%26%20%3D%20-%20%5Cfrac%7B1%7D%7B2%7D%20%5Cleft(%20%5Csum_%7Bi%3D0%7D%5E%7Br%7D%20q_%7Bi%7D%20%5Cright)%20%5Cln%202%20%5Cpi-%20%5Cfrac%7B1%7D%7B2%7D%20%20%5Csum_%7Bi%3D0%7D%5E%7Br%7D%20q_%7Bi%7D%20%5Cln%20%5Csigma_%7Bi%7D%5E%7B2%7D%20-%20%5Cfrac%7B1%7D%7B2%7D%5Csum_%7Bi%3D0%7D%5E%7Br%7D%20%5Cfrac%7B%5Cmathbf%7Bu%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7Bu%7D_%7Bi%7D%7D%7B%5Csigma_%7Bi%7D%5E%7B2%7D%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>其中第二步推导是因为 <img src="https://math.now.sh?inline=%5Cmathbf%7By-X%7D%5Cboldsymbol%7B%5Cbeta%7D-%5Csum_%7Bi%3D1%7D%5E%7Br%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7Bu%7D_%7Bi%7D%20%3D%20%5Cmathbf%7Be%7D%20%3D%20%5Cmathbf%7Bu%7D_%7B0%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>因此根据完全数据的对数似然函数，对 <img src="https://math.now.sh?inline=%5Csigma_%7Bi%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 求偏导，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%5Cpartial%20l%7D%7B%5Cpartial%20%5Csigma_%7Bi%7D%5E%7B2%7D%7D%20%3D%20-%20%5Cfrac%7B1%7D%7B2%7D%20%5Cleft%28%20%5Cfrac%7Bq_%7Bi%7D%7D%7B%5Csigma_%7Bi%7D%5E%7B2%7D%7D%20-%20%5Cfrac%7B%5Cmathbf%7Bu%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7Bu%7D_%7Bi%7D%7D%7B%5Csigma_%7Bi%7D%5E%7B4%7D%7D%20%5Cright%29%0A" /></p><p>使该式为 0 ，我们可以轻松得到 ML 估计值</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D%20%3D%20%5Cmathbf%7Bu%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7Bu%7D_%7Bi%7D%2Fq_%7Bi%7D%0A" /></p><p>对 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 求偏导，计算过程如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cmathrm%7Bd%7D%28%5Cmathrm%7Btr%7D((%5Cmathbf%7By-X%7D%5Cboldsymbol%7B%5Cbeta%7D-%5Csum_%7Bi%3D1%7D%5E%7Br%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7Bu%7D_%7Bi%7D%29%5E%7B%5Cprime%7D%20(%5Cmathbf%7By-X%7D%5Cboldsymbol%7B%5Cbeta%7D-%5Csum_%7Bi%3D1%7D%5E%7Br%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7Bu%7D_%7Bi%7D)))%20%5C%5C%0A%26%3D%5Cmathrm%7Btr%7D(%5Cmathrm%7Bd%7D((%5Cmathbf%7By-X%7D%5Cboldsymbol%7B%5Cbeta%7D-%5Csum_%7Bi%3D1%7D%5E%7Br%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7Bu%7D_%7Bi%7D)%5E%7B%5Cprime%7D%20(%5Cmathbf%7By-X%7D%5Cboldsymbol%7B%5Cbeta%7D-%5Csum_%7Bi%3D1%7D%5E%7Br%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7Bu%7D_%7Bi%7D)))%20%5C%5C%0A%26%3D%5Cmathrm%7Btr%7D%5Cleft(-%5Cmathrm%7Bd%7D(%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%5Cprime%7D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D)%20(%5Cmathbf%7By-X%7D%5Cboldsymbol%7B%5Cbeta%7D-%5Csum_%7Bi%3D1%7D%5E%7Br%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7Bu%7D_%7Bi%7D)-(%5Cmathbf%7By-X%7D%5Cboldsymbol%7B%5Cbeta%7D-%5Csum_%7Bi%3D1%7D%5E%7Br%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7Bu%7D_%7Bi%7D)%5E%7B%5Cprime%7D%5Cmathrm%7Bd%7D(%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%20%20%5Cright)%20%5C%5C%0A%26%3D-%5Cmathrm%7Btr%7D%5Cleft(%5Cmathrm%7Bd%7D(%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%5Cprime%7D)%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20(%5Cmathbf%7By-X%7D%5Cboldsymbol%7B%5Cbeta%7D-%5Csum_%7Bi%3D1%7D%5E%7Br%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7Bu%7D_%7Bi%7D)%5Cright)-%5Cmathrm%7Btr%7D%5Cleft((%5Cmathbf%7By-X%7D%5Cboldsymbol%7B%5Cbeta%7D-%5Csum_%7Bi%3D1%7D%5E%7Br%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7Bu%7D_%7Bi%7D)%5E%7B%5Cprime%7D%5Cmathbf%7BX%7D%5Cmathrm%7Bd%7D(%20%5Cboldsymbol%7B%5Cbeta%7D)%20%20%5Cright)%20%5C%5C%0A%26%3D-%5Cmathrm%7Btr%7D%5Cleft((%5Cmathbf%7By-X%7D%5Cboldsymbol%7B%5Cbeta%7D-%5Csum_%7Bi%3D1%7D%5E%7Br%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7Bu%7D_%7Bi%7D)%5E%7B%5Cprime%7D%5Cmathbf%7BX%7D%5Cmathrm%7Bd%7D(%20%5Cboldsymbol%7B%5Cbeta%7D)%20%20%5Cright)-%5Cmathrm%7Btr%7D%5Cleft((%5Cmathbf%7By-X%7D%5Cboldsymbol%7B%5Cbeta%7D-%5Csum_%7Bi%3D1%7D%5E%7Br%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7Bu%7D_%7Bi%7D)%5E%7B%5Cprime%7D%5Cmathbf%7BX%7D%5Cmathrm%7Bd%7D(%20%5Cboldsymbol%7B%5Cbeta%7D)%20%20%5Cright)%20%5C%5C%0A%26%3D-2%5Cmathrm%7Btr%7D%5Cleft((%5Cmathbf%7By-X%7D%5Cboldsymbol%7B%5Cbeta%7D-%5Csum_%7Bi%3D1%7D%5E%7Br%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7Bu%7D_%7Bi%7D)%5E%7B%5Cprime%7D%5Cmathbf%7BX%7D%5Cmathrm%7Bd%7D(%20%5Cboldsymbol%7B%5Cbeta%7D)%20%20%5Cright)%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%5Cpartial%20l%7D%7B%5Cpartial%20%5Cboldsymbol%7B%5Cbeta%7D%7D%20%3D%20%5Cfrac%7B1%7D%7B%5Csigma_%7B0%7D%5E%7B2%7D%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%28%5Cmathbf%7By-X%7D%5Cboldsymbol%7B%5Cbeta%7D-%5Csum_%7Bi%3D1%7D%5E%7Br%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7Bu%7D_%7Bi%7D%29%0A" /></p><p>使之为 <img src="https://math.now.sh?inline=%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> ，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%20%3D%20%5Cmathbf%7B%28X'X%29%5E%7B-%7DX'%7D%5Cleft(%20%5Cmathbf%7By%7D%20-%20%5Csum_%7Bi%3D1%7D%5E%7Br%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7Bu%7D_%7Bi%7D%20%20%5Cright)%0A" /></p><p>即</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%20%3D%20%5Cmathbf%7BX%28X'X%29%5E%7B-%7DX'%7D%5Cleft(%20%5Cmathbf%7By%7D%20-%20%5Csum_%7Bi%3D1%7D%5E%7Br%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7Bu%7D_%7Bi%7D%20%20%5Cright)%0A" /></p><p>这个公式等价于从 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 中剔除除了残差之外的随机效应，再应用普通最小二乘法得到的估计值。</p>
<p>为了完善 EM 算法的迭代步骤，我们还需要知道 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7Bu%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%20-%20%5Csum_%7Bi%3D1%7D%5E%7Br%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7Bu%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 在给定 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 时的条件期望。我们可以直接使用多变量正态分布的公式</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%28%5Cmathbf%7By%7D%20%5Cmid%20%5Cmathbf%7Bx%7D%29%20%26%3D%5Cboldsymbol%7B%5Cmu%7D_%7By%7D%2B%5Cmathbf%7B%5CSigma%7D_%7By%20x%7D%20%5CSigma_%7Bx%20x%7D%5E%7B-1%7D%5Cleft(%5Cmathbf%7Bx%7D-%5Cboldsymbol%7B%5Cmu%7D_%7Bx%7D%5Cright)%2C%20%5C%5C%0A%5Coperatorname%7Bcov%7D(%5Cmathbf%7By%7D%20%5Cmid%20%5Cmathbf%7Bx%7D)%20%26%3D%5Cmathbf%7B%5CSigma%7D_%7By%20y%7D-%5Cmathbf%7B%5CSigma%7D_%7By%20x%7D%20%5Cmathbf%7B%5CSigma%7D_%7Bx%20x%7D%5E%7B-1%7D%20%5Cmathbf%7B%5CSigma%7D_%7Bx%20y%7D%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>进行推导得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bu%7D_%7Bi%7D%20%7C%20%5Cmathbf%7By%7D%20%5Csim%20%5Cmathcal%7BN%7D%5Cleft%5B%20%5Csigma_%7Bi%7D%5E%7B2%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7BV%7D%5E%7B-1%7D%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D%29%2C%20%5Csigma_%7Bi%7D%5E%7B2%7D%5Cmathbf%7BI%7D_%7Bq_%7Bi%7D%7D%20-%20%5Csigma_%7Bi%7D%5E%7B4%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5Cright%5D%0A" /></p><p>因此我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BE%7D%28%5Cmathbf%7Bu%7D_%7Bi%7D%20%7C%20%5Cmathbf%7By%7D%29%20%3D%20%5Csigma_%7Bi%7D%5E%7B2%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7BV%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D)%0A" /></p><p>根据二次型期望公式 <img src="https://math.now.sh?inline=%5Cmathrm%7BE%7D%5Cleft%28%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BA%20y%7D%5Cright%29%3D%5Coperatorname%7Btr%7D(%5Cmathbf%7BA%7D%20%5CSigma)%2B%5Cboldsymbol%7B%5Cmu%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BA%7D%20%5Cboldsymbol%7B%5Cmu%7D" style="display:inline-block;margin: 0;"/> ，我们可以推导得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BE%7D%28%5Cmathbf%7Bu%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7Bu%7D_%7Bi%7D%7C%5Cmathbf%7By%7D%29%20%3D%20%5Csigma_%7Bi%7D%5E%7B4%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D)%5E%7B%5Cprime%7D%5Cmathbf%7BV%7D%5E%7B-1%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7BV%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D)%20%2B%20%5Cmathrm%7Btr%7D(%5Csigma_%7Bi%7D%5E%7B2%7D%5Cmathbf%7BI%7D_%7Bq_%7Bi%7D%7D%20-%20%5Csigma_%7Bi%7D%5E%7B4%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D)%0A" /></p><h2 id="ML-的-EM-算法1">ML 的 EM 算法1</h2>
<p>我们现在可以形成 ML 的 EM 算法的正式描述，其中上标 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> 为第 m 次迭代得到的估计值</p>
<p><strong>step 0</strong>:  给定一组初始值 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%280%29%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Csigma%7D%5E%7B2%280%29%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=m%3D0" style="display:inline-block;margin: 0;"/>  。</p>
<p><strong>step 1 (E 步)</strong>: 计算 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7Bu%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%20-%20%5Csum_%7Bi%3D1%7D%5E%7Br%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7Bu%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 这两个统计量的条件期望，将它们标记为 <img src="https://math.now.sh?inline=t_%7Bi%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Bs%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Chat%7Bt%7D_%7Bi%7D%5E%7B%28m%29%7D%20%26%3D%20%5Cmathrm%7BE%7D(%5Cmathbf%7Bu%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7Bu%7D_%7Bi%7D%7C%5Cmathbf%7By%7D)%7C_%7B%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cboldsymbol%7B%5Cbeta%7D%5E%7B(m)%7D%2C%20%5Cmathbf%7B%5Csigma%7D%5E%7B2%7D%3D%5Cmathbf%7B%5Csigma%7D%5E%7B2(m)%7D%7D%20%5C%5C%0A%26%3D%5Csigma_%7Bi%7D%5E%7B4(m)%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D%5E%7B(m)%7D)%5E%7B%5Cprime%7D(%5Cmathbf%7BV%7D%5E%7B(m)%7D)%5E%7B-1%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D(%5Cmathbf%7BV%7D%5E%7B(m)%7D)%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D%5E%7B(m)%7D)%20%5C%5C%0A%26%20%5Cquad%20%2B%20%5Cmathrm%7Btr%7D(%5Csigma_%7Bi%7D%5E%7B2(m)%7D%5Cmathbf%7BI%7D_%7Bq_%7Bi%7D%7D%20-%20%5Csigma_%7Bi%7D%5E%7B4(m)%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D(%5Cmathbf%7BV%7D%5E%7B(m)%7D)%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D)%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7B%5Chat%7Bs%7D%7D%5E%7B%28m%29%7D%20%26%3D%20%5Cmathrm%7BE%7D(%5Cmathbf%7By%7D%20-%20%5Csum_%7Bi%3D1%7D%5E%7Br%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%20%5Cmathbf%7Bu%7D_%7Bi%7D%7C%5Cmathbf%7By%7D)%7C_%7B%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cboldsymbol%7B%5Cbeta%7D%5E%7B(m)%7D%2C%20%5Cmathbf%7B%5Csigma%7D%5E%7B2%7D%3D%5Cmathbf%7B%5Csigma%7D%5E%7B2(m)%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7By%7D%20-%20%5Csum_%7Bi%3D1%7D%5E%7Br%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Csigma_%7Bi%7D%5E%7B2(m)%7D%20(%5Cmathbf%7BV%7D%5E%7B(m)%7D)%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D%5E%7B(m)%7D)%20%5C%5C%0A%26%3D%20%5Cmathbf%7By%7D%20-%20(%5Cmathbf%7BV%7D%5E%7B(m)%7D%20-%20%5Csigma_%7B0%7D%5E%7B2(m)%7D%5Cmathbf%7BI%7D)%20(%5Cmathbf%7BV%7D%5E%7B(m)%7D)%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D%5E%7B(m)%7D)%20%5C%5C%0A%26%3D%20%5Cmathbf%7By%7D%20-%20(%5Cmathbf%7BV%7D%5E%7B(m)%7D%20-%20%5Csigma_%7B0%7D%5E%7B2(m)%7D%5Cmathbf%7BI%7D)%20(%5Cmathbf%7BV%7D%5E%7B(m)%7D)%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D%5E%7B(m)%7D)%20%5C%5C%0A%26%3D%20%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D%5E%7B(m)%7D%2B%5Csigma_%7B0%7D%5E%7B2(m)%7D%20(%5Cmathbf%7BV%7D%5E%7B(m)%7D)%5E%7B-1%7D%20(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D%5E%7B(m)%7D)%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p><strong>step 2 (M 步)</strong>: 基于完整数据，采用最大似然法，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Csigma_%7Bi%7D%5E%7B2%28m%2B1%29%7D%20%3D%20%5Chat%7Bt%7D_%7Bi%7D%5E%7B(m)%7D%2Fq_%7Bi%7D%2C%20%5Cquad%20i%3D0%2C1%2C2%2C%5Ccdots%2Cr%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%5E%7B%28m%2B1%29%7D%7D%20%3D%20%5Cmathbf%7BX(X'X)%5E%7B-%7DX'%7D%5Cmathbf%7B%5Chat%7Bs%7D%7D_%7B(m)%7D%0A" /></p><p><strong>step 3</strong>: 如果达到了收敛标准，则将 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Chat%7B%5Csigma%7D%7D%5E%7B2%7D%20%3D%20%5Cboldsymbol%7B%5Csigma%7D%5E%7B2%28m%2B1%29%7D" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%20%3D%20%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%28m%2B1%29%7D" style="display:inline-block;margin: 0;"/> ；不然 m 递增1，返回 step 1 。</p>
<h2 id="ML-的-EM-算法2">ML 的 EM 算法2</h2>
<p>如果我们使用 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D" style="display:inline-block;margin: 0;"/> 的 ML 估计值 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Chat%7BV%7D%7D" style="display:inline-block;margin: 0;"/> ，则 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的 ML 估计值为  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%28X'%5Chat%7BV%7D%5E%7B-1%7DX%29%5E%7B-%7DX'%5Chat%7BV%7D%5E%7B-1%7Dy%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>Laird (1992) 建议在 EM 算法的迭代过程中不计算 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Chat%7Bs%7D%7D%5E%7B%28m%29%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%28m%29%7D" style="display:inline-block;margin: 0;"/> ，而只是收敛时计算一次 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> ，推导过程如下，如果上面式子中的 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%28m%29%7D" style="display:inline-block;margin: 0;"/> 均采用  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 的公式计算，即</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%28m%29%7D_%7B*%7D%20%3D%20%5Cmathbf%7BX(X'(V%5E%7B(m)%7D)%5E%7B-1%7DX)%5E%7B-%7DX'(V%5E%7B(m)%7D)%5E%7B-1%7Dy%7D%0A" /></p><p>而在计算 <img src="https://math.now.sh?inline=%5Chat%7Bt%7D_%7Bi%7D%5E%7B%28m%29%7D" style="display:inline-block;margin: 0;"/> 其中用到了 <img src="https://math.now.sh?inline=%28%5Cmathbf%7BV%7D%5E%7B(m%29%7D)%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D%5E%7B(m)%7D)" style="display:inline-block;margin: 0;"/> ，这正好是 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D%5E%7B%28m%29%7D%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D%5E%7B%28m%29%7D" style="display:inline-block;margin: 0;"/> 为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BP%5E%7B%28m%29%7D%7D%20%3D%20(%5Cmathbf%7BV%5E%7B(m)%7D%7D)%5E%7B-1%7D%20-%20(%5Cmathbf%7BV%5E%7B(m)%7D%7D)%5E%7B-1%7D%20%5Cmathbf%7BX(X'(V%5E%7B(m)%7D)%5E%7B-1%7DX)%5E%7B-%7DX'(V%5E%7B(m)%7D)%5E%7B-1%7D%7D%0A" /></p><p>因此此时在每个迭代过程中，我们不需要得到 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%28m%29%7D" style="display:inline-block;margin: 0;"/> ，我们只需要计算  <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D%5E%7B%28m%29%7D%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>这个算法其实严格来说不是 EM 算法，但是和 EM 算法差距很小，具体过程如下：</p>
<p><strong>step 0</strong>:  给定一组初始 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Csigma%7D%5E%7B2%280%29%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=m%3D0" style="display:inline-block;margin: 0;"/>  。</p>
<p><strong>step 1 (E 步)</strong>: 计算 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7Bu%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的条件期望，标记为 <img src="https://math.now.sh?inline=t_%7Bi%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Chat%7Bt%7D_%7Bi%7D%5E%7B%28m%29%7D%20%26%3D%20%5Cmathrm%7BE%7D(%5Cmathbf%7Bu%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7Bu%7D_%7Bi%7D%7C%5Cmathbf%7By%7D)%7C_%7B%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cboldsymbol%7B%5Cbeta%7D%5E%7B(m)%7D%2C%20%5Cmathbf%7B%5Csigma%7D%5E%7B2%7D%3D%5Cmathbf%7B%5Csigma%7D%5E%7B2(m)%7D%7D%20%5C%5C%0A%26%3D%5Csigma_%7Bi%7D%5E%7B4(m)%7D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%5Cmathbf%7BP%7D%5E%7B(m)%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7BP%7D%5E%7B(m)%7D%5Cmathbf%7By%7D%20%5C%5C%0A%26%20%5Cquad%20%2B%20%5Cmathrm%7Btr%7D(%5Csigma_%7Bi%7D%5E%7B2(m)%7D%5Cmathbf%7BI%7D_%7Bq_%7Bi%7D%7D%20-%20%5Csigma_%7Bi%7D%5E%7B4(m)%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D(%5Cmathbf%7BV%7D%5E%7B(m)%7D)%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D)%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p><strong>step 2 (M 步)</strong>: 基于完整数据，采用最大似然法，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Csigma_%7Bi%7D%5E%7B2%28m%2B1%29%7D%20%3D%20%5Chat%7Bt%7D_%7Bi%7D%5E%7B(m)%7D%2Fq_%7Bi%7D%2C%20%5Cquad%20i%3D0%2C1%2C2%2C%5Ccdots%2Cr%0A" /></p><p><strong>step 3</strong>: 如果达到了收敛标准，则将 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Chat%7B%5Csigma%7D%7D%5E%7B2%7D%20%3D%20%5Cboldsymbol%7B%5Csigma%7D%5E%7B2%28m%2B1%29%7D" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%20%3D%20%5Cmathbf%7BX%28X'%5Chat%7BV%7D%5E%7B-1%7DX%29%5E%7B-%7DX'%5Chat%7BV%7D%5E%7B-1%7Dy%7D" style="display:inline-block;margin: 0;"/> ；不然 m 递增1，返回 step 1 。</p>
<h2 id="EM-算法和-ML-方程组的等价性">EM 算法和 ML 方程组的等价性</h2>
<p>我们现在考虑EM 算法和 ML 方程组的等价性，首先当 EM 算法收敛时，我们有 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%3D%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%28m%2B1%29%7D%3D%5Cboldsymbol%7B%5Cbeta%7D%5E%7B(m)%7D" style="display:inline-block;margin: 0;"/>， <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Chat%7B%5Csigma%7D%5E%7B2%7D%7D%3D%5Cboldsymbol%7B%5Csigma%7D%5E%7B2%28m%2B1%29%7D%3D%5Cboldsymbol%7B%5Csigma%7D%5E%7B2(m)%7D" style="display:inline-block;margin: 0;"/> ，利用第一个等式，根据 ML 的 EM 算法1， 我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%20%3D%20%5Cmathbf%7BX%28X'X%29%5E%7B-%7DX'%7D%5Cleft%5B%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%2B%5Chat%7B%5Csigma%7D_%7B0%7D%5E%7B2%7D%20(%5Cmathbf%7B%5Chat%7BV%7D%7D%5E%7B-1%7D%20(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D)%20%5Cright%5D%0A" /></p><p>根据广义逆性质我们有 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%3D%20%5Cmathbf%7BX%28X'X%29%5E%7B-%7DX'X%7D" style="display:inline-block;margin: 0;"/> ，因此化简得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%28X'X%29%5E%7B-%7DX'%7D%20%5Cmathbf%7B%5Chat%7BV%7D%7D%5E%7B-1%7D%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%20%3D%20%5Cmathbf%7BX(X'X)%5E%7B-%7DX'%7D%20%5Cmathbf%7B%5Chat%7BV%7D%7D%5E%7B-1%7D%5Cmathbf%7By%7D%0A" /></p><p>等式左右两侧乘以 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> , 根据广义逆性质 <img src="https://math.now.sh?inline=%5Cmathbf%7BX'%7D%20%3D%20%5Cmathbf%7BX'X%28X'X%29%5E%7B-%7DX'%7D" style="display:inline-block;margin: 0;"/>, 我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX'%7D%5Cmathbf%7B%5Chat%7BV%7D%7D%5E%7B-1%7D%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%20%3D%20%5Cmathbf%7BX'%7D%20%5Cmathbf%7B%5Chat%7BV%7D%7D%5E%7B-1%7D%5Cmathbf%7By%7D%0A" /></p><p>这就是 ML 方程组中的一个式子。</p>
<p>类似地，对于 <img src="https://math.now.sh?inline=%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Aq_%7Bi%7D%20%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D%20%26%3D%20%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B4%7D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%5Cmathbf%7B%5Chat%7BP%7D%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7B%5Chat%7BP%7D%7D%5Cmathbf%7By%7D%0A%20%2B%20%5Cmathrm%7Btr%7D%28%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D%5Cmathbf%7BI%7D_%7Bq_%7Bi%7D%7D%20-%20%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B4%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D(%5Cmathbf%7B%5Chat%7BV%7D%7D%29%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D)%20%5C%5C%0A%20%26%3D%20%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B4%7D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%5Cmathbf%7B%5Chat%7BP%7D%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7B%5Chat%7BP%7D%7D%5Cmathbf%7By%7D%0A%20%2B%20q_%7Bi%7D%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D%20-%20%20%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B4%7D%20%5Cmathrm%7Btr%7D(%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D(%5Cmathbf%7B%5Chat%7BV%7D%7D)%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D)%20%5C%5C%0A%20%5Cend%7Baligned%7D%0A" /></p><p>只要 <img src="https://math.now.sh?inline=%5Chat%7B%5Csigma%7D_%7Bi%7D%5E%7B2%7D%20%5Cneq%200" style="display:inline-block;margin: 0;"/> ，我们可以简单得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7Btr%7D%28%20%5Cmathbf%7B%5Chat%7BV%7D%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%29%20%3D%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%5Cmathbf%7B%5Chat%7BP%7D%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7B%5Chat%7BP%7D%7D%5Cmathbf%7By%7D%0A" /></p><p>这是 ML 方程组中的另外一个式子。</p>
<h2 id="REML-的-EM-算法">REML 的 EM 算法</h2>
<p>我们只需要将 ML 的 EM 算法中的矩阵和向量进行以下替换：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Ctext%7Breplacing%7D%20%5Cquad%20%5Cmathbf%7By%7D%20%5Cquad%20%5Ctext%7Bby%7D%20%5Cquad%20%5Cmathbf%7BK'y%7D%20%5C%5C%0A%26%5Ctext%7Breplacing%7D%20%5Cquad%20%5Cmathbf%7BX%7D%20%5Cquad%20%5Ctext%7Bby%7D%20%5Cquad%20%5Cmathbf%7BK'X%3D0%7D%20%5C%5C%0A%26%5Ctext%7Breplacing%7D%20%5Cquad%20%5Cmathbf%7BZ%7D%20%5Cquad%20%5Ctext%7Bby%7D%20%5Cquad%20%5Cmathbf%7BK'Z%7D%20%5C%5C%0A%26%5Ctext%7Breplacing%7D%20%5Cquad%20%5Cmathbf%7BV%7D%20%5Cquad%20%5Ctext%7Bby%7D%20%5Cquad%20%5Cmathbf%7BK'VK%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>然后我们就可以从  ML 的 EM 算法2 推导得到 REML 的 EM 算法。</p>
<p>其中会应用到下面的式子</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BP%7D%3D%5Cmathbf%7BV%7D%5E%7B-1%7D-%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%3D%5Cmathbf%7BK%7D%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BK%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%0A" /></p><p>我们先推导一下ML 的 EM 算法2式子中的 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D" style="display:inline-block;margin: 0;"/> 矩阵，将其中的 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D" style="display:inline-block;margin: 0;"/> 矩阵进行替换，得到：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BP%7D%20%26%3D%5Cmathbf%7B%28K'VK%29%7D%5E%7B-1%7D-%5Cmathbf%7B(K'VK)%7D%5E%7B-1%7D%20%5Cmathbf%7B(K'X)%7D%5Cleft(%5Cmathbf%7B(K'X)%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7B(K'VK)%7D%5E%7B-1%7D%20%5Cmathbf%7B(K'X)%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7B(K'X)%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7B(K'VK)%7D%5E%7B-1%7D%20%5C%5C%0A%26%3D%5Cmathbf%7B(K'VK)%7D%5E%7B-1%7D%20%5Cquad%20%5Cbecause%20%5Cmathbf%7BK'X%3D0%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因此ML 的 EM 算法2式子中的 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ_%7Bi%7D%5E%7B%5Cprime%7DPy%20%3D%20Z_%7Bi%7D%5E%7B%5Cprime%7DK%28K'VK%29%5E%7B-1%7DK'y%20%7D" style="display:inline-block;margin: 0;"/> ，因此其在 REML 的算法中仍为 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ_%7Bi%7D%5E%7B%5Cprime%7DPy%7D" style="display:inline-block;margin: 0;"/>  不变。</p>
<p>因此，我们得到 REML 的 EM 算法步骤如下：</p>
<p><strong>step 0</strong>:  给定一组初始 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Csigma%7D%5E%7B2%280%29%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=m%3D0" style="display:inline-block;margin: 0;"/>  。</p>
<p><strong>step 1 (E 步)</strong>: 计算 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7Bu%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的条件期望，标记为 <img src="https://math.now.sh?inline=t_%7Bi%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Chat%7Bt%7D_%7Bi%7D%5E%7B%28m%29%7D%20%26%3D%20%5Cmathrm%7BE%7D(%5Cmathbf%7Bu%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7Bu%7D_%7Bi%7D%7C%5Cmathbf%7By%7D)%7C_%7B%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cboldsymbol%7B%5Cbeta%7D%5E%7B(m)%7D%2C%20%5Cmathbf%7B%5Csigma%7D%5E%7B2%7D%3D%5Cmathbf%7B%5Csigma%7D%5E%7B2(m)%7D%7D%20%5C%5C%0A%26%3D%5Csigma_%7Bi%7D%5E%7B4(m)%7D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%5Cmathbf%7BP%7D%5E%7B(m)%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7BP%7D%5E%7B(m)%7D%5Cmathbf%7By%7D%20%5C%5C%0A%26%20%5Cquad%20%2B%20%5Cmathrm%7Btr%7D(%5Csigma_%7Bi%7D%5E%7B2(m)%7D%5Cmathbf%7BI%7D_%7Bq_%7Bi%7D%7D%20-%20%5Csigma_%7Bi%7D%5E%7B4(m)%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BK%7D(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%5Cmathbf%7BV%7D%5E%7B(m)%7D%5Cmathbf%7BK%7D)%5E%7B-1%7D%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%5Cmathbf%7BZ%7D_%7Bi%7D)%20%5C%5C%0A%26%3D%5Csigma_%7Bi%7D%5E%7B4(m)%7D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%5Cmathbf%7BP%7D%5E%7B(m)%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%5Cmathbf%7BP%7D%5E%7B(m)%7D%5Cmathbf%7By%7D%20%20%2B%20%5Cmathrm%7Btr%7D(%5Csigma_%7Bi%7D%5E%7B2(m)%7D%5Cmathbf%7BI%7D_%7Bq_%7Bi%7D%7D%20-%20%5Csigma_%7Bi%7D%5E%7B4(m)%7D%20%5Cmathbf%7BZ%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D%5E%7B(m)%7D%5Cmathbf%7BZ%7D_%7Bi%7D)%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p><strong>step 2 (M 步)</strong>: 基于完整数据，采用最大似然法，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Csigma_%7Bi%7D%5E%7B2%28m%2B1%29%7D%20%3D%20%5Chat%7Bt%7D_%7Bi%7D%5E%7B(m)%7D%2Fq_%7Bi%7D%2C%20%5Cquad%20i%3D0%2C1%2C2%2C%5Ccdots%2Cr%0A" /></p><p><strong>step 3</strong>: 如果达到了收敛标准，则将 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Chat%7B%5Csigma%7D%7D%5E%7B2%7D%20%3D%20%5Cboldsymbol%7B%5Csigma%7D%5E%7B2%28m%2B1%29%7D" style="display:inline-block;margin: 0;"/> ；不然 m 递增1，返回 step 1 。</p>
<p>我们可以看到 REML 的 EM 算法与 ML 的 EM 算法只有一点不同，就是将公式中的 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 替换成了 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D" style="display:inline-block;margin: 0;"/> 。</p>
<h1>参考文献</h1>
<ol>
<li>Rencher A C, Schaalje G B. Linear models in statistics[M]. John Wiley &amp; Sons, 2008.</li>
<li>Patterson H D, Thompson R. Recovery of inter-block information when block sizes are unequal[J]. Biometrika, 1971, 58(3): 545-554.</li>
<li>Hofer A. Variance component estimation in animal breeding: a review[J]. Journal of Animal Breeding and Genetics, 1998, 115(1‐6): 247-265.</li>
<li>Misztal I. Reliable computing in estimation of variance components[J]. Journal of animal breeding and genetics, 2008, 125(6): 363-370.</li>
<li>张沅, 张勤, 家畜育种. 畜禽育种中的线性模型[M]. 北京农业大学出版社, 1993.</li>
<li>Searle S R. Large sample variances of maximum likelihood estimators of variance components using unbalanced data[J]. Biometrics, 1970: 505-524.</li>
<li>Searle S R. Notes on variance components estimation-A detailed account of maximum likelihood and kindred methodology[J]. Technical Report BU-673-M, 1979.</li>
<li>Searle S R. An overview of variance component estimation[J]. Metrika, 1995, 42(1): 215-230.</li>
<li>Searle S R, Casella G, McCulloch C E. Variance components[M]. John Wiley &amp; Sons, 2009.</li>
<li>Matsaglia G, PH Styan G. Equalities and inequalities for ranks of matrices[J]. Linear and multilinear Algebra, 1974, 2(3): 269-292.</li>
<li>Marsaglia G, Styan G P H. Rank conditions for generalized inverses of partitioned matrices[J]. Sankhyā: The Indian Journal of Statistics, Series A, 1974: 437-442.</li>
<li>Bard, Y. (1974). Nonlinear Parameter Estimation. Academic Press, New York.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
        <tag>方差组分</tag>
        <tag>REML</tag>
      </tags>
  </entry>
  <entry>
    <title>方差组分估计方法一之一般思路</title>
    <url>/posts/372fb709/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这是我重新整理方差组分算法的博客，主要是关于 EM-REML 和 AI-REML 算法。这是第一篇博客，介绍估计方差组分的一般思路。</p>
<span id="more"></span>
<h1>一般思路</h1>
<p>我们采用似然方法，查找使得<strong>对数似然函数</strong>最大化的一组方差组分，这本身是一个优化问题，严格来说是一个<strong>有约束条件</strong>的优化问题，因为找到的方差组分需要在给定的参数空间内。</p>
<p>我们是要关注对数似然函数值本身，而不是其一阶导数，这里有两个原因，第一是使得似然函数一阶导数等于0的位点可能是<strong>局部最小值，局部最大值和鞍点</strong>，仅仅是查看一阶导数，我们无法区分这三者；第二是在迭代过程中，随着一阶导数趋于0，我们可以通过对数似然函数值查看其值是否也在不断变大，从而检查我们是不是收敛于一个局部最大值。</p>
<p>如果我们采用一阶导数进行方差组分估计，对于最简单的模型（应该指的是单性状模型），最大值可能在参数空间的边界线找到；对于随机效应之间存在协方差的模型，情况更加复杂，对数似然函数的表面可能会有局部最优解。</p>
<p>一般的解决思路是使用目标函数的一阶导数或者二阶导数从而进行迭代，而这些迭代方法均有共同的特征，首先他们必须提供一个初始值，然后使用这个初始值通过迭代得到下一组值，循环这个过程直到根据某种规则停止迭代，然后将最后一组值视为 ML 或 REML 估计值。</p>
<p>因此一个好的迭代方法应该至少具有三个特征：受到初始值影响小（指初始值的变化，不影响迭代方法收敛于全局最大值），每个迭代过程计算速度快，迭代次数短。但是可惜的是，没有一个已知的技术可以保证从任意的一个初始值均可以收敛到全局最大值（<strong>说明迭代方法均受到初始值的影响</strong>）。</p>
<h1>基于导数的迭代方法</h1>
<p>基于导数的迭代方法在数值分析文献中统称为<strong>导数方法</strong>（gradient methods）</p>
<h2 id="方法基础">方法基础</h2>
<p>任何一个迭代方法的核心就是如何使用当前的参数估计值找到下一组估计值，实际上是需要做两个决定，往哪个方向走，以及走多远的问题，我们称为 <em>step direction</em> 和 <em>step size</em> 。</p>
<p>一个合理的方向选择是对数似然函数值增加最快的方向，一个合理的步长是使得似然函数值增加最大的长度。我们可以证明，似然函数增加最快的方向就是一阶导数向量指向的方向，我们称为<strong>梯度</strong>。按照这种方法进行迭代的方法称为<strong>最速上升法</strong>，但是不幸的是在实践中最速上升法效果很糟糕，需要很多次迭代才能收敛。</p>
<p>然而我们还是可以通过梯度来定义方向，通过我们会对梯度乘以一个矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D" style="display:inline-block;margin: 0;"/> 来适度修改方向，因此此时的方向为 <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D%20%5CDelta%20l" style="display:inline-block;margin: 0;"/> 。如果 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Ctheta%7D%5E%7B%28m%29%7D" style="display:inline-block;margin: 0;"/> 表示第 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> 次迭代的参数向量，那么我们可以得到迭代方程为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Ctheta%7D%5E%7B%28m%2B1%29%7D%20%3D%20%5Cboldsymbol%7B%5Ctheta%7D%5E%7B(m)%7D%20%2B%20s%5E%7B(m)%7D%20%5Cmathbf%7BM%7D%5E%7B(m)%7D%20%5Cfrac%7B%5Cpartial%7Bl%7D%7D%7B%5Cpartial%7B%5Cboldsymbol%7B%5Ctheta%7D%7D%7D%5Cbigg%7C_%7B%5Cboldsymbol%7B%5Ctheta%7D%5E%7B(m)%7D%7D%0A" /></p><p>在这个公式中， <img src="https://math.now.sh?inline=s%5E%7B%28m%29%7D" style="display:inline-block;margin: 0;"/> 是一个标量，表示第 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> 步的步长。</p>
<p>Bard (1974) 证明只要  <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D%5E%7B%28m%29%7D" style="display:inline-block;margin: 0;"/> 是正定矩阵并且没有收敛到全局最大值，那么均存在一个步长   <img src="https://math.now.sh?inline=s%5E%7B%28m%29%7D" style="display:inline-block;margin: 0;"/>  使得似然值继续增加。</p>
<h2 id="牛顿法">牛顿法</h2>
<p>吴恩达老师对牛顿法的解释比较简单明了，放置如下：</p>
<p>假设存在一个函数 f(θ): R → R，你想找到一个θ值，使得 f(θ) = 0 。 我们可以用牛顿方法使用下式来不断更新 θ 值</p>
<p style=""><img src="https://math.now.sh?from=%5Ctheta%3A%3D%5Ctheta-%5Cfrac%7Bf%28%5Ctheta%29%7D%7Bf%5E%7B%5Cprime%7D(%5Ctheta)%7D%0A" /></p><p>后面这部分就相当于目前位置与切线和X轴交点的距离。</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7Bf%28%5Ctheta%29-0%7D%7Bf%5E%7B%5Cprime%7D(%5Ctheta)%7D%20%3D%20%5Cfrac%7B%5CDelta%20f%7D%7Bf%5E%7B%5Cprime%7D(%5Ctheta)%7D%20%3D%20%7B%5CDelta%20%5Ctheta%7D%0A" /></p><p>因此每一次就是迭代到切线与X轴的交点，画图如下</p>
<p><img src="1.png" alt=""></p>
<p>如果你要找某个函数的最大值或最小值，比如似然函数 L(θ) 。你需要计算<strong>一阶导数等于0</strong>的地方，因此你可以将上面的 f(θ) 替换为 L’(θ)</p>
<p style=""><img src="https://math.now.sh?from=%5Ctheta%3A%3D%5Ctheta-%5Cfrac%7B%5Cell%5E%7B%5Cprime%7D%28%5Ctheta%29%7D%7B%5Cell%5E%7B%5Cprime%20%5Cprime%7D(%5Ctheta)%7D%0A" /></p><p>上面的 θ 只是单个数字，我们将其推广为一般化的向量。</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Ctheta%7D%3A%3D%5Cboldsymbol%7B%5Ctheta%7D-%5Cmathbf%7BH%7D%5E%7B-1%7D%20%5Cnabla_%7B%5Cboldsymbol%7B%5Ctheta%7D%7D%20%5Cell%28%5Cboldsymbol%7B%5Ctheta%7D%29%0A" /></p><p>这里 H 是 <strong>Hessian</strong> 矩阵，其元素为：</p>
<p style=""><img src="https://math.now.sh?from=H_%7Bi%20j%7D%3D%5Cfrac%7B%5Cpartial%5E%7B2%7D%20%5Cell%28%5Ctheta%29%7D%7B%5Cpartial%20%5Ctheta_%7Bi%7D%20%5Cpartial%20%5Ctheta_%7Bj%7D%7D%0A" /></p><p>牛顿法的优点是迭代次数少，其缺点是需要计算二阶导数，每一轮迭代计算速度慢。</p>
<p>Marquardt (1963) 年提出了一种综合牛顿法和最速上升法的一种方法，公式如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Ctheta%7D%5E%7B%28m%2B1%29%7D%20%3D%20%5Cboldsymbol%7B%5Ctheta%7D%5E%7B(m)%7D%20-%5Cleft(%20%5Cmathbf%7BH%7D%5E%7B(m)%7D%20%2B%20%20%5Ctau%5E%7B(m)%7D%20%5Cmathbf%7BI%7D%5E%7B(m)%7D%5Cright)%5E%7B-1%7D%20%5Cfrac%7B%5Cpartial%7Bl%7D%7D%7B%5Cpartial%7B%5Cboldsymbol%7B%5Ctheta%7D%7D%7D%5Cbigg%7C_%7B%5Cboldsymbol%7B%5Ctheta%7D%5E%7B(m)%7D%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Ctau%5E%7B%28m%29%7D" style="display:inline-block;margin: 0;"/> 是一个标量，如果  <img src="https://math.now.sh?inline=%5Ctau%5E%7B%28m%29%7D" style="display:inline-block;margin: 0;"/> 很小，那么就近似于牛顿法；如果   <img src="https://math.now.sh?inline=%5Ctau%5E%7B%28m%29%7D" style="display:inline-block;margin: 0;"/> 比较大，那么就接近最速上升法的方法。通常的建议是随着似然函数值的不断增加，  <img src="https://math.now.sh?inline=%5Ctau%5E%7B%28m%29%7D" style="display:inline-block;margin: 0;"/> 逐渐变小（越来越趋于牛顿法）。如果似然函数值没有增加，那么需要不断增加  <img src="https://math.now.sh?inline=%5Ctau%5E%7B%28m%29%7D" style="display:inline-block;margin: 0;"/> 的值，直到似然函数值增加。</p>
<h2 id="scoring-法">scoring 法</h2>
<p>为了减少计算二级导数的计算量，我们可以将 <img src="https://math.now.sh?inline=-%5Cmathbf%7BH%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 替换为信息矩阵的逆矩阵，即将黑塞矩阵替换为其期望，公式如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Ctheta%7D%5E%7B%28m%2B1%29%7D%20%3D%20%5Cboldsymbol%7B%5Ctheta%7D%5E%7B(m)%7D%20%2B%20%5Cleft%5B%5Cmathbf%7BI%7D(%5Cboldsymbol%7B%5Ctheta%7D%5E%7B(m)%7D)%5Cright%5D%5E%7B-1%7D%20%5Cfrac%7B%5Cpartial%7Bl%7D%7D%7B%5Cpartial%7B%5Cboldsymbol%7B%5Ctheta%7D%7D%7D%5Cbigg%7C_%7B%5Cboldsymbol%7B%5Ctheta%7D%5E%7B(m)%7D%7D%0A" /></p><h2 id="超出参数空间的补救">超出参数空间的补救</h2>
<p>如果在某次迭代中出现负数 (<img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 或 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> 或 <strong>AI</strong> 矩阵不正定)，Jennrich and Schluchter (1986) 建议使用 “step-halving” 方法，即将步长减半，如果下一次得到了合理的结果则继续往下迭代，不然则将步长继续减半。例如在 AI 算法，我们可以添加一个步长的参数 <img src="https://math.now.sh?inline=%5Clambda%20%3C%201" style="display:inline-block;margin: 0;"/> ，使得 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Ckappa%7D%5E%7B%28m%2B1%29%7D%20%3D%20%5Cmathbf%7B%5Ckappa%7D%5E%7B(m)%7D%20%2B%20%5Clambda%20%5Cmathbf%7BI%7D(%5Cmathbf%7B%5Ckappa%7D%5E%7B(m)%7D)%5E%7B-1%7D%5Cmathbf%7BU%7D(%5Cmathbf%7B%5Ckappa%7D%5E%7B(m)%7D)" style="display:inline-block;margin: 0;"/>  。某软件就采用了控制步长的方式来避免 <code>overshooting</code> ，一开始 AI 算法的 <img src="https://math.now.sh?inline=%5Clambda" style="display:inline-block;margin: 0;"/> 值设为  0.1 ，随着每一步的迭代逐渐接近 1 。</p>
<p>另外一种补救方式是改成使用 EM 算法（初始值使用上一次 EM 算法的估计值）来获得更好的初始值。</p>
<p>还有一种情况是，如果AI 估计值其与上次的参数估计值差距过大（计算公式如下，我们称其为 <em>convergence criterion</em>），那么此时也可以更换使用 EM 算法。</p>
<p style=""><img src="https://math.now.sh?from=%5CDelta%5E%7B%28m%29%7D%20%3D%20%5Csqrt%7B%5Cfrac%7B%5Csum%20%5Cleft(%20%5Ctheta_%7Bi%7D%5E%7B(m)%7D%20-%20%5Ctheta_%7Bi%7D%5E%7B(m-1)%7D%20%20%5Cright)%5E%7B2%7D%7D%7B%5Csum%20%5Ctheta_%7Bi%7D%5E%7B(m)%5E%7B2%7D%7D%7D%7D%0A" /></p><h1>参考文献</h1>
<ol>
<li>
<p>Searle S R, Casella G, McCulloch C E. Variance components[M]. John Wiley &amp; Sons, 2009.</p>
</li>
<li>
<p>Ng A. CS229 Lecture notes[J]. CS229 Lecture notes, 2000.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
        <tag>方差组分</tag>
        <tag>REML</tag>
      </tags>
  </entry>
  <entry>
    <title>多态信息含量PIC</title>
    <url>/posts/19d449e8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>介绍多态信息含量PIC的计算公式</p>
<span id="more"></span>
<p>多态信息含量 (polymorphism information content，PIC) 是衡量遗传标记多态性的一个指标，类似的常见指标还有最小等位基因频率。</p>
<p>Bostein 在 1980 年提出 PIC 的计算公式如下</p>
<p style=""><img src="https://math.now.sh?from=1-%5Csum_%7Bi%3D1%7D%5E%7Bn%7Dp_%7Bi%7D%5E%7B2%7D-%5Csum_%7Bi%3D1%7D%5E%7Bn-1%7D%5Csum_%7Bj%3Di%2B1%7D%5E%7Bn%7D2p_%7Bi%7D%5E%7B2%7Dp_%7Bj%7D%5E%7B2%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=p_%7Bi%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=p_%7Bj%7D" style="display:inline-block;margin: 0;"/> 分别是第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 个和第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 个等位基因型的频率，<img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 是等位基因数目</p>
<h1>二等位标记的PIC</h1>
<p>对于二等位标记，例如 SNP，设其最小等位基因频率 (MAF) 为 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> , 则 PIC 关于 MAF 的函数如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Ctext%7BPIC%7D%20%26%3D%201%20-%20x%5E%7B2%7D%20-%20%281-x%29%5E%7B2%7D%20-%202x%5E%7B2%7D(1-x)%5E%7B2%7D%20%5C%5C%0A%26%3D%20-2x%5E%7B4%7D%20%2B%204x%5E%7B3%7D-4x%5E%7B2%7D%20%2B%202x%0A%5Cend%7Baligned%7D%0A" /></p><p>我想看看这个函数的图像是什么样子，通过求一阶导和二阶导也没有很快看出来，就找了一个<a href="https://www.desmos.com/calculator?lang=zh-CN">函数作图网站</a> ，其函数图像如下，看上去最高点应该是 (0.5, 0.375) ，将 <img src="https://math.now.sh?inline=x%3D0.5" style="display:inline-block;margin: 0;"/> 代入其一阶导可以得到一阶导为 0，所以证明其最大值就是  <img src="https://math.now.sh?inline=f%280.5%29%20%3D%200.375" style="display:inline-block;margin: 0;"/> 。</p>
<p>因此对于二等位标记，PIC 和 MAF 是成正比的，MAF 越大，PIC 也越大。</p>
<p><img src="1.png" alt=""></p>
<h1>参考文献</h1>
<ol>
<li>Botstein D, White R L, Skolnick M, et al. Construction of a genetic linkage map in man using restriction fragment length polymorphisms[J]. American journal of human genetics, 1980, 32(3): 314.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>多态信息含量</tag>
        <tag>PIC</tag>
      </tags>
  </entry>
  <entry>
    <title>使用blupf90构建母体效应模型</title>
    <url>/posts/11a64ff8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>如何使用 blupf90 软件构建母体效应模型。</p>
<span id="more"></span>
<h1>母体效应模型理论</h1>
<p>有一些性状可以收到母体的影响很大，比如断奶重，那么我们就可以将母体的效应加入到模型中。母体效应又可以分为两类，母体遗传效应和母体环境效应。</p>
<p>一般的模型模型如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%20%3D%20%5Cmathbf%7BXb%2BZu%2BWm%2BSp%2Be%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> 是固定效应，<img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> 是个体直接加性效应，<img src="https://math.now.sh?inline=%5Cmathbf%7Bm%7D" style="display:inline-block;margin: 0;"/> 是母体遗传效应，<img src="https://math.now.sh?inline=%5Cmathbf%7Bp%7D" style="display:inline-block;margin: 0;"/> 是母体永久环境效应，<img src="https://math.now.sh?inline=%5Cmathbf%7Be%7D" style="display:inline-block;margin: 0;"/> 是残差。</p>
<p>相应的协方差矩阵如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7Bvar%7D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%20%0A%5Cmathbf%7Bu%7D%20%5C%5C%0A%5Cmathbf%7Bm%7D%20%5C%5C%0A%5Cmathbf%7Bp%7D%20%5C%5C%0A%5Cmathbf%7Be%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%20%0A%5Cmathbf%7BA%7D%5Csigma_%7Bd%7D%5E%7B2%7D%20%26%20%20%5Cmathbf%7BA%7D%5Csigma_%7Bdm%7D%5E%7B2%7D%20%26%20%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7BA%7D%5Csigma_%7Bdm%7D%5E%7B2%7D%20%26%20%20%5Cmathbf%7BA%7D%5Csigma_%7Bm%7D%5E%7B2%7D%20%26%20%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%20%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BI%7D%5Csigma_%7Bp%7D%5E%7B2%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%20%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BI%7D%5Csigma_%7Be%7D%5E%7B2%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>其中个体直接加性效应和母体效应的加性协方差矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BG%7D_%7B0%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%20%0A%5Csigma_%7Bd%7D%5E%7B2%7D%20%26%20%5Csigma_%7Bdm%7D%5E%7B2%7D%20%5C%5C%0A%5Csigma_%7Bdm%7D%5E%7B2%7D%20%26%20%5Csigma_%7Bm%7D%5E%7B2%7D%20%5C%5C%0A%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><h1>准备文件</h1>
<p>其它准备文件和正常的个体动物模型一样，只需要修改 renumf90 的参数卡。</p>
<p>参数卡只需新增一个关键词 OPTIONAL，这个关键词必须放在加性效应EFFECT的后面，如下图所示。这里最多可以加入三个效应，<code>pe</code> (永久环境效应)，<code>mat</code> (母体遗传效应)， <code>mpe</code> （母体环境效应）。</p>
<p><strong>如果表型个体缺少系谱（母本为 0），需要手动剔除这些个体的表型</strong>（相当于存在因子缺失）。我测试了一下，BLUPF90 会将缺失的母本也分配一个虚拟的重编码个体号，就是说也当成一个已知的个体，这应该不符合我们的预期。</p>
<p>如果你选了<code>mat</code>（母系效应），那么 (CO)VARIANCES 地方必须放一个 <img src="https://math.now.sh?inline=2%20%5Ctimes%202" style="display:inline-block;margin: 0;"/> 的矩阵（单性状模型），包括个体直接加性效应和母体加性效应 (<strong>注意顺序，第一个是个体加性效应，第二个是母体加性效应</strong>)；如果你选了 <code>mpe</code>，那么你应该把永久环境效应方差放在 (C0)VARIANCES_MPE中；如果你选了 <code>pe</code>，那么你应该把永久环境效应方差放在 (C0)VARIANCES_PE中。</p>
<p>按照上面的母体效应模型，我们应该往模型中加入 <code>mat</code> 和 <code>mpe</code> 。</p>
<p><img src="1.png" alt=""></p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>BLUPF90</tag>
        <tag>母体效应</tag>
      </tags>
  </entry>
  <entry>
    <title>理财知识</title>
    <url>/posts/dea5e814/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>之前整理的关于股票，基金，税务，保险的相关知识，基本上也都是从网上复制来的。</p>
<span id="more"></span>
<h1>A股股票交易手续费</h1>
<p><a href="https://zhuanlan.zhihu.com/p/38360510">https://zhuanlan.zhihu.com/p/38360510</a></p>
<h2 id="印花税">印花税</h2>
<p>股票交易金额的千分之一（0.1%），只在股票<strong>卖出</strong>的时候收取。</p>
<h2 id="过户费">过户费</h2>
<p>过户费为成交<strong>股票数量</strong>的万分之六（0.06%），<strong>不足1元按1元计算</strong>（要买到16手以上，过户费才高于1元），<strong>买入和卖出均要收取</strong>。</p>
<p>目前上交所（60开头）收取，<strong>深交所不收取</strong>。</p>
<h2 id="佣金">佣金</h2>
<p>按交易金额的一定比例收取，一般不足5元按5元收费。</p>
<p><strong>买入和卖出均收取</strong>。</p>
<h2 id="小结">小结</h2>
<p>过户费基本很少，可以忽略不记，目前我就是买入卖出就2块（深交所还不用出）（额，我看了我的交割单，过户费是0.5元）。佣金免五后收取金额也很少（万分之一，买入卖出平均一万也就2块）。</p>
<p>成本最高的是<strong>印花税</strong>，以一万为例，卖出就10块。</p>
<p>也就是说目前我<strong>买入股票手续费很低</strong>，<strong>卖出要交千分之一的印花税</strong>，其它可忽略不计。</p>
<p>话说回来，都2023年了，我股票到现在都还套着呢，当然我买股票也是出于玩票的心理。我深刻地认识到，一般人估计都很难从A股挣到什么钱，总体算下来不赔钱就算不错了。</p>
<h1>分红</h1>
<p><a href="https://zhuanlan.zhihu.com/p/107545268">https://zhuanlan.zhihu.com/p/107545268</a></p>
<p>这个链接讲的很清楚。</p>
<h2 id="分红概念">分红概念</h2>
<p><a href="https://www.zhihu.com/question/314361762/answer/1061573703">https://www.zhihu.com/question/314361762/answer/1061573703</a></p>
<p>在<strong>股权登记日</strong>（<strong>即统计和确认参加股息红利的日期</strong>）收盘前购买了股票就可以享有本期股票分红。</p>
<p>一般分红后第二天会进行除息，因此投资者的总资产没有增加，而且因为分红需要缴税，总资产甚至是下降的。</p>
<p><strong>分红的意义就在于大肥羊得到了实实在在的现金，而投资者持有的股票数量没有发生变化。</strong></p>
<h2 id="红利税">红利税</h2>
<p>红利税不是拿到分红时缴纳的，而是在拿到分红后，卖出「获得分红的股数」的第二天，由证券公司代扣代缴。</p>
<ol>
<li>
<p>没有拿到分红，不用担心有红利税支出，只有拿到分红后，才需要考虑红利税；</p>
</li>
<li>
<p>分红时不会立即支出红利税，而是在卖出这些拿了分红的股数后，第二天由证券公司进行代扣代缴。</p>
</li>
</ol>
<p><strong>股票分红扣税跟股票的持有时间长短有关，且分红后不会立马扣税，待卖出时才扣税。</strong></p>
<p><strong>1、持股期限在1个月（含）以内的，卖出时扣除分红所得的20%作为个人所得税；</strong></p>
<p><strong>2、持股期限在1个月以上至1年（含）的，卖出时扣除分红所得的10%作为个人所得税；</strong></p>
<p><strong>3、持股期限超过1年的，不需要缴纳个人所得税；</strong></p>
<p><strong>4、股票分多次买入的，一律按照先进先出原则一一对应计算持股时间；</strong></p>
<p><strong>5、当日有买进卖出的（即所谓做T），收盘后系统计算你当日净额，净额为买入，则记录为今日新买入，净额为卖出，则按照先进先出原则，算成你卖出了你最早买入的对应数量持股，并考虑是否扣税和税率问题。</strong></p>
<p><strong>6、以上扣除的税会在股票卖出时由券商直接扣除。</strong></p>
<p>简单总结一下：没有拿到分红的股票不用扣税，拿到分红的股票不是直接扣税，而是卖出时扣税（两个链接有一点出入在于是卖出时直接扣除红利税还是第二天扣除）；做T看当日净额；<strong>先进先出原则</strong>；<strong>持股超一年，不用缴税</strong>。</p>
<h1>ETF 与 LOF 基金的区别</h1>
<p><a href="https://zhuanlan.zhihu.com/p/37425870">https://zhuanlan.zhihu.com/p/37425870</a></p>
<p>ETF即交易型开放式指数基金，通常又被称为交易所交易基金（Exchange Traded Funds），是一种在交易所上市交易的、基金份额可变的一种开放式基金。</p>
<p>LOF，英文全称是&quot;ListedOpen-EndedFund&quot;,汉语称为&quot;上市型开放式基金&quot;。也就是上市型开放式基金发行结束后，投资者既可以在指定网点申购与赎回基金份额,也可以在交易所买卖该基金。</p>
<p><img src="1.png" alt="1"></p>
<h2 id="ETF">ETF</h2>
<p>ETF基金有两种交易方式，第一种是像股票一样买卖，<strong>买卖仅收佣金费用</strong>；第二种是用一揽子股票申购赎回，在做ETF申购时，投资者需要提前购买后指数对应的一篮子股票，然后用一篮子股票来申购ETF的份额；赎回时，投资者拿到手的也不是现金，而是对应的一堆股票，<strong>申购赎回费用没找到资料</strong>。<strong>第二种方式对现金量有要求，一般要50万以上</strong>，所以目前与我无关。一般人只能是第一种方式，类似于买卖股票。</p>
<p>其实ETF基金还有一个费用，那就是运行费用。比如 300ETF (SH510300)的费用是 管理费：0.5%，托管费：0.1%，指数使用费：0.03%。**这些费用会在每天的净值中直接减去。**可以查你想买的ETF的招募说明书查看具体的费率。也就是说，ETF基金默认扣除了年化0.6%的收益，这个比例还可以。</p>
<p>ETF基金的特点：</p>
<ol>
<li>
<p>只能场内交易</p>
</li>
<li>
<p>跟踪指数</p>
</li>
<li>
<p>几乎百分百买股票，现金很少，比如512690股票比例是97.65%</p>
</li>
<li>
<p>运营费用低</p>
</li>
</ol>
<h2 id="LOF">LOF</h2>
<p>LOF基金也一样是两种交易方式，第一种是场内买卖，和ETF一样，<strong>买卖只收佣金</strong>；第二种是<strong>场外</strong>申购赎回，<strong>直接现金交易</strong>，也就是说投资者是用现金买基金份额，然后用份额赎回得到现金，另外门槛低，1000起步。</p>
<p>场内和场外购买，管理费用一样。管理费和托管费都是在基金资产里计提的，二级市场里买卖的都是扣费后的。</p>
<p><a href="https://www.zhihu.com/question/56018270">https://www.zhihu.com/question/56018270</a></p>
<p>LOF 特点：</p>
<ol>
<li>交易场所既可以是场内，也可以是场外</li>
<li>无法满仓。由于需要应对赎回，一般股票比例95%</li>
<li>运营费用相对ETF较高。<s>LOF的管理费大部分为0.75%，托管费为0.15%。</s>（这个数据旧了，以富国天惠为例，管理费1.5%，托管费0.25%。）这是因为LOF基金申赎时需要买卖股票，从而提高了交易成本。而ETF直接使用股票申赎的，交易成本低。</li>
<li>可以不跟踪指数，主动买股票</li>
</ol>
<p>总的来说个人感觉LOF不如ETF。知乎上说LOF的优势就在于可以不开户，方便普通投资者购买，这个对我不成立。</p>
<h2 id="小结-2">小结</h2>
<ul>
<li>ETF和LOF 都是场内购买划算，主要是省了买入卖出的费用（运营费用不变）。</li>
<li><strong>用途</strong>：ETF只能追踪指数，而LOF可以是主动型基金。</li>
<li><strong>费用</strong>： ETF和LOF 买入卖出都只收佣金，ETF运营费用很低，而且好像基本都是0.6%; <strong>LOF不同基金收费不同（具体查看该基金的招募说明书），但比ETF高</strong></li>
<li><strong>风险</strong>：ETF 风险更低，因为是宽基基金，哪怕某个股票暴雷也不影响；LOF就不同，这个就要看基金经理了。</li>
</ul>
<h1>税务管理</h1>
<h2 id="个人所得税">个人所得税</h2>
<p><a href="https://www.youtube.com/watch?v=NanTBuduuiA">https://www.youtube.com/watch?v=NanTBuduuiA</a></p>
<p>本文为看李永乐老师视频的笔记</p>
<h3 id="应纳税所得额">应纳税所得额</h3>
<p>应纳税所得额 = 综合所得额 - 免征 - 扣除</p>
<ul>
<li>
<p>综合所得额 ：工资 + 劳务费×80% + 稿费×80%×70% + 特许使用费×80%</p>
<p>劳务费大概就是做副业的钱，特许使用费大概是把版权借给其他公司使用的钱</p>
</li>
<li>
<p>免征：目前是一年6万，所有人都一样</p>
</li>
<li>
<p>扣除：分为专项扣除和附加扣除</p>
<ol>
<li>
<p>专项：三险一金等</p>
</li>
<li>
<p>附加：子女教育（1.2万/年）</p>
<pre><code>   	继续教育（考证，4800/年，考上了3600/年）

   		大病医疗（自付&gt;1.5万，超出部分不交税，最多8万）

         房贷（必须首套，定额，1.2万/年）

   		 房租（省会、直辖市等1.8万，普通城市1.32万）（房租和房贷只能选一个）

         赡养老人（独生子女2.4万/年，非独生最多1.2万/年)
</code></pre>
</li>
</ol>
</li>
</ul>
<h3 id="所得税计算">所得税计算</h3>
<p>按<strong>应纳税所得额</strong>划分不同的税率。累进税制。</p>
<p><img src="2.png" alt="2"></p>
<p>比如你应纳税所得额为5万，那么你前3.6万按照3%计算，后1.4万按照10%计算。</p>
<h3 id="汇算清缴">汇算清缴</h3>
<h4 id="工资">工资</h4>
<p>工资：收入 - 免征 - 扣除 （公司预扣的所得税）</p>
<p>补加个人所得税的情况：假如一个人一年内同时在两家公司工作，两家公司只按他在本公司的工资缴税，就导致他的累进税率较低。</p>
<h4 id="劳务">劳务</h4>
<p>退税主要是劳务费，劳务费的应纳税收入计算方法为，如果劳务报酬不超过800为0，800-4000时则为劳务费-800元，超过4000为劳务费×80%。</p>
<p>劳务费预扣税率为：应纳税所得额不超过20000为20%，超过2万至5万的部分为30%，超过5万的部分为40%。</p>
<p>劳务税的<strong>预扣</strong>税率比工资高得多。</p>
<h4 id="清缴">清缴</h4>
<p>第一种情况如果你换了工作，一年内在两家公司工作，那么你可能要补加税费。但是可以通过<strong>填附加扣除降低税费</strong>。</p>
<p>劳务费就可以<strong>退税</strong>。</p>
<h3 id="不需申报的情况">不需申报的情况</h3>
<ol>
<li>年收入 ≤ 12万</li>
<li>补税 ≤ 400</li>
</ol>
<h3 id="年终奖计税">年终奖计税</h3>
<p>年终奖有两种计税方式，第一种是单列，第二种计入汇总中，两种可能有差异，视情况来选择。</p>
<h1>保险</h1>
<p>我个人只是买了一个百万医疗险，买保险需要认真查看相关的保险内容，看看自己符不符合全部条件，尽量避免需要出险的时候不能赔偿。</p>
<h2 id="理赔时保险公司调查健康状况">理赔时保险公司调查健康状况</h2>
<p><a href="https://zhuanlan.zhihu.com/p/90282213">https://zhuanlan.zhihu.com/p/90282213</a></p>
<p>保险公司考虑到成本，一般不会在投保前进行严格的调查，如果年龄、地区、职业符合要求，并且健康告知通过，那么一般都可以正常投保。除非发生了高保额、财务状况与保额不符的情况，保险公司才会注意到投保人。</p>
<p>但是投保前不查并不代表理赔时不查，毕竟一个是你给保险公司交钱，另一个就是保险公司给你钱。<strong>这也就是我们所说的买保险时的“宽进严出”——买保险的时候容易买，可是理赔的时候就没有那么容易理赔了。</strong></p>
<p>所以，理赔时的调查，才是重中之重。</p>
<p><strong>保险公司一般会根据理赔金额的大小、投保时间与申请理赔时间的长短、是否存在骗保的可能性，来确定是否进行更详尽的审查。</strong></p>
<p>一般来讲，保险公司有3种方式获知投保人的既往病史：</p>
<p>a）<strong>调查社保就医记录</strong></p>
<p>b）<strong>调查医院门诊住院记录</strong></p>
<p>c）<strong>调查同业的投保和理赔记录</strong></p>
]]></content>
      <categories>
        <category>生活</category>
        <category>理财</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>我的个人数据备份之路</title>
    <url>/posts/1536238c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>整理一下我的个人数据存储和备份方法的历程。</p>
<span id="more"></span>
<h1>目的</h1>
<p>其实我不是单纯地涉及备份，还包括资料如何存储，如何获取的问题。因为我的目的主要是两个，第一是防止数据丢失，这是最基本的目的；第二就是我想要获取相应的资料时需要容易获取容易找到，因为存储的目的是为了使用，如果不方便使用那就也没有价值了。</p>
<h1>数据分类</h1>
<p>我目前的数据应该可以主要分为三类：</p>
<ol>
<li>往期数据：主要是研究生，本科的东西，多且杂，利用频率较低。</li>
<li>工作数据：工作电脑上的东西</li>
<li>个人文档：自己整理的文档，基本是 markdown 格式。</li>
</ol>
<p>下面基于每一块数据进行讨论。</p>
<h1>备份方法</h1>
<h2 id="往期数据">往期数据</h2>
<p>这个最简单，百度网盘 + 移动硬盘。</p>
<p>因为目前利用频率低，需要的时候再去找就行，查找多花点时间也没事。</p>
<h2 id="工作数据">工作数据</h2>
<p>我的习惯是将所有东西放在桌面，然后将桌面移动到 D 盘（防止系统损坏，需要重装电脑）。</p>
<p>然后在桌面上建立相应的文件夹，每周对其中重要的文件夹进行打包压缩，然后压缩包再上传到服务器。这样可以说是三备，相同的数据存放在个人电脑未压缩的文件夹，个人电脑里的压缩包（放在了另一个磁盘里），服务器里的压缩包三个地方。只要我的工作电脑和服务器不是同时损坏（这应该是非常小概率的事件），我最多就损失一周的工作量。</p>
<h2 id="个人文档">个人文档</h2>
<p>这里又可以细分为两块，短文档和长文档。</p>
<h3 id="短文档">短文档</h3>
<p>对于短文档，我目前最终使用的解决方案是 <code>hexo</code> + <code>onedrive</code> 。</p>
<p>我这个网页就是 hexo 搭建的个人博客，将文档发布在我的这个博客上，这样只要有网络就可以访问，很方便。但是还有一个小问题就是，我在写新的文档时可能需要复制之前文档中的公式（因为不想自己重新打公式），但是我是无法从网页上复制公式的，我还需要去获取原始的 markdown 文件。</p>
<p>因此我进一步使用了  <code>onedrive</code> ，我一开始是将这个博客的东西都搬移到了  <code>onedrive</code> ，然后我发现由于同步不及时的原因，  <code>onedrive</code> 容易产生一堆的副本文件，因此又把博客迁移回去了（汗！）。</p>
<p>后来在 B站视频 <a href="https://www.bilibili.com/video/BV1Q5411x7SR/?vd_source=584d44ba7fed271fb82848e7894a53c8">【神器】C盘拯救者 - FolderMove - 妈妈再也不怕我C盘不够用啦</a>  发现可以通过符号链接的方式使用   <code>onedrive</code>  备份其它文件夹的内容。我就去<a href="https://foldermove.com/">官网</a> 下载了 foldermove 软件，将博客的文件夹 _posts 移动了    <code>onedrive</code>  目录下（原位置会留下一个符号链接），然后更新博客内容， <code>hexo</code>  和  <code>onedrive</code> 就会保持同步，我在其它电脑上可以通过登录 <code>onedrive</code>来查看原始的 markdown 文件。</p>
<p>对于个人博客的全部原始文件，压缩后使用个人电脑+移动硬盘保存。</p>
<h3 id="长文档">长文档</h3>
<p>对于长文档，我目前使用的解决方案是  <code>onedrive</code> 。</p>
<p>我一开始也尝试过将长文档放在个人博客上，但是加载很慢，尤其是图片特别多的文档，于是便放弃了。</p>
<p>之后尝试过飞书，但是我的文档里往往包含图片，放在飞书上我需要将图片一个一个地黏贴过去，太麻烦了，于是也放弃了。</p>
<p>最终就还是用  <code>onedrive</code> 保存，不需要做什么修改，只需要图片使用相对路径，然后用 typora 正常打开就行了。</p>
<h1>总结</h1>
<ol>
<li>
<p>硬盘有价，数据无价，重要数据的备份意识不可少。</p>
</li>
<li>
<p>除了备份以外，也要考虑自己获取这些数据的难易程度。</p>
<p>按照我使用的这些方式来看，获取程度从易到难排名的话，首先是 <code>hexo</code> 博客最容易（条件只是网络），然后是 <code>onedrive</code> 和百度网盘 (网络+一台电脑) ，然后是个人电脑（因为我使用了远程软件，远程的话需要这台电脑保持开机状态，以及知道远程软件的账号秘密），最后才是移动硬盘。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客提交百度谷歌收录</title>
    <url>/posts/8b726d4e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近发现百度上搜索不到我的博客，原来是一直没有弄搜索引擎收录的原因，就捣鼓了一下。</p>
<span id="more"></span> 
<h1>百度收录</h1>
<p>访问<a href="https://link.zhihu.com/?target=https%3A//ziyuan.baidu.com/">百度搜索资源平台官网</a>，注册或者登陆百度账号，依次选择【用户中心】-【站点管理】，添加你的网站</p>
<p>选择文件验证，将文件放到 Source 根目录下。</p>
<p>选择 HTML标签验证，放到<code>head.ejs</code>（D:\Desktop\blog\themes\ayer\layout_partial\head.ejs），<code>&lt;head&gt;</code>与 <code>&lt;/head&gt;</code>标签之间。</p>
<p>两种方式，这两种方式我都失败了，都提示<code>原因：301 网页存在跳转。</code></p>
<p>尝试对网页 <a href="https://vincerezhou.github.io">https://vincerezhou.github.io</a> 进行收录，失败</p>
<p>尝试对网页 <a href="https://vincere.fun">https://vincere.fun</a> （去除 www）进行收录，文件验证失败原因如下，选择HTML标签验证，</p>
<blockquote>
<p>原因：验证的文件内容错误。<br>
问题分析&amp;解决办法： 验证文件的内容与我们提供的不符，请确定是原样上传搜索资源平台的问题，检查方式：访问验证文件——查看源代码检查，部分服务器会自动加上一些内容导致校验失败。</p>
</blockquote>
<p>有人说应该这么做</p>
<blockquote>
<p>网上大多数的说法都是说直接把该文件放到Hexo博客根目录的source目录下，然后编译打包上传到远程仓库，但是事实上这种做法是有问题的，当执行<code>hexo g</code>生成静态界面的时候，hexo会把多余的内容添加到source目录下的这个html验证文件中，导致百度、谷歌验证失败。</p>
<h3 id="正确做法">正确做法</h3>
<p>验证文件存放在Hexo博客根目录的source目录下，在验证文件头部添加<code>layout: false</code>，以谷歌验证文件为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">layout: false</span><br><span class="line">---</span><br><span class="line">google-site-verification: googlexxxxxx.html</span><br></pre></td></tr></table></figure>
<p>这样<code>hexo g</code>执行成功后，这个html验证文件中就不会有多余的内容，然后执行<code>hexo d</code>上传到远程仓库，这样百度、谷歌都验证成功了，为了保证一直验证成功，建议不要删除这个验证文件。</p>
</blockquote>
<p>选择HTML标签验证，放到<code>head.ejs</code>（D:\Desktop\blog\themes\ayer\layout_partial\head.ejs），<code>&lt;head&gt;</code>与 <code>&lt;/head&gt;</code>标签之间，<strong>成功了</strong>。</p>
<blockquote>
<p><a href="https://vincere.xn--fun-zw2ey91ewf1dnwva">https://vincere.fun验证成功</a>！</p>
<p>建议您向百度搜索主动推送资源，缩短爬虫发现网页链接时间。<a href="https://ziyuan.baidu.com/linksubmit/index">提交资源</a></p>
</blockquote>
<h2 id="提交百度搜索">提交百度搜索</h2>
<h3 id="sitemap-提交">sitemap 提交</h3>
<ol>
<li>执行命令，安装站点地图生成插件。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-generator-sitemap --save</span><br><span class="line">cnpm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在博客根目录下的配置文件<code>_config.yml</code>中修改 ·<code>url:</code> 部分为真实网址</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://vincere.fun</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在博客根目录下的配置文件<code>_config.yml</code>中配置 sitemap</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># automatically generate sitemap</span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>
<p>执行<code>hexo g -d</code>，会在<code>博客根目录/public</code>中生成两个文件， <code>sitemap.xml</code> 文件是搜索引擎通用的 sitemap 文件，<code>baidusitemap.xml</code> 是百度专用的 sitemap 文件。然后访问 <code>你的首页/sitemap.xml</code> 或者  <code>你的首页/baidusitemap.xml</code>  就可以看到网站地图了</p>
</li>
<li>
<p>然后来到百度站长平台的 sitemap 提交页面，将你的 sitemap 地址提交即可（好像要两个都提交，一天只能提交一个文件），如果成功的话状态会显示为正常，初次提交要等几分钟，sitemap.xml 相比 baidusitemap.xml 来说等待时间也会更长，如果以后你博客有新的文章或其他页面，可以点击<strong>手动更新文件</strong>，更新一下新的 sitemap。</p>
</li>
</ol>
<h4 id="解决无法抓取的问题">解决无法抓取的问题</h4>
<p>提交完 sitemap 后显示无法抓取，按照网上的说法设置如下，好像还是显示无法抓取。</p>
<blockquote>
<p>配置完sitemap可能还是不行，然后通过google搜索后发现，大家都有遇到类似的问题，根据大神的说法，可能不是<code>Hexo</code>的问题，应该是<code>Github Pages</code>的问题。<code>Github Pages</code>默认是基于<code>Jekyll</code>构建的，如果不是基于此方式构建的，<code>Github Pages</code>会忽略掉一些文件和文件夹。</p>
<p>因此，<strong>在Hexo博客的source文件夹下添加一个.nojekyll空文件</strong>，该文件会告诉<code>Github Pages</code>当前网站不是基于<code>Jekyll</code>构建的，不要忽略掉一些文件和文件夹。然后<strong>打开根目录下的_config.yml，找到include files区域，修改成下面这样</strong>，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Include / Exclude file(s)</span><br><span class="line">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span><br><span class="line">include: </span><br><span class="line"> - .nojekyll</span><br><span class="line">exclude: null</span><br><span class="line">ignore: null</span><br></pre></td></tr></table></figure>
<p>然后再<strong>在<code>deploy</code>区域，添加<code>ignore_hidden</code>属性并设为<code>false</code></strong> （我设置了两行，一个 -type 下面放一行）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  # 上面部分省略</span><br><span class="line">  ignore_hidden: false</span><br></pre></td></tr></table></figure>
<p>这样在<code>hexo g</code>时就会把<code>.nojekyll</code>文件添加到<code>public</code>目录下，<code>hexo d</code>时会把<code>.nojekyll</code>文件推送到github上。</p>
</blockquote>
<h3 id="主动提交">主动提交</h3>
<p>首先在博客根目录中安装插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure>
<p>然后在根目录 <code>_config.yml</code> 文件里写入以下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 提交百度搜索</span><br><span class="line">baidu_url_submit:</span><br><span class="line">  count: 10               # 提交最新的多少个链接</span><br><span class="line">  host: vincere.fun    # 在百度站长平台中添加的域名</span><br><span class="line">  token: your_token      # 秘钥</span><br><span class="line">  path: baidu_urls.txt   # 文本文档的地址， 新链接会保存在此文本文档里</span><br></pre></td></tr></table></figure>
<p>其中的 <code>token</code> 可以在【链接提交】-【API提交】下面看到，接口调用地址最后面 <code>token=xxxxx</code> 即为你的 <code>token</code></p>
<blockquote>
<p>推送接口<br>
接口调用地址：<a href="http://data.zz.baidu.com/urls?site=https://vincere.fun&amp;token=">http://data.zz.baidu.com/urls?site=https://vincere.fun&amp;token=</a>???</p>
</blockquote>
<p>然后在博客根目录下的配置文件<code>_config.yml</code>中修改 ·<code>url:</code> 部分为真实网址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://vincere.fun</span><br></pre></td></tr></table></figure>
<p>最后，加入新的 deployer：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">***</span><br><span class="line">***	</span><br><span class="line">- type: baidu_url_submitter                         # 这是新加的主动推送</span><br></pre></td></tr></table></figure>
<p>最后执行 <code>hexo g -d</code> 部署一遍即可实现主动推送，推送成功的标志是：在执行部署命令最后会显示类似如下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;remain&quot;</span>:89,<span class="string">&quot;success&quot;</span>:10&#125;</span><br><span class="line">INFO  Deploy <span class="keyword">done</span>: baidu_url_submitter</span><br></pre></td></tr></table></figure>
<p>这表示有 10 个页面已经主动推送成功，remain 的意思是当天剩余的可推送 89 条。</p>
<h1>谷歌收录</h1>
<p>进入 <a href="https://search.google.com/search-console/about">google search console</a> ，按照类似的方式进行收录，我是用了 CNAME 的方式。</p>
<h2 id="提交sitemap">提交sitemap</h2>
<p>点击<a href="https://www.google.com/webmasters/tools/sitemap-list">添加站点地图</a>，选择要添加的网站，如下，点击【提交】。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://vincere.fun/sitemap.xml</span><br></pre></td></tr></table></figure>
<p>会提示正在处理数据，请在一天左右的时间内再次检查。</p>
<h1>参考文献</h1>
<ol>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/100922816">https://zhuanlan.zhihu.com/p/100922816</a></p>
</li>
<li>
<p><a href="https://marmalade.vip/baidugoogleseo.html">https://marmalade.vip/baidugoogleseo.html</a></p>
</li>
<li>
<p><a href="https://chengzhy.github.io/2022/hexo-seo-note/">https://chengzhy.github.io/2022/hexo-seo-note/</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>软件学习</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>软件学习</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>R包-BGLR</title>
    <url>/posts/d4668321/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>BGLR 是一个使用贝叶斯方法进行基因组选择的一个 R 包。</p>
<span id="more"></span>
<h1>支持的表型</h1>
<ul>
<li>连续性状（censored or not）</li>
<li>分类性状：二分类（标记为01或者12），或者有序多分类（标记为 1到 n ）</li>
</ul>
<p>表型可以有缺失，但是自变量不能有缺失。</p>
<h1>支持的模型</h1>
<p>支持的回归模型如下，这里 <code>Flat</code> 就是固定因子，</p>
<p><img src="1.png" alt=""></p>
<h1>函数参数</h1>
<p>使用 BGLR 函数具有以下参数，其中除了表型向量 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 其余参数具有默认值。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">BGLR<span class="punctuation">(</span>y<span class="punctuation">,</span> response_type <span class="operator">=</span> <span class="string">&quot;gaussian&quot;</span><span class="punctuation">,</span> a<span class="operator">=</span><span class="literal">NULL</span><span class="punctuation">,</span> b<span class="operator">=</span><span class="literal">NULL</span><span class="punctuation">,</span>ETA <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> nIter <span class="operator">=</span> <span class="number">1500</span><span class="punctuation">,</span></span><br><span class="line">burnIn <span class="operator">=</span> <span class="number">500</span><span class="punctuation">,</span> thin <span class="operator">=</span> <span class="number">5</span><span class="punctuation">,</span> saveAt <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> S0 <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">df0 <span class="operator">=</span><span class="number">5</span><span class="punctuation">,</span> R2 <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">,</span> weights <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">verbose <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> rmExistingFiles <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> groups<span class="operator">=</span><span class="literal">NULL</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>以下是主要参数的说明：</p>
<ul>
<li>
<p><code>y</code> : 表型向量，允许有缺失 NA 。</p>
</li>
<li>
<p><code>response_type</code> : 表型向量的类型，“gaussian” 或 “ordinal”</p>
</li>
<li>
<p><code>ETA</code> : 一个双层列表(list)，用于指定自变量，默认是只有截距，具体用法见下面的例子。</p>
<p>里面的每一个子列表表示一种类型的自变量，其中 <code>X</code> 是相应的设计矩阵（可以用 <code>model.matrix</code> 语法，见下面应用中的例子），<code>model</code> 是使用的模型（<code>FIXED</code> ，<code>BRR</code>，<code>BayesA</code>, <code>BL</code>，<code>BayesB</code>, <code>BayesC</code>）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ETA<span class="operator">=</span><span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span>X<span class="operator">=</span>W<span class="punctuation">,</span> model<span class="operator">=</span><span class="string">&quot;FIXED&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line"><span class="built_in">list</span><span class="punctuation">(</span>X<span class="operator">=</span>Z<span class="punctuation">,</span>model<span class="operator">=</span><span class="string">&quot;BL&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>nIter,burnIn, thin</code>:  (integer) the number of iterations, burn-in and thinning .</p>
</li>
<li>
<p><code>saveAt</code> : 字符串，输出文件前缀。</p>
</li>
</ul>
<h1>输出</h1>
<p>BGLR 函数会返回一个列表，其中有后验均值估计值及其标准误估计值，其元素包括:</p>
<ul>
<li><code>y</code> ：表型</li>
<li><code>whichNa</code> ：y 中缺失元素的索引</li>
<li><code>varE</code> 和  <code>SD.varE</code> ： 残差及其标准误</li>
<li><code>fit</code> ：模型拟合情况</li>
</ul>
<p>同时也会输出一些文件，为某些数值的采样结果，用于用户评估收敛情况。举例而言，<code>mu.dat</code> 就是截距的采样结果。</p>
<h1>应用举例</h1>
<p>BGLR 自带了两个数据集（小鼠和小麦）</p>
<ul>
<li>小鼠数据中包含 1814 个个体， 10346 个 SNP</li>
<li>小麦数据中包含 599 个个体</li>
</ul>
<h2 id="连续表型">连续表型</h2>
<p>使用小鼠数据，其模型为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%20%3D%20%5Cmathbf%7B1%7D%20%5Cmu%20%2B%20%5Cmathbf%7BX%7D_%7B1%7D%20%5Cboldsymbol%7B%5Cbeta%7D_%7B1%7D%20%2B%20%5Cmathbf%7BX%7D_%7B2%7D%20%5Cboldsymbol%7B%5Cbeta%7D_%7B2%7D%20%2B%20%2B%20%5Cmathbf%7BX%7D_%7B3%7D%20%5Cboldsymbol%7B%5Cbeta%7D_%7B3%7D%20%2B%20%5Cmathbf%7Be%7D%0A" /></p><p>其中：</p>
<ul>
<li><img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 为性别和窝大小的效应，为固定因子</li>
<li><img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> 为笼子的效应，视为随机因子（先验分布为正态分布）</li>
<li><img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> 为标记的效应，先验分布为 double-exponential</li>
</ul>
<p><img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D_%7B1%7D%2C%5Cmathbf%7BX%7D_%7B2%7D%2C%20%5Cmathbf%7BX%7D_%7B3%7D" style="display:inline-block;margin: 0;"/> 为相应的设计矩阵。</p>
<p>使用 BGLR 的脚本如下，注意这里的 <code>ETA</code> 部分使用了 <code>model.matrix</code> 函数的语法来生成设计矩阵。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1# Loading and preparing the input data</span></span><br><span class="line">library<span class="punctuation">(</span>BGLR<span class="punctuation">)</span>; data<span class="punctuation">(</span>mice<span class="punctuation">)</span>;</span><br><span class="line">Y<span class="operator">&lt;-</span>mice.pheno; X<span class="operator">&lt;-</span>mice.X; A<span class="operator">=</span>mice.A;</span><br><span class="line">y<span class="operator">&lt;-</span>Y<span class="operator">$</span>Obesity.BMI; y<span class="operator">&lt;-</span><span class="punctuation">(</span>y<span class="operator">-</span>mean<span class="punctuation">(</span>y<span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">/</span>sd<span class="punctuation">(</span>y<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2# Setting the linear predictor</span></span><br><span class="line">ETA<span class="operator">&lt;-</span><span class="built_in">list</span><span class="punctuation">(</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="operator">~</span>factor<span class="punctuation">(</span>GENDER<span class="punctuation">)</span><span class="operator">+</span>factor<span class="punctuation">(</span>Litter<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">data<span class="operator">=</span>Y<span class="punctuation">,</span>model<span class="operator">=</span><span class="string">&#x27;FIXED&#x27;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line"><span class="built_in">list</span><span class="punctuation">(</span><span class="operator">~</span>factor<span class="punctuation">(</span>cage<span class="punctuation">)</span><span class="punctuation">,</span>data<span class="operator">=</span>Y<span class="punctuation">,</span> model<span class="operator">=</span><span class="string">&#x27;BRR&#x27;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line"><span class="built_in">list</span><span class="punctuation">(</span>X<span class="operator">=</span>X<span class="punctuation">,</span> model<span class="operator">=</span><span class="string">&#x27;BL&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3# Fitting the model</span></span><br><span class="line">fm<span class="operator">&lt;-</span>BGLR<span class="punctuation">(</span>y<span class="operator">=</span>y<span class="punctuation">,</span>ETA<span class="operator">=</span>ETA<span class="punctuation">,</span> nIter<span class="operator">=</span><span class="number">12000</span><span class="punctuation">,</span> burnIn<span class="operator">=</span><span class="number">2000</span><span class="punctuation">)</span></span><br><span class="line">save<span class="punctuation">(</span>fm<span class="punctuation">,</span>file<span class="operator">=</span><span class="string">&#x27;fm.rda&#x27;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>这里基因型数据就是一个矩阵，一行是一个样本（与 <code>y</code> 保持一致），一列是一个位点（基因型为 012，缺失用该列均值填充）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> X<span class="punctuation">[</span><span class="number">0</span><span class="operator">:</span><span class="number">5</span><span class="punctuation">,</span> <span class="number">0</span><span class="operator">:</span><span class="number">5</span><span class="punctuation">]</span></span><br><span class="line">           rs3683945_G rs3707673_G rs6269442_G rs6336442_G rs13475700_A</span><br><span class="line">A048005080           <span class="number">1</span>           <span class="number">1</span>           <span class="number">1</span>           <span class="number">1</span>            <span class="number">0</span></span><br><span class="line">A048006063           <span class="number">1</span>           <span class="number">1</span>           <span class="number">2</span>           <span class="number">1</span>            <span class="number">1</span></span><br><span class="line">A048006555           <span class="number">2</span>           <span class="number">0</span>           <span class="number">2</span>           <span class="number">2</span>            <span class="number">0</span></span><br><span class="line">A048007096           <span class="number">1</span>           <span class="number">1</span>           <span class="number">1</span>           <span class="number">1</span>            <span class="number">1</span></span><br><span class="line">A048010273           <span class="number">2</span>           <span class="number">0</span>           <span class="number">2</span>           <span class="number">2</span>            <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>然后我们可以从输出的列表中提取结果，其中</p>
<ul>
<li><code>#1#</code> 部分是提取所有位点的效应估计值及其标准误，这里因为标记效应是第 3 个自变量，因此使用 <code>fm$ETA[[3]]</code> 。</li>
<li><code>#2#</code> 部分是个体的基因型值（所有位点加性效应的总和）与表型的散点图。</li>
<li><code>#3#</code> 部分是提取模型的拟合情况（DIC）和残差</li>
<li><code>#4#</code> 部分是提取后验分布的采样结果。</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1# Estimated Marker Effects &amp; posterior SDs</span></span><br><span class="line">par<span class="punctuation">(</span>mfrow<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">bHat<span class="operator">&lt;-</span> fm<span class="operator">$</span>ETA<span class="punctuation">[[</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">$</span>b</span><br><span class="line">SD.bHat<span class="operator">&lt;-</span> fm<span class="operator">$</span>ETA<span class="punctuation">[[</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">$</span>SD.b</span><br><span class="line">plot<span class="punctuation">(</span>bHat<span class="operator">^</span><span class="number">2</span><span class="punctuation">,</span> ylab<span class="operator">=</span><span class="string">&#x27;Estimated Squared-Marker Effect&#x27;</span><span class="punctuation">,</span></span><br><span class="line">type<span class="operator">=</span><span class="string">&#x27;o&#x27;</span><span class="punctuation">,</span>cex<span class="operator">=</span><span class="number">.5</span><span class="punctuation">,</span>col<span class="operator">=</span><span class="number">4</span><span class="punctuation">,</span>main<span class="operator">=</span><span class="string">&#x27;Marker Effects&#x27;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2# Predictions</span></span><br><span class="line"><span class="comment"># Total prediction</span></span><br><span class="line"><span class="comment"># yHat&lt;-fm$yHat</span></span><br><span class="line"><span class="comment"># tmp&lt;-range(c(y,yHat))</span></span><br><span class="line"><span class="comment"># plot(yHat~y,xlab=&#x27;Observed&#x27;,ylab=&#x27;Predicted&#x27;,col=2,</span></span><br><span class="line"><span class="comment"># xlim=tmp,ylim=tmp); abline(a=0,b=1,col=4,lwd=2)</span></span><br><span class="line"><span class="comment"># Just the genomic part</span></span><br><span class="line">gHat<span class="operator">&lt;-</span>X<span class="operator">%*%</span>fm<span class="operator">$</span>ETA<span class="punctuation">[[</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">$</span>b</span><br><span class="line">tmp<span class="operator">&lt;-</span><span class="built_in">range</span><span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span>y<span class="punctuation">,</span>gHat<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>gHat<span class="operator">~</span>y<span class="punctuation">,</span>xlab<span class="operator">=</span><span class="string">&#x27;Phenotype&#x27;</span><span class="punctuation">,</span></span><br><span class="line">ylab<span class="operator">=</span><span class="string">&#x27;Predicted Genomic Value&#x27;</span><span class="punctuation">,</span>col<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">xlim<span class="operator">=</span>tmp<span class="punctuation">,</span>ylim<span class="operator">=</span>tmp<span class="punctuation">)</span>; abline<span class="punctuation">(</span>a<span class="operator">=</span><span class="number">0</span><span class="punctuation">,</span>b<span class="operator">=</span><span class="number">1</span><span class="punctuation">,</span>col<span class="operator">=</span><span class="number">4</span><span class="punctuation">,</span>lwd<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3# Godness of fit and related statistics</span></span><br><span class="line">fm<span class="operator">$</span>fit</span><br><span class="line">fm<span class="operator">$</span>varE <span class="comment"># compare to var(y)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4# Trace plots</span></span><br><span class="line">list.files<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># Residual variance</span></span><br><span class="line">varE<span class="operator">&lt;-</span>scan<span class="punctuation">(</span><span class="string">&#x27;varE.dat&#x27;</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>varE<span class="punctuation">,</span>type<span class="operator">=</span><span class="string">&#x27;o&#x27;</span><span class="punctuation">,</span>col<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span>cex<span class="operator">=</span><span class="number">.5</span><span class="punctuation">,</span>ylab<span class="operator">=</span><span class="built_in">expression</span><span class="punctuation">(</span>var<span class="punctuation">[</span>e<span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">)</span>;</span><br><span class="line">abline<span class="punctuation">(</span>h<span class="operator">=</span>fm<span class="operator">$</span>varE<span class="punctuation">,</span>col<span class="operator">=</span><span class="number">4</span><span class="punctuation">,</span>lwd<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span>;</span><br><span class="line">abline<span class="punctuation">(</span>v<span class="operator">=</span>fm<span class="operator">$</span>burnIn<span class="operator">/</span>fm<span class="operator">$</span>thin<span class="punctuation">,</span>col<span class="operator">=</span><span class="number">4</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># lambda (regularization parameter of the Bayesian Lasso)</span></span><br><span class="line">lambda<span class="operator">&lt;-</span>scan<span class="punctuation">(</span><span class="string">&#x27;ETA_3_lambda.dat&#x27;</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>lambda<span class="punctuation">,</span>type<span class="operator">=</span><span class="string">&#x27;o&#x27;</span><span class="punctuation">,</span>col<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span>cex<span class="operator">=</span><span class="number">.5</span><span class="punctuation">,</span>ylab<span class="operator">=</span><span class="built_in">expression</span><span class="punctuation">(</span>lambda<span class="punctuation">)</span><span class="punctuation">)</span>;</span><br><span class="line">abline<span class="punctuation">(</span>h<span class="operator">=</span>fm<span class="operator">$</span>ETA<span class="punctuation">[[</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">$</span>lambda<span class="punctuation">,</span>col<span class="operator">=</span><span class="number">4</span><span class="punctuation">,</span>lwd<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span>;</span><br><span class="line">abline<span class="punctuation">(</span>v<span class="operator">=</span>fm<span class="operator">$</span>burnIn<span class="operator">/</span>fm<span class="operator">$</span>thin<span class="punctuation">,</span>col<span class="operator">=</span><span class="number">4</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>画图结果见下面，这里图3以及图4和文献中的结果不一样，文献中总共有 24000 个点，但是我得到的 ‘varE.dat’ 和 ‘ETA_3_lambda.dat’ 均只有 2400 个结果，暂时不清楚原因。</p>
<p><img src="2.png" alt=""></p>
<h2 id="分类表型">分类表型</h2>
<p>对于分类变量，我们需要设置 <code>response_type='ordinal' </code>，我们使用小麦的数据进行分析如下。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1# Loading and preparing the input data</span></span><br><span class="line">library<span class="punctuation">(</span>BGLR<span class="punctuation">)</span>; data<span class="punctuation">(</span>wheat<span class="punctuation">)</span>;</span><br><span class="line">Y<span class="operator">&lt;-</span>wheat.Y; X<span class="operator">&lt;-</span>wheat.X; A<span class="operator">&lt;-</span>wheat.A;</span><br><span class="line">y<span class="operator">&lt;-</span>Y<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">tst<span class="operator">&lt;-</span>sample<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span>nrow<span class="punctuation">(</span>X<span class="punctuation">)</span><span class="punctuation">,</span>size<span class="operator">=</span><span class="number">150</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2# Binary outcome</span></span><br><span class="line">yBin<span class="operator">&lt;-</span>ifelse<span class="punctuation">(</span>y<span class="operator">&gt;</span><span class="number">0</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">)</span></span><br><span class="line">yBinNA<span class="operator">&lt;-</span>yBin ; yBinNA<span class="punctuation">[</span>tst<span class="punctuation">]</span><span class="operator">&lt;-</span><span class="literal">NA</span></span><br><span class="line">ETA<span class="operator">&lt;-</span><span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span>X<span class="operator">=</span>X<span class="punctuation">,</span>model<span class="operator">=</span><span class="string">&#x27;BL&#x27;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">fmBin<span class="operator">&lt;-</span>BGLR<span class="punctuation">(</span>y<span class="operator">=</span>yBinNA<span class="punctuation">,</span>response_type<span class="operator">=</span><span class="string">&#x27;ordinal&#x27;</span><span class="punctuation">,</span> ETA<span class="operator">=</span>ETA<span class="punctuation">,</span></span><br><span class="line">nIter<span class="operator">=</span><span class="number">1200</span><span class="punctuation">,</span>burnIn<span class="operator">=</span><span class="number">200</span><span class="punctuation">)</span></span><br><span class="line">head<span class="punctuation">(</span>fmBin<span class="operator">$</span>probs<span class="punctuation">)</span></span><br><span class="line">par<span class="punctuation">(</span>mfrow<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">boxplot<span class="punctuation">(</span>fmBin<span class="operator">$</span>probs<span class="punctuation">[</span><span class="operator">-</span>tst<span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span><span class="operator">~</span>yBin<span class="punctuation">[</span><span class="operator">-</span>tst<span class="punctuation">]</span><span class="punctuation">,</span>main<span class="operator">=</span><span class="string">&#x27;Training&#x27;</span><span class="punctuation">,</span>ylab<span class="operator">=</span><span class="string">&#x27;Estimated prob.&#x27;</span><span class="punctuation">)</span></span><br><span class="line">boxplot<span class="punctuation">(</span>fmBin<span class="operator">$</span>probs<span class="punctuation">[</span>tst<span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span><span class="operator">~</span>yBin<span class="punctuation">[</span>tst<span class="punctuation">]</span><span class="punctuation">,</span>main<span class="operator">=</span><span class="string">&#x27;Testing&#x27;</span><span class="punctuation">,</span> ylab<span class="operator">=</span><span class="string">&#x27;Estimated prob.&#x27;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3# Ordinal outcome</span></span><br><span class="line">yOrd<span class="operator">&lt;-</span>ifelse<span class="punctuation">(</span>y<span class="operator">&lt;</span>quantile<span class="punctuation">(</span>y<span class="punctuation">,</span><span class="number">1</span><span class="operator">/</span><span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span>ifelse<span class="punctuation">(</span>y<span class="operator">&lt;</span>quantile<span class="punctuation">(</span>y<span class="punctuation">,</span><span class="number">3</span><span class="operator">/</span><span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">yOrdNA<span class="operator">&lt;-</span>yOrd ; yOrdNA<span class="punctuation">[</span>tst<span class="punctuation">]</span><span class="operator">&lt;-</span><span class="literal">NA</span></span><br><span class="line">ETA<span class="operator">&lt;-</span><span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span>X<span class="operator">=</span>X<span class="punctuation">,</span>model<span class="operator">=</span><span class="string">&#x27;BL&#x27;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">fmOrd<span class="operator">&lt;-</span>BGLR<span class="punctuation">(</span>y<span class="operator">=</span>yOrdNA<span class="punctuation">,</span>response_type<span class="operator">=</span><span class="string">&#x27;ordinal&#x27;</span><span class="punctuation">,</span> ETA<span class="operator">=</span>ETA<span class="punctuation">,</span></span><br><span class="line">nIter<span class="operator">=</span><span class="number">1200</span><span class="punctuation">,</span>burnIn<span class="operator">=</span><span class="number">200</span><span class="punctuation">)</span></span><br><span class="line">head<span class="punctuation">(</span>fmOrd<span class="operator">$</span>probs<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>分析过程和上面一样，输出结果中 <code>fmBin$ETA[[1]]$b</code> 为标记效应，<code>fmBin$prob</code> 给出每个样本估计表型是0或者1的概率（不清楚怎么计算的），如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> head<span class="punctuation">(</span>fmBin<span class="operator">$</span>prob<span class="punctuation">)</span></span><br><span class="line">             <span class="number">0</span>         <span class="number">1</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="punctuation">]</span> <span class="number">0.4488623</span> <span class="number">0.5511377</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="punctuation">]</span> <span class="number">0.6177665</span> <span class="number">0.3822335</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="punctuation">]</span> <span class="number">0.6119654</span> <span class="number">0.3880346</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span><span class="punctuation">]</span> <span class="number">0.3914834</span> <span class="number">0.6085166</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="punctuation">]</span> <span class="number">0.3705525</span> <span class="number">0.6294475</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">6</span><span class="punctuation">,</span><span class="punctuation">]</span> <span class="number">0.4130708</span> <span class="number">0.5869292</span></span><br></pre></td></tr></table></figure>
<p>上面脚本中给出了参考群和验证群的真实表型和预测概率的箱线图，如下</p>
<p><img src="3.png" alt=""></p>
<p>我想看一下所有样本的加性效应值结果，发现它和 <code>fmBin$yHat</code> 结果是一样的，因为 <code>fmBin$mu</code> 等于 0  。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> gHat<span class="operator">&lt;-</span>X<span class="operator">%*%</span>fmBin<span class="operator">$</span>ETA<span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">$</span>b</span><br><span class="line"><span class="operator">&gt;</span> head<span class="punctuation">(</span>gHat<span class="punctuation">)</span></span><br><span class="line">          <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="punctuation">]</span> <span class="operator">-</span><span class="number">1.359382</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="punctuation">]</span> <span class="operator">-</span><span class="number">1.828429</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="punctuation">]</span> <span class="operator">-</span><span class="number">1.810299</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span><span class="punctuation">]</span> <span class="operator">-</span><span class="number">1.204968</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">5</span><span class="punctuation">,</span><span class="punctuation">]</span> <span class="operator">-</span><span class="number">1.152511</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">6</span><span class="punctuation">,</span><span class="punctuation">]</span> <span class="operator">-</span><span class="number">1.272660</span></span><br><span class="line"><span class="operator">&gt;</span> head<span class="punctuation">(</span>fmBin<span class="operator">$</span>yHat<span class="punctuation">)</span></span><br><span class="line">      <span class="number">775</span>      <span class="number">2166</span>      <span class="number">2167</span>      <span class="number">2465</span>      <span class="number">3881</span>      <span class="number">3889</span></span><br><span class="line"><span class="operator">-</span><span class="number">1.359382</span> <span class="operator">-</span><span class="number">1.828429</span> <span class="operator">-</span><span class="number">1.810299</span> <span class="operator">-</span><span class="number">1.204968</span> <span class="operator">-</span><span class="number">1.152511</span> <span class="operator">-</span><span class="number">1.272660</span></span><br><span class="line"><span class="operator">&gt;</span> fmBin<span class="operator">$</span>mu</span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>自己查看了一下  <code>fmBin$yHat</code> 和  <code>fmBin$prob</code> 的相关系数在 99.9% 以上，二者应该是一致的。而且，我发现有一个  <code>fmBin$threshold</code> 为 -1.5 ，计算 <img src="https://math.now.sh?inline=%5CPhi%28yHat%20%2B%201.5%29" style="display:inline-block;margin: 0;"/> （这里 <img src="https://math.now.sh?inline=%5CPhi" style="display:inline-block;margin: 0;"/> 是标准正态分布的累积分布函数）和     <code>fmBin$prob</code> 很相似，但是不完全一样。</p>
<p>改成使用 BayesC 方法，就是将脚本中的 <code>model='BL'</code> 改为 <code>model='BayesC'</code> ，结果见下图，比上面感觉好一点。</p>
<p><img src="4.png" alt=""></p>
<h1>参考文献</h1>
<ol>
<li>
<p>Pérez P, de Los Campos G. Genome-wide regression and prediction with the BGLR statistical package[J]. Genetics, 2014, 198(2): 483-495.</p>
</li>
<li>
<p>Pérez P, de los Campos G. BGLR: a statistical package for whole genome regression and prediction[J]. Genetics, 2014, 198(2): 483-495.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>R</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>STR亲权鉴定指标</title>
    <url>/posts/e2974541/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>利用微卫星标记 (STR) 可以进行亲权鉴定，这里主要是介绍其中用到的一些指标。</p>
<span id="more"></span>
<h1>亲权鉴定</h1>
<p>先看几个概念：</p>
<p><strong>三联体亲权鉴定</strong> (parentage testing of trios)：被检测男子、孩子生母与孩子，或者被检测女子，孩子生父与孩子的亲权鉴定</p>
<p><strong>二联体亲权鉴定</strong> (parentage testing of duos)：被检测男子与孩子，或被检测女子与孩子的亲权鉴定</p>
<h2 id="排除概率">排除概率</h2>
<p><strong>排除概率</strong> （power of exclusion, PE）：不是孩子生父或生母的随机个体，能够被遗传标记排除血缘关系的概率。简单地说，就是使用单个标记能将假父亲（非生父）正确排除的概率。</p>
<p>排除概率是对于单个标记而言的，在 SF/Z JD0105001-2016 《亲权鉴定技术规范》给出的公式如下（下面推导过程有更加清晰的公式）</p>
<p><img src="1.png" alt=""></p>
<p><strong>累积排除概率</strong> （cumulative power of exclusion, CPE）：顾名思义，就是使用所有位点的累积排除概率，其计算公式如下，其中 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> 为标记数目</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BCPE%7D%20%3D%201%20%20-%20%5Cprod_%7Bi%3D1%7D%5E%7Bm%7D%281-%5Cmathrm%7BPE%7D_%7Bi%7D%29%0A" /></p><p>这个公式解释一下，<img src="https://math.now.sh?inline=1-%5Cmathrm%7BPE%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 就是标记 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 不能排除随机样本是真实亲本的概率，所有位点连乘的结果就是所有位点都不能排除随机样本的概率，1减去这个值就是至少有一个位点能够排除随机样本的概率。</p>
<p>排除概率是针对标记而言的，标记的多态性越好则排除概率越高。</p>
<p>如果累积排除概率较低，说明标记数目不够，需要继续增加标记数目。</p>
<h3 id="排除概率公式推导过程">排除概率公式推导过程</h3>
<p>根据 Fung (2002) 的文献，我找到了排除概率公式的推导过程。</p>
<p>我们假设一个标记有 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个等位碱基 <img src="https://math.now.sh?inline=A_%7B1%7D%2C%20%5Ccdots%2C%20A_%7Bn%7D" style="display:inline-block;margin: 0;"/> ，相应的等位基因频率为 <img src="https://math.now.sh?inline=p_%7B1%7D%2C%20%5Ccdots%2C%20p_%7Bn%7D" style="display:inline-block;margin: 0;"/> ，假设一个孩子和其母亲在这个位点的基因型标记为 <img src="https://math.now.sh?inline=G_%7BC%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=G_%7BM%7D" style="display:inline-block;margin: 0;"/> ，举个例子，假设 <img src="https://math.now.sh?inline=G_%7BM%7D%20%3D%20A_%7B1%7DA_%7B2%7D" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=G_%7BC%7D%20%3D%20A_%7B1%7DA_%7B1%7D" style="display:inline-block;margin: 0;"/> ，因此任何没有 <img src="https://math.now.sh?inline=A_%7B1%7D" style="display:inline-block;margin: 0;"/> 基因的男性都可以被排除（不是这个孩子的父亲），此时的排除概率我们定义为 <code>individual probability of exclusion(IPE)</code> 为 <img src="https://math.now.sh?inline=%5Cmathrm%7BIPE%7D%20%3D%20%281-p_%7B1%7D%29%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，即 <img src="https://math.now.sh?inline=%281-p_%7B1%7D%29%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 的男性群体可以被排除，即</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BPr%7D%28%5Ctext%7Ba%20random%20man%20is%20excluded%7D%20%5C%20%7C%20%5C%20G_%7BM%7D%2CG_%7BC%7D%29%20%3D%20(1-p_%7B1%7D)%5E%7B2%7D%0A" /></p><p>而这个母子对组合出现的概率为（计算过程）</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BPr%7D%28%20G_%7BM%7D%3DA_%7B1%7DA_%7B2%7D%2CG_%7BC%7D%3DA_%7B1%7DA_%7B1%7D%29%3D%20%5Cmathrm%7BPr%7D(G_%7BC%7D)%20%20%5Cmathrm%7BPr%7D(G_%7BM%7D%7CG_%7BC%7D)%20%3D%20p_%7B1%7D%5E%7B2%7Dp_%7B2%7D%0A" /></p><p>因此我们可以通过对所有的母子对组合进行加权求和，从而得到 PE （这个我懒得推导了）</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AQ_1%20%26%20%3D%5Csum_%7BG_M%2C%20G_C%7D%20%5Coperatorname%7BPr%7D%5Cleft%28%5Ctext%20%7B%20a%20random%20man%20is%20excluded%20%7D%20%5Cmid%20G_M%2C%20G_C%5Cright%29%20%5C%5C%0A%26%20%5Ctimes%20%5Coperatorname%7BPr%7D%5Cleft(G_M%2C%20G_C%5Cright)%20%5C%5C%0A%26%20%3D%5Csum_%7Bi%3D1%7D%5En%20p_i%5Cleft(1-p_i%2Bp_i%5E2%5Cright)%5Cleft(1-p_i%5Cright)%5E2%20%5C%5C%0A%26%20%2B%5Csum_%7Bi%3D1%7D%5E%7Bn-1%7D%20%5Csum_%7Bj%3Di%2B1%7D%5En%20p_i%20p_j%5Cleft(p_i%2Bp_j%5Cright)%5Cleft(1-p_i-p_j%5Cright)%5E2%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>一个等价的式子为</p>
<p style=""><img src="https://math.now.sh?from=Q_1%3D%5Csum_%7Bi%3D1%7D%5En%20p_i%5Cleft%281-p_i%5Cright%29%5E2-%5Csum_%7Bi%3D1%7D%5E%7Bn-1%7D%20%5Csum_%7Bj%3Di%2B1%7D%5En%20p_i%5E2%20p_j%5E2%5Cleft(4-3%20p_i-3%20p_j%5Cright)%0A" /></p><p>如果母本基因型未知，此时 PE 的公式如下</p>
<p style=""><img src="https://math.now.sh?from=Q_2%3D%5Csum_%7Bi%3D1%7D%5En%20p_i%5E2%5Cleft%281-p_i%5Cright%29%5E2%2B%5Csum_%7Bi%3D1%7D%5E%7Bn-1%7D%20%5Csum_%7Bj%3Di%2B1%7D%5En%202%20p_i%20p_j%5Cleft(1-p_i-p_j%5Cright)%5E2%0A" /></p><p>上面例子中的已知母本基因型换成已知父本基因型也是一样的。</p>
<h2 id="亲权指数">亲权指数</h2>
<p><strong>亲权指数</strong> (parentage index; PI) ：判断亲权关系所需的两个条件概率的似然比率。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BPI%7D%3D%5Cfrac%7B%5Ctext%20%7B%20%E6%A6%82%E7%8E%87%20%28%E6%A3%80%E6%B5%8B%E5%88%B0%E5%BD%93%E4%BA%8B%E4%BA%BA%E7%9A%84%E9%81%97%E4%BC%A0%E8%A1%A8%E5%9E%8B%20%7D%20%5Cmid%20%5Ctext%20%7B%20%E5%81%87%E8%AE%BE%E8%A2%AB%E6%A3%80%E6%B5%8B%E4%B8%AA%E4%BD%93%E6%98%AF%E5%AD%A9%E5%AD%90%E7%9A%84%E7%94%9F%E7%89%A9%E5%AD%A6%E7%88%B6%E4%BA%B2%E6%88%96%E6%AF%8D%E4%BA%B2%29%20%7D%7D%7B%5Ctext%20%7B%20%E6%A6%82%E7%8E%87%20(%E6%A3%80%E6%B5%8B%E5%88%B0%E5%BD%93%E4%BA%8B%E4%BA%BA%E7%9A%84%E9%81%97%E4%BC%A0%E8%A1%A8%E5%9E%8B%20%7D%20%5Cmid%20%5Ctext%20%7B%20%E5%81%87%E8%AE%BE%E4%B8%80%E4%B8%AA%E9%9A%8F%E6%9C%BA%E4%B8%AA%E4%BD%93%E6%98%AF%E5%AD%A9%E5%AD%90%E7%9A%84%E7%94%9F%E7%89%A9%E5%AD%A6%E7%88%B6%E4%BA%B2%E6%88%96%E6%AF%8D%E4%BA%B2)%20%7D%7D%0A" /></p><p>实际上这就是 cervus 软件中计算单个位点的原始似然比，举例如下</p>
<p><img src="3.png" alt=""></p>
<p><strong>累积亲权指数</strong> (parentage index; CPI) ：公式如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BCPI%7D%20%3D%20%5Cprod_%7Bi%3D1%7D%5E%7Bm%7D%5Cmathrm%7BPI%7D_%7Bi%7D%0A" /></p><p>累积亲权指数就是所有位点的原始似然值。</p>
<p>因为 cervus 对原始似然比求了 ln ，得到 LOD scores ，因此我们得到二者关系为</p>
<p style=""><img src="https://math.now.sh?from=%5Ctext%7BLOD%20scores%7D%20%3D%20%5Cmathrm%7Be%7D%5E%7B%5Cmathrm%7BCPI%7D%7D%0A" /></p><p>但是，如果存在孟德尔错误的位点，那么不同人不同软件的处理方式不一样，因此得到的结果也会有差异。比如在 SF/Z JD0105001-2016 《亲权鉴定技术规范》，不符合遗传规律情形时亲权指数的计算方法如下图，图中 <img src="https://math.now.sh?inline=%5Cmu" style="display:inline-block;margin: 0;"/> 为平均突变率。</p>
<p><img src="2.png" alt=""></p>
<h2 id="父权相对机会">父权相对机会</h2>
<p>父权相对机会（relative chance of paternity），有人也翻译为亲子关系相对机会，是将亲权指数 PI 换算为百分数后的一个指标。</p>
<p>参考<a href="https://www.zgbk.com/ecph/words?SiteID=1&amp;ID=490853&amp;Type=bkzyb">中国大百科全书</a>，我们设假设为 Hd 含义为候选父本不是孩子的生父，另一个假设 Hp 含义为候选父本是孩子的生父，E 是表示获得二联体或三联体遗传标记检测结果的事件，因此我们得到亲权指数可以表示为 PI = Pr(E|Hp)/Pr(E|Hd) 。父权相对机会便可以表示为 <code>Pr(Hp | E)</code> ，即在获得二联体或三联体遗传标记检测结果的条件下，候选父本是孩子生父的概率。根据贝叶斯公式，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0APr%28Hp%20%7C%20E%29%20%26%3D%20%5Cfrac%7BPr(E%7CHp)Pr(Hp)%7D%7BPr(E%7CHp)Pr(Hp)%20%2B%20Pr(E%7CHd)Pr(Hd)%7D%20%5C%5C%0A%26%3D%5Cfrac%7BPI%20%5C%20Pr(Hp)%7D%7BPI%20%5C%20Pr(Hp)%20%2B%20Pr(Hd)%7D%20%5Cquad%20%5Cbecause%20PI%20%3D%20Pr(E%7CHp)%2FPr(E%7CHd)%20%20%5C%5C%0A%26%3D%5Cfrac%7BPI%20%7D%7BPI%20%20%2B%20Pr(Hd)%2FPr(Hp)%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>这里 Pr(Hd) 和 Pr(Hp) 分别表示候选父本不是孩子生父和候选父本是孩子生父的前概率，由于鉴定人对这两个前概率无法准确获知，故通常假设二者均为 0.5。</p>
<p>在 SF/Z JD0105001-2016 《亲权鉴定技术规范》中，也明确提出以下说明</p>
<blockquote>
<p>如果在鉴定书里使用其他数学或词语的表达式时，应定义并解释其含义，使委托人或法庭了解其 意义。如要将亲权指数值转换为传统使用的父权相对机会，应同时给出转换时所采用的前概率。例如， 某案累计亲权指数为 10000 时，可以表述为本案累计亲权指数为 10000，在假定父权前概率为 0.5 时， 父权相对机会为 0.99 。</p>
</blockquote>
<h1>亲子鉴定文书规范</h1>
<p>在 SF/Z JD0105004 - 2015《亲子鉴定文书规范》中，列出了三种出具意见，下面是三联体亲权鉴定的三种意见如下</p>
<p>第一种，支持意见</p>
<blockquote>
<p>D19S433 等 19 个 STR 基因座均为人类的遗传标记，遵循孟德尔遗传定律，联合应用可进行亲权鉴 定，其累积非父排除概率大于 0.9999。综上检验结果分析，在每一个 STR 基因座，CC 均能提供给 BB 必需的等位基因。经计算，累积亲权指数为 XXXX（注：大于 10000）</p>
</blockquote>
<p>第二种，排除意见</p>
<blockquote>
<p>D19S433 等 19 个 STR 基因座均为人类的遗传标记，遵循孟德尔遗传定律，联合应用可进行亲权鉴 定，其累积非父排除概率大于 0.9999。综上检验结果分析，CC 在 XXXX、XXXX 和 XXXX 等基因座不能提 供给孩子必需的等位基因。经计算，累积亲权指数为 XXXX（注：小于 0.0001）</p>
</blockquote>
<p>第三种，出现不符合遗传现象，仍表示支持意见</p>
<blockquote>
<p>D19S433 等 19 个 STR 基因座均为人类的遗传标记，遵循孟德尔遗传定律，联合应用可进行亲权鉴 定，其累积非父排除概率大于 0.9999。上述检验结果表明，除 D3S1358 基因座外，CC 均能提供给孩子 必需的等位基因。在 D3S1358 基因座，AA 的基因型为“16,18”，BB 的基因型为“16,18”，CC 的基因型 为“15,15”，CC 不能提供给孩子必需的等位基因 16 或 18，不符合遗传规律。按照 GA/T965-2011《法 庭科学 DNA 亲子鉴定规范》和 SF/Z JD0105001-2015《亲权鉴定技术规范》中不符合遗传规律情形时亲权指数的计算方法，XXX 基因座的亲权指数为 XXXX。综上 19 个 STR 基因座的累积亲权指数为 XXXX（注： 大于 10000）</p>
</blockquote>
<p>其实还有一种罕见但是理论上可能出现的特殊情况，那就是出现（少量的）不符合遗传现象，并且累积亲权指数低于 10000，那么就需要增加 STR 基因型，如果仍未达到认定标准，则可以出具“不排除”意见。</p>
<h1>参考文献</h1>
<ol>
<li>
<p>GB/T 37223-2018</p>
</li>
<li>
<p>GB/T 27642-2011</p>
</li>
<li>
<p>SF/Z JD0105001-2016 《亲权鉴定技术规范》</p>
</li>
<li>
<p>SF/Z JD0105004 - 2015《亲子鉴定文书规范》</p>
</li>
<li>
<p>Marshall T C, Slate J, Kruuk L E B, et al. Statistical confidence for likelihood‐based paternity inference in natural populations[J]. Molecular ecology, 1998, 7(5): 639-655.</p>
</li>
<li>
<p>Fung W K, Chung Y, Wong D. Power of exclusion revisited: probability of excluding relatives of the true father from paternity[J]. International journal of legal medicine, 2002, 116: 64-67.</p>
</li>
<li>
<p>Jamieson A. The genetics of transferrins in cattle[J]. Heredity, 1965, 20(3): 419-441.</p>
</li>
<li>
<p>Jamieson A. The effectiveness of using co‐dominant polymorphic allelic series for (1) checking pedigrees and (2) distinguishing full‐sib pair members[J]. Animal Genetics, 1994, 25(S1): 37-44.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>亲子鉴定</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>亲子鉴定</tag>
      </tags>
  </entry>
  <entry>
    <title>cervus软件</title>
    <url>/posts/c13fbdfa/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>cervus 是经典的亲子鉴定软件。</p>
<span id="more"></span>
<h1>cervus 原理</h1>
<p><img src="10.png" alt=""></p>
<p><img src="11.png" alt=""></p>
<p><img src="12.png" alt=""></p>
<p><img src="13.png" alt=""></p>
<h1>下载 cervus</h1>
<p>去官网下载软件（见参考文献的第一条链接），我下载的是 3.0.7 版本</p>
<h1>准备基因型文件</h1>
<p>基因型文件可以由 plink 文件生成，第一列是个体号，从第二列起为每个位点的基因型，一个基因型占2列（SSR 使用片段大小，SNP 可以使用碱基，缺失标记为 0），含有标题（两列基因型分别添加后缀 “a”, “b”）。</p>
<p>举例如下</p>
<p><img src="1.png" alt=""></p>
<h1>计算等位基因频率</h1>
<p>点击 <code>Analysis</code> ，然后点击 <code>Allele Frequency Analysis</code></p>
<p><img src="3.png" alt=""></p>
<p>在弹出的窗口设置如下，其中左下部分含义为</p>
<ul>
<li><code>Header row</code> ： 是否有标题</li>
<li><code>Read locus names</code> ： 是否读取位点名称</li>
<li><code>ID in column</code> ： 样本号在第几列</li>
<li><code>First allele in column</code> ： 第一个位点的基因型在第几列</li>
<li><code>Number of loci</code> : 位点总数</li>
</ul>
<p>右下部分默认不动（含义为做哈温伯格平衡测试，最小期望频率为5，使用叶氏连续性修正，使用Bonferroni校正，估计无效等位基因频率）。</p>
<p><img src="4.png" alt=""></p>
<p>运行结束了我们得到了两个结果文件</p>
<p><code>frequence.alf</code> 就是等位基因型频率结果文件</p>
<p><img src="7.png" alt=""></p>
<p><code>frequence.txt</code> 文件各列内容如下</p>
<ul>
<li><code>Locus</code> ： 位点名称</li>
<li><code>k</code> ： 等位基因型数目</li>
<li><code>N</code> ： 该位点的样本数目（应该是剔除缺失后的）</li>
<li><code>HObs</code> : 该位点的观测杂合度</li>
<li><code>HExp</code> : 该位点的期望杂合度</li>
<li><code>PIC</code> ： 该位点的多态信息含量 (Polymorphic information content)</li>
</ul>
<p>后续列为（<strong>注意</strong>，这里的结果是<strong>非排除概率</strong>，排除概率等于 1- 该列的值） 。</p>
<p>后面三列应该对应着三种情况，双亲的基因型均未知鉴定一个候选亲本（1P）， 已知一个亲本基因型鉴定另一个候选亲本（2P），双亲的基因型均未知鉴定一对候选亲本（PP）。</p>
<blockquote>
<p>NE-1P: Average non-exclusion probability for one candidate parent.</p>
<p>NE-2P: Average non-exclusion probability for one candidate parent given the genotype of a known parent of the opposite sex.</p>
<p>NE-PP: Average non-exclusion probability for a candidate parent pair.</p>
<p>NE-I: Average non-exclusion probability for identity of two unrelated individuals.</p>
<p>NE-SI: Average non-exclusion probability for identity of two siblings.</p>
<p>HW: 哈温伯格平衡NS = not significant无显著性, * = significant at the 5% level显著性水平5%, ** = significant at the 1% level显著性水平1%, *** = significant at the 0.1% level显著性水平0.1%, ND = not done没有做</p>
<p>F(Null): Estimated null allele frequency估计无效等位基因频率</p>
</blockquote>
<p><img src="5.png" alt=""></p>
<p>之后的统计内容为</p>
<ul>
<li><code>Number of individuals</code>: 个体数量</li>
<li><code>Number of loci</code> : 位点数量</li>
<li><code>Mean number of alleles per locus</code> : 所有位点平均等位基因数量</li>
<li><code>Mean proportion of loci typed</code> : 所有位点的平均检出率</li>
<li><code>Mean expected heterozygosity</code> : 所有位点的平均期望杂合度</li>
<li><code>Mean polymorphic information content (PIC)</code>: 所有位点的平均多态信息含量</li>
</ul>
<p>之后是累积<strong>非排除概率</strong>的统计。</p>
<p><img src="6.png" alt=""></p>
<h1>检测重复样本</h1>
<p>亲子鉴定前最好做一下个体识别，或者说重复样本检测，看看有没有基因型一样的个体。</p>
<p>点击 <code>Analysis</code> ，然后点击 <code>Identity Analysis</code> 。</p>
<p><img src="2.png" alt=""></p>
<p>设置如下，其它设置上面均提过，新增加的选项就是输出选项</p>
<ul>
<li><code>Minimum number of matching loci</code> ：这应该是说输出的重复样本之间最少应该匹配上多少个体位点</li>
<li><code>Allow fuzzy matching</code> : 允许模糊匹配，就是说允许两个重复存在不一致位点</li>
<li><code>Allow 3 mismatches</code> ：允许重复样本之间最多存在几个不一致位点</li>
</ul>
<p><img src="8.png" alt=""></p>
<p>输出文件 <code>identity.csv</code> 中含有所有重复样本的信息</p>
<p><img src="9.png" alt=""></p>
<h1>模拟亲缘关系推断</h1>
<p>通过模拟训练可以获得亲子关系统计指标 <img src="https://math.now.sh?inline=%5CDelta" style="display:inline-block;margin: 0;"/> 置信区间为80%和95%的临界值。</p>
<p>点击 <code>Analysis</code> ，然后点击 <code>Simulation of Parentage Analysis</code> 。</p>
<p><img src="14.png" alt=""></p>
<p>这里有四种亲子鉴定分析类型类型：maternity analysis, paternity analysis, parent pair analysis where the sexes of candidate parents are known and parent pair analysis where the sexes of candidate parents are unknown 。</p>
<p>可以简单地理解为单亲鉴定和双亲鉴定，下面以 <code>parent pair (Sexes Known)</code> 为例</p>
<p>其中：</p>
<ul>
<li><code>Offspring</code>:  后代数目，默认就是 10000</li>
<li><code>Candidate mothers</code> ： 候选母本数目（包括没有基因型的样本）(父本同理)</li>
<li><code>Prop. sampled</code> : 候选母本采样比例</li>
<li><code>Prop. loci typed</code> ：位点的分型率</li>
<li><code>Prop. loci mistyped</code> ：位点的错误分型率</li>
</ul>
<p><img src="15.png" alt=""></p>
<p>这里有两个输出文件: <code>sim_mother.sim</code> 中包含了所有的参数，<code>sim_mother.txt</code> 是模拟结果。</p>
<h1>亲子鉴定</h1>
<p>首先将后代的个体号放在一个文件中(offspring.txt) ，如果已知亲本性别则创建一个候选父本的个体号文件(father.txt) 和 候选母本的个体号文件（mother.txt），如果亲本性别未知则将所有候选亲本放在一个文件夹中。</p>
<p>下面以亲本性别已知为例，点击 <code>Analysis</code>  再点击 <code>Parentage Analysis</code> , <code>Parent Pair (Sexes Known)</code></p>
<p>填写参数如下，每一步之后都点击 <code>next</code> 进入下一步，注意选择模拟结果文件时要选择相同的分析结果（比如这里是双亲有性别信息，这里的模拟结果也要用双亲有性别信息）</p>
<p><img src="16.png" alt=""></p>
<p><img src="17.png" alt=""></p>
<p><img src="18.png" alt=""></p>
<p><img src="19.png" alt=""></p>
<p><img src="20.png" alt=""></p>
<p>输出结果中 <code>assign_out.txt</code> 是汇总文件， <code>assign_out.csv</code> 是具体结果，其结构如下，首先是最可能的母本（主要关注其似然比，<img src="https://math.now.sh?inline=%5CDelta" style="display:inline-block;margin: 0;"/> 还有显著性水平 ），然后是最可能的父本，然后是这个 trios 的似然比结果。</p>
<p>显著性水平有三种符号，<code>*</code> 表示亲子关系极显著，置信度超过 95%；<code>+</code> 表示亲子关系较显著，置信度超过 80%； <code>-</code> 表示亲子关系没有达到显著要求，置信度低于 80% 。</p>
<p><img src="21.png" alt=""></p>
<h1>讨论</h1>
<p>cervus 是一款经典的亲子鉴定软件，使用起来还算是比较方便简单，但是我认为它有几点缺点：</p>
<ol>
<li>图形化界面，只能在 windows 环境中运行</li>
<li>必须将个体分为后代和候选亲本，没有考虑世代重叠的情况</li>
<li>当真实亲本不在候选亲本中，会错误地推出一个错误的候选亲本</li>
<li>无法有效区分亲子关系和全同胞关系</li>
</ol>
<h1>参考文献</h1>
<ol>
<li><a href="http://www.fieldgenetics.com/pages/aboutCervus_Overview.jsp">http://www.fieldgenetics.com/pages/aboutCervus_Overview.jsp</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/378780428">https://zhuanlan.zhihu.com/p/378780428</a></li>
<li><a href="https://wenku.baidu.com/view/101e04e0aff8941ea76e58fafab069dc50224763.html?_wkts_=1682647370039">https://wenku.baidu.com/view/101e04e0aff8941ea76e58fafab069dc50224763.html?_wkts_=1682647370039</a></li>
</ol>
]]></content>
      <categories>
        <category>软件学习</category>
        <category>cervus</category>
      </categories>
      <tags>
        <tag>软件学习</tag>
        <tag>cervus</tag>
      </tags>
  </entry>
  <entry>
    <title>python包-glob</title>
    <url>/posts/2aec3b6c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><code>glob</code> 是一个内置模块， 其提供了一个函数用于从目录中搜索匹配的文件路径名模式，它可以帮助你快速找到符合条件的文件路径。</p>
<p>递归查找所有文件的利器。</p>
<span id="more"></span>
<h1>glob</h1>
<p>使用 <code>glob</code> 模块需要先导入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import glob</span><br></pre></td></tr></table></figure>
<p>然后可以使用 <code>glob.glob()</code> 函数来搜索匹配的文件路径，该函数接受一个文件路径模式作为参数，返回符合模式的所有文件路径<strong>列表</strong>。</p>
<p>以下是 <code>glob</code> 模块的一些示例用法：</p>
<ol>
<li>查找当前目录下所有的 <code>.txt</code> 文件：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line">txt_files = glob.glob(<span class="string">&quot;*.txt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(txt_files)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查找指定路径下所有的 <code>.py</code> 文件：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line">py_files = glob.glob(<span class="string">&quot;/path/to/dir/*.py&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(py_files)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>查找多个后缀名的文件：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line">files = glob.glob(<span class="string">&quot;*.[png,jpg,gif]&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(files)</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>查找所有子目录下的所有 <code>.txt</code> 文件：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line">base_path = <span class="string">&quot;/path/to/dir&quot;</span></span><br><span class="line">txt_files = glob.glob(os.path.join(base_path, <span class="string">&quot;**/*.txt&quot;</span>), recursive=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(txt_files)</span><br></pre></td></tr></table></figure>
<p>在第四个示例中，我们使用了 <code>os.path.join()</code> 来构造完整的查询路径，并且设置了 <code>recursive=True</code> 来递归查找所有子目录（默认是 False ，即仅搜索指定目录中符合条件的文件路径名）。</p>
<h1>两个*号</h1>
<p><code>**</code> 是一个特殊的通配符，在 <code>glob</code> 模块中表示匹配多级子目录。具体来说，<code>**</code> 可以匹配任意层数的子目录，例如：</p>
<ul>
<li><code>/path/to/dir/**/*.txt</code>：匹配 <code>/path/to/dir</code> 目录下以及其所有子目录中的所有 <code>.txt</code> 文件。</li>
<li><code>/path/to/dir/**/foo/*.txt</code>：匹配 <code>/path/to/dir</code> 目录下以及其所有子目录中名为 <code>foo</code> 的子目录中的所有 <code>.txt</code> 文件。</li>
</ul>
<p>需要注意的是，在 Windows 系统中使用 <code>**</code> 时需要开启 <code>recursive=True</code> 参数，而在类 Unix 系统中则不需要（也就是说在  Unix 系统中用<code>**</code> 不用设置 <code>recursive=True</code> 参数 ）。</p>
<h1>参考文献</h1>
<ol>
<li>Chat机器人</li>
</ol>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>EM算法</title>
    <url>/posts/27a0e22b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>EM 算法 (expectation-maximization)  是获得最大似然估计值的一种迭代算法，当原始的似然函数很复杂时，无法直接得到显式解时，我们可以选择使用 EM 算法。</p>
<span id="more"></span>
<h1>Jensen’s inequality</h1>
<p>假设 <img src="https://math.now.sh?inline=f" style="display:inline-block;margin: 0;"/> 是一个定义域为实数的函数，只有当 <img src="https://math.now.sh?inline=f%5E%7B%5Cprime%20%5Cprime%7D%28x%29%20%5Cgeq%200" style="display:inline-block;margin: 0;"/>  恒成立是，<img src="https://math.now.sh?inline=f" style="display:inline-block;margin: 0;"/> 才是一个<strong>凸函数</strong>。如果 <img src="https://math.now.sh?inline=f" style="display:inline-block;margin: 0;"/> 输入是一个向量，那么其为凸函数的条件一般化为，只有当其 hessian 矩阵是一个半正定矩阵成立 (<img src="https://math.now.sh?inline=%5Cboldsymbol%7BH%7D%20%5Cgeq%200" style="display:inline-block;margin: 0;"/>)。 如果 <img src="https://math.now.sh?inline=f%5E%7B%5Cprime%20%5Cprime%7D%28x%29%20%3E%200" style="display:inline-block;margin: 0;"/>  (<img src="https://math.now.sh?inline=%5Cboldsymbol%7BH%7D%20%3E%200" style="display:inline-block;margin: 0;"/>) ，那么我们称 <img src="https://math.now.sh?inline=f" style="display:inline-block;margin: 0;"/> 是一个<strong>严格凸函数 (strictly convex)</strong> 。</p>
<p><strong>Jensen’s inequality</strong> 表述如下：</p>
<p><img src="3.png" alt="1"></p>
<p>我们可以下面的图，这里 <img src="https://math.now.sh?inline=f" style="display:inline-block;margin: 0;"/> 是一个凸函数，X 是一个随机变量，其有一半概率为 a, 一半概率为 b 。从这个例子中，我们可以看到 <img src="https://math.now.sh?inline=%5Cmathrm%7BE%7D%5Bf%28X%29%5D%20%5Cgeq%20f(%5Cmathrm%7BE%7D%20X)" style="display:inline-block;margin: 0;"/> 。</p>
<p><img src="4.png" alt="1"></p>
<p>注意：如果 <img src="https://math.now.sh?inline=f" style="display:inline-block;margin: 0;"/> 是一个凹函数，那么 <img src="https://math.now.sh?inline=-f" style="display:inline-block;margin: 0;"/> 就是凸函数。因此对于凹函数存在 <img src="https://math.now.sh?inline=%5Cmathrm%7BE%7D%5Bf%28X%29%5D%20%5Cleq%20f(%5Cmathrm%7BE%7D%20X)" style="display:inline-block;margin: 0;"/> 。</p>
<h1>The EM algorithm</h1>
<p>假设我们有一个包含 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> 个独立样本的训练集数据 <img src="https://math.now.sh?inline=%5Cleft%5C%7Bx%5E%7B%281%29%7D%2C%20%5Cldots%2C%20x%5E%7B(m)%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> ，我们需要对一个模型 <img src="https://math.now.sh?inline=p%28x%2C%20z%29" style="display:inline-block;margin: 0;"/> 进行拟合参数，其中似然函数为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cell%28%5Ctheta%29%20%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Clog%20p(x%20%3B%20%5Ctheta)%20%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Clog%20%5Csum_%7Bz%7D%20p(x%2C%20z%20%3B%20%5Ctheta)%0A%5Cend%7Baligned%7D%0A" /></p><p>但是，我们想要找到 <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/> 的最大似然估计值很难。这里，<img src="https://math.now.sh?inline=z%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> 是隐藏的随机变量。如果我们已知 <img src="https://math.now.sh?inline=z%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> ，那么获取最大似然估计值就很容易。</p>
<p>在这种情况下，EM 算法提供了一种估计参数的最大似然估计值的有效方法（哈哈哈，估计最大似然估计值，“估计估计值”，双重估计）。</p>
<blockquote>
<p>Maximizing <img src="https://math.now.sh?inline=%5Cell%28%5Ctheta%29" style="display:inline-block;margin: 0;"/> explicitly might be difficult，our strategy will be to instead repeatedly construct a lower-bound on <img src="https://math.now.sh?inline=%5Cell" style="display:inline-block;margin: 0;"/> (E-step), and then optimize that lower-bound (M-step).</p>
</blockquote>
<p>对于每个个体 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> ，设 <img src="https://math.now.sh?inline=Q_%7Bi%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=z" style="display:inline-block;margin: 0;"/> 的分布 <img src="https://math.now.sh?inline=%5Cleft%28%5Csum_%7Bz%7D%20Q_%7Bi%7D(z%29%3D1%2C%20Q_%7Bi%7D(z)%20%5Cgeq%200%20%5Cright)" style="display:inline-block;margin: 0;"/> ，因此 (如果 <img src="https://math.now.sh?inline=z" style="display:inline-block;margin: 0;"/> 是连续变量，那么 <img src="https://math.now.sh?inline=Q_%7Bi%7D" style="display:inline-block;margin: 0;"/> 就改为概率密度， <strong><img src="https://math.now.sh?inline=z" style="display:inline-block;margin: 0;"/> 的求和式子改为积分</strong> ，也就是 <img src="https://math.now.sh?inline=%5Csum_%7Bz%5E%7B%28i%29%7D%7D" style="display:inline-block;margin: 0;"/> 改为 <img src="https://math.now.sh?inline=%5Cint_%7Bz%5E%7B%28i%29%7D%7D%20*%20dz%5E%7B(i)%7D" style="display:inline-block;margin: 0;"/> )</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cell%28%5Ctheta%29%20%3D%20%5Csum_%7Bi%7D%20%5Clog%20p%5Cleft(x%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%20%26%3D%5Csum_%7Bi%7D%20%5Clog%20%5Csum_%7Bz%5E%7B(i)%7D%7D%20p%5Cleft(x%5E%7B(i)%7D%2C%20z%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%20%5C%5C%0A%26%3D%5Csum_%7Bi%7D%20%5Clog%20%5Csum_%7Bz%5E%7B(i)%7D%7D%20Q_%7Bi%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%20%5Cfrac%7Bp%5Cleft(x%5E%7B(i)%7D%2C%20z%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%7D%7BQ_%7Bi%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%7D%20%5C%5C%0A%26%20%5Cgeq%20%5Csum_%7Bi%7D%20%5Csum_%7Bz%5E%7B(i)%7D%7D%20Q_%7Bi%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%20%5Clog%20%5Cfrac%7Bp%5Cleft(x%5E%7B(i)%7D%2C%20z%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%7D%7BQ_%7Bi%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>最后一步应用了 Jensen 不等式。因为，我们知道 <img src="https://math.now.sh?inline=%5Clog%28x%29" style="display:inline-block;margin: 0;"/> 是一个凹函数，因为 <img src="https://math.now.sh?inline=f%5E%7B%5Cprime%20%5Cprime%7D%28x%29%3D-1%20%2F%20x%5E%7B2%7D%3C0" style="display:inline-block;margin: 0;"/> 恒成立。并且，下式可视为 <img src="https://math.now.sh?inline=%5Cleft%5B%5Cfrac%7Bp%5Cleft%28x%5E%7B(i%29%7D%2C%20z%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%7D%7BQ_%7Bi%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%7D%5Cright%5D" style="display:inline-block;margin: 0;"/> 对 <img src="https://math.now.sh?inline=z%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> 的期望</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bz%5E%7B%28i%29%7D%7D%20Q_%7Bi%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%5Cleft%5B%5Cfrac%7Bp%5Cleft(x%5E%7B(i)%7D%2C%20z%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%7D%7BQ_%7Bi%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%7D%5Cright%5D%0A" /></p><p>通过 Jensen 不等式，我们有下式成立，得证上面公式的最后一步。这里的 <img src="https://math.now.sh?inline=%7Bz%7D%5E%7B%28i%29%7D%20%5Csim%20Q_%7Bi%7D" style="display:inline-block;margin: 0;"/>  下标表示这是对  <img src="https://math.now.sh?inline=z%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> 的期望，其中  <img src="https://math.now.sh?inline=z%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> 服从分布 <img src="https://math.now.sh?inline=Q_i" style="display:inline-block;margin: 0;"/> 。</p>
<p style=""><img src="https://math.now.sh?from=f%5Cleft%28%5Cmathrm%7BE%7D_%7Bz%5E%7B(i%29%7D%20%5Csim%20Q_%7Bi%7D%7D%5Cleft%5B%5Cfrac%7Bp%5Cleft(x%5E%7B(i)%7D%2C%20z%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%7D%7BQ_%7Bi%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%7D%5Cright%5D%5Cright)%20%5Cgeq%20%5Cmathrm%7BE%7D_%7Bz%5E%7B(i)%7D%20%5Csim%20Q_%7Bi%7D%7D%5Cleft%5Bf%5Cleft(%5Cfrac%7Bp%5Cleft(x%5E%7B(i)%7D%2C%20z%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%7D%7BQ_%7Bi%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%7D%5Cright)%5Cright%5D%0A" /></p><p>现在，对于任何一个分布  <img src="https://math.now.sh?inline=Q_i" style="display:inline-block;margin: 0;"/> , 我们都能得到一个 <img src="https://math.now.sh?inline=%5Cell%28%5Ctheta%29" style="display:inline-block;margin: 0;"/> 的下限。我们对于 <img src="https://math.now.sh?inline=Q_i" style="display:inline-block;margin: 0;"/> 存在很多种选择，那么我们选择哪一个呢？如果我们对参数 <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/> 目前已有估计值，那么一个自然的选择是使得  <img src="https://math.now.sh?inline=%5Cell%28%5Ctheta%29" style="display:inline-block;margin: 0;"/> 的下限与  <img src="https://math.now.sh?inline=%5Cell%28%5Ctheta%29" style="display:inline-block;margin: 0;"/>  的值很接近。换句话说，我们想让上面的不等式针对特定的  <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/> 变成等式，这样做可以使得每次迭代 <img src="https://math.now.sh?inline=%5Cell%28%5Ctheta%29" style="display:inline-block;margin: 0;"/>  单调递增。</p>
<p>为了使得  <img src="https://math.now.sh?inline=%5Cell%28%5Ctheta%29" style="display:inline-block;margin: 0;"/> 的下限等于 <img src="https://math.now.sh?inline=%5Cell%28%5Ctheta%29" style="display:inline-block;margin: 0;"/> ，我们需要上面的 Jensen 不等式在特定的 <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/> 时变成等式，也是就说要对常量求期望，即要求，对所有所有的  <img src="https://math.now.sh?inline=z%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/>  ，下式均为一个固定的常数。</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7Bp%5Cleft%28x%5E%7B(i%29%7D%2C%20z%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%7D%7BQ_%7Bi%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%7D%3Dc%0A" /></p><p>做个变换得到：</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bz%7Dp%5Cleft%28x%5E%7B(i%29%7D%2C%20z%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%20%3D%20%5Csum_%7Bz%7DQ_%7Bi%7D%5Cleft(z%5E%7B(i)%7D%5Cright)c%0A" /></p><p>我们知道 <img src="https://math.now.sh?inline=%5Csum_%7Bz%7D%20Q_%7Bi%7D%5Cleft%28z%5E%7B(i%29%7D%5Cright)%3D1" style="display:inline-block;margin: 0;"/> ，因此我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bz%7Dp%5Cleft%28x%5E%7B(i%29%7D%2C%20z%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%20%3D%20c%0A" /></p><p>因此</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AQ_%7Bi%7D%5Cleft%28z%5E%7B(i%29%7D%5Cright)%20%0A%26%3D%5Cfrac%7Bp%5Cleft(x%5E%7B(i)%7D%2C%20z%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%7D%7Bc%7D%20%5C%5C%0A%26%3D%5Cfrac%7Bp%5Cleft(x%5E%7B(i)%7D%2C%20z%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%7D%7B%5Csum_%7Bz%7D%20p%5Cleft(x%5E%7B(i)%7D%2C%20z%20%3B%20%5Ctheta%5Cright)%7D%20%5C%5C%0A%26%3D%5Cfrac%7Bp%5Cleft(x%5E%7B(i)%7D%2C%20z%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%7D%7Bp%5Cleft(x%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%7D%20%5C%5C%0A%26%3Dp%5Cleft(z%5E%7B(i)%7D%20%5Cmid%20x%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，这里我们简单地将   <img src="https://math.now.sh?inline=Q_i" style="display:inline-block;margin: 0;"/>  设定为  <img src="https://math.now.sh?inline=z%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> 基于给定的 <img src="https://math.now.sh?inline=x%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/>  的<strong>后验分布</strong> 。</p>
<p>现在，通过我们选择的 <img src="https://math.now.sh?inline=Q_i" style="display:inline-block;margin: 0;"/> ，我们得到了想要最大化的 <img src="https://math.now.sh?inline=%5Cell%28%5Ctheta%29" style="display:inline-block;margin: 0;"/> 的下限，这是 E 步。在 M 步中，我们则基于 <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/>  最大化 <img src="https://math.now.sh?inline=%5Cell%28%5Ctheta%29" style="display:inline-block;margin: 0;"/> 的下限公式，得到一组新的参数 <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/>  。重复上面的步骤就是 EM 算法，描述如下：</p>
<p><img src="1.png" alt="1"></p>
<p>这里第二个式子还可以进一步简化：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Ctheta%20%26%20%3A%3D%20%5Coperatorname%7Barg%7D%20%5Cmax_%7B%5Ctheta%7D%20%5Csum_%7Bi%7D%20%5Csum_%7Bz%5E%7B%28i%29%7D%7D%20Q_%7Bi%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%20%5Clog%20%5Cfrac%7Bp%5Cleft(x%5E%7B(i)%7D%2C%20z%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%7D%7BQ_%7Bi%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%7D%20%5C%5C%0A%20%26%20%3A%3D%20%5Coperatorname%7Barg%7D%20%5Cmax_%7B%5Ctheta%7D%20%5Csum_%7Bi%7D%20%5Csum_%7Bz%5E%7B(i)%7D%7D%20Q_%7Bi%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%20%5Cleft(%20%5Clog%20p%5Cleft(x%5E%7B(i)%7D%2C%20z%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%20-%20%5Clog%20Q_%7Bi%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%20%5Cright)%20%5C%5C%0A%20%26%20%3A%3D%20%5Coperatorname%7Barg%7D%20%5Cmax_%7B%5Ctheta%7D%20%5Csum_%7Bi%7D%20%5Csum_%7Bz%5E%7B(i)%7D%7D%20Q_%7Bi%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%20%20%5Clog%20p%5Cleft(x%5E%7B(i)%7D%2C%20z%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%20%5Cquad%20%5Cbecause%20%5Ctext%7B%E5%90%8E%E4%B8%80%E9%A1%B9%E4%B8%8E%7D%20%5Ctheta%20%5Ctext%7B%E6%97%A0%E5%85%B3%EF%BC%8C%E4%B8%BA%E5%B8%B8%E9%87%8F%7D%5C%5C%20%0A%20%26%20%3A%3D%20%5Coperatorname%7Barg%7D%20%5Cmax_%7B%5Ctheta%7D%20%5Csum_%7Bi%7D%20%5Cmathrm%7BE%7D_%7Bz%5E%7B(i)%7D%7Cx%5E%7B(i)%7D%2C%20%5Ctheta%5E%7B%5Bt%5D%7D%7D%20%20%20%5Clog%20p%5Cleft(x%5E%7B(i)%7D%2C%20z%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%20%5C%5C%20%0A%20%26%20%3A%3D%20%5Coperatorname%7Barg%7D%20%5Cmax_%7B%5Ctheta%7D%20%20%5Cmathrm%7BE%7D_%7Bz%5E%7B(i)%7D%7Cx%5E%7B(i)%7D%2C%20%5Ctheta%5E%7B%5Bt%5D%7D%7D%20%5Cleft(%20%5Csum_%7Bi%7D%20%20%20%20%5Clog%20p%5Cleft(x%5E%7B(i)%7D%2C%20z%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%20%5Cright)%20%5C%5C%20%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>其中， <img src="https://math.now.sh?inline=%5Ctheta%5E%7B%5Bt%5D%7D" style="display:inline-block;margin: 0;"/> 是上一轮的参数值。</p>
<p>还有一点小问题，因为 E 步是计算条件期望的，因此严格来说计算 <img src="https://math.now.sh?inline=%5Csum_%7Bi%7D%20%5Csum_%7Bz%5E%7B%28i%29%7D%7D%20Q_%7Bi%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%20%20%5Clog%20p%5Cleft(x%5E%7B(i)%7D%2C%20z%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)" style="display:inline-block;margin: 0;"/> 的过程应该放在 E 步。</p>
<p>那么，我们如何知道EM算法是否收敛呢？</p>
<h1>EM 算法的收敛性</h1>
<p>我们这里证明 EM 算法只会单调地增加对数似然值，即证明 <img src="https://math.now.sh?inline=%5Cell%5Cleft%28%5Ctheta%5E%7B(t%29%7D%5Cright)%20%5Cleq%20%5Cell%5Cleft(%5Ctheta%5E%7B(t%2B1)%7D%5Cright)" style="display:inline-block;margin: 0;"/> 。</p>
<p>首先，我们通过选择 <img src="https://math.now.sh?inline=Q_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，我们使得 Jensen 不等式在当前参数下满足等式关系，因此，在求 <img src="https://math.now.sh?inline=%5Ctheta%5E%7B%28t%2B1%29%7D" style="display:inline-block;margin: 0;"/> 过程中， 存在：</p>
<p style=""><img src="https://math.now.sh?from=%5Cell%5Cleft%28%5Ctheta%5E%7B(t%29%7D%5Cright)%3D%5Csum_%7Bi%7D%20%5Csum_%7Bz%5E%7B(i)%7D%7D%20Q_%7Bi%7D%5E%7B(t%2B1)%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%20%5Clog%20%5Cfrac%7Bp%5Cleft(x%5E%7B(i)%7D%2C%20z%5E%7B(i)%7D%20%3B%20%5Ctheta%5E%7B(t)%7D%5Cright)%7D%7BQ_%7Bi%7D%5E%7B(t%2B1)%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%7D%0A" /></p><p>当我们通过 M 步对上式右手项最大化，获得  <img src="https://math.now.sh?inline=%5Ctheta%5E%7B%28t%2B1%29%7D" style="display:inline-block;margin: 0;"/> 后，此时：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cell%5Cleft%28%5Ctheta%5E%7B(t%2B1%29%7D%5Cright)%20%26%20%5Cgeq%20%5Csum_%7Bi%7D%20%5Csum_%7Bz%5E%7B(i)%7D%7D%20Q_%7Bi%7D%5E%7B(t%2B1)%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%20%5Clog%20%5Cfrac%7Bp%5Cleft(x%5E%7B(i)%7D%2C%20z%5E%7B(i)%7D%20%3B%20%5Ctheta%5E%7B(t%2B1)%7D%5Cright)%7D%7BQ_%7Bi%7D%5E%7B(t%2B1)%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%7D%20%5Cquad%20%5Cbecause%20%5Ctext%7BJensen's%20inequality%7D%5C%5C%0A%26%20%5Cgeq%20%5Csum_%7Bi%7D%20%5Csum_%7Bz%5E%7B(i)%7D%7D%20Q_%7Bi%7D%5E%7B(t%2B1)%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%20%5Clog%20%5Cfrac%7Bp%5Cleft(x%5E%7B(i)%7D%2C%20z%5E%7B(i)%7D%20%3B%20%5Ctheta%5E%7B(t)%7D%5Cright)%7D%7BQ_%7Bi%7D%5E%7B(t%2B1)%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%7D%20%5Cquad%20%5Cbecause%20%20%5Ctheta%5E%7B(t%2B1)%7D%20%3D%20%5Carg%20%5Cmax%20_%7B%5Ctheta%7D%20%5Csum_%7Bi%7D%20%5Csum_%7Bz%5E%7B(i)%7D%7D%20Q_%7Bi%7D%5E%7B(t%2B1)%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%20%5Clog%20%5Cfrac%7Bp%5Cleft(x%5E%7B(i)%7D%2C%20z%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%7D%7BQ_%7Bi%7D%5E%7B(t%2B1)%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%7D%5C%5C%0A%26%3D%5Cell%5Cleft(%5Ctheta%5E%7B(t)%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们证明</p>
<p style=""><img src="https://math.now.sh?from=%5Cell%5Cleft%28%5Ctheta%5E%7B(t%29%7D%5Cright)%20%5Cleq%20%5Cell%5Cleft(%5Ctheta%5E%7B(t%2B1)%7D%5Cright)%0A" /></p><p>因此，EM 算法只会使对数似然值不断增加，直至收敛。收敛的标准可以看两次迭代的  <img src="https://math.now.sh?inline=%5Cell%28%5Ctheta%29" style="display:inline-block;margin: 0;"/> 的增加量是否低于给定阈值。</p>
<p><strong>注意</strong>，如果我们定义：</p>
<p style=""><img src="https://math.now.sh?from=J%28Q%2C%20%5Ctheta%29%3D%5Csum_%7Bi%7D%20%5Csum_%7Bz%5E%7B(i)%7D%7D%20Q_%7Bi%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%20%5Clog%20%5Cfrac%7Bp%5Cleft(x%5E%7B(i)%7D%2C%20z%5E%7B(i)%7D%20%3B%20%5Ctheta%5Cright)%7D%7BQ_%7Bi%7D%5Cleft(z%5E%7B(i)%7D%5Cright)%7D%0A" /></p><p>我们知道 <img src="https://math.now.sh?inline=%5Cell%28%5Ctheta%29%20%5Cgeq%20J(Q%2C%20%5Ctheta)" style="display:inline-block;margin: 0;"/>  。 EM 算法可以视为对 <img src="https://math.now.sh?inline=J%28Q%2C%20%5Ctheta%29" style="display:inline-block;margin: 0;"/> 的坐标上升法，其中 E 步可以视为固定 <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/> 对 <img src="https://math.now.sh?inline=Q" style="display:inline-block;margin: 0;"/> 的最大化（因为  <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/> 固定，因为  <img src="https://math.now.sh?inline=J%28Q%2C%20%5Ctheta%29" style="display:inline-block;margin: 0;"/>  的最大值就是 <img src="https://math.now.sh?inline=%5Cell%28%5Ctheta%29" style="display:inline-block;margin: 0;"/> ，因此就是选择一个  <img src="https://math.now.sh?inline=Q" style="display:inline-block;margin: 0;"/> 使得不等式成立），而 M 步可以视为固定 <img src="https://math.now.sh?inline=Q" style="display:inline-block;margin: 0;"/>  对 <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/> 的最大化（这一点很好理解  <img src="https://math.now.sh?inline=%5Cell%28%5Ctheta%29" style="display:inline-block;margin: 0;"/> ）。</p>
<p>下图为形象化的解释，其中红线为</p>
<p><img src="2.png" alt="1"></p>
<p>因此 <strong>EM 算法一定会收敛</strong>，只不过收敛的位置可能是<strong>局部最优解</strong>。</p>
<h1>参考文献</h1>
<ol>
<li>
<p>Ng A. CS229 Lecture notes[J]. CS229 Lecture notes, 2000, 1(1): 1-3.</p>
</li>
<li>
<p><a href="https://www.cnblogs.com/pinard/p/6912636.html">https://www.cnblogs.com/pinard/p/6912636.html</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>文献阅读-基因型填充</title>
    <url>/posts/2ca177e4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>关于基因型填充的文献总结。</p>
<span id="more"></span>
<h1>亲属个体间的基因型填充</h1>
<p>在下图中，所有个体均存在分型的位点标为红色，前两个世代的个体存在分型的位点标为黑色 (见图 A)。根据前两个世代的基因型数据，可以对前两个世代的基因型进行定相，然后再第三世代的个体基因型进行定相（见图 B）。最后，第三世代所有个体缺失的基因型可以通过比对它们自身的单倍型与家系中其它个体的单倍型 （二者同源相同，IBD）来推断缺失位点的基因型（见图 C）。</p>
<p><img src="1.png" alt="1"></p>
<p>从 图A 到图B根据系谱信息定向的原理解释如下，亲子对在每个位点都共享一个碱基，并且共享的碱基是 IBD 的，因此亲本和子代在一条染色体上共享一个相同的单倍型（假设没有重组事件）。</p>
<p>下图就是根据 IBD 来定相的一个例子，这两个个体在这 4 个位点共享一个 IBD 的单倍型块（比如亲子对）。对于某个位点，只要其中一个个体的基因型为纯合子，那么 IBD 的单倍型在这个位点的分型就是这个纯合子的碱基。因此，只有当两个个体在某个位点均为杂合子时（或者存在缺失），这个位点的定相才是未知的。</p>
<p>如果同时处理超过 2 个亲属个体，例如<strong>对于 trios 只有当三者均为杂合子（或者存在缺失）时才无法定相</strong>。采用更大的家系会包含更多的信息。</p>
<p><img src="6.png" alt="1"></p>
<p>因此只根据系谱信息无法实现所有个体全部位点的定相，之后还需要使用群体信息定相。并且而且如果存在<strong>分型错误</strong>，那么根据系谱信息定相的比例和准确率都会下降。</p>
<h1>群体信息的基因型填充</h1>
<p>无关个体之间仍存在类似于亲属个体 IBD 片段的共同单倍型片段，只不过它们共享的单倍型片段长度要短得多（因为它们得共同祖先更远），因此也很难完全确定它们之间共享的单倍型片段。</p>
<p>无关个体的基因型填充原理见下图，这里目标样本 (study samples) 具有相对较多的位点（可能是100k 到 1000 k），我们将目标样本与参考单倍型库（比目标样本具有更多的位点）进行比对（下图 A），二者共同的单倍型见图 B ，然后目标样本中的缺失位点可以通过复制匹配上的参考单倍型的基因型来进行填充（下图C）。</p>
<p>当将目标样本的单倍型与参考单倍型库进行比对存在<strong>歧义</strong>，即不知道复制哪一个参考单倍型时，填充脚本一般会提供这个缺失位点的基因型概率（比如单倍型库中观测到的 A/A 比例为 60%，A/C 比例为 40%）。</p>
<p>大部分的单倍型构建软件均会在估计单倍型过程中自动”填充“缺失的基因型。基因型填充软件可以分为两列：一是计算密集型工具，例如 IMPUTE, MACH, fastPHASE/BIMBAM，这些软件在填充缺失位点时会考虑全部观测到的位点；二是计算更加高效的工具，例如 PLINK，TUNA, WHAP, BEAGLE ，这些软件填充缺失位点时只会考虑少量的相邻位点的基因型。</p>
<p><img src="2.png" alt="1"></p>
<h2 id="群体信息定相算法">群体信息定相算法</h2>
<p>总共有三种算法：<code>Clark's algorithm</code> ，<code>EM algorithm</code> 和 <code>Coalescent-based methods and hidden Markov models</code>，目前用的最多是最后一种。</p>
<p>运用 HMM 算法的软件包括，PHASE, fastPHASE, MACH, IMPUTE2 。其中，PHASE 古老，计算慢，但是在所有有的群体信息定相软件中最准确，有时视为金标准 (<strong>SHAPE-IT是其更快的版本</strong>)。fastPHASE 相比于 PHASE  提升了速度，准确性略有下降。</p>
<p>相比于 fastPHASE ， <strong>BEAGLE 速度上快了一个数量级</strong>，但是 BEAGLE  对于<strong>中大型样本（大于 1000</strong>）群体更加准确，不适合小样本（100）。当某个染色体区域的位点数目小于 100 时，BEAGLE 同时不适合。</p>
<p>MACH 和 IMPUTE2 使用了新的统计方法，其可以计算更大的群体，而且准确性比 fastPHASE 更高。</p>
<p>Browning (2011) 比较了 BEAGLE  和 MACH, IMPUTE2 的定相表型，其中<strong>MACH在小样本中准确性最高</strong>，<strong>BEAGLE在大样本中准确性最高</strong>，并且 <strong>BEAGLE计算时间最短</strong>。<strong>三种软件均可以通过提高计算时间来增加填充准确性</strong>。在 MACH 和 IMPUTE2 中，可以通过增加 HMM states 的数目来增加模型复杂度，从而更好地利用数据中的信息，得到更准确的结果。在 BEAGLE 中，可以通过合并多次运行结果来提高准确性（这里使用 beagle 3.3.1 版本，跑 15 次，然后每一个杂合子的定向使用 15次结果中的最多的那个，也就是说之前的 beagle 版本都是每次运行结果不一样的）。</p>
<p><img src="8.png" alt=""></p>
<h1>基因型填充的准确性</h1>
<p>Scott et al. (93) 填充了超过 2百万的位点，提取超过 500 个位点与实验室的实际分型进行比较，总的不一致率只有 1.5%。</p>
<p>第二，通过对 90个样本的超过 660k 的位点的填充基因型和实际分型基因型进行比对，总的不一致率小于 0.9% ，<strong>所有位点的平均 <img src="https://math.now.sh?inline=r%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 达到了 0.93</strong> 。</p>
<h1>基因型填充的作用</h1>
<p>基因型填充的一个作用就是更好地挖掘与性状相关的位点和基因，通过基因型填充，我们可以查看一个关联位点其临近的位点是否也与性状关联，甚至我们可以找到<strong>潜在的因果位点</strong>。</p>
<p>除此之外，基因型填充还可以提高 GWAS 分析的 POWER 。举个例子，Willer et al.  和 Kathiresan et al 发现 rs6511720 这个位点 (在 LDLR 基因中) 与 LDL cholesterol levels 这个性状显著关联，但是由于这个位点不在芯片中，而初始分析只使用了芯片位点，因此初始分析中遗漏了这个选择信号（芯片中的位点与 rs6511720 不存在紧密连锁，最大的配对 r2 只有 0.21）。</p>
<p><img src="3.png" alt="1"></p>
<p>另外一个例子如下</p>
<p><img src="4.png" alt="1"></p>
<p>但是，准确估计填充对于提高关联分析 POWER 的作用非常困难，这里有两种思路，第一种是使用模拟数据，第二种是合并使用基因组数据和基因表达数据。这里第二种方式更加吸引仍，因为我们比较容易确定位点和转录水平的正向关联。这两种思路均建议基因型填充可以提到挖掘基因研究的 power ，特别是对于等位基因频率小于 10% -20% 的位点。</p>
<h1>基因组关联分析的元分析</h1>
<p>基因型填充作用最好的说明可能就是其可以用于对不同检测平台产生的数据的 GWAS 分析结果的元分析（具体怎么做我不清楚）。</p>
<h1>填充的注意事项</h1>
<ol>
<li>
<p>自填充严格质控</p>
</li>
<li>
<p>有参填充需要确保参考群体和填充群体相同位点的两个碱基的标签相同（应该说的是 vcf 文件中的 ref 和 alt）。</p>
</li>
<li>
<p>有参填充需要严格挑选参考群体。比较不同参考群时，可以在填充群中的基因型随机缺失部分位点，然后查看使用不同参考群的填充准确性。</p>
</li>
<li>
<p>填充完成后，不是所有标记都能准确填充，我们需要确定挑选哪些位点用于下一步的分析。</p>
<p>最简单的方法就是看填充位点的一致率（比如挑选大于 90%），但是这里作者并不推荐这种方式，因为位点的一致率还受到 maf 的影响，因此无法直接比较（举个例子，对于 maf 小于 0.05 的位点，那么我们只要将所有样本的分型均分配为最可能的基因型，则一致率就会达到 90% 以上）。</p>
<p>这里我们推荐的方法是使用位点的填充基因型和真实基因型的<strong>相关系数</strong>，通常我们会使用<strong>相关系数的平方</strong>，即 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>最通常的方法是查看填充位点偏离哈温平衡的程度（because imputed allele counts for poorly imputed markers show less variability than expected based on allele frequency，这句话没有太看懂） 。</p>
</li>
<li>
<p>最后一步就是分析填充的基因型，一般来说填充的基因型是服从一个概率分布的，举个例子，某个样本在某个位点可能有 90% 的概率是 A/A ，有 10% 的概率是 A/C ，也就是说，这个位点的Ａ的剂量期望值为 1.9 。</p>
<p>对于 GWAS 分析，这里作者建议不用使用具体的填充基因型（比如上面的 AA），而是可以使用碱基的剂量（即上面的 1.9）来进行关联分析。</p>
</li>
</ol>
<h1>未来的挑战</h1>
<ol>
<li>
<p>希望有更具特色的参考面板（reference panels），可以包含除 SNP 之外的其它变异，比如 CNV 。</p>
</li>
<li>
<p>希望有更好的填充算法。</p>
</li>
<li>
<p><strong>最重要的，希望有更大的参考面板</strong>，如下图，参考群体越大，基因型填充的准确性越高，因为参考群体的样本和目标样本之间共享的单倍型区块长度会越长，而且也越容易在参考面板中<strong>无歧义地</strong>识别共同的单倍型区块。</p>
<p><img src="5.png" alt="1"></p>
</li>
</ol>
<h1>填充和重测序数据</h1>
<p>填充计数可以使得从<strong>低密度重测序数据</strong>得到高质量的分型数据，从而降低测序成本（略微降低数据质量），比如千人基因组计划。</p>
<h1>参考文献</h1>
<ol>
<li>
<p>Li Y, Willer C, Sanna S, et al. Genotype imputation[J]. Annual review of genomics and human genetics, 2009, 10: 387.</p>
</li>
<li>
<p>Browning S R, Browning B L. Haplotype phasing: existing methods and new developments[J]. Nature Reviews Genetics, 2011, 12(10): 703-714.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>基因型填充</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>基因型填充</tag>
      </tags>
  </entry>
  <entry>
    <title>文献阅读-APY方法</title>
    <url>/posts/7aca4f75/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>APY 方法的相应文献。</p>
<span id="more"></span>
<h1>引言</h1>
<p>一步法要对 G  阵求逆，其计算和存储花销是 <img src="https://math.now.sh?inline=n%5E3" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=n%5E2" style="display:inline-block;margin: 0;"/> ，因此当基因型数据量很大时计算量很大。</p>
<p>Misztal (2014) 提出了 APY 算法（an algorithm for proven and young animals）来计算 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> ，这里称为  <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D%5E%7B-1%7D_%7BAPY%7D" style="display:inline-block;margin: 0;"/> ，一开始这里的 proven 指的是初始的个体，young 指的是更年轻的个体。</p>
<p>之后的研究发现（Fragomeni, 2015）发现没有必要通过年纪对个体进行排序，因此此时这个算法将基因型个体划分为核心个体 (core) 和 非核心个体 (noncore) 。 当基因型个体总数为 50万，核心群体数目为 2万是，APY 方法的计算和存储花销分别是常规求逆的 0.3% 和 8% 。</p>
<p>当核心群体数目超过 1万时，APY 方法计算的 GEBV 结果与常规结果非常类似。</p>
<p>之前的重心都关注APY算法的可行性，效率并不是最主要的考虑。这篇文章关注<strong>如何研究出一个高效的 APY 算法</strong>，并用实际的奶牛数据进行计算。</p>
<h1>方法</h1>
<p>常规的 G 阵构建方法如下（VanRaden, 2008）</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BG%7D%3D%5Cfrac%7B%5Cmathbf%7BZ%20Z%7D%5E%7B%5Cprime%7D%7D%7B2%20%5Csum%20p_j%5Cleft%281-p_j%5Cright%29%7D%20%5Ctext%20%7B%20and%20%7D%20%5Cmathbf%7BZ%7D%3D(%5Cmathbf%7BM%7D-%5Cmathbf%7BP%7D)%0A" /></p><p>这里 <img src="https://math.now.sh?inline=p_%7Bj%7D" style="display:inline-block;margin: 0;"/> 是第二个碱基的基因频率（当前的基因型个体），M 矩阵包含所有位点的基因型，P 矩阵包含 <img src="https://math.now.sh?inline=2p_%7Bj%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>我们将 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵分成 4 块：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BG%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BG%7D_%7Bc%20c%7D%20%26%20%5Cmathbf%7BG%7D_%7Bc%20n%7D%20%5C%5C%0A%5Cmathbf%7BG%7D_%7Bn%20c%7D%20%26%20%5Cmathbf%7BG%7D_%7Bn%20n%7D%0A%5Cend%7Barray%7D%5Cright%5D%2C%0A" /></p><p>这里下标 c 为核心群体，n 为非核心群体。这里的 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/>  经过了 blending 从而确保其为非奇异矩阵，  即 <img src="https://math.now.sh?inline=0.95%5Cmathbf%7BG%7D%2B0.05%5Cmathbf%7BA%7D_%7B22%7D" style="display:inline-block;margin: 0;"/>。<strong>这里的 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B22%7D" style="display:inline-block;margin: 0;"/> 矩阵使用 (Aguilar, 2011) 中的算法得到</strong>，但是只使用其中相对于 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7Bcc%7D" style="display:inline-block;margin: 0;"/> , <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7Bcn%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7Bnn%7D" style="display:inline-block;margin: 0;"/> 对角线位置的元素加入到 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵中。然后对 blending 之后的 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵进行 scale ，使得其对角线元素矩阵和非对角线元素均值与 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B22%7D" style="display:inline-block;margin: 0;"/> 矩阵相同。</p>
<p>然后我们计算 APY 逆，公式如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%20%5Cmathbf%7BG%7D_%7B%5Cmathrm%7BAPY%7D%7D%5E%7B-1%7D%3D%20%7B%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BG%7D_%7Bc%20c%7D%5E%7B-1%7D%2B%5Cmathbf%7BG%7D_%7Bc%20c%7D%5E%7B-1%7D%20%5Cmathbf%7BG%7D_%7Bc%20n%7D%20%5Cmathbf%7BM%7D_%7Bn%20n%7D%5E%7B-1%7D%20%5Cmathbf%7BG%7D_%7Bc%20n%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BG%7D_%7Bc%20c%7D%5E%7B-1%7D%20%26%20-%5Cmathbf%7BG%7D_%7Bc%20c%7D%5E%7B-1%7D%20%5Cmathbf%7BG%7D_%7Bc%20n%7D%20%5Cmathbf%7BM%7D_%7Bn%20n%7D%5E%7B-1%7D%20%5C%5C%0A-%5Cmathbf%7BM%7D_%7Bn%20n%7D%5E%7B-1%7D%20%5Cmathbf%7BG%7D_%7Bc%20n%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BG%7D_%7Bc%20c%7D%5E%7B-1%7D%20%26%20%5Cmathbf%7BM%7D_%7Bn%20n%7D%5E%7B-1%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%7D%20%5C%5C%0A%26%3D%20%7B%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BG%7D_%7B%5Cmathrm%7BAPY%7D%7D%5E%7Bc%20c%7D%20%26%20%5Cmathbf%7BG%7D_%7B%5Cmathrm%7BAPY%7D%7D%5E%7Bc%20n%7D%20%5C%5C%0A%5Cmathbf%7BG%7D_%7B%5Cmathrm%7BAPY%7D%7D%5E%7Bc%20n%7D%20%26%20%5Cmathbf%7BM%7D_%7Bn%20n%7D%5E%7B-1%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5Ctext%20%7B%20and%20%7D%20%7D%20%5C%5C%0A%26%20%5Cmathbf%7BM%7D_%7Bn%20n%7D%3D%5Coperatorname%7Bdiag%7D%5Cleft%5C%7Bg_%7Bi%20i%7D-%5Cmathbf%7Bg%7D_%7Bc%20i%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BG%7D_%7Bc%20c%7D%5E%7B-1%7D%20%5Cmathbf%7Bg%7D_%7Bc%20i%7D%5Cright%5C%7D%2C%0A%5Cend%7Baligned%7D%0A" /></p><p>这里<img src="https://math.now.sh?inline=g_%7Bii%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7Bnn%7D" style="display:inline-block;margin: 0;"/> 的第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 个对角线元素， <img src="https://math.now.sh?inline=%5Cmathbf%7Bg%7D_%7Bci%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7Bcn%7D" style="display:inline-block;margin: 0;"/> 的第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 列，<img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D_%7Bnn%7D" style="display:inline-block;margin: 0;"/> 是一个对角线矩阵。</p>
<p>下面是为了实现高效计算需要注意的地方：</p>
<ol>
<li>基因型需要压缩为二进制格式（如plink的 bed 文件），以节约内存。</li>
<li>我们需要完整计算 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7Bcc%7D" style="display:inline-block;margin: 0;"/>  和  <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7Bcn%7D" style="display:inline-block;margin: 0;"/>， 但是 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7Bnn%7D" style="display:inline-block;margin: 0;"/> 矩阵只需要计算对角线元素，保存为一个向量。</li>
<li>我们通过 <strong>LAPACK</strong> (the Linear Algebra Package) 包 (Aguilar, 2011) 对 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7Bcc%7D" style="display:inline-block;margin: 0;"/> 矩阵进行更新覆盖得到  <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7Bcc%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> ，那么  <img src="https://math.now.sh?inline=-%20%5Cmathbf%7BG%7D_%7Bcc%7D%5E%7B-1%7D%5Cmathbf%7BG%7D_%7Bcn%7D" style="display:inline-block;margin: 0;"/> 会临时存储在内存中，而 <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D_%7Bnn%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 中的对角线元素会替换 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7Bnn%7D" style="display:inline-block;margin: 0;"/> 矩阵中的元素。最终  <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7Bcc%7D" style="display:inline-block;margin: 0;"/>  和  <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7Bcn%7D" style="display:inline-block;margin: 0;"/> 会覆盖为   <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D%5E%7Bcc%7D_%7BAPY%7D" style="display:inline-block;margin: 0;"/>  和  <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D%5E%7Bcn%7D_%7BAPY%7D" style="display:inline-block;margin: 0;"/> 。<strong>BLAS</strong> (the Basic Linear Algebra Subprograms) 用于密集矩阵操作(Aguilar, 2011) 。</li>
</ol>
<p>ssGBLUP 同样需要 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> ， 这个矩阵是一个密集矩阵，并且不能保存在内存中。当我们使用 PCG 方法来求解 MME 时，每一轮迭代我们只需要计算  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 和一个向量 (称为 <img src="https://math.now.sh?inline=%5Cmathbf%7Bq%7D" style="display:inline-block;margin: 0;"/> ) 的乘积，这个乘积可以通过下面的公式得到（Strandén and Mäntysaari (2014)）：</p>
<p style=""><img src="https://math.now.sh?from=A_%7B22%7D%5E%7B-1%7D%3DA%5E%7B22%7D-%5Cleft%28A%5E%7B12%7D%5Cright%29%5E%7B%5Cprime%7D%5Cleft(A%5E%7B11%7D%5Cright)%5E%7B-1%7D%5Cleft(A%5E%7B12%7D%5Cright)%0A" /></p><p style=""><img src="https://math.now.sh?from=A_%7B22%7D%5E%7B-1%7D%20q%3DA%5E%7B22%7D%20q-%5Cleft%28A%5E%7B12%7D%5Cright%29%5E%7B%5Cprime%7D%5Cleft%5B%5Cleft(A%5E%7B11%7D%5Cright)%5E%7B-1%7D%5Cleft%5BA%5E%7B12%7D%20q%5Cright%5D%5Cright%5D%0A" /></p><p>其中右手项的所有元素均是 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 矩阵的子矩阵，即</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BA%7D_%7B11%7D%20%26%20%5Cmathbf%7BA%7D_%7B12%7D%20%5C%5C%0A%5Cmathbf%7BA%7D_%7B21%7D%20%26%20%5Cmathbf%7BA%7D_%7B22%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5Ctext%20%7B%20and%20%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BA%7D%5E%7B11%7D%20%26%20%5Cmathbf%7BA%7D%5E%7B12%7D%20%5C%5C%0A%5Cmathbf%7BA%7D%5E%7B21%7D%20%26%20%5Cmathbf%7BA%7D%5E%7B22%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>每一次计算 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7Bq%7D" style="display:inline-block;margin: 0;"/> 均通过一系列系数矩阵操作得到：<img src="https://math.now.sh?inline=%5Cmathbf%7Bt%20%3D%20A%5E%7B22%7Dq%7D" style="display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%20%3D%20A%5E%7B12%7Dq%7D" style="display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=%5Cmathbf%7By%20%3D%20%28A%5E%7B11%7D%29%5E%7B%E2%88%921%7D%20x%7D" style="display:inline-block;margin: 0;"/> , <img src="https://math.now.sh?inline=%5Cmathbf%7Bz%20%3D%20%28A%5E%7B12%7D%29%5E%7B%5Cprime%7Dy%7D" style="display:inline-block;margin: 0;"/>,  <img src="https://math.now.sh?inline=%5Cmathbf%7BA_%7B22%7D%5E%7B%E2%88%921%7Dq%20%3D%20t%20%E2%88%92%20z%7D" style="display:inline-block;margin: 0;"/>  。 其中 <img src="https://math.now.sh?inline=%5Cmathbf%7Bt%2Cx%2Cy%2Cz%7D" style="display:inline-block;margin: 0;"/> 均为临时向量。</p>
<p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7By%20%3D%20%28A%5E%7B11%7D%29%5E%7B%E2%88%921%7D%20x%7D" style="display:inline-block;margin: 0;"/> 可以改为方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B11%7Dy%20%3D%20%20x%7D" style="display:inline-block;margin: 0;"/> ，因此我们需要对 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B11%7D" style="display:inline-block;margin: 0;"/> 矩阵进行 Cholesky 分解，我们可以使用 FSPAK 或 YAMS 来实现这一点。在实际中，因为结果相同，上面的表达式只考虑基因型个体（在矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B22%7D" style="display:inline-block;margin: 0;"/> 中）和<strong>基因型个体的未检测基因型的祖先</strong> （在矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B11%7D" style="display:inline-block;margin: 0;"/> 中）（很好理解，就相当于对基因型个体追系谱了）。</p>
<p>我们将上面提到的算法应用到 <strong>BLUP90IOD2</strong> 程序中，其中通过 PCG 方法求解 MME 。这个脚本通过 Intel Fortran Compiler 14.0  进行编译。我们使用 the Intel Math Kernel Library 11.0 中的 BLAS 和 LAPACK 包。</p>
<h1>参考文献</h1>
<ol>
<li>Masuda Y, Misztal I, Tsuruta S, et al. Implementation of genomic recursions in single-step genomic best linear unbiased predictor for US Holsteins with a large number of genotyped animals[J]. Journal of Dairy Science, 2016, 99(3): 1968-1974.</li>
<li>Aguilar, I., I. Misztal, A. Legarra, and S. Tsuruta. 2011. Efficient computation of the genomic relationship matrix and other matrices  used in single-step evaluation. J. Anim. Breed. Genet. 128:422–428.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>舒尔补公式</title>
    <url>/posts/c7f3d98a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>有关舒尔补的一些公式，主要是涉及 <img src="https://math.now.sh?inline=2%20%5Ctimes%202" style="display:inline-block;margin: 0;"/> 的分块矩阵的求逆和行列式。</p>
<span id="more"></span>
<h1>舒尔补</h1>
<p>对于一个非奇异的分块矩阵，其逆矩阵可以写为（假设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 可逆）</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BA%7D%20%26%20%5Cmathbf%7BB%7D%20%5C%5C%0A%5Cmathbf%7BC%7D%20%26%20%5Cmathbf%7BD%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%5E%7B-1%7D%20%3D%20%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BA%7D%5E%7B-1%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%2B%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A-%5Cmathbf%7BA%7D%5E%7B-1%7D%5Cmathbf%7BB%7D%20%5C%5C%0A%5Cmathbf%7BI%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%28%5Cmathbf%7BD-CA%5E%7B-1%7DB%7D%29%5E%7B-1%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7B-CA%5E%7B-1%7D%7D%20%26%20%5Cmathbf%7BI%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>其中矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BD-CA%5E%7B-1%7DB%7D" style="display:inline-block;margin: 0;"/> 称为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的舒尔补 (Schur complement) 。</p>
<p>类似地，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BA%7D%20%26%20%5Cmathbf%7BB%7D%20%5C%5C%0A%5Cmathbf%7BC%7D%20%26%20%5Cmathbf%7BD%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%5E%7B-1%7D%20%3D%20%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BD%7D%5E%7B-1%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%2B%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BI%7D%20%5C%5C%0A-%5Cmathbf%7BD%7D%5E%7B-1%7D%5Cmathbf%7BC%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%28%5Cmathbf%7BA%7D-%5Cmathbf%7BB%20D%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%29%5E%7B-1%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BI%7D%20%26%20%5Cmathbf%7B-BD%5E%7B-1%7D%7D%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>其中矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D-%5Cmathbf%7BB%20D%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 称为矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D" style="display:inline-block;margin: 0;"/> 的舒尔补。</p>
<p>Marsaglia 和 Styan (1974a,b) 给出了两个重要公式，分别为（第二个式子可以理解为将 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 替换成了  <img src="https://math.now.sh?inline=%5Cmathbf%7B-A%7D" style="display:inline-block;margin: 0;"/> ）。</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cmathbf%7BD%7D-%5Cmathbf%7BC%20A%7D%5E%7B-1%7D%20%5Cmathbf%7BB%7D%5Cright%29%5E%7B-1%7D%3D%5Cmathbf%7BD%7D%5E%7B-1%7D%2B%5Cmathbf%7BD%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%5Cleft(%5Cmathbf%7BA%7D-%5Cmathbf%7BB%20D%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BB%20D%7D%5E%7B-1%7D%2C%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cmathbf%7BD%7D%2B%5Cmathbf%7BC%20A%7D%5E%7B-1%7D%20%5Cmathbf%7BB%7D%5Cright%29%5E%7B-1%7D%3D%5Cmathbf%7BD%7D%5E%7B-1%7D-%5Cmathbf%7BD%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%5Cleft(%5Cmathbf%7BA%7D%2B%5Cmathbf%7BB%20D%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BB%20D%7D%5E%7B-1%7D%20%5Ctext%20%7B%2C%20%7D%0A" /></p><p>证明就是用右手项乘以  <img src="https://math.now.sh?inline=%5Cmathbf%7BD-CA%5E%7B-1%7DB%7D" style="display:inline-block;margin: 0;"/> ，证明过程略。</p>
<p><img src="https://math.now.sh?inline=%5Cmathbf%7BD-CA%5E%7B-1%7DB%7D" style="display:inline-block;margin: 0;"/> 的行列式推导如下，首先根据行列式性质，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BR%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BT%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%3D%20%7C%5Cmathbf%7BR%7D%7C%7C%5Cmathbf%7BT%7D%7C%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BR%7D%5E%7B%5Cprime%7D%20%26%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BT%7D%5E%7B%5Cprime%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%20%0A" /></p><p>因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Bdet%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BA%7D%20%26%20%5Cmathbf%7BB%7D%20%5C%5C%0A%5Cmathbf%7BC%7D%20%26%20%5Cmathbf%7BD%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%26%3D%5Coperatorname%7Bdet%7D%5Cleft%28%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BA%7D%20%26%20%5Cmathbf%7BO%7D%20%5C%5C%0A%5Cmathbf%7BC%7D%20%26%20%5Cmathbf%7BD%7D-%5Cmathbf%7BC%20A%7D%5E%7B-1%7D%20%5Cmathbf%7BB%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BI%7D%20%26%20%5Cmathbf%7BA%7D%5E%7B-1%7D%20%5Cmathbf%7BB%7D%20%5C%5C%0A%5Cmathbf%7BO%7D%20%26%20%5Cmathbf%7BI%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cright%29%20%5C%5C%0A%26%3D%7C%5Cmathbf%7BA%7D%7C%20%7C%5Cmathbf%7BD%7D-%5Cmathbf%7BC%20A%7D%5E%7B-1%7D%20%5Cmathbf%7BB%7D%7C%0A%5Cend%7Baligned%7D%0A" /></p><p>类似的，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Bdet%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BA%7D%20%26%20%5Cmathbf%7BB%7D%20%5C%5C%0A%5Cmathbf%7BC%7D%20%26%20%5Cmathbf%7BD%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%26%3D%5Coperatorname%7Bdet%7D%5Cleft%28%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7B%5Cmathbf%7BA%7D-%5Cmathbf%7BB%20D%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%7D%20%26%20%5Cmathbf%7BB%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BD%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BI%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7BD%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%20%26%20%5Cmathbf%7BI%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cright%29%20%5C%5C%0A%26%3D%7C%5Cmathbf%7BD%7D%7C%20%7C%5Cmathbf%7BA%7D-%5Cmathbf%7BB%20D%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%7C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%7C%5Cmathbf%7BD%7D-%5Cmathbf%7BC%20A%7D%5E%7B-1%7D%20%5Cmathbf%7BB%7D%7C%20%3D%20%28%7C%5Cmathbf%7BD%7D%7C%2F%7C%5Cmathbf%7BA%7D%7C%29%20%7C%5Cmathbf%7BA%7D-%5Cmathbf%7BB%20D%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%7C%0A" /></p><h1>参考文献</h1>
<ol>
<li>Searle S R, Casella G, McCulloch C E. Variance components[M]. John Wiley &amp; Sons, 2009.</li>
<li>Matsaglia G, PH Styan G. Equalities and inequalities for ranks of matrices[J]. Linear and multilinear Algebra, 1974, 2(3): 269-292.</li>
<li>Marsaglia G, Styan G P H. Rank conditions for generalized inverses of partitioned matrices[J]. Sankhyā: The Indian Journal of Statistics, Series A, 1974: 437-442.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>混合模型方程组的迭代求解</title>
    <url>/posts/bdd0ca05/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>当数据量很大时，对混合模型方程组的系数矩阵直接求逆困难或不可实现，需要采用迭代求解的方法。</p>
<span id="more"></span>
<h1>迭代求解的基本方法</h1>
<h2 id="雅可比迭代法">雅可比迭代法</h2>
<p>设有线性方程组</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BAb%7D%20%3D%20%5Cmathbf%7Br%7D%0A" /></p><p>其中，<img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=p%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的系数矩阵；<img src="https://math.now.sh?inline=%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> 为待求解的 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> 维向量；<img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D" style="display:inline-block;margin: 0;"/> 为右手项的 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> 维向量。</p>
<p>如果见矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 分解为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%20%3D%20%5Cmathbf%7BM%2BN%7D%0A" /></p><p>其中，<img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D" style="display:inline-block;margin: 0;"/> 为一可逆矩阵，将其代入上式，则有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BMb%7D%20%3D%20%5Cmathbf%7B-Nb%2Br%7D%0A" /></p><p>或写成</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bb%7D%20%3D%20%5Cmathbf%7BQb%20%2Bf%7D%0A" /></p><p>其中，<img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D%20%3D%20%5Cmathbf%7B-M%5E%7B-1%7DN%7D" style="display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cmathbf%7Bf%7D%20%3D%20%5Cmathbf%7BM%5E%7B-1%7Dr%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>那么我们可以构建出迭代方法</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bb%5E%7B%28t%2B1%29%7D%7D%20%3D%20%5Cmathbf%7BQb%5E%7B(t)%7D%2Bf%7D%0A" /></p><p>如果在 <img src="https://math.now.sh?inline=t%20%5Crightarrow%20%5Cinfty" style="display:inline-block;margin: 0;"/> 时 ,  <img src="https://math.now.sh?inline=%5Cmathbf%7Bb%5E%7B%28t%29%7D%7D%20%5Crightarrow%20%5Cmathbf%7Bb%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> ，我们称迭代收敛，且 <img src="https://math.now.sh?inline=%5Cmathbf%7Bb%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> 就是该方程组的解。</p>
<p>例如，对于 <img src="https://math.now.sh?inline=p%20%3D3" style="display:inline-block;margin: 0;"/> 时，设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%3D%20%5C%7Ba_%7Bij%7D%5C%7D" style="display:inline-block;margin: 0;"/> ，<strong>其对角线元素均不为0</strong>，即 <img src="https://math.now.sh?inline=a_%7Bii%7D%20%5Cneq%200" style="display:inline-block;margin: 0;"/> ，则我们可取 <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BN%7D" style="display:inline-block;margin: 0;"/> 为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BM%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D%0Aa_%7B11%7D%20%26%200%20%26%200%20%5C%5C%0A0%20%26%20a_%7B22%7D%20%26%200%20%5C%5C%0A0%20%26%200%20%26%20a_%7B33%7D%0A%5Cend%7Barray%7D%5Cright%5D%2C%20%5Cmathbf%7BN%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D%0A0%20%26%20a_%7B12%7D%20%26%20a_%7B13%7D%20%5C%5C%0Aa_%7B21%7D%20%26%200%20%26%20a_%7B23%7D%20%5C%5C%0Aa_%7B31%7D%20%26%20a_%7B32%7D%20%26%200%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>那么我们可以得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BQ%7D%20%26%3D%20%5Cmathbf%7B-M%5E%7B-1%7DN%7D%20%5C%5C%0A%26%3D-%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D%0A1%2Fa_%7B11%7D%20%26%200%20%26%200%20%5C%5C%0A0%20%26%201%2Fa_%7B22%7D%20%26%200%20%5C%5C%0A0%20%26%200%20%26%201%2Fa_%7B33%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D%0A0%20%26%20a_%7B12%7D%20%26%20a_%7B13%7D%20%5C%5C%0Aa_%7B21%7D%20%26%200%20%26%20a_%7B23%7D%20%5C%5C%0Aa_%7B31%7D%20%26%20a_%7B32%7D%20%26%200%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%3D%0A%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D%0A0%20%26%20-%5Cfrac%7Ba_%7B12%7D%7D%7Ba_%7B11%7D%7D%20%26%20-%5Cfrac%7Ba_%7B13%7D%7D%7Ba_%7B11%7D%7D%20%5C%5C%0A-%5Cfrac%7Ba_%7B21%7D%7D%7Ba_%7B22%7D%7D%20%26%200%20%26%20-%5Cfrac%7Ba_%7B23%7D%7D%7Ba_%7B22%7D%7D%20%5C%5C%0A-%5Cfrac%7Ba_%7B31%7D%7D%7Ba_%7B33%7D%7D%20%26%20-%5Cfrac%7Ba_%7B32%7D%7D%7Ba_%7B33%7D%7D%20%26%200%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%5C%5C%0A%0A%5Cmathbf%7Bf%7D%20%26%3D%20%5Cmathbf%7BM%5E%7B-1%7Dr%7D%20%5C%5C%0A%26%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D%0A1%2Fa_%7B11%7D%20%26%200%20%26%200%20%5C%5C%0A0%20%26%201%2Fa_%7B22%7D%20%26%200%20%5C%5C%0A0%20%26%200%20%26%201%2Fa_%7B33%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D%0Ar_%7B1%7D%20%5C%5C%0Ar_%7B2%7D%20%5C%5C%0Ar_%7B3%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cfrac%7Br_%7B1%7D%7D%7Ba_%7B11%7D%7D%20%5C%5C%0A%5Cfrac%7Br_%7B2%7D%7D%7Ba_%7B22%7D%7D%20%5C%5C%0A%5Cfrac%7Br_%7B3%7D%7D%7Ba_%7B33%7D%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们有方程组</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0Ab_%7B1%7D%20%5C%5C%0Ab_%7B2%7D%20%5C%5C%0Ab_%7B3%7D%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D%0A0%20%26%20-%5Cfrac%7Ba_%7B12%7D%7D%7Ba_%7B11%7D%7D%20%26%20-%5Cfrac%7Ba_%7B13%7D%7D%7Ba_%7B11%7D%7D%20%5C%5C%0A-%5Cfrac%7Ba_%7B21%7D%7D%7Ba_%7B22%7D%7D%20%26%200%20%26%20-%5Cfrac%7Ba_%7B23%7D%7D%7Ba_%7B22%7D%7D%20%5C%5C%0A-%5Cfrac%7Ba_%7B31%7D%7D%7Ba_%7B33%7D%7D%20%26%20-%5Cfrac%7Ba_%7B32%7D%7D%7Ba_%7B33%7D%7D%20%26%200%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0Ab_%7B1%7D%20%5C%5C%0Ab_%7B2%7D%20%5C%5C%0Ab_%7B3%7D%0A%5Cend%7Barray%7D%5Cright%5D%2B%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cfrac%7Br_%7B1%7D%7D%7Ba_%7B11%7D%7D%20%5C%5C%0A%5Cfrac%7Br_%7B2%7D%7D%7Ba_%7B22%7D%7D%20%5C%5C%0A%5Cfrac%7Br_%7B3%7D%7D%7Ba_%7B33%7D%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>即</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bl%7D%0Ab_%7B1%7D%3D%5Cleft%28r_%7B1%7D-a_%7B12%7D%20b_%7B2%7D-a_%7B13%7D%20b_%7B3%7D%5Cright%29%20%2F%20a_%7B11%7D%20%5C%5C%0Ab_%7B2%7D%3D%5Cleft(r_%7B2%7D-a_%7B21%7D%20b_%7B1%7D-a_%7B23%7D%20b_%7B3%7D%5Cright)%20%2F%20a_%7B22%7D%20%5C%5C%0Ab_%7B3%7D%3D%5Cleft(r_%7B3%7D-a_%7B31%7D%20b_%7B1%7D-a_%7B32%7D%20b_%7B2%7D%5Cright)%20%2F%20a_%7B33%7D%0A%5Cend%7Barray%7D%5Cright.%0A" /></p><p>因此，我们得到了一个迭代公式</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bl%7D%0Ab_%7B1%7D%5E%7B%28t%2B1%29%7D%3D%5Cleft(r_%7B1%7D-a_%7B12%7D%20b_%7B2%7D%5E%7B(t)%7D-a_%7B13%7D%20b_%7B3%7D%5E%7B(t)%7D%5Cright)%20%2F%20a_%7B11%7D%20%5C%5C%0Ab_%7B2%7D%5E%7B(t%2B1)%7D%3D%5Cleft(r_%7B2%7D-a_%7B21%7D%20b_%7B1%7D%5E%7B(t)%7D-a_%7B23%7D%20b_%7B3%7D%5E%7B(t)%7D%5Cright)%20%2F%20a_%7B22%7D%20%5C%5C%0Ab_%7B3%7D%5E%7B(t%2B1)%7D%3D%5Cleft(r_%7B3%7D-a_%7B31%7D%20b_%7B1%7D%5E%7B(t)%7D-a_%7B32%7D%20b_%7B2%7D%5E%7B(t)%7D%5Cright)%20%2F%20a_%7B33%7D%0A%5Cend%7Barray%7D%5Cright.%0A" /></p><p>将上面的情形推广至一般情况，即可以将 <img src="https://math.now.sh?inline=%5Cmathbf%7BAb%7D%20%3D%20%5Cmathbf%7Br%7D" style="display:inline-block;margin: 0;"/> 改写为</p>
<p style=""><img src="https://math.now.sh?from=b_%7Bi%7D%3D%5Cleft%28r_%7Bi%7D-%5Csum_%7Bj%3D1%7D%5E%7Bi-1%7D%20a_%7Bi%20j%7D%20b_%7Bj%7D-%5Csum_%7Bj%3Di%2B1%7D%5E%7Bp%7D%20a_%7Bi%20j%7D%20b_%7Bj%7D%5Cright%29%20%2F%20a_%7Bi%20i%7D%2C%20%5Cquad%20(i%3D1%2C2%2C%5Ccdots%2Cp)%0A" /></p><p>由此可得如下的一般迭代式</p>
<p style=""><img src="https://math.now.sh?from=b_%7Bi%7D%5E%7B%28t%2B1%29%7D%3D%5Cleft(r_%7Bi%7D-%5Csum_%7Bj%3D1%7D%5E%7Bi-1%7D%20a_%7Bi%20j%7D%20b_%7Bj%7D%5E%7B(t)%7D-%5Csum_%7Bj%3Di%2B1%7D%5E%7Bp%7D%20a_%7Bi%20j%7D%20b_%7Bj%7D%5E%7B(t)%7D%5Cright)%20%2F%20a_%7Bi%20i%7D%2C%20%5Cquad%20(i%3D1%2C2%2C%5Ccdots%2Cp)%0A" /></p><p>或者写成</p>
<p style=""><img src="https://math.now.sh?from=b_%7Bi%7D%5E%7B%28t%2B1%29%7D%3Db_%7Bi%7D%5E%7B(t)%7D%2B%5Cleft(r_%7Bi%7D-%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20a_%7Bi%20j%7D%20b_%7Bj%7D%5E%7B(t)%7D%5Cright)%20%2F%20a_%7Bi%20i%7D%2C%20%5Cquad%20i%3D1%2C%20%5Ccdots%2C%20p%0A" /></p><p>写成矩阵的形式，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bb%5E%7B%28t%2B1%29%7D%7D%3D%20%5Cmathbf%7Bb%5E%7B(t)%7D%2BD%5E%7B-1%7D%5Cleft(r-A%20b%5E%7B(t)%7D%5Cright)%7D%0A" /></p><p>或者</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bb%5E%7B%28t%2B1%29%7D%7D%20%3D%20%5Cmathbf%7BD%5E%7B-1%7D%5Cleft%5Br-(A-D)%20b%5E%7B(t)%7D%5Cright%5D%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D%20%3D%20Diag%5C%7B%5Cmathbf%7BA%7D%5C%7D" style="display:inline-block;margin: 0;"/> ，是由 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 中的对角线元素构成的对角线矩阵。</p>
<p>这个迭代法称为 <strong>雅可比</strong> (Jacobi) 迭代法。在计算时一般按 <img src="https://math.now.sh?inline=b_%7B1%7D%5E%7B%28t%2B1%29%7D%2C%20b_%7B2%7D%5E%7B(t%2B1)%7D%2C%20%5Ccdots" style="display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=b_%7Bp%7D%5E%7B%28t%2B1%29%7D" style="display:inline-block;margin: 0;"/> 的顺序进行。注意在计算 <img src="https://math.now.sh?inline=b_%7Bi%7D%5E%7B%28t%2B1%29%7D" style="display:inline-block;margin: 0;"/> 时, 在它前面的 <img src="https://math.now.sh?inline=b_%7B1%7D%5E%7B%28t%2B1%29%7D%2C%20%5Ccdots%2C%20b_%7Bi-1%7D%5E%7B(t%2B1)%7D" style="display:inline-block;margin: 0;"/> 已经计算出 来了, 而雅可比法并不利用这些最新的迭代值, 仍用 <img src="https://math.now.sh?inline=b_%7B1%7D%5E%7B%28t%29%7D%2C%20%5Ccdots%2C%20b_%7Bi-1%7D%5E%7B(t)%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>写成伪代码的格式为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Ctext%7Bdo%20i%3D1%2Cn%7D%26%20%5C%5C%0A%26b_%7Bi%7D%5E%7B%28t%2B1%29%7D%3Db_%7Bi%7D%5E%7B(t)%7D%2B%5Cleft(r_%7Bi%7D-%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20a_%7Bi%20j%7D%20b_%7Bj%7D%5E%7B(t)%7D%5Cright)%20%2F%20a_%7Bi%20i%7D%20%5C%5C%0A%5Ctext%7Bend%20do%7D%26%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><h3 id="另一种理解">另一种理解</h3>
<p>假设系数矩阵的对角线元素均不为0 （如果存在某些行的对角线元素为 0 ，可以与邻近的行进行交换位置），那么雅可比迭代法其实就是用第一个方程计算 <img src="https://math.now.sh?inline=%5Chat%7Bb%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> ，用第二个方程计算 <img src="https://math.now.sh?inline=%5Chat%7Bb%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> ，依次类推。以上面的 <img src="https://math.now.sh?inline=p%3D3" style="display:inline-block;margin: 0;"/> 的例子为例，我们将方程组写成标量形式，即：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26a_%7B11%7D%20b_%7B1%7D%2Ba_%7B12%7D%20b_%7B2%7D%2Ba_%7B13%7D%20b_%7B3%7D%3Dr_%7B1%7D%20%5C%5C%0A%26a_%7B21%7D%20b_%7B1%7D%2Ba_%7B22%7D%20b_%7B2%7D%2Ba_%7B23%7D%20b_%7B3%7D%3Dr_%7B2%7D%20%5C%5C%0A%26a_%7B31%7D%20b_%7B1%7D%2Ba_%7B32%7D%20b_%7B2%7D%2Ba_%7B33%7D%20b_%7B3%7D%3Dr_%7B3%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>用第一个方程计算 <img src="https://math.now.sh?inline=%5Chat%7Bb%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> ，用第二个方程计算 <img src="https://math.now.sh?inline=%5Chat%7Bb%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> ，用第三个方程计算 <img src="https://math.now.sh?inline=%5Chat%7Bb%7D_%7B3%7D" style="display:inline-block;margin: 0;"/> ，得到下式</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26b_%7B1%7D%5E%7B%28t%2B1%29%7D%3D%5Cleft(1%20%2F%20a_%7B11%7D%5Cright)%5Cleft(r_%7B1%7D-a_%7B12%7D%20b_%7B2%7D%5E%7B(t)%7D-a_%7B13%7D%20b_%7B3%7D%5E%7B(t)%7D%5Cright)%20%5C%5C%0A%26b_%7B2%7D%5E%7B(t%2B1)%7D%3D%5Cleft(1%20%2F%20a_%7B22%7D%5Cright)%5Cleft(r_%7B2%7D-a_%7B21%7D%20b_%7B1%7D%5E%7B(t)%7D-a_%7B23%7D%20b_%7B3%7D%5E%7B(t)%7D%5Cright)%20%5C%5C%0A%26b_%7B3%7D%5E%7B(t%2B1)%7D%3D%5Cleft(1%20%2F%20c_%7B33%7D%5Cright)%5Cleft(r_%7B3%7D-c_%7B31%7D%20b_%7B1%7D%5E%7B(t)%7D-c_%7B32%7D%20b_%7B2%7D%5E%7B(t)%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>我们同样得到雅可比的迭代公式，这种方式更好理解一点。</p>
<h2 id="GS迭代法">GS迭代法</h2>
<p>如果我们对这一点进行修改, 即在每个 <img src="https://math.now.sh?inline=b_%7Bi%7D%5E%7B%28u%2B1%29%7D" style="display:inline-block;margin: 0;"/> 的计算中尽量利用最新的迭代值, 于是有</p>
<p style=""><img src="https://math.now.sh?from=b_%7Bi%7D%5E%7B%28t%2B1%29%7D%3D%5Cleft(r_%7Bi%7D-%5Csum_%7Bj%3D1%7D%5E%7Bi-1%7D%20a_%7Bi%20j%7D%20b_%7Bj%7D%5E%7B(t%2B1)%7D-%5Csum_%7Bj%3Di%2B1%7D%5E%7Bp%7D%20a_%7Bi%20j%7D%20b_%7Bj%7D%5E%7B(t)%7D%5Cright)%20%2F%20a_%7Bi%20i%7D%0A" /></p><p>或者</p>
<p style=""><img src="https://math.now.sh?from=b_%7Bi%7D%5E%7B%28t%2B1%29%7D%3Db_%7Bi%7D%5E%7B(t)%7D%2B%5Cleft(r_%7Bi%7D-%5Csum_%7Bj%3D1%7D%5E%7Bi-1%7D%20a_%7Bi%20j%7D%20b_%7Bj%7D%5E%7B(t%2B1)%7D-%5Csum_%7Bj%3Di%7D%5E%7Bp%7D%20a_%7Bi%20j%7D%20b_%7Bj%7D%5E%7B(t)%7D%5Cright)%20%2F%20a_%7Bi%20i%7D%0A" /></p><p>这种迭代方法称为 <strong>高斯-塞德尔</strong> (Gauss-Seidel, GS) 迭代法。此时编程更加容易，因为新解可以直接覆盖旧的解。伪代码如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Ctext%7Bdo%20i%3D1%2Cn%7D%26%20%5C%5C%0A%26b_%7Bi%7D%3Db_%7Bi%7D%2B%5Cleft%28r_%7Bi%7D-%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20a_%7Bi%20j%7D%20b_%7Bj%7D%5Cright%29%20%2F%20a_%7Bi%20i%7D%20%5C%5C%0A%5Ctext%7Bend%20do%7D%26%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>上式可以改写为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ab_%7Bi%7D%5E%7B%28t%2B1%29%7D%26%3D%5Cleft(r_%7Bi%7D-%5Csum_%7Bj%3D1%7D%5E%7Bi-1%7D%20a_%7Bi%20j%7D%20b_%7Bj%7D%5E%7B(t%2B1)%7D-%5Csum_%7Bj%3Di%2B1%7D%5E%7Bp%7D%20a_%7Bi%20j%7D%20b_%7Bj%7D%5E%7B(t)%7D%5Cright)%20%2F%20a_%7Bi%20i%7D%20%5C%5C%0Aa_%7Bi%20i%7D%20b_%7Bi%7D%5E%7B(t%2B1)%7D%20%26%3D%5Cleft(r_%7Bi%7D-%5Csum_%7Bj%3D1%7D%5E%7Bi-1%7D%20a_%7Bi%20j%7D%20b_%7Bj%7D%5E%7B(t%2B1)%7D-%5Csum_%7Bj%3Di%2B1%7D%5E%7Bp%7D%20a_%7Bi%20j%7D%20b_%7Bj%7D%5E%7B(t)%7D%5Cright)%20%5C%5C%0A%5Csum_%7Bj%3D1%7D%5E%7Bi%7D%20a_%7Bi%20j%7D%20b_%7Bj%7D%5E%7B(t%2B1)%7D%20%26%3D%20r_%7Bi%7D-%5Csum_%7Bj%3Di%2B1%7D%5E%7Bp%7D%20a_%7Bi%20j%7D%20b_%7Bj%7D%5E%7B(t)%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>我们看如何将其写成矩阵的形式，首先我们矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 分解为如下形式</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%20%3D%20%5Cmathbf%7BD%2BL%2BU%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D%20%3D%20Diag%5C%7B%5Cmathbf%7BA%7D%5C%7D" style="display:inline-block;margin: 0;"/> ，是由 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 中的对角线元素构成的对角线矩阵。 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%2C%20U%7D" style="display:inline-block;margin: 0;"/> 均为严格三角矩阵: <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 为严格下 三角矩阵，即对角线以下的元素； <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 为严格上三角矩阵，即对角线以上的元素。</p>
<p>于是我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7B%28L%2BD%29%20%5Cmathbf%7Bb%5E%7B(t%2B1)%7D%7D%7D%20%26%3D%20%5Cmathbf%7Br-U%20b%5E%7B(t)%7D%7D%20%5C%5C%0A%5Cmathbf%7Bb%5E%7B(t%2B1)%7D%7D%20%26%3D%20%5Cmathbf%7B(L%2BD)%5E%7B-1%7D%5Cleft%5C%7Br-U%20b%5E%7B(t)%7D%5Cright%5C%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7B(L%2BD)%5E%7B-1%7D%5Cleft%5C%7Br-%5BA-(L%2BD)%5D%20b%5E%7B(t)%7D%5Cright%5C%7D%7D%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>与雅可比迭代的式子比较发现，这里是用  <img src="https://math.now.sh?inline=%5Cmathbf%7BL%2BD%7D" style="display:inline-block;margin: 0;"/> 替代了雅可比迭代式子中的 <img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D" style="display:inline-block;margin: 0;"/> ，由于  <img src="https://math.now.sh?inline=%5Cmathbf%7BL%2BD%7D" style="display:inline-block;margin: 0;"/>  比  <img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D" style="display:inline-block;margin: 0;"/> 更接近 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> , 因此 GS 迭代法的收敛速度一般更快。</p>
<p>但要注意的是，这两种方法并不是在任何情况下都能收敛的。对于 GS 迭代法，它能够收敛的一个充分条件是<strong>方程组的系数矩阵为正定矩阵或半正定矩阵</strong>，由于混合线性方程组的系数矩阵一般来说都是正定矩阵，所以基本上可以不用担心它们的收敛问题。对于雅可比迭代法，一般来说，对于系数矩阵为对角优势矩阵（即在每一行中，均有对角线元素的值大于所有非对角线元素的值）的方程组，它是可以收敛的。但是混合模型方程组中的系数矩阵往往不是对角优势矩阵，因此不能保证它收敛，因此只有在对数据文件迭代 (iteration on data) 中才可能用到雅可比迭代。</p>
<h2 id="SOR-迭代法">SOR 迭代法</h2>
<p>GS 迭代法有时收敛速度较慢，此时可考虑<strong>逐次超松弛迭代法</strong> (successive over-relaxation, SOR) ，其迭代公式为</p>
<p style=""><img src="https://math.now.sh?from=b_%7Bi%7D%5E%7B%28t%2B1%29%7D%3Db_%7Bi%7D%5E%7B(t)%7D%2B%20%5Comega%20%5Cleft(r_%7Bi%7D-%5Csum_%7Bj%3D1%7D%5E%7Bi-1%7D%20a_%7Bi%20j%7D%20b_%7Bj%7D%5E%7B(t%2B1)%7D-%5Csum_%7Bj%3Di%7D%5E%7Bp%7D%20a_%7Bi%20j%7D%20b_%7Bj%7D%5E%7B(t)%7D%5Cright)%20%2F%20a_%7Bi%20i%7D%0A" /></p><p>其中，<img src="https://math.now.sh?inline=%5Comega" style="display:inline-block;margin: 0;"/> 是松弛因子，适当选取 <img src="https://math.now.sh?inline=%5Comega" style="display:inline-block;margin: 0;"/> 可加快收敛速度，通常取 <img src="https://math.now.sh?inline=1%3C%5Comega%3C2" style="display:inline-block;margin: 0;"/>  （那么如何选择一个合适的 <img src="https://math.now.sh?inline=%5Comega" style="display:inline-block;margin: 0;"/> 就成了一个新的问题）。当  <img src="https://math.now.sh?inline=%5Comega%20%3D%201" style="display:inline-block;margin: 0;"/> 时，SOR 迭代法就变成 GS 迭代法。 SOR 方法的伪代码如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Ctext%7Bdo%20i%3D1%2Cn%7D%26%20%5C%5C%0A%26b_%7Bi%7D%3Db_%7Bi%7D%2B%5Comega%5Cleft%28r_%7Bi%7D-%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20a_%7Bi%20j%7D%20b_%7Bj%7D%5Cright%29%20%2F%20a_%7Bi%20i%7D%20%5C%5C%0A%5Ctext%7Bend%20do%7D%26%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><h2 id="PCG">PCG</h2>
<p>在复杂问题中，<strong>预处理共轭梯度法</strong> (<em>Preconditioned conjugate gradient</em>, PCG) 比前面三种方法收敛速度都要快，其理论可见 Meurant (1999) 。</p>
<p>PCG 和二阶雅可比算法有一些相似，二阶雅可比算法如下 (在动物模型，合适的参数是 <img src="https://math.now.sh?inline=%5Calpha%20%3D%200.7-0.9" style="display:inline-block;margin: 0;"/>， <img src="https://math.now.sh?inline=%5Cbeta%20%3D1" style="display:inline-block;margin: 0;"/> 。)</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bb%7D%5E%7B%28%5Cmathrm%7Bn%7D%2B1%29%7D%3D%5Cmathbf%7Bb%7D%5E%7B(%5Cmathrm%7Bn%7D)%7D%2B%5Calpha%5Cleft(%5Cmathbf%7Bb%7D%5E%7B(%5Cmathrm%7Bn%7D)%7D-%5Cmathbf%7Bb%7D%5E%7B(%5Cmathrm%7Bn%7D-1)%7D%5Cright)%2B%5Cbeta%20%5Cmathbf%7BD%7D%5E%7B-1%7D%5Cleft(%5Cmathbf%7Br%7D-%5Cmathrm%7BA%7D%20%5Cmathbf%7Bb%7D%5E%7B(%5Cmathrm%7Bn%7D)%7D%5Cright)%0A" /></p><p>PCG 算法采用相似的公式，只是 <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cbeta" style="display:inline-block;margin: 0;"/> 在每一轮迭代中需要重新计算，并且这里的 <img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D" style="display:inline-block;margin: 0;"/> 改为了 <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D" style="display:inline-block;margin: 0;"/> 矩阵，称为预处理矩阵。<img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D" style="display:inline-block;margin: 0;"/> 矩阵可能等于 <img src="https://math.now.sh?inline=diag%28%5Cmathbf%7BA%7D%29" style="display:inline-block;margin: 0;"/> 或者容易求逆的 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 矩阵的任意一种近似矩阵。</p>
<p>PCG 迭代的完整的伪代码如下 (这里原方程组设为 <img src="https://math.now.sh?inline=%5Cmathbf%7BAx%7D%20%3D%20%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> )</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%0A%26%5Cmathbf%7Bx%7D%3D0%20%3B%20%5Cmathbf%7Br%7D%3D%5Cmathbf%7Bb%7D-%5Cmathbf%7BA%20x%7D%20%3B%20%5Cmathrm%7Bk%7D%3D1%20%5C%5C%0A%26%20%5Ctext%7Bdo%20while%28%7D%20%5Cmathbf%7Br'r%7D%20%5Ctext%7B%20not%20sufficiently%20small%29%7D%20%20%5C%5C%0A%26%20%5Cquad%20%5Cmathbf%7Bz%7D%3D%5Cmathbf%7BM%7D%5E%7B-1%7D%20%5Cmathbf%7Br%7D%20%5C%5C%0A%26%20%5Cquad%20%5Ctau_%7B%5Cmathrm%7Bk%7D-1%7D%3D%5Cmathbf%7Bz%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Br%7D%20%5C%5C%0A%26%20%5Cquad%20%5Ctext%7Bif%7D%20(%5Cmathrm%7Bk%7D%3D%3D1)%20%5Ctext%7B%20then%7D%20%5C%5C%0A%26%20%5Cquad%20%5Cquad%20%5Cbeta%3D0%20%3B%20%5Cmathbf%7Bp%7D%3D%5Cmathbf%7Bz%7D%20%5C%5C%0A%26%20%5Cquad%20%5Ctext%7Belse%7D%20%5C%5C%0A%0A%26%20%5Cquad%20%5Cquad%20%5Cbeta%3D%5Ctau_%7B%5Cmathrm%7Bk%7D-1%7D%20%2F%20%5Ctau_%7B%5Cmathrm%7Bk%7D-2%7D%20%3B%20%5Cmathbf%7Bp%7D%3D%5Cmathbf%7Bz%7D%2B%5Cbeta%20%5Cmathbf%7Bp%7D%20%5C%5C%0A%26%20%5Cquad%20%5Ctext%20%7B%20end%20if%20%7D%20%5C%5C%0A%26%20%5Cquad%20%5Cmathbf%7Bw%7D%3D%5Cmathbf%7BA%20p%7D%20%5C%5C%0A%26%20%5Cquad%20%5Calpha%3D%5Ctau_%7B%5Cmathrm%7Bk%7D-1%7D%20%2F%5Cleft(%5Cmathbf%7Bp%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bw%7D%5Cright)%20%5C%5C%0A%26%20%5Cquad%20%5Cmathbf%7Bx%7D%3D%5Cmathbf%7Bx%7D%2B%5Calpha%20%5Cmathbf%7Bp%7D%20%5C%5C%0A%26%20%5Cquad%20%5Ctext%20%7B%20if%20%7D(%5Cbmod%20(%5Cmathrm%7Bk%7D%2C%20100)%20%2F%3D0)%20%5Ctext%20%7B%20then%20%7D%20%5C%5C%0A%26%20%5Cquad%20%5Cquad%20%5Cmathbf%7Br%7D%3D%5Cmathbf%7Br%7D-%5Calpha%20%5Cmathbf%7Bw%7D%20%5C%5C%0A%26%20%5Cquad%20%5Ctext%20%7B%20else%20%7D%20%5C%5C%0A%26%20%5Cquad%20%5Cquad%20%5Cmathbf%7Br%7D%3D%5Cmathbf%7Bb%7D-%5Cmathbf%7BA%7D%20%5Cmathbf%7Bx%7D%20%5C%5C%0A%26%20%5Cquad%20%5Ctext%20%7B%20end%20if%20%7D%20%5C%5C%0A%26%20%5Cquad%20%5Cmathrm%7Bk%7D%3D%5Cmathrm%7Bk%7D%2B1%5C%5C%0A%26%5Ctext%7Bend%20do%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>尽管看上去比较复杂，但是 PCG 方法很容易应用，因为这里唯一的复杂计算就是 <img src="https://math.now.sh?inline=%5Cmathbf%7BAx%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BAp%7D" style="display:inline-block;margin: 0;"/> 。</p>
<h2 id="迭代的收敛性">迭代的收敛性</h2>
<p>“真实的”收敛标准为下式，其中  <img src="https://math.now.sh?inline=%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> 为精确解。</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%5C%7C%5Cmathbf%7Bb%5E%7B%28t%29%7D-b%7D%5C%7C%7D%7B%5C%7C%5Cmathbf%7Bb%7D%5C%7C%7D%0A" /></p><p>但是由于实际上我们不知道   <img src="https://math.now.sh?inline=%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> ，因此在迭代过程中，我们常用下面的两个收敛标准：</p>
<p>第一种方式，根据两次迭代解的差距，公式如下。也就是说，如果两次迭代的解相差很小，则认为收敛。</p>
<p style=""><img src="https://math.now.sh?from=C_%7Bd%7D%5E%7B%28t%29%7D%20%3D%20%5Cfrac%7B%5C%7C%5Cmathbf%7Bb%5E%7B(t)%7D-b%5E%7B(t-1)%7D%7D%5C%7C%7D%7B%5C%7C%5Cmathbf%7Bb%5E%7B(t)%7D%7D%5C%7C%7D%3D%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bp%7D%5Cleft(b_%7Bi%7D%5E%7B(t)%7D-b_%7Bi%7D%5E%7B(t-1)%7D%5Cright)%5E%7B2%7D%7D%7B%5Csum_%7Bi%3D1%7D%5E%7Bp%7D%5Cleft(b_%7Bi%7D%5E%7B(t)%7D%5Cright)%5E%7B2%7D%7D%3C%5Cvarepsilon%0A" /></p><p>第二种方式，根据左手项和右手项的差距，公式如下</p>
<p style=""><img src="https://math.now.sh?from=C_%7Br%7D%5E%7B%28t%29%7D%20%3D%20%5Cfrac%7B%5C%7C%5Cmathbf%7Br-Ab%5E%7B(t)%7D%7D%5C%7C%7D%7B%5C%7C%5Cmathbf%7Br%7D%5C%7C%7D%20%3C%20%5Cvarepsilon%0A" /></p><p>其中 ，<img src="https://math.now.sh?inline=%5Cvarepsilon%3E%200" style="display:inline-block;margin: 0;"/> 是预先给定的允许误差，通常是一个很小的数值。在每次迭代结束时，都检查上式是否成立，如果成立，就意味着本次迭代与上次迭代所得到的解已非常接近，可以认为迭代收敛，从而结束迭代，将当前迭代的解作为方程组的解。</p>
<h1>混合模型方程组的迭代求解</h1>
<h2 id="直接迭代求解">直接迭代求解</h2>
<p>直接迭代求解是先计算出方程组系数矩阵和右手项的各个元素，然后用前面所介绍的方法进行迭代求解，这种解法也称为对方程组迭代 (iteration on equations) 。一般来说，<strong>当数据可以读入内存中时，我们会用 GS 或 SOR 迭代法</strong>。但是，PCG 方法现在越来越流行，比如将预处理矩阵设为对角矩阵的 PCG 方法可以对所有的模型均收敛，包括复杂性状，随机回归模型，母性效应模型等；PCG 方法的收敛速度一般也优于前几种方法；PCG 方法还不需要确定任何参数。PCG 方法的一个劣势是它需要更多的内存。</p>
<h2 id="间接迭代解法">间接迭代解法</h2>
<p>用直接迭代求解并将方程组存储在硬盘上的缺陷在于从硬盘读取数据的次数太多，计算速度减慢，同时编程也较复杂。针对这种缺陷，Schaeffer 和 Kennedy (1986a, 1986b) 及 Misztal 和 Gianola (1987) 等分别提出了混合模型方程组的间接迭代解法，用这种方法<strong>不需要建立方程组</strong>，而是在每次迭代中读入观测值书数据文件和系谱数据文件，并同时计算方程组的解，故这种方法又称为对数据文件迭代 (iteration on data) 。因为在多数情况下混合模型方程组的大小要比数据文件的大小要大，这种方法所需的读取次数少于直接迭代方法，因而计算速度要快一点，这种方法的另一个优点是它的编程非常简单。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>从GBLUP或ssGBLUP的育种值推导snp效应值</title>
    <url>/posts/6b882d9f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>基于GBLUP/ssGBLUP的育种值计算 SNP 效应。</p>
<span id="more"></span>
<h1>估计SNP效应</h1>
<p>一步法中的 <img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 公式为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BH%7D%5E%7B-1%7D%3D%5Cmathbf%7BA%7D%5E%7B-1%7D%2B%5Cleft%5B%5Cbegin%7Barray%7D%7Blc%7D%0A0%20%26%200%20%5C%5C%0A0%20%26%20%5Cmathbf%7BG%7D%5E%7B-1%7D-%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 是校正到与 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B22%7D" style="display:inline-block;margin: 0;"/> 矩阵规模相同后的矩阵。</p>
<p>我们将个体育种值分为基因型个体 (<img src="https://math.now.sh?inline=%5Cmathbf%7Ba_%7Bg%7D%7D" style="display:inline-block;margin: 0;"/>) 和 非基因型个体 (<img src="https://math.now.sh?inline=%5Cmathbf%7Ba_%7Bn%7D%7D" style="display:inline-block;margin: 0;"/>) ， 基因型个体的育种值可以视为所有 snp 效应之和，即：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Ba_%7Bg%7D%7D%20%3D%20%5Cmathbf%7BZ%7D%5Cmathbf%7Bu%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 是 SNP 效应的系数矩阵（<strong>中心化</strong>的系数矩阵），<img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> 是 SNP 效应向量。</p>
<p>因此，个体加性效应的方差为</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Bvar%7D%28%5Cmathbf%7Ba_%7Bg%7D%7D%29%20%3D%20%5Coperatorname%7Bvar%7D(%5Cmathbf%7BZ%7D%5Cmathbf%7Bu%7D)%20%3D%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7BD%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Csigma_%7Bu%7D%5E%7B2%7D%20%3D%20%5Cmathbf%7BG%7D%5E%7B*%7D%5Csigma_%7Ba%7D%5E%7B2%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D" style="display:inline-block;margin: 0;"/> 是位点的权重的对角矩阵（GBLUP 中为 <img src="https://math.now.sh?inline=%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ），<img src="https://math.now.sh?inline=%5Csigma_%7Bu%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 是位点的加性方差，<img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 是有权重的基因组亲缘关系矩阵。</p>
<p>基因型个体的育种值 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba_%7Bg%7D%7D" style="display:inline-block;margin: 0;"/> 和 SNP 效应 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> 的联合协方差矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Bvar%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Blc%7D%0A%5Cmathbf%7Ba_%7Bg%7D%7D%20%5C%5C%0A%5Cmathbf%7Bu%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Blc%7D%0A%5Cmathbf%7BZDZ%5E%7B%5Cprime%7D%7D%20%26%20%5Cmathbf%7BZD%5E%7B%5Cprime%7D%7D%20%5C%5C%0A%5Cmathbf%7BDZ%5E%7B%5Cprime%7D%7D%20%26%20%5Cmathbf%7BD%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5Csigma_%7Bu%7D%5E%7B2%7D%0A" /></p><p>因此</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BG%7D%5E%7B*%7D%20%3D%20%5Cfrac%7B%5Coperatorname%7Bvar%7D%28%5Cmathbf%7Ba_%7Bg%7D%7D%29%7D%20%7B%5Csigma_%7Ba%7D%5E%7B2%7D%7D%20%3D%20%5Cfrac%7B%5Coperatorname%7Bvar%7D(%5Cmathbf%7BZu%7D)%7D%20%7B%5Csigma_%7Ba%7D%5E%7B2%7D%7D%20%3D%20%5Cmathbf%7BZDZ%5E%7B%5Cprime%7D%7D%20%5Cfrac%7B%5Csigma_%7Bu%7D%5E%7B2%7D%7D%7B%5Csigma_%7Ba%7D%5E%7B2%7D%7D%20%3D%20%5Cmathbf%7BZDZ%5E%7B%5Cprime%7D%7D%5Clambda%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Clambda" style="display:inline-block;margin: 0;"/> 是一个方差比值，基于 VanRaden 2009 ，存在公式</p>
<p style=""><img src="https://math.now.sh?from=%5Clambda%20%3D%20%5Cfrac%7B%5Csigma_%7Bu%7D%5E%7B2%7D%7D%7B%5Csigma_%7Ba%7D%5E%7B2%7D%7D%20%3D%20%5Cfrac%7B1%7D%7B%5Csum_%7Bi%3D1%7D%5E%7BM%7D2p_%7Bi%7D%281-p_%7Bi%7D%29%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=M" style="display:inline-block;margin: 0;"/> 是位点数目，<img src="https://math.now.sh?inline=p_%7Bi%7D" style="display:inline-block;margin: 0;"/> 是等位基因频率。</p>
<p>基于 Stranden &amp; Garrick (2009) ，可以推导出公式</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cmathbf%7Bu%7D%7D%20%20%3D%20%5Clambda%20%5Cmathbf%7BDZ%5E%7B%5Cprime%7DG%5E%7B*-1%7D%5Cmathbf%7B%5Chat%7Ba%7D_%7Bg%7D%7D%7D%20%3D%20%5Cmathbf%7BDZ%5E%7B%5Cprime%7D%28ZDZ%5E%7B%5Cprime%7D%29%5E%7B-1%7D%5Cmathbf%7B%5Chat%7Ba%7D_%7Bg%7D%7D%7D%0A" /></p><p>我们可以检查一下， 没有问题</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%5Chat%7Ba%7D_%7Bg%7D%7D%20%3D%20%5Cmathbf%7BZu%7D%20%3D%5Cmathbf%7BZDZ%5E%7B%5Cprime%7D%28ZDZ%5E%7B%5Cprime%7D%29%5E%7B-1%7D%5Cmathbf%7B%5Chat%7Ba%7D_%7Bg%7D%7D%7D%20%3D%20%5Cmathbf%7B%5Chat%7Ba%7D_%7Bg%7D%7D%0A" /></p><h1>估计SNP效应的方差</h1>
<p>每一个 SNP 效应的方差估计值为 （Zhang, 2010）</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Csigma%7D_%7Bu%2Ci%7D%5E%7B2%7D%20%3D%20%5Chat%7Bu%7D_%7Bi%7D%5E%7B2%7D2p_%7Bi%7D%281-p_%7Bi%7D%29%0A" /></p><p>根据上面的公式可以构建一个估计一步法的 <img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D" style="display:inline-block;margin: 0;"/> 矩阵的算法，定义 <img src="https://math.now.sh?inline=t" style="display:inline-block;margin: 0;"/> 是迭代次数，<img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 个 SNP ，算法流程如下（这也是 blupf90 进行 ssGWAS 的流程）：</p>
<ol>
<li><img src="https://math.now.sh?inline=t%3D0" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D_%7B%28t%29%7D%20%3D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D%5E%7B*%7D_%7B%28t%29%7D%20%3D%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7BD%7D_%7B(t)%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Clambda" style="display:inline-block;margin: 0;"/></li>
<li>使用 ssGBLUP 计算 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Chat%7Ba%7D_%7Bg%7D%7D" style="display:inline-block;margin: 0;"/></li>
<li>计算 <img src="https://math.now.sh?inline=%5Chat%7B%5Cmathbf%7Bu%7D_%7B%28t%29%7D%7D%20%20%3D%20%5Clambda%20%5Cmathbf%7BD_%7B(t)%7DZ%5E%7B%5Cprime%7DG%5E%7B*-1%7D_%7B(t)%7D%5Cmathbf%7B%5Chat%7Ba%7D_%7Bg%7D%7D%7D" style="display:inline-block;margin: 0;"/></li>
<li>对每一个位点，计算 <img src="https://math.now.sh?inline=d%5E%7B*%7D_%7Bi%28t%2B1%29%7D%20%3D%20%5Chat%7Bu%7D_%7Bi(t)%7D%5E%7B2%7D2p_%7Bi%7D(1-p_%7Bi%7D)" style="display:inline-block;margin: 0;"/> ，得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D%5E%7B*%7D_%7B%28t%2B1%29%7D" style="display:inline-block;margin: 0;"/> 矩阵</li>
<li>标准化 <img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D_%7B%28t%2B1%29%7D%20%3D%20%5Cfrac%7B%5Coperatorname%7Btr%7D%20(%5Cmathbf%7BD%7D_%7B(0)%7D)%7D%7B%5Coperatorname%7Btr%7D%20(%5Cmathbf%7BD%7D%5E%7B*%7D_%7B(t%2B1)%7D)%7D%20%5Cmathbf%7BD%7D%5E%7B*%7D_%7B(t%2B1)%7D" style="display:inline-block;margin: 0;"/></li>
<li>计算 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D%5E%7B*%7D_%7B%28t%2B1%29%7D%20%3D%20%5Cmathbf%7BZD_%7B(t%2B1)%7DZ%5E%7B%5Cprime%7D%7D%20%5Clambda" style="display:inline-block;margin: 0;"/></li>
<li><img src="https://math.now.sh?inline=t%20%3D%20t%2B1" style="display:inline-block;margin: 0;"/></li>
<li>退出程序，或循环跳到第二步或第三步。</li>
</ol>
<p>如果循环跳到第三步，则每一次计算均使用相同的  <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Chat%7Ba%7D_%7Bg%7D%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>具体是跳到第二步或第三步 ，还有循环次数均需要根据具体情况确定。</p>
<h1>参考文献</h1>
<ol>
<li>Wang H, Misztal I, Aguilar I, et al. Genome-wide association mapping including phenotypes from relatives without genotypes[J]. Genetics research, 2012, 94(2): 73-83.</li>
<li>VanRaden P M, Van Tassell C P, Wiggans G R, et al. Invited review: Reliability of genomic predictions for North American Holstein bulls[J]. Journal of dairy science, 2009, 92(1): 16-24.</li>
<li>Strandén I, Garrick D J. Derivation of equivalent computing algorithms for genomic predictions and reliabilities of animal merit[J]. Journal of dairy science, 2009, 92(6): 2971-2975.</li>
<li>Zhang Z, Liu J, Ding X, et al. Best linear unbiased prediction of genomic breeding values using a trait-specific marker-derived relationship matrix[J]. PloS one, 2010, 5(9): e12648.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>R包-GCA</title>
    <url>/posts/cecfc845/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>GCA 包可以计算群体间遗传关联。</p>
<span id="more"></span>
<h1>安装包</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">remotes::install_github(&quot;QGresources/GCA&quot;)</span><br><span class="line">library(GCA)</span><br></pre></td></tr></table></figure>
<h1>加载网页需要的包</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">library(BGLR)</span><br><span class="line">library(corrplot)</span><br><span class="line">library(GCA)</span><br><span class="line">library(ggplot2)</span><br><span class="line">library(gridExtra)</span><br></pre></td></tr></table></figure>
<h1>准备数据</h1>
<p>模拟数据  <code>GCcattle</code>包含两个对象 <code>cattle.pheno</code> and <code>cattle.W</code>，分别为表型和基因组信息，具体信息可见</p>
<p>这是模拟数据，6个世代，基因型应该没有缺失。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?GCcattle</span><br><span class="line"></span><br><span class="line"># Load cattle dataset</span><br><span class="line">data(GCcattle)</span><br><span class="line"></span><br><span class="line"># Check phenotype, fixed covariates and pedigree information</span><br><span class="line">str(cattle.pheno)</span><br><span class="line">&#x27;data.frame&#x27;:   2500 obs. of  6 variables:</span><br><span class="line"> $ Progeny  : int  1 2 3 4 5 6 7 8 9 10 ...</span><br><span class="line"> $ Sire     : int  0 0 0 0 0 0 0 0 0 0 ...</span><br><span class="line"> $ Dam      : int  0 0 0 0 0 0 0 0 0 0 ...</span><br><span class="line"> $ Sex      : chr  &quot;M&quot; &quot;M&quot; &quot;M&quot; &quot;M&quot; ...</span><br><span class="line"> $ Unit     : Factor w/ 8 levels &quot;U1&quot;,&quot;U2&quot;,&quot;U3&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...</span><br><span class="line"> $ Phenotype: num  -0.614 0.803 1.79 0.117 0.399 ...</span><br><span class="line"></span><br><span class="line"># Check marker information</span><br><span class="line">str(cattle.W)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; dim(cattle.W) # marker matrix</span><br><span class="line">[1]  2500 10000</span><br></pre></td></tr></table></figure>
<p>遗传力设为 0.6</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sigma2a &lt;- 0.6 # additive genetic variance</span><br><span class="line">sigma2e &lt;- 0.4 # residual variance</span><br></pre></td></tr></table></figure>
<p>我们接下来构建固定效应的系数矩阵和基因组关系矩阵</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X2 &lt;- model.matrix(~ -1 + factor(cattle.pheno$Unit) + factor(cattle.pheno$Sex)) # incidence matrix of unit effect and sex</span><br><span class="line">G &lt;- computeG(cattle.W, maf = 0.05) # genomic relationship matrix; markers with minor allele frequency (maf) less than 0.05 are removed</span><br></pre></td></tr></table></figure>
<p>查看一下 <code>computeG</code> 这个函数，基因型缺失为 NA ，缺失值默认用随机抽样得到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Compute genomic relationship matrix</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">     Use single nucleotide polymorphisms markers to derive an additive</span><br><span class="line">     genomic relationship matrix. Missing markers are allowed, but</span><br><span class="line">     should be coded as NA.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">     computeG(snpmatrix, maf = 0.05, impute = &quot;rbinom&quot;, method = &quot;G1&quot;)</span><br><span class="line"></span><br><span class="line">Arguments:</span><br><span class="line"></span><br><span class="line">snpmatrix: A marker matrix with the dimension of n by m, where the</span><br><span class="line">          elements are coded as 0, 1, 2, or NA, where n and m are the</span><br><span class="line">          total number of individuals and markers, respectively.</span><br><span class="line"></span><br><span class="line">     maf: A minor allele frequency cutoff for quality control. The</span><br><span class="line">          default minor allele frequency is 0.05.</span><br><span class="line"></span><br><span class="line">  impute: Perform genotype imputation for missing markers if</span><br><span class="line">          applicable. Two methods of &#x27;mean&#x27; and &#x27;rbinom&#x27; are available,</span><br><span class="line">          where the &#x27;mean&#x27; imputes missing markers using mean and</span><br><span class="line">          &#x27;rbinom&#x27; imputes the missing markers by random sampling from</span><br><span class="line">          a binomial distribution. The default method is &#x27;rbinom&#x27;. This</span><br><span class="line">          argument will be ignored if the ‘snpmatrix’ does not include</span><br><span class="line">          any missing markers.</span><br><span class="line"></span><br><span class="line">  method: A type of genomic relationship matrix including &#x27;G1&#x27; and &#x27;G2&#x27;</span><br><span class="line">          (VanRaden 2008). The default method is &#x27;G1&#x27;.</span><br></pre></td></tr></table></figure>
<h1>计算群体关联的例子</h1>
<h2 id="选项说明">选项说明</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gca(Kmatrix, Xmatrix, sigma2a, sigma2e, MUScenario, statistic, NumofMU, </span><br><span class="line">    Uidx = NULL, scale = TRUE, diag = TRUE)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Kmatrix</code>: Genetic relationship matrix constructed from either pedigree or genomics.</li>
<li><code>Xmatrix</code>: Fixed effects incidence matrix excluding intercept. The first column of the Xmatrix should start with unit effects followed by other fixed effects if applicable.</li>
<li><code>sigma2a and sigma2e</code>: Estimates of additive genetic and residual variances, respectively.</li>
<li><code>MUScenario</code>: A vector of fixed factor units.</li>
<li><code>statistic</code>: Choice of connectedness statistic. Available options include
<ol>
<li>PEV-derived functions: PEVD_IdAve, PEVD_GrpAve, PEVD_contrast, CD_IdAve, CD_GrpAve, CD_contrast, r_IdAve, r_GrpAve, and r_contrast.</li>
<li>VE-derived functions: VED0, VED1, VED2, CDVED0, CDVED1, CDVED2, CR0, CR1, and CR2.</li>
</ol>
</li>
<li><code>NumofMU</code>: Return either pairwise unit connectedness (Pairwise) or overall connectedness across all units (Overall).</li>
<li><code>Uidx</code>: An integer indicating the last column number of units in the Xmatrix. This Uidx is required for VED2, CDVED2, and CR2 statistics. The default is NULL.</li>
<li><code>scale (logical)</code>: Should sigma2a be used to scale statistic (i.e., PEVD_IdAve, PEVD_GrpAve, PEVD_contrast, VED0, VED1, and VED2) so that connectedness is independent of measurement unit? The default is TRUE.</li>
<li><code>diag (logical)</code>: Should the diagonal elements of the PEV matrix (i.e., PEVD_GrpAve, CD_GrpAve, and r_GrpAve) or the K matrix (CDVED0, CDVED1, and CDVED2) be included? The default is TRUE.</li>
</ul>
<h2 id="PEVD-GrpAve">PEVD_GrpAve</h2>
<p>下面我们以 PEVD_GrpAve 这个指标作为例子，其范围为 0 到 1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PEVD_GrpAve &lt;- gca(Kmatrix = G, Xmatrix = X2, sigma2a = sigma2a, sigma2e = sigma2e,</span><br><span class="line">                  MUScenario = as.factor(cattle.pheno$Unit), statistic = &#x27;PEVD_GrpAve&#x27;,</span><br><span class="line">                  NumofMU = &#x27;Pairwise&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; PEVD_GrpAve</span><br><span class="line">           U1         U2         U3         U4         U5         U6         U7</span><br><span class="line">U1         NA 0.01668301 0.02314068 0.02845543 0.02468162 0.02908540 0.01920005</span><br><span class="line">U2 0.01668301         NA 0.03679673 0.04326783 0.03956293 0.04428925 0.03464098</span><br><span class="line">U3 0.02314068 0.03679673         NA 0.04837241 0.04439133 0.04987349 0.03808480</span><br><span class="line">U4 0.02845543 0.04326783 0.04837241         NA 0.05041112 0.05712596 0.04589734</span><br><span class="line">U5 0.02468162 0.03956293 0.04439133 0.05041112         NA 0.05062642 0.04002046</span><br><span class="line">U6 0.02908540 0.04428925 0.04987349 0.05712596 0.05062642         NA 0.04647375</span><br><span class="line">U7 0.01920005 0.03464098 0.03808480 0.04589734 0.04002046 0.04647375         NA</span><br><span class="line">U8 0.01559363 0.03069310 0.03658017 0.04175780 0.03786799 0.04314658 0.03401520</span><br><span class="line">           U8</span><br><span class="line">U1 0.01559363</span><br><span class="line">U2 0.03069310</span><br><span class="line">U3 0.03658017</span><br><span class="line">U4 0.04175780</span><br><span class="line">U5 0.03786799</span><br><span class="line">U6 0.04314658</span><br><span class="line">U7 0.03401520</span><br><span class="line">U8         NA</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>移除对角线元素，并绘图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diag(PEVD_GrpAve) &lt;- 0 </span><br><span class="line">corrplot(PEVD_GrpAve, is.corr = FALSE, method =&quot;circle&quot;, type = &quot;upper&quot;,</span><br><span class="line">         diag = F, number.cex = 7 / ncol(PEVD_GrpAve), col = cm.colors(10), cl.lim = c(0, 0.08),</span><br><span class="line">         number.digits = 4, mar = c(0,1,1,1), addCoef.col = &quot;black&quot;,</span><br><span class="line">         tl.col = &quot;black&quot;, tl.srt = 90, tl.cex = 1.2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果设置 <code>NumofMU = 'Overall'</code> ，那么我们会得到所有配对的群体间PEVD 的均值</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> PEVD_GrpAve_Overall <span class="operator">&lt;-</span> gca<span class="punctuation">(</span>Kmatrix <span class="operator">=</span> G<span class="punctuation">,</span> Xmatrix <span class="operator">=</span> X2<span class="punctuation">,</span> sigma2a <span class="operator">=</span> sigma2a<span class="punctuation">,</span></span><br><span class="line">                           sigma2e <span class="operator">=</span> sigma2e<span class="punctuation">,</span> MUScenario <span class="operator">=</span> as.factor<span class="punctuation">(</span>cattle.pheno<span class="operator">$</span>Unit<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                           statistic <span class="operator">=</span> <span class="string">&#x27;PEVD_GrpAve&#x27;</span><span class="punctuation">,</span> NumofMU <span class="operator">=</span> <span class="string">&#x27;Overall&#x27;</span><span class="punctuation">)</span></span><br><span class="line">PEVD_GrpAve_Overall</span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">0.03752627</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当然，这里的统计量也可以换为  <code>'PEVD_IdAve'</code> 和 <code>'PEVD_contrast'</code>,</p>
<h2 id="PEVD-IdAve">PEVD_IdAve</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PEVD_IdAve &lt;- gca(Kmatrix = G, Xmatrix = X2, sigma2a = sigma2a, sigma2e = sigma2e,</span><br><span class="line">                  MUScenario = as.factor(cattle.pheno$Unit), statistic = &#x27;PEVD_IdAve&#x27;,</span><br><span class="line">                  NumofMU = &#x27;Pairwise&#x27;)</span><br><span class="line">diag(PEVD_IdAve) &lt;- 0</span><br><span class="line">pdf(&quot;test2.pdf&quot;)</span><br><span class="line">corrplot(PEVD_IdAve, is.corr = FALSE, method =&quot;circle&quot;, type = &quot;upper&quot;,</span><br><span class="line">         diag = F, number.cex = 7 / ncol(PEVD_GrpAve), col = cm.colors(10), cl.lim = c(0, 0.08),</span><br><span class="line">         number.digits = 4, mar = c(0,1,1,1), addCoef.col = &quot;black&quot;,</span><br><span class="line">         tl.col = &quot;black&quot;, tl.srt = 90, tl.cex = 1.2)</span><br><span class="line">dev.off()         </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下图为两种方法结果的比对，左边是 PEVD_GrpAve ，右边是 PEVD_IdAve ，趋势是一致的。</p>
<p><a href="https://imgse.com/i/v7aeDU"><img src="https://s1.ax1x.com/2022/09/06/v7aeDU.png" alt="v7aeDU.png"></a></p>
<h2 id="CD-GrpAve">CD_GrpAve</h2>
<p>CD 越大越好，下面的统计量同样可以改为 <code>'CD_IdAve'</code>  和 <code>'CD_contrast'</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CD_GrpAve &lt;- gca(Kmatrix = G, Xmatrix = X2, sigma2a = sigma2a, sigma2e = sigma2e,</span><br><span class="line">                MUScenario = as.factor(cattle.pheno$Unit), statistic = &#x27;CD_GrpAve&#x27;,</span><br><span class="line">                NumofMU = &#x27;Pairwise&#x27;)</span><br><span class="line"># replace NAs in diagnol to make plot</span><br><span class="line">diag(CD_GrpAve) &lt;- min(CD_GrpAve, na.rm = T)</span><br><span class="line">pdf(&quot;CD_GrpAve.pdf&quot;)</span><br><span class="line">corrplot(CD_GrpAve, is.corr = FALSE, method =&quot;circle&quot;, type = &quot;upper&quot;,</span><br><span class="line">         diag = F, number.cex = 7 / ncol(CD_GrpAve), col = cm.colors(10), </span><br><span class="line">         number.digits = 4, mar = c(0,1,1,1), addCoef.col = &quot;black&quot;,</span><br><span class="line">         tl.col = &quot;black&quot;, tl.srt = 90, tl.cex = 1.2, cl.lim = c(0.5, 0.8))</span><br><span class="line">dev.off()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2022/09/06/v7wpfs.png" alt="v7wpfs.png"></p>
<p>结果和 PEVD 不一致。</p>
<h2 id="r-GrpAve">r_GrpAve</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r_GrpAve &lt;- gca(Kmatrix = G, Xmatrix = X2, sigma2a = sigma2a, sigma2e = sigma2e,</span><br><span class="line">                  MUScenario = as.factor(cattle.pheno$Unit), </span><br><span class="line">                statistic = &#x27;r_GrpAve&#x27;, NumofMU = &#x27;Pairwise&#x27;)</span><br><span class="line">diag(r_GrpAve) &lt;- 0</span><br><span class="line">png(&quot;r_GrpAve.png&quot;)</span><br><span class="line">corrplot(r_GrpAve, is.corr = FALSE, method =&quot;circle&quot;, type = &quot;upper&quot;,</span><br><span class="line">         diag = F, number.cex = 7 / ncol(PEVD_GrpAve), col = cm.colors(10), cl.lim = c(0, 0.08),</span><br><span class="line">         number.digits = 4, mar = c(0,1,1,1), addCoef.col = &quot;black&quot;,</span><br><span class="line">         tl.col = &quot;black&quot;, tl.srt = 90, tl.cex = 1.2)</span><br><span class="line">dev.off()         </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>全是负数</p>
<p><a href="https://imgse.com/i/v7yP1J"><img src="https://s1.ax1x.com/2022/09/06/v7yP1J.png" alt="v7yP1J.png"></a></p>
<h2 id="VED">VED</h2>
<p>VED 越小越好</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VED0  &lt;- gca(Kmatrix = G, Xmatrix = X2, sigma2a = sigma2a, sigma2e = sigma2e,</span><br><span class="line">             MUScenario = as.factor(cattle.pheno$Unit), statistic = &#x27;VED0&#x27;,</span><br><span class="line">             NumofMU = &#x27;Pairwise&#x27;)</span><br><span class="line">VED1  &lt;- gca(Kmatrix = G, Xmatrix = X2, sigma2a = sigma2a, sigma2e = sigma2e,</span><br><span class="line">             MUScenario = as.factor(cattle.pheno$Unit), statistic = &#x27;VED1&#x27;,</span><br><span class="line">             NumofMU = &#x27;Pairwise&#x27;)</span><br><span class="line">VED2  &lt;- gca(Kmatrix = G, Xmatrix = X2, sigma2a = sigma2a, sigma2e = sigma2e,</span><br><span class="line">               MUScenario = as.factor(cattle.pheno$Unit), statistic = &#x27;VED2&#x27;,</span><br><span class="line">               NumofMU = &#x27;Pairwise&#x27;, Uidx = 8)</span><br><span class="line"># 剔除对角线的缺失</span><br><span class="line">diag(VED0) &lt;- diag(VED1) &lt;- diag(VED2) &lt;- floor(min(VED0, na.rm = T)) </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>分别绘图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">png(&quot;VED0.png&quot;)</span><br><span class="line">corrplot(VED0, is.corr =FALSE, method=&quot;circle&quot;, type = &quot;upper&quot;,</span><br><span class="line">         diag = F, number.cex = 7 / ncol(VED0), col = cm.colors(10),</span><br><span class="line">         number.digits = 4, addCoef.col = &quot;black&quot;, tl.col = &quot;black&quot;, </span><br><span class="line">         tl.srt = 90, tl.cex = 1.2, cl.lim = c(0, 0.08))</span><br><span class="line">         dev.off()</span><br><span class="line">         </span><br><span class="line">png(&quot;VED1.png&quot;)</span><br><span class="line">corrplot(VED1, is.corr =FALSE, method=&quot;circle&quot;, type = &quot;upper&quot;,</span><br><span class="line">         diag = F, number.cex = 7 / ncol(VED0), col = cm.colors(10),</span><br><span class="line">         number.digits = 4, addCoef.col = &quot;black&quot;, tl.col = &quot;black&quot;, </span><br><span class="line">         tl.srt = 90, tl.cex = 1.2, cl.lim = c(0, 0.08))</span><br><span class="line">         dev.off()</span><br><span class="line">         </span><br><span class="line">png(&quot;VED2.png&quot;)</span><br><span class="line">corrplot(VED2, is.corr =FALSE, method=&quot;circle&quot;, type = &quot;upper&quot;,</span><br><span class="line">         diag = F, number.cex = 7 / ncol(VED0), col = cm.colors(10),</span><br><span class="line">         number.digits = 4, addCoef.col = &quot;black&quot;, tl.col = &quot;black&quot;, </span><br><span class="line">         tl.srt = 90, tl.cex = 1.2, cl.lim = c(0, 0.08))</span><br><span class="line">         dev.off()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>三个趋势一致，并且和 PEVD 趋势一致。</p>
<p>只是 VED1 和 VED2 结果完全一致。</p>
<h2 id="CR">CR</h2>
<p>CR 越大越好</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CR0  &lt;- gca(Kmatrix = G, Xmatrix = X2, sigma2a = sigma2a, sigma2e = sigma2e,</span><br><span class="line">             MUScenario = as.factor(cattle.pheno$Unit), statistic = &#x27;CR0&#x27;,</span><br><span class="line">             NumofMU = &#x27;Pairwise&#x27;)</span><br><span class="line">CR1  &lt;- gca(Kmatrix = G, Xmatrix = X2, sigma2a = sigma2a, sigma2e = sigma2e,</span><br><span class="line">             MUScenario = as.factor(cattle.pheno$Unit), statistic = &#x27;CR1&#x27;,</span><br><span class="line">             NumofMU = &#x27;Pairwise&#x27;)</span><br><span class="line">CR2  &lt;- gca(Kmatrix = G, Xmatrix = X2, sigma2a = sigma2a, sigma2e = sigma2e,</span><br><span class="line">               MUScenario = as.factor(cattle.pheno$Unit), statistic = &#x27;CR2&#x27;,</span><br><span class="line">               NumofMU = &#x27;Pairwise&#x27;, Uidx = 8)</span><br><span class="line"># 剔除对角线的缺失</span><br><span class="line">diag(CR0) &lt;- diag(CR1) &lt;- diag(CR2) &lt;- floor(min(CR0, na.rm = T)) </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>分别绘图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">png(&quot;CR0.png&quot;)</span><br><span class="line">corrplot(CR0, is.corr =FALSE, method=&quot;circle&quot;, type = &quot;upper&quot;,</span><br><span class="line">         diag = F, number.cex = 7 / ncol(CR0), col = cm.colors(10),</span><br><span class="line">         number.digits = 4, addCoef.col = &quot;black&quot;, tl.col = &quot;black&quot;, </span><br><span class="line">         tl.srt = 90, tl.cex = 1.2, cl.lim = c(0, 0.08))</span><br><span class="line">         dev.off()</span><br><span class="line">         </span><br><span class="line">png(&quot;CR1.png&quot;)</span><br><span class="line">corrplot(CR1, is.corr =FALSE, method=&quot;circle&quot;, type = &quot;upper&quot;,</span><br><span class="line">         diag = F, number.cex = 7 / ncol(CR0), col = cm.colors(10),</span><br><span class="line">         number.digits = 4, addCoef.col = &quot;black&quot;, tl.col = &quot;black&quot;, </span><br><span class="line">         tl.srt = 90, tl.cex = 1.2, cl.lim = c(0, 0.08))</span><br><span class="line">         dev.off()</span><br><span class="line">         </span><br><span class="line">png(&quot;CR2.png&quot;)</span><br><span class="line">corrplot(CR2, is.corr =FALSE, method=&quot;circle&quot;, type = &quot;upper&quot;,</span><br><span class="line">         diag = F, number.cex = 7 / ncol(CR0), col = cm.colors(10),</span><br><span class="line">         number.digits = 4, addCoef.col = &quot;black&quot;, tl.col = &quot;black&quot;, </span><br><span class="line">         tl.srt = 90, tl.cex = 1.2, cl.lim = c(0, 0.08))</span><br><span class="line">         dev.off()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>趋势和 PEVD 完全相反。</p>
<p>下图为 CR0</p>
<p><a href="https://imgse.com/i/v7yAn1"><img src="https://s1.ax1x.com/2022/09/06/v7yAn1.png" alt="v7yAn1.png"></a></p>
<h1>不同统计量的关系</h1>
<p>PEVD_GrPAve 和 VED0, VED1, and VED2 强相关，基本为 1</p>
<p>CD_GrpAve 和  CDVED0, CDVED1, and CDVED2 强相关，基本为1</p>
<p>r_GrPAve 和  CR0, CR1, and CR2 相关很强，但是只有0.94-0.99</p>
<h1>关联率和GS准确性</h1>
<p>在全基因组评估中，参考群和验证群的关系会影响预测准确性。</p>
<p>在模拟数据中，模拟了5种情况，通过交换 0, 140, 210, 280 和 350 个个体来逐步增加参考群和验证群的群体关联，   计算 PEVD_GrpAve 和 CD_GrpAve</p>
<p>从下面可以看到，从 MUSC1 到 MUSC5 ，PEVD_GrpAve 逐级递减，说明群体关联越来越高，而 CD_GrpAve 先高后低，这是由于 <code>CD penalizes the connectedness measure when the genetic variability among population is reduced</code>  。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># PEVD_GrpAve</span><br><span class="line">PEVD_GrpAve &lt;- apply(CattleSIM[, 7: 11], 2, function(x) GC(x,</span><br><span class="line">                     Kmatrix = G, sigma2a, sigma2e, stat = &#x27;PEVD_GrpAve&#x27;))</span><br><span class="line">print(PEVD_GrpAve)</span><br><span class="line">##        MUSC1        MUSC2        MUSC3        MUSC4        MUSC5 </span><br><span class="line">## 0.0039430647 0.0018066760 0.0013236613 0.0010374891 0.0009192205</span><br><span class="line"># CD_GrpAve</span><br><span class="line">CD_GrpAve &lt;- apply(CattleSIM[, 7: 11], 2, function(x) GC(x,</span><br><span class="line">                   Kmatrix = G, sigma2a, sigma2e, stat = &#x27;CD_GrpAve&#x27;))</span><br><span class="line">print(CD_GrpAve)</span><br><span class="line">##     MUSC1     MUSC2     MUSC3     MUSC4     MUSC5 </span><br><span class="line">## 0.6679398 0.7586556 0.7626448 0.7503289 0.7140141</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过交叉验证计算模拟数据的准确性（cor(gebv, tbv)）</p>
<p>群体关联和GS准确性的关系见下图。</p>
<p><a href="https://imgse.com/i/v76ern"><img src="https://s1.ax1x.com/2022/09/06/v76ern.png" alt="v76ern.png"></a></p>
<h1>参考文献</h1>
<ol>
<li><a href="https://qgresources.github.io/GCA_Vignette/GCA.html">https://qgresources.github.io/GCA_Vignette/GCA.html</a></li>
</ol>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>R</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>软件学习-conda</title>
    <url>/posts/5375f878/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我一般在linux 系统下会用 conda 安装 R 和 python 。</p>
<span id="more"></span>
<h1>Anaconda 与 Miniconda 介绍</h1>
<p><strong>Anaconda</strong>是一个免费<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81">开源</a>[<a href="https://zh.wikipedia.org/wiki/Anaconda_(Python%E5%8F%91%E8%A1%8C%E7%89%88)#cite_note-5">5]</a>的<a href="https://zh.wikipedia.org/wiki/Python">Python</a>和<a href="https://zh.wikipedia.org/wiki/R%E8%AF%AD%E8%A8%80">R语言</a>的发行版本，用于<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E7%A7%91%E5%AD%A6">计算科学</a>（<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6">数据科学</a>、<a href="https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0">机器学习</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86&amp;action=edit&amp;redlink=1">大数据处理</a>和<a href="https://zh.wikipedia.org/wiki/%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90">预测分析</a>），Anaconda致力于简化<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">软件包管理系统</a>和部署。Anaconda的包使用<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">软件包管理系统</a><a href="https://zh.wikipedia.org/wiki/Conda">Conda</a>[<a href="https://zh.wikipedia.org/wiki/Anaconda_(Python%E5%8F%91%E8%A1%8C%E7%89%88)#cite_note-6">6]</a>进行管理。超过1200万人使用Anaconda发行版本，并且Anaconda拥有超过1400个适用于<a href="https://zh.wikipedia.org/wiki/Microsoft_Windows">Windows</a>、<a href="https://zh.wikipedia.org/wiki/Linux">Linux</a>和<a href="https://zh.wikipedia.org/wiki/MacOS">MacOS</a>的<a href="https://zh.wikipedia.org/w/index.php?title=%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%8C%85&amp;action=edit&amp;redlink=1">数据科学软件包</a>[<a href="https://zh.wikipedia.org/wiki/Anaconda_(Python%E5%8F%91%E8%A1%8C%E7%89%88)#cite_note-AnacondaSite-7">7]</a>。 - 维基百科</p>
<p><strong>Anaconda 与 Miniconda</strong> 的差别。</p>
<blockquote>
<p>Anaconda则是一个打包的集合，里面预装好了conda、某个版本的python、众多packages、科学计算工具等等，就是把很多常用的不常用的库都给你装好了。</p>
<p>Miniconda，顾名思义，它只包含最基本的内容——python与conda，以及相关的必须依赖项，对于空间要求严格的用户，Miniconda是一种选择。就只包含最基本的东西，其他的库得自己装。</p>
</blockquote>
<p>个人倾向于使用 Miniconda</p>
<h1>Miniconda 安装</h1>
<p>网址：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/?C=M&amp;O=D">https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/?C=M&amp;O=D</a></p>
<p>安装代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /mnt/data/zhouziwen/bin/miniConda</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-py38_4.9.2-Linux-x86_64.sh</span><br><span class="line">bash Miniconda3-py38_4.9.2-Linux-x86_64.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>安装过程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Do you accept the license terms? [yes|no] #是否接受协议，必须选 yes</span><br><span class="line">yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Anaconda3 will now be installed into this location: #安装位置，必须给一个事先不存在的路径</span><br><span class="line">/home/zhouziwen/anaconda3</span><br><span class="line"></span><br><span class="line">  - Press ENTER to confirm the location</span><br><span class="line">  - Press CTRL-C to abort the installation</span><br><span class="line">  - Or specify a different location below</span><br><span class="line"></span><br><span class="line">[/home/zhouziwen/anaconda3] &gt;&gt;&gt; /mnt/data/zhouziwen/bin/Anaconda/Anaconda3</span><br><span class="line"></span><br><span class="line">Do you wish the installer to initialize Anaconda3 #不知道啥意思，选了yes</span><br><span class="line">by running conda init? [yes|no]</span><br><span class="line">[no] &gt;&gt;&gt; yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">之后就没有提示了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，需要退出终端后，再次进入才能输入conda命令。</p>
<p>或者不想退出的话，刷新一下环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<h2 id="查看是否安装R和python">查看是否安装R和python</h2>
<p>安装好之后，发现自带了python，但是没有R</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> python</span></span><br><span class="line">/mnt/data/zhouziwen/bin/Anaconda/Anaconda3/bin/python</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> R</span></span><br><span class="line">/usr/bin/R</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">whereis R</span></span><br><span class="line">R: /usr/bin/R /usr/bin/R.distrib /usr/lib64/R /usr/include/R /usr/share/R /usr/share/man/man1/R.1.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>到Anaconda 的 bin 文件夹下看看，确实没有R，再安装R</p>
<h2 id="安装-R-4-1">安装 R 4.1</h2>
<p><a href="https://www.jianshu.com/p/9a77174549cc">https://www.jianshu.com/p/9a77174549cc</a></p>
<p>安装好 Miniconda 之后，首先添加 channel : <strong>清华镜像 free conda-forge bioconda</strong> （Miniconda 默认情况下，R 版本最高为 3.6，有点低）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda</span><br><span class="line">conda config --set show_channel_urls yes</span><br><span class="line">conda config --show  # 查看新增channels</span><br></pre></td></tr></table></figure>
<p>此时再查找一下可以用的 R (<code>conda search r</code>) ，发现就有了 4.0 和 4.1</p>
<p>安装 4.1 版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install r-base=4.1</span><br></pre></td></tr></table></figure>
<h2 id="卸载R">卸载R</h2>
<p>我发现使用 <code>conda remove r</code> 只能卸载R包，不能卸载R。</p>
<p>只能是粗暴地手动删除了。先找到R所在路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> R</span></span><br><span class="line">/mnt/data/zhouziwen/bin/Anaconda/Anaconda3/bin/R</span><br></pre></td></tr></table></figure>
<p>这里的 R 文件是一个软链接，链接到 <code>../lib/bin/R</code>。删除</p>
<p>额，找到了 <code>../lib/R</code> 文件夹，没有找到 <code>../lib/bin</code> 文件夹。删除</p>
<p>ok，删除成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> R</span></span><br><span class="line">/usr/bin/R</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件学习</category>
        <category>conda</category>
      </categories>
      <tags>
        <tag>软件学习</tag>
        <tag>conda</tag>
      </tags>
  </entry>
  <entry>
    <title>创建kegg本地数据库</title>
    <url>/posts/80b4ed31/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>将 kegg 数据库下载到本地，避免因为无法连接到 kegg 网页而无法分析。</p>
<span id="more"></span>
<h1>创建</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">library(createKEGGdb)</span><br><span class="line"></span><br><span class="line">org = &quot;gmx&quot;</span><br><span class="line"></span><br><span class="line">createKEGGdb::create_kegg_db(org) </span><br><span class="line"></span><br><span class="line">#file.rename(&quot;./KEGG.db_1.0.tar.gz&quot;, sprintf(&quot;./KEGG.db_1.0_%s.tar.gz&quot;, org))</span><br></pre></td></tr></table></figure>
<p>然后安装这个包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install.packages(&quot;KEGG.db_1.0.tar.gz&quot;, type=&#x27;source&#x27;, repos = NULL)</span><br><span class="line"></span><br><span class="line">library(KEGG.db)</span><br></pre></td></tr></table></figure>
<p>之后进行 kegg 分析，唯一的区别就是设置 <code>use_internal_data=T</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ekk=enrichKEGG(gene=eg$ENTREZID, organism=organism,keyType=&quot;kegg&quot;,pAdjustMethod=&quot;none&quot;,pvalueCutoff=1, use_internal_data=T)</span><br></pre></td></tr></table></figure>
<h1>参考文献</h1>
<ol>
<li><a href="http://www.360doc.com/content/19/1204/10/62751463_877310221.shtml">http://www.360doc.com/content/19/1204/10/62751463_877310221.shtml</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>case-control性状能用混合线性模型做GWAS吗</title>
    <url>/posts/fe54dd0e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>偶读一篇文献，发现了对于为什么case-control 性状可以使用混合线性模型做GWAS的说明。</p>
<span id="more"></span>
<h1>前提说明</h1>
<p>混合线性模型，或者标准的线性回归模型都是用于数量性状的。如果采用混合线性模型进行GWAS 分析，则性状需要满足正态分布假设。 而 case-control 性状明显是不符合正态分布假设的。</p>
<h1>the Armitage trend test</h1>
<p>Armitage 证明了可以对 case-control 性状转换为 0-1的数量性状的反应变量，然后直接使用线性回归的模型去进行检验。</p>
<p>具体证明过程我没有细看，只是记录一下，插个眼。</p>
<h1>参考文献</h1>
<ol>
<li>Kang, H., Sul, J., Service, S. <em>et al.</em> Variance component model to account for sample structure in genome-wide association studies. <em>Nat Genet</em> <strong>42</strong>, 348–354 (2010). <a href="https://doi.org/10.1038/ng.548">https://doi.org/10.1038/ng.548</a></li>
<li>Armitage, P. Tests for linear trends in proportions and frequencies. Biometrics 11,<br>
375–386 (1955)</li>
<li><a href="https://en.wikipedia.org/wiki/Cochran%E2%80%93Armitage_test_for_trend">https://en.wikipedia.org/wiki/Cochran–Armitage_test_for_trend</a></li>
<li>Agresti, A. &amp; Wiley, J.  Categorical Data Analysis (Wiley, New York, 1990)</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>python包-f2py使用流程</title>
    <url>/posts/15c32607/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>个人使用 f2py 的流程整理。</p>
<span id="more"></span>
<h1>修改 fortran 脚本</h1>
<ol>
<li>
<p>在<strong>需要直接调用的</strong>子例程中的参数中，如果存在数组，那么同时需要将<strong>数组的维度作为参数添加进来</strong>。</p>
</li>
<li>
<p>在<strong>需要直接调用的</strong>子例程中的参数中，如果存在数组，那么定义数组参数时，需要准确定义数组的维度（因为有些子例程中数组维度会定义为1）。</p>
</li>
<li>
<p>定义变量后，通过注释字符+<code>f2py</code> 定义参数的 <code>intent</code> 属性，总共有三种属性，解释如下：</p>
<ul>
<li>
<p><code>in</code> ：输入变量，只读</p>
</li>
<li>
<p><code>out</code>:  输出变量，输出变量不会出现在模块的输入参数中，如果有多个输出变量，会以元组的形式同时输出。</p>
</li>
<li>
<p><code>in, out</code> : 输入输出变量，会对输入变量进行修改，再输出，如果有多个输出变量，会以元组的形式同时输出。</p>
</li>
</ul>
</li>
</ol>
<p>举个例子，根据下面的脚本，假设这个子例程原本就只有两个数组参数 <code>a</code>, <code>b</code> ，那么首先第一步我们要将 <code>nze</code> 和 <code>n</code> 加入到子例程的参数中，第二步因为定义 <code>a</code>, <code>b</code> 时其维度已经定义好了，不需要动，第三步就是像最后两句一样定义   <code>a</code>, <code>b</code> 的 <code>intent</code> ，这里就是需要同时输入  <code>a</code>, <code>b</code>  ，然后输出 <code>a</code></p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">      <span class="keyword">real</span>*<span class="number">8</span> a(nze),b(n)</span><br><span class="line">cf2py <span class="keyword">intent</span>(<span class="keyword">in</span>,<span class="keyword">out</span>) a</span><br><span class="line">cf2py <span class="keyword">intent</span>(<span class="keyword">in</span>) b</span><br></pre></td></tr></table></figure>
<h1>检查 fortran 脚本</h1>
<p>在 linux 中逐个编译需要用到的 fortran 脚本，看看是否有语法问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gfortran -c *.f</span><br></pre></td></tr></table></figure>
<h1>调用 F2PY</h1>
<p>两种方式：既可以使用命令行工具<code>f2py</code> ，也可以使用 python 模块 <code>numpy.f2py</code> 。</p>
<p>如果使用第一种方式，则直接运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">f2py</span><br></pre></td></tr></table></figure>
<p>如果使用第二种方式，则运行命令为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -m numpy.f2py</span><br></pre></td></tr></table></figure>
<p>按照下面的命令进行打包，<code>-c</code> 后面接 fortran 脚本名称，可以包含多个脚本；<code>-m</code> 后面接输出的模块名称。</p>
<p>运行日志中如果最后有 <code>Removing build directory ***</code> 字样并且没有报错信息，则说明运行正常。并且在当前目录中会生成 <code>modulename.cpython-39-x86_64-linux-gnu.so</code>（在windows 中后缀为 <code>.pyd</code> ） 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">f2py -c *.f  -m modulename </span><br></pre></td></tr></table></figure>
<p>然后在 ipython 页面中，导入生成的模块，查看其文档 (<code>__doc__</code>)。</p>
<p>首先模块的文档包含了所有可用的函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">2</span>]: <span class="keyword">import</span> fib1</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: <span class="built_in">print</span>(fib1.__doc__)</span><br><span class="line">This module <span class="string">&#x27;fib1&#x27;</span> <span class="keyword">is</span> auto-generated <span class="keyword">with</span> f2py (version:<span class="number">1.21</span><span class="number">.5</span>).</span><br><span class="line">Functions:</span><br><span class="line">  fib(a,n=<span class="built_in">len</span>(a))</span><br><span class="line">.</span><br></pre></td></tr></table></figure>
<p>然后查看需要调用的函数的文档，可以看到所有输入函数的类型。</p>
<p>这里有两个作用，第一是检查一下是否和之前设置的参数的 <code>intent</code> 属性保持一致（如果不一致，重新调用一遍 F2PY 覆盖一下），第二就是看如何在 python 中运行这个模块 (看第一行)。这个模块在 python 中的调用方式就是 <code>ia,ja,a,b = test(option,ia,ja,a,b,[n,nze])</code> 。</p>
<p>这里也可以看到，虽然我们需要在 fortran 脚本将数组参数的维度也作为参数加入进来（<code>n</code> 和 <code>nze</code>），但是经过 F2PY 打包之后，我们在 python 中运行其实是不需要输入数组维度的（可选参数），因为会自动从输入数组维度中得到 <code>n</code> 和 <code>nze</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [2]: print(test.test.__doc__)</span><br><span class="line">ia,ja,a,b = test(option,ia,ja,a,b,[n,nze])</span><br><span class="line"></span><br><span class="line">Wrapper for ``test``.</span><br><span class="line"></span><br><span class="line">Parameters</span><br><span class="line">----------</span><br><span class="line">option : input int</span><br><span class="line">ia : input rank-1 array(&#x27;i&#x27;) with bounds (n + 1)</span><br><span class="line">ja : input rank-1 array(&#x27;i&#x27;) with bounds (nze)</span><br><span class="line">a : input rank-1 array(&#x27;d&#x27;) with bounds (nze)</span><br><span class="line">b : input rank-1 array(&#x27;d&#x27;) with bounds (n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Other Parameters</span><br><span class="line">----------------</span><br><span class="line">n : input int, optional</span><br><span class="line">    Default: (len(ia)-1)</span><br><span class="line">nze : input int, optional</span><br><span class="line">    Default: len(ja)</span><br><span class="line"></span><br><span class="line">Returns</span><br><span class="line">-------</span><br><span class="line">ia : rank-1 array(&#x27;i&#x27;) with bounds (n + 1)</span><br><span class="line">ja : rank-1 array(&#x27;i&#x27;) with bounds (nze)</span><br><span class="line">a : rank-1 array(&#x27;d&#x27;) with bounds (nze)</span><br><span class="line">b : rank-1 array(&#x27;d&#x27;) with bounds (n)</span><br></pre></td></tr></table></figure>
<p>除了在 ipython 界面运行，你也可以按照下面的命令生成一个签名文件 (<code>*.pyf</code>) ，查看子例程参数的属性。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">f2py *.f  -m * -h *.pyf</span><br></pre></td></tr></table></figure>
<h1>在 python 中运行</h1>
<p>唯一需要注意的地方就是<strong>输入数组的数据类型必须正确</strong>，不然不会对输入数组进行修改，也不会报错。</p>
<blockquote>
<p>否则 F2PY会生成输入数组的连续副本（具有正确的dtype），并将副本的C指针传递给Fortran子例程。因此，对输入数组（副本）的任何可能更改都不会影响原始参数。</p>
</blockquote>
<p>比如说 fortran 中 <code>REAL*8</code> 对应的就是 python 中的 <code>float</code> 及数组中的 <code>np.float64</code> 。</p>
<h2 id="注意-array-的顺序">注意 array 的顺序</h2>
<p>注意 numpy 数组在内存中数据顺序一直使用 C 的惯例（称为行优先顺序），而 Fortran 使用列优先顺序。举个例例子，矩阵[ [1, 2], [3, 4] ] 在内存中按行优先顺序排列成[1, 2, 3, 4]，按列优先顺序排列成<br>
[1, 3, 2, 4]。</p>
<p>因此对于2维数组，在声明时需要指定其 <code>order=’F’</code> ，即按照列优先顺序排列，从而与 Fortran 保持一致。</p>
<h1>参考文献</h1>
<ol>
<li>
<p><a href="https://numpy123.com/f2py/">https://numpy123.com/f2py/</a></p>
</li>
<li>
<p><a href="https://blog.finaltheory.me/research/Introduction-to-F2PY.html">https://blog.finaltheory.me/research/Introduction-to-F2PY.html</a></p>
</li>
<li>
<p><a href="https://sites.engineering.ucsb.edu/~shell/che210d/f2py.pdf">https://sites.engineering.ucsb.edu/~shell/che210d/f2py.pdf</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python包-cython编译脚本</title>
    <url>/posts/7e15d6ea/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>使用 cython 编译 python 脚本。</p>
<span id="more"></span>
<h1>安装 cython</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install cython</span><br></pre></td></tr></table></figure>
<p>然后查看是否安装上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cython -V</span></span><br><span class="line">Cython version 0.29.33</span><br></pre></td></tr></table></figure>
<h1>修改 pyx 脚本</h1>
<p>以下面的程序为例，这个程序是计算一个对称矩阵和一个输入向量的乘积，这个矩阵的上三角元素按照三元组的形式存储在 <code>(row_list, col_list, data_list)</code> 中，<code>x</code> 为输入向量，函数返回乘积 <code>b</code> 。</p>
<p>首先需要用 <code>cimport cython</code> 导入模块。</p>
<p>将 <code>row_list</code> 和 <code>col_list</code> 的数据类型定义为 <code>np.intc</code> ，与 C 语言中的 <code>int</code> 类型对应；将 <code>data_list</code>的数据类型定义为 <code>np.double</code> ，与 C 语言中的 <code>double</code> 类型对应。这里就是要保证数据类型一致，具体的 numpy 与 C 语言所有数据类型的对应关系可见官网 <a href="https://www.numpy.org.cn/user/basics/types.html">数组类型之间的转换</a>。</p>
<p>通过网上发现 numpy.double 等同于 numpy.float64 ,  numpy.intc 等同于 numpy.int32， 证明如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: np.double <span class="keyword">is</span> np.float64</span><br><span class="line">Out[<span class="number">2</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: np.intc <span class="keyword">is</span> np.int32</span><br><span class="line">Out[<span class="number">3</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><code>@cython.wraparound(False)</code> 和 <code>@cython.boundscheck(False)</code> 这两句是说不再检查循环变量 (<code>i</code> ) 的范围。</p>
<p><code>@cython.cdivision(True)</code> 是说使用 C 语言中的除法，而不是 python 的除法。注意如果是两个整数相除，C 语言的除法会取整，想要得到正确的结果，需要将一个数改为浮点数，比如将 <code>x</code> 改为 <code>&lt;double&gt;  (x)</code> 。</p>
<p>然后我们看函数内部 ，首先就是将数据类型改为与 C 语言一致，<code>x = x.astype(np.double)</code> 。然后数组对象需要放到缓存中，这样就能将 python 的数组对象转为 C 语言直接处理的对象，比如 <code>cdef int[:] row_list_view = row_list</code>（对 <code>row_list_view</code> 的处理，<code>row_list</code> 也会出现相应的改变）。标量可以直接定义，注意这里涉及数据维度的地方也需要提前定义，因为数组维度对象也是 python 对象，比如 <code>cdef int element_num = row_list.shape[0]</code> 。对于循环变量，定义为 <code>cdef Py_ssize_t</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cimport cython</span><br><span class="line"></span><br><span class="line">row_list = np.array(row_list, dtype = np.intc)   </span><br><span class="line">col_list = np.array(col_list, dtype = np.intc)          </span><br><span class="line">data_list = np.array(data_list, dtype = np.double)          </span><br><span class="line"></span><br><span class="line"><span class="meta">@cython.wraparound(<span class="params"><span class="literal">False</span></span>)</span></span><br><span class="line"><span class="meta">@cython.boundscheck(<span class="params"><span class="literal">False</span></span>)</span></span><br><span class="line"><span class="meta">@cython.cdivision(<span class="params"><span class="literal">True</span></span>) </span><span class="comment"># 使用 c 的除法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Ax</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="comment"># lhs_dict2 为 A 的字典, 0-index</span></span><br><span class="line">    <span class="comment"># x 为需要乘的向量，输出 Ax</span></span><br><span class="line">    <span class="comment"># x = x.astype(np.double) # 转换类型</span></span><br><span class="line">    b = np.zeros_like(x, dtype = np.double)</span><br><span class="line">    cdef <span class="built_in">int</span>[:] row_list_view = row_list <span class="comment"># 存入缓存中</span></span><br><span class="line">    cdef <span class="built_in">int</span>[:] col_list_view = col_list <span class="comment"># 存入缓存中</span></span><br><span class="line">    cdef double[:] data_list_view = data_list <span class="comment"># 存入缓存中</span></span><br><span class="line">    cdef double[:] x_view = x <span class="comment"># 存入缓存中</span></span><br><span class="line">    cdef double[:] b_view = b <span class="comment"># 存入缓存中</span></span><br><span class="line"></span><br><span class="line">    cdef <span class="built_in">int</span> element_num = row_list.shape[<span class="number">0</span>]</span><br><span class="line">    cdef Py_ssize_t i <span class="comment"># 循环变量</span></span><br><span class="line">    cdef <span class="built_in">int</span> row_index,col_index</span><br><span class="line">    cdef double data</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(element_num):</span><br><span class="line">        row_index = row_list_view[i] - <span class="number">1</span> <span class="comment"># 0-index</span></span><br><span class="line">        col_index = col_list_view[i] - <span class="number">1</span> <span class="comment"># 0-index</span></span><br><span class="line">        data = data_list_view[i]</span><br><span class="line">        b_view[row_index] += data * x_view[col_index]</span><br><span class="line">        <span class="keyword">if</span> (row_index != col_index): <span class="comment"># 非对角线元素</span></span><br><span class="line">            b_view[col_index] += data * x_view[row_index]</span><br><span class="line">            <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>
<h1>查看修改效果</h1>
<p>Cython 程序的扩展名是 .pyx ，使用下面的命令会生成一个同名的 html ，这个文件中黄色部分就是和 python 进行交互的地方，也就是拖累性能的地方。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cython -a *.pyx</span><br></pre></td></tr></table></figure>
<p>如果遇到提示 <code>FutureWarning: Cython directive 'language_level' not set, using 2 for now (Py2).</code> 。只需要在 pyx 文件开头增加一条注释，指明使用 python3 即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cython: language_level=3</span></span><br></pre></td></tr></table></figure>
<p>这里只要循环部分不是黄的，就可以了，比如上面的函数的 html 文件如下：</p>
<p><img src="1.png" alt=""></p>
<h1>使用 cython 编译 py 文件</h1>
<p>创建一个临时的 py 文件，比如 <a href="http://setup.py">setup.py</a>，其中内容如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> distutils.extension <span class="keyword">import</span> Extension</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个文件</span></span><br><span class="line"><span class="comment"># 第一个参数 recode 是输出模块的前缀，第二个列表是所有需要编译的源文件</span></span><br><span class="line">extensions=[</span><br><span class="line"> Extension(<span class="string">&quot;recode&quot;</span>, [<span class="string">&quot;recode_so.py&quot;</span>]),  <span class="comment"># 配置需要cython编译的源文件</span></span><br><span class="line"> Extension(<span class="string">&quot;blup&quot;</span>, [<span class="string">&quot;blup_so.py&quot;</span>]),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">setup(ext_modules=cythonize(extensions, language_level=<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 里面的 language_level=3 表示只需要兼容 python3 即可, 而默认是 2 和 3 都兼容</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后运行脚本进行编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python setup.py build</span><br></pre></td></tr></table></figure>
<p>在我们执行命令之后，运行成功结尾就是 <code>.so</code>。并且在当前目录会多出一个 build 目录，里面的 <code>.so</code> 文件就是编译后的文件（windows 系统中是 <code>.pyd</code> ）</p>
<p>实际使用发现，cython 不能和 numba 联合使用。</p>
<h1>参考文献</h1>
<ol>
<li>
<p><a href="https://www.cnblogs.com/traditional/p/13213173.html">https://www.cnblogs.com/traditional/p/13213173.html</a></p>
</li>
<li>
<p><a href="https://www.jianshu.com/p/9053dacee822">https://www.jianshu.com/p/9053dacee822</a></p>
</li>
<li>
<p><a href="https://www.bilibili.com/video/BV1NF411i74S?p=1&amp;vd_source=584d44ba7fed271fb82848e7894a53c8">https://www.bilibili.com/video/BV1NF411i74S?p=1&amp;vd_source=584d44ba7fed271fb82848e7894a53c8</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python获得网络时间</title>
    <url>/posts/309f8f08/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>使用 <code>http.client</code> 包获得网络时间。</p>
<span id="more"></span>
<h1>获得网络时间</h1>
<p>首先需要安装 <code>http.client</code> 这个包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install http.client</span><br></pre></td></tr></table></figure>
<p>运行下面的脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> http.client</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">host = <span class="string">&#x27;www.baidu.com&#x27;</span></span><br><span class="line">conn=http.client.HTTPConnection(host)</span><br><span class="line">conn.request(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">r=conn.getresponse()</span><br><span class="line">ts=  r.getheader(<span class="string">&#x27;date&#x27;</span>) <span class="comment">#获取http头date部分</span></span><br><span class="line"><span class="comment">#将GMT时间转换成北京时间</span></span><br><span class="line">ltime= time.strptime(ts[<span class="number">5</span>:<span class="number">25</span>], <span class="string">&quot;%d %b %Y %H:%M:%S&quot;</span>) <span class="comment"># GMT 时间</span></span><br><span class="line">ttime=time.localtime(time.mktime(ltime)+<span class="number">8</span>*<span class="number">60</span>*<span class="number">60</span>) <span class="comment"># 北京时间</span></span><br><span class="line">dat=<span class="string">f&quot;<span class="subst">&#123;ttime.tm_year&#125;</span>-<span class="subst">&#123;ttime.tm_mon:02d&#125;</span>-<span class="subst">&#123;ttime.tm_mday:02d&#125;</span>&quot;</span></span><br><span class="line">tm=<span class="string">f&quot;<span class="subst">&#123;ttime.tm_hour:02d&#125;</span>:<span class="subst">&#123;ttime.tm_min:02d&#125;</span>:<span class="subst">&#123;ttime.tm_sec:02d&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">print</span>(dat,tm)</span><br><span class="line"><span class="comment"># 或者也可以直接使用 strftime() 输出, 会自动补零</span></span><br><span class="line"><span class="built_in">print</span>(time.strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>, ttime))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2023-02-17 13:46:54</span><br></pre></td></tr></table></figure>
<h1>参考文献</h1>
<ol>
<li><a href="https://cloud.tencent.com/developer/article/1570662">https://cloud.tencent.com/developer/article/1570662</a></li>
</ol>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python包-re-time-random-collections-argparse</title>
    <url>/posts/1fd14144/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>多个比较简单的 python 包的备忘录。</p>
<span id="more"></span>
<h1>re</h1>
<h2 id="多个分隔符拆分字符串">多个分隔符拆分字符串</h2>
<p>内置的 split() 函数只能有一个分隔符，可以采用 re 模块的 split 函数，可以采用多个分隔符，用 <code>|</code> 分开</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">re.split(<span class="string">&#x27;;|:&#x27;</span>, text)</span><br></pre></td></tr></table></figure>
<h1>time</h1>
<p>打印软件运行开始和结束时间如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">begin_time = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Start time: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(begin_time)) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">end_time = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Finish time: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(end_time)) </span><br></pre></td></tr></table></figure>
<h1>random</h1>
<h2 id="shuffle">shuffle</h2>
<p>shuffle 可以将列表中的元素随机排列（<strong>原地操作</strong>）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">list1 = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">random.shuffle(list1)</span><br><span class="line"><span class="built_in">print</span>(list1)</span><br></pre></td></tr></table></figure>
<p>输出为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h1>collections</h1>
<h2 id="defaultdict">defaultdict</h2>
<p>可以设置字典的值的默认格式，比如列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">dict1 = defaultdict(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Counter">Counter</h2>
<p>字典的值默认为 0，起到计数功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">dict1 = Counter()</span><br><span class="line">dict1[<span class="string">&quot;a&quot;</span>] += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>统计最常见的数（计数最多的键），使用 most_common([n]) 函数，其中的参数为输出键值对数目（如果省略则输出全部元素）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">dict1 = Counter(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line">dict1.most_common(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>输出为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="number">5</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;r&#x27;</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure>
<h2 id="OrderedDict">OrderedDict</h2>
<p>有序字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line">dict1 = OrderedDict()</span><br></pre></td></tr></table></figure>
<h1>argparse</h1>
<p>第一步，创建解析步骤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import argparse</span><br><span class="line">parser = argparse.ArgumentParser(prog = &#x27;&#x27;, description=&#x27;Process some integers.&#x27;)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>prog</strong> : 程序名称，默认为 sys.argv[0]</li>
<li><strong>description</strong> :是对整个程序的说明，会打印在帮助文档的开头</li>
</ul>
<p>第二步，添加参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&quot;-r&quot;</span>, <span class="string">&quot;--raw&quot;</span>, required=<span class="literal">True</span>, </span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&#x27;&#x27;&#x27;the raw file generated from plink software&#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>每一个参数单独设置，参数名称可以设置为缩写（-h）和全称（–help），也可以同时设置。</p>
<p>重要参数设定解释：</p>
<ul>
<li>
<p>type</p>
<p>参数类型，默认为str ， 也可以设置为 float 或 int 。</p>
</li>
<li>
<p><strong>choices</strong></p>
<p>指定参数值的范围，必须事先指定 type</p>
<p>举个例子，这里是设置 -x 参数必须是从1到3的某个整数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;-x&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, choices=<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<p>如果输入的参数不在这个范围内，则报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">usage: [-h] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">: error: argument x: invalid choice: <span class="number">4</span> (choose <span class="keyword">from</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>required</p>
<p>是否为必选参数，默认为True （仅针对可选选项）</p>
</li>
<li>
<p>default</p>
<p>该参数未出现时的默认值（感觉应该配合required =  False ，联合使用）</p>
</li>
<li>
<p>help</p>
<p>帮助的解释信息</p>
</li>
</ul>
<p>第三步，解析参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="built_in">print</span>(args.gpus)</span><br></pre></td></tr></table></figure>
<h2 id="实际例子">实际例子</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;do sth&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加参数步骤</span></span><br><span class="line">parser.add_argument(<span class="string">&quot;-r&quot;</span>, <span class="string">&quot;--raw&quot;</span>, required=<span class="literal">True</span>, </span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&#x27;&#x27;&#x27;the raw file&#x27;&#x27;&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;-i&quot;</span>, <span class="string">&quot;--id&quot;</span>, required=<span class="literal">True</span>, </span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&#x27;&#x27;&#x27;id file&#x27;&#x27;&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;-p&quot;</span>, <span class="string">&quot;--pedigree&quot;</span>, required=<span class="literal">True</span>, </span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&#x27;&#x27;&#x27;the pedigree file&#x27;&#x27;&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;--choose&quot;</span>, required=<span class="literal">False</span>, </span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&#x27;&#x27;&#x27;a list file&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析参数步骤  </span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="built_in">print</span>(args.raw)</span><br><span class="line"><span class="built_in">print</span>(args.<span class="built_in">id</span>)</span><br><span class="line"><span class="built_in">print</span>(args.pedigree)</span><br><span class="line"><span class="built_in">print</span>(args.choose)    </span><br></pre></td></tr></table></figure>
<h1>参考文献</h1>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/34395749">Python-argparse-命令行与参数解析</a></li>
</ol>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础及标准库</title>
    <url>/posts/81382537/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>python基础部分备忘录。</p>
<span id="more"></span>
<h1>python 基础</h1>
<p>python 是一门解释型语言，无需编译。</p>
<h2 id="数据类型">数据类型</h2>
<p>不可变对象：数值（Numbers），字符串 （String) ， 元组 （Tuple) ，逻辑值 （Bool)</p>
<p>可变对象：列表（List)，字典（Dictionary），集合（Set)</p>
<h3 id="None">None</h3>
<p>None是Python的空值类型。如果一个函数没有明确的返回值，就会默认返回None。</p>
<p>判断是否为空值，要用 <code>is</code>(内存地址是否相同)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">37</span>]: a = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: a <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">Out[<span class="number">38</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>None也常常作为函数的默认参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">39</span>]: <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a,b,c=<span class="literal">None</span></span>):</span><br><span class="line">    ...:     result = a + b</span><br><span class="line">        </span><br><span class="line">    ...:     <span class="keyword">if</span> c <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    ...:         result = result * c</span><br><span class="line">        </span><br><span class="line">    ...:     <span class="keyword">return</span> result</span><br><span class="line">    ...:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另外，None 不仅是一个保留字，还是唯一的 NoneType 的实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">40</span>]: <span class="built_in">type</span>(<span class="literal">None</span>)</span><br><span class="line">Out[<span class="number">40</span>]: NoneType</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="变量赋值">变量赋值</h2>
<p>在 python 中，变量名称和变量本身的值是一种引用（指针）的关系，我个人就是理解为标签和人的关系，每个人均至少需要贴一个标签，一个人身上可以有多个标签，赋值的过程就是将左侧的标签对应上右侧的值。</p>
<p>因此对于不可变对象，如果修改某个变量的值（因为这个过程是新建了一个值），不会影响其它变量，以字符串举例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=&#x27;ABC&#x27;</span><br><span class="line">b=a</span><br><span class="line">a=&#x27;XYZ&#x27;</span><br><span class="line"># 问此时b是什么？</span><br><span class="line"># 咋一看，b=a，此时a=&#x27;XYZ&#x27;,b也应该是&#x27;XYZ&#x27;</span><br><span class="line"># 实际上不是，变量的名称和值是映射的关系，</span><br><span class="line"># 这里的逻辑是首先内存中创建了一个值’ABC&#x27;,变量a 映射到了ABC, 之后变量b也映射到了ABC</span><br><span class="line"># 最后将a又映射到XYZ，过程见下图</span><br></pre></td></tr></table></figure>
<p><img src="1.png" alt="1"></p>
<p>但是，对于可变对象，则相反。举个例子，下面这种形式b也会改变（<strong>因为列表是可变对象，这里是修改了原列表</strong>）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">b=a</span><br><span class="line">a.append(<span class="number">3</span>) <span class="comment">#b一样会改变</span></span><br></pre></td></tr></table></figure>
<p>如果是 a=[1,2] , b=[1,2]，这个时候修改a，对b就没有任何影响了，因为这时候是创建了两个列表对象。</p>
<h2 id="函数中修改全局变量（变量作用域）">函数中修改全局变量（变量作用域）</h2>
<p>可变对象：当函数内修改同名变量时，函数外的同名变量也会随之改变，所以<strong>使用修改可变对象没有作用域的概念</strong>。</p>
<p>不可变对象：当函数内修改同名变量时，<strong>会先复制过来再修改</strong>，函数外部的变量不变。（如果一定要修改，可以使用 <code>global x</code>，x为全局变量名）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a,b</span>):</span><br><span class="line">    a=a+<span class="number">1</span></span><br><span class="line">    b.append(<span class="number">13</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;inner a: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(a))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;inner b: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(b))</span><br><span class="line"></span><br><span class="line">a=<span class="number">5</span></span><br><span class="line">b=[<span class="number">10</span>,<span class="number">11</span>]</span><br><span class="line"></span><br><span class="line">test(a,b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;outer a: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;outer b: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(b))</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inner a: <span class="number">6</span></span><br><span class="line">inner b: [<span class="number">10</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line">outer a: <span class="number">5</span></span><br><span class="line">outer b: [<span class="number">10</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br></pre></td></tr></table></figure>
<p>注意如果再次运行 <code>test(a,b)</code>，那么列表 b 中还会新增一个元素 13 ，为了避免出现问题，<strong>避免使用可变对象作为函数参数</strong>。我们可以在函数内部中定义新的局部可变对象，也可以直接读取或修改全局变量中的可变对象。</p>
<h3 id="变量查找顺序">变量查找顺序</h3>
<p>函数内部 – 父函数（如果有）-- 全局 – python 内置变量</p>
<p><strong>UnboundLocalError</strong> ： 函数先调用，后修改同名全局变量。</p>
<h3 id="函数调用和修改同名全局变量（针对不可变变量）">函数调用和修改同名全局变量（针对不可变变量）</h3>
<ol>
<li>
<p>光调用 ： python 认为是全局变量，没有问题</p>
</li>
<li>
<p>光修改：  python 认为是局部变量（只是和全局变量同名），也没有问题</p>
</li>
<li>
<p>调用+修改 ，分为两种情况</p>
<p>3.1 先改，后调用：python 认为是局部变量，python 认为是局部变量，没有问题</p>
<p>3.2 先调用，后改：python 认为是修改全局变量，<strong>报错</strong>。</p>
</li>
</ol>
<p>其实不用那么麻烦，命名的时候注意一点，<strong>避免函数内的变量名和全局变量同名</strong>就好了。</p>
<h3 id="函数返回值">函数返回值</h3>
<ul>
<li>无 return : 返回值均为 None。 例如 a = function() ， a 均为 None</li>
<li>有 return : return 一旦执行，函数就会终止。</li>
</ul>
<h2 id="字符串操作">字符串操作</h2>
<h3 id="字符串查找">字符串查找</h3>
<ul>
<li>str.find() : 找到目标时返回该字符的索引位置；没找到返回-1</li>
<li>str.index() : 找到目标时返回该字符的索引位置；没找到报错</li>
</ul>
<h3 id="字符串分割">字符串分割</h3>
<ul>
<li>str.patition() : 将字符串按找到的第一个关键字分割为三段（只分割一次），形成一个元组，内容包括关键字前、关键字本身、关键字后</li>
<li>str.split() : 以关键字为分割点进行分割（多次分割，且结果中不包含关键字），生成一个列表。</li>
<li>str.strip() : 移除字符串头尾指定的字符（默认是空格）</li>
</ul>
<h3 id="字符串运算符">字符串运算符</h3>
<ul>
<li>+ : 连接字符串</li>
<li>* : 重复，比如 a=“hello” , a*2 为 “hellohello&quot;</li>
<li>[startnum:endnum] :  获取子字符串</li>
<li>in : 判断子字符串是否在大字符串中</li>
<li>not in</li>
<li>“”&quot;  “”&quot; : 允许跨行</li>
<li>str.lower()  : 全部转为小写</li>
<li>str.upper() : 全部转为大写</li>
<li>str.replace(old, new) : 替换字符串</li>
</ul>
<h2 id="break">break</h2>
<h3 id="break-与-continue">break 与 continue</h3>
<ul>
<li>break 是直接跳出循环，包括该循环的 else 。如果break 在内层循环，则会跳出内层循环，但是不影响外层循环和外层循环的 else 部分</li>
<li>continue : 准确地说，continue 是指不执行循环体中continue 语句之后的代码，重新回到循环开始部分，直接进入下一次循环。</li>
</ul>
<h3 id="break-与-else">break 与 else</h3>
<p>for else 语句 与 while else 语句 中如果存在 if break 语句，else 语句只有在满足下面两个条件才会运行</p>
<ul>
<li>for/while 执行完</li>
<li>整个循环过程中没有触发 break</li>
</ul>
<h2 id="所有逻辑值">所有逻辑值</h2>
<p>python 进行逻辑判断的时候，认为:</p>
<ul>
<li>True : 所有非空的量（非空字符串，非空列表）；非0的数字</li>
<li>False : <strong>0，None, False, 任意为空的量</strong></li>
</ul>
<h2 id="递归函数">递归函数</h2>
<p>递归函数有两点：</p>
<ol>
<li>自己引用自己</li>
<li>有一个明确的递归结束条件（不然就成死循环了）</li>
</ol>
<p>例子一，目录遍历（或得一个目录所有文件/文件夹的路径，包括子目录，子子目录……）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">m = []</span><br><span class="line">def dirlist(path):</span><br><span class="line">	file_list = os.listdir(path)</span><br><span class="line">	for i in file_list:</span><br><span class="line">		file_path = os.path.join(path,i)</span><br><span class="line">		m.append(file_path)</span><br><span class="line">		if os.path.isdir(file_path):</span><br><span class="line">			dirlist(file_path) #引用自身</span><br></pre></td></tr></table></figure>
<p>例子二，求阶乘 n!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">n</span>):</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n*f(n-<span class="number">1</span>) </span><br><span class="line"><span class="comment">#这里不用写else，因为python 只要运行了一个return，程序自动退出。但是我觉得还是写上 else，逻辑更严密，提高可读性</span></span><br></pre></td></tr></table></figure>
<h2 id="切片">切片</h2>
<p>格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequence[start_index:end_index:step]</span><br></pre></td></tr></table></figure>
<ul>
<li>start_index : 默认为0</li>
<li>end_index : 默认为 len(sequence)</li>
<li>step : 步长，默认为1（正索引），-1 表示负索引</li>
</ul>
<p>注意：这里的正索引指的是<strong>方向从左到右</strong>，而不是单纯的索引号的增加。</p>
<p>所以 <code>[:-1]</code>  表示从第一个位置，一直向右，读到倒数第二个位置（即不要最后一个）。<code>[-2:]</code> 表示提取最后两个位置</p>
<h2 id="列表排序">列表排序</h2>
<p>简单列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=[3,1,2]</span><br><span class="line">b=sorted(a,reverse=True/False)</span><br><span class="line">a.sort(reverse=True/False)</span><br></pre></td></tr></table></figure>
<p>复杂列表（例如列表的每个元素又是一个长度为2的列表）</p>
<p>下面这两种方式的区别在于：如果列表的元素是字符类型，第一种按照 ASCII 码顺序，<strong>先比第一个字符，如果相同再比第二个字符</strong>，依次类推；第二种才是按照数字大小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m2 = sorted(m1, key =lambda x:x[1], reverse=True/False)</span><br><span class="line">m2 = sorted(m1, key =lambda x:float(x[1]), reverse=True/False)</span><br></pre></td></tr></table></figure>
<p>多个条件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dup_sort_list = <span class="built_in">sorted</span>(dup_list, key = <span class="keyword">lambda</span> s:(<span class="built_in">float</span>(s[<span class="number">5</span>]),s[<span class="number">0</span>])) <span class="comment">#不一致率从小到大</span></span><br></pre></td></tr></table></figure>
<h2 id="删除对象">删除对象</h2>
<ul>
<li>del a : 只是删除对象的一个引用</li>
</ul>
<h1>python 标准库</h1>
<p><a href="https://docs.python.org/zh-cn/3/library/index.html">https://docs.python.org/zh-cn/3/library/index.html</a></p>
<h2 id="内置函数">内置函数</h2>
<h3 id="enumerate-iterable-start-0"><code>enumerate</code>(<em>iterable</em>, <em>start=0</em>)</h3>
<p>返回一个枚举对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>seasons = [<span class="string">&#x27;Spring&#x27;</span>, <span class="string">&#x27;Summer&#x27;</span>, <span class="string">&#x27;Fall&#x27;</span>, <span class="string">&#x27;Winter&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">enumerate</span>(seasons)</span><br><span class="line">&lt;<span class="built_in">enumerate</span> <span class="built_in">object</span> at <span class="number">0x2ba732af1c40</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">enumerate</span>(seasons))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">&#x27;Spring&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;Summer&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;Fall&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;Winter&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">enumerate</span>(seasons, start=<span class="number">1</span>))</span><br><span class="line">[(<span class="number">1</span>, <span class="string">&#x27;Spring&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;Summer&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;Fall&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;Winter&#x27;</span>)]</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">enumerate</span>(<span class="params">sequence, start=<span class="number">0</span></span>):</span><br><span class="line">    n = start</span><br><span class="line">    <span class="keyword">for</span> elem <span class="keyword">in</span> sequence:</span><br><span class="line">        <span class="keyword">yield</span> n, elem</span><br><span class="line">        n += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="zip-iterables"><code>zip</code>(*<em>iterables</em>)</h3>
<p>创建一个聚合了来自每个可迭代对象中的元素的<strong>元组</strong>的迭代器。</p>
<p>**当所输入可迭代对象中最短的一个被耗尽时，迭代器将停止迭代。 **</p>
<p>相当于：（没看懂）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def zip(*iterables):</span><br><span class="line">    # zip(&#x27;ABCD&#x27;, &#x27;xy&#x27;) --&gt; Ax By</span><br><span class="line">    sentinel = object()</span><br><span class="line">    iterators = [iter(it) for it in iterables]</span><br><span class="line">    while iterators:</span><br><span class="line">        result = []</span><br><span class="line">        for it in iterators:</span><br><span class="line">            elem = next(it, sentinel)</span><br><span class="line">            if elem is sentinel:</span><br><span class="line">                return</span><br><span class="line">            result.append(elem)</span><br><span class="line">        yield tuple(result)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zipped = <span class="built_in">zip</span>(x, y)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(zipped)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">zip</span>(*<span class="built_in">zip</span>(x, y))) <span class="comment">#返回原来的两个列表</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x2, y2 = <span class="built_in">zip</span>(*<span class="built_in">zip</span>(x, y))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x == <span class="built_in">list</span>(x2) <span class="keyword">and</span> y == <span class="built_in">list</span>(y2)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>zip 也可以用于使用两个列表构建字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">73</span>]: mapping = <span class="built_in">dict</span>(<span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">5</span>),<span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">5</span>))))</span><br><span class="line"></span><br><span class="line">In [<span class="number">74</span>]: mapping</span><br><span class="line">Out[<span class="number">74</span>]: &#123;<span class="number">0</span>: <span class="number">4</span>, <span class="number">1</span>: <span class="number">3</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">1</span>, <span class="number">4</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="内置类型">内置类型</h2>
<h3 id="数字类型-—-int-float-complex">数字类型 — int, float, complex</h3>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">运算</td>
<td style="text-align:left">结果</td>
<td style="text-align:left">注释</td>
<td style="text-align:left">完整文档</td>
</tr>
<tr>
<td style="text-align:left"><code>x // y</code></td>
<td style="text-align:left"><em>x</em> 和 <em>y</em> 的商数（整除）</td>
<td style="text-align:left">整除</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>x % y</code></td>
<td style="text-align:left"><code>x / y</code> 的余数</td>
<td style="text-align:left">(2)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>abs(x)</code></td>
<td style="text-align:left"><em>x</em> 的绝对值或大小</td>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/functions.html#abs"><code>abs()</code></a></td>
</tr>
<tr>
<td style="text-align:left"><code>divmod(x, y)</code></td>
<td style="text-align:left"><code>(x // y, x % y)</code></td>
<td style="text-align:left">(2)</td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/functions.html#divmod"><code>divmod()</code></a></td>
</tr>
<tr>
<td style="text-align:left"><code>pow(x, y)</code></td>
<td style="text-align:left"><em>x</em> 的 <em>y</em> 次幂</td>
<td style="text-align:left">(5)</td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/functions.html#pow"><code>pow()</code></a></td>
</tr>
<tr>
<td style="text-align:left"><code>x ** y</code></td>
<td style="text-align:left"><em>x</em> 的 <em>y</em> 次幂</td>
<td style="text-align:left">(5)</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>注释：</p>
<ol>
<li>
<p>也称为整数除法。 结果值是一个整数，但结果的类型不一定是 int。 运算结果总是向负无穷的方向舍入: <code>1//2</code> 为 <code>0</code>, <code>(-1)//2</code> 为 <code>-1</code>, <code>1//(-2)</code> 为 <code>-1</code> 而 <code>(-1)//(-2)</code> 为 <code>0</code>。</p>
</li>
<li>
<p><strong>从浮点数转换为整数会被舍入</strong>；请参阅 <a href="https://docs.python.org/zh-cn/3/library/math.html#math.floor"><code>math.floor()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/math.html#math.ceil"><code>math.ceil()</code></a> 函数查看转换的完整定义。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="number">1.9</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>float 也接受字符串 “nan” 和附带可选前缀 “+” 或 “-” 的 “inf” 分别表示非数字 (NaN) 以及正或负无穷。</p>
</li>
<li>
<p>Python 将 <code>pow(0, 0)</code> 和 <code>0 ** 0</code> 定义为 <code>1</code>，这是编程语言的普遍做法。</p>
</li>
</ol>
<p>浮点型类型还包括以下运算。</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/math.html#math.trunc"><code>math.trunc(x)</code></a></td>
<td style="text-align:left"><em>x</em> 截断为 <a href="https://docs.python.org/zh-cn/3/library/numbers.html#numbers.Integral"><code>Integral</code></a></td>
</tr>
<tr>
<td style="text-align:left"><code>round(x[, n]）</code></td>
<td style="text-align:left"><em>x</em> 舍入到 <em>n</em> 位小数，半数值会舍入到偶数。 如果省略 <em>n</em>，则默认为 0。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/math.html#math.floor"><code>math.floor(x)</code></a></td>
<td style="text-align:left">&lt;= <em>x</em> 的最大 <a href="https://docs.python.org/zh-cn/3/library/numbers.html#numbers.Integral"><code>Integral</code></a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3/library/math.html#math.ceil"><code>math.ceil(x)</code></a></td>
<td style="text-align:left">&gt;= <em>x</em> 的最小 <a href="https://docs.python.org/zh-cn/3/library/numbers.html#numbers.Integral"><code>Integral</code></a></td>
</tr>
</tbody>
</table>
<h3 id="序列类型-–-list-tuple-range">序列类型 – list, tuple, range</h3>
<h4 id="通用序列操作">通用序列操作</h4>
<p>此表按优先级升序列出了序列操作。 在表格中，<em>s</em> 和 <em>t</em> 是具有相同类型的序列，<em>n</em>, <em>i</em>, <em>j</em> 和 <em>k</em> 是整数而 <em>x</em> 是任何满足 <em>s</em> 所规定的类型和值限制的任意对象。</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算</th>
<th style="text-align:left">结果</th>
<th style="text-align:left">注释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>x in s</code></td>
<td style="text-align:left">如果 <em>s</em> 中的某项等于 <em>x</em> 则结果为 <code>True</code>，否则为 <code>False</code></td>
<td style="text-align:left">(1)</td>
</tr>
<tr>
<td style="text-align:left"><code>x not in s</code></td>
<td style="text-align:left">如果 <em>s</em> 中的某项等于 <em>x</em> 则结果为 <code>False</code>，否则为 <code>True</code></td>
<td style="text-align:left">(1)</td>
</tr>
<tr>
<td style="text-align:left"><code>s + t</code></td>
<td style="text-align:left"><em>s</em> 与 <em>t</em> 相拼接</td>
<td style="text-align:left">(6)(7)</td>
</tr>
<tr>
<td style="text-align:left"><code>s * n</code> 或 <code>n * s</code></td>
<td style="text-align:left">相当于 <em>s</em> 与自身进行 <em>n</em> 次拼接</td>
<td style="text-align:left">(2)(7)</td>
</tr>
<tr>
<td style="text-align:left"><code>s[i]</code></td>
<td style="text-align:left"><em>s</em> 的第 <em>i</em> 项，起始为 0</td>
<td style="text-align:left">(3)</td>
</tr>
<tr>
<td style="text-align:left"><code>s[i:j]</code></td>
<td style="text-align:left"><em>s</em> 从 <em>i</em> 到 <em>j</em> 的切片</td>
<td style="text-align:left">(3)(4)</td>
</tr>
<tr>
<td style="text-align:left"><code>s[i:j:k]</code></td>
<td style="text-align:left"><em>s</em> 从 <em>i</em> 到 <em>j</em> 步长为 <em>k</em> 的切片</td>
<td style="text-align:left">(3)(5)</td>
</tr>
<tr>
<td style="text-align:left"><code>len(s)</code></td>
<td style="text-align:left"><em>s</em> 的长度</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>min(s)</code></td>
<td style="text-align:left"><em>s</em> 的最小项</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>max(s)</code></td>
<td style="text-align:left"><em>s</em> 的最大项</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>s.index(x[, i[, j]])</code></td>
<td style="text-align:left"><em>x</em> 在 <em>s</em> 中首次出现项的索引号（索引号在 <em>i</em> 或其后且在 <em>j</em> 之前）</td>
<td style="text-align:left">(8)</td>
</tr>
<tr>
<td style="text-align:left"><code>s.count(x)</code></td>
<td style="text-align:left"><em>x</em> 在 <em>s</em> 中出现的总次数</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<ol start="2">
<li>
<p>注意：这里的<code>*</code> 号并不是拷贝，而是<strong>多次引用</strong>。例如下式，由于是引用，修改任一元素都是对这一个空列表的修改。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; lists = [[]] * 3</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; lists</span></span><br><span class="line">[[], [], []]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; lists[0].append(3)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; lists</span></span><br><span class="line">[[3], [3], [3]]</span><br></pre></td></tr></table></figure>
<p>你可以用以下方式创建以不同列表为元素的列表:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists[<span class="number">0</span>].append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists[<span class="number">1</span>].append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists[<span class="number">2</span>].append(<span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists</span><br><span class="line">[[<span class="number">3</span>], [<span class="number">5</span>], [<span class="number">7</span>]]</span><br></pre></td></tr></table></figure>
<p>但是如果是可变对象，则没有影响</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">16</span>]: a = [<span class="number">0</span>] * <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: a[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: a</span><br><span class="line">Out[<span class="number">18</span>]: [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>切片中的 i 或 j 如果为负值， 索引号会被替换为 <code>len(s) + i</code> 或 <code>len(s) + j</code></p>
<p>例如 a[-2:] 中的 -2 会被替换为 len(a)-2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[-<span class="number">2</span>:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="built_in">len</span>(a)-<span class="number">2</span>:]</span><br><span class="line">[<span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>s 从i 到 j 的切片需要满足<strong>i &lt;j</strong>。如果 i 或 j 大于 <code>len(s)</code> ，则使用 <code>len(s)</code>。 如果 <em>i</em> 被省略或为 <code>None</code>，则使用 <code>0</code>。 如果 <em>j</em> 被省略或为 <code>None</code>，则使用 <code>len(s)</code>。 如果 <em>i</em> 大于等于 <em>j</em>，则切片为空。</p>
</li>
<li>
<p>拼接不可变序列总是会生成新的对象。 这意味着通过重复拼接来构建序列的运行时开销将会基于序列总长度的乘方。 想要获得线性的运行时开销，你必须改用下列替代方案之一</p>
<p>这里主要讨论<strong>拼接字符串</strong>。当我们使用加号(+)操作符去连接大量的字符串的时候是非常低效率的， 因为加号连接会引起内存复制以及垃圾回收操作。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>plink软件备忘录</title>
    <url>/posts/18c130be/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这是我个人使用的plink软件备忘录，将我所有会用到但是又没有完全记住的选项和功能记录在这里，方便查看。</p>
<span id="more"></span>
<h1>输入输出</h1>
<h2 id="输入">输入</h2>
<h3 id="compound格式">compound格式</h3>
<p>使用 <strong>–compound-genotypes</strong> 选项，读取 compound格式的plink文件（一个SNP的两个碱基之间没有空格）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">plink --file compound --compound-genotypes --recode --out new</span><br></pre></td></tr></table></figure>
<h3 id="二进制文件-bed">二进制文件(bed)</h3>
<p>查看plink2.0文章的算法部分，发现plink2.0 采用了<strong>按位运算</strong>，大大提高了计算效率。但是按位运算的前提是需要先把基因型文件转化为<strong>二进制</strong>格式。因此这里，需要介绍一下plink 生成的bed文件格式：</p>
<p>官方说明：<a href="http://zzz.bwh.harvard.edu/plink/binary.shtml">http://zzz.bwh.harvard.edu/plink/binary.shtml</a></p>
<p>这个说明很详细，看这个就懂了。</p>
<p>首先，plink生成二进制文件时，同时会生成bim和fam文件。因此，plink 读取bed文件到的时候，同时也会读取 bim 和 fam 文件，获取<strong>snp和样本数目</strong>信息。</p>
<p>一个SNP的碱基信息会转化为2 bits。规则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00  Homozygote &quot;1&quot;/&quot;1&quot; （first allele in .bim file）</span><br><span class="line"> 01  Heterozygote</span><br><span class="line"> 11  Homozygote &quot;2&quot;/&quot;2&quot;</span><br><span class="line"> 10  Missing genotype</span><br></pre></td></tr></table></figure>
<p>bed 文件将8个bits 作为一个 block (即一个字节)。一开始的三个block是由plink指定的，从第四个开始才开始记录基因型数据。</p>
<p>前两个 block 称为 magic number ，作用是用于plink软件来区分这个bed是不是真的bed文件。第三个 block 称为 mode ，表明这个bed文件是SNP-major(00000001) 还是 individual-major(0000000)，这个意思就是说数据按什么顺序排序，默认都是按照SNP的顺序，即先把bim文件中第一个SNP的所有基因型排列完，然后是第二个SNP，第三个SNP……（一直到最后，如果样本不能整除4，那么最后一个block多余的bits设为0，确保每一个新行都从一个新的block开始）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-magic number--| |-mode-| |--genotype data---------| </span><br><span class="line"></span><br><span class="line">01101100 00011011 00000001 11011100 00001111 11100111</span><br><span class="line"></span><br><span class="line">|--genotype data-cont&#x27;d--| </span><br><span class="line"></span><br><span class="line">00001111 01101011 00000001 </span><br></pre></td></tr></table></figure>
<p>这里其相应的 bim 文件内容如下（<strong>A1 为等位基因频率较小的碱基</strong> ）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1       snp1    0       1       G       A</span><br><span class="line">1       snp2    0       2       1       2</span><br><span class="line">1       snp3    0       3       A       C</span><br></pre></td></tr></table></figure>
<p>fam 文件如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 0 0 1 0</span><br><span class="line">1 2 0 0 1 0</span><br><span class="line">1 3 1 2 1 2</span><br><span class="line">2 1 0 0 1 0</span><br><span class="line">2 2 0 0 1 2</span><br><span class="line">2 3 1 2 1 2</span><br></pre></td></tr></table></figure>
<p>这里还有一个小问题是，<strong>在读取每个字节数据的时候</strong>是<strong>从后向前</strong>读的。如果把一个字节的8个位置<strong>从后到前</strong>标记伪 A 到 H，举例如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01101100</span><br><span class="line">HGFEDCBA</span><br></pre></td></tr></table></figure>
<p>第一个SNP的前4个基因型则为 AB, CD,EF,GH 四个位置对应的分型，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">01101100</span><br><span class="line">HGFEDCBA</span><br><span class="line"></span><br><span class="line">      AB   00  -- homozygote (first)</span><br><span class="line">    CD     11  -- other homozygote (second)</span><br><span class="line">  EF       01  -- heterozygote (third)</span><br><span class="line">GH         10  -- missing genotype (fourth)</span><br></pre></td></tr></table></figure>
<p>上面例子中的 3 个位点的解析如下，第一个SNP的 A1 和 A2 碱基为 G 和 A ，因此 00 对应 GG，01 对应 GA ，11 对应 GG ，10 对应缺失。由于这里总共是 6 个样本，因此一个 SNP 需要占用 2 个字节，第<strong>二个字节多余的位置使用 00 填充</strong>。</p>
<p>因此第一个SNP的第一个样本是GG，之后是AA,00, AA, AA, AA。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">           Genotype    Person    SNP</span><br><span class="line">11011100 </span><br><span class="line"></span><br><span class="line">      00   G/G         1 1       snp1</span><br><span class="line">    11     A/A         1 2       snp1</span><br><span class="line">  10       0/0         1 3       snp1</span><br><span class="line">11         A/A         2 1       snp1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">00001111 </span><br><span class="line"></span><br><span class="line">      11   A/A         2 2       snp1</span><br><span class="line">    11     A/A         2 3       snp1</span><br><span class="line">  00       (null)</span><br><span class="line">00         (null)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">11100111</span><br><span class="line">      </span><br><span class="line">      11   2/2         1 1       snp2</span><br><span class="line">    10     0/0         1 2       snp2</span><br><span class="line">  01       1/2         1 3       snp2</span><br><span class="line">11         2/2         2 1       snp2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">00001111 </span><br><span class="line">  </span><br><span class="line">      11   2/2         2 2       snp2</span><br><span class="line">    11     2/2         2 3       snp2</span><br><span class="line">  00       (null) </span><br><span class="line">00         (null)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">01101011</span><br><span class="line"></span><br><span class="line">      11   C/C         1 1       snp3</span><br><span class="line">    01     A/C         1 2       snp3</span><br><span class="line">  01       A/C         1 3       snp3</span><br><span class="line">10         0/0         2 1       snp3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">00000001</span><br><span class="line"></span><br><span class="line">      10   0/0         2 2       snp3</span><br><span class="line">    00     A/A         2 3       snp3</span><br><span class="line">  00       (null)</span><br><span class="line">00         (null)</span><br></pre></td></tr></table></figure>
<h3 id="VCF-文件">VCF 文件</h3>
<p>联合使用 <strong>–vcf filename</strong> 和 <strong>–const-fid</strong> 来读取 vcf 文件，这里  <strong>–const-fid</strong>  是将所有个体的家系号均设为 0 。</p>
<p>注意 VCF 文件作为 plink 的输入文件，<strong>其位点必须严格按照物理位置顺序排序</strong>，不然就会遇到下面的报错。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Error: .bim file has a split chromosome.  Use --make-bed by itself to</span><br><span class="line">remedy this.</span><br></pre></td></tr></table></figure>
<p>你需要先用 <strong>–make-bed</strong> 生成标准的二进制文件（排序好的），再进行其他处理。</p>
<h2 id="输出">输出</h2>
<h3 id="compound格式-2">compound格式</h3>
<p>使用 <strong>–recode compound-genotypes</strong> 选项，生成 compound格式的plink文件（一个SNP的两个碱基之间没有空格）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plink --allow-extra-chr --chr-set 95 --file plink59 --recode compound-genotypes --out plink59_compound</span><br></pre></td></tr></table></figure>
<h3 id="012格式">012格式</h3>
<p>使用 <code>--recodeA</code> 选项可以输出 012 格式的基因型文件，默认是按照 A1 (最小等位基因) 进行计数。</p>
<p>可以通过添加 <code>--recode-allele</code> 选项指定每一个 SNP 是计数哪一个碱基，其后面接着输入文件名称，这个输入文件含有两列，第一列是 SNP 名称，第二列是需要计数的碱基。</p>
<p>举例如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plink --allow-extra-chr --chr-set 95 --file 1 --recode-allele count_allele.txt --recodeA --out 1_count</span><br></pre></td></tr></table></figure>
<p>其中的 count_allele.txt 文件内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1_242598	C</span><br><span class="line">1_10673082	T</span><br><span class="line">1_10723065	T</span><br><span class="line">1_11407894	A</span><br><span class="line">1_11426075	C</span><br></pre></td></tr></table></figure>
<h3 id="VCF-文件-2">VCF 文件</h3>
<p>使用 <strong>–recode vcf-iid</strong> 输出为 VCF 文件。</p>
<p>这里 vcf-iid 含义是只使用个体号作为 VCF 文件中的样本号，如果仅仅是 --recode vcf，那么生成的VCF文件的样本号是家系号和个体号合并的结果（以_连接） 。</p>
<p>需要注意的是，plink 默认会将等位基因频率高的碱基 (A2) 设置为 ref ，将等位基因频率低的碱基 (A1) 设置为 alt 。如果你需要指定每个位点 的 ref 和 alt ，比如你可以设置与某一个 VCF 中的 ref 和 alt 保持一致，你可以添加一下选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--a2-allele ref.vcf 4 3 &#x27;#&#x27;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<p><code>--a2-allele ref.vcf 4 3 '#'</code> :</p>
<p>​	<code>--a2-allele</code> 命令表示 指定A2基因（Major）</p>
<p>​	<code>ref.vcf</code>  是参考群体的vcf文件（必须是未压缩文件）</p>
<p>​	<code>4</code> 是参考群体A2基因所在列</p>
<p>​	<code>3</code> 是SNP名称列</p>
<p>​	<code>#</code> 是需要跳过的行</p>
<p>需要注意的地方如下</p>
<ol>
<li><strong>ref.vcf 和 plink 文件中的染色体，snp名称，物理位置，两个碱基必须一致</strong></li>
<li>需要转换的 plink 文件中的位点必须均在 ref.vcf 中。</li>
</ol>
<h3 id="位点顺序">位点顺序</h3>
<p>经过 plink 处理之后，<strong>位点会按照物理位置排序</strong>。</p>
<h3 id="样本顺序">样本顺序</h3>
<h4 id="按照特定样本顺序排序">按照特定样本顺序排序</h4>
<p><strong>除了merge操作外，plink 不会改变样本顺序，会保持原顺序</strong>。</p>
<p>如果想要改变样本顺序，那么可以使用 <strong>–indiv-sort &lt;mode name&gt; [filename]</strong> 选项，这个选项有 4 种模式，说明如下：</p>
<ul>
<li>
<p>'‘<strong>none</strong>’/‘<strong>0</strong>’: 保持原顺序。这是 PLINK 1.9 中 <strong>除merge</strong> 外的所有操作的默认值。</p>
</li>
<li>
<p>‘<strong>natural</strong>’/‘<strong>n</strong>’:  按照家系号和个体号排序，这是<strong>PLINK 1.9 在merge操作中的默认值</strong>。举例如下</p>
<blockquote>
<p>‘id2’ &lt; ‘ID3’ &lt; ‘id10’</p>
</blockquote>
</li>
<li>
<p>‘<strong>ascii</strong>’/‘<strong>a</strong>’:  同样按照家系号和个体号排序，不过是按照 ASCII 码。举例如下</p>
<blockquote>
<p>‘ID3’ &lt; ‘id10’ &lt; ‘id2’</p>
</blockquote>
</li>
<li>
<p>‘<strong>file</strong>’/‘<strong>f</strong>’:  采用另一个文件中的顺序。这个文件前两列是家系号-个体号，<strong>空格或tab</strong>分隔。</p>
</li>
</ul>
<p>如果想要使用 file 模式来改变样本顺序，先生成二进制文件，再生成正常的plink格式，分两步走。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">plink --allow-extra-chr --chr-set 95 --chr 1-18 --file raw --indiv-sort file keep_id.txt --make-bed --out sorted</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># --indiv-sort 只能生成二进制文件，但是顺序果然是一样的。</span></span></span><br><span class="line"></span><br><span class="line">plink --allow-extra-chr --chr-set 95 --bfile sorted --recode --out sorted</span><br></pre></td></tr></table></figure>
<h4 id="merge操作后样本顺序">merge操作后样本顺序</h4>
<p>merge 后得到的 plink 文件，<strong>其默认会按照家系号和个体号排序</strong>，即 <strong>–indiv-sort</strong> 中的 <strong>natural</strong> 模式。</p>
<h1>质控</h1>
<h2 id="样本质控">样本质控</h2>
<p>除了常规的 call rate 之外，还有<strong>杂合子比例</strong>，<strong>性别检查</strong>，<strong>PCA分析剔除离群样本</strong>，<strong>IBS和IBD</strong>。</p>
<h3 id="杂合子比例">杂合子比例</h3>
<p>使用选项 <strong>–het</strong> 。如果杂合子比例过高，可能是样本污染；如果杂合子比例过低，可能是近交造成的。</p>
<p>建议<strong>先根据 LD 质控</strong>（<strong>–indep-pairwise 50 5 0.2</strong>），只使用独立的位点计算样本杂合子比例。</p>
<p>结果文件后缀为 <code>.het</code> ，其内容举例如下，这里 O(HOM) 是样本的纯合子比例，E(HOM) 是期望的纯合子比例，N(NM) 是剔除缺失后的位点总数，根据 plink 官方文档 F 系数计算公式为  <code>(&lt;observed hom. count&gt; - &lt;expected count&gt;) / (&lt;total observations&gt; - &lt;expected count&gt;)</code></p>
<table>
<thead>
<tr>
<th>FID</th>
<th>IID</th>
<th>O(HOM)</th>
<th>E(HOM)</th>
<th>N(NM)</th>
<th>F</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>30340</td>
<td>2.92E+04</td>
<td>45590</td>
<td>0.0693</td>
</tr>
<tr>
<td>0</td>
<td>2</td>
<td>28816</td>
<td>2.92E+04</td>
<td>45588</td>
<td>-0.02362</td>
</tr>
</tbody>
</table>
<p>因此每个样本的杂合子比例计算公式为：<img src="https://math.now.sh?inline=%5Cfrac%7BN%28NM%29-O(HOM)%7D%7BN(NM)%7D" style="display:inline-block;margin: 0;"/>  ，有人建议剔除群体杂合子比例均值的 3 倍标准差之外的样本。</p>
<h3 id="性别检查">性别检查</h3>
<p>使用 <strong>–check-sex</strong> 选项， 使用 X 染色体上的位点检查性别，看 F 值，大于0.8为公，反之为母（一般小于0.2），0.2 到 0.8 之间的个体性别会标记为 “PROBLEM” 。</p>
<p>这个 F 值是根据 X 染色体上的近交系数（纯合子比例）得到的，所以需要事先<strong>剔除 X 染色体上的伪常染色体区域的位点</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">plink --chr-set 95 --allow-extra-chr --file all_sex_maf --check-sex --out all_sex_maf</span><br></pre></td></tr></table></figure>
<h3 id="离群个体">离群个体</h3>
<p>使用 <code>--pca</code> 进行 PCA 分析，根据散点图手动剔除离群个体。</p>
<h3 id="IBS-和-IBD">IBS 和 IBD</h3>
<h4 id="IBS">IBS</h4>
<p>IBS 就是样本间同态相同的比例，实际计算两个样本间相同碱基的比例。</p>
<p>首先我们先看一个位点的情况，下面的 IBS Count 就是两个个体在这个位点中的共同的碱基数目。</p>
<table>
<thead>
<tr>
<th>个体1</th>
<th>个体2</th>
<th>IBS State</th>
</tr>
</thead>
<tbody>
<tr>
<td>AA</td>
<td>AA</td>
<td>2</td>
</tr>
<tr>
<td>AA</td>
<td>Aa</td>
<td>1</td>
</tr>
<tr>
<td>AA</td>
<td>aa</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>扩展到多个位点，IBS 计算公式如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Ctext%7BIBS%7D%20%3D%20%5Cfrac%7B%5Ctext%7B%28Number%20of%20markers%20with%20IBS%20count%202%29%7D%20%2B%200.5%20%5Ctimes%20%5Ctext%7B(Number%20of%20markers%20with%20IBS%20count%201)%7D%7D%7B%5Ctext%7BNumber%20of%20non-missing%20markers%7D%7D%0A" /></p><p>plink 计算 IBS 利用 <strong>–distance ibs</strong> 选项，生成 <code>.mibs</code> 为后缀的结果文件，例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">plink --allow-extra-chr --chr-set 95 --file hapmap1 --distance square ibs flat-missing</span><br></pre></td></tr></table></figure>
<p>其中 <strong>square</strong> 指输出文件为矩阵格式，<strong>flat-missing</strong> 就是对应地从分母剔除缺失位点。</p>
<h4 id="IBD">IBD</h4>
<p>IBS 就是样本间同源相同的比例，其不仅仅是具有相同的等位基因，而且要来自于同一祖先。</p>
<p>通常 IBD 无法观测得到，PLINK 通过隐马尔科夫模型来计算 IBD = 0,1,2 的概率，然后计算 PI_HAT 作为 IBD 估计值，其计算公式类似 IBS ，即 P(IBD=2) + 0.5 P(IBD=1) 。</p>
<p>建议<strong>先根据 LD 质控</strong>（<strong>–indep-pairwise 50 5 0.2</strong>），只使用独立的位点计算样本杂合子比例。</p>
<p>在 plink 中使用 <strong>–genome</strong> 选项来计算 IBD ，还可以通过 <strong>–min &lt;minimum PI_HAT value&gt;</strong> 和 <strong>—max &lt;maximum PI_HAT value&gt;</strong> 来移除 PI_HAT 小于或大于某个值的样本对的行（例如 <strong>–min 0.2</strong>）。</p>
<p>输出结果后缀为 <code>.genome</code> ，其各列内容解释如下，这里主要关注 Z0,Z1,Z2,PI_HAT,DST (这就是 IBS) 。</p>
<p>由于输出文件中包含所有样本两两配对的结果，因此文件会比较大。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">FID1	Family ID for first sample</span><br><span class="line">IID1	Individual ID for first sample</span><br><span class="line">FID2	Family ID for second sample</span><br><span class="line">IID2	Individual ID for second sample</span><br><span class="line">RT	Relationship type inferred from .fam/.ped file</span><br><span class="line">EZ	IBD sharing expected value, based on just .fam/.ped relationship</span><br><span class="line">Z0	P(IBD=0)</span><br><span class="line">Z1	P(IBD=1)</span><br><span class="line">Z2	P(IBD=2)</span><br><span class="line">PI_HAT	Proportion IBD, i.e. P(IBD=2) + 0.5*P(IBD=1)</span><br><span class="line">PHE	Pairwise phenotypic code (1, 0, -1 = AA, AU, and UU pairs, respectively)</span><br><span class="line">DST	IBS distance, i.e. (IBS2 + 0.5*IBS1) / (IBS0 + IBS1 + IBS2)</span><br><span class="line">PPC	IBS binomial test</span><br><span class="line">RATIO	HETHET : IBS0 SNP ratio (expected value 2)</span><br></pre></td></tr></table></figure>
<h4 id="三种亲缘关系的IBD测试">三种亲缘关系的IBD测试</h4>
<p>路径：/mnt/data/zhouziwen/test/isolate/2021/2021-03-25-plink_test/IBD</p>
<p>同时使用杜长大三个品种的数据（总共样本数目为 3150），其系谱均检验均正确，<strong>质控 LD 后剩余 5260 个位点</strong>，使用这些位点计算 IBD，查看亲子、全同胞及半同胞三种亲缘关系的样本间的情况 。</p>
<p>按照理论来说，这三种亲缘关系的 Z0,Z1,Z2 和 PI_HAT的期望为</p>
<table>
<thead>
<tr>
<th></th>
<th>Z0</th>
<th>Z1</th>
<th>Z2</th>
<th>PI_HAT</th>
</tr>
</thead>
<tbody>
<tr>
<td>亲子</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0.5</td>
</tr>
<tr>
<td>全同胞</td>
<td>0.25</td>
<td>0.5</td>
<td>0.25</td>
<td>0.5</td>
</tr>
<tr>
<td>半同胞</td>
<td>0.5</td>
<td>0.5</td>
<td>0</td>
<td>0.25</td>
</tr>
</tbody>
</table>
<p>下面是亲子的直方图，所有样本 Z0 均接近于 0，Z1 较大，但是 Z2 并不等于 0 。</p>
<p><img src="1.png" alt=""></p>
<p><img src="2.png" alt=""></p>
<p><img src="3.png" alt=""></p>
<p><img src="4.png" alt=""></p>
<p><strong>全同胞的结果如下</strong></p>
<p><img src="5.png" alt=""></p>
<p><img src="6.png" alt=""></p>
<p><img src="7.png" alt=""></p>
<p><img src="8.png" alt=""></p>
<p><strong>半同胞的结果如下</strong></p>
<p><img src="9.png" alt=""></p>
<p><img src="10.png" alt=""></p>
<p><img src="11.png" alt=""></p>
<p><img src="12.png" alt=""></p>
<h4 id="测试结论">测试结论</h4>
<ol>
<li>
<p>三种关系中 ，<strong>Z2 值均偏大</strong>，远高于期望值，因此这里的 IBD 算法不够精确。</p>
</li>
<li>
<p>三种关系中 ，<strong>PI_HAT 值均偏大</strong>，远高于期望值，估计是收到了 Z2 值偏大的影响。</p>
</li>
<li>
<p>这里最好区分的是<strong>亲子关系</strong>，其 Z0 值接近于 0，Z1 值均大于 0.6 。但是这里半同胞和全同胞的 PI_HAT 的分布有交叉，无法完全分开。</p>
</li>
<li>
<p>总体来说，IBD 的计算结果只能说勉强符合要求，应该只能用于筛选样本，比如挑选或剔除亲缘关系比较近的样本对。</p>
</li>
<li>
<p><strong>计算 IBD 前必须根据 LD 质控位点</strong>，不然得到的结果更加糟糕。</p>
</li>
</ol>
<h2 id="位点质控">位点质控</h2>
<h3 id="杂合子比例-2">杂合子比例</h3>
<p>位点杂合子比例可以通过 <code>--hardy</code> 进行计算，输出文件后缀维 <code>.hwe</code> ，内容举例如下。</p>
<p>其中 <strong>O(HET)</strong> 便是位点的观察杂合度，GENO 的三个数值对应着 A1A1,A1A2,A2A2 三种基因型的数目。</p>
<table>
<thead>
<tr>
<th>CHR</th>
<th>SNP</th>
<th>TEST</th>
<th>A1</th>
<th>A2</th>
<th>GENO</th>
<th>O(HET)</th>
<th>E(HET)</th>
<th>P</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>snp1</td>
<td>ALL(NP)</td>
<td>T</td>
<td>C</td>
<td>4337/533/26259</td>
<td>0.01712</td>
<td>0.252</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>snp2</td>
<td>ALL(NP)</td>
<td>G</td>
<td>T</td>
<td>8035/1174/22550</td>
<td>0.03697</td>
<td>0.3956</td>
<td>0</td>
</tr>
</tbody>
</table>
<h3 id="剔除多等位基因位点">剔除多等位基因位点</h3>
<p>使用 <strong>–snps-only just-acgt</strong> 选项会剔除非 SNP 位点（例如 indel 位点），对于存在三等位基因的 SNP ，会将存在三等位基因的基因型替换为0。</p>
<p>举个例子，输入文件，第一个SNP是<strong>一等位基因</strong>，第二个SNP是<strong>三等位基因</strong>，第三个SNP是<strong>INDEL</strong> 位点。</p>
<blockquote>
<p>1 1 0 0 0 0 A A A C I D<br>
2 2 0 0 0 0 A A A T D D<br>
3 3 0 0 0 0 A A T T D D<br>
4 4 0 0 0 0 A A A T D D</p>
</blockquote>
<p>输出文件，保留了第一个SNP（<strong>即会保留无变异的位点</strong>），第二个SNP将存在三等位基因的基因型替换为0，直接剔除了第三个SNP。</p>
<blockquote>
<p>1 1 0 0 0 -9 A A 0 0<br>
2 2 0 0 0 -9 A A A T<br>
3 3 0 0 0 -9 A A T T<br>
4 4 0 0 0 -9 A A A T</p>
</blockquote>
<p>注意：<strong>–make-bed</strong> 默认就会执行 <strong>–snps-only</strong>，因此如果生成二进制文件过程中出现多等位基因的 SNP ，不会报错，只会给出下面的提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Warning: Variant 1 triallelic; setting rarest alleles missing.</span><br></pre></td></tr></table></figure>
<h3 id="LD-过滤">LD 过滤</h3>
<p>使用 <strong>–indep-pairwise &lt;window size&gt;[‘kb’] &lt;step size (variant ct)&gt; &lt;r^2 threshold&gt;</strong> 选项来过滤位点，常用参数组合为 <strong>50 5 0.5</strong> 或 <strong>50 5 0.2</strong> ，一般不动前面两个参数，修改第三个的值。</p>
<p>这三个参数说明如下：</p>
<ul>
<li>窗口大小，单位 Kb</li>
<li>步长，单位位点数目，表示每次计算后移动窗口的位点数目</li>
<li>r2 阈值</li>
</ul>
<h1>其它</h1>
<h2 id="flip-翻转位点">flip-翻转位点</h2>
<p>合并失败，首先检查是不是存在正反链问题（查看bim文件），如果是正反链问题，用 flip 命令进行部分位点的翻转。如果不是，估计就是基因型文件分型出问题了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- flip &lt;SNP ID list&gt;</span><br></pre></td></tr></table></figure>
<p>Given a file containing a list of SNPs with A/C/G/T alleles, <strong>–flip</strong> swaps A↔T and C↔G. A warning will be given if any alleles are not named A, C, G, or T.</p>
<h2 id="merge-注意事项">merge 注意事项</h2>
<p>使用 <strong>–merge</strong> 合并时有以下注意事项：</p>
<ol>
<li>
<p>合并后的基因型文件位点是所有被合并的基因型文件位点的<strong>并集</strong>，不存在的位点基因型会设为缺失。</p>
</li>
<li>
<p><strong>如果多个被合并文件中存在共同样本（最好事先避免这一点）</strong>，在第一个文件中已经存在的标记数据，默认情况下不会被第二个文件覆盖。例如第一个文件某个体某snp为AA，第二个文件该个体该SNP为AG，最终合并文件中还是AA。覆盖情况可以通过–merge-mode调整。</p>
</li>
<li>
<p><strong>不同map相同snp的名称必须保持一致</strong>，不然会被 plink 软件视为不同的位点。</p>
</li>
<li>
<p>两个芯片文件的snp编码方式要保持一致，比如不能一个ACGT，一个1234。</p>
</li>
</ol>
<h2 id="计算位点间的-r2">计算位点间的 r2</h2>
<h3 id="r2-和-D’-定义">r2 和 D’ 定义</h3>
<p>首先我们先看一下理论，首先我们假设有两个位点，其等位基因分别为 Aa, Bb</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>等位基因</td>
<td>A</td>
<td>a</td>
<td>B</td>
<td>b</td>
</tr>
<tr>
<td>等位基因频率</td>
<td><img src="https://math.now.sh?inline=p_%7BA%7D" style="display:inline-block;margin: 0;"/></td>
<td><img src="https://math.now.sh?inline=q_%7BA%7D" style="display:inline-block;margin: 0;"/></td>
<td><img src="https://math.now.sh?inline=p_%7BB%7D" style="display:inline-block;margin: 0;"/></td>
<td><img src="https://math.now.sh?inline=q_%7BB%7D" style="display:inline-block;margin: 0;"/></td>
</tr>
<tr>
<td>配子类型</td>
<td>AB</td>
<td>Ab</td>
<td>aB</td>
<td>ab</td>
</tr>
<tr>
<td>连锁平衡时的理论频率</td>
<td><img src="https://math.now.sh?inline=p_%7BA%7Dp_%7BB%7D" style="display:inline-block;margin: 0;"/></td>
<td><img src="https://math.now.sh?inline=p_%7BA%7Dq_%7BB%7D" style="display:inline-block;margin: 0;"/></td>
<td><img src="https://math.now.sh?inline=q_%7BA%7Dp_%7BB%7D" style="display:inline-block;margin: 0;"/></td>
<td><img src="https://math.now.sh?inline=q_%7BA%7Dq_%7BB%7D" style="display:inline-block;margin: 0;"/></td>
</tr>
<tr>
<td>实际频率</td>
<td>r</td>
<td>s</td>
<td>t</td>
<td>u</td>
</tr>
<tr>
<td>偏离值</td>
<td>+D</td>
<td>-D</td>
<td>-D</td>
<td>+D</td>
</tr>
</tbody>
</table>
<p>首先我们可以先求出所有样本中所有位点的等位基因频率，就是这里的 <em>p<sub>A</sub></em>  <em>q<sub>A</sub></em>  <em>p<sub>B</sub></em>  <em>q<sub>B</sub></em> 。</p>
<p>如果这两个位点之间不存在连锁，那么这两个位点的组合的频率应该正好等于位点等位基因之和，例如 P(AB) = P(A)P(B) （孟德尔的自由组合定律）。</p>
<p>这里我们计算出第一个统计量，D 值 <strong>(连锁不平衡系数，coefficient of linkage disequilibrium）</strong>，其计算公式为（缺证明）</p>
<p style=""><img src="https://math.now.sh?from=D%20%3D%20ru-st%0A" /></p><p>如果连锁平衡，则 <img src="https://math.now.sh?inline=D%20%3D%200" style="display:inline-block;margin: 0;"/> 。</p>
<p>r2 计算公式为</p>
<p style=""><img src="https://math.now.sh?from=r%5E%7B2%7D%20%3D%20%5Cfrac%7BD%5E%7B2%7D%7D%7Bp_%7BA%7Dq_%7BA%7Dp_%7BB%7Dq_%7BB%7D%7D%0A" /></p><p>这里<strong>r 是两个位点之间的相关系数</strong>（缺证明）</p>
<p>D’ 定义如下，这里 <img src="https://math.now.sh?inline=D_%7BMAX%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%7CD%7C" style="display:inline-block;margin: 0;"/> 可以取到的最大值。D’ 取值范围同样为 [0,1]。 当等位基因频率较低时，D’ 有偏，偏高。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AD'%20%26%3D%20%5Cfrac%7B%7CD%7C%7D%7BD_%7BMAX%7D%7D%20%5C%5C%0A%26%5C%5C%0AD_%7BMAX%7D%20%26%3D%20%5Cbegin%7Bcases%7D%5Cmin%20%5Cleft%28p_A%20p_B%2C%20q_A%20q_B%5Cright%29%20%26%20%5Ctext%20%7B%20if%20%7D%20D%3C0%20%5C%5C%20%5Cmin%20%5Cleft(p_A%20q_B%2C%20q_A%20p_B%5Cright)%20%26%20%5Ctext%20%7B%20if%20%7D%20D%3E0%5Cend%7Bcases%7D%0A%0A%5Cend%7Baligned%7D%0A" /></p><h2 id="计算-r2">计算 r2</h2>
<p>使用 <strong>–r2</strong> 计算位点间碱基计数的相关系数的平方看，举例如下，会生成 <code>.ld</code> 为后缀的结果文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">plink --allow-extra-chr --chr-set 95 --file pick --r2</span><br></pre></td></tr></table></figure>
<p>可以设置一下过滤的参数</p>
<ul>
<li>
<p>–ld-window 10  ：表示计算LD的区间（SNP数目，默认为10），表示距离小于这个值的标记对都要进行LD的计算。</p>
</li>
<li>
<p>–ld-window-kb 1000 ：默认为1Mb，表示只对距离在1Mb之内的SNP位点进行分析。</p>
</li>
<li>
<p>–ld-window-r2 0.2 ：这个参数只能和 --r2参数搭配使用，默认值为0.2对输出结果进行过滤，只输出r2大于该参数的r2值</p>
</li>
</ul>
<p>如果按照默认参数，就是<strong>只算两个位点对距离小于1000kb，中间间隔的SNP数目小于9（10-1）的位点对的r2</strong>，<strong>并且只输出 r2 大于 0.2 的结果</strong>。</p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>windows下运行R-python-dmu-blupf90</title>
    <url>/posts/ad8683e2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在windows 的 cmd 中运行 R , Python, dmu, blupf90。</p>
<span id="more"></span>
<h1>运行R脚本</h1>
<ol>
<li>
<p>将R.exe所在路径加到环境变量path下，路径一般为C:\Program Files\R\R-4.0.2\bin</p>
</li>
<li>
<p>调用 cmd ，首先进入到程序和输入文件的文件夹（<strong>cd</strong> 命令），然后</p>
<p>在windows 命令行中敲入以下命令运行程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C:\Program Files\R\R-4.0.2\bin\R.exe&quot; CMD BATCH inbreeding.R</span><br></pre></td></tr></table></figure>
<p>由于 R.exe所在路径已经加到环境变量中，可以省略 R.exe 的路径，即</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R.exe CMD BATCH sth.R</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>举例，截图如下</p>
<p><img src="1.png" alt=""></p>
<h1>运行python脚本</h1>
<ol>
<li>
<p>将 python 的两个路径均加入到环境变量里，我这里是 <code>D:\software\python\</code> 和 <code>D:\software\python\Scripts\</code> ，python 在第一个路径中，ipython 和 pip 在第二个路径中。</p>
<p>注意，需要放在 <code>C:\Users\zhuan\AppData\Local\Microsoft\WindowsApps</code> 的前面，不然会调用这个路径中的 python</p>
</li>
<li>
<p>调用 cmd，首先进入到程序和输入文件的文件夹（<strong>cd</strong> 命令）， 然后正常运行 python 即可，例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python pick.py --id-file need_pedigree.txt --big-file save_id.txt --seek-column 1</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1>运行 DMU</h1>
<h2 id="安装程序">安装程序</h2>
<p>64 位计算机双击 <strong>DMUv6-R5-2-EM64T.msi</strong> 程序进行安装，每次点击下一步即可。</p>
<p>将安装路径加入到环境变量中，例如 C:\Program Files (x86)\QGG-AU\DMUv6\R5.2-EM64T\bin</p>
<h2 id="运行-DUM">运行 DUM</h2>
<p>调用 cmd, 首先进入到输入文件夹的目录中，然后执行下面的命令，唯一的一个参数是参数卡前缀。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run_dmuai.bat sz</span><br></pre></td></tr></table></figure>
<p>运行截图如下</p>
<p><img src="2.png" alt=""></p>
<h1>运行 blupf90</h1>
<h2 id="下载程序">下载程序</h2>
<p>官网：<a href="http://nce.ads.uga.edu/html/projects/programs/Windows/">http://nce.ads.uga.edu/html/projects/programs/Windows/</a></p>
<p>从官网下载程序，这里存放在 blupf90_win64 文件夹中，然后将 <strong>blupf90_win64 文件夹加入到环境变量 path中</strong>。</p>
<p>然后在 cmd 中测试一下，输入 renunf90.exe ，如果弹出下面的文字，说明安装成功。</p>
<p><img src="3.png" alt=""></p>
<p>第一次运行报错 <strong>“由于找不到libiomp5md.dll，无法继续执行代码”</strong>，从网上下载 libiomp5md.dll ，放到  blupf90_win64 文件夹中</p>
<h2 id="运行-blupf90">运行 blupf90</h2>
<p>首先，进入输入文件的文件夹中</p>
<p><img src="4.png" alt=""></p>
<p>然后，首先运行 renumf90.exe （唯一一个参数为参数卡名称） ，对输入文件进行重编码，下面会有一堆提示，输入文件夹中出现 renf90 开头的一堆重编码文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">renumf90.exe par_name</span><br></pre></td></tr></table></figure>
<p><img src="5.png" alt=""></p>
<p>然后运行 blupf90 估计育种值，参数固定为 renf90.par。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blupf90.exe renf90.par</span><br></pre></td></tr></table></figure>
<p><img src="6.png" alt=""></p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>文献阅读-稀疏矩阵求逆</title>
    <url>/posts/b245ffb2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这里主要是涉及 <strong>Takahashi et al (1971)</strong> 的稀疏矩阵求逆算法，但是没有找到最初的文献或书籍。</p>
<span id="more"></span>
<h1>Erisman_1975</h1>
<h2 id="引言">引言</h2>
<p>新算法有两个基本的优势，一是不会计算 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> ，这可以利用矩阵的稀疏性；二是他会在逆矩阵的元素间产生新的依赖关系，从而可以有效计算这些元素的子集。举个例子，对称矩阵逆矩阵的对角元素的计算可能只需要分解矩阵的非零元素在逆矩阵中的值。</p>
<h2 id="算法">算法</h2>
<p>假设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的非奇异矩阵，并且已经分解为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20%3D%20LDU%7D%20%5Cquad%20%281%29" style="display:inline-block;margin: 0;"/> 。</p>
<p>假设  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 矩阵的逆矩阵为 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> ，Takahashi 给出下面两个公式</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BZ%7D%20%26%3D%20%5Cmathbf%7BD%5E%7B-1%7DL%5E%7B-1%7D%20%2B%20%28I-U%29Z%7D%20%5Cquad%20(2)%20%5C%5C%0A%5Cmathbf%7BZ%7D%20%26%3D%20%5Cmathbf%7BU%5E%7B-1%7DD%5E%7B-1%7D%20%2B%20Z(I-L)%7D%20%5Cquad%20(3)%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>证明过程很简单，略过。注意这里 <img src="https://math.now.sh?inline=%5Cmathbf%7B%28I-U%29%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cmathbf%7B%28I-L%29%7D" style="display:inline-block;margin: 0;"/> 是严格上三角和严格下三角矩阵。通过公式 (2) 可以获得 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 的上三角矩阵的元素（因为 <img src="https://math.now.sh?inline=%5Cmathbf%7BD%5E%7B-1%7DL%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> 为下三角矩阵，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 的上三角矩阵元素均在 <img src="https://math.now.sh?inline=%5Cmathbf%7B%28I-U%29Z%7D" style="display:inline-block;margin: 0;"/> 中) 。同理，通过公式 (3) 获得下三角矩阵的元素。因此在计算过程中，我们不需要使用 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> 。因此这两个公式提供了一种使用之前计算的 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 矩阵和  <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 矩阵， <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 矩阵来计算 <img src="https://math.now.sh?inline=z_%7Bij%7D" style="display:inline-block;margin: 0;"/> 的方式。其中我们利用矩阵的稀疏性减少计算量。</p>
<p>对于对称的  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 矩阵，此时我们有  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20%3D%20LDL%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/> ，因此上面的两个公式可以替换为下面这一个公式。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BZ%7D%20%3D%20%5Cmathbf%7BD%5E%7B-1%7DL%5E%7B-1%7D%20%2B%20%28I-L%5E%7BT%7D%29Z%7D%20%5Cquad%20(4)%0A" /></p><p>这里我们同样需要利用 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 矩阵的对称性，即只计算上三角矩阵的元素。</p>
<p>为了形成依赖关系，定义相邻矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 更加方便，其中</p>
<p style=""><img src="https://math.now.sh?from=c_%7Bij%7D%20%3D%20%5Cleft%5C%7B%0A%5Cbegin%7Baligned%7D%0A%261%2C%20%5Cquad%20l_%7Bij%7D%20%5Ctext%7B%20or%20%7D%20u_%7Bij%7D%20%5Cneq%200%5C%5C%0A%260%2C%20%5Cquad%20%5Ctext%7Botherwise.%7D%0A%5Cend%7Baligned%7D%0A%5Cright.%0A" /></p><p>那么 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 具有 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D%20%2B%20%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 的的稀疏特征。注意 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 中的对角线元素均为 1。</p>
<p>根据消元图的性质，对于任意 <img src="https://math.now.sh?inline=k%2Cj%20%3E%20i" style="display:inline-block;margin: 0;"/> ，如果 <img src="https://math.now.sh?inline=c_%7Bki%7D%20%3D%201" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=c_%7Bij%7D%20%3D%201" style="display:inline-block;margin: 0;"/>，那么  <img src="https://math.now.sh?inline=c_%7Bkj%7D%20%3D%201" style="display:inline-block;margin: 0;"/> 。</p>
<p><strong>定理 1</strong>：任何一个满足 <img src="https://math.now.sh?inline=c_%7Bji%7D%20%3D%201" style="display:inline-block;margin: 0;"/> 的 <img src="https://math.now.sh?inline=z_%7Bij%7D" style="display:inline-block;margin: 0;"/> 均可以通过 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 和满足 <img src="https://math.now.sh?inline=c_%7Bqp%7D%20%3D%201%2C%20q%20%5Cgeq%20j%2C%20p%20%5Cgeq%20i" style="display:inline-block;margin: 0;"/> 的 <img src="https://math.now.sh?inline=z_%7Bpq%7D" style="display:inline-block;margin: 0;"/> 的元素进行计算。</p>
<p><strong>证明</strong>：假设 <img src="https://math.now.sh?inline=i%20%3C%20j" style="display:inline-block;margin: 0;"/> ，那么根据公式 (2) ，我们有</p>
<p style=""><img src="https://math.now.sh?from=z_%7Bij%7D%20%3D%20-%20%5Csum_%7Bk%3Di%2B1%7D%5E%7Bn%7D%20u_%7Bik%7D%20z_%7Bkj%7D%0A" /></p><p>如果 <img src="https://math.now.sh?inline=u_%7Bip%7D%20%5Cneq%200" style="display:inline-block;margin: 0;"/> ，那么 我们就需要 <img src="https://math.now.sh?inline=z_%7Bpj%7D" style="display:inline-block;margin: 0;"/> 。但是 <img src="https://math.now.sh?inline=c_%7Bji%7D%20%3D1" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=c_%7Bip%7D%20%3D1" style="display:inline-block;margin: 0;"/> ，根据 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 矩阵的性质，我们有 <img src="https://math.now.sh?inline=c_%7Bjp%7D%20%3D%201" style="display:inline-block;margin: 0;"/> 。因此 <img src="https://math.now.sh?inline=z_%7Bpj%7D" style="display:inline-block;margin: 0;"/> 也满足定理 1 的条件 (也就是说，对于上三角矩阵的元素，其计算首先需要其所在列下方非零元素的 <img src="https://math.now.sh?inline=z_%7Bpj%7D" style="display:inline-block;margin: 0;"/> 值)。对于 <img src="https://math.now.sh?inline=j%20%3C%20i" style="display:inline-block;margin: 0;"/> 也有类似的结果，即此时计算 <img src="https://math.now.sh?inline=z_%7Bij%7D" style="display:inline-block;margin: 0;"/> 我们需要 <img src="https://math.now.sh?inline=l_%7Bqj%7D%20%5Cneq%200" style="display:inline-block;margin: 0;"/> 的 <img src="https://math.now.sh?inline=z_%7Bip%7D" style="display:inline-block;margin: 0;"/>  。对于 <img src="https://math.now.sh?inline=j%20%3D%20i" style="display:inline-block;margin: 0;"/> ，使用公式 (2) ，我们有（<img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 仍为单位下三角矩阵）</p>
<p style=""><img src="https://math.now.sh?from=z_%7Bii%7D%20%3D%201%2Fd_%7Bii%7D%20-%5Csum_%7Bk%3Di%2B1%7D%5E%7Bn%7D%20u_%7Bik%7D%20z_%7Bki%7D%0A" /></p><p>对于每一个非零元素 <img src="https://math.now.sh?inline=u_%7Bik%7D" style="display:inline-block;margin: 0;"/> ，则有 <img src="https://math.now.sh?inline=c_%7Bik%7D%20%3D%201" style="display:inline-block;margin: 0;"/>，并且 <img src="https://math.now.sh?inline=z_%7Bki%7D" style="display:inline-block;margin: 0;"/> 也满足定理中的条件。</p>
<p>但是，计算 <img src="https://math.now.sh?inline=z_%7Bij%7D" style="display:inline-block;margin: 0;"/> 不会用到满足   <img src="https://math.now.sh?inline=c_%7Bqp%7D%20%3D%201%2C%20q%20%5Cgeq%20j%2C%20p%20%5Cgeq%20i" style="display:inline-block;margin: 0;"/> 的 <img src="https://math.now.sh?inline=z_%7Bpq%7D" style="display:inline-block;margin: 0;"/> 的全部元素，只会用到一部分元素。</p>
<p><strong>推论</strong>：<img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 矩阵中相应于在 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D%5E%7BT%7D" style="display:inline-block;margin: 0;"/> 的非零位置元素的子集可以直接通过 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 及 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 中这个子集中的其它元素计算得到。</p>
<p>证明：在定理1中设 <img src="https://math.now.sh?inline=i%3Dj%3D1" style="display:inline-block;margin: 0;"/> ，得证。</p>
<p>为了计算 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 矩阵中相应于在 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D%5E%7BT%7D" style="display:inline-block;margin: 0;"/> 的非零位置元素的任何子集，上面的定理均提供一种计算方法。为了计算 <img src="https://math.now.sh?inline=z_%7Bij%7D" style="display:inline-block;margin: 0;"/> ，需要从 <img src="https://math.now.sh?inline=%28n%2Cn%29" style="display:inline-block;margin: 0;"/> 位置开始，一直向上计算得到 <img src="https://math.now.sh?inline=z_%7Bij%7D" style="display:inline-block;margin: 0;"/> 。需要注意的是，这个定理提供了获得 <img src="https://math.now.sh?inline=z_%7Bij%7D" style="display:inline-block;margin: 0;"/> 必须事先得到的一个充足的集合，但是我们可能不会需要计算其中的全部元素。举个例子，如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 具有以下的格式</p>
<p style=""><img src="https://math.now.sh?from=A%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Blllll%7D%0A%5Cmathrm%7Bx%7D%20%26%200%20%26%200%20%26%200%20%26%20%5Cmathrm%7Bx%7D%20%5C%5C%0A0%20%26%20%5Cmathrm%7Bx%7D%20%26%20%5Cmathrm%7Bx%7D%20%26%20%5Cmathrm%7Bx%7D%20%26%200%20%5C%5C%0A0%20%26%20%5Cmathrm%7Bx%7D%20%26%20%5Cmathrm%7Bx%7D%20%26%20%5Cmathrm%7Bx%7D%20%26%200%20%5C%5C%0A0%20%26%200%20%26%200%20%26%20%5Cmathrm%7Bx%7D%20%26%20%5Cmathrm%7Bx%7D%20%5C%5C%0A%5Cmathrm%7Bx%7D%20%26%200%20%26%20%5Cmathrm%7Bx%7D%20%26%20%5Cmathrm%7Bx%7D%20%26%20%5Cmathrm%7Bx%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>这里可以证明 <img src="https://math.now.sh?inline=z_%7B11%7D" style="display:inline-block;margin: 0;"/> 的计算只需要 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> , <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=z_%7B51%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=z_%7B55%7D" style="display:inline-block;margin: 0;"/> (不知道怎么证明的)。</p>
<p>为了计算 <img src="https://math.now.sh?inline=c_%7Bji%7D%20%3D%200" style="display:inline-block;margin: 0;"/> 的 <img src="https://math.now.sh?inline=z_%7Bij%7D" style="display:inline-block;margin: 0;"/> ，经过修改 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 矩阵之后可以再应用这个定理。此时我们需要设置 <img src="https://math.now.sh?inline=c_%7Bji%7D%20%3D%201" style="display:inline-block;margin: 0;"/>，并利用对 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 矩阵的假设（对于任意 <img src="https://math.now.sh?inline=k%2Cj%20%3E%20i" style="display:inline-block;margin: 0;"/> ，如果 <img src="https://math.now.sh?inline=c_%7Bki%7D%20%3D%201" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=c_%7Bij%7D%20%3D%201" style="display:inline-block;margin: 0;"/>，那么  <img src="https://math.now.sh?inline=c_%7Bkj%7D%20%3D%201" style="display:inline-block;margin: 0;"/> ），在  <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 矩阵可能需要生成其它非零元素。</p>
<h2 id="计算次数">计算次数</h2>
<p>这里我们比较这个算法和通常的求逆算法的时间复杂度。</p>
<p>设 <img src="https://math.now.sh?inline=%5Cdelta_%7Bi%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 矩阵的第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行的非零元素的数目，<img src="https://math.now.sh?inline=%5Cgamma_%7Bi%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 矩阵第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 列的非零元素数目。那么根据公式 (2) 计算 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 的上三角元素的计算次数为 <img src="https://math.now.sh?inline=%5Csum_%7Bi%3D1%7D%5E%7Bn-1%7D%28n-i%29%20%5Cdelta_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，根据公式 (3) 计算 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 的下三角矩阵的计算次数为  <img src="https://math.now.sh?inline=%5Csum_%7Bi%3D1%7D%5E%7Bn-1%7D%28n-i%29%20%5Cgamma_%7Bi%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>因为 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 矩阵的对角线元素可以通过公式 (2) 或者 公式 (3) 来计算，最有效的方式的计算次数为 <img src="https://math.now.sh?inline=%5Csum_%7Bi%3D1%7D%5E%7Bn-1%7D%20%5Cmin%20%28%20%5Cdelta_%7Bi%7D%2C%20%5Cgamma_%7Bi%7D%29" style="display:inline-block;margin: 0;"/> 。</p>
<p>我们采用通常的向前替换求解的方式来计算 <img src="https://math.now.sh?inline=%5Cmathbf%7B%28LD%29%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> （每次右手项均只有一个非零元素，得到的解是  <img src="https://math.now.sh?inline=%5Cmathbf%7B%28LD%29%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> 的一列），假设这一步会生成一个满的下三角矩阵，其计算次数为 <img src="https://math.now.sh?inline=%5Csum_%7Bi%3D1%7D%5E%7Bn-1%7D%20i%20%5Cgamma_%7Bi%7D" style="display:inline-block;margin: 0;"/> （实际计算次数小于这个数）。我们对每一个向量采用一个完全的向后替换求解 ( <img src="https://math.now.sh?inline=%5Cmathbf%7BU%5E%7B-1%7D%20%28LD%29%5E%7B-1%7D%20%3D%20Z%7D" style="display:inline-block;margin: 0;"/>，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BUZ%3D%28LD%29%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> )，其计算次数为  <img src="https://math.now.sh?inline=n%5Csum_%7Bi%3D1%7D%5E%7Bn-1%7D%20%20%5Cdelta_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，因此使用公式 (2) 和 公式 (3) 对于稀疏矩阵节约的计算量是明显的（我没感觉到啊）。</p>
<p>对于密集矩阵而言，<img src="https://math.now.sh?inline=%5Cdelta_%7Bi%7D%20%3D%20%5Cgamma_%7Bi%7D%20%3D%20n-i" style="display:inline-block;margin: 0;"/>，此时两种方式的计算次数均为 <img src="https://math.now.sh?inline=2n%5E%7B3%7D%2F3" style="display:inline-block;margin: 0;"/> 。</p>
<h1>Misztal_1993</h1>
<h2 id="引言-2">引言</h2>
<p>对于动物育种模型，REML 是用于估计方差组分的算法，其中获得 REML 估计值的两个主流方法是 EM 和 DF 方法。EM 方法需要似然函数的一阶导，因此需要稀疏矩阵逆矩阵的相应元素。</p>
<p>DF 方法不需要求逆，但是 DF 具有更差的数值性质，其可能不会找到全局最优解，因为这个算法不能区分斜率较小的区域的点。因此 Press 建议 DF 算法收敛之后需要再次运行。<strong>对于多性状模型，DF REML 算法的表现更为糟糕</strong>。当使用不同的初始值时，DF 算法的某些解可能相差 20% 以上。虽然没有程序证明 EM 算法没有这个问题，但是对于简单的数据 EM 算法比 DF 算法会收敛到一个更加准确的结果。</p>
<p>本文是想证明，如果使用稀疏矩阵求逆，EM 和 DF 算法的计算量是相似的。</p>
<h2 id="数据和方法">数据和方法</h2>
<p>设 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D" style="display:inline-block;margin: 0;"/> 是MME 的系数矩阵，设 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 是其逆矩阵。出于一般化考虑，<img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D" style="display:inline-block;margin: 0;"/> 假设是满秩的。在 EM 算法中，迹具有以下形式</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathrm%7Btr%7D%28%5Cmathbf%7BC%5E%7Baa%7D%7D%5Cmathbf%7BG%5E%7Ba%7D%7D%29%20%26%3D%20%5Csum_%7Bi%2Cj%7D%20c_%7Bij%7D%5E%7Baa%7Dg_%7Bij%7D%5E%7Ba%7D%20%5C%5C%0A%26%3D%20%5Csum_%7Bi%7D%20c_%7Bi%7D%5E%7Baa%7Dg_%7Bi%7D%5E%7Ba%7D%20%2B%202%20%5Csum_%7Bi%2Cj%3Ei%7D%20c_%7Bij%7D%5E%7Baa%7D%20g_%7Bij%7D%5E%7Ba%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%5E%7Ba%7D%7D" style="display:inline-block;margin: 0;"/> 是随机向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D" style="display:inline-block;margin: 0;"/> 的协方差矩阵的逆矩阵，<img src="https://math.now.sh?inline=%5Cmathbf%7BC%5E%7Baa%7D%7D" style="display:inline-block;margin: 0;"/> 定义为 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 中对应这个随机向量的子矩阵。在这个式子中，求和的上限是 q(a) ，即效应 a 的水平数目。为了计算迹，这里我们只需要 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 上/下三角中对应 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%5E%7Ba%7D%7D" style="display:inline-block;margin: 0;"/> 的非零元素位置的元素。因为所有需要的 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 中的元素均在 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D" style="display:inline-block;margin: 0;"/> 矩阵中，因此我们只需要知道所有  <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D" style="display:inline-block;margin: 0;"/> 矩阵中的非零元素位置的逆矩阵元素（上三角或下三角），我们就可以计算这个迹。</p>
<p>对于直接求解方法，<img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D" style="display:inline-block;margin: 0;"/> 首先会重排来减少 fill-ins 的数目，然后这个矩阵会经过 cholesky 分解，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BW%20%3D%20U'DU%7D%0A" /></p><p>DF 方法需要的行列式可以直接通过 <img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D" style="display:inline-block;margin: 0;"/> 矩阵对角线元素的乘积得到。</p>
<p><img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D" style="display:inline-block;margin: 0;"/> 的逆矩阵元素可以通过 Takahashi 公式得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BW%7D%5E%7B-1%7D%20%3D%20%5Cmathbf%7BC%7D%20%3D%20%5Cmathbf%7BD%5E%7B-1%7DU%5E%7B-T%7D%20%2B%20%28I-U%29C%7D%0A" /></p><p>因为矩阵对称，<img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 中的元素可以不需要对 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 进行求逆得到。进一步，相应于<img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 矩阵非零元素位置的 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 矩阵的元素的计算不需要使用  <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 矩阵其它位置的元素。相应于<img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 矩阵非零元素位置的 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 矩阵的元素集合也称为 <strong>“sparse inverse”</strong> ，下面翻译为稀疏逆。根据 Takahashi 公式，稀疏逆元素可以通过下面的公式得到 (右手项涉及 C 矩阵元素均可以从第 i 列得到。)</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ac_%7Bii%7D%20%26%3D%201%2Fd_%7Bii%7D%20-%20%5Csum_%7Bk%3Di%2B1%7D%5E%7Bn%7D%20u_%7Bik%7D%20c_%7Bki%7D%20%5C%5C%0Ac_%7Bij%7D%20%26%3D%20c_%7Bji%7D%3D%20-%20%5Csum_%7Bk%3Dj%2B1%7D%5E%7Bn%7D%20u_%7Bjk%7D%20c_%7Bki%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=i%20%3D%20n%2Cn-1%2C%5Ccdots%2C1" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=j%3Di-1%2Ci-2%2C%5Ccdots%2C1" style="display:inline-block;margin: 0;"/> 。因为在 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 中存在 fill-ins，稀疏逆 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/>  比 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D" style="display:inline-block;margin: 0;"/> 具有更多的非零元素。</p>
<p>为了高效应用该算法，稀疏逆需要存储和获取 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 矩阵的一个维度，<img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 矩阵的两个维度（为啥？）。因此，稀疏逆计算消耗的内存比数值分解高两到三倍，因为数值分解过程只需要存储和获取 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 矩阵的一个维度。稀疏逆相比于数值分解的计算次数的倍数小于等于 3，这取决于 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D" style="display:inline-block;margin: 0;"/> 的稀疏结构。</p>
<p>逆矩阵的某些元素也可以通过<strong>稀疏向量方法</strong>得到，但是 Takahashi 的方法更快，因此这里不考虑其它方法。</p>
<h2 id="举例">举例</h2>
<p>考虑下面的重排后的矩阵</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BW%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bccccc%7D%0A5%20%26%200%20%26%200%20%26%203%20%26%200%20%5C%5C%0A%26%203%20%26%200%20%26%200%20%26%201%20%5C%5C%0A%26%20%26%204%20%26%201%20%26%201%20%5C%5C%0A%5Ctext%20%7B%20symmetric%20%7D%20%26%20%26%20%26%204%20%26%200%20%5C%5C%0A%26%20%26%20%26%20%26%202%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>分解后得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BD%7D%3D%5Coperatorname%7Bdiag%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Blllll%7D%0A5.0%20%26%203.0%20%26%204.0%20%26%201.95%20%26%201.38%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BU%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Brrrrr%7D%0A1.00%20%26%20.00%20%26%20.00%20%26%20.60%20%26%20.00%20%5C%5C%0A.00%20%26%201.00%20%26%20.00%20%26%20.00%20%26%20.33%20%5C%5C%0A.00%20%26%20.00%20%26%201.00%20%26%20.25%20%26%20.25%20%5C%5C%0A.00%20%26%20.00%20%26%20.00%20%26%201.00%20%26%20-.13%20%5C%5C%0A.00%20%26%20.00%20%26%20.00%20%26%20.00%20%26%201.00%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>其行列式为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%7C%5Cmathbf%7BW%7D%7C%3D%26%205.0%20%5Ctimes%203.0%20%5Ctimes%204.0%20%5Ctimes%201.95%20%5C%5C%0A%26%20%5Ctimes%201.38%3D161.5%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>按照上面的算法计算稀疏逆</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26c_%7B55%7D%3D1%20%2F%20%5Cmathrm%7Bd%7D_%7B55%7D%3D.72%20%5Ctext%20%7B%2C%20%7D%20%5C%5C%0A%26%5Cmathrm%7Bc%7D_%7B45%7D%3D-%5Cmathrm%7Bu%7D_%7B45%7D%20%5Cmathrm%7Bc%7D_%7B55%7D%3D.09%20%5Ctext%20%7B%2C%20%7D%20%5C%5C%0A%26%5Cmathrm%7Bc%7D_%7B35%7D%3D-%5Cmathrm%7Bu%7D_%7B35%7D%20%5Cmathrm%7Bc%7D_%7B55%7D-%5Cmathrm%7Bu%7D_%7B34%7D%20%5Cmathrm%7Bc%7D_%7B45%7D%3D-.20%20%5Ctext%20%7B%2C%20%7D%20%5C%5C%0A%26c_%7B25%7D%3D-%5Cmathrm%7Bu%7D_%7B25%7D%20%5Cmathrm%7Bc%7D_%7B55%7D%3D-.24%20%5Ctext%20%7B%2C%20%7D%20%5C%5C%0A%26%5Cmathrm%7Bc%7D_%7B44%7D%3D1%20%2F%20%5Cmathrm%7Bd%7D_%7B44%7D-%5Cmathrm%7Bu%7D_%7B45%7D%20%5Cmathrm%7Bc%7D_%7B54%7D%3D.52%20%5Ctext%20%7B%2C%20%7D%20%5C%5C%0A%26%5Cmathrm%7Bc%7D_%7B34%7D%3D-%5Cmathrm%7Bu%7D_%7B35%7D%20%5Cmathrm%7Bc%7D_%7B54%7D-%5Cmathrm%7Bu%7D_%7B34%7D%20%5Cmathrm%7Bc%7D_%7B44%7D%3D-.15%20%5Ctext%20%7B%2C%20%7D%20%5C%5C%0A%26%5Cmathrm%7Bc%7D_%7B14%7D%3D-%5Cmathrm%7Bu%7D_%7B14%7D%20%5Cmathrm%7Bc%7D_%7B44%7D%3D-.31%20%5Ctext%20%7B%2C%20%7D%20%5C%5C%0A%26%5Cmathrm%7Bc%7D_%7B33%7D%3D1%20%2F%20%5Cmathrm%7Bd%7D_%7B33%7D-%5Cmathrm%7Bu%7D_%7B35%7D%20%5Cmathrm%7Bc%7D_%7B53%7D-%5Cmathrm%7Bu%7D_%7B34%7D%20%5Cmathrm%7Bc%7D_%7B43%7D%3D.34%20%5Ctext%20%7B%2C%20%7D%20%5C%5C%0A%26%5Cmathrm%7Bc%7D_%7B22%7D%3D1%20%2F%20%5Cmathrm%7Bd%7D_%7B22%7D-%5Cmathrm%7Bu%7D_%7B25%7D%20%5Cmathrm%7Bc%7D_%7B52%7D%3D.41%20%5Ctext%20%7B%2C%20%7D%20%5C%5C%0A%26%5Cmathrm%7Bc%7D_%7B11%7D%3D1%20%2F%20%5Cmathrm%7Bd%7D_%7B11%7D-%5Cmathrm%7Bu%7D_%7B14%7D%20%5Cmathrm%7Bc%7D_%7B41%7D%3D.39%20%20%5C%5C%0A%26%0A%5Cend%7Baligned%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BC%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bccccc%7D%0A.39%20%26%20%3C%3E%20%26%20%3C%3E%20%26%20-.31%20%26%20%3C%3E%20%5C%5C%0A%26%20.41%20%26%20%3C%3E%20%26%20%3C%3E%20%26%20-.24%20%5C%5C%0A%26%20%26%20.34%20%26%20-.15%20%26%20-.20%20%5C%5C%0A%5Ctext%20%7B%20symmetric%20%7D%20%26%20%26%20%26%20.52%20%26%20.09%20%5C%5C%0A%26%20%26%20%26%20%26%20.72%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>其中 &lt;&gt; 表示没有计算。</p>
<h2 id="数值测试">数值测试</h2>
<p>使用实际数据比较数值分解和计算稀疏逆使用内存和计算时间的比较。</p>
<h2 id="结果和讨论">结果和讨论</h2>
<p>计算稀疏逆在内存和计算时间上，基本上是数值分解消耗的 2-3 倍</p>
<p>使用稀疏逆方法，EM 和 DF 方法单次迭代的计算消耗是相似地，因此总计算量取决于迭代次数。因此在 EM 和 DF 的选择上，我们可以优先考虑数值性质，而不是计算量。</p>
<h2 id="附录">附录</h2>
<p>稀疏逆和数值分解的计算量。</p>
<p>设 <img src="https://math.now.sh?inline=p_%7Bi%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 矩阵第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行的非零元素数目，将 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D" style="display:inline-block;margin: 0;"/> 矩阵分解为 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D" style="display:inline-block;margin: 0;"/> 的计算次数为 (Duff, 1989)</p>
<p style=""><img src="https://math.now.sh?from=N_%7Bfact%7D%20%3D%20%5Csum_%7Bi%3D1%7D%5E%7Bn-1%7D%28p_%7Bi%7D%5E%7B2%7D%20%2B%20%5Cfrac%7B1%7D%7B2%7D%20p_%7Bi%7D%29)%0A" /></p><p>一旦分解完成之后，根据 Dempster (1977)，计算稀疏逆的计算次数为</p>
<p style=""><img src="https://math.now.sh?from=N_%7Binv%7D%20%3D%202n%20%2B%202%20%5Csum_%7Bi%3D1%7D%5E%7Bn-1%7D%20p_%7Bi%7D%5E%7B2%7D%0A" /></p><p>因此对于较大的 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/>  和 <img src="https://math.now.sh?inline=p_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，分解和求逆的总耗时为 <img src="https://math.now.sh?inline=%28N_%7Bfact%7D%20%2B%20N_%7Binv%7D%29%2FN_%7Bfact%7D%20%5Capprox%203" style="display:inline-block;margin: 0;"/> 。</p>
<h1>不满秩的 W 矩阵</h1>
<p>如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D" style="display:inline-block;margin: 0;"/> 矩阵不满秩，我们考虑其广义逆。</p>
<ol>
<li>
<p>如果矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 分解为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%3DLDU%7D" style="display:inline-block;margin: 0;"/> ，则 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B-%7D%3DU%5E%7B-1%7DD%5E%7B%2B%7DL%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/>  是 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 矩阵的一个自反身广义逆。</p>
<p>这里容易证明满足 MP 逆的前两个方程。</p>
</li>
<li>
<p>如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B-%7D%3DU%5E%7B-1%7DD%5E%7B%2B%7DL%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D" style="display:inline-block;margin: 0;"/> 为正交矩阵，则 <img src="https://math.now.sh?inline=%5Cmathbf%7B%28PAQ%29%5E%7B-%7D%20%3D%20Q%5E%7B-1%7DA%5E%7B-%7DP%5E%7B-1%7D%20%3D%20Q%5E%7BT%7DU%5E%7B-1%7DD%5E%7B%2B%7DL%5E%7B-1%7DP%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BPAQ%7D" style="display:inline-block;margin: 0;"/> 的一个自反身广义逆。</p>
<p>同样，代入 MP 逆的前两个方程即可证明。</p>
</li>
</ol>
<p>这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D" style="display:inline-block;margin: 0;"/> 矩阵不满秩的广义逆矩阵选择为 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%3DU%5E%7B-1%7DD%5E%7B%2B%7DL%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> ，则满足下面的两个公式，证明过程略。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BZ%7D%20%26%3D%20%5Cmathbf%7BD%5E%7B%2B%7DL%5E%7B-1%7D%20%2B%20%28I-U%29Z%7D%20%5C%5C%0A%5Cmathbf%7BZ%7D%20%26%3D%20%5Cmathbf%7BU%5E%7B-1%7DD%5E%7B%2B%7D%20%2B%20Z(I-L)%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，根据这两个公式同样可以得到其广义逆的稀疏逆，只是对角元素计算公式改为</p>
<p style=""><img src="https://math.now.sh?from=c_%7Bii%7D%20%3D%20d_%7Bii%7D%5E%7B%2B%7D%20-%20%5Csum_%7Bk%3Di%2B1%7D%5E%7Bn%7D%20u_%7Bik%7D%20c_%7Bki%7D%0A" /></p><h1>参考文献</h1>
<ol>
<li>
<p>Erisman A M, Tinney W F. On computing certain elements of the inverse of a sparse matrix[J]. Communications of the ACM, 1975, 18(3): 177-179.</p>
</li>
<li>
<p>Misztal I, Perez-Enciso M. Sparse matrix inversion for restricted maximum likelihood estimation of variance components by expectation-maximization[J]. Journal of dairy science, 1993, 76(5): 1479-1483.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>稀疏矩阵</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>稀疏矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>文献阅读-稀疏向量方法</title>
    <url>/posts/306861db/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>介绍稀疏向量方法的文献。</p>
<span id="more"></span>
<h1>引言</h1>
<ol>
<li>稀疏矩阵方法得到广泛应用，但是稀疏向量方法没有得到重视，即我们一般不会考虑向量的稀疏性。</li>
<li>在求解方程组时，稀疏向量方法在两种情况下很实用，1）右手项是稀疏的；2）我们只需要得到解向量的一部分元素。</li>
<li>稀疏向量算法的主要优势是求解速度更快。</li>
</ol>
<h1>稀疏分解</h1>
<p>一般的线性方程组可以表述为 <img src="https://math.now.sh?inline=%5Cmathbf%7BAx%3Db%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 是一个非奇异矩阵，并且可以进一步分解为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%20%3D%20LDU%7D%0A" /></p><p>如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 是对称矩阵，那么 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%3DL'%7D" style="display:inline-block;margin: 0;"/> ；如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 是 incidence symmetric, 那么 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 不是 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 的转置，但是二者的稀疏结构相同。</p>
<p>稀疏向量方法适用于任何一个非奇异的矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> ，但是如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 满足  incidence symmetric，那么可以简化表达式。</p>
<p>求解过程可以分为两步，向前求解和向后求解。<strong>对于稀疏向量算法，向前求解必须按列执行，向后求解必须按行执行（见附录A）</strong>。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cmathbf%7BLDy%3Db%7D%5C%5C%0A%26%5Cmathbf%7BUx%3Dy%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>不同的存储格式可以用于存储 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> ，但是对于稀疏向量算法，我们需要直接获取 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 矩阵中的<strong>每一列</strong>的非对角的非零元素，这一般可以得到满足。</p>
<p>附录 A 的内容直接放在下面</p>
<h2 id="附录-A-求解过程">附录 A - 求解过程</h2>
<p>这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BLDy%3Db%7D" style="display:inline-block;margin: 0;"/> 其实还是可以分为两步，<img src="https://math.now.sh?inline=%5Cmathbf%7BLy'%3Db%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7By%3DD%5E%7B-1%7Dy'%7D" style="display:inline-block;margin: 0;"/> ，第一步就是常规的三角方程组求解，第二步其实就是 <img src="https://math.now.sh?inline=%5Cmathbf%7By'%7D" style="display:inline-block;margin: 0;"/> 的每个元素除以 <img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D" style="display:inline-block;margin: 0;"/> 相应位置的对角线元素。这两步在计算过程中可以合二为一。</p>
<p>以一个 <img src="https://math.now.sh?inline=3%20%5Ctimes%203" style="display:inline-block;margin: 0;"/> 的矩阵方程组为例，假设  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 分解为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20%3D%20LDU%7D" style="display:inline-block;margin: 0;"/>，这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 矩阵按列存储，<img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 矩阵按行存储，因此向前求解过程按照外积方法（求出的解再除以 <img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D" style="display:inline-block;margin: 0;"/> 的对角线元素），向后求解过程按照内积方法，过程如下</p>
<p><img src="7.png" alt="1"></p>
<h1>稀疏向量求解</h1>
<p>右手项 <img src="https://math.now.sh?inline=%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> 很多情况下是稀疏的，但是解向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> 一般不是稀疏的。接下来我们说到的“稀疏向量”要么指的是一个稀疏向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> ，要么就是指我们感兴趣的 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> 向量的子集，可以语境来判断是哪一种情况。</p>
<p>如果右手项 <img src="https://math.now.sh?inline=%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> 是稀疏的，那么向前求解时，我们只需要 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 的一部分列（因为采用外积方式，如果 <img src="https://math.now.sh?inline=y_%7Bi%7D%3D0" style="display:inline-block;margin: 0;"/>，那么就不需要使用 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D_%7B*i%7D" style="display:inline-block;margin: 0;"/> 列），这称为<strong>快速向前求解 (fast forward, FF)</strong>。如果我们只需要向量 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 的一部分元素，那么向后求解时，我们只需要使用 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 的一部分行（行号对应需要向量 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 的这部分元素的序号，这里应该还需要这部分行中的其它非零元素的行），这称为<strong>快速向后求解 (fast back, FB)</strong>。  <strong>稀疏向量的核心原理就是有效确定 FF 和 FB 中  <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 的子集</strong>。</p>
<p>使用 FF 相对于全向前求解 (full forward solution) 的相对优势 R 计算公式如下</p>
<p style=""><img src="https://math.now.sh?from=%5Ctext%7BR%7D%20%3D%20%5Cfrac%7B%5Ctext%7BNumber%20of%20nonzeros%20in%20the%20columns%20used%20in%20FF%7D%7D%7B%5Ctext%7BNumber%20of%20nonzeros%20in%20L%20and%20D%7D%7D%0A" /></p><p>FB 的 R 值类似。</p>
<h1>分解路径</h1>
<p>稀疏向量方法中的向前分解可以采用下面简单的算法得到</p>
<ol>
<li>将 <img src="https://math.now.sh?inline=%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> 的所有元素设为0，然后加入 <img src="https://math.now.sh?inline=%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> 中给定的非零元素（“解压”右手项）。设 k 是第一个非零元素。</li>
<li>对 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 的第 k 列执行向前分解（因为 k 列之前的解均为 0）。</li>
<li>将 k 改为此时  <img src="https://math.now.sh?inline=%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> 中下一个非零元素的位置。</li>
<li>如果 k = N ，程序终止。不然，回到步骤2。</li>
</ol>
<p>这个算法确保在 FF 中只执行必要的非零操作，但是它在第一步和第三步比较浪费时间。FB 也有一个类似的算法。</p>
<p>更加高效的算法需要用到**分解路径 (factorization paths)**的概念，以下也简称路径。稀疏向量的一个分解路径定义为 FF 中使用的  <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 矩阵的列的有序列表，或者 FB 中 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 矩阵的行的列表。分解路径在 FF 中按照向前的顺序执行，在 FB 中按照向后的顺序执行。在 FF 和 FB 中可能使用相同或者不同的路径。</p>
<p>对于一个 singleton （只有一个非零元素的向量），可以使用下面的算法决定其路径。</p>
<ol>
<li>设 k 是路径中的第一个数字</li>
<li>得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 矩阵的第 k 列 (或  <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 矩阵的第 k 行 ) 非对角线上的最小的非零元素，替换 k ，并加入到路径中。</li>
<li>如果 k = N ，退出。不然，回到步骤2 。</li>
</ol>
<p>一个一般的稀疏向量可以视为多个 singletons 的组合，其路径也是这些 singletons 的路径的并集。</p>
<p>路径的性质可以通过下面一个例子来说明。下图1为 20个节点的图，图2是相应的 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵和 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 阵的结构。</p>
<p><img src="1.png" alt="1"></p>
<p><img src="2.png" alt="1"></p>
<p>对于这个图的一个路径表格见下表，其描述所有的 singleton 的路径，任何一个 singleton 均可以直接从这个表格追溯到，首先起始节点为 K ，然后追踪 K 的 NEXT 列，一直到 K=N。举个例子，对于 K=4 的 singleton，其路径为 {4,10,13,18,19,20} 。但是注意这个路径表格在实践中不会生成，因为相应的信息均在 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 或 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 矩阵中。</p>
<p><img src="3.png" alt="1"></p>
<p>路径表格一个图像描述见下图，对于 FF 方向是从低到高，对于 FB 则是从高到低。</p>
<p><img src="4.png" alt="1"></p>
<p>下面是一个对于多个非零元素的稀疏向量查找路径的算法。</p>
<ol>
<li>首先从稀疏向量中第一个非零元素开始，按照上面的方法查找其 singleton 的路径，这个路径通常都会终止于 N 。</li>
<li>确定稀疏向量中下一个不在之前路径中的非零元素，查找其 singleton 路径直到找到某个元素已经出现在之前的路径中了。</li>
<li>将新形成的路径片段合并到之前路径的前端。</li>
<li>如果稀疏向量中所有非零元素均在路径中，退出。不然，回到步骤2。</li>
</ol>
<p>举个例子，假设我们有一个在 2,6,7,12 位置上具有非零元素的稀疏向量。第一步通过节点2找到的路径为 {2,11,12,15,17,18,19,20} 。第二个找到的路径片段为 {6,16} ，第三个为 {7,14}，第四个没有任何路径片段。总的路径为 {7,14,6,16, 2,11,12,15,17,18,19,20} 。<br>
从图像来看，这些路径组成的子图如下</p>
<p><img src="5.png" alt="1"></p>
<p>在 FF 中，一个节点/未知数的求解需要知道子图中所有在其前面的节点的值。但是在交会点之前的分支可以按照任何顺序计算，也就是说 {7,14}, {6,16}, {2,11,12,15} 这三个分支可以按照任意顺序计算，然后再计算 {17,18,19,20} 。FB 类似，不过方向相反。</p>
<p>举个例子，在 FF 过程，对于子图中的某个节点 k ，只有在其前面的节点在计算过程中才会影响右手项 k 位置的值。比如节点 12，那么在求解节点2 和节点 11 时均会修改右手项节点 12 的值，但是求解节点 6 不会影响右手项节点 12 的值（因为在 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 矩阵中 (12,6) 不在第6列中）。</p>
<h1>稀疏向量操作的初始化</h1>
<p>我们需要避免对路径之外的位置进行归零(zeroing)，这里总共分为4种情况。其实这里只有涉及 FF 方法，才涉及到归零的操作（首先将右手项路径中或全部位置设为 0.0，然后再将右手项中的非零元素加进来）。</p>
<p><img src="6.png" alt="1"></p>
<h1>实验结果</h1>
<ol>
<li>对于 singletons ，稀疏向量算法具有优势。</li>
<li>随着随机选择的非零元素的增加，路径长度和计算时间随之增加，虽然增加幅度相对缓慢，但是这也说明当随机选择的非零元素越来越多时，稀疏向量算法的优势就逐渐消除。</li>
</ol>
<h1>结论</h1>
<p>稀疏向量算法的效果取决于向量的稀疏程序，以及向量与系数矩阵的拓扑关系。</p>
<h1>文献</h1>
<ol>
<li>Tinney W F, Brandwajn V, Chan S M. Sparse vector methods[J]. IEEE transactions on power apparatus and systems, 1985 (2): 295-301.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>稀疏矩阵</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>稀疏矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>python包-openpyxl</title>
    <url>/posts/d5f7e646/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>openpyxl 是一个处理 excel 的 python 包，但是相比于 pandas ，除了速度上可能有优势外，个人感觉没有 pandas 更好用。</p>
<span id="more"></span>
<h1>创建工作簿</h1>
<p>这里我们可以直接使用这个包来创建一个 excel 文件，只需要导入 <code>workbook</code> 类</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">In</span> [<span class="number">1</span>]: from openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> [<span class="number">2</span>]: wb = Workbook()</span><br></pre></td></tr></table></figure>
<p>一个工作簿至少有一个工作表 (worksheet)。你可以使用 <code>workbook.active</code> 的属性来得到一个工作表，使用这种方法得到的是第一个工作表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">3</span>]: ws = wb.active</span><br></pre></td></tr></table></figure>
<p>你可以使用  <code>Workbook.create_sheet()</code> 方法来创建新的工作表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">4</span>]: &gt;&gt;&gt; ws1 = wb.create_sheet(<span class="string">&quot;Mysheet&quot;</span>) <span class="comment"># insert at the end (default)</span></span><br><span class="line">   ...: <span class="comment"># or</span></span><br><span class="line">   ...: &gt;&gt;&gt; ws2 = wb.create_sheet(<span class="string">&quot;Mysheet&quot;</span>, <span class="number">0</span>) <span class="comment"># insert at first position</span></span><br><span class="line">   ...: <span class="comment"># or</span></span><br><span class="line">   ...: &gt;&gt;&gt; ws3 = wb.create_sheet(<span class="string">&quot;Mysheet&quot;</span>, -<span class="number">1</span>) <span class="comment"># insert at the penultimate position</span></span><br></pre></td></tr></table></figure>
<p>默认创建的sheet 表的名称为 Sheet, Sheet1, Sheet2, …，你可以通过 <code>Worksheet.title</code> 属性来随时修改名称</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">7</span>]: ws.title = <span class="string">&quot;New Title&quot;</span></span><br></pre></td></tr></table></figure>
<p>一旦你给了工作表一个名称，你就可以通过名称得到这个工作表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">8</span>]: ws3 = wb[<span class="string">&quot;New Title&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>你可以通过 <code>Workbook.sheetnames</code> 属性得到工作簿中所有表格的名称</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">In</span> [<span class="number">9</span>]: <span class="built_in">print</span>(wb.sheetnames)</span><br><span class="line">[<span class="string">&#x27;Mysheet1&#x27;</span>, <span class="string">&#x27;New Title&#x27;</span>, <span class="string">&#x27;Mysheet2&#x27;</span>, <span class="string">&#x27;Mysheet&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>你可以使用 for 循环遍历所有的表格</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">In</span> [<span class="number">10</span>]: &gt;&gt;&gt; for sheet <span class="keyword">in</span> wb:</span><br><span class="line">    ...: ...     <span class="built_in">print</span>(sheet.title)</span><br><span class="line">    ...:</span><br><span class="line">Mysheet1</span><br><span class="line">New Title</span><br><span class="line">Mysheet2</span><br><span class="line">Mysheet</span><br></pre></td></tr></table></figure>
<p>你可以在一个工作簿中复制一个表格，使用 <code>Workbook.copy_worksheet()</code> 方法</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">In</span> [<span class="number">11</span>]: &gt;&gt;&gt; source = wb.active</span><br><span class="line">    ...: &gt;&gt;&gt; <span class="keyword">target</span> = wb.copy_worksheet(source)</span><br></pre></td></tr></table></figure>
<h1>处理数据</h1>
<h2 id="获取一个单元格">获取一个单元格</h2>
<p>一旦得到了一个表格，我们可以直接获取或修改某个单元格的值</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">In</span> [<span class="number">12</span>]: &gt;&gt;&gt; c = ws[<span class="string">&#x27;A4&#x27;</span>]</span><br><span class="line">    ...: &gt;&gt;&gt; ws[<span class="string">&#x27;A4&#x27;</span>] = <span class="number">4</span></span><br><span class="line">    ...:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更普遍地，我们可以使用 <strong>Worksheet.cell()</strong> 通过行号和列号来获取某个单元格， value 参数用于赋值</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d = ws.cell(row=<span class="number">4</span>, column=<span class="number">2</span>, <span class="keyword">value</span>=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>当一个工作表只在内存中创建时，此时它没有任何单元格，因此第一次获取这个单元格就会创建这个单元格。因此类似下面的代码，就可以在内存中创建 100 乘 100 的空的单元格。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: &gt;&gt;&gt; <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>):</span><br><span class="line">    ...: ...        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>):</span><br><span class="line">    ...: ...            ws.cell(row=x, column=y)</span><br><span class="line">    ...:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="获取很多单元格">获取很多单元格</h2>
<p>可以使用下面的切片获得一个区域</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">19</span>]: &gt;&gt;&gt; cell_range = ws[<span class="string">&#x27;A1&#x27;</span>:<span class="string">&#x27;C2&#x27;</span>]</span><br><span class="line">    ...:</span><br></pre></td></tr></table></figure>
<p>行或列的切片如下</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">In</span> [<span class="number">20</span>]: &gt;&gt;&gt; colC = ws[<span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">    ...: &gt;&gt;&gt; col_range = ws[<span class="string">&#x27;C:D&#x27;</span>]</span><br><span class="line">    ...: &gt;&gt;&gt; row10 = ws[<span class="number">10</span>]</span><br><span class="line">    ...: &gt;&gt;&gt; row_range = ws[<span class="number">5</span>:<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<p>你也可以使用 <strong>Worksheet.iter_rows()</strong> 方法</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">In</span> [<span class="number">21</span>]: &gt;&gt;&gt; for row <span class="keyword">in</span> ws.iter_rows(min_row=<span class="number">1</span>, max_col=<span class="number">3</span>, max_row=<span class="number">2</span>):</span><br><span class="line">    ...: ...    for cell <span class="keyword">in</span> row:</span><br><span class="line">    ...: ...        <span class="built_in">print</span>(cell)</span><br><span class="line">    ...:</span><br><span class="line">&lt;Cell <span class="string">&#x27;New Title&#x27;</span>.A1&gt;</span><br><span class="line">&lt;Cell <span class="string">&#x27;New Title&#x27;</span>.B1&gt;</span><br><span class="line">&lt;Cell <span class="string">&#x27;New Title&#x27;</span>.C1&gt;</span><br><span class="line">&lt;Cell <span class="string">&#x27;New Title&#x27;</span>.A2&gt;</span><br><span class="line">&lt;Cell <span class="string">&#x27;New Title&#x27;</span>.B2&gt;</span><br><span class="line">&lt;Cell <span class="string">&#x27;New Title&#x27;</span>.C2&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>类似地， <code>Worksheet.iter_cols()</code> 会返回列，但是这个方法在可读模式中不可用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">22</span>]: &gt;&gt;&gt; <span class="keyword">for</span> col <span class="keyword">in</span> ws.iter_cols(min_row=<span class="number">1</span>, max_col=<span class="number">3</span>, max_row=<span class="number">2</span>):</span><br><span class="line">    ...: ...     <span class="keyword">for</span> cell <span class="keyword">in</span> col:</span><br><span class="line">    ...: ...         <span class="built_in">print</span>(cell)</span><br><span class="line">    ...:</span><br><span class="line">&lt;Cell <span class="string">&#x27;New Title&#x27;</span>.A1&gt;</span><br><span class="line">&lt;Cell <span class="string">&#x27;New Title&#x27;</span>.A2&gt;</span><br><span class="line">&lt;Cell <span class="string">&#x27;New Title&#x27;</span>.B1&gt;</span><br><span class="line">&lt;Cell <span class="string">&#x27;New Title&#x27;</span>.B2&gt;</span><br><span class="line">&lt;Cell <span class="string">&#x27;New Title&#x27;</span>.C1&gt;</span><br><span class="line">&lt;Cell <span class="string">&#x27;New Title&#x27;</span>.C2&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你需要迭代一个表格的所有行，你可以</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">23</span>]: &gt;&gt;&gt; ws = wb.active</span><br><span class="line">    ...: &gt;&gt;&gt; ws[<span class="string">&#x27;C9&#x27;</span>] = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">    ...: &gt;&gt;&gt; <span class="built_in">tuple</span>(ws.rows)</span><br><span class="line">Out[<span class="number">23</span>]:</span><br><span class="line">((&lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.A1&gt;, &lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.B1&gt;, &lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.C1&gt;),</span><br><span class="line"> (&lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.A2&gt;, &lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.B2&gt;, &lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.C2&gt;),</span><br><span class="line"> (&lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.A3&gt;, &lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.B3&gt;, &lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.C3&gt;),</span><br><span class="line"> (&lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.A4&gt;, &lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.B4&gt;, &lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.C4&gt;),</span><br><span class="line"> (&lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.A5&gt;, &lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.B5&gt;, &lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.C5&gt;),</span><br><span class="line"> (&lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.A6&gt;, &lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.B6&gt;, &lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.C6&gt;),</span><br><span class="line"> (&lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.A7&gt;, &lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.B7&gt;, &lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.C7&gt;),</span><br><span class="line"> (&lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.A8&gt;, &lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.B8&gt;, &lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.C8&gt;),</span><br><span class="line"> (&lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.A9&gt;, &lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.B9&gt;, &lt;Cell <span class="string">&#x27;Mysheet1&#x27;</span>.C9&gt;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>或  <code>Worksheet.columns</code> 属性。</p>
<h2 id="只获取值">只获取值</h2>
<p>如果你只想要获得一个表格中的值，你可以使用  <code>Worksheet.values</code> 属性。它会迭代一个表格中的所有的行，但是只会返回表格的值 (<strong>这才是目的</strong>)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">24</span>]: <span class="keyword">for</span> row <span class="keyword">in</span> ws.values:</span><br><span class="line">    ...:     <span class="keyword">for</span> value <span class="keyword">in</span> row:</span><br><span class="line">    ...:         <span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure>
<p><code>Worksheet.iter_rows()</code> 和 <code>Worksheet.iter_cols()</code>  也可以通过 <code>values_only</code> 参数来返回单元格的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">25</span>]: &gt;&gt;&gt; <span class="keyword">for</span> row <span class="keyword">in</span> ws.iter_rows(min_row=<span class="number">1</span>, max_col=<span class="number">3</span>, max_row=<span class="number">2</span>, values_only=<span class="literal">True</span>):</span><br><span class="line">    ...: ...   <span class="built_in">print</span>(row)</span><br><span class="line">    ...:</span><br><span class="line">(<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">(<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<h1>追加 (append)</h1>
<p>append是按行向Excel中追加数据，从当前行的下一行开始追加。默认从第1行开始，如果想要从指定的行开始需要通过sheet._current_row =row_num设置。</p>
<p>输入数据类型可以是列表，元组和字典。</p>
<p>列表和元组的作用是一样的，第一个元素对应插入行 A1 列的元素，以此类推。</p>
<p>字典的话，键必须是 1234 或者 “A”,“B”,“C” ，对应列号；值必须是单个元素，对应单元格的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line">wb=Workbook()</span><br><span class="line">ws=wb.create_sheet(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">ws._current_row=<span class="number">20</span></span><br><span class="line"><span class="comment"># 将当前行指定在20行</span></span><br><span class="line">ws.append([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="comment"># 1,2,3,4将会插入到21行，的第A,B,C,D列</span></span><br></pre></td></tr></table></figure>
<h1>数据存储</h1>
<p>一旦你获得了一个单元格，你可以分配一个值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">26</span>]: &gt;&gt;&gt; c.value = <span class="string">&#x27;hello, world&#x27;</span></span><br><span class="line">    ...: &gt;&gt;&gt; <span class="built_in">print</span>(c.value)</span><br><span class="line">    ...: <span class="string">&#x27;hello, world&#x27;</span></span><br><span class="line">    ...:</span><br><span class="line">    ...: &gt;&gt;&gt; d.value = <span class="number">3.14</span></span><br><span class="line">    ...: &gt;&gt;&gt; <span class="built_in">print</span>(d.value)</span><br><span class="line">    ...: <span class="number">3.14</span></span><br></pre></td></tr></table></figure>
<h2 id="保存为文件">保存为文件</h2>
<p>使用  <code>Workbook.save()</code> 方法来保存文件，注意这会<strong>覆盖旧文件</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>wb = Workbook()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wb.save(<span class="string">&#x27;balances.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1>导入文件</h1>
<p>使用  <code>openpyxl.load_workbook()</code> 来打开一个 excel 文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wb2 = load_workbook(<span class="string">&#x27;test.xlsx&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(wb2.sheetnames)</span><br></pre></td></tr></table></figure>
<h1>文献</h1>
<ol>
<li>
<p><a href="https://openpyxl.readthedocs.io/en/stable/tutorial.html">https://openpyxl.readthedocs.io/en/stable/tutorial.html</a></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/539094399">Python 处理数据（Excel）—— openpyxl 之append</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python包-subprosscess及f-string用法</title>
    <url>/posts/b03a55a2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>介绍 subprocess 和 f-string 的常用的用法。</p>
<span id="more"></span>
<h1>subprocess</h1>
<p>subprocess 模块允许你生成新的<strong>子进程</strong>，连接它们的输入，输出，错误管道，并且获取它们的返回码。此模块打算代替一些老旧的模块与功能，比如 os.system() 。</p>
<h2 id="subprocess-run">subprocess.run()</h2>
<p>推荐的调用子进程的方式是在任何它支持的用例中使用 <strong>run() 函数</strong>（python 3.5及以上，官方推荐）。对于更进阶的用例，也可以使用底层的 Popen 接口。</p>
<h3 id="参数">参数</h3>
<p>使用的参数入下，常用参数为 <strong>shell, stdout, stderr, encoding</strong> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subprocess.run(args, *,  stdout=None, stderr=None, shell=False, check=False, timeout=None,encoding=None )</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><em><strong>args：</strong></em> 要执行的shell命令，默认应该是一个字符串序列，如[‘df’, ‘-Th’]或(‘df’, ‘-Th’)。<strong>如果如果传递单个字符串，shell 参数必须为<code>True</code>（推荐使用）</strong></p>
</li>
<li>
<p><em><strong>shell：</strong></em> 如果shell为True，那么指定的命令将通过shell执行。</p>
</li>
<li>
<p><em><strong>stdin, stdout, stderr：</strong></em></p>
<p>进程的标准输入、输出和错误，默认为 None (表示什么也不做，输出直接打印到屏幕上)， 其值可以是<code>subprocess.PIPE</code> (管道)、<code>subprocess.DEVNULL</code>（这个估计类似于 <code>&gt; /dev/null</code> ）、一个已经存在的文件描述符、已经打开的文件对象或者None。</p>
<p><strong>如果设置了参数<code>stderr=subprocess.STDOUT</code>，则错误信息会和stdout一起输出，此时stderr的返回值是None。</strong></p>
</li>
<li>
<p><em><strong>encoding</strong></em>:  如果指定了该参数，则stdin、stdout和stderr可以接收字符串数据，并以该编码方式编码。否则<strong>只接收bytes类型的数据</strong>。</p>
</li>
<li>
<p><em><strong>check：</strong></em> 如果check参数的值是True，且执行命令的进程以非0状态码退出，则会抛出一个CalledProcessError的异常。</p>
</li>
<li>
<p><em><strong>timeout</strong></em>：设置命令超时时间。如果命令执行时间超时，子进程将被杀死，并弹出<code>TimeoutExpired</code>异常。</p>
</li>
</ul>
<h3 id="输出">输出</h3>
<p>输出是一个CompletedProcess类型对象，具有以下属性</p>
<ul>
<li>args 启动进程的参数，通常是个列表或字符串。</li>
<li>returncode 进程结束状态返回码。0表示成功状态。</li>
<li>stdout 获取子进程的stdout。</li>
<li>stderr 获取子进程的错误信息，正常为 None 。</li>
<li>check_returncode() 用于检查返回码。如果返回状态码不为零，弹出<code>CalledProcessError</code>异常。</li>
</ul>
<h3 id="简单例子">简单例子</h3>
<p>首先，查看 <strong>args</strong> 参数 和 <strong>shell</strong> 参数，建议使用第二种方式，更加方便，而且可以<strong>采用 f-string 的方式</strong>加入参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">16</span>]: subprocess.run(<span class="string">&quot;python --version&quot;</span>, shell=<span class="literal">True</span>) <span class="comment"># 推荐</span></span><br><span class="line">Python <span class="number">3.9</span><span class="number">.10</span></span><br><span class="line">Out[<span class="number">16</span>]: CompletedProcess(args=<span class="string">&#x27;python --version&#x27;</span>, returncode=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>查看 <strong>check</strong> 参数，就是如果 check = True ，那么如果有问题就会报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: a = subprocess.run(<span class="string">&quot;exit 1&quot;</span>, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: a.returncode  <span class="comment"># returncode 不为 0</span></span><br><span class="line">Out[<span class="number">18</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: a = subprocess.run(<span class="string">&quot;exit 1&quot;</span>, shell=<span class="literal">True</span>, check=<span class="literal">True</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">CalledProcessError                        Traceback (most recent call last)</span><br><span class="line">Input In [<span class="number">19</span>], <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; <span class="number">1</span> a = subprocess.run(<span class="string">&quot;exit 1&quot;</span>, shell=<span class="literal">True</span>, check=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">File /mnt/data/zhouziwen/lib/miniconda3/lib/python3<span class="number">.9</span>/subprocess.py:<span class="number">528</span>, <span class="keyword">in</span> run(<span class="built_in">input</span>, capture_output, timeout, check, *popenargs, **kwargs)</span><br><span class="line">    <span class="number">526</span>     retcode = process.poll()</span><br><span class="line">    <span class="number">527</span>     <span class="keyword">if</span> check <span class="keyword">and</span> retcode:</span><br><span class="line">--&gt; <span class="number">528</span>         <span class="keyword">raise</span> CalledProcessError(retcode, process.args,</span><br><span class="line">    <span class="number">529</span>                                  output=stdout, stderr=stderr)</span><br><span class="line">    <span class="number">530</span> <span class="keyword">return</span> CompletedProcess(process.args, retcode, stdout, stderr)</span><br><span class="line"></span><br><span class="line">CalledProcessError: Command <span class="string">&#x27;exit 1&#x27;</span> returned non-zero exit status <span class="number">1.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="获取执行结果">获取执行结果</h3>
<h4 id="stdout-subprocess-PIPE">stdout=subprocess.PIPE</h4>
<p>需要将 stdout 设为 subprocess.PIPE， 然后获取输出值的 stdout 属性，<strong>推荐同时使用 encoding 参数</strong>。</p>
<p>不设置  encoding 参数， 需要使用 decode(‘utf-8’) 方法转为字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">22</span>]: a=subprocess.run(<span class="string">&quot;wc -l all.ped&quot;</span>, shell = <span class="literal">True</span>,  stdout = subprocess.PIPE).stdout.decode(<span class="string">&#x27;utf-8&#x27;</span>).split()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: a</span><br><span class="line">Out[<span class="number">23</span>]: <span class="string">&#x27;773&#x27;</span></span><br></pre></td></tr></table></figure>
<p>设置  encoding 参数 ，看上去更加清爽一点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">45</span>]: a = subprocess.run(</span><br><span class="line">    ...:     <span class="string">&quot;wc -l all.ped&quot;</span>, shell=<span class="literal">True</span>, encoding=<span class="string">&quot;utf-8&quot;</span>, stdout=subprocess.PIPE</span><br><span class="line">    ...: ).stdout</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: a</span><br><span class="line">Out[<span class="number">46</span>]: <span class="string">&#x27;773 all.ped\n&#x27;</span></span><br></pre></td></tr></table></figure>
<p>举个输出为多行字符串的例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">47</span>]: a = subprocess.run(</span><br><span class="line">    ...:     <span class="string">&quot;wc -l *.ped&quot;</span>, shell=<span class="literal">True</span>, encoding=<span class="string">&quot;utf-8&quot;</span>, stdout=subprocess.PIPE</span><br><span class="line">    ...: ).stdout</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: a</span><br><span class="line">Out[<span class="number">48</span>]: <span class="string">&#x27;    773 all.ped\n    193 1.ped\n    198 2.ped\n    187 3.ped\n   1351 total\n&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: a.splitlines()</span><br><span class="line">Out[<span class="number">49</span>]:</span><br><span class="line">[<span class="string">&#x27;    773 all.ped&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;    193 1.ped&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;    198 2.ped&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;    187 3.ped&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;   1351 total&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果含有参数，<strong>使用 f-string 语法</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">26</span>]: filename = <span class="string">&quot;all.ped&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: a = (</span><br><span class="line">    ...:     subprocess.run(<span class="string">f&quot;wc -l <span class="subst">&#123;filename&#125;</span>&quot;</span>, shell=<span class="literal">True</span>, stdout=subprocess.PIPE)</span><br><span class="line">    ...:     .stdout.decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    ...:     .split()[<span class="number">0</span>]</span><br><span class="line">    ...: )</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: a</span><br><span class="line">Out[<span class="number">28</span>]: <span class="string">&#x27;773&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="stdout-filename">stdout=filename</h4>
<p>输出为文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">41</span>]: test_file = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: a=subprocess.run(<span class="string">&quot;wc -l *.ped&quot;</span>, shell = <span class="literal">True</span>,  encoding = <span class="string">&quot;utf-8&quot;</span>, stdout = test_file)</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: test_file.close()</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: !cat test.txt</span><br><span class="line">    <span class="number">773</span> <span class="built_in">all</span>.ped</span><br><span class="line">    <span class="number">193</span> <span class="number">1.</span>ped</span><br><span class="line">    <span class="number">198</span> <span class="number">2.</span>ped</span><br><span class="line">    <span class="number">187</span> <span class="number">3.</span>ped</span><br><span class="line">   <span class="number">1351</span> total</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="subprocess-Popen">subprocess.Popen()</h2>
<p>用法基本和 run() 方法类同，但是返回的是一个 Popen 对象，其 stdin、stdout、stderr 是三个文件句柄，可以像文件那样进行读写操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">30</span>]: a = subprocess.Popen(<span class="string">&quot;wc -l *.ped&quot;</span>, shell=<span class="literal">True</span>, stdout=subprocess.PIPE, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: a.stdout.readline()</span><br><span class="line">Out[<span class="number">31</span>]: <span class="string">&#x27;    773 all.ped\n&#x27;</span></span><br></pre></td></tr></table></figure>
<p>也可以写入一个文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">32</span>]: test_file = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: a = subprocess.Popen(<span class="string">&quot;wc -l *.ped&quot;</span>, shell=<span class="literal">True</span>, stdout=test_file, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: test_file.close()</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: !cat test.txt</span><br><span class="line">    <span class="number">773</span> <span class="built_in">all</span>.ped</span><br><span class="line">    <span class="number">193</span> <span class="number">1.</span>ped</span><br><span class="line">    <span class="number">198</span> <span class="number">2.</span>ped</span><br><span class="line">    <span class="number">187</span> <span class="number">3.</span>ped</span><br><span class="line">   <span class="number">1351</span> total</span><br></pre></td></tr></table></figure>
<h1>f-string 技巧</h1>
<p>f-string 是Python3.6新引入的一种字符串格式化方法，上面 subprocess 的介绍中也提到了 f-string ，其使用起来非常简便。其形式就是 <code>f'***'</code> 或 <code>F'***'</code> （单双引号均可），以大括号<code>&#123;&#125;</code>表示被替换的字段（也可以是表达式或待用函数）。</p>
<h2 id="特殊字符">特殊字符</h2>
<h3 id="单双引号混用">单双引号混用</h3>
<p>f-string 如果使用了双引号，则字符串中则不能再出现双引号（出现会报错），如果需要使用，需要用<strong>反斜杠 \</strong>  去除特殊含义，单引号同理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">53</span>]: <span class="string">f&quot;a&quot;</span> b <span class="string">&quot;&quot;</span> <span class="comment"># 报错</span></span><br><span class="line">  Input In [<span class="number">53</span>]</span><br><span class="line">    <span class="string">f&quot;a&quot;</span> b <span class="string">&quot;&quot;</span> <span class="comment"># 报错</span></span><br><span class="line">         ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [<span class="number">54</span>]: <span class="string">f&#x27;a&quot; b &quot;&#x27;</span></span><br><span class="line">Out[<span class="number">54</span>]: <span class="string">&#x27;a&quot; b &quot;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>一种简单的解决方法是，如果字符串中只出现双引号，那么 f-string 就可以使用单引号，这样就不用使用反斜杠，反之同理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">54</span>]: <span class="string">f&#x27;a&quot; b &quot;&#x27;</span></span><br><span class="line">Out[<span class="number">54</span>]: <span class="string">&#x27;a&quot; b &quot;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果字符串中内单双引号混用， f-string 可以使用 <code>f&quot;&quot;&quot;&quot;&quot;&quot;</code> 或 <code>f''''''</code>，这种三引号的格式 (这种格式还可以支持多行的字符串) 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">55</span>]: <span class="string">f&#x27;&#x27;&#x27; I&#x27;am very &quot;good&quot; at sth  &#x27;&#x27;&#x27;</span></span><br><span class="line">Out[<span class="number">55</span>]: <span class="string">&#x27; I\&#x27;am very &quot;good&quot; at sth  &#x27;</span></span><br></pre></td></tr></table></figure>
<p>注意这里我没有考虑 <code>&#123;&#125;</code> 中还有引号的情况，因为被替换的字段包含引号的情况基本不可能发生。</p>
<h3 id="大括号">大括号</h3>
<p>如果 f-string 中需要使用大括号，则需要输入连续两个大括号 <code>&#123;&#123;` 和 `&#125;&#125;</code> 。</p>
<p>举个实际的例子，假如我们需要获取某个文件的第二列，则可以使用以下命令。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">57</span>]: filename = <span class="string">&quot;all.ped&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: a = subprocess.run(<span class="string">f&quot;awk &#x27;&#123;&#123;print $2&#125;&#125;&#x27; <span class="subst">&#123;filename&#125;</span>&quot;</span>, shell=<span class="literal">True</span>, encoding = <span class="string">&quot;utf-8&quot;</span>, stdout=subprocess.PIPE)</span><br></pre></td></tr></table></figure>
<h2 id="自定义格式">自定义格式</h2>
<p>f-string采用 <code>&#123;content:format&#125;</code> 设置字符串格式，其中 <code>content</code> 是替换并填入字符串的内容，可以是变量、表达式或函数等，<code>format</code> 是格式描述符。如果不指定  <code>&#123;:format&#125;</code> 则采用默认格式。</p>
<h3 id="对齐字符串">对齐字符串</h3>
<p>“&lt;” 表示左对齐， “&gt;” 表示右对齐，“^&quot; 表示居中。</p>
<p>举例如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">67</span>]: b = <span class="string">&quot;abcdef&quot;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: <span class="string">f&quot;<span class="subst">&#123;b:&lt;<span class="number">8</span>&#125;</span>&quot;</span></span><br><span class="line">Out[<span class="number">68</span>]: <span class="string">&#x27;abcdef  &#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="宽度和精度">宽度和精度</h3>
<p>这里只介绍最常用的宽度与精度的格式。<strong>一般格式为 <code>width.precision</code>, 整数 width 指定宽度，整数 precision 指定显示精度。</strong></p>
<p>width.precision 用于 f 和 % (浮点数) 时 precision 指定的是小数点后的位数。</p>
<p>width.precision 用于字符串时 precision 含义是只使用字符串中前 precision 位字符。</p>
<h4 id="浮点数">浮点数</h4>
<p>我最常用的就是设置小数点位数，这里 width 设为 0 。</p>
<p>使用 % 来获得百分号的格式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">74</span>]: a = <span class="number">111.111</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">75</span>]: <span class="string">f&quot;<span class="subst">&#123;a:<span class="number">0.2</span>f&#125;</span>&quot;</span> <span class="comment"># 2 位小数</span></span><br><span class="line">Out[<span class="number">75</span>]: <span class="string">&#x27;111.11&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">76</span>]: <span class="string">f&quot;<span class="subst">&#123;a:<span class="number">0.2</span>%&#125;</span>&quot;</span> <span class="comment"># 百分数</span></span><br><span class="line">Out[<span class="number">76</span>]: <span class="string">&#x27;11111.10%&#x27;</span></span><br></pre></td></tr></table></figure>
<p>省略 width 也可以</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">83</span>]: <span class="string">f&quot;<span class="subst">&#123;a:<span class="number">.2</span>f&#125;</span>&quot;</span> <span class="comment"># 2 位小数</span></span><br><span class="line">Out[<span class="number">83</span>]: <span class="string">&#x27;111.11&#x27;</span></span><br></pre></td></tr></table></figure>
<p>但是注意双精度下，只能保留 16 位小数（只能精确到小数点后 15 位，有效位数位 16位 ）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">93</span>]: a = <span class="number">1.12345678901234567890</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: a</span><br><span class="line">Out[<span class="number">94</span>]: <span class="number">1.1234567890123457</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">95</span>]: <span class="string">f&quot;<span class="subst">&#123;a:<span class="number">.18</span>f&#125;</span>&quot;</span></span><br><span class="line">Out[<span class="number">95</span>]: <span class="string">&#x27;1.123456789012345691&#x27;</span></span><br></pre></td></tr></table></figure>
<p>单双精度描述见下</p>
<blockquote>
<p>含义：表明单精度和双精度精确的范围不一样，单精度，也即float，一般在计算机中存储占用4字节，也32位，有效位数为7位；双精度（double）在计算机中存储占用8字节，64位，有效位数为16位。</p>
<p>原因：不管float还是double 在计算机上的存储都遵循IEEE规范，使用二进制科学计数法，都包含三个部分：符号位，指数位和尾数部分。其中float的符号位，指数位，尾数部分分别为1,  8,  23.     双精度分别为1,  11,  52。</p>
<p>精度主要取决于尾数部分的位数，float为23位，除去全部为0的情况以外，最小为2的-23次方，约等于1.19乘以10的-7次方，所以float小数部分只能精确到后面6位，加上小数点前的一位，即有效数字为7位。  类似，double 尾数部分52位，最小为2的-52次方，约为2.22乘以10的-16次方，所以精确到小数点后15位，有效位数为16位。</p>
<p>作者：涛了个帅<br>
链接：<a href="https://www.zhihu.com/question/26022206/answer/81573345">https://www.zhihu.com/question/26022206/answer/81573345</a><br>
来源：知乎<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h4 id="字符串">字符串</h4>
<p>没怎么格式化字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">78</span>]: <span class="string">f&quot;<span class="subst">&#123;a:8s&#125;</span>&quot;</span></span><br><span class="line">Out[<span class="number">78</span>]: <span class="string">&#x27;hell0   &#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">79</span>]: <span class="string">f&quot;<span class="subst">&#123;a:<span class="number">8.3</span>s&#125;</span>&quot;</span> <span class="comment"># 提取前3个字符，总长度为 8</span></span><br><span class="line">Out[<span class="number">79</span>]: <span class="string">&#x27;hel     &#x27;</span></span><br><span class="line">    </span><br><span class="line">In [<span class="number">80</span>]: <span class="string">f&quot;<span class="subst">&#123;a:<span class="number">3.3</span>s&#125;</span>&quot;</span> <span class="comment"># 提取前3个字符，总长度正好为 3</span></span><br><span class="line">Out[<span class="number">80</span>]: <span class="string">&#x27;hel&#x27;</span></span><br></pre></td></tr></table></figure>
<h1>参考文献</h1>
<ol>
<li>
<p><a href="https://www.liujiangblog.com/course/python/55">https://www.liujiangblog.com/course/python/55</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/sunxb10/article/details/81036693">https://blog.csdn.net/sunxb10/article/details/81036693</a></p>
</li>
<li>
<p><a href="https://docs.python.org/3/library/string.html#format-string-syntax">https://docs.python.org/3/library/string.html#format-string-syntax</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python包-multiprocessing</title>
    <url>/posts/a49531b5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我目前只掌握了这个包的一些用法，还有很多不清楚的地方。</p>
<span id="more"></span>
<p>据说python的多线程是假的，不能有效利用多核，一个时间只有一个线程在跑。因此平行计算只能使用多进程的技术。</p>
<p>这里我一般就是使用 pool 创建进程池。</p>
<h1>为什么要用进程池</h1>
<p>如果每个任务使用一个进程，每处理一个任务都会伴随着一个进程的创建、运行、销毁，如果进程的运行时间越短，创建和销毁的时间所占的比重就越大，显然，我们应该尽量避免创建和销毁进程本身的额外开销，提高进程的运行效率。我们可以用进程池来减少进程的创建和开销，提高进程对象的复用。</p>
<h1>apply 和 apply_async</h1>
<ul>
<li>
<p><strong>apply</strong>（<strong>不推荐</strong>）: 阻塞，堵塞的意思是说等待当前子进程执行完毕之后再执行下一个进程。</p>
<p>首先主进程开始运行，碰到子进程，操作系统切换到子进程，等待子进程运行结束后，在切换到另外一个子进程，直到所有子进程运行完毕。然后在切换到主进程，运行剩余的部分。</p>
<p><strong>相当于还是单进程，串行计算，没有使用余地</strong></p>
</li>
<li>
<p><strong>apply_async</strong> : 非阻塞</p>
<p>需要配合使用 <code>pool.close()</code> 和 <code>pool.join()</code> ，这两部分是及时我们要告诉主进程，你等着所有子进程运行完毕后再运行剩余部分。这两个命令的官方文档说明如下</p>
<figure class="highlight f#"><table><tr><td class="code"><pre><span class="line">close()</span><br><span class="line">阻止后续任务提交到进程池，当所有任务执行完成后，工作进程会退出。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">join()</span><br><span class="line">等待工作进程结束。调用 join() 前必须先调用 close() 或者 terminate() 。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>map</strong> 和 <strong>map_async</strong> 大同小异，不过接的参数是列表。</p>
</li>
</ul>
<h1>获取结果</h1>
<p>首先，多进程函数要将结果写到 <code>return</code> 中（<code>return</code> 默认为 <code>None</code>，如果有多个值可以返回一个列表对象）。然后可以写到 一个列表中，提取列表元素时要用 <code>get()</code> ，才能得到值。</p>
<p>注意：</p>
<ol>
<li>
<p>多进程中的子进程不会返回报错信息，只有在主进程用get方法来获取返回值时，子进程中的异常才会正常抛出。</p>
</li>
<li>
<p>由于子进程会拷贝父进程的所有状态，因此对于大文件会占用很多内存。为了避免这一点，可以先把大文件拆分为很多小的子文件，然后用子进程读取每个子文件。</p>
</li>
<li>
<p>杀死父进程时，子进程会变成孤儿进程，这一点我暂时还有解决方法。</p>
</li>
</ol>
<h1>举例</h1>
<p>下面是我常用的多进程的例子，这个例子是打印 1- 20 这 20 个数字，每打印一个数字睡眠 1 秒。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">i</span>):</span><br><span class="line">    <span class="keyword">import</span> time <span class="comment"># 多进程中需要在函数中调用需要的模块</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span>(i)</span><br><span class="line"></span><br><span class="line">result_list = [] <span class="comment"># 后面两步合并结果的临时列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置进程数</span></span><br><span class="line">process_nums =  <span class="number">5</span></span><br><span class="line">pool = multiprocessing.Pool(process_nums)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    result_list.append(pool.apply_async(func=test, args=(i,)))</span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以继续写入结果列表中</span></span><br><span class="line">process_nums =  <span class="number">5</span></span><br><span class="line">pool = multiprocessing.Pool(process_nums)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>,<span class="number">21</span>):</span><br><span class="line">    result_list.append(pool.apply_async(func=test, args=(i,)))</span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result_list:</span><br><span class="line">    <span class="built_in">print</span>(i.get()) <span class="comment"># 获得多进程结果</span></span><br></pre></td></tr></table></figure>
<p>如果不使用多进程，正常串行运算的话，运行时间肯定在 20 秒以上，但是这里使用 5 个进程，运行时间只有 4 秒左右（20/5=4）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: %timeit %run test.py</span><br><span class="line">...</span><br><span class="line"><span class="number">4.06</span> s ± <span class="number">2.94</span> ms per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">1</span> loop each)</span><br></pre></td></tr></table></figure>
<h1>参考文献</h1>
<ol>
<li>
<p><a href="https://blog.csdn.net/hellenlee22/article/details/90643200">https://blog.csdn.net/hellenlee22/article/details/90643200</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/Bryan__/article/details/78786648">https://blog.csdn.net/Bryan__/article/details/78786648</a></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/340657122">https://zhuanlan.zhihu.com/p/340657122</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>LU分解及单位下三角矩阵性质</title>
    <url>/posts/b6e8976b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>证明LU分解及单位下三角矩阵的性质。</p>
<span id="more"></span>
<p>单位下三角矩阵指对角线元素均为 1 的下三角矩阵，一个很好的例子就是 LU 分解得到的 L 矩阵。</p>
<h1>证明LU分解</h1>
<p>我们考虑对一个矩阵进行高斯消元（假设这里不考虑换行），消元的过程就是对原始矩阵左乘很多个初等矩阵。</p>
<p>举个例子，考虑下面的矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/></p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%0A%5Cbegin%7Barray%7D%7Bc%7D%0A2%20%26%201%20%5C%5C%0A8%20%26%207%20%5C%5C%0A%5Cend%7Barray%7D%0A%5Cright%5D%0A" /></p><p>消元的过程等于左乘一个初等矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BE_%7B21%7D%7D" style="display:inline-block;margin: 0;"/></p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%0A%5Cbegin%7Barray%7D%7Bc%7D%0A1%20%26%200%20%5C%5C%0A-4%20%26%201%20%5C%5C%0A%5Cend%7Barray%7D%0A%5Cright%5D%0A%5Cleft%5B%0A%5Cbegin%7Barray%7D%7Bc%7D%0A2%20%26%201%20%5C%5C%0A8%20%26%207%20%5C%5C%0A%5Cend%7Barray%7D%0A%5Cright%5D%0A%3D%20%0A%5Cleft%5B%0A%5Cbegin%7Barray%7D%7Bc%7D%0A2%20%26%201%20%5C%5C%0A0%20%26%203%20%5C%5C%0A%5Cend%7Barray%7D%0A%5Cright%5D%0A" /></p><p>这样就能一次性得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 矩阵了。</p>
<p>但是如果我们要得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20%3D%20LU%7D" style="display:inline-block;margin: 0;"/> , 那么我们就需要  <img src="https://math.now.sh?inline=%5Cmathbf%7BE_%7B21%7D%7D" style="display:inline-block;margin: 0;"/> 求逆放在右手项中，在这个例子中， <img src="https://math.now.sh?inline=%5Cmathbf%7BE_%7B21%7D%7D" style="display:inline-block;margin: 0;"/> 的逆矩阵只需要将 -4 改为 4，即</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%0A%5Cbegin%7Barray%7D%7Bc%7D%0A2%20%26%201%20%5C%5C%0A8%20%26%207%20%5C%5C%0A%5Cend%7Barray%7D%0A%5Cright%5D%20%3D%20%5Cleft%5B%0A%5Cbegin%7Barray%7D%7Bc%7D%0A1%20%26%200%20%5C%5C%0A4%20%26%201%20%5C%5C%0A%5Cend%7Barray%7D%0A%5Cright%5D%0A%5Cleft%5B%0A%5Cbegin%7Barray%7D%7Bc%7D%0A2%20%26%201%20%5C%5C%0A0%20%26%203%20%5C%5C%0A%5Cend%7Barray%7D%0A%5Cright%5D%0A" /></p><p>这是最简单的 <img src="https://math.now.sh?inline=2%20%5Ctimes%202" style="display:inline-block;margin: 0;"/> 的情况。</p>
<p>这里我们可以换一个格式来证明，使用高斯变换矩阵，高斯变换矩阵是只有某一列存在非零元素的单位下三角矩阵，即</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BL%7D_i%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccccccc%7D%0A1%20%26%20%26%20%26%20%5Cldots%20%26%20%26%20%26%20%26%200%20%5C%5C%0A0%20%26%20%5Cddots%20%26%20%26%20%26%20%26%20%26%20%26%20%5C%5C%0A0%20%26%20%5Cddots%20%26%201%20%26%20%26%20%26%20%26%20%26%20%5Cvdots%20%5C%5C%0A0%20%26%20%5Cddots%20%26%200%20%26%201%20%26%20%26%20%26%20%26%20%5Cvdots%20%5C%5C%0A%26%20%26%200%20%26%20l_%7Bi%2B1%2C%20i%7D%20%26%201%20%26%20%26%20%26%20%5Cvdots%20%5C%5C%0A%5Cvdots%20%26%20%26%200%20%26%20l_%7Bi%2B2%2C%20i%7D%20%26%200%20%26%20%5Cddots%20%26%20%26%20%5C%5C%0A%26%20%26%20%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cddots%20%26%201%20%26%20%5C%5C%0A0%20%26%20%5Cldots%20%26%200%20%26%20l_%7Bn%2C%20i%7D%20%26%200%20%26%20%5Cldots%20%26%200%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>其可以写为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BL%7D_%7Bi%7D%20%3D%20%5Cmathbf%7BI%7D%20%2B%20%5Cmathbf%7Bl%7D_%7Bi%7D%20%5Cmathbf%7Be%7D_%7Bi%7D%5E%7BT%7D%0A" /></p><p>其中</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bl%7D_%7Bk%7D%20%3D%20%280%5Ccdots0%2Cl_%7Bi%2B1%2Ci%7D%2C%5Ccdots%2Cl_%7Bn%2Ci%7D%29%5E%7BT%7D%0A" /></p><p>其逆矩阵为 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D_%7Bi%7D%5E%7B-1%7D%20%3D%20%5Cmathbf%7BI%7D%20-%20%5Cmathbf%7Bl%7D_%7Bi%7D%20%5Cmathbf%7Be%7D_%7Bi%7D%5E%7BT%7D" style="display:inline-block;margin: 0;"/>， 因为 <img src="https://math.now.sh?inline=%28%5Cmathbf%7BI%7D%20-%20%5Cmathbf%7Bl%7D_%7Bi%7D%20%5Cmathbf%7Be%7D_%7Bi%7D%5E%7BT%7D%29(%5Cmathbf%7BI%7D%20%2B%20%5Cmathbf%7Bl%7D_%7Bi%7D%20%5Cmathbf%7Be%7D_%7Bi%7D%5E%7BT%7D)%20%3D%20%5Cmathbf%7BI%7D%20-%20%5Cmathbf%7Bl%7D_%7Bi%7D%20%5Cmathbf%7Be%7D_%7Bi%7D%5E%7BT%7D%5Cmathbf%7Bl%7D_%7Bi%7D%20%5Cmathbf%7Be%7D_%7Bi%7D%5E%7BT%7D%20%3D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>所以其逆矩阵仍为高斯变换矩阵，如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BL%7D_i%5E%7B-1%7D%20%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccccccc%7D%0A1%20%26%20%26%20%26%20%5Cldots%20%26%20%26%20%26%20%26%200%20%5C%5C%0A0%20%26%20%5Cddots%20%26%20%26%20%26%20%26%20%26%20%26%20%5C%5C%0A0%20%26%20%5Cddots%20%26%201%20%26%20%26%20%26%20%26%20%26%20%5Cvdots%20%5C%5C%0A0%20%26%20%5Cddots%20%26%200%20%26%201%20%26%20%26%20%26%20%26%20%5Cvdots%20%5C%5C%0A%26%20%26%200%20%26%20-l_%7Bi%2B1%2C%20i%7D%20%26%201%20%26%20%26%20%26%20%5Cvdots%20%5C%5C%0A%5Cvdots%20%26%20%26%200%20%26%20-l_%7Bi%2B2%2C%20i%7D%20%26%200%20%26%20%5Cddots%20%26%20%26%20%5C%5C%0A%26%20%26%20%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cddots%20%26%201%20%26%20%5C%5C%0A0%20%26%20%5Cldots%20%26%200%20%26%20-l_%7Bn%2C%20i%7D%20%26%200%20%26%20%5Cldots%20%26%200%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>这一点很好理解，左乘 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的作用是对 <img src="https://math.now.sh?inline=i%2B1" style="display:inline-block;margin: 0;"/> 到 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 行均加上了第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行的倍数，而左乘 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D_%7Bi%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 的作用是对 <img src="https://math.now.sh?inline=i%2B1" style="display:inline-block;margin: 0;"/> 到 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 行均减去了第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行的相应倍数，因此就还原了原来的矩阵，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D_%7Bi%7D%20%5Cmathbf%7BL%7D_%7Bi%7D%5E%7B-1%7D%20%3D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>对于一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> ，经过了消元之后（假设没有换行），则有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BL%7D_%7Bn-1%7D%5E%7B-1%7D%20%5Ccdots%5Cmathbf%7BL%7D_%7B1%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D%20%3D%20%5Cmathbf%7BU%7D%0A" /></p><p>因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BL%7D%20%26%3D%20%5Cmathbf%7BL%7D_%7B1%7D%5Cmathbf%7BL%7D_%7B2%7D%20%5Ccdots%20%5Cmathbf%7BL%7D_%7Bn-1%7D%20%5C%5C%0A%26%3D%20%28%5Cmathbf%7BI%7D%20%2B%20%5Cmathbf%7Bl%7D_%7B1%7D%20%5Cmathbf%7Be%7D_%7B1%7D%5E%7BT%7D%29%20(%5Cmathbf%7BI%7D%20%2B%20%5Cmathbf%7Bl%7D_%7B2%7D%20%5Cmathbf%7Be%7D_%7B2%7D%5E%7BT%7D)%20%5Ccdots%20(%5Cmathbf%7BI%7D%20%2B%20%5Cmathbf%7Bl%7D_%7Bn-1%7D%20%5Cmathbf%7Be%7D_%7Bn-1%7D%5E%7BT%7D)%20%5C%5C%20%20%0A%5Cend%7Baligned%7D%0A" /></p><p>这里我们可以证明，对于 <img src="https://math.now.sh?inline=i%20%3C%20j" style="display:inline-block;margin: 0;"/> ，存在</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bl%7D_%7Bi%7D%20%5Cmathbf%7Be%7D_%7Bi%7D%5E%7BT%7D%20%5Cmathbf%7Bl%7D_%7Bj%7D%20%5Cmathbf%7Be%7D_%7Bj%7D%5E%7BT%7D%20%3D%20%5Cmathbf%7Bl%7D_%7Bi%7D%20%28%5Cmathbf%7Be%7D_%7Bi%7D%5E%7BT%7D%20%5Cmathbf%7Bl%7D_%7Bj%7D%29%20%5Cmathbf%7Be%7D_%7Bj%7D%5E%7BT%7D%20%3D%200%20%5Ctimes%20%5Cmathbf%7Bl%7D_%7Bi%7D%20%5Cmathbf%7Be%7D_%7Bj%7D%5E%7BT%7D%20%3D%20%5Cmathbf%7B0%7D%0A" /></p><p>因此对于上面的式子，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BL%7D%20%26%3D%20%5Cmathbf%7BL%7D_%7B1%7D%5Cmathbf%7BL%7D_%7B2%7D%20%5Ccdots%20%5Cmathbf%7BL%7D_%7Bn-1%7D%20%5C%5C%0A%26%3D%20%28%5Cmathbf%7BI%7D%20%2B%20%5Cmathbf%7Bl%7D_%7B1%7D%20%5Cmathbf%7Be%7D_%7B1%7D%5E%7BT%7D%29%20(%5Cmathbf%7BI%7D%20%2B%20%5Cmathbf%7Bl%7D_%7B2%7D%20%5Cmathbf%7Be%7D_%7B2%7D%5E%7BT%7D)%20%5Ccdots%20(%5Cmathbf%7BI%7D%20%2B%20%5Cmathbf%7Bl%7D_%7Bn-1%7D%20%5Cmathbf%7Be%7D_%7Bn-1%7D%5E%7BT%7D)%20%5C%5C%20%20%0A%26%3D%20(%5Cmathbf%7BI%7D%20%2B%20%5Cmathbf%7Bl%7D_%7B1%7D%20%5Cmathbf%7Be%7D_%7B1%7D%5E%7BT%7D%20%2B%20%5Cmathbf%7Bl%7D_%7B2%7D%20%5Cmathbf%7Be%7D_%7B2%7D%5E%7BT%7D)%20%5Ccdots%20(%5Cmathbf%7BI%7D%20%2B%20%5Cmathbf%7Bl%7D_%7Bn-1%7D%20%5Cmathbf%7Be%7D_%7Bn-1%7D%5E%7BT%7D)%20%5C%5C%0A%26%3D%20(%5Cmathbf%7BI%7D%20%2B%20%5Cmathbf%7Bl%7D_%7B1%7D%20%5Cmathbf%7Be%7D_%7B1%7D%5E%7BT%7D%20%2B%20%5Cmathbf%7Bl%7D_%7B2%7D%20%5Cmathbf%7Be%7D_%7B2%7D%5E%7BT%7D%2B%20%5Cmathbf%7Bl%7D_%7B3%7D%20%5Cmathbf%7Be%7D_%7B3%7D%5E%7BT%7D)%20%5Ccdots%20(%5Cmathbf%7BI%7D%20%2B%20%5Cmathbf%7Bl%7D_%7Bn-1%7D%20%5Cmathbf%7Be%7D_%7Bn-1%7D%5E%7BT%7D)%20%5C%5C%0A%26%5Ccdots%20%5C%5C%0A%26%3D%20%5Cmathbf%7BI%7D%20%2B%20%5Cmathbf%7Bl%7D_%7B1%7D%20%5Cmathbf%7Be%7D_%7B1%7D%5E%7BT%7D%20%2B%20%5Ccdots%20%2B%20%5Cmathbf%7Bl%7D_%7Bn-1%7D%20%5Cmathbf%7Be%7D_%7Bn-1%7D%5E%7BT%7D%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>即</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BL%7D%3D%5Cmathbf%7BL%7D_1%20%5Cmathbf%7BL%7D_2%20%5Cldots%20%5Cmathbf%7BL%7D_%7Bn-1%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bccccc%7D%0A1%20%26%20%26%20%26%20%26%20%5C%5C%0Al_%7B21%7D%20%26%201%20%26%20%26%20%26%20%5C%5C%0A1_%7B31%7D%20%26%201_%7B32%7D%20%26%20%5Cddots%20%26%20%26%20%5C%5C%0A%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cddots%20%26%201%20%26%20%5C%5C%0Al_%7B%5Cmathrm%7Bn%7D%201%7D%20%26%201_%7B%5Cmathrm%7Bn%7D%202%7D%20%26%20%5Ccdots%20%26%20l_%7B%5Cmathrm%7Bn%7D%2C%20%5Cmathrm%7Bn%7D-1%7D%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>得证。</p>
<h1>单位下三角矩阵的性质</h1>
<ol>
<li>
<p>多个单位下三角矩阵的乘积仍为单位下三角矩阵</p>
<p>证明：先以两个单位下三角矩阵的乘积为例，假设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 是两个 n 维的单位下三角矩阵，根据矩阵乘积性质，<img src="https://math.now.sh?inline=%5Cmathbf%7BAB%7D" style="display:inline-block;margin: 0;"/> 的每一行均是 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 的行的线性组合，<img src="https://math.now.sh?inline=%5Cmathbf%7BAB%7D" style="display:inline-block;margin: 0;"/> 的第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行等于 <img src="https://math.now.sh?inline=a_%7Bi1%7D%20%5Cmathbf%7Bb%7D_%7B1%7D%5E%7BT%7D%20%2B%20a_%7Bi2%7D%20%5Cmathbf%7Bb%7D_%7B2%7D%5E%7BT%7D%20%2B%20%5Ccdots%20%2B%20%20%5Cmathbf%7Bb%7D_%7Bi%7D%5E%7BT%7D" style="display:inline-block;margin: 0;"/> ，易得 <img src="https://math.now.sh?inline=%5Cmathbf%7BAB%7D" style="display:inline-block;margin: 0;"/> 的对角线元素均为 1，因此  <img src="https://math.now.sh?inline=%5Cmathbf%7BAB%7D" style="display:inline-block;margin: 0;"/> 为单位下三角矩阵，这可以推广至多个下三角矩阵的乘积。</p>
</li>
<li>
<p>单位下三角矩阵的逆矩阵仍为单位下三角矩阵</p>
<p>证明：根据上面的推导，对于任意一个单位下三角矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> ，其可以分解为 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D%3D%5Cmathbf%7BL%7D_1%20%5Cmathbf%7BL%7D_2%20%5Cldots%20%5Cmathbf%7BL%7D_%7Bn-1%7D" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D%5E%7B-1%7D%20%3D%20%5Cmathbf%7BL%7D_%7Bn-1%7D%5E%7B-1%7D%20%5Ccdots%5Cmathbf%7BL%7D_%7B1%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> ，由于多个单位下三角矩阵的乘积仍为单位下三角矩阵，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 也是单位下三角矩阵。</p>
</li>
</ol>
<h1>高斯消元的时间复杂度</h1>
<p>假设存在一个 <img src="https://math.now.sh?inline=100%20%5Ctimes%20100" style="display:inline-block;margin: 0;"/> 的矩阵，由于一般的数学计算都是乘法和减法合并在一块，因此这里我们只考虑乘法的次数。</p>
<p>对于第一步，消除第一列的计算次数差不多是 <img src="https://math.now.sh?inline=100%5E%7B2%7D" style="display:inline-block;margin: 0;"/> (准确次数是 <img src="https://math.now.sh?inline=99%20%5Ctimes%20100" style="display:inline-block;margin: 0;"/> ，因为不考虑第一行)，消除第二列的计算次数差不多是 <img src="https://math.now.sh?inline=99%5E%7B2%7D" style="display:inline-block;margin: 0;"/> (准确次数是 <img src="https://math.now.sh?inline=98%20%5Ctimes%2099" style="display:inline-block;margin: 0;"/> ），以此类推。</p>
<p>一般化得到，对于一个维度为 n 的矩阵，高斯消元的计算次数大约为</p>
<p style=""><img src="https://math.now.sh?from=n%5E%7B2%7D%20%2B%20%5Ccdots%20%2B%201%5E%7B2%7D%20%3D%20%5Cfrac%7Bn%5E%7B3%7D%7D%7B3%7D%20%2B%20%20%20%5Cfrac%7Bn%5E%7B2%7D%7D%7B2%7D%20%2B%20%20%20%5Cfrac%7Bn%7D%7B6%7D%20%5Capprox%20%5Cfrac%7Bn%5E%7B3%7D%7D%7B3%7D%0A" /></p><h1>参考文献</h1>
<ol>
<li>MIT-线性代数课程</li>
<li><a href="https://zhuanlan.zhihu.com/p/363948873">矩阵的LU分解</a></li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用blupf90进行GBLUP分析</title>
    <url>/posts/784a5321/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>blupf90 默认只能使用一步法进行基因组选择，本身并不支持 GBLUP ，但是我们可以做一些修改，使之进行 GBLUP 运算。</p>
<span id="more"></span>
<h1>准备数据</h1>
<p>系谱：只有基因型个体，并且基因型个体的亲本均为 0</p>
<p>表型：<strong>必须只包含基因型个体</strong>的表型。</p>
<p>基因型：如同一步法。</p>
<h1>修改参数卡</h1>
<p>blupf90 构建 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵的时候会做一些处理，由于其默认进行的是 ssblup ，因此最好做一些修改。</p>
<p>第一个选项是指构建 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵时原始 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵和 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵的比例修改为 0.99 和 0.01，默认是 0.95 和 0.05。由于此时的 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵就是一个单位矩阵，此时的效果就是对原始 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵的对角线元素均加上一个很小的数 0.01，使得  <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵可逆。</p>
<p>第二个选项时关闭 Tuning 步骤，即不用使得 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B22%7D" style="display:inline-block;margin: 0;"/> 矩阵的取值范围相同。</p>
<p>第三个选项是避免因为  <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵和 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵的相关过低导致程序中止。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPTION AlphaBeta 0.99 0.01</span><br><span class="line">OPTION tunedG 0</span><br><span class="line">OPTION thrStopCorAG -0.9</span><br></pre></td></tr></table></figure>
<h1>运行 BLUPF90</h1>
<p>现在正常运行 BLUPF90 ，得到的结果就是 GBLUP 结果。</p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏矩阵算法最小度数算法八之最小度数算法子程序QMDMRG</title>
    <url>/posts/bb2089ba/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本章节介绍 <em>the minimum degree algorithm</em> ，我个人将其翻译为最小度数算法。这里我们看最小度数算法的子程序QMDMRG。</p>
<span id="more"></span>
<h1>QMDMRG</h1>
<p>这个子程序根据之前提到的原理确定不可区分的节点。设 C1,C2,R1,R2,Y 如同引理 5.4.6。这个子程序假定 C1 和 R1 事先已经给定 (C1 就是当前新找到的需要消元的节点形成的 supernode , R1 是其相邻的未消元的节点)。<strong>注意 R1 中的节点的 MARKER 已经设为 1</strong> 。</p>
<p>输入变量 DEG0 是 R1 中的节点数目。</p>
<p>这里存在很多个 C2，存放在 <strong>(NHDSZE, NBRHD)</strong> ，其中每一个 NBRHD(i) 均为一个已经消元的 supernode 。</p>
<p>循环 <code>DO 1400</code> 对于每一个  C2 使用条件，它首先确定集合 R2 - R1 ，存放在 <strong>(RCHSZE, RCHSET)</strong> 。循环 <code>DO 600</code> 循环确定交集 <img src="https://math.now.sh?inline=R2%20%5Ccap%20R1" style="display:inline-block;margin: 0;"/> ，存放在  <strong>(NOVRLP, OVRLP)</strong> 。对于交集中的每一个节点，通过 <code>DO 1100</code> 循环确定能否满足条件（ <img src="https://math.now.sh?inline=Adj%28y%29%20%5Csubset%20R_%7B1%7D%20%5Ccup%20R_%7B2%7D%20%5Ccup%20C_%7B1%7D%20%5Ccup%20C_%7B2%7D" style="display:inline-block;margin: 0;"/> ），如果满足条件，那么这个节点会包括在一个 supernode 中，并放置在 QLINK 向量中，同时计算这个新的 supernode 的大小，并更新其 DEG 值。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">C****************************************************************          <span class="number">1.</span></span><br><span class="line">C****************************************************************          <span class="number">2.</span></span><br><span class="line">C**********     QMDMRG ..... QUOT <span class="built_in">MIN</span> DEG <span class="built_in">MERGE</span>       ***********          <span class="number">3.</span></span><br><span class="line">C****************************************************************          <span class="number">4.</span></span><br><span class="line">C****************************************************************          <span class="number">5.</span></span><br><span class="line"><span class="comment">C                                                                          6.</span></span><br><span class="line"><span class="comment">C     PURPOSE - THIS ROUTINE MERGES INDISTINGUISHABLE NODES IN             7.</span></span><br><span class="line"><span class="comment">C               THE MINIMUM DEGREE ORDERING ALGORITHM.                     8.</span></span><br><span class="line"><span class="comment">C               IT ALSO COMPUTES THE NEW DEGREES OF THESE                  9.</span></span><br><span class="line"><span class="comment">C               NEW SUPERNODES.                                           10.</span></span><br><span class="line"><span class="comment">C                                                                         11.</span></span><br><span class="line"><span class="comment">C     INPUT PARAMETERS -                                                  12.</span></span><br><span class="line"><span class="comment">C        (XADJ, ADJNCY) - THE ADJACENCY STRUCTURE.                        13.</span></span><br><span class="line"><span class="comment">C        DEG0 - THE NUMBER OF NODES IN THE GIVEN SET.                     14.</span></span><br><span class="line"><span class="comment">C        (NHDSZE, NBRHD) - THE SET OF ELIMINATED SUPERNODES               15.</span></span><br><span class="line"><span class="comment">C               ADJACENT TO SOME NODES IN THE SET.                        16.</span></span><br><span class="line"><span class="comment">C                                                                         17.</span></span><br><span class="line"><span class="comment">C     UPDATED PARAMETERS -                                                18.</span></span><br><span class="line"><span class="comment">C        DEG - THE DEGREE VECTOR.                                         19.</span></span><br><span class="line"><span class="comment">C        QSIZE - SIZE OF INDISTINGUISHABLE NODES.                         20.</span></span><br><span class="line"><span class="comment">C        QLINK - LINKED LIST FOR INDISTINGUISHABLE NODES.                 21.</span></span><br><span class="line"><span class="comment">C        MARKER - THE GIVEN SET IS GIVEN BY THOSE NODES WITH              22.</span></span><br><span class="line"><span class="comment">C               MARKER VALUE SET TO 1.  THOSE NODES WITH DEGREE           23.</span></span><br><span class="line"><span class="comment">C               UPDATED WILL HAVE MARKER VALUE SET TO 2.                  24.</span></span><br><span class="line"><span class="comment">C                                                                         25.</span></span><br><span class="line"><span class="comment">C     WORKING PARAMETERS -                                                26.</span></span><br><span class="line"><span class="comment">C        RCHSET - THE REACHABLE SET.                                      27.</span></span><br><span class="line"><span class="comment">C        OVRLP -  TEMP VECTOR TO STORE THE INTERSECTION OF TWO            28.</span></span><br><span class="line"><span class="comment">C               REACHABLE SETS.                                           29.</span></span><br><span class="line"><span class="comment">C                                                                         30.</span></span><br><span class="line">C****************************************************************         <span class="number">31.</span></span><br><span class="line"><span class="comment">C                                                                         32.</span></span><br><span class="line">      <span class="function"><span class="keyword">SUBROUTINE</span></span>  QMDMRG ( XADJ, ADJNCY, DEG, QSIZE, QLINK,               <span class="number">33.</span></span><br><span class="line">     <span class="number">1</span>                     MARKER, DEG0, NHDSZE, NBRHD, RCHSET,           <span class="number">34.</span></span><br><span class="line">     <span class="number">1</span>                     OVRLP )                                        <span class="number">35.</span></span><br><span class="line"><span class="comment">C                                                                         36.</span></span><br><span class="line">C****************************************************************         <span class="number">37.</span></span><br><span class="line"><span class="comment">C                                                                         38.</span></span><br><span class="line">         <span class="keyword">INTEGER</span>  ADJNCY(<span class="number">1</span>), DEG(<span class="number">1</span>), QSIZE(<span class="number">1</span>), QLINK(<span class="number">1</span>),                  <span class="number">39.</span></span><br><span class="line">     <span class="number">1</span>            MARKER(<span class="number">1</span>), RCHSET(<span class="number">1</span>), NBRHD(<span class="number">1</span>), OVRLP(<span class="number">1</span>)                <span class="number">40.</span></span><br><span class="line">         <span class="keyword">INTEGER</span>  XADJ(<span class="number">1</span>), DEG0, DEG1, HEAD, INHD, IOV, IRCH,             <span class="number">41.</span></span><br><span class="line">     <span class="number">1</span>            J, JSTRT, JSTOP, LINK, LNODE, MARK, MRGSZE,             <span class="number">42.</span></span><br><span class="line">     <span class="number">1</span>            NABOR, NHDSZE, NODE, NOVRLP, RCHSZE, ROOT               <span class="number">43.</span></span><br><span class="line"><span class="comment">C                                                                         44.</span></span><br><span class="line">C****************************************************************         <span class="number">45.</span></span><br><span class="line"><span class="comment">C                                                                         46.</span></span><br><span class="line"><span class="comment">C        ------------------                                               47.</span></span><br><span class="line"><span class="comment">C        INITIALIZATION ...                                               48.</span></span><br><span class="line"><span class="comment">C        ------------------                                               49.</span></span><br><span class="line">         <span class="keyword">IF</span> ( NHDSZE .LE. <span class="number">0</span> )  <span class="keyword">RETURN</span>                                     <span class="number">50.</span></span><br><span class="line">         <span class="keyword">DO</span> <span class="number">100</span> INHD = <span class="number">1</span>, NHDSZE                                          <span class="number">51.</span></span><br><span class="line">            ROOT = NBRHD(INHD)                                            <span class="number">52.</span></span><br><span class="line">            MARKER(ROOT) = <span class="number">0</span>                                              <span class="number">53.</span></span><br><span class="line">  <span class="number">100</span>    <span class="keyword">CONTINUE</span>                                                         <span class="number">54.</span></span><br><span class="line"><span class="comment">C        -------------------------------------------------                55.</span></span><br><span class="line"><span class="comment">C        LOOP THROUGH EACH ELIMINATED SUPERNODE IN THE SET                56.</span></span><br><span class="line"><span class="comment">C        (NHDSZE, NBRHD).                                                 57.</span></span><br><span class="line"><span class="comment">C        -------------------------------------------------                58.</span></span><br><span class="line">         <span class="keyword">DO</span> <span class="number">1400</span> INHD = <span class="number">1</span>, NHDSZE                                         <span class="number">59.</span></span><br><span class="line">            ROOT = NBRHD(INHD)                                            <span class="number">60.</span></span><br><span class="line">            MARKER(ROOT) = - <span class="number">1</span>                                            <span class="number">61.</span></span><br><span class="line">            RCHSZE = <span class="number">0</span>                                                    <span class="number">62.</span></span><br><span class="line">            NOVRLP = <span class="number">0</span>                                                    <span class="number">63.</span></span><br><span class="line">            DEG1   = <span class="number">0</span>                                                    <span class="number">64.</span></span><br><span class="line">  <span class="number">200</span>       JSTRT  = XADJ(ROOT)                                           <span class="number">65.</span></span><br><span class="line">            JSTOP  = XADJ(ROOT+<span class="number">1</span>) - <span class="number">1</span>                                     <span class="number">66.</span></span><br><span class="line"><span class="comment">C           ----------------------------------------------                67.</span></span><br><span class="line"><span class="comment">C           DETERMINE THE REACHABLE SET AND ITS INTERSECT-                68.</span></span><br><span class="line"><span class="comment">C           ION WITH THE INPUT REACHABLE SET.                             69.</span></span><br><span class="line"><span class="comment">C           ----------------------------------------------                70.</span></span><br><span class="line">            <span class="keyword">DO</span> <span class="number">600</span> J = JSTRT, JSTOP                                       <span class="number">71.</span></span><br><span class="line">               NABOR = ADJNCY(J)                                          <span class="number">72.</span></span><br><span class="line">               ROOT  = - NABOR                                            <span class="number">73.</span></span><br><span class="line">               <span class="keyword">IF</span> (NABOR)  <span class="number">200</span>, <span class="number">700</span>, <span class="number">300</span>                                  <span class="number">74.</span></span><br><span class="line"><span class="comment">C                                                                         75.</span></span><br><span class="line">  <span class="number">300</span>          MARK = MARKER(NABOR)                                       <span class="number">76.</span></span><br><span class="line">               <span class="keyword">IF</span> ( MARK ) <span class="number">600</span>, <span class="number">400</span>, <span class="number">500</span>                                  <span class="number">77.</span></span><br><span class="line">  <span class="number">400</span>             RCHSZE = RCHSZE + <span class="number">1</span>                                     <span class="number">78.</span></span><br><span class="line">                  RCHSET(RCHSZE) = NABOR                                  <span class="number">79.</span></span><br><span class="line">                  DEG1 = DEG1 + QSIZE(NABOR)                              <span class="number">80.</span></span><br><span class="line">                  MARKER(NABOR) = <span class="number">1</span>                                       <span class="number">81.</span></span><br><span class="line">                  <span class="keyword">GOTO</span> <span class="number">600</span>                                                <span class="number">82.</span></span><br><span class="line">  <span class="number">500</span>          <span class="keyword">IF</span> ( MARK .GT. <span class="number">1</span> )  <span class="keyword">GOTO</span> <span class="number">600</span>                               <span class="number">83.</span></span><br><span class="line">                  NOVRLP = NOVRLP + <span class="number">1</span>                                     <span class="number">84.</span></span><br><span class="line">                  OVRLP(NOVRLP) = NABOR                                   <span class="number">85.</span></span><br><span class="line">                  MARKER(NABOR) = <span class="number">2</span>                                       <span class="number">86.</span></span><br><span class="line">  <span class="number">600</span>       <span class="keyword">CONTINUE</span>                                                      <span class="number">87.</span></span><br><span class="line"><span class="comment">C           --------------------------------------------                  88.</span></span><br><span class="line"><span class="comment">C           FROM THE OVERLAPPED SET, DETERMINE THE NODES                  89.</span></span><br><span class="line"><span class="comment">C           THAT CAN BE MERGED TOGETHER.                                  90.</span></span><br><span class="line"><span class="comment">C           --------------------------------------------                  91.</span></span><br><span class="line">  <span class="number">700</span>       HEAD = <span class="number">0</span>                                                      <span class="number">92.</span></span><br><span class="line">            MRGSZE = <span class="number">0</span>                                                    <span class="number">93.</span></span><br><span class="line">            <span class="keyword">DO</span> <span class="number">1100</span> IOV = <span class="number">1</span>, NOVRLP                                       <span class="number">94.</span></span><br><span class="line">               NODE = OVRLP(IOV)                                          <span class="number">95.</span></span><br><span class="line">               JSTRT = XADJ(NODE)                                         <span class="number">96.</span></span><br><span class="line">               JSTOP = XADJ(NODE+<span class="number">1</span>) - <span class="number">1</span>                                   <span class="number">97.</span></span><br><span class="line">               <span class="keyword">DO</span> <span class="number">800</span> J = JSTRT, JSTOP                                    <span class="number">98.</span></span><br><span class="line">                  NABOR = ADJNCY(J)                                       <span class="number">99.</span></span><br><span class="line">                  <span class="keyword">IF</span> ( MARKER(NABOR) .NE. <span class="number">0</span> )  <span class="keyword">GOTO</span> <span class="number">800</span>                  <span class="number">100.</span></span><br><span class="line">                     MARKER(NODE) = <span class="number">1</span>                                    <span class="number">101.</span></span><br><span class="line">                     <span class="keyword">GOTO</span> <span class="number">1100</span>                                           <span class="number">102.</span></span><br><span class="line">  <span class="number">800</span>          <span class="keyword">CONTINUE</span>                                                  <span class="number">103.</span></span><br><span class="line"><span class="comment">C              -----------------------------------------                 104.</span></span><br><span class="line"><span class="comment">C              NODE BELONGS TO THE NEW MERGED SUPERNODE.                 105.</span></span><br><span class="line"><span class="comment">C              UPDATE THE VECTORS QLINK AND QSIZE.                       106.</span></span><br><span class="line"><span class="comment">C              -----------------------------------------                 107.</span></span><br><span class="line">               MRGSZE = MRGSZE + QSIZE(NODE)                             <span class="number">108.</span></span><br><span class="line">               MARKER(NODE) = - <span class="number">1</span>                                        <span class="number">109.</span></span><br><span class="line">               LNODE = NODE                                              <span class="number">110.</span></span><br><span class="line">  <span class="number">900</span>          LINK  = QLINK(LNODE)                                      <span class="number">111.</span></span><br><span class="line">               <span class="keyword">IF</span> ( LINK .LE. <span class="number">0</span> )  <span class="keyword">GOTO</span> <span class="number">1000</span>                             <span class="number">112.</span></span><br><span class="line">                  LNODE = LINK                                           <span class="number">113.</span></span><br><span class="line">                  <span class="keyword">GOTO</span> <span class="number">900</span>                                               <span class="number">114.</span></span><br><span class="line"> <span class="number">1000</span>          QLINK(LNODE) = HEAD                                       <span class="number">115.</span></span><br><span class="line">               HEAD = NODE                                               <span class="number">116.</span></span><br><span class="line"> <span class="number">1100</span>       <span class="keyword">CONTINUE</span>                                                     <span class="number">117.</span></span><br><span class="line">            <span class="keyword">IF</span> ( HEAD .LE. <span class="number">0</span> )  <span class="keyword">GOTO</span> <span class="number">1200</span>                                <span class="number">118.</span></span><br><span class="line">               QSIZE(HEAD) = MRGSZE                                      <span class="number">119.</span></span><br><span class="line">               DEG(HEAD) = DEG0 + DEG1 - <span class="number">1</span>                               <span class="number">120.</span></span><br><span class="line">               MARKER(HEAD) = <span class="number">2</span>                                          <span class="number">121.</span></span><br><span class="line"><span class="comment">C           --------------------                                         122.</span></span><br><span class="line"><span class="comment">C           RESET MARKER VALUES.                                         123.</span></span><br><span class="line"><span class="comment">C           --------------------                                         124.</span></span><br><span class="line"> <span class="number">1200</span>       ROOT = NBRHD(INHD)                                           <span class="number">125.</span></span><br><span class="line">            MARKER(ROOT) = <span class="number">0</span>                                             <span class="number">126.</span></span><br><span class="line">            <span class="keyword">IF</span> ( RCHSZE .LE. <span class="number">0</span> )  <span class="keyword">GOTO</span> <span class="number">1400</span>                              <span class="number">127.</span></span><br><span class="line">               <span class="keyword">DO</span> <span class="number">1300</span> IRCH = <span class="number">1</span>, RCHSZE                                  <span class="number">128.</span></span><br><span class="line">                  NODE = RCHSET(IRCH)                                    <span class="number">129.</span></span><br><span class="line">                  MARKER(NODE) = <span class="number">0</span>                                       <span class="number">130.</span></span><br><span class="line"> <span class="number">1300</span>          <span class="keyword">CONTINUE</span>                                                  <span class="number">131.</span></span><br><span class="line"> <span class="number">1400</span>    <span class="keyword">CONTINUE</span>                                                        <span class="number">132.</span></span><br><span class="line">         <span class="keyword">RETURN</span>                                                          <span class="number">133.</span></span><br><span class="line">      <span class="keyword">END</span>                                                                <span class="number">134.</span></span><br></pre></td></tr></table></figure>
<p>首先进行初始化，将相邻的已经消元的 supernode 的 MARKER 值设置为 0（<strong>QMDUPD</strong> 子程序里一开始将这些节点的 MARKER 值设为 - 1 了，本来可以直接在 <strong>QMDUPD</strong> 子程序里将 MARKER 值设为0的（应该也不用设，本来MARKER值就是 0） ）。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C        ------------------                                               47.</span></span><br><span class="line"><span class="comment">C        INITIALIZATION ...                                               48.</span></span><br><span class="line"><span class="comment">C        ------------------                                               49.</span></span><br><span class="line">         <span class="keyword">IF</span> ( NHDSZE .LE. <span class="number">0</span> )  <span class="keyword">RETURN</span>                                     <span class="number">50.</span></span><br><span class="line">         <span class="keyword">DO</span> <span class="number">100</span> INHD = <span class="number">1</span>, NHDSZE                                          <span class="number">51.</span></span><br><span class="line">            ROOT = NBRHD(INHD)                                            <span class="number">52.</span></span><br><span class="line">            MARKER(ROOT) = <span class="number">0</span>                                              <span class="number">53.</span></span><br><span class="line">  <span class="number">100</span>    <span class="keyword">CONTINUE</span>                                                         <span class="number">54.</span></span><br></pre></td></tr></table></figure>
<p>遍历 (NHDSZE, NBRHD) 中每一个已经消元的 supernode，设置为 ROOT ，将其 MARKER 值设为 -1 。JSTRT 和 JSTOP 是 ROOT 的相邻节点。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C        -------------------------------------------------                55.</span></span><br><span class="line"><span class="comment">C        LOOP THROUGH EACH ELIMINATED SUPERNODE IN THE SET                56.</span></span><br><span class="line"><span class="comment">C        (NHDSZE, NBRHD).                                                 57.</span></span><br><span class="line"><span class="comment">C        -------------------------------------------------                58.</span></span><br><span class="line">         <span class="keyword">DO</span> <span class="number">1400</span> INHD = <span class="number">1</span>, NHDSZE                                         <span class="number">59.</span></span><br><span class="line">            ROOT = NBRHD(INHD)                                            <span class="number">60.</span></span><br><span class="line">            MARKER(ROOT) = - <span class="number">1</span>                                            <span class="number">61.</span></span><br><span class="line">            RCHSZE = <span class="number">0</span>                                                    <span class="number">62.</span></span><br><span class="line">            NOVRLP = <span class="number">0</span>                                                    <span class="number">63.</span></span><br><span class="line">            DEG1   = <span class="number">0</span>                                                    <span class="number">64.</span></span><br><span class="line">  <span class="number">200</span>       JSTRT  = XADJ(ROOT)                                           <span class="number">65.</span></span><br><span class="line">            JSTOP  = XADJ(ROOT+<span class="number">1</span>) - <span class="number">1</span>                                     <span class="number">66.</span></span><br></pre></td></tr></table></figure>
<p><code>DO 600</code> 遍历 ROOT 的相邻节点，设为 NABOR 。</p>
<p>ROOT 设为 <code>- NABOR</code> 。如果 NABOR 小于0，说明此时NABOR 为链接，则 <code>GO TO 200</code> ,继续遍历；如果 NABOR 等于0，则说明此时所有相邻节点，遍历结束，<code>GO TO 700</code> ；如果 NABOR 大于0，继续往下运行，<code>GO TO 300</code>。</p>
<p>将 NABOR 的 MARKER 值设为 MARK ，如果 MARK 小于0 (因为 NABOR 是没有消元的节点，此时只有一种情况，就是 NABOR 合并到与其不可区分的节点中 )，则<code>GO TO 600</code>，跳过这个节点；如果 MARK 等于0，说明这个节点不在 R1 中，即其在 R2 - R1 中，则继续往下运行，则<code>GO TO 400</code>；如果 MARK 大于0，说明其同样在 R1 中，即其在   <img src="https://math.now.sh?inline=R2%20%5Ccap%20R1" style="display:inline-block;margin: 0;"/> 中， 则<code>GO TO 500</code>。</p>
<p>我们先看 400 的语句，如果 MARK 等于0，确定集合 R2 - R1 （在R2 但不在 R1 中，因为 R1 的 MARKER 值均为 1） ，存放在 <strong>(RCHSZE, RCHSET)</strong>，将其 MARKER 值设为 1 ， DEG1 添加这些节点的数目。</p>
<p>我们再看 500 的语句，如果  MARK 等于2（<strong>说明这个节点已经是别的 C2 找到的不可区分的 supernode</strong>，这种情况感觉不可能发生，因为其相邻节点满足   <img src="https://math.now.sh?inline=Adj%28y%29%20%5Csubset%20R_%7B1%7D%20%5Ccup%20R_%7B2%7D%20%5Ccup%20C_%7B1%7D%20%5Ccup%20C_%7B2%7D" style="display:inline-block;margin: 0;"/> ，因此不可能在别的 <img src="https://math.now.sh?inline=C_%7Bn%7D" style="display:inline-block;margin: 0;"/> 中 ），跳过这个节点。如果 MARK 等于1，确定为交集 <img src="https://math.now.sh?inline=R2%20%5Ccap%20R1" style="display:inline-block;margin: 0;"/> ，存放在  <strong>(NOVRLP, OVRLP)</strong> ，将其 MARKER 值设为 2。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C           ----------------------------------------------                67.</span></span><br><span class="line"><span class="comment">C           DETERMINE THE REACHABLE SET AND ITS INTERSECT-                68.</span></span><br><span class="line"><span class="comment">C           ION WITH THE INPUT REACHABLE SET.                             69.</span></span><br><span class="line"><span class="comment">C           ----------------------------------------------                70.</span></span><br><span class="line">            <span class="keyword">DO</span> <span class="number">600</span> J = JSTRT, JSTOP                                       <span class="number">71.</span></span><br><span class="line">               NABOR = ADJNCY(J)                                          <span class="number">72.</span></span><br><span class="line">               ROOT  = - NABOR                                            <span class="number">73.</span></span><br><span class="line">               <span class="keyword">IF</span> (NABOR)  <span class="number">200</span>, <span class="number">700</span>, <span class="number">300</span>                                  <span class="number">74.</span></span><br><span class="line"><span class="comment">C                                                                         75.</span></span><br><span class="line">  <span class="number">300</span>          MARK = MARKER(NABOR)                                       <span class="number">76.</span></span><br><span class="line">               <span class="keyword">IF</span> ( MARK ) <span class="number">600</span>, <span class="number">400</span>, <span class="number">500</span>                                  <span class="number">77.</span></span><br><span class="line">  <span class="number">400</span>             RCHSZE = RCHSZE + <span class="number">1</span>                                     <span class="number">78.</span></span><br><span class="line">                  RCHSET(RCHSZE) = NABOR                                  <span class="number">79.</span></span><br><span class="line">                  DEG1 = DEG1 + QSIZE(NABOR)                              <span class="number">80.</span></span><br><span class="line">                  MARKER(NABOR) = <span class="number">1</span>                                       <span class="number">81.</span></span><br><span class="line">                  <span class="keyword">GOTO</span> <span class="number">600</span>                                                <span class="number">82.</span></span><br><span class="line">  <span class="number">500</span>          <span class="keyword">IF</span> ( MARK .GT. <span class="number">1</span> )  <span class="keyword">GOTO</span> <span class="number">600</span>                               <span class="number">83.</span></span><br><span class="line">                  NOVRLP = NOVRLP + <span class="number">1</span>                                     <span class="number">84.</span></span><br><span class="line">                  OVRLP(NOVRLP) = NABOR                                   <span class="number">85.</span></span><br><span class="line">                  MARKER(NABOR) = <span class="number">2</span>                                       <span class="number">86.</span></span><br><span class="line">  <span class="number">600</span>       <span class="keyword">CONTINUE</span>                                                      <span class="number">87.</span></span><br></pre></td></tr></table></figure>
<p>从交集  <img src="https://math.now.sh?inline=R2%20%5Ccap%20R1" style="display:inline-block;margin: 0;"/> 中，根据条件（ <img src="https://math.now.sh?inline=Adj%28y%29%20%5Csubset%20R_%7B1%7D%20%5Ccup%20R_%7B2%7D%20%5Ccup%20C_%7B1%7D%20%5Ccup%20C_%7B2%7D" style="display:inline-block;margin: 0;"/> ），确定不可区分的节点。</p>
<p>HEAD 是不可区分节点其 QLINK 中最后一个节点应该设的值，初始为 0 ，MRGSZE  为可以合并的所有不可区分节点数目，初始为 0 。</p>
<p><code>DO 1100</code> 循环遍历 NOVRLP 中的每一个节点，设为 NODE 。通过 <code>DO 800</code> 循环遍历其所有相邻节点，确定其是否符合条件  <img src="https://math.now.sh?inline=Adj%28y%29%20%5Csubset%20R_%7B1%7D%20%5Ccup%20R_%7B2%7D%20%5Ccup%20C_%7B1%7D%20%5Ccup%20C_%7B2%7D" style="display:inline-block;margin: 0;"/> ，如果符合条件则其所有相邻节点的MARKER 值必须均不为0 （C1 中的节点有的为1（本次需要消元的节点），有的为 -1（其它）；R1 的 MARKER 值为 1，这两部分是由 QMDRCH 设置的。C2 的 MARKER 值为 -1，R2 中一部分为 1 ( R2 - R1 )，一部分为 2 ( <img src="https://math.now.sh?inline=R2%20%5Ccap%20R1" style="display:inline-block;margin: 0;"/> )，这两部分是本脚本设置的。除了这些节点以外，其它节点的 MARKER 值并未改变，也就是说，其它节点如何合并进别的节点中了则 MARKER 值为 -1 ，否则为 0）。</p>
<p>如果存在 MARKER 值等于0的相邻节点（这个节点不在 <img src="https://math.now.sh?inline=R_%7B1%7D%20%5Ccup%20R_%7B2%7D%20%5Ccup%20C_%7B1%7D%20%5Ccup%20C_%7B2%7D" style="display:inline-block;margin: 0;"/>中），则将 NODE 的 MARKER 值从 2 修改为 1(重置为 R1 的默认值)， 说明 NODE 不符合条件，跳出 <code>DO 800</code> 循环，<code>GOTO 1100</code>，遍历下一个接待你 。</p>
<p>如果均不存在 MARKER 值等于0的相邻节点，说明 NODE 符合条件，接着向下走，MRGSZE 加上 NODE 的 QSIZE 值。将 NODE 节点的 MARKER 值改为 -1 。</p>
<p>后面的几句脚本 (110-114句) 通过一个 UNTIL 循环找到 NODE 在 QLINK 中的最后一个节点 LNODE。最后 <code>QLINK(LNODE) = HEAD</code> 将 LNODE 的  QLINK 值设为 HEAD ，然后将 HEAD 设为 NODE 。这段脚本的含义是将所有不可区分的节点合并到一块，对于第一个不可区分的节点 NODE，将其QLINK 链接中最后一个节点的 QLINK 值设为 0 (HEAD 初始值)；对于第二个不可区分的节点，将其QLINK 链接中最后一个节点的 QLINK 值设为第一个节点，从而将第二个不可区分的节点和第一个不可区分的节点链接起来，以此类推。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C           --------------------------------------------                  88.</span></span><br><span class="line"><span class="comment">C           FROM THE OVERLAPPED SET, DETERMINE THE NODES                  89.</span></span><br><span class="line"><span class="comment">C           THAT CAN BE MERGED TOGETHER.                                  90.</span></span><br><span class="line"><span class="comment">C           --------------------------------------------                  91.</span></span><br><span class="line">  <span class="number">700</span>       HEAD = <span class="number">0</span>                                                      <span class="number">92.</span></span><br><span class="line">            MRGSZE = <span class="number">0</span>                                                    <span class="number">93.</span></span><br><span class="line">            <span class="keyword">DO</span> <span class="number">1100</span> IOV = <span class="number">1</span>, NOVRLP                                       <span class="number">94.</span></span><br><span class="line">               NODE = OVRLP(IOV)                                          <span class="number">95.</span></span><br><span class="line">               JSTRT = XADJ(NODE)                                         <span class="number">96.</span></span><br><span class="line">               JSTOP = XADJ(NODE+<span class="number">1</span>) - <span class="number">1</span>                                   <span class="number">97.</span></span><br><span class="line">               <span class="keyword">DO</span> <span class="number">800</span> J = JSTRT, JSTOP                                    <span class="number">98.</span></span><br><span class="line">                  NABOR = ADJNCY(J)                                       <span class="number">99.</span></span><br><span class="line">                  <span class="keyword">IF</span> ( MARKER(NABOR) .NE. <span class="number">0</span> )  <span class="keyword">GOTO</span> <span class="number">800</span>                  <span class="number">100.</span></span><br><span class="line">                     MARKER(NODE) = <span class="number">1</span>                                    <span class="number">101.</span></span><br><span class="line">                     <span class="keyword">GOTO</span> <span class="number">1100</span>                                           <span class="number">102.</span></span><br><span class="line">  <span class="number">800</span>          <span class="keyword">CONTINUE</span>                                                  <span class="number">103.</span></span><br><span class="line"><span class="comment">C              -----------------------------------------                 104.</span></span><br><span class="line"><span class="comment">C              NODE BELONGS TO THE NEW MERGED SUPERNODE.                 105.</span></span><br><span class="line"><span class="comment">C              UPDATE THE VECTORS QLINK AND QSIZE.                       106.</span></span><br><span class="line"><span class="comment">C              -----------------------------------------                 107.</span></span><br><span class="line">               MRGSZE = MRGSZE + QSIZE(NODE)                             <span class="number">108.</span></span><br><span class="line">               MARKER(NODE) = - <span class="number">1</span>                                        <span class="number">109.</span></span><br><span class="line">               LNODE = NODE                                              <span class="number">110.</span></span><br><span class="line">  <span class="number">900</span>          LINK  = QLINK(LNODE)                                      <span class="number">111.</span></span><br><span class="line">               <span class="keyword">IF</span> ( LINK .LE. <span class="number">0</span> )  <span class="keyword">GOTO</span> <span class="number">1000</span>                             <span class="number">112.</span></span><br><span class="line">                  LNODE = LINK                                           <span class="number">113.</span></span><br><span class="line">                  <span class="keyword">GOTO</span> <span class="number">900</span>                                               <span class="number">114.</span></span><br><span class="line"> <span class="number">1000</span>          QLINK(LNODE) = HEAD                                       <span class="number">115.</span></span><br><span class="line">               HEAD = NODE                                               <span class="number">116.</span></span><br><span class="line"> <span class="number">1100</span>       <span class="keyword">CONTINUE</span>                                                     <span class="number">117.</span></span><br></pre></td></tr></table></figure>
<p>如果 HEAD 等于0，那说明符合条件  <img src="https://math.now.sh?inline=Adj%28y%29%20%5Csubset%20R_%7B1%7D%20%5Ccup%20R_%7B2%7D%20%5Ccup%20C_%7B1%7D%20%5Ccup%20C_%7B2%7D" style="display:inline-block;margin: 0;"/> 的节点数目是 0 个，因此没有需要合并的不可区分的节点，那么直接 <code>GOTO 1200</code></p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">IF</span> ( HEAD .LE. <span class="number">0</span> )  <span class="keyword">GOTO</span> <span class="number">1200</span>                                <span class="number">118.</span></span><br></pre></td></tr></table></figure>
<p>如果 HEAD 不等于0，那么就说明存在需要合并的不可区分的节点，形成一个 supernode ，这个 supernode 的代表节点就是 HEAD。修改 HEAD 的 QSIZE 为 MRGSZE（所有不可区分节点数目）。</p>
<p>将 HEAD 的 DEG 值设为 <code>DEG0 + DEG1 - 1</code> ，这里的度数是 <img src="https://math.now.sh?inline=%7CReach%28u%2CS%20%5Ccup%20C_%7B1%7D%29%7C" style="display:inline-block;margin: 0;"/> 。这句话解释如下，这些节点在  <img src="https://math.now.sh?inline=R2%20%5Ccap%20R1" style="display:inline-block;margin: 0;"/> 中 ，其相邻节点满足条件  <img src="https://math.now.sh?inline=Adj%28y%29%20%5Csubset%20R_%7B1%7D%20%5Ccup%20R_%7B2%7D%20%5Ccup%20C_%7B1%7D%20%5Ccup%20C_%7B2%7D" style="display:inline-block;margin: 0;"/> ，因此其尚未消元的相邻节点均在 <img src="https://math.now.sh?inline=R_%7B1%7D%20%5Ccup%20R_%7B2%7D" style="display:inline-block;margin: 0;"/> 中。进一步消除 <img src="https://math.now.sh?inline=C_%7B1%7D" style="display:inline-block;margin: 0;"/> 之后，<img src="https://math.now.sh?inline=R_%7B1%7D" style="display:inline-block;margin: 0;"/> 中的节点彼此相连，Head 节点也在 <img src="https://math.now.sh?inline=R_%7B1%7D" style="display:inline-block;margin: 0;"/> 中，因此其与  <img src="https://math.now.sh?inline=R_%7B1%7D" style="display:inline-block;margin: 0;"/> 中其它节点均相连，数目为 DEG0 - 1（减去 HEAD 自己）。而在  <img src="https://math.now.sh?inline=R_%7B2%7D" style="display:inline-block;margin: 0;"/> 中，除了与 <img src="https://math.now.sh?inline=R_%7B1%7D" style="display:inline-block;margin: 0;"/> 共同的节点， 额外与 HEAD 相邻的节点均在 R2 - R1 中，其节点数目为 DEG1 。因此，合并这两点，其 DEG 值更新为   <code>DEG0 + DEG1 - 1</code> 。</p>
<p>这些节点的 MARKER 值已经设为 -1 了，最后 supernode 的代表节点 HEAD 的 MARKER 值更新为 2 。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">QSIZE(HEAD) = MRGSZE                                      <span class="number">119.</span></span><br><span class="line">DEG(HEAD) = DEG0 + DEG1 - <span class="number">1</span>                               <span class="number">120.</span></span><br><span class="line">MARKER(HEAD) = <span class="number">2</span>                                          <span class="number">121.</span></span><br></pre></td></tr></table></figure>
<p>最后重置 MARKER 值，将 NBRHD 的节点 ROOT 的 MARKER 值重新设为 0 ，将 RCHSET 中节点 (R2-R1) 的 MARKER 值均重新设为 0 。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C           --------------------                                         122.</span></span><br><span class="line"><span class="comment">C           RESET MARKER VALUES.                                         123.</span></span><br><span class="line"><span class="comment">C           --------------------                                         124.</span></span><br><span class="line"> <span class="number">1200</span>       ROOT = NBRHD(INHD)                                           <span class="number">125.</span></span><br><span class="line">            MARKER(ROOT) = <span class="number">0</span>                                             <span class="number">126.</span></span><br><span class="line">            <span class="keyword">IF</span> ( RCHSZE .LE. <span class="number">0</span> )  <span class="keyword">GOTO</span> <span class="number">1400</span>                              <span class="number">127.</span></span><br><span class="line">               <span class="keyword">DO</span> <span class="number">1300</span> IRCH = <span class="number">1</span>, RCHSZE                                  <span class="number">128.</span></span><br><span class="line">                  NODE = RCHSET(IRCH)                                    <span class="number">129.</span></span><br><span class="line">                  MARKER(NODE) = <span class="number">0</span>                                       <span class="number">130.</span></span><br><span class="line"> <span class="number">1300</span>          <span class="keyword">CONTINUE</span>                                                  <span class="number">131.</span></span><br><span class="line"> <span class="number">1400</span>    <span class="keyword">CONTINUE</span>                                                        <span class="number">132.</span></span><br><span class="line">         <span class="keyword">RETURN</span>                                                          <span class="number">133.</span></span><br><span class="line">      <span class="keyword">END</span>                                                                <span class="number">134.</span></span><br></pre></td></tr></table></figure>
<p><strong>最后除了 NOVRLP 中节点的  MARKER  值修改了之外（不可区分的supernode 为 2，被合并的节点为 -1），其它节点的 MARKER 值均已经还原重置。</strong></p>
<p><strong>注意 NBRHD 中所以所有节点的 MARKER 值均为 0</strong>。</p>
<h1>参考文献</h1>
<ol>
<li>George A, Liu J, Ng E. Computer solution of sparse linear systems[J]. Oak Ridge National Laboratory, 1994.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>稀疏矩阵</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>稀疏矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏矩阵算法最小度数算法七之最小度数算法子程序QMDUPD</title>
    <url>/posts/3082be2e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本章节介绍 <em>the minimum degree algorithm</em> ，我个人将其翻译为最小度数算法。这里我们看最小度数算法的子程序 QMDUPD 。</p>
<span id="more"></span>
<h1>QMDUPD</h1>
<p><strong>(Quotient MD UPDate)</strong>，这个子程序用于执行自由度更新这一步。节点的新的自由度通过 <strong>(NLIST, LIST)</strong> 来确定。这个子程序同时会确定不可区分的节点。</p>
<p>第一个循环 <code>DO 200</code> 之后调用子程序 <strong>QMDMRG</strong> 来确定不可区分的节点，它们会合并到一块，并且更新这些节点的自由度。</p>
<p>对于没有合并的节点，<code>DO 600</code> 循环通过调用子程序 <strong>QMDRCH</strong> 来确定它们新的自由度。</p>
<p>向量 RCHSET 和 NBRHD 用于作为临时向量。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">C****************************************************************          <span class="number">1.</span></span><br><span class="line">C****************************************************************          <span class="number">2.</span></span><br><span class="line">C**********     QMDUPD ..... QUOT <span class="built_in">MIN</span> DEG UPDATE      ***********          <span class="number">3.</span></span><br><span class="line">C****************************************************************          <span class="number">4.</span></span><br><span class="line">C****************************************************************          <span class="number">5.</span></span><br><span class="line"><span class="comment">C                                                                          6.</span></span><br><span class="line"><span class="comment">C     PURPOSE - THIS ROUTINE PERFORMS DEGREE UPDATE FOR A SET              7.</span></span><br><span class="line"><span class="comment">C        OF NODES IN THE MINIMUM DEGREE ALGORITHM.                         8.</span></span><br><span class="line"><span class="comment">C                                                                          9.</span></span><br><span class="line"><span class="comment">C     INPUT PARAMETERS -                                                  10.</span></span><br><span class="line"><span class="comment">C        (XADJ, ADJNCY) - THE ADJACENCY STRUCTURE.                        11.</span></span><br><span class="line"><span class="comment">C        (NLIST, LIST) - THE LIST OF NODES WHOSE DEGREE HAS TO            12.</span></span><br><span class="line"><span class="comment">C               BE UPDATED.                                               13.</span></span><br><span class="line"><span class="comment">C                                                                         14.</span></span><br><span class="line"><span class="comment">C     UPDATED PARAMETERS -                                                15.</span></span><br><span class="line"><span class="comment">C        DEG - THE DEGREE VECTOR.                                         16.</span></span><br><span class="line"><span class="comment">C        QSIZE - SIZE OF INDISTINGUISHABLE SUPERNODES.                    17.</span></span><br><span class="line"><span class="comment">C        QLINK - LINKED LIST FOR INDISTINGUISHABLE NODES.                 18.</span></span><br><span class="line"><span class="comment">C        MARKER - USED TO MARK THOSE NODES IN REACH/NBRHD SETS.           19.</span></span><br><span class="line"><span class="comment">C                                                                         20.</span></span><br><span class="line"><span class="comment">C     WORKING PARAMETERS -                                                21.</span></span><br><span class="line"><span class="comment">C        RCHSET - THE REACHABLE SET.                                      22.</span></span><br><span class="line"><span class="comment">C        NBRHD -  THE NEIGHBORHOOD SET.                                   23.</span></span><br><span class="line"><span class="comment">C                                                                         24.</span></span><br><span class="line"><span class="comment">C     PROGRAM SUBROUTINES -                                               25.</span></span><br><span class="line"><span class="comment">C        QMDMRG.                                                          26.</span></span><br><span class="line"><span class="comment">C                                                                         27.</span></span><br><span class="line">C****************************************************************         <span class="number">28.</span></span><br><span class="line"><span class="comment">C                                                                         29.</span></span><br><span class="line">      <span class="function"><span class="keyword">SUBROUTINE</span></span>  QMDUPD ( XADJ, ADJNCY, NLIST, LIST, DEG,                <span class="number">30.</span></span><br><span class="line">     <span class="number">1</span>                     QSIZE, QLINK, MARKER, RCHSET, NBRHD )          <span class="number">31.</span></span><br><span class="line"><span class="comment">C                                                                         32.</span></span><br><span class="line">C****************************************************************         <span class="number">33.</span></span><br><span class="line"><span class="comment">C                                                                         34.</span></span><br><span class="line">         <span class="keyword">INTEGER</span>  ADJNCY(<span class="number">1</span>), LIST(<span class="number">1</span>), DEG(<span class="number">1</span>), MARKER(<span class="number">1</span>),                  <span class="number">35.</span></span><br><span class="line">     <span class="number">1</span>            RCHSET(<span class="number">1</span>), NBRHD(<span class="number">1</span>), QSIZE(<span class="number">1</span>), QLINK(<span class="number">1</span>)                 <span class="number">36.</span></span><br><span class="line">         <span class="keyword">INTEGER</span>  XADJ(<span class="number">1</span>), DEG0, DEG1, IL, INHD, INODE, IRCH,             <span class="number">37.</span></span><br><span class="line">     <span class="number">1</span>            J, JSTRT, JSTOP, MARK, NABOR, NHDSZE, NLIST,            <span class="number">38.</span></span><br><span class="line">     <span class="number">1</span>            NODE, RCHSZE, ROOT                                      <span class="number">39.</span></span><br><span class="line"><span class="comment">C                                                                         40.</span></span><br><span class="line">C****************************************************************         <span class="number">41.</span></span><br><span class="line"><span class="comment">C                                                                         42.</span></span><br><span class="line"><span class="comment">C        ------------------------------------------------                 43.</span></span><br><span class="line"><span class="comment">C        FIND ALL ELIMINATED SUPERNODES THAT ARE ADJACENT                 44.</span></span><br><span class="line"><span class="comment">C        TO SOME NODES IN THE GIVEN LIST. PUT THEM INTO                   45.</span></span><br><span class="line"><span class="comment">C        (NHDSZE, NBRHD). DEG0 CONTAINS THE NUMBER OF                     46.</span></span><br><span class="line"><span class="comment">C        NODES IN THE LIST.                                               47.</span></span><br><span class="line"><span class="comment">C        ------------------------------------------------                 48.</span></span><br><span class="line">         <span class="keyword">IF</span> ( NLIST .LE. <span class="number">0</span> )  <span class="keyword">RETURN</span>                                      <span class="number">49.</span></span><br><span class="line">         DEG0 = <span class="number">0</span>                                                         <span class="number">50.</span></span><br><span class="line">         NHDSZE = <span class="number">0</span>                                                       <span class="number">51.</span></span><br><span class="line">         <span class="keyword">DO</span> <span class="number">200</span> IL = <span class="number">1</span>, NLIST                                             <span class="number">52.</span></span><br><span class="line">            NODE = LIST(IL)                                               <span class="number">53.</span></span><br><span class="line">            DEG0 = DEG0 + QSIZE(NODE)                                     <span class="number">54.</span></span><br><span class="line">            JSTRT = XADJ(NODE)                                            <span class="number">55.</span></span><br><span class="line">            JSTOP = XADJ(NODE+<span class="number">1</span>) - <span class="number">1</span>                                      <span class="number">56.</span></span><br><span class="line">            <span class="keyword">DO</span> <span class="number">100</span> J = JSTRT, JSTOP                                       <span class="number">57.</span></span><br><span class="line">               NABOR = ADJNCY(J)                                          <span class="number">58.</span></span><br><span class="line">               <span class="keyword">IF</span> ( MARKER(NABOR) .NE. <span class="number">0</span>  .OR.                            <span class="number">59.</span></span><br><span class="line">     <span class="number">1</span>              DEG(NABOR) .GE. <span class="number">0</span> )  GO TO <span class="number">100</span>                        <span class="number">60.</span></span><br><span class="line">                  MARKER(NABOR) = - <span class="number">1</span>                                     <span class="number">61.</span></span><br><span class="line">                  NHDSZE = NHDSZE + <span class="number">1</span>                                     <span class="number">62.</span></span><br><span class="line">                  NBRHD(NHDSZE) = NABOR                                   <span class="number">63.</span></span><br><span class="line">  <span class="number">100</span>       <span class="keyword">CONTINUE</span>                                                      <span class="number">64.</span></span><br><span class="line">  <span class="number">200</span>    <span class="keyword">CONTINUE</span>                                                         <span class="number">65.</span></span><br><span class="line"><span class="comment">C        --------------------------------------------                     66.</span></span><br><span class="line"><span class="comment">C        MERGE INDISTINGUISHABLE NODES IN THE LIST BY                     67.</span></span><br><span class="line"><span class="comment">C        CALLING THE SUBROUTINE QMDMRG.                                   68.</span></span><br><span class="line"><span class="comment">C        --------------------------------------------                     69.</span></span><br><span class="line">         <span class="keyword">IF</span> ( NHDSZE .GT. <span class="number">0</span> )                                             <span class="number">70.</span></span><br><span class="line">     <span class="number">1</span>      <span class="keyword">CALL</span>  QMDMRG ( XADJ, ADJNCY, DEG, QSIZE, QLINK,               <span class="number">71.</span></span><br><span class="line">     <span class="number">1</span>                     MARKER, DEG0, NHDSZE, NBRHD, RCHSET,           <span class="number">72.</span></span><br><span class="line">     <span class="number">1</span>                     NBRHD(NHDSZE+<span class="number">1</span>) )                              <span class="number">73.</span></span><br><span class="line"><span class="comment">C        ----------------------------------------------------             74.</span></span><br><span class="line"><span class="comment">C        FIND THE NEW DEGREES OF THE NODES THAT HAVE NOT BEEN             75.</span></span><br><span class="line"><span class="comment">C        MERGED.                                                          76.</span></span><br><span class="line"><span class="comment">C        ----------------------------------------------------             77.</span></span><br><span class="line">         <span class="keyword">DO</span> <span class="number">600</span> IL = <span class="number">1</span>, NLIST                                             <span class="number">78.</span></span><br><span class="line">            NODE = LIST(IL)                                               <span class="number">79.</span></span><br><span class="line">            MARK = MARKER(NODE)                                           <span class="number">80.</span></span><br><span class="line">            <span class="keyword">IF</span> ( MARK .GT. <span class="number">1</span>  .OR.  MARK .LT. <span class="number">0</span> )  GO TO <span class="number">600</span>              <span class="number">81.</span></span><br><span class="line">               MARKER(NODE) = <span class="number">2</span>                                           <span class="number">82.</span></span><br><span class="line">               <span class="keyword">CALL</span>  QMDRCH ( NODE, XADJ, ADJNCY, DEG, MARKER,            <span class="number">83.</span></span><br><span class="line">     <span class="number">1</span>                        RCHSZE, RCHSET, NHDSZE, NBRHD )             <span class="number">84.</span></span><br><span class="line">               DEG1 = DEG0                                                <span class="number">85.</span></span><br><span class="line">               <span class="keyword">IF</span> ( RCHSZE .LE. <span class="number">0</span> )  GO TO <span class="number">400</span>                            <span class="number">86.</span></span><br><span class="line">                  <span class="keyword">DO</span> <span class="number">300</span> IRCH = <span class="number">1</span>, RCHSZE                                 <span class="number">87.</span></span><br><span class="line">                     INODE = RCHSET(IRCH)                                 <span class="number">88.</span></span><br><span class="line">                     DEG1 = DEG1 + QSIZE(INODE)                           <span class="number">89.</span></span><br><span class="line">                     MARKER(INODE) = <span class="number">0</span>                                    <span class="number">90.</span></span><br><span class="line">  <span class="number">300</span>             <span class="keyword">CONTINUE</span>                                                <span class="number">91.</span></span><br><span class="line">  <span class="number">400</span>          DEG(NODE) = DEG1 - <span class="number">1</span>                                       <span class="number">92.</span></span><br><span class="line">               <span class="keyword">IF</span> ( NHDSZE .LE. <span class="number">0</span> )  GO TO <span class="number">600</span>                            <span class="number">93.</span></span><br><span class="line">                  <span class="keyword">DO</span> <span class="number">500</span> INHD = <span class="number">1</span>, NHDSZE                                 <span class="number">94.</span></span><br><span class="line">                     INODE = NBRHD(INHD)                                  <span class="number">95.</span></span><br><span class="line">                     MARKER(INODE) = <span class="number">0</span>                                    <span class="number">96.</span></span><br><span class="line">  <span class="number">500</span>             <span class="keyword">CONTINUE</span>                                                <span class="number">97.</span></span><br><span class="line">  <span class="number">600</span>    <span class="keyword">CONTINUE</span>                                                         <span class="number">98.</span></span><br><span class="line">         <span class="keyword">RETURN</span>                                                           <span class="number">99.</span></span><br><span class="line">      <span class="keyword">END</span>                                                                <span class="number">100.</span></span><br></pre></td></tr></table></figure>
<p>下面开始逐行分析脚本</p>
<p>首先查找与给定列表中节点相邻的已经消元的 supernodes ，将它们放在 **(NHDSZE, NBRHD)**中，<strong>DEG0</strong> 表示 LIST 中的节点数目（包括其不可区分的节点）。</p>
<p><code>DO 100</code> 循环中的 IF 判断就是说，NABOR 节点需要满足 DEG 值小于 0 (表示其为消元节点) 并且 Marker 值等于0（表示其为除了本次需要消元的节点形成的 supernode 之外的其它已经消元的 supernode），将这样的 NABOR 节点的 MARKER 值设为 -1（<strong>这里设为 -1 应该只是为了去重</strong>，下面调用 QMDMRG 会将其MARKER 值重新设为 0 ） ，放到  <strong>(NHDSZE, NBRHD)</strong> 中。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">       <span class="keyword">IF</span> ( NLIST .LE. <span class="number">0</span> )  <span class="keyword">RETURN</span>                                      <span class="number">49.</span></span><br><span class="line">       DEG0 = <span class="number">0</span>                                                         <span class="number">50.</span></span><br><span class="line">       NHDSZE = <span class="number">0</span>                                                       <span class="number">51.</span></span><br><span class="line">       <span class="keyword">DO</span> <span class="number">200</span> IL = <span class="number">1</span>, NLIST                                             <span class="number">52.</span></span><br><span class="line">          NODE = LIST(IL)                                               <span class="number">53.</span></span><br><span class="line">          DEG0 = DEG0 + QSIZE(NODE)                                     <span class="number">54.</span></span><br><span class="line">          JSTRT = XADJ(NODE)                                            <span class="number">55.</span></span><br><span class="line">          JSTOP = XADJ(NODE+<span class="number">1</span>) - <span class="number">1</span>                                      <span class="number">56.</span></span><br><span class="line">          <span class="keyword">DO</span> <span class="number">100</span> J = JSTRT, JSTOP                                       <span class="number">57.</span></span><br><span class="line">             NABOR = ADJNCY(J)                                          <span class="number">58.</span></span><br><span class="line">             <span class="keyword">IF</span> ( MARKER(NABOR) .NE. <span class="number">0</span>  .OR.                            <span class="number">59.</span></span><br><span class="line">   <span class="number">1</span>              DEG(NABOR) .GE. <span class="number">0</span> )  GO TO <span class="number">100</span>                        <span class="number">60.</span></span><br><span class="line">                MARKER(NABOR) = - <span class="number">1</span>                                     <span class="number">61.</span></span><br><span class="line">                NHDSZE = NHDSZE + <span class="number">1</span>                                     <span class="number">62.</span></span><br><span class="line">                NBRHD(NHDSZE) = NABOR                                   <span class="number">63.</span></span><br><span class="line"><span class="number">100</span>       <span class="keyword">CONTINUE</span>                                                      <span class="number">64.</span></span><br><span class="line"><span class="number">200</span>    <span class="keyword">CONTINUE</span>                                                         <span class="number">65.</span></span><br></pre></td></tr></table></figure>
<p>通过调用子程序 QMDMRG 来找到 LIST 中的不可区分的节点并进行合并，并更新其 DEG 值。</p>
<p>运行结束后，<strong>不可区分的supernode 的 MARKER 值为 2，被合并的节点的 MARKER 值为 -1</strong>。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">IF</span> ( NHDSZE .GT. <span class="number">0</span> )                                             <span class="number">70.</span></span><br><span class="line"><span class="number">1</span>      <span class="keyword">CALL</span>  QMDMRG ( XADJ, ADJNCY, DEG, QSIZE, QLINK,               <span class="number">71.</span></span><br><span class="line"><span class="number">1</span>                     MARKER, DEG0, NHDSZE, NBRHD, RCHSET,           <span class="number">72.</span></span><br><span class="line"><span class="number">1</span>                     NBRHD(NHDSZE+<span class="number">1</span>) )                              <span class="number">73.</span></span><br></pre></td></tr></table></figure>
<p>对于那些没有合并的节点，更新其 DEG 值，为  <img src="https://math.now.sh?inline=%7CReach%28u%2CS%20%5Ccup%20C_%7B1%7D%29%7C" style="display:inline-block;margin: 0;"/> 。</p>
<p><code>DO 600</code> 遍历 LIST 中的每一个节点 NODE ，其 MARKER 值为 MARK 。如果 MARK 大于 1 （新合并的 supernode 的代表节点）或者小于 0（新合并的 supernode 的其它节点），那么跳过这个节点。</p>
<p>不然的话，接着往下走，<strong>将 NODE 的 MARKER 值设为 2</strong>，调用 <strong>QMDRCH</strong> ，注意 <strong>QMDRCH</strong> 子程序中加入到 RCHSET 的节点其 MARKER 值必须为 0 ，因此此时 RCHSET 中的节点均不在 NLIST 中，均为新的其它未消元的节点。将 DEG0 赋值给 DEG1 ，通过<code>DO 300</code> 循环将  RCHSET 的节点数目加入到 DEG1 ，然后将 NODE 的 DEG 值设为 DEG1 - 1（DEG0 中包含 NODE 本身）。</p>
<p>同样地，此时 NHDSZE 中的节点均不是与本次要消元的节点相邻的已消元的 supernode ，均为新的其它与已消元的节点不相邻的 supernode 。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C        ----------------------------------------------------             74.</span></span><br><span class="line"><span class="comment">C        FIND THE NEW DEGREES OF THE NODES THAT HAVE NOT BEEN             75.</span></span><br><span class="line"><span class="comment">C        MERGED.                                                          76.</span></span><br><span class="line"><span class="comment">C        ----------------------------------------------------             77.</span></span><br><span class="line">         <span class="keyword">DO</span> <span class="number">600</span> IL = <span class="number">1</span>, NLIST                                             <span class="number">78.</span></span><br><span class="line">            NODE = LIST(IL)                                               <span class="number">79.</span></span><br><span class="line">            MARK = MARKER(NODE)                                           <span class="number">80.</span></span><br><span class="line">            <span class="keyword">IF</span> ( MARK .GT. <span class="number">1</span>  .OR.  MARK .LT. <span class="number">0</span> )  GO TO <span class="number">600</span>              <span class="number">81.</span></span><br><span class="line">               MARKER(NODE) = <span class="number">2</span>                                           <span class="number">82.</span></span><br><span class="line">               <span class="keyword">CALL</span>  QMDRCH ( NODE, XADJ, ADJNCY, DEG, MARKER,            <span class="number">83.</span></span><br><span class="line">     <span class="number">1</span>                        RCHSZE, RCHSET, NHDSZE, NBRHD )             <span class="number">84.</span></span><br><span class="line">               DEG1 = DEG0                                                <span class="number">85.</span></span><br><span class="line">               <span class="keyword">IF</span> ( RCHSZE .LE. <span class="number">0</span> )  GO TO <span class="number">400</span>                            <span class="number">86.</span></span><br><span class="line">                  <span class="keyword">DO</span> <span class="number">300</span> IRCH = <span class="number">1</span>, RCHSZE                                 <span class="number">87.</span></span><br><span class="line">                     INODE = RCHSET(IRCH)                                 <span class="number">88.</span></span><br><span class="line">                     DEG1 = DEG1 + QSIZE(INODE)                           <span class="number">89.</span></span><br><span class="line">                     MARKER(INODE) = <span class="number">0</span>                                    <span class="number">90.</span></span><br><span class="line">  <span class="number">300</span>             <span class="keyword">CONTINUE</span>                                                <span class="number">91.</span></span><br><span class="line">  <span class="number">400</span>          DEG(NODE) = DEG1 - <span class="number">1</span>                                       <span class="number">92.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果 NBRHD 不为空，将其中节点的 MARKER 值重置为 0 。</p>
<p>这样就将上面调用  <strong>QMDRCH</strong> 修改的 MARKER 值全部重置了。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">             <span class="keyword">IF</span> ( NHDSZE .LE. <span class="number">0</span> )  GO TO <span class="number">600</span>                            <span class="number">93.</span></span><br><span class="line">                <span class="keyword">DO</span> <span class="number">500</span> INHD = <span class="number">1</span>, NHDSZE                                 <span class="number">94.</span></span><br><span class="line">                   INODE = NBRHD(INHD)                                  <span class="number">95.</span></span><br><span class="line">                   MARKER(INODE) = <span class="number">0</span>                                    <span class="number">96.</span></span><br><span class="line"><span class="number">500</span>             <span class="keyword">CONTINUE</span>                                                <span class="number">97.</span></span><br><span class="line"><span class="number">600</span>    <span class="keyword">CONTINUE</span>                                                         <span class="number">98.</span></span><br><span class="line">       <span class="keyword">RETURN</span>                                                           <span class="number">99.</span></span><br><span class="line">    <span class="keyword">END</span>                                                                <span class="number">100.</span></span><br></pre></td></tr></table></figure>
<p><strong>最后，只有 NLIST 中节点（即要消元节点的相邻节点）的 MARKER 值被修改了，被合并到不可区分的 supernode 中的节点为 -1，其它为 2</strong> 。</p>
<h1>参考文献</h1>
<ol>
<li>George A, Liu J, Ng E. Computer solution of sparse linear systems[J]. Oak Ridge National Laboratory, 1994.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>稀疏矩阵</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>稀疏矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏矩阵算法最小度数算法六之最小度数算法子程序QMDQT</title>
    <url>/posts/e270c640/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本章节介绍 <em>the minimum degree algorithm</em> ，我个人将其翻译为最小度数算法。这里我们看最小度数算法的子程序 QMDQT。</p>
<span id="more"></span>
<h1>QMDQT</h1>
<p><strong>(Quotient MD Quotient graph Transformation)</strong>，这个子程序执行商图的转换，生成相应的 <strong>(XADJ, ADJNCY)</strong>。新的消除的节点包含节点 ROOT 和 NBRHD 中的节点，在新的商图中生成一个以 ROOT 为代表的新的 supernode ，其在新商图的相邻集合在旧商图的 (RCHSZE, RCHSET) 中。</p>
<p>初始化之后，通过 <code>DO 200</code> 循环，将 (RCHSZE, RCHSET) 中的节点放到 ROOT 中的相邻列表中。如果没有足够的空间，程序会利用 NBRHD 集合中的节点的空间。</p>
<p>在退出之前，通过<code>DO 600</code> 循环将以 ROOT 为代表的相邻节点会加入到 RCHSET 中每一个节点的相邻列表中。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">C*************************************************************             <span class="number">1.</span></span><br><span class="line">C*************************************************************             <span class="number">2.</span></span><br><span class="line">C*******     QMDQT  ..... QUOT <span class="built_in">MIN</span> DEG QUOT TRANSFORM  *******             <span class="number">3.</span></span><br><span class="line">C*************************************************************             <span class="number">4.</span></span><br><span class="line">C*************************************************************             <span class="number">5.</span></span><br><span class="line"><span class="comment">C                                                                          6.</span></span><br><span class="line"><span class="comment">C     PURPOSE - THIS SUBROUTINE PERFORMS THE QUOTIENT GRAPH                7.</span></span><br><span class="line"><span class="comment">C        TRANSFORMATION AFTER A NODE HAS BEEN ELIMINATED.                  8.</span></span><br><span class="line"><span class="comment">C                                                                          9.</span></span><br><span class="line"><span class="comment">C     INPUT PARAMETERS -                                                  10.</span></span><br><span class="line"><span class="comment">C        ROOT - THE NODE JUST ELIMINATED. IT BECOMES THE                  11.</span></span><br><span class="line"><span class="comment">C               REPRESENTATIVE OF THE NEW SUPERNODE.                      12.</span></span><br><span class="line"><span class="comment">C        (XADJ, ADJNCY) - THE ADJACENCY STRUCTURE.                        13.</span></span><br><span class="line"><span class="comment">C        (RCHSZE, RCHSET) - THE REACHABLE SET OF ROOT IN THE              14.</span></span><br><span class="line"><span class="comment">C               OLD QUOTIENT GRAPH.                                       15.</span></span><br><span class="line"><span class="comment">C        NBRHD - THE NEIGHBORHOOD SET WHICH WILL BE MERGED                16.</span></span><br><span class="line"><span class="comment">C               WITH ROOT TO FORM THE NEW SUPERNODE.                      17.</span></span><br><span class="line"><span class="comment">C        MARKER - THE MARKER VECTOR.                                      18.</span></span><br><span class="line"><span class="comment">C                                                                         19.</span></span><br><span class="line"><span class="comment">C     UPDATED PARAMETER -                                                 20.</span></span><br><span class="line"><span class="comment">C        ADJNCY - BECOMES THE ADJNCY OF THE QUOTIENT GRAPH.               21.</span></span><br><span class="line"><span class="comment">C                                                                         22.</span></span><br><span class="line">C*************************************************************            <span class="number">23.</span></span><br><span class="line"><span class="comment">C                                                                         24.</span></span><br><span class="line">      <span class="function"><span class="keyword">SUBROUTINE</span></span>  QMDQT ( ROOT, XADJ, ADJNCY, MARKER,                     <span class="number">25.</span></span><br><span class="line">     <span class="number">1</span>                    RCHSZE, RCHSET, NBRHD )                         <span class="number">26.</span></span><br><span class="line"><span class="comment">C                                                                         27.</span></span><br><span class="line">C*************************************************************            <span class="number">28.</span></span><br><span class="line"><span class="comment">C                                                                         29.</span></span><br><span class="line">         <span class="keyword">INTEGER</span> ADJNCY(<span class="number">1</span>), MARKER(<span class="number">1</span>), RCHSET(<span class="number">1</span>), NBRHD(<span class="number">1</span>)                <span class="number">30.</span></span><br><span class="line">         <span class="keyword">INTEGER</span> XADJ(<span class="number">1</span>), INHD, IRCH, J, JSTRT, JSTOP, LINK,              <span class="number">31.</span></span><br><span class="line">     <span class="number">1</span>           NABOR, NODE, RCHSZE, ROOT                                <span class="number">32.</span></span><br><span class="line"><span class="comment">C                                                                         33.</span></span><br><span class="line">C*************************************************************            <span class="number">34.</span></span><br><span class="line"><span class="comment">C                                                                         35.</span></span><br><span class="line">         IRCH = <span class="number">0</span>                                                         <span class="number">36.</span></span><br><span class="line">         INHD = <span class="number">0</span>                                                         <span class="number">37.</span></span><br><span class="line">         NODE = ROOT                                                      <span class="number">38.</span></span><br><span class="line">  <span class="number">100</span>    JSTRT = XADJ(NODE)                                               <span class="number">39.</span></span><br><span class="line">         JSTOP = XADJ(NODE+<span class="number">1</span>) - <span class="number">2</span>                                         <span class="number">40.</span></span><br><span class="line">         <span class="keyword">IF</span> ( JSTOP .LT. JSTRT )  GO TO <span class="number">300</span>                               <span class="number">41.</span></span><br><span class="line"><span class="comment">C           ------------------------------------------------              42.</span></span><br><span class="line"><span class="comment">C           PLACE REACH NODES INTO THE ADJACENT LIST OF NODE              43.</span></span><br><span class="line"><span class="comment">C           ------------------------------------------------              44.</span></span><br><span class="line">            <span class="keyword">DO</span> <span class="number">200</span> J = JSTRT, JSTOP                                       <span class="number">45.</span></span><br><span class="line">               IRCH = IRCH + <span class="number">1</span>                                            <span class="number">46.</span></span><br><span class="line">               ADJNCY(J) = RCHSET(IRCH)                                   <span class="number">47.</span></span><br><span class="line">               <span class="keyword">IF</span> ( IRCH .GE. RCHSZE )  <span class="keyword">GOTO</span> <span class="number">400</span>                          <span class="number">48.</span></span><br><span class="line">  <span class="number">200</span>       <span class="keyword">CONTINUE</span>                                                      <span class="number">49.</span></span><br><span class="line"><span class="comment">C        ----------------------------------------------                   50.</span></span><br><span class="line"><span class="comment">C        LINK TO OTHER SPACE PROVIDED BY THE NBRHD SET.                   51.</span></span><br><span class="line"><span class="comment">C        ----------------------------------------------                   52.</span></span><br><span class="line">  <span class="number">300</span>    LINK = ADJNCY(JSTOP+<span class="number">1</span>)                                           <span class="number">53.</span></span><br><span class="line">         NODE = - LINK                                                    <span class="number">54.</span></span><br><span class="line">         <span class="keyword">IF</span> ( LINK .LT. <span class="number">0</span> )  <span class="keyword">GOTO</span> <span class="number">100</span>                                     <span class="number">55.</span></span><br><span class="line">            INHD = INHD + <span class="number">1</span>                                               <span class="number">56.</span></span><br><span class="line">            NODE = NBRHD(INHD)                                            <span class="number">57.</span></span><br><span class="line">            ADJNCY(JSTOP+<span class="number">1</span>) = - NODE                                      <span class="number">58.</span></span><br><span class="line">            GO TO <span class="number">100</span>                                                     <span class="number">59.</span></span><br><span class="line"><span class="comment">C        -------------------------------------------------------          60.</span></span><br><span class="line"><span class="comment">C        ALL REACHABLE NODES HAVE BEEN SAVED.  END THE ADJ LIST.          61.</span></span><br><span class="line"><span class="comment">C        ADD ROOT TO THE NBR LIST OF EACH NODE IN THE REACH SET.          62.</span></span><br><span class="line"><span class="comment">C        -------------------------------------------------------          63.</span></span><br><span class="line">  <span class="number">400</span>    ADJNCY(J+<span class="number">1</span>) = <span class="number">0</span>                                                  <span class="number">64.</span></span><br><span class="line">         <span class="keyword">DO</span> <span class="number">600</span> IRCH = <span class="number">1</span>, RCHSZE                                          <span class="number">65.</span></span><br><span class="line">            NODE = RCHSET(IRCH)                                           <span class="number">66.</span></span><br><span class="line">            <span class="keyword">IF</span> ( MARKER(NODE) .LT. <span class="number">0</span> )  <span class="keyword">GOTO</span> <span class="number">600</span>                          <span class="number">67.</span></span><br><span class="line">               JSTRT = XADJ(NODE)                                         <span class="number">68.</span></span><br><span class="line">               JSTOP = XADJ(NODE+<span class="number">1</span>) - <span class="number">1</span>                                   <span class="number">69.</span></span><br><span class="line">               <span class="keyword">DO</span> <span class="number">500</span> J = JSTRT, JSTOP                                    <span class="number">70.</span></span><br><span class="line">                  NABOR = ADJNCY(J)                                       <span class="number">71.</span></span><br><span class="line">                  <span class="keyword">IF</span> ( MARKER(NABOR) .GE. <span class="number">0</span> ) GO TO <span class="number">500</span>                   <span class="number">72.</span></span><br><span class="line">                     ADJNCY(J) = ROOT                                     <span class="number">73.</span></span><br><span class="line">                     <span class="keyword">GOTO</span> <span class="number">600</span>                                             <span class="number">74.</span></span><br><span class="line">  <span class="number">500</span>          <span class="keyword">CONTINUE</span>                                                   <span class="number">75.</span></span><br><span class="line">  <span class="number">600</span>    <span class="keyword">CONTINUE</span>                                                         <span class="number">76.</span></span><br><span class="line">         <span class="keyword">RETURN</span>                                                           <span class="number">77.</span></span><br><span class="line">      <span class="keyword">END</span>                                                                 <span class="number">78.</span></span><br></pre></td></tr></table></figure>
<p>下面开始逐行解析脚本，首先开始初始化，这里 <code>JSTOP = XADJ(NODE+1) - 2</code> 是将 ROOT 的相邻列表中的最后一个位置空出来不用。如果 <code>JSTOP .LT. JSTRT</code> ，那么说明 ROOT 的相邻列表中只有一个位置，那么要利用其 NBRHD 列表中其它 supernode 的空间，<code>GO TO 300</code> 。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">       IRCH = <span class="number">0</span>                                                         <span class="number">36.</span></span><br><span class="line">       INHD = <span class="number">0</span>                                                         <span class="number">37.</span></span><br><span class="line">       NODE = ROOT                                                      <span class="number">38.</span></span><br><span class="line"><span class="number">100</span>    JSTRT = XADJ(NODE)                                               <span class="number">39.</span></span><br><span class="line">       JSTOP = XADJ(NODE+<span class="number">1</span>) - <span class="number">2</span>                                         <span class="number">40.</span></span><br><span class="line">       <span class="keyword">IF</span> ( JSTOP .LT. JSTRT )  GO TO <span class="number">300</span>            </span><br></pre></td></tr></table></figure>
<p>下一步我们将 NODE 在旧商图中的相邻集合 RCHSET 中的节点放置到这些位置上。</p>
<p>如果 <code>IRCH .GE. RCHSZE</code> ，那就说明 NODE  的相邻列表空间已经足够存放 RCHSET 中的节点了，不需要利用其 NBRHD 列表中其它节点的空间，那么直接 <code>GO TO 400</code> 。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">          <span class="keyword">DO</span> <span class="number">200</span> J = JSTRT, JSTOP                                       <span class="number">45.</span></span><br><span class="line">             IRCH = IRCH + <span class="number">1</span>                                            <span class="number">46.</span></span><br><span class="line">             ADJNCY(J) = RCHSET(IRCH)                                   <span class="number">47.</span></span><br><span class="line">             <span class="keyword">IF</span> ( IRCH .GE. RCHSZE )  <span class="keyword">GOTO</span> <span class="number">400</span>                          <span class="number">48.</span></span><br><span class="line"><span class="number">200</span>       <span class="keyword">CONTINUE</span>                                                      <span class="number">49.</span></span><br></pre></td></tr></table></figure>
<p>如果 NODE 的空间不够用，那么利用 NBRHD 列表中其它已经消元的 supernode 的空间。</p>
<p>首先<code>LINK = ADJNCY(JSTOP+1)</code> ，将 NODE 相邻列表的最后一个位置设为链接。<code>NODE = - LINK</code> 先将 <code>NODE</code> 设为 <code>- LINK</code> 。如果 LINK 小于 0 ，说明这个位置是一个链接，那么直接 <code>GOTO 100</code> (这在 ROOT 节点是不可能的，ROOT 节点最后一个位置不可能是链接。这是用于 NBRHD 中的节点的，如果这个节点是一个 supernode ,这些节点最后一个位置可能是链接)。</p>
<p>不然地话，INHD  加1，<code>NODE = NBRHD(INHD)</code> 将 NODE 修改为 NBRHD 的节点。<code>ADJNCY(JSTOP+1) = - NODE</code> 将 ROOT 最后一个位置改为 - NODE，然后<code>GO TO 100</code> ，利用其空间存放剩余的 RCHSET 中的节点（同样最后一个位置如果已经是链接则继续循环，不然最后一个位置改为链接，放 NBRHD 下一个节点的负数）。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">300</span>    LINK = ADJNCY(JSTOP+<span class="number">1</span>)                                           <span class="number">53.</span></span><br><span class="line">       NODE = - LINK                                                    <span class="number">54.</span></span><br><span class="line">       <span class="keyword">IF</span> ( LINK .LT. <span class="number">0</span> )  <span class="keyword">GOTO</span> <span class="number">100</span>                                     <span class="number">55.</span></span><br><span class="line">          INHD = INHD + <span class="number">1</span>                                               <span class="number">56.</span></span><br><span class="line">          NODE = NBRHD(INHD)                                            <span class="number">57.</span></span><br><span class="line">          ADJNCY(JSTOP+<span class="number">1</span>) = - NODE                                      <span class="number">58.</span></span><br><span class="line">          GO TO <span class="number">100</span>                                                     <span class="number">59.</span></span><br></pre></td></tr></table></figure>
<p>循环结束之后，RCHSET 中的所有节点均存放好了。</p>
<p><code>ADJNCY(J+1) = 0</code> 将RCHSET 存放的最后一个位置之后的一个位置设为0，表示RCHSET  节点的<strong>终止位置</strong>。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">400</span>    ADJNCY(J+<span class="number">1</span>) = <span class="number">0</span>                                                  <span class="number">64.</span></span><br></pre></td></tr></table></figure>
<p>反过来，将 RCHSET 中的所有节点的列表中添加 ROOT 节点。</p>
<p><code>DO 600</code> 循环遍历 RCHSET 的每一个节点，设为 NODE 。如果 NODE 的 MARKER 值低于0，那么说明这个节点已经合并到其它不可区分的节点中了，直接跳过这个节点。不然的话，<code>DO 500</code> 循环遍历 NODE 节点的所有相邻节点，设为 NABOR ；如果 NABOR 的 MARKER 值大于等于0，跳过这个节点。如果 NABOR 的 MARKER 值小于0（如果 NABOR 原来是消元节点，那么就说明 NABOR 和 ROOT 合并了；如果 NABOR 原来是未消元的节点，那么这个节点已经合并到其它不可区分的节点中了。无论是哪种情况，此时这个 NABOR 都可以修改了），那么将其修改为 ROOT ，然后跳出循环， <code>GO TO 600</code> ，运行下一个节点。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">       <span class="keyword">DO</span> <span class="number">600</span> IRCH = <span class="number">1</span>, RCHSZE                                          <span class="number">65.</span></span><br><span class="line">          NODE = RCHSET(IRCH)                                           <span class="number">66.</span></span><br><span class="line">          <span class="keyword">IF</span> ( MARKER(NODE) .LT. <span class="number">0</span> )  <span class="keyword">GOTO</span> <span class="number">600</span>                          <span class="number">67.</span></span><br><span class="line">             JSTRT = XADJ(NODE)                                         <span class="number">68.</span></span><br><span class="line">             JSTOP = XADJ(NODE+<span class="number">1</span>) - <span class="number">1</span>                                   <span class="number">69.</span></span><br><span class="line">             <span class="keyword">DO</span> <span class="number">500</span> J = JSTRT, JSTOP                                    <span class="number">70.</span></span><br><span class="line">                NABOR = ADJNCY(J)                                       <span class="number">71.</span></span><br><span class="line">                <span class="keyword">IF</span> ( MARKER(NABOR) .GE. <span class="number">0</span> ) GO TO <span class="number">500</span>                   <span class="number">72.</span></span><br><span class="line">                   ADJNCY(J) = ROOT                                     <span class="number">73.</span></span><br><span class="line">                   <span class="keyword">GOTO</span> <span class="number">600</span>                                             <span class="number">74.</span></span><br><span class="line"><span class="number">500</span>          <span class="keyword">CONTINUE</span>                                                   <span class="number">75.</span></span><br><span class="line"><span class="number">600</span>    <span class="keyword">CONTINUE</span>                                                         <span class="number">76.</span></span><br><span class="line">       <span class="keyword">RETURN</span>                                                           <span class="number">77.</span></span><br><span class="line">    <span class="keyword">END</span>                                                                 <span class="number">78.</span></span><br></pre></td></tr></table></figure>
<p>其实，这里只将第一个可以修改的节点中改为 ROOT ，就完成了添加 ROOT 节点的任务，实际上此时  NODE 的    商图相邻位点中可能有重复的 ROOT 节点或其它可以删除的位点（MARKER 值小于0）。</p>
<p>以下图从  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7B5%7D" style="display:inline-block;margin: 0;"/> 到 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7B6%7D" style="display:inline-block;margin: 0;"/> 的形成过程中，节点 8 原始相邻节点为 5,3,6,9，按照上面的脚本遍历，第一个相邻节点 5 的 MARKER 值为 -1，改为 6 ，然后退出循环，因此<strong>节点 8 修改后的相邻列表实际为 6,3,6,9</strong>，存在重复的 ROOT 节点 6，并不是下面的 3,6,9 。</p>
<p><img src="74.png" alt="74"></p>
<h1>参考文献</h1>
<ol>
<li>George A, Liu J, Ng E. Computer solution of sparse linear systems[J]. Oak Ridge National Laboratory, 1994.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>稀疏矩阵</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>稀疏矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏矩阵算法最小度数算法五之最小度数算法子程序QMDRCH</title>
    <url>/posts/cbfa6df5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本章节介绍 <em>the minimum degree algorithm</em> ，我个人将其翻译为最小度数算法。这里我们看最小度数算法的子程序 QMDRCH。</p>
<span id="more"></span>
<h1>QMDRCH</h1>
<p><strong>(Quotient MD Reachable set)</strong> ，这个子程序用于查找一个给定节点 ROOT 通过已经消元的节点的 <em>reachable set</em> 。这里使用的相邻结构必须已经是之前提到的商图结构。</p>
<p>输出的 <em>reachable set</em> 存储在向量 <strong>RCHSET</strong> 中，其大于为 RCHSZE 。作为一个副产品，邻近 ROOT 的已经消元的 supernode 放在 <strong>NBRHD</strong>  中，其大小为 NHDSZE 。则两个集合中的节点其 MARKER 值均会设为非零值。</p>
<p>这个子程序完全就是之前提到的算法的实现，如下图。</p>
<p><img src="67.png" alt="1"></p>
<p>脚本如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">C***************************************************************           <span class="number">1.</span></span><br><span class="line">C***************************************************************           <span class="number">2.</span></span><br><span class="line">C*********     QMDRCH ..... QUOT <span class="built_in">MIN</span> DEG REACH SET    **********           <span class="number">3.</span></span><br><span class="line">C***************************************************************           <span class="number">4.</span></span><br><span class="line">C***************************************************************           <span class="number">5.</span></span><br><span class="line"><span class="comment">C                                                                          6.</span></span><br><span class="line"><span class="comment">C     PURPOSE - THIS SUBROUTINE DETERMINES THE REACHABLE SET OF            7.</span></span><br><span class="line"><span class="comment">C        A NODE THROUGH A GIVEN SUBSET.  THE ADJACENCY STRUCTURE           8.</span></span><br><span class="line"><span class="comment">C        IS ASSUMED TO BE STORED IN A QUOTIENT GRAPH FORMAT.               9.</span></span><br><span class="line"><span class="comment">C                                                                         10.</span></span><br><span class="line"><span class="comment">C     INPUT PARAMETERS -                                                  11.</span></span><br><span class="line"><span class="comment">C        ROOT - THE GIVEN NODE NOT IN THE SUBSET.                         12.</span></span><br><span class="line"><span class="comment">C        (XADJ, ADJNCY) - THE ADJACENCY STRUCTURE PAIR.                   13.</span></span><br><span class="line"><span class="comment">C        DEG - THE DEGREE VECTOR.  DEG(I) LT 0 MEANS THE NODE             14.</span></span><br><span class="line"><span class="comment">C               BELONGS TO THE GIVEN SUBSET.                              15.</span></span><br><span class="line"><span class="comment">C                                                                         16.</span></span><br><span class="line"><span class="comment">C     OUTPUT PARAMETERS -                                                 17.</span></span><br><span class="line"><span class="comment">C        (RCHSZE, RCHSET) - THE REACHABLE SET.                            18.</span></span><br><span class="line"><span class="comment">C        (NHDSZE, NBRHD) - THE NEIGHBORHOOD SET.                          19.</span></span><br><span class="line"><span class="comment">C                                                                         20.</span></span><br><span class="line"><span class="comment">C     UPDATED PARAMETERS -                                                21.</span></span><br><span class="line"><span class="comment">C        MARKER - THE MARKER VECTOR FOR REACH AND NBRHD SETS.             22.</span></span><br><span class="line"><span class="comment">C               GT 0 MEANS THE NODE IS IN REACH SET.                      23.</span></span><br><span class="line"><span class="comment">C               LT 0 MEANS THE NODE HAS BEEN MERGED WITH                  24.</span></span><br><span class="line"><span class="comment">C               OTHERS IN THE QUOTIENT OR IT IS IN NBRHD SET.             25.</span></span><br><span class="line"><span class="comment">C                                                                         26.</span></span><br><span class="line">C***************************************************************          <span class="number">27.</span></span><br><span class="line"><span class="comment">C                                                                         28.</span></span><br><span class="line">      <span class="function"><span class="keyword">SUBROUTINE</span></span>  QMDRCH ( ROOT, XADJ, ADJNCY, DEG, MARKER,               <span class="number">29.</span></span><br><span class="line">     <span class="number">1</span>                     RCHSZE, RCHSET, NHDSZE, NBRHD )                <span class="number">30.</span></span><br><span class="line"><span class="comment">C                                                                         31.</span></span><br><span class="line">C***************************************************************          <span class="number">32.</span></span><br><span class="line"><span class="comment">C                                                                         33.</span></span><br><span class="line">         <span class="keyword">INTEGER</span> ADJNCY(<span class="number">1</span>), DEG(<span class="number">1</span>), MARKER(<span class="number">1</span>),                            <span class="number">34.</span></span><br><span class="line">     <span class="number">1</span>           RCHSET(<span class="number">1</span>), NBRHD(<span class="number">1</span>)                                      <span class="number">35.</span></span><br><span class="line">         <span class="keyword">INTEGER</span> XADJ(<span class="number">1</span>), I, ISTRT, ISTOP, J, JSTRT, JSTOP,               <span class="number">36.</span></span><br><span class="line">     <span class="number">1</span>           NABOR, NHDSZE, NODE, RCHSZE, ROOT                        <span class="number">37.</span></span><br><span class="line"><span class="comment">C                                                                         38.</span></span><br><span class="line">C***************************************************************          <span class="number">39.</span></span><br><span class="line"><span class="comment">C                                                                         40.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------                        41.</span></span><br><span class="line"><span class="comment">C        LOOP THROUGH THE NEIGHBORS OF ROOT IN THE                        42.</span></span><br><span class="line"><span class="comment">C        QUOTIENT GRAPH.                                                  43.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------                        44.</span></span><br><span class="line">         NHDSZE = <span class="number">0</span>                                                       <span class="number">45.</span></span><br><span class="line">         RCHSZE = <span class="number">0</span>                                                       <span class="number">46.</span></span><br><span class="line">         ISTRT = XADJ(ROOT)                                               <span class="number">47.</span></span><br><span class="line">         ISTOP = XADJ(ROOT+<span class="number">1</span>) - <span class="number">1</span>                                         <span class="number">48.</span></span><br><span class="line">         <span class="keyword">IF</span> ( ISTOP .LT. ISTRT )  <span class="keyword">RETURN</span>                                  <span class="number">49.</span></span><br><span class="line">            <span class="keyword">DO</span> <span class="number">600</span> I = ISTRT, ISTOP                                       <span class="number">50.</span></span><br><span class="line">               NABOR =  ADJNCY(I)                                         <span class="number">51.</span></span><br><span class="line">               <span class="keyword">IF</span> ( NABOR .EQ. <span class="number">0</span> ) <span class="keyword">RETURN</span>                                 <span class="number">52.</span></span><br><span class="line">               <span class="keyword">IF</span> ( MARKER(NABOR) .NE. <span class="number">0</span> )  GO TO <span class="number">600</span>                     <span class="number">53.</span></span><br><span class="line">                  <span class="keyword">IF</span> ( DEG(NABOR) .LT. <span class="number">0</span> )     GO TO <span class="number">200</span>                  <span class="number">54.</span></span><br><span class="line"><span class="comment">C                    -------------------------------------                55.</span></span><br><span class="line"><span class="comment">C                    INCLUDE NABOR INTO THE REACHABLE SET.                56.</span></span><br><span class="line"><span class="comment">C                    -------------------------------------                57.</span></span><br><span class="line">                     RCHSZE = RCHSZE + <span class="number">1</span>                                  <span class="number">58.</span></span><br><span class="line">                     RCHSET(RCHSZE) = NABOR                               <span class="number">59.</span></span><br><span class="line">                     MARKER(NABOR) = <span class="number">1</span>                                    <span class="number">60.</span></span><br><span class="line">                     GO TO <span class="number">600</span>                                            <span class="number">61.</span></span><br><span class="line"><span class="comment">C                 -------------------------------------                   62.</span></span><br><span class="line"><span class="comment">C                 NABOR HAS BEEN ELIMINATED. FIND NODES                   63.</span></span><br><span class="line"><span class="comment">C                 REACHABLE FROM IT.                                      64.</span></span><br><span class="line"><span class="comment">C                 -------------------------------------                   65.</span></span><br><span class="line">  <span class="number">200</span>             MARKER(NABOR) = -<span class="number">1</span>                                      <span class="number">66.</span></span><br><span class="line">                  NHDSZE = NHDSZE +  <span class="number">1</span>                                    <span class="number">67.</span></span><br><span class="line">                  NBRHD(NHDSZE) = NABOR                                   <span class="number">68.</span></span><br><span class="line">  <span class="number">300</span>             JSTRT = XADJ(NABOR)                                     <span class="number">69.</span></span><br><span class="line">                  JSTOP = XADJ(NABOR+<span class="number">1</span>) - <span class="number">1</span>                               <span class="number">70.</span></span><br><span class="line">                  <span class="keyword">DO</span> <span class="number">500</span> J = JSTRT, JSTOP                                 <span class="number">71.</span></span><br><span class="line">                     NODE = ADJNCY(J)                                     <span class="number">72.</span></span><br><span class="line">                     NABOR = - NODE                                       <span class="number">73.</span></span><br><span class="line">                     <span class="keyword">IF</span> (NODE) <span class="number">300</span>, <span class="number">600</span>, <span class="number">400</span>                              <span class="number">74.</span></span><br><span class="line">  <span class="number">400</span>                <span class="keyword">IF</span> ( MARKER(NODE) .NE. <span class="number">0</span> )  GO TO <span class="number">500</span>                <span class="number">75.</span></span><br><span class="line">                        RCHSZE = RCHSZE + <span class="number">1</span>                               <span class="number">76.</span></span><br><span class="line">                        RCHSET(RCHSZE) = NODE                             <span class="number">77.</span></span><br><span class="line">                        MARKER(NODE) = <span class="number">1</span>                                  <span class="number">78.</span></span><br><span class="line">  <span class="number">500</span>             <span class="keyword">CONTINUE</span>                                                <span class="number">79.</span></span><br><span class="line">  <span class="number">600</span>       <span class="keyword">CONTINUE</span>                                                      <span class="number">80.</span></span><br><span class="line">            <span class="keyword">RETURN</span>                                                        <span class="number">81.</span></span><br><span class="line">      <span class="keyword">END</span>                                                                 <span class="number">82.</span></span><br></pre></td></tr></table></figure>
<p>现在开始逐行分析脚本。</p>
<p><code>DO 600</code> 会遍历 ROOT 在商图中的相邻节点，<strong>如果相邻节点 NABOR 为0，说明已经到了相邻列表的终点</strong> 。如果相邻节点 NABOR 的 MARKER 值不为0，说明这个节点合并到其它节点中或者已经在 reachable set 中了，因此直接跳过这个节点，<code>GO TO 600</code> 。</p>
<p>如果相邻节点 NABOR 的 DEG 值低于0，说明这个节点是已经消除的 supernode, 那么 <code>GO TO 200</code> ，将 NABOR 节点的相邻节点加到  reachable set 中</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C        -----------------------------------------                        41.</span></span><br><span class="line"><span class="comment">C        LOOP THROUGH THE NEIGHBORS OF ROOT IN THE                        42.</span></span><br><span class="line"><span class="comment">C        QUOTIENT GRAPH.                                                  43.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------                        44.</span></span><br><span class="line">         NHDSZE = <span class="number">0</span>                                                       <span class="number">45.</span></span><br><span class="line">         RCHSZE = <span class="number">0</span>                                                       <span class="number">46.</span></span><br><span class="line">         ISTRT = XADJ(ROOT)                                               <span class="number">47.</span></span><br><span class="line">         ISTOP = XADJ(ROOT+<span class="number">1</span>) - <span class="number">1</span>                                         <span class="number">48.</span></span><br><span class="line">         <span class="keyword">IF</span> ( ISTOP .LT. ISTRT )  <span class="keyword">RETURN</span>                                  <span class="number">49.</span></span><br><span class="line">            <span class="keyword">DO</span> <span class="number">600</span> I = ISTRT, ISTOP                                       <span class="number">50.</span></span><br><span class="line">               NABOR =  ADJNCY(I)                                         <span class="number">51.</span></span><br><span class="line">               <span class="keyword">IF</span> ( NABOR .EQ. <span class="number">0</span> ) <span class="keyword">RETURN</span>                                 <span class="number">52.</span></span><br><span class="line">               <span class="keyword">IF</span> ( MARKER(NABOR) .NE. <span class="number">0</span> )  GO TO <span class="number">600</span>                     <span class="number">53.</span></span><br><span class="line">                  <span class="keyword">IF</span> ( DEG(NABOR) .LT. <span class="number">0</span> )     GO TO <span class="number">200</span>                  <span class="number">54.</span></span><br></pre></td></tr></table></figure>
<p>如果 NABOR 的 MARKER 值为 0，并且 DEG 值大于等于0，那么就直接将 NABOR 加入到 reachable set 中，最后将其 MARKER 值改为 1，然后 <code>GO TO 600</code>。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C                    -------------------------------------                55.</span></span><br><span class="line"><span class="comment">C                    INCLUDE NABOR INTO THE REACHABLE SET.                56.</span></span><br><span class="line"><span class="comment">C                    -------------------------------------                57.</span></span><br><span class="line">                     RCHSZE = RCHSZE + <span class="number">1</span>                                  <span class="number">58.</span></span><br><span class="line">                     RCHSET(RCHSZE) = NABOR                               <span class="number">59.</span></span><br><span class="line">                     MARKER(NABOR) = <span class="number">1</span>                                    <span class="number">60.</span></span><br><span class="line">                     GO TO <span class="number">600</span>                                            <span class="number">61.</span></span><br></pre></td></tr></table></figure>
<p>接下来是  <code>GO TO 200</code>  之后的语句，需要将   NABOR 节点的相邻节点加到  reachable set 中。</p>
<p>将 NABOR 加入到 NBRHD 中，并将其 MARKER 值改为 -1（因为这些节点会合并到 ROOT 中，因此属于要合并的节点，其 MARKER 值改为负数） 。</p>
<p>JSTRT 和 JSTOP 是 NABOR 的相邻列表的第一个位置和最后一个位置。注意这里 NABOR  是已经消元的 supernode ，其在商图中的相邻列表如果不够放，最后一个位置会是链接（负数），最后一个相邻位点之后一个位置为 0 。</p>
<p>因此，<code>IF (NODE) 300, 600, 400</code> ，这是一条<strong>算术 IF 语句</strong>，会判断 NODE 的符号，根据算术表达式的结果来决定程序执行的转移，如果 NODE &lt; 0 ，则 <code>GO TO 300</code> ，此时 NODE 是下一个节点的链接，<code>NABOR = - NODE</code> ，继续遍历相邻节点 ; 如果 NODE = 0 ，则 <code>GO TO 600</code> ，说明此时已经找完所有相邻节点; 如果 NODE &gt; 0 则 <code>GO TO 400</code>，正常向下运行 。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C                 -------------------------------------                   62.</span></span><br><span class="line"><span class="comment">C                 NABOR HAS BEEN ELIMINATED. FIND NODES                   63.</span></span><br><span class="line"><span class="comment">C                 REACHABLE FROM IT.                                      64.</span></span><br><span class="line"><span class="comment">C                 -------------------------------------                   65.</span></span><br><span class="line">  <span class="number">200</span>             MARKER(NABOR) = -<span class="number">1</span>                                      <span class="number">66.</span></span><br><span class="line">                  NHDSZE = NHDSZE +  <span class="number">1</span>                                    <span class="number">67.</span></span><br><span class="line">                  NBRHD(NHDSZE) = NABOR                                   <span class="number">68.</span></span><br><span class="line">  <span class="number">300</span>             JSTRT = XADJ(NABOR)                                     <span class="number">69.</span></span><br><span class="line">                  JSTOP = XADJ(NABOR+<span class="number">1</span>) - <span class="number">1</span>                               <span class="number">70.</span></span><br><span class="line">                  <span class="keyword">DO</span> <span class="number">500</span> J = JSTRT, JSTOP                                 <span class="number">71.</span></span><br><span class="line">                     NODE = ADJNCY(J)                                     <span class="number">72.</span></span><br><span class="line">                     NABOR = - NODE                                       <span class="number">73.</span></span><br><span class="line">                     <span class="keyword">IF</span> (NODE) <span class="number">300</span>, <span class="number">600</span>, <span class="number">400</span>                              <span class="number">74.</span></span><br><span class="line">  <span class="number">400</span>                <span class="keyword">IF</span> ( MARKER(NODE) .NE. <span class="number">0</span> )  GO TO <span class="number">500</span>                <span class="number">75.</span></span><br><span class="line">                        RCHSZE = RCHSZE + <span class="number">1</span>                               <span class="number">76.</span></span><br><span class="line">                        RCHSET(RCHSZE) = NODE                             <span class="number">77.</span></span><br><span class="line">                        MARKER(NODE) = <span class="number">1</span>                                  <span class="number">78.</span></span><br><span class="line">  <span class="number">500</span>             <span class="keyword">CONTINUE</span>                                                <span class="number">79.</span></span><br><span class="line">  <span class="number">600</span>       <span class="keyword">CONTINUE</span>                                                      <span class="number">80.</span></span><br><span class="line">            <span class="keyword">RETURN</span>                                                        <span class="number">81.</span></span><br><span class="line">      <span class="keyword">END</span>                                                                 <span class="number">82.</span></span><br></pre></td></tr></table></figure>
<h1>参考文献</h1>
<ol>
<li>George A, Liu J, Ng E. Computer solution of sparse linear systems[J]. Oak Ridge National Laboratory, 1994.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>稀疏矩阵</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>稀疏矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏矩阵算法最小度数算法四之最小度数算法主程序</title>
    <url>/posts/e0c9e6c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本章节介绍 <em>the minimum degree algorithm</em> ，我个人将其翻译为最小度数算法。这里我们看最小度数算法的主程序部分。</p>
<span id="more"></span>
<h1>最小度数算法的实施</h1>
<p>在最小度数算法的实施过程中，不可区分的节点会视为一个 <em>supernode</em> 。注意此时我们有两种不同情况下的 <em>supernode</em>，一个是消元过程中已经消元的连接起来的节点组成的 <em>supernode</em> ，一个是上面提到的不可区分的节点组成的 <em>supernode</em> 。</p>
<p>下图就是对于这两种 <em>supernode</em> 的说明，它是对图 5.4.5 中的图是如何通过两种商图存储的，其中的阴影的双层圆圈表示已经消元的节点组成的<em>supernodes</em> ，而空白的双层圆圈表示不可区分的节点组成的 <em>supernodes</em> 。</p>
<p><img src="84.png" alt="1"></p>
<p>我们现在会讨论如何实施这个算法的脚本，其输入为图的结构 <strong>(XADJ, ADJNCY)</strong> 和方程数目 <strong>NEQNS</strong> ，输出为 <strong>PERM</strong> 和 <strong>INVP</strong> 。</p>
<p>这个子程序要求一些临时向量来实施商图模型和不可区分的节点。当前消元图中所有节点的度数存储在数组 <strong>DEG</strong> 中，其中已经被消除的节点的 DEG 值会设为 -1 。</p>
<p>在商图模型中，连通的已经消除的节点会合并为一个 <em>supernode</em> ，此时我们需要挑出一个节点作为 <em>supernode</em> 的代表。如果 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%28C%29" style="display:inline-block;margin: 0;"/> 就是这样一个连通组分，我们通常会选择 <img src="https://math.now.sh?inline=C" style="display:inline-block;margin: 0;"/> 中最后消除的节点作为 <img src="https://math.now.sh?inline=C" style="display:inline-block;margin: 0;"/> 的代表，其它节点不再使用。</p>
<p>同样地，对于未消除的不可区分的节点，也会挑出一个节点作为代表，其它节点不再使用。</p>
<p>中间向量 <strong>MARKER</strong> 用于标记在相邻结构中可以忽略的节点，这样的节点的 MARKER 值会设为 -1 ，这个向量也会临时用于生成 <em>reachable sets</em> 。<strong>QSIZE</strong> 和 <strong>QLINK</strong> 数组用于指定不可区分的节点，如果节点 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 作为代表，那么在这个 <em>supernode</em> 中的节点数目为 <strong>QSIZE(i)</strong> ，这些节点为</p>
<p style=""><img src="https://math.now.sh?from=i%2C%20QLINK%28i%29%2C%20QLINK(Qlink(i))%2C%5Ccdots%0A" /></p><p>下图说明了 <strong>QSIZE</strong>, <strong>QLINK</strong> 和 <strong>MARKER</strong> 的使用，节点 <img src="https://math.now.sh?inline=%5C%7B2%2C5%2C8%5C%7D" style="display:inline-block;margin: 0;"/> 形成了一个由不可区分的节点组成的 <em>supernode</em> ，其代表为节点 2 。因此节点 5 和 8 的 MARKER 值设置为 -1；节点 <img src="https://math.now.sh?inline=%5C%7B3%2C6%2C9%5C%7D" style="display:inline-block;margin: 0;"/> 形成了一个已经消元的 <em>supernode</em> ，其代表为节点 9 ，因此节点 3 和 6 的 MARKER 值设置为 -1</p>
<p><img src="85.png" alt="1"></p>
<p>这里总共有 5 个子程序，分别为 <strong>GENQMD, QMDRCH, QMDQT, QMDUPD, QMDMRG</strong> ，它们的控制关系见下图。</p>
<p><img src="86.png" alt="1"></p>
<h1>GENQMD</h1>
<p>(General Quotient Minimum Degree algorithm)，这个子程序的目的是对一个<strong>不连通</strong>的图找到其最小度数排序。其输入为图的结构 <strong>(XADJ, ADJNCY)</strong> 和方程数目 <strong>NEQNS</strong> ，输出为 <strong>PERM</strong> 和 <strong>INVP</strong> 。运算过程中， <strong>(XADJ, ADJNCY)</strong> 会被修改，用于存储商图的结构。</p>
<p>这个子程序一开始会初始化中间数组  <strong>QSIZE</strong>, <strong>QLINK</strong>, <strong>MARKER</strong> 和 <strong>DEG</strong> 向量，之后进行到主循环中。在主循环中，子程序首先会通过 <em>threshold searching</em> 找到一个度数最小的节点，其中有两个变量 <strong>THRESH</strong> 和 <strong>MINDEG</strong>，任何当前的度数等于 <strong>THRESH</strong> 的节点均是度数最小的节点。变量 <strong>MINDEG</strong> 保存大于 <strong>THRESH</strong> 的值的最小的度数，并用于更新 <strong>THRESH</strong> 的值。</p>
<p>当找到了一个最小度数的节点 <strong>NODE</strong> ，之后通过调用子程序 <strong>QMDRCH</strong> 来通过已经消除的节点获得 NODE 的 <em>reachable set</em> 。这个集合会存储在向量 <strong>RCHSET</strong> 中，其大小为 RCHSZE。通过 <strong>QLINK</strong> 获得 NODE 的不可区分的节点，并且进行编号和消除。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">C----- <span class="function"><span class="keyword">SUBROUTINE</span></span> GENQMD</span><br><span class="line">C****************************************************************          <span class="number">1.</span></span><br><span class="line">C****************************************************************          <span class="number">2.</span></span><br><span class="line">C**********    GENQMD ..... QUOT <span class="built_in">MIN</span> DEGREE ORDERING    *********          <span class="number">3.</span></span><br><span class="line">C****************************************************************          <span class="number">4.</span></span><br><span class="line">C****************************************************************          <span class="number">5.</span></span><br><span class="line"><span class="comment">C                                                                          6.</span></span><br><span class="line"><span class="comment">C     PURPOSE - THIS ROUTINE IMPLEMENTS THE MINIMUM DEGREE                 7.</span></span><br><span class="line"><span class="comment">C        ALGORITHM.  IT MAKES USE OF THE IMPLICIT REPRESENT-               8.</span></span><br><span class="line"><span class="comment">C        ATION OF THE ELIMINATION GRAPHS BY QUOTIENT GRAPHS,               9.</span></span><br><span class="line"><span class="comment">C        AND THE NOTION OF INDISTINGUISHABLE NODES.                       10.</span></span><br><span class="line"><span class="comment">C        CAUTION - THE ADJACENCY VECTOR ADJNCY WILL BE                    11.</span></span><br><span class="line"><span class="comment">C        DESTROYED.                                                       12.</span></span><br><span class="line"><span class="comment">C                                                                         13.</span></span><br><span class="line"><span class="comment">C     INPUT PARAMETERS -                                                  14.</span></span><br><span class="line"><span class="comment">C        NEQNS - NUMBER OF EQUATIONS.                                     15.</span></span><br><span class="line"><span class="comment">C        (XADJ, ADJNCY) - THE ADJACENCY STRUCTURE.                        16.</span></span><br><span class="line"><span class="comment">C                                                                         17.</span></span><br><span class="line"><span class="comment">C     OUTPUT PARAMETERS -                                                 18.</span></span><br><span class="line"><span class="comment">C        PERM - THE MINIMUM DEGREE ORDERING.                              19.</span></span><br><span class="line"><span class="comment">C        INVP - THE INVERSE OF PERM.                                      20.</span></span><br><span class="line"><span class="comment">C                                                                         21.</span></span><br><span class="line"><span class="comment">C     WORKING PARAMETERS -                                                22.</span></span><br><span class="line"><span class="comment">C        DEG - THE DEGREE VECTOR. DEG(I) IS NEGATIVE MEANS                23.</span></span><br><span class="line"><span class="comment">C               NODE I HAS BEEN NUMBERED.                                 24.</span></span><br><span class="line"><span class="comment">C        MARKER - A MARKER VECTOR, WHERE MARKER(I) IS                     25.</span></span><br><span class="line"><span class="comment">C               NEGATIVE MEANS NODE I HAS BEEN MERGED WITH                26.</span></span><br><span class="line"><span class="comment">C               ANOTHER NODE AND THUS CAN BE IGNORED.                     27.</span></span><br><span class="line"><span class="comment">C        RCHSET - VECTOR USED FOR THE REACHABLE SET.                      28.</span></span><br><span class="line"><span class="comment">C        NBRHD - VECTOR USED FOR THE NEIGHBORHOOD SET.                    29.</span></span><br><span class="line"><span class="comment">C        QSIZE - VECTOR USED TO STORE THE SIZE OF                         30.</span></span><br><span class="line"><span class="comment">C               INDISTINGUISHABLE SUPERNODES.                             31.</span></span><br><span class="line"><span class="comment">C        QLINK - VECTOR TO STORE INDISTINGUISHABLE NODES,                 32.</span></span><br><span class="line"><span class="comment">C               I, QLINK(I), QLINK(QLINK(I)) ... ARE THE                  33.</span></span><br><span class="line"><span class="comment">C               MEMBERS OF THE SUPERNODE REPRESENTED BY I.                34.</span></span><br><span class="line"><span class="comment">C                                                                         35.</span></span><br><span class="line"><span class="comment">C     PROGRAM SUBROUTINES -                                               36.</span></span><br><span class="line"><span class="comment">C        QMDRCH, QMDQT, QMDUPD.                                           37.</span></span><br><span class="line"><span class="comment">C                                                                         38.</span></span><br><span class="line">C****************************************************************         <span class="number">39.</span></span><br><span class="line"><span class="comment">C                                                                         40.</span></span><br><span class="line"><span class="comment">C                                                                         41.</span></span><br><span class="line">      <span class="function"><span class="keyword">SUBROUTINE</span></span>  GENQMD ( NEQNS, XADJ, ADJNCY, PERM, INVP, DEG,          <span class="number">42.</span></span><br><span class="line">     <span class="number">1</span>                     MARKER, RCHSET, NBRHD, QSIZE, QLINK,           <span class="number">43.</span></span><br><span class="line">     <span class="number">1</span>                     NOFSUB )                                       <span class="number">44.</span></span><br><span class="line"><span class="comment">C                                                                         45.</span></span><br><span class="line">C****************************************************************         <span class="number">46.</span></span><br><span class="line"><span class="comment">C                                                                         47.</span></span><br><span class="line">         <span class="keyword">INTEGER</span> ADJNCY(<span class="number">1</span>), PERM(<span class="number">1</span>), INVP(<span class="number">1</span>), DEG(<span class="number">1</span>), MARKER(<span class="number">1</span>),          <span class="number">48.</span></span><br><span class="line">     <span class="number">1</span>           RCHSET(<span class="number">1</span>), NBRHD(<span class="number">1</span>), QSIZE(<span class="number">1</span>), QLINK(<span class="number">1</span>)                  <span class="number">49.</span></span><br><span class="line">         <span class="keyword">INTEGER</span> XADJ(<span class="number">1</span>), INODE, IP, IRCH, J, MINDEG, NDEG,               <span class="number">50.</span></span><br><span class="line">     <span class="number">1</span>           NEQNS, NHDSZE, NODE, NOFSUB, NP, NUM, NUMP1,             <span class="number">51.</span></span><br><span class="line">     <span class="number">1</span>           NXNODE, RCHSZE, SEARCH, THRESH                           <span class="number">52.</span></span><br><span class="line"><span class="comment">C                                                                         53.</span></span><br><span class="line">C****************************************************************         <span class="number">54.</span></span><br><span class="line"><span class="comment">C                                                                         55.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            56.</span></span><br><span class="line"><span class="comment">C        INITIALIZE DEGREE VECTOR AND OTHER WORKING VARIABLES.            57.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            58.</span></span><br><span class="line">         MINDEG = NEQNS                                                   <span class="number">59.</span></span><br><span class="line">         NOFSUB = <span class="number">0</span>                                                       <span class="number">60.</span></span><br><span class="line">         <span class="keyword">DO</span> <span class="number">100</span> NODE = <span class="number">1</span>, NEQNS                                           <span class="number">61.</span></span><br><span class="line">            PERM(NODE) = NODE                                             <span class="number">62.</span></span><br><span class="line">            INVP(NODE) = NODE                                             <span class="number">63.</span></span><br><span class="line">            MARKER(NODE) = <span class="number">0</span>                                              <span class="number">64.</span></span><br><span class="line">            QSIZE(NODE)  = <span class="number">1</span>                                              <span class="number">65.</span></span><br><span class="line">            QLINK(NODE)  = <span class="number">0</span>                                              <span class="number">66.</span></span><br><span class="line">            NDEG = XADJ(NODE+<span class="number">1</span>) - XADJ(NODE)                              <span class="number">67.</span></span><br><span class="line">            DEG(NODE) = NDEG                                              <span class="number">68.</span></span><br><span class="line">            <span class="keyword">IF</span> ( NDEG .LT. MINDEG )  MINDEG = NDEG                        <span class="number">69.</span></span><br><span class="line">  <span class="number">100</span>    <span class="keyword">CONTINUE</span>                                                         <span class="number">70.</span></span><br><span class="line">         NUM = <span class="number">0</span>                                                          <span class="number">71.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            72.</span></span><br><span class="line"><span class="comment">C        PERFORM THRESHOLD SEARCH TO GET A NODE OF MIN DEGREE.            73.</span></span><br><span class="line"><span class="comment">C        VARIABLE SEARCH POINTS TO WHERE SEARCH SHOULD START.             74.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            75.</span></span><br><span class="line">  <span class="number">200</span>    SEARCH = <span class="number">1</span>                                                       <span class="number">76.</span></span><br><span class="line">            THRESH = MINDEG                                               <span class="number">77.</span></span><br><span class="line">            MINDEG = NEQNS                                                <span class="number">78.</span></span><br><span class="line">  <span class="number">300</span>       NUMP1 = NUM + <span class="number">1</span>                                               <span class="number">79.</span></span><br><span class="line">               <span class="keyword">IF</span> ( NUMP1 .GT. SEARCH )  SEARCH = NUMP1                   <span class="number">80.</span></span><br><span class="line">               <span class="keyword">DO</span> <span class="number">400</span> J = SEARCH, NEQNS                                   <span class="number">81.</span></span><br><span class="line">                  NODE = PERM(J)                                          <span class="number">82.</span></span><br><span class="line">                  <span class="keyword">IF</span> ( MARKER(NODE) .LT. <span class="number">0</span> )  <span class="keyword">GOTO</span> <span class="number">400</span>                    <span class="number">83.</span></span><br><span class="line">                     NDEG = DEG(NODE)                                     <span class="number">84.</span></span><br><span class="line">                     <span class="keyword">IF</span> ( NDEG .LE. THRESH )  GO TO <span class="number">500</span>                   <span class="number">85.</span></span><br><span class="line">                     <span class="keyword">IF</span> ( NDEG .LT. MINDEG )  MINDEG =  NDEG              <span class="number">86.</span></span><br><span class="line">  <span class="number">400</span>          <span class="keyword">CONTINUE</span>                                                   <span class="number">87.</span></span><br><span class="line">            GO TO <span class="number">200</span>                                                     <span class="number">88.</span></span><br><span class="line"><span class="comment">C           ---------------------------------------------------           89.</span></span><br><span class="line"><span class="comment">C           NODE HAS MINIMUM DEGREE. FIND ITS REACHABLE SETS BY           90.</span></span><br><span class="line"><span class="comment">C           CALLING QMDRCH.                                               91.</span></span><br><span class="line"><span class="comment">C           ---------------------------------------------------           92.</span></span><br><span class="line">  <span class="number">500</span>       SEARCH = J                                                    <span class="number">93.</span></span><br><span class="line">            NOFSUB = NOFSUB + DEG(NODE)                                   <span class="number">94.</span></span><br><span class="line">            MARKER(NODE) = <span class="number">1</span>                                              <span class="number">95.</span></span><br><span class="line">            <span class="keyword">CALL</span> QMDRCH (NODE, XADJ, ADJNCY, DEG, MARKER,                 <span class="number">96.</span></span><br><span class="line">     <span class="number">1</span>                   RCHSZE, RCHSET, NHDSZE, NBRHD )                  <span class="number">97.</span></span><br><span class="line"><span class="comment">C           ------------------------------------------------              98.</span></span><br><span class="line"><span class="comment">C           ELIMINATE ALL NODES INDISTINGUISHABLE FROM NODE.              99.</span></span><br><span class="line"><span class="comment">C           THEY ARE GIVEN BY NODE, QLINK(NODE), ....                    100.</span></span><br><span class="line"><span class="comment">C           ------------------------------------------------             101.</span></span><br><span class="line">            NXNODE = NODE                                                <span class="number">102.</span></span><br><span class="line">  <span class="number">600</span>       NUM = NUM + <span class="number">1</span>                                                <span class="number">103.</span></span><br><span class="line">               NP  = INVP(NXNODE)                                        <span class="number">104.</span></span><br><span class="line">               IP  = PERM(NUM)                                           <span class="number">105.</span></span><br><span class="line">               PERM(NP) = IP                                             <span class="number">106.</span></span><br><span class="line">               INVP(IP) = NP                                             <span class="number">107.</span></span><br><span class="line">               PERM(NUM) = NXNODE                                        <span class="number">108.</span></span><br><span class="line">               INVP(NXNODE) = NUM                                        <span class="number">109.</span></span><br><span class="line">               DEG(NXNODE) = - <span class="number">1</span>                                         <span class="number">110.</span></span><br><span class="line">               NXNODE = QLINK(NXNODE)                                    <span class="number">111.</span></span><br><span class="line">            <span class="keyword">IF</span> (NXNODE .GT. <span class="number">0</span>) <span class="keyword">GOTO</span> <span class="number">600</span>                                  <span class="number">112.</span></span><br><span class="line"><span class="comment">C                                                                        113.</span></span><br><span class="line">            <span class="keyword">IF</span> ( RCHSZE .LE. <span class="number">0</span> )  GO TO <span class="number">800</span>                              <span class="number">114.</span></span><br><span class="line"><span class="comment">C              ------------------------------------------------          115.</span></span><br><span class="line"><span class="comment">C              UPDATE THE DEGREES OF THE NODES IN THE REACHABLE          116.</span></span><br><span class="line"><span class="comment">C              SET AND IDENTIFY INDISTINGUISHABLE NODES.                 117.</span></span><br><span class="line"><span class="comment">C              ------------------------------------------------          118.</span></span><br><span class="line">               <span class="keyword">CALL</span>  QMDUPD ( XADJ, ADJNCY, RCHSZE, RCHSET, DEG,         <span class="number">119.</span></span><br><span class="line">     <span class="number">1</span>                        QSIZE, QLINK, MARKER, RCHSET(RCHSZE+<span class="number">1</span>),    <span class="number">120.</span></span><br><span class="line">     <span class="number">1</span>                        NBRHD(NHDSZE+<span class="number">1</span>) )                          <span class="number">121.</span></span><br><span class="line"><span class="comment">C              -------------------------------------------               122.</span></span><br><span class="line"><span class="comment">C              RESET MARKER VALUE OF NODES IN REACH SET.                 123.</span></span><br><span class="line"><span class="comment">C              UPDATE THRESHOLD VALUE FOR CYCLIC SEARCH.                 124.</span></span><br><span class="line"><span class="comment">C              ALSO CALL QMDQT TO FORM NEW QUOTIENT GRAPH.               125.</span></span><br><span class="line"><span class="comment">C              -------------------------------------------               126.</span></span><br><span class="line">               MARKER(NODE) = <span class="number">0</span>                                          <span class="number">127.</span></span><br><span class="line">               <span class="keyword">DO</span> <span class="number">700</span> IRCH = <span class="number">1</span>, RCHSZE                                   <span class="number">128.</span></span><br><span class="line">                  INODE = RCHSET(IRCH)                                   <span class="number">129.</span></span><br><span class="line">                  <span class="keyword">IF</span> ( MARKER(INODE) .LT. <span class="number">0</span> )  <span class="keyword">GOTO</span> <span class="number">700</span>                  <span class="number">130.</span></span><br><span class="line">                     MARKER(INODE) = <span class="number">0</span>                                   <span class="number">131.</span></span><br><span class="line">                     NDEG = DEG(INODE)                                   <span class="number">132.</span></span><br><span class="line">                     <span class="keyword">IF</span> ( NDEG .LT. MINDEG )  MINDEG = NDEG              <span class="number">133.</span></span><br><span class="line">                     <span class="keyword">IF</span> ( NDEG .GT. THRESH )  <span class="keyword">GOTO</span> <span class="number">700</span>                   <span class="number">134.</span></span><br><span class="line">                        MINDEG = THRESH                                  <span class="number">135.</span></span><br><span class="line">                        THRESH = NDEG                                    <span class="number">136.</span></span><br><span class="line">                        SEARCH = INVP(INODE)                             <span class="number">137.</span></span><br><span class="line">  <span class="number">700</span>          <span class="keyword">CONTINUE</span>                                                  <span class="number">138.</span></span><br><span class="line">               <span class="keyword">IF</span> ( NHDSZE .GT. <span class="number">0</span> )  <span class="keyword">CALL</span>  QMDQT ( NODE, XADJ,           <span class="number">139.</span></span><br><span class="line">     <span class="number">1</span>            ADJNCY, MARKER, RCHSZE, RCHSET, NBRHD )                <span class="number">140.</span></span><br><span class="line">  <span class="number">800</span>    <span class="keyword">IF</span> ( NUM .LT. NEQNS )  GO TO <span class="number">300</span>                                <span class="number">141.</span></span><br><span class="line">         <span class="keyword">RETURN</span>                                                          <span class="number">142.</span></span><br><span class="line">      <span class="keyword">END</span>                                                                <span class="number">143.</span></span><br></pre></td></tr></table></figure>
<p>下面开始逐行解析脚本，首先初始化 DEG 向量和其它变量</p>
<p>MARKER 值全部设为 0，QSIZE 值和 QLINK 值全部为 1和 0，DEG 为原始图中的度数，MINDEG 是原始图中的最小度数。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C        -----------------------------------------------------            56.</span></span><br><span class="line"><span class="comment">C        INITIALIZE DEGREE VECTOR AND OTHER WORKING VARIABLES.            57.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            58.</span></span><br><span class="line">         MINDEG = NEQNS                                                   <span class="number">59.</span></span><br><span class="line">         NOFSUB = <span class="number">0</span>                                                       <span class="number">60.</span></span><br><span class="line">         <span class="keyword">DO</span> <span class="number">100</span> NODE = <span class="number">1</span>, NEQNS                                           <span class="number">61.</span></span><br><span class="line">            PERM(NODE) = NODE                                             <span class="number">62.</span></span><br><span class="line">            INVP(NODE) = NODE                                             <span class="number">63.</span></span><br><span class="line">            MARKER(NODE) = <span class="number">0</span>                                              <span class="number">64.</span></span><br><span class="line">            QSIZE(NODE)  = <span class="number">1</span>                                              <span class="number">65.</span></span><br><span class="line">            QLINK(NODE)  = <span class="number">0</span>                                              <span class="number">66.</span></span><br><span class="line">            NDEG = XADJ(NODE+<span class="number">1</span>) - XADJ(NODE)                              <span class="number">67.</span></span><br><span class="line">            DEG(NODE) = NDEG                                              <span class="number">68.</span></span><br><span class="line">            <span class="keyword">IF</span> ( NDEG .LT. MINDEG )  MINDEG = NDEG                        <span class="number">69.</span></span><br><span class="line">  <span class="number">100</span>    <span class="keyword">CONTINUE</span>                                                         <span class="number">70.</span></span><br><span class="line">         NUM = <span class="number">0</span>                                                          <span class="number">71.</span></span><br></pre></td></tr></table></figure>
<p>这里采用 <code>threshold search</code> 来查找拥有最小度数的一个节点，SEARCH 变量指向查找的起始位置。</p>
<p>将之前 MINDEG 的值赋值给 THRESH ，MINDEG 重新设置为 NEQNS ，通过<code>DO 400</code>循环遍历需要搜索的所有节点，如果找到拥有最小度数的节点，则跳出循环，<code>GO TO 500</code> 。而 MINDEG 是跳出循环前大于 THRESH 的最小度数值。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C        -----------------------------------------------------            72.</span></span><br><span class="line"><span class="comment">C        PERFORM THRESHOLD SEARCH TO GET A NODE OF MIN DEGREE.            73.</span></span><br><span class="line"><span class="comment">C        VARIABLE SEARCH POINTS TO WHERE SEARCH SHOULD START.             74.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            75.</span></span><br><span class="line">  <span class="number">200</span>    SEARCH = <span class="number">1</span>                                                       <span class="number">76.</span></span><br><span class="line">            THRESH = MINDEG                                               <span class="number">77.</span></span><br><span class="line">            MINDEG = NEQNS                                                <span class="number">78.</span></span><br><span class="line">  <span class="number">300</span>       NUMP1 = NUM + <span class="number">1</span>                                               <span class="number">79.</span></span><br><span class="line">               <span class="keyword">IF</span> ( NUMP1 .GT. SEARCH )  SEARCH = NUMP1                   <span class="number">80.</span></span><br><span class="line">               <span class="keyword">DO</span> <span class="number">400</span> J = SEARCH, NEQNS                                   <span class="number">81.</span></span><br><span class="line">                  NODE = PERM(J)                                          <span class="number">82.</span></span><br><span class="line">                  <span class="keyword">IF</span> ( MARKER(NODE) .LT. <span class="number">0</span> )  <span class="keyword">GOTO</span> <span class="number">400</span>                    <span class="number">83.</span></span><br><span class="line">                     NDEG = DEG(NODE)                                     <span class="number">84.</span></span><br><span class="line">                     <span class="keyword">IF</span> ( NDEG .LE. THRESH )  GO TO <span class="number">500</span>                   <span class="number">85.</span></span><br><span class="line">                     <span class="keyword">IF</span> ( NDEG .LT. MINDEG )  MINDEG =  NDEG              <span class="number">86.</span></span><br><span class="line">  <span class="number">400</span>          <span class="keyword">CONTINUE</span>                                                   <span class="number">87.</span></span><br><span class="line">            GO TO <span class="number">200</span>                                                     <span class="number">88.</span></span><br></pre></td></tr></table></figure>
<p>对于最小度数节点，将其 MARKER 值设为1，通过调用 QMDRCH 子程序找到它通过已经消除的节点的 REACHABLE SETS，存储在 RCHSET 向量中（<strong>MARKER 值均修改为1</strong>），其向量长度为 RCHSZE ；与 NODE 节点相邻的已经消元的 supernodes 存储在 NBRHD 向量中（<strong>MARKER 值均修改为 -1</strong>），其向量长度为 NHDSZE 。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C           ---------------------------------------------------           89.</span></span><br><span class="line"><span class="comment">C           NODE HAS MINIMUM DEGREE. FIND ITS REACHABLE SETS BY           90.</span></span><br><span class="line"><span class="comment">C           CALLING QMDRCH.                                               91.</span></span><br><span class="line"><span class="comment">C           ---------------------------------------------------           92.</span></span><br><span class="line">  <span class="number">500</span>       SEARCH = J                                                    <span class="number">93.</span></span><br><span class="line">            NOFSUB = NOFSUB + DEG(NODE)                                   <span class="number">94.</span></span><br><span class="line">            MARKER(NODE) = <span class="number">1</span>                                              <span class="number">95.</span></span><br><span class="line">            <span class="keyword">CALL</span> QMDRCH (NODE, XADJ, ADJNCY, DEG, MARKER,                 <span class="number">96.</span></span><br><span class="line">     <span class="number">1</span>                   RCHSZE, RCHSET, NHDSZE, NBRHD )                  <span class="number">97.</span></span><br></pre></td></tr></table></figure>
<p>消除与 NODE 节点所有不可区分的节点，这些节点为 NODE, QLINK(NODE), … 等。</p>
<p>将 NODE 赋值给 NXNODE ，NUM 加 1，应该是 NXNODE 排序后的新位置。</p>
<p>NP 是 NXNODE 节点的原始位置，IP 是 NUM 位置现在的节点。</p>
<p>下面四句互换 NUM 和 NP 位置的节点，<code>PERM(NP) = IP</code> 和 <code>INVP(IP) = NP</code> 将 IP 节点放置到 NP 位置。<code>PERM(NUM) = NXNODE</code> 和 <code>INVP(NXNODE) = NUM</code> 将 NXNODE 放置到 NUM 位置。</p>
<p>排好序的 NXNODE 节点就可以消除了，消除方式是将其 DEG 值设为 -1 。</p>
<p>下面我们获取与 NXNODE 节点不可区分的节点，一并消除。<code>NXNODE = QLINK(NXNODE)</code> 此命令将 NXNODE 更新为下一个不可区分的节点。<code>IF (NXNODE .GT. 0) GO TO 600</code> ，如果其不为0，则再进行循环中进行编号消除。</p>
<p>将所有不可区分的节点消除完毕之后，如果 researchable sets 长度为0，则 <code>GO TO 800</code>，跳过度数更新这一步，直接进入下一个节点的排序。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C           ------------------------------------------------              98.</span></span><br><span class="line"><span class="comment">C           ELIMINATE ALL NODES INDISTINGUISHABLE FROM NODE.              99.</span></span><br><span class="line"><span class="comment">C           THEY ARE GIVEN BY NODE, QLINK(NODE), ....                    100.</span></span><br><span class="line"><span class="comment">C           ------------------------------------------------             101.</span></span><br><span class="line">            NXNODE = NODE                                                <span class="number">102.</span></span><br><span class="line">  <span class="number">600</span>       NUM = NUM + <span class="number">1</span>                                                <span class="number">103.</span></span><br><span class="line">               NP  = INVP(NXNODE)                                        <span class="number">104.</span></span><br><span class="line">               IP  = PERM(NUM)                                           <span class="number">105.</span></span><br><span class="line">               PERM(NP) = IP                                             <span class="number">106.</span></span><br><span class="line">               INVP(IP) = NP                                             <span class="number">107.</span></span><br><span class="line">               PERM(NUM) = NXNODE                                        <span class="number">108.</span></span><br><span class="line">               INVP(NXNODE) = NUM                                        <span class="number">109.</span></span><br><span class="line">               DEG(NXNODE) = - <span class="number">1</span>                                         <span class="number">110.</span></span><br><span class="line">               NXNODE = QLINK(NXNODE)                                    <span class="number">111.</span></span><br><span class="line">            <span class="keyword">IF</span> (NXNODE .GT. <span class="number">0</span>) <span class="keyword">GOTO</span> <span class="number">600</span>                                  <span class="number">112.</span></span><br><span class="line"><span class="comment">C                                                                        113.</span></span><br><span class="line">            <span class="keyword">IF</span> ( RCHSZE .LE. <span class="number">0</span> )  GO TO <span class="number">800</span>                              <span class="number">114.</span></span><br></pre></td></tr></table></figure>
<p>如果 researchable sets 长度不为0，我们则对其  researchable sets 中节点的度数进行更新，并查找不可区分的节点。这里我们通过调用子程序 QMDUPD 来实现这一点（此时  researchable sets  节点的 MARKER 值均为1）。最后两个参数 <code>RCHSET(RCHSZE+1)</code> 和 <code>NBRHD(NHDSZE+1)</code> 利用 RCHSET 和 NBRHD 中尚未利用的空间作为临时变量。</p>
<p>运行结束后，确定新的不可区分的节点，修改 RCHSET 中的 DEG 值。<strong>RCHSET 中除了被合并到不可区分的 supernode 的节点的 MARKER 值改为-1之外，其它 MARKER 值改为2</strong> 。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C              ------------------------------------------------          115.</span></span><br><span class="line"><span class="comment">C              UPDATE THE DEGREES OF THE NODES IN THE REACHABLE          116.</span></span><br><span class="line"><span class="comment">C              SET AND IDENTIFY INDISTINGUISHABLE NODES.                 117.</span></span><br><span class="line"><span class="comment">C              ------------------------------------------------          118.</span></span><br><span class="line">               <span class="keyword">CALL</span>  QMDUPD ( XADJ, ADJNCY, RCHSZE, RCHSET, DEG,         <span class="number">119.</span></span><br><span class="line">     <span class="number">1</span>                        QSIZE, QLINK, MARKER, RCHSET(RCHSZE+<span class="number">1</span>),    <span class="number">120.</span></span><br><span class="line">     <span class="number">1</span>                        NBRHD(NHDSZE+<span class="number">1</span>) )                          <span class="number">121.</span></span><br></pre></td></tr></table></figure>
<p><strong>将要消元的节点 NODE 的 MARKER 值修改为 0</strong>，并<strong>重置 RCHSET 中节点的 MARKER 值</strong>，遍历 RCHSET 中的节点 INODE，如果其 MARKER 值小于0，说明其已经合并到其它节点中了，则跳过这个节点，不然的话将其 <strong>MARKER 值重置为 0</strong>。节点 INODE 的 DEG 值赋值给 NDEG，如果 NDEG 小于  MINDEG，则更新 MINDEG。</p>
<p><strong>这一步完成后，所有节点的 MAKER 值均已经正确设置</strong>（NODE 的 MARKER 值为0，RCHSET 除了被合并的节点之外 MARKER 值也为 0，NBRHD 的 MARKER 值仍为 -1 ，因此这些节点之后会合并到 NODE 中）。</p>
<p>如果 NDEG 小于等于  THRESH，则将MINDEG 改为旧的 THRESH 值，将 THRESH 改为 NDEG 值，SEARCH 改为 INODE 所处的位置。此时说明 INODE 就是下一个消元的节点。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C              -------------------------------------------               122.</span></span><br><span class="line"><span class="comment">C              RESET MARKER VALUE OF NODES IN REACH SET.                 123.</span></span><br><span class="line"><span class="comment">C              UPDATE THRESHOLD VALUE FOR CYCLIC SEARCH.                 124.</span></span><br><span class="line"><span class="comment">C              ALSO CALL QMDQT TO FORM NEW QUOTIENT GRAPH.               125.</span></span><br><span class="line"><span class="comment">C              -------------------------------------------               126.</span></span><br><span class="line">               MARKER(NODE) = <span class="number">0</span>                                          <span class="number">127.</span></span><br><span class="line">               <span class="keyword">DO</span> <span class="number">700</span> IRCH = <span class="number">1</span>, RCHSZE                                   <span class="number">128.</span></span><br><span class="line">                  INODE = RCHSET(IRCH)                                   <span class="number">129.</span></span><br><span class="line">                  <span class="keyword">IF</span> ( MARKER(INODE) .LT. <span class="number">0</span> )  <span class="keyword">GOTO</span> <span class="number">700</span>                  <span class="number">130.</span></span><br><span class="line">                     MARKER(INODE) = <span class="number">0</span>                                   <span class="number">131.</span></span><br><span class="line">                     NDEG = DEG(INODE)                                   <span class="number">132.</span></span><br><span class="line">                     <span class="keyword">IF</span> ( NDEG .LT. MINDEG )  MINDEG = NDEG              <span class="number">133.</span></span><br><span class="line">                     <span class="keyword">IF</span> ( NDEG .GT. THRESH )  <span class="keyword">GOTO</span> <span class="number">700</span>                   <span class="number">134.</span></span><br><span class="line">                        MINDEG = THRESH                                  <span class="number">135.</span></span><br><span class="line">                        THRESH = NDEG                                    <span class="number">136.</span></span><br><span class="line">                        SEARCH = INVP(INODE)                             <span class="number">137.</span></span><br><span class="line">  <span class="number">700</span>          <span class="keyword">CONTINUE</span>                                                  <span class="number">138.</span></span><br></pre></td></tr></table></figure>
<p>如果 NHDSZE 大于0，说明 NODE 需要和其它消元节点进行合并，调用 QMDQT 来形成新的商图。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">          <span class="keyword">IF</span> ( NHDSZE .GT. <span class="number">0</span> )  <span class="keyword">CALL</span>  QMDQT ( NODE, XADJ,           <span class="number">139.</span></span><br><span class="line"><span class="number">1</span>            ADJNCY, MARKER, RCHSZE, RCHSET, NBRHD )                <span class="number">140.</span></span><br></pre></td></tr></table></figure>
<p>最后，如果 NUM 小于 NEQNS，<code>GO TO 300</code> ，重新进入循环。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">800</span>    <span class="keyword">IF</span> ( NUM .LT. NEQNS )  GO TO <span class="number">300</span>                                <span class="number">141.</span></span><br><span class="line">       <span class="keyword">RETURN</span>                                                          <span class="number">142.</span></span><br><span class="line">    <span class="keyword">END</span>                                                                <span class="number">143.</span></span><br></pre></td></tr></table></figure>
<h1>讨论</h1>
<p>这里用的所谓的 <code>threshold search</code> 查找度数最小的节点的算法写得并不很合理，这一步实际上就是从尚未消元的节点中，找到一个度数最小的节点，内容其实很简单，完全可以直接用一遍循环得到，原76至95行可以修改如下。</p>
<p>遍历过程中如果存在节点度数小于等于上次的最小度数 THRESH ，则这个节点就是本次消元的节点，<code>GO TO 500</code>（THRESH  不变） 。否则的话遍历结束后，MINDEG 和  NODE 就时最小度数和相应节点，最后再将 MINDEG 赋值给 THRESH 。这样这一块最多遍历一遍。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">          THRESH = MINDEG                                              </span><br><span class="line"><span class="number">300</span>       MINDEG = NEQNS                                                           </span><br><span class="line">          NUMP1 = NUM + <span class="number">1</span>                                               </span><br><span class="line">             <span class="keyword">DO</span> <span class="number">400</span> J = NUMP1, NEQNS                                    </span><br><span class="line">                INODE = PERM(J)                                        </span><br><span class="line">                <span class="keyword">IF</span> ( MARKER(INODE) .LT. <span class="number">0</span> )  <span class="keyword">GOTO</span> <span class="number">400</span>                    </span><br><span class="line">                   NDEG = DEG(INODE)</span><br><span class="line">                   <span class="keyword">IF</span> ( NDEG .LE. THRESH ) <span class="keyword">THEN</span></span><br><span class="line">                   	NODE = INODE</span><br><span class="line">                   	GO TO <span class="number">500</span></span><br><span class="line">                   <span class="keyword">END</span> <span class="keyword">IF</span></span><br><span class="line">                   <span class="keyword">IF</span> ( NDEG .LT. MINDEG )  <span class="keyword">THEN</span></span><br><span class="line">                   	MINDEG = NDEG</span><br><span class="line">                   	NODE = INODE</span><br><span class="line">                   <span class="keyword">ENDIF</span></span><br><span class="line"><span class="number">400</span>          <span class="keyword">CONTINUE</span></span><br><span class="line">			   THRESH = MINDEG</span><br><span class="line">			   </span><br><span class="line"><span class="number">500</span>       NOFSUB = NOFSUB + DEG(NODE)                                   </span><br><span class="line">			...   </span><br></pre></td></tr></table></figure>
<p>原脚本中采用 SEARCH，MINDEG 和  THRESH 三个变量来查找最小位点，那么查找消元节点的过程如下。第一次查找到的节点假设为 <img src="https://math.now.sh?inline=j%20%3E%202" style="display:inline-block;margin: 0;"/> ，MINDEG 为原始 1到 j-1 节点中的原始最小度数，SEARCH 设为 J 。节点 1 和 j 互换后，MINDEG 就是PERM 中 2 到 j 位置节点中的原始最小度数。更新度数后，如果 RCHSET 中节点度数小于 MINDEG ，更新 MINDEG 。 假设我们最后重置 RCHSET 节点的 MARKER 值时均没有找到下一个消元的节点（没有更新 THRESH ，注意此时仍为第一次的最小度数），  之后我们查找第二个消元节点，<code>GO TO 300</code> ，遍历 PERM 中第 J 到 最后一个位置的所有节点，如果没有度数小于等于 THRESH （由于 THRESH 仍是上一次的最小度数，很可能就是找不到的），遍历完 400 循环之后， <strong>MINDEG 值为最小度数的下限</strong>；<code>GO TO 200</code> ,  更新 THRESH  值为 MINDEG，再次进入 400 循环 ，这一次大概率可以找到需要的节点 NODE ，退出循环，<code>GO TO 500</code> 。但是还是有一个小概率遍历完还是没找到，但是遍历完之后， MINDEG 就会更新为所有剩余节点的实际的最小度数，<code>GO TO 200</code> ，再经过一次 400 循环 ，这一次绝对可以找到需要的节点 NODE，然后跳出循环。</p>
<p>因此这里查找最小度数过程中可能经过多次循环（最佳一次，最差三次），而且可读性差，逻辑性差。</p>
<h1>参考文献</h1>
<ol>
<li>George A, Liu J, Ng E. Computer solution of sparse linear systems[J]. Oak Ridge National Laboratory, 1994.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>稀疏矩阵</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>稀疏矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏矩阵算法最小度数算法三之最小度数算法理论</title>
    <url>/posts/ff1d909d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本章节介绍 <em>the minimum degree algorithm</em> ，我个人将其翻译为最小度数算法。这里我们看最小度数算法的理论部分。</p>
<span id="more"></span>
<h1>The Minimum Degree</h1>
<p>虽然 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BPAP%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/> 的非零元素结构不同，但是其非零元素数目相同，即 <img src="https://math.now.sh?inline=%7CNonz%28%5Cmathbf%7BA%7D%29%7C%20%3D%20%7CNonz(%5Cmathbf%7BPAP%5E%7BT%7D%7D)%7C" style="display:inline-block;margin: 0;"/> 。然而对于某些 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%7CNonz%28%5Cmathbf%7BF(A%29%7D)%7C" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%7CNonz%28%5Cmathbf%7BF(PAP%5E%7BT%7D%29%7D)%7C" style="display:inline-block;margin: 0;"/> 可能有很大的差别。</p>
<p>我们希望找到一个置换矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> ，能够最大限度地减少 <em>fill-in</em> ，即</p>
<p style=""><img src="https://math.now.sh?from=%7CNonz%28%5Cmathbf%7BF(P%5E%7B*%7DAP%5E%7B*T%7D%29%7D)%7C%20%3D%20%5Cmin_%7B%5Cmathbf%7BP%7D%7D%20%7CNonz(%5Cmathbf%7BF(PAP%5E%7BT%7D)%7D)%7C%0A" /></p><p>然而至今为止，我们没有一个有效的算法可以得到这个最佳的  <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 。实际上这个问题是一个 <em>NP-complete problem</em> (Yannakakis[56]) 。因此我们不得不采用一些启发式的算法来得到一个可以接受的 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>到目前位置，最流行的算法就是<strong>最小度数算法</strong> (<em>the minimum degree algorithm</em>) (Tinney [53]) 。假设 <img src="https://math.now.sh?inline=%5C%7Bx_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bi-1%7D%5C%7D" style="display:inline-block;margin: 0;"/> 已经打上了标签，此时这些列在 <em>filled graph</em> 中的非零元素数目已经确定了。为了减少第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 列中的非零元素数目，很明显在剩下的需要分解的子矩阵中，拥有最少的非零元素的列应该选为列 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 。</p>
<h2 id="The-Basic-Algorithm">The Basic Algorithm</h2>
<p><em>the minimum degree algorithm</em> 可以简单地描述为对一个图节点地排序。设 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7B0%7D%20%3D%20%28X%2CE%29" style="display:inline-block;margin: 0;"/> 是一个没有排序的图，采用 <em>elimination graph model</em> ，基本算法如下</p>
<p><img src="75.png" alt="1"></p>
<p><img src="76.png" alt="1"></p>
<p>举个例子，下图是我们考虑的图</p>
<p><img src="77.png" alt="1"></p>
<p>最小度数算法的执行过程如下图。注意在某一步中可能存在多个度数最小的节点，这里我们是随机选择了一个。然而在不同的版本中，这个节点的选择可能有着不同的方法。</p>
<p><img src="78.png" alt="1"></p>
<h2 id="Description-of-the-Minimum-Degree-Algorithm-Using-Reachable-Sets">Description of the Minimum Degree Algorithm Using Reachable Sets</h2>
<p>在最小度数算法中，每一步均包含了图的转换，这是这个算法实施起来最费时的步骤。如果我们可以提供一种替代方法来计算 <em>elimination graph</em> 中节点的度数，我们就可以跳过这些图的转换过程。</p>
<p>定理 5.2.3 可以通过利用 <em>reachable sets</em> 来实现这一点，因此我们可以对算法做一些修改如下：</p>
<p><img src="79.png" alt="1"></p>
<p>此时在整个过程中我们均只采用原始的图结构。实际上，这个算法可以只通过相邻结构  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7B0%7D%20%3D%20%28X%2CE%29" style="display:inline-block;margin: 0;"/>  得到实现。</p>
<p>需要指出的是，在 <em>Degree update</em> 这一步中，我们没有必要对每一个 <img src="https://math.now.sh?inline=X-T" style="display:inline-block;margin: 0;"/> 中的节点均计算度数，因为其中的绝大部分均会保持不变，存在引理如下</p>
<p><strong>引理 5.4.1</strong>：设 $y \notin S $ ，<img src="https://math.now.sh?inline=T%20%3D%20S%20%5Ccup%20%5C%7By%5C%7D" style="display:inline-block;margin: 0;"/>，那么</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bequation%7D%0AReach%28x%2C%20T%29%3D%20%5Cleft%5C%7B%0A%5Cbegin%7Baligned%7D%0A%26Reach(x%2CS)%20%26%26%20%5Ctext%7Bfor%20%7D%20x%20%5Cnotin%20Reach(y%2CS)%20%5C%5C%0A%26Reach(x%2CS)%20%5Ccup%20Reach(y%2CS)%20-%20%5C%7B%20x%2Cy%20%5C%7D%20%26%26%20otherwise%0A%0A%5Cend%7Baligned%7D%0A%5Cright.%0A%5Cend%7Bequation%7D%0A" /></p><p><img src="https://math.now.sh?inline=x%20%5Cin%20Reach%28y%2CS%29" style="display:inline-block;margin: 0;"/> 说明在剔除 <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> 的消元图中，<img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/>  和 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 是相邻的，此时剔除 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 的度数可能会发生改变，反之 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 的度数不会发生改变。也就是说，<strong>剔除 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 只有在消元图中 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 的相邻位点的度数会发生改变</strong>。</p>
<p>在图 5.4.3 中，考虑节点 <img src="https://math.now.sh?inline=d" style="display:inline-block;margin: 0;"/> 被消除的步骤中，此时 <img src="https://math.now.sh?inline=S%20%3D%20%5C%7Ba%2Cc%5C%7D" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=Reach%28d%2CS%29%20%3D%20%5C%7Bb%2Cg%5C%7D" style="display:inline-block;margin: 0;"/> ，因此消除 <img src="https://math.now.sh?inline=d" style="display:inline-block;margin: 0;"/> 影响节点 <img src="https://math.now.sh?inline=b" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=g" style="display:inline-block;margin: 0;"/> 的度数。</p>
<p>因此上面算法的步骤 3 可以重新表达为</p>
<p><img src="80.png" alt="1"></p>
<p><strong>推论 5.4.2</strong>：对于 <img src="https://math.now.sh?inline=x%20%5Cin%20X-T" style="display:inline-block;margin: 0;"/> ，均有</p>
<p style=""><img src="https://math.now.sh?from=%7CReach%28x%2C%20T%29%7C%20%5Cgeq%20%7CReach(x%2C%20S)%7C%20-%201%0A" /></p><p>根据引理 5.4.1 ，对于 <img src="https://math.now.sh?inline=x%20%5Cnotin%20Reach%28y%2CS%29" style="display:inline-block;margin: 0;"/> ，自然成立。否则，在剔除 <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> 的消元图中，<img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/>  和 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 是相邻的。剔除节点 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> ，首先剔除了 <img src="https://math.now.sh?inline=%5C%7Bx%2Cy%5C%7D" style="display:inline-block;margin: 0;"/> 这条边，然后 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 的相邻节点互相连接，因此 <img src="https://math.now.sh?inline=%7CReach%28x%2C%20T%29%7C" style="display:inline-block;margin: 0;"/> 至少为 <img src="https://math.now.sh?inline=%7CReach%28x%2C%20S%29%7C%20-%201" style="display:inline-block;margin: 0;"/>。</p>
<h2 id="An-Enhancement">An Enhancement</h2>
<p>上面提到的算法每次循环只会对一个节点进行编号，但是当我们在步骤 2 中找到了一个度数最小的节点 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> ，我们通常可能会发现可能是下一个节点的候选节点集合。当我们考虑一次消元的过程，其中 <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> 是已经消除的节点的集合，如果满足下式，那么节点 <img src="https://math.now.sh?inline=x%2Cy%20%5Cin%20X-S" style="display:inline-block;margin: 0;"/> 称为<strong>不可区分的</strong> (<em>indistinguishable with respect to elimination</em>) 。</p>
<p style=""><img src="https://math.now.sh?from=Reach%28x%2CS%29%20%5Ccup%20%5C%7Bx%5C%7D%20%3D%20Reach(y%2CS)%20%5Ccup%20%5C%7By%5C%7D%0A" /></p><p>以下图为例，子集 <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> 包含 36 个阴影的节点。我们注意到此时 <img src="https://math.now.sh?inline=a%2Cb%2Cc" style="display:inline-block;margin: 0;"/> 是不可区分的，因为 <img src="https://math.now.sh?inline=Reach%28a%2CS%29%20%5Ccup%20%5C%7Ba%5C%7D" style="display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=Reach%28b%2CS%29%20%5Ccup%20%5C%7Bb%5C%7D" style="display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=Reach%28c%2CS%29%20%5Ccup%20%5C%7Bc%5C%7D" style="display:inline-block;margin: 0;"/> 是一样的，均为</p>
<p style=""><img src="https://math.now.sh?from=%5C%7B%20a%2Cb%2Cc%2Cd%2Ce%2Cf%2Cg%2Ch%2Cj%2Ck%5C%7D%0A" /></p><p><img src="81.png" alt="1"></p>
<p>还有两组节点是不可区分的，分别为 <img src="https://math.now.sh?inline=%5C%7Bj%2Ck%5C%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5C%7Bf%2Cg%5C%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>不可区分的节点可以加速最小度数算法。</p>
<p><strong>定理 5.4.3</strong>：设 <img src="https://math.now.sh?inline=x%2Cy%20%5Cin%20X-S" style="display:inline-block;margin: 0;"/> ，如果</p>
<p style=""><img src="https://math.now.sh?from=Reach%28x%2CS%29%20%5Ccup%20%5C%7Bx%5C%7D%20%3D%20Reach(y%2CS)%20%5Ccup%20%5C%7By%5C%7D%0A" /></p><p>那么对于所有的 <img src="https://math.now.sh?inline=X%20-%20%5C%7Bx%2Cy%5C%7D%20%5Csupset%20T%20%5Csupset%20S" style="display:inline-block;margin: 0;"/> ，存在</p>
<p style=""><img src="https://math.now.sh?from=Reach%28x%2CT%29%20%5Ccup%20%5C%7Bx%5C%7D%20%3D%20Reach(y%2CT)%20%5Ccup%20%5C%7By%5C%7D%0A" /></p><p>首先我们想要证明 <img src="https://math.now.sh?inline=x%20%5Cin%20Reach%28y%2CT%29" style="display:inline-block;margin: 0;"/>。 因为 <img src="https://math.now.sh?inline=Reach%28x%2CS%29%20%5Ccup%20%5C%7Bx%5C%7D%20%3D%20Reach(y%2CS)%20%5Ccup%20%5C%7By%5C%7D" style="display:inline-block;margin: 0;"/> ，所以 <img src="https://math.now.sh?inline=x%20%5Cin%20Reach%28y%2CS%29%20%5Ccup%20%5C%7By%5C%7D" style="display:inline-block;margin: 0;"/> ，而 <img src="https://math.now.sh?inline=x%20%5Cneq%20y" style="display:inline-block;margin: 0;"/>，因此 <img src="https://math.now.sh?inline=x%20%5Cin%20Reach%28y%2CS%29" style="display:inline-block;margin: 0;"/> 。由于 <img src="https://math.now.sh?inline=Reach%28y%2CS%29%20%5Csubset%20Reach(y%2CT)%20%5Ccup%20T" style="display:inline-block;margin: 0;"/>，而 <img src="https://math.now.sh?inline=T" style="display:inline-block;margin: 0;"/> 中不包含 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/>，因此我们得到  <img src="https://math.now.sh?inline=x%20%5Cin%20Reach%28y%2CT%29" style="display:inline-block;margin: 0;"/>。</p>
<p>其次我们想要证明 <img src="https://math.now.sh?inline=Reach%28x%2C%20T%29%20%5Csubset%20Reach(y%2CT)%20%5Ccup%20%5C%7By%5C%7D" style="display:inline-block;margin: 0;"/> 。考虑 <img src="https://math.now.sh?inline=z%20%5Cin%20Reach%28x%2CT%29" style="display:inline-block;margin: 0;"/> ，肯定存在一条路径 <img src="https://math.now.sh?inline=%28x%2Cs_%7B1%7D%2C%5Ccdots%2Cs_%7Bt%7D%2Cz%29" style="display:inline-block;margin: 0;"/>，其中 <img src="https://math.now.sh?inline=%5C%7Bs_%7B1%7D%2C%5Ccdots%2Cs_%7Bt%7D%5C%7D%20%5Csubset%20T" style="display:inline-block;margin: 0;"/> 。如果所有 <img src="https://math.now.sh?inline=s_%7Bi%7D%20%5Cin%20S" style="display:inline-block;margin: 0;"/> ，由于 <img src="https://math.now.sh?inline=Reach%28x%2CS%29%20%5Ccup%20%5C%7Bx%5C%7D%20%3D%20Reach(y%2CS)%20%5Ccup%20%5C%7By%5C%7D" style="display:inline-block;margin: 0;"/> ，那么要么 <img src="https://math.now.sh?inline=z%20%3D%20y" style="display:inline-block;margin: 0;"/> ，自然成立；要么 <img src="https://math.now.sh?inline=z%20%5Cin%20Reach%28y%2CS%29" style="display:inline-block;margin: 0;"/> ，由于 <img src="https://math.now.sh?inline=z%20%5Cnotin%20T" style="display:inline-block;margin: 0;"/> ，因此同样有 <img src="https://math.now.sh?inline=z%20%5Cin%20Reach%28y%2CT%29" style="display:inline-block;margin: 0;"/> 。如果不是所有 <img src="https://math.now.sh?inline=s_%7Bi%7D%20%5Cin%20S" style="display:inline-block;margin: 0;"/> ，设 <img src="https://math.now.sh?inline=s_%7Bi%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5C%7Bs_%7B1%7D%2C%5Ccdots%2Cs_%7Bt%7D%5C%7D" style="display:inline-block;margin: 0;"/>  中第一个不在 <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> 中的节点，即</p>
<p style=""><img src="https://math.now.sh?from=s_%7Bi%7D%20%5Cin%20Reach%28x%2CS%29%20%5Ccap%20T%0A" /></p><p>这说明 <img src="https://math.now.sh?inline=s_%7Bi%7D%20%5Cin%20Reach%28y%2CS%29" style="display:inline-block;margin: 0;"/> ，也就是说，<img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/>  也可以通过 <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> 中的节点连接到 <img src="https://math.now.sh?inline=s_%7Bi%7D" style="display:inline-block;margin: 0;"/>, 进而进一步通过 <img src="https://math.now.sh?inline=s_%7Bi%2B1%7D%2C%5Ccdots%2Cs_%7Bt%7D" style="display:inline-block;margin: 0;"/> 连接到 <img src="https://math.now.sh?inline=z" style="display:inline-block;margin: 0;"/> , 因此有 <img src="https://math.now.sh?inline=z%20%5Cin%20Reach%28y%2C%20T%29" style="display:inline-block;margin: 0;"/> 。得证  <img src="https://math.now.sh?inline=Reach%28x%2C%20T%29%20%5Csubset%20Reach(y%2CT)%20%5Ccup%20%5C%7By%5C%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>联合起来，因此我们得到：</p>
<p style=""><img src="https://math.now.sh?from=Reach%28x%2CT%29%20%5Ccup%20%5C%7Bx%5C%7D%20%5Csubset%20Reach(y%2CT)%20%5Ccup%20%5C%7By%5C%7D%0A" /></p><p>我们可以从反方向证明得到 <img src="https://math.now.sh?inline=Reach%28y%2CT%29%20%5Ccup%20%5C%7By%5C%7D%20%5Csubset%20Reach(x%2CT)%20%5Ccup%20%5C%7Bx%5C%7D" style="display:inline-block;margin: 0;"/> ，因此我们得证 <img src="https://math.now.sh?inline=Reach%28x%2CT%29%20%5Ccup%20%5C%7Bx%5C%7D%20%3D%20Reach(y%2CT)%20%5Ccup%20%5C%7By%5C%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p><strong>推论 5.4.4</strong>：设 <img src="https://math.now.sh?inline=x%2Cy" style="display:inline-block;margin: 0;"/> 相对于 <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> 不可区分，那么对于 <img src="https://math.now.sh?inline=T%20%5Csupset%20S" style="display:inline-block;margin: 0;"/> ，存在</p>
<p style=""><img src="https://math.now.sh?from=%7CReach%28x%2CT%29%7C%20%3D%20%7CReach(y%2CT)%7C%0A" /></p><p>换句话说，如果在消元的某一步中，如果两个节点不可区分，那么除非其中一个节点被消除，不然它们会一直保持不可区分的状态。进一步地说，这些不可区分的节点可以<strong>同时消除</strong>。</p>
<p><strong>定理 5.4.5</strong>：如果两个节点在最小度数算法中的某一步中不可区分，那么它们可以在算法中同时被消除。</p>
<p>证明：设 <img src="https://math.now.sh?inline=x%2Cy" style="display:inline-block;margin: 0;"/> 相对于 <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> 不可区分，假设在集合 <img src="https://math.now.sh?inline=T%20%5Csupset%20S" style="display:inline-block;margin: 0;"/> 已经被消除之后，<img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 变成了度数最小的一个节点，即</p>
<p style=""><img src="https://math.now.sh?from=%7CReach%28x%2CT%29%7C%20%5Cleq%20%7CReach(z%2CT)%7C%20%5Ctext%7B%20for%20all%20%7D%20z%20%5Cin%20X-T%0A" /></p><p>那么我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%7CReach%28y%2C%20T%20%5Ccup%20%5C%7B%20x%20%5C%7D%29%7C%20%0A%26%3D%20%7CReach(y%2C%20T)%20%5Ccup%20Reach(x%2C%20T)%20-%20%5C%7Bx%2Cy%5C%7D%7C%20%5Cbecause%20%5Ctext%7B%20%E5%BC%95%E7%90%86%205.4.1%7D%5C%5C%0A%26%3D%20%7CReach(y%2CT)%20-%20%5C%7Bx%5C%7D%7C%20%5C%5C%0A%26%3D%7CReach(y%2CT)%7C%20-1%20%5C%5C%0A%26%3D%7CReach(x%2CT)%7C%20-1%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，对于所有的 <img src="https://math.now.sh?inline=z%20%5Cin%20X-T%20%5Ccup%20%5C%7Bx%5C%7D" style="display:inline-block;margin: 0;"/> ，通过推论 5.4.2 ，存在</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%7CReach%28y%2C%20T%20%5Ccup%20%5C%7B%20x%20%5C%7D%29%7C%20%26%3D%7CReach(x%2CT)%7C%20-1%20%5C%5C%0A%26%20%5Cleq%20%7CReach(z%2CT)%7C%20-1%20%5Cquad%20%5Cbecause%20%5Ctext%7B%20x%20%E6%98%AF%E5%BA%A6%E6%95%B0%E6%9C%80%E5%B0%8F%E8%8A%82%E7%82%B9%7D%5C%5C%0A%26%20%5Cleq%20%7CReach(z%2CT%20%5Ccup%20%5C%7Bx%5C%7D)%7C%20%5Cquad%20%5Cbecause%20%5Ctext%7B%20%E6%8E%A8%E8%AE%BA%205.4.2%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>换句话说，当消除了 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 之后，节点 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 就会变成度数最小的节点。</p>
<p>因此不可区分的节点可以聚集在一块，视为一个 <em><strong>supernode</strong></em> 。举个例子，下图展示了两步中不可区分的节点形成 supernode 的过程，当 {a,b,c} 被消元之后，剩下的所有节点均有相同的 <em>reachable sets</em> ，因此均可以聚集成一个节点。</p>
<p><img src="82.png" alt="1"></p>
<p>一般来说，我们不会试图找出所有可能的不可区分的节点，我们会查找一个简单但是证明非常有效的条件，在绝大多数情况下，这个条件会找出所有不可区分的节点。</p>
<p>设 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%20%3D%20%28X%2CE%29" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> 是已经消元的节点，设 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%28C_%7B1%7D%29" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%28C_%7B2%7D%29" style="display:inline-block;margin: 0;"/> 是子图  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%28S%29" style="display:inline-block;margin: 0;"/> 的两个连通组分，即</p>
<p style=""><img src="https://math.now.sh?from=C_%7B1%7D%2CC_%7B2%7D%20%5Cin%20C%28S%29%0A" /></p><p><strong>引理 5.4.6</strong>：设 <img src="https://math.now.sh?inline=R_%7B1%7D%20%3D%20Adj%28C_%7B1%7D%29" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=R_%7B2%7D%20%3D%20Adj%28C_%7B2%7D%29" style="display:inline-block;margin: 0;"/> 。如果 <img src="https://math.now.sh?inline=y%20%5Cin%20R_%7B1%7D%20%5Ccap%20R_%7B2%7D" style="display:inline-block;margin: 0;"/> ，并且 <img src="https://math.now.sh?inline=Adj%28y%29%20%5Csubset%20R_%7B1%7D%20%5Ccup%20R_%7B2%7D%20%5Ccup%20C_%7B1%7D%20%5Ccup%20C_%7B2%7D" style="display:inline-block;margin: 0;"/> ，那么存在</p>
<p style=""><img src="https://math.now.sh?from=Reach%28y%2CS%29%20%5Ccup%20%5C%7B%20y%20%5C%7D%20%3D%20R_%7B1%7D%20%5Ccup%20R_%7B2%7D%0A" /></p><p>证明：如果 <img src="https://math.now.sh?inline=x%20%5Cin%20R_%7B1%7D%20%5Ccup%20R_%7B2%7D" style="display:inline-block;margin: 0;"/> 。假设 <img src="https://math.now.sh?inline=x%20%5Cin%20R_%7B1%7D%20%3D%20Adj%28C_%7B1%7D%29" style="display:inline-block;margin: 0;"/> ，因为  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%28C_%7B1%7D%29" style="display:inline-block;margin: 0;"/> 是  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%28S%29" style="display:inline-block;margin: 0;"/> 的 一个连通组分，同样  <img src="https://math.now.sh?inline=y%20%5Cin%20R_%7B1%7D%20%3D%20Adj%28C_%7B1%7D%29" style="display:inline-block;margin: 0;"/>，即 <img src="https://math.now.sh?inline=x%2Cy" style="display:inline-block;margin: 0;"/> 均是 <img src="https://math.now.sh?inline=C_%7B1%7D" style="display:inline-block;margin: 0;"/> 的相邻节点， 因此我们可以通过  <img src="https://math.now.sh?inline=C_%7B1%7D%20%5Csubset%20S" style="display:inline-block;margin: 0;"/> 找到一条从 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 到 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 的路径，因此 <img src="https://math.now.sh?inline=x%20%5Cin%20Reach%28y%2CS%29%20%5Ccup%20%5C%7By%5C%7D" style="display:inline-block;margin: 0;"/> ；同样地，假设 <img src="https://math.now.sh?inline=x%20%5Cin%20R_%7B2%7D%20%3D%20Adj%28C_%7B2%7D%29" style="display:inline-block;margin: 0;"/> ，同理可证  <img src="https://math.now.sh?inline=x%20%5Cin%20Reach%28y%2CS%29%20%5Ccup%20%5C%7By%5C%7D" style="display:inline-block;margin: 0;"/> 。因此可得 <img src="https://math.now.sh?inline=R_%7B1%7D%20%5Ccup%20R_%7B2%7D%20%5Csubset%20Reach%28y%2CS%29%20%5Ccup%20%5C%7By%5C%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>反过来，如果 <img src="https://math.now.sh?inline=x%20%5Cin%20Reach%28y%2CS%29" style="display:inline-block;margin: 0;"/> ，那么肯定存在一条路径 <img src="https://math.now.sh?inline=%28y%2Cs_1%2Cs_2%2C%5Ccdots%2Cs_t%2Cx%29" style="display:inline-block;margin: 0;"/> 。如果 <img src="https://math.now.sh?inline=t%20%3D%200" style="display:inline-block;margin: 0;"/> ，那么 <img src="https://math.now.sh?inline=x%20%5Cin%20%28Adj(y%29-S)%20%5Csubset%20(R_%7B1%7D%20%5Ccup%20R_%7B2%7D%20%5Ccup%20C_%7B1%7D%20%5Ccup%20C_%7B2%7D%20-%20S)%20%5Csubset%20R_%7B1%7D%20%5Ccup%20R_%7B2%7D" style="display:inline-block;margin: 0;"/> 。 如果 <img src="https://math.now.sh?inline=t%20%3E%200" style="display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=s_%7B1%7D%20%5Cin%20Adj%28y%29%20%5Ccap%20S%20%5Csubset%20C_%7B1%7D%20%5Ccup%20C_%7B2%7D" style="display:inline-block;margin: 0;"/> 。如果 <img src="https://math.now.sh?inline=s_%7B1%7D%20%5Cin%20C_%7B1%7D" style="display:inline-block;margin: 0;"/> ，由于 <img src="https://math.now.sh?inline=C_%7B1%7D" style="display:inline-block;margin: 0;"/> 是 S 中的一个连通组分，这说明 <img src="https://math.now.sh?inline=%5C%7Bs_1%2Cs_2%2C%5Ccdots%2Cs_t%5C%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=C_%7B1%7D" style="display:inline-block;margin: 0;"/> 的子集，否则  <img src="https://math.now.sh?inline=s_%7B1%7D%20%5Cin%20C_%7B2%7D" style="display:inline-block;margin: 0;"/>，则  <img src="https://math.now.sh?inline=%5C%7Bs_1%2Cs_2%2C%5Ccdots%2Cs_t%5C%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=C_%7B2%7D" style="display:inline-block;margin: 0;"/> 的子集。因此 <img src="https://math.now.sh?inline=x%20%5Cin%20R_%7B1%7D%20%5Ccup%20R_%7B2%7D" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=Reach%28y%2CS%29%20%5Ccup%20%5C%7B%20y%20%5C%7D%20%5Csubset%20R_%7B1%7D%20%5Ccup%20R_%7B2%7D" style="display:inline-block;margin: 0;"/> ，因此我们证明 <img src="https://math.now.sh?inline=Reach%28y%2CS%29%20%5Ccup%20%5C%7B%20y%20%5C%7D%20%3D%20R_%7B1%7D%20%5Ccup%20R_%7B2%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p><strong>定理 5.4.7</strong>：在下面的集合中的节点相对于 <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> 是不可区分的。</p>
<p style=""><img src="https://math.now.sh?from=Y%20%3D%20%5C%7B%20y%20%5Cin%20R_%7B1%7D%20%5Ccap%20R_%7B2%7D%20%5Cmid%20Adj%28y%29%20%5Csubset%20R_%7B1%7D%20%5Ccup%20R_%7B2%7D%20%5Ccup%20C_%7B1%7D%20%5Ccup%20C_%7B2%7D%20%5C%7D%0A" /></p><p><strong>推论 5.4.8</strong>： 对于 <img src="https://math.now.sh?inline=y%20%5Cin%20Y" style="display:inline-block;margin: 0;"/> ，存在</p>
<p style=""><img src="https://math.now.sh?from=%7CReach%28y%2CS%29%7C%20%3D%20%7CR_%7B1%7D%20%5Ccup%20R_%7B2%7D%7C%20-%201%0A" /></p><p>更新后的最小度数算法如下：</p>
<p><img src="83.png" alt="1"></p>
<h2 id="思考题">思考题</h2>
<ol>
<li>
<p>设 <img src="https://math.now.sh?inline=x_%7Bi%7D" style="display:inline-block;margin: 0;"/> 是从最小度数算法中消元图 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi-1%7D" style="display:inline-block;margin: 0;"/> 中选中的度数最小的节点，设 <img src="https://math.now.sh?inline=y%20%5Cin%20Adj_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D%28x_%7Bi%7D%29" style="display:inline-block;margin: 0;"/> ，并且满足</p>
<p style=""><img src="https://math.now.sh?from=Deg_%7B%5Cmathcal%7BG%7D_%7Bi%7D%7D%28y%29%20%3D%20Deg_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D(x_%7Bi%7D)%20-%201%0A" /></p><p>尝试证明 y 是 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 中度数最小的一个节点。</p>
<p><strong>证明</strong>： 我们把 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 中的节点分为两类，第一类是 <img src="https://math.now.sh?inline=Adj_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D%28x_%7Bi%7D%29" style="display:inline-block;margin: 0;"/> ，第二类是其他节点。根据之前的推导，第二类的节点从   <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi-1%7D" style="display:inline-block;margin: 0;"/> 到  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的过程中度数不变，因此对于其中任意一个节点 <img src="https://math.now.sh?inline=z" style="display:inline-block;margin: 0;"/> ，均满足 <img src="https://math.now.sh?inline=Deg_%7B%5Cmathcal%7BG%7D_%7Bi%7D%7D%28z%29%20%3D%20Deg_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D(z)%20%5Cgeq%20Deg_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D(x_%7Bi%7D)%20%3E%20Deg_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D(x_%7Bi%7D)%20-%201%20%3D%20Deg_%7B%5Cmathcal%7BG%7D_%7Bi%7D%7D(y)" style="display:inline-block;margin: 0;"/> ，因此这些节点在  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 中的自由度均大于 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 。</p>
<p>我们再看第一类节点，我们看在什么情况下 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 才能满足上面的条件，首先从   <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi-1%7D" style="display:inline-block;margin: 0;"/> 到  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的过程中， <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 的度数先减去 1（消除 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/>），再加上 n (新增的 <code>fill-in</code> ) ，因此我们有 <img src="https://math.now.sh?inline=Deg_%7B%5Cmathcal%7BG%7D_%7Bi%7D%7D%28y%29%20%5Cgeq%20Deg_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D(y)%20-1%20%5Cgeq%20Deg_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D(x_%7Bi%7D)%20-%201" style="display:inline-block;margin: 0;"/> ，因此  <img src="https://math.now.sh?inline=Deg_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D%28x_%7Bi%7D%29%20-%201" style="display:inline-block;margin: 0;"/> 是第一类节点在   <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 中可能取到的最小度数。</p>
<p>结合这两点，我们得证  y 是 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 中度数最小的一个节点。</p>
</li>
<li>
<p>设 <img src="https://math.now.sh?inline=x_%7Bi%7D" style="display:inline-block;margin: 0;"/> 是从最小度数算法中消元图 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi-1%7D" style="display:inline-block;margin: 0;"/> 中选中的度数最小的节点，设 <img src="https://math.now.sh?inline=y%20%5Cin%20Adj_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D%28x_%7Bi%7D%29" style="display:inline-block;margin: 0;"/> ，并且满足</p>
<p style=""><img src="https://math.now.sh?from=Adj_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D%28y%29%20%5Csubset%20Adj_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D(x_%7Bi%7D)%20%5Ccup%20%5C%7Bx_%7Bi%7D%5C%7D%0A" /></p><p><strong>证明</strong>：这里我们证明这个条件和第一题的条件是等价的。首先我们证明如果满足第一题中的条件，那么同样满足第二题的条件。第一题中我们证明得到  <img src="https://math.now.sh?inline=Deg_%7B%5Cmathcal%7BG%7D_%7Bi%7D%7D%28y%29%20%5Cgeq%20Deg_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D(y)%20-1%20%5Cgeq%20Deg_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D(x_%7Bi%7D)%20-%201" style="display:inline-block;margin: 0;"/> 。由于首尾相等，因此其中的两个不等式均为等式。因此我们得到 <img src="https://math.now.sh?inline=Deg_%7B%5Cmathcal%7BG%7D_%7Bi%7D%7D%28y%29%20%3D%20Deg_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D(y)%20-1" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=Deg_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D%28y%29%20%3D%20Deg_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D(x_%7Bi%7D)" style="display:inline-block;margin: 0;"/> ，也就是说在  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi-1%7D" style="display:inline-block;margin: 0;"/> 中 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 也是度数最小的节点，并且消除 x 之后  y 没有新增的  <code>fill-in</code> 。没有新增的 <code>fill-in</code> 说明 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi-1%7D" style="display:inline-block;margin: 0;"/> 中 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 除 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 之外的相邻节点均与 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 相邻，设 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 在  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi-1%7D" style="display:inline-block;margin: 0;"/> 的相邻节点数为 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> ，其 除 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 之外的相邻节点数为 <img src="https://math.now.sh?inline=n-1" style="display:inline-block;margin: 0;"/> ，这 <img src="https://math.now.sh?inline=n%20-%201" style="display:inline-block;margin: 0;"/> 个节点也是 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 的相邻节点。由于 <img src="https://math.now.sh?inline=Deg_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D%28y%29%20%3D%20Deg_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D(x_%7Bi%7D)" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 在  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi-1%7D" style="display:inline-block;margin: 0;"/> 的相邻节点数也为 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/>，除了上面的 <img src="https://math.now.sh?inline=n-1" style="display:inline-block;margin: 0;"/> 个节点就还有节点 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> ，正好是 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个节点，因此说明 <strong><img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 是不可区分的</strong>，因此满足 <img src="https://math.now.sh?inline=Adj_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D%28y%29%20%5Csubset%20Adj_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D(x_%7Bi%7D)%20%5Ccup%20%5C%7Bx_%7Bi%7D%5C%7D" style="display:inline-block;margin: 0;"/>。</p>
<p>反过来，如果 <img src="https://math.now.sh?inline=Adj_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D%28y%29%20%5Csubset%20Adj_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D(x_%7Bi%7D)%20%5Ccup%20%5C%7Bx_%7Bi%7D%5C%7D" style="display:inline-block;margin: 0;"/>，实际这个条件为 <img src="https://math.now.sh?inline=Adj_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D%28y%29%20%5Csubset%20Adj_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D(x_%7Bi%7D)%20%5Ccup%20%5C%7Bx_%7Bi%7D%5C%7D%20-%20%5C%7By%5C%7D" style="display:inline-block;margin: 0;"/> ，需要减去其自身。因此 <img src="https://math.now.sh?inline=Deg_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D%28y%29%20%5Cleq%20Deg_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D(x_%7Bi%7D)" style="display:inline-block;margin: 0;"/> ，由于 <img src="https://math.now.sh?inline=x_%7Bi%7D" style="display:inline-block;margin: 0;"/> 在 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi-1%7D" style="display:inline-block;margin: 0;"/> 中度数最小，因此我们得到   <img src="https://math.now.sh?inline=Deg_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D%28y%29%20%3D%20Deg_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D(x_%7Bi%7D)" style="display:inline-block;margin: 0;"/>  ，这说明 <img src="https://math.now.sh?inline=Adj_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D%28y%29%20%3D%20Adj_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D(x_%7Bi%7D)%20%5Ccup%20%5C%7Bx_%7Bi%7D%5C%7D%20-%20%5C%7By%5C%7D" style="display:inline-block;margin: 0;"/> ，因此说明  <strong><img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 是不可区分的</strong>，易得 <img src="https://math.now.sh?inline=Deg_%7B%5Cmathcal%7BG%7D_%7Bi%7D%7D%28y%29%20%3D%20Deg_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D(x_%7Bi%7D)%20-%201" style="display:inline-block;margin: 0;"/> ，得证。</p>
</li>
</ol>
<p>总结一下，对于 <img src="https://math.now.sh?inline=Adj_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D%28x_%7Bi%7D%29" style="display:inline-block;margin: 0;"/> 中的节点，其在 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 中可能取到的度数的最小值为  <img src="https://math.now.sh?inline=Deg_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D%28x_%7Bi%7D%29%20-%201" style="display:inline-block;margin: 0;"/> ；对于其它节点，其在 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 中可能取到的度数的最小值为  <img src="https://math.now.sh?inline=Deg_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D%28x_%7Bi%7D%29" style="display:inline-block;margin: 0;"/> 。因此，在查找  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 中度数最小的节点时，可以先遍历  <img src="https://math.now.sh?inline=Adj_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D%28x_%7Bi%7D%29" style="display:inline-block;margin: 0;"/> 中的节点，只要存在度数小于等于  <img src="https://math.now.sh?inline=Deg_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D%28x_%7Bi%7D%29" style="display:inline-block;margin: 0;"/> 的节点，就可以在 <img src="https://math.now.sh?inline=Adj_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D%28x_%7Bi%7D%29" style="display:inline-block;margin: 0;"/> 中找到度数最小的节点，即下一次消元的节点。</p>
<h1>参考文献</h1>
<ol>
<li>George A, Liu J, Ng E. Computer solution of sparse linear systems[J]. Oak Ridge National Laboratory, 1994.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>稀疏矩阵</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>稀疏矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏矩阵算法最小度数算法二之商图</title>
    <url>/posts/aef04e13/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本章节介绍 <em>the minimum degree algorithm</em> ，我个人将其翻译为最小度数算法。这里我们看如何用商图表示和转换消元图。</p>
<span id="more"></span>
<h1>Computer Representation of Elimination Graphs</h1>
<p>在这一章节汇总，我们研究如何在计算中表示和转换 <em>elimination graphs</em> 。</p>
<h2 id="Explicit-and-Implicit-Representations">Explicit and Implicit Representations</h2>
<p>让我们回顾一下消元的转换过程，<img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 是从 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi-1%7D" style="display:inline-block;margin: 0;"/> 消除节点 <img src="https://math.now.sh?inline=x_%7Bi%7D" style="display:inline-block;margin: 0;"/> 得到的图，<img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的相邻结构可以按照下面的方式获得：</p>
<ol>
<li>
<p>获得  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi-1%7D" style="display:inline-block;margin: 0;"/> 中的相邻集合 <img src="https://math.now.sh?inline=Adj_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D%28x_%7Bi%7D%29" style="display:inline-block;margin: 0;"/></p>
</li>
<li>
<p>从相邻结构中移除节点 <img src="https://math.now.sh?inline=x_%7Bi%7D" style="display:inline-block;margin: 0;"/> 及其相邻列表</p>
</li>
<li>
<p>对于任何一个节点 <img src="https://math.now.sh?inline=y%20%5Cin%20Adj_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D%28x_%7Bi%7D%29" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/>  在 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 中新的相邻列表通过合并两个子集得到</p>
<p style=""><img src="https://math.now.sh?from=Adj_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D%28y%29%20-%20%5C%7Bx_%7Bi%7D%5C%7D%20%5Ctext%7B%20and%20%7D%20Adj_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D(x_%7Bi%7D)%20-%20%5C%7B%20y%20%5C%7D%0A" /></p></li>
</ol>
<p>这里有两点需要注意，首先在相邻结构中用于存储 <img src="https://math.now.sh?inline=Adj_%7B%5Cmathcal%7BG%7D_%7Bi-1%7D%7D%28x_%7Bi%7D%29" style="display:inline-block;margin: 0;"/> 的空间可以在第二步之后重复使用；第二，<img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 可能会比 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi-1%7D" style="display:inline-block;margin: 0;"/> 占用更多的空间。</p>
<p>我们需要一种更加灵活的数据结构，用于存储在 <em>elimination graphs</em>  中结构的动态变化，比如之前提到的 <em>adjacency linked list</em> 。</p>
<h2 id="Quotient-Graph-Model">Quotient Graph Model</h2>
<p>让我们首先对下面的图进行消元，我们消除节点 <img src="https://math.now.sh?inline=x_%7B1%7D" style="display:inline-block;margin: 0;"/> 到 <img src="https://math.now.sh?inline=x_%7B5%7D" style="display:inline-block;margin: 0;"/> 之后得到右边的消元图。</p>
<p><img src="64.png" alt="1"></p>
<p>设 <img src="https://math.now.sh?inline=S%20%3D%20%5C%7B%20x_%7B1%7D%2C%20x_%7B2%7D%2C%20x_%7B3%7D%2Cx_%7B4%7D%2C%20x_%7B5%7D%5C%7D" style="display:inline-block;margin: 0;"/> ，在 <em>implicit model</em> 中，为了发现 <img src="https://math.now.sh?inline=x_%7B6%7D%20%5Cin%20Reach%28x_%7B7%7D%2C%20S%29" style="display:inline-block;margin: 0;"/> ，我们必须先找到路径 <img src="https://math.now.sh?inline=%28x_%7B7%7D%2C%20x_%7B4%7D%2C%20x_%7B2%7D%2Cx_%7B5%7D%2C%20x_%7B6%7D%29" style="display:inline-block;margin: 0;"/> 。相似地， <img src="https://math.now.sh?inline=x_%7B8%7D%20%5Cin%20Reach%28x_%7B7%7D%2C%20S%29" style="display:inline-block;margin: 0;"/> 也是因为存在路径 <img src="https://math.now.sh?inline=%28x_%7B7%7D%2C%20x_%7B4%7D%2C%20x_%7B2%7D%2Cx_%7B5%7D%2C%20x_%7B1%7D%2C%20x_%7B8%7D%29" style="display:inline-block;margin: 0;"/> 。注意这两个路径的长度分别为 4 和 5 。</p>
<p>我们有两个观测结果：</p>
<ol>
<li>如果未消元的节点间的 reachable path 的长度可以缩减，那么生成 reachable sets 的工作量会降低</li>
<li>如果上面的这些路径可以缩减到极端的情况，那么我们就可以得到 <em>explicit elimination graphs</em> 。</li>
</ol>
<p>我们寻求一个妥协，通过聚集连接的消除的节点，我们获得了一个新的图结构。举个例子，在上面的图中，在图 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%28S%29" style="display:inline-block;margin: 0;"/> 中存在两个连通组分，分别为 <img src="https://math.now.sh?inline=%5C%7B%20x_%7B1%7D%2C%20x_%7B2%7D%2C%20x_%7B4%7D%2C%20x_%7B5%7D%20%5C%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5C%7Bx_%7B3%7D%5C%7D" style="display:inline-block;margin: 0;"/> 。通过形成两个 “supernodes”，我们获得下面的图</p>
<p><img src="65.png" alt="1"></p>
<p>为了方便，我们设  <img src="https://math.now.sh?inline=%5Cbar%7Bx%7D_%7B5%7D%20%3D%20%5C%7B%20x_%7B1%7D%2C%20x_%7B2%7D%2C%20x_%7B4%7D%2C%20x_%7B5%7D%20%5C%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cbar%7Bx%7D_%7B3%7D%20%3D%5C%7Bx_%7B3%7D%5C%7D" style="display:inline-block;margin: 0;"/> 来表示 <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> 中的这两个连通组分。在这个新图中，我们注意到存在路径</p>
<p style=""><img src="https://math.now.sh?from=%28x_%7B7%7D%2C%20%5Cbar%7Bx%7D_%7B5%7D%2C%20x_%7B6%7D%29%0A" /></p><p>和</p>
<p style=""><img src="https://math.now.sh?from=%28x_%7B7%7D%2C%20%5Cbar%7Bx%7D_%7B5%7D%2C%20x_%7B8%7D%29%0A" /></p><p>这两条路径的长度为 2，一般来说，如果采用这种策略，那么所有这样的路径的长度均会小于等于 2 。</p>
<p>这种策略的另一个优势可以 <em>implemented in-place</em> ，也就是说，这种方式不会占用比原始的图结构更多的空间。</p>
<p>为了正式描述这种消元方式，我们引入<strong>商图</strong> (<em>quotient graphs</em>) 。设 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%20%3D%20%28X%2CE%29" style="display:inline-block;margin: 0;"/> 是一个给定的图，设 <img src="https://math.now.sh?inline=%5Cmathcal%7BP%7D" style="display:inline-block;margin: 0;"/> 是一种基于节点集合 <img src="https://math.now.sh?inline=X" style="display:inline-block;margin: 0;"/> 的分隔形式</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathcal%7BP%7D%20%3D%20%5C%7BY_%7B1%7D%2CY_%7B2%7D%2C%5Ccdots%2CY_%7Bp%7D%5C%7D%0A" /></p><p>即 <img src="https://math.now.sh?inline=%5Ccup_%7Bk%3D1%7D%5E%7Bp%7D%20Y_%7Bk%7D%20%3D%20X" style="display:inline-block;margin: 0;"/> , <img src="https://math.now.sh?inline=Y_%7Bi%7D%20%5Ccap%20Y_%7Bj%7D%20%3D%20%5Cphi%2C%20i%20%5Cneq%20j" style="display:inline-block;margin: 0;"/></p>
<p>我们定义 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D" style="display:inline-block;margin: 0;"/> 基于 <img src="https://math.now.sh?inline=%5Cmathcal%7BP%7D" style="display:inline-block;margin: 0;"/> 的商图为图 <img src="https://math.now.sh?inline=%28%5Cmathcal%7BP%7D%2C%20%5Cmathcal%7B%5Cxi%7D%29" style="display:inline-block;margin: 0;"/>，其中当且仅当 <img src="https://math.now.sh?inline=Adj%28Y_%7Bi%7D%29%20%5Ccap%20Y_%7Bj%7D%20%5Cneq%20%5Cphi" style="display:inline-block;margin: 0;"/> 时 <img src="https://math.now.sh?inline=%5C%7B%20Y_%7Bi%7D%2C%20Y_%7Bj%7D%5C%7D%20%5Cin%20%5Cxi" style="display:inline-block;margin: 0;"/> 。通常我们将这个图标记为 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%2FP%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>上面图 5.3.2 就是一个商图，其切分方式为</p>
<p style=""><img src="https://math.now.sh?from=%5C%7B%20x_%7B1%7D%2C%20x_%7B2%7D%2C%20x_%7B4%7D%2C%20x_%7B5%7D%20%5C%7D%2C%5C%7Bx_%7B3%7D%5C%7D%2C%5C%7Bx_%7B6%7D%5C%7D%2C%5C%7Bx_%7B7%7D%5C%7D%2C%5C%7Bx_%7B8%7D%5C%7D%2C%5C%7Bx_%7B9%7D%5C%7D%0A" /></p><p>设  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%20%3D%20%28X%2CE%29" style="display:inline-block;margin: 0;"/> 是一个给定的图，我们考虑消元的一个阶段，其中 <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> 是已经消除的节点集合。我们现在将其联系为一个基于 <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> 的商图，定义集合</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathcal%7BC%7D%28S%29%20%3D%20%5C%7B%20C%20%5Csubset%20S%20%5Cmid%20%5Cmathcal%7BG%7D(C)%20%5Ctext%7B%20is%20a%20connected%20component%20in%20the%20subgraph%20%7D%20%5Cmathcal%7BG%7D(S)%20%5C%7D%0A" /></p><p>对 <img src="https://math.now.sh?inline=X" style="display:inline-block;margin: 0;"/> 的切分为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathcal%7B%5Cbar%7BC%7D%7D%28S%29%20%3D%20%5C%7B%20%5C%7By%5C%7D%20%5Cmid%20y%20%5Cin%20X-S%20%20%5C%7D%20%5Ccup%20%5Cmathcal%7BC%7D(S)%0A" /></p><p>则可以唯一地定义商图</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathcal%7BG%7D%20%2F%20%5Cmathcal%7B%5Cbar%7BC%7D%7D%28S%29%0A" /></p><p>则可以视为对 <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> 中的聚集的连通集合得到的图，图 5.3.2 就是对 <img src="https://math.now.sh?inline=S%20%3D%20%5C%7B%20x_%7B1%7D%2C%20x_%7B2%7D%2C%20x_%7B3%7D%2Cx_%7B4%7D%2C%20x_%7B5%7D%5C%7D" style="display:inline-block;margin: 0;"/> 生成的商图。我们现在研究消元过程中的商图间的相关性。设 <img src="https://math.now.sh?inline=x_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Ccdots%2C%20x_%7Bn%7D" style="display:inline-block;margin: 0;"/> 为给定图  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D" style="display:inline-block;margin: 0;"/>  消元的一系列节点，就像之前一样，设</p>
<p style=""><img src="https://math.now.sh?from=S_%7Bi%7D%20%3D%20%5C%7B%20x_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Ccdots%2C%20x_%7Bi%7D%5C%7D%2C%20%5Cquad%201%20%5Cleq%20i%20%5Cleq%20n%0A" /></p><p>对于每一个 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/>  ，子集 <img src="https://math.now.sh?inline=S_%7Bi%7D" style="display:inline-block;margin: 0;"/> 可以推导出分隔方式 <img src="https://math.now.sh?inline=%5Cmathcal%7B%5Cbar%7BC%7D%7D%28S_%7Bi%7D%29" style="display:inline-block;margin: 0;"/> ，而相应的商图为</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7Bi%7D%20%3D%20%5Cmathcal%7BG%7D%2F%5Cmathcal%7B%5Cbar%7BC%7D%7D%28S_%7Bi%7D%29%20%3D%20(%5Cmathcal%7B%5Cbar%7BC%7D%7D(S_%7Bi%7D)%2C%20%5Cmathcal%7B%5Cxi%7D_%7Bi%7D)%0A" /></p><p>用这种方式，我们可以得到一系列商图</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7B1%7D%20%5Crightarrow%20%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7B2%7D%20%5Crightarrow%20%5Ccdots%20%5Crightarrow%20%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7Bn%7D%0A" /></p><p>下图就是上面例子中的这一系列商图。</p>
<p><img src="66.png" alt="1"></p>
<p>下图的定理说明了上面商图其实就是 <em>elimination  graphs</em> 的另一种表示。</p>
<p><strong>定理 5.3.1</strong>：对于任意 <img src="https://math.now.sh?inline=y%20%5Cin%20X%20-%20S_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，我们有</p>
<p style=""><img src="https://math.now.sh?from=Reach_%7B%5Cmathcal%7BG%7D%7D%28y%2C%20S_%7Bi%7D%29%20%3D%20Reach_%7B%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7Bi%7D%7D(y%2C%20%5Cmathcal%7BC%7D(S_%7Bi%7D))%0A" /></p><p>证明略</p>
<p>确定在商图 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的 <em>reachable set</em> 很直接，对于一个给定的节点 <img src="https://math.now.sh?inline=y%20%5Cnotin%20%5Cmathcal%7BC%7D%28S_%7Bi%7D%29" style="display:inline-block;margin: 0;"/>  ，下面的算法会返回集合 <img src="https://math.now.sh?inline=Reach_%7B%5Cmathcal%7BG%7D_%7Bi%7D%7D%28y%2C%20%5Cmathcal%7BC%7D(S_%7Bi%7D%29)" style="display:inline-block;margin: 0;"/> ，注意这里应用了商图的 <em>reachable path</em> 长度最多为 2 的特性 。</p>
<p><img src="67.png" alt="1"></p>
<p>实际上我们可以从商图中获得 <em>elimination graph</em> ，算法如下：</p>
<p><img src="68.png" alt="1"></p>
<p>为了说明这个事先，我们考虑上例中从 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7B4%7D" style="display:inline-block;margin: 0;"/> 生成 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7B4%7D" style="display:inline-block;margin: 0;"/> 的过程（加粗表示商图，不加粗表示 <em>elimination graph</em> ），见下图</p>
<p><img src="69.png" alt="1"></p>
<p>商图模型处于两种模型的中间</p>
<p><img src="70.png" alt="1"></p>
<p>这三种模型的对应关系总结如下表</p>
<p><img src="71.png" alt="1"></p>
<h2 id="Implementation-of-the-Quotient-Graph-Model">Implementation of the Quotient Graph Model</h2>
<p>我们考虑由消除的节点集合 <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> 形成的商图 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7Bi%7D%20%3D%20%5Cmathcal%7BG%7D%2F%5Cmathcal%7B%5Cbar%7BC%7D%7D%28S_%7Bi%7D%29" style="display:inline-block;margin: 0;"/> ，如果 <img src="https://math.now.sh?inline=s%20%5Cin%20S" style="display:inline-block;margin: 0;"/> ，我们采用符号 <img src="https://math.now.sh?inline=%5Cbar%7Bs%7D" style="display:inline-block;margin: 0;"/> 来表明在子图 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%28S%29" style="display:inline-block;margin: 0;"/> 中的包含 <img src="https://math.now.sh?inline=s" style="display:inline-block;margin: 0;"/> 的连通组分。比如，在上面的例子中</p>
<p style=""><img src="https://math.now.sh?from=%5Cbar%7Bx%7D_%7B5%7D%20%3D%20%5Cbar%7Bx%7D_%7B1%7D%20%3D%20%5Cbar%7Bx%7D_%7B2%7D%20%3D%20%5Cbar%7Bx%7D_%7B4%7D%20%3D%20%5C%7B%20x_1%2Cx_2%2Cx_4%2Cx_5%5C%7D%0A" /></p><p>换句话说，对于一个给定的连通组分 <img src="https://math.now.sh?inline=C%20%5Csubset%20%5Cmathcal%7BC%7D%28S%29" style="display:inline-block;margin: 0;"/> ，我们可以选择 <img src="https://math.now.sh?inline=C" style="display:inline-block;margin: 0;"/> 中的任意一个节点 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> ，然后使用 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 来表示 <img src="https://math.now.sh?inline=C" style="display:inline-block;margin: 0;"/> ，即 <img src="https://math.now.sh?inline=%5Cbar%7Bx%7D%20%3D%20C" style="display:inline-block;margin: 0;"/> 。在我们讨论如何选择 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 之前，我们先证明商图模型可以 <em>implemented in-place</em> ，也就是说，只利用原始图的相邻结构的空间。</p>
<p><strong>引理 5.3.2</strong>：设 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%20%3D%20%28X%2CE%29" style="display:inline-block;margin: 0;"/> , <img src="https://math.now.sh?inline=C%20%5Csubset%20X" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%28C%29" style="display:inline-block;margin: 0;"/> 是一个连通的子图，那么我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bx%20%5Cin%20C%7D%7CAdj%28x%29%7C%20%5Cgeq%20%7CAdj(C)%7C%20%2B%202(%7CC%7C%20-%201)%0A" /></p><p><strong>证明</strong>：因为  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%28C%29" style="display:inline-block;margin: 0;"/> 是一个连通子图，因此在   <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%28C%29" style="display:inline-block;margin: 0;"/> 中至少有 <img src="https://math.now.sh?inline=%7CC%7C-1" style="display:inline-block;margin: 0;"/> 条边，这些边在 <img src="https://math.now.sh?inline=%5Csum_%7Bx%20%5Cin%20C%7D%7CAdj%28x%29%7C" style="display:inline-block;margin: 0;"/> 中会计算两次，得证。</p>
<p>设 <img src="https://math.now.sh?inline=x_%7B1%7D%2Cx_%7B2%7D%2C%5Ccdots%2C%20x_%7Bn%7D" style="display:inline-block;margin: 0;"/> 是节点序列，<img src="https://math.now.sh?inline=S_%7Bi%7D%20%3D%20%5C%7B%20x_%7B1%7D%2C%5Ccdots%2Cx_%7Bi%7D%5C%7D" style="display:inline-block;margin: 0;"/> ，对于 <img src="https://math.now.sh?inline=1%20%5Cleq%20i%20%5Cleq%20n" style="display:inline-block;margin: 0;"/> ，我们有：</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7Bi%7D%20%3D%20%5Cmathcal%7BG%7D%2F%5Cmathcal%7B%5Cbar%7BC%7D%7D%28S_%7Bi%7D%29%20%3D%20(%5Cmathcal%7B%5Cbar%7BC%7D%7D(S_%7Bi%7D)%2C%20%5Cmathcal%7B%5Cxi%7D_%7Bi%7D)%0A" /></p><p><strong>引理 5.3.3</strong>：设 <img src="https://math.now.sh?inline=y%20%5Cin%20X%20-%20S_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，那么</p>
<p style=""><img src="https://math.now.sh?from=%7CAdj_%7B%5Cmathcal%7BG%7D%7D%28y%29%7C%20%5Cgeq%20%7CAdj_%7B%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7Bi%7D%7D(y)%7C%0A" /></p><p>证明：<img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 的相邻节点可以分为两类，属于 <img src="https://math.now.sh?inline=S_%7Bi%7D" style="display:inline-block;margin: 0;"/> 和 不属于  <img src="https://math.now.sh?inline=S_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的节点。对于不属于  <img src="https://math.now.sh?inline=S_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的节点，原图和商图均不受影响；对于属于 <img src="https://math.now.sh?inline=S_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的节点，商图可能会合并成一个 “supernode”，因此数目会减少。因此得证 <img src="https://math.now.sh?inline=%7CAdj_%7B%5Cmathcal%7BG%7D%7D%28y%29%7C%20%5Cgeq%20%7CAdj_%7B%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7Bi%7D%7D(y)%7C" style="display:inline-block;margin: 0;"/> 。</p>
<p>同时容易证明 <img src="https://math.now.sh?inline=%7CAdj_%7B%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7Bi%7D%7D%28y%29%7C%20%5Cgeq%20%7CAdj_%7B%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7Bi%2B1%7D%7D(y)%7C" style="display:inline-block;margin: 0;"/> ，如果 <img src="https://math.now.sh?inline=x_%7Bi%2B1%7D%20%5Cnotin%20Adj_%7B%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7Bi%7D%7D%28y%29" style="display:inline-block;margin: 0;"/> ，那么 无论<img src="https://math.now.sh?inline=x_%7Bi%2B1%7D" style="display:inline-block;margin: 0;"/> 是否与其它节点进行合并，都不会影响 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 的相邻节点数目，因此 <img src="https://math.now.sh?inline=%7CAdj_%7B%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7Bi%7D%7D%28y%29%7C%20%3D%20%7CAdj_%7B%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7Bi%2B1%7D%7D(y)%7C" style="display:inline-block;margin: 0;"/>。如果  <img src="https://math.now.sh?inline=x_%7Bi%2B1%7D%20%5Cin%20Adj_%7B%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7Bi%7D%7D%28y%29" style="display:inline-block;margin: 0;"/> ，此时如果 <img src="https://math.now.sh?inline=x_%7Bi%2B1%7D" style="display:inline-block;margin: 0;"/> 是孤立的，那么 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 的相邻节点不变，如果  <img src="https://math.now.sh?inline=x_%7Bi%2B1%7D" style="display:inline-block;margin: 0;"/> 与其它节点进行合并，那么此时 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 的相邻节点数目要么不变，要么会减1。因此得证成立。</p>
<p><strong>定理 5.3.4</strong>：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmax_%7Bi%20%5Cleq%20i%20%5Cleq%20n%7D%20%7C%5Cmathcal%7B%5Cxi%7D_%7Bi%7D%7C%20%5Cleq%20%7CE%7C%0A" /></p><p>证明：考虑商图 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7Bi%2B1%7D" style="display:inline-block;margin: 0;"/> ，如果 <img src="https://math.now.sh?inline=x_%7Bi%2B1%7D" style="display:inline-block;margin: 0;"/> 在子图 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%28S_%7Bi%2B1%7D%29" style="display:inline-block;margin: 0;"/> 中是孤立的，那么显然 <img src="https://math.now.sh?inline=%7C%5Cmathcal%7B%5Cxi%7D_%7Bi%2B1%7D%7C%20%3D%20%7C%5Cmathcal%7B%5Cxi%7D_%7Bi%7D%7C" style="display:inline-block;margin: 0;"/> ；否则 <img src="https://math.now.sh?inline=x_%7Bi%2B1%7D" style="display:inline-block;margin: 0;"/> 会合并到 <img src="https://math.now.sh?inline=S_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的某个连通组分中，形成 <img src="https://math.now.sh?inline=S_%7Bi%2B1%7D" style="display:inline-block;margin: 0;"/> ，那么消元节点内的边数目不变，而根据  <img src="https://math.now.sh?inline=%7CAdj_%7B%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7Bi%7D%7D%28y%29%7C%20%5Cgeq%20%7CAdj_%7B%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7Bi%2B1%7D%7D(y)%7C" style="display:inline-block;margin: 0;"/>  ，说明不属于 <img src="https://math.now.sh?inline=S_%7Bi%2B1%7D" style="display:inline-block;margin: 0;"/> 的节点的边的数目最多和之前相等，再加上减少的  <img src="https://math.now.sh?inline=x_%7Bi%2B1%7D" style="display:inline-block;margin: 0;"/> 的边，因此得到  <img src="https://math.now.sh?inline=%7C%5Cmathcal%7B%5Cxi%7D_%7Bi%2B1%7D%7C%20%3C%20%7C%5Cmathcal%7B%5Cxi%7D_%7Bi%7D%7C" style="display:inline-block;margin: 0;"/> ，因此在所有的情况中均存在  <img src="https://math.now.sh?inline=%7C%5Cmathcal%7B%5Cxi%7D_%7Bi%2B1%7D%7C%20%5Cleq%20%7C%5Cmathcal%7B%5Cxi%7D_%7Bi%7D%7C" style="display:inline-block;margin: 0;"/> ，因此得证 <img src="https://math.now.sh?inline=%5Cmax_%7Bi%20%5Cleq%20i%20%5Cleq%20n%7D%20%7C%5Cmathcal%7B%5Cxi%7D_%7Bi%7D%7C%20%5Cleq%20%7CE%7C" style="display:inline-block;margin: 0;"/> 。</p>
<p>这个定理说明通过消元生成的商图占用的空间不会超过原始的图，而且通过引理 5.3.2，对于 <img src="https://math.now.sh?inline=%7CC%7C%20%3E1" style="display:inline-block;margin: 0;"/> ，会富裕出 <img src="https://math.now.sh?inline=2%28%7CC%7C%20-%201%29" style="display:inline-block;margin: 0;"/> 个位置。</p>
<p>设 <img src="https://math.now.sh?inline=x_%7B1%7D%2Cx_%7B2%7D%2C%5Ccdots%2C%20x_%7Bn%7D" style="display:inline-block;margin: 0;"/> 是节点序列，<img src="https://math.now.sh?inline=C%20%5Cin%20C%28S%29" style="display:inline-block;margin: 0;"/> 。我们选择 <img src="https://math.now.sh?inline=x_%7Br%7D%20%5Cin%20C" style="display:inline-block;margin: 0;"/> 作为 <img src="https://math.now.sh?inline=C" style="display:inline-block;margin: 0;"/>的代表，其中</p>
<p style=""><img src="https://math.now.sh?from=r%20%3D%20%5Cmax%5C%7Bj%20%5Cmid%20x_%7Bj%7D%20%5Cin%20%20C%5C%7D%0A" /></p><p>也就是说，<img src="https://math.now.sh?inline=x_%7Br%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=C" style="display:inline-block;margin: 0;"/> 中最后消除的节点。</p>
<p>到此为止，我们描述了商图的数据结构以及如何表示 <em>supernodes</em> ，另一个重要的部分就是在消元的过程中商图的转换。下面的算法展现了如何从  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7Bi-1%7D" style="display:inline-block;margin: 0;"/> 中剔除节点 <img src="https://math.now.sh?inline=x_%7Bi%7D" style="display:inline-block;margin: 0;"/> 得到  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p><img src="72.png" alt="1"></p>
<p>让我们用图 5.3.3 中从  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7B4%7D" style="display:inline-block;margin: 0;"/> 到 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7B5%7D" style="display:inline-block;margin: 0;"/> 的过程为例，在  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7B4%7D" style="display:inline-block;margin: 0;"/> 中 <img src="https://math.now.sh?inline=C%28S_%7B4%7D%29%20%3D%20%5C%7B%5Cbar%7Bx%7D_%7B1%7D%2C%5Cbar%7Bx%7D_%7B3%7D%2C%5Cbar%7Bx%7D_%7B4%7D%5C%7D" style="display:inline-block;margin: 0;"/> ，我们对 <img src="https://math.now.sh?inline=x_%7B5%7D" style="display:inline-block;margin: 0;"/> 采用第一步，得到</p>
<p style=""><img src="https://math.now.sh?from=T%20%3D%20%5C%7B%5Cbar%7Bx%7D_%7B1%7D%2C%5Cbar%7Bx%7D_%7B4%7D%5C%7D%0A" /></p><p>和</p>
<p style=""><img src="https://math.now.sh?from=R%20%3D%20%5C%7Bx_%7B6%7D%2Cx_%7B7%7D%2Cx_%7B8%7D%5C%7D%0A" /></p><p>因此，新的 ”supernode“ 为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbar%7Bx%7D_%7B5%7D%20%3D%20%5C%7B%20x_%7B5%7D%20%5C%7D%20%5Ccup%20%5Cbar%7Bx%7D_%7B1%7D%20%5Ccup%20%5Cbar%7Bx%7D_%7B4%7D%20%3D%20%5C%7B%20x_%7B1%7D%2Cx_%7B2%7D%2Cx_%7B4%7D%2Cx_%7B5%7D%5C%7D%0A" /></p><p>新的拆分方式为</p>
<p style=""><img src="https://math.now.sh?from=C%28S_%7B5%7D%29%20%3D%20%20%5C%7B%20%5Cbar%7Bx%7D_%7B3%7D%2C%20%5Cbar%7Bx%7D_%7B5%7D%20%5C%7D%0A" /></p><p>最后，在第三步我们更新相邻集合，得到</p>
<p style=""><img src="https://math.now.sh?from=Adj_%7B%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7B5%7D%7D%28%5Cbar%7Bx%7D_%7B5%7D%29%20%3D%20R%20%3D%20%5C%7Bx_%7B6%7D%2Cx_%7B7%7D%2Cx_%7B8%7D%5C%7D%0A" /></p><p>和</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AAdj_%7B%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7B5%7D%7D%28x_%7B6%7D%29%20%26%3D%20%5C%7B%20%5Cbar%7Bx%7D_%7B5%7D%2C%20x_%7B8%7D%5C%7D%20%5C%5C%0AAdj_%7B%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7B5%7D%7D(x_%7B7%7D)%20%26%3D%20%5C%7B%20%5Cbar%7Bx%7D_%7B5%7D%5C%7D%20%5C%5C%0AAdj_%7B%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7B5%7D%7D(x_%7B8%7D)%20%26%3D%20%5C%7B%20%5Cbar%7Bx%7D_%7B3%7D%20%2C%20%5Cbar%7Bx%7D_%7B5%7D%20%2C%20x_%7B6%7D%20%2C%20x_%7B9%7D%20%5C%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>商图转换的效果可以通过一个例子来说明，采用图 5.3.3 中的例子，其中我们其相邻结构如图 5.3.6 所示。图 5.3.7 展示生成商图的一些步骤，在  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 到 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7B3%7D" style="display:inline-block;margin: 0;"/> 的形成过程中，相邻结构没有改变。而从  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7B3%7D" style="display:inline-block;margin: 0;"/> 到 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7B4%7D" style="display:inline-block;margin: 0;"/> 的转换过程中，节点 <img src="https://math.now.sh?inline=x_%7B2%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=x_%7B4%7D" style="display:inline-block;margin: 0;"/> 聚合到了一起，因此在 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7B4%7D" style="display:inline-block;margin: 0;"/> 中，节点 <img src="https://math.now.sh?inline=x_%7B4%7D" style="display:inline-block;margin: 0;"/> 的新的相邻结构包含了原图中 <img src="https://math.now.sh?inline=%5C%7Bx_%7B2%7D%2C%20x_%7B4%7D%5C%7D" style="display:inline-block;margin: 0;"/> 的相邻结构。这里 <img src="https://math.now.sh?inline=x_%7B4%7D" style="display:inline-block;margin: 0;"/> 的相邻列表的最后位置采用了一个链表（貌似是其相邻节点排好序，先放到 <img src="https://math.now.sh?inline=x_%7B4%7D" style="display:inline-block;margin: 0;"/> 的相邻列表中第1个到倒数第二个位置，还有多的再放到其它节点的相邻列表中。<strong>此时最后一个位置的链接采用负数，这里就是 -2</strong> 。将相邻节点最后一个位置之后的一个位置<strong>设为0</strong>，表示终止位置，对应下图中划线的方块 ）。注意在 <img src="https://math.now.sh?inline=x_%7B5%7D" style="display:inline-block;margin: 0;"/> 的相邻列表中，其相邻节点 <img src="https://math.now.sh?inline=x_%7B2%7D" style="display:inline-block;margin: 0;"/> 在 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cmathcal%7BG%7D%7D_%7B4%7D" style="display:inline-block;margin: 0;"/> 中改为了 <img src="https://math.now.sh?inline=x_%7B4%7D" style="display:inline-block;margin: 0;"/> ，因此此时 <img src="https://math.now.sh?inline=x_%7B4%7D" style="display:inline-block;margin: 0;"/> 已经变成了子集 <img src="https://math.now.sh?inline=%5C%7Bx_%7B2%7D%2C%20x_%7B4%7D%5C%7D" style="display:inline-block;margin: 0;"/> 的代表。</p>
<p><img src="73.png" alt="1"></p>
<p><img src="74.png" alt="1"></p>
<h1>参考文献</h1>
<ol>
<li>George A, Liu J, Ng E. Computer solution of sparse linear systems[J]. Oak Ridge National Laboratory, 1994.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>稀疏矩阵</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>稀疏矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏矩阵算法最小度数算法一之消元图</title>
    <url>/posts/9b2dddf7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本章节介绍 <em>the minimum degree algorithm</em> ，我个人将其翻译为最小度数算法，我们这里看消元图的理论基础。</p>
<span id="more"></span>
<p>在这一章节中我们研究的排序算法称为 <em><strong>minimum degree algorithm</strong></em> (Rose) ，这是一个启发式算法，用于对 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 排序减少其分解时产生的 <code>fill-in</code>  数目。</p>
<h1>Cholesky 分解</h1>
<p>设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 是一个对称稀疏矩阵，其中的<strong>非零结构</strong> (<em>nonzero structure</em>) 定义为</p>
<p style=""><img src="https://math.now.sh?from=Nonz%28%5Cmathbf%7BA%7D%29%20%3D%20%5C%7B%20%5C%7B%20i%2Cj%20%5C%7D%20%5Cmid%20a_%7Bij%7D%20%5Cneq%200%20%5Ctext%7B%20and%20%7D%20i%20%5Cneq%20j%20%5C%7D%0A" /></p><p>假设  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 分解为 <img src="https://math.now.sh?inline=%5Cmathbf%7BLL%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/> ，而 <em>filled matrix</em> <img src="https://math.now.sh?inline=%5Cmathbf%7BF%28A%29%EF%BC%9DL%2BL%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/>，下文中我们用 <img src="https://math.now.sh?inline=%5Cmathbf%7BF%7D" style="display:inline-block;margin: 0;"/> 替换 <img src="https://math.now.sh?inline=%5Cmathbf%7BF%28A%29%7D" style="display:inline-block;margin: 0;"/> ，其相应的非零结构为</p>
<p style=""><img src="https://math.now.sh?from=Nonz%28%5Cmathbf%7BF%7D%29%20%3D%20%5C%7B%20%5C%7B%20i%2Cj%20%5C%7D%20%5Cmid%20l_%7Bij%7D%20%5Cneq%200%20%5Ctext%7B%20and%20%7D%20i%20%5Cneq%20j%20%5C%7D%0A" /></p><p>在本文中，<strong>我们假设精确的数值消除并不存在</strong>（就是说任意两个浮点数相减不能得到0），因此对于一个给定的非零结构 <img src="https://math.now.sh?inline=Nonz%28%5Cmathbf%7BA%7D%29" style="display:inline-block;margin: 0;"/>，其相应的 <img src="https://math.now.sh?inline=Nonz%28%5Cmathbf%7BF%7D%29" style="display:inline-block;margin: 0;"/> 的结构就能完全确定。</p>
<p>这个假设立刻推导出</p>
<p style=""><img src="https://math.now.sh?from=Nonz%28%5Cmathbf%7BA%7D%29%20%5Csubset%20Nonz(%5Cmathbf%7BF%7D)%0A" /></p><p>矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的 <em>fill</em> 可以定义为</p>
<p style=""><img src="https://math.now.sh?from=Fill%28%5Cmathbf%7BA%7D%29%20%3D%20Nonz(%5Cmathbf%7BF%7D)%20-%20Nonz(%5Cmathbf%7BA%7D)%0A" /></p><p>举个例子，假设存在下图中的矩阵，其中的 <em>fill-in</em> 用加号表示，其相应的集合为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7BNonz%7D%28%5Cboldsymbol%7BA%7D%29%20%26%3D%5C%7B%5C%7B1%2C5%5C%7D%2C%5C%7B1%2C8%5C%7D%2C%5C%7B2%2C4%5C%7D%2C%5C%7B2%2C5%5C%7D%2C%5C%7B3%2C8%5C%7D%2C%5C%7B4%2C7%5C%7D%2C%5C%7B5%2C6%5C%7D%2C%5C%7B6%2C8%5C%7D%2C%5C%7B8%2C9%5C%7D%5C%7D%20%5C%5C%0A%5Coperatorname%7BFill%7D(%5Cboldsymbol%7BA%7D)%20%26%3D%5C%7B%5C%7B4%2C5%5C%7D%2C%5C%7B5%2C7%5C%7D%2C%5C%7B5%2C8%5C%7D%2C%5C%7B6%2C7%5C%7D%2C%5C%7B7%2C8%5C%7D%5C%7D%20.%0A%5Cend%7Baligned%7D%0A" /></p><p><img src="56.png" alt="1"></p>
<h2 id="Elimation-Graph-Model">Elimation Graph Model</h2>
<p>我们现在联系 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的高斯消元，与相应的图 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%5E%7B%5Cmathbf%7BA%7D%7D" style="display:inline-block;margin: 0;"/> 的变化。我们回顾一下分解的 <em>outer product form</em> ，第一步为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cboldsymbol%7BA%7D%20%26%3D%5Cboldsymbol%7BA%7D_%7B0%7D%3D%5Cboldsymbol%7BH%7D_%7B0%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D%0Ad_%7B1%7D%20%26%20%5Cboldsymbol%7Bv%7D_%7B1%7D%5E%7BT%7D%20%5C%5C%0A%5Cboldsymbol%7Bv%7D_%7B1%7D%20%26%20%5Coverline%7B%5Cboldsymbol%7BH%7D%7D_%7B1%7D%0A%5Cend%7Barray%7D%5Cright%29%20%5C%5C%0A%26%3D%5Cleft(%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Csqrt%7Bd_%7B1%7D%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cfrac%7B%5Cboldsymbol%7Bv%7D_%7B1%7D%7D%7B%5Csqrt%7Bd_%7B1%7D%7D%7D%20%26%20%5Cboldsymbol%7BI%7D_%7Bn-1%7D%0A%5Cend%7Barray%7D%5Cright)%5Cleft(%5Cbegin%7Barray%7D%7Bcc%7D%0A1%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cboldsymbol%7BH%7D_%7B1%7D%0A%5Cend%7Barray%7D%5Cright)%5Cleft(%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Csqrt%7Bd_%7B1%7D%7D%20%26%20%5Cfrac%7B%5Cboldsymbol%7Bv%7D_%7B1%7D%5E%7BT%7D%7D%7B%5Csqrt%7Bd_%7B1%7D%7D%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cboldsymbol%7BI%7D_%7Bn-1%7D%0A%5Cend%7Barray%7D%5Cright)%20%5C%5C%0A%26%3D%5Cboldsymbol%7BL%7D_%7B1%7D%20%5Cboldsymbol%7BA%7D_%7B1%7D%20%5Cboldsymbol%7BL%7D_%7B1%7D%5E%7BT%7D%2C%0A%5Cend%7Baligned%7D%0A" /></p><p>其中</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7BH%7D_%7B1%7D%3D%5Coverline%7B%5Cboldsymbol%7BH%7D%7D_%7B1%7D-%5Cfrac%7B%5Cboldsymbol%7Bv%7D_%7B1%7D%20%5Cboldsymbol%7Bv%7D_%7B1%7D%5E%7BT%7D%7D%7Bd_%7B1%7D%7D%0A" /></p><p>这一步会递归地应用于 <img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D_%7B1%7D" style="display:inline-block;margin: 0;"/>， <img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> 等。由于我们假设不存在精准的消除，因此根据上面的公式，如果 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Cbar%7BH%7D_%7B1%7D%7D" style="display:inline-block;margin: 0;"/> 中的   <img src="https://math.now.sh?inline=%5C%7Bj%2Ck%5C%7D" style="display:inline-block;margin: 0;"/>  元素不为0，或者 <img src="https://math.now.sh?inline=%28v_%7B1%7D%29_%7Bj%7D%20%5Cneq%200%20%5Ctext%7B%20and%20%7D%20(v_%7B1%7D)_%7Bk%7D%20%5Cneq%200" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 矩阵的 <img src="https://math.now.sh?inline=%5C%7Bj%2Ck%5C%7D" style="display:inline-block;margin: 0;"/> 元素才不为0。当第一个条件不成立，而第二个条件成立时，便产生了 <em>fill-in</em> 。下图中展示了这个情况</p>
<p><img src="57.png" alt="1"></p>
<p>当第一步分解完成之后，我们对  <img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 矩阵继续进行分解。</p>
<p>现在我们看从  <img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D_%7B0%7D" style="display:inline-block;margin: 0;"/> 到  <img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 的转变过程中，其相应的图从 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%5E%7B%5Cmathbf%7BH%7D_%7B0%7D%7D" style="display:inline-block;margin: 0;"/> 到 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%5E%7B%5Cmathbf%7BH%7D_%7B1%7D%7D" style="display:inline-block;margin: 0;"/>的变化，下图是一个例子。生成图  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%5E%7B%5Cmathbf%7BH%7D_%7B1%7D%7D" style="display:inline-block;margin: 0;"/>的过程如下</p>
<ol>
<li>删除节点 <img src="https://math.now.sh?inline=x_%7B1%7D" style="display:inline-block;margin: 0;"/> 及其相应的边</li>
<li>添加边，使得图  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%5E%7B%5Cmathbf%7BH%7D_%7B1%7D%7D" style="display:inline-block;margin: 0;"/>中的 <img src="https://math.now.sh?inline=Adj%28x_%7B1%7D%29" style="display:inline-block;margin: 0;"/> 彼此之间相邻</li>
</ol>
<p><img src="58.png" alt="1"></p>
<p>因此，就像 Rose 观察到的，对称矩阵的高斯消元（上面的 <img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D_%7B1%7D" style="display:inline-block;margin: 0;"/>， <img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> 等其实也一样就是高斯消元的结果 ）可以理解为生成一系列 <em>elimination graphs</em></p>
<p style=""><img src="https://math.now.sh?from=%5Cmathcal%7BG%7D_%7Bi%7D%5E%7B%5Calpha%7D%3D%5Cmathcal%7BG%7D%5E%7B%5Cboldsymbol%7BH%7D_%7Bi%7D%7D%3D%5Cleft%28X_%7Bi%7D%5E%7B%5Calpha%7D%2C%20E_%7Bi%7D%5E%7B%5Calpha%7D%5Cright%29%2C%20%5Cquad%20i%3D1%2C2%2C%20%5Ccdots%2C%20n-1%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi%7D%5E%7B%5Calpha%7D" style="display:inline-block;margin: 0;"/> 是从 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi-1%7D%5E%7B%5Calpha%7D" style="display:inline-block;margin: 0;"/> 中得到的，过程就和上面描述的一样。这里 <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/> 是所有节点的标签，当我们已知所有节点的标签时，我们用标记 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 替换 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi%7D%5E%7B%5Calpha%7D" style="display:inline-block;margin: 0;"/> 。在上图的消元过程，比如从  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 消除 <img src="https://math.now.sh?inline=x_%7B2%7D" style="display:inline-block;margin: 0;"/> 的过程中，产生了三个 <em>fill-in</em> 的边 <img src="https://math.now.sh?inline=%5C%7Bx_%7B3%7D%2C%20x_%7B4%7D%5C%7D%2C%20%5C%7Bx_%7B3%7D%2C%20x_%7B6%7D%5C%7D%2C%20%5C%7Bx_%7B4%7D%2C%20x_%7B6%7D%5C%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>设 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的分解因子，定义 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%5E%7B%5Cmathbf%7BA%7D%7D" style="display:inline-block;margin: 0;"/>的 <em>filled graph</em> 为  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%5E%7B%5Cmathbf%7BF%7D%7D%20%3D%20%28X%5E%7B%5Cmathbf%7BF%7D%7D%2CE%5E%7B%5Cmathbf%7BF%7D%7D%29" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BF%20%3D%20L%20%2B%20L%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/> 。这里所有边的集合 <img src="https://math.now.sh?inline=E%5E%7B%5Cmathbf%7BF%7D%7D" style="display:inline-block;margin: 0;"/>包含了 <img src="https://math.now.sh?inline=E%5E%7B%5Cmathbf%7BA%7D%7D" style="display:inline-block;margin: 0;"/> 中的所有边，加上分解过程中新增的边。</p>
<p><img src="https://math.now.sh?inline=E%5E%7B%5Cmathbf%7BF%7D%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=E%5E%7B%5Cmathbf%7BA%7D%7D" style="display:inline-block;margin: 0;"/> 的关系存在以下引理 (Parter)</p>
<p><strong>引理</strong>：当且仅当 <img src="https://math.now.sh?inline=%5C%7B%20x_%7Bi%7D%2C%20x_%7Bj%7D%5C%7D%20%5Cin%20E%5E%7B%5Cmathbf%7BA%7D%7D" style="display:inline-block;margin: 0;"/>，或者  <img src="https://math.now.sh?inline=%5C%7B%20x_%7Bi%7D%2C%20x_%7Bk%7D%5C%7D%20%5Cin%20E%5E%7B%5Cmathbf%7BF%7D%7D" style="display:inline-block;margin: 0;"/> and  <img src="https://math.now.sh?inline=%5C%7B%20x_%7Bk%7D%2C%20x_%7Bj%7D%5C%7D%20%5Cin%20E%5E%7B%5Cmathbf%7BF%7D%7D" style="display:inline-block;margin: 0;"/> for some <img src="https://math.now.sh?inline=k%20%3C%20%5Cmin%5C%7Bi%2Cj%5C%7D" style="display:inline-block;margin: 0;"/> ，才满足 <img src="https://math.now.sh?inline=%5C%7B%20x_%7Bi%7D%2C%20x_%7Bj%7D%5C%7D%20%5Cin%20E%5E%7B%5Cmathbf%7BF%7D%7D" style="display:inline-block;margin: 0;"/></p>
<p>根据这个引理，上图中得到的 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%5E%7B%5Cmathbf%7BF%7D%7D" style="display:inline-block;margin: 0;"/> 如下。发现了  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%5E%7B%5Cmathbf%7BF%7D%7D" style="display:inline-block;margin: 0;"/> ，我们就可以得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 矩阵的结构。</p>
<p><img src="59.png" alt="1"></p>
<h2 id="Modelling-Elimination-By-Reachable-Sets">Modelling Elimination By Reachable Sets</h2>
<p>上面的章节中定义了 <em>elimination graphs</em> 的序列</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathcal%7BG%7D_%7B0%7D%20%5Crightarrow%20%5Cmathcal%7BG%7D_%7B1%7D%20%5Crightarrow%20%5Ccdots%20%5Crightarrow%20%5Cmathcal%7BG%7D_%7Bn-1%7D%0A" /></p><p>然后提供了一种递归的方式来确认 <img src="https://math.now.sh?inline=E%5E%7B%5Cmathbf%7BF%7D%7D" style="display:inline-block;margin: 0;"/> ，我们这一章节的目标是采用 <em><strong>reachable sets</strong></em> 的概念来确认这些步骤。</p>
<p>让我们首先研究在上图中 <em>fill edge</em> <img src="https://math.now.sh?inline=%5C%7B%20x_%7B4%7D%2C%20x_%7B6%7D%20%5C%7D" style="display:inline-block;margin: 0;"/> 的形成过程。在 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> ，存在路径：</p>
<p style=""><img src="https://math.now.sh?from=%28x_%7B4%7D%2C%20x_%7B2%7D%2C%20x_%7B6%7D%29%0A" /></p><p>因此当 <img src="https://math.now.sh?inline=x_%7B2%7D" style="display:inline-block;margin: 0;"/> 被消除，被创建了 <img src="https://math.now.sh?inline=%5C%7B%20x_%7B4%7D%2C%20x_%7B6%7D%20%5C%7D" style="display:inline-block;margin: 0;"/> 这条边。然而，<img src="https://math.now.sh?inline=%5C%7B%20x_%7B2%7D%2C%20x_%7B6%7D%20%5C%7D" style="display:inline-block;margin: 0;"/> 并不在原始的图中，这条边是由于路径 <img src="https://math.now.sh?inline=%28x_%7B2%7D%2C%20x_%7B1%7D%2C%20x_%7B6%7D%29" style="display:inline-block;margin: 0;"/> 中的 <img src="https://math.now.sh?inline=x_%7B1%7D" style="display:inline-block;margin: 0;"/> 从  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7B0%7D" style="display:inline-block;margin: 0;"/> 中消除而创建得到的。</p>
<p>联合这两个，我们得到  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7B0%7D" style="display:inline-block;margin: 0;"/> 中的路径 <img src="https://math.now.sh?inline=%28x_%7B4%7D%2C%20x_%7B2%7D%2C%20x_%7B1%7D%2C%20x_%7B6%7D%29" style="display:inline-block;margin: 0;"/> 才是生成  <em>fill edge</em> <img src="https://math.now.sh?inline=%5C%7B%20x_%7B4%7D%2C%20x_%7B6%7D%20%5C%7D" style="display:inline-block;margin: 0;"/> 的真正原因，因此我们引入  <em><strong>reachable sets</strong></em> 的概念。</p>
<p>设 <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> 是节点集合的一个真子集，<img src="https://math.now.sh?inline=x%20%5Cnotin%20S" style="display:inline-block;margin: 0;"/> 。如果存在一个从 y 到 x 的路径 <img src="https://math.now.sh?inline=%28y%2C%20v_%7B1%7D%2C%20%5Ccdots%2C%20v_%7Bk%7D%2Cx%29" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=v_%7Bi%7D%20%5Cin%20S%2C%201%20%5Cleq%20i%20%5Cleq%20k%2C%20k%20%5Cgeq%200" style="display:inline-block;margin: 0;"/>，则我们称节点 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 是 <em>be reachable from a node <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> through <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/></em> ，注意由于 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 可以为 0，因此 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 的任何不在 <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> 中的相邻节点均 <em>be reachable from <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> through <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/></em></p>
<p>这些节点的集合就是 <em>reachable set of y through S</em> ，标记为 <img src="https://math.now.sh?inline=Reach%28y%2C%20S%29" style="display:inline-block;margin: 0;"/> ，定义为</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BReach%7D%28y%2C%20S%29%3D%5C%7Bx%20%5Cnotin%20S%20%5Cmid%20x%20%5Ctext%20%7B%20is%20reachable%20from%20%7D%20y%20%5Ctext%20%7B%20through%20%7D%20S%5C%7D%20.%0A" /></p><p>为了说明 <em>reachable set</em> 的概念，以下图为例，如果 <img src="https://math.now.sh?inline=S%20%3D%20%5C%7Bs_%7B1%7D%2C%20s_%7B2%7D%2Cs_%7B3%7D%2Cs_%7B4%7D%5C%7D" style="display:inline-block;margin: 0;"/> ，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BReach%7D%28y%2C%20S%29%3D%5C%7B%20a%2Cb%2Cc%5C%7D%0A" /></p><p>因为存在以下路径 <img src="https://math.now.sh?inline=%5C%7By%2Cs_%7B2%7D%2Cs_%7B4%7D%2Ca%5C%7D" style="display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5C%7By%2Cb%5C%7D" style="display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5C%7By%2Cs_%7B1%7D%2Cc%5C%7D" style="display:inline-block;margin: 0;"/></p>
<p><img src="60.png" alt="1"></p>
<p>下面的定理说明通过 <em>reachable set</em> 来创建的 <em>filled graph</em></p>
<p><strong>定理</strong>：</p>
<p style=""><img src="https://math.now.sh?from=E%5E%7B%5Cboldsymbol%7BF%7D%7D%3D%5Cleft%5C%7B%5Cleft%5C%7Bx_%7Bi%7D%2C%20x_%7Bj%7D%5Cright%5C%7D%20%5Cmid%20x_%7Bj%7D%20%5Cin%20%5Coperatorname%7BReach%7D%5Cleft%28x_%7Bi%7D%2C%5Cleft%5C%7Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Ccdots%2C%20x_%7Bi-1%7D%5Cright%5C%7D%5Cright%29%5Cright%5C%7D%20.%0A" /></p><p>证明：假设 <img src="https://math.now.sh?inline=x_%7Bj%7D%20%5Cin%20%5Coperatorname%7BReach%7D%5Cleft%28x_%7Bi%7D%2C%5Cleft%5C%7Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Ccdots%2C%20x_%7Bi-1%7D%5Cright%5C%7D%5Cright%29" style="display:inline-block;margin: 0;"/> ，根据定义，在 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7B0%7D" style="display:inline-block;margin: 0;"/> 中存在一条路径 <img src="https://math.now.sh?inline=%28x_%7Bi%7D%2Cy_%7B1%7D%2C%5Ccdots%2C%20y_%7Bt%7D%2Cx_%7Bj%7D%29" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=y_%7Bk%7D%20%5Cin%20%5Cleft%5C%7Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Ccdots%2C%20x_%7Bi-1%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> 。如果 <img src="https://math.now.sh?inline=t%20%3D%200" style="display:inline-block;margin: 0;"/> 或者 <img src="https://math.now.sh?inline=t%20%3D%201" style="display:inline-block;margin: 0;"/> ，根据上面的引理就可以直接得到 <img src="https://math.now.sh?inline=%5Cleft%5C%7Bx_%7Bi%7D%2C%20x_%7Bj%7D%5Cright%5C%7D%20%5Cin%20E%5E%7B%5Cmathbf%7BF%7D%7D" style="display:inline-block;margin: 0;"/>。如果 <img src="https://math.now.sh?inline=t%20%3E%201" style="display:inline-block;margin: 0;"/> ，我们可以从 <img src="https://math.now.sh?inline=y_%7B1%7D%2C%5Ccdots%2C%20y_%7Bt%7D" style="display:inline-block;margin: 0;"/> 中逐渐消除节点，使得 <img src="https://math.now.sh?inline=t%20%3D%200" style="display:inline-block;margin: 0;"/> ，从而得到 <img src="https://math.now.sh?inline=%5Cleft%5C%7Bx_%7Bi%7D%2C%20x_%7Bj%7D%5Cright%5C%7D%20%5Cin%20E%5E%7B%5Cmathbf%7BF%7D%7D" style="display:inline-block;margin: 0;"/>。</p>
<p>反过来，假设  <img src="https://math.now.sh?inline=%5Cleft%5C%7Bx_%7Bi%7D%2C%20x_%7Bj%7D%5Cright%5C%7D%20%5Cin%20E%5E%7B%5Cmathbf%7BF%7D%7D" style="display:inline-block;margin: 0;"/> ，并且 <img src="https://math.now.sh?inline=i%20%5Cleq%20j" style="display:inline-block;margin: 0;"/> 。根据前面的推理，则 <img src="https://math.now.sh?inline=%5C%7B%20x_%7Bi%7D%2C%20x_%7Bj%7D%5C%7D%20%5Cin%20E%5E%7B%5Cmathbf%7BA%7D%7D" style="display:inline-block;margin: 0;"/>，或者  <img src="https://math.now.sh?inline=%5C%7B%20x_%7Bi%7D%2C%20x_%7Bk%7D%5C%7D%20%5Cin%20E%5E%7B%5Cmathbf%7BF%7D%7D" style="display:inline-block;margin: 0;"/> and  <img src="https://math.now.sh?inline=%5C%7B%20x_%7Bk%7D%2C%20x_%7Bj%7D%5C%7D%20%5Cin%20E%5E%7B%5Cmathbf%7BF%7D%7D" style="display:inline-block;margin: 0;"/> for some <img src="https://math.now.sh?inline=k%20%3C%20%5Cmin%5C%7Bi%2Cj%5C%7D" style="display:inline-block;margin: 0;"/> 。如果是满足第一个条件  <img src="https://math.now.sh?inline=%5C%7B%20x_%7Bi%7D%2C%20x_%7Bj%7D%5C%7D%20%5Cin%20E%5E%7B%5Cmathbf%7BA%7D%7D" style="display:inline-block;margin: 0;"/>，则  <img src="https://math.now.sh?inline=x_%7Bj%7D%20%5Cin%20%5Coperatorname%7BReach%7D%5Cleft%28x_%7Bi%7D%2C%5Cleft%5C%7Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Ccdots%2C%20x_%7Bi-1%7D%5Cright%5C%7D%5Cright%29" style="display:inline-block;margin: 0;"/>  成立；如果是满足第二个条件，即   <img src="https://math.now.sh?inline=%5C%7B%20x_%7Bi%7D%2C%20x_%7Bk%7D%5C%7D%20%5Cin%20E%5E%7B%5Cmathbf%7BF%7D%7D" style="display:inline-block;margin: 0;"/> and  <img src="https://math.now.sh?inline=%5C%7B%20x_%7Bk%7D%2C%20x_%7Bj%7D%5C%7D%20%5Cin%20E%5E%7B%5Cmathbf%7BF%7D%7D" style="display:inline-block;margin: 0;"/> for some <img src="https://math.now.sh?inline=k%20%3C%20%5Cmin%5C%7Bi%2Cj%5C%7D" style="display:inline-block;margin: 0;"/> ，这说明在 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7B0%7D" style="display:inline-block;margin: 0;"/> 中 <img src="https://math.now.sh?inline=x_%7Bi%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=x_%7Bk%7D" style="display:inline-block;margin: 0;"/>， <img src="https://math.now.sh?inline=x_%7Bk%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=x_%7Bj%7D" style="display:inline-block;margin: 0;"/> 均存在一条路径连接，二者可以连通起来，说明   存在某条通过 <img src="https://math.now.sh?inline=x_%7Bk%7D" style="display:inline-block;margin: 0;"/> 连接 <img src="https://math.now.sh?inline=x_%7Bi%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=x_%7Bj%7D" style="display:inline-block;margin: 0;"/> 的路径  <img src="https://math.now.sh?inline=%28x_%7Bi%7D%2Cx_%7Bk%7D%2Cx_%7Bj%7D%29" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=x_%7Bj%7D%20%5Cin%20%5Coperatorname%7BReach%7D%5Cleft%28x_%7Bi%7D%2C%5Cleft%5C%7Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Ccdots%2C%20x_%7Bi-1%7D%5Cright%5C%7D%5Cright%29" style="display:inline-block;margin: 0;"/>  成立。</p>
<p>证明完毕。</p>
<p>采用矩阵的术语，<img src="https://math.now.sh?inline=%5Coperatorname%7BReach%7D%5Cleft%28x_%7Bi%7D%2C%5Cleft%5C%7Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Ccdots%2C%20x_%7Bi-1%7D%5Cright%5C%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 就是在列向量 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D_%7B*i%7D" style="display:inline-block;margin: 0;"/> 中的非零元素的行号。举个例子，假设上图 5.2.5 中的图排序如下</p>
<p><img src="61.png" alt="1"></p>
<p>如果 <img src="https://math.now.sh?inline=S_%7Bi%7D%20%3D%20%5Cleft%5C%7Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Ccdots%2C%20x_%7Bi-1%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> ，根据上面的定理，我们可以轻松得到下面的 <em>reachable set</em></p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7BReach%7D%5Cleft%28x_%7B1%7D%2C%20S_%7B0%7D%5Cright%29%20%26%3D%5Cleft%5C%7Bx_%7B5%7D%2C%20x_%7B8%7D%5Cright%5C%7D%20%5C%5C%0A%5Coperatorname%7BReach%7D%5Cleft(x_%7B2%7D%2C%20S_%7B1%7D%5Cright)%20%26%3D%5Cleft%5C%7Bx_%7B4%7D%2C%20x_%7B5%7D%5Cright%5C%7D%20%5C%5C%0A%5Coperatorname%7BReach%7D%5Cleft(x_%7B3%7D%2C%20S_%7B2%7D%5Cright)%20%26%3D%5Cleft%5C%7Bx_%7B8%7D%5Cright%5C%7D%20%5C%5C%0A%5Coperatorname%7BReach%7D%5Cleft(x_%7B4%7D%2C%20S_%7B3%7D%5Cright)%20%26%3D%5Cleft%5C%7Bx_%7B5%7D%2C%20x_%7B7%7D%5Cright%5C%7D%20%5C%5C%0A%5Coperatorname%7BReach%7D%5Cleft(x_%7B5%7D%2C%20S_%7B4%7D%5Cright)%20%26%3D%5Cleft%5C%7Bx_%7B6%7D%2C%20x_%7B7%7D%2C%20x_%7B8%7D%5Cright%5C%7D%20%5C%5C%0A%5Coperatorname%7BReach%7D%5Cleft(x_%7B6%7D%2C%20S_%7B5%7D%5Cright)%20%26%3D%5Cleft%5C%7Bx_%7B7%7D%2C%20x_%7B8%7D%5Cright%5C%7D%20%5C%5C%0A%5Coperatorname%7BReach%7D%5Cleft(x_%7B7%7D%2C%20S_%7B6%7D%5Cright)%20%26%3D%5Cleft%5C%7Bx_%7B8%7D%5Cright%5C%7D%20%5C%5C%0A%5Coperatorname%7BReach%7D%5Cleft(x_%7B8%7D%2C%20S_%7B7%7D%5Cright)%20%26%3D%5Cleft%5C%7Bx_%7B9%7D%5Cright%5C%7D%20%5C%5C%0A%5Coperatorname%7BReach%7D%5Cleft(x_%7B9%7D%2C%20S_%7B8%7D%5Cright)%20%26%3D%5Cphi%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>因此我们可以得到下面的 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 矩阵</p>
<p><img src="62.png" alt="1"></p>
<p>因此我们可以通过 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的结构而直接得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 矩阵的结构（这种方式比 <em>envelope region</em> 的方式更加精确，<em>fill-in</em> 更少）。更重要的是，我们可以更方便的得到 <em>elimination graphs</em> 。设 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7B0%7D%20%5Crightarrow%20%5Cmathcal%7BG%7D_%7B1%7D%20%5Crightarrow%20%5Ccdots%20%5Crightarrow%20%5Cmathcal%7BG%7D_%7Bn-1%7D" style="display:inline-block;margin: 0;"/> 为一组 <em>elimination graphs</em> ，我们有：</p>
<p><strong>定理</strong>：设 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 是一个  <em>elimination graph</em>   <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi%7D%20%3D%20%28X_%7Bi%7D%2CE_%7Bi%7D%29" style="display:inline-block;margin: 0;"/> 中的一个节点，邻近于 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 中的节点 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 的节点集合为：</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BReach%7D%5Cleft%28y%2C%5Cleft%5C%7Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Ccdots%2C%20x_%7Bi%7D%5Cright%5C%7D%5Cright%29%0A" /></p><p>其中，这里的 <img src="https://math.now.sh?inline=%5Coperatorname%7BReach%7D" style="display:inline-block;margin: 0;"/> 操作符是用于原始的图 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7B0%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>证明：证明可以通过对 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 采用归纳法证明得到，设 <img src="https://math.now.sh?inline=i%20%3D%201" style="display:inline-block;margin: 0;"/> ，易证明成立；假设 <img src="https://math.now.sh?inline=i%20%3Dk" style="display:inline-block;margin: 0;"/> 时成立，即邻近于 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bk%7D" style="display:inline-block;margin: 0;"/> 中的节点 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 的节点集合为 <img src="https://math.now.sh?inline=%5Coperatorname%7BReach%7D%5Cleft%28y%2C%5Cleft%5C%7Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Ccdots%2C%20x_%7Bk%7D%5Cright%5C%7D%5Cright%29" style="display:inline-block;margin: 0;"/> ；当 <img src="https://math.now.sh?inline=i%20%3D%20k%2B1" style="display:inline-block;margin: 0;"/> 时， <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bk%2B1%7D" style="display:inline-block;margin: 0;"/> 进一步剔除了 <img src="https://math.now.sh?inline=x_%7Bk%2B1%7D" style="display:inline-block;margin: 0;"/> ，我们需要证明邻近于  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bk%2B1%7D" style="display:inline-block;margin: 0;"/> 中的节点 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 的节点集合为  <img src="https://math.now.sh?inline=%5Coperatorname%7BReach%7D%5Cleft%28y%2C%5Cleft%5C%7Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Ccdots%2C%20x_%7Bk%2B1%7D%5Cright%5C%7D%5Cright%29" style="display:inline-block;margin: 0;"/>  。此时如果 <img src="https://math.now.sh?inline=y%20%5Cnotin%20%5Coperatorname%7BReach%7D%5Cleft%28x_%7Bk%2B1%7D%2C%5Cleft%5C%7Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Ccdots%2C%20x_%7Bk%7D%5Cright%5C%7D%5Cright%29" style="display:inline-block;margin: 0;"/> , 也就是说在  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bk%7D" style="display:inline-block;margin: 0;"/> 中 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=x_%7Bk%2B1%7D" style="display:inline-block;margin: 0;"/> 不相邻，此时  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bk%2B1%7D" style="display:inline-block;margin: 0;"/> 中的节点 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 的相邻列表不变，仍为 <img src="https://math.now.sh?inline=%5Coperatorname%7BReach%7D%5Cleft%28y%2C%5Cleft%5C%7Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Ccdots%2C%20x_%7Bk%7D%5Cright%5C%7D%5Cright%29" style="display:inline-block;margin: 0;"/> ，也等于  <img src="https://math.now.sh?inline=%5Coperatorname%7BReach%7D%5Cleft%28y%2C%5Cleft%5C%7Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Ccdots%2C%20x_%7Bk%2B1%7D%5Cright%5C%7D%5Cright%29" style="display:inline-block;margin: 0;"/>   。如果 <img src="https://math.now.sh?inline=y%20%5Cin%20%5Coperatorname%7BReach%7D%5Cleft%28x_%7Bk%2B1%7D%2C%5Cleft%5C%7Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Ccdots%2C%20x_%7Bk%7D%5Cright%5C%7D%5Cright%29" style="display:inline-block;margin: 0;"/> ，此时 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 的相邻节点会减去 <img src="https://math.now.sh?inline=x_%7Bk%2B1%7D" style="display:inline-block;margin: 0;"/> , 新增 <img src="https://math.now.sh?inline=x_%7Bk%2B1%7D" style="display:inline-block;margin: 0;"/> 在  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bk%7D" style="display:inline-block;margin: 0;"/> 中 除 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 之外的相邻节点，即此时 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bk%2B1%7D" style="display:inline-block;margin: 0;"/> 中的节点 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 的相邻列表为 <img src="https://math.now.sh?inline=%28%5Coperatorname%7BReach%7D%5Cleft(y%2C%5Cleft%5C%7Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Ccdots%2C%20x_%7Bk%7D%5Cright%5C%7D%5Cright%29%20-%20%5C%7Bx_%7Bk%2B1%7D%5C%7D)%20%5Ccup%20(%5Coperatorname%7BReach%7D%5Cleft(x_%7Bk%2B1%7D%2C%5Cleft%5C%7Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Ccdots%2C%20x_%7Bk%7D%5Cright%5C%7D%5Cright)%20-%20%5C%7By%5C%7D)" style="display:inline-block;margin: 0;"/> ，易得其中第一部分为  <img src="https://math.now.sh?inline=%5Coperatorname%7BReach%7D%5Cleft%28y%2C%5Cleft%5C%7Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Ccdots%2C%20x_%7Bk%7D%2C%20x_%7Bk%2B1%7D%5Cright%5C%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 中路径中不包含 <img src="https://math.now.sh?inline=x_%7Bk%2B1%7D" style="display:inline-block;margin: 0;"/> 的部分 ，对于第二部分，设 <img src="https://math.now.sh?inline=t%20%5Cin%20%20%28%5Coperatorname%7BReach%7D%5Cleft(x_%7Bk%2B1%7D%2C%5Cleft%5C%7Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Ccdots%2C%20x_%7Bk%7D%5Cright%5C%7D%5Cright%29%20-%20%5C%7By%5C%7D)" style="display:inline-block;margin: 0;"/> ,  由于  <img src="https://math.now.sh?inline=y%20%5Cin%20%5Coperatorname%7BReach%7D%5Cleft%28x_%7Bk%2B1%7D%2C%5Cleft%5C%7Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Ccdots%2C%20x_%7Bk%7D%5Cright%5C%7D%5Cright%29" style="display:inline-block;margin: 0;"/> ，易得 <img src="https://math.now.sh?inline=t%20%5Cin%20%5Coperatorname%7BReach%7D%5Cleft%28y%2C%5Cleft%5C%7Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Ccdots%2C%20x_%7Bk%7D%2C%20x_%7Bk%2B1%7D%5Cright%5C%7D%5Cright%29" style="display:inline-block;margin: 0;"/> ，因此第二部分为 <img src="https://math.now.sh?inline=%5Coperatorname%7BReach%7D%5Cleft%28y%2C%5Cleft%5C%7Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Ccdots%2C%20x_%7Bk%7D%2C%20x_%7Bk%2B1%7D%5Cright%5C%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 路径中包含 <img src="https://math.now.sh?inline=x_%7Bk%2B1%7D" style="display:inline-block;margin: 0;"/> 的部分 ，因此第一部分和第二部分的并集就正好为  <img src="https://math.now.sh?inline=%5Coperatorname%7BReach%7D%5Cleft%28y%2C%5Cleft%5C%7Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Ccdots%2C%20x_%7Bk%7D%2C%20x_%7Bk%2B1%7D%5Cright%5C%7D%5Cright%29" style="display:inline-block;margin: 0;"/> ，因此得证 邻近于  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bk%2B1%7D" style="display:inline-block;margin: 0;"/> 中的节点 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 的节点集合为  <img src="https://math.now.sh?inline=%5Coperatorname%7BReach%7D%5Cleft%28y%2C%5Cleft%5C%7Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Ccdots%2C%20x_%7Bk%2B1%7D%5Cright%5C%7D%5Cright%29" style="display:inline-block;margin: 0;"/>  。</p>
<p>证明完毕。</p>
<p>我们用图 5.2.3 来重新举一个例子，我们考虑 图 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7B0%7D" style="display:inline-block;margin: 0;"/> 和 图 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> 如下：</p>
<p><img src="63.png" alt="1"></p>
<p>设 <img src="https://math.now.sh?inline=S_%7B2%7D%20%3D%20%7Bx_%7B1%7D%2C%20x_%7B2%7D%7D" style="display:inline-block;margin: 0;"/> ，我们易得：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7BReach%7D%5Cleft%28x_%7B3%7D%2C%20S_%7B2%7D%5Cright%29%20%26%3D%5Cleft%5C%7Bx_%7B4%7D%2C%20x_%7B5%7D%2C%20x_%7B6%7D%5Cright%5C%7D%20%5C%5C%0A%5Coperatorname%7BReach%7D%5Cleft(x_%7B4%7D%2C%20S_%7B2%7D%5Cright)%20%26%3D%5Cleft%5C%7Bx_%7B3%7D%2C%20x_%7B6%7D%5Cright%5C%7D%20%5C%5C%0A%5Coperatorname%7BReach%7D%5Cleft(x_%7B5%7D%2C%20S_%7B2%7D%5Cright)%20%26%3D%5Cleft%5C%7Bx_%7B3%7D%2C%20x_%7B6%7D%5Cright%5C%7D%20%5C%5C%0A%5Coperatorname%7BReach%7D%5Cleft(x_%7B6%7D%2C%20S_%7B2%7D%5Cright)%20%26%3D%5Cleft%5C%7Bx_%7B3%7D%2C%20x_%7B4%7D%2C%20%20x_%7B5%7D%5Cright%5C%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>因此我们就得到  图 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> 的结构。</p>
<p>我们采用 <em>reachable sets</em> 得到的 图 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 称为 <em>implicit model</em> for elimation；而上一节中消除节点 <img src="https://math.now.sh?inline=x_%7B1%7D" style="display:inline-block;margin: 0;"/> 及其相应的边 添加边，使得图  <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%5E%7B%5Cmathbf%7BH%7D_%7B1%7D%7D" style="display:inline-block;margin: 0;"/>中的 <img src="https://math.now.sh?inline=Adj%28x_%7B1%7D%29" style="display:inline-block;margin: 0;"/> 彼此之间相邻，这种方式称为 <em>explicit model</em> for elimation。</p>
<h1>参考文献</h1>
<ol>
<li>George A, Liu J, Ng E. Computer solution of sparse linear systems[J]. Oak Ridge National Laboratory, 1994.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>稀疏矩阵</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>稀疏矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏矩阵算法Envelope方法三之Cholesky分解</title>
    <url>/posts/57869f4c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本章节是介绍 George and Liu 书中 Envelope Method 的应用</p>
<span id="more"></span>
<h1>ESFCT</h1>
<h1>原理</h1>
<p>ESFCT，用于计算 Cholesky 分解 <img src="https://math.now.sh?inline=%5Cmathbf%7BLL%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/> ，将 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 矩阵按照 <em>envelope storage scheme</em> 格式存储。</p>
<p>Cholesky 分解的方法是 bordering method ，假设矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 可以分块为</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7BA%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cboldsymbol%7BM%7D%20%26%20%5Cboldsymbol%7Bu%7D%20%5C%5C%0A%5Cboldsymbol%7Bu%7D%5E%7BT%7D%20%26%20s%0A%5Cend%7Barray%7D%5Cright%29%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D" style="display:inline-block;margin: 0;"/> 可以分解为 <img src="https://math.now.sh?inline=%5Cmathbf%7BL_%7BM%7DL_%7BM%7D%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的分解因子为</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7BL%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cboldsymbol%7BL_%7BM%7D%7D%20%26%20%5Cboldsymbol%7B0%7D%20%5C%5C%0A%5Cboldsymbol%7Bw%7D%5E%7BT%7D%20%26%20t%0A%5Cend%7Barray%7D%5Cright%29%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BL_%7BM%7Dw%20%3D%20u%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathbf%7Bt%20%3D%20%28s%20-%20w%5E%7BT%7Dw%29%5E%7B1%2F2%7D%7D" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的分解因子 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 可以<strong>逐行</strong>计算。以下图为例，假设我们已经完成了前 <img src="https://math.now.sh?inline=i-1" style="display:inline-block;margin: 0;"/> 步的分解，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的左上角的 <img src="https://math.now.sh?inline=%28i-1%29%20%5Ctimes%20(i-1)" style="display:inline-block;margin: 0;"/> 的子矩阵已经完成了分解。为了计算 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 矩阵的第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行，我们需要计算  <img src="https://math.now.sh?inline=%5Cmathbf%7BL_%7BM%7Dw%20%3D%20u%7D" style="display:inline-block;margin: 0;"/> 。但是，实际上 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> 只有一部分 envelope 区域需要计算，因此实际使用和计算的 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Cbar%7BL%7D%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Cbar%7Bu%7D%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/> 如右图，因此此时 <strong>ELSLV</strong> 可以对这个 <strong>IBAND</strong> 大小的三角方程组进行求解</p>
<p><img src="52.png" alt="1"></p>
<h1>脚本</h1>
<p>具体脚本如下：</p>
<p><img src="53.png" alt="1"></p>
<p><img src="54.png" alt="1"></p>
<p><img src="55.png" alt="1"></p>
<p>现在开始逐行解析。</p>
<p>首先对第一行进行分解，如果对角线元素小于等于0则程序中止</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IF ( DIAG(1) .LE. 0.0E0) GO TO 400</span><br><span class="line">DIAG(1) = SQRT(DIAG(1))</span><br><span class="line">IF( NEQNS .EQ. 1) RETURN</span><br></pre></td></tr></table></figure>
<p>对第二行及之后的行进行分解，IXENV 是 ENV 向量中第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行第一个元素的位置，TEMP 是矩阵第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行的对角线元素，如果 IBAND 等于 0，则跳过三角方程组求解这一步，<code>GO TO 200</code> 。</p>
<p>IFIRST 是第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行第一个元素所在列。</p>
<p>之后调用 ELSLV 求解得到 <img src="https://math.now.sh?inline=%5Cmathbf%7Bw%7D" style="display:inline-block;margin: 0;"/> 。 这里就用到了子矩阵求解的方法，方程数目为 IBAND，<code>XENV(IFIRST)</code> 表示其第一个未知数是 IFIRST所在行/列的未知数，<code>DIAG(IFIRST)</code>，其右手项是本行的非零元素，第一个元素为 <code>ENV(IXENV)</code> 。</p>
<p>因此调用结束后会更新右手项的值，即更新 ENV 向量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DO 300 I = 2, NEQNS</span><br><span class="line">  IXENV = XENV(I)</span><br><span class="line">  IBAND = XENV(I+1) - IXENV</span><br><span class="line">  TEMP = DIAG(I)</span><br><span class="line">  IF (IBAND .EQ. 0) GO TO 200</span><br><span class="line">    IFIRST = I - IBAND</span><br><span class="line">    CALL ELSLV( IBAND, XENV(IFIRST), ENV, DIAG(IFIRST), ENV(IXENV))</span><br></pre></td></tr></table></figure>
<p>下一步，我们计算 t ，首先我们从对角线元素中减去  <img src="https://math.now.sh?inline=%5Cmathbf%7Bw%7D" style="display:inline-block;margin: 0;"/> 的内积。</p>
<p>JSTOP 是 ENV 向量中第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行最后一个元素的位置，<code>DO 100</code> 循环遍历了ENV 向量中第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行的全部位置，<code>TEMP = TEMP - S * S</code> 便是对角线元素减去了   <img src="https://math.now.sh?inline=%5Cmathbf%7Bw%7D" style="display:inline-block;margin: 0;"/> 的内积</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	      JSTOP = XENV(I+1) - 1</span><br><span class="line">	      DO 100 J = IXENV, JSTOP</span><br><span class="line">	      	S = ENV(J)</span><br><span class="line">	      	TEMP = TEMP - S * S</span><br><span class="line">100	      CONTINUE</span><br></pre></td></tr></table></figure>
<p>然后求开方，如果 TEMP 小于等于0，程序中止。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">200    	IF(TEMP .LE.  0.0E0) GO TO 400</span><br><span class="line">		  DIAG(I) = SQRT(TEMP)</span><br><span class="line">		  COUNT = IBAND </span><br><span class="line">		  OPS = OPS + COUNT </span><br><span class="line">300	  CONTINUE</span><br><span class="line">	  RETURN </span><br></pre></td></tr></table></figure>
<p>如果存在对角线元素小于等于0的情况，程序中止，IFLAG 设为 1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">400   IFLAG = 1</span><br><span class="line">	  RETURN</span><br><span class="line">	  END</span><br></pre></td></tr></table></figure>
<h1>参考文献</h1>
<ol>
<li>George A, Liu J, Ng E. Computer solution of sparse linear systems[J]. Oak Ridge National Laboratory, 1994.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>稀疏矩阵</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>稀疏矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏矩阵算法Envelope方法二之三角方程组求解</title>
    <url>/posts/f06c6ce7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本章节是介绍 George and Liu 书中 Envelope Method 的应用</p>
<span id="more"></span>
<p>在这一章节中，我们利用上面章节提到的 envelope storage scheme，描述执行 Cholesky 分解和求解的子程序。我们会先介绍三角方程组求解子程序 <strong>ELSLV (Envelope-Lower-Solve)</strong> 和  <strong>EUSLV (Envelope-Upper-Solve)</strong> ，再介绍矩阵分解的子程序 <strong>ESFCT (Envelope-Symmetric-Factorization)</strong> 。</p>
<h1>ELSLV</h1>
<p>这些子程序用于求解下面的下三角方程组和上三角方程组</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cmathbf%7BLy%3Db%7D%20%5C%5C%0A%26%5Cmathbf%7BL%5E%7BT%7Dx%3Dy%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 是一个下三角矩阵，其存储方式就是之前提到的 envelope storage scheme 。</p>
<p><strong>ELSLV</strong> 脚本如下，该流程首先查找右手项 RHS 中的第一个非零元素 (<strong>IFIRST</strong>) ，之前的未知数就全部是 0。然后从 <strong>IFIRST</strong> 行循环至最后一行，采用内积原理，逐个计算 <img src="https://math.now.sh?inline=x_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，覆盖 RHS 相应元素的值。</p>
<p>变量 <strong>LAST</strong> 记录上一次计算的<strong>非零</strong>解的索引，这样如果本方程计算时左手项第一个非零元素大于 <strong>LAST</strong> ，那么就可以直接采用 <img src="https://math.now.sh?inline=RHS%28I%29%20%3D%20S%2FDIAG(I)" style="display:inline-block;margin: 0;"/> 计算解。</p>
<p>最终输出 <strong>RHS</strong> 和 <strong>OPS</strong>，这里 RHS 就是最终的解，OPS 是执行的算术操作的次数（乘法和除法）。我感觉OPS 应该采用长整型，而不是用双精度浮点数。</p>
<p>注意，下面脚本中的 <img src="https://math.now.sh?inline=OPS%20%3D%20OPS%20%2B%201.0D0" style="display:inline-block;margin: 0;"/> ，其中的 <code>1.0D0</code> 就是 <img src="https://math.now.sh?inline=1.0%20%5Ctimes%2010%5E%7B0%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=D" style="display:inline-block;margin: 0;"/> 是双精度的意思。</p>
<p><img src="44.png" alt="1"></p>
<p><img src="45.png" alt="1"></p>
<p><img src="46.png" alt="1"></p>
<p><img src="47.png" alt="1"></p>
<p>下面我们开始逐行解析脚本，定义变量时将 OPS 定义成了  SPKOPS 组的第一个<strong>全局变量</strong>，用于记录乘除法的操作次数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMMON /SPKOPS/ OPS</span><br></pre></td></tr></table></figure>
<p>第一步，我们查找右手项中第一个非零元素的位置</p>
<p>如果右手项全部元素均为0，则程序终止，全为0的 RHS 就是方程组的解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	  IFIRST = 0</span><br><span class="line">100	  IFIRST = IFIRST + 1</span><br><span class="line">	    IF( RHS(IFIRST) .NE. 0.0E0 ) GO TO 200</span><br><span class="line">	    IF ( IFIRST .LT. NEQNS ) GO TO 100</span><br><span class="line">	    RETURN</span><br><span class="line">200	  LAST = 0</span><br></pre></td></tr></table></figure>
<p>从 IFIRST 行开始逐行求解 (之前的行解也全部为0)，采用内积原理进行求解。</p>
<p>IBAND 是这一行的 <em>bandwidth</em> ，<code> IF ( IBAND .GE. I) IBAND = I - 1</code> 这句目前看是废话，之后会有进一步的解释。</p>
<p><code> L = I - IBAND</code> 是这一行第一个非零元素的位置；<code>RHS(I) = 0.0E0</code> 将对应的解首先设置为 0 ，之后再覆盖。</p>
<p><code>LAST</code> 记录的是上一次计算的非零解的位置。</p>
<p><code>IF (IBAND .EQ. 0 .OR. LAST .LT. L) GO TO 400</code> ，这句话第一个条件很容易理解，如果 IBAND 等于 0 ，那么就只需要考虑对角线元素；第二个条件是 LAST 小于 L ，LAST 是上一次计算的非零解的位置，那就说明从 LAST + 1 到 I - 1，这些位置的解均为 0；而这一行第一个非零元素的位置 L 大于 LAST ，说明这一行非对角线元素对应的解均为0，因此也只需要考虑对角线元素。</p>
<p>如果不满足上面两个条件，接着往下走，KSTRT 和 KSTOP 是 IBAND 的第一个和最后一个元素，<code>DO 300</code> 循环根据内积原理从 S 中减去非对角线元素的乘积 (<code>S = S - ENV(K)*RHS(L)</code>) 。</p>
<p>最后，COUNT 是本次的乘除法计算次数，加入到 OPS 中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	  DO 500 I = IFIRST, NEQNS</span><br><span class="line">	    IBAND = XENV(I+1) - XENV(I)</span><br><span class="line">	    IF ( IBAND .GE. I) IBAND = I - 1</span><br><span class="line">	    S = RHS(I)</span><br><span class="line">	    L = I - IBAND</span><br><span class="line">	    RHS(I) = 0.0E0</span><br><span class="line">	    </span><br><span class="line">	    IF (IBAND .EQ. 0 .OR. LAST .LT. L) GO TO 400</span><br><span class="line">	      KSTRT = XENV(I+1) - IBAND</span><br><span class="line">	      KSTOP = XENV(I+1) - 1</span><br><span class="line">	      DO 300 K = KSTRT, KSTOP</span><br><span class="line">	        S = S - ENV(K)*RHS(L)</span><br><span class="line">	        L = L + 1</span><br><span class="line">300	      CONTINUE</span><br><span class="line">	      COUNT = IBAND</span><br><span class="line">	      OPS = OPS + COUNT</span><br></pre></td></tr></table></figure>
<p>最后计算 RHS(I) ，如果此时 S 已经等于 0 ，那么 RHS(I) = 0 , 这就是我们预设的值，不用做任何事情，直接求解下一个未知数；否则的话，<code>RHS(I) = S/DIAG(I)</code> ，OPS 加1，LAST 更新为 I 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">400     IF( S .EQ. 0.0E0) GO TO 500</span><br><span class="line">		  RHS(I) = S/DIAG(I)</span><br><span class="line">		  OPS = OPS + 1.0D0</span><br><span class="line">		  LAST = I</span><br><span class="line">500   CONTINUE</span><br><span class="line">      RETURN</span><br><span class="line">    END</span><br></pre></td></tr></table></figure>
<p>下图描述了本子程序的计算逻辑，其中圆圈圈起来的元素是ELSLV 实际使用的元素，可以按照上面的子程序手动模拟一下计算流程，看看是不是只用了圆圈圈起来的元素。</p>
<p>注意，在这个子流程中，我们在 <code>DO 300</code> 循环中可能执行了 一些乘以 0 的乘法，但是在大部分机器中通过做一个检查来避免这种乘法可能比不管它更加耗时。</p>
<p><img src="48.png" alt="1"></p>
<p>子程序中 54 行对 <strong>IBAND</strong> 的处理（<code> IF ( IBAND .GE. I) IBAND = I - 1</code> ）解释如下，在某些环境中，<strong>ELSLV</strong> 子程序只用于求解导入的系数矩阵**(XADJ, ADJNCY)<strong>的</strong>子矩阵**的解，如下图所示，<img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 实际是一个 <img src="https://math.now.sh?inline=16%20%5Ctimes%2016" style="display:inline-block;margin: 0;"/> 的矩阵，而我们想要求解的方程组是框起来的 <img src="https://math.now.sh?inline=11%20%5Ctimes%2011" style="display:inline-block;margin: 0;"/> 的子矩阵，伴随着其相应的右手项 RHS ，我们求解的脚本为</p>
<p style=""><img src="https://math.now.sh?from=%5Ctext%7BCALL%20%20ELSLV%28%2011%2C%20XENV(5%29%2C%20ENV%2C%20DIAG(5)%2C%20RHS)%7D%0A" /></p><p>在这个子程序中，XENV(5) 被解释为 XENV(1)， XENV(6) 被解释为 XENV(2)，依此类推。</p>
<p><img src="49.png" alt="1"></p>
<h1>EUSLV</h1>
<h2 id="原理">原理</h2>
<p>我们现在查看子程序 <strong>EUSLV</strong> ，其求解 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%5E%7BT%7Dx%20%3D%20y%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 就是 <strong>ELSLV</strong> 中的系数矩阵，这就意味着我们可以获取 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/> 的<strong>列</strong>，此时我们采用 <em>outer product form</em>，该方法描述如下</p>
<p>假设 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7BTx%20%3D%20b%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D" style="display:inline-block;margin: 0;"/> 是一个<strong>非奇异的</strong>下三角矩阵，并且按列存储，其计算公式如下</p>
<p><img src="3.png" alt="1"></p>
<p>这种算法适用于 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> 向量很稀疏的情况，如果在第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 步一开始 <img src="https://math.now.sh?inline=b_%7Bi%7D" style="display:inline-block;margin: 0;"/> 就等于 0 ，那么 <img src="https://math.now.sh?inline=x_%7Bi%7D" style="display:inline-block;margin: 0;"/> 等于 0，我们可以整个跳过这一步。</p>
<p>同样类似于 <strong>ELSLV</strong> ，我们可以对提供的系数矩阵的子矩阵进行计算求解。</p>
<p>其求解顺序是反的，从 <img src="https://math.now.sh?inline=x_%7Bn%7D" style="display:inline-block;margin: 0;"/> 到 <img src="https://math.now.sh?inline=x_%7B1%7D" style="display:inline-block;margin: 0;"/> 。</p>
<h2 id="脚本">脚本</h2>
<p><img src="50.png" alt="1"></p>
<p><img src="51.png" alt="1"></p>
<p>现在对该脚本逐行解析如下，首先这个是按照从ｎ到１的顺序，设 I 的初值设为 NEQNS + 1，进入循环。</p>
<p>如果 RHS(I) 等于0，直接跳过，进入下一个循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	  I = NEQNS + 1</span><br><span class="line">100   I = I - 1</span><br><span class="line">	  IF (I .EQ. 0) RETURN</span><br><span class="line">	    IF (RHS(I) .EQ. 0.0E0) GO TO 100</span><br></pre></td></tr></table></figure>
<p>不然的话，按照上面的公式进行处理，下面这两行将 RHS(I) 赋值为 RHS(I)/DIAG(I) ，OPS 加1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S = RHS(I)/DIAG(I)</span><br><span class="line">RHS(I) = S</span><br><span class="line">OPS = OPS + 1.0D0</span><br></pre></td></tr></table></figure>
<p>接下来处理第二步， <img src="https://math.now.sh?inline=%5Cmathbf%7BL%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/> 的第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 列，就是 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 矩阵的第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行，而且只需要针对第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/>  行的非零元素。</p>
<p>IBAND 是第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行的 <em>bandwidth</em> ，KSTRT 和 KSTOP 是第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行相对于 IBAND 的第一个位置和最后一个位置。</p>
<p><code>L = XENV(I+1) - IBAND</code> 其实就是 <code>XENV(I)</code>，就是 ENV 向量中第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行的第一个元素位置 。</p>
<p><code>DO 200</code> 循环中，<code>RHS(K) = RHS(K) - S*ENV(L)</code> ，就是右手项相应元素减去 RHS(I) 乘以 第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行的相应元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	  IBAND = XENV(I+1) - XENV(I)</span><br><span class="line">	  IF (IBAND .GE. I) IBAND = I-1</span><br><span class="line">	  IF (IBAND .EQ. 0) GO TO 100</span><br><span class="line">	    KSTRT = I - IBAND</span><br><span class="line">	    KSTOP = I - 1</span><br><span class="line">	    L = XENV(I+1) - IBAND</span><br><span class="line">	    DO 200 K = KSTRT, KSTOP</span><br><span class="line">	      RHS(K) = RHS(K) - S*ENV(L)</span><br><span class="line">	      L = L + 1</span><br><span class="line">	    CONTINUE</span><br><span class="line">	    COUNT = IBAND</span><br><span class="line">	    OPS = OPS + COUNT</span><br><span class="line">	  GO TO 100</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p>一直遍历到 <img src="https://math.now.sh?inline=i%20%3D%201" style="display:inline-block;margin: 0;"/> 为止，便得到了所有未知数的解。</p>
<h1>参考文献</h1>
<ol>
<li>George A, Liu J, Ng E. Computer solution of sparse linear systems[J]. Oak Ridge National Laboratory, 1994.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>稀疏矩阵</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>稀疏矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏矩阵算法Envelope方法一之存储格式</title>
    <url>/posts/e5ac741a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本章节是介绍 George and Liu 书中 Envelope Method 的应用</p>
<span id="more"></span>
<h1>Envelope 存储格式</h1>
<p>这个存储格式中，数组 <strong>ENV</strong> 包含矩阵中每一行的 <em>envelope entries</em> ，一个长度为 <img src="https://math.now.sh?inline=n%2B1" style="display:inline-block;margin: 0;"/> 的索引向量 <strong>XENV</strong> ，其用于指示每一行的开始位置，而 <img src="https://math.now.sh?inline=XENV%28n%2B1%29%20%3D%20%7CEnv(%5Cmathbf%7BA%7D)%7C%20%2B%201" style="display:inline-block;margin: 0;"/> ，如同之前的索引向量。</p>
<p><img src="https://math.now.sh?inline=Env%28%5Cmathbf%7BA%7D%29" style="display:inline-block;margin: 0;"/> 中的 <img src="https://math.now.sh?inline=%5C%7B%20i%2Cj%5C%7D" style="display:inline-block;margin: 0;"/> 元素对应关系如下：</p>
<p style=""><img src="https://math.now.sh?from=%5C%7B%20i%2Cj%5C%7D%20%5Crightarrow%20%5Cmathrm%7BXENV%7D%28i%2B1%29%20-%20(i-j)%0A" /></p><p>换句话说，矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的 <em>envelope</em> 区域的某个元素 <img src="https://math.now.sh?inline=a_%7Bij%7D" style="display:inline-block;margin: 0;"/> 可以表示为 <img src="https://math.now.sh?inline=ENV%28XENV(i%2B1%29%20-%20(i-j))" style="display:inline-block;margin: 0;"/> 。下图是一个例子，对于其中的 <img src="https://math.now.sh?inline=a_%7B64%7D" style="display:inline-block;margin: 0;"/> ，我们有 <img src="https://math.now.sh?inline=ENV%28%5Cmathrm%7BXENV%7D(7%29%20-%20(6-4))%20%3D%20ENV(8)%20%3D%20a_%7B64%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p><img src="41.png" alt="1"></p>
<p>更一般的操作是提取 <em>envelope</em> 区域的一行，这个可以按照下面的方式进行</p>
<h3 id="The-Storage-Allocation-Subroutine-FNENV">The Storage Allocation Subroutine FNENV</h3>
<p>在这一章节中我们讨论子程序 <strong>FNENV (FiNd ENVelope)</strong> ，这个子程序输入为矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的图，存储在数组对**(XADJ, ADJNCY)** 中，伴随着其置换矩阵 <strong>PERM</strong> 以及其逆向量 <strong>INVP</strong> 。假如 <img src="https://math.now.sh?inline=%5Cmathrm%7BPERM%7D%28i%29%20%3D%20k" style="display:inline-block;margin: 0;"/> ，那么就说明原始编号 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 在新顺序中其编号是 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/>  。我们通常会用一个相应的长度为 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 的置换向量 <strong>INVP</strong> (<em>the inverse permutation</em>) ，其满足 <img src="https://math.now.sh?inline=%5Cmathrm%7BINVP%28PERM(i%29)%20%3D%20i%7D" style="display:inline-block;margin: 0;"/> 。也就是说，INVP(k) 表示原始编号 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 在新顺序中的位置。</p>
<p>这个子程序的目的是计算上面讨论的数组 <strong>XENV</strong> ，这可以用于存储 <img src="https://math.now.sh?inline=%5Cmathbf%7BPAP%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/> 的 Cholesky 分解因子 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> ；同时返回 <strong>ENVSZE</strong>，这是 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 的 <em>envelope size</em> ，等于<img src="https://math.now.sh?inline=XENV%28NEQNS%20%2B1%29-1" style="display:inline-block;margin: 0;"/> ，其中 <strong>NEQNS</strong> 为节点或者方程的数目。</p>
<p>这里是说，<img src="https://math.now.sh?inline=%5Cmathbf%7BPAP%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 的 <em>envelope</em> 的结构是一样的（证明略）。</p>
<p>这个子程序的内容很简单，循环 <code>DO 200 I= ...</code> 对每一行进行处理，其中循环 <code>DO 100 I= ...</code> 会找到  <img src="https://math.now.sh?inline=%5Cmathbf%7BPAP%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/> 第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行的第一个非零元素的索引 (<strong>IFIRST</strong>) 。</p>
<p><img src="42.png" alt="1"></p>
<p><img src="43.png" alt="1"></p>
<p>下面开始逐行解析脚本，首先初始化 BANDW=0, ENVSZE=1，注意这里的 ENVSZE 其实就是每行的初始位置。</p>
<p>对于每一行进行循环，<code>XENV(I) = ENVSZE</code>  设置每一行的 XENV 的元素，这一行对应的置换矩阵的原始节点编号为 <code>IPERM = PERM(I)</code>，设这一行第一个非零元素位置为 IFIRST ，初始值设为 <code>i</code></p>
<p>通过 <code>DO 100</code> 遍历其相邻的原始节点，<code>NABOR = ADJNCY(J)</code> 得到其原始编号，<code>NABOR = INVP(NABOR)</code> 进一步得到其在置换矩阵中的新编号，如果新编号低于 IFIRST ，则用这个编号覆盖 IFIRST ，最终得到 IFIRST 的真实值。</p>
<p>通过 <code>I - IFIRST</code> 得到这一行的 <em>bandwidth</em> ，记为 <code>IBAND</code> ，下一行的初始位置更新为 <code>ENVSZE = ENVSZE + IBAND</code> ，如果 <code>BANDW</code> 小于  <code>IBAND</code> ，则 <code>BANDW = IBAND</code> ，最终得到矩阵的 <em>bandwidth</em> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	  BANDW = 0</span><br><span class="line">	  ENVSZE = 1</span><br><span class="line">	  DO 200 I=1, NEQNS</span><br><span class="line">	    XENV(I) = ENVSZE</span><br><span class="line">	    IPERM = PERM(I)</span><br><span class="line">	    JSTRT = XADJ(IPERM)</span><br><span class="line">	    JSTOP = XADJ(IPERM + 1) - 1</span><br><span class="line">	    IF (JSTOP .LT. JSTRT) GO TO 200</span><br><span class="line">          IFIRST = I</span><br><span class="line">          DO 100 J = JSTRT, JSTOP</span><br><span class="line">            NABOR = ADJNCY(J)</span><br><span class="line">            NABOR = INVP(NABOR)</span><br><span class="line">            IF ( NABOR .LT. IFIRST ) IFIRST = NABOR</span><br><span class="line">100       CONTINUE</span><br><span class="line">          IBAND = I - IFIRST</span><br><span class="line">          ENVSZE = ENVSZE + IBAND</span><br><span class="line">          IF (BANDW .LT. IBAND) BANDW = IBAND</span><br><span class="line">200   CONTINUE</span><br></pre></td></tr></table></figure>
<p>最后，XENV 需要补上最后一个元素 <code>NEQNS+1</code></p>
<p>实际的 <code>ENVSZE</code> 需要减1，程序终止</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  XENV(NEQNS+1) = ENVSZE</span><br><span class="line">  ENVSZE = ENVSZE - 1</span><br><span class="line">  RETURN</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<h1>参考文献</h1>
<ol>
<li>George A, Liu J, Ng E. Computer solution of sparse linear systems[J]. Oak Ridge National Laboratory, 1994.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>稀疏矩阵</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>稀疏矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏矩阵算法RCM算法三之RCM算法</title>
    <url>/posts/23fd2749/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本章节是介绍 George and Liu 书中 RCM 算法脚本的第三篇，介绍RCM的完整算法。</p>
<span id="more"></span>
<h1>程序结构</h1>
<p>在这一章节中，我们会介绍三个子程序 <strong>DEGREE, RCM, GENRCM</strong> ，再加上之前提到的子程序，就构成了 RCM 算法的所有脚本。其输入为 ROOT, MASK, XADJ, ADJNCY 和 PERM 。不同子程序之间的关系见下图：</p>
<p><img src="32.png" alt="1"></p>
<h1>DEGREE</h1>
<p>这个子程序会计算一个连通组分中所有节点的度数。其输入为 ROOT, MASK, XADJ, ADJNCY 。</p>
<p>这个子程序会从第一层 (只包含 ROOT ) 开始，同时计算每一层的所有节点的度数，然后产生下一层的所有节点，加入到 LS 数组中。当一个节点加入到 LS 数组中，其在 XADJ 数组中的符号会改变，从而确保这个节点只会被记录一次（这个功能之前在 ROOTLS 中是通过修改 MASK 数组实现的，但是这里 MASK 必须保持不变，以保证所有节点的度数可以正确计算）。</p>
<p>变量 CCSIZE 包含了当前在 LS 中的节点数目。当所有的节点均被发现之后，所有节点的度数也计算完毕，此时 LS 数组中的节点在 XADJ 中的元素会改回原来的符号。</p>
<p>输出的 LS 的结构是一个节点，后面接着这个节点的所有相邻节点，而不是按照上面的那种层次结构。</p>
<p>脚本如下（**IABS()**是 fortran 内置的对整数求绝对值的函数）</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">C****************************************************************          <span class="number">1.</span></span><br><span class="line">C****************************************************************          <span class="number">2.</span></span><br><span class="line">C**********    DEGREE ..... DEGREE <span class="keyword">IN</span> MASKED COMPONENT        ***          <span class="number">3.</span></span><br><span class="line">C****************************************************************          <span class="number">4.</span></span><br><span class="line">C****************************************************************          <span class="number">5.</span></span><br><span class="line"><span class="comment">C                                                                          6.</span></span><br><span class="line"><span class="comment">C     PURPOSE - THIS ROUTINE COMPUTES THE DEGREES OF THE NODE              7.</span></span><br><span class="line"><span class="comment">C        IN THE CONNECTED COMPONENT SPECIFIED BY MASK AND ROOT.            8.</span></span><br><span class="line"><span class="comment">C        NODES FOR WHICH MASK IS ZERO ARE IGNORED.                         9.</span></span><br><span class="line"><span class="comment">C                                                                         10.</span></span><br><span class="line"><span class="comment">C    INPUT PARAMETERS -                                                   11.</span></span><br><span class="line"><span class="comment">C        ROOT - IS THE INPUT NODE THAT DEFINES THE COMPONENT              12.</span></span><br><span class="line"><span class="comment">C        (XADJ, ADJNCY) - ADJACENCY STRUCTURE PAIR.                       13.</span></span><br><span class="line"><span class="comment">C        MASK - SPECIFIES A SECTION SUBGRAPH.                             14.</span></span><br><span class="line"><span class="comment">C                                                                         15.</span></span><br><span class="line"><span class="comment">C     OUTPUT PARAMETERS -                                                 16.</span></span><br><span class="line"><span class="comment">C        DEG - ARRAY CONTAINING THE DEGREES OF THE NODES IN               17.</span></span><br><span class="line"><span class="comment">C              THE COMPONENT                                              18.</span></span><br><span class="line"><span class="comment">C        CCSIZE - SIZE OF THE COMPONENT SPECIFIED BY MASK AND ROOT        19.</span></span><br><span class="line"><span class="comment">C                                                                         20.</span></span><br><span class="line"><span class="comment">C     WORKING PARAMETER -                                                 21.</span></span><br><span class="line"><span class="comment">C        LS - A TEMPORARY VECTOR USED TO STORE THE NODES OF THE           22.</span></span><br><span class="line"><span class="comment">C               COMPONENT LEVEL BY LEVEL                                  23.</span></span><br><span class="line"><span class="comment">C                                                                         24.</span></span><br><span class="line">C****************************************************************         <span class="number">25.</span></span><br><span class="line"><span class="comment">C                                                                         26.</span></span><br><span class="line">      <span class="function"><span class="keyword">SUBROUTINE</span></span>  DEGREE ( ROOT, XADJ, ADJNCY, MASK,                      <span class="number">27.</span></span><br><span class="line">     <span class="number">1</span>                     DEG, CCSIZE, LS )                              <span class="number">28.</span></span><br><span class="line"><span class="comment">C                                                                         29.</span></span><br><span class="line">C****************************************************************         <span class="number">30.</span></span><br><span class="line"><span class="comment">C                                                                         31.</span></span><br><span class="line">         <span class="keyword">INTEGER</span> ADJNCY(<span class="number">1</span>), DEG(<span class="number">1</span>), LS(<span class="number">1</span>), MASK(<span class="number">1</span>)                        <span class="number">32.</span></span><br><span class="line">         <span class="keyword">INTEGER</span> XADJ(<span class="number">1</span>), CCSIZE, I, IDEG, J, JSTOP, JSTRT,               <span class="number">33.</span></span><br><span class="line">     <span class="number">1</span>           LBEGIN, LVLEND, LVSIZE, NBR, NODE, ROOT                  <span class="number">34.</span></span><br><span class="line"><span class="comment">C                                                                         35.</span></span><br><span class="line">C****************************************************************         <span class="number">36.</span></span><br><span class="line"><span class="comment">C                                                                         37.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            38.</span></span><br><span class="line"><span class="comment">C        INITIALIZATION ...                                               39.</span></span><br><span class="line"><span class="comment">C        THE ARRAY XADJ IS USED AS A TEMPORARY MARKER TO                  40.</span></span><br><span class="line"><span class="comment">C        INDICATE WHICH NODES HAVE BEEN CONSIDERED SO FAR.                41.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            42.</span></span><br><span class="line">         LS(<span class="number">1</span>) = ROOT                                                     <span class="number">43.</span></span><br><span class="line">         XADJ(ROOT) = -XADJ(ROOT)                                         <span class="number">44.</span></span><br><span class="line">         LVLEND = <span class="number">0</span>                                                       <span class="number">45.</span></span><br><span class="line">         CCSIZE = <span class="number">1</span>                                                       <span class="number">46.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            47.</span></span><br><span class="line"><span class="comment">C        LBEGIN IS THE POINTER OT THE BEGINNING OF THE CURRENT            48.</span></span><br><span class="line"><span class="comment">C        LEVEL. AND LVLEND POINTS TO THE END OF THIS LEVEL.               49.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            50.</span></span><br><span class="line">   <span class="number">100</span>   LBEGIN = LVLEND + <span class="number">1</span>                                              <span class="number">51.</span></span><br><span class="line">         LVLEND = CCSIZE                                                  <span class="number">52.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            53.</span></span><br><span class="line"><span class="comment">C        FIND THE DEGREES OF NODES IN THE CURRENT LEVEL,                  54.</span></span><br><span class="line"><span class="comment">C        AND AT THE SAME TIME, GENERATE THE NEXT LEVEL.                   55.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            56.</span></span><br><span class="line">         <span class="keyword">DO</span> <span class="number">400</span> I = LBEGIN, LVLEND                                        <span class="number">57.</span></span><br><span class="line">            NODE = LS(I)                                                  <span class="number">58.</span></span><br><span class="line">            JSTRT = -XADJ(NODE)                                           <span class="number">59.</span></span><br><span class="line">            JSTOP = <span class="built_in">IABS</span>(XADJ(NODE+<span class="number">1</span>)) - <span class="number">1</span>                                <span class="number">60.</span></span><br><span class="line">            IDEG = <span class="number">0</span>                                                      <span class="number">61.</span></span><br><span class="line">            <span class="keyword">IF</span> ( JSTOP .LT. JSTRT ) GO TO <span class="number">300</span>                             <span class="number">62.</span></span><br><span class="line">               <span class="keyword">DO</span> <span class="number">200</span> J = JSTRT, JSTOP                                    <span class="number">63.</span></span><br><span class="line">                  NBR = ADJNCY(J)                                         <span class="number">64.</span></span><br><span class="line">                  <span class="keyword">IF</span> ( MASK(NBR) .EQ. <span class="number">0</span> ) GO TO <span class="number">200</span>                       <span class="number">65.</span></span><br><span class="line">                     IDEG = IDEG + <span class="number">1</span>                                      <span class="number">66.</span></span><br><span class="line">                     <span class="keyword">IF</span> ( XADJ(NBR) .LT. <span class="number">0</span> ) GO TO <span class="number">200</span>                    <span class="number">67.</span></span><br><span class="line">                        XADJ(NBR) = -XADJ(NBR)                            <span class="number">68.</span></span><br><span class="line">                        CCSIZE = CCSIZE + <span class="number">1</span>                               <span class="number">69.</span></span><br><span class="line">                        LS(CCSIZE) = NBR                                  <span class="number">70.</span></span><br><span class="line">  <span class="number">200</span>          <span class="keyword">CONTINUE</span>                                                   <span class="number">71.</span></span><br><span class="line">  <span class="number">300</span>       DEG(NODE) = IDEG                                              <span class="number">72.</span></span><br><span class="line">  <span class="number">400</span>    <span class="keyword">CONTINUE</span>                                                         <span class="number">73.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            74.</span></span><br><span class="line"><span class="comment">C        COMPUTE THE CURRENT LEVEL WIDTH.                                 75.</span></span><br><span class="line"><span class="comment">C        IF IT IS NONZERO, GENERATE ANOTHER LEVEL.                        76.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            77.</span></span><br><span class="line">         LVSIZE = CCSIZE - LVLEND                                         <span class="number">78.</span></span><br><span class="line">         <span class="keyword">IF</span> ( LVSIZE .GT. <span class="number">0</span> ) GO TO <span class="number">100</span>                                   <span class="number">79.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            80.</span></span><br><span class="line"><span class="comment">C        RESET XADJ TO ITS CORRECT SIGN AND RETURN.                       81.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            82.</span></span><br><span class="line">         <span class="keyword">DO</span> <span class="number">500</span> I = <span class="number">1</span>, CCSIZE                                             <span class="number">83.</span></span><br><span class="line">            NODE = LS(I)                                                  <span class="number">84.</span></span><br><span class="line">            XADJ(NODE) = -XADJ(NODE)                                      <span class="number">85.</span></span><br><span class="line">  <span class="number">500</span>    <span class="keyword">CONTINUE</span>                                                         <span class="number">86.</span></span><br><span class="line">         <span class="keyword">RETURN</span>                                                           <span class="number">87.</span></span><br><span class="line">      <span class="keyword">END</span>                                                                 <span class="number">88.</span></span><br></pre></td></tr></table></figure>
<p>下面我们开始逐行分析脚本。</p>
<p>首先是初始化过程，从 ROOT 节点开始，将其加入到 LS 向量中，并将其 XADJ 中的值改为负数。</p>
<p>凡是加入到 LS 向量中的节点，其 XADJ 中的值均要改为相应的负数，防止重复添加到 LS 向量中。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C        -----------------------------------------------------            38.</span></span><br><span class="line"><span class="comment">C        INITIALIZATION ...                                               39.</span></span><br><span class="line"><span class="comment">C        THE ARRAY XADJ IS USED AS A TEMPORARY MARKER TO                  40.</span></span><br><span class="line"><span class="comment">C        INDICATE WHICH NODES HAVE BEEN CONSIDERED SO FAR.                41.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            42.</span></span><br><span class="line">         LS(<span class="number">1</span>) = ROOT                                                     <span class="number">43.</span></span><br><span class="line">         XADJ(ROOT) = -XADJ(ROOT)                                         <span class="number">44.</span></span><br><span class="line">         LVLEND = <span class="number">0</span>                                                       <span class="number">45.</span></span><br><span class="line">         CCSIZE = <span class="number">1</span>                                                       <span class="number">46.</span></span><br></pre></td></tr></table></figure>
<p>开始进入循环，其中 LBEGIN 是当前层的起点，LVLEND 是当前层的终点</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C        -----------------------------------------------------            47.</span></span><br><span class="line"><span class="comment">C        LBEGIN IS THE POINTER OT THE BEGINNING OF THE CURRENT            48.</span></span><br><span class="line"><span class="comment">C        LEVEL. AND LVLEND POINTS TO THE END OF THIS LEVEL.               49.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            50.</span></span><br><span class="line">   <span class="number">100</span>   LBEGIN = LVLEND + <span class="number">1</span>                                              <span class="number">51.</span></span><br><span class="line">         LVLEND = CCSIZE                                                  <span class="number">52.</span></span><br></pre></td></tr></table></figure>
<p>查找当前层的所有节点的度数，注意这里已经是加入到 LS 向量中的节点，<code>XADJ(NODE)</code> 本身就是负数，而 <code>XADJ(NODE + 1)</code> 不确定是否是负数，因此采用 <code>IABS()</code> 函数取绝对值。</p>
<p><code>IDEG</code> 记录度数，其中的节点必须满足 MASK 值不为0的条件；如果这些节点进一步满足其 XADJ 值不为负数，则加入到 LS 向量中，LS 向量长度 CCSIZE 加1，其 XADJ 值改为负数，这些节点作为下一层次的节点。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C        -----------------------------------------------------            53.</span></span><br><span class="line"><span class="comment">C        FIND THE DEGREES OF NODES IN THE CURRENT LEVEL,                  54.</span></span><br><span class="line"><span class="comment">C        AND AT THE SAME TIME, GENERATE THE NEXT LEVEL.                   55.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            56.</span></span><br><span class="line">         <span class="keyword">DO</span> <span class="number">400</span> I = LBEGIN, LVLEND                                        <span class="number">57.</span></span><br><span class="line">            NODE = LS(I)                                                  <span class="number">58.</span></span><br><span class="line">            JSTRT = -XADJ(NODE)                                           <span class="number">59.</span></span><br><span class="line">            JSTOP = <span class="built_in">IABS</span>(XADJ(NODE+<span class="number">1</span>)) - <span class="number">1</span>                                <span class="number">60.</span></span><br><span class="line">            IDEG = <span class="number">0</span>                                                      <span class="number">61.</span></span><br><span class="line">            <span class="keyword">IF</span> ( JSTOP .LT. JSTRT ) GO TO <span class="number">300</span>                             <span class="number">62.</span></span><br><span class="line">               <span class="keyword">DO</span> <span class="number">200</span> J = JSTRT, JSTOP                                    <span class="number">63.</span></span><br><span class="line">                  NBR = ADJNCY(J)                                         <span class="number">64.</span></span><br><span class="line">                  <span class="keyword">IF</span> ( MASK(NBR) .EQ. <span class="number">0</span> ) GO TO <span class="number">200</span>                       <span class="number">65.</span></span><br><span class="line">                     IDEG = IDEG + <span class="number">1</span>                                      <span class="number">66.</span></span><br><span class="line">                     <span class="keyword">IF</span> ( XADJ(NBR) .LT. <span class="number">0</span> ) GO TO <span class="number">200</span>                    <span class="number">67.</span></span><br><span class="line">                        XADJ(NBR) = -XADJ(NBR)                            <span class="number">68.</span></span><br><span class="line">                        CCSIZE = CCSIZE + <span class="number">1</span>                               <span class="number">69.</span></span><br><span class="line">                        LS(CCSIZE) = NBR                                  <span class="number">70.</span></span><br><span class="line">  <span class="number">200</span>          <span class="keyword">CONTINUE</span>                                                   <span class="number">71.</span></span><br><span class="line">  <span class="number">300</span>       DEG(NODE) = IDEG                                              <span class="number">72.</span></span><br><span class="line">  <span class="number">400</span>    <span class="keyword">CONTINUE</span>                                                         <span class="number">73.</span></span><br></pre></td></tr></table></figure>
<p>我们计算当前层次的节点数目，如果不为0，则继续循环。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C        -----------------------------------------------------            74.</span></span><br><span class="line"><span class="comment">C        COMPUTE THE CURRENT LEVEL WIDTH.                                 75.</span></span><br><span class="line"><span class="comment">C        IF IT IS NONZERO, GENERATE ANOTHER LEVEL.                        76.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            77.</span></span><br><span class="line">         LVSIZE = CCSIZE - LVLEND                                         <span class="number">78.</span></span><br><span class="line">         <span class="keyword">IF</span> ( LVSIZE .GT. <span class="number">0</span> ) GO TO <span class="number">100</span>                                   <span class="number">79.</span></span><br></pre></td></tr></table></figure>
<p>最后我们将 XADJ 向量“复原”</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C        -----------------------------------------------------            80.</span></span><br><span class="line"><span class="comment">C        RESET XADJ TO ITS CORRECT SIGN AND RETURN.                       81.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            82.</span></span><br><span class="line">         <span class="keyword">DO</span> <span class="number">500</span> I = <span class="number">1</span>, CCSIZE                                             <span class="number">83.</span></span><br><span class="line">            NODE = LS(I)                                                  <span class="number">84.</span></span><br><span class="line">            XADJ(NODE) = -XADJ(NODE)                                      <span class="number">85.</span></span><br><span class="line">  <span class="number">500</span>    <span class="keyword">CONTINUE</span>                                                         <span class="number">86.</span></span><br><span class="line">         <span class="keyword">RETURN</span>                                                           <span class="number">87.</span></span><br><span class="line">      <span class="keyword">END</span>                                                                 <span class="number">88.</span></span><br></pre></td></tr></table></figure>
<h1>RCM</h1>
<p><strong>Reverse Cuthill-McKee</strong>, 这个子程序就是对一个<strong>连通组分</strong>执行 RCM 算法，其输入为  ROOT, MASK, XADJ, ADJNCY 。</p>
<p>因为这个算法要求知道连通组分中所有节点的度数，因此其第一步就是通过调用 <strong>DEGREE</strong> 子程序计算所有节点的度数，所有节点会按照一层接着一层的顺序排列在 LS 数组中（这里是 PERM 数组），但是每一层的节点之间没有按照度数从低到高排序；因此我们通过 <code>DO 600 I = ...</code> 对每一层的节点按照度数排序或者说编码，生成一个新的顺序的层；通过循环 <code>DO 200 I = ...</code> 查找某个节点的所有未编码的相邻节点，按照度数从低到高的顺序排序。最终新的排序会记录在 <strong>PERM</strong> 数组中，最后再翻转这个顺序，得到我们最终想要的顺序。</p>
<p>注意，这里就像 ROOTLS 子程序，当节点 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 编码了之后，MASK(i) 会设为0；但是不像  ROOTLS 子程序， RCM 子程序不会将 MASK 数组恢复如初，其编码后的节点始终为 0 。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">C****************************************************************          <span class="number">1.</span></span><br><span class="line">C****************************************************************          <span class="number">2.</span></span><br><span class="line">C**********    RCM ..... REVERSE CUTHILL-MCKEE ORDERING       ***          <span class="number">3.</span></span><br><span class="line">C****************************************************************          <span class="number">4.</span></span><br><span class="line">C****************************************************************          <span class="number">5.</span></span><br><span class="line"><span class="comment">C                                                                          6.</span></span><br><span class="line"><span class="comment">C     PURPOSE - RCM NUMBERS A CONNECTED COMPONENT SPECIFIED BY             7.</span></span><br><span class="line"><span class="comment">C        MASK AND ROOT, USING THE RCM ALGORITHM.                           8.</span></span><br><span class="line"><span class="comment">C        THE NUMBERING IS TO BE STARTED AT THE NODE ROOT.                  9.</span></span><br><span class="line"><span class="comment">C                                                                         10.</span></span><br><span class="line"><span class="comment">C    INPUT PARAMETERS -                                                   11.</span></span><br><span class="line"><span class="comment">C        ROOT - IS THE NODE THAT DEFINES THE CONNECTED                    12.</span></span><br><span class="line"><span class="comment">C               COMPONENT AND IT IS USED AS THE STARTING                  13.</span></span><br><span class="line"><span class="comment">C               NODE FOR THE RCM ORDERING                                 14.</span></span><br><span class="line"><span class="comment">C        (XADJ, ADJNCY) - ADJACENCY STRUCTURE PAIR FOR                    15.</span></span><br><span class="line"><span class="comment">C                         THE GRAPH.                                      16.</span></span><br><span class="line"><span class="comment">C                                                                         17.</span></span><br><span class="line"><span class="comment">C     UPDATED PARAMETERS -                                                18.</span></span><br><span class="line"><span class="comment">C        MASK - ONLY THOSE NODES WITH NONZERO INPUT MASK                  19.</span></span><br><span class="line"><span class="comment">C               VALUES ARE CONSIDERED BY THE ROUTINE. THE                 20.</span></span><br><span class="line"><span class="comment">C               NODES NUMBERED BY RCM WILL HAVE THEIR                     21.</span></span><br><span class="line"><span class="comment">C               MASK VALUES SET TO ZERO.                                  22.</span></span><br><span class="line"><span class="comment">C                                                                         23.</span></span><br><span class="line"><span class="comment">C     OUTPUT PARAMETERS -                                                 24.</span></span><br><span class="line"><span class="comment">C        PERM - WILL CONTAIN THE RCM ORDERING                             25.</span></span><br><span class="line"><span class="comment">C        CCSIZE - IS THE SIZE OF THE CONNECTED COMPONENT                  26.</span></span><br><span class="line"><span class="comment">C                 THAT HAS BEEN NUMBERED BY RCM.                          27.</span></span><br><span class="line"><span class="comment">C                                                                         28.</span></span><br><span class="line"><span class="comment">C     WORKING PARAMETER -                                                 29.</span></span><br><span class="line"><span class="comment">C        DEG - IS A TEMPORARY VECTOR USED TO HOLD THE DEGREE              30.</span></span><br><span class="line"><span class="comment">C              OF THE NODES IN THE SECTION GRAPH SPECIFIED                31.</span></span><br><span class="line"><span class="comment">C              BY MASK AND ROOT                                           32.</span></span><br><span class="line"><span class="comment">C                                                                         33.</span></span><br><span class="line"><span class="comment">C     PROGRAM SUBROUTINES -                                               34.</span></span><br><span class="line"><span class="comment">C        DEGREE.                                                          35.</span></span><br><span class="line"><span class="comment">C                                                                         36.</span></span><br><span class="line">C****************************************************************         <span class="number">37.</span></span><br><span class="line"><span class="comment">C                                                                         38.</span></span><br><span class="line">      <span class="function"><span class="keyword">SUBROUTINE</span></span>  RCM ( ROOT, XADJ, ADJNCY, MASK,                         <span class="number">39.</span></span><br><span class="line">     <span class="number">1</span>                     PERM, CCSIZE, DEG )                            <span class="number">40.</span></span><br><span class="line"><span class="comment">C                                                                         41.</span></span><br><span class="line">C****************************************************************         <span class="number">42.</span></span><br><span class="line"><span class="comment">C                                                                         43.</span></span><br><span class="line">         <span class="keyword">INTEGER</span> ADJNCY(<span class="number">1</span>), DEG(<span class="number">1</span>), MASK(<span class="number">1</span>), PERM(<span class="number">1</span>)                      <span class="number">44.</span></span><br><span class="line">         <span class="keyword">INTEGER</span> XADJ(<span class="number">1</span>), CCSIZE, FNBR, I, J, JSTOP,                      <span class="number">45.</span></span><br><span class="line">     <span class="number">1</span>           JSTRT, K, L, LBEGIN, LNBR, LPERM,                        <span class="number">46.</span></span><br><span class="line">     <span class="number">1</span>           LVLEND, NBR, NODE, ROOT                                  <span class="number">47.</span></span><br><span class="line"><span class="comment">C                                                                         48.</span></span><br><span class="line">C****************************************************************         <span class="number">49.</span></span><br><span class="line"><span class="comment">C                                                                         50.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            51.</span></span><br><span class="line"><span class="comment">C        FIND THE DEGREES OF THE NODES IN THE                             52.</span></span><br><span class="line"><span class="comment">C        COMPONENT SPECIFIED BY MASK ADN ROOT.                            53.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            54.</span></span><br><span class="line">         <span class="keyword">CALL</span> DEGREE( ROOT, XADJ, ADJNCY, MASK, DEG,                      <span class="number">55.</span></span><br><span class="line">     <span class="number">1</span>                CCSIZE, PERM )                                      <span class="number">56.</span></span><br><span class="line">         MASK(ROOT) = <span class="number">0</span>                                                   <span class="number">57.</span></span><br><span class="line">         <span class="keyword">IF</span> ( CCSIZE .LE. <span class="number">1</span> ) <span class="keyword">RETURN</span>                                      <span class="number">58.</span></span><br><span class="line">         LVLEND = <span class="number">0</span>                                                       <span class="number">59.</span></span><br><span class="line">         LNBR = <span class="number">1</span>                                                         <span class="number">60.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            61.</span></span><br><span class="line"><span class="comment">C        LBEGIN AND LVLEND POINT OT THE BEGINNING AND                     62.</span></span><br><span class="line"><span class="comment">C        THE END OF THE CURRENT LEVEL RESPECTIVELY.                       63.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            64.</span></span><br><span class="line">  <span class="number">100</span>    LBEGIN = LVLEND + <span class="number">1</span>                                              <span class="number">65.</span></span><br><span class="line">         LVLEND = LNBR                                                    <span class="number">66.</span></span><br><span class="line">         <span class="keyword">DO</span> <span class="number">600</span> I = LBEGIN, LVLEND                                        <span class="number">67.</span></span><br><span class="line"><span class="comment">C           --------------------------------------------------            68.</span></span><br><span class="line"><span class="comment">C           FOR EACH NODE IN CURRENT LEVEL ...                            69.</span></span><br><span class="line"><span class="comment">C           --------------------------------------------------            70.</span></span><br><span class="line">            NODE = PERM(I)                                                <span class="number">71.</span></span><br><span class="line">            JSTRT = XADJ(NODE)                                            <span class="number">72.</span></span><br><span class="line">            JSTOP = XADJ(NODE+<span class="number">1</span>) - <span class="number">1</span>                                      <span class="number">73.</span></span><br><span class="line"><span class="comment">C           --------------------------------------------------            74.</span></span><br><span class="line"><span class="comment">C           FIND THE UNNUMBERED NEIGHBORS OF NODE.                        75.</span></span><br><span class="line"><span class="comment">C           FNBR AND LNBR POINT TO THE FIRST AND LAST                     76.</span></span><br><span class="line"><span class="comment">C           UNNUMBERED NEIGHBORS RESPECTIVELY OF THE CURRENT              77.</span></span><br><span class="line"><span class="comment">C           NODE IN PERM.                                                 78.</span></span><br><span class="line"><span class="comment">C           --------------------------------------------------            79.</span></span><br><span class="line">            FNBR = LNBR + <span class="number">1</span>                                               <span class="number">80.</span></span><br><span class="line">            <span class="keyword">DO</span> <span class="number">200</span> J = JSTRT, JSTOP                                       <span class="number">81.</span></span><br><span class="line">               NBR = ADJNCY(J)                                            <span class="number">82.</span></span><br><span class="line">               <span class="keyword">IF</span> ( MASK(NBR) .EQ. <span class="number">0</span> ) GO TO <span class="number">200</span>                          <span class="number">83.</span></span><br><span class="line">                  LNBR = LNBR + <span class="number">1</span>                                         <span class="number">84.</span></span><br><span class="line">                  MASK(NBR) = <span class="number">0</span>                                           <span class="number">85.</span></span><br><span class="line">                  PERM(LNBR) = NBR                                        <span class="number">86.</span></span><br><span class="line">  <span class="number">200</span>       <span class="keyword">CONTINUE</span>                                                      <span class="number">87.</span></span><br><span class="line">            <span class="keyword">IF</span> ( FNBR .GE. LNBR ) GO TO <span class="number">600</span>                               <span class="number">88.</span></span><br><span class="line"><span class="comment">C              -----------------------------------------------            89.</span></span><br><span class="line"><span class="comment">C              SORT THE NEIGHBORS OF NODE IN INCREASING                   90.</span></span><br><span class="line"><span class="comment">C              ORDER BY DEGREE. LINEAR INSERTION IS USED.                 91.</span></span><br><span class="line"><span class="comment">C              -----------------------------------------------            92.</span></span><br><span class="line">               K = FNBR                                                   <span class="number">93.</span></span><br><span class="line">  <span class="number">300</span>          L = K                                                      <span class="number">94.</span></span><br><span class="line">                  K = K + <span class="number">1</span>                                               <span class="number">95.</span></span><br><span class="line">                  NBR = PERM(K)                                           <span class="number">96.</span></span><br><span class="line">  <span class="number">400</span>             <span class="keyword">IF</span> ( L .LT. FNBR ) GO TO <span class="number">500</span>                            <span class="number">97.</span></span><br><span class="line">                     LPERM = PERM(L)                                      <span class="number">98.</span></span><br><span class="line">                     <span class="keyword">IF</span> ( DEG(LPERM) .LE. DEG(NBR) ) GO TO <span class="number">500</span>            <span class="number">99.</span></span><br><span class="line">                        PERM(L+<span class="number">1</span>) = LPERM                                <span class="number">100.</span></span><br><span class="line">                        L = L -<span class="number">1</span>                                         <span class="number">101.</span></span><br><span class="line">                        GO TO <span class="number">400</span>                                        <span class="number">102.</span></span><br><span class="line">  <span class="number">500</span>             PERM(L+<span class="number">1</span>) = NBR                                        <span class="number">103.</span></span><br><span class="line">                  <span class="keyword">IF</span> ( K .LT. LNBR ) GO TO <span class="number">300</span>                           <span class="number">104.</span></span><br><span class="line">  <span class="number">600</span>    <span class="keyword">CONTINUE</span>                                                        <span class="number">105.</span></span><br><span class="line">         <span class="keyword">IF</span> (LNBR .GT. LVLEND) GO TO <span class="number">100</span>                                 <span class="number">106.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------           107.</span></span><br><span class="line"><span class="comment">C        WE NOW HAVE THE CUTHILL MCKEE ORDERING.                         108.</span></span><br><span class="line"><span class="comment">C        REVERSE IT BELOW ...                                            109.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------           110.</span></span><br><span class="line">         K = CCSIZE/<span class="number">2</span>                                                    <span class="number">111.</span></span><br><span class="line">         L = CCSIZE                                                      <span class="number">112.</span></span><br><span class="line">         <span class="keyword">DO</span> <span class="number">700</span> I = <span class="number">1</span>, K                                                 <span class="number">113.</span></span><br><span class="line">            LPERM = PERM(L)                                              <span class="number">114.</span></span><br><span class="line">            PERM(L) = PERM(I)                                            <span class="number">115.</span></span><br><span class="line">            PERM(I) = LPERM                                              <span class="number">116.</span></span><br><span class="line">            L = L - <span class="number">1</span>                                                    <span class="number">117.</span></span><br><span class="line">  <span class="number">700</span>    <span class="keyword">CONTINUE</span>                                                        <span class="number">118.</span></span><br><span class="line">         <span class="keyword">RETURN</span>                                                          <span class="number">119.</span></span><br><span class="line">      <span class="keyword">END</span>                                                                <span class="number">120.</span></span><br></pre></td></tr></table></figure>
<p>下面我们开始逐行查看这个脚本</p>
<p>首先我们调用 DEGREE 子程序，找到连通组分中所有节点的度数，注意这里的 LS 向量替换为 PERM 向量</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C        -----------------------------------------------------            51.</span></span><br><span class="line"><span class="comment">C        FIND THE DEGREES OF THE NODES IN THE                             52.</span></span><br><span class="line"><span class="comment">C        COMPONENT SPECIFIED BY MASK ADN ROOT.                            53.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            54.</span></span><br><span class="line">         <span class="keyword">CALL</span> DEGREE( ROOT, XADJ, ADJNCY, MASK, DEG,                      <span class="number">55.</span></span><br><span class="line">     <span class="number">1</span>                CCSIZE, PERM )                                      <span class="number">56.</span></span><br></pre></td></tr></table></figure>
<p>然后我们从 ROOT 出发，将其 MASK 值设为 0</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">MASK(ROOT) = <span class="number">0</span>                                                   <span class="number">57.</span></span><br><span class="line"><span class="keyword">IF</span> ( CCSIZE .LE. <span class="number">1</span> ) <span class="keyword">RETURN</span>                                      <span class="number">58.</span></span><br><span class="line">LVLEND = <span class="number">0</span>                                                       <span class="number">59.</span></span><br><span class="line">LNBR = <span class="number">1</span>                                                         <span class="number">60.</span></span><br></pre></td></tr></table></figure>
<p>LBEGIN 和 LVLEND 指向当前层次的初始和结束位置，进入循环。</p>
<p>FNBR 和 LNBR 指向这个节点的所有未排序的相邻节点的初始和结束位置（由于是连通子图，每个节点至少有一个相邻节点；但是考虑到 MASK 值为0的情况，因此可能有0个相邻节点）。并且将相应的节点重新赋值给 PERM 向量（这些节点之间还没有排序）。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C        -----------------------------------------------------            61.</span></span><br><span class="line"><span class="comment">C        LBEGIN AND LVLEND POINT OT THE BEGINNING AND                     62.</span></span><br><span class="line"><span class="comment">C        THE END OF THE CURRENT LEVEL RESPECTIVELY.                       63.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            64.</span></span><br><span class="line">  <span class="number">100</span>    LBEGIN = LVLEND + <span class="number">1</span>                                              <span class="number">65.</span></span><br><span class="line">         LVLEND = LNBR                                                    <span class="number">66.</span></span><br><span class="line">         <span class="keyword">DO</span> <span class="number">600</span> I = LBEGIN, LVLEND                                        <span class="number">67.</span></span><br><span class="line"><span class="comment">C           --------------------------------------------------            68.</span></span><br><span class="line"><span class="comment">C           FOR EACH NODE IN CURRENT LEVEL ...                            69.</span></span><br><span class="line"><span class="comment">C           --------------------------------------------------            70.</span></span><br><span class="line">            NODE = PERM(I)                                                <span class="number">71.</span></span><br><span class="line">            JSTRT = XADJ(NODE)                                            <span class="number">72.</span></span><br><span class="line">            JSTOP = XADJ(NODE+<span class="number">1</span>) - <span class="number">1</span>                                      <span class="number">73.</span></span><br><span class="line"><span class="comment">C           --------------------------------------------------            74.</span></span><br><span class="line"><span class="comment">C           FIND THE UNNUMBERED NEIGHBORS OF NODE.                        75.</span></span><br><span class="line"><span class="comment">C           FNBR AND LNBR POINT TO THE FIRST AND LAST                     76.</span></span><br><span class="line"><span class="comment">C           UNNUMBERED NEIGHBORS RESPECTIVELY OF THE CURRENT              77.</span></span><br><span class="line"><span class="comment">C           NODE IN PERM.                                                 78.</span></span><br><span class="line"><span class="comment">C           --------------------------------------------------            79.</span></span><br><span class="line">            FNBR = LNBR + <span class="number">1</span>                                               <span class="number">80.</span></span><br><span class="line">            <span class="keyword">DO</span> <span class="number">200</span> J = JSTRT, JSTOP                                       <span class="number">81.</span></span><br><span class="line">               NBR = ADJNCY(J)                                            <span class="number">82.</span></span><br><span class="line">               <span class="keyword">IF</span> ( MASK(NBR) .EQ. <span class="number">0</span> ) GO TO <span class="number">200</span>                          <span class="number">83.</span></span><br><span class="line">                  LNBR = LNBR + <span class="number">1</span>                                         <span class="number">84.</span></span><br><span class="line">                  MASK(NBR) = <span class="number">0</span>                                           <span class="number">85.</span></span><br><span class="line">                  PERM(LNBR) = NBR                                        <span class="number">86.</span></span><br><span class="line">  <span class="number">200</span>       <span class="keyword">CONTINUE</span>                                                      <span class="number">87.</span></span><br></pre></td></tr></table></figure>
<p>如果没有MASK 不为0的相邻节点，则 FNBR = LNBR + 1；如果只有一个MASK 值不为0的相邻节点，此时 FNBR = LNBR。这两种情况下，相邻节点不需要排序，<code>GO TO 600</code>，查找下一个节点。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">IF</span> ( FNBR .GE. LNBR ) GO TO <span class="number">600</span>                               <span class="number">88.</span></span><br></pre></td></tr></table></figure>
<p>正常情况下，我们要对刚刚加入到 PERM 向量中的向量节点进行排序（注意这里还在 <code>DO 600</code> 的循环内部）。</p>
<p>下面这段脚本的可读性太差了。看了半天大概看懂了，第 K 个位置和节点 NBR 相当于新增的节点，而之前的 FNBR 到  K-1 默认是已经排好序的节点。首先将第 K 个位置的节点与 K-1 位置的节点比较，如果左边大于等于右边则不用重排；否则将 K-1 位置的节点放到 K 位置，将 NBR 再和 K-2 位置的节点比较，依次比下去，直到找到 NBR 节点合适的<strong>插入</strong>位置。</p>
<p>其实就是看新增的 NBR 节点适合插入哪个位置，其实就是<a href="https://www.runoob.com/w3cnote/insertion-sort.html"><strong>插入排序</strong>算法</a>。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C              -----------------------------------------------            89.</span></span><br><span class="line"><span class="comment">C              SORT THE NEIGHBORS OF NODE IN INCREASING                   90.</span></span><br><span class="line"><span class="comment">C              ORDER BY DEGREE. LINEAR INSERTION IS USED.                 91.</span></span><br><span class="line"><span class="comment">C              -----------------------------------------------            92.</span></span><br><span class="line">               K = FNBR                                                   <span class="number">93.</span></span><br><span class="line">  <span class="number">300</span>          L = K                                                      <span class="number">94.</span></span><br><span class="line">                  K = K + <span class="number">1</span>                                               <span class="number">95.</span></span><br><span class="line">                  NBR = PERM(K)                                           <span class="number">96.</span></span><br><span class="line">  <span class="number">400</span>             <span class="keyword">IF</span> ( L .LT. FNBR ) GO TO <span class="number">500</span>                            <span class="number">97.</span></span><br><span class="line">                     LPERM = PERM(L)                                      <span class="number">98.</span></span><br><span class="line">                     <span class="keyword">IF</span> ( DEG(LPERM) .LE. DEG(NBR) ) GO TO <span class="number">500</span>            <span class="number">99.</span></span><br><span class="line">                        PERM(L+<span class="number">1</span>) = LPERM                                <span class="number">100.</span></span><br><span class="line">                        L = L -<span class="number">1</span>                                         <span class="number">101.</span></span><br><span class="line">                        GO TO <span class="number">400</span>                                        <span class="number">102.</span></span><br><span class="line">  <span class="number">500</span>             PERM(L+<span class="number">1</span>) = NBR                                        <span class="number">103.</span></span><br><span class="line">                  <span class="keyword">IF</span> ( K .LT. LNBR ) GO TO <span class="number">300</span>                           <span class="number">104.</span></span><br><span class="line">  <span class="number">600</span>    <span class="keyword">CONTINUE</span>                                                        <span class="number">105.</span></span><br></pre></td></tr></table></figure>
<p>对这一层的所有节点的相邻节点进行排序，加入到 PERM 中后，判断是否新增了节点，即 LNBR 是否大于 LVLEND ，LNBR 是此时 PERM 的长度，LVLEND 是之前 PERM 的长度。如果新增了节点，则继续循环</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">IF</span> (LNBR .GT. LVLEND) GO TO <span class="number">100</span>                                 <span class="number">106.</span></span><br></pre></td></tr></table></figure>
<p>最后我们对 PERM 向量进行翻转，K 是总数除以2取整，然后第一个数和最后一个数互换，第二个数和倒数第二个数互换，以此类推。</p>
<p>举个例子，假设 CCSIZE = 5，那么 K = 5/2=2，那么就是位置1和位置5的数互换，位置2和位置4的数互换，位置3不动。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C        -----------------------------------------------------           107.</span></span><br><span class="line"><span class="comment">C        WE NOW HAVE THE CUTHILL MCKEE ORDERING.                         108.</span></span><br><span class="line"><span class="comment">C        REVERSE IT BELOW ...                                            109.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------           110.</span></span><br><span class="line">         K = CCSIZE/<span class="number">2</span>                                                    <span class="number">111.</span></span><br><span class="line">         L = CCSIZE                                                      <span class="number">112.</span></span><br><span class="line">         <span class="keyword">DO</span> <span class="number">700</span> I = <span class="number">1</span>, K                                                 <span class="number">113.</span></span><br><span class="line">            LPERM = PERM(L)                                              <span class="number">114.</span></span><br><span class="line">            PERM(L) = PERM(I)                                            <span class="number">115.</span></span><br><span class="line">            PERM(I) = LPERM                                              <span class="number">116.</span></span><br><span class="line">            L = L - <span class="number">1</span>                                                    <span class="number">117.</span></span><br><span class="line">  <span class="number">700</span>    <span class="keyword">CONTINUE</span>                                                        <span class="number">118.</span></span><br><span class="line">         <span class="keyword">RETURN</span>                                                          <span class="number">119.</span></span><br><span class="line">      <span class="keyword">END</span>                                                                <span class="number">120.</span></span><br></pre></td></tr></table></figure>
<h1>GENRCM</h1>
<p><strong>(GENeral RCM)</strong> ，这个子程序用于找到一个<strong>不连通的图</strong>的 RCM 顺序，这个子程序会对每一个连通组分运行子程序 RCM 。这个子程序的输入为 <strong>NEQNS</strong> (the number of nodes or equations)，<strong>(XADJ, ADJNCY)</strong>。中间数据为 <strong>MASK</strong> 和 <strong>XLS</strong> ，作为中间子程序 FNROOT 和 RCM 的输入。</p>
<p>这个子程序一开始将 <strong>MASK</strong> 中的所有值均设为 1，之后对 MASK 进行循环知道其发现一个节点 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> ，其 MASK(i) = 1;  节点 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 和 <strong>MASK</strong>, <strong>(XADJ, ADJNCY)</strong> 便可以指定一个连通子图，之后调用子程序 <strong>FNROOT</strong> 和 <strong>RCM</strong> 来确定这个子图中所有节点的顺序（注意运行完 RCM 之后，所有排序号的节点其 MASK 值会设为 0）。</p>
<p>注意 <strong>NUM</strong> 指向数组 <strong>PERM</strong> 中的第一个自由的位置 (<em>first free position</em>) ，每次运行完 RCM 子程序后就会更新。<strong>GENRCM</strong> 程序中运行 RCM 中关于 <strong>PERM</strong> 的实际参数为 <strong>PERM(NUM)</strong> ，也就是说在 RCM 中的 PERM(NUM) 参数是 GENRCM 中 PERM 数据的最后 <strong>NEQNS - NUM + 1</strong> 个元素。</p>
<p>最后当一个连通组分排好序后，<strong>GENRCM</strong> 程序会查找下一个 <img src="https://math.now.sh?inline=MASK%28i%29%20%3D%201" style="display:inline-block;margin: 0;"/> 的节点，对下一个连通组分进行排序，直到终止。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">C****************************************************************          <span class="number">1.</span></span><br><span class="line">C****************************************************************          <span class="number">2.</span></span><br><span class="line">C**********    GENRCM ..... GENERAL REVERSE CUTHILL MCKEE     ***          <span class="number">3.</span></span><br><span class="line">C****************************************************************          <span class="number">4.</span></span><br><span class="line">C****************************************************************          <span class="number">5.</span></span><br><span class="line"><span class="comment">C                                                                          6.</span></span><br><span class="line"><span class="comment">C     PURPOSE - GENRCM FINDS THE REVERSE CUTHILL-MCKEE                     7.</span></span><br><span class="line"><span class="comment">C        ORDERING FOR A GENERAL GRAPH. FOR EACH CONNECTED                  8.</span></span><br><span class="line"><span class="comment">C        COMPONENT IN THE GRAPH, GENRCM OBTAINS THE ORDERING               9.</span></span><br><span class="line"><span class="comment">C        BY CALLING THE SUBROUTINE RCM.                                   10.</span></span><br><span class="line"><span class="comment">C                                                                         11.</span></span><br><span class="line"><span class="comment">C     INPUT PARAMETERS -                                                  12.</span></span><br><span class="line"><span class="comment">C        NEQNS - NUMBER OF EQUATIONS                                      13.</span></span><br><span class="line"><span class="comment">C        (XADJ, ADJNCY) - ARRAY PAIR CONTAINING THE ADJACENCY             14.</span></span><br><span class="line"><span class="comment">C               STRUCTURE OF THE GRAPH OF THE MATRIX                      15.</span></span><br><span class="line"><span class="comment">C                                                                         16.</span></span><br><span class="line"><span class="comment">C     OUTPUT PARAMETER -                                                  17.</span></span><br><span class="line"><span class="comment">C        PERM - VECTOR THAT CONTAINS THE RCM ORDERING.                    18.</span></span><br><span class="line"><span class="comment">C                                                                         19.</span></span><br><span class="line"><span class="comment">C     WORKING PARAMETERS -                                                20.</span></span><br><span class="line"><span class="comment">C        MASK - IS USED TO MARK VARIABLES THAT HAVE BEEN                  21.</span></span><br><span class="line"><span class="comment">C               NUMBERED DURING THE ORDERING PROCESS. IT IS               22.</span></span><br><span class="line"><span class="comment">C               INITIALIZED TO 1, AND SET TO ZERO AS EACH NODE            23.</span></span><br><span class="line"><span class="comment">C               IS NUMBERED.                                              24.</span></span><br><span class="line"><span class="comment">C        XLS - THE INDEX VECTOR FOR A LEVEL STRUCTURE. THE                25.</span></span><br><span class="line"><span class="comment">C               LEVEL STRUCTURE IS STORED IN THE CURRENTLY                26.</span></span><br><span class="line"><span class="comment">C               UNUSED SPACES IN THE PERMUTATION VECTOR PERM.             27.</span></span><br><span class="line"><span class="comment">C                                                                         28.</span></span><br><span class="line"><span class="comment">C     PROGRAM SUBROUTINES -                                               29.</span></span><br><span class="line"><span class="comment">C        FNROOT, RCM.                                                     30.</span></span><br><span class="line"><span class="comment">C                                                                         31.</span></span><br><span class="line">C****************************************************************         <span class="number">32.</span></span><br><span class="line"><span class="comment">C                                                                         33.</span></span><br><span class="line">      <span class="function"><span class="keyword">SUBROUTINE</span></span>  GENRCM ( NEQNS, XADJ, ADJNCY, PERM, MASK, XLS )         <span class="number">34.</span></span><br><span class="line"><span class="comment">C                                                                         35.</span></span><br><span class="line">C****************************************************************         <span class="number">36.</span></span><br><span class="line"><span class="comment">C                                                                         37.</span></span><br><span class="line">         <span class="keyword">INTEGER</span> ADJNCY(<span class="number">1</span>), MASK(<span class="number">1</span>), PERM(<span class="number">1</span>), XLS(<span class="number">1</span>)                      <span class="number">38.</span></span><br><span class="line">         <span class="keyword">INTEGER</span> XADJ(<span class="number">1</span>), CCSIZE, I, NEQNS, NLVL                          <span class="number">39.</span></span><br><span class="line">     <span class="number">1</span>           NUM, ROOT                                                <span class="number">40.</span></span><br><span class="line"><span class="comment">C                                                                         41.</span></span><br><span class="line">C****************************************************************         <span class="number">42.</span></span><br><span class="line"><span class="comment">C                                                                         43.</span></span><br><span class="line">         <span class="keyword">DO</span> <span class="number">100</span> I = <span class="number">1</span>, NEQNS                                              <span class="number">44.</span></span><br><span class="line">            MASK(I) = <span class="number">1</span>                                                   <span class="number">45.</span></span><br><span class="line">  <span class="number">100</span>    <span class="keyword">CONTINUE</span>                                                         <span class="number">46.</span></span><br><span class="line">         NUM = <span class="number">1</span>                                                          <span class="number">47.</span></span><br><span class="line">         <span class="keyword">DO</span> <span class="number">200</span> I = <span class="number">1</span>, NEQNS                                              <span class="number">48.</span></span><br><span class="line"><span class="comment">C           -----------------------------------------------------         49.</span></span><br><span class="line"><span class="comment">C           FOR EACH MASKED CONNECTED COMPONENT ...                       50.</span></span><br><span class="line"><span class="comment">C           -----------------------------------------------------         51.</span></span><br><span class="line">            <span class="keyword">IF</span> (MASK(I) .EQ. <span class="number">0</span>) GO TO <span class="number">200</span>                                 <span class="number">52.</span></span><br><span class="line">               ROOT = I                                                   <span class="number">53.</span></span><br><span class="line"><span class="comment">C              --------------------------------------------------         54.</span></span><br><span class="line"><span class="comment">C              FIRST FIND A PSEUDO-PERIPHERAL NODE ROOT.                  55.</span></span><br><span class="line"><span class="comment">C              NOTE THAT THE LEVEL STRUCTURE FOUND BY                     56.</span></span><br><span class="line"><span class="comment">C              FNROOT IS STORED STARTING AT PERM(NUM).                    57.</span></span><br><span class="line"><span class="comment">C              THEN RCM IS CALLED TO ORDER THE COMPONENT                  58.</span></span><br><span class="line"><span class="comment">C              USING ROOT AS THE STARTING NODE.                           59.</span></span><br><span class="line"><span class="comment">C              --------------------------------------------------         60.</span></span><br><span class="line">               <span class="keyword">CALL</span> FNROOT ( ROOT, XADJ, ADJNCY, MASK,                    <span class="number">61.</span></span><br><span class="line">     <span class="number">1</span>                       NLVL, XLS, PERM(NUM) )                       <span class="number">62.</span></span><br><span class="line">               <span class="keyword">CALL</span>    RCM ( ROOT, XADJ, ADJNCY, MASK,                    <span class="number">63.</span></span><br><span class="line">     <span class="number">1</span>                       PERM(NUM), CCSIZE, XLS )                     <span class="number">64.</span></span><br><span class="line">               NUM = NUM + CCSIZE                                         <span class="number">65.</span></span><br><span class="line">               <span class="keyword">IF</span> (NUM .GT. NEQNS) <span class="keyword">RETURN</span>                                 <span class="number">66.</span></span><br><span class="line">  <span class="number">200</span>    <span class="keyword">CONTINUE</span>                                                         <span class="number">67.</span></span><br><span class="line">         <span class="keyword">RETURN</span>                                                           <span class="number">68.</span></span><br><span class="line">      <span class="keyword">END</span>                                                                 <span class="number">69.</span></span><br></pre></td></tr></table></figure>
<p>下面我们开始逐行解析脚本</p>
<p>首先将 MASK 向量的元素均初始化为 1，NUM 初始设为 1</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">       <span class="keyword">DO</span> <span class="number">100</span> I = <span class="number">1</span>, NEQNS                                              <span class="number">44.</span></span><br><span class="line">          MASK(I) = <span class="number">1</span>                                                   <span class="number">45.</span></span><br><span class="line"><span class="number">100</span>    <span class="keyword">CONTINUE</span>                                                         <span class="number">46.</span></span><br><span class="line">       NUM = <span class="number">1</span>                                                          <span class="number">47.</span></span><br></pre></td></tr></table></figure>
<p>开始循环，找到第一个 MASK 值不为 0 个节点，设为 ROOT</p>
<p>然后调用 FNROOT 查找一个合适的初始节点，然后调用 RCM 算法查找合适的顺序，其中 NUM 表示 PERM 第一额可用的位置。</p>
<p>FNROOT 子程序中的 LS 向量用 PERM(NUM) 替代，RCM 子程序中的 DEG 向量用 XLS 替代，应该是出于节省内存的作用。这两个都只是中间向量，没有必要再创建两个数组。</p>
<p>调用完这两个子程序之后，已经排序的节点的 MASK 值已经设为 0 了。</p>
<p>之后对 NUM 进行更新，如果 NUM 大于 NEQNS ，说明所有节点已经排序，退出程序 (<code>RETURN</code>) ；否则继续对下一个连通组分进行排序，直至所有节点均被排序。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">         <span class="keyword">DO</span> <span class="number">200</span> I = <span class="number">1</span>, NEQNS                                              <span class="number">48.</span></span><br><span class="line"><span class="comment">C           -----------------------------------------------------         49.</span></span><br><span class="line"><span class="comment">C           FOR EACH MASKED CONNECTED COMPONENT ...                       50.</span></span><br><span class="line"><span class="comment">C           -----------------------------------------------------         51.</span></span><br><span class="line">            <span class="keyword">IF</span> (MASK(I) .EQ. <span class="number">0</span>) GO TO <span class="number">200</span>                                 <span class="number">52.</span></span><br><span class="line">               ROOT = I                                                   <span class="number">53.</span></span><br><span class="line"><span class="comment">C              --------------------------------------------------         54.</span></span><br><span class="line"><span class="comment">C              FIRST FIND A PSEUDO-PERIPHERAL NODE ROOT.                  55.</span></span><br><span class="line"><span class="comment">C              NOTE THAT THE LEVEL STRUCTURE FOUND BY                     56.</span></span><br><span class="line"><span class="comment">C              FNROOT IS STORED STARTING AT PERM(NUM).                    57.</span></span><br><span class="line"><span class="comment">C              THEN RCM IS CALLED TO ORDER THE COMPONENT                  58.</span></span><br><span class="line"><span class="comment">C              USING ROOT AS THE STARTING NODE.                           59.</span></span><br><span class="line"><span class="comment">C              --------------------------------------------------         60.</span></span><br><span class="line">               <span class="keyword">CALL</span> FNROOT ( ROOT, XADJ, ADJNCY, MASK,                    <span class="number">61.</span></span><br><span class="line">     <span class="number">1</span>                       NLVL, XLS, PERM(NUM) )                       <span class="number">62.</span></span><br><span class="line">               <span class="keyword">CALL</span>    RCM ( ROOT, XADJ, ADJNCY, MASK,                    <span class="number">63.</span></span><br><span class="line">     <span class="number">1</span>                       PERM(NUM), CCSIZE, XLS )                     <span class="number">64.</span></span><br><span class="line">               NUM = NUM + CCSIZE                                         <span class="number">65.</span></span><br><span class="line">               <span class="keyword">IF</span> (NUM .GT. NEQNS) <span class="keyword">RETURN</span>                                 <span class="number">66.</span></span><br><span class="line">  <span class="number">200</span>    <span class="keyword">CONTINUE</span>                                                         <span class="number">67.</span></span><br><span class="line">         <span class="keyword">RETURN</span>                                                           <span class="number">68.</span></span><br><span class="line">      <span class="keyword">END</span>                                                                 <span class="number">69.</span></span><br></pre></td></tr></table></figure>
<h1>参考文献</h1>
<ol>
<li>George A, Liu J, Ng E. Computer solution of sparse linear systems[J]. Oak Ridge National Laboratory, 1994.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>稀疏矩阵</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>稀疏矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏矩阵算法RCM算法二之查找初始位点程序</title>
    <url>/posts/7fa16310/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本章节是介绍 George and Liu 书中 RCM 算法脚本的第二篇，介绍查找初始节点的算法。</p>
<span id="more"></span>
<h1>ROOTLS</h1>
<p>(<strong>ROOTed Level Structure</strong>) 这个子程序的目的是产生一个<strong>连通组分</strong>的 <em>level structure</em> 。</p>
<p>其输入参数为 <strong>ROOT</strong>, <strong>MASK</strong>, <strong>XADJ</strong>, <strong>ADJNCY</strong>。<strong>(XADJ, ADJNCY)</strong> 为整个图的相邻结构，  <strong>MASK</strong> 和  <strong>ROOT</strong> 指定了连通子图，MASK(i)=0 的节点会直接忽略，ROOT 为起始节点。</p>
<p>其输出的以<strong>ROOT</strong>为根的  <em>level structure</em> ，保存在数组对 <strong>(XLS, LS)</strong> 中，其第 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 层的节点为 <img src="https://math.now.sh?inline=LS%28j%29%2C%20XLS(k)%20%5Cleq%20j%20%3C%20XLS(k%2B1)" style="display:inline-block;margin: 0;"/> 。总层数存储在 <strong>NLVL</strong> 。</p>
<p>注意由于 Fortran 是 1-index ，因此算法中 0 水平在代码中是 1，因此这里的 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 其实是上面算法里的 <img src="https://math.now.sh?inline=k-1" style="display:inline-block;margin: 0;"/> 层 <img src="https://math.now.sh?inline=L_%7Bk-1%7D" style="display:inline-block;margin: 0;"/> ，而 <img src="https://math.now.sh?inline=NLVL%20%3D%20%5Cell%28x%29%20%2B%201" style="display:inline-block;margin: 0;"/> 。</p>
<p>这个子程序会逐层查找节点，所有找到的节点会存储在数组 <strong>LS</strong> 中，然后其相应的 <strong>MASK</strong> 的值设置为 0 ，因此这些节点不会再出现在 <strong>LS</strong> 中。当所有的水平都找完，MASK 中所有 level structure 中的节点的值会重新设置为 1 。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">C****************************************************************          <span class="number">1.</span></span><br><span class="line">C****************************************************************          <span class="number">2.</span></span><br><span class="line">C**********    ROOTLS ..... ROOTED LEVEL STRUCTURE            ***          <span class="number">3.</span></span><br><span class="line">C****************************************************************          <span class="number">4.</span></span><br><span class="line">C****************************************************************          <span class="number">5.</span></span><br><span class="line"><span class="comment">C                                                                          6.</span></span><br><span class="line"><span class="comment">C     PURPOSE - ROOTLS GENERATES THE LEVEL STRUCTURE ROOTED                7.</span></span><br><span class="line"><span class="comment">C        AT THE INPUT NODE CALLED ROOT. ONLY THOSE NODES FOR               8.</span></span><br><span class="line"><span class="comment">C        WHICH MASK IS NONZERO WILL BE CONSIDERED.                         9.</span></span><br><span class="line"><span class="comment">C                                                                         10.</span></span><br><span class="line"><span class="comment">C    INPUT PARAMETERS -                                                   11.</span></span><br><span class="line"><span class="comment">C        ROOT - THE NODE AT WHICH THE LEVEL STRUCTURE IS TO               12.</span></span><br><span class="line"><span class="comment">C               BE ROOTED.                                                13.</span></span><br><span class="line"><span class="comment">C        (XADJ, ADJNCY) - ADJACENCY STRUCTURE PAIR FOR THE                14.</span></span><br><span class="line"><span class="comment">C                         GIVEN GRAPH.                                    15.</span></span><br><span class="line"><span class="comment">C        MASK - IS USED TO SPECIFY A SECTION SUBGRAPH. NODES              16.</span></span><br><span class="line"><span class="comment">C               WITH MASK(I)=0 ARE IGNORED                                17.</span></span><br><span class="line"><span class="comment">C                                                                         18.</span></span><br><span class="line"><span class="comment">C     OUTPUT PARAMETERS -                                                 19.</span></span><br><span class="line"><span class="comment">C        NLVL - IS THE NUMBER OF LEVELS IN THE LEVEL STRUCTURE.           20.</span></span><br><span class="line"><span class="comment">C        (XLS, LS) - ARRAY PAIR FOR THE ROOTED LEVEL STRUCTURE.           21.</span></span><br><span class="line"><span class="comment">C                                                                         22.</span></span><br><span class="line">C****************************************************************         <span class="number">23.</span></span><br><span class="line"><span class="comment">C                                                                         24.</span></span><br><span class="line">      <span class="function"><span class="keyword">SUBROUTINE</span></span>  ROOTLS ( ROOT, XADJ, ADJNCY, MASK, NLVL, XLS, LS )      <span class="number">25.</span></span><br><span class="line"><span class="comment">C                                                                         26.</span></span><br><span class="line">C****************************************************************         <span class="number">27.</span></span><br><span class="line"><span class="comment">C                                                                         28.</span></span><br><span class="line">         <span class="keyword">INTEGER</span> ADJNCY(<span class="number">1</span>), LS(<span class="number">1</span>), MASK(<span class="number">1</span>), XLS(<span class="number">1</span>)                        <span class="number">29.</span></span><br><span class="line">         <span class="keyword">INTEGER</span> XADJ(<span class="number">1</span>), I, J, JSTOP, JSTRT, LBEGIN,                     <span class="number">30.</span></span><br><span class="line">     <span class="number">1</span>           CCSIZE, LVLEND, LVSIZE, NBR, NLVL,                       <span class="number">31.</span></span><br><span class="line">     <span class="number">1</span>           NODE, ROOT                                               <span class="number">32.</span></span><br><span class="line"><span class="comment">C                                                                         33.</span></span><br><span class="line">C****************************************************************         <span class="number">34.</span></span><br><span class="line"><span class="comment">C                                                                         35.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            36.</span></span><br><span class="line"><span class="comment">C        INITIALIZATION ...                                               37.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            38.</span></span><br><span class="line">         MASK(ROOT) = <span class="number">0</span>                                                   <span class="number">39.</span></span><br><span class="line">         LS(<span class="number">1</span>) = ROOT                                                     <span class="number">40.</span></span><br><span class="line">         NLVL = <span class="number">0</span>                                                         <span class="number">41.</span></span><br><span class="line">         LVLEND = <span class="number">0</span>                                                       <span class="number">42.</span></span><br><span class="line">         CCSIZE = <span class="number">1</span>                                                       <span class="number">43.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            44.</span></span><br><span class="line"><span class="comment">C        LBEGIN IS THE POINTER TO THE BEGINNING OF THE CURRENT            45.</span></span><br><span class="line"><span class="comment">C        LEVEL, AND LVLEND POINTS TO THE END OF THIS LEVEL.               46.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            47.</span></span><br><span class="line">  <span class="number">200</span>    LBEGIN = LVLEND + <span class="number">1</span>                                              <span class="number">48.</span></span><br><span class="line">         LVLEND = CCSIZE                                                  <span class="number">49.</span></span><br><span class="line">         NLVL = NLVL + <span class="number">1</span>                                                  <span class="number">50.</span></span><br><span class="line">         XLS(NLVL) = LBEGIN                                               <span class="number">51.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            52.</span></span><br><span class="line"><span class="comment">C        GENERATE THE NEXT LEVEL BY FINDING ALL THE MASKED                53.</span></span><br><span class="line"><span class="comment">C        NEIGHBORS OF NODES IN THE CURRENT LEVEL.                         54.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            55.</span></span><br><span class="line">         <span class="keyword">DO</span> <span class="number">400</span> I = LBEGIN, LVLEND                                        <span class="number">56.</span></span><br><span class="line">            NODE = LS(I)                                                  <span class="number">57.</span></span><br><span class="line">            JSTRT = XADJ(NODE)                                            <span class="number">58.</span></span><br><span class="line">            JSTOP = XADJ(NODE+<span class="number">1</span>) - <span class="number">1</span>                                      <span class="number">59.</span></span><br><span class="line">            <span class="keyword">IF</span> (JSTOP .LT. JSTRT) GO TO <span class="number">400</span>                               <span class="number">60.</span></span><br><span class="line">               <span class="keyword">DO</span> <span class="number">300</span> J = JSTRT, JSTOP                                    <span class="number">61.</span></span><br><span class="line">                  NBR = ADJNCY(J)                                         <span class="number">62.</span></span><br><span class="line">                  <span class="keyword">IF</span> (MASK(NBR) .EQ. <span class="number">0</span>) GO TO <span class="number">300</span>                         <span class="number">63.</span></span><br><span class="line">                     CCSIZE = CCSIZE + <span class="number">1</span>                                  <span class="number">64.</span></span><br><span class="line">                     LS(CCSIZE) = NBR                                     <span class="number">65.</span></span><br><span class="line">                     MASK(NBR) = <span class="number">0</span>                                        <span class="number">66.</span></span><br><span class="line">  <span class="number">300</span>          <span class="keyword">CONTINUE</span>                                                   <span class="number">67.</span></span><br><span class="line">  <span class="number">400</span>    <span class="keyword">CONTINUE</span>                                                         <span class="number">68.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            69.</span></span><br><span class="line"><span class="comment">C        COMPUTE THE CURRENT WIDTH.                                       70.</span></span><br><span class="line"><span class="comment">C        IF IT IS NONZERO, GENERATE THE NEXT LEVEL.                       71.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            72.</span></span><br><span class="line">         LVSIZE = CCSIZE - LVLEND                                         <span class="number">73.</span></span><br><span class="line">         <span class="keyword">IF</span> (LVSIZE .GT. <span class="number">0</span>) GO TO <span class="number">200</span>                                     <span class="number">74.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            75.</span></span><br><span class="line"><span class="comment">C        RESET MASK TO ONE FOR THE NODES IN THE LEVEL STRUCTURE.          76.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            77.</span></span><br><span class="line">         XLS(NLVL+<span class="number">1</span>) = LVLEND + <span class="number">1</span>                                         <span class="number">78.</span></span><br><span class="line">         <span class="keyword">DO</span> <span class="number">500</span> I = <span class="number">1</span>, CCSIZE                                             <span class="number">79.</span></span><br><span class="line">            NODE = LS(I)                                                  <span class="number">80.</span></span><br><span class="line">            MASK(NODE) = <span class="number">1</span>                                                <span class="number">81.</span></span><br><span class="line">  <span class="number">500</span>    <span class="keyword">CONTINUE</span>                                                         <span class="number">82.</span></span><br><span class="line">         <span class="keyword">RETURN</span>                                                           <span class="number">83.</span></span><br><span class="line">      <span class="keyword">END</span>                                                                 <span class="number">84.</span></span><br></pre></td></tr></table></figure>
<p>下面逐行进行解析，根据注释，首先是一个初始化过程，第一层就是 ROOT 节点本身，加入到 LS 中，并将其 MASK 值设为0。总层数 NLVL 初始化为 0，LVLEND 设为0 (这个变量的含义下面会提到)，CCSIZE 设为 1 (CCSIZE 为当前 LS 向量的长度)</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C        -----------------------------------------------------            36.</span></span><br><span class="line"><span class="comment">C        INITIALIZATION ...                                               37.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            38.</span></span><br><span class="line">         MASK(ROOT) = <span class="number">0</span>                                                   <span class="number">39.</span></span><br><span class="line">         LS(<span class="number">1</span>) = ROOT                                                     <span class="number">40.</span></span><br><span class="line">         NLVL = <span class="number">0</span>                                                         <span class="number">41.</span></span><br><span class="line">         LVLEND = <span class="number">0</span>                                                       <span class="number">42.</span></span><br><span class="line">         CCSIZE = <span class="number">1</span>                                                       <span class="number">43.</span></span><br></pre></td></tr></table></figure>
<p>下一步，我们获得当前层次在 LS 的初始位置 LBEGIN 和结束位置 LVLEND，由于第一层只有 ROOT 这个节点，因此目前 LBEGIN =  LVLEND = 1。总层数 NLVL 加一，将本层次的初始位置加入到 XLS 中。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C        -----------------------------------------------------            44.</span></span><br><span class="line"><span class="comment">C        LBEGIN IS THE POINTER TO THE BEGINNING OF THE CURRENT            45.</span></span><br><span class="line"><span class="comment">C        LEVEL, AND LVLEND POINTS TO THE END OF THIS LEVEL.               46.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            47.</span></span><br><span class="line">  <span class="number">200</span>    LBEGIN = LVLEND + <span class="number">1</span>                                              <span class="number">48.</span></span><br><span class="line">         LVLEND = CCSIZE                                                  <span class="number">49.</span></span><br><span class="line">         NLVL = NLVL + <span class="number">1</span>                                                  <span class="number">50.</span></span><br><span class="line">         XLS(NLVL) = LBEGIN                                               <span class="number">51.</span></span><br></pre></td></tr></table></figure>
<p>对本层次的所有节点逐一查找相邻节点，其中如果某一个节点的相邻节点数目为 0 ，那么存在  <code>JSTOP &lt; JSTRT</code> ，此时直接跳过这个节点（<code>GO TO 400</code>）。</p>
<p>对于下一层的向量节点，其必须满足 MASK 值不为 0 的条件，这样做有两个作用，一是找到的节点是我们需要的连通组分内的节点，二是避免 LS 向量中出现重复节点。对于满足 MASK 值不为 0 的相邻节点，CCSIZE 加1，将其加入到 LS 向量中，其 MASK 值设为 0。</p>
<p>因此，运行完这一步之后，LS 向量中加入了下一层次的节点，其长度 CCSIZE 同样更新为当前 LS 向量的长度。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C        -----------------------------------------------------            52.</span></span><br><span class="line"><span class="comment">C        GENERATE THE NEXT LEVEL BY FINDING ALL THE MASKED                53.</span></span><br><span class="line"><span class="comment">C        NEIGHBORS OF NODES IN THE CURRENT LEVEL.                         54.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            55.</span></span><br><span class="line">         <span class="keyword">DO</span> <span class="number">400</span> I = LBEGIN, LVLEND                                        <span class="number">56.</span></span><br><span class="line">            NODE = LS(I)                                                  <span class="number">57.</span></span><br><span class="line">            JSTRT = XADJ(NODE)                                            <span class="number">58.</span></span><br><span class="line">            JSTOP = XADJ(NODE+<span class="number">1</span>) - <span class="number">1</span>                                      <span class="number">59.</span></span><br><span class="line">            <span class="keyword">IF</span> (JSTOP .LT. JSTRT) GO TO <span class="number">400</span>                               <span class="number">60.</span></span><br><span class="line">               <span class="keyword">DO</span> <span class="number">300</span> J = JSTRT, JSTOP                                    <span class="number">61.</span></span><br><span class="line">                  NBR = ADJNCY(J)                                         <span class="number">62.</span></span><br><span class="line">                  <span class="keyword">IF</span> (MASK(NBR) .EQ. <span class="number">0</span>) GO TO <span class="number">300</span>                         <span class="number">63.</span></span><br><span class="line">                     CCSIZE = CCSIZE + <span class="number">1</span>                                  <span class="number">64.</span></span><br><span class="line">                     LS(CCSIZE) = NBR                                     <span class="number">65.</span></span><br><span class="line">                     MASK(NBR) = <span class="number">0</span>                                        <span class="number">66.</span></span><br><span class="line">  <span class="number">300</span>          <span class="keyword">CONTINUE</span>                                                   <span class="number">67.</span></span><br><span class="line">  <span class="number">400</span>    <span class="keyword">CONTINUE</span>                                                         <span class="number">68.</span></span><br></pre></td></tr></table></figure>
<p>下面我们查看添加的节点数目是否为 0，如果为 0，那就说明找到头了；不为0，则 <code>GO TO 200</code> ，接着循环，查找下一层次的节点。</p>
<p>这里 LVLEND 是上一次循环中 LS 向量的长度，CCSIZE 是当前 LS 向量的长度，二者一相减就是本次循环新增的节点数目。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C        -----------------------------------------------------            69.</span></span><br><span class="line"><span class="comment">C        COMPUTE THE CURRENT WIDTH.                                       70.</span></span><br><span class="line"><span class="comment">C        IF IT IS NONZERO, GENERATE THE NEXT LEVEL.                       71.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            72.</span></span><br><span class="line">         LVSIZE = CCSIZE - LVLEND                                         <span class="number">73.</span></span><br><span class="line">         <span class="keyword">IF</span> (LVSIZE .GT. <span class="number">0</span>) GO TO <span class="number">200</span>                                     <span class="number">74.</span></span><br></pre></td></tr></table></figure>
<p>因此，当循环结束后，我们就找到了 <em>level structure</em>  中的所有节点，因此此时 LS 向量就是最终的 LS 向量。</p>
<p>但是 XLS 向量还缺少一个元素，就是 LS 长度 + 1，即下面的 LVLEND + 1 (此时 LVLEND = CCSIZE, 也是 LS 向量长度)。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C        -----------------------------------------------------            75.</span></span><br><span class="line"><span class="comment">C        RESET MASK TO ONE FOR THE NODES IN THE LEVEL STRUCTURE.          76.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            77.</span></span><br><span class="line">         XLS(NLVL+<span class="number">1</span>) = LVLEND + <span class="number">1</span>                                         <span class="number">78.</span></span><br></pre></td></tr></table></figure>
<p>最后，我们将  LS 向量中的所有节点的 MASK 重新设为 1，也就是说 “还原” MASK 向量。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">       <span class="keyword">DO</span> <span class="number">500</span> I = <span class="number">1</span>, CCSIZE                                             <span class="number">79.</span></span><br><span class="line">          NODE = LS(I)                                                  <span class="number">80.</span></span><br><span class="line">          MASK(NODE) = <span class="number">1</span>                                                <span class="number">81.</span></span><br><span class="line"><span class="number">500</span>    <span class="keyword">CONTINUE</span>                                                         <span class="number">82.</span></span><br><span class="line">       <span class="keyword">RETURN</span>                                                           <span class="number">83.</span></span><br><span class="line">    <span class="keyword">END</span>                                                                 <span class="number">84.</span></span><br></pre></td></tr></table></figure>
<h1>FNROOT</h1>
<p><strong>(FiNd ROOT)</strong> 这个子程序用于查找一个<strong>连通组分</strong>的 <em>pseudo-peripheral node</em> 。</p>
<p>其输入与上一个子程序相同，首先调用 ROOTLS 这个子程序，如果这个连通组分只有 ROOT 这一个节点或者只包含以 ROOT 为终点的一条链，那么 ROOT 就是要找的  <em>pseudo-peripheral node</em> ， LS 就是其相应的 rooted level structure ，程序终止 。</p>
<p>否则，程序会找到最后一个水平的度数最小的一个节点，针对这个节点生成其相应的新的 level structure ，我们会检查是否 <img src="https://math.now.sh?inline=%5Cell%28x%29%20%3E%20%5Cell(r)" style="display:inline-block;margin: 0;"/> ，如果不满足则程序终止，否则则重复上述流程。</p>
<p>当程序终止的时候，ROOT 就是我们想要找的 <em>pseudo-peripheral node</em> ，而数组对 (XLS, LS) 包含了相应的 rooted level structure 。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">C****************************************************************          <span class="number">1.</span></span><br><span class="line">C****************************************************************          <span class="number">2.</span></span><br><span class="line">C**********    FNROOT ..... FIND PSEUDO-PERIPHERAL NODE       ***          <span class="number">3.</span></span><br><span class="line">C****************************************************************          <span class="number">4.</span></span><br><span class="line">C****************************************************************          <span class="number">5.</span></span><br><span class="line"><span class="comment">C                                                                          6.</span></span><br><span class="line"><span class="comment">C     PURPOSE - FNROOT IMPLEMENTS A MODIFIED VERSION OF THE                7.</span></span><br><span class="line"><span class="comment">C        SCHEME BY GIBBS, POOLE, AND STOCKMEYER TO FIND PSEUDO-            8.</span></span><br><span class="line"><span class="comment">C        PERIPHERAL NODES. IT DETERMINES SUCH A NODE FOR THE               9.</span></span><br><span class="line"><span class="comment">C        SECTION SUBGRAPH SPECIFIED BY MASK AND ROOT                      10.</span></span><br><span class="line"><span class="comment">C                                                                         11.</span></span><br><span class="line"><span class="comment">C    INPUT PARAMETERS -                                                   12.</span></span><br><span class="line"><span class="comment">C        (XADJ, ADJNCY) - ADJACENCY STRUCTURE PAIR FOR THE GRAPH.         13.</span></span><br><span class="line"><span class="comment">C        MASK - SPECIFIES A SECTION SUBGRAPH. NODES FOR WHICH             14.</span></span><br><span class="line"><span class="comment">C               MASK IS ZERO ARE IGNORED BY FNROOT.                       15.</span></span><br><span class="line"><span class="comment">C                                                                         16.</span></span><br><span class="line"><span class="comment">C     UPDATED PARAMETERS -                                                17.</span></span><br><span class="line"><span class="comment">C        ROOT - ON INPUT, IT (ALONG WITH MASK) DEFINES THE                18.</span></span><br><span class="line"><span class="comment">C               COMPONENT FOR WHICH A PSEUDO-PERIPHERAL NODE IS           19.</span></span><br><span class="line"><span class="comment">C               TO BE FOUND. ON OUTPUT, IT IS THE NODE OBTAINED           20.</span></span><br><span class="line"><span class="comment">C                                                                         21.</span></span><br><span class="line"><span class="comment">C     OUTPUT PARAMETERS -                                                 22.</span></span><br><span class="line"><span class="comment">C        NLVL - IS THE NUMBER OF LEVELS IN THE LEVEL STRUCTURE            23.</span></span><br><span class="line"><span class="comment">C               ROOTED AT THE NODE ROOT.                                  24.</span></span><br><span class="line"><span class="comment">C        (XLS, LS) - THE LEVEL STRUCTURE ARRAY PAIR CONTAINING            25.</span></span><br><span class="line"><span class="comment">C                    THE LEVEL STRUCTURE FOUND.                           26.</span></span><br><span class="line"><span class="comment">C                                                                         27.</span></span><br><span class="line"><span class="comment">C     PROGRAM SUBROUTINES -                                               28.</span></span><br><span class="line"><span class="comment">C        ROOTLS.                                                          29.</span></span><br><span class="line"><span class="comment">C                                                                         30.</span></span><br><span class="line">C****************************************************************         <span class="number">31.</span></span><br><span class="line"><span class="comment">C                                                                         32.</span></span><br><span class="line">      <span class="function"><span class="keyword">SUBROUTINE</span></span>  FNROOT ( ROOT, XADJ, ADJNCY, MASK, NLVL, XLS, LS )      <span class="number">33.</span></span><br><span class="line"><span class="comment">C                                                                         34.</span></span><br><span class="line">C****************************************************************         <span class="number">35.</span></span><br><span class="line"><span class="comment">C                                                                         36.</span></span><br><span class="line">         <span class="keyword">INTEGER</span> ADJNCY(<span class="number">1</span>), LS(<span class="number">1</span>), MASK(<span class="number">1</span>), XLS(<span class="number">1</span>)                        <span class="number">37.</span></span><br><span class="line">         <span class="keyword">INTEGER</span> XADJ(<span class="number">1</span>), CCSIZE, J, JSTRT, K, KSTOP, KSTRT,              <span class="number">38.</span></span><br><span class="line">     <span class="number">1</span>           MINDEG, NABOR, NDEG, NLVL,NODE, NUNLVL,                  <span class="number">39.</span></span><br><span class="line">     <span class="number">1</span>           ROOT                                                     <span class="number">40.</span></span><br><span class="line"><span class="comment">C                                                                         41.</span></span><br><span class="line">C****************************************************************         <span class="number">42.</span></span><br><span class="line"><span class="comment">C                                                                         43.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            44.</span></span><br><span class="line"><span class="comment">C        DETERMINE THE LEVEL STRUCTURE ROOTED AT ROOT.                    45.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            46.</span></span><br><span class="line">         <span class="keyword">CALL</span> ROOTLS( ROOT, XADJ, ADJNCY, MASK, NLVL, XLS, LS )           <span class="number">47.</span></span><br><span class="line">         CCSIZE = XLS(NLVL+<span class="number">1</span>) - <span class="number">1</span>                                         <span class="number">48.</span></span><br><span class="line">         <span class="keyword">IF</span> ( NLVL.EQ. <span class="number">1</span> .OR. NLVL .EQ. CCSIZE ) <span class="keyword">RETURN</span>                   <span class="number">49.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            50.</span></span><br><span class="line"><span class="comment">C        PICK A NODE WITH MINIMUM DEGREE FROM THE LAST LEVEL.             51.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            52.</span></span><br><span class="line">  <span class="number">100</span>    JSTRT = XLS(NLVL)                                                <span class="number">53.</span></span><br><span class="line">         MINDEG = CCSIZE                                                  <span class="number">54.</span></span><br><span class="line">         ROOT = LS(JSTRT)                                                 <span class="number">55.</span></span><br><span class="line">         <span class="keyword">IF</span> ( CCSIZE .EQ. JSTRT) GO TO <span class="number">400</span>                                <span class="number">56.</span></span><br><span class="line">            <span class="keyword">DO</span> <span class="number">300</span> J = JSTRT, CCSIZE                                      <span class="number">57.</span></span><br><span class="line">               NODE = LS(J)                                               <span class="number">58.</span></span><br><span class="line">               NDEG = <span class="number">0</span>                                                   <span class="number">59.</span></span><br><span class="line">               KSTRT = XADJ(NODE)                                         <span class="number">60.</span></span><br><span class="line">               KSTOP = XADJ(NODE+<span class="number">1</span>) - <span class="number">1</span>                                   <span class="number">61.</span></span><br><span class="line">               <span class="keyword">DO</span> <span class="number">200</span> K = KSTRT, KSTOP                                    <span class="number">62.</span></span><br><span class="line">                  NABOR = ADJNCY(K)                                       <span class="number">63.</span></span><br><span class="line">                  <span class="keyword">IF</span> ( MASK(NABOR) .GT. <span class="number">0</span> ) NDEG = NDEG + <span class="number">1</span>               <span class="number">64.</span></span><br><span class="line">  <span class="number">200</span>          <span class="keyword">CONTINUE</span>                                                   <span class="number">65.</span></span><br><span class="line">               <span class="keyword">IF</span> ( NDEG .GE. MINDEG ) GO TO <span class="number">300</span>                          <span class="number">66.</span></span><br><span class="line">                  ROOT = NODE                                             <span class="number">67.</span></span><br><span class="line">                  MINDEG = NDEG                                           <span class="number">68.</span></span><br><span class="line">  <span class="number">300</span>       <span class="keyword">CONTINUE</span>                                                      <span class="number">69.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            70.</span></span><br><span class="line"><span class="comment">C        AND GENERATE ITS ROOTED LEVEL STRUCTURE                          71.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            72.</span></span><br><span class="line">  <span class="number">400</span>    <span class="keyword">CALL</span> ROOTLS( ROOT, XADJ, ADJNCY, MASK, NUNLVL, XLS, LS )         <span class="number">73.</span></span><br><span class="line">         <span class="keyword">IF</span> (NUNLVL .LE. NLVL) <span class="keyword">RETURN</span>                                     <span class="number">74.</span></span><br><span class="line">            NLVL = NUNLVL                                                 <span class="number">75.</span></span><br><span class="line">            <span class="keyword">IF</span> ( NLVL .LT. CCSIZE ) GO TO <span class="number">100</span>                             <span class="number">76.</span></span><br><span class="line">            <span class="keyword">RETURN</span>                                                        <span class="number">77.</span></span><br><span class="line">      <span class="keyword">END</span>                                                                 <span class="number">78.</span></span><br></pre></td></tr></table></figure>
<p>下面我们进行逐句解析</p>
<p>第一步，调用 ROOTLS 找到 ROOT 的 level structure，然后同样将 CCSIZE 设为 level structure 中节点数目。注意，由于我们是在一个<strong>连通组分</strong>中查找节点，因此所有可用的节点互相都是连通的，CCSIZE 就是这个连通组分的所有节点的数目，是一个固定值，也是所有可能的节点集合的节点数目的<strong>最大值</strong>。</p>
<p>然后我们做一个判断，如果总层数为1，或者总层数等于总节点数，则直接退出程序，输入节点 ROOT 就是我们要找的节点。总节点数为1，说明<strong>连通组分</strong>中只有 ROOT 这一个节点；总层数等于总节点数，说明每一层只有一个节点，也就是连通组分中只有一条链，而 ROOT 是这条链的一个起点/终点。因此，这两种情况下，输入节点 ROOT 就是我们要找的节点。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C        -----------------------------------------------------            44.</span></span><br><span class="line"><span class="comment">C        DETERMINE THE LEVEL STRUCTURE ROOTED AT ROOT.                    45.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            46.</span></span><br><span class="line">         <span class="keyword">CALL</span> ROOTLS( ROOT, XADJ, ADJNCY, MASK, NLVL, XLS, LS )           <span class="number">47.</span></span><br><span class="line">         CCSIZE = XLS(NLVL+<span class="number">1</span>) - <span class="number">1</span>                                         <span class="number">48.</span></span><br><span class="line">         <span class="keyword">IF</span> ( NLVL.EQ. <span class="number">1</span> .OR. NLVL .EQ. CCSIZE ) <span class="keyword">RETURN</span>                   <span class="number">49.</span></span><br></pre></td></tr></table></figure>
<p>如果不是上面的两种特殊情况，那么我们接着往下走。</p>
<p>下面这一段脚本的意思，就是从 ROOT 的 level structure 的最后一层中，找到一个度数最小的节点，然后覆盖 ROOT 。</p>
<p>JSTRT 是最后一层的初始节点位置。采用一个中间变量 MINDEG，存储最小的度数，其初始值设置为可能的最大值 CCSIZE 。ROOT 首先设为最后一层的第一个节点。</p>
<p>如果 CCSIZE 等于 JSTRT ，那就说明最后一层只有一个节点，此时 ROOT 就是我们要找的节点，直接 <code>GO TO 400</code> ，跳过下面这一段。</p>
<p>不然地话，采用 <code>DO 300</code> 循环便利最后一层的所有节点，对于每一个节点采用 <code>DO 200</code> 循环计算该节点的度数，存储在 NDEG 中。</p>
<p>如果 NDEG 小于  MINDEG ，则将 ROOT 赋值为 NOTE ，MINDEG 赋值为 NDEG 。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C        -----------------------------------------------------            50.</span></span><br><span class="line"><span class="comment">C        PICK A NODE WITH MINIMUM DEGREE FROM THE LAST LEVEL.             51.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            52.</span></span><br><span class="line">  <span class="number">100</span>    JSTRT = XLS(NLVL)                                                <span class="number">53.</span></span><br><span class="line">         MINDEG = CCSIZE                                                  <span class="number">54.</span></span><br><span class="line">         ROOT = LS(JSTRT)                                                 <span class="number">55.</span></span><br><span class="line">         <span class="keyword">IF</span> ( CCSIZE .EQ. JSTRT) GO TO <span class="number">400</span>                                <span class="number">56.</span></span><br><span class="line">            <span class="keyword">DO</span> <span class="number">300</span> J = JSTRT, CCSIZE                                      <span class="number">57.</span></span><br><span class="line">               NODE = LS(J)                                               <span class="number">58.</span></span><br><span class="line">               NDEG = <span class="number">0</span>                                                   <span class="number">59.</span></span><br><span class="line">               KSTRT = XADJ(NODE)                                         <span class="number">60.</span></span><br><span class="line">               KSTOP = XADJ(NODE+<span class="number">1</span>) - <span class="number">1</span>                                   <span class="number">61.</span></span><br><span class="line">               <span class="keyword">DO</span> <span class="number">200</span> K = KSTRT, KSTOP                                    <span class="number">62.</span></span><br><span class="line">                  NABOR = ADJNCY(K)                                       <span class="number">63.</span></span><br><span class="line">                  <span class="keyword">IF</span> ( MASK(NABOR) .GT. <span class="number">0</span> ) NDEG = NDEG + <span class="number">1</span>               <span class="number">64.</span></span><br><span class="line">  <span class="number">200</span>          <span class="keyword">CONTINUE</span>                                                   <span class="number">65.</span></span><br><span class="line">               <span class="keyword">IF</span> ( NDEG .GE. MINDEG ) GO TO <span class="number">300</span>                          <span class="number">66.</span></span><br><span class="line">                  ROOT = NODE                                             <span class="number">67.</span></span><br><span class="line">                  MINDEG = NDEG                                           <span class="number">68.</span></span><br><span class="line">  <span class="number">300</span>       <span class="keyword">CONTINUE</span>                                                      <span class="number">69.</span></span><br></pre></td></tr></table></figure>
<p>下面，我们对找到的最后一层度数最小的节点 ROOT ，再运行一遍 ROOTLS 子程序，唯一区别是总层数存储在变量 NUNLVL 中。</p>
<p>首先 NUNLVL 不可能小于 NLVL ，因为按照 level structure 的结构，NLVL - 1 就是初始节点到最后一层节点的<strong>最短</strong>路径长度， 因此反过来从最后一层的最小度数节点出发，其 level structure 的最后一层如果包含了初始节点，那么 NUNLVL = NLVL ；如果不包含初始节点，那么 NUNLVL &gt; NLVL ，因此不存在 NUNLVL  &lt; NLVL 的可能。</p>
<p>因此这里的 <code>IF (NUNLVL .LE. NLVL) RETURN</code> 等价于<code>IF (NUNLVL .EQ. NLVL) RETURN</code>，也就是说如果 NUNLVL 等于 NLVL ，子程序终止 (<code>RETURN</code>) 。</p>
<p>否则的话，将 NUNLVL 的值赋值给 NLVL，判断  NLVL 是否小于 CCSIZE ，如果 NLVL小于 CCSIZE， <code>GOTO 100</code>，重新进入循环；如果  NLVL等于 CCSIZE (不可能大于)，那么说明总层数等于总位点数，说明连通组分中只有这一条链，而 ROOT 是这条链的起点/终点，此时 ROOT 就是要找的结果，程序终止。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">C        -----------------------------------------------------            70.</span></span><br><span class="line"><span class="comment">C        AND GENERATE ITS ROOTED LEVEL STRUCTURE                          71.</span></span><br><span class="line"><span class="comment">C        -----------------------------------------------------            72.</span></span><br><span class="line">  <span class="number">400</span>    <span class="keyword">CALL</span> ROOTLS( ROOT, XADJ, ADJNCY, MASK, NUNLVL, XLS, LS )         <span class="number">73.</span></span><br><span class="line">         <span class="keyword">IF</span> (NUNLVL .LE. NLVL) <span class="keyword">RETURN</span>                                     <span class="number">74.</span></span><br><span class="line">            NLVL = NUNLVL                                                 <span class="number">75.</span></span><br><span class="line">            <span class="keyword">IF</span> ( NLVL .LT. CCSIZE ) GO TO <span class="number">100</span>                             <span class="number">76.</span></span><br><span class="line">            <span class="keyword">RETURN</span>                                                        <span class="number">77.</span></span><br><span class="line">      <span class="keyword">END</span>                                                                 <span class="number">78.</span></span><br></pre></td></tr></table></figure>
<h1>参考文献</h1>
<ol>
<li>George A, Liu J, Ng E. Computer solution of sparse linear systems[J]. Oak Ridge National Laboratory, 1994.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>稀疏矩阵</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>稀疏矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏矩阵算法RCM算法一之理论基础</title>
    <url>/posts/4339589f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本章节是介绍 George and Liu 书中 RCM 算法脚本的第一篇。</p>
<span id="more"></span>
<h1>RCM理论简介</h1>
<p>The Reverse Cuthill-McKee Algorithm，简称 RCM 算法，是对于稀疏矩阵进行排序的算法，其目的是希望将所有非零元素聚集在对角线附近，这样之后进行 Cholesky 分解得到的 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 矩阵也会有类似性质</p>
<p>其对于一个<strong>连通图</strong>的步骤如下：</p>
<p><img src="18.png" alt="18"></p>
<p>如果 <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D%5E%7B%5Cmathbf%7BA%7D%7D" style="display:inline-block;margin: 0;"/> 是不连通的，我们可以对其每一个连通组分采用上面的算法。对于一个给定的起始节点，这个算法很简单。举例见下图，假设我们将节点 “g” 选为起始节点，即 <img src="https://math.now.sh?inline=x_%7B1%7D%20%3D%20g" style="display:inline-block;margin: 0;"/> 。</p>
<p><img src="19.png" alt="1"></p>
<p>下图说明了算法第二步中所有节点是如何排序的</p>
<p><img src="20.png" alt="1"></p>
<p>下图说明了第三步的结果（翻转顺序），最终 envelope size (右图框起来的元素数目)等于 22</p>
<p><img src="21.png" alt="1"></p>
<p>起始节点的选择会显著影响这个排序算法的效果，在这个例子中，如果我们选择 “a” 作为起始节点，效果会更好， envelope size 等于 18。</p>
<h1>查找初始位点</h1>
<p>我们现在看如何查找 RCM 算法的起始节点。</p>
<p>回顾一下，一条长度为 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> ，从节点 <img src="https://math.now.sh?inline=x_%7B0%7D" style="display:inline-block;margin: 0;"/> 到 <img src="https://math.now.sh?inline=x_%7Bk%7D" style="display:inline-block;margin: 0;"/> 的通路是由不同的节点组成的有序集合 <img src="https://math.now.sh?inline=%28x_%7B0%7D%2Cx_%7B1%7D%2C%5Ccdots%2Cx_%7Bk%7D%29" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=x_%7Bi%7D%20%5Cin%20Adj%28x_%7Bi%2B1%7D%29" style="display:inline-block;margin: 0;"/> 。两个节点 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 的距离 <img src="https://math.now.sh?inline=d%28x%2Cy%29" style="display:inline-block;margin: 0;"/> 定义为二者最短通路的长度。我们进一步定义节点 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 的 <em><strong>eccentricity</strong></em> 为</p>
<p style=""><img src="https://math.now.sh?from=%5Cell%28x%29%3D%5Cmax%20%5C%7Bd(x%2C%20y)%20%5Cmid%20y%20%5Cin%20X%5C%7D%0A" /></p><p><em><strong>diameter</strong></em> <em>of <img src="https://math.now.sh?inline=%5Cmathcal%7BG%7D" style="display:inline-block;margin: 0;"/></em> 为</p>
<p style=""><img src="https://math.now.sh?from=%5Cdelta%28%5Cmathcal%7BG%7D%29%3D%5Cmax%20%5C%7B%5Cell(x)%20%5Cmid%20x%20%5Cin%20X%5C%7D%0A" /></p><p>或者等价于</p>
<p style=""><img src="https://math.now.sh?from=%5Cdelta%28%5Cmathcal%7BG%7D%29%3D%5Cmax%20%5C%7Bd(x%2C%20y)%20%5Cmid%20x%2Cy%20%5Cin%20X%5C%7D%0A" /></p><p>如果一个节点 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 的 <em>eccentricity</em> 等于 图的 <em>diameter</em> ，即 <img src="https://math.now.sh?inline=%5Cell%28x%29%20%3D%20%5Cdelta(%5Cmathcal%7BG%7D)" style="display:inline-block;margin: 0;"/> ，那么我们称其为一个 <em><strong>peripheral</strong></em> <em>node</em> 。</p>
<p>下图中的图有 8 个节点，其 <em>diameter</em> 等于 5，节点 <img src="https://math.now.sh?inline=x_%7B2%7D%2Cx_%7B5%7D%2Cx_%7B7%7D" style="display:inline-block;margin: 0;"/> 为 <em><strong>peripheral</strong></em> <em>node</em> 。</p>
<p><img src="22.png" alt="1"></p>
<p>我们这一小节的目标就是得到一个有效的<strong>启发式</strong>算法，来找到 <em><strong>eccentricity</strong></em> 很高的节点。注意，我们的算法不一定能找到  <em><strong>peripheral</strong></em> <em>node</em> ，但是我们找到的节点往往具有很高的 <em><strong>eccentricity</strong></em> ，适合作为初始节点。进一步地说，在实际应用中， <em><strong>peripheral</strong></em> <em>node</em> 貌似也没有比算法找到的初始节点有任何优势。最后查找  <em><strong>peripheral</strong></em> <em>node</em> 可能是非常耗时的。</p>
<p>在下面的章节中，我们称用这个算法找到的节点为 <em>pseudo-peripheral</em> nodes 。这个算法的关键是 <em>rooted level structure</em> ，给定一个节点 <img src="https://math.now.sh?inline=x%20%5Cin%20X" style="display:inline-block;margin: 0;"/> ，<em>the level structure rooted at x</em> 就是 <em>partitioning</em> <img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D%28x%29" style="display:inline-block;margin: 0;"/> ，满足：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathcal%7BL%7D%28x%29%20%3D%20%5C%7B%20L_%7B0%7D(x)%2C%20L_%7B1%7D(x)%2C%5Ccdots%2CL_%7B%5Cell(x)%7D(x)%5C%7D%0A" /></p><p>其中</p>
<p style=""><img src="https://math.now.sh?from=L_%7B0%7D%28x%29%20%3D%20%5C%7B%20x%20%5C%7D%2C%20L_%7B1%7D(x)%20%3D%20Adj(L_%7B0%7D(x))%0A" /></p><p>并且</p>
<p style=""><img src="https://math.now.sh?from=L_%7Bi%7D%28x%29%20%3D%20Adj(L_%7Bi-1%7D(x))%20-%20L_%7Bi-2%7D(x)%2C%20%5Cquad%20i%3D2%2C3%2C%5Ccdots%2C%5Cell(x)%0A" /></p><p><em>eccentricity</em> <img src="https://math.now.sh?inline=%5Cell%28x%29" style="display:inline-block;margin: 0;"/> 称为 <img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D%28x%29" style="display:inline-block;margin: 0;"/> 的<strong>长度</strong> (<em>length</em>) 。 <img src="https://math.now.sh?inline=%5Cmathcal%7BL%7D%28x%29" style="display:inline-block;margin: 0;"/> 的<strong>宽度</strong> (<em>width</em>) 定义为：</p>
<p style=""><img src="https://math.now.sh?from=w%28x%29%3D%5Cmax%20%5Cleft%5C%7B%5Cleft%7CL_%7Bi%7D(x)%5Cright%7C%20%5Cmid%200%20%5Cleq%20i%20%5Cleq%20%5Cell(x)%5Cright%5C%7D%0A" /></p><p>下图中我们展示了一个  <em>rooted level structure</em> at <img src="https://math.now.sh?inline=x_%7B6%7D" style="display:inline-block;margin: 0;"/> ，我们注意到 <img src="https://math.now.sh?inline=%5Cell%28x_%7B6%7D%29%20%3D%203" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=w%28x_%7B6%7D%29%20%3D%203" style="display:inline-block;margin: 0;"/> 。</p>
<p><img src="23.png" alt="1"></p>
<p>我们现在可以描述 <em>pseudo-peripheral</em> nodes finding algorithm 了，如下</p>
<p><img src="24.png" alt="1"></p>
<p><img src="25.png" alt="1"></p>
<p>下图是其中的一个例子，<em>the level structures</em> 的第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 层标记为 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 。</p>
<p><img src="26.png" alt="1"></p>
<h1>参考文献</h1>
<ol>
<li>George A, Liu J, Ng E. Computer solution of sparse linear systems[J]. Oak Ridge National Laboratory, 1994.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>稀疏矩阵</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>稀疏矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>H逆矩阵的推导</title>
    <url>/posts/6a829195/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在<a href="https://vincere.fun/posts/e0b3b4ee/">基因组选择模型介绍下</a>提到了H逆矩阵，这里是补上证明。</p>
<span id="more"></span>
<h1>H逆证明</h1>
<p>首先，按照无基因型个体在前，有基因型个体在后的顺序，H 阵的公式为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BH%7D%20%26%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Coperatorname%7Bvar%7D%5Cleft(%5Cmathbf%7Bu%7D_%7B1%7D%5Cright%29%20%26%20%5Coperatorname%7Bcov%7D%5Cleft(%5Cmathbf%7Bu%7D_%7B1%7D%2C%20%5Cmathbf%7Bu%7D_%7B2%7D%5Cright)%20%5C%5C%0A%5Coperatorname%7Bcov%7D%5Cleft(%5Cmathbf%7Bu%7D_%7B2%7D%2C%20%5Cmathbf%7Bu%7D_%7B1%7D%5Cright)%20%26%20%5Coperatorname%7Bvar%7D%5Cleft(%5Cmathbf%7Bu%7D_%7B2%7D%5Cright)%0A%5Cend%7Barray%7D%5Cright)%20%5C%5C%0A%26%3D%5Cleft(%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BA%7D_%7B11%7D%2B%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%5Cleft(%5Cmathbf%7BG%7D-%5Cmathbf%7BA%7D_%7B22%7D%5Cright)%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B21%7D%20%26%20%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BG%7D%20%5C%5C%0A%5Cmathbf%7BG%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B21%7D%20%26%20%5Cmathbf%7BG%7D%0A%5Cend%7Barray%7D%5Cright)%20%5C%5C%0A%26%3D%5Cmathbf%7BA%7D%2B%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%5Cleft(%5Cmathbf%7BG%7D-%5Cmathbf%7BA%7D_%7B22%7D%5Cright)%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B21%7D%20%26%20%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%5Cleft(%5Cmathbf%7BG%7D-%5Cmathbf%7BA%7D_%7B22%7D%5Cright)%20%5C%5C%0A%5Cleft(%5Cmathbf%7BG%7D-%5Cmathbf%7BA%7D_%7B22%7D%5Cright)%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B21%7D%20%26%20%5Cmathbf%7BG%7D-%5Cmathbf%7BA%7D_%7B22%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A%5Cend%7Baligned%7D%0A" /></p><p>如果我们按照有基因型个体在前，无基因型个体在后的顺序，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BH%7D%20%26%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Coperatorname%7Bvar%7D%5Cleft(%5Cmathbf%7Bu%7D_%7B1%7D%5Cright%29%20%26%20%5Coperatorname%7Bcov%7D%5Cleft(%5Cmathbf%7Bu%7D_%7B1%7D%2C%20%5Cmathbf%7Bu%7D_%7B2%7D%5Cright)%20%5C%5C%0A%5Coperatorname%7Bcov%7D%5Cleft(%5Cmathbf%7Bu%7D_%7B2%7D%2C%20%5Cmathbf%7Bu%7D_%7B1%7D%5Cright)%20%26%20%5Coperatorname%7Bvar%7D%5Cleft(%5Cmathbf%7Bu%7D_%7B2%7D%5Cright)%0A%5Cend%7Barray%7D%5Cright)%20%5C%5C%0A%26%3D%5Cleft(%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BG%7D%20%26%20%5Cmathbf%7BG%7D%20%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B12%7D%20%20%20%5C%5C%0A%5Cmathbf%7BA%7D_%7B21%7D%20%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%5Cmathbf%7BG%7D%20%26%20%5Cmathbf%7BA%7D_%7B22%7D%2B%5Cmathbf%7BA%7D_%7B21%7D%20%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%5Cleft(%5Cmathbf%7BG%7D-%5Cmathbf%7BA%7D_%7B11%7D%5Cright)%20%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B12%7D%0A%5Cend%7Barray%7D%5Cright)%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>相应的 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵分块为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%20%3D%20%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BA%7D_%7B11%7D%20%26%20%5Cmathbf%7BA%7D_%7B12%7D%20%5C%5C%0A%5Cmathbf%7BA%7D_%7B21%7D%20%26%20%5Cmathbf%7BA%7D_%7B22%7D%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%29%0A" /></p><p>根据分块矩阵求逆的一般规则 (<a href="https://www.zhihu.com/question/47760591/answer/331976386">分块矩阵求逆公式</a> ，如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B11%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B22%7D-%5Cmathbf%7BA%7D_%7B21%7D%20%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B12%7D" style="display:inline-block;margin: 0;"/> 可逆，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%5E%7B-1%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%2B%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B12%7D%5Cleft%28%5Cmathbf%7BA%7D_%7B22%7D-%5Cmathbf%7BA%7D_%7B21%7D%20%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B12%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B21%7D%20%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%26%20-%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B12%7D%5Cleft(%5Cmathbf%7BA%7D_%7B22%7D-%5Cmathbf%7BA%7D_%7B21%7D%20%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B12%7D%5Cright)%5E%7B-1%7D%20%5C%5C%0A-%5Cleft(%5Cmathbf%7BA%7D_%7B22%7D-%5Cmathbf%7BA%7D_%7B21%7D%20%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B12%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B21%7D%20%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%26%20%5Cleft(%5Cmathbf%7BA%7D_%7B22%7D-%5Cmathbf%7BA%7D_%7B21%7D%20%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B12%7D%5Cright)%5E%7B-1%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>同样地，对于 <img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D" style="display:inline-block;margin: 0;"/> 矩阵，应用相同的规则，化简后得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cmathbf%7BH%7D%5E%7B-1%7D%20%5C%5C%0A%26%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BG%7D%5E%7B-1%7D%2B%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B12%7D%5Cleft%28%5Cmathbf%7BA%7D_%7B22%7D-%5Cmathbf%7BA%7D_%7B21%7D%20%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B12%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B21%7D%20%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%26%20-%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B12%7D%5Cleft(%5Cmathbf%7BA%7D_%7B22%7D-%5Cmathbf%7BA%7D_%7B21%7D%20%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B12%7D%5Cright)%5E%7B-1%7D%20%5C%5C%0A-%5Cleft(%5Cmathbf%7BA%7D_%7B22%7D-%5Cmathbf%7BA%7D_%7B21%7D%20%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B12%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B21%7D%20%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%26%20%5Cleft(%5Cmathbf%7BA%7D_%7B22%7D-%5Cmathbf%7BA%7D_%7B21%7D%20%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B12%7D%5Cright)%5E%7B-1%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BG%7D%5E%7B-1%7D-%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%0A%5Cend%7Barray%7D%5Cright%5D%2B%5Cmathbf%7BA%7D%5E%7B-1%7D%20%0A%5Cend%7Baligned%7D%0A" /></p><h1>参考文献</h1>
<ol>
<li>Christensen O F, Lund M S. Genomic prediction when some animals are not genotyped[J]. Genetics Selection Evolution, 2010, 42(1): 1-8.</li>
<li>Aguilar I, Misztal I, Johnson D L, et al. Hot topic: a unified approach to utilize phenotypic, full pedigree, and genomic information for genetic evaluation of Holstein final score[J]. Journal of dairy science, 2010, 93(2): 743-752.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>最小二乘中的可估计函数</title>
    <url>/posts/abc85283/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在不考虑互作的前提下，一个固定因子的不同水平效应之差是可估计的吗？</p>
<span id="more"></span>
<h1>可估计函数</h1>
<p>如果存在一个观测值 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的线性组合的期望等于  $ \boldsymbol{\lambda^{\prime} \boldsymbol{\beta}}$ ，我们就称这个参数的线性组合  $ \boldsymbol{\lambda^{\prime} \boldsymbol{\beta}}$ 是<strong>可估计的</strong> (<em>estimable</em>) ，也就是说，存在一个向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D" style="display:inline-block;margin: 0;"/> ，使得下式成立</p>
<p style=""><img src="https://math.now.sh?from=E%5Cleft%28%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%0A" /></p><p>在模型  <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> 中，其中 <img src="https://math.now.sh?inline=E%28%5Cmathbf%7By%7D%29%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的秩为 $k &lt; p \leq n $ 的矩阵。那么<strong>当且仅当 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的行的线性组合</strong>时，线性函数 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 可估计。也就是说存在一个向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D" style="display:inline-block;margin: 0;"/> 使得下式成立</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%0A" /></p><p><strong>证明</strong>： 如果存在一个向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D" style="display:inline-block;margin: 0;"/> 使得 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%3D%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> ，那么我们有</p>
<p style=""><img src="https://math.now.sh?from=E%5Cleft%28%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%3D%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20E(%5Cmathbf%7By%7D)%3D%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%0A" /></p><p>因此  $ \boldsymbol{\lambda^{\prime} \boldsymbol{\beta}}$ 可估计。</p>
<p>反过来，如果 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 可估计，那么存在一个向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D" style="display:inline-block;margin: 0;"/> 使得 <img src="https://math.now.sh?inline=E%5Cleft%28%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 对于所有可能的 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 均成立，因此 $\mathbf{a}^{\prime} \mathbf{X}=\boldsymbol{\lambda}^{\prime} $ ，得证。</p>
<p>因此，我们可以轻松得到以下性质。</p>
<h1>性质</h1>
<ol>
<li>
<p>任何一个观测值的期望值都是可估计的，即 <img src="https://math.now.sh?inline=E%28y_%7Bijk%7D%29%20%3D%20%5Cmu%20%2B%20%5Calpha_%7Bi%7D%20%2B%20%5Cbeta_%7Bj%7D" style="display:inline-block;margin: 0;"/> 是可估计的。</p>
<p>证明：此时 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%5E%7B%5Cprime%7D%7D%20%3D%20%5Cmathbf%7Bx%7D_%7Bi%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，即等于 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵的某一行 ，因此当然是  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵行的线性组合， <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 可估计，得证。</p>
</li>
<li>
<p>可估计函数的任意线性组合也是可估计函数</p>
<p>证明：假设有两个可估计函数 <img src="https://math.now.sh?inline=E%5Cleft%28%5Cmathbf%7Ba%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D_%7B1%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=E%5Cleft%28%5Cmathbf%7Ba%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D_%7B2%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/>  ，这两个可估计函数的线性组合为：</p>
<p style=""><img src="https://math.now.sh?from=c_%7B1%7D%20%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D_%7B1%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20%2B%20c_%7B2%7D%20%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D_%7B2%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20%3D%20c_%7B1%7D%20E%5Cleft%28%5Cmathbf%7Ba%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%20%2B%20c_%7B2%7D%20E%5Cleft(%5Cmathbf%7Ba%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright)%20%3D%20%20E%5Cleft(%20(c_%7B1%7D%20%5Cmathbf%7Ba%7D_%7B1%7D%5E%7B%5Cprime%7D%20%2B%20c_%7B2%7D%20%5Cmathbf%7Ba%7D_%7B2%7D%5E%7B%5Cprime%7D)%20%5Cmathbf%7By%7D%20%5Cright)%0A" /></p><p>得证。</p>
</li>
<li>
<p>如果 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 可估计，则对于方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7BX'X%7D%20%5Cboldsymbol%7B%5Cbeta%7D%5E%7B0%7D%20%3D%20%5Cmathbf%7BX'y%7D" style="display:inline-block;margin: 0;"/> 的任意解 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D%5E%7B0%7D" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%5E%7B0%7D" style="display:inline-block;margin: 0;"/> 是唯一的。</p>
<p>证明：我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%5E%7B0%7D%20%3D%20%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%5E%7B0%7D%20%3D%20%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%28X'X%29%5E%7B-%7DX'y%7D%0A" /></p><p>因为对于任意的 <img src="https://math.now.sh?inline=%28%5Cmathbf%7BX'X%7D%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathbf%7BX%28X'X%29%5E%7B-%7DX'%7D" style="display:inline-block;margin: 0;"/> 均是唯一的（证明见 <a href="https://vincere.fun/posts/73361a24/">广义逆及其性质</a>）因此证明 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%5E%7B0%7D" style="display:inline-block;margin: 0;"/> 是唯一的。</p>
</li>
<li>
<p>如果 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 可估计，则  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%5E%7B0%7D" style="display:inline-block;margin: 0;"/> 是 <strong>BLUE</strong> 估计值（最佳线性无偏估计值）。</p>
<p>证明略</p>
</li>
</ol>
<h1>一个因子不同水平效应之差</h1>
<p>如果一个固定因子与其他因子之间没有互作，那么它的不同水平效应之差是可估计的吗？</p>
<p>根据上面的内容，我们已知判断是否估计，关键要看 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 是不是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的行的线性组合。我们先看一个反例，假设总共只有两个固定因子 <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cbeta" style="display:inline-block;margin: 0;"/> ，每个固定因子有两个水平。假设我们有8条数据，有4条数据包含效应 <img src="https://math.now.sh?inline=%5Calpha_%7B1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cbeta_%7B1%7D" style="display:inline-block;margin: 0;"/> ，另外四条数据包含效应 <img src="https://math.now.sh?inline=%5Calpha_%7B2%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cbeta_%7B2%7D" style="display:inline-block;margin: 0;"/> ，构建模型时不考虑均值列，用矩阵形式表示为</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bl%7D%0Ay_%7B1%7D%20%5C%5C%0Ay_%7B2%7D%20%5C%5C%0Ay_%7B3%7D%20%5C%5C%0Ay_%7B4%7D%20%5C%5C%0Ay_%7B5%7D%20%5C%5C%0Ay_%7B6%7D%20%5C%5C%0Ay_%7B7%7D%20%5C%5C%0Ay_%7B8%7D%20%5C%5C%0A%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cbegin%7Barray%7D%7Blll%7D%0A1%20%26%200%20%26%201%20%26%200%20%5C%5C%0A1%20%26%200%20%26%201%20%26%200%20%5C%5C%0A1%20%26%200%20%26%201%20%26%200%20%5C%5C%0A1%20%26%200%20%26%201%20%26%200%20%5C%5C%0A0%20%26%201%20%26%200%20%26%201%20%5C%5C%0A0%20%26%201%20%26%200%20%26%201%20%5C%5C%0A0%20%26%201%20%26%200%20%26%201%20%5C%5C%0A0%20%26%201%20%26%200%20%26%201%20%5C%5C%0A%0A%5Cend%7Barray%7D%5Cright)%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Calpha_%7B1%7D%20%5C%5C%0A%5Calpha_%7B2%7D%20%5C%5C%0A%5Cbeta_%7B1%7D%20%5C%5C%0A%5Cbeta_%7B2%7D%20%5C%5C%0A%0A%5Cend%7Barray%7D%5Cright)%2B%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cvarepsilon_%7B1%7D%20%5C%5C%0A%5Cvarepsilon_%7B2%7D%20%5C%5C%0A%5Cvarepsilon_%7B3%7D%20%5C%5C%0A%5Cvarepsilon_%7B4%7D%20%5C%5C%0A%5Cvarepsilon_%7B5%7D%20%5C%5C%0A%5Cvarepsilon_%7B6%7D%20%5C%5C%0A%5Cvarepsilon_%7B7%7D%20%5C%5C%0A%5Cvarepsilon_%7B8%7D%20%5C%5C%0A%0A%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>或者</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=8%20%5Ctimes%204" style="display:inline-block;margin: 0;"/> 的矩阵，秩为2 。此时我们无法得到唯一的估计值 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，因为 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 不存在。</p>
<p>由于可估计函数  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 中的  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 必须是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的行的线性组合，易得 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的行空间的两个基向量为</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Blll%7D%0A1%20%26%200%20%26%201%20%26%200%20%5C%5C%0A%0A%0A%5Cend%7Barray%7D%5Cright%29%0A" /></p><p>和</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Blll%7D%0A0%20%26%201%20%26%200%20%26%201%20%5C%5C%0A%0A%5Cend%7Barray%7D%5Cright%29%0A" /></p><p>这两个向量的线性组合为</p>
<p style=""><img src="https://math.now.sh?from=c_%7B1%7D%20%5Cleft%28%5Cbegin%7Barray%7D%7Blll%7D%0A1%20%26%200%20%26%201%20%26%200%20%5C%5C%0A%0A%0A%5Cend%7Barray%7D%5Cright%29%20%2B%20c_%7B2%7D%20%5Cleft(%5Cbegin%7Barray%7D%7Blll%7D%0A0%20%26%201%20%26%200%20%26%201%20%5C%5C%0A%0A%5Cend%7Barray%7D%5Cright)%20%3D%20%0A%0A%20%5Cleft(%5Cbegin%7Barray%7D%7Blll%7D%0Ac_%7B1%7D%20%26%20c_%7B2%7D%20%26%20c_%7B1%7D%20%26%20c_%7B2%7D%20%5C%5C%0A%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>那么所有可估计函数的形式就是</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Blll%7D%0Ac_%7B1%7D%20%26%20c_%7B2%7D%20%26%20c_%7B1%7D%20%26%20c_%7B2%7D%20%5C%5C%0A%0A%5Cend%7Barray%7D%5Cright%29%20%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Calpha_%7B1%7D%20%5C%5C%0A%5Calpha_%7B2%7D%20%5C%5C%0A%5Cbeta_%7B1%7D%20%5C%5C%0A%5Cbeta_%7B2%7D%20%5C%5C%0A%0A%5Cend%7Barray%7D%5Cright)%20%3D%20c_%7B1%7D%20%5Calpha_%7B1%7D%20%2B%20c_%7B2%7D%20%5Calpha_%7B2%7D%20%2B%20c_%7B1%7D%20%5Cbeta_%7B1%7D%20%2B%20c_%7B2%7D%20%5Cbeta_%7B2%7D%0A" /></p><p>根据这个形式，我们不可能得到 <img src="https://math.now.sh?inline=%5Calpha_%7B1%7D%20-%20%5Calpha_%7B2%7D" style="display:inline-block;margin: 0;"/> 或者 <img src="https://math.now.sh?inline=%5Cbeta_%7B1%7D%20-%20%5Cbeta_%7B2%7D" style="display:inline-block;margin: 0;"/> ，此时任何一个因子不同水平效应之差都是不可估计的。你只能得到 <img src="https://math.now.sh?inline=%5Calpha_%7B1%7D%20-%20%5Calpha_%7B2%7D%20%2B%20%5Cbeta_%7B1%7D%20-%20%5Cbeta_%7B2%7D" style="display:inline-block;margin: 0;"/> 是可估计的。</p>
<p>因此根据这个反例，我们知道，<strong>一个因子不同水平效应之差是不可估计的</strong>，或者说不是在所有情况下都可以估计。</p>
<p>那么什么情况下，一个因子不同水平效应之差是可以估计的呢？我们还是要看其能不能表示为  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的行的线性组合 ，一个最简单的情况就是能不能找  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的两行的差值乘以 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/>  正好等于这两个水平的效应之差。也就是说需要存在两个观测值在其它固定因子的所属水平均相同，只在这个固定因子的所属水平不同，比如按照上面的例子，如果存在两个观测值 <img src="https://math.now.sh?inline=E%28y_%7Bi%7D%29%20%3D%20%5Calpha_%7B1%7D%20%2B%20%5Cbeta_%7B1%7D" style="display:inline-block;margin: 0;"/>  , <img src="https://math.now.sh?inline=E%28y_%7Bj%7D%29%20%3D%20%5Calpha_%7B2%7D%20%2B%20%5Cbeta_%7B1%7D" style="display:inline-block;margin: 0;"/>  ，那么这两个式子之差得到 <img src="https://math.now.sh?inline=E%28y_%7Bi%7D%20-%20y_%7Bj%7D%29%20%3D%20%5Calpha_%7B1%7D%20-%20%5Calpha_%7B2%7D" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=%5Calpha_%7B1%7D%20-%20%5Calpha_%7B2%7D" style="display:inline-block;margin: 0;"/> 可估计。</p>
<p>因此，如果所有水平组合均至少存在一个观测值，那么此时所有因子不同水平效应之差都是可估计的。还是以上面的二变量固定模型为例，其数据分布如下，可以看出其数据过于不均衡。如果四个水平组合都有观测值，那么  <img src="https://math.now.sh?inline=%5Calpha_%7B1%7D%20-%20%5Calpha_%7B2%7D" style="display:inline-block;margin: 0;"/> 或者 <img src="https://math.now.sh?inline=%5Cbeta_%7B1%7D%20-%20%5Cbeta_%7B2%7D" style="display:inline-block;margin: 0;"/> 均可以估计。其实只需要三个水平组合都有观测值，那么 <img src="https://math.now.sh?inline=%5Calpha_%7B1%7D%20-%20%5Calpha_%7B2%7D" style="display:inline-block;margin: 0;"/> 或者 <img src="https://math.now.sh?inline=%5Cbeta_%7B1%7D%20-%20%5Cbeta_%7B2%7D" style="display:inline-block;margin: 0;"/> 也是可以估计的。</p>
<table>
<thead>
<tr>
<th></th>
<th><img src="https://math.now.sh?inline=%5Cbeta_%7B1%7D" style="display:inline-block;margin: 0;"/></th>
<th><img src="https://math.now.sh?inline=%5Cbeta_%7B2%7D" style="display:inline-block;margin: 0;"/></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://math.now.sh?inline=%5Calpha_%7B1%7D" style="display:inline-block;margin: 0;"/></td>
<td>4</td>
<td>0</td>
</tr>
<tr>
<td><img src="https://math.now.sh?inline=%5Calpha_%7B2%7D" style="display:inline-block;margin: 0;"/></td>
<td>0</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>在实际数据中，一般 <img src="https://math.now.sh?inline=n%20%5Cgg%20p" style="display:inline-block;margin: 0;"/> ，而且数据一般也不会像上面的例子一样这么不均衡，因此一般来说一个因子不同水平效应之差还是可估计的。</p>
<h1>参考文献</h1>
<ol>
<li>Rencher A C, Schaalje G B. Linear models in statistics[M]. John Wiley &amp; Sons, 2008.</li>
<li>张沅，张勤，《畜禽育种中的线性模型》</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>不满秩的线性回归模型的参数估计</title>
    <url>/posts/1c2f25ac/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>上一篇<a href="https://vincere.fun/posts/55264e6f/">矩阵微分与正规方程组推导</a>，我推导了线性回归模型中的正规方程组，以及当矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 满秩时的最小二乘估计值，现在我们考虑当 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 不满秩时的情况。</p>
<p>本章节内容主要来自于 《linear models in statistics》第二版的第十二章 <em>Analysis-of-Variance Models</em> 。</p>
<span id="more"></span>
<h1>含有均值列的线性模型系数矩阵一定不满秩</h1>
<p>一般我们设计的模型中均包含均值列，即全为1的列，而对于任何一个固定效应，每个个体只在一个水平为1，其余水平为0，因此将任何一个固定效应的所有水平的列加在一起，就等于均值列，因此设计矩阵的列之间存在线性相关，设计矩阵一定不满秩，最小二乘解不唯一，不是所有固定效应的水平均可估计。</p>
<p>所以如果模型中包含均值列，那么是<strong>一定</strong>不满秩，而不是可能不满秩。</p>
<h1>不满秩的模型</h1>
<p>首先我们看单变量的模型的例子，假设是平衡数据（各个水平的观测值相同）。</p>
<h2 id="单变量模型">单变量模型</h2>
<p>假设研究人员开发了两种用于增加汽油日程的化学添加剂，假设不添加任何添加剂的情况下，一加仑的汽油平均可以跑 <img src="https://math.now.sh?inline=%5Cmu" style="display:inline-block;margin: 0;"/> 英里。那么假设我们添加化学物质 1，我们期望一加仑汽油的里程数增加 <img src="https://math.now.sh?inline=%5Ctau_%7B1%7D" style="display:inline-block;margin: 0;"/> 英里；而添加化学物质 2，一加仑汽油的里程数增加 <img src="https://math.now.sh?inline=%5Ctau_%7B1%7D" style="display:inline-block;margin: 0;"/> 英里。</p>
<p>因此，这个模型可以表示为</p>
<p style=""><img src="https://math.now.sh?from=y_%7B1%7D%3D%5Cmu%2B%5Ctau_%7B1%7D%2B%5Cvarepsilon_%7B1%7D%2C%20%5Cquad%20y_%7B2%7D%3D%5Cmu%2B%5Ctau_%7B2%7D%2B%5Cvarepsilon_%7B2%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=y_1" style="display:inline-block;margin: 0;"/> 是添加化学物质 1 的日程数， <img src="https://math.now.sh?inline=y_2" style="display:inline-block;margin: 0;"/> 是添加化学物质 2 的日程数。我们想要估计参数 <img src="https://math.now.sh?inline=%5Cmu%2C%20%5Ctau_%7B1%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Ctau_%7B2%7D" style="display:inline-block;margin: 0;"/> ，并且做假设检验，例如 <img src="https://math.now.sh?inline=H_%7B0%7D%3A%20%5Ctau_%7B1%7D%3D%5Ctau_%7B2%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>假设我们做了6次实验，其中每个化学物质做了3次，用矩阵形式表示为</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bl%7D%0Ay_%7B11%7D%20%5C%5C%0Ay_%7B12%7D%20%5C%5C%0Ay_%7B13%7D%20%5C%5C%0Ay_%7B21%7D%20%5C%5C%0Ay_%7B22%7D%20%5C%5C%0Ay_%7B23%7D%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cbegin%7Barray%7D%7Blll%7D%0A1%20%26%201%20%26%200%20%5C%5C%0A1%20%26%201%20%26%200%20%5C%5C%0A1%20%26%201%20%26%200%20%5C%5C%0A1%20%26%200%20%26%201%20%5C%5C%0A1%20%26%200%20%26%201%20%5C%5C%0A1%20%26%200%20%26%201%0A%5Cend%7Barray%7D%5Cright)%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmu%20%5C%5C%0A%5Ctau_%7B1%7D%20%5C%5C%0A%5Ctau_%7B2%7D%0A%5Cend%7Barray%7D%5Cright)%2B%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cvarepsilon_%7B11%7D%20%5C%5C%0A%5Cvarepsilon_%7B12%7D%20%5C%5C%0A%5Cvarepsilon_%7B13%7D%20%5C%5C%0A%5Cvarepsilon_%7B21%7D%20%5C%5C%0A%5Cvarepsilon_%7B22%7D%20%5C%5C%0A%5Cvarepsilon_%7B23%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>或者</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=6%20%5Ctimes%203" style="display:inline-block;margin: 0;"/> 的矩阵，秩为2 ，因为第一列等于第二列和第三列的和。此时我们无法得到估计值 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，因为 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 不存在。</p>
<p>这里我们考虑这些参数的含义。参数 <img src="https://math.now.sh?inline=%5Cmu" style="display:inline-block;margin: 0;"/> 表示不添加任何化学物质的均值，<img src="https://math.now.sh?inline=%5Ctau_%7B1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Ctau_%7B2%7D" style="display:inline-block;margin: 0;"/> 表示两个化学物质的增加量。举个例子，假设 <img src="https://math.now.sh?inline=%5Cmu%3D15%2C%20%5Ctau_%7B1%7D%3D1" style="display:inline-block;margin: 0;"/>,  <img src="https://math.now.sh?inline=%5Ctau_%7B2%7D%3D3" style="display:inline-block;margin: 0;"/> ，那么模型为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Barray%7D%7Bll%7D%0Ay_%7B1%20j%7D%3D15%2B1%2B%5Cvarepsilon_%7B1%20j%7D%3D16%2B%5Cvarepsilon_%7B1%20j%7D%2C%20%26%20j%3D1%2C2%2C3%2C%20%5C%5C%0Ay_%7B2%20j%7D%3D15%2B3%2B%5Cvarepsilon_%7B2%20j%7D%3D18%2B%5Cvarepsilon_%7B2%20j%7D%2C%20%26%20j%3D1%2C2%2C3%20.%0A%5Cend%7Barray%7D%0A" /></p><p>然而，我们从数据中能得到的是 <img src="https://math.now.sh?inline=y_%7B1%20j%7D%3D16%2B%5Cvarepsilon_%7B1%20j%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=y_%7B2%20j%7D%3D18%2B%5Cvarepsilon_%7B2%20j%7D" style="display:inline-block;margin: 0;"/> ，我们无法得到 <img src="https://math.now.sh?inline=%5Cmu%3D15%2C%20%5Ctau_%7B1%7D%3D1" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Ctau_%7B2%7D%3D3" style="display:inline-block;margin: 0;"/>  ，因为很多模型都可以得到这两个式子，比如</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Barray%7D%7Bll%7D%0Ay_%7B1%20j%7D%3D10%2B6%2B%5Cvarepsilon_%7B1%20j%7D%2C%20%26%20j%3D1%2C2%2C3%2C%20%5C%5C%0Ay_%7B2%20j%7D%3D10%2B8%2B%5Cvarepsilon_%7B2%20j%7D%2C%20%26%20j%3D1%2C2%2C3%2C%0A%5Cend%7Barray%7D%0A" /></p><p>又比如，</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Barray%7D%7Bll%7D%0Ay_%7B1%20j%7D%3D25-9%2B%5Cvarepsilon_%7B1%20j%7D%2C%20%26%20j%3D1%2C2%2C3%20%5C%5C%0Ay_%7B2%20j%7D%3D25-7%2B%5Cvarepsilon_%7B2%20j%7D%2C%20%26%20j%3D1%2C2%2C3%0A%5Cend%7Barray%7D%0A" /></p><p>我们有无穷的参数组合可以实现这一点。也就是说，我们无法得到唯一的 <img src="https://math.now.sh?inline=%5Cmu%2C%20%5Ctau_%7B1%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Ctau_%7B2%7D" style="display:inline-block;margin: 0;"/> ，此时我们称这个模型为 <strong>过度参数化的</strong> (<em>overparameterized</em>) 。在平衡数据中，你增加数据量无助于这一点，因为不会改变 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的秩。</p>
<p>我们很多种方法可以解决这一点，来获得唯一的估计值，但是这些方法各有利弊。第一种，重新定义一个模型，减少参数的数目，使得参数估计值唯一；第二种，模型不变，但是对参数增加<strong>约束条件</strong>，使得参数估计值唯一；第三种，模型不变，估计某个唯一的<strong>参数的线性组合</strong>。下面我们来简单地介绍这三种方法。</p>
<p><strong>第一种方法</strong>：为了减少参数数量，考虑到下面两个式子成立</p>
<p style=""><img src="https://math.now.sh?from=y_%7B1%20j%7D%3D16%2B%5Cvarepsilon_%7B1%20j%7D%20%5Cquad%20%5Ctext%20%7B%20and%20%7D%20%5Cquad%20y_%7B2%20j%7D%3D18%2B%5Cvarepsilon_%7B2%20j%7D%0A" /></p><p>这里，16 和 18 是添加两种化学物质之后的均值，我们可以将其标记为 <img src="https://math.now.sh?inline=%5Cmu_%7B1%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cmu_%7B2%7D" style="display:inline-block;margin: 0;"/> ，我们可以将模型修改为</p>
<p style=""><img src="https://math.now.sh?from=y_%7B1%20j%7D%3D%5Cmu_%7B1%7D%2B%5Cvarepsilon_%7B1%20j%7D%20%5Cquad%20%5Ctext%20%7B%20and%20%7D%20%5Cquad%20y_%7B2%20j%7D%3D%5Cmu_%7B2%7D%2B%5Cvarepsilon_%7B2%20j%7D%20.%0A" /></p><p>此时我们要估计的参数就是  <img src="https://math.now.sh?inline=%5Cmu_%7B1%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cmu_%7B2%7D" style="display:inline-block;margin: 0;"/> ，观测值的矩阵表示式为</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bl%7D%0Ay_%7B11%7D%20%5C%5C%0Ay_%7B12%7D%20%5C%5C%0Ay_%7B13%7D%20%5C%5C%0Ay_%7B21%7D%20%5C%5C%0Ay_%7B22%7D%20%5C%5C%0Ay_%7B23%7D%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cbegin%7Barray%7D%7Bll%7D%0A1%20%26%200%20%5C%5C%0A1%20%26%200%20%5C%5C%0A1%20%26%200%20%5C%5C%0A0%20%26%201%20%5C%5C%0A0%20%26%201%20%5C%5C%0A0%20%26%201%0A%5Cend%7Barray%7D%5Cright)%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmu_%7B1%7D%20%5C%5C%0A%5Cmu_%7B2%7D%0A%5Cend%7Barray%7D%5Cright)%2B%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cvarepsilon_%7B11%7D%20%5C%5C%0A%5Cvarepsilon_%7B12%7D%20%5C%5C%0A%5Cvarepsilon_%7B13%7D%20%5C%5C%0A%5Cvarepsilon_%7B21%7D%20%5C%5C%0A%5Cvarepsilon_%7B22%7D%20%5C%5C%0A%5Cvarepsilon_%7B23%7D%0A%5Cend%7Barray%7D%5Cright)%2C%0A" /></p><p>这可以写作</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%3D%5Cmathbf%7BW%7D%20%5Cboldsymbol%7B%5Cmu%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D%0A" /></p><p>其中矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D" style="display:inline-block;margin: 0;"/> 是一个满秩矩阵，因此我们可以得到唯一的参数估计值为</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cboldsymbol%7B%5Cmu%7D%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bl%7D%0A%5Chat%7B%5Cmu%7D_%7B1%7D%20%5C%5C%0A%5Chat%7B%5Cmu%7D_%7B2%7D%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BW%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BW%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A" /></p><p>这种解决方法也称为 <strong>再参数化</strong> (<em>reparameterization</em>)</p>
<p><strong>第二种方法</strong>：我们需要添加一个约束条件，我们定义加了约束条件的参数为 <img src="https://math.now.sh?inline=%5Cmu%5E%7B*%7D%2C%20%5Ctau_%7B1%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Ctau_%7B2%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/>，约束条件为  <img src="https://math.now.sh?inline=%5Ctau_%7B1%7D%5E%7B*%7D%2B%5Ctau_%7B2%7D%5E%7B*%7D%3D0" style="display:inline-block;margin: 0;"/> 。此时定义的 <img src="https://math.now.sh?inline=%5Cmu%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 有一个特殊含义， 表示采用处理后的新的均值，而 <img src="https://math.now.sh?inline=%5Ctau_%7B1%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Ctau_%7B2%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 表示对这个均值的偏差。采用这个限制条件，上面的例子可以<strong>唯一</strong>的表示为</p>
<p style=""><img src="https://math.now.sh?from=y_%7B1%20j%7D%3D17-1%2B%5Cvarepsilon_%7B1%20j%7D%2C%20%5Cquad%20y_%7B2%20j%7D%3D17%2B1%2B%5Cvarepsilon_%7B2%20j%7D%20.%0A" /></p><p>这种约束条件通常称为 <strong>附加条件</strong> (<em>side conditions</em>) ，我们可以将上面的模型用 <img src="https://math.now.sh?inline=%5Ctau_%7B2%7D%5E%7B*%7D%3D-%5Ctau_%7B1%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 表示为</p>
<p><img src="https://math.now.sh?inline=y_%7B1%20j%7D%3D%5Cmu%5E%7B*%7D%2B%5Ctau_%7B1%7D%5E%7B*%7D%2B%5Cvarepsilon_%7B1%20j%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=y_%7B2%20j%7D%3D%5Cmu%5E%7B*%7D-%5Ctau_%7B1%7D%5E%7B*%7D%2B%5Cvarepsilon_%7Bi%20j%7D" style="display:inline-block;margin: 0;"/> ，观测值向量可以表示为</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bl%7D%0Ay_%7B11%7D%20%5C%5C%0Ay_%7B12%7D%20%5C%5C%0Ay_%7B13%7D%20%5C%5C%0Ay_%7B21%7D%20%5C%5C%0Ay_%7B22%7D%20%5C%5C%0Ay_%7B23%7D%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cbegin%7Barray%7D%7Brr%7D%0A1%20%26%201%20%5C%5C%0A1%20%26%201%20%5C%5C%0A1%20%26%201%20%5C%5C%0A1%20%26%20-1%20%5C%5C%0A1%20%26%20-1%20%5C%5C%0A1%20%26%20-1%0A%5Cend%7Barray%7D%5Cright)%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmu%5E%7B*%7D%20%5C%5C%0A%5Ctau_%7B1%7D%5E%7B*%7D%0A%5Cend%7Barray%7D%5Cright)%2B%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cvarepsilon_%7B11%7D%20%5C%5C%0A%5Cvarepsilon_%7B12%7D%20%5C%5C%0A%5Cvarepsilon_%7B13%7D%20%5C%5C%0A%5Cvarepsilon_%7B21%7D%20%5C%5C%0A%5Cvarepsilon_%7B22%7D%20%5C%5C%0A%5Cvarepsilon_%7B23%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>或者</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%5E%7B*%7D%20%5Cboldsymbol%7B%5Cmu%7D%5E%7B*%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 是一个满秩矩阵，因此可以得到唯一的一个参数估计值。但是需要注意，添加的约束条件相当于对参数做了一个新的定义。</p>
<p><strong>第三种方法</strong>：我们从之前的结果可以看到，一些参数的线性组合的值是唯一的。比如 <img src="https://math.now.sh?inline=%5Ctau_%7B1%7D-%5Ctau_%7B2%7D%3D-2%2C%20%5Cquad%20%5Cmu%2B%5Ctau_%7B1%7D%3D16" style="display:inline-block;margin: 0;"/>  和 <img src="https://math.now.sh?inline=%5Cmu%2B%5Ctau_%7B2%7D%3D18" style="display:inline-block;margin: 0;"/> 对于所有可能的参数的值均成立，因为我们可以估计这种唯一的线性组合的值。</p>
<h2 id="双变量模型">双变量模型</h2>
<p>和单变量相比无新增内容，略</p>
<h1>估计参数</h1>
<p>在这一章节中，我们考虑不满秩的模型 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> 的参数 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的估计。这里我们采用再参数化或者添加约束条件，这里也不假设正态分布。</p>
<h2 id="估计-boldsymbol-beta">估计  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/></h2>
<p>我们将其一般化，考虑固定模型</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D%2C%0A" /></p><p>根据最小二乘，存在正规方程组</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 且秩为 <img src="https://math.now.sh?inline=k%20%3C%20p%20%5Cleq%20n" style="display:inline-block;margin: 0;"/> 的矩阵，即不满秩，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 无逆矩阵，正规方程组无唯一解。但是，我们可以证明 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 有解（无穷多解）。</p>
<p>根据广义逆的性质，对于线性方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7BAx%20%3Dc%20%7D" style="display:inline-block;margin: 0;"/> ，当且仅当对于任意一个 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B-%7D" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20A%7D%5E%7B-%7D%20%5Cmathbf%7Bc%7D%3D%5Cmathbf%7Bc%7D" style="display:inline-block;margin: 0;"/>  均成立时，方程组才相容。因此我们只需要证明  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，这里 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 是任意一个广义逆，根据广义逆性质我们知道 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，因此该式子成立，正规方程组相容。</p>
<p>既然正规方程组相容，那么它的一个解可以用广义逆表示为</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 是  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的任意一个广义逆。此时 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 的期望值为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%28%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29%20%26%3D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20E(%5Cmathbf%7By%7D)%20%5C%5C%0A%26%3D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>因为 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cneq%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ，因此  <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的一个<strong>有偏估计值</strong>。并且 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 会随着  <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/>  的选择而发生改变，也就是说，每一个选中的 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 的 <img src="https://math.now.sh?inline=E%28%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29" style="display:inline-block;margin: 0;"/> 均不相同。</p>
<p>我们可以进一步证明，此时所有的 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的线性组合均不是  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的无偏估计值。假设我们存在一个 <img src="https://math.now.sh?inline=p%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 使得 <img src="https://math.now.sh?inline=E%28%5Cmathbf%7BA%20y%7D%29%3D%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> ，那么</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Cbeta%7D%3DE%28%5Cmathbf%7BA%20y%7D%29%3DE%5B%5Cmathbf%7BA%7D(%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D)%5D%3DE(%5Cmathbf%7BA%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%2B%5Cmathbf%7BA%7D%20E(%5Cboldsymbol%7B%5Cvarepsilon%7D)%3D%5Cmathbf%7BA%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%0A" /></p><p>该式对所有可能的 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 均成立，因此我们有 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20X%7D%3D%5Cmathbf%7BI%7D_%7Bp%7D" style="display:inline-block;margin: 0;"/> 。但是我们知道 <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28%20%5Cmathbf%7BA%7D%20%5Cmathbf%7BX%7D%29%20%5Cleq%20%5Coperatorname%7Brank%7D(%5Cmathbf%7BX%7D)%20%3D%20k%20%3C%20p" style="display:inline-block;margin: 0;"/> ，而 <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28%20%5Cmathbf%7BI%7D_%7Bp%7D%20%29%20%3D%20p" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20X%7D" style="display:inline-block;margin: 0;"/> 不可能等于 <img src="https://math.now.sh?inline=%5Cmathbf%7BI%7D_%7Bp%7D" style="display:inline-block;margin: 0;"/> ，因此我们证明没有一个  <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的线性组合是  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的无偏估计值 ，得证。</p>
<h2 id="估计-boldsymbol-beta-的函数">估计  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的函数</h2>
<p>上面我们证明了我们无法估计 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> ，那么我们能不能估计任何一个  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的线性组合呢？也就是说，估计  $ \boldsymbol{\lambda^{\prime} \boldsymbol{\beta}}$ 。</p>
<p>如果存在一个观测值 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的线性组合的期望等于  $ \boldsymbol{\lambda^{\prime} \boldsymbol{\beta}}$ ，我们就称这个参数的线性组合  $ \boldsymbol{\lambda^{\prime} \boldsymbol{\beta}}$ 是<strong>可估计的</strong> (<em>estimable</em>) ，也就是说，存在一个向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D" style="display:inline-block;margin: 0;"/> ，使得下式成立</p>
<p style=""><img src="https://math.now.sh?from=E%5Cleft%28%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%0A" /></p><p>在下面的定理中，我们用三种方法来确定是否一个线性函数  $ \boldsymbol{\lambda^{\prime} \boldsymbol{\beta}}$  是可以估计的。</p>
<p><strong>定理</strong>：在模型  <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> 中，其中 <img src="https://math.now.sh?inline=E%28%5Cmathbf%7By%7D%29%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的秩为 $k &lt; p \leq n $ 的矩阵。那么当且仅当下面任何一个等式条件成立时，线性函数 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 可估计。</p>
<p>(1) <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的行的线性组合，也就是说存在一个向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D" style="display:inline-block;margin: 0;"/> 使得下式成立</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Ba%7D%20%3D%5Cboldsymbol%7B%5Clambda%7D%20%5CRightarrow%20%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%0A" /></p><p>(2)  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的行的线性组合，或者 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/>  是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的列的线性组合，也就是说，存在一个向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D" style="display:inline-block;margin: 0;"/> 使得</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cquad%20%5Ctext%20%7B%20or%20%7D%20%5Cquad%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D%3D%5Cboldsymbol%7B%5Clambda%7D%0A" /></p><p>(3) <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> 或者 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 满足下式</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cboldsymbol%7B%5Clambda%7D%3D%5Cboldsymbol%7B%5Clambda%7D%20%5Cquad%20%5Ctext%20%7B%20or%20%7D%20%5Cquad%20%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 是  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/>  的任何一个（对称的）广义逆。</p>
<p><strong>证明</strong>：对于 (1) ，我们同时证明 “if” 和 “only if” ；对于 (2) 和 (3) ，这里只证明了  “if” 部分。</p>
<p>(1) 如果存在一个向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D" style="display:inline-block;margin: 0;"/> 使得 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%3D%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> ，那么我没有</p>
<p style=""><img src="https://math.now.sh?from=E%5Cleft%28%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%3D%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20E(%5Cmathbf%7By%7D)%3D%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%0A" /></p><p>反过来，如果 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 可估计，那么存在一个向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D" style="display:inline-block;margin: 0;"/> 使得 <img src="https://math.now.sh?inline=E%5Cleft%28%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 对于所有可能的 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 均成立，因此 $\mathbf{a}^{\prime} \mathbf{X}=\boldsymbol{\lambda}^{\prime} $</p>
<p>(2) 如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D%3D%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> ，通过定义 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%3D%5Cmathbf%7BX%20r%7D" style="display:inline-block;margin: 0;"/> ，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%5Cleft%28%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%20%26%3DE%5Cleft(%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright)%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20E(%5Cmathbf%7By%7D)%20%5C%5C%0A%26%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>(3) 如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cboldsymbol%7B%5Clambda%7D%3D%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> ，那么 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> 就是上面 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%20r%7D%3D%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> 的一个解。</p>
<p>根据这个定理第一条等式，我们知道对于 <img src="https://math.now.sh?inline=i%3D1%2C2%2C%20%5Cldots%2C%20n" style="display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 均可估计，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D_%7Bi%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 是矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行。因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的每一行 (元素) 均是可估计的，我们可以说  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 本身是可以估计的。同样地，根据第二条等式，我们得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的每一行 (元素) 均是可估计的，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 也是可估计的。反过来说，所有的可估计函数都可以从 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 或 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 中得到。</p>
<p>如果系数向量 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D_%7B1%7D%2C%20%5Cboldsymbol%7B%5Clambda%7D_%7B2%7D%2C%20%5Cldots%2C%20%5Cboldsymbol%7B%5Clambda%7D_%7Bm%7D" style="display:inline-block;margin: 0;"/> 之间线性无关，那么这些线性函数 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2C%20%5Cboldsymbol%7B%5Clambda%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2C%20%5Cldots%2C%20%5Cboldsymbol%7B%5Clambda%7D_%7Bm%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 称为线性无关的。下面的定理给出了线性无关的可估计函数的数目。</p>
<p><strong>定理</strong>：在不满秩的模型 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> 中，线性无关的可估计函数的数目等于 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的秩。</p>
<p>缺证明，见 Graybill (1976, pp. 485 – 486)</p>
<h1>估计值</h1>
<h2 id="boldsymbol-lambda-prime-boldsymbol-beta-的估计值">$ \boldsymbol{\lambda^{\prime} \boldsymbol{\beta}}$ 的估计值</h2>
<p>根据上面的定理第一条和第二条，我们有 <img src="https://math.now.sh?inline=%5Clambda%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的估计值 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 满足 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%3D%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 。 <img src="https://math.now.sh?inline=%5Clambda%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 第三个估计值就是 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> ，其中<img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的任意一个解。在下面的定理，我们讨论 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 的一些性质，我们不会讨论 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的性质，因为这个式子不能保证有最小方差（个人理解 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 中的 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 是不唯一的，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 不一定满足最小方差）。</p>
<p><strong>定理</strong>：如果 $ \boldsymbol{\lambda^{\prime} \boldsymbol{\beta}}$ 是不满秩模型的一个可估计函数，设 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 是正规方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的任意一个解，<img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D%3D%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> 的任意一个解。那么两个估计值 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 有下面的性质：</p>
<ol>
<li><img src="https://math.now.sh?inline=E%5Cleft%28%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5Cright%29%3DE%5Cleft(%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright)%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/></li>
<li>对于任意一个 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 或 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D" style="display:inline-block;margin: 0;"/>  ，<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%20%3D%20%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/></li>
<li><img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的值不会随着 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 或 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D" style="display:inline-block;margin: 0;"/> 的选择而改变。</li>
</ol>
<p>证明：</p>
<p>(1) 我们有</p>
<p style=""><img src="https://math.now.sh?from=E%5Cleft%28%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5Cright%29%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20E(%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%0A" /></p><p>根据上面的定理的第三条等式，我们有 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，因此</p>
<p style=""><img src="https://math.now.sh?from=E%5Cleft%28%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5Cright%29%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%0A" /></p><p>同样地，我们有</p>
<p style=""><img src="https://math.now.sh?from=E%5Cleft%28%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20E(%5Cmathbf%7By%7D)%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%0A" /></p><p>(2) 对于正规方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 乘以 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A" /></p><p>因为  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/>  ，带入得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A" /></p><p>(3) 为了证明 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 与 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D" style="display:inline-block;margin: 0;"/> 的选择无关，设 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> 满足 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D_%7B1%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D_%7B2%7D%3D%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> ，那么</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Br%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7Br%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%5Cquad%20%5Ctext%20%7B%20and%20%7D%20%5Cquad%20%5Cmathbf%7Br%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7Br%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A" /></p><p>因为 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cmathbf%7Br%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> ，因此我们有 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%3D%5Cmathbf%7Br%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>同样的，我们可以证明  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 的值不会随着  <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 的选择而改变，设  <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7B1%7D%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7B2%7D%7D" style="display:inline-block;margin: 0;"/>  是正规方程组  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/>  的两个解，那么</p>
<p>根据上面定理，我们知道存在一个向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D" style="display:inline-block;margin: 0;"/> ，使得 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 。 因此</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7B1%7D%7D%20%3D%20%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7B1%7D%7D%20%3D%20%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7B2%7D%7D%20%3D%20%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7B2%7D%7D%20%3D%20%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A" /></p><p>因此  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7B1%7D%7D%20%20%3D%20%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7B2%7D%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>估计值 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/>  或  <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的方差有以下定理。</p>
<p><strong>定理</strong>：<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 是不满秩模型 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> 的一个可估计函数，<img src="https://math.now.sh?inline=%5Coperatorname%7Bcov%7D%28%5Cmathbf%7By%7D%29%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%20r%7D%3D%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> 的一个解， <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 是  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的一个解，那么 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/>  或  <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的方差有以下性质：</p>
<p>(1) <img src="https://math.now.sh?inline=%5Coperatorname%7Bvar%7D%5Cleft%28%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Clambda%7D%20%3D%20%5Csigma%5E%7B2%7D%20%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/><br>
(2) <img src="https://math.now.sh?inline=%5Coperatorname%7Bvar%7D%5Cleft%28%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5Cright%29%3D%5Csigma%5E%7B2%7D%20%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/><br>
( 3) <img src="https://math.now.sh?inline=%5Coperatorname%7Bvar%7D%5Cleft%28%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Coperatorname%7Bvar%7D%5Cleft%28%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 值唯一，也就是说与 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D" style="display:inline-block;margin: 0;"/> 或 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/>的选择无关，因此 <img src="https://math.now.sh?inline=%5Coperatorname%7Bvar%7D%5Cleft%28%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%20%3D%20%5Coperatorname%7Bvar%7D%5Cleft(%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5Cright)" style="display:inline-block;margin: 0;"/> 。</p>
<p><strong>证明</strong>：</p>
<p>(1)</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Bvar%7D%5Cleft%28%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%20%26%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Coperatorname%7Bcov%7D(%5Cmathbf%7By%7D)%20%5Cmathbf%7BX%20r%7D%20%20%5C%5C%0A%26%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cleft(%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D%5Cright)%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D%5C%5C%0A%26%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D%20%5C%5C%0A%26%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Clambda%7D%20%0A%5Cend%7Baligned%7D%0A" /></p><p>(2)</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Bvar%7D%5Cleft%28%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5Cright%29%20%26%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Coperatorname%7Bcov%7D(%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%20%5Cboldsymbol%7B%5Clambda%7D%20%5C%5C%0A%26%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Coperatorname%7Bcov%7D(%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D)%20%5Cboldsymbol%7B%5Clambda%7D%20%5C%5C%0A%26%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%20%5Coperatorname%7Bcov%7D(%5Cmathbf%7By%7D)%20%5Cmathbf%7BX%7D%20%20%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cboldsymbol%7B%5Clambda%7D%20%5C%5C%0A%26%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%20(%5Csigma%5E2%20%5Cmathbf%7BI%7D)%20%5Cmathbf%7BX%7D%20%20%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cboldsymbol%7B%5Clambda%7D%20%5C%5C%0A%26%3D%5Csigma%5E%7B2%7D%20%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cboldsymbol%7B%5Clambda%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>根据定理 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/>，因此</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Bvar%7D%5Cleft%28%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5Cright%29%3D%5Csigma%5E%7B2%7D%20%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cboldsymbol%7B%5Clambda%7D%0A" /></p><p>(3)  为了 证明 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> 与 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D" style="display:inline-block;margin: 0;"/> 无关，设  <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> 满足 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%20r%7D_%7B1%7D%3D%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D_%7B2%7D%3D%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> 。这两个等式分别乘以 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D_%7B2%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D_%7B1%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Br%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%20r%7D_%7B1%7D%3D%5Cmathbf%7Br%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Clambda%7D%20%5Cquad%20%5Ctext%20%7B%20and%20%7D%20%5Cquad%20%5Cmathbf%7Br%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%20r%7D_%7B2%7D%3D%5Cmathbf%7Br%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Clambda%7D%20.%0A" /></p><p>这两个式子的左手项互为转置且为标量，因此二者相等，因此右手项也相等，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Br%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Clambda%7D%3D%5Cmathbf%7Br%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Clambda%7D%0A" /></p><p>为了证明 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> 与 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 的选择无关，设 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的两个广义逆，根据广义逆的性质，无论 <img src="https://math.now.sh?inline=%28%5Cmathbf%7BA%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BA%7D%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 取何值， <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5Cleft%28%5Cmathbf%7BA%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BA%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BA%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/>  均保持不变（缺证明）。因此我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%20G%7D_%7B1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%3D%5Cmathbf%7BX%7D%20%5Cmathbf%7BG%7D_%7B2%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%0A" /></p><p>两边均乘以 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D" style="display:inline-block;margin: 0;"/> 使得  <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%20G%7D_%7B1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Ba%7D%20%26%3D%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%20G%7D_%7B2%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Ba%7D%2C%20%5C%5C%0A%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BG%7D_%7B1%7D%20%5Cboldsymbol%7B%5Clambda%7D%20%26%3D%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BG%7D_%7B2%7D%20%5Cboldsymbol%7B%5Clambda%7D%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>得证。</p>
<p>两个可估计函数的估计值存在以下定理。</p>
<p><strong>定理</strong>：如果 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 是不满秩模型的两个可估计函数，<img src="https://math.now.sh?inline=%5Coperatorname%7Bcov%7D%28%5Cmathbf%7By%7D%29%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ，这两个可估计函数的估计值的协方差为</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Bcov%7D%5Cleft%28%5Cboldsymbol%7B%5Clambda%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%2C%20%5Cboldsymbol%7B%5Clambda%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5Cright%29%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7Br%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Clambda%7D_%7B2%7D%3D%5Csigma%5E%7B2%7D%20%5Cboldsymbol%7B%5Clambda%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Br%7D_%7B2%7D%3D%5Csigma%5E%7B2%7D%20%5Cboldsymbol%7B%5Clambda%7D_%7B1%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cboldsymbol%7B%5Clambda%7D_%7B2%7D%2C%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D_%7B1%7D%3D%5Cboldsymbol%7B%5Clambda%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D_%7B2%7D%3D%5Cboldsymbol%7B%5Clambda%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> 。缺证明。</p>
<p><strong>定理</strong>：如果 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 是不满秩模型的一个可估计函数，<img src="https://math.now.sh?inline=%5Coperatorname%7Bcov%7D%28%5Cmathbf%7By%7D%29%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ， 那么估计值 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 是 <strong>BLUE</strong> 值。</p>
<p>证明：假设 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 可以表示为 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，我们表示 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> (为什么这是一个一般的式子?)，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7Br%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%20r%7D%3D%5Cboldsymbol%7B%5Clambda%7D" style="display:inline-block;margin: 0;"/> 的一个解。为了确保无偏性，我们必须保证</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3DE%5Cleft%28%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%3D%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cleft(%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%2B%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cleft(%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%20%5Cboldsymbol%7B%5Cbeta%7D%0A" /></p><p>该式必须对所有 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 均成立，因此我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cmathbf%7B0%7D%5E%7B%5Cprime%7D%0A" /></p><p>我们进一步得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Bvar%7D%5Cleft%28%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%20%26%3D%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Coperatorname%7Bcov%7D(%5Cmathbf%7By%7D)%20%5Cmathbf%7Ba%7D%3D%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D%20%5Cmathbf%7Ba%7D%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Ba%7D%20%5C%5C%0A%26%3D%5Csigma%5E%7B2%7D%5Cleft(%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%5Cright)(%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D%2B%5Cmathbf%7Bc%7D)%20%5C%5C%0A%26%3D%5Csigma%5E%7B2%7D%5Cleft(%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D%2B%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bc%7D%2B%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D%2B%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bc%7D%5Cright)%20%5C%5C%0A%26%3D%5Csigma%5E%7B2%7D%5Cleft(%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7Br%7D%2B%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bc%7D%5Cright)%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>因此为了最小化 <img src="https://math.now.sh?inline=%5Coperatorname%7Bvar%7D%5Cleft%28%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29" style="display:inline-block;margin: 0;"/> ，我们只能使得 <img src="https://math.now.sh?inline=%5Cmathbf%7Bc%7D%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> ，此时满足 <img src="https://math.now.sh?inline=%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cmathbf%7B0%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 。因此  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/>  的 BLUE 值就是 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%3D%5Cmathbf%7Br%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>这个证明感觉不够好，不够清晰。</p>
<h2 id="sigma-2-的估计值"><img src="https://math.now.sh?inline=%5Csigma%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 的估计值</h2>
<p>SSE 计算公式为</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BSSE%7D%3D%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29%5E%7B%5Cprime%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的任意一个解。SSE 的另外两个表达式为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0A%5Cmathrm%7BSSE%7D%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D-%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%5Cmathrm%7BSSE%7D%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%5Cleft%5B%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%20%5Cmathbf%7By%7D%0A%5Cend%7Bgathered%7D%0A" /></p><p>我们定义 <img src="https://math.now.sh?inline=s%5E2" style="display:inline-block;margin: 0;"/> 作为 <img src="https://math.now.sh?inline=%5Csigma%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 的估计值，计算公式为</p>
<p style=""><img src="https://math.now.sh?from=s%5E%7B2%7D%3D%5Cfrac%7B%5Cmathrm%7BSSE%7D%7D%7Bn-k%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵的行数，<img src="https://math.now.sh?inline=k%3D%5Coperatorname%7Brank%7D%28%5Cmathbf%7BX%7D%29" style="display:inline-block;margin: 0;"/></p>
<p><img src="https://math.now.sh?inline=s%5E2" style="display:inline-block;margin: 0;"/> 的两个性质表示为以下定理。</p>
<p><strong>定理</strong>：在不满秩模型中定义的 <img src="https://math.now.sh?inline=s%5E2" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Coperatorname%7Bcov%7D%28%5Cmathbf%7By%7D%29%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ，我们有以下性质：</p>
<p>(1) <img src="https://math.now.sh?inline=E%5Cleft%28s%5E%7B2%7D%5Cright%29%3D%5Csigma%5E%7B2%7D" style="display:inline-block;margin: 0;"/></p>
<p>(2) <img src="https://math.now.sh?inline=s%5E2" style="display:inline-block;margin: 0;"/> 不会随着 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 或  <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 的选择而改变</p>
<p>证明：</p>
<p>(1) 根据公式，我们有 <img src="https://math.now.sh?inline=E%28%5Cmathrm%7BSSE%7D%29%3DE%5Cleft%5C%7B%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%5Cleft%5B%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%20%5Cmathbf%7By%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> ，根据二次型的期望计算公式 $E\left(\mathbf{y}^{\prime} \mathbf{A} \mathbf{y}\right)=\operatorname{tr}(\mathbf{A} \mathbf{\Sigma})+\boldsymbol{\mu}^{\prime} \mathbf{A} \boldsymbol{\mu} $ ，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%28%5Cmathrm%7BSSE%7D%29%26%3D%5Coperatorname%7Btr%7D%5Cleft%5C%7B%5Cleft%5B%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%5Cleft(%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D%5Cright)%5Cright%5C%7D%2B%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cleft%5B%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft%5C%7B%5Cleft%5B%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%5Cleft(%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D%5Cright)%5Cright%5C%7D%2B%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20-%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft%5C%7B%5Cleft%5B%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%5Cleft(%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D%5Cright)%5Cright%5C%7D%20%5C%5C%0A%0A%26%3D%5Csigma%5E%7B2%7D%5Cleft%5C%7B%5Coperatorname%7Btr%7D(%5Cmathbf%7BI%7D)-%5Coperatorname%7Btr%7D%5Cleft%5B%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%5Cright%5D%5Cright%5C%7D%20%5C%5C%0A%26%3D(n-k)%20%5Csigma%5E%7B2%7D%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=k%3D%5Coperatorname%7Brank%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%3D%5Coperatorname%7Brank%7D(%5Cmathbf%7BX%7D)" style="display:inline-block;margin: 0;"/> 。</p>
<p>这里少了一步证明，就是 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%5B%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%5Cright%5D%20%3D%20k" style="display:inline-block;margin: 0;"/> 的证明，首先根据广义逆的性质，我们有 <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%5Cleft%28%5Cmathbf%7BA%7D%5E%7B-%7D%20%5Cmathbf%7BA%7D%5Cright%29%3D%5Coperatorname%7Brank%7D%5Cleft(%5Cmathbf%7BA%7D%20%5Cmathbf%7BA%7D%5E%7B-%7D%5Cright)%3D%5Coperatorname%7Brank%7D(%5Cmathbf%7BA%7D)%3Dr" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%5Cleft%5B%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%5Cright%5D%20%3D%20k" style="display:inline-block;margin: 0;"/> 。而 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 同时是一个幂等矩阵，因此 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%5B%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%5Cright%5D%20%3D%5Coperatorname%7Brank%7D%5Cleft%5B%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%5Cright%5D%20%3D%20k" style="display:inline-block;margin: 0;"/>  。</p>
<p>(2) 因为 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 可估计，因此 <img src="https://math.now.sh?inline=X%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 对于不同的  <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/>  具有不变性，因此 <img src="https://math.now.sh?inline=%5Cmathrm%7BSSE%7D%3D%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29%5E%7B%5Cprime%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)" style="display:inline-block;margin: 0;"/> 具有不变性。从另一个公式来说，<img src="https://math.now.sh?inline=%5Cmathrm%7BSSE%7D%3D%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%5Cleft%5B%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 中的 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 也具有不变性，同样可证明 SSE 具有不变性，因此 <img src="https://math.now.sh?inline=s%5E2" style="display:inline-block;margin: 0;"/> 具有不变性。</p>
<h2 id="假设正态分布的模型">假设正态分布的模型</h2>
<p>对于不满秩的模型 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> ，我们现在假设</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%20%5Ctext%20%7B%20is%20%7D%20N_%7Bn%7D%5Cleft%28%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2C%20%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D%5Cright%29%20%5Cquad%20%5Ctext%20%7B%20or%20%7D%20%5Cquad%20%5Cboldsymbol%7B%5Cvarepsilon%7D%20%5Ctext%20%7B%20is%20%7D%20N_%7Bn%7D%5Cleft(%5Cmathbf%7B0%7D%2C%20%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D%5Cright)%0A" /></p><p>新增了正态分布假设后，我们现在可以计算得到最大似然估计值。</p>
<p><strong>定理</strong>：如果 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%20%5Csim%20%20N_%7Bn%7D%5Cleft%28%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2C%20%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D%5Cright%29" style="display:inline-block;margin: 0;"/>  ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的秩为 <img src="https://math.now.sh?inline=k%20%3C%20p%20%5Cleq%20n" style="display:inline-block;margin: 0;"/> 的矩阵，那么 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Csigma%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 的最大似然估计值为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0A%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%2C%20%5C%5C%0A%5Chat%7B%5Csigma%7D%5E%7B2%7D%3D%5Cfrac%7B1%7D%7Bn%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%5E%7B%5Cprime%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%20.%0A%5Cend%7Bgathered%7D%0A" /></p><p><strong>证明</strong>：不满秩模型和满秩模型一样，其似然函数和对数似然函数为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0AL%5Cleft%28%5Cboldsymbol%7B%5Cbeta%7D%2C%20%5Csigma%5E%7B2%7D%5Cright%29%3D%5Cfrac%7B1%7D%7B%5Cleft(2%20%5Cpi%20%5Csigma%5E%7B2%7D%5Cright)%5E%7Bn%20%2F%202%7D%7D%20e%5E%7B-(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%5E%7B%5Cprime%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%20%2F%202%20%5Csigma%5E%7B2%7D%7D%2C%20%5C%5C%0A%5Cln%20L%5Cleft(%5Cboldsymbol%7B%5Cbeta%7D%2C%20%5Csigma%5E%7B2%7D%5Cright)%3D-%5Cfrac%7Bn%7D%7B2%7D%20%5Cln%20(2%20%5Cpi)-%5Cfrac%7Bn%7D%7B2%7D%20%5Cln%20%5Csigma%5E%7B2%7D-%5Cfrac%7B1%7D%7B2%20%5Csigma%5E%7B2%7D%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%5E%7B%5Cprime%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%20.%0A%5Cend%7Bgathered%7D%0A" /></p><p>求偏导，使之为0，得到（缺证明）</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%2C%20%5C%5C%0A%5Chat%7B%5Csigma%7D%5E%7B2%7D%3D%5Cfrac%7B1%7D%7Bn%7D%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29%5E%7B%5Cprime%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%2C%0A%5Cend%7Bgathered%7D%0A" /></p><p>这里 $\hat{\boldsymbol{\beta}} $ 是任意一个解，即</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A" /></p><p>同样的，这里 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 与最小二乘估计值一样，但是 <img src="https://math.now.sh?inline=%5Chat%7B%5Csigma%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 是<strong>有偏的</strong>。</p>
<p>下面的定理给出最大似然估计值的一些性质。</p>
<p><strong>定理</strong>：上面的最大似然估计值有以下性质</p>
<p>(1) <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> is <img src="https://math.now.sh?inline=N_%7Bp%7D%5Cleft%5B%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2C%20%5Csigma%5E%7B2%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%5Cright%5D%20." style="display:inline-block;margin: 0;"/><br>
(2) <img src="https://math.now.sh?inline=%28n-k%29%20s%5E%7B2%7D%20%2F%20%5Csigma%5E%7B2%7D" style="display:inline-block;margin: 0;"/> is <img src="https://math.now.sh?inline=%5Cchi%5E%7B2%7D%28n-k%29" style="display:inline-block;margin: 0;"/>.<br>
(3) <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> and <img src="https://math.now.sh?inline=s%5E%7B2%7D" style="display:inline-block;margin: 0;"/> are independent.</p>
<p>缺证明，证明过程与满秩模型应该差不多。注意到 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 的均值和协方差矩阵等都受到  <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 选择的影响，而 <img src="https://math.now.sh?inline=s%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 则对于  <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/>  或  <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/>  的选择具有不变性。</p>
<p><strong>定理</strong>：对于正态分布假设下的不满秩模型，如果 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 是一个可估计函数，那么 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 在所有的无偏估计值中具有最小的方差（注意，没有线性两个字）。</p>
<p>如果没有正态假设，那么  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/>  仅仅是 <strong>BLUE</strong> , 也就是<strong>线性</strong>无偏估计值中方差最小的。但是满足正态假设后，  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Clambda%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/>  是 <strong>BUE</strong> ，是所有无偏估计值中方差最小的 。</p>
<h1>不满秩模型中最小二乘估计值的几何含义</h1>
<p>不满秩模型类似与满秩模型，但是有一些重要的差别。</p>
<p>我们还是有三个空间，参数空间，数据空间和预测空间。<img src="https://math.now.sh?inline=n%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 可以拆分为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D%3D%5Cleft%28%5Cmathbf%7Bx%7D_%7B1%7D%2C%20%5Cmathbf%7Bx%7D_%7B2%7D%2C%20%5Cldots%2C%20%5Cmathbf%7Bx%7D_%7Bp%7D%5Cright%29%0A" /></p><p>矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的每一列均是数据空间中的向量，但是由于 <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28%5Cmathbf%7BX%7D%29%3Dk%3Cp" style="display:inline-block;margin: 0;"/> ，因此这些列向量之间不是线性独立的，但是预测空间还是由这些列的所有可能的线性组合组成。此时，参数空间的维度是 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> ，但是预测空间的维度是 <img src="https://math.now.sh?inline=k%20%3C%20p" style="display:inline-block;margin: 0;"/> 。因此，矩阵乘积  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%20u%7D" style="display:inline-block;margin: 0;"/> ，这里 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> 是参数空间的任意一个向量，是一个从参数空间到预测空间的<strong>多对一</strong>的映射（根据矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 列向量之间的线性相关的关系，易知存在多个不同的  <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> 可以得到相同的乘积）。</p>
<p>根据模型设定  <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/>  ，其中 <img src="https://math.now.sh?inline=E%28%5Cmathbf%7By%7D%29%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> , 根据最小二乘的思想，我们想从预测空间找到一个 <img src="https://math.now.sh?inline=E%28%5Cmathbf%7By%7D%29" style="display:inline-block;margin: 0;"/> 的估计值  <img src="https://math.now.sh?inline=%5Chat%7B%5Cmathbf%7By%7D%7D" style="display:inline-block;margin: 0;"/>  ，使得其与 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的距离最近。这里我们同样需要需要满足  <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cvarepsilon%7D%7D%3D%5Cmathbf%7By%7D-%5Chat%7B%5Cmathbf%7By%7D%7D" style="display:inline-block;margin: 0;"/> 与预测空间正交，因此同样有 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cvarepsilon%7D%7D%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> ，得到正规方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>然后我们再根据这个  <img src="https://math.now.sh?inline=%5Chat%7B%5Cmathbf%7By%7D%7D" style="display:inline-block;margin: 0;"/>  ，推导 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的估计值。由于这里是<strong>多对一</strong>的映射，因此可以得到   <img src="https://math.now.sh?inline=%5Chat%7B%5Cmathbf%7By%7D%7D" style="display:inline-block;margin: 0;"/>  的  <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 不唯一，求解正规方程组，得到 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，也就是说我们有无穷多个解。但是<strong>注意 <img src="https://math.now.sh?inline=%5Chat%7B%5Cmathbf%7By%7D%7D%3D%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 是唯一的</strong>。</p>
<h1>再参数化</h1>
<p>我们现在来正式地了解一下再参数化的例子。在再参数化中，我们将一个不满秩的模型 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的秩为 <img src="https://math.now.sh?inline=k%20%3C%20p%20%5Cleq%20n" style="display:inline-block;margin: 0;"/> 的矩阵，转化为一个满秩的模型 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%5Cmathbf%7BZ%7D%20%5Cboldsymbol%7B%5Cgamma%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20k" style="display:inline-block;margin: 0;"/> 的秩为 $k $ 的矩阵，并且 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cgamma%7D%3D%5Cmathbf%7BU%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 是由 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 个<strong>线性独立的</strong> <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的可估计函数组成的向量。因此我们可以写作</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BZ%7D%20%5Cboldsymbol%7B%5Cgamma%7D%3D%5Cmathbf%7BZ%7D%20%5Cboldsymbol%7BU%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%3D%5Cmathbf%7BZ%20U%7D" style="display:inline-block;margin: 0;"/> ，由于 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=k%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的秩为 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 的矩阵（秩为 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> ，是因为根据要求， <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 的行彼此独立），因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D%20%5Cmathbf%7BU%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 是一个非奇异矩阵，我们可以对 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%20U%7D%3D%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 乘以 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 来得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 的表达式</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BZ%7D%20%5Cmathbf%7BU%7D%20%5Cmathbf%7BU%7D%5E%7B%5Cprime%7D%20%26%3D%5Cmathbf%7BX%7D%20%5Cmathbf%7BU%7D%5E%7B%5Cprime%7D%20%5C%5C%0A%5Cmathbf%7BZ%7D%20%26%3D%5Cmathbf%7BX%7D%20%5Cmathbf%7BU%7D%5E%7B%5Cprime%7D%5Cleft%28%5Cmathbf%7BU%7D%20%5Cmathbf%7BU%7D%5E%7B%5Cprime%7D%5Cright%29%5E%7B-1%7D%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>我们可以证明  <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 满秩，我们有 <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28%5Cmathbf%7BZ%7D%29%20%5Cgeq%20%5Coperatorname%7Brank%7D(%5Cmathbf%7BZ%7D%20%5Cmathbf%7BU%7D)%3D%5Coperatorname%7Brank%7D(%5Cmathbf%7BX%7D)%3Dk" style="display:inline-block;margin: 0;"/> ，但是  <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 的秩最大值为 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> ，因此  <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 的秩为 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 。因此，<img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%5Cmathbf%7BZ%7D%20%5Cboldsymbol%7B%5Cgamma%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> 是一个满秩的模型，可以得到唯一的解 <img src="https://math.now.sh?inline=%5Chat%7B%5Cgamma%7D%3D%5Cleft%28%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>在再参数化的满秩模型中，<img src="https://math.now.sh?inline=%5Csigma%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 的无偏估计值为</p>
<p style=""><img src="https://math.now.sh?from=s%5E%7B2%7D%3D%5Cfrac%7B1%7D%7Bn-k%7D%28%5Cmathbf%7By%7D-%5Cmathbf%7BZ%7D%20%5Chat%7B%5Cgamma%7D%29%5E%7B%5Cprime%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BZ%7D%20%5Chat%7B%5Cgamma%7D)%0A" /></p><p>因为 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D%20%5Cboldsymbol%7B%5Cgamma%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D%20%5Chat%7B%5Cgamma%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 也是相同的，也就是预测值是相同的。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BZ%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cgamma%7D%7D%3D%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%0A" /></p><p>然后两次计算的 SSE 也是相同的</p>
<p style=""><img src="https://math.now.sh?from=%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29%5E%7B%5Cprime%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%3D(%5Cmathbf%7By%7D-%5Cmathbf%7BZ%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cgamma%7D%7D)%5E%7B%5Cprime%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BZ%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cgamma%7D%7D)%0A" /></p><h1>附加条件</h1>
<p>通过添加<strong>附加条件</strong> (<em>side conditions</em>) 使得参数估计值唯一，此时得到的参数估计值<strong>与某个特定的广义逆参数估计值相同</strong>。</p>
<p>我们知道 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 可以理解为 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> 个可估计函数组成的向量，如果一个附加条件（的左手项）是一个可估计函数，那么这个附加条件（的左手项）可以表示为  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的行的线性组合，因此无法有助于改善 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的秩亏缺的状态，因此正规方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 还是没有唯一解 。因此，<strong>附加条件必须是一个不可估计函数</strong>。</p>
<p><img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的秩为 <img src="https://math.now.sh?inline=k%20%3C%20p%20%5Cleq%20n" style="display:inline-block;margin: 0;"/> 的矩阵，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 缺少的秩为 <img src="https://math.now.sh?inline=p-k" style="display:inline-block;margin: 0;"/> 。为了得到唯一估计值 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> ，我们需要添加附件条件使得 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 满秩。因此，我们定义附加条件 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> 或 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=%28p-k%29%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的秩为 <img src="https://math.now.sh?inline=p-k" style="display:inline-block;margin: 0;"/> 的矩阵，并且 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 是由<strong>不可估计函数</strong>组成的向量。</p>
<p><strong>定理</strong>：在满足上面的条件下，同时满足 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> 的参数估计值 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 是<strong>唯一的</strong>。</p>
<p><strong>证明</strong>：这里我们有两个方程组</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D%20%5C%5C%0A%26%5Cmathbf%7B0%7D%3D%5Cmathbf%7BT%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cmathbf%7B0%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>我们可以将其合并为一个</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7By%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BX%7D%20%5C%5C%0A%5Cmathbf%7BT%7D%0A%5Cend%7Barray%7D%5Cright)%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cboldsymbol%7B%5Cvarepsilon%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>因为矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D" style="display:inline-block;margin: 0;"/> 的行之间线性无关，并且不是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的行的线性函数，因此矩阵 <img src="https://math.now.sh?inline=%5Cleft%28%5Cbegin%7Barray%7D%7Bl%7D%5Cmathbf%7BX%7D%20%5C%5C%20%5Cmathbf%7BT%7D%5Cend%7Barray%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=%28n%2Bp-k%29%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的秩为 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> 的矩阵，也就是满秩矩阵。因此 <img src="https://math.now.sh?inline=%5Cleft%28%5Cbegin%7Barray%7D%7Bl%7D%5Cmathbf%7BX%7D%20%5C%5C%20%5Cmathbf%7BT%7D%5Cend%7Barray%7D%5Cright%29%5E%7B%5Cprime%7D%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%5Cmathbf%7BX%7D%20%5C%5C%20%5Cmathbf%7BT%7D%5Cend%7Barray%7D%5Cright)" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=p%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的秩为 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> 的矩阵，最小二乘的正规方程组</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BX%7D%20%5C%5C%0A%5Cmathbf%7BT%7D%0A%5Cend%7Barray%7D%5Cright%29%5E%7B%5Cprime%7D%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BX%7D%20%5C%5C%0A%5Cmathbf%7BT%7D%0A%5Cend%7Barray%7D%5Cright)%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BX%7D%20%5C%5C%0A%5Cmathbf%7BT%7D%0A%5Cend%7Barray%7D%5Cright)%5E%7B%5Cprime%7D%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7By%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>具有唯一解，为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%20%26%3D%5Cleft%5B%5Cleft%28%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BX%7D%20%5C%5C%0A%5Cmathbf%7BT%7D%0A%5Cend%7Barray%7D%5Cright%29%5E%7B%5Cprime%7D%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BX%7D%20%5C%5C%0A%5Cmathbf%7BT%7D%0A%5Cend%7Barray%7D%5Cright)%5Cright%5D%5E%7B-1%7D%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BX%7D%20%5C%5C%0A%5Cmathbf%7BT%7D%0A%5Cend%7Barray%7D%5Cright)%5E%7B%5Cprime%7D%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7By%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%0A%5Cend%7Barray%7D%5Cright)%20%5C%5C%0A%26%3D%5Cleft%5B%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%2C%20%5Cmathbf%7BT%7D%5E%7B%5Cprime%7D%5Cright)%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BX%7D%20%5C%5C%0A%5Cmathbf%7BT%7D%0A%5Cend%7Barray%7D%5Cright)%5Cright%5D%5E%7B-1%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%2C%20%5Cmathbf%7BT%7D%5E%7B%5Cprime%7D%5Cright)%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7By%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%0A%5Cend%7Barray%7D%5Cright)%20%5C%5C%0A%26%3D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%2B%5Cmathbf%7BT%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BT%7D%5Cright)%5E%7B-1%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%2B%5Cmathbf%7BT%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7B0%7D%5Cright)%20%5C%5C%0A%26%3D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%2B%5Cmathbf%7BT%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BT%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>添加附加条件的方式不适合满秩的模型，如果模型满秩，此时 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=p%20%5Ctimes%20%20p" style="display:inline-block;margin: 0;"/> 的非奇异矩阵，也就是说  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 有 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> 的线性无关的行，因此   <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的所有行是 <img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7Bp%7D" style="display:inline-block;margin: 0;"/> 的一组基，因此任意一个 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D" style="display:inline-block;margin: 0;"/> 矩阵的行一定是   <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的所有行的线性组合，也就是说，你找不到一个 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D" style="display:inline-block;margin: 0;"/> 矩阵，使得 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 是由不可估计函数组成的向量。</p>
<p>这里得到 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 仍然满足原始的正规方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，因为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%2B%5Cmathbf%7BT%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BT%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%26%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%5Cquad%20%5Cbecause%20%5Cmathbf%7BT%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%26%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>我有几个问题，这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵的秩 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 在实际数据中是一个不确定的数，也就是说我们需要添加的附加条件的数目 <img src="https://math.now.sh?inline=p-k" style="display:inline-block;margin: 0;"/> 也不定；第二，我们怎么找到这个 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D" style="display:inline-block;margin: 0;"/> 矩阵，使得 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 是由不可估计函数组成的向量呢？我感觉这个方法不好实现，就是在实际处理中，用了附件条件也不一定能得到唯一解，可能还是要求广义逆的解。再说了，最终得到的所谓的唯一的  <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/>  ，实际上还是之前的不满秩矩阵的一个解，我感觉没有必要非要这么折腾一下，可以直接求广义逆的解。</p>
<p>从现实的角度来看，好像一般是几种方式联合使用，比如添加附加条件 + 广义逆求解，再参数化 + 广义逆求解等。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵分解</title>
    <url>/posts/46823193/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>矩阵分解，就是将一个矩阵分解为比较简单或性质较好的几个矩阵的乘积。</p>
<span id="more"></span>
<h1>半正定矩阵的平方</h1>
<p>设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为半正定 (正定) 矩阵，则存在<strong>唯一</strong>半正定 (正定) 矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> ，使得</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%20%3D%20B%5E%7B2%7D%7D%0A" /></p><p>反过来，我们称矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的平方根，记为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B1%2F2%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p><strong>证明</strong>： 设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的半正定 (正定) 矩阵，其可对角化为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%20%3D%20%5Cmathbf%7BU%7D%20%5C%20%5Cmathrm%7Bdiag%7D%28%5Clambda_%7B1%7D%2C%5Ccdots%2C%20%5Clambda_%7Bn%7D%29%20%5Cmathbf%7BU%7D%5E%7B*%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Clambda_%7B1%7D%20%5Cgeq%20%5Ccdots%20%5Cgeq%20%5Clambda_%7Bn%7D%20%5Cgeq%200" style="display:inline-block;margin: 0;"/> 为  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的特征值，令</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BB%7D%20%3D%20%5Cmathbf%7BU%7D%20%5C%20%5Cmathrm%7Bdiag%7D%28%5Clambda_%7B1%7D%5E%7B1%2F2%7D%2C%5Ccdots%2C%20%5Clambda_%7Bn%7D%5E%7B1%2F2%7D%29%20%5Cmathbf%7BU%7D%5E%7B*%7D%0A" /></p><p>显然，<img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D%20%5Cgeq%200" style="display:inline-block;margin: 0;"/> 且 $\mathbf{B}^{2} = \mathbf{A} $ 。</p>
<p>下面我们证明唯一性，假设存在另外一个 Hermite 矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D%20%5Cgeq%200" style="display:inline-block;margin: 0;"/> 且 $\mathbf{C}^{2} = \mathbf{A} $ ，那么假设  <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 可对角化为下式，其中 <img src="https://math.now.sh?inline=u_%7B1%7D%20%5Cgeq%20%5Ccdots%20%5Cgeq%20u_%7Bn%7D%20%5Cgeq%200" style="display:inline-block;margin: 0;"/></p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BC%7D%20%3D%20%5Cmathbf%7BW%7D%20%5C%20%5Cmathrm%7Bdiag%7D%28u_%7B1%7D%2C%5Ccdots%2C%20u_%7Bn%7D%29%20%5Cmathbf%7BW%7D%5E%7B*%7D%0A" /></p><p>并且我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BC%7D%5E%7B2%7D%20%3D%20%5Cmathbf%7BW%7D%20%5C%20%5Cmathrm%7Bdiag%7D%28u_%7B1%7D%5E%7B2%7D%2C%5Ccdots%2C%20u_%7Bn%7D%5E%7B2%7D%29%20%5Cmathbf%7BW%7D%5E%7B*%7D%20%3D%20%5Cmathbf%7BA%7D%0A" /></p><p>故 <img src="https://math.now.sh?inline=u_%7B1%7D%5E%7B2%7D%2C%5Ccdots%2C%20u_%7Bn%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的特征值，因此 <img src="https://math.now.sh?inline=u_%7Bi%7D%5E%7B2%7D%20%3D%20%5Clambda_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，于是</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BC%7D%20%3D%20%5Cmathbf%7BW%7D%20%5C%20%5Cmathrm%7Bdiag%7D%28%5Clambda_%7B1%7D%5E%7B1%2F2%7D%2C%5Ccdots%2C%20%5Clambda_%7Bn%7D%5E%7B1%2F2%7D%29%20%5Cmathbf%7BW%7D%5E%7B*%7D%0A" /></p><p>再由 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D%5E%7B2%7D%20%3D%20%5Cmathbf%7BC%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BU%7D%20%5C%20%5Cmathrm%7Bdiag%7D%28%5Clambda_%7B1%7D%2C%5Ccdots%2C%20%5Clambda_%7Bn%7D%29%20%5Cmathbf%7BU%7D%5E%7B*%7D%20%3D%20%5Cmathbf%7BW%7D%20%5C%20%5Cmathrm%7Bdiag%7D(%5Clambda_%7B1%7D%2C%5Ccdots%2C%20%5Clambda_%7Bn%7D)%20%5Cmathbf%7BW%7D%5E%7B*%7D%0A" /></p><p>等价地</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BW%7D%5E%7B*%7D%20%5Cmathbf%7BU%7D%20%5C%20%5Cmathrm%7Bdiag%7D%28%5Clambda_%7B1%7D%2C%5Ccdots%2C%20%5Clambda_%7Bn%7D%29%20%20%3D%20%5Cmathrm%7Bdiag%7D(%5Clambda_%7B1%7D%2C%5Ccdots%2C%20%5Clambda_%7Bn%7D)%20%5Cmathbf%7BW%7D%5E%7B*%7D%20%5Cmathbf%7BU%7D%0A" /></p><p>记 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D%5E%7B*%7D%20%5Cmathbf%7BU%7D%20%3D%20%28d_%7Bij%7D%29" style="display:inline-block;margin: 0;"/> ，即其元素为 <img src="https://math.now.sh?inline=d_%7Bij%7D" style="display:inline-block;margin: 0;"/> 。根据矩阵乘积的法则 ( <img src="https://math.now.sh?inline=%5Cmathbf%7BAB%7D_%7Bij%7D" style="display:inline-block;margin: 0;"/> 等于 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行乘以 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 的第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 列  )，左右两边元素相等，得到</p>
<p style=""><img src="https://math.now.sh?from=d_%7Bij%7D%20%5Clambda_%7Bj%7D%20%3D%20%5Clambda_%7Bi%7D%20d_%7Bij%7D%2C%20%5Cquad%20i%2Cj%20%3D%201%2C%5Ccdots%2Cn%0A" /></p><p>因而当 <img src="https://math.now.sh?inline=%5Clambda_%7Bi%7D%20%5Cneq%20%5Clambda_%7Bj%7D" style="display:inline-block;margin: 0;"/> 时，必有 <img src="https://math.now.sh?inline=d_%7Bij%7D%20%3D%200" style="display:inline-block;margin: 0;"/> 。因此无论  <img src="https://math.now.sh?inline=%5Clambda_%7Bi%7D" style="display:inline-block;margin: 0;"/>  和  <img src="https://math.now.sh?inline=%5Clambda_%7Bj%7D" style="display:inline-block;margin: 0;"/> 是否相等，我们总有</p>
<p style=""><img src="https://math.now.sh?from=d_%7Bij%7D%20%5Clambda_%7Bj%7D%5E%7B1%2F2%7D%20%3D%20d_%7Bij%7D%20%5Clambda_%7Bi%7D%5E%7B1%2F2%7D%20%2C%20%5Cquad%20i%2Cj%20%3D%201%2C%5Ccdots%2Cn%0A" /></p><p>也就是</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BW%7D%5E%7B*%7D%20%5Cmathbf%7BU%7D%20%5C%20%5Cmathrm%7Bdiag%7D%28%5Clambda_%7B1%7D%5E%7B1%2F2%7D%2C%5Ccdots%2C%20%5Clambda_%7Bn%7D%5E%7B1%2F2%7D%29%20%20%3D%20%5Cmathrm%7Bdiag%7D(%5Clambda_%7B1%7D%5E%7B1%2F2%7D%2C%5Ccdots%2C%20%5Clambda_%7Bn%7D%5E%7B1%2F2%7D)%20%5Cmathbf%7BW%7D%5E%7B*%7D%20%5Cmathbf%7BU%7D%0A" /></p><p>等价于</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BU%7D%20%5C%20%5Cmathrm%7Bdiag%7D%28%5Clambda_%7B1%7D%5E%7B1%2F2%7D%2C%5Ccdots%2C%20%5Clambda_%7Bn%7D%5E%7B1%2F2%7D%29%20%5Cmathbf%7BU%7D%5E%7B*%7D%20%3D%20%5Cmathbf%7BW%7D%20%5C%20%5Cmathrm%7Bdiag%7D(%5Clambda_%7B1%7D%5E%7B1%2F2%7D%2C%5Ccdots%2C%20%5Clambda_%7Bn%7D%5E%7B1%2F2%7D)%20%5Cmathbf%7BW%7D%5E%7B*%7D%0A" /></p><p>即</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BB%20%3D%20C%7D%0A" /></p><p>因此唯一性得证，定理证毕。</p>
<h1>奇异值分解</h1>
<p>对于任意 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 秩为 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> 的矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> ，其均存在奇异值分解形式 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20%3D%20U%20%5CSigma%20V%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D" style="display:inline-block;margin: 0;"/> 分别为 <img src="https://math.now.sh?inline=m%20%5Ctimes%20m" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的酉 (正交) 矩阵，$\mathbf{\Sigma} = \mathrm{diag}(\lambda_{1},\cdots, \lambda_{r}) $ 为 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的对角矩阵, <img src="https://math.now.sh?inline=%5Clambda_%7Bi%7D%20%3E%200%2C%20i%20%3D%201%2C%5Ccdots%2C%20r" style="display:inline-block;margin: 0;"/>  。</p>
<p><strong>证明</strong>：我们知道 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B*%7DA%7D%20%5Cgeq%200" style="display:inline-block;margin: 0;"/> ，因此其特征值均为非负数，假设其正特征值为 <img src="https://math.now.sh?inline=%5Clambda_%7B1%7D%5E%7B2%7D%2C%20%5Ccdots%2C%5Clambda_%7Br%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，因此其可以对角化为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BV%5E%7B*%7DA%5E%7B*%7DAV%7D%20%3D%20%5Cleft%28%20%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7B%5CLambda%5E%7B2%7D%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright%29%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CLambda%5E%7B2%7D%7D%20%3D%20%5Cmathrm%7Bdiag%7D%28%5Clambda_%7B1%7D%5E%7B2%7D%2C%20%5Ccdots%2C%5Clambda_%7Br%7D%5E%7B2%7D%29" style="display:inline-block;margin: 0;"/>  ，记 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%20%3D%20AV%7D" style="display:inline-block;margin: 0;"/> ，因此上式变为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BB%5E%7B*%7DB%7D%20%3D%20%5Cleft%28%20%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7B%5CLambda%5E%7B2%7D%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright%29%0A" /></p><p>这表明 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 的 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个列互相正交，且前 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> 个列向量长度分别为  <img src="https://math.now.sh?inline=%5Clambda_%7B1%7D%2C%20%5Ccdots%2C%5Clambda_%7Br%7D" style="display:inline-block;margin: 0;"/> ( <img src="https://math.now.sh?inline=%5Clambda_%7Bi%7D%20%3E%200" style="display:inline-block;margin: 0;"/> ) ，后 <img src="https://math.now.sh?inline=n%20-%20r" style="display:inline-block;margin: 0;"/> 列均为 <img src="https://math.now.sh?inline=%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> 向量。</p>
<p>于是，存在一个酉矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> ，可以将  <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/>  表示为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BB%7D%20%3D%20%5Cmathbf%7BU%7D%20%5Cleft%28%20%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7B%5CLambda%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright%29%0A" /></p><p>于是我们得证 <img src="https://math.now.sh?inline=%5Cmathbf%7BAV%20%3D%20U%20%5CSigma%20%7D" style="display:inline-block;margin: 0;"/> ，因此得证。</p>
<h2 id="性质">性质</h2>
<p>根据证明过程，我们知道 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B*%7DA%7D" style="display:inline-block;margin: 0;"/> 的特征向量组成的矩阵，<img src="https://math.now.sh?inline=%5Clambda_%7B1%7D%5E%7B2%7D%2C%5Ccdots%2C%20%5Clambda_%7Br%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 为  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B*%7DA%7D" style="display:inline-block;margin: 0;"/> 的特征值。</p>
<p>同理，根据下式我们可得，</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BAA%5E%7B*%7D%20%3D%20U%20%5CSigma%20V%5E%7B*%7D%20V%20%5CSigma%5E%7B*%7D%20%20U%5E%7B*%7D%20%20%3D%20%7D%20%5Cmathbf%7BU%7D%20%5Cleft%28%20%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7B%5CLambda%5E%7B2%7D%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright%29%20%20%5Cmathbf%7BU%7D%5E%7B*%7D%0A" /></p><p>因为，我们知道 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 的列是 <img src="https://math.now.sh?inline=%5Cmathbf%7BAA%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> 的特征向量 ，<img src="https://math.now.sh?inline=%5Clambda_%7B1%7D%5E%7B2%7D%2C%5Ccdots%2C%20%5Clambda_%7Br%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 为  <img src="https://math.now.sh?inline=%5Cmathbf%7BAA%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> 的特征值。</p>
<p><img src="https://math.now.sh?inline=%5Clambda_%7B1%7D%2C%5Ccdots%2C%20%5Clambda_%7Bn%7D" style="display:inline-block;margin: 0;"/> 称为 矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的<strong>奇异值</strong>，奇异值是<strong>唯一的</strong>，但是  <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D" style="display:inline-block;margin: 0;"/> 不唯一。 矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的秩等于非零奇异值的数目，证明很简单，由于 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D" style="display:inline-block;margin: 0;"/> 均为满秩矩阵，因此 <img src="https://math.now.sh?inline=r%20%5Cleft%28%20%5Cmathbf%7BA%7D%20%5Cright%29%20%3D%20r%20%5Cleft(%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7B*%7D%7D%20%5Cright)%20%3D%20%20r%20%5Cleft(%20%5Cmathbf%7B%20%5CSigma%20%7D%20%5Cright)" style="display:inline-block;margin: 0;"/> 。</p>
<p>当 矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的秩序为 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> ，设 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D_%7B1%7D%20%3D%20%28%5Cmathbf%7Bu_%7B1%7D%2C%5Ccdots%2Cu_%7Br%7D%7D%29" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D_%7B1%7D%20%3D%20%28%5Cmathbf%7Bv_%7B1%7D%2C%5Ccdots%2Cv_%7Br%7D%7D%29" style="display:inline-block;margin: 0;"/> ，则 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20%3D%20U_%7B1%7D%20%5CSigma_%7B1%7D%20V%5E%7B*%7D_%7B1%7D%7D" style="display:inline-block;margin: 0;"/> ，证明如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BA%7D%20%26%3D%20%5Cleft%28%20%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BU%7D_%7B1%7D%20%26%20%5Cmathbf%7BU%7D_%7B2%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright%29%20%0A%5Cleft(%20%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7B%5CSigma_%7B1%7D%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright)%20%0A%5Cleft(%20%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BV_%7B1%7D%5E%7B*%7D%7D%20%5C%5C%0A%5Cmathbf%7BV_%7B2%7D%5E%7B*%7D%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright)%20%5C%5C%0A%26%3D%20%5Cmathbf%7BU_%7B1%7D%20%5CSigma_%7B1%7D%20V%5E%7B*%7D_%7B1%7D%7D%20%5C%5C%0A%0A%0A%5Cend%7Baligned%7D%0A" /></p><h1>极分解</h1>
<p>设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的方阵，则存在 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的酉矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的半正定矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BS%7D" style="display:inline-block;margin: 0;"/> ，使得</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%20%3D%20SU%7D%0A" /></p><p>若 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 可逆，则这种分解是<strong>唯一</strong>的。</p>
<p><strong>证明</strong>：对 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 进行奇异值分解得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%20%3D%20%5Cmathbf%7B%20P%20%5CSigma%20Q%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> ，稍做转换得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BA%7D%20%20%26%3D%20%5Cmathbf%7B%20P%20%5CSigma%20P%5E%7B*%7D%20P%20Q%5E%7B*%7D%7D%20%5C%5C%0A%5Cmathbf%7BA%7D%20%20%26%3D%20%5Cmathbf%7B%20SU%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>其中</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BS%20%3D%20P%20%5CSigma%20P%5E%7B*%7D%7D%20%5Cgeq%200%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BU%20%3D%20PQ%5E%7B*%7D%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 为酉矩阵，得证存在性。</p>
<p>下面我们证明 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 可逆时极分解的唯一性，假设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20%3D%20S_%7B1%7DU_%7B1%7D%20%3D%20S_%7B2%7DU_%7B2%7D%7D" style="display:inline-block;margin: 0;"/> ，其中  <img src="https://math.now.sh?inline=%5Cmathbf%7BU_%7B1%7D%7D" style="display:inline-block;margin: 0;"/> 和   <img src="https://math.now.sh?inline=%5Cmathbf%7BU_%7B2%7D%7D" style="display:inline-block;margin: 0;"/>  为酉矩阵， <img src="https://math.now.sh?inline=%5Cmathbf%7BS%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cmathbf%7BS%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> 皆正定（因为 $r\left( \mathbf{A} \right) = r\left( \mathbf{SU} \right) \leq r\left( \mathbf{S} \right) $ 。</p>
<p>并且我们有  <img src="https://math.now.sh?inline=%5Cmathbf%7BAA%5E%7B*%7D%20%3D%20S%5E%7B2%7D_%7B1%7D%20%3D%20S%5E%7B2%7D_%7B2%7D%20%7D" style="display:inline-block;margin: 0;"/> ，我们知道  <img src="https://math.now.sh?inline=%5Cmathbf%7BS%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cmathbf%7BS%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> 均为半正定矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7BAA%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> 的平方根矩阵，我们已知半正定矩阵的平方根矩阵是唯一的，因此  <img src="https://math.now.sh?inline=%5Cmathbf%7BS_%7B1%7D%20%3D%20S_%7B2%7D%7D" style="display:inline-block;margin: 0;"/> 。同时我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BU_%7B1%7D%20%3D%20S_%7B1%7D%5E%7B-1%7DA%20%3D%20%20S_%7B2%7D%5E%7B-1%7DA%20%3D%20U_%7B2%7D%7D%0A" /></p><p>得证唯一性，证明完毕。</p>
<h1>Schur 酉三角分解</h1>
<p>设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为复方矩阵，则存在酉矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> ，使得</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%20%3D%20ULU%5E%7B*%7D%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 为上 (或下) 三角矩阵，其对角元素为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的特征值。</p>
<p>若  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为实方阵且特征值均是实数，则 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 为正交矩阵。</p>
<p><strong>证明</strong>：对 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的阶数采用数学归纳法证明，对 <img src="https://math.now.sh?inline=n%3D1" style="display:inline-block;margin: 0;"/> ，命题显然成立（<img src="https://math.now.sh?inline=1%3D1%5Ctimes1%5Ctimes1" style="display:inline-block;margin: 0;"/> ，其实 从 <img src="https://math.now.sh?inline=n%3D2" style="display:inline-block;margin: 0;"/> 开始更好理解 ）。</p>
<p>现在假设命题对 <img src="https://math.now.sh?inline=%28n-1%29%20%5Ctimes%20(n-1)" style="display:inline-block;margin: 0;"/> 的方阵成立，设  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 阶方阵，其特征值为 <img src="https://math.now.sh?inline=%5Clambda_%7B1%7D%2C%5Ccdots%2C%20%5Clambda_%7Bn%7D" style="display:inline-block;margin: 0;"/> ，令 <img src="https://math.now.sh?inline=%5Cmathbf%7Bw%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 为相对于 <img src="https://math.now.sh?inline=%5Clambda_%7B1%7D" style="display:inline-block;margin: 0;"/> 的<strong>单位</strong>特征向量，我们可以得到一组包含 <img src="https://math.now.sh?inline=%5Cmathbf%7Bw%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 的 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 的一组基，利用格拉姆-施密特正交化过程，将这些向量转化为一组标准正交基，<img src="https://math.now.sh?inline=%5Cmathbf%7Bw%7D_%7B1%7D%2C%5Ccdots%2C%5Cmathbf%7Bw%7D_%7Bn%7D" style="display:inline-block;margin: 0;"/> ，定义酉矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D_%7B0%7D%20%3D%20%28%5Cmathbf%7Bw%7D_%7B1%7D%2C%5Ccdots%2C%5Cmathbf%7Bw%7D_%7Bn%7D%29" style="display:inline-block;margin: 0;"/> ，则</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BU_%7B0%7D%5E%7B*%7DAU_%7B0%7D%7D%20%3D%20%5Cleft%28%20%5Cbegin%7Barray%7D%7Bc%7D%0A%5Clambda_%7B1%7D%20%26%20%5Cmathbf%7B*%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BA_%7B1%7D%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright%29%0A" /></p><p>其中第一列为 <img src="https://math.now.sh?inline=%5Cmathbf%7BU_%7B0%7D%5E%7B*%7DAw_%7B1%7D%7D%20%3D%20%5Clambda_%7B1%7D%20%5Cmathbf%7BU_%7B0%7D%5E%7B*%7D%7D%20%20%5Cmathbf%7Bw_%7B1%7D%7D%20%3D%20%5Clambda_%7B1%7D%20%5Cmathbf%7Be%7D_%7B1%7D" style="display:inline-block;margin: 0;"/>  ，即第一列第一个元素为 <img src="https://math.now.sh?inline=%5Clambda_%7B1%7D" style="display:inline-block;margin: 0;"/> ，其他元素为 0 。</p>
<p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=%28n-1%29%20%5Ctimes%20(n-1)" style="display:inline-block;margin: 0;"/> 的方阵，由于 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cleft%28%20%5Cbegin%7Barray%7D%7Bc%7D%0A%5Clambda_%7B1%7D%20%26%20%5Cmathbf%7B*%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BA_%7B1%7D%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright%29" style="display:inline-block;margin: 0;"/> 相似，因此特征值相同，因此  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 的特征值为  <img src="https://math.now.sh?inline=%5Clambda_%7B2%7D%2C%5Ccdots%2C%20%5Clambda_%7Bn%7D" style="display:inline-block;margin: 0;"/> 。由于我们假设命题对 <img src="https://math.now.sh?inline=%28n-1%29%20%5Ctimes%20(n-1)" style="display:inline-block;margin: 0;"/> 的方阵成立，因此存在 <img src="https://math.now.sh?inline=n-1" style="display:inline-block;margin: 0;"/> 阶的酉矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> ，使得</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA_%7B1%7D%20%3D%20U_%7B1%7DL_%7B1%7DU%5E%7B*%7D_%7B1%7D%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 为上三角矩阵，其对角元素为  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 的特征值 <img src="https://math.now.sh?inline=%5Clambda_%7B2%7D%2C%5Ccdots%2C%20%5Clambda_%7Bn%7D" style="display:inline-block;margin: 0;"/> ，令</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BU%7D%20%26%3D%20%5Cmathbf%7BU_%7B0%7D%7D%20%5Cleft%28%20%5Cbegin%7Barray%7D%7Bc%7D%0A1%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BU_%7B1%7D%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright%29%20%5C%5C%0A%0A%5Cmathbf%7BL%7D%20%26%3D%20%5Cleft(%20%5Cbegin%7Barray%7D%7Bc%7D%0A%5Clambda_%7B1%7D%20%26%20%5Cmathbf%7B*%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BL_%7B1%7D%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright)%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>我们有下式成立，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 为酉矩阵</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%0A%5Cmathbf%7BU%7D%5E%7B*%7D%20%5Cmathbf%7BU%7D%20%26%3D%5Cleft%28%20%5Cbegin%7Barray%7D%7Bc%7D%0A1%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BU_%7B1%7D%7D%5E%7B*%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright%29%20%5Cmathbf%7BU_%7B0%7D%7D%5E%7B*%7D%20%20%5Cmathbf%7BU_%7B0%7D%7D%20%5Cleft(%20%5Cbegin%7Barray%7D%7Bc%7D%0A1%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BU_%7B1%7D%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright)%20%5C%5C%0A%0A%26%3D%20%5Cleft(%20%5Cbegin%7Barray%7D%7Bc%7D%0A1%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BU_%7B1%7D%7D%5E%7B*%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright)%20%20%5Cleft(%20%5Cbegin%7Barray%7D%7Bc%7D%0A1%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BU_%7B1%7D%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright)%20%5C%5C%0A%0A%26%3D%20%5Cmathbf%7BI%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>同时我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%0A%5Cmathbf%7BULU%5E%7B*%7D%7D%20%26%3D%20%20%5Cmathbf%7BU_%7B0%7D%7D%20%5Cleft%28%20%5Cbegin%7Barray%7D%7Bc%7D%0A1%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BU_%7B1%7D%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright%29%20%20%20%5Cleft(%20%5Cbegin%7Barray%7D%7Bc%7D%0A%5Clambda_%7B1%7D%20%26%20%5Cmathbf%7B*%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BL_%7B1%7D%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright)%20%5Cleft(%20%5Cbegin%7Barray%7D%7Bc%7D%0A1%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BU_%7B1%7D%7D%5E%7B*%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright)%20%5Cmathbf%7BU_%7B0%7D%7D%5E%7B*%7D%20%5C%5C%0A%0A%26%3D%20%20%5Cmathbf%7BU_%7B0%7D%7D%20%5Cleft(%20%5Cbegin%7Barray%7D%7Bc%7D%0A%5Clambda_%7B1%7D%20%26%20%5Cmathbf%7B*%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BU_%7B1%7DL_%7B1%7DU_%7B1%7D%5E%7B*%7D%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright)%20%20%5Cmathbf%7BU_%7B0%7D%7D%5E%7B*%7D%20%5C%5C%0A%0A%26%3D%20%20%5Cmathbf%7BU_%7B0%7D%7D%20%5Cleft(%20%5Cbegin%7Barray%7D%7Bc%7D%0A%5Clambda_%7B1%7D%20%26%20%5Cmathbf%7B*%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BA_%7B1%7D%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright)%20%20%5Cmathbf%7BU_%7B0%7D%7D%5E%7B*%7D%20%5C%5C%0A%0A%26%3D%20%5Cmathbf%7BA%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们证明了 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 为上三角矩阵的情形。若对 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 进行上面的分解，则有 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B*%7D%20%3D%20ULU%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> ，此时则有 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20%3D%20U%5E%7B*%7DL%5E%7B*%7D%20U%7D" style="display:inline-block;margin: 0;"/>  ，因此同样可以分解为下三角矩阵的情况。</p>
<p>最后看 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为实方阵且特征值均是实数的情况，此时它的特征向量都可以取为实向量。简单证明一下若  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为实方阵且特征值均是实数，则它的特征向量都可以取为实向量。第一种是 <img src="https://math.now.sh?inline=%28%5Cmathbf%7BA%7D%20-%20%5Clambda%20%5Cmathbf%7BI%7D%29%20%5Cmathbf%7Bx%7D%20%3D%20%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> ，此时特征向量就是在实矩阵的零空间中，因此显然其可以为实向量；第二种是假设特征值 <img src="https://math.now.sh?inline=%5Clambda" style="display:inline-block;margin: 0;"/> 存在一个复特征向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> ，则 <img src="https://math.now.sh?inline=%5Cmathbf%7BAx%7D%20%3D%20%5Clambda%20%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> ，共轭得到   <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Cbar%7BA%7D%20%5Cbar%7Bx%7D%7D%20%3D%20%5Cmathbf%7BA%20%5Cbar%7Bx%7D%7D%20%3D%20%5Cbar%7B%5Clambda%7D%20%5Cmathbf%7B%5Cbar%7Bx%7D%7D%3D%20%5Clambda%20%5Cmathbf%7B%5Cbar%7Bx%7D%7D" style="display:inline-block;margin: 0;"/> ，即 <img src="https://math.now.sh?inline=%5Clambda" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Cbar%7Bx%7D%7D" style="display:inline-block;margin: 0;"/> 也是一组特征值和特征向量，两个方程相加得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%28x%2B%5Cbar%7Bx%7D%29%7D%20%3D%20%5Clambda%20%5Cmathbf%7B(x%2B%5Cbar%7Bx%7D)%7D" style="display:inline-block;margin: 0;"/> ，因此我们一定可以找到一个实特折向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%2B%5Cbar%7Bx%7D%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>然后我们同样采用上面的归纳法证明，只是此时 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D_%7B0%7D" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 需要替换为正交矩阵，证明略。</p>
<h1>满秩分解</h1>
<p>对于任意 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 秩为 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> 的矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> ，则存在 <img src="https://math.now.sh?inline=m%20%5Ctimes%20r" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=r%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 且秩皆为 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> 的矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> ，使得 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20%3D%20BC%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p><strong>证明</strong>：设 矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的相抵标准形如下，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D" style="display:inline-block;margin: 0;"/>  和  <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D" style="display:inline-block;margin: 0;"/> 为  <img src="https://math.now.sh?inline=m%20%5Ctimes%20m" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=n%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的可逆矩阵</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%20%3D%20%5Cmathbf%7BP%7D%20%5Cleft%28%20%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BI_%7Br%7D%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright%29%20%5Cmathbf%7BQ%7D%0A" /></p><p>对 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D" style="display:inline-block;margin: 0;"/> 进行分块，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BP%7D%20%3D%20%20%5Cleft%28%20%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BP_%7B1%7D%7D%20%26%20%5Cmathbf%7BP_%7B2%7D%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright%29%2C%20%0A%5Cmathbf%7BQ%7D%20%3D%20%20%5Cleft(%20%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BQ_%7B1%7D%7D%20%5C%5C%0A%5Cmathbf%7BQ_%7B2%7D%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright)%0A" /></p><p>其中  <img src="https://math.now.sh?inline=%5Cmathbf%7BP_%7B1%7D%7D" style="display:inline-block;margin: 0;"/>  和  <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 分别为  <img src="https://math.now.sh?inline=m%20%5Ctimes%20r" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=r%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的列 (行) 满秩矩阵，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%20%3D%20%5Cleft%28%20%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BP_%7B1%7D%7D%20%26%20%5Cmathbf%7BP_%7B2%7D%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright%29%0A%5Cleft(%20%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BI_%7Br%7D%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright)%20%5Cleft(%20%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BQ_%7B1%7D%7D%20%5C%5C%0A%5Cmathbf%7BQ_%7B2%7D%7D%20%5C%5C%0A%5Cend%7Barray%7D%20%5Cright)%20%3D%20%5Cmathbf%7BP_%7B1%7DQ_%7B1%7D%7D%0A" /></p><p>证明完毕。</p>
<h1>QR 分解</h1>
<p>对于任意 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 秩为 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 的满列秩矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> ，则存在 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 上三角矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> ，使得 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20%3D%20QR%7D" style="display:inline-block;margin: 0;"/> 。其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%5E%7B*%7DQ%20%3D%20I_%7Bn%7D%7D" style="display:inline-block;margin: 0;"/> ,    <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> 的对角元素为正数。如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为实矩阵，则  <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> 也是实矩阵。</p>
<p><strong>证明</strong>：对矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 施加施密特正交化，便可以得到主要结论。</p>
<p><strong>注</strong>: 如果矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 不满秩，其秩为 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> ，此时  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20%3D%20QR%7D" style="display:inline-block;margin: 0;"/> 仍然成立，且  <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%5E%7B*%7DQ%20%3D%20I_%7Bn%7D%7D" style="display:inline-block;margin: 0;"/> ,  但此时  <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> 的对角元素可以为零。</p>
<h1>Cholesky 分解</h1>
<p>设矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的<strong>正定</strong>矩阵，则存在上三角矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> ，其对角线元素均为正数，使得 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20%3D%20L%5E%7B*%7DL%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>若 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为实矩阵，则  <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 的元素均为实数。</p>
<p><strong>证明</strong>：因为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%3E%200" style="display:inline-block;margin: 0;"/> ，故存在  <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D%20%3E%200" style="display:inline-block;margin: 0;"/> ，使得 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20%3D%20B%5E%7B2%7D%20%3D%20B%5E%7B*%7DB%7D" style="display:inline-block;margin: 0;"/> ，对 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 作 QR 分解，有 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%20%3D%20QR%7D" style="display:inline-block;margin: 0;"/> ,这里  <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D" style="display:inline-block;margin: 0;"/> 为酉矩阵， <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> 为上三角矩阵，其对角元素阶为正数。于是</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%20%3D%20B%5E%7B*%7DB%20%3D%20R%5E%7B*%7DQ%5E%7B*%7DQR%20%3D%20R%5E%7B*%7DR%7D%0A" /></p><p>得证。</p>
<p>更详细的内容可见 <a href="https://ccjou.wordpress.com/2010/09/16/cholesky-%E5%88%86%E8%A7%A3/">Cholesky 分解</a> 。</p>
<p><img src="1.png" alt="1"></p>
<h1>谱分解</h1>
<p>若 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的 Hermite 矩阵，则存在一个酉矩阵对角化 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> ，即下式成立。其中 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 为由 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 矩阵特征值组成的对角矩阵，其元素均为实数；<img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 矩阵的列均为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 矩阵 的特征向量。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%20%3D%20U%5CSigma%20U%5E%7B*%7D%7D%0A" /></p><p>当 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为实对称矩阵时，<img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 矩阵为正交矩阵。</p>
<p><strong>证明</strong>：根据 Schur 酉三角分解易得</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%20%3D%20ULU%5E%7B*%7D%20%3D%20UL%5E%7B*%7DU%5E%7B*%7D%20%3D%20A%5E%7B*%7D%7D%0A" /></p><p>即 <img src="https://math.now.sh?inline=%5Cmathbf%7BULU%5E%7B*%7D%20%3D%20UL%5E%7B*%7DU%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> ，左乘 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> ，右乘 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 后得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BL%20%3D%20L%5E%7B*%7D%7D%0A" /></p><p>因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 为对角矩阵，即 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20%3D%20U%5CSigma%20U%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>下面证明 Hermite 矩阵的特征值均为实数，对 <img src="https://math.now.sh?inline=%5Cmathbf%7BAu%7D%20%3D%20%5Clambda%20%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> 进行共轭转置得到 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%5E%7B*%7DA%5E%7B*%7D%7D%20%3D%20%5Cmathbf%7Bu%5E%7B*%7DA%7D%20%3D%20%5Clambda%5E%7B*%7D%20%5Cmathbf%7Bu%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> ，右乘 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> 得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7Bu%5E%7B*%7DAu%7D%20%26%3D%20%5Clambda%5E%7B*%7D%20%5Cmathbf%7Bu%5E%7B*%7Du%7D%20%5C%5C%0A%5Clambda%20%5Cmathbf%7Bu%5E%7B*%7Du%7D%20%26%3D%20%5Clambda%5E%7B*%7D%20%5Cmathbf%7Bu%5E%7B*%7Du%7D%20%5C%5C%0A%0A%28%5Clambda%20-%20%5Clambda%5E%7B*%7D%29%20%5Cmathbf%7Bu%5E%7B*%7Du%7D%20%26%3D%200%20%5Cquad%20%5Cbecause%20%5Cmathbf%7Bu%5E%7B*%7Du%7D%20%5Ctext%7B%20%E4%B8%BA%E5%A4%A7%E4%BA%8E0%E7%9A%84%E5%AE%9E%E6%95%B0%7D%20%5C%5C%0A%0A%5Clambda%20%26%20%3D%20%5Clambda%5E%7B*%7D%20%20%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>得证 Hermite 矩阵的特征值均为实数。</p>
<p>当 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为实对称矩阵时，同样根据 Schur 酉三角分解，易得此时 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 矩阵为正交矩阵。</p>
<h2 id="正规矩阵">正规矩阵</h2>
<p>若 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的方阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 满足 <img src="https://math.now.sh?inline=%5Cmathbf%7BAA%5E%7B*%7D%20%3D%20A%5E%7B*%7DA%7D" style="display:inline-block;margin: 0;"/> ，则称为<strong>正规矩阵</strong> (normal matrix) 。</p>
<p><strong>定理</strong>：一个方阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 是正规矩阵，<strong>当且仅当</strong>方阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 可以找到一组彼此正交的特征向量集。</p>
<p>首先证明<strong>充分性</strong>，假设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 可以找到一组彼此正交的特征向量集， 那么其可以对角化为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20%3D%20U%5CSigma%20U%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> ，注意其特征值不一定均为实数，即 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 是一个复矩阵。此时我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%20%5Cmathbf%7BAA%5E%7B*%7D%3D%20U%5CSigma%20U%5E%7B*%7D%20U%5CSigma%5E%7B*%7D%20U%5E%7B*%7D%20%3D%20U%5CSigma%20%5CSigma%5E%7B*%7D%20U%5E%7B*%7D%7D%20%5C%5C%0A%26%20%5Cmathbf%7BA%5E%7B*%7DA%3D%20U%5CSigma%5E%7B*%7D%20U%5E%7B*%7D%20U%5CSigma%20U%5E%7B*%7D%20%20%3D%20U%5CSigma%5E%7B*%7D%20%5CSigma%20U%5E%7B*%7D%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>容易证明 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%20%5CSigma%5E%7B*%7D%20%3D%20%5CSigma%5E%7B*%7D%20%5CSigma%7D" style="display:inline-block;margin: 0;"/> ，其对角线元素为 <img src="https://math.now.sh?inline=%5CSigma_%7Bii%7D%5CSigma_%7Bii%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> ，非对角线元素均为 0 。</p>
<p>因此  <img src="https://math.now.sh?inline=%5Cmathbf%7BAA%5E%7B*%7D%20%3D%20A%5E%7B*%7DA%7D" style="display:inline-block;margin: 0;"/> ，得证。</p>
<p>再证明<strong>必要性</strong>，根据 Schur 酉三角分解，有 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20%3D%20ULU%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 为上三角矩阵。因为  <img src="https://math.now.sh?inline=%5Cmathbf%7BAA%5E%7B*%7D%20%3D%20A%5E%7B*%7DA%7D" style="display:inline-block;margin: 0;"/> ，我们可以证明 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 也是正规矩阵，即 <img src="https://math.now.sh?inline=%5Cmathbf%7BLL%5E%7B*%7D%20%3D%20L%5E%7B*%7DL%7D" style="display:inline-block;margin: 0;"/> ，如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cmathbf%7BLL%5E%7B*%7D%20%3D%20U%5E%7B*%7DAU%20%20U%5E%7B*%7DA%5E%7B*%7DU%20%3D%20U%5E%7B*%7DAA%5E%7B*%7DU%7D%20%5C%5C%0A%26%5Cmathbf%7BL%5E%7B*%7DL%20%3D%20U%5E%7B*%7DA%5E%7B*%7DU%20U%5E%7B*%7DAU%20%20%20%3D%20U%5E%7B*%7DA%5E%7B*%7DAU%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>得证 <img src="https://math.now.sh?inline=%5Cmathbf%7BLL%5E%7B*%7D%20%3D%20L%5E%7B*%7DL%7D" style="display:inline-block;margin: 0;"/> ，比较 <img src="https://math.now.sh?inline=%5Cmathbf%7BLL%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cmathbf%7BL%5E%7B*%7DL%7D" style="display:inline-block;margin: 0;"/> 对角线元素得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%7Cl_%7B11%7D%7C%5E%7B2%7D%20%2B%20%7Cl_%7B12%7D%7C%5E%7B2%7D%20%2B%20%7Cl_%7B13%7D%7C%5E%7B2%7D%20%2B%20%5Ccdots%20%2B%20%7Cl_%7B1n%7D%7C%5E%7B2%7D%20%26%3D%20%7Cl_%7B11%7D%7C%5E%7B2%7D%20%5C%5C%0A%7Cl_%7B22%7D%7C%5E%7B2%7D%20%2B%20%7Cl_%7B23%7D%7C%5E%7B2%7D%20%2B%20%5Ccdots%20%2B%20%7Cl_%7B2n%7D%7C%5E%7B2%7D%20%26%3D%20%7Cl_%7B12%7D%7C%5E%7B2%7D%20%2B%20%7Cl_%7B22%7D%7C%5E%7B2%7D%20%5C%5C%0A%26%5Cvdots%20%5C%5C%0A%0A%7Cl_%7Bnn%7D%7C%5E%7B2%7D%20%26%3D%20%7Cl_%7B1n%7D%7C%5E%7B2%7D%20%2B%20%7Cl_%7B2n%7D%7C%5E%7B2%7D%20%2B%20%7Cl_%7B3n%7D%7C%5E%7B2%7D%20%2B%20%5Ccdots%20%2B%20%7Cl_%7Bnn%7D%7C%5E%7B2%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>根据第一个方程我们得到 <img src="https://math.now.sh?inline=l_%7B1i%7D%20%3D%200%2C%20i%20%5Cneq%201" style="display:inline-block;margin: 0;"/> ，其余方程同理，我们得到结论  <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 矩阵非对角线元素均为0，即  <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 为对角矩阵，因此我们有  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20%3D%20U%5CSigma%20U%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> ，得证  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 可以找到一组彼此正交的特征向量集。</p>
<h1>参考文献</h1>
<ol>
<li>
<p>Rencher A C, Schaalje G B. Linear models in statistics[M]. John Wiley &amp; Sons, 2008.</p>
</li>
<li>
<p>王松桂, 杨振海. 广义逆矩阵及其应用[M]. 北京工业大学出版社, 1996.</p>
</li>
<li>
<p>Leon S J, Bica I, Hohn T. Linear algebra with applications[M]. Upper Saddle River, NJ: Pearson Prentice Hall, 2006.</p>
</li>
<li>
<p><a href="https://ccjou.wordpress.com/2010/09/16/cholesky-%E5%88%86%E8%A7%A3/">Cholesky 分解</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>方阵的秩等于非零特征值的数目吗</title>
    <url>/posts/a67ad139/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这是一句很容易混淆的话，答案是错的，方阵的秩不一定等于非零特征值的数目。</p>
<span id="more"></span>
<p>查了一些资料，但只有一篇文章给出了严密的证明。本文内容来自于张景晓老师的文章，是一篇读书笔记。</p>
<h1>反例</h1>
<p>先看一个反例</p>
<p>对于下面的矩阵，其秩为 3 , 然而它的特征值均为 0 （三角矩阵的特征值等于对角线元素）。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BM%7D%20%3D%20%5Cleft%28%20%5Cbegin%7Barray%7D%7Bc%7D%0A0%20%26%201%20%26%200%20%26%200%20%5C%5C%0A0%20%26%200%20%26%201%20%26%200%20%5C%5C%0A0%20%26%200%20%26%200%20%26%201%20%5C%5C%0A0%20%26%200%20%26%200%20%26%200%20%5C%5C%0A%0A%0A%5Cend%7Barray%7D%20%5Cright%29%0A" /></p><p>这就说明方阵的秩不一定等于非零特征值的数目。</p>
<h1>矩阵的秩 <img src="https://math.now.sh?inline=r%28A%29" style="display:inline-block;margin: 0;"/> 和非零特征值个数 <img src="https://math.now.sh?inline=%5Cmu%28A%29" style="display:inline-block;margin: 0;"/> 间的关系</h1>
<p><strong>定理1</strong>：对于任意 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 阶方阵 <img src="https://math.now.sh?inline=%5Cmathbf%28A%29" style="display:inline-block;margin: 0;"/> 都有 <img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%7D%29%20%5Cgeq%20%5Cmu(%5Cmathbf%7BA%7D)" style="display:inline-block;margin: 0;"/> 。</p>
<p>证明：当矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 可逆时，<img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%7D%29%20%3D%20n" style="display:inline-block;margin: 0;"/> ，此时我们设 <img src="https://math.now.sh?inline=%5Clambda_%7B1%7D%2C%20%5Clambda_%7B2%7D%2C%20%5Ccdots%2C%20%5Clambda_%7Bn%7D" style="display:inline-block;margin: 0;"/> 是矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的全部特征根, 则 <img src="https://math.now.sh?inline=%7C%5Cmathbf%7BA%7D%7C%3D%5Clambda_%7B1%7D%20%5Clambda_%7B2%7D%20%5Ccdots%20%5Clambda_%7Bn%7D%20%5Cneq%200" style="display:inline-block;margin: 0;"/> (证明可参考<a href="https://vincere.fun/posts/c98e6ad5/">特征值的乘积与和</a> ), 从而 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 有 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个非零特征值, 故 <img src="https://math.now.sh?inline=%5Cmu%28%5Cmathbf%7BA%7D%29%3Dn" style="display:inline-block;margin: 0;"/>,  此时  <img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%7D%29%20%3D%20%5Cmu(%5Cmathbf%7BA%7D)" style="display:inline-block;margin: 0;"/> ，上面的定理成立。</p>
<p>当矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 不可逆时，此时 <img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%7D%29%3Dr%3Cn" style="display:inline-block;margin: 0;"/> ，矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的行向量组 <img src="https://math.now.sh?inline=%5Calpha_%7B1%7D%2C%20%5Calpha_%7B2%7D%2C%20%5Ccdots%2C%20%5Calpha_%7Bn%7D" style="display:inline-block;margin: 0;"/> 的秩是 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/>, 故该向量组中必有 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> 个向量线性无关，不妨设 前 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> 个向量 <img src="https://math.now.sh?inline=%5Calpha_%7B1%7D%2C%20%5Calpha_%7B2%7D%2C%20%5Ccdots%2C%20%5Calpha_%7Br%7D" style="display:inline-block;margin: 0;"/> 线性无关,则 <img src="https://math.now.sh?inline=%5Calpha_%7Br%2B1%7D%2C%20%5Calpha_%7Br%2B2%7D%2C%20%5Ccdots%2C%20%5Calpha_%7Bn%7D" style="display:inline-block;margin: 0;"/> 均可由 <img src="https://math.now.sh?inline=%5Calpha_%7B1%7D%2C%20%5Calpha_%7B2%7D%2C%20%5Ccdots%2C%20%5Calpha_%7Br%7D" style="display:inline-block;margin: 0;"/> 线性表出, 设 $\alpha_{i}= k_{i 1} \alpha_{1}+k_{i 2} \alpha_{2}+\cdots+k_{i r} \alpha_{r}, \quad i=r+1, r+2, \cdots, n $  ，则有</p>
<p style=""><img src="https://math.now.sh?from=%7C%5Clambda%20%5Cboldsymbol%7BE%7D-%5Cboldsymbol%7BA%7D%7C%3D%5Cleft%7C%5Cbegin%7Barray%7D%7Bccccccc%7D%0A%5Clambda-a_%7B11%7D%20%26%20-a_%7B12%7D%20%26%20%5Ccdots%20%26%20-a_%7B1%20r%7D%20%26%20-a_%7B1%20%28r%2B1%29%7D%20%26%20%5Ccdots%20%26%20-a_%7B1%20n%7D%20%5C%5C%0A-a_%7B21%7D%20%26%20%5Clambda-a_%7B22%7D%20%26%20%5Ccdots%20%26%20-a_%7B2%20r%7D%20%26%20-a_%7B2%20(r%2B1)%7D%20%26%20%5Ccdots%20%26%20-a_%7B2%20n%7D%20%5C%5C%0A%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%5C%5C%0A-a_%7Br%201%7D%20%26%20-a_%7Br%202%7D%20%26%20%5Ccdots%20%26%20%5Clambda-a_%7Br%20r%7D%20%26%20-a_%7Br(r%2B1)%7D%20%26%20%5Ccdots%20%26%20-a_%7Br%20n%7D%20%5C%5C%0A-a_%7B(r%2B1)1%7D%20%26%20-a_%7B(r%2B1)2%7D%20%26%20%5Ccdots%20%26%20-a_%7B(r%2B1)%20r%7D%20%26%20%5Clambda-a_%7B(r%2B1)%20(r%2B1)%7D%20%26%20%5Ccdots%20%26%20-a_%7B(r%2B1)%20n%7D%20%5C%5C%0A%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%5C%5C%0A-a_%7Bn%201%7D%20%26%20-a_%7Bn%202%7D%20%26%20%5Ccdots%20%26%20-a_%7Bn%20r%7D%20%26%20-a_%7Bn%20(r%2B1)%7D%20%26%20%5Ccdots%20%26%20%5Clambda-a_%7Bn%20n%7D%0A%5Cend%7Barray%7D%5Cright%7C%0A" /></p><p>将 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的特征行列式的第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 行 <img src="https://math.now.sh?inline=%28j%3D1%2C2%2C%20%5Ccdots%2C%20r%29" style="display:inline-block;margin: 0;"/> 分别乘以 <img src="https://math.now.sh?inline=-k_%7Bi%20j%7D" style="display:inline-block;margin: 0;"/> 后均加到第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行 <img src="https://math.now.sh?inline=%28i%3Dr%2B1%2C%20r%2B2%2C%20%5Ccdots%2C%20n%29" style="display:inline-block;margin: 0;"/> 上得（注意：这里将第某一个行的倍数加到另外一行，不会改变行列式的大小。）</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0A%5Cleft%7C%5Cbegin%7Barray%7D%7Bccccccc%7D%0A%5Clambda-a_%7B11%7D%20%26%20-a_%7B12%7D%20%26%20%5Ccdots%20%26%20-a_%7B1%20r%7D%20%26%20-a_%7B1%20%28r%2B1%29%7D%20%26%20%5Ccdots%20%26%20-a_%7B1%20n%7D%20%5C%5C%0A-a_%7B21%7D%20%26%20%5Clambda-a_%7B22%7D%20%26%20%5Ccdots%20%26%20-a_%7B2%20r%7D%20%26%20-a_%7B2%20(r%2B1)%7D%20%26%20%5Ccdots%20%26%20-a_%7B2%20n%7D%20%5C%5C%0A%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%5C%5C%0A-a_%7Br%201%7D%20%26%20-a_%7Br%202%7D%20%26%20%5Ccdots%20%26%20%5Clambda-a_%7Br%20r%7D%20%26%20-a_%7Br%20(r%2B1)%7D%20%26%20%5Ccdots%20%26%20-a_%7Br%20n%7D%20%5C%5C%0A-k_%7B(r%2B1)1%7D%20%5Clambda%20%26%20-k_%7B(r%2B1)2%7D%20%5Clambda%20%26%20%5Ccdots%20%26%20-k_%7B(r%2B1)%20r%7D%20%5Clambda%20%26%20%5Clambda%20%26%20%5Ccdots%20%26%200%20%5C%5C%0A%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%5C%5C%0A-k_%7Bn%201%7D%20%5Clambda%20%26%20-k_%7Bn%202%7D%20%5Clambda%20%26%20%5Ccdots%20%26%20-k_%7Bn%20r%7D%20%5Clambda%20%26%200%20%26%20%5Ccdots%20%26%20%5Clambda%0A%5Cend%7Barray%7D%5Cright%7C%3D%20%5C%5C%0A%5Clambda%5E%7Bn-r%7D%5Cleft%7C%5Cbegin%7Barray%7D%7Bccccccc%7D%0A%5Clambda-a_%7B11%7D%20%26%20-a_%7B12%7D%20%26%20%5Ccdots%20%26%20-a_%7B1%20r%7D%20%26%20-a_%7B1%20(r%2B1)%7D%20%26%20%5Ccdots%20%26%20-a_%7B1%20n%7D%20%5C%5C%0A-a_%7B21%7D%20%26%20%5Clambda-a_%7B22%7D%20%26%20%5Ccdots%20%26%20-a_%7B2%20r%7D%20%26%20-a_%7B2%20(r%2B1)%7D%20%26%20%5Ccdots%20%26%20-a_%7B2%20n%7D%20%5C%5C%0A%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%5C%5C%0A-a_%7Br%201%7D%20%26%20-a_%7Br%202%7D%20%26%20%5Ccdots%20%26%20%5Clambda-a_%7Br%20r%7D%20%26%20-a_%7Br%20(r%2B1)%7D%20%26%20%5Ccdots%20%26%20-a_%7Br%20n%7D%20%5C%5C%0A-k_%7B(r%2B1)%201%7D%20%26%20-k_%7B(r%2B1)%202%7D%20%26%20%5Ccdots%20%26%20-k_%7B(r%2B1)%20r%7D%20%26%201%20%26%20%5Ccdots%20%26%200%20%5C%5C%0A%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%5C%5C%0A-k_%7Bn%201%7D%20%26%20-k_%7Bn%202%7D%20%26%20%5Ccdots%20%26%20-k_%7Bn%20r%7D%20%26%200%20%26%20%5Ccdots%20%26%201%0A%5Cend%7Barray%7D%5Cright%7C%3D%5Clambda%5E%7Bn-r%7D%20g(%5Clambda)%0A%5Cend%7Bgathered%7D%0A" /></p><p>由此可知，矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 至少有 <img src="https://math.now.sh?inline=n-r" style="display:inline-block;margin: 0;"/> 个零特征值, 从而 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 至多有 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> 个非零特征值, 因此有 <img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%7D%29%20%5Cgeqslant%20%5Cmu(%5Cmathbf%7BA%7D)" style="display:inline-block;margin: 0;"/> 。</p>
<h1><img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%7D%29%3D%5Cmu(%5Cmathbf%7BA%7D)" style="display:inline-block;margin: 0;"/> 的充分条件</h1>
<h2 id="1-可对角化">1 可对角化</h2>
<p><strong>定理2</strong>： 若矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 可对角化,则 <img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%7D%29%3D%5Cmu(%5Cmathbf%7BA%7D)" style="display:inline-block;margin: 0;"/>.</p>
<p>如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 可对角化.故存在可逆阵 <img src="https://math.now.sh?inline=T" style="display:inline-block;margin: 0;"/> 使得</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7BT%7D%5E%7B-1%7D%20%5Cboldsymbol%7BA%20T%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bllll%7D%0A%5Clambda_%7B1%7D%20%26%20%26%20%26%20%5C%5C%0A%26%20%5Clambda_%7B2%7D%20%26%20%26%20%5C%5C%0A%26%20%26%20%5Cddots%20%26%20%5C%5C%0A%26%20%26%20%26%20%5Clambda_%7B%5Cmathrm%7Bn%7D%7D%0A%5Cend%7Barray%7D%5Cright%29%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Clambda_%7B1%7D%2C%20%5Clambda_%7B2%7D%2C%20%5Ccdots%2C%20%5Clambda_%7Bn%7D" style="display:inline-block;margin: 0;"/> 是矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的全部特征根 ，由于矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D" style="display:inline-block;margin: 0;"/> 可逆，故矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的秩与对角矩阵的秩相同，即等于非零特征值数目，从而有 <img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%7D%29%3D%5Cmu(%5Cmathbf%7BA%7D)" style="display:inline-block;margin: 0;"/> 。</p>
<p><strong>推论 1</strong> 若矩阵 A 的秩与它的非零特征值个数不相等 ，则矩阵 A不可对角化．</p>
<p>该推论是定理2的逆否命题，因此成立。</p>
<p><strong>推论 2</strong> 实对称矩阵的秩与其非零特征 值个数相同。</p>
<p>根据谱定理，实对称矩阵均可对角化，因此该结论成立</p>
<p><strong>推论 3</strong>  设矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/>  的实矩阵，则有 <img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%7D%29%20%20%3D%20%20%5Cmu(%5Cmathbf%7BAA%5E%7BT%7D%7D)%20%3D%20%20%5Cmu(%5Cmathbf%7BA%5E%7BT%7DA%7D%20)" style="display:inline-block;margin: 0;"/> 。</p>
<p>证明：由于矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/>  是实矩 阵 ，从 而 <img src="https://math.now.sh?inline=%5Cmathbf%7BAA%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7BT%7DA%7D" style="display:inline-block;margin: 0;"/>  均实对称 ，由推论 2 得，<img src="https://math.now.sh?inline=r%28%5Cmathbf%7BAA%5E%7BT%7D%7D%29%20%3D%20%5Cmu(%5Cmathbf%7BAA%5E%7BT%7D%7D)" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%5E%7BT%7DA%7D%29%20%3D%20%5Cmu(%5Cmathbf%7BA%5E%7BT%7DA%7D)" style="display:inline-block;margin: 0;"/> ，又因为 <img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%7D%29%3Dr%5Cleft(%5Cmathbf%7BA%20A%5E%7BT%7D%7D%5Cright)%3Dr%5Cleft(%5Cmathbf%7BA%5E%7BT%7D%20A%7D%5Cright)" style="display:inline-block;margin: 0;"/> ，因此我们有  <img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%7D%29%20%20%3D%20%20%5Cmu(%5Cmathbf%7BAA%5E%7BT%7D%7D)%20%3D%20%20%5Cmu(%5Cmathbf%7BA%5E%7BT%7DA%7D%20)" style="display:inline-block;margin: 0;"/></p>
<h2 id="2-矩阵可逆">2 矩阵可逆</h2>
<p>证明见上。</p>
<h1><img src="https://math.now.sh?inline=r%28%5Cmathbf%7BA%7D%29%3D%5Cmu(%5Cmathbf%7BA%7D)" style="display:inline-block;margin: 0;"/> 的充分必要条件</h1>
<p>暂时看不懂，放着</p>
<p><img src="1.png" alt=""></p>
<h1>参考文献</h1>
<ol>
<li>张景晓.矩阵的秩与其非零特征值个数相等的条件J.德州学院学报,2012,28(4):5-8</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>MP逆及其性质</title>
    <url>/posts/4bcf906/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>之前在<a href="https://vincere.fun/posts/bc1cea9f/">奇异值分解与穆尔-彭罗斯伪逆</a>简单地学了一下MP逆，下面进一步学习MP逆矩阵的性质。</p>
<span id="more"></span>
<h1>定义</h1>
<p>对于任意矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/>，其MP逆矩阵记为  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B%2B%7D" style="display:inline-block;margin: 0;"/> ，其为满足下面四个条件的解（注意下面的 <code>*</code>号表示共轭转置，下同）。</p>
<p>(1) <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%5E%2B%7D%20%5Cboldsymbol%7BA%7D%3D%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/>;<br>
(2) <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%5E%2B%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%5E%2B%7D%3D%5Cboldsymbol%7BA%5E%2B%7D%20%3B" style="display:inline-block;margin: 0;"/><br>
(3) <img src="https://math.now.sh?inline=%5Cleft%28%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%5Cright%29%5E%7B%5Cmathrm%7B*%7D%7D%3D%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%7D%5E%7B%2B%7D" style="display:inline-block;margin: 0;"/>;<br>
(4) <img src="https://math.now.sh?inline=%5Cleft%28%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%20%5Cboldsymbol%7BA%7D%5Cright%29%5E%7B%5Cmathrm%7B*%7D%7D%3D%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%20%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/>;</p>
<h1>唯一性及构造</h1>
<p>在 <a href="https://vincere.fun/posts/bc1cea9f/">奇异值分解与穆尔-彭罗斯伪逆</a> 中，我们证明了基于 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的奇异值分解可以得到满足上面四个条件的MP逆为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B%2B%7D%7D%3D%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D" style="display:inline-block;margin: 0;"/> 。因此对于任意矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> , 至少存在一个MP逆满足上面四个条件，下面我们进一步证明MP逆的<strong>唯一性</strong>。</p>
<p>假设 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BY%7D" style="display:inline-block;margin: 0;"/> 均是矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的MP逆矩阵，通过反复利用 MP 逆矩阵的四个方程，有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cboldsymbol%7BX%7D%20%26%3D%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7BA%7D%3D%5Cboldsymbol%7BX%7D%28%5Cboldsymbol%7BA%20X%7D%29%5E%7B*%7D%3D%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7BX%7D%5E%7B*%7D%20%5Cboldsymbol%7BA%7D%5E%7B*%7D%3D%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7BX%7D%5E%7B*%7D%20%5Cboldsymbol%7BA%7D%5E%7B*%7D%20%5Cboldsymbol%7BX%7D%5E%7B*%7D%20%5Cboldsymbol%7BA%7D%5E%7B*%7D%20%5C%5C%0A%26%3D%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7BX%7D%5E%7B*%7D%20%5Cboldsymbol%7BA%7D%5E%7B*%7D%20%5Cboldsymbol%7BY%7D%5E%7B*%7D%20%5Cboldsymbol%7BA%7D%5E%7B*%7D%3D%5Cboldsymbol%7BX%7D(%5Cboldsymbol%7BA%20X%7D)%5E%7B*%7D(%5Cboldsymbol%7BA%20Y%7D)%5E%7B*%7D%3D%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7BAY%7D%3D%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BY%7D%20%5C%5C%0A%26%3D%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BY%7D%20%5Cboldsymbol%7BAY%7D%3D(%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7BA%7D)%5E%7B*%7D(%5Cboldsymbol%7BY%7D%20%5Cboldsymbol%7BA%7D)%5E%7B*%7D%20%5Cboldsymbol%7BY%7D%3D%5Cboldsymbol%7BA%7D%5E%7B*%7D%20%5Cboldsymbol%7BX%7D%5E%7B*%7D%20%5Cboldsymbol%7BA%7D%5E%7B*%7D%20%5Cboldsymbol%7BY%7D%5E%7B*%7D%20%5Cboldsymbol%7BY%7D%20%5C%5C%0A%26%3D%5Cboldsymbol%7BA%7D%5E%7B*%7D%20%5Cboldsymbol%7BY%7D%5E%7B*%7D%20%5Cboldsymbol%7BY%7D%3D(%5Cboldsymbol%7BY%7D%20%5Cboldsymbol%7BA%7D)%5E%7B*%7D%20%5Cboldsymbol%7BY%7D%3D%5Cboldsymbol%7BY%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BY%7D%3D%5Cboldsymbol%7BY%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因此我们得证，对于任意矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> ，均存在唯一的一个MP逆矩阵，即  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B%2B%7D%7D%3D%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>我们还有一种表示形式，假设  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%5Cin%20%5Cmathbf%7BC%7D%5E%7Bm%20%5Ctimes%20n%7D" style="display:inline-block;margin: 0;"/> 有满秩分解 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%3DF%20G%7D" style="display:inline-block;margin: 0;"/> ，其中 $\boldsymbol{F} \in \boldsymbol{C}^{m \times r}, \boldsymbol{G} \in \boldsymbol{C}^{r  \times n}, r=r(\boldsymbol{A})=r(\boldsymbol{F})=r(\boldsymbol{G}) $ ，则我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%5E%7B%2B%7D%3DG%5E%7B*%7D%5Cleft%28F%5E%7B*%7D%20A%20G%5E%7B*%7D%5Cright%29%5E%7B-1%7D%20F%5E%7B*%7D%7D%0A" /></p><p><strong>证明</strong>：首先我们要证明 <img src="https://math.now.sh?inline=%5Cmathbf%7BF%5E%7B*%7D%20A%20G%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> 为可逆矩阵，注意到  <img src="https://math.now.sh?inline=r%5Cleft%28%5Cboldsymbol%7BF%7D%5E%7B*%7D%20%5Cboldsymbol%7BF%7D%5Cright%29%3Dr(%5Cboldsymbol%7BF%7D)%3Dr%2C%20r%5Cleft(%5Cboldsymbol%7BG%7D%20%5Cboldsymbol%7BG%7D%5E%7B*%7D%5Cright)%3Dr(%5Cboldsymbol%7BG%7D)%3Dr" style="display:inline-block;margin: 0;"/> ，于是方阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BF%7D%5E%7B*%7D%20%5Cboldsymbol%7BF%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BG%7D%20%5Cboldsymbol%7BG%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 均为可逆矩阵，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BF%5E%7B*%7D%20A%20G%5E%7B*%7D%7D%20%3D%20%20%5Cmathbf%7BF%5E%7B*%7D%20F%20G%20%20G%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> 也是可逆矩阵，并且</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%5Cleft%28F%5E%7B*%7D%20A%20G%5E%7B*%7D%5Cright%29%5E%7B-1%7D%3D%5Cleft(G%20G%5E%7B*%7D%5Cright)%5E%7B-1%7D%5Cleft(F%5E%7B*%7D%20F%5Cright)%5E%7B-1%7D%7D%0A" /></p><p>带入 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B%2B%7D%3DG%5E%7B*%7D%5Cleft%28F%5E%7B*%7D%20A%20G%5E%7B*%7D%5Cright%29%5E%7B-1%7D%20F%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> ，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%5E%7B%2B%7D%3DG%5E%7B*%7D%5Cleft%28G%20G%5E%7B*%7D%5Cright%29%5E%7B-1%7D%5Cleft(F%5E%7B*%7D%20F%5Cright)%5E%7B-1%7D%20F%5E%7B*%7D%7D%0A" /></p><p>易证该式满足MP逆矩阵的四个条件，因此该式为 MP 逆矩阵，证明完毕。</p>
<p>实际上，存在（同样可以带入上面四个方程来证明）</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cboldsymbol%7BG%7D%5E%7B%2B%7D%3D%5Cboldsymbol%7BG%7D%5E%7B*%7D%5Cleft%28%5Cboldsymbol%7BG%7D%20%5Cboldsymbol%7BG%7D%5E%7B*%7D%5Cright%29%5E%7B-1%7D%2C%20%5C%5C%0A%26%5Cboldsymbol%7BF%7D%5E%7B%2B%7D%3D%5Cleft(%5Cboldsymbol%7BF%7D%5E%7B*%7D%20%5Cboldsymbol%7BF%7D%5Cright)%5E%7B-1%7D%20%5Cboldsymbol%7BF%7D%5E%7B*%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因此上面的结论也可以写成</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%5E%7B%2B%7D%3D%28F%20G%29%5E%7B%2B%7D%3DG%5E%7B%2B%7D%20F%5E%7B%2B%7D%7D%0A" /></p><p>但是一般来说 <img src="https://math.now.sh?inline=%5Cmathbf%7B%28A%20B%29%5E%7B%2B%7D%20%5Cneq%20B%5E%7B%2B%7D%20A%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/> ，这是 MP 逆矩阵和普通逆矩阵的一个不同之处。</p>
<p>最后一种 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/> 的表达形式如下（缺证明）</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%5E%7B%2B%7D%3DA%5E%7B*%7D%5Cleft%28A%20A%5E%7B*%7D%5Cright%29%5E%7B-%7D%20A%5Cleft(A%5E%7B*%7D%20A%5Cright)%5E%7B-%7D%20A%5E%7B*%7D%7D%0A" /></p><h1>基本性质</h1>
<h2 id="性质1">性质1</h2>
<ul>
<li>
<p><img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B%2B%7D" style="display:inline-block;margin: 0;"/> 的满秩形式</p>
<ul>
<li>
<p>若  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 可逆，则 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B%2B%7D%20%3D%20%5Cmathbf%7BA%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/></p>
</li>
<li>
<p>若  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为列满秩矩阵，则 <img src="https://math.now.sh?inline=%5Cmathbf%7B%20A%5E%7B%2B%7D%20%3D%20%28A%5E%7B*%7DA%29%5E%7B-1%7DA%5E%7B*%7D%20%7D" style="display:inline-block;margin: 0;"/></p>
</li>
<li>
<p>若  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为行满秩矩阵，则 <img src="https://math.now.sh?inline=%5Cmathbf%7B%20A%5E%7B%2B%7D%20%3D%20A%5E%7B*%7D%20%28AA%5E%7B*%7D%29%5E%7B-1%7D%20%7D" style="display:inline-block;margin: 0;"/></p>
</li>
<li>
<p>设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20%3D%20LR%7D" style="display:inline-block;margin: 0;"/> 是秩为 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> 的 <img src="https://math.now.sh?inline=%5Cmathrm%7BC%7D%5E%7Bm%20%5Ctimes%20n%7D" style="display:inline-block;margin: 0;"/> 的矩阵，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=m%20%5Ctimes%20r" style="display:inline-block;margin: 0;"/> 的列满秩矩阵， <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=r%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的行满秩矩阵，则</p>
</li>
</ul>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%20A%5E%7B%2B%7D%20%3D%20R%5E%7B%2B%7DL%5E%7B%2B%7D%20%3D%20R%5E%7B*%7D%20%28RR%5E%7B*%7D%29%5E%7B-1%7D%20%20(L%5E%7B*%7DL)%5E%7B-1%7D%20L%5E%7B*%7D%20%7D%0A" /></p><p>这其实是满足乘法公式的一个特例，证明如下，首先我们知道 <img src="https://math.now.sh?inline=%5Cmathbf%7B%20R%20R%5E%7B%2B%7D%20%3D%20I%7D" style="display:inline-block;margin: 0;"/> ，  <img src="https://math.now.sh?inline=%5Cmathbf%7B%20L%5E%7B%2B%7D%20L%20%3D%20I%7D" style="display:inline-block;margin: 0;"/>  ，因此我们带入MP逆的四个方程，易证 <img src="https://math.now.sh?inline=%5Cmathbf%7B%20A%5E%7B%2B%7D%20%3D%20R%5E%7B%2B%7DL%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/> 。</p>
</li>
<li>
<p><img src="https://math.now.sh?inline=%28%5Cmathbf%7BA%7D%5E%7B%2B%7D%29%5E%7B%2B%7D%20%3D%20%5Cmathbf%7BA%7D%5E%7B%2B%7D" style="display:inline-block;margin: 0;"/></p>
</li>
<li>
<p><img src="https://math.now.sh?inline=%5Cmathbf%7B%5Cleft%28A%5E%7B*%7D%5Cright%29%5E%7B%2B%7D%3D%5Cleft(A%5E%7B%2B%7D%5Cright)%5E%7B*%7D%2C%5Cleft(A%5E%7B%5Cprime%7D%5Cright)%5E%7B%2B%7D%3D%5Cleft(A%5E%7B%2B%7D%5Cright)%5E%7B%5Cprime%7D%7D" style="display:inline-block;margin: 0;"/></p>
<p>只要对MP逆矩阵的四个条件的左右两边均进行转置即可得证。这条性质表明如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为 Hermite 矩阵，则 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B%2B%7D" style="display:inline-block;margin: 0;"/> 也是 Hermite 矩阵。</p>
</li>
<li>
<p>记</p>
</li>
</ul>
<p style=""><img src="https://math.now.sh?from=%5Clambda%5E%7B%2B%7D%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Clambda%5E%7B-1%7D%2C%20%26%20%5Ctext%20%7B%20%E8%8B%A5%20%7D%20%5Clambda%20%5Cneq%200%2C%20%5C%5C%0A0%2C%20%26%20%5Ctext%20%7B%20%E8%8B%A5%20%7D%20%5Clambda%3D0%2C%0A%5Cend%7Barray%7D%5Cright.%0A" /></p><p>​		则</p>
<p style=""><img src="https://math.now.sh?from=%28%5Clambda%20%5Cmathbf%7BA%7D%29%5E%7B%2B%7D%3D%5Clambda%5E%7B%2B%7D%20%5Cmathbf%7BA%7D%5E%7B%2B%7D%0A" /></p><ul>
<li>
<p>若 <img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D%3D%5Coperatorname%7Bdiag%7D%5Cleft%28d_%7B1%7D%2C%20%5Ccdots%2C%20d_%7Bn%7D%5Cright%29" style="display:inline-block;margin: 0;"/>, 则 <img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D%5E%7B%2B%7D%3D%5Coperatorname%7Bdiag%7D%5Cleft%28d_%7B1%7D%5E%7B%2B%7D%2C%20%5Ccdots%2C%20d_%7Bn%7D%5E%7B%2B%7D%5Cright%29" style="display:inline-block;margin: 0;"/></p>
</li>
<li>
<p><img src="https://math.now.sh?inline=r%5Cleft%28%20%5Cmathbf%7BA%7D%5E%7B%2B%7D%5Cright%29%20%3D%20r%5Cleft(%20%5Cmathbf%7BA%7D%5Cright)" style="display:inline-block;margin: 0;"/></p>
</li>
<li>
<p><img src="https://math.now.sh?inline=R%28%5Cmathbf%7BA%7D%5E%7B%2B%7D%29%20%3D%20R(%5Cmathbf%7BA%7D%5E%7B*%7D)" style="display:inline-block;margin: 0;"/></p>
<p>证明：由 {1}-逆的性质 <img src="https://math.now.sh?inline=R%28%5Cmathbf%7BA%7D%5E%7B*%7D%29%20%3D%20R%5Cleft(%5Cmathbf%7B(A%5E%7B-%7DA)%7D%5E%7B*%7D%5Cright)" style="display:inline-block;margin: 0;"/> ，有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AR%28%5Cmathbf%7BA%7D%5E%7B*%7D%29%20%26%3D%20R%5Cleft(%5Cmathbf%7B(A%5E%7B-%7DA)%7D%5E%7B*%7D%5Cright)%20%5C%5C%0A%26%3D%20R%5Cleft(%5Cmathbf%7B(A%5E%7B%2B%7DA)%7D%5E%7B*%7D%5Cright)%20%5C%5C%0A%26%3D%20R%5Cleft(%5Cmathbf%7BA%5E%7B%2B%7DA%7D%5Cright)%20%5C%5C%0A%26%5Csubset%20R%5Cleft(%5Cmathbf%7BA%5E%7B%2B%7DA%7D%5Cright)%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>又由于 <img src="https://math.now.sh?inline=r%5Cleft%28%20%5Cmathbf%7BA%7D%5E%7B%2B%7D%5Cright%29%20%3D%20r%5Cleft(%20%5Cmathbf%7BA%7D%5Cright)%20%3D%20r%5Cleft(%20%5Cmathbf%7BA%7D%5E%7B*%7D%5Cright)" style="display:inline-block;margin: 0;"/> ，因而得证 <img src="https://math.now.sh?inline=R%28%5Cmathbf%7BA%7D%5E%7B%2B%7D%29%20%3D%20R(%5Cmathbf%7BA%7D%5E%7B*%7D)" style="display:inline-block;margin: 0;"/></p>
</li>
<li>
<p><img src="https://math.now.sh?inline=N%28%5Cmathbf%7BA%7D%5E%7B%2B%7D%29%20%3D%20N(%5Cmathbf%7BA%7D%5E%7B*%7D)" style="display:inline-block;margin: 0;"/></p>
</li>
</ul>
<p>同上。</p>
<h2 id="性质2">性质2</h2>
<p>对于任意的矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> ，均有以下等式成立</p>
<ul>
<li><img src="https://math.now.sh?inline=%5Cmathbf%7BA%3DA%20A%5E%7B*%7D%5Cleft%28A%5E%7B%2B%7D%5Cright%29%5E%7B*%7D%3D%5Cleft(A%5E%7B%2B%7D%5Cright)%5E%7B*%7D%20A%5E%7B*%7D%20A%7D" style="display:inline-block;margin: 0;"/>.</li>
<li><img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B%2B%7D%3D%5Cmathbf%7BA%7D%5E%7B%2B%7D%5Cleft%28%5Cmathbf%7BA%7D%5E%7B%2B%7D%5Cright%29%5E%7B*%7D%20%5Cmathbf%7B~A%7D%5E%7B*%7D%3D%5Cmathbf%7BA%7D%5E%7B*%7D%5Cleft(%5Cmathbf%7B~A%7D%5E%7B%2B%7D%5Cright)%5E%7B*%7D%20%5Cmathbf%7B~A%7D%5E%7B%2B%7D" style="display:inline-block;margin: 0;"/>.</li>
<li><img src="https://math.now.sh?inline=%5Cmathbf%7B%5Cleft%28A%5E%7B*%7D%20A%5Cright%29%5E%7B%2B%7D%3DA%5E%7B%2B%7D%5Cleft(A%5E%7B%2B%7D%5Cright)%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/>.</li>
<li><img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B%2B%7D%3D%5Cleft%28A%5E%7B*%7D%20A%5Cright%29%5E%7B%2B%7D%20A%5E%7B*%7D%3DA%5E%7B*%7D%5Cleft(A%20A%5E%7B*%7D%5Cright)%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/>.</li>
</ul>
<p>这里第一条和第二条是等价的，通过第三条可以轻松得到第四条，因此只需要证明第一条和第三条即可。我们先看第一条，代入奇异值分解形式，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BA%20A%5E%7B*%7D%5Cleft%28A%5E%7B%2B%7D%5Cright%29%5E%7B*%7D%7D%0A%26%3D%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7B*%7D%20V%20%5CSigma%5E%7B*%7D%20U%5E%7B*%7D%20U%20%5CSigma%5E%7B%2B%20*%7D%20V%5E%7B*%7D%20%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BU%20%5CSigma%20%5CSigma%5E%7B*%7D%20%20%5CSigma%5E%7B%2B%20*%7D%20V%5E%7B*%7D%20%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BU%20%5CSigma%20(%5CSigma%5E%7B%2B%7D%20%5CSigma)%5E%7B*%7D%20%20%20V%5E%7B*%7D%20%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BU%20%5CSigma%20%20%20%20V%5E%7B*%7D%20%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BA%7D%20%5C%5C%0A%0A%0A%5Cmathbf%7B%5Cleft(A%5E%7B%2B%7D%5Cright)%5E%7B*%7D%20A%5E%7B*%7D%20A%7D%20%20%0A%26%3D%20%5Cmathbf%7BU%20%5CSigma%5E%7B%2B%20*%7D%20V%5E%7B*%7D%20V%20%5CSigma%5E%7B*%7D%20U%5E%7B*%7D%20%20U%20%5CSigma%20V%5E%7B*%7D%20%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BU%20%5CSigma%5E%7B%2B%20*%7D%20%20%5CSigma%5E%7B*%7D%20%20%5CSigma%20V%5E%7B*%7D%20%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BU%20%20%5CSigma%20V%5E%7B*%7D%20%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BA%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>得证第一条。</p>
<p>我们再看第三条，我们易得 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B*%7D%20A%7D%0A%3D%20%5Cmathbf%7BV%20%5CSigma%5E%7B%5Cmathrm%7BT%7D%7D%20U%5E%7B%5Cmathrm%7BT%7D%7D%20%20U%20%5CSigma%20V%5E%7B%5Cmathrm%7BT%7D%7D%20%7D%20%0A%3D%20%5Cmathbf%7BV%20%5CSigma%5E%7B%5Cmathrm%7BT%7D%7D%20%5CSigma%20V%5E%7B%5Cmathrm%7BT%7D%7D%20%7D" style="display:inline-block;margin: 0;"/> ，易知该式就是 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B*%7D%20A%7D" style="display:inline-block;margin: 0;"/> 的对角化/奇异值分解的形式，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B%2B%7D%5Cleft%28A%5E%7B%2B%7D%5Cright%29%5E%7B*%7D%7D%20%3D%20%5Cmathbf%7BV%20(%5CSigma%5E%7B%5Cmathrm%7BT%7D%7D%20%5CSigma)%5E%7B%2B%7D%20V%5E%7B%5Cmathrm%7BT%7D%7D%20%7D" style="display:inline-block;margin: 0;"/> ，其中  <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%5E%7BT%7D%7D%20%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 格式为下式</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7Cl%7D%0A%5Cmathbf%7B%5CSigma_%7B1%7D%5E%7B2%7D%7D%20%26%20%5Cmathbf%7BO%7D%20%5C%5C%0A%5Chline%20%5Cmathbf%7BO%7D%20%26%20%5Cmathbf%7BO%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>易得  <img src="https://math.now.sh?inline=%28%5Cmathbf%7B%5CSigma%5E%7BT%7D%7D%20%5Cmathbf%7B%5CSigma%7D%29%5E%7B%2B%7D%20%3D%20%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D%20%5Cmathbf%7B(%5CSigma%5E%7BT%7D)%5E%7B%2B%7D%7D%20%3D%20%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D%20%5Cmathbf%7B(%5CSigma%5E%7B%2B%7D)%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/>  ，因此我们得证</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%28A%5E%7B*%7DA%29%5E%7B%2B%7D%7D%20%3D%20%5Cmathbf%7BV%20(%5CSigma%5E%7BT%7D%20%5CSigma)%5E%7B%2B%7D%20V%5E%7B%5Cprime%7D%7D%20%20%3D%20%5Cmathbf%7BV%20%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D%20%5Cmathbf%7B(%5CSigma%5E%7B%2B%7D)%5E%7BT%7D%7D%20V%5E%7BT%7D%7D%20%3D%20%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20U%5E%7BT%7D%20U%20(%5CSigma%5E%7B%2B%7D)%5E%7BT%7D%20V%5E%7BT%7D%7D%20%3D%5Cmathbf%7BA%5E%2B%7D%5Cleft(%5Cmathbf%7BA%5E%2B%7D%5Cright)%5E%7B*%7D%0A" /></p><p>同理可证，<img src="https://math.now.sh?inline=%5Cmathbf%7B%5Cleft%28A%20A%5E%7B*%7D%20%5Cright%29%5E%7B%2B%7D%3D%5Cleft(A%5E%7B%2B%7D%5Cright)%5E%7B*%7D%20A%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/></p>
<p>推论，假设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%3D%5Csum_%7Bi%3D1%7D%5E%7Bk%7D%20A_%7Bi%7D%7D" style="display:inline-block;margin: 0;"/> ，并且对一切 <img src="https://math.now.sh?inline=i%20%5Cneq%20j" style="display:inline-block;margin: 0;"/> ，均满足</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA_%7Bi%7D%5E%7B*%7D%20A_%7Bj%7D%3D0%2C%20%5Cquad%20A_%7Bi%7D%20A_%7Bj%7D%5E%7B*%7D%3D0%7D%0A" /></p><p>则有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%5E%7B%2B%7D%3D%5Csum_%7Bi%3D1%7D%5E%7Bk%7D%20A_%7Bi%7D%5E%7B%2B%7D%7D%0A" /></p><p>这个性质同样可以通过带入 MP 逆的四个方程得证。</p>
<h2 id="性质3">性质3</h2>
<p>设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20%5Cin%20C%5E%7Bm%20%5Ctimes%20n%7D%7D" style="display:inline-block;margin: 0;"/> ，则</p>
<ul>
<li>
<p><img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%20%5Cboldsymbol%7BA%7D%2C%20%5Cboldsymbol%7BA%20A%20%5E%20%7B%20%2B%20%7D%7D%2C%20%5Cboldsymbol%7BI%7D_%7Bn%7D-%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%20%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BI%7D_%7Bm%7D-%5Cboldsymbol%7BA%20A%20%5E%20%7B%20%2B%20%7D%7D" style="display:inline-block;margin: 0;"/> 都是 Hermite 幂等矩阵</p>
</li>
<li>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ar%28%5Cboldsymbol%7BA%7D%29%3D%26%20r%5Cleft(%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%5Cright)%3Dr%5Cleft(%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%20%5Cboldsymbol%7BA%7D%5Cright)%3Dr%5Cleft(%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%5Cright)%20%5C%5C%0A%26%20r%5Cleft(%5Cboldsymbol%7BI%7D_%7Bn%7D-%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%20%5Cboldsymbol%7BA%7D%5Cright)%3Dn-r(%5Cboldsymbol%7BA%7D)%20%5C%5C%0A%26%20r%5Cleft(%5Cboldsymbol%7BI%7D_%7Bm%7D-%5Cboldsymbol%7BA%20A%7D%5E%7B%2B%7D%5Cright)%3Dm-r(%5Cboldsymbol%7BA%7D)%0A%5Cend%7Baligned%7D%0A" /></p></li>
<li>
<p><img src="https://math.now.sh?inline=I_%7Bn%7D%20%5Cgeqslant%20A%5E%7B%2B%7D%20A%2C%20I_%7Bm%7D%20%5Cgeqslant%20A%20A%5E%7B%2B%7D" style="display:inline-block;margin: 0;"/>, 这里 <img src="https://math.now.sh?inline=A%20%5Cgeqslant%20B" style="display:inline-block;margin: 0;"/> 表示 <img src="https://math.now.sh?inline=A-B%20%5Cgeqslant%200" style="display:inline-block;margin: 0;"/>.</p>
</li>
</ul>
<p>我们先看第一条，根据MP逆的性质，易得上面四个矩阵为 Hermite 矩阵，我们只需要证明其幂等，如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7B%28A%5E%7B%2B%7DA%29%5E2%7D%20%0A%26%3D%20%5Cmathbf%7BA%5E%7B%2B%7DAA%5E%7B%2B%7DA%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BA%5E%7B%2B%7DA%7D%20%5C%5C%0A%0A%5Cmathbf%7B(AA%5E%7B%2B%7D)%5E2%7D%20%0A%26%3D%20%5Cmathbf%7BAA%5E%7B%2B%7DAA%5E%7B%2B%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BAA%5E%7B%2B%7D%7D%20%5C%5C%0A%0A%5Cmathbf%7B(I_%7Bn%7D%20-%20A%5E%7B%2B%7DA)%5E2%7D%20%0A%26%3D%20%5Cmathbf%7B(I_%7Bn%7D%20-%20A%5E%7B%2B%7DA)(I_%7Bn%7D%20-%20A%5E%7B%2B%7DA)%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BI_%7Bn%7D%20-%202%20A%5E%7B%2B%7DA%20%2B%20(A%5E%7B%2B%7DA)%5E2%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BI_%7Bn%7D%20-%20A%5E%7B%2B%7DA%7D%20%5C%5C%0A%0A%5Cmathbf%7B(I_%7Bm%7D%20-%20AA%5E%7B%2B%7D)%5E2%7D%20%0A%26%3D%20%5Cmathbf%7B(I_%7Bm%7D%20-%20AA%5E%7B%2B%7D)(I_%7Bm%7D%20-%20AA%5E%7B%2B%7D)%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BI_%7Bm%7D%20-%202%20AA%5E%7B%2B%7D%20%2B%20(AA%5E%7B%2B%7D)%5E2%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BI_%7Bm%7D%20-%20AA%5E%7B%2B%7D%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>我们再看第二条性质，根据奇异值分解形式，易得 $r(\boldsymbol{A})= r\left(\boldsymbol{A}^{+}\right) =r\left(\boldsymbol{A}^{+} \boldsymbol{A}\right)=r\left(\boldsymbol{A} \boldsymbol{A}^{+}\right) $  。后面两条可以根据对称幂等矩阵的秩等于秩的性质证明，如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ar%5Cleft%28%5Cmathbf%7BI_%7Bn%7D%20-%20A%5E%7B%2B%7DA%7D%5Cright%29%20%0A%26%3D%20tr%5Cleft(%5Cmathbf%7BI_%7Bn%7D%20-%20A%5E%7B%2B%7DA%7D%5Cright)%20%5C%5C%0A%26%3D%20n%20-%20tr%5Cleft(%5Cmathbf%7B%20A%5E%7B%2B%7DA%7D%5Cright)%20%5C%5C%0A%26%3D%20n%20-%20r%5Cleft(%5Cmathbf%7B%20A%5E%7B%2B%7DA%7D%5Cright)%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>第三条，根据对称幂等矩阵的性质，如果 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 奇异，对称，并且幂等，那么 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 半正定，证明如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ax%5E%7BT%7DAx%20%26%20%3D%20x%5E%7BT%7DA%5E%7B2%7Dx%20%5C%5C%0A%26%3D%20x%5E%7BT%7DA%5E%7BT%7DAx%20%5C%5C%0A%26%3D%20%28Ax%29%5E%7BT%7D(Ax)%20%5C%5C%0A%26%20%5Cgeq%200%0A%5Cend%7Baligned%7D%0A" /></p><p>因此 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BI%7D_%7Bn%7D-%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%20%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BI%7D_%7Bm%7D-%5Cboldsymbol%7BA%20A%20%5E%20%7B%20%2B%20%7D%7D" style="display:inline-block;margin: 0;"/> 均为半正定矩阵。</p>
<h2 id="性质4">性质4</h2>
<p>我们知道向矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的<strong>列空间</strong>投影的投影矩阵为 (<a href="https://vincere.fun/posts/e4aae57/">最小二乘的几何含义</a>)</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BP_%7BA%7D%3DA%5Cleft%28A%5E%7B*%7D%20A%5Cright%29%5E%7B-%7D%20A%5E%7B*%7D%7D%0A" /></p><p>这个式子与所含的广义逆的选择无关，因此我们带入 MP 逆得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BP_%7BA%7D%3DA%5Cleft%28A%5E%7B*%7D%20A%5Cright%29%5E%7B%2B%7D%20A%5E%7B*%7D%20%3D%20AA%5E%7B%2B%7D%7D%0A" /></p><p>因此矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BAA%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/> 为向 <img src="https://math.now.sh?inline=C%28%5Cmathbf%7BA%7D%29" style="display:inline-block;margin: 0;"/> 的正交投影矩阵。</p>
<p>同理可得，向矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的<strong>行空间</strong>投影的投影矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BP_%7BA%5E%7B*%7D%7D%3DA%5E%7B*%7D%5Cleft%28A%20A%5E%7B*%7D%5Cright%29%5E%7B-%7D%20A%3DA%5E%7B*%7D%5Cleft(A%20A%5E%7B*%7D%5Cright)%5E%7B%2B%7D%20A%3DA%5E%7B%2B%7D%20A%7D%0A" /></p><h2 id="性质5">性质5</h2>
<p>对于一般的广义逆（只满足MP逆的第一个方程），假设 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%2CQ%7D" style="display:inline-block;margin: 0;"/> 均为可逆矩阵时，存在</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7BQ%7D%5E%7B-1%7D%20%5Cboldsymbol%7BA%7D%5E%7B-%7D%20%5Cboldsymbol%7BP%7D%5E%7B-1%7D%20%5Cin%28%5Cboldsymbol%7BP%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BQ%7D%29%5C%7B1%5C%7D%0A" /></p><p>证明很简单，如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%28PAQ%29(Q%5E%7B-1%7DA%5E%7B-%7DP%5E%7B-1%7D)((PAQ))%7D%20%3D%20%5Cmathbf%7BPAA%5E%7B-%7DAQ%7D%20%3D%20%5Cmathbf%7BPAQ%7D%0A" /></p><p>但是一般来说，对于 MP 逆，<img src="https://math.now.sh?inline=%28%5Cboldsymbol%7BP%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BQ%7D%29%5E%7B%2B%7D%3D%5Cboldsymbol%7BQ%7D%5E%7B-1%7D%20%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%20%5Cboldsymbol%7BP%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 并不成立，然而我们有以下结论</p>
<ul>
<li>若 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BP%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cboldsymbol%7BQ%7D" style="display:inline-block;margin: 0;"/> 分别为 <img src="https://math.now.sh?inline=m%20%5Ctimes%20m" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 酉阵, 则</li>
</ul>
<p style=""><img src="https://math.now.sh?from=%28%5Cboldsymbol%7BP%20A%7D%20%5Cboldsymbol%7BQ%7D%29%5E%7B%2B%7D%3D%5Cboldsymbol%7BQ%7D%5E%7B-1%7D%20%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%20%5Cboldsymbol%7BP%7D%5E%7B-1%7D%3D%5Cboldsymbol%7BQ%7D%5E%7B*%7D%20%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%20%5Cboldsymbol%7BP%7D%5E%7B*%7D%20%5Ctext%20%7B.%20%7D%0A" /></p><ul>
<li>若 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BP%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BQ%7D" style="display:inline-block;margin: 0;"/> 分别为 <img src="https://math.now.sh?inline=k%20%5Ctimes%20m" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=l%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 阵, 且满足 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BP%7D%5E%7B*%7D%20%5Cboldsymbol%7BP%7D%3D%5Cboldsymbol%7BI%7D_%7Bm%7D" style="display:inline-block;margin: 0;"/>,<br>
<img src="https://math.now.sh?inline=%5Cboldsymbol%7BQ%5E%7B*%7D%20Q%3DI_%7Bn%7D%7D" style="display:inline-block;margin: 0;"/>. 则</li>
</ul>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cboldsymbol%7BP%20A%7D%20%5Cboldsymbol%7BQ%7D%5E%7B*%7D%5Cright%29%5E%7B%2B%7D%3D%5Cboldsymbol%7BQ%7D%20%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%20%5Cboldsymbol%7BP%7D%5E%7B*%7D%0A" /></p><p>证明很简单，只要带入MP逆的四个方程即可得证。</p>
<h2 id="性质6">性质6</h2>
<ul>
<li>若矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为 Hermite 幂等矩阵，则 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B%2B%7D%20%3D%20A%7D" style="display:inline-block;margin: 0;"/></li>
<li>若矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为正规矩阵，则 <img src="https://math.now.sh?inline=%5Cmathbf%7BAA%5E%7B%2B%7D%20%3D%20A%5E%7B%2B%7DA%7D" style="display:inline-block;margin: 0;"/></li>
<li>若矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为正规矩阵，对任意一个自然数 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> , 满足 <img src="https://math.now.sh?inline=%5Cmathbf%7B%28A%5E%7Bk%7D%29%5E%7B%2B%7D%20%3D%20(A%5E%7B%2B%7D)%5E%7Bk%7D%7D" style="display:inline-block;margin: 0;"/></li>
</ul>
<p>第一条证明如下：设 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的正规矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> ( <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B*%7DA%20%3D%20AA%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> ) ，则其对角化分解为</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7BA%7D%3D%5Cboldsymbol%7BU%7D%5Cleft%28%5Cbegin%7Barray%7D%7Bllll%7D%0A%5Clambda_%7B1%7D%20%26%20%26%20%26%20%5C%5C%0A%26%20%5Clambda_%7B2%7D%20%26%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%26%20%26%20%5Cddots%20%26%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%26%20%26%20%5Clambda_%7Bn%7D%0A%5Cend%7Barray%7D%5Cright%29%20%5Cboldsymbol%7BU%7D%5E%7B*%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的酉矩阵，则</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%3D%5Cboldsymbol%7BU%7D%5Cleft%28%5Cbegin%7Barray%7D%7Bccc%7D%0A%5Clambda_%7B1%7D%5E%7B%2B%7D%20%26%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%26%20%5Cddots%20%26%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%26%20%5Clambda_%7Bn%7D%5E%7B%2B%7D%0A%5Cend%7Barray%7D%5Cright%29%20%5Cboldsymbol%7BU%7D%5E%7B*%7D%0A" /></p><p>由于 Hermite 幂等矩阵的特征值只能是 0 和 1 ，因此立即得到  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B%2B%7D%20%3D%20A%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>第二条证明如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BAA%5E%7B%2B%7D%7D%20%0A%26%3D%20%5Cmathbf%7BU%20%5CSigma%20U%5E%7B*%7D%20U%20%5CSigma%5E%7B*%7D%20U%5E%7B*%7D%20%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BU%20%5CSigma%20%5CSigma%5E%7B*%7D%20U%5E%7B*%7D%20%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BU%20%5CSigma%5E%7B2%7D%20U%5E%7B*%7D%20%7D%20%5C%5C%0A%0A%5Cmathbf%7BA%5E%7B%2B%7D%20A%7D%20%0A%26%3D%20%5Cmathbf%7BU%20%5CSigma%5E%7B*%7D%20U%5E%7B*%7D%20U%20%5CSigma%20U%5E%7B*%7D%20%20%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BU%20%5CSigma%5E%7B*%7D%20%5CSigma%20%20U%5E%7B*%7D%20%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BU%20%5CSigma%5E%7B2%7D%20U%5E%7B*%7D%20%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>得证  <img src="https://math.now.sh?inline=%5Cmathbf%7BAA%5E%7B%2B%7D%20%3D%20A%5E%7B%2B%7DA%7D" style="display:inline-block;margin: 0;"/></p>
<p>第三条证明如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7B%28A%5E%7Bk%7D%29%5E%7B%2B%7D%7D%0A%26%3D%20%5Cmathbf%7B(U%20%5CSigma%5E%7Bk%7D%20U%5E%7BT%7D)%5E%7B%2B%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BU%20(%5CSigma%5E%7Bk%7D)%5E%7B%2B%7D%20U%5E%7BT%7D%7D%20%5C%5C%0A%0A%5Cmathbf%7B(A%5E%7B%2B%7D)%5E%7Bk%7D%7D%0A%26%3D%20%5Cmathbf%7B(U%20%5CSigma%5E%7B%2B%7D%20U%5E%7BT%7D)%5E%7Bk%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BU%20(%5CSigma%5E%7B%2B%7D)%5E%7Bk%7D%20U%5E%7BT%7D%7D%20%5C%5C%0A%0A%0A%5Cend%7Baligned%7D%0A" /></p><h2 id="性质7">性质7</h2>
<ul>
<li><img src="https://math.now.sh?inline=%5Cmathbf%7BB%5E%7B%2B%7D%20A%5E%7B%2B%7D%3D0%20%5CLongleftrightarrow%20A%20B%3D0%7D" style="display:inline-block;margin: 0;"/></li>
<li><img src="https://math.now.sh?inline=%5Cmathbf%7BA%20B%5E%7B%2B%7D%3D0%20%5CLongleftrightarrow%20A%20B%5E%7B*%7D%3D0%7D" style="display:inline-block;margin: 0;"/></li>
<li><img src="https://math.now.sh?inline=%5Cmathbf%7BB%5E%7B%2B%7D%20A%3D0%20%5CLongleftrightarrow%20A%5E%7B*%7D%20B%3D0%7D" style="display:inline-block;margin: 0;"/></li>
</ul>
<p>首先证明第一条，首先证明若 <img src="https://math.now.sh?inline=%5Cmathbf%7BAB%3D0%7D" style="display:inline-block;margin: 0;"/> 则 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%5E%7B%2B%7D%20A%5E%7B%2B%7D%3D0%7D" style="display:inline-block;margin: 0;"/> 。此时我们有 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%5E%7B*%7DA%5E%7B*%7D%3D0%7D" style="display:inline-block;margin: 0;"/> ，左乘 <img src="https://math.now.sh?inline=%5Cmathbf%7B%28B%5E%7B*%7DB%29%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/> ，再右乘 <img src="https://math.now.sh?inline=%5Cmathbf%7B%28AA%5E%7B*%7D%29%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/> 得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%5Cleft%28B%5E%7B*%7D%20B%5Cright%29%5E%7B%2B%7D%20B%5E%7B*%7D%20A%5E%7B*%7D%5Cleft(A%20A%5E%7B*%7D%5Cright)%5E%7B%2B%7D%3D0%7D%0A" /></p><p>根据 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B%2B%7D%3D%5Cleft%28A%5E%7B*%7D%20A%5Cright%29%5E%7B%2B%7D%20A%5E%7B*%7D%3DA%5E%7B*%7D%5Cleft(A%20A%5E%7B*%7D%5Cright)%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/> ，可得</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%20B%5E%7B%2B%7D%20A%5E%7B%2B%7D%20%3D%20%5Cleft%28B%5E%7B*%7D%20B%5Cright%29%5E%7B%2B%7D%20B%5E%7B*%7D%20A%5E%7B*%7D%5Cleft(A%20A%5E%7B*%7D%5Cright)%5E%7B%2B%7D%3D0%20%7D%0A" /></p><p>反过来，证明如果  <img src="https://math.now.sh?inline=%5Cmathbf%7BB%5E%7B%2B%7D%20A%5E%7B%2B%7D%3D0%7D" style="display:inline-block;margin: 0;"/>  则 <img src="https://math.now.sh?inline=%5Cmathbf%7BAB%3D0%7D" style="display:inline-block;margin: 0;"/> 。左乘 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%5E%7B*%7DB%7D" style="display:inline-block;margin: 0;"/> ，再右乘 <img src="https://math.now.sh?inline=%5Cmathbf%7BAA%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> ，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7B0%7D%20%26%3D%20%5Cmathbf%7BB%5E%7B*%7D%20B%20B%5E%7B%2B%7D%20A%5E%7B%2B%7D%20A%20A%5E%7B*%7D%3DB%5E%7B*%7D%5Cleft%28B%20B%5E%7B%2B%7D%5Cright%29%5E%7B*%7D%5Cleft(A%5E%7B%2B%7D%20A%5Cright)%5E%7B*%7D%20A%5E%7B*%7D%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BB%5E%7B*%7D%5Cleft(B%5E%7B%2B%7D%5Cright)%5E%7B*%7D%20B%5E%7B*%7D%20A%5E%7B*%7D%5Cleft(A%5E%7B%2B%7D%5Cright)%5E%7B*%7D%20A%5E%7B*%7D%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BB%5E%7B*%7D%20A%5E%7B*%7D%3D(A%20B)%5E%7B*%7D%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>再证明第二条，若  <img src="https://math.now.sh?inline=%5Cmathbf%7BAB%5E%7B*%7D%3D0%7D" style="display:inline-block;margin: 0;"/> ，右乘 <img src="https://math.now.sh?inline=%5Cmathbf%7B%28B%5E%7B%2B%7D%29%5E%7B*%7DB%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/> 得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BAB%5E%7B*%7D%28B%5E%7B%2B%7D%29%5E%7B*%7DB%5E%7B%2B%7D%3D%20AB%5E%7B%2B%7D%20%3D0%7D" style="display:inline-block;margin: 0;"/> ；反过来，如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BAB%5E%7B%2B%7D%3D0%7D" style="display:inline-block;margin: 0;"/>  ，右乘 <img src="https://math.now.sh?inline=%5Cmathbf%7BBB%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> ，我们得到 <img src="https://math.now.sh?inline=%5Cmathbf%7B%20AB%5E%7B%2B%7DBB%5E%7B*%7D%20%3D%20A%28B%5E%7B%2B%7DB%29%5E%7B*%7DB%5E%7B*%7D%20%3D%20AB%5E%7B*%7D(B%5E%7B%2B%7D)%5E%7B*%7DB%5E%7B*%7D%20%3D%20AB%5E%7B*%7D%20%3D%200%7D" style="display:inline-block;margin: 0;"/>  。</p>
<p>第三条根据第二条同理可证。</p>
<h1>乘法公式</h1>
<p>对于 MP 逆矩阵，乘法公式一般不成立，即 <img src="https://math.now.sh?inline=%5Cmathbf%7B%28AB%29%5E%7B%2B%7D%20%5Cneq%20B%5E%7B%2B%7DA%5E%7B%2B%7D%20%7D" style="display:inline-block;margin: 0;"/> ，但是在某些条件下这个等式成立。</p>
<p>我们先看一个<strong>引理</strong>，设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%5Cin%20C%5E%7Bm%20%5Ctimes%20n%7D%2C%20%5Cmathbf%7BX%7D%20%5Cin%20C%5E%7Bn%20%5Ctimes%20m%7D%2C%20r%28%5Cmathbf%7BX%7D%29%20%5Cleqslant%20r(%5Cmathbf%7BA%7D)" style="display:inline-block;margin: 0;"/>,</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7BA%7D%3D%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%20%5Cboldsymbol%7BA%7D%2C%20%5Cquad%20%5Cboldsymbol%7BA%20X%7D%3D%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%2C%0A" /></p><p>则必有 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%3DA%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/>。</p>
<p>证明：容易看出MP逆的后两个方程成立，因此只需要看前两个方程，我们有 <img src="https://math.now.sh?inline=%5Cmathbf%7BAXA%20%3D%20A%28A%5E%7B%2B%7DA%29%20%3D%20A%7D" style="display:inline-block;margin: 0;"/> ，因此第一个方程成立，再证明第二个方程，我们有</p>
<p style=""><img src="https://math.now.sh?from=r%28X%29%20%5Cleqslant%20r(%5Cboldsymbol%7BA%7D)%3Dr(%5Cboldsymbol%7BA%20X%20A%7D)%20%5Cleqslant%20r(%20%5Cboldsymbol%7BX%20A%7D)%20%5Cleqslant%20r(X)%0A" /></p><p>因此得到</p>
<p style=""><img src="https://math.now.sh?from=r%28%5Cmathbf%7BX%7D%29%20%3D%20r(%5Cmathbf%7BXA%7D)%0A" /></p><p>由于 <img src="https://math.now.sh?inline=%5Cmathbf%7BXA%7D" style="display:inline-block;margin: 0;"/> 的列均是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的列的线性组合，因此</p>
<p style=""><img src="https://math.now.sh?from=C%28%5Cmathbf%7BX%7D%29%20%3D%20C(%5Cmathbf%7BXA%7D)%0A" /></p><p>因此存在矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BY%7D" style="display:inline-block;margin: 0;"/> ，使得 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%20%3D%20XAY%7D" style="display:inline-block;margin: 0;"/> ，对这个式子左乘 <img src="https://math.now.sh?inline=%5Cmathbf%7BXA%7D" style="display:inline-block;margin: 0;"/> 得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%20A%20X%3DX%20%28A%20X%20A%29%20Y%3DX%20A%20Y%3DX%7D%0A" /></p><p>得证。</p>
<h2 id="充分必要条件">充分必要条件</h2>
<p><strong>当且仅当</strong>下列两个条件同时成立时，乘法公式  <img src="https://math.now.sh?inline=%5Cmathbf%7B%28AB%29%5E%7B%2B%7D%20%3D%20B%5E%7B%2B%7DA%5E%7B%2B%7D%20%7D" style="display:inline-block;margin: 0;"/> 成立。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cboldsymbol%7BA%5E%7B%2B%7D%20A%20B%20B%5E%7B*%7D%20A%5E%7B*%7D%7D%20%26%3D%5Cboldsymbol%7BB%7D%20%5Cboldsymbol%7BB%7D%5E%7B*%7D%20%5Cboldsymbol%7BA%7D%5E%7B*%7D%2C%20%5C%5C%0A%5Cboldsymbol%7BB%20B%5E%7B%2B%7D%20A%5E%7B*%7D%20A%20B%7D%20%26%3D%5Cboldsymbol%7BA%7D%5E%7B*%7D%20%5Cboldsymbol%7BA%20B%7D%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>证明：</p>
<p>首先证明<strong>充分性</strong>，假设这两个条件成立，用 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D%5E%7B%2B%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7B%28AB%29%7D%5E%7B*%20%2B%7D" style="display:inline-block;margin: 0;"/> 分别左乘、右乘 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%5E%7B%2B%7D%20A%20B%20B%5E%7B*%7D%20A%5E%7B*%7D%7D%20%3D%5Cboldsymbol%7BB%7D%20%5Cboldsymbol%7BB%7D%5E%7B*%7D%20%5Cboldsymbol%7BA%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/>  的两边，其左侧变为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BB%5E%7B%2B%7D%20A%5E%7B%2B%7D%20A%20B%20B%5E%7B*%7D%20A%5E%7B*%7D%28A%20B%29%5E%7B*%20%2B%7D%7D%0A%26%3D%20%5Cmathbf%7BB%5E%7B%2B%7D%20A%5E%7B%2B%7D(A%20B)(A%20B)%5E%7B*%7D(A%20B)%5E%7B*%2B%7D%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>根据 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%3DA%20A%5E%7B*%7D%5Cleft%28A%5Cright%29%5E%7B%2B*%7D%7D" style="display:inline-block;margin: 0;"/> ，得到 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%20B%7D%28%5Cboldsymbol%7BA%20B%7D%29%5E%7B*%7D(%5Cboldsymbol%7BA%20B%7D)%5E%7B*%2B%7D%3D%5Cboldsymbol%7BA%20B%7D" style="display:inline-block;margin: 0;"/> ，得到左侧为 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%5E%7B%2B%7D%20A%5E%7B%2B%7D%20A%20B%7D" style="display:inline-block;margin: 0;"/> 。我们看右侧为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BB%5E%7B%2B%7D%20B%20B%5E%7B*%7D%20A%5E%7B*%7D%28A%20B%29%5E%7B*%2B%7D%7D%20%0A%26%3D%20%5Cmathbf%7B%5Cleft(B%5E%7B%2B%7D%20B%20B%5E%7B*%7D%5Cright)%20A%5E%7B*%7D(A%20B)%5E%7B*%2B%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BB%5E%7B*%7D%20A%5E%7B*%7D(A%20B)%5E%7B*%2B%7D%7D%20%5Cquad%20%5Cbecause%20%5Cmathbf%7BA%20%3D%20A%5E%7B%2B*%7D%20A%5E%7B*%7D%20A%7D%5C%5C%0A%26%3D%20%5Cmathbf%7B(A%20B)%5E%7B*%7D%5Cleft(A%20B%5Cright)%5E%7B*%2B%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7B%5Cleft((A%20B)%5E%7B%2B%7DAB%5Cright)%5E%7B*%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7B(A%20B)%5E%7B%2B%7DAB%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>左侧等于右侧得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BB%5E%7B%2B%7D%20A%5E%7B%2B%7D%20A%20B%7D%20%3D%20%5Cmathbf%7B%28A%20B%29%5E%7B%2B%7DAB%7D%0A" /></p><p>我们再看第二个条件，将其两边做转置共轭运算，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BB%5E%7B*%7D%20A%5E%7B*%7D%20A%5Cleft%28B%5E%7B%2B%7D%5Cright%29%5E%7B*%7D%20B%5E%7B*%7D%3DB%5E%7B*%7D%20A%5E%7B*%7D%20A%7D%20%0A" /></p><p>用 <img src="https://math.now.sh?inline=%5Cmathbf%7B%28AB%29%7D%5E%7B*%2B%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B%2B%7D" style="display:inline-block;margin: 0;"/> 分别左乘、右乘上式两边，左边变为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%20%5Cmathbf%7B%28A%20B%29%5E%7B*%2B%7D%20B%5E%7B*%7D%20A%5E%7B*%7D%20A%20B%5E%7B*%2B%7D%20B%5E%7B*%7D%20A%5E%7B%2B%7D%7D%20%5C%5C%0A%3D%26%20%5Cmathbf%7B(A%20B)%5E%7B*%2B%7D(A%20B)%5E%7B*%7D%20A%20B%5E%7B*%2B%7D%20B%5E%7B*%7D%20A%5E%7B%2B%7D%7D%20%5C%5C%0A%3D%26%20%5Cmathbf%7B(A%20B)%5E%7B*%2B%7D(A%20B)%5E%7B*%7D%20A%5Cleft(B%20B%5E%7B%2B%7D%5Cright)%5E%7B*%7D%20A%5E%7B%2B%7D%7D%20%5C%5C%0A%3D%26%20%5Cmathbf%7B(A%20B)%5E%7B*%2B%7D(A%20B)%5E%7B*%7D%20A%20B%20B%5E%7B%2B%7D%20A%5E%7B%2B%7D%7D%20%5C%5C%0A%3D%26%20%5Cmathbf%7BA%20B%20B%5E%7B%2B%7D%20A%5E%7B%2B%7D%7D%20%5Cquad%20%5Cbecause%20%5Cmathbf%7BA%20%3D%20A%5E%7B%2B*%7D%20A%5E%7B*%7D%20A%7D%20%0A%5Cend%7Baligned%7D%0A" /></p><p>右侧变为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7B%28A%20B%29%5E%7B*%2B%7D%20B%5E%7B*%7D%20A%5E%7B*%7D%20A%20A%5E%7B%2B%7D%7D%0A%3D%26%20%5Cmathbf%7B(A%20B)%5E%7B*%2B%7D%20B%5E%7B*%7D%20A%5E%7B*%7D%7D%20%5Cquad%20%5Cbecause%20%5Cmathbf%7BA%20%3D%20A%20A%5E%7B*%7D%20A%5E%7B*%20%2B%7D%7D%5C%5C%0A%3D%26%20%5Cmathbf%7B(A%20B)%5E%7B*%2B%7D(A%20B)%5E%7B*%7D%7D%20%5C%5C%0A%3D%26%20%5Cmathbf%7B%5Cleft(A%20B(A%20B)%5E%7B%2B%7D%5Cright)%5E%7B*%7D%7D%20%5C%5C%0A%3D%26%20%5Cmathbf%7BA%20B(A%20B)%5E%7B%2B%7D%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>左侧等于右侧，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%20B%20B%5E%7B%2B%7D%20A%5E%7B%2B%7D%7D%20%3D%20%5Cmathbf%7BA%20B%28A%20B%29%5E%7B%2B%7D%7D%0A" /></p><p>另外，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7B%20B%5E%7B%2B%7D%20A%5E%7B%2B%7D%20%7D%0A%26%3D%5Cmathbf%7BB%5E%7B%2B%7D%20B%20B%5E%7B%2B%7D%20A%5E%7B%2B%7D%20A%20A%5E%7B%20%2B%20%7D%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BB%5E%7B%2B%7D%20%28B%20B%5E%7B%2B%7D%29%5E%7B*%7D%20(A%5E%7B%2B%7D%20A)%5E%7B*%7D%20A%5E%7B%20%2B%20%7D%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BB%5E%7B%2B%7D%20B%5E%7B%2B%20*%7D%20B%5E%7B*%7D%20A%5E%7B*%7D%20A%5E%7B%2B%7D%7B%20%7D%5E%7B*%7D%20A%5E%7B*%7D%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BB%5E%7B%2B%7D%20B%5E%7B%2B%20*%7D(A%20B)%5E%7B*%7D%20A%5E%7B%2B%7D%7B%20%7D%5E%7B*%7D%20A%5E%7B%2B%7D%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因此</p>
<p style=""><img src="https://math.now.sh?from=r%5Cleft%28%5Cboldsymbol%7BB%7D%5E%7B%2B%7D%20%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%5Cright%29%20%5Cleqslant%20r(%5Cboldsymbol%7BA%20B%7D)%0A" /></p><p>将这个式子，与两个条件的推导式子结合起来，再利用乘法公式一开始介绍的引理 (设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%5Cin%20C%5E%7Bm%20%5Ctimes%20n%7D%2C%20%5Cmathbf%7BX%7D%20%5Cin%20C%5E%7Bn%20%5Ctimes%20m%7D%2C%20r%28%5Cmathbf%7BX%7D%29%20%5Cleqslant%20r(%5Cmathbf%7BA%7D)" style="display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7BA%7D%3D%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%20%5Cboldsymbol%7BA%7D%2C%20%5Cquad%20%5Cboldsymbol%7BA%20X%7D%3D%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%2C" style="display:inline-block;margin: 0;"/> 则必有 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%3DA%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/>。) ，因此我们证明了乘法公式成立，即  <img src="https://math.now.sh?inline=%5Cmathbf%7B%28AB%29%5E%7B%2B%7D%20%3D%20B%5E%7B%2B%7DA%5E%7B%2B%7D%20%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>我们再看<strong>必要性</strong>，根据 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20%3D%20A%5E%7B*%20%2B%7D%20A%5E%7B*%7D%20A%7D" style="display:inline-block;margin: 0;"/>  ，我们有 <img src="https://math.now.sh?inline=%28%5Cboldsymbol%7BA%20B%7D%29%5E%7B*%7D%3D(%5Cboldsymbol%7BA%20B%7D)%5E%7B%2B%7D(%5Cboldsymbol%7BA%20B%7D)(%5Cboldsymbol%7BA%20B%7D)%5E%7B*%7D" style="display:inline-block;margin: 0;"/> ，带入乘法公式，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7BB%7D%5E%7B*%7D%20%5Cboldsymbol%7BA%7D%5E%7B*%7D%3D%5Cboldsymbol%7BB%7D%5E%7B%2B%7D%20%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%20%5Cboldsymbol%7BA%20B%7D%20%5Cboldsymbol%7BB%7D%5E%7B*%7D%20%5Cboldsymbol%7BA%7D%5E%7B*%7D%20.%0A" /></p><p>用 <img src="https://math.now.sh?inline=%5Cmathbf%7BABB%5E%7B*%7DB%7D" style="display:inline-block;margin: 0;"/> 左乘上式，并利用 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%5E%7B*%7DBB%5E%7B%2B%7D%20%3D%20B%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> ，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BA%20B%20B%5E%7B*%7D%20B%20B%5E%7B*%7D%20A%5E%7B*%7D%7D%20%26%3D%20%5Cmathbf%7BA%20B%20B%5E%7B*%7D%20B%20B%5E%7B%2B%7D%20A%5E%7B%2B%7D%20A%20B%20B%5E%7B*%7D%20A%5E%7B*%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BA%20B%20B%5E%7B*%7D%20A%5E%7B%2B%7D%20A%20B%20B%5E%7B*%7D%20A%5E%7B*%7D%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>即</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%20B%20B%5E%7B*%7D%5Cleft%28I-A%5E%7B%2B%7D%20A%5Cright%29%20B%20B%5E%7B*%7D%20A%5E%7B*%7D%3D0%7D%0A" /></p><p>因为 <img src="https://math.now.sh?inline=%5Cmathbf%7BI-A%5E%7B%2B%7D%20A%7D" style="display:inline-block;margin: 0;"/> 为半正定 Hermite 矩阵，因此可以分解为  <img src="https://math.now.sh?inline=%5Cmathbf%7BI-A%5E%7B%2B%7D%20A%20%3D%20U%20%5CSigma%20U%5E%7B*%7D%20%3D%20U%20%5CSigma%5E%7B0.5%7D%20%5CSigma%5E%7B0.5%7D%20%20U%5E%7B*%7D%20%3D%20C%20C%5E%7B*%7D%20%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%20%3D%20U%20%5CSigma%5E%7B0.5%7D%7D" style="display:inline-block;margin: 0;"/> ，因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%20B%20B%5E%7B*%7DC%20C%5E%7B*%7D%20B%20B%5E%7B*%7D%20A%5E%7B*%7D%20%3D%20%28A%20B%20B%5E%7B*%7DC%29(A%20B%20B%5E%7B*%7DC)%5E%7B*%7D%20%3D0%7D%0A" /></p><p>因此 <img src="https://math.now.sh?inline=r%5Cleft%28%5Cmathbf%7BA%20B%20B%5E%7B*%7DC%7D%5Cright%29%20%3D%20r%5Cleft(%5Cmathbf%7B(A%20B%20B%5E%7B*%7DC)%5E%7B*%7D%7D%5Cright)%20%3Dr%5Cleft(%5Cmathbf%7B(A%20B%20B%5E%7B*%7DC)(A%20B%20B%5E%7B*%7DC)%5E%7B*%7D%7D%5Cright)%20%3D0" style="display:inline-block;margin: 0;"/> ，由于只有 <img src="https://math.now.sh?inline=%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> 矩阵的秩才为 0 ，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%5E%7B*%7D%20B%20B%5E%7B*%7D%20A%5E%7B*%7D%20%3D%200%7D" style="display:inline-block;margin: 0;"/> ，左乘 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> ，得到 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Cleft%28I-A%5E%7B%2B%7D%20A%5Cright%29%20B%20B%5E%7B*%7D%20A%5E%7B*%7D%3D0%7D" style="display:inline-block;margin: 0;"/> ，因此证明了第一个条件。</p>
<p>第二个条件等价于证明 <img src="https://math.now.sh?inline=%5Cmathbf%7B%28%20I%20-%20B%20B%5E%7B%2B%7D%20%29%20A%5E%7B*%7D%20A%20B%20%3D%200%7D" style="display:inline-block;margin: 0;"/> ，这和第一个条件是类似地，因此同理可得第二个条件成立。</p>
<h2 id="推论1">推论1</h2>
<p><strong>推论</strong>：当且仅当下面两个条件成立时，乘法公式成立</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0AC%5Cleft%28%5Cboldsymbol%7BB%7D%20%5Cboldsymbol%7BB%7D%5E%7B*%7D%20%5Cboldsymbol%7BA%7D%5E%7B*%7D%5Cright%29%20%5Csubset%20C%5Cleft(%5Cboldsymbol%7BA%7D%5E%7B*%7D%5Cright)%20%5C%5C%0AC%5Cleft(%5Cboldsymbol%7BA%7D%5E%7B*%7D%20%5Cboldsymbol%7BA%20B%7D%5Cright)%20%5Csubset%20C(%5Cboldsymbol%7BB%7D)%0A%5Cend%7Bgathered%7D%0A" /></p><p>证明：我们只需要证明这里的两个条件和上面的两个条件等价即可。</p>
<p>因为 <img src="https://math.now.sh?inline=%5Cmathbf%7BBB%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 列空间的投影矩阵，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%5E%7B%2B%7DA%20%3D%20P_%7BA%5E%7B*%7D%7D%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BBB%5E%7B%2B%7D%20%3D%20P_%7BB%7D%7D%0A" /></p><p>于是我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BA%5E%7B%2B%7D%20A%20B%20B%5E%7B*%7D%20A%5E%7B*%7D%7D%20%0A%26%3D%20%5Cmathbf%7BP_%7BA%5E%7B*%7D%7D%20B%20B%5E%7B*%7D%20A%5E%7B*%7D%20%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BB%20B%5E%7B*%7D%20A%5E%7B*%7D%7D%20%5CLongleftrightarrow%20C%5Cleft%28%5Cboldsymbol%7BB%7D%20%5Cboldsymbol%7BB%7D%5E%7B*%7D%20%5Cboldsymbol%7BA%7D%5E%7B*%7D%5Cright%29%20%5Csubset%20C%5Cleft(%5Cboldsymbol%7BA%7D%5E%7B*%7D%5Cright)%20%5C%5C%20%20%5C%5C%0A%0A%5Cmathbf%7BB%20B%5E%7B%2B%7D%20A%5E%7B*%7D%20A%20B%7D%0A%26%3D%20%5Cmathbf%7BP_%7BB%7D%20A%5E%7B*%7D%20A%20B%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BA%5E%7B*%7D%20A%20B%7D%20%5CLongleftrightarrow%20C%5Cleft(%5Cboldsymbol%7BA%7D%5E%7B*%7D%20%5Cboldsymbol%7BA%20B%7D%5Cright)%20%5Csubset%20C(%5Cboldsymbol%7BB%7D)%20%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><h2 id="推论2">推论2</h2>
<p><strong>推论</strong>：若 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B%2B%7D%20A%20B%20B%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B*%7D%20A%20B%20B%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/>皆为 Hermite 阵, 则乘法公式成立.</p>
<p>证明：若 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B%2B%7D%20A%20B%20B%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> 为 Hermite 矩阵，则</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%5E%7B%2B%7D%20A%20B%20B%5E%7B*%7D%20%3D%20B%20B%5E%7B*%7D%20%28A%5E%7B%2B%7D%20A%29%5E%7B*%7D%20%3D%20B%20B%5E%7B*%7D%20A%5E%7B%2B%7D%20A%20%7D%20%0A" /></p><p>用 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 右乘上式，得</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%5E%7B%2B%7D%20A%20B%20B%5E%7B*%7D%20A%5E%7B*%7D%20%3D%20B%20B%5E%7B*%7D%20A%5E%7B%2B%7D%20A%20A%5E%7B*%7D%20%3D%20B%20B%5E%7B*%7D%20A%5E%7B*%7D%20%7D%0A" /></p><p>因此充要条件的第一个条件成立。</p>
<p>若  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B*%7D%20A%20B%20B%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/> 为 Hermite 矩阵，则</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%5E%7B*%7D%20A%20B%20B%5E%7B%2B%7D%20%3D%20%28B%20B%5E%7B%2B%7D%29%5E%7B*%7DA%5E%7B*%7D%20A%20%3D%20B%20B%5E%7B%2B%7DA%5E%7B*%7D%20A%20%20%20%7D%0A" /></p><p>用 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 右乘上式，得</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%20B%20B%5E%7B%2B%7DA%5E%7B*%7D%20A%20B%20%3D%20A%5E%7B*%7D%20A%20B%20B%5E%7B%2B%7D%20B%20%3D%20%20%20A%5E%7B*%7D%20A%20B%20%7D%0A" /></p><p>因此充要条件的第二个条件成立，于是乘法公式成立，得证。</p>
<h1>参考文献</h1>
<ol>
<li>Rencher A C, Schaalje G B. Linear models in statistics[M]. John Wiley &amp; Sons, 2008.</li>
<li>王松桂, 杨振海. 广义逆矩阵及其应用[M]. 北京工业大学出版社, 1996.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>广义逆及其性质</title>
    <url>/posts/73361a24/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本章节介绍最普通的广义逆，{1}-广义逆的构造和性质。</p>
<span id="more"></span>
<h1>{1}-逆的定义</h1>
<p>一个相容的线性方程组  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%5Cmathbf%7Bx%7D%3D%5Cmathbf%7Bc%7D" style="display:inline-block;margin: 0;"/> 的解可以表示为 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的广义逆的式子。</p>
<p>对于一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> ，定义其广义逆  <img src="https://math.now.sh?inline=A%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 满足：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%20%5Cmathbf%7BA%7D%5E%7B-%7D%20%5Cmathbf%7BA%7D%3D%5Cmathbf%7BA%7D%0A" /></p><p>一个矩阵广义逆一般不唯一，除非矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 为非奇异矩阵，此时 <img src="https://math.now.sh?inline=A%5E%7B-%7D%20%3D%20A%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>无论是方阵，还是非方阵也有广义逆，甚至向量均有广义逆，比如如果</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bx%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bl%7D%0A1%20%5C%5C%0A2%20%5C%5C%0A3%20%5C%5C%0A4%0A%5Cend%7Barray%7D%5Cright%29%0A" /></p><p>它的一个广义逆为 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D_%7B1%7D%5E%7B-%7D%3D%281%2C0%2C0%2C0%29" style="display:inline-block;margin: 0;"/> 。</p>
<p><strong>定理</strong>： 如果 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的矩阵，那么其广义逆 <img src="https://math.now.sh?inline=A%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 为 $ p \times n$ 的矩阵。</p>
<h1>{1}-逆的构造</h1>
<h2 id="一般构造">一般构造</h2>
<h3 id="第一种形式">第一种形式</h3>
<p><strong>定理</strong>：设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%5Cin%20%5Cmathbf%7BC%7D%5E%7Bm%20%5Ctimes%20n%7D" style="display:inline-block;margin: 0;"/> , 其秩为 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> ，其相抵标准形为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%3D%20%5Cmathbf%7BP%7D%20%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BI%7D_%7Br%7D%20%26%20%5Cmathbf%7BO%7D%20%5C%5C%0A%5Cmathbf%7BO%7D%20%26%20%5Cmathbf%7BO%7D%0A%5Cend%7Barray%7D%5Cright%29%20%5Cmathbf%7BQ%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D" style="display:inline-block;margin: 0;"/> 分别为 <img src="https://math.now.sh?inline=m%20%5Ctimes%20m" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的可逆矩阵，则</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%5E%7B-%7D%7D%20%3D%20%5Cmathbf%7BQ%7D%5E%7B-1%7D%20%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BI%7D_%7Br%7D%20%26%20%5Cmathbf%7BB%7D_%7B12%7D%20%5C%5C%0A%5Cmathbf%7BB%7D_%7B21%7D%20%26%20%5Cmathbf%7BB%7D_%7B22%7D%0A%5Cend%7Barray%7D%5Cright%29%20%5Cmathbf%7BP%7D%5E%7B-1%7D%0A" /></p><p>其中  <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D_%7B12%7D" style="display:inline-block;margin: 0;"/>、 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D_%7B21%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D_%7B22%7D" style="display:inline-block;margin: 0;"/> 为任意矩阵。</p>
<p><strong>证明</strong>：设 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 为任意一个 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B-%7D" style="display:inline-block;margin: 0;"/> ，则有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BP%7D%20%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BI%7D_%7Br%7D%20%26%20%5Cmathbf%7BO%7D%20%5C%5C%0A%5Cmathbf%7BO%7D%20%26%20%5Cmathbf%7BO%7D%0A%5Cend%7Barray%7D%5Cright%29%20%5Cmathbf%7BQ%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BP%7D%20%5Cleft(%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BI%7D_%7Br%7D%20%26%20%5Cmathbf%7BO%7D%20%5C%5C%0A%5Cmathbf%7BO%7D%20%26%20%5Cmathbf%7BO%7D%0A%5Cend%7Barray%7D%5Cright)%20%5Cmathbf%7BQ%7D%20%3D%20%5Cmathbf%7BP%7D%20%5Cleft(%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BI%7D_%7Br%7D%20%26%20%5Cmathbf%7BO%7D%20%5C%5C%0A%5Cmathbf%7BO%7D%20%26%20%5Cmathbf%7BO%7D%0A%5Cend%7Barray%7D%5Cright)%20%5Cmathbf%7BQ%7D%0A" /></p><p>因为  <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D" style="display:inline-block;margin: 0;"/> 均为可逆矩阵，因此同时左乘  <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 和 右乘 <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BI%7D_%7Br%7D%20%26%20%5Cmathbf%7BO%7D%20%5C%5C%0A%5Cmathbf%7BO%7D%20%26%20%5Cmathbf%7BO%7D%0A%5Cend%7Barray%7D%5Cright%29%20%5Cmathbf%7BQ%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BP%7D%20%5Cleft(%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BI%7D_%7Br%7D%20%26%20%5Cmathbf%7BO%7D%20%5C%5C%0A%5Cmathbf%7BO%7D%20%26%20%5Cmathbf%7BO%7D%0A%5Cend%7Barray%7D%5Cright)%20%20%3D%20%5Cleft(%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BI%7D_%7Br%7D%20%26%20%5Cmathbf%7BO%7D%20%5C%5C%0A%5Cmathbf%7BO%7D%20%26%20%5Cmathbf%7BO%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>若设</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BQXP%7D%20%3D%20%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BB%7D_%7B11%7D%20%26%20%5Cmathbf%7BB%7D_%7B12%7D%20%5C%5C%0A%5Cmathbf%7BB%7D_%7B21%7D%20%26%20%5Cmathbf%7BB%7D_%7B22%7D%0A%5Cend%7Barray%7D%5Cright%29%0A" /></p><p>代入上式，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BB%7D_%7B11%7D%20%26%20%5Cmathbf%7BO%7D%20%5C%5C%0A%5Cmathbf%7BO%7D%20%26%20%5Cmathbf%7BO%7D%0A%5Cend%7Barray%7D%5Cright%29%20%20%3D%20%5Cleft(%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BI%7D_%7Br%7D%20%26%20%5Cmathbf%7BO%7D%20%5C%5C%0A%5Cmathbf%7BO%7D%20%26%20%5Cmathbf%7BO%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>因此，我们得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D_%7B11%7D%20%3D%20%5Cmathbf%7BI%7D_%7Br%7D" style="display:inline-block;margin: 0;"/> 。这就证明了，当且仅当下式成立时， <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 为一个广义逆 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B-%7D" style="display:inline-block;margin: 0;"/></p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BQXP%7D%20%3D%20%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BB%7D_%7B11%7D%20%26%20%5Cmathbf%7BO%7D%20%5C%5C%0A%5Cmathbf%7BO%7D%20%26%20%5Cmathbf%7BO%7D%0A%5Cend%7Barray%7D%5Cright%29%0A" /></p><p>得证。</p>
<p>则所有的 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 的集合为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%5C%7B1%5C%7D%20%3D%20%5Cleft%5C%7B%5Cmathbf%7BA%7D%5E%7B-%7D%3A%5Cmathbf%7BA%7D%5E%7B-%7D%20%3D%20%5Cmathbf%7BQ%7D%5E%7B-1%7D%20%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BI%7D_%7Br%7D%20%26%20%5Cmathbf%7BB%7D_%7B12%7D%20%5C%5C%0A%5Cmathbf%7BB%7D_%7B21%7D%20%26%20%5Cmathbf%7BB%7D_%7B22%7D%0A%5Cend%7Barray%7D%5Cright%29%20%5Cmathbf%7BP%7D%5E%7B-1%7D%2C%20%5Cmathbf%7BB%7D_%7Bij%7D%20%5Ctext%7B%20%E4%B8%BA%E9%80%82%E5%BD%93%E9%98%B6%E6%95%B0%E7%9A%84%E4%BB%BB%E6%84%8F%E7%9F%A9%E9%98%B5%7D%20%20%5Cright%5C%7D%0A" /></p><h3 id="第二种形式">第二种形式</h3>
<p><strong>定理</strong>：设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%5Cin%20%5Cmathbf%7BC%7D%5E%7Bm%20%5Ctimes%20n%7D" style="display:inline-block;margin: 0;"/> ,  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 为其特定的一个广义逆，则</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BA%7D%5C%7B1%5C%7D%20%26%3D%20%5Cleft%5C%7B%20%5Cmathbf%7BA%5E%7B-%7D%20%2B%20U%20-%20A%5E%7B-%7DAUAA%5E%7B-%7D%7D%2C%20%5Cquad%20%5Cmathbf%7BU%7D%20%5Cin%20%5Cmathbf%7BC%7D%5E%7Bn%20%5Ctimes%20m%7D%20%5Ctext%7B%20%E4%B8%BA%E4%BB%BB%E6%84%8F%E7%9F%A9%E9%98%B5%20%7D%20%20%20%5Cright%5C%7D%3B%20%5C%5C%0A%0A%5Cmathbf%7BA%7D%5C%7B1%5C%7D%20%26%3D%20%5Cleft%5C%7B%20%5Cmathbf%7BA%5E%7B-%7D%20%2BZ%28I_%7Bm%7D%20-%20AA%5E%7B-%7D%29%20%2B%20(I_%7Bn%7D%20-%20A%5E%7B-%7DA)Y%7D%2C%20%5Cquad%20%5Cmathbf%7BZ%2CY%7D%20%5Cin%20%5Cmathbf%7BC%7D%5E%7Bn%20%5Ctimes%20m%7D%20%5Ctext%7B%20%E4%B8%BA%E4%BB%BB%E6%84%8F%E7%9F%A9%E9%98%B5%20%7D%20%20%20%5Cright%5C%7D%3B%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p><strong>证明</strong>：将上面两个式子的集合分别记为 <img src="https://math.now.sh?inline=S_%7B1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=S_%7B2%7D" style="display:inline-block;margin: 0;"/> ，易证，这两个集合中的每个矩阵都满足 <img src="https://math.now.sh?inline=%5Cmathbf%7BAXA%20%3D%20A%7D" style="display:inline-block;margin: 0;"/> 。反过来，对于  <img src="https://math.now.sh?inline=%5Cmathbf%7BAXA%20%3D%20A%7D" style="display:inline-block;margin: 0;"/> 的任意一个解 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> ，取 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%20%3D%20X%20-%20A%5E%7B-%7D%7D" style="display:inline-block;margin: 0;"/> ，便可以推出 $ \mathbf{X} \in S_{1}$ 。若取</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BZ%7D%20%26%3D%20%5Cmathbf%7BX%20-%20A%5E%7B-%7D%7D%20%5C%5C%0A%5Cmathbf%7BY%7D%20%26%3D%20%5Cmathbf%7BX%20AA%5E%7B-%7D%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>可以推出  $ \mathbf{X} \in S_{2}$ ，证毕。</p>
<h2 id="分块矩阵的广义逆">分块矩阵的广义逆</h2>
<p><strong>定理</strong>：  如果 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的矩阵，<strong>秩为 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/></strong> ，并且可以分块为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BA%7D_%7B11%7D%20%26%20%5Cmathbf%7BA%7D_%7B12%7D%20%5C%5C%0A%5Cmathbf%7BA%7D_%7B21%7D%20%26%20%5Cmathbf%7BA%7D_%7B22%7D%0A%5Cend%7Barray%7D%5Cright%29%0A" /></p><p>其中 <img src="https://math.now.sh?inline=A_%7B11%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=r%20%5Ctimes%20r" style="display:inline-block;margin: 0;"/> 的<strong>满秩</strong>矩阵。那么此时 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的一个广义逆为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%5E%7B-%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%26%20%5Cmathbf%7BO%7D%20%5C%5C%0A%5Cmathbf%7BO%7D%20%26%20%5Cmathbf%7BO%7D%0A%5Cend%7Barray%7D%5Cright%29%0A" /></p><p>证明：通过分块矩阵乘积，我们得到:</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%20%5Cmathbf%7BA%7D%5E%7B-%7D%20%5Cmathbf%7BA%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BI%7D%20%26%20%5Cmathbf%7BO%7D%20%5C%5C%0A%5Cmathbf%7BA%7D_%7B21%7D%20%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%26%20%5Cmathbf%7BO%7D%0A%5Cend%7Barray%7D%5Cright%29%20%5Cmathbf%7BA%7D%3D%5Cleft(%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BA%7D_%7B11%7D%20%26%20%5Cmathbf%7BA%7D_%7B12%7D%20%5C%5C%0A%5Cmathbf%7BA%7D_%7B21%7D%20%26%20%5Cmathbf%7BA%7D_%7B21%7D%20%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B12%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>这里我们需要证明 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B21%7D%20%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B12%7D%3D%5Cmathbf%7BA%7D_%7B22%7D" style="display:inline-block;margin: 0;"/> ，我们设</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BB%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BI%7D%20%26%20%5Cmathbf%7BO%7D%20%5C%5C%0A-%5Cmathbf%7BA%7D_%7B21%7D%20%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%26%20%5Cmathbf%7BI%7D%0A%5Cend%7Barray%7D%5Cright%29%0A" /></p><p>因此，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BB%20A%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BA%7D_%7B11%7D%20%26%20%5Cmathbf%7BA%7D_%7B12%7D%20%5C%5C%0A%5Cmathbf%7BO%7D%20%26%20%5Cmathbf%7BA%7D_%7B22%7D-%5Cmathbf%7BA%7D_%7B21%7D%20%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B12%7D%0A%5Cend%7Barray%7D%5Cright%29%20.%0A" /></p><p>由于 <img src="https://math.now.sh?inline=B" style="display:inline-block;margin: 0;"/> 为非奇异矩阵，因此 <img src="https://math.now.sh?inline=rank%28BA%29%20%3D%20rank(A)%3Dr" style="display:inline-block;margin: 0;"/> 。在 <img src="https://math.now.sh?inline=BA" style="display:inline-block;margin: 0;"/> 中 ，其子矩阵 <img src="https://math.now.sh?inline=%5Cleft%28%5Cbegin%7Barray%7D%7Bc%7D%5Cmathbf%7BA%7D_%7B11%7D%20%5C%5C%20%5Cmathbf%7BO%7D%5Cend%7Barray%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 的列秩为 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> ，因此后面的列都是前面的列的线性组合，我们可以表示为下式，即等于  <img src="https://math.now.sh?inline=%5Cleft%28%5Cbegin%7Barray%7D%7Bc%7D%5Cmathbf%7BA%7D_%7B11%7D%20%5C%5C%20%5Cmathbf%7BO%7D%5Cend%7Barray%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 右乘某个矩阵 <img src="https://math.now.sh?inline=Q" style="display:inline-block;margin: 0;"/> 。</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BA%7D_%7B12%7D%20%5C%5C%0A%5Cmathbf%7BA%7D_%7B22%7D-%5Cmathbf%7BA%7D_%7B21%7D%20%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B12%7D%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BA%7D_%7B11%7D%20%5C%5C%0A%5Cmathbf%7BO%7D%0A%5Cend%7Barray%7D%5Cright)%20%5Cmathbf%7BQ%7D%0A" /></p><p>右手项为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BA%7D_%7B11%7D%20%5C%5C%0A%5Cmathbf%7BO%7D%0A%5Cend%7Barray%7D%5Cright%29%20%5Cmathbf%7BQ%7D%3D%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BA%7D_%7B11%7D%20%5Cmathbf%7BQ%7D%20%5C%5C%0A%5Cmathbf%7BO%20Q%7D%0A%5Cend%7Barray%7D%5Cright)%3D%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BA%7D_%7B11%7D%20%5Cmathbf%7BQ%7D%20%5C%5C%0A%5Cmathbf%7BO%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>因此，<img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B22%7D-%5Cmathbf%7BA%7D_%7B21%7D%20%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B12%7D%3D%5Cmathbf%7BO%7D" style="display:inline-block;margin: 0;"/> ，或者说</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D_%7B22%7D%3D%5Cmathbf%7BA%7D_%7B21%7D%20%5Cmathbf%7BA%7D_%7B11%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B12%7D%20.%0A" /></p><p>因此，得证上式。</p>
<p><strong>推论</strong>：如果 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的矩阵，<strong>秩为 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/></strong> ，并且可以按上面一样的方式分块，其中 <img src="https://math.now.sh?inline=A_%7B22%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=r%20%5Ctimes%20r" style="display:inline-block;margin: 0;"/> 的<strong>满秩</strong>矩阵，此时 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的一个广义逆为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%5E%7B-%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BO%7D%20%26%20%5Cmathbf%7BO%7D%20%5C%5C%0A%5Cmathbf%7BO%7D%20%26%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%0A%5Cend%7Barray%7D%5Cright%29%0A" /></p><p>事实上，这里满秩的子矩阵不一定必须为 <img src="https://math.now.sh?inline=A_%7B11%7D" style="display:inline-block;margin: 0;"/> 或 <img src="https://math.now.sh?inline=A_%7B22%7D" style="display:inline-block;margin: 0;"/> ，可以是任何子矩阵（缺证明）。</p>
<h1>性质</h1>
<h2 id="简单">简单</h2>
<p>如果 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 为一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20p" style="display:inline-block;margin: 0;"/> 的秩为 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> 的子矩阵，<img src="https://math.now.sh?inline=A%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的任意一个广义逆，令 <img src="https://math.now.sh?inline=%28A'A%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 为  <img src="https://math.now.sh?inline=A'A" style="display:inline-block;margin: 0;"/> 的任意一个广义逆，那么存在：</p>
<ul>
<li>
<p><img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%5Cleft%28%5Cmathbf%7BA%7D%5E%7B-%7D%20%5Cmathbf%7BA%7D%5Cright%29%3D%5Coperatorname%7Brank%7D%5Cleft(%5Cmathbf%7BA%7D%20%5Cmathbf%7BA%7D%5E%7B-%7D%5Cright)%3D%5Coperatorname%7Brank%7D(%5Cmathbf%7BA%7D)%3Dr" style="display:inline-block;margin: 0;"/> ，并且 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B-%7DA%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cmathbf%7BAA%5E%7B-%7D%7D" style="display:inline-block;margin: 0;"/> 均为幂等矩阵</p>
<p>证明：我们已知 <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28AB%29%20%5Cleq%20%5Cmin%20%5C%7B%5Coperatorname%7Brank%7D(A)%2C%5Coperatorname%7Brank%7D(B)%20%20%5C%7D" style="display:inline-block;margin: 0;"/> ，因此存在</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Coperatorname%7Brank%7D%28AA%5E%7B-%7DA%29%20%5Cleq%20%5Coperatorname%7Brank%7D(A%5E%7B-%7DA)%20%5Cleq%20%5Coperatorname%7Brank%7D(A)%5C%5C%0A%26%5Coperatorname%7Brank%7D(AA%5E%7B-%7DA)%20%5Cleq%20%5Coperatorname%7Brank%7D(AA%5E%7B-%7D)%20%5Cleq%20%5Coperatorname%7Brank%7D(A)%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>不等式两头相同，因此得证 <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%5Cleft%28%5Cmathbf%7BA%7D%5E%7B-%7D%20%5Cmathbf%7BA%7D%5Cright%29%3D%5Coperatorname%7Brank%7D%5Cleft(%5Cmathbf%7BA%7D%20%5Cmathbf%7BA%7D%5E%7B-%7D%5Cright)%3D%5Coperatorname%7Brank%7D(%5Cmathbf%7BA%7D)%3Dr" style="display:inline-block;margin: 0;"/></p>
<p>幂等矩阵证明如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%5E%7B-%7DAA%5E%7B-%7DA%20%3D%20A%5E%7B-%7D%28AA%5E%7B-%7DA%29%20%3DA%5E%7B-%7DA%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BAA%5E%7B-%7DAA%5E%7B-%7D%20%3D%20%28AA%5E%7B-%7DA%29A%5E%7B-%7D%20%3D%20AA%5E%7B-%7D%20%20%7D%0A" /></p></li>
<li>
<p><img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%5Cleft%28%5Cmathbf%7BA%7D%5E%7B-%7D%5Cright%29%20%5Cgeq%20%5Coperatorname%7Brank%7D%5Cleft(%5Cmathbf%7BA%7D%5Cright)" style="display:inline-block;margin: 0;"/></p>
</li>
</ul>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Brank%7D%28AA%5E%7B-%7DA%29%20%5Cleq%20%5Coperatorname%7Brank%7D(A%5E%7B-%7DA)%20%5Cleq%20%5Coperatorname%7Brank%7D(A%5E%7B-%7D)%5C%5C%0A" /></p><p>​		举个例子，对于幂等矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bl%7D%0A%E2%80%8B%091%20%26%201%5C%5C%0A%E2%80%8B%090%20%26%200%20%5C%5C%0A%E2%80%8B%09%5Cend%7Barray%7D%5Cright%29" style="display:inline-block;margin: 0;"/> ，单位矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BI%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> 就是其一个广义逆。</p>
<ul>
<li>
<p><img src="https://math.now.sh?inline=R%28AA%5E%7B-%7D%29%20%3D%20R(A)" style="display:inline-block;margin: 0;"/></p>
<p><img src="https://math.now.sh?inline=N%28A%5E%7B-%7DA%29%20%3D%20N(A)" style="display:inline-block;margin: 0;"/> 或者写成  <img src="https://math.now.sh?inline=R%28(A%5E%7B-%7DA%29%5E%7BH%7D)%20%3D%20R(A%5E%7BH%7D)" style="display:inline-block;margin: 0;"/></p>
<p>只证明第一条，第二条同理。易得 <img src="https://math.now.sh?inline=AA%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 的列空间是 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的列空间的子空间，又由二者的秩相同，因此二者的列空间相同，得证。</p>
</li>
<li>
<p><img src="https://math.now.sh?inline=%28A%5E%7B-%7D%29'" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=A'" style="display:inline-block;margin: 0;"/> 的广义逆，因此 <img src="https://math.now.sh?inline=%28A'%29%5E%7B-%7D%20%3D%20(A%5E%7B-%7D)'" style="display:inline-block;margin: 0;"/> 。</p>
<p>证明如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AA'%28A%5E%7B-%7D%29'A'%20%26%20%3D%20(AA%5E%7B-%7DA)'%20%5C%5C%0A%26%3D%20A'%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，<img src="https://math.now.sh?inline=%28A%5E%7B-%7D%29'" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=A'" style="display:inline-block;margin: 0;"/> 的广义逆 。</p>
</li>
<li>
<p>设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%5Cin%20C%5E%7Bm%20%5Ctimes%20n%7D" style="display:inline-block;margin: 0;"/> ，其秩为 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> ，则</p>
<ul>
<li><img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B-%7DA%20%3D%20I_%7Bn%7D%7D" style="display:inline-block;margin: 0;"/> 当且仅当 <img src="https://math.now.sh?inline=r%3Dn" style="display:inline-block;margin: 0;"/></li>
<li><img src="https://math.now.sh?inline=%5Cmathbf%7BAA%5E%7B-%7D%20%3D%20I_%7Bm%7D%7D" style="display:inline-block;margin: 0;"/> 当且仅当 <img src="https://math.now.sh?inline=r%3Dm" style="display:inline-block;margin: 0;"/></li>
</ul>
<p>证明：先看第一条，如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B-%7DA%20%3D%20I_%7Bn%7D%7D" style="display:inline-block;margin: 0;"/> ，则 <img src="https://math.now.sh?inline=r%5Cleft%28%5Cmathbf%7BA%5E%7B-%7DA%7D%5Cright%29%20%3D%20%20r%5Cleft(%5Cmathbf%7BA%7D%5Cright)%20%3D%20n" style="display:inline-block;margin: 0;"/>  ；反过来，如果  <img src="https://math.now.sh?inline=r%3Dn" style="display:inline-block;margin: 0;"/> ，则  <img src="https://math.now.sh?inline=r%5Cleft%28%5Cmathbf%7BA%5E%7B-%7DA%7D%5Cright%29%20%3D%20%20r%5Cleft(%5Cmathbf%7BA%7D%5Cright)%20%3D%20n" style="display:inline-block;margin: 0;"/> ，此时 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B-%7DA%7D" style="display:inline-block;margin: 0;"/> 非奇异，而非奇异的幂等矩阵只有单位矩阵，因此  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B-%7DA%20%3D%20I_%7Bn%7D%7D" style="display:inline-block;margin: 0;"/> 。第二条同理。</p>
</li>
</ul>
<h2 id="复杂">复杂</h2>
<h3 id="定理1">定理1</h3>
<p><strong>定理</strong>：设 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D%20%5Cneq%20%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D%20%5Cneq%20%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> ，则矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BBA%5E%7B-%7DC%7D" style="display:inline-block;margin: 0;"/> 与 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 的选择无关，当且仅当</p>
<p style=""><img src="https://math.now.sh?from=R%28%5Cmathbf%7BC%7D%29%20%5Csubset%20R(%5Cmathbf%7BA%7D)%2C%20%5Cquad%20R(%5Cmathbf%7BB%7D%5E%7B'%7D)%20%5Csubset%20R(%5Cmathbf%7BA%7D%5E%7B'%7D)%0A" /></p><p>证明：首先证明<strong>充分性</strong>，上面的条件等价于存在矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BY%7D" style="display:inline-block;margin: 0;"/> ，使得 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%20%3D%20AX%7D" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=%5Cmathbf%7BB'%20%3D%20A'Y%7D" style="display:inline-block;margin: 0;"/> ，于是</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BBA%5E%7B-%7DC%20%3D%20Y'AA%5E%7B-%7DAX%20%3D%20Y'AX%7D%0A" /></p><p>因此，矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BBA%5E%7B-%7DC%7D" style="display:inline-block;margin: 0;"/> 与 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 的选择无关。</p>
<p>再证明<strong>必要性</strong>，我们已知任意一个广义逆  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 可以表示为下式，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B%281%29%7D%7D" style="display:inline-block;margin: 0;"/> 为任一特定的广义逆。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%5E%7B-%7D%20%3D%20A%5E%7B%281%29%7D%20%2B%20U%20-%20A%5E%7B(1)%7DAUAA%5E%7B(1)%7D%7D%0A" /></p><p>于是</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BBA%5E%7B-%7DC%20%3D%20BA%5E%7B%281%29%7DC%20%2B%20BUC%20-%20BA%5E%7B(1)%7DAUAA%5E%7B(1)%7DC%7D%0A" /></p><p>若矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BBA%5E%7B-%7DC%7D" style="display:inline-block;margin: 0;"/> 与 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 的选择无关，则关于 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 必须要消掉，即</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BBUC%20-%20BA%5E%7B%281%29%7DAUAA%5E%7B(1)%7DC%20%3D%200%7D%0A" /></p><p>取 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%20%3D%20A%5E%7B%281%29%7DAZ%20%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 为任意矩阵 （有一个问题，这里  <img src="https://math.now.sh?inline=%5Cmathbf%7BU%20%3D%20A%5E%7B%281%29%7DAZ%20%7D" style="display:inline-block;margin: 0;"/>  应该不能取到 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D%5E%7Bn%20%5Ctimes%20m%7D" style="display:inline-block;margin: 0;"/> 的所有矩阵; 这不是问题，这里是说，<img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 可以取为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B%281%29%7DAZ%20%7D" style="display:inline-block;margin: 0;"/>   ），则</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BBA%5E%7B%281%29%7DAZ(C%20-%20AA%5E%7B(1)%7DC%20)%3D%200%7D%0A" /></p><p>由于 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 为任意矩阵，则</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BBA%5E%7B%281%29%7DA%20%3D%200%7D%0A" /></p><p>或者</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BC%20%3D%20AA%5E%7B%281%29%7DC%20%7D%0A" /></p><p>如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BBA%5E%7B%281%29%7DA%20%3D%200%7D" style="display:inline-block;margin: 0;"/> ，则根据 <img src="https://math.now.sh?inline=%5Cmathbf%7BBUC%20-%20BA%5E%7B%281%29%7DAUAA%5E%7B(1)%7DC%20%3D%200%7D" style="display:inline-block;margin: 0;"/> 可以立刻推出 <img src="https://math.now.sh?inline=%5Cmathbf%7BBUC%20%3D%200%7D" style="display:inline-block;margin: 0;"/> ，由于 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 的任意性，我们就有 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%20%3D%200%7D" style="display:inline-block;margin: 0;"/> 或 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%20%3D%200%7D" style="display:inline-block;margin: 0;"/>，这与原假设矛盾，因此我们得到   <img src="https://math.now.sh?inline=%5Cmathbf%7BC%20%3D%20AA%5E%7B%281%29%7DC%20%7D" style="display:inline-block;margin: 0;"/> 成立，这就说明 <img src="https://math.now.sh?inline=R%28%5Cmathbf%7BC%7D%29%20%5Csubset%20R(%5Cmathbf%7BA%7D)" style="display:inline-block;margin: 0;"/> 。</p>
<p>同理，若取  <img src="https://math.now.sh?inline=%5Cmathbf%7BU%20%3D%20ZAA%5E%7B%281%29%7D%20%7D" style="display:inline-block;margin: 0;"/> ，我们可以证明  $ R(\mathbf{B}^{‘}) \subset R(\mathbf{A}^{’})$</p>
<h3 id="定理2">定理2</h3>
<p><strong>定理</strong>：<img src="https://math.now.sh?inline=%5Cmathbf%7BAA%5E%7B-%7DB%20%3D%20B%7D" style="display:inline-block;margin: 0;"/> 当且仅当 <img src="https://math.now.sh?inline=R%28%5Cmathbf%7BB%7D%29%20%5Csubset%20R(%5Cmathbf%7BA%7D)" style="display:inline-block;margin: 0;"/></p>
<p>证明：必要性是显然的，我们证明充分性，假设  <img src="https://math.now.sh?inline=R%28%5Cmathbf%7BB%7D%29%20%5Csubset%20R(%5Cmathbf%7BA%7D)" style="display:inline-block;margin: 0;"/>  ，则存在一个 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> ，使得 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%20%3D%20AX%7D" style="display:inline-block;margin: 0;"/> ，因此</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BAA%5E%7B-%7DB%20%3D%20AA%5E%7B-%7DAx%20%3D%20AX%20%3D%20B%7D%0A" /></p><p>证毕。</p>
<h3 id="定理3">定理3</h3>
<ul>
<li>
<p><img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5Cleft%28%5Cmathbf%7BA%7D%5E%7B*%7D%20%5Cmathbf%7BA%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BA%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 与 <img src="https://math.now.sh?inline=%28%5Cmathbf%7BA%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BA%7D%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 的选择无关，且为 Hermite 矩阵，其秩与 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 相同。</p>
<p>证明：因为 <img src="https://math.now.sh?inline=R%28%5Cmathbf%7BA%5E%7B*%7D%7D%29%20%3D%20R(%5Cmathbf%7BA%5E%7B*%7DA%7D)" style="display:inline-block;margin: 0;"/> ，故存在矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> ，使得 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B*%7D%20%3D%20A%5E%7B*%7DAX%7D" style="display:inline-block;margin: 0;"/> ，因而</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%28A%5E%7B*%7DA%29%5E%7B-%7DA%5E%7B*%7D%20%3D%20X%5E%7B*%7DA%5E%7B*%7DA(A%5E%7B*%7DA)%5E%7B-%7DA%5E%7B*%7DAX%20%3D%20X%5E%7B*%7DA%5E%7B*%7DAX%20%7D%0A" /></p><p>因此得证 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%28A%5E%7B*%7DA%29%5E%7B-%7DA%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/>  与 <img src="https://math.now.sh?inline=%28%5Cmathbf%7BA%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BA%7D%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 的选择无关，且为 Hermite 矩阵</p>
<p>下面我们证明其秩与 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 相同，我们有</p>
<p style=""><img src="https://math.now.sh?from=r%20%5Cleft%28%20%5Cmathbf%7BA%5E%7B*%7D%7D%20%5Cright%29%20%3D%20r%5Cleft(%20%5Cmathbf%7BA%5E%7B*%7DAx%7D%20%5Cright)%20%5Cleq%20r%5Cleft(%20%5Cmathbf%7BAx%7D%20%5Cright)%20%5Cleq%20r%5Cleft(%20%5Cmathbf%7BA%7D%20%5Cright)%0A" /></p><p>因此  <img src="https://math.now.sh?inline=r%5Cleft%28%20%5Cmathbf%7BAx%7D%20%5Cright%29%20%3D%20r%5Cleft(%20%5Cmathbf%7BA%7D%20%5Cright)" style="display:inline-block;margin: 0;"/> ，从而</p>
<p style=""><img src="https://math.now.sh?from=r%20%5Cleft%28%20%5Cmathbf%7BA(A%5E%7B*%7DA%29%5E%7B-%7DA%5E%7B*%7D%7D%5Cright)%20%3D%20r%20%5Cleft(%20%5Cmathbf%7BX%5E%7B*%7DA%5E%7B*%7DAX%20%7D%20%5Cright)%20%3D%20r%20%5Cleft(%20%5Cmathbf%7B(AX)%5E%7B*%7DAX%20%7D%20%5Cright)%20%3D%20%20r%20%5Cleft(%20%5Cmathbf%7BAX%20%7D%20%5Cright)%20%3D%20%20r%20%5Cleft(%20%5Cmathbf%7BA%20%7D%20%5Cright)%20%0A" /></p></li>
<li>
<p><img src="https://math.now.sh?inline=%5Cmathbf%7B%20A%20%3D%20A%28A%5E%7B*%7DA%29%5E%7B-%7DA%5E%7B*%7DA%20%7D" style="display:inline-block;margin: 0;"/> , <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B*%7D%20%3D%20A%5E%7B*%7DA%28A%5E%7B*%7DA%29%5E%7B-%7DA%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/></p>
<p>上一条，我们证明了 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%28A%5E%7B*%7DA%29%5E%7B-%7DA%5E%7B*%7D%20%3D%20X%5E%7B*%7DA%5E%7B*%7DAX%20%3D%20X%5E%7B*%7DA%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> ，因此</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%20A%28A%5E%7B*%7DA%29%5E%7B-%7DA%5E%7B*%7DA%20%3D%20X%5E%7B*%7DA%5E%7B*%7D%20A%20%3D%20A%20%20%7D%0A" /></p><p>得证。第二个同理</p>
</li>
<li>
<p><img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BA%7D%5E%7B*%7D%20%5Cmathbf%7BA%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BA%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的一个广义逆，也就是说 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B-%7D%3D%5Cleft%28%5Cmathbf%7BA%7D%5E%7B*%7D%20%5Cmathbf%7BA%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BA%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>这个和上面是一样的，<img src="https://math.now.sh?inline=%5Cmathbf%7BAGA%7D%20%3D%20%5Cmathbf%7BA%7D%5Cleft%28%5Cmathbf%7BA%7D%5E%7B*%7D%20%5Cmathbf%7BA%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BA%7D%5E%7B*%7D%20%5Cmathbf%7BA%7D%20%3D%20%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/></p>
</li>
<li>
<p>设 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D" style="display:inline-block;margin: 0;"/> 为任一满足条件 $r\left(  \mathbf{A^{*}VA} \right) = r\left(  \mathbf{A} \right) $ 的 Hermite 矩阵，则 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%28A%5E%7B*%7DVA%29%5E%7B-%7DA%5E%7B*%7DVA%20%3D%20A%7D" style="display:inline-block;margin: 0;"/></p>
<p>证明：由于  <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D" style="display:inline-block;margin: 0;"/>  为 Hermite 矩阵，易得 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B*%7DVA%7D" style="display:inline-block;margin: 0;"/> 也是 Hermite 矩阵。</p>
<p>对于任意向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> , 则（为什么？我实在想不通。如果  <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D" style="display:inline-block;margin: 0;"/> 是正定矩阵，那么可以证明成立，左乘 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 得到 $ \mathbf{ (Ax)^{*}V(Ax) = 0 }$ ，由于   <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D" style="display:inline-block;margin: 0;"/> 正定，则必有 <img src="https://math.now.sh?inline=%5Cmathbf%7BAx%20%3D%200%7D" style="display:inline-block;margin: 0;"/>  。）</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%5E%7B*%7DVAx%20%3D%200%7D%20%5CRightarrow%20%5Cmathbf%7BAx%20%3D%200%7D%0A" /></p><p>对 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B*%7DVA%28A%5E%7B*%7DVA%29%5E%7B-%7DA%5E%7B*%7DVA%20%3D%20A%5E%7B*%7DVA%7D" style="display:inline-block;margin: 0;"/> 进行转换，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%5E%7B*%7DV%5BA%28A%5E%7B*%7DVA%29%5E%7B-%7DA%5E%7B*%7DVA%20-%20A%5D%20%3D%200%7D%0A" /></p><p>因此可得</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%28A%5E%7B*%7DVA%29%5E%7B-%7DA%5E%7B*%7DVA%20%3D%20A%7D%0A" /></p><p>得证。</p>
</li>
</ul>
<p>一个对称矩阵的广义逆不一定是对称的，但是你一定可以找到一个对称的广义逆，我们通常假定对称矩阵的广义逆也是对称的。</p>
<h1>线性方程组的解</h1>
<p><strong>定理</strong>： <strong>如果 线性方程组 <img src="https://math.now.sh?inline=Ax%20%3D%20c" style="display:inline-block;margin: 0;"/> 是相容的</strong>，并且 <img src="https://math.now.sh?inline=A%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的一个广义逆，<strong>那么 <img src="https://math.now.sh?inline=x%20%3D%20A%5E%7B-%7Dc" style="display:inline-block;margin: 0;"/> 是一个解</strong>。</p>
<p>证明：根据广义逆，我们有：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%20%5Cmathbf%7BA%7D%5E%7B-%7D%20%5Cmathbf%7BA%7D%20%5Cmathbf%7Bx%7D%3D%5Cmathbf%7BA%7D%20%5Cmathbf%7Bx%7D%0A" /></p><p>两边都用 <img src="https://math.now.sh?inline=Ax%20%3Dc" style="display:inline-block;margin: 0;"/> 替换，得到：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%20%28%5Cmathbf%7BA%7D%5E%7B-%7D%20%5Cmathbf%7Bc%7D%29%3D%5Cmathbf%7Bc%7D%0A" /></p><p>因此 <img src="https://math.now.sh?inline=A%5E%7B-%7Dc" style="display:inline-block;margin: 0;"/> 是  <img src="https://math.now.sh?inline=Ax%20%3D%20c" style="display:inline-block;margin: 0;"/>  的一个解。</p>
<p>注意，这里必须要已知方程组<strong>相容</strong>，才可以这样求解，这里举个不相容的例子</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%7B%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A1%20%26%201%20%5C%5C%0A1%20%26%201%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0Ax_%7B1%7D%20%5C%5C%0Ax_%7B2%7D%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A1%20%5C%5C%0A2%0A%5Cend%7Barray%7D%5Cright%5D%7D%20%5C%5C%0A%26%5C%5C%0A%26A%5E%7B-%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A1%20%26%200%20%5C%5C%0A0%20%26%200%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%5C%5C%0A%26A%5E%7B-%7D%20c%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A1%20%26%200%20%5C%5C%0A0%20%26%200%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A1%20%5C%5C%0A2%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A1%20%5C%5C%0A0%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%5C%5C%0A%26A%20A%5E%7B-%7D%20c%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A1%20%26%201%20%5C%5C%0A1%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A1%20%5C%5C%0A0%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A1%20%5C%5C%0A1%0A%5Cend%7Barray%7D%5Cright%5D%20%5Cneq%20c%0A%5Cend%7Baligned%7D%0A" /></p><p><strong>定理</strong>： <strong>如果 线性方程组 <img src="https://math.now.sh?inline=Ax%20%3D%20c" style="display:inline-block;margin: 0;"/> 是相容的</strong>，那么所有可能的解可以通过两种方式得到：</p>
<ol>
<li>使用某个特定的 <img src="https://math.now.sh?inline=A%5E%7B-%7D" style="display:inline-block;margin: 0;"/> ，设 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D%3D%5Cmathbf%7BA%7D%5E%7B-%7D%20%5Cmathbf%7Bc%7D%2B%5Cleft%28%5Cmathbf%7BI%7D-%5Cmathbf%7BA%7D%5E%7B-%7D%20%5Cmathbf%7BA%7D%5Cright%29%20%5Cmathbf%7Bh%7D" style="display:inline-block;margin: 0;"/> ，这里 <img src="https://math.now.sh?inline=h" style="display:inline-block;margin: 0;"/> 为所有可能的值组成的随机的向量。</li>
<li>对于所有可能的  <img src="https://math.now.sh?inline=A%5E%7B-%7D" style="display:inline-block;margin: 0;"/> , 设 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D%3D%5Cmathbf%7BA%7D%5E%7B-%7D%20%5Cmathbf%7Bc%7D" style="display:inline-block;margin: 0;"/>  如果 <img src="https://math.now.sh?inline=%5Cmathbf%7Bc%7D%20%5Cneq%20%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> 。</li>
</ol>
<p><strong>定理</strong>：<strong>当且仅当</strong>对于任何一个广义逆 <img src="https://math.now.sh?inline=A%5E%7B-%7D" style="display:inline-block;margin: 0;"/> ，下式均成立时， <strong>线性方程组 <img src="https://math.now.sh?inline=Ax%20%3D%20c" style="display:inline-block;margin: 0;"/> 相容</strong>。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%20A%7D%5E%7B-%7D%20%5Cmathbf%7Bc%7D%3D%5Cmathbf%7Bc%7D%0A" /></p><p>首先，如果线性方程组相容，那么 <img src="https://math.now.sh?inline=x%20%3D%20A%5E%7B-%7Dc" style="display:inline-block;margin: 0;"/> 是一个解，这个就是上面的定理。反过来，如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20A%7D%5E%7B-%7D%20%5Cmathbf%7Bc%7D%3D%5Cmathbf%7Bc%7D" style="display:inline-block;margin: 0;"/> 对于任何一个 广义逆 <img src="https://math.now.sh?inline=A%5E%7B-%7D" style="display:inline-block;margin: 0;"/>  均成立，那么很显然方程组有解，即相容。</p>
<p>因此，我们看一个方程组是否相容，只要找一个广义逆  <img src="https://math.now.sh?inline=A%5E%7B-%7D" style="display:inline-block;margin: 0;"/> ，查看是否存在  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20A%7D%5E%7B-%7D%20%5Cmathbf%7Bc%7D%3D%5Cmathbf%7Bc%7D" style="display:inline-block;margin: 0;"/> 即可。</p>
<h1>参考文献</h1>
<ol>
<li>Rencher A C, Schaalje G B. Linear models in statistics[M]. John Wiley &amp; Sons, 2008.</li>
<li>王松桂, 杨振海. 广义逆矩阵及其应用[M]. 北京工业大学出版社, 1996.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>行列式与平行四边形面积</title>
    <url>/posts/de3921ab/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Gilbert Strang 提到行列式 (的绝对值) 在几何上可以理解为由矩阵的行向量构成的“箱子”的体积，下面证明一下二维空间的平行四边形的面积等于行列式大小。</p>
<span id="more"></span>
<h1>行列式</h1>
<p>假设有一个 <img src="https://math.now.sh?inline=2%20%5Ctimes%202" style="display:inline-block;margin: 0;"/> 的矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%20%3D%20%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bccc%7D%0Aa%20%26%20b%20%5C%5C%0Ac%20%26%20d%20%0A%5Cend%7Barray%7D%20%5Cright%5D%0A" /></p><p>其行向量构建成的平行四边形为</p>
<p><img src="1.png" alt="1"></p>
<p>其面积就是矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的行列式的绝对值，即</p>
<p style=""><img src="https://math.now.sh?from=S%20%3D%20%7C%5Cdet%28%5Cmathbf%7BA%7D%29%7C%20%3D%20%7Cad%20-%20bc%7C%0A" /></p><p>下面我们证明这一点。</p>
<h1>证明</h1>
<p>我们知道平行四边形的面积等于底乘高，画图如下，设两条边为 <img src="https://math.now.sh?inline=x_%7B1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=x_%7B2%7D" style="display:inline-block;margin: 0;"/> ，夹角为 <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/> ，则可设底为  <img src="https://math.now.sh?inline=%5C%7Cx_%7B1%7D%5C%7C" style="display:inline-block;margin: 0;"/> ，高为  <img src="https://math.now.sh?inline=%5C%7Cx_%7B2%7D%5C%7C%20%5Csin%28%5Ctheta%29" style="display:inline-block;margin: 0;"/></p>
<p><img src="2.png" alt="1"></p>
<p>此时，我们得到平行四边形的面积为 <img src="https://math.now.sh?inline=S%3D%5C%7Cx_%7B1%7D%5C%7C%20%5C%7Cx_%7B2%7D%5C%7C%20%5Csin%28%5Ctheta%29" style="display:inline-block;margin: 0;"/> 。</p>
<p>在<a href="https://vincere.fun/posts/c511f635/">内积与角度及正交</a>中，我们证明了两个向量的内积为 <img src="https://math.now.sh?inline=x%5E%7B%5Ctop%7D%20y%3D%5C%7Cx%5C%7C_%7B2%7D%5C%7Cy%5C%7C_%7B2%7D%20%5Ccos%20%5Ctheta" style="display:inline-block;margin: 0;"/> ，因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AS%5E%7B2%7D%20%2B%20%28x%5E%7B'%7D_%7B1%7Dx_%7B2%7D%29%5E%7B2%7D%20%26%3D%20%5C%7Cx_%7B1%7D%5C%7C%5E%7B2%7D%20%20%5C%7Cx_%7B2%7D%5C%7C%5E%7B2%7D%20%5C%5C%0AS%5E%7B2%7D%20%20%26%3D%20%20%5C%7Cx_%7B1%7D%5C%7C%5E%7B2%7D%20%20%5C%7Cx_%7B2%7D%5C%7C%5E%7B2%7D%20-%20(x%5E%7B'%7D_%7B1%7Dx_%7B2%7D)%5E%7B2%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>带入具体数值得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AS%5E%7B2%7D%20%26%3D%5Cleft%28a%5E%7B2%7D%2Bb%5E%7B2%7D%5Cright%29%5Cleft(c%5E%7B2%7D%2Bd%5E%7B2%7D%5Cright)-(a%20c%2Bb%20d)%5E%7B2%7D%20%5C%5C%0A%26%3Da%5E%7B2%7D%20c%5E%7B2%7D%2Bb%5E%7B2%7D%20c%5E%7B2%7D%2Ba%5E%7B2%7D%20d%5E%7B2%7D%2Bb%5E%7B2%7D%20d%5E%7B2%7D-a%5E%7B2%7D%20c%5E%7B2%7D-2%20a%20b%20c%20d-b%5E%7B2%7D%20d%5E%7B2%7D%20%5C%5C%0A%26%3Db%5E%7B2%7D%20c%5E%7B2%7D%20%2B%20a%5E%7B2%7D%20d%5E%7B2%7D%20-2%20a%20b%20c%20d%20%5C%5C%0A%26%3D(a%20d-b%20c)%5E%7B2%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因此得证 <img src="https://math.now.sh?inline=S%20%20%3D%20%7Cad%20-%20bc%7C" style="display:inline-block;margin: 0;"/> 。</p>
<p>注意用行列式计算平行四边形的面积，必须有一个点是原点，如果平行四边形不满足这个条件，需要先平移再计算。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>最小二乘的几何含义</title>
    <url>/posts/e4aae57/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我不知道有多少人认为自己对最小二乘法的思想理解不够清晰，其实如果从几何的角度，可以轻松掌握最小二乘的内涵。</p>
<span id="more"></span>
<h1>为什么是最小二乘/最小平方？</h1>
<p>在学习线性回归的过程中，往往一给出模型式子 $y=\beta_{0}+\beta_{1} x_{1}+\beta_{2} x_{2}+\cdots+\beta_{k} x_{k}+\varepsilon $ ，后面就要讲到用最小二乘来估计参数 <img src="https://math.now.sh?inline=%5Cbeta_i" style="display:inline-block;margin: 0;"/>  。但是在讲到最小二乘法的时候，要么就是把最小二乘法视为“显然”的“公理”，不加解释；要么从直观上来说，我们要找一条直线与这些点的距离要足够近，也就是是残差 <img src="https://math.now.sh?inline=y_%7Bi%7D%20-%20%20%5Chat%7By%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 最小，但是由于残差有正有负，因此我们采用残差的平方，需要使得所有残差的平方和最小，然后我当时就产生了一个疑问，那为什么不用残差的绝对值呢？</p>
<p>后来听了吴恩达老师的课，我认识到当代价函数采用平方和的时候，对其求导很简单，因此此时求解比较容易。如果你采用残差的绝对值的形式，绝对值不是处处可导，求解比较麻烦。然后我就产生了一种想法，就是因为绝对值求解不易，所以最小二乘是为了求解方便的一种退而求其次的方法。</p>
<p>最近，从《linear models in statistic》和 《linear algebra with applications》这两本书中，我发现从几何角度去看，最小二乘法其实是一种很自然的估计参数的方法。</p>
<h1>最小二乘的参数估计值</h1>
<p>根据我之前的博客 <a href="https://vincere.fun/posts/55264e6f/">矩阵微分与正规方程组推导</a> ，对于多元线性回归模型 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> 而言，最小二乘估计值满足正规方程组</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20.%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 为一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20%28k%2B1%29" style="display:inline-block;margin: 0;"/> 的矩阵，这里 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 是样本数目，<img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 为特征数目，并且 <img src="https://math.now.sh?inline=k%2B1%20%3C%20n" style="display:inline-block;margin: 0;"/> 。</p>
<p>如果  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵的秩为 <img src="https://math.now.sh?inline=k%2B1" style="display:inline-block;margin: 0;"/> ，那么该方程组存在唯一解</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A" /></p><p>下面我们均假设  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵的秩为 <img src="https://math.now.sh?inline=k%2B1" style="display:inline-block;margin: 0;"/> ，即其为一个列满秩矩阵。</p>
<h1>最小二乘的几何性质</h1>
<p>我们现在完全从最小二乘的几何性质出发去推导这些参数估计值。这部分内容来源于 《linear models in statistic》。</p>
<h2 id="参数空间、数据空间和预测空间">参数空间、数据空间和预测空间</h2>
<p>最小二乘的几何方法首先要从两个高维空间中说起，一个 <img src="https://math.now.sh?inline=%28k%2B1%29" style="display:inline-block;margin: 0;"/> 维的空间，一个 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 维的空间。未知参数向量 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 可以视为 <img src="https://math.now.sh?inline=%28k%2B1%29" style="display:inline-block;margin: 0;"/> 维的空间中的一个点，其坐标轴分别为  <img src="https://math.now.sh?inline=%28k%2B1%29" style="display:inline-block;margin: 0;"/> 个回归系数 <img src="https://math.now.sh?inline=%5Cbeta_%7B0%7D%2C%20%5Cbeta_%7B1%7D%2C%20%5Cbeta_%7B0%7D%2C%20%5Cldots%2C%20%5Cbeta_%7Bk%7D" style="display:inline-block;margin: 0;"/> ，因此我们可以称这个空间为<strong>参数空间</strong> (<em>parameter space</em>) 。相似地，数据向量 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 可以视为在 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 维向量空间中的一个点，其坐标轴分别为 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个观测值，我们称这个空间为<strong>数据空间</strong> (<em>data space</em>) 。</p>
<p>多元线性回归的 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵可以写为下面的形式</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D%3D%5Cleft%28%5Cmathbf%7Bj%7D%2C%20%5Cmathbf%7Bx%7D_%7B1%7D%2C%20%5Cmathbf%7Bx%7D_%7B2%7D%2C%20%5Cmathbf%7Bx%7D_%7B3%7D%2C%20%5Cldots%2C%20%5Cmathbf%7Bx%7D_%7Bk%7D%5Cright%29%0A" /></p><p><img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵的每一列都是 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 维向量，因此每一列都是数据空间中的一个点。因为我们假设 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵的秩为 <img src="https://math.now.sh?inline=k%2B1" style="display:inline-block;margin: 0;"/> ，因此其列向量是线性无关的，<img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵的列向量的线性组合组成了数据空间的一个子空间（易证其符合可加性和齐次性），可以写成</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%20b%7D%3Db_%7B0%7D%20%5Cmathbf%7Bj%7D%2Bb_%7B1%7D%20%5Cmathbf%7Bx%7D_%7B1%7D%2Bb_%7B2%7D%20%5Cmathbf%7Bx%7D_%7B2%7D%2B%5Ccdots%2Bb_%7Bk%7D%20%5Cmathbf%7Bx%7D_%7Bk%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> 是任意一个 <img src="https://math.now.sh?inline=k%2B1" style="display:inline-block;margin: 0;"/> 的向量，因此  <img src="https://math.now.sh?inline=%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> 是参数空间中的一个向量。</p>
<p>我们称<img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵的列向量的线性组合组成的子空间为<strong>预测空间</strong> (<em>prediction space</em>), <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵的列组成了预测空间的一组基。</p>
<p>三个向量空间的可视化见下图</p>
<p><img src="1.png" alt=""></p>
<h2 id="多元线性回归模型的几何解释">多元线性回归模型的几何解释</h2>
<p>多元线性回归认为 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=E%28%5Cmathbf%7By%7D%29%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/>  。我 们的问题是 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D%2C%20%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> 均不知道，我们可以其以几何形式表示为下图</p>
<p><img src="2.png" alt=""></p>
<p>如果我们忽略残差项 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> ，此时 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 一般是一个超定方程组（独立的方程的数目超过了未知数的数目），超定方程组是无解的，也就是说我们一般无法找到一个 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/>  ，使得 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 正好等于  <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>那么，我们估计 <img src="https://math.now.sh?inline=E%28%5Cmathbf%7By%7D%29" style="display:inline-block;margin: 0;"/> 的一个合理的几何思想是从预测空间中找到一个点 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 与 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 距离最近。而两个向量之间的距离我们用范数来定义为</p>
<p style=""><img src="https://math.now.sh?from=%5C%7C%20%5Cmathbf%7By%7D%20-%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%20%5C%7C%0A" /></p><p>如果我们定义残差向量 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Chat%7B%5Cvarepsilon%7D%7D%20%3D%20%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> ，此时也就是需要找到一个 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> ，使得 <img src="https://math.now.sh?inline=%5C%7C%5Cboldsymbol%7B%5Chat%7B%5Cvarepsilon%7D%7D%5C%7C" style="display:inline-block;margin: 0;"/> 最小。最小化 <img src="https://math.now.sh?inline=%5C%7C%5Cboldsymbol%7B%5Chat%7B%5Cvarepsilon%7D%7D%5C%7C" style="display:inline-block;margin: 0;"/> 等价于最小化 <img src="https://math.now.sh?inline=%5C%7C%5Cboldsymbol%7B%5Chat%7B%5Cvarepsilon%7D%7D%5C%7C%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，而  <img src="https://math.now.sh?inline=%5C%7C%5Cboldsymbol%7B%5Chat%7B%5Cvarepsilon%7D%7D%5C%7C%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 就是<strong>残差平方和</strong>，因此此时的几何思想就是最小二乘的思想。</p>
<p>进一步，我们可以发现与 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 距离最近的点， <img src="https://math.now.sh?inline=%5Chat%7B%5Cmathbf%7By%7D%7D" style="display:inline-block;margin: 0;"/>  的一个条件是 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cvarepsilon%7D%7D%3D%5Cmathbf%7By%7D-%5Chat%7B%5Cmathbf%7By%7D%7D" style="display:inline-block;margin: 0;"/> 必须与预测空间（的所有向量）正交，也就是说，  <img src="https://math.now.sh?inline=%5Chat%7B%5Cmathbf%7By%7D%7D" style="display:inline-block;margin: 0;"/>  是  <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/>  在预测空间 <img src="https://math.now.sh?inline=R%28A%29" style="display:inline-block;margin: 0;"/> 的<strong>投影</strong>（可以通过勾股定理来证明）。更进一步，由于预测空间被 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的列张成，因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%28%5Cmathbf%7BXb%7D%29%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cvarepsilon%7D%7D%20%3D%20%5Cmathbf%7Bb%7D%5E%7B%5Cprime%7D%20%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cvarepsilon%7D%7D%20%20%3D%20%5Cmathbf%7B0%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>该式对任意 <img src="https://math.now.sh?inline=%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> 均成立，因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cvarepsilon%7D%7D%3D%5Cmathbf%7B0%7D%0A" /></p><p>即</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%28%5Cmathbf%7By%7D-%5Chat%7B%5Cmathbf%7By%7D%7D%29%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D)%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7B0%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A" /></p><p>由于 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 列满秩，因此存在唯一解</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A" /></p><p>这里我们采用了纯粹的几何思想，我们同样得到了正规方程组和最小二乘估计值。</p>
<h2 id="投影矩阵">投影矩阵</h2>
<p>因为 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Chat%7By%7D%7D" style="display:inline-block;margin: 0;"/> 是任意一个 $n \times 1 $ 的 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 向量在 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的列空间上的投影，其投影  <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Chat%7By%7D%7D" style="display:inline-block;margin: 0;"/> 的计算公式为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%5Chat%7By%7D%7D%20%3D%20%20%5Cmathbf%7BX%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%20%5Cmathbf%7BX%7D%20%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%3D%20%5Cmathbf%7BPy%7D%0A" /></p><p>其中，<img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D%20%3D%20%5Cmathbf%7BX%7D%20%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，我们称为投影矩阵。因此根据最小二乘法，我们得到了将任意一个向量投影到一个矩阵的列空间的一般公式。</p>
<p>当 <img src="https://math.now.sh?inline=%5Cmathbf%7BX'X%7D" style="display:inline-block;margin: 0;"/> 奇异时，此时我们有 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D%20%3D%20%5Cmathbf%7BX%7D%20%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 。而且根据广义逆的性质，我们知道无论 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 取何值，投影矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D" style="display:inline-block;margin: 0;"/> 均保持不变，因此投影  <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Chat%7By%7D%7D" style="display:inline-block;margin: 0;"/> 也保持不变。但是 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%3D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 有无穷多个解。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>证明 row rank = column rank 及 rank(AA&#39;) = rank(A&#39;A) = rank(A)</title>
    <url>/posts/4e1b8d12/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>上一篇<a href="https://vincere.fun/posts/6c72beb0/">证明AB的秩小于等于A的秩</a>，本篇证明矩阵 A 的行秩等于列秩，及 rank(AA’) = rank(A’A) = rank(A)。</p>
<span id="more"></span>
<h1>证明行秩等于列秩</h1>
<p>在维基百科的页面 <a href="https://en.wikipedia.org/wiki/Rank_%28linear_algebra%29">Rank (linear algebra)</a> 提到了三种证明方法，下面进行介绍。</p>
<p>我们需要证明矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的线性独立的行数等于其线性独立的列数，即行秩等于列秩。换句话说，<img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28%5Cmathbf%7BA%7D%29%20%3D%20%5Coperatorname%7Brank%7D(%5Cmathbf%7BA%7D%5E%7B'%7D)" style="display:inline-block;margin: 0;"/> 。</p>
<h2 id="第一种证明：行最简形式">第一种证明：行最简形式</h2>
<p>首先初等行变换不会改变行秩和列秩（不改变行秩很容易理解，但是不改变列秩我不理解），因此矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的行最简阶梯形式不会改变其行秩和列秩。而易得矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的行最简阶梯形的行秩和列秩均等于主元数目，因此得证行秩等于列秩。</p>
<h2 id="第二种证明：线性组合">第二种证明：线性组合</h2>
<p>设矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵，假设其列秩为 <img src="https://math.now.sh?inline=r%20%5Cleq%20n" style="display:inline-block;margin: 0;"/> , 设其列空间的一组基为 <img src="https://math.now.sh?inline=%5Cmathbf%7Bc%7D_%7B1%7D%2C%20%5Cldots%2C%20%5Cmathbf%7Bc%7D_%7Br%7D" style="display:inline-block;margin: 0;"/> ，使用这些列组成矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 。因此矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的每一列均可以表达为矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D" style="display:inline-block;margin: 0;"/> 的列的线性组合，即存在一个 <img src="https://math.now.sh?inline=r%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> ，使得 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20%3D%20C%20R%7D" style="display:inline-block;margin: 0;"/> 。从另一个角度说，矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的每一行均是矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> 的所有行的线性组合，即矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> 的所有行张成了矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的行空间，因此矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的行秩小于等于矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> 的行数，即矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的行秩小于等于列秩。这个结论对所有矩阵均成立，因此对于其转置矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，同样使用这个结论，我们得到矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的列秩小于等于行秩，因此我们得证矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的行秩等于列秩。</p>
<h2 id="第三种证明：使用正交性">第三种证明：使用正交性</h2>
<p>设矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵，假设其行秩为 <img src="https://math.now.sh?inline=r%20%5Cleq%20m" style="display:inline-block;margin: 0;"/> ,  因此矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 行空间的维度为 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> ，设其行空间的一组基为 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D_%7B1%7D%2C%20%5Cmathbf%7Bx%7D_%7B2%7D%2C%20%5Cldots%2C%20%5Cmathbf%7Bx%7D_%7Br%7D" style="display:inline-block;margin: 0;"/> 。我们可以证明 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%5Cmathbf%7Bx%7D_%7B1%7D%2C%20%5Cmathbf%7BA%7D%20%5Cmathbf%7Bx%7D_%7B2%7D%2C%20%5Cldots%2C%20%5Cmathbf%7BA%7D%20%5Cmathbf%7Bx%7D_%7Br%7D" style="display:inline-block;margin: 0;"/> 这些向量是线性无关的，证明如下</p>
<p style=""><img src="https://math.now.sh?from=0%3Dc_%7B1%7D%20%5Cmathbf%7BA%7D%20%20%5Cmathbf%7Bx%7D_%7B1%7D%2Bc_%7B2%7D%20%5Cmathbf%7BA%7D%20%20%5Cmathbf%7Bx%7D_%7B2%7D%2B%5Ccdots%2Bc_%7Br%7D%20%5Cmathbf%7BA%7D%20%5Cmathbf%7Bx%7D_%7Br%7D%3D%5Cmathbf%7BA%7D%20%5Cleft%28c_%7B1%7D%20%5Cmathbf%7Bx%7D_%7B1%7D%2Bc_%7B2%7D%20%5Cmathbf%7Bx%7D_%7B2%7D%2B%5Ccdots%2Bc_%7Br%7D%20%5Cmathbf%7Bx%7D_%7Br%7D%5Cright%29%3D%5Cmathbf%7BA%7D%20%20%5Cmathbf%7Bv%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7Bv%7D%3Dc_%7B1%7D%20%5Cmathbf%7Bx%7D_%7B1%7D%2Bc_%7B2%7D%20%5Cmathbf%7Bx%7D_%7B2%7D%2B%5Ccdots%2Bc_%7Br%7D%20%5Cmathbf%7Bx%7D_%7Br%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>我们发现 <img src="https://math.now.sh?inline=%5Cmathbf%7Bv%7D" style="display:inline-block;margin: 0;"/> 处于矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的行空间之中，其次 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%20%5Cmathbf%7Bv%7D%20%3D%200" style="display:inline-block;margin: 0;"/> 说明矩阵矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的每一行均与 <img src="https://math.now.sh?inline=%5Cmathbf%7Bv%7D" style="display:inline-block;margin: 0;"/> 正交，因此  <img src="https://math.now.sh?inline=%5Cmathbf%7Bv%7D" style="display:inline-block;margin: 0;"/>  和所有行空间中的向量正交，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7Bv%7D" style="display:inline-block;margin: 0;"/> 也和它自身正交，即 <img src="https://math.now.sh?inline=%5Cmathbf%7Bv'v%3D0%7D" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7Bv%3D0%7D" style="display:inline-block;margin: 0;"/> ，或者写成：</p>
<p style=""><img src="https://math.now.sh?from=c_%7B1%7D%20%5Cmathbf%7Bx%7D_%7B1%7D%2Bc_%7B2%7D%20%5Cmathbf%7Bx%7D_%7B2%7D%2B%5Ccdots%2Bc_%7Br%7D%20%5Cmathbf%7Bx%7D_%7Br%7D%3D%5Cmathbf%7B0%7D%0A" /></p><p>由于  <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D_%7B1%7D%2C%20%5Cmathbf%7Bx%7D_%7B2%7D%2C%20%5Cldots%2C%20%5Cmathbf%7Bx%7D_%7Br%7D" style="display:inline-block;margin: 0;"/>  是一组基，因此它们是线性无关的，因此 <img src="https://math.now.sh?inline=c_%7B1%7D%3Dc_%7B2%7D%3D%5Ccdots%3Dc_%7Br%7D%3D0" style="display:inline-block;margin: 0;"/> ，我们得证  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%5Cmathbf%7Bx%7D_%7B1%7D%2C%20%5Cmathbf%7BA%7D%20%5Cmathbf%7Bx%7D_%7B2%7D%2C%20%5Cldots%2C%20%5Cmathbf%7BA%7D%20%5Cmathbf%7Bx%7D_%7Br%7D" style="display:inline-block;margin: 0;"/> 这些向量是线性无关的。</p>
<p>同时，<img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%5Cmathbf%7Bx%7D_%7B1%7D%2C%20%5Cmathbf%7BA%7D%20%5Cmathbf%7Bx%7D_%7B2%7D%2C%20%5Cldots%2C%20%5Cmathbf%7BA%7D%20%5Cmathbf%7Bx%7D_%7Br%7D" style="display:inline-block;margin: 0;"/> 这些向量均在矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的列空间中，因此矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的列秩必须大于等于行秩 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> 。我们同样将这个结论带入其转置矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，我们得到矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的行秩必须大于等于列秩，因此我们得证矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的行秩等于列秩。</p>
<h1>证明 rank(AA’) = rank(A’A) = rank(A)</h1>
<p>这个可以通过零空间来证明。我们先证明 <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28%5Cmathbf%7BA'A%7D%29%20%3D%20%5Coperatorname%7Brank%7D(%5Cmathbf%7BA%7D)" style="display:inline-block;margin: 0;"/> ，设矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵，那么 $ \mathbf{A’A}$ 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵，其零空间的向量满足下式</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA'A%7D%20%5Cmathbf%7Bx%7D%20%3D%20%5Cmathbf%7B0%7D%0A" /></p><p>我们对这个式子两边左乘一个 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx'%7D" style="display:inline-block;margin: 0;"/> ，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7Bx'A'A%7D%20%5Cmathbf%7Bx%7D%20%26%3D%200%20%5C%5C%0A%5Cmathbf%7B%28Ax%29%7D%5E%7B'%7D%20%5Cmathbf%7BAx%7D%20%26%3D%200%20%5C%5C%0A%7C%7C%5Cmathbf%7BAx%7D%7C%7C%5E%7B2%7D%20%26%3D%200%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此此时我们有 <img src="https://math.now.sh?inline=%5Cmathbf%7BAx%3D0%7D" style="display:inline-block;margin: 0;"/> ，说明 <img src="https://math.now.sh?inline=%5Cmathbf%7BA'A%7D%20%5Cmathbf%7Bx%7D%20%3D%20%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BAx%3D0%7D" style="display:inline-block;margin: 0;"/> 的充分条件。反过来，如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BAx%3D0%7D" style="display:inline-block;margin: 0;"/> ，那么易得 <img src="https://math.now.sh?inline=%5Cmathbf%7BA'A%7D%20%5Cmathbf%7Bx%7D%20%3D%20%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> 。因此二者互为充分必要条件，这说明矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cmathbf%7BA'A%7D" style="display:inline-block;margin: 0;"/> 的零空间完全一样。根据零空间的知识，我们知道零空间的维度等于矩阵的列数减去秩，即 <img src="https://math.now.sh?inline=n-r" style="display:inline-block;margin: 0;"/> ，因此我们得证矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cmathbf%7BA'A%7D" style="display:inline-block;margin: 0;"/> 的秩相同。</p>
<p>同样地，对于矩阵 $ \mathbf{AA’}$ ，其零空间的向量满足 <img src="https://math.now.sh?inline=%5Cmathbf%7BAA'%7D%20%5Cmathbf%7Bx%7D%20%3D%20%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> ，同理可得矩阵 $ \mathbf{AA’}$ 与 <img src="https://math.now.sh?inline=%5Cmathbf%7BA'%7D" style="display:inline-block;margin: 0;"/> 的秩相同，由于上面我们证明了 <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28%5Cmathbf%7BA%7D%29%20%3D%20%5Coperatorname%7Brank%7D(%5Cmathbf%7BA%7D%5E%7B'%7D)" style="display:inline-block;margin: 0;"/> ，因此我们得证 <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28%5Cmathbf%7BAA'%7D%29%20%3D%5Coperatorname%7Brank%7D(%5Cmathbf%7BA'A%7D)%20%3D%20%5Coperatorname%7Brank%7D(%5Cmathbf%7BA%7D)" style="display:inline-block;margin: 0;"/> 。</p>
<h1>参考文献</h1>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Rank_%28linear_algebra%29">Rank (linear algebra)</a></li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>证明det(AB)=det(A)det(B)</title>
    <url>/posts/930f86ce/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>证明 det(AB) = det(A)det(B) ，顺便证明 det(A’) = det(A) 。</p>
<span id="more"></span>
<h1>证明 det(AB) = det(A)det(B)</h1>
<h2 id="先验知识">先验知识</h2>
<p>这里我们需要用到行列式的三个基本性质及其引理：</p>
<ol>
<li>
<p>单位矩阵的行列式为 1</p>
</li>
<li>
<p>任意交换两行，矩阵的行列式改变符号</p>
</li>
<li>
<p>保持其他列不变，矩阵某一行乘以一个标量，矩阵的行列式也乘以这个标量；矩阵某一行如果可以表示为两个向量的加法，那么这个矩阵的行列式也可以根据这一行拆分成两个行列式的和。</p>
</li>
<li>
<p>矩阵的某一行乘以常数加到另一行上，矩阵的行列式不变</p>
</li>
<li>
<p>三角矩阵的行列式等于其所有对角线元素乘积</p>
</li>
</ol>
<p>第二，根据高斯消元法，任意一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 矩阵都可以分解为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%3D%20%5Cmathbf%7BLU%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 是一个对角线元素均为 1 的下三角矩阵，而 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 是一个上三角矩阵。如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 是一个可逆矩阵，那么  <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 的所有对角线元素均不为零；如果  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/>  不满秩，那么   <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 矩阵中含有等于0的主元。根据性质 4 ，我们知道消元不会影响行列式的大小（假设没有换行），因此 <img src="https://math.now.sh?inline=%5Cdet%28%5Cmathbf%7BA%7D%29%20%3D%20%5Cdet(%5Cmathbf%7BU%7D)" style="display:inline-block;margin: 0;"/> 。</p>
<h2 id="证明过程">证明过程</h2>
<p>我们首先对 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 进行消元，我们得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%3D%20%5Cmathbf%7BLU%7D" style="display:inline-block;margin: 0;"/> ，首先我们证明 <img src="https://math.now.sh?inline=%5Cdet%28%5Cmathbf%7BLB%7D%29%20%3D%20%5Cdet(%5Cmathbf%7BB%7D)" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cdet%28%5Cmathbf%7BUB%7D%29%20%3D%20%5Cdet(%5Cmathbf%7BU%7D)%20%5Cdet(%5Cmathbf%7BB%7D)" style="display:inline-block;margin: 0;"/> ，其实这就是 <img src="https://math.now.sh?inline=%5Cdet%28%5Cmathbf%7BAB%7D%29%20%3D%20%5Cdet(%5Cmathbf%7BA%7D)%20%5Cdet(%5Cmathbf%7BB%7D)" style="display:inline-block;margin: 0;"/> 的两个特例。</p>
<p>根据矩阵乘法的性质，<img src="https://math.now.sh?inline=%5Cmathbf%7BLB%7D" style="display:inline-block;margin: 0;"/> 的每一行均是 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 的所有行的线性组合，比如 <img src="https://math.now.sh?inline=%5Cmathbf%7BLB%7D" style="display:inline-block;margin: 0;"/> 的第一行就是 <img src="https://math.now.sh?inline=l_%7B11%7D%20%5Cmathbf%7Bb%7D_%7B1%7D%5E%7B'%7D" style="display:inline-block;margin: 0;"/> ；第二行就是 <img src="https://math.now.sh?inline=l_%7B21%7D%20%5Cmathbf%7Bb%7D_%7B1%7D%5E%7B'%7D%20%2B%20l_%7B22%7D%20%5Cmathbf%7Bb%7D_%7B2%7D%5E%7B'%7D" style="display:inline-block;margin: 0;"/>，以此类推。因此，第二行至第 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 行均添加了其他行的倍数，根据性质 4 我们知道这不会影响行列式的大小，因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cdet%28%5Cmathbf%7BLB%7D%29%20%26%3D%20%5Cleft%7C%20%5Cbegin%7Barray%7D%7Bc%7D%0Al_%7B11%7D%20%5Cmathbf%7Bb%7D_%7B1%7D%5E%7B'%7D%20%5C%5C%0Al_%7B21%7D%20%5Cmathbf%7Bb%7D_%7B1%7D%5E%7B'%7D%20%20%2B%20l_%7B22%7D%20%5Cmathbf%7Bb%7D_%7B2%7D%5E%7B'%7D%20%5C%5C%0A%5Ccdots%20%5C%5C%0Al_%7Bn1%7D%20%5Cmathbf%7Bb%7D_%7B1%7D%5E%7B'%7D%20%20%2B%20%5Ccdots%20%2B%20%20l_%7Bnn%7D%20%5Cmathbf%7Bb%7D_%7Bn%7D%5E%7B'%7D%20%5C%5C%0A%0A%5Cend%7Barray%7D%20%5Cright%7C%20%5C%5C%0A%0A%0A%26%3D%20%5Cleft%7C%20%5Cbegin%7Barray%7D%7Bc%7D%0Al_%7B11%7D%20%5Cmathbf%7Bb%7D_%7B1%7D%5E%7B'%7D%20%5C%5C%0Al_%7B22%7D%20%5Cmathbf%7Bb%7D_%7B2%7D%5E%7B'%7D%20%5C%5C%0A%5Ccdots%20%5C%5C%0Al_%7Bnn%7D%20%5Cmathbf%7Bb%7D_%7Bn%7D%5E%7B'%7D%20%5C%5C%0A%0A%5Cend%7Barray%7D%20%5Cright%7C%20%5C%5C%0A%0A%26%3D%20l_%7B11%7D%20l_%7B22%7D%20%5Ccdots%20l_%7Bnn%7D%20%20%5Cleft%7C%20%5Cbegin%7Barray%7D%7Bc%7D%20%5Cmathbf%7Bb%7D_%7B1%7D%5E%7B'%7D%20%5C%5C%0A%5Cmathbf%7Bb%7D_%7B2%7D%5E%7B'%7D%20%5C%5C%0A%5Ccdots%20%5C%5C%0A%5Cmathbf%7Bb%7D_%7Bn%7D%5E%7B'%7D%20%5C%5C%0A%0A%5Cend%7Barray%7D%20%5Cright%7C%20%5C%5C%0A%0A%26%3D%20%5Cdet(%5Cmathbf%7BB%7D)%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>同理 <img src="https://math.now.sh?inline=%5Cmathbf%7BUB%7D" style="display:inline-block;margin: 0;"/> 的每一行均是 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 的所有行的线性组合，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cdet%28%5Cmathbf%7BUB%7D%29%20%26%3D%20%5Cleft%7C%20%5Cbegin%7Barray%7D%7Bc%7D%0Au_%7B11%7D%20%5Cmathbf%7Bb%7D_%7B1%7D%5E%7B'%7D%20%20%2B%20u_%7B12%7D%20%5Cmathbf%7Bb%7D_%7B2%7D%5E%7B'%7D%20%20%2B%20%5Ccdots%20%2B%20%20u_%7B1n%7D%20%5Cmathbf%7Bb%7D_%7Bn%7D%5E%7B'%7D%20%5C%5C%0A%5Ccdots%20%5C%5C%0Au_%7Bnn%7D%20%5Cmathbf%7Bb%7D_%7Bn%7D%5E%7B'%7D%5C%5C%0A%0A%5Cend%7Barray%7D%20%5Cright%7C%20%5C%5C%0A%0A%0A%26%3D%20%5Cleft%7C%20%5Cbegin%7Barray%7D%7Bc%7D%0Au_%7B11%7D%20%5Cmathbf%7Bb%7D_%7B1%7D%5E%7B'%7D%20%5C%5C%0Au_%7B22%7D%20%5Cmathbf%7Bb%7D_%7B2%7D%5E%7B'%7D%20%5C%5C%0A%5Ccdots%20%5C%5C%0Au_%7Bnn%7D%20%5Cmathbf%7Bb%7D_%7Bn%7D%5E%7B'%7D%20%5C%5C%0A%0A%5Cend%7Barray%7D%20%5Cright%7C%20%5C%5C%0A%0A%26%3D%20u_%7B11%7D%20u_%7B22%7D%20%5Ccdots%20u_%7Bnn%7D%20%20%5Cleft%7C%20%5Cbegin%7Barray%7D%7Bc%7D%20%5Cmathbf%7Bb%7D_%7B1%7D%5E%7B'%7D%20%5C%5C%0A%5Cmathbf%7Bb%7D_%7B2%7D%5E%7B'%7D%20%5C%5C%0A%5Ccdots%20%5C%5C%0A%5Cmathbf%7Bb%7D_%7Bn%7D%5E%7B'%7D%20%5C%5C%0A%0A%5Cend%7Barray%7D%20%5Cright%7C%20%5C%5C%0A%0A%26%3D%20%20%5Cdet(%5Cmathbf%7BU%7D)%20%5Cdet(%5Cmathbf%7BB%7D)%20%5Cquad%20%5Cbecause%20%5Ctext%7B%E6%80%A7%E8%B4%A8%205%7D%20%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>因此我们得到：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cdet%28%5Cmathbf%7BAB%7D%29%20%26%3D%20%5Cdet(%5Cmathbf%7BLUB%7D)%20%5C%5C%0A%26%20%3D%20%5Cdet(%5Cmathbf%7BUB%7D)%20%5C%5C%0A%26%20%3D%20%5Cdet(%5Cmathbf%7BU%7D)%20%5Cdet(%5Cmathbf%7BB%7D)%20%5C%5C%0A%26%20%3D%20%5Cdet(%5Cmathbf%7BA%7D)%20%5Cdet(%5Cmathbf%7BB%7D)%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>因此我们得证 <img src="https://math.now.sh?inline=%5Cdet%28%5Cmathbf%7BAB%7D%29%20%3D%20%5Cdet(%5Cmathbf%7BA%7D)%20%5Cdet(%5Cmathbf%7BB%7D)" style="display:inline-block;margin: 0;"/> 。</p>
<h1>证明 det(A’) = det(A)</h1>
<p>根据 <img src="https://math.now.sh?inline=%5Cdet%28%5Cmathbf%7BAB%7D%29%20%3D%20%5Cdet(%5Cmathbf%7BA%7D)%20%5Cdet(%5Cmathbf%7BB%7D)" style="display:inline-block;margin: 0;"/> ，我们可以轻松证明这一点。</p>
<p>我们首先还是对 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 进行消元，我们得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%3D%20%5Cmathbf%7BLU%7D" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BA'%7D%20%3D%20%5Cmathbf%7BU'L'%7D" style="display:inline-block;margin: 0;"/> ，根据 <img src="https://math.now.sh?inline=%5Cdet%28%5Cmathbf%7BAB%7D%29%20%3D%20%5Cdet(%5Cmathbf%7BA%7D)%20%5Cdet(%5Cmathbf%7BB%7D)" style="display:inline-block;margin: 0;"/> ，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cdet%28%5Cmathbf%7BA%7D%29%20%26%3D%20%5Cdet(%5Cmathbf%7BL%7D)%20%5Cdet(%5Cmathbf%7BU%7D)%20%20%5C%5C%0A%5Cdet(%5Cmathbf%7BA'%7D)%20%26%3D%20%5Cdet(%5Cmathbf%7BU'%7D)%20%5Cdet(%5Cmathbf%7BL'%7D)%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>而 <img src="https://math.now.sh?inline=%5Cdet%28%5Cmathbf%7BU%7D%29" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cdet%28%5Cmathbf%7BU'%7D%29" style="display:inline-block;margin: 0;"/> 均是对角线元素乘积，因此二者相等，同理 $\det(\mathbf{L}) = \det(\mathbf{L’}) $  ，故得证 <img src="https://math.now.sh?inline=%5Cdet%28%5Cmathbf%7BA'%7D%29%20%3D%20%5Cdet(%5Cmathbf%7BA%7D)" style="display:inline-block;margin: 0;"/> 。</p>
<p>这说明在行列式计算中，行和列的地位是一样的，例如任意交换两列，矩阵的行列式同样也要改变符号。因为我们可以先对矩阵进行转置 (不改变行列式) ，然后交换两行（符号改变），再转置回来（不改变行列式），此时我们的实际效果是交换了两列，而行列式符号发生了改变。</p>
<h1>参考文献</h1>
<ol>
<li>MIT 18.06 线性代数课程</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>内积与角度及正交</title>
    <url>/posts/c511f635/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>第一次看到余弦定理的证明过程，记录一下。</p>
<span id="more"></span>
<h1>内积定义</h1>
<p>本文中，一般字母表示向量，希腊字母表示标量。</p>
<p>内积是一个实数函数，其将两个向量映射为一个标量，记为 <img src="https://math.now.sh?inline=%3Cx%2Cy%3E" style="display:inline-block;margin: 0;"/> ，内积满足下面的定理：对于同一向量空间的任意三个向量 <img src="https://math.now.sh?inline=x%2Cy%2Cx" style="display:inline-block;margin: 0;"/> ，及任意一个标量 <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/> ，存在</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Clangle%20x%2C%20x%5Crangle%20%5Cgeq%200%20%5C%5C%0A%26%5Clangle%20x%2C%20x%5Crangle%3D0%20%5Ctext%20%7B%20if%20and%20only%20if%20%7D%20x%3D0%20%5C%5C%0A%26%5Clangle%20x%2By%2C%20z%5Crangle%3D%5Clangle%20x%2C%20z%5Crangle%2B%5Clangle%20y%2C%20z%5Crangle%20%5C%5C%0A%26%5Clangle%5Calpha%20x%2C%20y%5Crangle%3D%5Calpha%5Clangle%20x%2C%20y%5Crangle%20%5C%5C%0A%26%5Clangle%20x%2C%20y%5Crangle%3D%5Clangle%20y%2C%20x%5Crangle%0A%5Cend%7Baligned%7D%0A" /></p><p><strong>标准向量内积</strong> (<em>standard inner product</em>) 定义如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Clangle%20x%2C%20y%5Crangle%3Dx%5E%7B%5Ctop%7D%20y%3D%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%20x_%7Bk%7D%20y_%7Bk%7D%20.%0A" /></p><p>标准向量内积和欧几里得范数存在以下关系：</p>
<p style=""><img src="https://math.now.sh?from=%5Csqrt%7B%5Clangle%20x%2C%20x%5Crangle%7D%3D%5C%7Cx%5C%7C_%7B2%7D%20%0A" /></p><h1>余弦定理</h1>
<p>下面我们采用勾股定理来证明余弦定理，假设向量 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 的夹角为 <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/> ，设 <img src="https://math.now.sh?inline=z%3Dx-y" style="display:inline-block;margin: 0;"/> ，如下图，我们做一条中垂线。</p>
<p><img src="1.png" alt="1"></p>
<p>根据勾股定理，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5C%7Cz%5C%7C_%7B2%7D%5E%7B2%7D%20%26%3D%5Cleft%28%5C%7Cy%5C%7C_%7B2%7D%20%5Csin%20%5Ctheta%5Cright%29%5E%7B2%7D%2B%5Cleft(%5C%7Cx%5C%7C_%7B2%7D-%5C%7Cy%5C%7C_%7B2%7D%20%5Ccos%20%5Ctheta%5Cright)%5E%7B2%7D%20%5C%5C%0A%26%3D%5C%7Cx%5C%7C_%7B2%7D%5E%7B2%7D%2B%5C%7Cy%5C%7C_%7B2%7D%5E%7B2%7D-2%5C%7Cx%5C%7C_%7B2%7D%5C%7Cy%5C%7C_%7B2%7D%20%5Ccos%20%5Ctheta%0A%5Cend%7Baligned%7D%0A" /></p><p>同时，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5C%7Cz%5C%7C_%7B2%7D%5E%7B2%7D%3D%5C%7Cx-y%5C%7C_%7B2%7D%5E%7B2%7D%3D%28x-y%29%5E%7B%5Ctop%7D(x-y)%3Dx%5E%7B%5Ctop%7D%20x%2By%5E%7B%5Ctop%7D%20y-2%20x%5E%7B%5Ctop%7D%20y%0A" /></p><p>比较二式，我们得到</p>
<p style=""><img src="https://math.now.sh?from=x%5E%7B%5Ctop%7D%20y%3D%5C%7Cx%5C%7C_%7B2%7D%5C%7Cy%5C%7C_%7B2%7D%20%5Ccos%20%5Ctheta%0A" /></p><p>或者写成</p>
<p style=""><img src="https://math.now.sh?from=%5Ccos%20%5Ctheta%3D%5Cfrac%7Bx%5E%7B%5Ctop%7D%20y%7D%7B%5C%7Cx%5C%7C_%7B2%7D%5C%7Cy%5C%7C_%7B2%7D%7D%0A" /></p><p>因此我们有 Cauchy–Schwartz 不等式，即：</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%7Cx%5E%7B%5Ctop%7D%20y%5Cright%7C%20%5Cleq%5C%7Cx%5C%7C_%7B2%7D%20%5Cmid%20y%20%5C%7C_%7B2%7D%0A" /></p><h1>两个向量正交</h1>
<p>如果两个向量之间的角度为直角，此时我们称两个向量正交。</p>
<p>根据上面的公式 <img src="https://math.now.sh?inline=x%5E%7B%5Ctop%7D%20y%3D%5C%7Cx%5C%7C_%7B2%7D%5C%7Cy%5C%7C_%7B2%7D%20%5Ccos%20%5Ctheta" style="display:inline-block;margin: 0;"/> ，我们知道两个向量正交，等价于其内积为零，即 <img src="https://math.now.sh?inline=x%5E%7B%5Ctop%7D%20y%3D%200" style="display:inline-block;margin: 0;"/> 。</p>
<h1>两个子空间正交</h1>
<p>设 <img src="https://math.now.sh?inline=X" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=Y" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 的两个子空间，如果对每一 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D%20%5Cin%20X" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%20%5Cin%20Y" style="display:inline-block;margin: 0;"/> 均有 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%5E%7B%5Ctop%7Dy%20%3D%200%7D" style="display:inline-block;margin: 0;"/> ，则称  <img src="https://math.now.sh?inline=X" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=Y" style="display:inline-block;margin: 0;"/> 是正交的，记作 <img src="https://math.now.sh?inline=X%20%5Cperp%20Y" style="display:inline-block;margin: 0;"/> 。</p>
<p>举个例子，<strong>矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的行空间与其零空间正交</strong>。证明如下，根据零空间定义，我们有 <img src="https://math.now.sh?inline=%5Cmathbf%7BAx%20%3D%200%7D" style="display:inline-block;margin: 0;"/> ，根据矩阵乘法，我们得到 矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的每一行与 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> 的内积均为 0，即矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的每一行均与 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> 正交。由于矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的行空间是矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的所有行的线性组合，因此易得矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的行空间与其零空间正交。</p>
<p>性质：对于两个正交的子空间  <img src="https://math.now.sh?inline=X" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=Y" style="display:inline-block;margin: 0;"/> ，其交集为 <img src="https://math.now.sh?inline=%5C%7B%5Cmathbf%7B0%7D%5C%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>证明：对于 <img src="https://math.now.sh?inline=X" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=Y" style="display:inline-block;margin: 0;"/> 的交集的元素，设 <img src="https://math.now.sh?inline=x%20%5Cin%20X%20%20%5Ccap%20Y" style="display:inline-block;margin: 0;"/> ，则必须满足其自身与自身正交，即  <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%5E%7B%5Ctop%7Dx%20%3D%200%7D" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%20%3D%200%7D" style="display:inline-block;margin: 0;"/> 。</p>
<h2 id="正交补">正交补</h2>
<p>令  <img src="https://math.now.sh?inline=Y" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 的子空间， <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 中所有与 <img src="https://math.now.sh?inline=Y" style="display:inline-block;margin: 0;"/> 中每一向量正交的向量集合称为 <img src="https://math.now.sh?inline=Y" style="display:inline-block;margin: 0;"/> 的正交补，记为 <img src="https://math.now.sh?inline=Y%5E%7B%5Cperp%7D" style="display:inline-block;margin: 0;"/> ，即</p>
<p style=""><img src="https://math.now.sh?from=Y%5E%7B%5Cperp%7D%20%3D%20%5C%7B%20x%20%5Cin%20%5Cmathbf%7BR%7D%5E%7Bn%7D%20%7C%20%5Cmathbf%7Bx%5E%7BT%7Dy%7D%20%3D%200%20%2C%20%5Ctext%7B%20for%20every%20%7D%20%5Cmathbf%7By%7D%20%5Cin%20Y%5C%7D%0A" /></p><p>而且  <img src="https://math.now.sh?inline=Y%5E%7B%5Cperp%7D" style="display:inline-block;margin: 0;"/> 也是一个子空间，根据加法和标量乘法原则证明如下：</p>
<p>设 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D%20%5Cin%20Y%5E%7B%5Cperp%7D" style="display:inline-block;margin: 0;"/>, 且 <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/> 为一个标量, 则对任意 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%20%5Cin%20Y" style="display:inline-block;margin: 0;"/>,</p>
<p style=""><img src="https://math.now.sh?from=%28%5Calpha%20%5Cboldsymbol%7Bx%7D%29%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7By%7D%3D%5Calpha%5Cleft(%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7By%7D%5Cright)%3D%5Calpha%20%5Ccdot%200%3D0%0A" /></p><p>因此 <img src="https://math.now.sh?inline=%5Calpha%20%5Cmathbf%7Bx%7D%20%5Cin%20Y%5E%7B%5Cperp%7D" style="display:inline-block;margin: 0;"/>。</p>
<p>若 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=Y%5E%7B%5Cperp%7D" style="display:inline-block;margin: 0;"/> 的元素, 则对每一个 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%20%5Cin%20Y" style="display:inline-block;margin: 0;"/>, 有</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cboldsymbol%7Bx%7D_%7B1%7D%2B%5Cboldsymbol%7Bx%7D_%7B2%7D%5Cright%29%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7By%7D%3D%5Cboldsymbol%7Bx%7D_%7B1%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7By%7D%2B%5Cboldsymbol%7Bx%7D_%7B2%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7By%7D%3D0%2B0%3D0%0A" /></p><p>因此 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D_%7B1%7D%2B%5Cboldsymbol%7Bx%7D_%7B2%7D%20%5Cin%20Y%5E%7B%5Cperp%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>于是得证  <img src="https://math.now.sh?inline=Y%5E%7B%5Cperp%7D" style="display:inline-block;margin: 0;"/> 也是  <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 的子空间。</p>
<p>我们可以进一步证明，矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的行空间与其零空间互为正交补。</p>
<h1>参考文献</h1>
<ol>
<li>Calafiore G C, El Ghaoui L. Optimization models[M]. Cambridge university press, 2014.</li>
<li>Leon S J, Bica I, Hohn T. Linear algebra with applications[M]. Upper Saddle River, NJ: Pearson Prentice Hall, 2006.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>MCMC算法</title>
    <url>/posts/ae89860e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>马尔科夫链蒙特卡罗方法（Markov Chain Monte Carlo，以下简称MCMC），是用于得到服从某一特定分布的随机采样的方法。很多复杂算法求解的基础，都使用到了 MCMC 算法。</p>
<p>本文内容主要参考张勤老师的《动物遗传育种中的计算方法》和刘建平的博客<a href="https://www.cnblogs.com/pinard/p/6625739.html">MCMC(一)蒙特卡罗方法</a></p>
<span id="more"></span>
<h1>随机数产生方法</h1>
<p>服从某一特定分布的随机变量的抽样值称为随机数，我们通常采用数学方法来产生随机数。</p>
<p>这种方法是利用一定的数学递推公式来产生随机数，即在给定一个任意的初值后，就可由此递推公式产生任意多的随机数，这种方法非常容易在计算机上实现。这种方法最大的缺陷在于给定初值后，以后所有的随机数便被唯一地确定下来了，而且这些随机数还存在<strong>周期现象</strong>，即随机序列达到一定长度后会出现重复，因此严格来说这些随机数并不是真正的随机数，故一般称之为<strong>伪随机数</strong> (pseudo random number)。但由于初值可随机确定，因此其后的一系列数也可看作是随机的。</p>
<h2 id="0-1-均匀随机数的产生">[0,1]均匀随机数的产生</h2>
<p>[0,1]均匀随机数是在[0,1]区间上均匀分布随机变量的抽样值，其是产生其他一切分布随机数的基础。也就是说，任何其他分布的随机数都可通过对[0,1]均匀随机数进行某种转换得到。</p>
<p>目前产生[0,1]均匀随机数的最广泛的方法是<strong>线性同余法</strong>，也称为<strong>线性同余发生器</strong> (linear congruential generator) 。</p>
<h3 id="线性同余法">线性同余法</h3>
<p>Lehmer (1951) 提出这种方法，它利用数论中的同余运算原理产生随机数，其递推公式为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ax_%7Bi%7D%20%26%3D%20%28ax_%7Bi-1%7D%20%2Bc%29(%5Cmathrm%7BMOD%7D%20%5Cquad%20m)%5C%5C%0Ar_%7Bi%7D%20%26%3D%20x_%7Bi%7D%2Fm%2C%20%5Cquad%20i%3D1%2C2%2C%5Ccdots%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=a%2Cc%2Cm" style="display:inline-block;margin: 0;"/> 是事先给定的参数，均为非负整数；<img src="https://math.now.sh?inline=x_%7Bi%7D" style="display:inline-block;margin: 0;"/> 是在 [0,m] 区间取值的一个随机整数；<img src="https://math.now.sh?inline=r_%7Bi%7D" style="display:inline-block;margin: 0;"/> 是在 [0,1] 区间取值的一个随机实数。</p>
<p>在给定一个任意非负整数的初值 <img src="https://math.now.sh?inline=x_%7B0%7D" style="display:inline-block;margin: 0;"/> 后，由上式求出整数序列 <img src="https://math.now.sh?inline=x_%7B1%7D%2Cx_%7B2%7D%2C%5Ccdots" style="display:inline-block;margin: 0;"/> 和实数序列 <img src="https://math.now.sh?inline=r_%7B1%7D%2Cr_%7B2%7D%2C%5Ccdots" style="display:inline-block;margin: 0;"/> 。</p>
<p>若 <img src="https://math.now.sh?inline=c%3D0" style="display:inline-block;margin: 0;"/> ，则称为<strong>乘同余法</strong>；若 <img src="https://math.now.sh?inline=c%3E0" style="display:inline-block;margin: 0;"/> ，则称为<strong>混同余法</strong>。</p>
<h2 id="其他分布随机数的产生">其他分布随机数的产生</h2>
<p>任何其他分布的随机数都可以通过[0,1]均匀进行某种转换得到，例如正态分布可以通过著名的 Box-Muller 变换得到，根据下面公式通过两个[0,1]均匀随机数，我们可以得到两个彼此独立的标准正态分布随机数（缺证明，下式中的 <img src="https://math.now.sh?inline=X_%7B1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=X_%7B2%7D" style="display:inline-block;margin: 0;"/> 为两个独立的[0,1]均匀随机数）。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26Z_%7B1%7D%3D%5Csqrt%7B-2%20%5Cln%20X_%7B1%7D%7D%20%5Ccos%20%5Cleft%282%20%5Cpi%20X_%7B2%7D%5Cright%29%20%5C%5C%0A%26Z_%7B2%7D%3D%5Csqrt%7B-2%20%5Cln%20X_%7B1%7D%7D%20%5Csin%20%5Cleft(2%20%5Cpi%20X_%7B2%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>下面介绍两种基本方法，反函数法与接受-拒绝采样法。</p>
<h3 id="反函数法">反函数法</h3>
<p>假设我们已知某个分布的累积分布函数 <img src="https://math.now.sh?inline=F%28x%29" style="display:inline-block;margin: 0;"/> ，那么抽样值可以通过下式得到</p>
<p style=""><img src="https://math.now.sh?from=x%20%3D%20F%5E%7B-1%7D%28u%29%0A" /></p><p>其中，<img src="https://math.now.sh?inline=u" style="display:inline-block;margin: 0;"/> 为[0,1]均匀随机数。</p>
<p>证明：因为 <img src="https://math.now.sh?inline=u" style="display:inline-block;margin: 0;"/> 服从[0,1]均匀分布，所以 <img src="https://math.now.sh?inline=P%28u%20%5Cleq%20t%29%20%3Dt" style="display:inline-block;margin: 0;"/> ，因此，我们有</p>
<p style=""><img src="https://math.now.sh?from=P%5Cleft%28F%5E%7B-1%7D(u%29%20%5Cleqslant%20x%5Cright)%3D%5Cmathrm%7BP%7D%5Cleft(F%5Cleft(F%5E%7B-1%7D(u)%5Cright)%20%5Cleqslant%20F(x)%5Cright)%3D%5Cmathrm%7BP%7D(u%20%5Cleqslant%20F(x))%3D%5Cmathrm%7BF%7D(x)%0A" /></p><p>所以 <img src="https://math.now.sh?inline=F%5E%7B-1%7D%28u%29" style="display:inline-block;margin: 0;"/> 的累积分布函数就是 <img src="https://math.now.sh?inline=F%28x%29" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=x%20%3D%20F%5E%7B-1%7D%28u%29" style="display:inline-block;margin: 0;"/> 就是 <img src="https://math.now.sh?inline=F%28x%29" style="display:inline-block;margin: 0;"/> 的一个抽样值。</p>
<p>这种方法非常简单，但是要求随机变量累积分布函数的反函数存在，而且容易计算。在很多情况下，累积分布函数的反函数不存在，或者虽然存在但其计算却非常困难，此时这种方法并不适用。</p>
<h3 id="接受-拒绝采样法">接受-拒绝采样法</h3>
<p>对于概率分布不常见的分布，假设我们已知其概率密度分布为 <img src="https://math.now.sh?inline=p%28x%29" style="display:inline-block;margin: 0;"/> ，此时我们用一个程序可采样的分布 <img src="https://math.now.sh?inline=q%28x%29" style="display:inline-block;margin: 0;"/> ，比如正态分布。具体过程如下：</p>
<ol>
<li>
<p>首先我们找到一个常数 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> ,  使得 <img src="https://math.now.sh?inline=p%28x%29%20%5Cleq%20kq(x)" style="display:inline-block;margin: 0;"/> 恒成立，即 <img src="https://math.now.sh?inline=p%28x%29" style="display:inline-block;margin: 0;"/> 恒在 <img src="https://math.now.sh?inline=kq%28x%29" style="display:inline-block;margin: 0;"/> 下方。</p>
</li>
<li>
<p>采样得到 <img src="https://math.now.sh?inline=q%28x%29" style="display:inline-block;margin: 0;"/> 的一个样本 <img src="https://math.now.sh?inline=x_%7B0%7D" style="display:inline-block;margin: 0;"/> ，然后从均匀分布 <img src="https://math.now.sh?inline=%5B0%2Ckq%28x_%7B0%7D%29%5D" style="display:inline-block;margin: 0;"/> 中采样得到一个值 <img src="https://math.now.sh?inline=u" style="display:inline-block;margin: 0;"/> 。如果 <img src="https://math.now.sh?inline=u%20%3E%20p%28x_%7B0%7D%29" style="display:inline-block;margin: 0;"/> ，则拒绝这一次抽样，否则则接受这次抽样。</p>
</li>
<li>
<p>重复以上过程，直到得到 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个抽样值。</p>
</li>
</ol>
<p>整个过程从直观理解来看，就是从  <img src="https://math.now.sh?inline=kq%28x%29" style="display:inline-block;margin: 0;"/> 曲线下方的二维图形中随机抽取一个点，如果这个点正好落在  <img src="https://math.now.sh?inline=p%28x%29" style="display:inline-block;margin: 0;"/> 的曲线下方，则接受这个抽样，否则就拒绝这个抽样。</p>
<p>因此使用接受-拒绝采样法时，只有当   <img src="https://math.now.sh?inline=kq%28x%29" style="display:inline-block;margin: 0;"/> 与 <img src="https://math.now.sh?inline=p%28x%29" style="display:inline-block;margin: 0;"/> 曲线图形越接近时，抽样接受率越高，抽样效率越高。</p>
<h1>蒙特卡罗方法</h1>
<p>蒙特卡罗方法 (Monte Carlo) 是指使用随机数来解决很多计算问题的方法。</p>
<p>总的来说，蒙特卡罗方法处理的问题可以分为两大类：</p>
<p>第一类是确定性的数学问题。如计算定积分、解线性和非线性方程组，解积分方程和某些偏积分方程等。在这类问题中，因不含时间因素，故常将相应的模拟模型称为静态模型。</p>
<p>第二类是随机性问题，例如中子在介质中的扩散问题，运筹学中的库存问题等。</p>
<h2 id="用蒙特卡罗方法计算定积分">用蒙特卡罗方法计算定积分</h2>
<p>用蒙特卡罗方法计算定积分是其最典型的应用，这里有两种算法，一是随机投点法，二是平均值法。下面以单重积分为例，分别进行介绍。</p>
<h3 id="随机投点法">随机投点法</h3>
<p>假设所求定积分为</p>
<p style=""><img src="https://math.now.sh?from=I%3D%20%5Cint_%7B0%7D%5E%7B1%7D%20g%28x%29%20dx%2C%20%5Cquad%200%20%5Cleq%20g(x)%20%5Cleq%201%0A" /></p><p>因此，如果我们向 (0,0) (0,1) (1,1) (1,0) 这四个点构成的单位正方形均匀地投点，落在曲线 <img src="https://math.now.sh?inline=g%28x%29" style="display:inline-block;margin: 0;"/> 下方的概率就是我们要求的定积分，证明如下：</p>
<p style=""><img src="https://math.now.sh?from=P%28y%20%5Cleq%20g(x%29)%20%3D%20%5Cint_%7B0%7D%5E%7B1%7D%20%5Cint_%7B0%7D%5E%7Bg(x)%7D%20dydx%20%3D%20%5Cint_%7B0%7D%5E%7B1%7D%20g(x)%20dx%0A" /></p><p>因此，我们可以按照以下步骤计算这个积分：</p>
<ol>
<li>独立地产生两个 [0,1]均匀随机数 <img src="https://math.now.sh?inline=x_%7Bi%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=y_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，则 <img src="https://math.now.sh?inline=%28x_%7Bi%7D%2C%20y_%7Bi%7D%29" style="display:inline-block;margin: 0;"/> 就构成了在单位正方形中地一个均匀分布的随机点</li>
<li>检验该随机点是否落在曲线 <img src="https://math.now.sh?inline=g%28x%29" style="display:inline-block;margin: 0;"/> 下方</li>
</ol>
<p>重复上面两个步骤 <img src="https://math.now.sh?inline=N" style="display:inline-block;margin: 0;"/> 次，设有 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> 次随机点落在曲线 <img src="https://math.now.sh?inline=g%28x%29" style="display:inline-block;margin: 0;"/> 下方，则当 <img src="https://math.now.sh?inline=N" style="display:inline-block;margin: 0;"/> 足够大时，我们有</p>
<p style=""><img src="https://math.now.sh?from=I%20%5Capprox%20m%2FN%0A" /></p><p>我们可以将上面的方法一般化，假设我们所求的定积分为</p>
<p style=""><img src="https://math.now.sh?from=I%3D%20%5Cint_%7Ba%7D%5E%7Bb%7D%20g%28x%29%20dx%2C%20%5Cquad%20L%20%5Cleq%20g(x)%20%5Cleq%20M%0A" /></p><p>我们需要先对这个积分进行变换。由 <img src="https://math.now.sh?inline=L%20%5Cleq%20g%28x%29%20%5Cleq%20M" style="display:inline-block;margin: 0;"/> 可得 <img src="https://math.now.sh?inline=0%20%5Cleqslant%20%5Cfrac%7Bg%28x%29-L%7D%7BM-L%7D%20%5Cleqslant%201" style="display:inline-block;margin: 0;"/> ，因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AI%20%26%3D%5Cint_%7Ba%7D%5E%7Bb%7D%20g%28x%29%20%5Cmathrm%7Bd%7D%20x%20%5C%5C%0A%26%3D%5Cint_%7Ba%7D%5E%7Bb%7D(M-L)%20%5Cfrac%7Bg(x)-L%2BL%7D%7BM-L%7D%20%5Cmathrm%7B~d%7D%20x%20%5C%5C%0A%26%3D(M-L)%20%5Cint_%7Ba%7D%5E%7Bb%7D%20%5Cfrac%7Bg(x)-L%7D%7BM-L%7D%20%5Cmathrm%7B~d%7D%20x%2BL(b-a)%0A%5Cend%7Baligned%7D%0A" /></p><p>令 <img src="https://math.now.sh?inline=x%20%3D%20a%2B%28b-a%29z" style="display:inline-block;margin: 0;"/> ，有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26I%3D%28M-L%29%20%5Cint_%7B0%7D%5E%7B1%7D%20%5Cfrac%7Bg(a%2B(b-a)%20z)-L%7D%7BM-L%7D(b-a)%20d%20z%2BL(b-a)%20%5C%5C%0A%26%20%5C%5C%0A%26%3D(M-L)(b-a)%20%5Cint_%7B0%7D%5E%7B1%7D%20g%5E%7B*%7D(z)%20d%20z%2BL(b-a)%0A%5Cend%7Baligned%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=g%5E%7B*%7D%28z%29%20%3D%20%5Cfrac%7Bg(a%2B(b-a)%20z)-L%7D%7BM-L%7D" style="display:inline-block;margin: 0;"/> ，它满足 <img src="https://math.now.sh?inline=0%20%5Cleq%20g%5E%7B*%7D%28x%29%20%5Cleq%201" style="display:inline-block;margin: 0;"/> ，因此积分 $ \int_{0}^{1} g^{*}(z) d z$ 可以按照上面的方法进行计算。</p>
<h3 id="平均值法">平均值法</h3>
<p>假设我们所求的定积分为</p>
<p style=""><img src="https://math.now.sh?from=I%3D%20%5Cint_%7Ba%7D%5E%7Bb%7D%20g%28x%29%20dx%0A" /></p><p>设 <img src="https://math.now.sh?inline=R" style="display:inline-block;margin: 0;"/> 是 [a,b] 区间上的均匀分布随机变量，则</p>
<p style=""><img src="https://math.now.sh?from=E%28g(R%29)%3D%5Cint_%7Ba%7D%5E%7Bb%7D%20g(x)%20p(x)%20%5Cmathrm%7Bd%7D%20x%3D%5Cint_%7Ba%7D%5E%7Bb%7D%20g(x)%20%5Cfrac%7B1%7D%7Bb-a%7D%20%5Cmathrm%7B~d%7D%20x%3D%5Cfrac%7B1%7D%7Bb-a%7D%20I%0A" /></p><p>于是，我们有</p>
<p style=""><img src="https://math.now.sh?from=I%20%3D%28b-a%29E(g(R))%0A" /></p><p>因此，我们可以用以下方法计算积分的近似解</p>
<ol>
<li>产生 [a,b] 区间上的均匀分布随机数 <img src="https://math.now.sh?inline=r_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=i%3D1%2C2%2C%5Ccdots%2CN" style="display:inline-block;margin: 0;"/></li>
<li>计算 <img src="https://math.now.sh?inline=g%28r_%7Bi%7D%29" style="display:inline-block;margin: 0;"/></li>
</ol>
<p>当 <img src="https://math.now.sh?inline=N" style="display:inline-block;margin: 0;"/> 足够大时，我们有</p>
<p style=""><img src="https://math.now.sh?from=I%20%5Capprox%20%5Cfrac%7Bb-a%7D%7BN%7D%20%5Csum_%7Bi%3D1%7D%5E%7BN%7D%20g%28r_%7Bi%7D%29%0A" /></p><p>其实这种做法就是在 [a,b] 区间上随机采样 <img src="https://math.now.sh?inline=N" style="display:inline-block;margin: 0;"/> 个点，用这 <img src="https://math.now.sh?inline=N" style="display:inline-block;margin: 0;"/> 个点的函数值均值代表 [a,b] 区间上的所有函数值，即用一个矩形的面积代表原来的曲线下方的面积。</p>
<p>这里我们有一个隐藏的假设是 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 在 [a,b] 区间是均匀分布的，而大多数时候这个假设均不成立。此时我们进一步假设 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 在 [a,b] 区间上的概率密度函数为 <img src="https://math.now.sh?inline=p%28x%29" style="display:inline-block;margin: 0;"/> ，此时我们有蒙特卡罗方法的一般形式 ：</p>
<p style=""><img src="https://math.now.sh?from=I%3D%5Cint_%7Ba%7D%5E%7Bb%7D%20g%28x%29%20d%20x%3D%5Cint_%7Ba%7D%5E%7Bb%7D%20%5Cfrac%7Bg(x)%7D%7Bp(x)%7D%20p(x)%20d%20x%20%3D%20E(%5Cfrac%7Bg(x)%7D%7Bp(x)%7D)%20%20%5Capprox%20%5Cfrac%7B1%7D%7BN%7D%20%5Csum_%7Bi%3D1%7D%5E%7BN%7D%20%5Cfrac%7Bg%5Cleft(x_%7Bi%7D%5Cright)%7D%7Bp%5Cleft(x_%7Bi%7D%5Cright)%7D%0A" /></p><p>因此，平均值法计算积分的一般过程如下：</p>
<ol>
<li>从概率密度函数为 <img src="https://math.now.sh?inline=p%28x%29" style="display:inline-block;margin: 0;"/> 的分布中生成随机数  $ x_{i}$ ，<img src="https://math.now.sh?inline=i%3D1%2C2%2C%5Ccdots%2CN" style="display:inline-block;margin: 0;"/></li>
<li>计算 <img src="https://math.now.sh?inline=g%5Cleft%28x_%7Bi%7D%5Cright%29%2Fp%5Cleft(x_%7Bi%7D%5Cright)" style="display:inline-block;margin: 0;"/></li>
</ol>
<p>当 <img src="https://math.now.sh?inline=N" style="display:inline-block;margin: 0;"/> 足够大时，我们有</p>
<p style=""><img src="https://math.now.sh?from=I%20%5Capprox%20%5Cfrac%7B1%7D%7BN%7D%20%5Csum_%7Bi%3D1%7D%5E%7BN%7D%20%5Cfrac%7Bg%5Cleft%28x_%7Bi%7D%5Cright%29%7D%7Bp%5Cleft(x_%7Bi%7D%5Cright)%7D%0A" /></p><p>可以看出当我们假设<img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 在 [a,b] 区间满足均匀分布时，我们将 <img src="https://math.now.sh?inline=p%28x%29%20%3D%20%5Cfrac%7B1%7D%7Bb-a%7D" style="display:inline-block;margin: 0;"/> 带入上式，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cfrac%7B1%7D%7BN%7D%20%5Csum_%7Bi%3D1%7D%5E%7BN%7D%20%5Cfrac%7Bg%5Cleft%28x_%7Bi%7D%5Cright%29%7D%7Bp%5Cleft(x_%7Bi%7D%5Cright)%7D%0A%26%3D%20%5Cfrac%7B1%7D%7BN%7D%20%5Csum_%7Bi%3D1%7D%5E%7BN%7D%20%5Cfrac%7Bg%5Cleft(x_%7Bi%7D%5Cright)%7D%7B1%2F(b-a)%7D%20%5C%5C%0A%26%3D%20%5Cfrac%7Bb-a%7D%7BN%7D%20%5Csum_%7Bi%3D1%7D%5E%7BN%7D%20g(x_%7Bi%7D)%0A%5Cend%7Baligned%7D%0A" /></p><p>我们得到了均匀分布的估计公式，即均匀分布是上式的一个特列。</p>
<h2 id="小结">小结</h2>
<p>蒙特卡罗方法的核心在于生成特定分布的随机数，常用的分布可以通过对于 [0,1] 均匀随机数进行转换得到。通过采用接受-拒绝采样，我们也可以得到一些不常见分布的随机数。</p>
<p>但是在很多时候，有一些分布我们还是很难得到其随机数，比如：</p>
<blockquote>
<p>1）对于一些二维分布<img src="https://math.now.sh?inline=p%28x%2Cy%29" style="display:inline-block;margin: 0;"/>，这个函数本身计算困难，但是我们能得到其条件分布 <img src="https://math.now.sh?inline=p%28x%7Cy%29" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=p%28y%7Cx%29" style="display:inline-block;margin: 0;"/> ，这时我们无法用接受-拒绝采样得到其样本集。</p>
<p>2）对于一些高维的分布 <img src="https://math.now.sh?inline=p%28x_%7B1%7D%2Cx_%7B2%7D%2C...%2Cx_%7Bn%7D%29" style="display:inline-block;margin: 0;"/> ，我们要找到一个合适的 <img src="https://math.now.sh?inline=q%28x%29" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 非常困难。</p>
</blockquote>
<p>此时我们需要马尔科夫链的方法帮助我们进行采样。</p>
<h1>马尔科夫链</h1>
<p>马尔科夫链 (Markov chain) 是一种最简单，应用最多的随机过程。随机过程是依赖于时间的一组随机变量。马尔科夫链要求具备“无记忆”的性质：下一状态的概率分布只能由当前状态决定，在时间序列中它前面的事件均与之无关，表示为</p>
<p style=""><img src="https://math.now.sh?from=P%5Cleft%28X_%7Bt%2B1%7D%3Dx%20%5Cmid%20X_%7Bt%7D%2C%20X_%7Bt-1%7D%2C%20%5Ccdots%5Cright%29%3DP%5Cleft(X_%7Bt%2B1%7D%3Dx%20%5Cmid%20X_%7Bt%7D%5Cright)%0A" /></p><p>我们将系统随着时间的变化而发生的状态改变称为系统状态的<strong>转移</strong>，将已知在时刻 <img src="https://math.now.sh?inline=t" style="display:inline-block;margin: 0;"/> 系统处于状态 <img src="https://math.now.sh?inline=s_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的条件下，在下一时刻处于状态 <img src="https://math.now.sh?inline=s_%7Bj%7D" style="display:inline-block;margin: 0;"/> 的概率称为<strong>转移概率</strong>，表示为 <img src="https://math.now.sh?inline=P_%7Bij%7D%28t%2C%20t%2B1%29" style="display:inline-block;margin: 0;"/> ，即</p>
<p style=""><img src="https://math.now.sh?from=P_%7Bij%7D%28t%2C%20t%2B1%29%20%3D%20P%5C%7B%20X(t%2B1)%20%3D%20s_%7Bj%7D%20%7C%20X(t)%20%3D%20s_%7Bi%7D%5C%7D%0A" /></p><p>如果系统由状态 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 在下一时刻转移为状态 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 的概率与系统当前所处的时刻无关，则称其为<strong>齐次的</strong> (homogeneous) 。对于齐次的马尔科夫链，我们可以将转移概率简单地表示为 <img src="https://math.now.sh?inline=P_%7Bij%7D" style="display:inline-block;margin: 0;"/> 。一般来说，我们涉及到的马尔科夫链均为齐次的，因此下文均默认为齐次的马尔科夫链。</p>
<p>此时我们将所有的转移概率放到一个矩阵中，称为<strong>转移概率矩阵</strong>，如下。</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7BP%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0AP_%7B11%7D%20%26%20P_%7B12%7D%20%26%20P_%7B13%7D%20%26%20%5Ccdots%20%5C%5C%0AP_%7B21%7D%20%26%20P_%7B22%7D%20%26%20P_%7B23%7D%20%26%20%5Ccdots%20%5C%5C%0AP_%7B31%7D%20%26%20P_%7B32%7D%20%26%20P_%7B33%7D%20%26%20%5Ccdots%20%5C%5C%0A%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cvdots%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>转移概率矩阵的<strong>每一行之和为1</strong>，即</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bj%7D%20P_%7Bij%7D%20%3D%201%0A" /></p><p>举个例子，假设天气变化是一个随机过程，假设天气的状态空间为 (有雨，晴天，多云)，再假设天气变化是一个马尔科夫链过程，即明天出现何种天气的概率仅与今天的天气有关。设状态转移矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7BP%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D%0A0.5%20%26%200.25%20%26%200.25%20%5C%5C%0A0.5%20%26%200%20%26%200.5%20%5C%5C%0A0.25%20%26%200.25%20%26%200.5%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>其中，第一行表示如果今天有雨，则明天为有雨，晴天，多云的概率分别为 0.5，0.25 和 0.25 。</p>
<p>假设系统初始的概率分布向量为 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cpi%7D_%7B0%7D%3D%5Cleft%5B%5Cpi_%7B0%7D%281%29%2C%20%5Cpi_%7B0%7D(2)%2C%20%5Cpi_%7B0%7D(3)%5Cright%5D" style="display:inline-block;margin: 0;"/> ，那么第一天的天气概率分布向量为 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cpi%7D_%7B1%7D%20%3D%20%5Cboldsymbol%7B%5Cpi%7D_%7B0%7D%20%20%5Cmathbf%7BP%7D" style="display:inline-block;margin: 0;"/> ，第二天的分布向量为 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cpi%7D_%7B2%7D%20%3D%20%5Cboldsymbol%7B%5Cpi%7D_%7B0%7D%20%20%5Cmathbf%7BP%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/>，依次类推，第 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 天的分布向量为 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cpi%7D_%7Bn%7D%20%3D%20%5Cboldsymbol%7B%5Cpi%7D_%7B0%7D%20%20%5Cmathbf%7BP%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> .</p>
<p>我们发现随着天数的增加，<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cpi%7D_%7Bn%7D" style="display:inline-block;margin: 0;"/> 会逐渐变成一个稳定不变的分布，此时我们称马尔科夫链<strong>收敛</strong>，收敛时系统状态空间的概率分布称为<strong>平稳分布</strong> (stationary distribution)，表示为 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cpi%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>在本例中为 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cpi%7D%20%3D%20%280.4%20%2C0.2%2C%200.4%29" style="display:inline-block;margin: 0;"/> ，而且与初始值无关。进一步发现其原因是由于 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 在 <img src="https://math.now.sh?inline=n%20%3D7" style="display:inline-block;margin: 0;"/> 之后就变成了一个稳定不变的矩阵，即</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bp%7D%5E%7B7%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Blll%7D%0A0.4%20%26%200.2%20%26%200.4%20%5C%5C%0A0.4%20%26%200.2%20%26%200.4%20%5C%5C%0A0.4%20%26%200.2%20%26%200.4%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cboldsymbol%7B%5Cpi%7D%20%5C%5C%0A%5Cboldsymbol%7B%5Cpi%7D%20%5C%5C%0A%5Cboldsymbol%7B%5Cpi%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>但是不是所有的马尔科夫链都能达到平稳分布。</p>
<h2 id="性质">性质</h2>
<p><strong>不可约</strong>：如果从马尔科夫链中的任一状态出发，都能以大于零的概率经过有限次转移变为其他任一状态，则称该马尔科夫链是<strong>不可约的</strong> (irreducible) 。假设 <img src="https://math.now.sh?inline=P_%7Bij%7D%28k%29" style="display:inline-block;margin: 0;"/> 为从状态 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 经过 k 次 (<img src="https://math.now.sh?inline=k%5Cgeq%201" style="display:inline-block;margin: 0;"/>) 转移变成状态 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 的概率，不可约是说对于任意的 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> ，必定存在一个正整数 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> ，使得 <img src="https://math.now.sh?inline=P_%7Bij%7D%28k%29%20%3E%200" style="display:inline-block;margin: 0;"/> 。换句话说，如果马尔科夫链是不可约的，那么它的任何两个状态是<strong>连通</strong>的（两个状态彼此均可以通过有限次转移变为另一种状态，记为 <img src="https://math.now.sh?inline=s_%7Bi%7D%20%5Cleftrightarrow%20s_%7Bj%7D" style="display:inline-block;margin: 0;"/> ），即可以经过一次或多次转移从某一种状态转移到任意一种状态。</p>
<p><strong>非周期</strong>：如果所有满足  <img src="https://math.now.sh?inline=P_%7Bii%7D%28k%29%20%3E%200" style="display:inline-block;margin: 0;"/> 的 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 中没有大于1的公因子，则称状态 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 是<strong>非周期的</strong> (aperiodic)。举个例子，假设存在一个马尔科夫链，其状态空间为 (1,2,3)， 而状态之间的转移只能是 1-2-3-1-2-3 ，即系统状态每经过三次转移就会发生重复，假设我们从状态 2 开始，则经过 3,6,9… 次转移之后会重复出现状态 2 ，因此我们说状态 2 是周期性的，其周期为3。由周期性的定义存在一下推论：</p>
<ol>
<li><em>推论</em>：若状态A与状态B连通，则A与B周期相同。</li>
<li><em>推论</em>：若不可约的马尔科夫链有周期性状态A，则该马尔科夫链的所有状态为周期性状态</li>
</ol>
<p>只有<strong>不可约</strong>和<strong>非周期</strong>的马尔科夫链才能收敛于<strong>平衡状态</strong>，并且存在以下性质</p>
<ol>
<li>
<p style=""><img src="https://math.now.sh?from=%5Clim%20_%7Bn%20%5Crightarrow%20%5Cinfty%7D%20P%5E%7Bn%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bccccc%7D%0A%5Cpi(1%29%20%26%20%5Cpi(2)%20%26%20%5Ccdots%20%26%20%5Cpi(j)%20%26%20%5Ccdots%20%5C%5C%0A%5Cpi(1)%20%26%20%5Cpi(2)%20%26%20%5Cldots%20%26%20%5Cpi(j)%20%26%20%5Ccdots%20%5C%5C%0A%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%5C%5C%0A%5Cpi(1)%20%26%20%5Cpi(2)%20%26%20%5Cldots%20%26%20%5Cpi(j)%20%26%20%5Ccdots%20%5C%5C%0A%5Ccdots%20%26%20%5Cldots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Cldots%0A%5Cend%7Barray%7D%5Cright)%0A" /></p></li>
<li>
<p>平稳分布 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cpi%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cpi%7D%20%5Cmathbf%7BP%7D%20%3D%20%5Cboldsymbol%7B%5Cpi%7D" style="display:inline-block;margin: 0;"/> 的唯一非负解。</p>
</li>
</ol>
<h2 id="基于马尔科夫链采样">基于马尔科夫链采样</h2>
<p>假如我们想得到某个马尔科夫链的平稳分布的随机数，如果我们得到了其转移概率矩阵，那么我们就可以轻松做到这一点。</p>
<p>我们可以从任意一个初始概率分布 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cpi%7D_%7B0%7D" style="display:inline-block;margin: 0;"/>  ，假设我们认为经过 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 轮后马尔科夫链收敛于平稳分布，那么之后采样得到的随机数就是我们需要服从平稳分布的随机数，其过程如下：</p>
<ol>
<li>输入转移概率矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D" style="display:inline-block;margin: 0;"/> ，设定状态转移次数阈值为 <img src="https://math.now.sh?inline=n_%7B1%7D" style="display:inline-block;margin: 0;"/> ，需要的样本数为 <img src="https://math.now.sh?inline=n_%7B2%7D" style="display:inline-block;margin: 0;"/></li>
<li>从任意简单概率分布采样得到初始状态值 <img src="https://math.now.sh?inline=x_%7B0%7D" style="display:inline-block;margin: 0;"/></li>
<li>从条件概率分布 <img src="https://math.now.sh?inline=P%28x%7Cx_%7Bt%7D%29" style="display:inline-block;margin: 0;"/> 采用得到 <img src="https://math.now.sh?inline=x_%7Bt%2B1%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=t%20%3D%200%2C1%2C%5Ccdots%2C%20n_%7B1%7D%2Bn_%7B2%7D-1" style="display:inline-block;margin: 0;"/> 。</li>
</ol>
<p>最终，样本集合 (<img src="https://math.now.sh?inline=x_%7Bn_%7B1%7D%2B1%7D%2Cx_%7Bn_%7B1%7D%2B2%7D%2C%5Ccdots%2Cx_%7Bn_%7B1%7D%2Bn_%7B2%7D%7D" style="display:inline-block;margin: 0;"/> ) 即为我们需要的满足平稳分布的随机数。</p>
<p>但是随意给定一个平稳分布 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cpi%7D" style="display:inline-block;margin: 0;"/> ，我们如何得到其相应的转移概率矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D" style="display:inline-block;margin: 0;"/> 呢？此时我们就需要将马尔科夫链和蒙特卡洛方法结合起来，即MCMC 方法。</p>
<h1>MCMC 算法</h1>
<p>在解决如果得到某个平稳分布相应的转移概率矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D" style="display:inline-block;margin: 0;"/> 这个问题之前，我们需要先看马尔科夫链的细致平稳条件</p>
<h2 id="马尔科夫链的细致平稳条件">马尔科夫链的细致平稳条件</h2>
<p>如果非周期马尔科夫链的转移概率矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D" style="display:inline-block;margin: 0;"/> 和概率分布 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cpi%7D%28x%29" style="display:inline-block;margin: 0;"/> 对于所有的 <img src="https://math.now.sh?inline=i%2Cj" style="display:inline-block;margin: 0;"/>  ，均满足</p>
<p style=""><img src="https://math.now.sh?from=%5Cpi%28i%29%20P(i%2C%20j)%3D%5Cpi(j)%20P(j%2C%20i)%0A" /></p><p>则  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cpi%7D%28x%29" style="display:inline-block;margin: 0;"/> 就是转移概率矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D" style="display:inline-block;margin: 0;"/> 的平稳分布。</p>
<p>证明如下，由细致平稳条件有</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bi%3D1%7D%5E%7B%5Cinfty%7D%20%5Cpi%28i%29%20P(i%2C%20j)%3D%5Csum_%7Bi%3D1%7D%5E%7B%5Cinfty%7D%20%5Cpi(j)%20P(j%2C%20i)%0A" /></p><p>其中我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bi%3D1%7D%5E%7B%5Cinfty%7D%20%5Cpi%28j%29%20P(j%2C%20i)%3D%5Cpi(j)%20%5Csum_%7Bi%3D1%7D%5E%7B%5Cinfty%7D%20P(j%2C%20i)%3D%5Cpi(j)%0A" /></p><p>因此我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bi%3D1%7D%5E%7B%5Cinfty%7D%20%5Cpi%28i%29%20P(i%2C%20j)%3D%20%5Cpi(j)%0A" /></p><p>即</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Cpi%7D%20%5Cmathbf%7BP%7D%20%3D%20%5Cboldsymbol%7B%5Cpi%7D%0A" /></p><p>因此，  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cpi%7D%28x%29" style="display:inline-block;margin: 0;"/> 就是转移概率矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D" style="display:inline-block;margin: 0;"/> 的平稳分布，证明完毕。</p>
<h2 id="MCMC-采样">MCMC 采样</h2>
<p>一般情况下，我们的目标平稳分布 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cpi%7D%28x%29" style="display:inline-block;margin: 0;"/> 和我们随机找的某一个马尔科夫链转移概率矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D" style="display:inline-block;margin: 0;"/> 不满足细致平稳条件，即</p>
<p style=""><img src="https://math.now.sh?from=%5Cpi%28i%29%20Q(i%2C%20j)%20%5Cneq%20%5Cpi(j)%20Q(j%2C%20i)%0A" /></p><p>我们可以对上式做一个改造，使得细致平稳条件成立，方法式引入 <img src="https://math.now.sh?inline=%5Calpha%28i%2C%20j%29" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Calpha%28j%2C%20i%29" style="display:inline-block;margin: 0;"/> ，使得</p>
<p style=""><img src="https://math.now.sh?from=%5Cpi%28i%29%20Q(i%2C%20j)%20%5Calpha(i%2C%20j)%3D%5Cpi(j)%20Q(j%2C%20i)%20%5Calpha(j%2C%20i)%0A" /></p><p>那么什么样的 <img src="https://math.now.sh?inline=%5Calpha%28i%2C%20j%29" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Calpha%28j%2C%20i%29" style="display:inline-block;margin: 0;"/> 可以使得上式成立呢？最简单的就是只要满足下面两个式子即可：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Calpha%28i%2C%20j%29%3D%5Cpi(j)%20Q(j%2C%20i)%20%5C%5C%0A%26%5Calpha(j%2C%20i)%3D%5Cpi(i)%20Q(i%2C%20j)%0A%5Cend%7Baligned%7D%0A" /></p><p>这样，我们就得到了我们的目标平稳分布 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cpi%7D%28x%29" style="display:inline-block;margin: 0;"/> 对应的转移概率矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D" style="display:inline-block;margin: 0;"/> ，其元素满足</p>
<p style=""><img src="https://math.now.sh?from=P%28i%2C%20j%29%3DQ(i%2C%20j)%20%5Calpha(i%2C%20j)%0A" /></p><p>也就是说，我们的目标矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BP%7D" style="display:inline-block;margin: 0;"/> 可以通过任意一个转移概率矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D" style="display:inline-block;margin: 0;"/> 构建得到，这里的 <img src="https://math.now.sh?inline=%5Calpha%28i%2C%20j%29" style="display:inline-block;margin: 0;"/> 我们一般称为<strong>接受率</strong>，这个思路很像上面的接受-拒绝采样。</p>
<p>MCMC 采样的步骤如下：</p>
<ol>
<li>输入任意的转移概率矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D" style="display:inline-block;margin: 0;"/> ，平稳分布  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cpi%7D%28x%29" style="display:inline-block;margin: 0;"/> ，设定状态转移次数阈值  <img src="https://math.now.sh?inline=n_%7B1%7D" style="display:inline-block;margin: 0;"/> ，需要的样本个数 <img src="https://math.now.sh?inline=n_%7B2%7D" style="display:inline-block;margin: 0;"/></li>
<li>从任意简单概率分布采样得到初始状态值 <img src="https://math.now.sh?inline=x_%7B0%7D" style="display:inline-block;margin: 0;"/></li>
<li><img src="https://math.now.sh?inline=%5Ctext%7Bfor%20%7Dt%20%3D%200%2C1%2C%5Ccdots%2C%20n_%7B1%7D%2Bn_%7B2%7D-1" style="display:inline-block;margin: 0;"/> 。
<ol>
<li>从条件概率分布 <img src="https://math.now.sh?inline=Q%28x%7Cx_%7Bt%7D%29" style="display:inline-block;margin: 0;"/> 采用得到 <img src="https://math.now.sh?inline=x_%7B*%7D" style="display:inline-block;margin: 0;"/></li>
<li>从[0,1]均匀分布采样 <img src="https://math.now.sh?inline=u" style="display:inline-block;margin: 0;"/></li>
<li>如果<img src="https://math.now.sh?inline=u%3C%5Calpha%5Cleft%28x_%7Bt%7D%2C%20x_%7B*%7D%5Cright%29%3D%5Cpi%5Cleft(x_%7B*%7D%5Cright)%20Q%5Cleft(x_%7B*%7D%2C%20x_%7Bt%7D%5Cright)" style="display:inline-block;margin: 0;"/> ，则接受转移，即 <img src="https://math.now.sh?inline=x_%7Bt%2B1%7D%3Dx_%7B*%7D" style="display:inline-block;margin: 0;"/>  ；否则不接受转移，即 <img src="https://math.now.sh?inline=x_%7Bt%2B1%7D%3Dx_%7Bt%7D" style="display:inline-block;margin: 0;"/></li>
</ol>
</li>
</ol>
<p>最终，样本集合 (<img src="https://math.now.sh?inline=x_%7Bn_%7B1%7D%2B1%7D%2Cx_%7Bn_%7B1%7D%2B2%7D%2C%5Ccdots%2Cx_%7Bn_%7B1%7D%2Bn_%7B2%7D%7D" style="display:inline-block;margin: 0;"/> ) 即为我们需要的满足平稳分布的随机数。</p>
<p>但是这个采样算法很难在实践中应用，因为这里的接受率  <img src="https://math.now.sh?inline=%5Calpha%28i%2C%20j%29" style="display:inline-block;margin: 0;"/> 可能非常的小，这样导致大部分的采样值都被拒绝转移，采样效率很低。</p>
<p>我们采用M-H 采样方法可以提高采样效率。</p>
<h2 id="M-H-采样">M-H 采样</h2>
<p>M-H采样是Metropolis-Hastings采样的简称，这个算法首先由Metropolis提出，被Hasting扩展，其解决了接受率过低的问题。</p>
<p>我们回到MCMC采样的细致平稳条件：</p>
<p style=""><img src="https://math.now.sh?from=%5Cpi%28i%29%20Q(i%2C%20j)%20%5Calpha(i%2C%20j)%3D%5Cpi(j)%20Q(j%2C%20i)%20%5Calpha(j%2C%20i)%0A" /></p><p>我们的问题是接受率  <img src="https://math.now.sh?inline=%5Calpha%28i%2C%20j%29" style="display:inline-block;margin: 0;"/> 太小了，比如  <img src="https://math.now.sh?inline=%5Calpha%28i%2C%20j%29%3D0.1" style="display:inline-block;margin: 0;"/> ，  <img src="https://math.now.sh?inline=%5Calpha%28j%2C%20i%29%3D0.2" style="display:inline-block;margin: 0;"/>  ，此时如果等式的两边同时扩大 5 倍，此时接受率提高到了 0.5，但是细致平稳条件依然是满足的。</p>
<p>因此，我们的接受率可以改为</p>
<p style=""><img src="https://math.now.sh?from=%5Calpha%28i%2C%20j%29%3D%5Cmin%20%5Cleft%5C%7B%5Cfrac%7B%5Cpi(j)%20Q(j%2C%20i)%7D%7B%5Cpi(i)%20Q(i%2C%20j)%7D%2C%201%5Cright%5C%7D%0A" /></p><p>其实这种做法可以换种方式解释，我们回到一开始我们说  <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D" style="display:inline-block;margin: 0;"/>  不满足细致平稳条件，即</p>
<p style=""><img src="https://math.now.sh?from=%5Cpi%28i%29%20Q(i%2C%20j)%20%5Cneq%20%5Cpi(j)%20Q(j%2C%20i)%0A" /></p><p>这可以分为两种情况</p>
<p style=""><img src="https://math.now.sh?from=%5Cpi%28i%29%20Q(i%2C%20j)%20%3E%20%5Cpi(j)%20Q(j%2C%20i)%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cpi%28i%29%20Q(i%2C%20j)%20%3C%20%5Cpi(j)%20Q(j%2C%20i)%0A" /></p><p>对于第一种情况，我们可以在左侧乘以概率 <img src="https://math.now.sh?inline=%5Calpha%28i%2C%20j%29%3D%20%5Cfrac%7B%5Cpi(j)%20Q(j%2C%20i)%7D%7B%5Cpi(i)%20Q(i%2C%20j)%7D%20%3C%201" style="display:inline-block;margin: 0;"/> ，使得细致平稳条件成立</p>
<p style=""><img src="https://math.now.sh?from=%5Cpi%28i%29%20Q(i%2C%20j)%5Calpha(i%2C%20j)%20%3D%20%20%5Cpi(j)%20Q(j%2C%20i)%0A" /></p><p>对于第二种情况，我们可以在右侧乘以概率 <img src="https://math.now.sh?inline=%5Calpha%28j%2C%20i%29%3D%20%5Cfrac%7B%5Cpi(i)%20Q(i%2C%20j)%7D%7B%5Cpi(j)%20Q(j%2C%20i)%7D%20%3C%201" style="display:inline-block;margin: 0;"/> ，使得细致平稳条件成立</p>
<p style=""><img src="https://math.now.sh?from=%5Cpi%28i%29%20Q(i%2C%20j)%20%3D%20%20%5Cpi(j)%20Q(j%2C%20i)%5Calpha(j%2C%20i)%0A" /></p><p>第一种情况的接受率为 <img src="https://math.now.sh?inline=%5Calpha%28i%2C%20j%29%3D%20%5Cfrac%7B%5Cpi(j)%20Q(j%2C%20i)%7D%7B%5Cpi(i)%20Q(i%2C%20j)%7D" style="display:inline-block;margin: 0;"/> ，第二种情况的接受率为 <img src="https://math.now.sh?inline=%5Calpha%28i%2C%20j%29%3D%201" style="display:inline-block;margin: 0;"/> ，因此我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Calpha%28i%2C%20j%29%3D%5Cmin%20%5Cleft%5C%7B%5Cfrac%7B%5Cpi(j)%20Q(j%2C%20i)%7D%7B%5Cpi(i)%20Q(i%2C%20j)%7D%2C%201%5Cright%5C%7D%0A" /></p><p>通过这个微小的改造，M-H采样算法过程如下</p>
<ol>
<li>输入任意的转移概率矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D" style="display:inline-block;margin: 0;"/> ，平稳分布  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cpi%7D%28x%29" style="display:inline-block;margin: 0;"/> ，设定状态转移次数阈值  <img src="https://math.now.sh?inline=n_%7B1%7D" style="display:inline-block;margin: 0;"/> ，需要的样本个数 <img src="https://math.now.sh?inline=n_%7B2%7D" style="display:inline-block;margin: 0;"/></li>
<li>从任意简单概率分布采样得到初始状态值 <img src="https://math.now.sh?inline=x_%7B0%7D" style="display:inline-block;margin: 0;"/></li>
<li><img src="https://math.now.sh?inline=%5Ctext%7Bfor%20%7Dt%20%3D%200%2C1%2C%5Ccdots%2C%20n_%7B1%7D%2Bn_%7B2%7D-1" style="display:inline-block;margin: 0;"/> 。
<ol>
<li>从条件概率分布 <img src="https://math.now.sh?inline=Q%28x%7Cx_%7Bt%7D%29" style="display:inline-block;margin: 0;"/> 采用得到 <img src="https://math.now.sh?inline=x_%7B*%7D" style="display:inline-block;margin: 0;"/></li>
<li>从[0,1]均匀分布采样 <img src="https://math.now.sh?inline=u" style="display:inline-block;margin: 0;"/></li>
<li>如果<img src="https://math.now.sh?inline=u%3C%5Calpha%5Cleft%28x_%7Bt%7D%2C%20x_%7B*%7D%5Cright%29%20%3D%20%5Cmin%20%5Cleft%5C%7B%5Cfrac%7B%5Cpi(j)%20Q(j%2C%20i)%7D%7B%5Cpi(i)%20Q(i%2C%20j)%7D%2C%201%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> ，则接受转移，即 <img src="https://math.now.sh?inline=x_%7Bt%2B1%7D%3Dx_%7B*%7D" style="display:inline-block;margin: 0;"/>  ；否则不接受转移，即 <img src="https://math.now.sh?inline=x_%7Bt%2B1%7D%3Dx_%7Bt%7D" style="display:inline-block;margin: 0;"/></li>
</ol>
</li>
</ol>
<p>最终，样本集合 (<img src="https://math.now.sh?inline=x_%7Bn_%7B1%7D%2B1%7D%2Cx_%7Bn_%7B1%7D%2B2%7D%2C%5Ccdots%2Cx_%7Bn_%7B1%7D%2Bn_%7B2%7D%7D" style="display:inline-block;margin: 0;"/> ) 即为我们需要的满足平稳分布的随机数。</p>
<p>很多时候，我们选择的转移概率矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D" style="display:inline-block;margin: 0;"/> 都是对称矩阵，即 <img src="https://math.now.sh?inline=Q%28i%2C%20j%29%3DQ(j%2C%20i)" style="display:inline-block;margin: 0;"/> ，此时我们的接受率可以进一步简化为</p>
<p style=""><img src="https://math.now.sh?from=%5Calpha%28i%2C%20j%29%3D%5Cmin%20%5Cleft%5C%7B%5Cfrac%7B%5Cpi(j)%7D%7B%5Cpi(i)%7D%2C%201%5Cright%5C%7D%0A" /></p><h3 id="小结-2">小结</h3>
<p>M-H算法有下面几个问题：</p>
<ol>
<li>对于高维度数据，由于每一次抽样均需要计算 <img src="https://math.now.sh?inline=%5Cfrac%7B%5Cpi%28j%29%20Q(j%2C%20i)%7D%7B%5Cpi(i)%20Q(i%2C%20j)%7D" style="display:inline-block;margin: 0;"/> ，计算效率低</li>
<li>由于 <img src="https://math.now.sh?inline=%5Calpha%28i%2C%20j%29%20%3C%201" style="display:inline-block;margin: 0;"/>，仍然有可能拒绝一部分抽样。</li>
<li>有时，对于高纬度数据，我们可能不知道其联合分布，但是可以方便计算各个特征之间的条件概率分布，此时无法使用 M-H 抽样。</li>
</ol>
<p>吉布斯抽样 (Gibbs) 解决了上面的几个问题，其接受概率为1，即不拒绝任何采样，而且其抽样过程中只计算条件分布。</p>
<h1>Gibbs 抽样</h1>
<h2 id="二维抽样">二维抽样</h2>
<p>我们回到细致平稳条件，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cpi%28i%29%20P(i%2C%20j)%3D%5Cpi(j)%20P(j%2C%20i)%0A" /></p><p>我们假设我们的数据是二维数据，平稳分布为 <img src="https://math.now.sh?inline=%5Cpi%5Cleft%28x_%7B1%7D%2C%20x_%7B2%7D%5Cright%29" style="display:inline-block;margin: 0;"/> ，观测第一个特征相同的两个点 <img src="https://math.now.sh?inline=A%5Cleft%28x_%7B1%7D%5E%7B(1%29%7D%2C%20x_%7B2%7D%5E%7B(1)%7D%5Cright)" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=B%5Cleft%28x_%7B1%7D%5E%7B(1%29%7D%2C%20x_%7B2%7D%5E%7B(2)%7D%5Cright)" style="display:inline-block;margin: 0;"/> ，根据概率论的知识，容易发现下面两个式子成立</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cpi%5Cleft%28x_%7B1%7D%5E%7B(1%29%7D%2C%20x_%7B2%7D%5E%7B(1)%7D%5Cright)%20%5Cpi%5Cleft(x_%7B2%7D%5E%7B(2)%7D%20%5Cmid%20x_%7B1%7D%5E%7B(1)%7D%5Cright)%3D%5Cpi%5Cleft(x_%7B1%7D%5E%7B(1)%7D%5Cright)%20%5Cpi%5Cleft(x_%7B2%7D%5E%7B(1)%7D%20%5Cmid%20x_%7B1%7D%5E%7B(1)%7D%5Cright)%20%5Cpi%5Cleft(x_%7B2%7D%5E%7B(2)%7D%20%5Cmid%20x_%7B1%7D%5E%7B(1)%7D%5Cright)%20%5C%5C%0A%26%5Cpi%5Cleft(x_%7B1%7D%5E%7B(1)%7D%2C%20x_%7B2%7D%5E%7B(2)%7D%5Cright)%20%5Cpi%5Cleft(x_%7B2%7D%5E%7B(1)%7D%20%5Cmid%20x_%7B1%7D%5E%7B(1)%7D%5Cright)%3D%5Cpi%5Cleft(x_%7B1%7D%5E%7B(1)%7D%5Cright)%20%5Cpi%5Cleft(x_%7B2%7D%5E%7B(2)%7D%20%5Cmid%20x_%7B1%7D%5E%7B(1)%7D%5Cright)%20%5Cpi%5Cleft(x_%7B2%7D%5E%7B(1)%7D%20%5Cmid%20x_%7B1%7D%5E%7B(1)%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>由于两个等式的右手项相等，因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cpi%5Cleft%28x_%7B1%7D%5E%7B(1%29%7D%2C%20x_%7B2%7D%5E%7B(1)%7D%5Cright)%20%5Cpi%5Cleft(x_%7B2%7D%5E%7B(2)%7D%20%5Cmid%20x_%7B1%7D%5E%7B(1)%7D%5Cright)%3D%5Cpi%5Cleft(x_%7B1%7D%5E%7B(1)%7D%2C%20x_%7B2%7D%5E%7B(2)%7D%5Cright)%20%5Cpi%5Cleft(x_%7B2%7D%5E%7B(1)%7D%20%5Cmid%20x_%7B1%7D%5E%7B(1)%7D%5Cright)%0A" /></p><p>也就是说</p>
<p style=""><img src="https://math.now.sh?from=%5Cpi%28A%29%20%5Cpi%5Cleft(x_%7B2%7D%5E%7B(2)%7D%20%5Cmid%20x_%7B1%7D%5E%7B(1)%7D%5Cright)%3D%5Cpi(B)%20%5Cpi%5Cleft(x_%7B2%7D%5E%7B(1)%7D%20%5Cmid%20x_%7B1%7D%5E%7B(1)%7D%5Cright)%0A" /></p><p>联合上面的细致平稳条件，我们发现在 $ x_{1}=x_{1}^{(1)}$ 这条直线上，我们只需要选择 <img src="https://math.now.sh?inline=P%28A%2CB%29%20%3D%20%5Cpi%5Cleft(x_%7B2%7D%5E%7B(B)%7D%20%5Cmid%20x_%7B1%7D%5E%7B(1)%7D%5Cright)" style="display:inline-block;margin: 0;"/> ，则任意两个点均满足细致平稳条件。</p>
<p>同样的道理，在在 $ x_{2}=x_{2}^{(1)}$ 这条直线上，我们只需要选择 <img src="https://math.now.sh?inline=P%28A%2CC%29%20%3D%20%5Cpi%5Cleft(x_%7B1%7D%5E%7B(C)%7D%20%5Cmid%20x_%7B2%7D%5E%7B(1)%7D%5Cright)" style="display:inline-block;margin: 0;"/> ，则任意两个点也满足细致平稳条件。</p>
<p>基于上面的发现，我们可以构建 <img src="https://math.now.sh?inline=%5Cpi%5Cleft%28x_%7B1%7D%2C%20x_%7B2%7D%5Cright%29" style="display:inline-block;margin: 0;"/>  的转移概率矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AP%28A%20%5Crightarrow%20B%29%3D%26%20%5Cpi%5Cleft(x_%7B2%7D%5E%7B(B)%7D%20%5Cmid%20x_%7B1%7D%5E%7B(1)%7D%5Cright)%20%5Ctext%20%7B%20if%20%7D%20x_%7B1%7D%5E%7B(A)%7D%3Dx_%7B1%7D%5E%7B(B)%7D%3Dx_%7B1%7D%5E%7B(1)%7D%20%5C%5C%0AP(A%20%5Crightarrow%20C)%3D%26%20%5Cpi%5Cleft(x_%7B1%7D%5E%7B(C)%7D%20%5Cmid%20x_%7B2%7D%5E%7B(1)%7D%5Cright)%20%5Ctext%20%7B%20if%20%7D%20x_%7B2%7D%5E%7B(A)%7D%3Dx_%7B2%7D%5E%7B(C)%7D%3Dx_%7B2%7D%5E%7B(1)%7D%20%5C%5C%0A%26%20P(A%20%5Crightarrow%20D)%3D0%20%5Ctext%20%7B%20else%20%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>我们可以轻松验证对于二维平面上的任意两点 <img src="https://math.now.sh?inline=E%2CF" style="display:inline-block;margin: 0;"/> ，细致平稳条件均成立，即：</p>
<p style=""><img src="https://math.now.sh?from=%5Cpi%28E%29%20P(E%20%5Crightarrow%20F)%3D%5Cpi(F)%20P(F%20%5Crightarrow%20E)%0A" /></p><p>于是这个二维空间的马尔科夫链将收敛到平稳分布  <img src="https://math.now.sh?inline=%5Cpi%5Cleft%28x_%7B1%7D%2C%20x_%7B2%7D%5Cright%29" style="display:inline-block;margin: 0;"/></p>
<p>二维 Gibbs 抽样具体过程如下：</p>
<ol>
<li>输入平稳分布 <img src="https://math.now.sh?inline=%5Cpi%5Cleft%28x_%7B1%7D%2C%20x_%7B2%7D%5Cright%29" style="display:inline-block;margin: 0;"/> ，设定状态转移次数阈值  <img src="https://math.now.sh?inline=n_%7B1%7D" style="display:inline-block;margin: 0;"/> ，需要的样本个数 <img src="https://math.now.sh?inline=n_%7B2%7D" style="display:inline-block;margin: 0;"/></li>
<li>从任意简单概率分布采样得到初始状态值 <img src="https://math.now.sh?inline=x_%7B1%7D%5E%7B%280%29%7D" style="display:inline-block;margin: 0;"/> 和   <img src="https://math.now.sh?inline=x_%7B2%7D%5E%7B%280%29%7D" style="display:inline-block;margin: 0;"/></li>
<li><img src="https://math.now.sh?inline=%5Ctext%7Bfor%20%7Dt%20%3D%200%2C1%2C%5Ccdots%2C%20n_%7B1%7D%2Bn_%7B2%7D-1" style="display:inline-block;margin: 0;"/> 。
<ol>
<li>从条件概率分布 <img src="https://math.now.sh?inline=P%28x_%7B1%7D%7Cx_%7B2%7D%5E%7B(t%29%7D)%3D%5Cpi(x_%7B1%7D%7Cx_%7B2%7D%5E%7B(t)%7D)" style="display:inline-block;margin: 0;"/> 采样得到 <img src="https://math.now.sh?inline=x%5E%7B%28t%2B1%29%7D_%7B1%7D" style="display:inline-block;margin: 0;"/></li>
<li>从条件概率分布 <img src="https://math.now.sh?inline=P%28x_%7B2%7D%7Cx_%7B1%7D%5E%7B(t%2B1%29%7D)%20%3D%20%5Cpi(x_%7B2%7D%7Cx_%7B1%7D%5E%7B(t%2B1)%7D)" style="display:inline-block;margin: 0;"/> 采样得到 <img src="https://math.now.sh?inline=x%5E%7B%28t%2B1%29%7D_%7B2%7D" style="display:inline-block;margin: 0;"/></li>
</ol>
</li>
</ol>
<p>最终，样本集合 <img src="https://math.now.sh?inline=%5Cleft%5C%7B%5Cleft%28x_%7B1%7D%5E%7B%5Cleft(n_%7B1%7D%2B1%5Cright%29%7D%2C%20x_%7B2%7D%5E%7B%5Cleft(n_%7B1%7D%2B1%5Cright)%7D%5Cright)%2C%5Cleft(x_%7B1%7D%5E%7B%5Cleft(n_%7B1%7D%2B2%5Cright)%7D%2C%20x_%7B2%7D%5E%7B%5Cleft(n_%7B1%7D%2B2%5Cright)%7D%5Cright)%2C%20%5Cldots%2C%5Cleft(x_%7B1%7D%5E%7B%5Cleft(n_%7B1%7D%2Bn_%7B2%7D%5Cright)%7D%2C%20x_%7B2%7D%5E%7B%5Cleft(n_%7B1%7D%2Bn_%7B2%7D%5Cright)%7D%5Cright)%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> 即为我们需要的满足平稳分布的随机数。</p>
<p>整个采样过程中，我们不停轮换坐标轴，即</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28x_%7B1%7D%5E%7B(1%29%7D%2C%20x_%7B2%7D%5E%7B(1)%7D%5Cright)%20%5Crightarrow%5Cleft(x_%7B1%7D%5E%7B(2)%7D%2C%20x_%7B2%7D%5E%7B(1)%7D%5Cright)%20%5Crightarrow%5Cleft(x_%7B1%7D%5E%7B(2)%7D%2C%20x_%7B2%7D%5E%7B(2)%7D%5Cright)%20%5Crightarrow%20%5Cldots%20%5Crightarrow%5Cleft(x_%7B1%7D%5E%7B%5Cleft(n_%7B1%7D%2Bn_%7B2%7D%5Cright)%7D%2C%20x_%7B2%7D%5E%7B%5Cleft(n_%7B1%7D%2Bn_%7B2%7D%5Cright)%7D%5Cright)%0A" /></p><h2 id="多维抽样">多维抽样</h2>
<p>我们从二维扩展到多维，假设我们有一个 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 维的平稳分布 <img src="https://math.now.sh?inline=%5Cpi%5Cleft%28x_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Cldots%20x_%7Bn%7D%5Cright%29" style="display:inline-block;margin: 0;"/> ，我们可以通过对 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个坐标轴轮换采样，来得到新的样本。具体的抽样过程如下：</p>
<ol>
<li>输入平稳分布 <img src="https://math.now.sh?inline=%5Cpi%5Cleft%28x_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Cldots%2C%20x_%7Bn%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 或者对应的所有特征的条件概率分布，设定状态转移次数阈值 <img src="https://math.now.sh?inline=n_%7B1%7D" style="display:inline-block;margin: 0;"/> ，需要的样本个数 <img src="https://math.now.sh?inline=n_%7B2%7D" style="display:inline-block;margin: 0;"/></li>
<li>随机初始化初始状态值 <img src="https://math.now.sh?inline=%5Cleft%28x_%7B1%7D%5E%7B(0%29%7D%2C%20x_%7B2%7D%5E%7B(0)%7D%2C%20%5Cldots%2C%20x_%7Bn%7D%5E%7B(0)%7D%5Cright)" style="display:inline-block;margin: 0;"/></li>
<li>for <img src="https://math.now.sh?inline=t%3D0" style="display:inline-block;margin: 0;"/> to <img src="https://math.now.sh?inline=n_%7B1%7D%2Bn_%7B2%7D-1" style="display:inline-block;margin: 0;"/> :
<ol>
<li>从条件概率分布 <img src="https://math.now.sh?inline=P%5Cleft%28x_%7B1%7D%20%5Cmid%20x_%7B2%7D%5E%7B(t%29%7D%2C%20x_%7B3%7D%5E%7B(t)%7D%2C%20%5Cldots%2C%20x_%7Bn%7D%5E%7B(t)%7D%5Cright)" style="display:inline-block;margin: 0;"/> 中采样得到样本 <img src="https://math.now.sh?inline=x_%7B1%7D%5E%7Bt%2B1%7D" style="display:inline-block;margin: 0;"/></li>
<li>从条件概率分布 <img src="https://math.now.sh?inline=P%5Cleft%28x_%7B2%7D%20%5Cmid%20x_%7B1%7D%5E%7B(t%2B1%29%7D%2C%20x_%7B3%7D%5E%7B(t)%7D%2C%20x_%7B4%7D%5E%7B(t)%7D%2C%20%5Cldots%2C%20x_%7Bn%7D%5E%7B(t)%7D%5Cright)" style="display:inline-block;margin: 0;"/> 中采样得到样本 <img src="https://math.now.sh?inline=x_%7B2%7D%5E%7Bt%2B1%7D" style="display:inline-block;margin: 0;"/></li>
<li>…</li>
<li>从条件概率分布 <img src="https://math.now.sh?inline=P%5Cleft%28x_%7Bj%7D%20%5Cmid%20x_%7B1%7D%5E%7B(t%2B1%29%7D%2C%20x_%7B2%7D%5E%7B(t%2B1)%7D%2C%20%5Cldots%2C%20x_%7Bj-1%7D%5E%7B(t%2B1)%7D%2C%20x_%7Bj%2B1%7D%5E%7B(t)%7D%20%5Cldots%2C%20x_%7Bn%7D%5E%7B(t)%7D%5Cright)" style="display:inline-block;margin: 0;"/> 中采样得到样本 <img src="https://math.now.sh?inline=x_%7Bj%7D%5E%7Bt%2B1%7D" style="display:inline-block;margin: 0;"/></li>
<li>…</li>
<li>从条件概率分布 <img src="https://math.now.sh?inline=P%5Cleft%28x_%7Bn%7D%20%5Cmid%20x_%7B1%7D%5E%7B(t%2B1%29%7D%2C%20x_%7B2%7D%5E%7B(t%2B1)%7D%2C%20%5Cldots%2C%20x_%7Bn-1%7D%5E%7B(t%2B1)%7D%5Cright)" style="display:inline-block;margin: 0;"/> 中采样得到样本 <img src="https://math.now.sh?inline=x_%7Bn%7D%5E%7Bt%2B1%7D" style="display:inline-block;margin: 0;"/></li>
</ol>
</li>
</ol>
<p>样本集 <img src="https://math.now.sh?inline=%5Cleft%5C%7B%5Cleft%28x_%7B1%7D%5E%7B%5Cleft(n_%7B1%7D%2B1%5Cright%29%7D%2C%20x_%7B2%7D%5E%7B%5Cleft(n_%7B1%7D%2B1%5Cright)%7D%2C%20%5Cldots%2C%20x_%7Bn%7D%5E%7B%5Cleft(n_%7B1%7D%2B1%5Cright)%7D%5Cright)%2C%20%5Cldots%2C%5Cleft(x_%7B1%7D%5E%7B%5Cleft(n_%7B1%7D%2Bn_%7B2%7D%5Cright)%7D%2C%20x_%7B2%7D%5E%7B%5Cleft(n_%7B1%7D%2Bn_%7B2%7D%5Cright)%7D%2C%20%5Cldots%2C%20x_%7Bn%7D%5E%7B%5Cleft(n_%7B1%7D%2Bn_%7B2%7D%5Cright)%7D%5Cright)%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> 即为我们需要的平稳分布对应的样本集。</p>
<h2 id="小结-3">小结</h2>
<p>由于 Gibbs 抽样对于高维度特征具有优势，因此一般所说的 MCMC 采样都是用的 Gibbs 抽样。但是 Gibbs 抽样要求至少有两个维度，因此一维的数据采样只能采用 M-H 采样。</p>
<h1>收敛性判断</h1>
<p>在MCMC 算法中，无论是 M-H 算法还是 Gibbs 算法，我们均认为随着马尔科夫链的延长，它就越接近其平稳分布，我们称其为收敛。而收敛前的所有迭代是要被舍弃的，这些被舍弃的抽样称为 burn-in 期。但是我们如何判断一条链是否收敛呢？也就是说，上面的 <img src="https://math.now.sh?inline=n_%7B1%7D" style="display:inline-block;margin: 0;"/> 应该设定为多少了？</p>
<p>这似乎没有一个统一的答案，目前常用的有两种方法。</p>
<h2 id="图式法">图式法</h2>
<p>我们将 MCMC 链上的轨迹点进行可视化，横坐标是迭代次数，纵坐标是抽样值。如果经过一段时间的剧烈波动之后逐渐趋于平稳，则意味着这条链可能收敛了。</p>
<p>更为合理的做法是，用不同的参数初值构建两个甚至多个独立的链，观察不同链的轨迹点，随着链的延长，不同链开始发生重叠，甚至几乎完全重合，此时可以认为收敛。</p>
<p>需要说明的是，图式法不能保证所观察的链一定收敛了，为稳妥起见， burn-in 期稍微设大一点较好。</p>
<h2 id="Geweke-检验">Geweke 检验</h2>
<p>首先假定一个burn-in 期，在其后的抽样值按一定间隔取2个样本，如前 10% 和 后 10% 的抽样值的平均数之间不存在显著差异，则可认为链收敛了。否则，需要延长burn-in 期，再重新进行检验。</p>
<h1>参考文献</h1>
<ol>
<li>
<p>张勤. 动物遗传育种中的计算方法[M]. 科学出版社, 2007.</p>
</li>
<li>
<p><a href="https://www.cnblogs.com/pinard/p/6625739.html">MCMC(一)蒙特卡罗方法</a></p>
</li>
<li>
<p>Brémaud P. Markov chains: Gibbs fields, Monte Carlo simulation, and queues[M]. Springer Science &amp; Business Media, 2013.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>方差组分估计的普遍观点与启发</title>
    <url>/posts/a6f7095/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近看 Misztal 2008年的一篇介绍方差组分估计的文章，其中一段话很有启发。</p>
<span id="more"></span>
<h1>方差组分的普遍观点</h1>
<p>原文如下。我大致翻译一下，方差组分估计的问题往往都可以归因为模型过于复杂，需要估计的参数太多。就像  Box and Draper (1987) 所说，<strong>实际上，所有的模型都是错误的，但是某些 (模型) 很有用</strong>。虽然复杂的模型可能能够更好地揭示性状的生物学性质，但是在遗传评估中简单的模型可能就足够了，因为 (很多文献报道) 复杂的模型和简单的模型可能预测能力差不多。</p>
<blockquote>
<p>Problems with variance component estimation often can be traced to unnecessarily high model complexity with too many parameters to estimate. As Box and Draper (1987) stated, ‘Essentially, all models are wrong, but some are useful’, thus the search for a perfect model is futile. While more complex models may be needed to reveal the biology of traits, simpler models may suffice for genetic evaluation. For example, Lopez-Romero &amp; Carabano (2003) compared random regression models using Legendre polynomials of orders 2–6. While more complex models fit the data better, the predictive ability of all the models was almost identical, indicating almost identical rankings of sires. Good arguments for following productivity in model comparisons were made by Blasco (2006). Reports from literature that simple and complicated models provide similar estimated breeding values are abound, e.g. Piles et al. (2006).</p>
</blockquote>
<h1>推荐</h1>
<p>Misztal 推荐的估计方差组分的步骤为：</p>
<ol>
<li>先通过 AI-REML 方法估计<strong>单性状模型</strong>的方差组分</li>
<li>尝试估计多性状的方差组分，首先采用不同的性状组合，其次如果性状总数较少（5-7），那么我们可以采用所有性状来估计方差组分。<strong>如果多性状模型和单性状模型的方差组分差别很大</strong>，那么说明存在问题。</li>
<li>如果方差组分估计值不切实际，那么检查数据是否有问题。举个例子，可以增加或剔除非加性效应，如果改变很小，那么就说明这个随机效应不重要。</li>
<li>如果采用 AI-REML 方法波动很大或者超出了参数空间，尝试 EM-REML 方法。</li>
<li>如果 AI 或 EM 方法的每一次迭代时间很长，或者分析时间太长（即一直在迭代），尝试 CT REML 方法（如果只有一个随机效应并且性状数目很多）或者 BaGS 方法。 当性状数目非常多时，你只能采用这两种方法。</li>
<li>如果数据量非常大，唯一可用的方法是<strong>优化后的</strong>  BaGS 方法</li>
<li>如果所有方法的估计结果均不稳定，或者估计值的 SE 非常大，那么建议简化模型。</li>
<li>如果 AI 方法估计的结果看上去有问题，尝试用 BaGS 方法再算一遍。对于大部分模型，这两种方法的估计结果是相似的。</li>
</ol>
<h1>启发</h1>
<ul>
<li>对于实际应用，不同模型的判定标准是合用，而不是正确。判断是否合用应该有多个层面上的考虑，比如计算稳定性，计算时间/计算效率，结果准确性，结果是否易于使用等等。</li>
<li>若无必要，勿增实体。做事情，做东西要从易到难，一步步增加复杂度，不要一开始就觉得越复杂的东西就越好。并且每一步最好需要和之前的简单方法进行比较，如果复杂的方式和简单的方式相比帮助不大，那么可能就不如回退到简单的方法。</li>
</ul>
<h1>参考文献</h1>
<ol>
<li>Misztal I. Reliable computing in estimation of variance components[J]. Journal of animal breeding and genetics, 2008, 125(6): 363-370.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
        <tag>方差组分</tag>
      </tags>
  </entry>
  <entry>
    <title>基因组选择模型介绍下</title>
    <url>/posts/e0b3b4ee/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本篇介绍第二类基因组选择方法，通过使用基因组数据构建新的关系矩阵加入到混合模型方程组中直接获得基因组估计育种值，如 GBLUP方法和 ssGBLUP 方法。</p>
<span id="more"></span> 
<h1>基因组关系矩阵</h1>
<p>先看三个定义</p>
<ul>
<li>共亲系数 <img src="https://math.now.sh?inline=%5Ctheta_%7B%5Cmathrm%7Bij%7D%7D" style="display:inline-block;margin: 0;"/> ，是两个个体的任一基因座，各随机抽取一个基因同源相同 (identical by descent, IBD，指两个基因相同并且来自于同一祖先)的概率。如果是一个个体，那么是可放回抽样。</li>
<li>近交系数 <img src="https://math.now.sh?inline=F_%7Bk%7D" style="display:inline-block;margin: 0;"/>，某个个体 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 同一基因座的两个基因同源相同的概率</li>
<li>分子亲缘相关，或者说加性遗传相关 <img src="https://math.now.sh?inline=A_%7B%5Cmathrm%7Bij%7D%7D%3D2%20%5Ctheta_%7B%5Cmathrm%7Bij%7D%7D" style="display:inline-block;margin: 0;"/> ，指两个个体的基因组中同源相同基因的比例，加性遗传相关的另一重含义是其为两个个体育种值的相关，即 <img src="https://math.now.sh?inline=%5Coperatorname%7BCov%7D%5Cleft%28u_%7Bi%7D%2C%20u_%7Bj%7D%5Cright%29%3D2%20%5Ctheta_%7B%5Cmathrm%7Bij%7D%7D%20%5Csigma_%7Bu%7D%5E%7B2%7D%3DA_%7B%5Cmathrm%7Bij%7D%7D%20%5Csigma_%7Bu%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 。</li>
</ul>
<p>注意下面说到的亲缘系数均指  <img src="https://math.now.sh?inline=A_%7B%5Cmathrm%7Bij%7D%7D" style="display:inline-block;margin: 0;"/> ，而不是 Wright 在 1922 年定义的那个亲缘系数（其中   <img src="https://math.now.sh?inline=A_%7B%5Cmathrm%7Bij%7D%7D" style="display:inline-block;margin: 0;"/> 是其分子 ）。</p>
<h2 id="IBS-和-IBD">IBS 和 IBD</h2>
<p>两个个体的 IBS (identity by states, 指两个基因相同) 概率，或者<strong>分子共亲系数</strong> (“molecular” coancestries) <img src="https://math.now.sh?inline=f_%7B%5Cmathrm%7BMij%7D%7D" style="display:inline-block;margin: 0;"/> 表示为两个个体各自随机抽取一个基因相同的概率。分子亲缘关系 (<em>molecular relationships</em>) 定义为 <img src="https://math.now.sh?inline=r_%7B%5Cmathrm%7BMij%7D%7D%3D2%20f_%7B%5Cmathrm%7BMij%7D%7D" style="display:inline-block;margin: 0;"/> ，这里和 <img src="https://math.now.sh?inline=A_%7B%5Cmathrm%7Bij%7D%7D" style="display:inline-block;margin: 0;"/> 类似 ，为两个个体的基因组中相同的比例。</p>
<p><img src="https://math.now.sh?inline=r_%7B%5Cmathrm%7BMij%7D%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=A_%7B%5Cmathrm%7Bij%7D%7D" style="display:inline-block;margin: 0;"/> 具有下面的关系。我们考虑从个体 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 和 个体 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 中各随机抽取一个基因，它们由于 IBD 相同的额概率为 <img src="https://math.now.sh?inline=A_%7B%5Cmathrm%7Bij%7D%7D%20%2F%202" style="display:inline-block;margin: 0;"/> ，它们不是 IBD 相同的概率为 <img src="https://math.now.sh?inline=1-A_%7B%5Cmathrm%7Bij%7D%7D%20%2F%202" style="display:inline-block;margin: 0;"/> 但是由于偶然相同的概率为 <img src="https://math.now.sh?inline=p%5E%7B2%7D%20%2B%20q%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 。因此，<img src="https://math.now.sh?inline=f_%7B%5Cmathrm%7BMij%7D%7D%3D%5Ctheta_%7B%5Cmathrm%7Bij%7D%7D%2B%5Cleft%281-%5Ctheta_%7B%5Cmathrm%7Bij%7D%7D%5Cright%29%5Cleft(p%5E%7B2%7D%2Bq%5E%7B2%7D%5Cright)" style="display:inline-block;margin: 0;"/> ，重排一下，我们得到：</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%281-f_%7B%5Cmathrm%7BMij%7D%7D%5Cright%29%3D%5Cleft(1-%5Ctheta_%7B%5Cmathrm%7Bij%7D%7D%5Cright)%5Cleft(1-p%5E%7B2%7D-q%5E%7B2%7D%5Cright)%20%3D%20%5Cleft(1-%5Ctheta_%7B%5Cmathrm%7Bij%7D%7D%5Cright)%5Cleft(2pq%5Cright)%0A" /></p><p>易得 <img src="https://math.now.sh?inline=f_%7B%5Cmathrm%7BMij%7D%7D%20%3E%20%5Ctheta_%7B%5Cmathrm%7Bij%7D%7D" style="display:inline-block;margin: 0;"/> ，或  <img src="https://math.now.sh?inline=r_%7B%5Cmathrm%7BMij%7D%7D%20%3E%20A_%7B%5Cmathrm%7Bij%7D%7D" style="display:inline-block;margin: 0;"/> ，因此相比于 IBD ，IBS 是向上有偏的。</p>
<p>左右乘2，我们得到 <img src="https://math.now.sh?inline=r_%7B%5Cmathrm%7BMij%7D%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=A_%7B%5Cmathrm%7Bij%7D%7D" style="display:inline-block;margin: 0;"/> 的关系：</p>
<p style=""><img src="https://math.now.sh?from=r_%7B%5Cmathrm%7BMij%7D%7D%3DA_%7B%5Cmathrm%7Bij%7D%7D%2B%5Cleft%282-A_%7B%5Cmathrm%7Bij%7D%7D%5Cright%29%5Cleft(p%5E%7B2%7D%2Bq%5E%7B2%7D%5Cright)%0A" /></p><p>或者</p>
<p style=""><img src="https://math.now.sh?from=A_%7B%5Cmathrm%7Bij%7D%7D%3D%5Cfrac%7Br_%7B%5Cmathrm%7BMij%7D%7D-2%20p%5E%7B2%7D-2%20q%5E%7B2%7D%7D%7B2%20p%20q%7D%0A" /></p><p>根据这个公式，我们可以从 IBS 关系中得到 IBD 关系，这个等价于 VanRaden 的 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵 (?)。</p>
<h2 id="单个-QTL-的个体间亲缘关系">单个 QTL 的个体间亲缘关系</h2>
<p>假设我们研究的物种只有一个二等位基因的基因，你获得了想要的个体的基因型之后，那么此时个体 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/>  和 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 的协方差是什么呢？让我们把育种值表达为加性值 (<img src="https://math.now.sh?inline=za" style="display:inline-block;margin: 0;"/>) 减去群体均值 (<img src="https://math.now.sh?inline=%5Cmu%20%3D%202pa" style="display:inline-block;margin: 0;"/> ) 后的差值：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0Au_%7Bi%7D%3Dz_%7Bi%7D%20a-2%20p%20a%3D%5Cleft%28z_%7Bi%7D-2%20p%5Cright%29%20a%20%5C%5C%0Au_%7Bj%7D%3Dz_%7Bj%7D%20a-2%20p%20a%3D%5Cleft(z_%7Bj%7D-2%20p%5Cright)%20a%0A%5Cend%7Bgathered%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=z_%7Bi%7D" style="display:inline-block;margin: 0;"/> 为 012 编码，即参考碱基的数目。如果这个 QTL 具有先验分布，其先验方差为 <img src="https://math.now.sh?inline=%5Coperatorname%7BVar%7D%28a%29%3D%5Csigma_%7Ba%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，假设哈温平衡下的加性方差为 <img src="https://math.now.sh?inline=2%20p%20q%20%5Csigma_%7Ba%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 。根据方差和协方差的计算公式，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BCov%7D%5Cleft%28u_%7Bi%7D%2C%20u_%7Bj%7D%5Cright%29%3D%5Cleft(z_%7Bi%7D-2%20p%5Cright)%5Cleft(z_%7Bj%7D-2%20p%5Cright)%20%5Csigma_%7Ba%7D%5E%7B2%7D%0A" /></p><p>如果我们定义 <img src="https://math.now.sh?inline=z_%7Bi%7D%5E%7B*%7D%3Dz_%7Bi%7D-2%20p" style="display:inline-block;margin: 0;"/> ，换句话说我们采用中心化的编码方式，那么此时两个个体之间的协方差等于 <img src="https://math.now.sh?inline=z_%7Bi%7D%5E%7B*%7D%20z_%7Bj%7D%5E%7B*%7D%20%5Csigma_%7Ba%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>对个体间的协方差 <img src="https://math.now.sh?inline=z_%7Bi%7D%5E%7B*%7D%20z_%7Bj%7D%5E%7B*%7D%20%5Csigma_%7Ba%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 除以加性方差 <img src="https://math.now.sh?inline=2%20%5Cmathrm%7Bpq%7D%20%5Csigma_%7Ba%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，我们得到了根据这个 QTL 得到的加性亲缘关系，这里称为 <img src="https://math.now.sh?inline=r_%7BQ_%7Bi%20j%7D%7D" style="display:inline-block;margin: 0;"/> 。<img src="https://math.now.sh?inline=p%3D0.5" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=p%3D0.25" style="display:inline-block;margin: 0;"/> 的两个例子如下表所示 (这两个表感觉有问题，我计算的都对不上，第一个表 AA 和 AA 我计算应该是 2 ) ：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Barray%7D%7Bllll%7D%0A%5Chline%20%26%20%5Cmathrm%7BAA%7D%20%26%20%5Cmathrm%7BAa%7D%20%26%20%5Cmathrm%7Baa%7D%20%5C%5C%0A%5Chline%20%5Cmathrm%7BAA%7D%20%26%201%20%26%200%20%26%20-1%20%5C%5C%0A%5Cmathrm%7BAa%7D%20%26%200%20%26%200%20%26%200%20%5C%5C%0A%5Cmathrm%7Baa%7D%20%26%20-1%20%26%200%20%26%201%20%5C%5C%0A%5Chline%0A%5Cend%7Barray%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Barray%7D%7Bllll%7D%0A%5Chline%20%26%20%5Cmathrm%7BAA%7D%20%26%20%5Cmathrm%7BAa%7D%20%26%20%5Cmathrm%7Baa%7D%20%5C%5C%0A%5Chline%20%5Cmathrm%7BAA%7D%20%26%202.25%20%26%200.75%20%26%20-0.75%20%5C%5C%0A%5Cmathrm%7BAa%7D%20%26%200.75%20%26%200.25%20%26%20-.025%20%5C%5C%0A%5Cmathrm%7Baa%7D%20%26%20-0.75%20%26%20-0.25%20%26%200.25%20%5C%5C%0A%5Chline%0A%5Cend%7Barray%7D%0A" /></p><p>我们看到这里有负的亲缘关系，原因是由于我们对育种值的计算过程中强行<strong>使得其为和群体均值的差值</strong>，因此这是正常的。</p>
<p>这里的近交系数就是  <img src="https://math.now.sh?inline=r_%7BQ_%7Bi%20j%7D%7D%20-%201" style="display:inline-block;margin: 0;"/> ，这里可能出现负值，说明这个个体的杂合子比例低于预期。</p>
<h2 id="基因组关系矩阵">基因组关系矩阵</h2>
<p>我们可以计算 IBS，再将其调整为 IBD 。我们先看 VanRaden 的第一种基因组关系矩阵，这里我们就是从上面的单个 QTL 推导为多个标记。为了使得育种值的均值为 0 ，我们对中心化的基因型编码，如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Barray%7D%7Bllll%7D%0A%5Chline%20%5Ctext%20%7B%20Genotype%20%7D%20%26%20101%20%5Ctext%20%7B%20Coding%20%7D%20%26%20012%20%5Ctext%20%7B%20Coding%20%7D%20%26%20%5Ctext%20%7B%20Centered%20coding%20%7D%20%5C%5C%0A%5Ctext%20%7B%20aa%20%7D%20%26%20-a_%7Bi%7D%20%26%200%20%26%20-2%20p_%7Bi%7D%20a_%7Bi%7D%20%5C%5C%0A%5Ctext%20%7B%20Aa%20%7D%20%26%200%20%26%20a_%7Bi%7D%20%26%20%5Cleft%281-2%20p_%7Bi%7D%5Cright%29%20a_%7Bi%7D%20%5C%5C%0A%5Ctext%20%7B%20AA%20%7D%20%26%20a_%7Bi%7D%20%26%202%20a_%7Bi%7D%20%26%20%5Cleft(2-2%20p_%7Bi%7D%5Cright)%20a_%7Bi%7D%20%5C%5C%0A%5Chline%0A%5Cend%7Barray%7D%0A" /></p><p>在理论上，为了参考系谱基础群体的育种值，这里我们应该也用基础群体的等位基因频率。但是这一点基本无法实现，因此我们通常还是用已有基因型数据的基因频率。育种值计算公式为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bu%7D%3D%5Cmathbf%7BZ%20a%7D%0A" /></p><p>即，个体育种值就是所有标记效应的和。我们假设标记效应的先验分布的协方差矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BVar%7D%28%5Cmathbf%7Ba%7D%29%3D%5Cmathbf%7BD%7D%0A" /></p><p>其中</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BD%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Csigma_%7Ba%201%7D%5E%7B2%7D%20%26%200%20%26%20%5Cldots%20%26%200%20%5C%5C%0A0%20%26%20%5Csigma_%7Ba%202%7D%5E%7B2%7D%20%26%20%5Ccdots%20%26%200%20%5C%5C%0A%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Cldots%20%5C%5C%0A0%20%26%200%20%26%20%5Cldots%20%26%20%5Csigma_%7Ba%20n%7D%5E%7B2%7D%0A%5Cend%7Barray%7D%5Cright%29%0A" /></p><p>通常我们假设不同标记的方差相同，即 <img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D%3D%5Cmathbf%7BI%7D%20%5Csigma_%7Ba%200%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 。那么，个体育种值的协方差矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BVar%7D%28%5Cmathbf%7Bu%7D%29%3D%5Cmathbf%7BZ%7D%20%5Coperatorname%7BVar%7D(%5Cmathbf%7Ba%7D)%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%3D%5Cmathbf%7BZ%20D%20Z%7D%3D%5Cmathbf%7BZ%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Csigma_%7Ba%200%7D%5E%7B2%7D%0A" /></p><p>但是这里还不是亲缘关系矩阵，<strong>亲缘关系矩阵是标准化的协方差矩阵</strong>，因此这里我们还要除以加性方差，即育种值的方差。如果我们假设<strong>哈温平衡</strong>和<strong>连锁平衡</strong>，我们已知存在下式</p>
<p style=""><img src="https://math.now.sh?from=%5Csigma_%7Bu%7D%5E%7B2%7D%3D2%20%5Csum_%7Bi%3D1%7D%5E%7B%5Cmathrm%7Bnsnp%7D%7D%20p_%7Bi%7D%20q_%7Bi%7D%20%5Csigma_%7Ba%200%7D%5E%7B2%7D%0A" /></p><p>因此，我们得到亲缘关系矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BG%7D%3D%5Cfrac%7B%5Cmathbf%7BZ%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Csigma_%7Ba%200%7D%5E%7B2%7D%7D%7B%5Csigma_%7Bu%7D%5E%7B2%7D%7D%20%3D%5Cfrac%7B%5Cmathbf%7BZ%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%7D%7B2%20%5Csum%20p_%7Bi%7D%20q_%7Bi%7D%7D%0A" /></p><p><img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵的对角线元素衡量一个个体的纯合子位点数目（纯合子位点数目越多，对角线元素越大），其非对角线元素衡量两个共同的碱基的数目。注意，<img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵可以理解是对 IBS 矩阵做了修改，从而变成了对于 IBD 关系的一个近似，这种近似比从系谱得到的近似更好，因此这就是为什么基因组预测由于系谱预测。</p>
<h3 id="GEBV-和-SNP-效应">GEBV 和 SNP 效应</h3>
<p>估计SNP效应时，我们有模型如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7By%7D%3D%5Cmu%2B%5Cmathrm%7BZa%7D%2B%5Cmathrm%7Be%7D%20%3B%20%5Cquad%20%5Coperatorname%7Bvar%7D%28%5Cmathrm%7Ba%7D%29%3D%5Cmathrm%7BD%7D%20%5Csigma_%7Ba%7D%5E%7B2%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D" style="display:inline-block;margin: 0;"/> 是一个对角矩阵，表示每个 SNP 的相对方差，这个模型等价于</p>
<p style=""><img src="https://math.now.sh?from=y%3D%5Cmu%2Bu%2Be%20%3B%20%5Coperatorname%7Bvar%7D%28u%29%3DZ%20D%20Z%5E%7B%5Cprime%7D%20%5Csigma_%7Ba%7D%5E%7B2%7D%3DG%20%5Csigma_%7Bu%7D%5E%7B2%7D%0A" /></p><p>因此，我们有</p>
<p style=""><img src="https://math.now.sh?from=G%3D%20%5Cfrac%7BZ%20D%20Z%5E%7B%5Cprime%7D%20%5Csigma_%7Ba%7D%5E%7B2%7D%7D%7B%20%5Csigma_%7Bu%7D%5E%7B2%7D%20%7D%0A" /></p><p>估计SNP效应得到的 GEBV 为</p>
<p style=""><img src="https://math.now.sh?from=u%3DZ%20a%0A" /></p><p>我们也可以从 GBLUP 的 GEBV 值中得到 SNP 效应（Stranden and Garrick, 2009）</p>
<p style=""><img src="https://math.now.sh?from=a%3D%5Cfrac%7B%5Csigma_%7Ba%7D%5E%7B2%7D%20%7D%7B%20%5Csigma_%7Bu%7D%5E%7B2%7D%20%7D%20D%20Z%5E%7B%5Cprime%7D%20G%5E%7B-1%7D%20u%0A" /></p><p>我们检查一下</p>
<p style=""><img src="https://math.now.sh?from=u%3DZ%20a%3D%20%5Cfrac%7B%5Csigma_%7Ba%7D%5E%7B2%7D%20%7D%7B%20%5Csigma_%7Bu%7D%5E%7B2%7D%20%7D%20Z%20D%20Z%5E%7B%5Cprime%7D%20G%5E%7B-1%7D%20u%3Du%0A" /></p><h3 id="G阵中使用的基因频率">G阵中使用的基因频率</h3>
<p>在构建 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵的过程中，使用的基因频率有些困惑的地方。(Strandén and Christensen 2011) 证明了， <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D%3D%5Cmathbf%7BZ%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%2F%202%20%5Csum%20p_%7Bi%7D%20q_%7Bi%7D" style="display:inline-block;margin: 0;"/> 中，构建 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 矩阵中使用不同的基因频率是无关的，只会使得所有元素偏移了一个常数，即 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵均值偏移了一个常数。为了和系谱构建的 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵的元素范围 (<em>scale</em>) 相同，我们应该使用基础群体的基因频率。</p>
<p>但是，分母中使用的基因频率更加重要。因为方程 <img src="https://math.now.sh?inline=%5Csigma_%7Bu%7D%5E%7B2%7D%3D2%20%5Csum_%7Bi%3D1%7D%5E%7B%5Cmathrm%7Bnsnp%7D%7D%20p_%7Bi%7D%20q_%7Bi%7D%20%5Csigma_%7Ba%200%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 中使用的加性方差和基因频率应该是同一个群体的，因此采用当前群体的基因频率表示我们参考的是当前群体的加性方差。如果系谱的基础群体和当前的基因型数据群体相差了很多世代，那么加性方差会降低。</p>
<h3 id="G阵的性质">G阵的性质</h3>
<ul>
<li>
<p>GBLUP 的估计育种值 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> 的均值为 0 ，这是因为 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 是中心化的矩阵 (缺证明？)。</p>
</li>
<li>
<p><img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵的均值为 0 。证明如下，首先我们有 <img src="https://math.now.sh?inline=%5Coperatorname%7Bsum%7D%5Cleft%28%5Cmathbf%7BZ%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%5Cright%29%3D%5Coperatorname%7Bsum%7D%5Cleft(%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D%5Cright)" style="display:inline-block;margin: 0;"/>  (缺证明)。<strong>假设连锁平衡</strong>，那么 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 的和为0 （因为连锁平衡，两个位点的基因型乘积之和为0，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 的非对角线元素全为 0，但是对角线元素不是 0 啊，感觉有问题）。</p>
</li>
<li>
<p>如果没有近交，那么 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵的对角线元素均值为 1 。  <strong>假设哈温平衡</strong>，存在 <img src="https://math.now.sh?inline=%5Cleft.%5Coperatorname%7Btr%7D%28%5Cmathbf%7BZ%20Z%7D%29%5E%7B%5Cprime%7D%5Cright)%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D%5Cright)" style="display:inline-block;margin: 0;"/> (缺证明)。 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 的对角线元素是某个位点对于碱基 “a” 和 “A” 的效应的协方差的平方，假设有 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> 个个体，位点 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 的两个碱基的基因频率分布为 <img src="https://math.now.sh?inline=1-p_%7Bi%7D" style="display:inline-block;margin: 0;"/>  和 <img src="https://math.now.sh?inline=p_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，即 (没看懂)</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bz%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bz%7D_%7Bi%7D%3D2%20m%5Cleft%5B%5Cleft%281-p_%7Bi%7D%5Cright%29%20p_%7Bi%7D%5E%7B2%7D%2Bp_%7Bi%7D%5Cleft(1-p_%7Bi%7D%5Cright)%5E%7B2%7D%5Cright%5D%3D2%20m%20p_%7Bi%7D%5Cleft(1-p_%7Bi%7D%5Cright)%3D2%20m%20p_%7Bi%7D%20q_%7Bi%7D%0A" /></p><p>因此， <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵的对角线元素均值为</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B1%7D%7Bm%7D%20%5Coperatorname%7Btr%7D%5Cleft%28%5Cfrac%7B%5Cmathbf%7BZ%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%7D%7B2%20%5Csum%20p_%7Bi%7D%20q_%7Bi%7D%7D%5Cright%29%3D%5Cfrac%7B2%20m%20%5Csum%20p_%7Bi%7D%20q_%7Bi%7D%7D%7B2%20m%20%5Csum%20p_%7Bi%7D%20q_%7Bi%7D%7D%3D1%0A" /></p><p>如果存在近交，那么就不满足哈温平衡，此时假设近交系数为 <img src="https://math.now.sh?inline=F" style="display:inline-block;margin: 0;"/> ，那么基因型的分布为 <img src="https://math.now.sh?inline=%5Cleft%5C%7Bq%5E%7B2%7D%2Bp%20q%20F%2C%202%20p%20q%281-F%29%2C%20p%5E%7B2%7D%2Bp%20q%20F%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> (Falconer and Mackay, 1996) 。那么此时我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bz%7D_%7Bi%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bz%7D_%7Bi%7D%3D2%20m%5Cleft%5B%5Cleft%281-2%20p_%7Bi%7D%5Cright%29%5Cleft(q_%7Bi%7D%5E%7B2%7D%2Bp_%7Bi%7D%20q_%7Bi%7D%20F%5Cright)%2B%5Cleft(1-2%20p_%7Bi%7D%5Cright)%5Cleft(2%20p_%7Bi%7D%20q_%7Bi%7D%20F%5Cright)%2B%5Cleft(2-2%20p_%7Bi%7D%5Cright)%5Cleft(p_%7Bi%7D%5E%7B2%7D%2Bp_%7Bi%7D%20q_%7Bi%7D%20F%5Cright)%5Cright%5D%3D2%20m%20p_%7Bi%7D%5Cleft(1-p_%7Bi%7D%5Cright)%3D2%20m(1%2BF)%20p_%7Bi%7D%20q_%7Bi%7D%0A" /></p><p>此时， <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵的对角线元素均值为</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B1%7D%7Bm%7D%20%5Coperatorname%7Btr%7D%5Cleft%28%5Cfrac%7B%5Cmathbf%7BZ%20Z%7D%5E%7B%5Cprime%7D%7D%7B2%20%5Csum%20p_%7Bi%7D%20q_%7Bi%7D%7D%5Cright%29%3D%5Cfrac%7B(1%2BF)%202%20m%20%5Csum%20p_%7Bi%7D%20q_%7Bi%7D%7D%7B2%20m%20%5Csum%20p_%7Bi%7D%20q_%7Bi%7D%7D%3D1%2BF%0A" /></p><p>注意，这里 <img src="https://math.now.sh?inline=F" style="display:inline-block;margin: 0;"/> 是群体内的近交系数，可以是负数，表示过多的纯合子。</p>
</li>
<li>
<p><img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵的非对角线元素均值几乎是 0 。也就是说，如果满足哈温平衡和连锁平衡，如果样本数为 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> ，那么（不懂）</p>
</li>
</ul>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Bavoff%7D%28%5Cmathbf%7BG%7D%29%3D%5Cfrac%7B1%7D%7Bm(m-1)%7D(%5Coperatorname%7Bsum%7D(%5Cmathbf%7BG%7D)-%5Coperatorname%7Bdiag%7D(%5Cmathbf%7BG%7D))%3D%5Cfrac%7Bm%7D%7Bm(m-1)%7D%3D%5Cfrac%7B1%7D%7Bm-1%7D%0A" /></p><h3 id="添加权重的G阵">添加权重的G阵</h3>
<p>在贝叶斯回归方法中，我们认为不同的标记可能有不同的方差。我们可以利用下式实现</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BVar%7D%28%5Cmathbf%7Bu%7D%29%3D%5Cmathbf%7BZ%7D%20%5Coperatorname%7BVar%7D(%5Cmathbf%7Ba%7D)%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%3D%5Cmathbf%7BZ%7D%20%5Cmathbf%7BD%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%0A" /></p><p>实际上，我们有另外一种简单的应用（在 BLUPF90 或 AsReml 中），我们可以通过分解加性方差，然后使用一个权重的矩阵，如 <img src="https://math.now.sh?inline=%5Coperatorname%7BVar%7D%28%5Cmathbf%7Bu%7D%29%20%3D%5Cmathbf%7BZ%7D%20%5Cmathbf%7BD%7D_%7Bw%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Csigma%5E%7B2%7D_%7Bu%7D" style="display:inline-block;margin: 0;"/> （笔误，这里的 <img src="https://math.now.sh?inline=%5Csigma%5E%7B2%7D_%7Bu%7D" style="display:inline-block;margin: 0;"/> 应该是 <img src="https://math.now.sh?inline=%5Csigma%5E%7B2%7D_%7Ba0%7D" style="display:inline-block;margin: 0;"/> ） ，其中</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BD%7D_%7Bw%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Csigma_%7Ba%201%7D%5E%7B2%7D%20%2F%20%5Csigma_%7Ba%200%7D%5E%7B2%7D%20%26%200%20%26%20%5Ccdots%20%26%200%20%5C%5C%0A0%20%26%20%5Csigma_%7Ba%202%7D%5E%7B2%7D%20%2F%20%5Csigma_%7Ba%200%7D%5E%7B2%7D%20%26%20%5Ccdots%20%26%200%20%5C%5C%0A%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%5C%5C%0A0%20%26%200%20%26%20%5Ccdots%20%26%20%5Csigma_%7Ba%20n%7D%5E%7B2%7D%20%2F%20%5Csigma_%7Ba%200%7D%5E%7B2%7D%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cbegin%7Barray%7D%7Bcccc%7D%0Aw_%7B1%7D%20%26%200%20%26%20%5Ccdots%20%26%200%20%5C%5C%0A0%20%26%20w_%7B2%7D%20%26%20%5Ccdots%20%26%200%20%5C%5C%0A%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%5C%5C%0A0%20%26%200%20%26%20%5Ccdots%20%26%20w_%7Bn%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>注意如果 <img src="https://math.now.sh?inline=w_%7B1%7D%3Dw_%7B2%7D%3D%5Cldots%3Dw_%7Bn%7D%3D1" style="display:inline-block;margin: 0;"/> ，此时就是常规的基因组矩阵。</p>
<p>标记的权重可以通过几种方式来得到，比如从贝叶斯回归中得到。</p>
<h3 id="G阵是实际的亲缘关系的估计值">G阵是实际的亲缘关系的估计值</h3>
<p>使用系谱构建亲缘关系矩阵时，我们假设有无穷多个不相关的基因。在每一个位点，两个全同胞可以共享2个，1个或0个碱基。但是考虑所有的位点，那么两个全同胞就正好是共享一半的基因组。但是真实情况并非如此，由于染色体数目有限，并且同一条染色体上的位点会连锁地传递给下一代，因此两个半同胞之间地差异可能比较大，如下图</p>
<p><img src="1.png" alt="1"></p>
<p>举个例子，这里 son 1 和 son3 比 son2 和 son4 更像。因此，在对 son 3 的预测中，son1 应该比 son2 和 son4 给更多的权重。基于上面这个图，这4个半同胞的亲缘关系可能如下</p>
<p style=""><img src="https://math.now.sh?from=R%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D%0A1%20%26%200%20%26%200.5%20%26%200.1%20%5C%5C%0A0%20%26%201%20%26%200%20%26%200.4%20%5C%5C%0A0.5%20%26%200%20%26%201%20%26%200.1%20%5C%5C%0A0.1%20%26%200.4%20%26%200.1%20%26%201%0A%5Cend%7Barray%7D%5Cright%29%0A" /></p><p>我们称这里的亲缘关系是实际的亲缘关系 (<em>realized relationships</em>) ，与系谱中的期望的亲缘关系相对应 (<em>expected relationships</em>) ，这里我们用 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> 矩阵表示，我们有</p>
<p style=""><img src="https://math.now.sh?from=E%5Cleft%28R_%7B%5Cmathrm%7Bij%7D%7D%5Cright%29%3DA_%7B%5Cmathrm%7Bij%7D%7D%0A" /></p><p>以两个半同胞为例，其实际的亲缘关系范围是 [0, 0.5] ，其期望值为 0.25 。</p>
<p><img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵就是实际的亲缘关系的估计值（证明略），我们有</p>
<p style=""><img src="https://math.now.sh?from=E%28%5Cmathbf%7BG%7D%29%3D%5Cmathbf%7BR%7D%0A" /></p><p>由于 <img src="https://math.now.sh?inline=E%28%5Cmathbf%7BR%7D%29%3D%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=E%28%5Cmathbf%7BG%7D%29%3D%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 。因此当 <img src="https://math.now.sh?inline=A_%7Bij%7D%20%3D%200" style="display:inline-block;margin: 0;"/> ，说明 <img src="https://math.now.sh?inline=G_%7Bij%7D" style="display:inline-block;margin: 0;"/> 的期望为 0，因此  <img src="https://math.now.sh?inline=G_%7Bij%7D" style="display:inline-block;margin: 0;"/> 可以在 0 的上下震荡，因此  <img src="https://math.now.sh?inline=G_%7Bij%7D" style="display:inline-block;margin: 0;"/>  可能是负数。</p>
<h2 id="G-阵和-A-阵-兼容问题">G 阵和 A 阵 兼容问题</h2>
<p>构建<img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵时需要使用基础群体的基因频率，但是我们一般用的是当前群体的基因频率，这会导致两个问题。</p>
<p>首先就是系谱和标记的遗传基础不一致了，在构建 G 阵时通过使用 “中心化” 的基因型编码，这会使得当前群体的育种值均值  <img src="https://math.now.sh?inline=%5Coverline%7B%5Cmathbf%7Bu%7D%7D%3D0" style="display:inline-block;margin: 0;"/> 。而在使用系谱的常规评估中，我们仅仅是使得基础群体的育种值均值 <img src="https://math.now.sh?inline=%5Coverline%7B%5Cmathbf%7Bu%7D%7D%3D0" style="display:inline-block;margin: 0;"/> 。</p>
<p>举个例子，为了比较基于系谱的 EBV 和基于基因组的 EBV，它们可能在范围 (<em>scale</em>) 上不一样，也就是说二者的 EBV 可能是相差一个常数，即绝对值有差异，但是相对大小和排名可能是一样的。</p>
<p>第二个问题就是加性方差改变了，基于系谱的加性方差 <img src="https://math.now.sh?inline=%5Csigma_%7Bu%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/>  是基础群体的育种值方差，而基于标记的加性方差 <img src="https://math.now.sh?inline=2%20%5Csum%20p_%7Bi%7D%20q_%7Bi%7D%20%5Csigma_%7Ba%200%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 则是等位基因频率为 <img src="https://math.now.sh?inline=p_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的群体的方差，即当前群体的育种值方差。但是，由于漂变和选择，标记倾向于固定，因此采用当前群体的 <img src="https://math.now.sh?inline=2%20%5Csum%20p_%7Bi%7D%20q_%7Bi%7D%20%5Csigma_%7Ba%200%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/>  会比基础群体更小。</p>
<p>但是，<strong>只有当我们想要合并系谱信息和基因组信息时，这些问题才有意义</strong>。在下一步，我们采用下面的写法，<img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D_%7B%5Ctext%20%7Bbase%20%7D%7D" style="display:inline-block;margin: 0;"/> 表示系谱中的基础群体，<img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> 表示基因型个体，<img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 表示没有基因型的个体。</p>
<h3 id="校正-G-阵">校正 G 阵</h3>
<p>根据之前的描述，使用当前群体的基因频率，对 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵分子的影响相当于增加了一个常数，对分母的影响相当于乘以了一个常数，因此我们可以用下式校正 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BG%7D%5E%7B*%7D%3Da%2Bb%20%5Cmathbf%7BG%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=b" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=a" style="display:inline-block;margin: 0;"/> 的取值有不同的说法，这里只说一种。Christensen et al. (2012) 建议根据两个式子来得到  <img src="https://math.now.sh?inline=b" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=a" style="display:inline-block;margin: 0;"/> ，如下，</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%5Coperatorname%7Btr%7D%28%5Cmathbf%7BG%7D%29%7D%7Bm%7D%20b%2Ba%3D%5Cfrac%7B%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BA%7D_%7B22%7D%5Cright)%7D%7Bm%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=a%2Bb%20%5Coverline%7B%5Cmathbf%7BG%7D%7D%3D%5Coverline%7B%5Cmathbf%7BA%7D%7D_%7B22%7D%0A" /></p><p>也就是说， <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵和  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B22%7D" style="display:inline-block;margin: 0;"/> 阵的对角线元素均值相同，所有元素均值相同（或者说非对角线元素均值相同）。</p>
<h2 id="G-阵的奇异性问题">G 阵的奇异性问题</h2>
<p><img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵可能是一个奇异矩阵，有两个原因可能导致这一点。首先如果存在两个基因型完全相同的个体，那么 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 矩阵就会有相同的两行，导致 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 矩阵不满秩，同时 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵也不满秩。第二点，如果构建 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 矩阵时采用的当前群体的基因频率，那么 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 矩阵就会是一个不满秩的矩阵，因为最后一行可以从其他行得到（Strandén and Christensen 2011）。</p>
<p>为了得到一个非奇异的 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵 ，从而可以在MME中使用 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> ，我们有两种处理方式。第一种是往对角线添加一个很小的数，见下式，这里 <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/> 是一个很小的数，通常是 0.01 或 0.05 。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BG%7D_%7Bw%7D%3D%281-%5Calpha%29%20%5Cmathbf%7BG%7D%2B%5Calpha%20%5Cmathbf%7BI%7D%0A" /></p><p>第二种方式如下，是添加   <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B22%7D" style="display:inline-block;margin: 0;"/> 阵，这里的  <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/> 是 0.05 。这种做法就是 BLUPF90 的做法。这种方式同时是作为剩余多基因效应，也就是这里的 <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/> 是基因组不能解释的育种值比例，有些文章说添加剩余多基因效应之后交叉验证结果更好。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BG%7D_%7Bw%7D%3D%281-%5Calpha%29%20%5Cmathbf%7BG%7D%2B%5Calpha%20%5Cmathbf%7BA%7D_%7B22%7D%0A" /></p><h1>GBLUP</h1>
<h2 id="单性状模型">单性状模型</h2>
<p>在 GBLUP 中，我们其实就是用基因组构建的  <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵替换了系谱构建的 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵，模型如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%20b%7D%2B%5Cmathbf%7BW%20u%7D%2B%5Cmathbf%7Be%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Coperatorname%7BVar%7D%28%5Cmathbf%7Bu%7D%29%3D%5Cmathbf%7BG%7D%20%5Csigma_%7Bu%7D%5E%7B2%7D%2C%20%5Coperatorname%7BVar%7D(%5Cmathbf%7Be%7D)%3D%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>如果假设随机向量均满足多变量正态分布，那么此时 <em>Best Predictions</em> 就是混合模型方程组的解：</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BW%7D%20%5C%5C%0A%5Cmathbf%7BW%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BW%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BW%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5Csigma_%7Bu%7D%5E%7B-2%7D%0A%5Cend%7Barray%7D%5Cright%29%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cwidehat%7B%5Cmathbf%7Bb%7D%7D%20%5C%5C%0A%5Cwidehat%7B%5Cmathbf%7Bu%7D%7D%0A%5Cend%7Barray%7D%5Cright)%3D%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%5Cmathbf%7BW%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D%3D%5Cmathbf%7BI%7D%20%5Csigma_%7Be%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，那么可以进一步简化得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BW%7D%20%5C%5C%0A%5Cmathbf%7BW%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BW%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BW%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5Clambda%0A%5Cend%7Barray%7D%5Cright%29%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cwidehat%7B%5Cmathbf%7Bb%7D%7D%20%5C%5C%0A%5Cwidehat%7B%5Cmathbf%7Bu%7D%7D%0A%5Cend%7Barray%7D%5Cright)%3D%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%5Cmathbf%7BW%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Clambda%3D%5Csigma_%7Be%7D%5E%7B2%7D%20%2F%20%5Csigma_%7Bu%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 。</p>
<h2 id="多性状模型">多性状模型</h2>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BW%7D%20%5C%5C%0A%5Cmathbf%7BW%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BW%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BW%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5Cbigotimes%20%5Cmathbf%7BG%7D_%7B0%7D%5E%7B-1%7D%0A%5Cend%7Barray%7D%5Cright%29%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cwidehat%7B%5Cmathbf%7Bb%7D%7D%20%5C%5C%0A%5Cwidehat%7B%5Cmathbf%7Bu%7D%7D%0A%5Cend%7Barray%7D%5Cright)%3D%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%5Cmathbf%7BW%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D_%7B0%7D" style="display:inline-block;margin: 0;"/> 就是多个性状的加性方差组分矩阵，通常 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D%3D%5Cmathbf%7BI%7D%20%5Cbigotimes%20%5Cmathbf%7BR%7D_%7B0%7D" style="display:inline-block;margin: 0;"/> ，这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D_%7B0%7D" style="display:inline-block;margin: 0;"/> 就是多个性状的残差方差组分矩阵。</p>
<h1>Single Step GBLUP</h1>
<p>在实际的生产过程中，只有一小部分的个体有基因型。因此，最佳的方法是合并系谱和基因组关系矩阵，生成一个新的关系矩阵，由于 MME 中，这就是 ssGBLUP 的思想。</p>
<h2 id="H-阵推导">H 阵推导</h2>
<p>Legarra et al. (2009) 说明如果所有模型中的所有个体均有基因型，那么基因组评估会很简单。此时，我们可以将 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵视为先验的关系矩阵 (<em>prior relationship</em>) ，将 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵视为一个观测到的亲缘关系 (<em>observed relationship)</em> 。然而，现实中往往只有一部分个体有基因型，即  <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵只包含一小部分个体，其相应的先验关系矩阵就是 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B22%7D" style="display:inline-block;margin: 0;"/> 阵。基于这个思想，我们可以基于无基因型的个体育种值 (<img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D_%7B1%7D" style="display:inline-block;margin: 0;"/>) 和 有基因型的个体育种值 (<img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D_%7B2%7D" style="display:inline-block;margin: 0;"/>) ，将有基因型个体的信息扩展到没有基因型的个体：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0Ap%5Cleft%28%5Cmathbf%7Bu%7D_%7B1%7D%2C%20%5Cmathbf%7Bu%7D_%7B2%7D%5Cright%29%3Dp%5Cleft(%5Cmathbf%7Bu%7D_%7B2%7D%5Cright)%20p%5Cleft(%5Cmathbf%7Bu%7D_%7B1%7D%20%5Cmid%20%5Cmathbf%7Bu%7D_%7B2%7D%5Cright)%20%5C%5C%0Ap%5Cleft(%5Cmathbf%7Bu%7D_%7B2%7D%5Cright)%3DN(%5Cmathbf%7B0%7D%2C%20%5Cmathbf%7BG%7D%20%5Csigma_%7Bu%7D%5E%7B2%7D)%0A%5Cend%7Bgathered%7D%0A" /></p><p>如果我们设</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Bvar%7D%28%5Cmathbf%7Bu%7D%29%3D%5Cmathbf%7BA%7D%20%5Csigma_%7Bu%7D%5E%7B2%7D%0A" /></p><p>在下面的推导中，我们可以忽略 <img src="https://math.now.sh?inline=%5Csigma_%7Bu%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 。我们将 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 按照无基因型个体在前，有基因型的个体在后的顺序分块如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BA%7D_%7B11%7D%20%26%20%5Cmathbf%7BA%7D_%7B12%7D%20%5C%5C%0A%5Cmathbf%7BA%7D_%7B21%7D%20%26%20%5Cmathbf%7BA%7D_%7B22%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>基于有基因型个体的育种值信息，无基因型个体育种值的条件分布为 (多元正态分布的条件分布公式为 <img src="https://math.now.sh?inline=%0A%5Cmu_%7B1%20%5Cmid%202%7D%20%3D%5Cmu_%7B1%7D%2B%5CSigma_%7B12%7D%20%5CSigma_%7B22%7D%5E%7B-1%7D%5Cleft%28x_%7B2%7D-%5Cmu_%7B2%7D%5Cright%29%20%2C%5Cquad%0A%5CSigma_%7B1%20%5Cmid%202%7D%20%3D%5CSigma_%7B11%7D-%5CSigma_%7B12%7D%20%5CSigma_%7B22%7D%5E%7B-1%7D%20%5CSigma_%7B21%7D%0A" style="display:inline-block;margin: 0;"/> )</p>
<p style=""><img src="https://math.now.sh?from=p%5Cleft%28%5Cmathbf%7Bu%7D_%7B1%7D%20%5Cmid%20%5Cmathbf%7Bu%7D_%7B2%7D%5Cright%29%3DN%5Cleft(%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7Bu%7D_%7B2%7D%2C%20%5Cmathbf%7BA%7D_%7B11%7D-%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B21%7D%5Cright)%0A" /></p><p>这也可以视为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bu%7D_%7B1%7D%3D%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7Bu%7D_%7B2%7D%2B%5Cboldsymbol%7B%5Cvarepsilon%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cvarepsilon%7D" style="display:inline-block;margin: 0;"/> 视为一个误差项，满足正态分布，其协方差矩阵为  <img src="https://math.now.sh?inline=%5Coperatorname%7BVar%7D%28%5Cboldsymbol%7B%5Cvarepsilon%7D%29%3D%5Cmathbf%7BA%7D_%7B11%7D-%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B21%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>因此，我们进一步推导得到（这就是基于基因型个体的信息的条件分布）</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7BVar%7D%5Cleft%28%5Cmathbf%7Bu%7D_%7B1%7D%5Cright%29%20%26%3D%5Coperatorname%7Bvar%7D%5Cleft(%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7Bu%7D_%7B2%7D%2B%5Cvarepsilon%5Cright)%3D%5Coperatorname%7BVar%7D%5Cleft(%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7Bu%7D_%7B2%7D%5Cright)%2B%5Coperatorname%7BVar%7D(%5Cvarepsilon)%20%5C%5C%0A%26%3D%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BG%20A%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B21%7D%2B%5Cmathbf%7BA%7D_%7B11%7D-%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B21%7D%20%5C%5C%0A%0A%0A%26%3D%5Cmathbf%7BA%7D_%7B11%7D%2B%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BG%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B21%7D-%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B21%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BA%7D_%7B11%7D%2B%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BG%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B21%7D-%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BI%7D%20%5Cmathbf%7BA%7D_%7B21%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BA%7D_%7B11%7D%2B%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BG%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B21%7D-%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B22%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B21%7D%20%5C%5C%0A%0A%26%3D%5Cmathbf%7BA%7D_%7B11%7D%2B%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%5Cleft(%5Cmathbf%7BG%7D-%5Cmathbf%7BA%7D_%7B22%7D%5Cright)%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B21%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>同时，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0A%5Coperatorname%7BVar%7D%5Cleft%28%5Cmathbf%7Bu%7D_%7B2%7D%5Cright%29%3D%5Cmathbf%7BG%7D%20%5C%5C%0A%5Coperatorname%7BCov%7D%5Cleft(%5Cmathbf%7Bu%7D_%7B1%7D%2C%20%5Cmathbf%7Bu%7D_%7B2%7D%5Cright)%3D%5Coperatorname%7BCov%7D%5Cleft(%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7Bu%7D_%7B2%7D%2C%20%5Cmathbf%7Bu%7D_%7B2%7D%5Cright)%3D%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Coperatorname%7BVar%7D%5Cleft(%5Cmathbf%7Bu%7D_%7B2%7D%5Cright)%3D%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BG%7D%0A%5Cend%7Bgathered%7D%0A" /></p><p>最终，我们把上面的这些内容放在一个矩阵中，我们得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D" style="display:inline-block;margin: 0;"/> 矩阵</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BH%7D%20%26%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Coperatorname%7Bvar%7D%5Cleft(%5Cmathbf%7Bu%7D_%7B1%7D%5Cright%29%20%26%20%5Coperatorname%7Bcov%7D%5Cleft(%5Cmathbf%7Bu%7D_%7B1%7D%2C%20%5Cmathbf%7Bu%7D_%7B2%7D%5Cright)%20%5C%5C%0A%5Coperatorname%7Bcov%7D%5Cleft(%5Cmathbf%7Bu%7D_%7B2%7D%2C%20%5Cmathbf%7Bu%7D_%7B1%7D%5Cright)%20%26%20%5Coperatorname%7Bvar%7D%5Cleft(%5Cmathbf%7Bu%7D_%7B2%7D%5Cright)%0A%5Cend%7Barray%7D%5Cright)%20%5C%5C%0A%26%3D%5Cleft(%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BA%7D_%7B11%7D%2B%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%5Cleft(%5Cmathbf%7BG%7D-%5Cmathbf%7BA%7D_%7B22%7D%5Cright)%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B21%7D%20%26%20%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BG%7D%20%5C%5C%0A%5Cmathbf%7BG%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B21%7D%20%26%20%5Cmathbf%7BG%7D%0A%5Cend%7Barray%7D%5Cright)%20%5C%5C%0A%26%3D%5Cmathbf%7BA%7D%2B%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%5Cleft(%5Cmathbf%7BG%7D-%5Cmathbf%7BA%7D_%7B22%7D%5Cright)%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B21%7D%20%26%20%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%5Cleft(%5Cmathbf%7BG%7D-%5Cmathbf%7BA%7D_%7B22%7D%5Cright)%20%5C%5C%0A%5Cleft(%5Cmathbf%7BG%7D-%5Cmathbf%7BA%7D_%7B22%7D%5Cright)%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B21%7D%20%26%20%5Cmathbf%7BG%7D-%5Cmathbf%7BA%7D_%7B22%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A%5Cend%7Baligned%7D%0A" /></p><p>这也可以简化为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BH%7D%3D%5Cmathbf%7BA%7D%2B%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BA%7D_%7B12%7D%20%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BI%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BI%7D%20%5C%5C%0A%5Cmathbf%7BI%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BG%7D-%5Cmathbf%7BA%7D_%7B22%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BI%7D%20%26%20%5Cmathbf%7BI%7D%5D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D_%7B21%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BI%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>相应的逆矩阵比较简单，见下式  (Aguilar et al. 2010 ; Christensen and Lund 2010)</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BH%7D%5E%7B-1%7D%3D%5Cmathbf%7BA%7D%5E%7B-1%7D%2B%5Cleft%5B%5Cbegin%7Barray%7D%7Blc%7D%0A0%20%26%200%20%5C%5C%0A0%20%26%20%5Cmathbf%7BG%7D%5E%7B-1%7D-%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>注意这里的 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 是要单独对 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B22%7D" style="display:inline-block;margin: 0;"/> 进行求逆得到的，而不是 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 的子矩阵，因此构建 <img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 分为下面三步：</p>
<ol>
<li>采用 Henderson 的方法构建 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/></li>
<li>构建 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 并求逆</li>
<li>构建 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B22%7D" style="display:inline-block;margin: 0;"/> 并求逆</li>
</ol>
<p>一般来说 <img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 阵是一个比较稀疏的矩阵，但是我们注意到 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵和 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 阵是稠密矩阵，因此当基因型个体数目很多时， <img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 阵可能也很稠密，那么此时求解 MME 计算量比较大。</p>
<p><img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D" style="display:inline-block;margin: 0;"/> 矩阵可以视为根据基因型亲缘关系对常规的系谱亲缘关系矩阵的一个修改。举个例子，假设两个个体在系谱中没有关系，但是由于它们的后代在 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵中有关系，因此这两个个体在 <img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D" style="display:inline-block;margin: 0;"/> 矩阵可能也有关系。</p>
<p>在构建 <img src="https://math.now.sh?inline=%5Cmathbf%7BH%7D" style="display:inline-block;margin: 0;"/> 矩阵时，我们需要计算 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D-%5Cmathbf%7BA%7D_%7B22%7D" style="display:inline-block;margin: 0;"/> ，这就表明这两个矩阵需要是可比较的 (Legarra et al. 2014)。由于构建 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵时我们一般不是采用基础群体的等位基因频率，因此我们需要先将  <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵的范围调整为与 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B22%7D" style="display:inline-block;margin: 0;"/> 阵一致，之后再解决  <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵的奇异性问题。</p>
<h2 id="MME">MME</h2>
<p>考虑下面的动物模型</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cmathbf%7Bb%7D%2B%5Cmathbf%7BW%20u%7D%2B%5Cmathbf%7Be%7D%0A" /></p><p>采用一步法的 MME 如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Csigma_%7Be%7D%5E%7B-2%7D%20%26%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BW%7D%20%5Csigma_%7Be%7D%5E%7B-2%7D%20%5C%5C%0A%5Cmathbf%7BW%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Csigma_%7Be%7D%5E%7B-2%7D%20%26%20%5Cmathbf%7BW%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BW%7D%20%5Csigma_%7Be%7D%5E%7B-2%7D%2B%5Cmathbf%7BH%7D%5E%7B-1%7D%20%5Csigma_%7Bu%7D%5E%7B-2%7D%0A%5Cend%7Barray%7D%5Cright%29%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cwidehat%7B%5Cmathbf%7Bb%7D%7D%20%5C%5C%0A%5Cwidehat%7B%5Cmathbf%7Bu%7D%7D%0A%5Cend%7Barray%7D%5Cright)%3D%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%5Csigma_%7Be%7D%5E%7B-2%7D%20%5C%5C%0A%5Cmathbf%7BW%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%5Csigma_%7Be%7D%5E%7B-2%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><h1>APY 方法 (Misztal, 2016)</h1>
<p>我们将个体拆分为核心群体 (<em>core animals</em>, “c”) 和 非核心群体 (<em>non-core animals</em>, “n”) ，</p>
<p>我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Bvar%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7Bu%7D_%7Bc%7D%20%5C%5C%0A%5Cmathbf%7Bu%7D_%7Bn%7D%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Cmathbf%7BG%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BG%7D_%7Bc%20c%7D%20%26%20%5Cmathbf%7BG%7D_%7Bc%20n%7D%20%5C%5C%0A%5Cmathbf%7BG%7D_%7Bn%20c%7D%20%26%20%5Cmathbf%7BG%7D_%7Bn%20n%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5Csigma_%7Bu%7D%5E%7B2%7D%2C%0A" /></p><p>此时 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 计算公式如下</p>
<p style=""><img src="https://math.now.sh?from=G%5E%7B-1%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0AG_%7Bc%20c%7D%5E%7B-1%7D%20%26%200%20%5C%5C%0A0%20%26%200%0A%5Cend%7Barray%7D%5Cright%5D%2B%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A-%20G_%7Bc%20c%7D%5E%7B-1%7D%20G_%7Bc%20n%7D%20%5C%5C%0AI%0A%5Cend%7Barray%7D%5Cright%5D%20M%5E%7B-1%7D%5Cleft%5B-G_%7Bn%20c%7D%20G_%7Bc%20c%7D%5E%7B-1%7D%20%5Cquad%20I%5Cright%5D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D" style="display:inline-block;margin: 0;"/> 矩阵是一个关于非核心群体的对角矩阵，其元素为（下面的 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 为非核心群体）</p>
<p style=""><img src="https://math.now.sh?from=m_%7Bi%7D%3Dg_%7Bi%20i%7D-%28G_%7Bn%20c%7D%20G_%7Bc%20c%7D%5E%7B-1%7D%20G_%7Bc%20n%7D%29_%7Bii%7D%0A" /></p><p>在实际中，猪和鸡的核心群体一般为 5k，牛的核心群体一般为 10-15k （Pocrnic et al., 2016）。</p>
<p>核心群体可以从所有的基因型个体中（具有高质量的基因分型）随机抽样得到。APY 方法得到 GEBV 通常比常规求逆方法的可靠性会提高 1-3% (估计是理论准确性)，原因可能是减少了采样噪音。</p>
<p>对于大群体， <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 是一个稀疏矩阵，但是  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 可能是一个稠密矩阵 (Faux and Genegler, 2013)。 此时我们可以通过一个间接的方式得到   <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B22%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> （Stranden and Mantysaari, 2014）（应该就是根据矩阵求逆的公式）</p>
<p style=""><img src="https://math.now.sh?from=A_%7B22%7D%5E%7B-1%7D%3DA%5E%7B22%7D-%5Cleft%28A%5E%7B12%7D%5Cright%29%5E%7B%5Cprime%7D%5Cleft(A%5E%7B11%7D%5Cright)%5E%7B-1%7D%5Cleft(A%5E%7B12%7D%5Cright)%0A" /></p><p>其中右手项的所有元素均是 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 矩阵的子矩阵，即</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BA%7D_%7B11%7D%20%26%20%5Cmathbf%7BA%7D_%7B12%7D%20%5C%5C%0A%5Cmathbf%7BA%7D_%7B21%7D%20%26%20%5Cmathbf%7BA%7D_%7B22%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5Ctext%20%7B%20and%20%7D%20%5Cmathbf%7BA%7D%5E%7B-1%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BA%7D%5E%7B11%7D%20%26%20%5Cmathbf%7BA%7D%5E%7B12%7D%20%5C%5C%0A%5Cmathbf%7BA%7D%5E%7B21%7D%20%26%20%5Cmathbf%7BA%7D%5E%7B22%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>如果我们采用 PCG 算法，我们只需要计算下式，只涉及到矩阵和向量的乘积</p>
<p style=""><img src="https://math.now.sh?from=A_%7B22%7D%5E%7B-1%7D%20q%3DA%5E%7B22%7D%20q-%5Cleft%28A%5E%7B12%7D%5Cright%29%5E%7B%5Cprime%7D%5Cleft%5B%5Cleft(A%5E%7B11%7D%5Cright)%5E%7B-1%7D%5Cleft%5BA%5E%7B12%7D%20q%5Cright%5D%5Cright%5D%0A" /></p><h1>参考文献</h1>
<ol>
<li><a href="http://nce.ads.uga.edu/wiki/lib/exe/fetch.php?media=gsip.pdf">http://nce.ads.uga.edu/wiki/lib/exe/fetch.php?media=gsip.pdf</a></li>
<li><a href="http://nce.ads.uga.edu/wiki/lib/exe/fetch.php?media=andres_part2.pdf">http://nce.ads.uga.edu/wiki/lib/exe/fetch.php?media=andres_part2.pdf</a></li>
<li>de Los Campos G, Hickey J M, Pong-Wong R, et al. Whole-genome regression and prediction methods applied to plant and animal breeding[J]. Genetics, 2013, 193(2): 327-345.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>基因组选择模型介绍上</title>
    <url>/posts/97b48478/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>基因组选择方法，大体上可以分为两类，第一类方法是通过参考群数据获得标记效应从而间接<br>
获得基因组估计育种值；第二类方法是通过使用基因组数据构建新的关系矩阵加<br>
入到混合模型方程组中直接获得基因组估计育种值，如 GBLUP方法。</p>
<p>本篇主要介绍第一类方法。</p>
<span id="more"></span>
<h1>单标记选择</h1>
<p>我们先看单个标记的模型，再扩展到全基因组的基因组选择。</p>
<p>假设存在一个标记与某个 QTL 处于完全连锁状态，那么我们可以将这个标记当作固定效应加入到模型中，即</p>
<p style=""><img src="https://math.now.sh?from=y_%7Bi%7D%20%3D%20%5Ctext%7Bmarker%20effect%20in%20animal%20%7Di%20%2B%20e_%7Bi%7D%0A" /></p><p>我们也可以往模型中添加一个<strong>剩余多基因效应</strong> (<em>additional polygenic genetic value</em>) 。</p>
<p style=""><img src="https://math.now.sh?from=y_%7Bi%7D%20%3D%20%5Ctext%7Bmarker%20effect%20in%20animal%20%7D%20i%20%2B%20%5Ctext%7Bpolygenic%20genetic%20value%20of%20animal%20%7D%20i%20%2B%20e_%7Bi%7D%0A" /></p><p>我们下面看一些例子，首先假设我们有一个 4 等位基因 (A,B,C,D)的标，三个个体的基因型分别为 BC, AA, BD。那么我们可以估计每个等位基因的效应，建立矩阵如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7BZ%7D%20%5Cboldsymbol%7Ba%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bllll%7D%0A0%20%26%201%20%26%201%20%26%200%20%5C%5C%0A2%20%26%200%20%26%200%20%26%200%20%5C%5C%0A0%20%26%201%20%26%200%20%26%201%0A%5Cend%7Barray%7D%5Cright%29%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0Aa_%7BA%7D%20%5C%5C%0Aa_%7BB%7D%20%5C%5C%0Aa_%7BC%7D%20%5C%5C%0Aa_%7BD%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>假设三个基因型个体的表型为 (12,35,6) ，则可以构建一个模型如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0A%5Cboldsymbol%7By%7D%3D%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7Bb%7D%2B%5Cboldsymbol%7BZ%7D%20%5Cboldsymbol%7Ba%7D%2B%5Cboldsymbol%7Be%7D%20%5C%5C%0A%5Cleft%28%5Cbegin%7Barray%7D%7Bc%7D%0A12%20%5C%5C%0A35%20%5C%5C%0A6%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A1%20%5C%5C%0A1%20%5C%5C%0A1%0A%5Cend%7Barray%7D%5Cright)%20%5Cmu%2B%5Cleft(%5Cbegin%7Barray%7D%7Bllll%7D%0A0%20%26%201%20%26%201%20%26%200%20%5C%5C%0A2%20%26%200%20%26%200%20%26%200%20%5C%5C%0A0%20%26%201%20%26%200%20%26%201%0A%5Cend%7Barray%7D%5Cright)%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0Aa_%7BA%7D%20%5C%5C%0Aa_%7BB%7D%20%5C%5C%0Aa_%7BC%7D%20%5C%5C%0Aa_%7BD%7D%0A%5Cend%7Barray%7D%5Cright)%2B%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0Ae_%7B1%7D%20%5C%5C%0Ae_%7B2%7D%20%5C%5C%0Ae_%7B3%7D%0A%5Cend%7Barray%7D%5Cright)%0A%5Cend%7Bgathered%7D%0A" /></p><p>这个模型是一个固定模型，可以通过最小二乘法进行求解。</p>
<p>如果我们考虑剩余多基因效应，则模型为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0A%5Cboldsymbol%7By%7D%3D%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7Bb%7D%2B%5Cboldsymbol%7BZ%7D%20%5Cboldsymbol%7Ba%7D%2B%5Cboldsymbol%7BW%7D%20%5Cboldsymbol%7Bu%7D%2B%5Cboldsymbol%7Be%7D%20%5C%5C%0A%5Cleft%28%5Cbegin%7Barray%7D%7Bc%7D%0A12%20%5C%5C%0A35%20%5C%5C%0A6%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A1%20%5C%5C%0A1%20%5C%5C%0A1%0A%5Cend%7Barray%7D%5Cright)%20%5Cmu%2B%5Cleft(%5Cbegin%7Barray%7D%7Bllll%7D%0A0%20%26%201%20%26%201%20%26%200%20%5C%5C%0A2%20%26%200%20%26%200%20%26%200%20%5C%5C%0A0%20%26%201%20%26%200%20%26%201%0A%5Cend%7Barray%7D%5Cright)%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0Aa_%7BA%7D%20%5C%5C%0Aa_%7BB%7D%20%5C%5C%0Aa_%7BC%7D%20%5C%5C%0Aa_%7BD%7D%0A%5Cend%7Barray%7D%5Cright)%2B%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0Au_%7B1%7D%20%5C%5C%0Au_%7B2%7D%20%5C%5C%0Au_%7B3%7D%0A%5Cend%7Barray%7D%5Cright)%2B%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0Ae_%7B1%7D%20%5C%5C%0Ae_%7B2%7D%20%5C%5C%0Ae_%7B3%7D%0A%5Cend%7Barray%7D%5Cright)%0A%5Cend%7Bgathered%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Coperatorname%7BVar%7D%28%5Cboldsymbol%7Bu%7D%29%3D%5Cboldsymbol%7BA%7D%20%5Csigma_%7Bu%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，此时模型为混合线性模型，可以用 BLUP 方法求解。</p>
<p>我们可以轻松扩展到 2 个标记的模型，即</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cmathbf%7By%3DX%20b%2BZ_%7B1%7D%20a_%7B1%7D%2BZ_%7B2%7D%20a_%7B2%7D%2BW%20u%2Be%7D%5C%5C%0A%26%5Cleft%28%5Cbegin%7Barray%7D%7Bc%7D%0A12%20%5C%5C%0A35%20%5C%5C%0A6%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A1%20%5C%5C%0A1%20%5C%5C%0A1%0A%5Cend%7Barray%7D%5Cright)%20%5Cmu%2B%5Cleft(%5Cbegin%7Barray%7D%7Bllll%7D%0A0%20%26%201%20%26%201%20%26%200%20%5C%5C%0A2%20%26%200%20%26%200%20%26%200%20%5C%5C%0A0%20%26%201%20%26%200%20%26%201%0A%5Cend%7Barray%7D%5Cright)%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0Aa_%7BA%201%7D%20%5C%5C%0Aa_%7BB%201%7D%20%5C%5C%0Aa_%7BC%201%7D%20%5C%5C%0Aa_%7BD%201%7D%0A%5Cend%7Barray%7D%5Cright)%2B%5Cleft(%5Cbegin%7Barray%7D%7Bll%7D%0A1%20%26%201%20%5C%5C%0A0%20%26%202%20%5C%5C%0A2%20%26%200%0A%5Cend%7Barray%7D%5Cright)%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0Aa_%7BC%202%7D%20%5C%5C%0Aa_%7BG%202%7D%0A%5Cend%7Barray%7D%5Cright)%2B%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0Au_%7B1%7D%20%5C%5C%0Au_%7B2%7D%20%5C%5C%0Au_%7B3%7D%0A%5Cend%7Barray%7D%5Cright)%2B%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0Ae_%7B1%7D%20%5C%5C%0Ae_%7B2%7D%20%5C%5C%0Ae_%7B3%7D%0A%5Cend%7Barray%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>然后到 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个标记的模型</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%3DX%20b%2BZ_%7B1%7D%20a_%7B1%7D%2BZ_%7B2%7D%20a_%7B2%7D%2B%5Ccdots%20W%20u%2Be%7D%0A" /></p><p>如果所有标记只有 2 个等位基因，例如 SNP ，假设两个 SNP 的碱基分别为 A/B, E/F ，按照上面的表示方式，我们需要将三个个体的标记效应表示为</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7BZ%7D%20%5Cboldsymbol%7Ba%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bccccc%7D%0A1%20%26%201%20%26%20%5Cvdots%20%26%202%20%26%200%20%5C%5C%0A2%20%26%200%20%26%20%5Cvdots%20%26%201%20%26%201%20%5C%5C%0A0%20%26%202%20%26%20%5Cvdots%20%26%200%20%26%202%0A%5Cend%7Barray%7D%5Cright%29%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0Aa_%7BA%7D%20%5C%5C%0Aa_%7BB%7D%20%5C%5C%0A%5Ccdots%20%5C%5C%0Aa_%7BE%7D%20%5C%5C%0Aa_%7BF%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>但是由于标记只有 2 个碱基，此时这种表达方式存在冗余，一个标记可以只估计一个效应，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7BZ%20a%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bccc%7D%0A1%20%26%20%5Cvdots%20%26%202%20%5C%5C%0A2%20%26%20%5Cvdots%20%26%201%20%5C%5C%0A0%20%26%20%5Cvdots%20%26%200%0A%5Cend%7Barray%7D%5Cright%29%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0Aa_%7BA%7D%20%5C%5C%0A%5Ccdots%20%5C%5C%0Aa_%7BE%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>或者 （可以任意挑选某个碱基进行计数）</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7BZ%7D%20%5Cboldsymbol%7Ba%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bccc%7D%0A1%20%26%20%5Cvdots%20%26%200%20%5C%5C%0A0%20%26%20%5Cvdots%20%26%201%20%5C%5C%0A2%20%26%20%5Cvdots%20%26%202%0A%5Cend%7Barray%7D%5Cright%29%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0Aa_%7BB%7D%20%5C%5C%0A%5Ccdots%20%5C%5C%0Aa_%7BF%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>此时我们面临下面几个问题</p>
<ul>
<li>我们应该放多少个标记到模型中？</li>
<li>基因组中总共有多少个 QTL ？</li>
<li>我们已经发现并通过验证的 QTL 有多少个？</li>
</ul>
<p>根据之前的研究结果，我们发现只用发现的 QTL，我们会遗漏很多的遗传变异。例如在 GWAS 分析中，当样本数为 1000 ，位点数为 50k ，经过 Bonferroni 校正后，找到的解释遗传方差比例超过 1% 的 QTL 只有 4% ，换句话说，如果群体中存在 100 个 QTL ，GWAS 只能找到 4 个显著的 QTL。</p>
<p>另外，我们发现的 QTL 效应一般都是夸大的，即其真实效应小于估计效应 (<em>Beavis effect</em>)。因为估计效应等于真实效应加上估计噪音，为了选择估计效应很大的 QTL ，我们就很容易选中实际是估计噪音很大的 QTL 。如果真实情况是只有少数几个QTL的效应很大，那么此时 <em>Beavis effect</em> 是可以忽略的，但是实际情况往往不是这样。当位点数目很多，就会出现某些位点的估计噪音很大，使得这些位点的估计效应比真实效应大得多，这个问题在 GWAS 分析中很严重。</p>
<h1>全基因组选择</h1>
<h1>贝叶斯估计，或标记效应的最佳估计</h1>
<p>我们已知标记辅助选择会导致选择出现偏差，那么如果我们不对 QTL 区域进行选择，我们就可以避免这个偏差。因此此时的估计育种值就是整个基因组所有区域的效应之和，即我们认为基因组的所有区域可能都有效应，这种思想就是全基因组选择。那么我们如何估计整个基因组所有区域的效应呢？</p>
<p>最简单的方法就是扩展单标记选择扩展为多标记选择，估计每一个标记的效应。但是由于此时我们采用覆盖全基因组的标记，问题在于标记数目太多了（标记数目很可能大于样本数目），此时用最小二乘法估计标记效应是很糟糕的。</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7By%7D%3D%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7Bb%7D%2B%5Cboldsymbol%7BZ%7D%20%5Cboldsymbol%7Ba%7D%2B%5Cboldsymbol%7Be%7D%20%5C%5C%0A" /></p><p>另外，即便我们有非常多的样本，我们还没有用上一个先验信息，即大部分的 SNP 效应都不大。那么我们如何进行改善呢？</p>
<p>我们可以利用 <em>Best Prediction</em> 的理论（最小化估计值和真实值的举例）， <em>Best Prediction</em>  也可以视为一个贝叶斯估计值，我们需要知道标记效应的先验分布 <img src="https://math.now.sh?inline=p%28%5Cmathbf%7Ba%7D%29" style="display:inline-block;margin: 0;"/> ，给定标记效应的表型数据的似然值 <img src="https://math.now.sh?inline=p%28%5Cmathbf%7By%7Ca%7D%29" style="display:inline-block;margin: 0;"/> ，此时估计的标记效应值为</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cmathbf%7Ba%7D%7D%3DE%28%5Cmathbf%7Ba%7D%20%5Cmid%20%5Cmathbf%7By%7D%29%3D%5Cfrac%7B%5Cint%20%5Cmathbf%7Ba%7D%20p(%5Cmathbf%7By%7D%20%5Cmid%20%5Cmathbf%7Ba%7D)%20p(%5Cmathbf%7Ba%7D)%20d%20%5Cmathbf%7Ba%7D%7D%7B%5Cint%20p(%5Cmathbf%7By%7D%20%5Cmid%20%5Cmathbf%7Ba%7D)%20p(%5Cmathbf%7Ba%7D)%20d%20%5Cmathbf%7Ba%7D%7D%0A" /></p><p>第二个等号推导如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%28%5Cmathbf%7Ba%7D%20%5Cmid%20%5Cmathbf%7By%7D%29%20%26%3D%20%5Cint%20%20%5Cmathbf%7Ba%7D%20p(%5Cmathbf%7Ba%7D%20%5Cmid%20%5Cmathbf%7By%7D)%20d%20%5Cmathbf%7Ba%7D%20%5Cquad%20%26%20%5Cbecause%20p(%5Cmathbf%7Ba%7D%20%5Cmid%20%5Cmathbf%7By%7D)%20%3D%20%5Cfrac%7Bp(%5Cmathbf%7Ba%7D%20%2C%20%5Cmathbf%7By%7D)%20%7D%7Bp(%5Cmathbf%7By%7D)%7D%20%3D%20%5Cfrac%7Bp(%5Cmathbf%7By%7Ca%7D)%20p(%20%5Cmathbf%7Ba%7D)%20%7D%7B%20%5Cint%20p(%5Cmathbf%7By%2Ca%7D)%20d%20%5Cmathbf%7Ba%7D%7D%20%3D%20%5Cfrac%7Bp(%5Cmathbf%7By%7Ca%7D)%20p(%20%5Cmathbf%7Ba%7D)%20%7D%7B%20%5Cint%20p(%5Cmathbf%7By%7Ca%7D)%20p(%5Cmathbf%7Ba%7D)%20d%20%5Cmathbf%7Ba%7D%7D%20%20%20%5C%5C%0A%26%3D%20%5Cfrac%7B%5Cint%20%5Cmathbf%7Ba%7D%20p(%5Cmathbf%7By%7D%20%5Cmid%20%5Cmathbf%7Ba%7D)%20p(%5Cmathbf%7Ba%7D)%20d%20%5Cmathbf%7Ba%7D%7D%7B%5Cint%20p(%5Cmathbf%7By%7D%20%5Cmid%20%5Cmathbf%7Ba%7D)%20p(%5Cmathbf%7Ba%7D)%20d%20%5Cmathbf%7Ba%7D%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p><em>Best Prediction</em> 方法相比于最小二乘方法具有更大的优势，是一个最优解，因为它用了所有可用的信息 (Gianola and Fernando 1986) 。先验分布  <img src="https://math.now.sh?inline=p%28%5Cmathbf%7Ba%7D%29" style="display:inline-block;margin: 0;"/> 可以使得估计值向我们的先验值（通常为0）进行回归，这个过程称为 <em>shrinkage</em> 。</p>
<p>贝叶斯回归方法中，一般普遍假设残差的分布为正态分布，即 <img src="https://math.now.sh?inline=p%28%5Cboldsymbol%7Be%7D%29%20%5Csim%20%5Cmathbf%7BN%7D(%5Cmathbf%7B0%7D%2C%20%5Cboldsymbol%7BR%7D)" style="display:inline-block;margin: 0;"/> ，似然函数 <img src="https://math.now.sh?inline=p%28%5Cmathbf%7By%7D%20%5Cmid%20%5Cmathbf%7Ba%7D%29%20%5Csim%20M%20V%20N(%5Cmathbf%7BX%7D%20%5Cmathbf%7Bb%7D%2B%5Cmathbf%7BZ%7D%20%5Cmathbf%7Ba%7D%2C%20%5Cmathbf%7BR%7D)" style="display:inline-block;margin: 0;"/> 。但是不同的人对于标记效应的先验分布 <img src="https://math.now.sh?inline=p%28%5Cboldsymbol%7Ba%7D%29" style="display:inline-block;margin: 0;"/> 的假设不一样，从而得到不同的贝叶斯方法，如 (Bayes A, B, C, R, S… Bayesian Lasso……)   。因此，贝叶斯回归的效果很大程度上受到标记效应的先验分布的影响，我们需要找到一个合适的先验分布，不然估计的标记效应就可能 <code>too much shrunken</code> (所有标记的效应估计值都非常小)，又或者 <code>too little shrunken</code> ，以至于标记效应的估计值中包含了太多的错误甚至是完全错误的。</p>
<h2 id="加性方差和标记方差">加性方差和标记方差</h2>
<p>假设个体育种值的加性方差为 <img src="https://math.now.sh?inline=%5Coperatorname%7BVar%7D%28u%29%3D%5Csigma_%7Bu%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 。如果一个标记的效应为 <img src="https://math.now.sh?inline=a_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，即每增加一个参考碱基的效应为  <img src="https://math.now.sh?inline=a_%7Bi%7D" style="display:inline-block;margin: 0;"/>  ，因此我们有 <img src="https://math.now.sh?inline=p%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 个个体在这个标记的效应为 <img src="https://math.now.sh?inline=u%3D%2B2%20a_%7Bi%7D" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=q%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 个个体在这个标记的效应为 <img src="https://math.now.sh?inline=u%3D%200" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=2pq" style="display:inline-block;margin: 0;"/> 个个体在这个标记的效应为 <img src="https://math.now.sh?inline=u%3D%20a_%7Bi%7D" style="display:inline-block;margin: 0;"/> （假设哈温平衡）。根据方差公式 <img src="https://math.now.sh?inline=%5Coperatorname%7BVar%7D%28u%29%3DE%5Cleft(u%5E%7B2%7D%5Cright)-E(u)%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，我们得到下表</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Barray%7D%7Bllll%7D%0A%5Chline%20%5Ctext%20%7B%20Genotype%20%7D%20%26%20%5Ctext%20%7B%20Frequency%20%7D%20%26%20u%5E%7B2%7D%20%26%20u%20%5C%5C%0A%5Chline%20%5Ctext%20%7B%20AA%20%7D%20%26%20p%5E%7B2%7D%20%26%204%20a_%7Bi%7D%5E%7B2%7D%20%26%202%20a_%7Bi%7D%20%5C%5C%0A%5Ctext%20%7B%20Aa%20%7D%20%26%202%20p%20q%20%26%20a_%7Bi%7D%5E%7B2%7D%20%26%20a_%7Bi%7D%20%5C%5C%0A%5Ctext%20%7B%20aa%20%7D%20%26%20q%5E%7B2%7D%20%26%200%20%26%200%20%5C%5C%0A%5Ctext%20%7B%20Average%20%7D%20%26%20%26%204%20p%5E%7B2%7D%20a_%7Bi%7D%5E%7B2%7D%2B2%20p%20q%20a_%7Bi%7D%5E%7B2%7D%20%26%202%20p%20a_%7Bi%7D%20%5C%5C%0A%5Chline%0A%5Cend%7Barray%7D%0A" /></p><p>因此，单个标记解释的方差为 <img src="https://math.now.sh?inline=4%20p%5E%7B2%7D%20a_%7Bi%7D%5E%7B2%7D%2B2%20p%20q%20a_%7Bi%7D%5E%7B2%7D-%5Cleft%282%20p%20%20a_%7Bi%7D%5Cright%29%5E%7B2%7D%3D2%20p%20q%20a_%7Bi%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 。由于 <img src="https://math.now.sh?inline=2pq" style="display:inline-block;margin: 0;"/> 在 <img src="https://math.now.sh?inline=p%20%3D%200.5" style="display:inline-block;margin: 0;"/> 时最大，因此 MAF 越大的标记解释的遗传方差一般也越大，因此这解释了可以忽略MAF比较低的标记的原因。</p>
<p>假设我们只有两个标记并且知道它们的效应大小，因此一个个体的育种值可以表示为 <img src="https://math.now.sh?inline=u%3Dz_%7B1%7D%20a_%7B1%7D%2Bz_%7B2%7D%20a_%7B2%7D" style="display:inline-block;margin: 0;"/> ，那么 $\operatorname{Var}(u)=\operatorname{Var}\left(z_{1}\right) a_{1}^{2}+\operatorname{Var}\left(z_{2}\right) a_{2}^{2}+2 \operatorname{Cov}\left(z_{1}, z_{2}\right) a_{1} a_{2} $ 。<strong>假设哈维平衡</strong>，易得 <img src="https://math.now.sh?inline=%5Coperatorname%7BVar%7D%5Cleft%28z_%7B1%7D%5Cright%29%3D2%20p_%7B1%7D%20q_%7B1%7D" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=%5Coperatorname%7BVar%7D%5Cleft%28z_%7B2%7D%5Cright%29%3D2%20p_%7B2%7D%20q_%7B2%7D" style="display:inline-block;margin: 0;"/> 。<img src="https://math.now.sh?inline=%5Coperatorname%7BCov%7D%5Cleft%28z_%7B1%7D%2C%20z_%7B2%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 这一项证明为 <img src="https://math.now.sh?inline=2%20r%20%5Csqrt%7Bp_%7B1%7D%20q_%7B1%7D%20p_%7B2%7D%20q_%7B2%7D%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> 为衡量连锁不平衡的相关系数（这里 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> 应该就是两列基因型的相关系数），另外这里的 <img src="https://math.now.sh?inline=a_%7B1%7Da_%7B2%7D" style="display:inline-block;margin: 0;"/> 项表示两个位点的效应必须方向一致，这样 <img src="https://math.now.sh?inline=2%20%5Coperatorname%7BCov%7D%5Cleft%28z_%7B1%7D%2C%20z_%7B2%7D%5Cright%29%20a_%7B1%7D%20a_%7B2%7D" style="display:inline-block;margin: 0;"/> 才是一个正数。因此我们一般不考虑协方差这一项，即<strong>假设连锁平衡</strong>。</p>
<p>假设连锁平衡，或者说假设位点间彼此不相关，此时 <img src="https://math.now.sh?inline=%5Coperatorname%7BVar%7D%28u%29%3D%5Coperatorname%7BVar%7D%5Cleft(z_%7B1%7D%5Cright)%20a_%7B1%7D%5E%7B2%7D%2B%5Coperatorname%7BVar%7D%5Cleft(z_%7B2%7D%5Cright)%20a_%7B2%7D%5E%7B2%7D%3D2%20p_%7B1%7D%20q_%7B1%7D%20a_%7B1%7D%5E%7B2%7D%2B2%20p_%7B2%7D%20q_%7B2%7D%20a_%7B2%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，也就是说每一个标记的方差是可以累加的。我们将这个结论一般化，得到加性方差用标记方差表达的公式：</p>
<p style=""><img src="https://math.now.sh?from=%5Csigma_%7Bu%7D%5E%7B2%7D%3D%5Coperatorname%7BVar%7D%28u%29%3D2%20%5Csum_%7Bi%7D%5E%7B%5Cmathrm%7Bnsnp%7D%7D%20p_%7Bi%7D%20q_%7Bi%7D%20a_%7Bi%7D%5E%7B2%7D%0A" /></p><p>但是在很多情况下，我们不知道标记效应大小。但是我们可能对标记效应有一些先验知识，比如我们一般认为其均值为0，有一个先验的方差。在这种情况下，我们可以将 <img src="https://math.now.sh?inline=a_%7Bi%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 替换为其先验的期望值，即 <img src="https://math.now.sh?inline=%5Csigma_%7B%5Cmathrm%7Bai%7D%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Csigma_%7Bu%7D%5E%7B2%7D%3D%5Coperatorname%7BVar%7D%28u%29%3D2%20%5Csum_%7Bi%7D%5E%7B%5Cmathrm%7Bnsnp%7D%7D%20p_%7Bi%7D%20q_%7Bi%7D%20%5Csigma_%7B%5Cmathrm%7Bai%7D%7D%5E%7B2%7D%0A" /></p><p>如果我们假设所有的标记具有相同的先验方差 <img src="https://math.now.sh?inline=%5Csigma_%7B%5Cmathrm%7Ba0%7D%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，那么 <img src="https://math.now.sh?inline=%5Csigma_%7Bu%7D%5E%7B2%7D%3D2%20%5Csum_%7Bi%7D%5E%7B%5Cmathrm%7Bnsnp%7D%7D%20p_%7Bi%7D%20q_%7Bi%7D%20%5Csigma_%7Ba0%7D%5E%7B2%7D%3D2%20%5Csigma_%7Ba0%7D%5E%7B2%7D%20%5Csum_%7Bi%7D%5E%7B%5Cmathrm%7Bnsnp%7D%7D%20p_%7Bi%7D%20q_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，因此我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Csigma_%7Ba%200%7D%5E%7B2%7D%3D%5Cfrac%7B%5Csigma_%7Bu%7D%5E%7B2%7D%7D%7B2%20%5Csum_%7Bi%7D%5E%7B%5Cmathrm%7Bnsnp%7D%7D%20p_%7Bi%7D%20q_%7Bi%7D%7D%0A" /></p><h2 id="SNP-BLUP">SNP-BLUP</h2>
<p>如果假设标记效应的先验分布为正态分布，即 <img src="https://math.now.sh?inline=a_%7Bi%7D%20%5Csim%20N%5Cleft%280%2C%20%5Csigma_%7Ba%7D%5E%7B2%7D%5Cright%29" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=p%28%5Cmathbf%7Ba%7D%29%3DM%20V%20N(%5Cmathbf%7B0%7D%2C%20%5Cmathbf%7BD%7D)%20%3B%20%5Coperatorname%7BVar%7D(%5Cmathbf%7Ba%7D)%3D%5Cmathbf%7BD%7D%3D%5Cmathbf%7BI%7D%20%5Csigma_%7Ba%20%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/>(即假设标记之间彼此独立)，此时我们假设绝大部分标记的效应均很小，这种方法我们称为 SNP-BLUP 方法 (等价于频率学派中的岭回归方法，<em>ridge regression</em> ，即在最小二乘中添加 <img src="https://math.now.sh?inline=%5Clambda%20%5Csum%20a_%7Bi%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 的惩罚项 ) 。此时绝大部分标记的效应在 0 附近，只有少量标记的效应可能比较大。</p>
<p>在假设标记效应的先验分布为正态分布的前提下，下面的三个方法实际内容相同：</p>
<ul>
<li>SNP-BLUP</li>
<li>GBLUP</li>
<li>ridge regression</li>
</ul>
<p>也就是说估计SNP效应的方法中的岭回归和SNP-BLUP，和构建基因组关系矩阵 (G阵) 来估计育种值的 GBLUP 方法，这三者其实是等价的。</p>
<p>SNP-BLUP 的估计值就是 BLUP 值，其混合模型方程组如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%20%5C%5C%0A%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BD%7D%5E%7B-1%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Chat%7B%5Cmathbf%7Bb%7D%7D%20%5C%5C%0A%5Chat%7B%5Cmathbf%7Ba%7D%7D%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D%20%3D%20%5Cmathbf%7BI%7D%20%5Csigma_%7Ba%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 。通常我们假设 <img src="https://math.now.sh?inline=%5Coperatorname%7BVar%7D%28%5Cmathbf%7Be%7D%29%3D%5Cmathbf%7BR%7D%3D%5Cmathbf%7BI%7D%20%5Csigma_%7Be%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，因此可以进一步简化为</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D%20%5C%5C%0A%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BI%7D%20%5Clambda%0A%5Cend%7Barray%7D%5Cright%29%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cwidehat%7B%5Cmathbf%7Bb%7D%7D%20%5C%5C%0A%5Cwidehat%7B%5Cmathbf%7Ba%7D%7D%0A%5Cend%7Barray%7D%5Cright)%3D%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Clambda%3D%5Csigma_%7Be%7D%5E%7B2%7D%20%2F%20%5Csigma_%7Ba%20%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 。这里的系数矩阵的行数或列数是<strong>固定效应数目+位点数目</strong>，与样本数目无关。第二，这里的系数矩阵是稠密的，因为 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 是稠密的（<img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 矩阵是由012编码或-101编码组成的）。</p>
<p>这里我们需要已知 <img src="https://math.now.sh?inline=%5Csigma_%7Be%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Csigma_%7Ba%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，我们有两种策略来得到这两个方差组分，最常用的方法是根据加性方差和先验的标记方差的关系，利用下面的公式得到  <img src="https://math.now.sh?inline=%5Csigma_%7Ba%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/></p>
<p style=""><img src="https://math.now.sh?from=%5Csigma_%7Ba%200%7D%5E%7B2%7D%3D%5Cfrac%7B%5Csigma_%7Bu%7D%5E%7B2%7D%7D%7B2%20%5Csum_%7Bi%7D%5E%7B%5Cmathrm%7Bnsnp%7D%7D%20p_%7Bi%7D%20q_%7Bi%7D%7D%0A" /></p><p>这里的  <img src="https://math.now.sh?inline=%5Csigma_%7Bu%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 是加性方差估计值，可以通过对系谱表型用REML方法估计得到；<img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> 是等位基因频率（注意，这里的等位基因频率必须是估计加性方差的群体的基因频率，比如<strong>系谱中的基础群体</strong>）。但是，我们直接用当前数据的基因频率 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> ，因此这里存在一些误差（虽然经常可以忽略）。至于残差方差  <img src="https://math.now.sh?inline=%5Csigma_%7Be%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，我们可以从之前的研究得到（应该是对系谱表型用REML方法估计得到的残差方差）。</p>
<p>第二种方法我们可以直接从标记数据中来估计方差组分，典型方法是 GREML 。</p>
<h2 id="贝叶斯回归方法简介">贝叶斯回归方法简介</h2>
<p>Bayes A 方法的先验分布为 <code>Scaled-t density</code>，见下式。相比于正态分布的先验分布， 这种方法的先验分布有两条”肥尾巴“，即认为效应很大的标记出现概率更大。</p>
<p style=""><img src="https://math.now.sh?from=p%5Cleft%28a_%7Bi%7D%20%5Cmid%20%5Csigma_%7Ba%200%7D%5E%7B2%7D%2C%20%5Cnu_%7Ba%7D%5Cright%29%3D%5Csigma_%7Ba%200%7D%20t%5Cleft(0%2C%20%5Cnu_%7Ba%7D%5Cright)%0A" /></p><p>Bayes B 方法在 Bayes A 方法的基础上进一步认为基因组上并没有很多 QTLs ，因此很多标记由于并不和 QTL 连锁，因此其效应为 0。即设定比例为 <img src="https://math.now.sh?inline=%5Cpi" style="display:inline-block;margin: 0;"/> 的位点的效应为0 ，其他位点的效应服从 <code>Scaled-t density</code> ， 即此时 <img src="https://math.now.sh?inline=a_%7Bi%7D%20%5Csim%20%5Cpi%280%29%2B(1-%5Cpi)%20t%5Cleft(0%2C%20v%2C%20%5Csigma_%7Ba%7D%5E%7B2%7D%5Cright)" style="display:inline-block;margin: 0;"/>  。</p>
<p>Bayes C(Pi) 方法认为比例为 <img src="https://math.now.sh?inline=%5Cpi" style="display:inline-block;margin: 0;"/> 的位点的效应为0 ，其他位点的效应服从正态分布，即 <img src="https://math.now.sh?inline=a_%7Bi%7D%20%5Csim%20%5Cpi%280%29%2B(1-%5Cpi)%20N%5Cleft(0%2C%20%5Csigma_%7Ba%7D%5E%7B2%7D%5Cright)" style="display:inline-block;margin: 0;"/> 。</p>
<p>Bayes Lasso 方法的先验分布为 <code>Double-Exponential</code> 分布，即 <img src="https://math.now.sh?inline=a_%7Bi%7D%20%5Csim%20%5Cfrac%7B%5Clambda%7D%7B2%7D%20%5Cexp%20%5Cleft%28-%5Clambda%5Cleft%7Ca_%7Bi%7D%5Cright%7C%5Cright%29" style="display:inline-block;margin: 0;"/>   (等价于频率学派中的Lasso方法，即在最小二乘中添加 <img src="https://math.now.sh?inline=%5Clambda%20%5Csum%20%7Ca_%7Bi%7D%7C" style="display:inline-block;margin: 0;"/> 的惩罚项 ) 。</p>
<p>不同方法的先验分布总结如下：</p>
<blockquote>
<ol>
<li>Normal distribution: Random regression BLUP (RR-BLUP), SNP-BLUP, GBLUP</li>
<li>Normal distribution with unknown variances: BayesC, GREML, GGibbs</li>
<li>Student (t) distribution : BayesA</li>
<li>Mixture of Student ( <img src="https://math.now.sh?inline=%5Cmathrm%7Bt%7D" style="display:inline-block;margin: 0;"/> ) distribution and spike at 0 : BayesB</li>
<li>Mixture of Normal distribution and spike at 0 : BayesCPi</li>
<li>Double exponential: Bayesian Lasso</li>
<li>Mixture of a large and small normal distribution: Stochastic Search Variable Selection (SSVS)</li>
</ol>
</blockquote>
<p>贝叶斯回归方法的缺点是计算缓慢。根据大量实验，假设标记效应的先验分布为正态分布是一个好的假设。</p>
<h1>参考文献</h1>
<ol>
<li><a href="http://nce.ads.uga.edu/wiki/lib/exe/fetch.php?media=gsip.pdf">http://nce.ads.uga.edu/wiki/lib/exe/fetch.php?media=gsip.pdf</a></li>
<li><a href="http://nce.ads.uga.edu/wiki/lib/exe/fetch.php?media=andres_part2.pdf">http://nce.ads.uga.edu/wiki/lib/exe/fetch.php?media=andres_part2.pdf</a></li>
<li>de Los Campos G, Hickey J M, Pong-Wong R, et al. Whole-genome regression and prediction methods applied to plant and animal breeding[J]. Genetics, 2013, 193(2): 327-345.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>GWAS分析中的多重校正方法</title>
    <url>/posts/3fef4efc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>根据一些资料，整理一下GWAS分析中可能用到的多重校正方法。</p>
<span id="more"></span>
<h1>多重比较问题</h1>
<p>首先我们看什么是多重比较问题，下面的内容来自于维基百科。</p>
<blockquote>
<p>当统计分析涉及多个同时进行的统计测试时，就会出现多重比较，每个测试都有可能产生相同数据集或相关数据集的“发现”。规定的置信水平通常仅适用于单独考虑的每个测试，但通常希望对整个系列的同时测试都有一个置信水平。未能对多重比较进行补偿可能会产生重要的现实后果，如以下示例所示：</p>
<ul>
<li>假设治疗是一种新的写作教学方式，而控制是写作教学的标准方式。两组学生可以在语法、拼写、组织、内容等方面进行比较。随着更多的属性被比较，处理组和控制组由于随机抽样误差而在至少一个属性上出现差异的可能性越来越大。</li>
<li>假设我们从减轻多种疾病症状中的任何一种来考虑药物的功效。随着更多症状被考虑，就至少一种症状而言，该药物似乎比现有药物有所改善的可能性越来越大。</li>
</ul>
<p>在这两个示例中，随着比较次数的增加，被比较的组更有可能在至少一个属性方面出现差异。如果将结果作为涉及多重比较的分析的一部分而不是仅涉及单一比较的分析进行观察，我们对结果将推广到独立数据的信心通常会减弱。 例如，如果在 5% 的水平上执行一项测试并且相应的原假设为真，则错误拒绝原假设的可能性只有 5%。但是，如果进行了 100 次测试并且所有相应的零假设都为真，则错误拒绝（也称为误报或 I 类错误）的预期数量为 5。如果测试在统计上彼此独立，则至少一个错误的拒绝是 <img src="https://math.now.sh?inline=1-0.95%5E%7B100%7D%20%3D%2099.4%5C%25" style="display:inline-block;margin: 0;"/> （当且仅当 <img src="https://math.now.sh?inline=P%28AB%29%3DP(A)P(B)" style="display:inline-block;margin: 0;"/> ，事件 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=B" style="display:inline-block;margin: 0;"/> 独立）。 请注意，多重比较问题当然不会出现在经验检验多个假设的每种情况下，无论是顺序还是并行（发）；粗略地说，每当在同一数据集（或不独立的数据集）上测试多个假设或在多个数据集中测试同一个假设时，就会出现多重比较问题。 多重比较问题也适用于置信区间。具有 95% 覆盖概率水平的单个置信区间将包含 95% 实验中的总体参数。但是，如果同时考虑 100 个置信区间，每个区间的覆盖概率为 95%，则非覆盖区间的预期数量为 5。如果区间在统计上彼此独立，则至少一个区间不包含总体的概率参数为 99.4%。 已经开发了一些技术来防止多重统计测试中出现的假阳性率和未覆盖率的膨胀。 - <a href="https://cn.wikiterhal.com/558787-multiple-testing-correction-IUCOPW">https://cn.wikiterhal.com/558787-multiple-testing-correction-IUCOPW</a></p>
</blockquote>
<p>简单地理解一下，假设你想比较的两个分组实际上没有区别（即来自于同一个总体），但是只要你比较的属性/水平足够多，你总能在某个属性/水平找到所谓的显著性差别。但是，此时实际上造成这种“显著性差别”的原因是<strong>抽样误差</strong>。</p>
<h1>多重校正标准</h1>
<h2 id="FWER">FWER</h2>
<p><strong>族错误率</strong> (Family-wise error rate, FWER) 指这多次检验中至少出现一次假阳性的概率，设 <img src="https://math.now.sh?inline=f" style="display:inline-block;margin: 0;"/> 为出现假阳性的次数，则有</p>
<p style=""><img src="https://math.now.sh?from=FWER%20%3D%20P%28f%20%5Cgeq%201%29%0A" /></p><h2 id="FDR">FDR</h2>
<p><strong>错误发现率</strong> (false discovery rate, FDR) 指在所有<strong>显著的检验</strong>中假阳性所占比例的期望，设 <img src="https://math.now.sh?inline=f" style="display:inline-block;margin: 0;"/> 为出现假阳性的次数，<img src="https://math.now.sh?inline=d" style="display:inline-block;margin: 0;"/> 为检验方法得到的显著性位点数目，则有</p>
<p style=""><img src="https://math.now.sh?from=FDR%20%3D%20E%28f%2Fd%29%0A" /></p><p>不同的多重校正方法都是通过控制整理的 FWER 或 FDR 低于给定水平，从而减少假阳性。可以证明，只要控制 <img src="https://math.now.sh?inline=%5Ctext%7BFWER%7D%20%5Cleq%20%5Calpha" style="display:inline-block;margin: 0;"/> ，就能保证  <img src="https://math.now.sh?inline=%5Ctext%7BFDR%7D%20%5Cleq%20%5Calpha" style="display:inline-block;margin: 0;"/> 。也就是说，基于 FWER 标准的方法比基于 FDR 标准的方法更加严格。</p>
<h1>GWAS的多重校正</h1>
<h2 id="多重检验问题">多重检验问题</h2>
<p>GWAS 分析中，我们是逐个SNP进行检验，假设SNP数目为 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> ，那么我们就做了 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 次检验。假设其中真正与性状有关联的 SNP 数目为 <img src="https://math.now.sh?inline=a%20%5Cll%20n" style="display:inline-block;margin: 0;"/>  ， 每次检验显著性水平我们定为 <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/> ，那么在 <img src="https://math.now.sh?inline=n-a" style="display:inline-block;margin: 0;"/> 个无关联位点的检验中 (原假设为真) 出现假阳性的次数为 <img src="https://math.now.sh?inline=%5Calpha%20%5Ctimes%20%28n-a%29" style="display:inline-block;margin: 0;"/> ，约等于 <img src="https://math.now.sh?inline=%5Calpha%20n" style="display:inline-block;margin: 0;"/> 。比如假设总位点数目为 100 万，<img src="https://math.now.sh?inline=%5Calpha%20%3D%200.05" style="display:inline-block;margin: 0;"/> ，那么出现假阳性的位点数目约为 5 万，很显然这是不可接受的。这就是GWAS研究中的多重检验问题。为了解决这一问题，提出了以下几种方法。</p>
<h2 id="Bonferroni-校正法">Bonferroni 校正法</h2>
<p>首先，Bonferroni 校正是一种基于 FWER 标准的方法。假设真正关联的 SNP 的集合为 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> ，所有 SNP 的集合为 <img src="https://math.now.sh?inline=B" style="display:inline-block;margin: 0;"/> ，其中某个位点 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 出现假阳性的事件为 <img src="https://math.now.sh?inline=B_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，基于事件集合，FWER 可以写为</p>
<p style=""><img src="https://math.now.sh?from=F%20W%20E%20R%3DP%5Cleft%28%5Cbigcup_%7BB_%7Bi%7D%20%5Cnotin%20A%7D%20B_%7Bi%7D%5Cright%29%0A" /></p><p>根据 Bonferroni 不等式，我们有</p>
<p style=""><img src="https://math.now.sh?from=P%5Cleft%28%5Cbigcup_%7BB_%7Bi%7D%20%5Cnotin%20A%7D%20B_%7Bi%7D%5Cright%29%20%5Cleqslant%20%5Csum_%7BB_%7Bi%7D%20%5Cnotin%20A%7D%20P(B_%7Bi%7D)%0A" /></p><p>这个不等式可以根据 <img src="https://math.now.sh?inline=P%28A%20%5Ccup%20B%29%3DP(A)%2BP(B)-P(A%20%5Ccap%20B)" style="display:inline-block;margin: 0;"/> 来证明。</p>
<p>可以得出，只要把单次检验的显著性水平设为 <img src="https://math.now.sh?inline=%5Calpha%2Fn" style="display:inline-block;margin: 0;"/> ，就可以使得整体检验的 <img src="https://math.now.sh?inline=%5Cmathrm%7BFWER%7D%20%5Cleq%28%5Cmathrm%7Bn%7D-%5Cmathrm%7Ba%7D%29%20%5Calpha%20%2F%20%5Cmathrm%7Bn%7D%20%3C%20%5Calpha" style="display:inline-block;margin: 0;"/> 。因此该方法只需要将单次检验的显著性水平设为  <img src="https://math.now.sh?inline=%5Calpha%2Fn" style="display:inline-block;margin: 0;"/> ，就能控制整体检验出现假阳性的概率低于 <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/> 。</p>
<p>Bonferroni 校正是最严格的多重校正方法，由于不同的位点间存在连锁不平衡 (LD)，即很多位点之间不是独立的，因此Bonferroni 校正可能过于保守，导致出现假阴性的概率增加。</p>
<h2 id="置换检验法">置换检验法</h2>
<p><strong>置换检验法</strong> (Permutation test) 也采用 FWER 标准，不同的是，它可以很好的处理不同检验之间存在的相关。置换检验法是Fisher于20世纪30年代提出的一种基于大量计算（computationally intensive），利用样本数据的全（或随机）排列，进行统计推断的方法，因其对总体分布自由，应用较为广泛，特别适用于总体分布未知的小样本资料，以及某些难以用常规方法分析资料的假设检验问题。</p>
<p>在GWAS分析中，由于不同的位点间存在连锁不平衡 (LD)，使得等效的独立SNP数目低于位点总数 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> ，置换检验法可以给出一个控制假阳性的合理的标准。其做法是将基因型和表型的对应关系随机打乱，<strong>我们认为随机打乱之后的基因型和表型之间不存在关联，也就是说此时所有的SNP均满足零假设</strong>。然后我们用打乱后的数据做GWAS，每次记录下最小的 P 值。重复此过程多次，比如1000次，我们就得到了原假设成立下最小 P 值的一个经验分布。如果我们将这些最小P值从小到大排序，如果我们选择显著性水平α=0.05，则将排序P值的0.05分位数作为校正后的显著性水平。这里用的最小 P 值也可换成最大统计量。</p>
<p>我们来直观解释一下其中的原理，FWER 标准是至少出现一次假阳性的概率，等价于零假设成立下至少有一个位点的 P 值小于校正后的显著性水平的概率，进而等价于零假设成立下最小 P 值小于校正后的显著性水平的概率。当我们将上面例子中 1000 次抽样排序P值的0.05分位数作为校正后的显著性水平时，此时 FWER ，即零假设成立下最小 P 值小于校正后的显著性水平的概率就是 0.05 ，满足要求。</p>
<p>置换检验法的每次随机打乱的过程中考虑到了 SNP 之间的连锁不平衡关系，因此相比于Bonferroni 校正可能更符合实际情况，其最主要的问题是计算量太大，短时间内几乎不可能实现。</p>
<h2 id="FDR-的-BH-法">FDR 的 BH 法</h2>
<p>FDR 标准下最常用的方法就是 BH 法，其原理如下。</p>
<p>我们先将所有 SNPs 检验的 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> 值从小到大排列,  假设我们找到的显著位点数目为 <img src="https://math.now.sh?inline=d" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=p_%7B%5Cmathrm%7Bd%7D%7D" style="display:inline-block;margin: 0;"/> 表示最后一个显著的 SNP 的 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> 值 。设 FDR 下的显著水平为 <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/>,  因为报告显著的 SNPs 有 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D" style="display:inline-block;margin: 0;"/> 个, 所以按 FDR 标准, 允许错误发现的 SNPs 个数为 <img src="https://math.now.sh?inline=%5Calpha%20%5Ctimes%20%5Cmathrm%7Bd%7D" style="display:inline-block;margin: 0;"/> ，而此时理论上假阳性的位点数目约等于 <img src="https://math.now.sh?inline=%5Cmathrm%7Bn%7D%20%5Ctimes%20p_%7B%5Cmathrm%7Bd%7D%7D" style="display:inline-block;margin: 0;"/>  (实际为  <img src="https://math.now.sh?inline=%5Cmathrm%7B%28n-a%29%7D%20%5Ctimes%20p_%7B%5Cmathrm%7Bd%7D%7D" style="display:inline-block;margin: 0;"/>)。为了把假阳性数目控制在允许错误发现数以内, 即 <img src="https://math.now.sh?inline=%5Cmathrm%7Bn%7D%20%5Ctimes%20p_%7B%5Cmathrm%7Bd%7D%7D%20%5Cleq%20%5Calpha%20%5Ctimes%20%5Cmathrm%7B~d%7D" style="display:inline-block;margin: 0;"/>,  等价于把 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> 值校正为 <img src="https://math.now.sh?inline=%28%5Cmathrm%7Bn%7D%20%2F%20%5Cmathrm%7Bd%7D%29%20%5Ctimes%20p_%7B%5Cmathrm%7Bd%7D%7D" style="display:inline-block;margin: 0;"/>, 再和 <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/> 比较。 <img src="https://math.now.sh?inline=%5Cmathrm%7BBH%7D" style="display:inline-block;margin: 0;"/> 法就是确定 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D" style="display:inline-block;margin: 0;"/> 的过程，具体步骤如下：</p>
<ol>
<li>把 <img src="https://math.now.sh?inline=%5Cmathrm%7Bn%7D" style="display:inline-block;margin: 0;"/> 个 SNPs 的 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> 值按从小到大排列;</li>
<li>把排在第 1 的 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> 值乘以 <img src="https://math.now.sh?inline=%5Cmathrm%7Bn%7D" style="display:inline-block;margin: 0;"/>, 排在第 <img src="https://math.now.sh?inline=%5Cmathrm%7Bi%7D" style="display:inline-block;margin: 0;"/> 的 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> 值 乘以 <img src="https://math.now.sh?inline=%5Cmathrm%7Bn%7D%20%2F%20%5Cmathrm%7Bi%7D" style="display:inline-block;margin: 0;"/>, 依次类推, 排在最后的 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> 值乘以 <img src="https://math.now.sh?inline=%5Cmathrm%7Bn%7D%20%2F%20%5Cmathrm%7Bn%7D" style="display:inline-block;margin: 0;"/>, 得到校正后的  <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> 值 (有人也称为 <img src="https://math.now.sh?inline=q" style="display:inline-block;margin: 0;"/> 值)</li>
<li>从排在最后的 SNP 开始, 按从后往前的顺序, 首次发现校正后 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> 值小于 <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/> 的 SNP (设序号为 d)后, 报告序号为 1 到 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D" style="display:inline-block;margin: 0;"/> 的 SNPs 显著。</li>
</ol>
<p>我们可以简单证明一下，BH 法比Bonferroni 校正法要宽松，也就是上面说的基于 FDR 标准的方法比基于  FWER 标准的方法更加宽松。Bonferroni 校正法的判定标准是 <img src="https://math.now.sh?inline=p%20%3C%20%5Calpha%2Fn" style="display:inline-block;margin: 0;"/> ，即 <img src="https://math.now.sh?inline=np%20%3C%20%5Calpha" style="display:inline-block;margin: 0;"/> ，我们可以理解为其校正后的 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/>  值为 <img src="https://math.now.sh?inline=np" style="display:inline-block;margin: 0;"/> ，而 BH 法的校正后的 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/>  值为 <img src="https://math.now.sh?inline=np%2Fd%20%5Cleq%20%5Calpha" style="display:inline-block;margin: 0;"/> ，因此 BH 法得到的校正后的  <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/>  值更小，得到的显著位点数目只会更多，即该方法比Bonferroni 校正法宽松。</p>
<h1>参考文献</h1>
<ol>
<li>
<p>BENJAMINI, 1995, Controlling the False Discovery Rate: a Practical and Powerful Approach to Multiple Testing</p>
</li>
<li>
<p>黄杨岳，2013，全基因组关联研究中的多重校正方法比较</p>
</li>
<li>
<p>[<a href="https://www.cnblogs.com/Dzhouqi/p/3440902.html">Permutation Test 置换检验(转）</a>](<a href="https://www.cnblogs.com/Dzhouqi/p/3440902.html">https://www.cnblogs.com/Dzhouqi/p/3440902.html</a>)</p>
</li>
<li>
<p><a href="http://blog.sina.com.cn/s/blog_14cce7aed0102vqsq.html">GWAS中的多重假设检验</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>TOP与BOT链的划分</title>
    <url>/posts/de96141/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>材料来自于<a href="https://www.illumina.com/documents/products/technotes/technote_topbot.pdf">technote_topbot</a> 。</p>
<span id="more"></span>
<p>这种划分DNA链的方式是 Illumina 提出的，其说法是可以使得在不同的基因组版本中的同一位点的链划分方式相同。</p>
<h1>无歧义情况</h1>
<p>当 SNP 的某一个碱基为 A ，另一个碱基是 G / C 时，此时我们称这个 SNP 所处的链为 TOP 链，碱基 A 称为  <code>Allele A</code>，碱基 C/G 称为 <code>Allele B</code> 。</p>
<p>相似地，当 SNP 的某一个碱基为 T ，另一个碱基是 G / C 时，此时我们称这个 SNP 所处的链为 BOT 链，碱基 T 称为  <code>Allele A</code>，碱基 C/G 称为 <code>Allele B</code> 。</p>
<p>总之，这里就是 A 和 T 分别是 TOP 链和  BOT 链的    <code>Allele A</code> ，而 碱基 C/G 是   <code>Allele B</code>  。</p>
<h1>有歧义情况</h1>
<p>如果 SNP 的两个碱基是 [A/T] 或者 [C/G] ，此时我们要看 SNP 附近的位点。我们 SNP 所处的位置是 n ，其前一个和后一个位置则是 n-1 和 n+1 ，我们将这两个位置的碱基组成一个配对；类似地，n-2 和 n+2 位置的两个碱基组成一个配对，以此类推，如下图所示</p>
<p><img src="1.png" alt="1"></p>
<p>采用这种方式，我们从SNP所在位置先两边依次延续，直到出现第一个无歧义的配对（某个碱基是 A/T ，另一个碱基是 G/C）。比如在上图中， n-1 和 n+1 所在位置的配对就是无歧义的配对。</p>
<p>我们进一步看第一个无歧义的配对，如果 A 或者 T 碱基出现在 5’ 端，那么此时我们称该 SNP 所处的链为 TOP 链；如果 A 或者 T 碱基出现在 3’ 端，那么此时我们称该 SNP 所处的链为 BOT 链。</p>
<p>然后确认SNP 的两个碱基哪一个是   <code>Allele A</code> ，哪一个是   <code>Allele B</code> 。当 SNP 是 [A/T] 突变，如果我们确实 SNP 所在链为 TOP 链，那么此时 A 是   <code>Allele A</code>  ，T 是    <code>Allele B</code> ；  如果我们确实 SNP 所在链为 BOT 链，那么此时 T 是   <code>Allele A</code>  ，A 是    <code>Allele B</code> 。</p>
<p>当 SNP 是 [C/G] 突变，如果我们确实 SNP 所在链为 TOP 链，那么此时 C 是   <code>Allele A</code>  ，G 是    <code>Allele B</code> ；  如果我们确实 SNP 所在链为 BOT 链，那么此时 G 是   <code>Allele A</code>  ，C 是    <code>Allele B</code> 。</p>
<p>举例见下表</p>
<p><img src="2.png" alt="1"></p>
<h1>实际例子</h1>
<p>下表中， SNP1 有两次基因组的组装版本，然而这两个版本提供的序列正好是互补的，这种情况并不罕见（注意互补应该是一条链是 5’ 到 3‘ ，一条链是 3’ 到 5’ 方向，然后才有相同位置的碱基互补。下表中的序列应该都是 5’ 到 3’ 方向，所以是 Assembly1 的最后一个碱基和  Assembly2 的第一个碱基互补，其余同理）。</p>
<p>我们看到此时两个组装版本中的 SNP1 正好一个是 TOP 链，一个是 BOT 链，即满足互补关系；同时    <code>Allele A</code>  和    <code>Allele B</code> 的划分保持一致。SNP2 同理。</p>
<p><img src="3.png" alt="1"></p>
<h1>个人理解</h1>
<p>这种划分链的方式纯粹是按照 SNP 及其临近位置的分型来划分的，唯一的好处就是理论上不随参考基因组的变化而变化。也就是说，如果对多个基因组版本的共同位点的 TOP 链的基因型数据理论上可以进行直接合并，而不会因为互补链的问题而报错。</p>
<p>问题在于，第一是和参考基因组的 FORWARD/REVERSE 链划分方式不同，那么就和对应的参考基因组不同 (如互补)；第二是这种 TOP/BOT 链的划分方式实际上是每个 SNP 特异的，即在同一条染色体均认为处在 TOP 链上的两个 SNP 根本不一定在一条 DNA 链上。</p>
<p>其实第二点还是在说 TOP/BOT 和  FORWARD/REVERSE 划分方式不同，因为 FORWARD/REVERSE 从理论上是真的把 DNA 双链一条命名为  FORWARD 链，一条命名为  REVERSE  链。</p>
<p>从个人角度出发，我还是比较认可 FORWARD/REVERSE 的划分方式，首先就是和对应的参考基因组保持一致，方便一些需要用到参考基因组的操作；第二就是规则简单，具有明确的含义（即我们认为在同一条 DNA 链上）。最后就是不同参考基因组版本的互补链问题，这一点还是比较容易发现，手动转换一下也不困难，比如采用 PLINK 的 <code>--flip</code> 选项。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>生物信息</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>生物信息</tag>
      </tags>
  </entry>
  <entry>
    <title>近交系数及A逆的计算</title>
    <url>/posts/ea64e7f3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在利用混合模型方程组估计育种值时，需要得到个体间的加性遗传相关矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的逆矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> ，虽然我们可以先构建  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵再求逆，但是这在观测值数目很多时计算是非常困难甚至是不可实现的，因而 Henderson 又提出了一种通过系谱直接构建  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> 的方法。</p>
<span id="more"></span>
<h1>近交系数</h1>
<h2 id="近交系数的一般公式">近交系数的一般公式</h2>
<p>近交系数是个体任一基因座的两个等位基因<strong>同源相同</strong> (identical by descent, IBD) 的概率。</p>
<p>举例如下图，X 是半同胞 S, D 间交配所生的近交个体，我们要考虑其近交系数 <img src="https://math.now.sh?inline=F_%7BX%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p><img src="1.png" alt=""></p>
<p>显然，S, D 仅仅因为共同祖先 A 而相关。因此，我们只需要考虑 A 的基因通过 S，D 传递给 X 的问题。<strong>假设 A 不是近交个体</strong>，令 <img src="https://math.now.sh?inline=A_%7B1%7D" style="display:inline-block;margin: 0;"/>  和 <img src="https://math.now.sh?inline=A_%7B2%7D" style="display:inline-block;margin: 0;"/> 表示 A 的任一基因座上的两个等位基因，则 <img src="https://math.now.sh?inline=A_%7B1%7D" style="display:inline-block;margin: 0;"/>  和 <img src="https://math.now.sh?inline=A_%7B2%7D" style="display:inline-block;margin: 0;"/>  同源相同的概率为 0。根据通径分析，则 X 的基因型为 <img src="https://math.now.sh?inline=A_%7B1%7DA_%7B1%7D" style="display:inline-block;margin: 0;"/> 的概率是 <img src="https://math.now.sh?inline=%28%5Cfrac%7B1%7D%7B2%7D%29%5E%7B4%7D%20%3D%20%5Cfrac%7B1%7D%7B16%7D" style="display:inline-block;margin: 0;"/>   ；同样地，X 的基因型为 <img src="https://math.now.sh?inline=A_%7B2%7DA_%7B2%7D" style="display:inline-block;margin: 0;"/> 的概率是 <img src="https://math.now.sh?inline=%28%5Cfrac%7B1%7D%7B2%7D%29%5E%7B4%7D%20%3D%20%5Cfrac%7B1%7D%7B16%7D" style="display:inline-block;margin: 0;"/>  。因此 X 为 <img src="https://math.now.sh?inline=A_%7B1%7DA_%7B1%7D" style="display:inline-block;margin: 0;"/> 或 <img src="https://math.now.sh?inline=A_%7B2%7DA_%7B2%7D" style="display:inline-block;margin: 0;"/> 的概率是 <img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7B8%7D" style="display:inline-block;margin: 0;"/> ，此时这就是  X 的近交系数。 <strong>假设 A 是近交个体</strong>，其近交系数为 <img src="https://math.now.sh?inline=F_%7BA%7D" style="display:inline-block;margin: 0;"/> ，即 <img src="https://math.now.sh?inline=A_%7B1%7D" style="display:inline-block;margin: 0;"/>  和 <img src="https://math.now.sh?inline=A_%7B2%7D" style="display:inline-block;margin: 0;"/>  同源相同的概率为  <img src="https://math.now.sh?inline=F_%7BA%7D" style="display:inline-block;margin: 0;"/>。那么即使 X 的基因型 为 <img src="https://math.now.sh?inline=A_%7B1%7DA_%7B2%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=A_%7B2%7DA_%7B1%7D" style="display:inline-block;margin: 0;"/> (区分父母的基因)，也有一定概率是同源相同的。 X 的基因型 为 <img src="https://math.now.sh?inline=A_%7B1%7DA_%7B2%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=A_%7B2%7DA_%7B1%7D" style="display:inline-block;margin: 0;"/> 的概率也是 <img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7B16%7D" style="display:inline-block;margin: 0;"/> ，因此出现任意一种基因型的概率为 <img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7B8%7D" style="display:inline-block;margin: 0;"/> ，此时因为  <img src="https://math.now.sh?inline=A_%7B1%7D" style="display:inline-block;margin: 0;"/>  和 <img src="https://math.now.sh?inline=A_%7B2%7D" style="display:inline-block;margin: 0;"/>  同源相同而新增的近交系数概率为 <img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7B8%7D%20F_%7BA%7D" style="display:inline-block;margin: 0;"/> ，将这两部分加在一起得到 X 的近交系数为</p>
<p style=""><img src="https://math.now.sh?from=F_%7BX%7D%20%3D%20%28%5Cfrac%7B1%7D%7B2%7D%29%5E%7B3%7D%20%2B%20(%5Cfrac%7B1%7D%7B2%7D)%5E%7B3%7D%20F_%7BA%7D%20%3D%20(%5Cfrac%7B1%7D%7B2%7D)%5E%7B3%7D(1%2BF_%7BA%7D)%0A" /></p><p>如果个体更加复杂，个体的两个亲本之间可能有更多通径，易得个体近交系数的一般公式为：</p>
<p style=""><img src="https://math.now.sh?from=F_%7BX%7D%20%3D%20%5Csum%20%28%5Cfrac%7B1%7D%7B2%7D%29%5E%7BN%7D%20(1%2BF_%7BA%7D)%20%3D%20%5Csum%20(%5Cfrac%7B1%7D%7B2%7D)%5E%7Bn_%7B1%7D%2Bn_%7B2%7D%2B1%7D%20(1%2BF_%7BA%7D)%0A" /></p><p>其中，N 为亲本相关通径链中的个体数，包括亲本、共同祖先以及通径链中的其他所有个体。<img src="https://math.now.sh?inline=n_%7B1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=n_2" style="display:inline-block;margin: 0;"/> 分别表示一个通径中个体的父亲和母亲到它们的共同祖先 A 的世代数。在上面的例子中，<img src="https://math.now.sh?inline=n_%7B1%7D%20%3D%20n_%7B2%7D%20%3D%201" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=N%20%3D%203" style="display:inline-block;margin: 0;"/> 。</p>
<p>这种根据通径计算近交系数的方式比较麻烦，下面介绍另一种方法。</p>
<h2 id="共亲系数">共亲系数</h2>
<p>共亲系数 (<em>coefficient of kinship</em>)，有时也称为共祖系数 (<em>coefficient of coancestry</em>) ，定义为二者交配所生后代的近交系数，是两个个体所产生的配子中，各随机抽取一个所携带的基因同源相同的概率。</p>
<p>假设我们要考虑的两个个体为 P 和 Q，个体 P 的任一基因座的两个基因是 a 和 b ，个体 Q 的同一基因座的两个等位基因是 c 和 d ，而 P(a=b) 表示两个基因同源相同的概率，于是 P 和 Q 的共亲系数为</p>
<p style=""><img src="https://math.now.sh?from=C_%7BPQ%7D%20%3D%20%5Cfrac%7B1%7D%7B4%7D%5BP%28a%3Dc%29%2BP(a%3Dd)%2BP(b%3Dc)%2BP(b%3Dd)%5D%0A" /></p><p>假设 P 的两个亲本为 S 和 T，Q 的两个亲本为 V 和 W，容易证明，两个个体的共亲系数等于这两个个体各自父母的共亲系数的平均，也等于一个个体与另外一个个体亲本的共亲系数的平均，即：</p>
<p style=""><img src="https://math.now.sh?from=%20C_%7BPQ%7D%20%3D%20%5Cfrac%7B1%7D%7B4%7D%28C_%7BSV%7D%2BC_%7BSW%7D%2BC_%7BTV%7D%2BC_%7BTW%7D%29%20%5C%5C%0A%20%20C_%7BPQ%7D%20%3D%20%5Cfrac%7B1%7D%7B2%7D(C_%7BPV%7D%2BC_%7BPW%7D)%0A" /></p><p>从逻辑上简单证明如下，首先我们看第一个式子，我们知道 P 的基因均来自于 S 和 T，从 P 的任一基因座随机提取一个基因，等同于从  S 和 T 同一基因座的四个基因中随机提取一个基因，个体 Q 同理。因此从P 和 Q 这两个个体所产生的配子中，各随机抽取一个所携带的基因同源相同的概率 ，等同于从 S  和 T 的四个基因抽取一个基因，及从V 和 W 的四个基因抽取一个基因，这两个基因同源相同的概率，易得其等于上式。同理可得第二个式子。</p>
<p>这里有一个特殊情况，即个体与其自身的共亲系数。根据定义，它应等于个体任意一个随机基因与该个体的另一个随机抽取的基因同源相同的概率。一个基因与其自身同源相同的概率为1，而与该位点上另一个基因同源相同的概率为 F ，即近交系数。两个概率的平均值为个体与其自身的共亲系数，即：</p>
<p style=""><img src="https://math.now.sh?from=C_%7BXX%7D%20%3D%20%5Cfrac%7B1%7D%7B2%7D%281%2BF_%7BX%7D%29%0A" /></p><p>据此，又有：</p>
<p style=""><img src="https://math.now.sh?from=F_%7BX%7D%20%3D%202C_%7BXX%7D%20-%201%0A" /></p><p>根据共亲系数，我们可以很容易地计算一个小群体内各个个体的近交系数。我们将个体按照出生前后排列起来（可以将各个体的父母标在各个体上方），按照以下公式依次计算共亲系数：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AF_%7BX%7D%20%26%3DC_%7BX_%7Bs%7D%20X_%7Bd%7D%7D%20%5C%5C%0AC_%7BX%20X%7D%20%26%3D%5Cfrac%7B1%7D%7B2%7D%5Cleft%281%2BF_%7BX%7D%5Cright%29%20%5C%5C%0AC_%7BX%20Y%7D%3DC_%7BY%20X%7D%3D%5Cfrac%7B1%7D%7B2%7D%5Cleft(C_%7BX%20Y_%7Bs%7D%7D%2BC_%7BX%20Y_%7Bd%7D%7D%5Cright)%20%26%3D%5Cfrac%7B1%7D%7B4%7D%5Cleft(C_%7BX_%7Bs%7D%20Y_%7Bs%7D%7D%2BC_%7BX_%7Bs%7D%20Y_%7Bd%7D%7D%2BC_%7BX_%7Bd%7D%20Y_%7Bs%7D%7D%2BC_%7BX_%7Bd%7D%20Y_%7Bd%7D%7D%5Cright)%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>我们可以得到下面的共亲系数矩阵</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cbegin%7Barray%7D%7Bc%7Cc%7Cc%7Cc%7Cc%7Cc%7Cc%7Cc%7Cc%7Cc%7D%0A%5Chline%20%26%20%26%20%5Cmathrm%7BI%7D%20%26%20%5Cmathrm%7BI%7D%20%26%20%5Cmathrm%7BHG%7D%20%26%20%5Cmathrm%7BGE%7D%20%26%20%5Cmathrm%7BE%7D%20%26%20%5Cmathrm%7BE%7D%20%26%20%5Cmathrm%7BDC%7D%20%26%20%5Cmathrm%7BBA%7D%20%5C%5C%0A%26%20%5Cmathrm%7BI%7D%20%26%20%5Cmathrm%7BH%7D%20%26%20%5Cmathrm%7BG%7D%20%26%20%5Cmathrm%7BE%7D%20%26%20%5Cmathrm%7BD%7D%20%26%20%5Cmathrm%7BC%7D%20%26%20%5Cmathrm%7BB%7D%20%26%20%5Cmathrm%7BA%7D%20%26%20%5Cmathrm%7BX%7D%20%5C%5C%0A%5Chline%20%5Cmathrm%7BI%7D%20%26%201%20%2F%202%20%26%201%20%2F%204%20%26%201%20%2F%204%20%26%201%20%2F%204%20%26%201%20%2F%204%20%26%201%20%2F%208%20%26%201%20%2F%208%20%26%203%20%2F%2016%20%26%205%20%2F%2032%20%5C%5C%0A%5Cmathrm%7BH%7D%20%26%20%26%201%20%2F%202%20%26%201%20%2F%208%20%26%205%20%2F%2016%20%26%207%20%2F%2032%20%26%205%20%2F%2032%20%26%205%20%2F%2032%20%26%206%20%2F%2032%20%26%2011%20%2F%2064%20%5C%5C%0A%5Cmathrm%7BG%7D%20%26%20%26%20%26%201%20%2F%202%20%26%205%20%2F%2016%20%26%2013%20%2F%2032%20%26%205%20%2F%2032%20%26%205%20%2F%2032%20%26%209%20%2F%2032%20%26%207%20%2F%2032%20%5C%5C%0A%5Cmathrm%7BE%7D%20%26%20%26%20%26%20%26%209%20%2F%2016%20%26%2014%20%2F%2032%20%26%209%20%2F%2032%20%26%209%20%2F%2032%20%26%2023%20%2F%2064%20%26%2041%20%2F%20128%20%5C%5C%0A%5Cmathrm%7BD%7D%20%26%20%26%20%26%20%26%20%26%2021%20%2F%2032%20%26%207%20%2F%2032%20%26%207%20%2F%2032%20%26%207%20%2F%2016%20%26%2021%20%2F%2064%20%5C%5C%0A%5Cmathrm%7BC%7D%20%26%20%26%20%26%20%26%20%26%20%26%201%20%2F%202%20%26%209%20%2F%2064%20%26%2023%20%2F%2064%20%26%201%20%2F%204%20%5C%5C%0A%5Cmathrm%7B~B%7D%20%26%20%26%20%26%20%26%20%26%20%26%20%26%201%20%2F%202%20%26%2023%20%2F%20128%20%26%2087%20%2F%20256%20%5C%5C%0A%5Cmathrm%7B~A%7D%20%26%20%26%20%26%20%26%20%26%20%26%20%26%20%26%2039%20%2F%2064%20%26%20101%20%2F%20256%20%5C%5C%0A%5Cmathrm%7BX%7D%20%26%20%26%20%26%20%26%20%26%20%26%20%26%20%26%20%26%20151%20%2F%20256%20%5C%5C%0A%5Chline%0A%5Cend%7Barray%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>最后根据公式 <img src="https://math.now.sh?inline=F_%7BX%7D%20%3D2%20C_%7BX%20X%7D-1" style="display:inline-block;margin: 0;"/> ，得到所有个体的近交系数。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0AF_%7B%5Cmathrm%7BI%7D%7D%3DF_%7B%5Cmathrm%7BH%7D%7D%3DF_%7B%5Cmathrm%7BG%7D%7D%3DF_%7B%5Cmathrm%7BC%7D%7D%3DF_%7B%5Cmathrm%7BB%7D%7D%3D0%20%5C%5C%0AF_%7B%5Cmathrm%7BE%7D%7D%3D1%20%2F%208%20%5Cquad%20F_%7B%5Cmathrm%7BD%7D%7D%3D5%20%2F%2016%20%5Cquad%20F_%7B%5Cmathrm%7BA%7D%7D%3D7%20%2F%2032%20%5Cquad%20F_%7B%5Cmathrm%7BX%7D%7D%3D23%20%2F%20128%0A%5Cend%7Bgathered%7D%0A" /></p><h2 id="加性遗传相关">加性遗传相关</h2>
<p>个体 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 和 个体 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 之间的加性遗传相关是指在它们的基因组中具有<strong>同源相同</strong> (identical by descent, IBD) 基因 (相同的且来自同一祖先的基因)<strong>的比例</strong>，或者说从个体 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 的基因组中随机抽取的一个基因在个体 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 的基因组中也存在的概率。</p>
<p>采用上面的例子，假设我们要考虑的两个个体为 P 和 Q，个体 P 的任一基因座的两个基因是 a 和 b ，个体 Q 的同一基因座的两个等位基因是 c 和 d，那么这两个个体的加性遗传相关为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Aa_%7BPQ%7D%20%26%3D%20%5Cfrac%7B1%7D%7B2%7D%5Cleft%28%20P%5Cleft(a%20%5Ctext%7B%20in%20%7D%20%5C%7Bc%2Cd%5C%7D%5Cright%29%20%2B%20%20P%5Cleft(b%20%5Ctext%7B%20in%20%7D%20%5C%7Bc%2Cd%5C%7D%5Cright)%20%5Cright)%20%5C%5C%0A%26%3D%20%5Cfrac%7B1%7D%7B2%7D%5BP(a%3Dc)%2BP(a%3Dd)%2BP(b%3Dc)%2BP(b%3Dd)%5D%20%5C%5C%0A%26%3D2%20C_%7BPQ%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，<strong>加性遗传相关等于共亲系数的两倍</strong>。根据上面共亲系数的公式，我们有</p>
<p style=""><img src="https://math.now.sh?from=F_%7B%5Cmathrm%7BX%7D%7D%3D%5Cfrac%7B1%7D%7B2%7D%20a_%7B%5Cmathrm%7Bx%7D_%7B%5Cmathrm%7Bs%7D%7D%20%5Cmathrm%7Bx%7D_%7B%5Cmathrm%7Bd%7D%7D%7D%20%5Cquad%20a_%7B%5Cmathrm%7Bxx%7D%7D%3D1%2BF_%7B%5Cmathrm%7Bx%7D%7D%20%5Cquad%20a_%7B%5Cmathrm%7Bxy%7D%7D%3Da_%7B%5Cmathrm%7Byx%7D%7D%3D%5Cfrac%7B1%7D%7B2%7D%5Cleft%28a_%7B%5Cmathrm%7Bxy%7D_%7B%5Cmathrm%7Bs%7D%7D%7D%2Ba_%7B%5Cmathrm%7Bxy%7D_%7B%5Cmathrm%7Bd%7D%7D%7D%5Cright%29%20%5Cquad%0A" /></p><p>加性遗传相关恰好是 Wright(1922) 所定义的<strong>亲缘系数</strong> (coefficient of relationship) 计算公式中的分子，故又称其为<strong>分子亲缘相关</strong> (numerator relationship)。</p>
<p>任意两个个体 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 的加性遗传相关的计算通式为：</p>
<p style=""><img src="https://math.now.sh?from=a_%7Bij%7D%20%3D%20%5Csum%20%28%5Cfrac%7B1%7D%7B2%7D%29%5E%7Bn_%7Bi%7D%2Bn_%7Bj%7D%7D%20(1%2Bf_%7BA%7D)%0A" /></p><p>其中，<img src="https://math.now.sh?inline=n_%7Bi%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=n_j" style="display:inline-block;margin: 0;"/> 分别表示连接个体 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/>  和个体 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 的一个通径中由 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 到它们的共同祖先 A 的世代数；<img src="https://math.now.sh?inline=f_%7BA%7D" style="display:inline-block;margin: 0;"/> 为 A 的近交系数；<img src="https://math.now.sh?inline=%5Csum" style="display:inline-block;margin: 0;"/> 表示当连接个体 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 和 个体 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 的通径不止一个时，要对所有的通径求和。</p>
<p>加性遗传相关也可以理解为个体 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 的育种值 (加性遗传值) 之间的相关 (故而称之为加性遗传相关)，于是有</p>
<p style=""><img src="https://math.now.sh?from=a_%7BX%20Y%7D%3D%5Cfrac%7B%5Coperatorname%7BCov%7D%5Cleft%28A_%7BX%7D%2C%20A_%7BY%7D%5Cright%29%7D%7B%5Csigma_%7BA_%7BX%7D%7D%20%5Csigma_%7BA_%7BY%7D%7D%7D%0A" /></p><p>如果 X 和 Y 在同一群体，则 <img src="https://math.now.sh?inline=%5Csigma_%7BA_%7BX%7D%7D%20%3D%20%5Csigma_%7BA_%7BY%7D%7D%20%3D%20%5Csigma_%7BA%7D" style="display:inline-block;margin: 0;"/> ，于是有</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BCov%7D%5Cleft%28A_%7BX%7D%2C%20A_%7BY%7D%5Cright%29%3Da_%7BX%20Y%7D%20%5Csigma_%7BA%7D%5E%7B2%7D%0A" /></p><p>对于一个有 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个个体的群体，它们之间的育种值的协方差矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BVar%7D%28%5Cmathbf%7Ba%7D%29%3D%5Cmathbf%7BA%7D%20%5Csigma_%7BA%7D%5E%7B2%7D%0A" /></p><p>其中， <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D" style="display:inline-block;margin: 0;"/> 为 n 个个体的育种值向量; <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为个个体间的加性遗传相关矩阵。</p>
<h2 id="亲缘系数">亲缘系数</h2>
<p>近交系数的大小，是对双亲间的亲缘程度的间接度量，双亲间的亲缘程度也可用二者间的亲缘系数直接度量。据 Wright (1921) ，<strong>亲缘系数是指两个个体间加性基因效应间的相关</strong>（不懂？）。设只考虑一个基因座，假设我们要考虑的两个个体为 P 和 Q，个体 P 的任一基因座的两个基因是 a 和 b ，个体 Q 的同一基因座的两个等位基因是 c 和 d，则相对于群体均值的加性基因效应分别为：</p>
<p style=""><img src="https://math.now.sh?from=A_%7BP%7D%20%3D%20%5Calpha_%7Ba%7D%20%2B%20%5Calpha_%7Bb%7D%20%5C%5C%0AA_%7BQ%7D%20%3D%20%5Calpha_%7Bc%7D%20%2B%20%5Calpha_%7Bd%7D%20%5C%5C%0A" /></p><p>由此，<img src="https://math.now.sh?inline=A_%7BP%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=A_%7BQ%7D" style="display:inline-block;margin: 0;"/> 的协方差为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0ACov%28A_%7BP%7D%2CA_%7BQ%7D%29%20%26%3D%20%20E%5Cleft%5B(%5Calpha_%7Ba%7D%20%2B%20%5Calpha_%7Bb%7D)(%5Calpha_%7Bc%7D%20%2B%20%5Calpha_%7Bd%7D)%5Cright%5D%20%5C%5C%0A%26%3D%20%20E(%5Calpha_%7Ba%7D%20%5Calpha_%7Bc%7D)%20%2B%20E(%5Calpha_%7Ba%7D%20%5Calpha_%7Bd%7D)%20%2BE(%5Calpha_%7Bb%7D%20%5Calpha_%7Bc%7D)%20%2BE(%5Calpha_%7Bb%7D%20%5Calpha_%7Bd%7D)%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>若令基础群的加性基因效应方差为 <img src="https://math.now.sh?inline=%5Csigma_%7BA%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，有：(这几个公式不知道怎么来的)</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%5Cleft%28%5Calpha_%7Ba%7D%20%5Calpha_%7Bc%7D%5Cright%29%3DP(a%3Dc)%20E%5Cleft(%5Calpha_%7Ba%7D%5E%7B2%7D%5Cright)%3DP(a%3Dc)%20%5Cfrac%7B1%7D%7B2%7D%20%5Csigma_%7BA%7D%5E%7B2%7D%20%5C%5C%0AE%5Cleft(%5Calpha_%7Ba%7D%20%5Calpha_%7Bd%7D%5Cright)%3DP(a%3Dd)%20E%5Cleft(%5Calpha_%7Ba%7D%5E%7B2%7D%5Cright)%3DP(a%3Dd)%20%5Cfrac%7B1%7D%7B2%7D%20%5Csigma_%7BA%7D%5E%7B2%7D%20%5C%5C%0AE%5Cleft(%5Calpha_%7Bb%7D%20%5Calpha_%7Bc%7D%5Cright)%3DP(b%3Dc)%20E%5Cleft(%5Calpha_%7Bb%7D%5E%7B2%7D%5Cright)%3DP(b%3Dc)%20%5Cfrac%7B1%7D%7B2%7D%20%5Csigma_%7BA%7D%5E%7B2%7D%20%5C%5C%0AE%5Cleft(%5Calpha_%7Bb%7D%20%5Calpha_%7Bd%7D%5Cright)%3DP(b%3Dd)%20E%5Cleft(%5Calpha_%7Bb%7D%5E%7B2%7D%5Cright)%3DP(b%3Dd)%20%5Cfrac%7B1%7D%7B2%7D%20%5Csigma_%7BA%7D%5E%7B2%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因而：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0A%5Coperatorname%7BCov%7D%5Cleft%28A_%7BP%7D%2C%20A_%7BQ%7D%5Cright%29%3D%5Cfrac%7B1%7D%7B2%7D%5BP(a%3Dc)%2BP(a%3Dd)%2B%20%5C%5C%0AP(b%3Dc)%2BP(b%3Dd)%5D%20%5Csigma_%7BA%7D%5E%7B2%7D%3D2%20C_%7BP%20Q%7D%20%5Csigma_%7BA%7D%5E%7B2%7D%0A%5Cend%7Bgathered%7D%0A" /></p><p>同时，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0A%5Csigma_%7BA_%7BP%7D%7D%5E%7B2%7D%3D%5Coperatorname%7BCov%7D%5Cleft%28A_%7BP%7D%2C%20A_%7BP%7D%5Cright%29%3Da_%7BP%20P%7D%20%5Csigma_%7BA%7D%5E%7B2%7D%20%3D2%20C_%7BP%20P%7D%20%5Csigma_%7BA%7D%5E%7B2%7D%20%5C%5C%0A%5Csigma_%7BA_%7BQ%7D%7D%5E%7B2%7D%3D%5Coperatorname%7BCov%7D%5Cleft(A_%7BQ%7D%2C%20A_%7BQ%7D%5Cright)%3Da_%7BQ%20Q%7D%20%5Csigma_%7BA%7D%5E%7B2%7D%3D2%20C_%7BQ%20Q%7D%20%5Csigma_%7BA%7D%5E%7B2%7D%0A%5Cend%7Bgathered%7D%0A" /></p><p>所以</p>
<p style=""><img src="https://math.now.sh?from=r_%7B%5Cmathrm%7BPQ%7D%7D%3D%5Cfrac%7B%5Coperatorname%7BCov%7D%5Cleft%28A_%7B%5Cmathrm%7BP%7D%7D%2C%20A_%7B%5Cmathrm%7BQ%7D%7D%5Cright%29%7D%7B%5Csigma_%7B%5Cmathrm%7BA%7D_%7B%5Cmathrm%7BP%7D%7D%7D%20%5Csigma_%7B%5Cmathrm%7BA%7D_%7B%5Cmathrm%7BQ%7D%7D%7D%7D%3D%5Cfrac%7B2%20C_%7B%5Cmathrm%7BPQ%7D%7D%7D%7B%5Csqrt%7B2%20C_%7B%5Cmathrm%7BPP%7D%7D%20%5Ccdot%202%20C_%7B%5Cmathrm%7BQQ%7D%7D%7D%7D%3D%5Cfrac%7Ba_%7B%5Cmathrm%7BPQ%7D%7D%7D%7B%5Csqrt%7Ba_%7B%5Cmathrm%7BPP%7D%7D%20a_%7B%5Cmathrm%7BQQ%7D%7D%7D%7D%3D%5Cfrac%7B%20%5Csum%20(%5Cfrac%7B1%7D%7B2%7D)%5E%7Bn_%7Bi%7D%2Bn_%7Bj%7D%7D%20(1%2Bf_%7BA%7D)%7D%7B%5Csqrt%7B%5Cleft(1%2BF_%7B%5Cmathrm%7BP%7D%7D%5Cright)%5Cleft(1%2BF_%7B%5Cmathrm%7BQ%7D%7D%5Cright)%7D%7D%0A" /></p><p>我尽可能地查找了资料和文献，还是没搞懂这个亲缘系数是怎么来的，最原始的文献是 Wright 1922 年的文章，我看也是直接给的公式。</p>
<p>基于 <a href="http://nce.ads.uga.edu/wiki/lib/exe/fetch.php?media=gsip.pdf">gsip.pdf</a> 中，Legarra 是直接使用加性遗传相关，而不是Wright 定义的亲缘系数，原文如下：</p>
<blockquote>
<p>Wright (1922) introduced the notion of relationships as correlation between genetic effects of two individuals. For practical reasons, it is more convenient to use what is often called “numerator relationship” (Quaas 1976) or simply “relationship” or “additive relationship”. This equals the standardized covariance (not the correlation) between the additive genetic values of two individuals. The pedigree relationship is not equal to the correlation if there is inbreeding. There are several terms used to talk about relationships, and here we will present the classical definitions according to pedigree</p>
</blockquote>
<h1>A 阵的计算方法</h1>
<p>本章节内容来自于张勤老师的《动物遗传育种中的计算方法》。</p>
<p><img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵是由个体间的加性遗传相关组成的矩阵。</p>
<h2 id="动物模型下-A-阵的计算">动物模型下 A 阵的计算</h2>
<p>在动物模型下，<img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵是所有动物个体之间的加性遗传相关矩阵，<img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵的每一元素可用以下的递推公式来计算：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0Aa_%7Bi%20i%7D%3D%20%5Cbegin%7Bcases%7D1%2B0.5%20a_%7Bs_%7Bi%7D%20d_%7Bi%7D%7D%2C%20%26%20%5Ctext%20%7B%20%E5%BD%93%20%7D%20s_%7Bi%7D%20%5Ctext%20%7B%20%E5%92%8C%20%7D%20d_%7Bi%7D%20%5Ctext%20%7B%20%E5%9D%87%E5%B7%B2%E7%9F%A5%20%7D%20%5C%5C%0A1%2C%20%26%20%5Ctext%20%7B%20%E5%BD%93%20%7D%20s_%7Bi%7D%20%5Ctext%20%7B%20%E6%88%96%20%7D%20d_%7Bi%7D%20%5Ctext%20%7B%20%E6%9C%AB%E7%9F%A5%20%7D%5Cend%7Bcases%7D%20%5C%5C%0Aa_%7Bi%20j%7D%3Da_%7Bj%20i%7D%3D%20%5Cbegin%7Bcases%7D0.5%5Cleft%28a_%7Bi%20s_%7Bj%7D%7D%2Ba_%7Bi%20d_%7Bj%7D%7D%5Cright%29%2C%20%26%20%5Ctext%20%7B%20%E5%BD%93%20%7D%20s_%7Bj%7D%20%5Ctext%20%7B%20%E5%92%8C%20%7D%20d_%7Bj%7D%20%5Ctext%20%7B%20%E5%9D%87%E5%B7%B2%E7%9F%A5%20%7D%20%5C%5C%0A0.5%20a_%7Bi%20s_%7Bj%7D%7D%2C%20%26%20%5Ctext%20%7B%20%E5%BD%93%20%7D%20s_%7Bj%7D%20%5Ctext%20%7B%20%E5%B7%B2%E7%9F%A5%2C%20%7D%20d_%7Bj%7D%20%5Ctext%20%7B%20%E6%9C%AB%E7%9F%A5%20%7D%20%5C%5C%0A0.5%20a_%7Bi%20d_%7Bj%7D%7D%2C%20%26%20%5Ctext%20%7B%20%E5%BD%93%20%7D%20d_%7Bj%7D%20%5Ctext%20%7B%20%E5%B7%B2%E7%9F%A5%2C%20%7D%20s_%7Bj%7D%20%5Ctext%20%7B%20%E6%9C%AB%E7%9F%A5%20%7D%20%5C%5C%0A0%2C%20%26%20%5Ctext%20%7B%20%E5%BD%93%20%7D%20s_%7Bj%7D%20%5Ctext%20%7B%20%E5%92%8C%20%7D%20d_%7Bj%7D%20%5Ctext%20%7B%20%E5%9D%87%E6%9C%AB%E7%9F%A5%20%7D%5Cend%7Bcases%7D%0A%5Cend%7Bgathered%7D%0A" /></p><p>其中，<img src="https://math.now.sh?inline=s_%7Bi%7D%28s_%7Bj%7D%29" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=d_%7Bi%7D%28d_%7Bj%7D%29" style="display:inline-block;margin: 0;"/> 为个体 <img src="https://math.now.sh?inline=i%28j%29" style="display:inline-block;margin: 0;"/> 的父亲和母亲。</p>
<p>在利用以上公式计算 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵时，要先将系谱中的所有个体按个体号、父号和母号列成一个三列表，在列表时应注意：</p>
<ol>
<li>在个体一列中应包括所有在父和母列中出现过的个体</li>
<li>在个体一列中应保证后代绝不会出现在其父母之前，一般可按出生日期排序，先出生的在前。</li>
<li>为便于编写程序，个体应用自然数从 1 开始连续编号。</li>
</ol>
<p>下面举例说明，设有 7 个个体，列如下表。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Barray%7D%7Bccc%7D%0A%5Chline%20%5Ctext%20%7B%20%E4%B8%AA%E4%BD%93%20%7D%20%26%20%5Ctext%20%7B%20%E7%88%B6%20%7D%20%26%20%5Ctext%20%7B%20%E6%AF%8D%20%7D%20%5C%5C%0A%5Chline%201%20%26%20-%20%26%20-%20%5C%5C%0A2%20%26%20-%20%26%20-%20%5C%5C%0A3%20%26%201%20%26%20-%20%5C%5C%0A4%20%26%201%20%26%202%20%5C%5C%0A5%20%26%203%20%26%204%20%5C%5C%0A6%20%26%201%20%26%204%20%5C%5C%0A7%20%26%205%20%26%206%20%5C%5C%0A%5Chline%0A%5Cend%7Barray%7D%0A" /></p><p>对于其中双亲未知的个体，我们假设它们都是非近交个体，且彼此无亲缘关系，这些个体就构成了所谓的<strong>基础群</strong> (base population) ，这些个体所对应的 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵中的子矩阵为一单位阵，对于本例而言，我们有</p>
<p style=""><img src="https://math.now.sh?from=a_%7B11%7D%3Da_%7B22%7D%3D1%2C%20a_%7B12%7D%3Da_%7B21%7D%3D0%0A" /></p><p>从这些元素出发可计算出 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 中所有的其他元素，如</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26a_%7B13%7D%3Da_%7B31%7D%3D0.5%20a_%7B11%7D%3D0.5%20%5C%5C%0A%26a_%7B23%7D%3Da_%7B32%7D%3D0%20%5C%5C%0A%26a_%7B33%7D%3D1%20%5C%5C%0A%26a_%7B14%7D%3Da_%7B41%7D%3D0.5%5Cleft%28a_%7B11%7D%2Ba_%7B21%7D%5Cright%29%3D0.5%20%5C%5C%0A%26a_%7B44%7D%3D1%2B0.5%20a_%7B12%7D%3D1%0A%5Cend%7Baligned%7D%0A" /></p><p>完整的 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵为（计算过程是只算上三角矩阵，然后第一列，第二列，第三列的顺序，也就是说计算顺序为 <img src="https://math.now.sh?inline=a_%7B11%7D%2C%20a_%7B21%7D%2C%20a_%7B22%7D%2C%20a_%7B31%7D%2C%20a_%7B32%7D%2Ca_%7B33%7D%2C%20a_%7B41%7D%2C%20%5Ccdots%20%2C" style="display:inline-block;margin: 0;"/> 的顺序 ）</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7BA%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Blllllll%7D%0A1%20%26%200%20%26%200.5%20%26%200.5%20%26%200.5%20%26%200.75%20%26%200.625%20%5C%5C%0A%26%201%20%26%200%20%26%200.5%20%26%200.25%20%26%200.25%20%26%200.25%20%5C%5C%0A%26%20%26%201%20%26%200.25%20%26%200.625%20%26%200.375%20%26%200.5%20%5C%5C%0A%26%20%26%20%26%201%20%26%200.625%20%26%200.75%20%26%200.6875%20%5C%5C%0A%26%20%26%20%26%20%26%201.125%20%26%200.5625%20%26%200.84375%20%5C%5C%0A%26%20%5Ctext%20%7B%20%E5%AF%B9%20%7D%20%26%20%5Ctext%20%7B%20%E7%A7%B0%20%7D%20%26%20%26%20%26%201.25%20%26%200.90625%20%5C%5C%0A%26%20%26%20%26%20%26%20%26%20%26%201.28125%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><h1>A逆的计算方法</h1>
<h2 id="L-矩阵">L 矩阵</h2>
<p>Henderson(1975a, 1976) 提出了一种可以从系谱直接构造 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> 的简洁方法，正是由于这一方法的提出，才使得BLUP法，尤其是动物模型 BLUP 法在家畜育种中的真正广泛使用成为可能。</p>
<p>由于 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵为正定对称矩阵，根据科列斯基分解 (<strong>Cholesky decomposition</strong>)，它总可以分解为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%20%3D%20%5Cmathbf%7BLL'%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 是一个下三角矩阵，<strong>其中基础群体构成的 <img src="https://math.now.sh?inline=b%20%5Ctimes%20b" style="display:inline-block;margin: 0;"/> 的子矩阵也是一个单位矩阵</strong>。简单证明以下，首先我们知道 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵基础群体的 <img src="https://math.now.sh?inline=b%20%5Ctimes%20b" style="display:inline-block;margin: 0;"/> 的子矩阵也是一个单位矩阵，我们将 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵和  <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 阵分块如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%20%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BI%7D%20%26%20%5Cmathbf%7BK_%7B1%7D%7D%20%5C%5C%0A%5Cmathbf%7BK_%7B2%7D%7D%20%26%20%5Cmathbf%7BK_%7B3%7D%7D%0A%5Cend%7Barray%7D%5Cright%5D%2C%0A%5Cmathbf%7BL%7D%20%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BL_%7B1%7D%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7BK_%7B3%7D%7D%20%26%20%5Cmathbf%7BL_%7B2%7D%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>由 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%3D%20%5Cmathbf%7BLL'%7D" style="display:inline-block;margin: 0;"/> ，得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵的左上角的子矩阵有计算公式如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BL_%7B1%7DL_%7B1%7D%5E%7B%5Cprime%7D%7D%20%3D%20%5Cmathbf%7BI%7D%0A" /></p><p>逐元素计算得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BL_%7B1%7D%7D%20%3D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> （证明其对角线元素均为 1，非对角线元素均为0，这一步证明略  ） ，得证。</p>
<p><strong>假设个体 <img src="https://math.now.sh?inline=t" style="display:inline-block;margin: 0;"/> 的父母均已知</strong>，分别为 p 和 q，p &lt; q ，假设总个体数目为 n ，假设个体 <img src="https://math.now.sh?inline=i%20%3C%20t" style="display:inline-block;margin: 0;"/> 。根据 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%3D%20%5Cmathbf%7BLL'%7D" style="display:inline-block;margin: 0;"/> ，我们有</p>
<p style=""><img src="https://math.now.sh?from=a_%7Bti%7D%20%3D%20%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%20l_%7Btk%7Dl_%7Bki%7D%5E%7B%5Cprime%7D%3D%20%20%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%20l_%7Btk%7Dl_%7Bik%7D%5C%5C%0A" /></p><p>同理，我们有</p>
<p style=""><img src="https://math.now.sh?from=a_%7Bip%7D%3D%20%20%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%20l_%7Bik%7Dl_%7Bpk%7D%20%5C%5C%0Aa_%7Biq%7D%3D%20%20%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%20l_%7Bik%7Dl_%7Bqk%7D%20%5C%5C%0A" /></p><p>根据加性遗传相关的计算公式 <img src="https://math.now.sh?inline=a_%7Bti%7D%20%3D%200.5%28a_%7Bip%7D%2Ba_%7Biq%7D%29" style="display:inline-block;margin: 0;"/> ，将上式带入，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%20l_%7Bik%7Dl_%7Btk%7D%20%26%3D%200.5%28%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%20l_%7Bik%7Dl_%7Bpk%7D%20%2B%20%5Csum_%7Bk%3Dn%7D%5E%7Bn%7D%20l_%7Bik%7Dl_%7Bqk%7D%20%29%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>令 <img src="https://math.now.sh?inline=i%20%3D%201%2C2%2C%5Ccdots%2Ct-1" style="display:inline-block;margin: 0;"/> ，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Al_%7B11%7Dl_%7Bt1%7D%20%26%3D%200.5%28l_%7B11%7Dl_%7Bp1%7D%2Bl_%7B11%7Dl_%7Bp2%7D%29%20%5C%5C%0Al_%7B21%7Dl_%7Bt1%7D%20%2B%20l_%7B22%7Dl_%7Bt2%7D%20%26%3D%200.5(l_%7B21%7Dl_%7Bp1%7D%20%2B%20l_%7B22%7Dl_%7Bp2%7D%2Bl_%7B21%7Dl_%7Bq1%7D%20%2B%20l_%7B22%7Dl_%7Bq2%7D)%20%5C%5C%0A%5Ccdots%0A%5Cend%7Baligned%7D%0A" /></p><p>整理一下，我们得到</p>
<p style=""><img src="https://math.now.sh?from=l_%7Bti%7D%20%3D%200.5%28l_%7Bpi%7D%2Bl_%7Bqi%7D%29%0A" /></p><p>根据加性遗传相关的另一个计算公式 <img src="https://math.now.sh?inline=a_%7Btt%7D%20%3D%201%2B0.5a_%7Bpq%7D" style="display:inline-block;margin: 0;"/> ，同理可得下面的公式</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Csum_%7Bk%3D1%7D%5E%7Bt%7D%20l_%7Btk%7D%7B%7D%5E%7B2%7D%20%26%3D%201%20%2B%200.5%5Csum_%7Bk%3D1%7D%5E%7Bp%7D%20l_%7Bpk%7Dl_%7Bqk%7D%20%20%5C%5C%0Al_%7Btt%7D%7B%7D%5E%7B2%7D%20%26%3D%201%20%2B%200.5%5Csum_%7Bk%3D1%7D%5E%7Bp%7D%20l_%7Bpk%7Dl_%7Bqk%7D%20-%20%5Csum_%7Bk%3D1%7D%5E%7Bt-1%7D%20l_%7Btk%7D%7B%7D%5E%7B2%7D%20%20%5C%5C%0Al_%7Btt%7D%7B%7D%5E%7B2%7D%20%26%3D%201%20%2B%200.5%5Csum_%7Bk%3D1%7D%5E%7Bp%7D%20l_%7Bpk%7Dl_%7Bqk%7D%20-%20%5Csum_%7Bk%3D1%7D%5E%7Bt-1%7D%20%280.5(l_%7Bpk%7D%2Bl_%7Bqk%7D%29)%7B%7D%5E%7B2%7D%20%20%5C%5C%0Al_%7Btt%7D%7B%7D%5E%7B2%7D%20%26%3D%201%20%2B%200.5%5Csum_%7Bk%3D1%7D%5E%7Bp%7D%20l_%7Bpk%7Dl_%7Bqk%7D%20-%20%5Csum_%7Bk%3D1%7D%5E%7Bq%7D%20(0.5(l_%7Bpk%7D%2Bl_%7Bqk%7D))%7B%7D%5E%7B2%7D%20%20%5C%5C%0Al_%7Btt%7D%7B%7D%5E%7B2%7D%20%26%3D%201%20%2B%200.5%5Csum_%7Bk%3D1%7D%5E%7Bp%7D%20l_%7Bpk%7Dl_%7Bqk%7D%20-%20%5Csum_%7Bk%3D1%7D%5E%7Bq%7D%20(0.25l_%7Bpk%7D%5E%7B2%7D%2B0.5l_%7Bpk%7Dl_%7Bqk%7D%2B0.25l_%7Bqk%7D%5E%7B2%7D)%20%20%5C%5C%0Al_%7Btt%7D%7B%7D%5E%7B2%7D%20%26%3D%201%20%2B%200.5%5Csum_%7Bk%3D1%7D%5E%7Bp%7D%20l_%7Bpk%7Dl_%7Bqk%7D%20-0.25%20%5Csum_%7Bk%3D1%7D%5E%7Bp%7D%20%20l_%7Bpk%7D%5E%7B2%7D-%200.5%20%5Csum_%7Bk%3D1%7D%5E%7Bp%7D%20l_%7Bpk%7Dl_%7Bqk%7D%20%20-%20%200.25%20%5Csum_%7Bk%3D1%7D%5E%7Bq%7Dl_%7Bqk%7D%5E%7B2%7D%20%20%5C%5C%0Al_%7Btt%7D%7B%7D%5E%7B2%7D%20%26%3D%201%20%20-0.25%20%5Csum_%7Bk%3D1%7D%5E%7Bp%7D%20%20l_%7Bpk%7D%5E%7B2%7D%20%20-%20%200.25%20%5Csum_%7Bk%3D1%7D%5E%7Bq%7Dl_%7Bqk%7D%5E%7B2%7D%20%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>我们有 <img src="https://math.now.sh?inline=a_%7Bpp%7D%20%3D%201%2Bf_%7Bp%7D%20%3D%20%5Csum_%7Bk%3D1%7D%5E%7Bp%7D%20l_%7Bpk%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=a_%7Bqq%7D%20%3D%201%2Bf_%7Bq%7D%20%3D%20%5Csum_%7Bk%3D1%7D%5E%7Bq%7D%20l_%7Bqk%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，带入得到</p>
<p style=""><img src="https://math.now.sh?from=l_%7Btt%7D%7B%7D%5E%7B2%7D%20%3D%201%20%20-0.25%20%281%2Bf_%7Bp%7D%29%20%20-%20%200.25%20%20(1%2Bf_%7Bq%7D)%20%3D%200.5%20-%200.25%20(f_%7Bp%7D%20%2B%20f_%7Bq%7D)%20%20%20%5C%5C%0A" /></p><p>整理一下，得到下面这两个式子</p>
<p style=""><img src="https://math.now.sh?from=l_%7Bti%7D%20%3D%200.5%28l_%7Bpi%7D%2Bl_%7Bqi%7D%29%0A" /></p><p style=""><img src="https://math.now.sh?from=l_%7Btt%7D%20%3D%20%5Csqrt%7B%200.5%20-%200.25%20%28f_%7Bp%7D%20%2B%20f_%7Bq%7D%29%7D%0A" /></p><p><strong>假设个体 <img src="https://math.now.sh?inline=t" style="display:inline-block;margin: 0;"/> 知道一个亲本 p</strong> ，同理可得</p>
<p style=""><img src="https://math.now.sh?from=l_%7Bti%7D%20%3D%200.5l_%7Bpi%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=l_%7Btt%7D%20%3D%20%5Csqrt%7B%200.75%20-%200.25%20f_%7Bp%7D%20%7D%0A" /></p><p><strong>假设个体 <img src="https://math.now.sh?inline=t" style="display:inline-block;margin: 0;"/> 两个亲本均未知</strong> ，同理可得</p>
<p style=""><img src="https://math.now.sh?from=l_%7Bti%7D%20%3D%200%0A" /></p><p style=""><img src="https://math.now.sh?from=l_%7Btt%7D%20%3D%201%0A" /></p><h2 id="进一步分解">进一步分解</h2>
<p><img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/>  又可以进一步分解为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BL%7D%20%3D%20%5Cmathbf%7BTD%7D%0A" /></p><p>其中，<img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D" style="display:inline-block;margin: 0;"/> 是一个对角矩阵，其对角线元素 (<img src="https://math.now.sh?inline=d_%7Bi%7D" style="display:inline-block;margin: 0;"/>) 等于 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 矩阵的对角线元素 (<img src="https://math.now.sh?inline=l_%7Bii%7D" style="display:inline-block;margin: 0;"/>) ，即 <img src="https://math.now.sh?inline=d_%7Bi%7D%3D%20l_%7Bii%7D" style="display:inline-block;margin: 0;"/> ；<img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D" style="display:inline-block;margin: 0;"/> 阵为下三角矩阵，其对角线元素全为1。</p>
<p>因此，我们有 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%3D%20%5Cmathbf%7BT%20D%5E%7B2%7D%20T%5E%7B%5Cprime%7D%7D" style="display:inline-block;margin: 0;"/> ，其对角线元素计算公式如下</p>
<p style=""><img src="https://math.now.sh?from=A_%7Bii%7D%20%3D%20%5Csum_%7Bj%3D1%7D%5E%7Bi%7D%20T_%7Bij%7D%5E%7B2%7D%20D%5E%7B2%7D_%7Bjj%7D%0A" /></p><p>同时，<img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> 可写为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%5E%7B-1%7D%3D%5Cleft%28L%20L%5E%7B%5Cprime%7D%5Cright%29%5E%7B-1%7D%3D%5Cleft(T%20D%20D%20T%5E%7B%5Cprime%7D%5Cright)%5E%7B-1%7D%3D%5Cleft(T%5E%7B%5Cprime%7D%5Cright)%5E%7B-1%7D%20D%5E%7B-2%7D%20T%5E%7B-1%7D%7D%0A" /></p><p>其中，<img src="https://math.now.sh?inline=%5Cmathbf%7BD%5E%7B2%7D%7D" style="display:inline-block;margin: 0;"/> 矩阵元素计算方式如下，其中 <img src="https://math.now.sh?inline=F_%7Bi%7D" style="display:inline-block;margin: 0;"/> 为 近交系数。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%0AD%5E%7B2%7D_%7Bii%7D%20%26%20%3D%200.5%20-%200.25%28F_%7Bs_%7Bi%7D%7D%20%2B%20F_%7Bd_%7Bi%7D%7D%29%20%5Cquad%20%5Ctext%7B%E5%BD%93%20i%20%E7%9A%84%E7%88%B6%E6%AF%8D%E5%9D%87%E5%B7%B2%E7%9F%A5%7D%5C%5C%0A%26%3D%200.75%20-%200.25%20F_%7Bp_%7Bi%7D%7D%20%20%5Cquad%20%5Ctext%7B%E5%BD%93%20i%20%E7%9A%84%E5%8D%95%E4%B8%AA%E4%BA%B2%E6%9C%AC%E5%B7%B2%E7%9F%A5%7D%5C%5C%0A%26%3D%201%20%5Cquad%20%5Ctext%7B%E5%BD%93%20i%20%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%BA%B2%E6%9C%AC%E5%9D%87%E6%9C%AA%E7%9F%A5%7D%5C%5C%0A%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>根据  <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 矩阵元素，我们可以按列计算 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D" style="display:inline-block;margin: 0;"/> 阵元素，计算公式如下（系谱按照出生日期顺序排序）</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%20%5Ctext%7Bfor%20%7D%20j%3D1%20%5Ctext%7B%20to%20%7D%20N%20%5C%5C%0A%26%20%5Cquad%20T_%7Bii%7D%20%3D%201%20%5C%5C%0A%0A%26%5C%5C%0A%26%20%5Ctext%7Bfor%20%7D%20i%3Dj%2B1%20%5Ctext%7B%20to%20%7D%20N%20%5C%5C%0A%26%20%5Cquad%20T_%7Bij%7D%20%3D%20%28T_%7Bs_%7Bi%7Dj%7D%20%2B%20T_%7Bd_%7Bi%7Dj%7D%29%2F2%20%5Cquad%20%5Ctext%7B%E5%BD%93%20i%20%E7%9A%84%E7%88%B6%E6%AF%8D%E5%9D%87%E5%B7%B2%E7%9F%A5%7D%5C%5C%0A%26%20%5Cquad%20%5Cquad%20%20%20%3D%20T_%7Bp_%7Bi%7Dj%7D%20%2F2%20%5Cquad%20%5Ctext%7B%E5%BD%93%20i%20%E7%9A%84%E5%8D%95%E4%B8%AA%E4%BA%B2%E6%9C%AC%E5%B7%B2%E7%9F%A5%7D%5C%5C%0A%26%20%5Cquad%20%5Cquad%20%20%20%3D%200%20%5Cquad%20%5Ctext%7B%E5%BD%93%20i%20%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%BA%B2%E6%9C%AC%E5%9D%87%E6%9C%AA%E7%9F%A5%7D%5C%5C%0A%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>如果按行来计算 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D" style="display:inline-block;margin: 0;"/> 阵元素，其第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行元素等于个体 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 从其直系祖先中得到的基因比例（个体与其亲本是 0.5 ，与其祖父母是 0.25 ，每隔一代乘以 0.5），比如  <img src="https://math.now.sh?inline=T_%7Bis_%7Bi%7D%7D%20%3D%20T_%7Bid_%7Bi%7D%7D%20%3D%200.5" style="display:inline-block;margin: 0;"/> 。如果两个个体没有直系的亲缘关系，那么 <img src="https://math.now.sh?inline=T_%7Bij%7D%20%3D%200" style="display:inline-block;margin: 0;"/> 。因此， <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D" style="display:inline-block;margin: 0;"/> 阵第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行元素可以拆分与个体 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 的亲本的元素的 1/2 的累积之和，即</p>
<p style=""><img src="https://math.now.sh?from=T_%7Bij%7D%20%3D%20%5Csum_%7Bk%20%5Cin%20P_%7Bj%7D%7D%200.5%20T_%7Bik%7D%20%3D%20%5Csum_%7Bk%20%5Cin%20ANC_%7Bi%7D%20%5Ccap%20P_%7Bj%7D%7D%200.5%20T_%7Bik%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=P_%7Bj%7D" style="display:inline-block;margin: 0;"/> 为个体 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 的所有后代， <img src="https://math.now.sh?inline=ANC_%7Bi%7D" style="display:inline-block;margin: 0;"/> 为个体 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 的所有祖先（包括个体 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 本身），第二个等号就是只提取  <img src="https://math.now.sh?inline=P_%7Bj%7D" style="display:inline-block;margin: 0;"/>  中为个体 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 祖先的个体，因为不是个体 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 祖先 ，那么 <img src="https://math.now.sh?inline=T_%7Bik%7D%20%3D%200" style="display:inline-block;margin: 0;"/> ，加不加一样 。</p>
<h2 id="T-1-矩阵">T^-1 矩阵</h2>
<p>Henderson 证明，<img src="https://math.now.sh?inline=%5Cmathbf%7BT%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> 中的对角线元素全为1，在其第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 行上，第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 个个体的每一已知亲本所对应的元素为 -0.5 ，其余元素均为0。对于上面的例子，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BT%5E%7B-1%7D%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccccc%7D%0A1%20%26%20%26%20%26%20%26%20%26%20%5C%5C%0A0%20%26%201%20%26%20%26%20%26%20%5C%5C%0A-0.5%20%26%200%20%26%201%20%26%20%26%20%5C%5C%0A-0.5%20%26%20-0.5%20%26%200%20%26%201%20%26%20%5C%5C%0A0%20%26%200%20%26%20-0.5%20%26%20-0.5%20%26%201%20%26%20%5C%5C%0A-0.5%20%26%200%20%26%200%20%26%20-0.5%20%26%200%20%26%201%20%5C%5C%0A0%20%26%200%20%26%200%20%26%200%20%26%20-0.5%20%26%20-0.5%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>证明如下，我们先考虑下面这个分块矩阵，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BP_%7B0%7D%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的下三角矩阵，<img src="https://math.now.sh?inline=%5Cmathbf%7Ba'%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=1%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的向量， <img src="https://math.now.sh?inline=%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 的向量。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BP%7D_%7B1%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BP%7D_%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D_%7B0%7D%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>那么其逆矩阵为（假设可逆，即对角线元素均不为0）</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BP%7D_%7B1%7D%5E%7B-1%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BP%7D_%7B0%7D%5E%7B-1%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A-%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>因为存在</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BP%7D_%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D_%7B0%7D%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BP%7D_%7B0%7D%5E%7B-1%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A-%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BP%7D_%7B0%7D%5E%7B-1%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A-%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BP%7D_%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BP%7D_%7B0%7D%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%20%3D%20%5Cmathbf%7BI%7D%0A" /></p><p>我们知道 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 矩阵中某个体的非对角线元素等于其父母同位置非对角线元素的一半，即 <img src="https://math.now.sh?inline=L_%7Bti%7D%20%3D%200.5%28L_%7Bpi%7D%2BL_%7Bqi%7D%29" style="display:inline-block;margin: 0;"/> 。</p>
<p>根据矩阵乘法公式，我们知道一个矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 右乘一个对角矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D" style="display:inline-block;margin: 0;"/> 的结果为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的每一列乘以 <img src="https://math.now.sh?inline=d_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，举例如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BA%20D%7D%20%26%3D%5Cleft%28%5Cbegin%7Barray%7D%7Blll%7D%0Aa_%7B11%7D%20%26%20a_%7B12%7D%20%26%20a_%7B13%7D%20%5C%5C%0Aa_%7B21%7D%20%26%20a_%7B22%7D%20%26%20a_%7B23%7D%20%5C%5C%0Aa_%7B31%7D%20%26%20a_%7B32%7D%20%26%20a_%7B33%7D%0A%5Cend%7Barray%7D%5Cright%29%5Cleft(%5Cbegin%7Barray%7D%7Blll%7D%0Ad_%7B1%7D%20%26%200%20%26%200%20%5C%5C%0A0%20%26%20d_%7B2%7D%20%26%200%20%5C%5C%0A0%20%26%200%20%26%20d_%7B3%7D%0A%5Cend%7Barray%7D%5Cright)%20%5C%5C%0A%26%3D%5Cleft(%5Cbegin%7Barray%7D%7Blll%7D%0Ad_%7B1%7D%20a_%7B11%7D%20%26%20d_%7B2%7D%20a_%7B12%7D%20%26%20d_%7B3%7D%20a_%7B13%7D%20%5C%5C%0Ad_%7B1%7D%20a_%7B21%7D%20%26%20d_%7B2%7D%20a_%7B22%7D%20%26%20d_%7B3%7D%20a_%7B23%7D%20%5C%5C%0Ad_%7B1%7D%20a_%7B31%7D%20%26%20d_%7B2%7D%20a_%7B32%7D%20%26%20d_%7B3%7D%20a_%7B33%7D%0A%5Cend%7Barray%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>因此易得 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%7D" style="display:inline-block;margin: 0;"/> 矩阵同样满足 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 矩阵的这个性质，即某个体的非对角线元素等于其父母同位置非对角线元素的一半，我们有（<img src="https://math.now.sh?inline=b" style="display:inline-block;margin: 0;"/> 为基础群体数目，<img src="https://math.now.sh?inline=%5Cmathbf%7BT_%7Bb%7D%7D%20%3D%20%5Cmathbf%7BL_%7Bb%7D%7D%20%3D%20%5Cmathbf%7BI_%7Bb%7D%7D" style="display:inline-block;margin: 0;"/> ）</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BT%7D_%7Bb%2B1%7D%20%26%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BT%7D_%7Bb%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7Ba%7D_%7Bb%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BT%7D_%7Bb%7D%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BI%7D_%7Bb%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7Ba%7D_%7Bb%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BT%7D_%7Bb%7D%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%5Cmathbf%7BT%7D_%7Bb%2B2%7D%20%26%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Blll%7D%0A%5Cmathbf%7BT%7D_%7Bb%2B1%7D%20%26%20%5Cmathbf%7B0%7D%20%26%20%5C%5C%0A%5Cmathbf%7Ba%7D_%7Bb%2B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BT%7D_%7Bb%2B1%7D%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%5Cvdots%20%20%5C%5C%0A%5Cmathbf%7BT%7D_%7Bn%7D%20%26%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BT%7D_%7Bn-1%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7Ba%7D_%7Bn-1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BT%7D_%7Bn-1%7D%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%0A%5Cend%7Baligned%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba_%7Bi%7D%5E%7B%5Cprime%7D%7D" style="display:inline-block;margin: 0;"/> 中的元素除了第 <img src="https://math.now.sh?inline=i%2B1" style="display:inline-block;margin: 0;"/> 的亲本为 0.5 之外，其余均为 0 （<strong>这就要求系谱需要排序，亲本需要排在个体前面</strong>）。</p>
<p>根据上面的求逆公式，我们可知 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> 矩阵是一个下三角矩阵，其对角线元素均为 1 ；非对角线元素中除了亲本是 -0.5 之外其余元素均是 0 。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BT%7D_%7Bb%2B1%7D%5E%7B-1%7D%20%0A%26%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BI%7D_%7Bb%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A-%5Cmathbf%7Ba%7D_%7Bb%7D%5E%7B%5Cprime%7D%20%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%5Cmathbf%7BT%7D_%7Bb%2B2%7D%5E%7B-1%7D%20%0A%26%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Blll%7D%0A%5Cmathbf%7BT%7D_%7Bb%2B1%7D%5E%7B-1%7D%20%26%20%5Cmathbf%7B0%7D%20%26%20%5C%5C%0A-%5Cmathbf%7Ba%7D_%7Bb%2B1%7D%5E%7B%5Cprime%7D%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%0A%26%5Cvdots%20%20%5C%5C%0A%5Cmathbf%7BT%7D_%7Bn%7D%5E%7B-1%7D%20%26%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BT%7D_%7Bn-1%7D%5E%7B-1%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A-%5Cmathbf%7Ba%7D_%7Bn-1%7D%5E%7B%5Cprime%7D%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%0A%5Cend%7Baligned%7D%0A" /></p><p>得证。</p>
<h2 id="D-2-矩阵">D^-2  矩阵</h2>
<p>而 <img src="https://math.now.sh?inline=%5Cmathbf%7BD%5E%7B-2%7D%7D" style="display:inline-block;margin: 0;"/> 仍是对角矩阵，设 <img src="https://math.now.sh?inline=d_%7Bi%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 为其对角线上的第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 个元素，根据上面 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 矩阵对角元素的公式，易得</p>
<p style=""><img src="https://math.now.sh?from=d_%7Bi%7D%5E%7B*%7D%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cfrac%7B1%7D%7B0.5-0.25%5Cleft%28f_%7Bi%7D%2Bf_%7Bd%7D%5Cright%29%7D%2C%20%5Cquad%20%26%5Ctext%7B%E5%BD%93%E4%B8%AA%E4%BD%93%E7%9A%84%E5%8F%8C%E4%BA%B2%20s%20%E5%92%8C%20d%20%E5%B7%B2%E7%9F%A5%7D%20%5C%5C%0A%5Cfrac%7B1%7D%7B0.75-0.25%20f_%7Bp%7D%7D%2C%20%5Cquad%20%26%5Ctext%7B%E5%BD%93%E4%B8%AA%E4%BD%93%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BA%B2%E6%9C%AC%20p%20%E5%B7%B2%E7%9F%A5%7D%20%5C%5C%0A1%2C%20%5Cquad%20%26%20%5Ctext%7B%E5%BD%93%E4%B8%AA%E4%BD%93%E7%9A%84%E5%8F%8C%E4%BA%B2%E6%9C%AA%E7%9F%A5%7D%20%0A%5Cend%7Barray%7D%5Cright.%0A" /></p><p>其中，<img src="https://math.now.sh?inline=f_%7Bs%7D" style="display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=f_%7Bd%7D" style="display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=f_%7Bp%7D" style="display:inline-block;margin: 0;"/> 为近交系数。如果这些近交系数已知，则易得  <img src="https://math.now.sh?inline=%5Cmathbf%7BD%5E%7B-2%7D%7D" style="display:inline-block;margin: 0;"/> ，进而求得 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>如果我们已经求出了 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵，则这些近交系数可以很容易地从 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵的对角线元素求得。</p>
<p>当群体为非近交群体（所有个体的近交系数均为0），可得</p>
<p style=""><img src="https://math.now.sh?from=d_%7Bi%7D%5E%7B*%7D%3D%20%5Cbegin%7Bcases%7D2%2C%20%26%20%5Ctext%20%7B%20%E5%BD%93%E4%B8%AA%E4%BD%93%20%7D%20i%20%5Ctext%20%7B%20%E7%9A%84%E5%8F%8C%E4%BA%B2%E5%B7%B2%E7%9F%A5%20%7D%20%5C%5C%204%20%2F%203%2C%20%26%20%5Ctext%20%7B%20%E5%BD%93%E4%B8%AA%E4%BD%93%20%7D%20i%20%5Ctext%20%7B%20%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BA%B2%E6%9C%AC%E5%B7%B2%E7%9F%A5%20%7D%20%5C%5C%201%2C%20%26%20%5Ctext%20%7B%20%E5%BD%93%E4%B8%AA%E4%BD%93%20%7D%20i%20%5Ctext%20%7B%20%E7%9A%84%E5%8F%8C%E4%BA%B2%E6%9C%AB%E7%9F%A5%20%7D%5Cend%7Bcases%7D%0A" /></p><h2 id="另一种构建A逆的方法">另一种构建A逆的方法</h2>
<p>Quass (1976) 提出了求 <img src="https://math.now.sh?inline=d_%7Bi%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 的另一种简便方法，现介绍如下。这里的内容我其实没有仔细看，感觉挺繁琐的，不如先构建 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵来得到近交系数的做法的逻辑简洁。</p>
<p>由 <img src="https://math.now.sh?inline=d_%7Bi%7D%20%3D%20l_%7Bii%7D" style="display:inline-block;margin: 0;"/> ，可得 <img src="https://math.now.sh?inline=d_%7Bi%7D%5E%7B*%7D%20%3D%201%2Fl_%7Bii%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，所以只要求出 <img src="https://math.now.sh?inline=l_%7Bii%7D" style="display:inline-block;margin: 0;"/> ，就可得到 <img src="https://math.now.sh?inline=d_%7Bi%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 。将  <img src="https://math.now.sh?inline=f_%7Bi%7D%20%3D%20a_%7Bii%7D-1" style="display:inline-block;margin: 0;"/> 带入上式得到</p>
<p style=""><img src="https://math.now.sh?from=l_%7Bii%7D%3D%5Cfrac%7B1%7D%7B%5Csqrt%7Bd_%7Bi%7D%5E%7B*%7D%7D%7D%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bl%7D%0A%7B%5Cleft%5B1-0.25%5Cleft%28a_%7Bs%20s%7D%2Ba_%7Bd%20d%7D%5Cright%29%5Cright%5D%5E%7B0.5%7D%7D%20%2C%20%5Cquad%20%26%5Ctext%7B%E5%BD%93%E4%B8%AA%E4%BD%93%E7%9A%84%E5%8F%8C%E4%BA%B2%20s%20%E5%92%8C%20d%20%E5%B7%B2%E7%9F%A5%7D%20%5C%5C%0A%5Cleft(1-0.25%20a_%7B%5Crho%20%5Crho%7D%5Cright)%5E%7B0.5%7D%20%2C%20%5Cquad%20%26%5Ctext%7B%E5%BD%93%E4%B8%AA%E4%BD%93%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BA%B2%E6%9C%AC%20p%20%E5%B7%B2%E7%9F%A5%7D%20%5C%5C%0A1%2C%20%5Cquad%20%26%20%5Ctext%7B%E5%BD%93%E4%B8%AA%E4%BD%93%E7%9A%84%E5%8F%8C%E4%BA%B2%E6%9C%AA%E7%9F%A5%7D%20%0A%5Cend%7Barray%7D%5Cright.%0A" /></p><p>由 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%3D%20%5Cmathbf%7BLL'%7D" style="display:inline-block;margin: 0;"/> ，可得 <img src="https://math.now.sh?inline=a_%7Bii%7D%20%3D%20%5Csum_%7Bk%3D1%7D%5E%7Bi%7D%20l_%7Bik%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 。注意在求 <img src="https://math.now.sh?inline=a_%7Bii%7D" style="display:inline-block;margin: 0;"/> 时要用到 <img src="https://math.now.sh?inline=%5Cmathbf%7BL%7D" style="display:inline-block;margin: 0;"/> 的非对角线元素。将这个式子带入上式，我们得到</p>
<p style=""><img src="https://math.now.sh?from=l_%7Bii%7D%3D%5Cfrac%7B1%7D%7B%5Csqrt%7Bd_%7Bi%7D%5E%7B*%7D%7D%7D%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bl%7D%0A%20%7B%5Cleft%5B1-0.25%5Cleft%28%5Csum_%7Bi%3D1%7D%5E%7Bs%7Dl_%7Bs%20i%7D%5E%7B2%7D%2B%5Csum_%7Bi%3D1%7D%5E%7Bm%7Dl_%7Bm%20i%7D%5E%7B2%7D%5Cright%29%5Cright%5D%5E%7B0.5%7D%7D%20%2C%20%5Cquad%20%26%5Ctext%7B%E5%BD%93%E4%B8%AA%E4%BD%93%E7%9A%84%E5%8F%8C%E4%BA%B2%20s%20%E5%92%8C%20d%20%E5%B7%B2%E7%9F%A5%7D%20%5C%5C%0A%5Cleft(1-0.25%20%5Csum_%7Bi%3D1%7D%5E%7Bp%7Dl_%7Bp%20i%7D%5E%7B2%7D%5Cright)%5E%7B0.5%7D%20%2C%20%5Cquad%20%26%5Ctext%7B%E5%BD%93%E4%B8%AA%E4%BD%93%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BA%B2%E6%9C%AC%20p%20%E5%B7%B2%E7%9F%A5%7D%20%5C%5C%0A1%2C%20%5Cquad%20%26%20%5Ctext%7B%E5%BD%93%E4%B8%AA%E4%BD%93%E7%9A%84%E5%8F%8C%E4%BA%B2%E6%9C%AA%E7%9F%A5%7D%20%0A%5Cend%7Barray%7D%5Cright.%0A" /></p><p>同时我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cunderset%7B%28i%20%3E%20j%29%7D%7Bl_%7Bi%20j%7D%7D%3Dt_%7Bi%20j%7D%20d_%7Bj%7D%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bl%7D%0A0.5%5Cleft(l_%7Bs%20j%7D%2Bl_%7Bd%20j%7D%5Cright)%20%2C%20%5Cquad%20%26%5Ctext%7B%E5%BD%93%E4%B8%AA%E4%BD%93%20i%20%E7%9A%84%E5%8F%8C%E4%BA%B2%20s%20%E5%92%8C%20d%20%E5%B7%B2%E7%9F%A5%7D%20%5C%5C%0A0.5%20l_%7Bp%20j%7D%20%2C%20%5Cquad%20%26%5Ctext%7B%E5%BD%93%E4%B8%AA%E4%BD%93%20i%20%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BA%B2%E6%9C%AC%20p%20%E5%B7%B2%E7%9F%A5%7D%20%5C%5C%0A0%20%2C%20%5Cquad%20%26%20%5Ctext%7B%E5%BD%93%E4%B8%AA%E4%BD%93%20i%20%E7%9A%84%E5%8F%8C%E4%BA%B2%E6%9C%AA%E7%9F%A5%7D%20%0A%5Cend%7Barray%7D%5Cright.%0A" /></p><p>综上所述，可按下列步骤计算 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> ：</p>
<ol>
<li>
<p>按计算 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 阵时的要求将系谱中的所有个体列表；</p>
</li>
<li>
<p>将 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> 中的所有元素置为 0</p>
</li>
<li>
<p>设置两个维数为 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 的零向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Bv%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=%5Cmathbf%7Bv%7D" style="display:inline-block;margin: 0;"/> 用于存放 <img src="https://math.now.sh?inline=l_%7Bii%7D" style="display:inline-block;margin: 0;"/> ，并临时存放 <img src="https://math.now.sh?inline=l_%7Bki%7D" style="display:inline-block;margin: 0;"/> (<img src="https://math.now.sh?inline=k%3Di%2B1%2C%5Ccdots%2Cn" style="display:inline-block;margin: 0;"/>)，<img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D" style="display:inline-block;margin: 0;"/> 用于存放 <img src="https://math.now.sh?inline=a_%7Bii%7D" style="display:inline-block;margin: 0;"/> 。</p>
</li>
<li>
<p>对于 <img src="https://math.now.sh?inline=i%20%3D%201%2C%5Ccdots%2Cn" style="display:inline-block;margin: 0;"/> ，计算</p>
</li>
</ol>
<ul>
<li><img src="https://math.now.sh?inline=v_%7Bi%7D%20%3D%20l_%7Bii%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=l_%7Bii%7D" style="display:inline-block;margin: 0;"/> 用上式计算，即：</li>
</ul>
<p style=""><img src="https://math.now.sh?from=l_%7Bii%7D%3D%5Cfrac%7B1%7D%7B%5Csqrt%7Bd_%7Bi%7D%5E%7B*%7D%7D%7D%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bl%7D%7B%5Cleft%5B1-0.25%5Cleft%28a_%7Bs%20s%7D%2Ba_%7Bd%20d%7D%5Cright%29%5Cright%5D%5E%7B0.5%7D%7D%20%2C%20%5Cquad%20%26%5Ctext%7B%E5%BD%93%E4%B8%AA%E4%BD%93%E7%9A%84%E5%8F%8C%E4%BA%B2%20s%20%E5%92%8C%20d%20%E5%B7%B2%E7%9F%A5%7D%20%5C%5C%5Cleft(1-0.25%20a_%7B%5Crho%20%5Crho%7D%5Cright)%5E%7B0.5%7D%20%2C%20%5Cquad%20%26%5Ctext%7B%E5%BD%93%E4%B8%AA%E4%BD%93%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BA%B2%E6%9C%AC%20p%20%E5%B7%B2%E7%9F%A5%7D%20%5C%5C1%2C%20%5Cquad%20%26%20%5Ctext%7B%E5%BD%93%E4%B8%AA%E4%BD%93%E7%9A%84%E5%8F%8C%E4%BA%B2%E6%9C%AA%E7%9F%A5%7D%20%5Cend%7Barray%7D%5Cright.%0A" /></p><ul>
<li>
<p><img src="https://math.now.sh?inline=a_%7Bi%7D%20%3D%20a_%7Bi%7D%20%2B%20v_%7Bi%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/></p>
</li>
<li>
<p>对于  <img src="https://math.now.sh?inline=k%20%3D%20i%2B1%2C%5Ccdots%2Cn" style="display:inline-block;margin: 0;"/>  ，计算</p>
</li>
</ul>
<p style=""><img src="https://math.now.sh?from=v_%7Bk%7D%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bl%7D%0A%20%200.5%5Cleft%28v_%7Bs_%7Bk%7D%7D%2Bv_%7Bd_%7Bk%7D%7D%5Cright%29%20%2C%5Cquad%20%26%5Ctext%7B%E5%BD%93%E4%B8%AA%E4%BD%93%20k%20%E7%9A%84%E5%8F%8C%E4%BA%B2%7D%20s_%7Bk%7D%20%5Ctext%7B%E5%92%8C%7D%20d_%7Bk%7D%20%5Ctext%7B%E5%9D%87%E5%B7%B2%E7%9F%A5%E4%B8%94%E6%8E%92%E5%9C%A8%20i%20%E4%B9%8B%E5%90%8E%E6%88%96%E7%AD%89%E4%BA%8E%20i%7D%5C%5C%0A%20%20%20%20%200.5%20v_%7Bp_%7Bk%7D%7D%20%20%2C%5Cquad%20%26%5Ctext%7B%E5%BD%93%E4%B8%AA%E4%BD%93%20k%20%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BA%B2%E6%9C%AC%7D%20p_%7Bk%7D%20%20%5Ctext%7B%E5%B7%B2%E7%9F%A5%E4%B8%94%E6%8E%92%E5%9C%A8%20i%20%E4%B9%8B%E5%90%8E%E6%88%96%E7%AD%89%E4%BA%8E%20i%7D%5C%5C%0A%20%200%20%2C%5Cquad%20%26%5Ctext%7B%E5%85%B6%E4%BB%96%7D%20%5C%5C%0A%20%20%20%20%20%5Cend%7Barray%7D%5Cright.%0A" /></p><p>​		<img src="https://math.now.sh?inline=a_%7Bk%7D%20%3D%20a_%7Bk%7D%20%2B%20v_%7Bk%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/></p>
<ul>
<li>
<p><img src="https://math.now.sh?inline=d_%7Bi%7D%5E%7B*%7D%3D1%2Fv_%7Bi%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/></p>
</li>
<li>
<p>将下列数值加到 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> 中：</p>
<p>如 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 的双亲 <img src="https://math.now.sh?inline=s" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=d" style="display:inline-block;margin: 0;"/> 已知（这里的箭头指把 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/>  右边的位置的元素加上左边的数值）：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ad_%7Bi%7D%5E%7B*%7D%20%26%20%5Crightarrow%28i%2C%20i%29%20%5C%5C%0A-0.5%20d_%7Bi%7D%5E%7B*%7D%20%26%20%5Crightarrow(i%2C%20s)%2C(s%2C%20i)%2C(i%2C%20d)%2C(d%2C%20i)%20%5C%5C%0A0.25%20d_%7Bi%7D%5E%7B*%7D%20%26%20%5Crightarrow(s%2C%20s)%2C(d%2C%20d)%2C(s%2C%20d)%2C(d%2C%20s)%0A%5Cend%7Baligned%7D%0A" /></p><p>如 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 的一个亲本 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> 已知：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ad_%7Bi%7D%5E%7B*%7D%20%26%20%5Crightarrow%28i%2C%20i%29%20%5C%5C%0A-0.5%20d_%7Bi%7D%5E%7B*%7D%20%26%20%5Crightarrow(i%2C%20p)%2C(p%2C%20i)%20%5C%5C%0A0.25%20d_%7Bi%7D%5E%7B*%7D%20%26%20%5Crightarrow(p%2C%20p)%0A%5Cend%7Baligned%7D%0A" /></p><p>如 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 的双亲均未知：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ad_%7Bi%7D%5E%7B*%7D%20%26%20%5Crightarrow%28i%2C%20i%29%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p></li>
</ul>
<h1>参考文献</h1>
<ol>
<li>Henderson, 1976,  A Simple Method for Computing the Inverse of a Numerator Relationship Matrix Used in Prediction of Breeding Values.</li>
<li>Wright, 1922, COEFFICIENTS OF INBREEDING AND  RELATIONSHIP .</li>
<li>张沅，《家畜育种学》</li>
<li>张沅，张勤，《畜禽育种中的线性模型》</li>
<li>张勤，《动物遗传育种中的计算方法》</li>
<li>Luo Z. Computing inbreeding coefficients in large populations[J]. Genetics Selection Evolution, 1992, 24(4): 305-313.</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>混合线性模型三之BLUP方法</title>
    <url>/posts/7fc57f76/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在前面的章节中，我们提到了 BLP 方法需要已知固定效应的值，而这在实践中往往不可能实现，由此引出 BLUP 方法，这应该也是本系列的最后一篇。</p>
<span id="more"></span>
<h1>BLUP</h1>
<p>我们先看 BLUP 方法的一般推导，假设我们想要预测一个随机变量 <img src="https://math.now.sh?inline=w" style="display:inline-block;margin: 0;"/> ，我们只知道其均值为 <img src="https://math.now.sh?inline=%5Cmathbf%7Bk%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> ，方差为 <img src="https://math.now.sh?inline=v" style="display:inline-block;margin: 0;"/> ，其与 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 的协方差为 <img src="https://math.now.sh?inline=Cov%28w%2C%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%29%20%3D%20%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，我们该如何取预测 <img src="https://math.now.sh?inline=w" style="display:inline-block;margin: 0;"/> 呢？</p>
<p>一种可行的方案是我们找到一个关于 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的线性函数，其均值为  <img src="https://math.now.sh?inline=%5Cmathbf%7Bk%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> （即无偏），并且其在所有线性无偏估计值中具有最小的<strong>预测误差方差</strong>，这种方法我们称为<strong>最佳线性无偏预测法 (BLUP)</strong> 。</p>
<p>假设预测函数为 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba'y%7D" style="display:inline-block;margin: 0;"/> ，其期望为 <img src="https://math.now.sh?inline=E%28%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%29%3D%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> ，我们需要使之为   <img src="https://math.now.sh?inline=%5Cmathbf%7Bk%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/>  ，即 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20%3D%20%5Cmathbf%7Bk%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 对于所有可能的 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 恒成立，因此存在</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cmathbf%7Bk%7D%5E%7B%5Cprime%7D%0A" /></p><p>预测误差方差为下式，其中 <img src="https://math.now.sh?inline=v%20%3D%20Var%28w%29" style="display:inline-block;margin: 0;"/></p>
<p style=""><img src="https://math.now.sh?from=Var%28%5Cmathbf%7Ba'y%7D-w%29%20%3D%20%5Cmathbf%7Ba'Va%7D%20-%202%20%5Cmathbf%7Ba'c%7D%2Bv%0A" /></p><p>构建拉格朗日函数如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BL%7D%20%3D%200.5%20%28%5Cmathbf%7Ba'Va%7D%20-%202%20%5Cmathbf%7Ba'c%7D%2Bv%29%20%2B%20(%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D-%5Cmathbf%7Bk%7D%5E%7B%5Cprime%7D)%20%5Cboldsymbol%7B%5Ctheta%7D%0A" /></p><p>分别对 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Ctheta%7D" style="display:inline-block;margin: 0;"/> 求偏导，使之为 0 ，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cpartial%20%5Cmathbf%7BL%7D%20%2F%20%5Cpartial%20%5Cmathbf%7Ba%7D%3D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7Ba%7D%20-%20%5Cmathbf%7Bc%7D%20%2B%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Ctheta%7D%3D%20%5Cmathbf%7B0%7D%20%5C%5C%0A%26%5Cpartial%20%5Cmathbf%7BL%7D%20%2F%20%5Cpartial%20%5Cboldsymbol%7B%5Ctheta%7D%3D%5Cmathbf%7BX%E2%80%99a-k%7D%20%3D%20%5Cmathbf%7B0%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>整理一下，我们得到方程组如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BV%7D%20%26%20%5Cmathbf%7BX%7D%20%5C%5C%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%26%200%0A%5Cend%7Barray%7D%5Cright%29%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7Ba%7D%20%5C%5C%0A%5Cboldsymbol%7B%5Ctheta%7D%0A%5Cend%7Barray%7D%5Cright)%3D%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7Bc%7D%20%5C%5C%0A%5Cmathbf%7Bk%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>这个方程组和广义最小二乘的方程组很相似。下面我们开始求解，对第一个方程进行变换，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BV%7D%20%5Cmathbf%7Ba%7D%2B%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Ctheta%7D%20%26%3D%20%5Cmathbf%7Bc%7D%20%5C%5C%0A%5Cmathbf%7Ba%7D%20%20%26%3D%20%5Cmathbf%7BV%5E%7B-1%7D%28c-X%20%5Cboldsymbol%7B%5Ctheta%7D%7D%29%20%5C%5C%0A%5Cmathbf%7BX'a%7D%20%26%3D%20%5Cmathbf%7BX'V%5E%7B-1%7D(c-X%20%5Cboldsymbol%7B%5Ctheta%7D%7D)%20%5C%5C%0A%5Cmathbf%7Bk%7D%20%20%26%3D%20%5Cmathbf%7BX'V%5E%7B-1%7D(c-X%20%5Cboldsymbol%7B%5Ctheta%7D%7D)%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>因此我们得到了一个只关于 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Ctheta%7D" style="display:inline-block;margin: 0;"/> 的方程组</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX'V%5E%7B-1%7DX%20%5Cboldsymbol%7B%5Ctheta%7D%7D%20%3D%20%5Cmathbf%7BX'V%5E%7B-1%7Dc-k%7D%0A" /></p><p>我们需要先证明这个方程组相容，我们只需要证明对于任何一个广义逆 <img src="https://math.now.sh?inline=%5Cmathbf%7B%20%28X'V%5E%7B-1%7DX%29%5E%7B-%7D%20%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathbf%7B%28X'V%5E%7B-1%7DX%29%20(X'V%5E%7B-1%7DX)%5E%7B-%7D(X'V%5E%7B-1%7Dc-k)%3DX'V%5E%7B-1%7Dc-k%7D" style="display:inline-block;margin: 0;"/> 均成立即可。<strong>假设  <img src="https://math.now.sh?inline=%5Cmathbf%7Bk%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 可估计</strong>，则必然存在某个  <img src="https://math.now.sh?inline=%5Cmathbf%7Ba_%7B0%7D%7D" style="display:inline-block;margin: 0;"/> 向量使得  <img src="https://math.now.sh?inline=%5Cmathbf%7Bk%20%3D%20X'a_%7B0%7D%7D" style="display:inline-block;margin: 0;"/> ，因此上式可以写成  <img src="https://math.now.sh?inline=%5Cmathbf%7B%28X'V%5E%7B-1%7DX%29%20(X'V%5E%7B-1%7DX)%5E%7B-%7D(X'V%5E%7B-1%7Dc-X'a_%7B0%7D)%3DX'V%5E%7B-1%7Dc-X'a_%7B0%7D%7D" style="display:inline-block;margin: 0;"/> 。我们设这里的 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%3DV%5E%7B-1%2F2%7DX%7D" style="display:inline-block;margin: 0;"/> ，这里的 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%5E%7B-1%2F2%7D%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%5E%7B1%2F2%7D%7D" style="display:inline-block;margin: 0;"/> 的逆矩阵，易得 <img src="https://math.now.sh?inline=%5Cmathbf%7B%28X'V%5E%7B-1%7DX%29%20(X'V%5E%7B-1%7DX)%5E%7B-%7DX'%7D%20%3D%20%5Cmathbf%7BA'A(A'A)%5E%7B-%7DA'V%5E%7B1%2F2%7D%7D%20%3D%20%5Cmathbf%7BA'V%5E%7B1%2F2%7D%7D%20%3D%20%20%5Cmathbf%7BX'V%5E%7B-1%2F2%7D%20V%5E%7B1%2F2%7D%7D%20%3D%20%5Cmathbf%7BX'%7D" style="display:inline-block;margin: 0;"/> ，因此得证   <img src="https://math.now.sh?inline=%5Cmathbf%7B%28X'V%5E%7B-1%7DX%29%20(X'V%5E%7B-1%7DX)%5E%7B-%7D(X'V%5E%7B-1%7Dc-X'a_%7B0%7D)%3DX'V%5E%7B-1%7Dc-X'a_%7B0%7D%7D" style="display:inline-block;margin: 0;"/>  ，即我们证明这个方程组相容。</p>
<p>因此  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Ctheta%7D" style="display:inline-block;margin: 0;"/>  的一个解为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%28X'V%5E%7B-1%7DX%29%5E%7B-%7D(X'V%5E%7B-1%7Dc-k)%7D%0A" /></p><p>我们将其带入到第一个方程 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D%20%5Cmathbf%7Ba%7D%2B%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Ctheta%7D%20%3D%20%5Cmathbf%7Bc%7D" style="display:inline-block;margin: 0;"/>  ，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7Ba%7D%26%3D-%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Ctheta%7D%2B%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7Bc%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7Bk%7D-%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7Bc%7D%2B%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7Bc%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>此时我们的预测值为 （这里需要<strong>设定 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 同样是一个对称矩阵</strong> ）</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%3D%5Cmathbf%7Bk%7D%5E%7B%5Cprime%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%2B%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%5Cleft%5B%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%5Cright%5D%0A" /></p><p>由于 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%3D%5Cboldsymbol%7B%5Cbeta%7D%5E%7Bo%7D" style="display:inline-block;margin: 0;"/> ，所以预测值可以写为</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7Bw%7D%20%3D%20%5Cmathbf%7Bk%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%5E%7Bo%7D%2B%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%5Cleft%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%5E%7Bo%7D%5Cright%29%0A" /></p><p>我们注意到，如果 <img src="https://math.now.sh?inline=%5Cmathbf%7Bk%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D0" style="display:inline-block;margin: 0;"/> 或者如果 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 已知，那么此时的预测值就是 <img src="https://math.now.sh?inline=%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%5Cleft%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%5E%7Bo%7D%5Cright%29" style="display:inline-block;margin: 0;"/> ，就是选择指数法的预测公式。因此，<strong>BLUP 就是用 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D%5E%7B0%7D" style="display:inline-block;margin: 0;"/> 替换 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的 BLP</strong>  。</p>
<p>从元素推广到向量，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%5Chat%7Bw%7D%7D%20%3D%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%5E%7Bo%7D%2B%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%5Cleft%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%5E%7Bo%7D%5Cright%29%0A" /></p><p>其中，<img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D%20%3D%20Cov%28%5Cmathbf%7By%7D%2C%20%5Cmathbf%7Bw%7D%5E%7B%5Cprime%7D%29" style="display:inline-block;margin: 0;"/> 。</p>
<h2 id="方差及协方差">方差及协方差</h2>
<p>我们现在来看一些有用的方差和协方差，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%5Chat%7Bw%7D%7D%3D%5Cleft%28%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%2B%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D-%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cright)%20%5Cmathbf%7By%7D%0A" /></p><p><strong>假设 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 是一个对称矩阵，并且是一个自反广义逆矩阵</strong>。因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7BVar%7D%28%5Chat%7B%5Cmathbf%7Bw%7D%7D%29%0A%3D%26%20%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%2B%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D-%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cright)%20%5Cmathbf%7BV%7D%20%5Cleft(%5Cmathbf%7BV%5E%7B-1%7DX(X'V%5E%7B-1%7DX)%5E%7B-%7DK%20%2B%20V%5E%7B-1%7DC%20-%20V%5E%7B-1%7DX(X'V%5E%7B-1%7DX)%5E%7B-%7DX'V%5E%7B-1%7DC%7D%5Cright)%20%5C%5C%0A%3D%26%20%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%0A%2B%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%0A-%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cright)%0A%5Cleft(%5Cmathbf%7BV%5E%7B-1%7DX(X'V%5E%7B-1%7DX)%5E%7B-%7DK%20%2B%20V%5E%7B-1%7DC%20-%20V%5E%7B-1%7DX(X'V%5E%7B-1%7DX)%5E%7B-%7DX'V%5E%7B-1%7DC%7D%5Cright)%20%5C%5C%0A%0A%3D%26%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BK%7D%0A%2B%20%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%5Cmathbf%7BV%5E%7B-1%7DX(X'V%5E%7B-1%7DX)%5E%7B-%7DK%7D%20%0A-%20%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%5Cmathbf%7BK%7D%20%5C%5C%0A%26%20%5Cquad%20%2B%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%5E%7B-1%7DC%7D%0A%2B%20%5Cmathbf%7BC'V%5E%7B-1%7DC%7D%20-%20%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%5E%7B-1%7DC%7D%20%5C%5C%0A%26%20%5Cquad%20-%5Cmathbf%7BK'%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%5Cmathbf%7BX'V%5E%7B-1%7DC%7D-%20%5Cmathbf%7BC'%20V%5E%7B-1%7DX(X'V%5E%7B-1%7DX)%5E%7B-%7DX'V%5E%7B-1%7DC%7D%20%2B%20%5Cmathbf%7BC'V%5E%7B-1%7DX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%5Cmathbf%7BX'V%5E%7B-1%7DC%7D%20%5C%5C%0A%0A%0A%0A%0A%3D%26%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BK%7D%2B%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%20%5C%5C%0A%26-%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>协方差</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7BCov%7D%5Cleft%28%5Chat%7B%5Cmathbf%7Bw%7D%7D%2C%20%5Cmathbf%7Bw%7D%5E%7B%5Cprime%7D%5Cright%29%0A%3D%26%20%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%2B%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D-%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cright)%20%5Coperatorname%7BCov%7D%5Cleft(%5Cmathbf%7By%7D%2C%20%5Cmathbf%7Bw%7D%5E%7B%5Cprime%7D%5Cright)%20%5C%5C%0A%0A%3D%26%20%5Cleft(%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%2B%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D-%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cright)%20%5Cmathbf%7BC%7D%20%5C%5C%0A%0A%0A%3D%26%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%2B%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%20%5C%5C%0A%26-%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%20%5C%5C%0A%3D%26%20%5Coperatorname%7BVar%7D(%5Chat%7B%5Cmathbf%7Bw%7D%7D)%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>预测误差方差为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7BVar%7D%28%5Chat%7B%5Cmathbf%7Bw%7D%7D-%5Cmathbf%7Bw%7D%29%0A%3D%26%20%5Coperatorname%7BVar%7D(%5Cmathbf%7B%5Chat%7Bw%7D%7D)-%5Coperatorname%7BCov%7D%5Cleft(%5Chat%7B%5Cmathbf%7Bw%7D%7D%2C%20%5Cmathbf%7Bw%7D%5E%7B%5Cprime%7D%5Cright)-%5Coperatorname%7BCov%7D%5Cleft(%5Cmathbf%7Bw%7D%2C%20%5Chat%7B%5Cmathbf%7Bw%7D%7D%5E%7B%5Cprime%7D%5Cright)%2B%5Coperatorname%7BVar%7D(%5Cmathbf%7Bw%7D)%20%5C%5C%0A%0A%3D%26%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BK%7D-%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%20%5C%5C%0A%26-%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BK%7D-%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%20%5C%5C%0A%26%2B%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%20%2B%5Cmathbf%7BG%7D%0A%5Cend%7Baligned%7D%0A" /></p><h2 id="BLUP-的性质">BLUP 的性质</h2>
<ol>
<li>在所有的线性无偏预测值中，BLUP 最大化了 <img src="https://math.now.sh?inline=%5Chat%7Bw%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=w_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的相关</li>
<li><strong>BLUP</strong> 具有不变性，即 <img src="https://math.now.sh?inline=%5Ctext%7BBLUP%20of%20%7D%5Cmathbf%7Bm%5E%7B%5Cprime%7Dw%7D%20%3D%20%5Cmathbf%7Bm%5E%7B%5Cprime%7D%5Chat%7Bw%7D%7D" style="display:inline-block;margin: 0;"/></li>
<li>在<strong>正态</strong>分布假设下，我们有
<ul>
<li><img src="https://math.now.sh?inline=E%28%5Cmathbf%7Bw%20%7C%20%5Chat%7Bw%7D%7D%29%20%3D%20%5Cmathbf%7B%5Chat%7Bw%7D%7D" style="display:inline-block;margin: 0;"/></li>
<li>$Var( \mathbf{\hat{w}} -  \mathbf{w}) = Var( \mathbf{w} | \mathbf{\hat{w}}) $</li>
<li><img src="https://math.now.sh?inline=%5Cmathbf%7B%5Chat%7Bw%7D%7D" style="display:inline-block;margin: 0;"/> 是最大似然估计值，并且是 <img src="https://math.now.sh?inline=%5Cmathbf%7Bw%7D" style="display:inline-block;margin: 0;"/> 的条件均值的最佳线性无偏估计值</li>
<li><img src="https://math.now.sh?inline=%5Cmathbf%7B%5Chat%7Bw%7D%7D" style="display:inline-block;margin: 0;"/> 元素正确排序的可能性最大</li>
</ul>
</li>
</ol>
<h1>混合模型方程组</h1>
<p>上面的BLUP计算公式中涉及到 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 的计算，当观测值较多时， <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 计算困难甚至不可计算，为此 Henderson 提出了求解 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Chat%7Bw%7D%7D" style="display:inline-block;margin: 0;"/> 的另一种方法， 这个方法原来被 Henderson 称为最大似然法，但是实际上这个方法比最大似然方法更加具有普遍性，因为它其实不需要<strong>正态假设</strong>。这个方法就是<strong>混合模型方程组</strong> (Mixed Model Equation, MME) .</p>
<p>对于一般的混合线性模型</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%20%3D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%20%5Cmathbf%7BZu%7D%2B%20%5Cmathbf%7Be%7D%0A" /></p><p>均值和方差，协方差如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0AE%28%5Cmathbf%7Bu%7D%29%3D%5Cmathbf%7B0%7D%2C%20E(%5Cmathbf%7Be%7D)%3D%5Cmathbf%7B0%7D%2C%20E(%5Cmathbf%7By%7D)%3D%5Cmathbf%7BX%7D%20%5Cbeta%20%5C%5C%0A%5Coperatorname%7BVar%7D(%5Cmathbf%7Bu%7D)%3D%5Cmathbf%7BG%7D%2C%20%5Coperatorname%7BVar%7D(%5Cmathbf%7Be%7D)%3D%5Cmathbf%7BR%7D%2C%20%5Coperatorname%7BCov%7D%5Cleft(%5Cmathbf%7Bu%7D%2C%20%5Cmathbf%7Be%7D%5E%7B%5Cprime%7D%5Cright)%3D%5Cmathbf%7B0%7D%2C%20%5Coperatorname%7BVar%7D(%5Cmathbf%7By%7D)%3D%5Cmathbf%7BZ%20G%20Z%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7BR%7D%0A%5Cend%7Bgathered%7D%0A" /></p><p>我们沿着 Henderson 一开始推出 MME 的思路，我们假设 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Be%7D" style="display:inline-block;margin: 0;"/> 服从正态分布， <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> 服从联合多变量高斯分布</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bu%7D%20%20%5Csim%20N%28%5Cmathbf%7B0%7D%2C%20%5Cmathbf%7BG%7D%29%20%5C%5C%0A%5Cmathbf%7Be%7D%20%5Csim%20N(%5Cmathbf%7B0%7D%2C%20%5Cmathbf%7BR%7D)%0A" /></p><p>那么 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> 的联合密度函数为</p>
<p style=""><img src="https://math.now.sh?from=f%28%5Cmathbf%7By%7D%2C%20%5Cmathbf%7Bu%7D%29%3Df_%7B1%7D(%5Cmathbf%7By%7D%20%5Cmid%20%5Cmathbf%7Bu%7D)%20f_%7B2%7D(%5Cmathbf%7Bu%7D)%0A" /></p><p>根据多元正态分布，我们知道多元正态分布的条件分布 也是正态分布，其均值和协方差矩阵满足公式</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%28%5Cmathbf%7By%7D%20%5Cmid%20%5Cmathbf%7Bx%7D%29%20%26%3D%5Cboldsymbol%7B%5Cmu%7D_%7By%7D%2B%5Cmathbf%7B%5CSigma%7D_%7By%20x%7D%20%5CSigma_%7Bx%20x%7D%5E%7B-1%7D%5Cleft(%5Cmathbf%7Bx%7D-%5Cboldsymbol%7B%5Cmu%7D_%7Bx%7D%5Cright)%2C%20%5C%5C%0A%5Coperatorname%7Bcov%7D(%5Cmathbf%7By%7D%20%5Cmid%20%5Cmathbf%7Bx%7D)%20%26%3D%5Cmathbf%7B%5CSigma%7D_%7By%20y%7D-%5Cmathbf%7B%5CSigma%7D_%7By%20x%7D%20%5Cmathbf%7B%5CSigma%7D_%7Bx%20x%7D%5E%7B-1%7D%20%5Cmathbf%7B%5CSigma%7D_%7Bx%20y%7D%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%28%5Cmathbf%7By%7D%20%5Cmid%20%5Cmathbf%7Bu%7D%29%20%26%3D%5Cboldsymbol%7B%5Cmu%7D_%7By%7D%2B%5Cmathbf%7B%5CSigma%7D_%5Cmathbf%7By%20u'%7D%20%5CSigma_%5Cmathbf%7Bu%20u'%7D%5E%7B-1%7D%5Cleft(%5Cmathbf%7Bu%7D-E(%5Cmathbf%7Bu%7D)%5Cright)%20%5C%5C%0A%26%3D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20%2B%20%5Cmathbf%7BZG%20G%5E%7B-1%7Du%7D%20%20%5C%5C%0A%26%3D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20%2B%20%5Cmathbf%7BZu%7D%20%20%0A%0A%5C%5C%0A%0A%5Coperatorname%7Bcov%7D(%5Cmathbf%7By%7D%20%5Cmid%20%5Cmathbf%7Bu%7D)%20%26%3D%5Cmathbf%7B%5CSigma%7D_%7By%20y'%7D-%5Cmathbf%7B%5CSigma%7D_%7By%20u'%7D%20%5Cmathbf%7B%5CSigma%7D_%7Bu%20u'%7D%5E%7B-1%7D%20%5Cmathbf%7B%5CSigma%7D_%7Bu%20y'%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BZGZ'%2BR%7D%20-%20%5Cmathbf%7B(ZG)(G%5E%7B-1%7D)(GZ')%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BR%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7Cu%7D%20%20%5Csim%20N%28%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20%2B%20%5Cmathbf%7BZu%7D%20%20%2C%20%5Cmathbf%7BR%7D%29%20%5C%5C%0A" /></p><p>根据多元正态分布的概率密度公式，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26f_%7B1%7D%28%5Cmathbf%7By%7D%20%5Cmid%20%5Cmathbf%7Bu%7D%29%3DC_%7B1%7D%20%5Cexp%20%5Cleft%5C%7B-%5Cfrac%7B1%7D%7B2%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cbeta-%5Cmathbf%7BZ%20u%7D)%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cbeta-%5Cmathbf%7BZ%20u%7D)%5Cright%5C%7D%20%5C%5C%0A%26f_%7B2%7D(%5Cmathbf%7Bu%7D)%3DC_%7B2%7D%20%5Cexp%20%5Cleft%5C%7B-%5Cfrac%7B1%7D%7B2%7D%20%5Cmathbf%7Bu%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5Cmathbf%7Bu%7D%5Cright%5C%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=C_%7B1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=C_%7B2%7D" style="display:inline-block;margin: 0;"/> 为常数，如下</p>
<p style=""><img src="https://math.now.sh?from=C_%7B1%7D%3D%282%20%5Cpi%29%5E%7B-%5Cfrac%7Bn%7D%7B2%7D%7D%7CR%7C%5E%7B-%5Cfrac%7B1%7D%7B2%7D%7D%2C%20%5Cquad%20C_%7B2%7D%3D(2%20%5Cpi)%5E%7B-%5Cfrac%7Bq%7D%7B2%7D%7D%7CG%7C%5E%7B-%5Cfrac%7B1%7D%7B2%7D%7D%0A" /></p><p>于是</p>
<p style=""><img src="https://math.now.sh?from=f%28%5Cmathbf%7By%7D%2C%20%5Cmathbf%7Bu%7D%29%3DC%20%5Cexp%20%5Cleft%5C%7B-%5Cfrac%7B1%7D%7B2%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D-%5Cmathbf%7BZ%20u%7D)%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20-%5Cmathbf%7BZ%20u%7D)-%5Cfrac%7B1%7D%7B2%7D%20%5Cmathbf%7Bu%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5Cmathbf%7Bu%7D%5Cright%5C%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=C%3DC_%7B1%7D%20%5Ctimes%20C_%7B2%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>取对数得到</p>
<p style=""><img src="https://math.now.sh?from=%5Clog%20f%28%5Cmathbf%7By%7D%2C%20%5Cmathbf%7Bu%7D%29%3D%20%5Clog%20(C)%20-%5Cfrac%7B1%7D%7B2%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D-%5Cmathbf%7BZ%20u%7D)%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20-%5Cmathbf%7BZ%20u%7D)-%5Cfrac%7B1%7D%7B2%7D%20%5Cmathbf%7Bu%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5Cmathbf%7Bu%7D%0A" /></p><p>根据最大似然的思想，我们要找一组参数 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Chat%7Bu%7D%7D" style="display:inline-block;margin: 0;"/> 使得  <img src="https://math.now.sh?inline=%5Clog%20f%28%5Cmathbf%7By%7D%2C%20%5Cmathbf%7Bu%7D%29" style="display:inline-block;margin: 0;"/> 最大。我们分别针对 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> 求偏导，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cfrac%7B%5Cpartial%20%5Clog%20f%28%5Cmathbf%7By%7D%2C%20%5Cmathbf%7Bu%7D%29%7D%7B%5Cpartial%20%5Cboldsymbol%7B%5Cbeta%7D%7D%0A%3D%5Cmathbf%7BX'R%5E%7B-1%7D%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D-%5Cmathbf%7BZ%20u%7D)%0A%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%5Cbeta-%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%20u%7D%20%3D%20%5Cmathbf%7B0%7D%20%5C%5C%0A%26%5Cfrac%7B%5Cpartial%20%5Clog%20f(%5Cmathbf%7By%7D%2C%20%5Cmathbf%7Bu%7D)%7D%7B%5Cpartial%20%5Cmathbf%7Bu%7D%7D%0A%3D%5Cmathbf%7BZ'R%5E%7B-1%7D%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D-%5Cmathbf%7BZ%20u%7D)%20-%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5Cmathbf%7Bu%7D%0A%3D%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D-%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%5Cbeta-%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%20u%7D-%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5Cmathbf%7Bu%7D%20%3D%20%5Cmathbf%7B0%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>整理一下，可得</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%2B%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%20%5Chat%7B%5Cmathbf%7Bu%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%26%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%2B%5Cleft%28%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright%29%20%5Chat%7B%5Cmathbf%7Bu%7D%7D%3D%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>我们也可以整理成方程组的形式</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%20%5C%5C%0A%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%20%20%5C%5C%0A%5Chat%7B%5Cmathbf%7Bu%7D%7D%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>此方程组就称为<strong>混合模型方程组</strong>。</p>
<p>我们下面证明混合模型方程组与根据 BLUP 的定义直接得到的  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Chat%7Bu%7D%7D" style="display:inline-block;margin: 0;"/>  等价，也就是说混合模型方程组实际不需要正态假设。</p>
<h2 id="证明等价">证明等价</h2>
<p>由混合模型方程组的第二个方程得</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bu%7D%3D%5Cleft%28%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D)%0A" /></p><p>这里需要证明 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 可逆，由于 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 阵是正定矩阵，因此其逆矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> 也是正定矩阵，易证  <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 为半正定矩阵，因此  <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 也是正定矩阵，因此其可逆。</p>
<p>将该式带入到第一个方程得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D-%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5Cleft%28%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5Cleft(%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>变换一下得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BX'%7D%5Cleft%28%5Cmathbf%7BR%7D%5E%7B-1%7D-%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5Cleft(%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%5Cright)%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%20%26%3D%20%20%5Cmathbf%7BX'%7D%5Cleft(%5Cmathbf%7BR%7D%5E%7B-1%7D-%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5Cleft(%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%5Cright)%5Cmathbf%7By%7D%20%5C%5C%0A%0A%0A%5Cmathbf%7BX'%7D%5Cmathbf%7BV%5E%7B-1%7D%7D%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%20%26%3D%20%20%5Cmathbf%7BX'%7D%5Cmathbf%7BV%5E%7B-1%7D%7D%5Cmathbf%7By%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>其中有 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D%5E%7B-1%7D%3D%5Cmathbf%7BR%7D%5E%7B-1%7D-%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5Cleft%28%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> ，推导可见<a href="https://vincere.fun/posts/5e674d74/">混合线性模型一之广义最小二乘</a> 。</p>
<p>因此，混合模型方程组得到的  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 就是广义最小二乘估计值。</p>
<p>然后我们再需要证明  <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Chat%7Bu%7D%7D%20%3D%20%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%5Cleft%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%5Cright%29" style="display:inline-block;margin: 0;"/>   ，即等于选择指数法估计值。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7Bu%7D%20%26%3D%5Cleft%28%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D)%20%5C%5C%0A%26%3D%5Cleft(%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cwidehat%7B%5Cbeta%7D)%20%5C%5C%0A%26%3D%5Cleft(%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%5Cleft(%5Cmathbf%7BZ%20G%20Z%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7BR%7D%5Cright)%20%5Cmathbf%7BV%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D)%20%5C%5C%0A%26%3D%5Cleft(%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright)%5E%7B-1%7D%5Cleft(%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright)%20%5Cmathbf%7BG%20Z%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D)%20%5C%5C%0A%26%3D%5Cmathbf%7BG%20Z%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D)%20%5C%5C%0A%26%3D%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D)%20%5Cquad(%20%5Cbecause%20%5Cmathbf%7BC%7D%3D%5Cmathbf%7BZ%20G%7D)%0A%5Cend%7Baligned%7D%0A" /></p><p>得证。</p>
<p>因此我们证明了混合模型方程组与根据 BLUP 的定义直接得到的  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Chat%7Bu%7D%7D" style="display:inline-block;margin: 0;"/>  等价，所以在家畜育种中，混合模型方程组已成了 BLUP 法的同义词。</p>
<p>但是这种从最大似然法推导出来混合模型方程组的方式，和 BLUP 的定义似乎缺少概念上的直接联系，下面我们尝试直接从 BLUP 的定义出发，直接推导得到混合模型方程组。</p>
<h2 id="重新推导">重新推导</h2>
<p>根据 BLUP 定义，对于单个变量 <img src="https://math.now.sh?inline=w" style="display:inline-block;margin: 0;"/> ，我们有方程组</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BV%7D%20%26%20%5Cmathbf%7BX%7D%20%5C%5C%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%26%200%0A%5Cend%7Barray%7D%5Cright%29%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7Ba%7D%20%5C%5C%0A%5Cboldsymbol%7B%5Ctheta%7D%0A%5Cend%7Barray%7D%5Cright)%3D%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7Bc%7D%20%5C%5C%0A%5Cmathbf%7Bk%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>推广至向量 <img src="https://math.now.sh?inline=%5Cmathbf%7Bw%7D" style="display:inline-block;margin: 0;"/> ，我们有下面的方程组 (注意这里的 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Ctheta%7D" style="display:inline-block;margin: 0;"/> 是一个矩阵，上面是一个向量 )。矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 满足 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Chat%7Bw%7D%20%3D%20A'y%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BV%7D%20%26%20%5Cmathbf%7BX%7D%20%5C%5C%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%26%200%0A%5Cend%7Barray%7D%5Cright%29%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BA%7D%20%5C%5C%0A%5Cboldsymbol%7B%5Ctheta%7D%0A%5Cend%7Barray%7D%5Cright)%3D%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BC%7D%20%5C%5C%0A%5Cmathbf%7BK%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>将 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%20%3D%20ZGZ'%20%2B%20R%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%3DZG%7D" style="display:inline-block;margin: 0;"/> 带入第一个方程，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%28ZGZ'%20%2B%20R%29A%7D%20%2B%20%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Ctheta%7D%20%3D%20%5Cmathbf%7BCG%7D%20%5C%5C%0A" /></p><p>或者写成</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BRA%7D%20%2B%20%5Cmathbf%7BZG%28Z'A-I%29%7D%20%2B%20%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Ctheta%7D%20%3D%20%5Cmathbf%7B0%7D%0A" /></p><p>令 <img src="https://math.now.sh?inline=%5Cmathbf%7BT%3DG%28Z'A-I%29%7D" style="display:inline-block;margin: 0;"/> ，则 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ'A-G%5E%7B-1%7DT%3DI%7D" style="display:inline-block;margin: 0;"/> ，于是有方程组</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BRA%7D%20%2B%20%5Cmathbf%7BZT%7D%20%2B%20%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Ctheta%7D%20%3D%20%5Cmathbf%7B0%7D%5C%5C%0A%5Cmathbf%7BZ'A-G%5E%7B-1%7DT%3DI%7D%20%5C%5C%0A%5Cmathbf%7BX'A%3DK%7D%0A" /></p><p>由其中的第一个方程可得</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%20%3D%20-%5Cmathbf%7BR%5E%7B-1%7DX%5Cboldsymbol%7B%5Ctheta%7D%20-%20R%5E%7B-1%7DZT%7D%0A" /></p><p>带入到第二方程，得</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A-%5Cmathbf%7BZ'R%5E%7B-1%7DX%5Cboldsymbol%7B%5Ctheta%7D%20-%20Z'R%5E%7B-1%7DZT-G%5E%7B-1%7DT%7D%20%26%3D%20%5Cmathbf%7BI%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>带入到第三方程，得</p>
<p style=""><img src="https://math.now.sh?from=-%5Cmathbf%7BX'R%5E%7B-1%7DX%5Cboldsymbol%7B%5Ctheta%7D%20-%20X%E2%80%99R%5E%7B-1%7DZT%7D%20%3D%20%5Cmathbf%7BK%7D%0A" /></p><p>整理成方程组得格式为</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%20%5C%5C%0A%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cboldsymbol%7B%5Ctheta%7D%20%5C%5C%0A%5Cmathbf%7BT%7D%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A-%5Cmathbf%7BK%7D%20%5C%5C%0A-%5Cmathbf%7BI%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>前面前面的推导，我们知道这个方程组应该是相容的。我们将上式系数矩阵的一个广义逆表示为（<strong>假设这个广义逆也是一个对称矩阵</strong>，满足 <img src="https://math.now.sh?inline=%5Cmathbf%7BC_%7B12%7D%7D%20%3D%20%5Cmathbf%7BC_%7B21%7D%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathbf%7BC_%7B11%7D%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BC_%7B22%7D%7D" style="display:inline-block;margin: 0;"/> 也是对称矩阵）</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BC%7D_%7B11%7D%20%26%20%5Cmathbf%7BC%7D_%7B12%7D%20%5C%5C%0A%5Cmathbf%7BC%7D_%7B21%7D%20%26%20%5Cmathbf%7BC%7D_%7B22%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>则该方程组的解为</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cboldsymbol%7B%5Ctheta%7D%20%5C%5C%0A%5Cmathbf%7BT%7D%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BC%7D_%7B11%7D%20%26%20%5Cmathbf%7BC%7D_%7B12%7D%20%5C%5C%0A%5Cmathbf%7BC%7D_%7B21%7D%20%26%20%5Cmathbf%7BC%7D_%7B22%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A-%5Cmathbf%7BK%7D%20%5C%5C%0A-%5Cmathbf%7BI%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>于是</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BA%7D%20%26%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BR%5E%7B-1%7DX%7D%20%26%0A%5Cmathbf%7BR%5E%7B-1%7DZ%7D%20%0A%5Cend%7Barray%7D%5Cright%5D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A-%5Cboldsymbol%7B%5Ctheta%7D%20%5C%5C%0A-%5Cmathbf%7BT%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%5C%5C%0A%26%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BR%5E%7B-1%7DX%7D%20%26%0A%5Cmathbf%7BR%5E%7B-1%7DZ%7D%20%0A%5Cend%7Barray%7D%5Cright%5D%20%0A%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BC%7D_%7B11%7D%20%26%20%5Cmathbf%7BC%7D_%7B12%7D%20%5C%5C%0A%5Cmathbf%7BC%7D_%7B21%7D%20%26%20%5Cmathbf%7BC%7D_%7B22%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BK%7D%20%5C%5C%0A%5Cmathbf%7BI%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>因此</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7B%5Chat%7Bw%7D%7D%20%26%3D%20%5Cmathbf%7BA'y%7D%20%5C%5C%0A%26%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BK'%7D%20%26%0A%5Cmathbf%7BI%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BC%7D_%7B11%7D%20%26%20%5Cmathbf%7BC%7D_%7B12%7D%20%5C%5C%0A%5Cmathbf%7BC%7D_%7B21%7D%20%26%20%5Cmathbf%7BC%7D_%7B22%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A%5Cend%7Baligned%7D%0A" /></p><p>同时根据上面的推导，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%5Chat%7Bw%7D%7D%20%3D%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%2B%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%5Cleft%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%5Cright%29%3D%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%2B%20%5Cmathbf%7B%5Chat%7Bu%7D%7D%20%3D%0A%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BK'%7D%20%26%0A%5Cmathbf%7BI%7D%0A%5Cend%7Barray%7D%20%5Cright%5D%0A%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%20%5C%5C%0A%5Cmathbf%7B%5Chat%7Bu%7D%7D%20%0A%5Cend%7Barray%7D%20%5Cright%5D%0A" /></p><p>因此</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%20%5C%5C%0A%5Cmathbf%7B%5Chat%7Bu%7D%7D%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BC%7D_%7B11%7D%20%26%20%5Cmathbf%7BC%7D_%7B12%7D%20%5C%5C%0A%5Cmathbf%7BC%7D_%7B21%7D%20%26%20%5Cmathbf%7BC%7D_%7B22%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>即</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%20%5C%5C%0A%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%20%20%5C%5C%0A%5Chat%7B%5Cmathbf%7Bu%7D%7D%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>证明完毕。</p>
<h2 id="性质">性质</h2>
<p><strong>假设 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 是一个对称矩阵，并且是一个自反广义逆矩阵</strong>。</p>
<h3 id="固定效应估计值">固定效应估计值</h3>
<p>固定效应估计值就是一个广义最小二乘估计值，公式如下，其性质不再赘述。</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%3D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%0A" /></p><h3 id="随机效应估计值">随机效应估计值</h3>
<p>随机效应计算公式为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7B%5Chat%7Bu%7D%7D%20%26%3D%5Cleft%28%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D)%20%5C%5C%0A%26%3D%5Cmathbf%7BG%20Z%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D)%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>根据广义最小二乘估计值的性质，我们易得 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 是一个可估计函数，即 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/>  的值唯一，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5Chat%7Bu%7D%7D" style="display:inline-block;margin: 0;"/> 也是<strong>唯一的</strong>。</p>
<p>首先看期望</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%28%5Chat%7B%5Cmathbf%7Bu%7D%7D%29%20%26%5Cleft.%3D%5Cmathbf%7BG%20Z%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%5Cleft(%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D-%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%5Cright)%5Cright)%20%5C%5C%0A%26%3D%5Cmathbf%7BG%20Z%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D(%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D-%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%3D0%0A%5Cend%7Baligned%7D%0A" /></p><p>其中存在  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%5Cleft%28%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%20%3D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> ，证明如下，我们设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%3DV%5E%7B-1%2F2%7DX%7D" style="display:inline-block;margin: 0;"/> ，这里的 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%5E%7B-1%2F2%7D%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%5E%7B1%2F2%7D%7D" style="display:inline-block;margin: 0;"/> 的逆矩阵，易得</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D%20%5Cleft%28%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%3D%20%5Cmathbf%7BV%5E%7B1%2F2%7DA(A'A)%5E%7B-%7DA'A%7D%20%3D%20%5Cmathbf%7BV%5E%7B1%2F2%7DA%7D%20%3D%20%5Cmathbf%7BX%7D%0A" /></p><p>第二，我们看随机效应的协方差矩阵，根据上面的 BLUP的一般推导，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BVar%7D%28%5Chat%7B%5Cmathbf%7Bw%7D%7D%29%20%3D%20%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BK%7D%2B%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%20%0A-%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%20%5C%5C%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> 均值为 <img src="https://math.now.sh?inline=%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> ，即 <img src="https://math.now.sh?inline=%5Cmathbf%7BK%20%3D%200%7D" style="display:inline-block;margin: 0;"/> ，同时有 <img src="https://math.now.sh?inline=%5Cmathbf%7BC%3DZG%7D" style="display:inline-block;margin: 0;"/> 带入得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7BVar%7D%28%5Chat%7B%5Cmathbf%7Bu%7D%7D%29%20%26%3D%20%20%5Cmathbf%7BGZ'%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZG%7D%20%0A-%5Cmathbf%7BGZ'%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZG%7D%20%5C%5C%0A%26%20%3D%5Cmathbf%7BG%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%5Cleft(%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%5Cright)%20%5Cmathbf%7BZ%20G%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>根据上面的 BLUP的一般推导，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BCov%7D%5Cleft%28%5Chat%7B%5Cmathbf%7Bu%7D%7D%2C%20%5Cmathbf%7Bu%7D%5E%7B%5Cprime%7D%5Cright%29%0A%3D%20%5Coperatorname%7BVar%7D(%5Chat%7B%5Cmathbf%7Bu%7D%7D)%0A" /></p><p>固定效应的可估计函数与随机效应估计值的协方差矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7BCov%7D%5Cleft%28%5Cmathbf%7BT%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%2C%20%5Cmathbf%7B%5Chat%7Bu%7D%7D%5E%7B%5Cprime%7D%5Cright%29%0A%26%3D%20%5Cmathbf%7BT%7D%5Coperatorname%7BCov%7D%5Cleft(%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%2C%20%5Cmathbf%7B%5Chat%7Bu%7D%7D%5E%7B%5Cprime%7D%5Cright)%20%5C%5C%0A%26%3D%20%5Cmathbf%7BT%7D%5Coperatorname%7BCov%7D%5Cleft(%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%2C%20%5Cleft(%20%5Cmathbf%7BG%20Z%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D(%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%20%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20)%20%5Cmathbf%7By%7D%20%5Cright)%5E%7B%5Cprime%7D%5Cright)%20%5C%5C%0A%26%3D%5Cmathbf%7BT%7D%20%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BV%7D%20%5Cleft(%20%5Cmathbf%7BI%7D%20-%20%5Cmathbf%7BV%5E%7B-1%7DX%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20X'%7D%20%20%5Cright)%20%5Cmathbf%7BV%5E%7B-1%7DZG%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BT%7D%20%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%20%5Cleft(%20%5Cmathbf%7BI%7D%20-%20%5Cmathbf%7BV%5E%7B-1%7DX%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20X'%7D%20%20%5Cright)%20%5Cmathbf%7BV%5E%7B-1%7DZG%7D%20%5C%5C%0A%0A%26%3D%5Cmathbf%7BT%7D%20%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%5E%7B-1%7DZG%7D%20%20-%20%5Cmathbf%7BT%7D%20%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%20%20%5Cmathbf%7BV%5E%7B-1%7DZG%7D%20%5C%5C%0A%0A%26%3D%5Cmathbf%7B0%7D%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>根据通式</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7BVar%7D%28%5Chat%7B%5Cmathbf%7Bw%7D%7D-%5Cmathbf%7Bw%7D%29%0A%3D%26%20%5Coperatorname%7BVar%7D(%5Cmathbf%7B%5Chat%7Bw%7D%7D)-%5Coperatorname%7BCov%7D%5Cleft(%5Chat%7B%5Cmathbf%7Bw%7D%7D%2C%20%5Cmathbf%7Bw%7D%5E%7B%5Cprime%7D%5Cright)-%5Coperatorname%7BCov%7D%5Cleft(%5Cmathbf%7Bw%7D%2C%20%5Chat%7B%5Cmathbf%7Bw%7D%7D%5E%7B%5Cprime%7D%5Cright)%2B%5Coperatorname%7BVar%7D(%5Cmathbf%7Bw%7D)%20%5C%5C%0A%0A%3D%26%20%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BK%7D-%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%20%5C%5C%0A%26-%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BK%7D-%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%20%5C%5C%0A%26%2B%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D%20%2B%5Cmathbf%7BG%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7BVar%7D%28%5Chat%7B%5Cmathbf%7Bu%7D%7D-%5Cmathbf%7Bu%7D%29%0A%26%3D%20-%5Cmathbf%7BGZ'V%5E%7B-1%7DZG%7D%20%2B%20%5Cmathbf%7BGZ'%7D%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BZG%7D%20%2B%20%5Cmathbf%7BG%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BG%7D-%5Cmathbf%7BG%20Z%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%5Cleft(%5Cmathbf%7BI%7D-%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%5Cright)%20%5Cmathbf%7BZ%20G%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><h3 id="系数矩阵广义逆矩阵的性质">系数矩阵广义逆矩阵的性质</h3>
<p>假设混合模型方程组的系数矩阵的<strong>任意一个对称的</strong>广义逆矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BC%7D_%7B11%7D%20%26%20%5Cmathbf%7BC%7D_%7B12%7D%20%5C%5C%0A%5Cmathbf%7BC%7D_%7B12%7D%5E%7B%5Cprime%7D%20%26%20%5Cmathbf%7BC%7D_%7B22%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>则存在下式</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Coperatorname%7BVar%7D%28%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%29%3D%5Cmathbf%7B%20C%7D_%7B11%7D%20%20%5C%5C%0A%26%5Coperatorname%7BVar%7D(%5Chat%7B%5Cmathbf%7Bu%7D%7D)%3D%5Coperatorname%7BCov%7D(%5Chat%7B%5Cmathbf%7Bu%7D%7D%2C%20%5Cmathbf%7Bu%7D)%3D%5Cmathbf%7BG%7D-%5Cmathbf%7BC%7D_%7B22%7D%20%5C%5C%0A%26%5Coperatorname%7BVar%7D(%5Chat%7B%5Cmathbf%7Bu%7D%7D-%5Cmathbf%7Bu%7D)%3D%5Cmathbf%7BC%7D_%7B22%7D%20%5C%5C%0A%26%5Coperatorname%7BCov%7D%5Cleft(%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%2C%20%5Cquad%20%5Chat%7B%5Cmathbf%7Bu%7D%7D%5E%7B%5Cprime%7D%5Cright)%3D%5Cmathbf%7B0%7D%20%5C%5C%0A%26%5Coperatorname%7BCov%7D(%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%2C%20%5Cquad%20%5Cmathbf%7Bu%5E%7B%5Cprime%7D%7D)%3D-%5Cmathbf%7B%20C%7D_%7B12%7D%20%5C%5C%0A%26%5Coperatorname%7BCov%7D(%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%2C%20%5Cquad%20%5Chat%7B%5Cmathbf%7Bu%7D%7D%5E%7B%5Cprime%7D-%5Cmathbf%7Bu%7D%5E%7B%5Cprime%7D)%3D%5Cmathbf%7B%20C%7D_%7B12%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>下面的证明是基于<strong>系数矩阵满秩的前提下</strong>，即此时的广义逆就是逆矩阵存在下式成立。</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BC%7D_%7B11%7D%20%26%20%5Cmathbf%7BC%7D_%7B12%7D%20%5C%5C%0A%5Cmathbf%7BC%7D_%7B12%7D%5E%7B%5Cprime%7D%20%26%20%5Cmathbf%7BC%7D_%7B22%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%20%5C%5C%0A%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%26%20%0A%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%0A%0A%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BI%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BI%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>这是 Henderson 在 1975 年提出的，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%20%5C%5C%0A%5Chat%7B%5Cmathbf%7Bu%7D%7D%0A%5Cend%7Barray%7D%5Cright%29%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Blll%7D%0A%5Cmathbf%7BC%7D_%7B11%7D%20%26%20%26%20%5Cmathbf%7BC%7D_%7B12%7D%20%5C%5C%0A%5Cmathbf%7BC%7D_%7B12%7D%5E%7B%5Cprime%7D%20%26%20%26%20%5Cmathbf%7BC%7D_%7B22%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BQ%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5C%5C%0A%5Cmathbf%7BQ%7D_%7B2%7D%5E%7B%5Cprime%7D%0A%5Cend%7Barray%7D%5Cright)%20%5Cmathbf%7By%7D%0A" /></p><p>其中，我们设</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BQ%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5C%5C%0A%5Cmathbf%7BQ%7D_%7B2%7D%5E%7B%5Cprime%7D%0A%5Cend%7Barray%7D%5Cright%29%20%0A%3D%0A%5Cleft%5B%5Cbegin%7Barray%7D%7Blll%7D%0A%5Cmathbf%7BC%7D_%7B11%7D%20%26%20%26%20%5Cmathbf%7BC%7D_%7B12%7D%20%5C%5C%0A%5Cmathbf%7BC%7D_%7B12%7D%5E%7B%5Cprime%7D%20%26%20%26%20%5Cmathbf%7BC%7D_%7B22%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%20%5C%5C%0A%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>继续拆开，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BQ%7D_%7B1%7D%5E%7B%5Cprime%7D%20%26%3D%20%5Cmathbf%7BC%7D_%7B11%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%20%2B%20%5Cmathbf%7BC%7D_%7B12%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5C%5C%0A%5Cmathbf%7BQ%7D_%7B2%7D%5E%7B%5Cprime%7D%20%26%3D%20%5Cmathbf%7BC%7D_%7B12%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%20%2B%20%5Cmathbf%7BC%7D_%7B22%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>或者</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BQ%7D_%7B1%7D%20%26%3D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%5Cmathbf%7BX%7D%20%5Cmathbf%7BC%7D_%7B11%7D%20%20%20%2B%20%5Cmathbf%7BR%7D%5E%7B-1%7D%5Cmathbf%7BZ%7D%20%5Cmathbf%7BC%7D_%7B12%7D%5E%7B%5Cprime%7D%20%20%5C%5C%0A%5Cmathbf%7BQ%7D_%7B2%7D%20%26%3D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%5Cmathbf%7BX%7D%20%5Cmathbf%7BC%7D_%7B12%7D%20%20%20%2B%20%5Cmathbf%7BR%7D%5E%7B-1%7D%5Cmathbf%7BZ%7D%20%5Cmathbf%7BC%7D_%7B22%7D%20%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%20%26%3D%20%5Cmathbf%7BQ%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%5Cmathbf%7B%5Chat%7Bu%7D%7D%20%26%3D%20%5Cmathbf%7BQ%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>我们可以得到下面这个等式</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BQ%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5C%5C%0A%5Cmathbf%7BQ%7D_%7B2%7D%5E%7B%5Cprime%7D%0A%5Cend%7Barray%7D%5Cright%5D%5B%5Cmathbf%7BX%7D%20%5Cquad%20%5Cvdots%20%5Cquad%20%20%5Cmathbf%7BZ%7D%5D%20%0A%26%3D%0A%5Cleft%5B%5Cbegin%7Barray%7D%7Blll%7D%0A%5Cmathbf%7BC%7D_%7B11%7D%20%26%20%26%20%5Cmathbf%7BC%7D_%7B12%7D%20%5C%5C%0A%5Cmathbf%7BC%7D_%7B12%7D%5E%7B%5Cprime%7D%20%26%20%26%20%5Cmathbf%7BC%7D_%7B22%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%20%5C%5C%0A%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%0A%5Cend%7Barray%7D%5Cright%5D%20%5B%5Cmathbf%7BX%7D%20%5Cquad%20%5Cvdots%20%5Cquad%20%20%5Cmathbf%7BZ%7D%5D%20%0A%5C%5C%0A%26%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BC%7D_%7B11%7D%20%26%20%5Cmathbf%7BC%7D_%7B12%7D%20%5C%5C%0A%5Cmathbf%7BC%7D_%7B12%7D%5E%7B%5Cprime%7D%20%26%20%5Cmathbf%7BC%7D_%7B22%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%28%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%20%5C%5C%0A%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%20%26%20%0A%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%0A%5Cend%7Barray%7D%5Cright%5D-%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BG%7D%5E%7B-1%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cright%29%20%5C%5C%0A%26%3D%5Cleft(%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BI%7D%20%26%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BI%7D%0A%5Cend%7Barray%7D%5Cright)-%5Cleft(%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BC%7D_%7B12%7D%20%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BC%7D_%7B22%7D%20%5Cmathbf%7BG%7D%5E%7B-1%7D%0A%5Cend%7Barray%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>因此我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cmathbf%7BQ_%7B1%7D%5E%7B%5Cprime%7D%20X%3DI%7D%20%5C%5C%0A%26%5Cmathbf%7BQ_%7B1%7D%5E%7B%5Cprime%7D%20Z%3D-C_%7B12%7D%20G%5E%7B-1%7D%7D%20%20%5C%5C%0A%26%5Cmathbf%7BQ_%7B2%7D%5E%7B%5Cprime%7D%20X%3D0%7D%20%20%5C%5C%0A%26%5Cmathbf%7BQ_%7B2%7D%5E%7B%5Cprime%7D%20Z%3DI-C_%7B22%7D%20G%5E%7B-1%7D%7D%20%0A%5Cend%7Baligned%7D%0A" /></p><p>利用这些结果，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7BVar%7D%28%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%29%0A%26%3D%5Coperatorname%7BVar%7D(%5Cmathbf%7BQ%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D)%5C%5C%0A%26%3D%5Cmathbf%7BQ%7D_%7B1%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BR%7D%2B%5Cmathbf%7BZ%7D%20%5Cmathbf%7BG%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%5Cright)%20%5Cmathbf%7BQ%7D_%7B1%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BQ%7D_%7B1%7D%5E%7B%5Cprime%7D%5Cmathbf%7BR%7D%5Cmathbf%7BQ%7D_%7B1%7D%2B%20%5Cmathbf%7BQ%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7BG%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BQ%7D_%7B1%7D%20%5C%5C%0A%0A%26%3D%5Cmathbf%7BQ%7D_%7B1%7D%5E%7B%5Cprime%7D%5Cmathbf%7BR%7D%20%5Cleft(%20%5Cmathbf%7BR%7D%5E%7B-1%7D%5Cmathbf%7BX%7D%20%5Cmathbf%7BC%7D_%7B11%7D%20%20%20%2B%20%5Cmathbf%7BR%7D%5E%7B-1%7D%5Cmathbf%7BZ%7D%20%5Cmathbf%7BC%7D_%7B12%7D%5E%7B%5Cprime%7D%20%5Cright)%2B%20%5Cmathbf%7BQ%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D%20%5Cmathbf%7BG%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BQ%7D_%7B1%7D%20%5C%5C%0A%0A%26%3D%5Cmathbf%7BQ%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%20C%7D_%7B11%7D%2B%5Cmathbf%7BQ%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%20C%7D_%7B12%7D%5E%7B%5Cprime%7D%2B(%5Cmathbf%7BQ%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D)%20%5Cmathbf%7B%20G%20%7D%20(%5Cmathbf%7BQ%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D)%5E%7B%5Cprime%7D%20%5C%5C%0A%0A%26%3D%5Cmathbf%7BI%20C%7D_%7B11%7D-%5Cmathbf%7BC%7D_%7B12%7D%20%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D_%7B12%7D%5E%7B%5Cprime%7D%2B%20(-%5Cmathbf%7BC%7D_%7B12%7D%20%5Cmathbf%7B%20G%20%7D%5E%7B-1%7D)%20%5Cmathbf%7B%20G%20%7D%20(-%5Cmathbf%7BC%7D_%7B12%7D%20%5Cmathbf%7B%20G%20%7D%5E%7B-1%7D)%5E%7B%5Cprime%7D%20%5C%5C%0A%26%3D%5Cmathbf%7B%20C%7D_%7B11%7D-%5Cmathbf%7BC%7D_%7B12%7D%20%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D_%7B12%7D%5E%7B%5Cprime%7D%2B%20%5Cmathbf%7BC%7D_%7B12%7D%20%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D_%7B12%7D%5E%7B%5Cprime%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BC%7D_%7B11%7D%0A%5Cend%7Baligned%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7BCov%7D%5Cleft%28%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%2C%20%5Chat%7B%5Cmathbf%7Bu%7D%7D%5E%7B%5Cprime%7D%5Cright%29%20%0A%26%3D%5Coperatorname%7BCov%7D%5Cleft(%20%5Cmathbf%7BQ%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%2C%20(%5Cmathbf%7BQ%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D)%5E%7B%5Cprime%7D%5Cright)%20%20%5C%5C%0A%26%3D%5Cmathbf%7BQ%7D_%7B1%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BR%7D%2B%5Cmathbf%7BZGZ%7D%5E%7B%5Cprime%7D%5Cright)%20%5Cmathbf%7BQ%7D_%7B2%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BQ%7D_%7B1%7D%5E%7B%5Cprime%7D%5Cmathbf%7BR%7D%5Cmathbf%7BQ%7D_%7B2%7D%2B%5Cmathbf%7BQ%7D_%7B1%7D%5E%7B%5Cprime%7D%5Cmathbf%7BZGZ%7D%5E%7B%5Cprime%7D%5Cmathbf%7BQ%7D_%7B2%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BQ%7D_%7B1%7D%5E%7B%5Cprime%7D%5Cmathbf%7BR%7D%20%5Cleft(%20%20%5Cmathbf%7BR%7D%5E%7B-1%7D%5Cmathbf%7BX%7D%20%5Cmathbf%7BC%7D_%7B12%7D%20%20%20%2B%20%5Cmathbf%7BR%7D%5E%7B-1%7D%5Cmathbf%7BZ%7D%20%5Cmathbf%7BC%7D_%7B22%7D%5Cright)%20%2B(%5Cmathbf%7BQ%7D_%7B1%7D%5E%7B%5Cprime%7D%5Cmathbf%7BZ%7D)%5Cmathbf%7BG%7D(%5Cmathbf%7BQ%7D_%7B2%7D%5E%7B%5Cprime%7D%5Cmathbf%7BZ%7D)%5E%7B%5Cprime%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BQ%7D_%7B1%7D%7B%20%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%20C%7D_%7B12%7D%2B%5Cmathbf%7BQ%7D_%7B1%7D%7B%20%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%20C%7D_%7B22%7D%2B(%5Cmathbf%7BQ%7D_%7B1%7D%5E%7B%5Cprime%7D%5Cmathbf%7BZ%7D)%5Cmathbf%7BG%7D(%5Cmathbf%7BQ%7D_%7B2%7D%5E%7B%5Cprime%7D%5Cmathbf%7BZ%7D)%5E%7B%5Cprime%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BI%20C%7D_%7B12%7D-%5Cmathbf%7BC%7D_%7B12%7D%20%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D_%7B22%7D-%5Cmathbf%7BC%7D_%7B12%7D%20%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5Cmathbf%7BG%7D%5Cleft(%5Cmathbf%7BI%7D-%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5Cmathbf%7BC%7D_%7B22%7D%5Cright)%20%5C%5C%0A%26%3D%20%5Cmathbf%7B0%7D%0A%5Cend%7Baligned%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7BCov%7D%5Cleft%28%5Cboldsymbol%7B%5Chat%7B%5Cmathbf%7B%5Cbeta%7D%7D%7D%2C%20%5Cmathbf%7Bu%7D%5E%7B%5Cprime%7D%5Cright%29%0A%26%3D%20%5Coperatorname%7BCov%7D%5Cleft(%5Cmathbf%7BQ%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%2C%20%5Cmathbf%7Bu%7D%5E%7B%5Cprime%7D%5Cright)%20%5C%5C%0A%26%3D%5Cmathbf%7BQ%7D_%7B1%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZG%7D%20%5C%5C%0A%26%3D-%5Cmathbf%7BC%7D_%7B12%7D%20%5Cmathbf%7BG%7D%5E%7B-1%7D%20%5Cmathbf%7BG%7D%20%5C%5C%0A%26%3D-%5Cmathbf%7BC%7D_%7B12%7D%20%0A%5Cend%7Baligned%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7BCov%7D%5Cleft%28%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%2C%20%5Cmathbf%7B%5Chat%7Bu%7D%5E%7B%5Cprime%7D-%5Cmathbf%7Bu%7D%5E%7B%5Cprime%7D%7D%5Cright%29%20%0A%26%3D%20%5Coperatorname%7BCov%7D%5Cleft(%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%2C%20%5Cmathbf%7B%5Chat%7Bu%7D%5E%7B%5Cprime%7D%7D%5Cright)%20-%20%5Coperatorname%7BCov%7D%5Cleft(%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%2C%20%5Cmathbf%7Bu%7D%5E%7B%5Cprime%7D%5Cright)%20%5C%5C%0A%26%3D0-%5Cleft(-%5Cmathbf%7BC%7D_%7B12%7D%5Cright)%20%5C%5C%0A%26%3D%5Cmathbf%7BC%7D_%7B12%7D%0A%5Cend%7Baligned%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7BVar%7D%28%5Chat%7B%5Cmathbf%7Bu%7D%7D%29%20%0A%26%3D%20%5Coperatorname%7BVar%7D(%5Cmathbf%7BQ%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D)%20%20%5C%5C%0A%26%3D%5Cmathbf%7BQ%7D_%7B2%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BR%7D%2B%5Cmathbf%7BZ%20G%20Z%7D%5E%7B%5Cprime%7D%5Cright)%20%5Cmathbf%7BQ%7D_%7B2%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BQ%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%20%5Cmathbf%7BQ%7D_%7B2%7D%20%2B%20(%5Cmathbf%7BQ%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D)%20%5Cmathbf%7BG%7D%20(%5Cmathbf%7BQ%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D)%5E%7B%5Cprime%7D%20%20%5C%5C%0A%26%3D%5Cmathbf%7BQ%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%20%5Cleft(%20%5Cmathbf%7BR%7D%5E%7B-1%7D%5Cmathbf%7BX%7D%20%5Cmathbf%7BC%7D_%7B12%7D%20%20%20%2B%20%5Cmathbf%7BR%7D%5E%7B-1%7D%5Cmathbf%7BZ%7D%20%5Cmathbf%7BC%7D_%7B22%7D%20%20%5Cright)%20%2B%20%5Cleft(%20%5Cmathbf%7BI-C_%7B22%7D%20G%5E%7B-1%7D%7D%20%5Cright)%20%5Cmathbf%7BG%7D%20%5Cleft(%20%5Cmathbf%7BI-%20G%5E%7B-1%7D%20C_%7B22%7D%7D%20%5Cright)%20%20%5C%5C%0A%0A%26%3D%5Cmathbf%7BQ%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%20C%7D_%7B12%7D%2B%5Cmathbf%7BQ%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%20C%7D_%7B22%7D%20%2B%20%5Cleft(%20%5Cmathbf%7BG-C_%7B22%7D%20%7D%20%5Cright)%20%20%5Cleft(%20%5Cmathbf%7BI-%20G%5E%7B-1%7D%20C_%7B22%7D%7D%20%5Cright)%20%20%5C%5C%0A%26%3D%5Cmathbf%7B0%7D%2B%5Cleft(%5Cmathbf%7BI%7D-%5Cmathbf%7BC%7D_%7B22%7D%20%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright)%20%5Cmathbf%7BC%7D_%7B22%7D%2B%20%5Cleft(%20%5Cmathbf%7BG-C_%7B22%7D%20%7D%20%5Cright)%20%20%5Cleft(%20%5Cmathbf%7BI-%20G%5E%7B-1%7D%20C_%7B22%7D%7D%20%5Cright)%20%5C%5C%0A%26%3D%5Cmathbf%7BC%7D_%7B22%7D-%5Cmathbf%7BC%7D_%7B22%7D%20%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cmathbf%7BC%7D_%7B22%7D%20%2B%20%5Cmathbf%7BG-C_%7B22%7D%20%7D%20-%20%5Cmathbf%7BC%7D_%7B22%7D%20%2B%5Cmathbf%7BC%7D_%7B22%7D%20%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cmathbf%7BC%7D_%7B22%7D%5C%5C%0A%0A%0A%26%3D%5Cmathbf%7BG%7D-%5Cmathbf%7BC%7D_%7B22%7D%0A%5Cend%7Baligned%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7BCov%7D%28%5Chat%7B%5Cmathbf%7Bu%7D%7D%2C%20%5Cmathbf%7Bu%7D%29%0A%26%3D%5Coperatorname%7BCov%7D(%20%5Cmathbf%7BQ%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%2C%20%5Cmathbf%7Bu%7D)%20%5C%5C%0A%26%3D%5Cmathbf%7BQ%7D_%7B2%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%20G%7D%20%5C%5C%0A%26%3D%5Cleft(%5Cmathbf%7BI%7D-%5Cmathbf%7BC%7D_%7B22%7D%20%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright)%20%5Cmathbf%7BG%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BG%7D-%5Cmathbf%7BC%7D_%7B22%7D%0A%5Cend%7Baligned%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7BVar%7D%28%5Chat%7B%5Cmathbf%7Bu%7D%7D-%5Cmathbf%7Bu%7D%29%20%0A%26%3D%5Coperatorname%7BVar%7D(%5Chat%7B%5Cmathbf%7Bu%7D%7D)%0A-%20%5Coperatorname%7BCov%7D(%5Chat%7B%5Cmathbf%7Bu%7D%7D%2C%20%5Cmathbf%7Bu%7D)%0A-%20%5Coperatorname%7BCov%7D(%5Cmathbf%7Bu%7D%2C%20%5Chat%7B%5Cmathbf%7Bu%7D%7D)%0A%2B%20%5Coperatorname%7BVar%7D(%5Cmathbf%7Bu%7D)%0A%5C%5C%0A%26%3D%5Cmathbf%7BG%7D-%5Cmathbf%7BC%7D_%7B22%7D-2%5Cleft(%5Cmathbf%7BG%7D-%5Cmathbf%7BC%7D_%7B22%7D%5Cright)%2B%5Cmathbf%7BG%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BC%7D_%7B22%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>全部证明完毕。</p>
<h2 id="简化方程组">简化方程组</h2>
<p>在家畜育种的实际运用中，我们常有</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BVar%7D%28%5Cmathbf%7Be%7D%29%3D%5Cmathbf%7BR%7D%3D%5Cmathbf%7BI%7D%20%5Csigma_%7Be%7D%5E%7B2%7D%2C%20%5Cquad%20%5Coperatorname%7BVar%7D(%5Cmathbf%7Bu%7D)%3D%5Cmathbf%7BG%7D%3D%5Cmathbf%7BA%7D%20%5Csigma_%7Bu%7D%5E%7B2%7D%0A" /></p><p>此时，我们可以对混合模型方程组的两侧均消去 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> ，得到一个简化版本</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D%20%5C%5C%0A%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%26%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D%2Bk%20%5Cmathbf%7BA%7D%5E%7B-1%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%20%5C%5C%0A%5Cmathbf%7B%5Chat%7Bu%7D%7D%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7BX%5E%7B%5Cprime%7D%20y%7D%20%5C%5C%0A%5Cmathbf%7BZ%5E%7B%5Cprime%7D%20y%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%0A" /></p><p>其中</p>
<p style=""><img src="https://math.now.sh?from=k%3D%5Csigma_%7Be%7D%5E%7B2%7D%20%2F%20%5Csigma_%7Bu%7D%5E%7B2%7D%0A" /></p><h2 id="优势">优势</h2>
<p>混合模型方程组中不涉及 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D" style="display:inline-block;margin: 0;"/> 矩阵，在常规评估中， <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> 计算比 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> 容易得多，当然这主要得益于 Henderson 提出了一种不用求逆直接构建  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> 的方法。</p>
<h1>参考文献</h1>
<ol>
<li>Henderson，1975，Best Linear Unbiased Estimation and Prediction under a Selection Model</li>
<li>Henderson，《Applications_of_Linear_Models_in_Animal_Breeding》, 1984</li>
<li>张沅，张勤，《畜禽育种中的线性模型》</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>混合线性模型二之选择指数法</title>
    <url>/posts/c9ff3048/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>混合线性模型理论的第二篇，如何估计随机效应的值（假设不存在固定效应或者已知固定效应）。上一篇见<a href="https://vincere.fun/posts/5e674d74/">混合线性模型一之广义最小二乘</a> 。</p>
<span id="more"></span>
<h1>代价函数</h1>
<p>这里运行机器学习的思想，不同的预测函数的好坏需要通过代价函数来计算比较，或者说我们需要通过最小化代价函数来确定一个合适的预测函数，因此首要的问题是确定一个合适的代价函数，也就是说我们如何定义“最佳”。</p>
<p>本节内容主要参考 Henderson 1973年的论文。</p>
<h2 id="最佳预测">最佳预测</h2>
<p>假设 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 是观测值向量，我们想要预测 <img src="https://math.now.sh?inline=%5Cmathbf%7Bw%7D" style="display:inline-block;margin: 0;"/> 向量， <img src="https://math.now.sh?inline=%5Cmathbf%7Bw%7D" style="display:inline-block;margin: 0;"/> 向量的第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 个元素的预测值为</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7Bw%7D_%7Bi%7D%20%3D%20f%28%5Cmathbf%7By%7D%29%0A" /></p><p>这里的 <img src="https://math.now.sh?inline=f" style="display:inline-block;margin: 0;"/> 是某个关于观测值的函数，不一定要是线性函数。</p>
<p>此时我们的问题是，我们如何定义“最佳”的预测函数？ 一种方式是我们想尽可能地减少预测误差 (<em>prediction error</em>) ，即 <img src="https://math.now.sh?inline=%5Chat%7Bw%7D_%7Bi%7D%20-%20w_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，那么我们如何去衡量预测误差的大小呢？从理论上，预测误差的大小可以用下式表示（等价于 <img src="https://math.now.sh?inline=L_%7Bp%7D" style="display:inline-block;margin: 0;"/> 范数）</p>
<p style=""><img src="https://math.now.sh?from=E%7C%5Chat%7Bw%7D_%7Bi%7D%20-%20w_%7Bi%7D%7C%5E%7Bp%7D%0A" /></p><p>即预测误差<strong>绝对值</strong>的 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> 次方的期望值。那么 <img src="https://math.now.sh?inline=p" style="display:inline-block;margin: 0;"/> 应该选多少呢？最普遍的选择是 2 ，因为 <img src="https://math.now.sh?inline=L_2" style="display:inline-block;margin: 0;"/> 范数计算简便，并且有其它优良性质。</p>
<p>我们将最小化 <img src="https://math.now.sh?inline=E%7C%5Chat%7Bw%7D_%7Bi%7D%20-%20w_%7Bi%7D%7C%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 的方法称为<strong>最小均方误差预测</strong> (Minimum Mean Square Error Prediction) ，有时也称为<strong>最佳预测</strong> (Best Prediction, <strong>BP</strong>) 。我们可以证明此时的估计值等价于下式 (<em>Cochran</em> , 1951 或 Rao 1965 )</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7Bw%7D_%7Bi%7D%20%3D%20%20E%28w_%7Bi%7D%20%7C%20%5Cmathbf%7By%7D%20%29%0A" /></p><p>也就是说等同于给定 $ \mathbf{y}$ 的 <img src="https://math.now.sh?inline=w_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的条件期望。</p>
<p>证明 (来自于 <a href="https://zh-cn.lambdageeks.com/conditional-variance-and-predictions/">条件方差和预测 | 其重要属性与 5+ 示例</a>) ：这里证明根据一个随机变量的观测值来预测另一个随机变量，假设我们有一个随机变量 X 的观测值，我们需要预测随机变量 Y ，证明最好的预测值为 <img src="https://math.now.sh?inline=E%28Y%7CX%29" style="display:inline-block;margin: 0;"/> 。假设 <img src="https://math.now.sh?inline=g%28X%29" style="display:inline-block;margin: 0;"/> 是任意一个预测函数，因此我们要证明</p>
<p style=""><img src="https://math.now.sh?from=E%5Cleft%5B%28Y-g(X%29)%5E%7B2%7D%5Cright%5D%20%5Cgeq%20E%5Cleft%5B(Y-E%5BY%20%5Cmid%20X%5D)%5E%7B2%7D%5Cright%5D%0A" /></p><p>我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%5Cleft%5B%28Y-g(X%29)%5E%7B2%7D%20%5Cmid%20X%5Cright%5D%3D%26%20E%5Cleft%5B(Y-E%5BY%20%5Cmid%20X%5D%2BE%5BY%20%5Cmid%20X%5D-g(X))%5E%7B2%7D%20%5Cmid%20X%5Cright%5D%20%5C%5C%0A%3D%26%20E%5Cleft%5B(Y-E%5BY%20%5Cmid%20X%5D)%5E%7B2%7D%20%5Cmid%20X%5Cright%5D%20%5C%5C%0A%26%2BE%5Cleft%5B(E%5BY%20%5Cmid%20X%5D-g(X))%5E%7B2%7D%20%5Cmid%20X%5Cright%5D%20%5C%5C%0A%26%2B2%20E%5B(Y-E%5BY%20%5Cmid%20X%5D)(E%5BY%20%5Cmid%20X%5D-g(X))%20%5Cmid%20X%5D%0A%5Cend%7Baligned%7D%0A" /></p><p>在给定 X 的前提下，<img src="https://math.now.sh?inline=%5Cmathrm%7BE%7D%5B%5Cmathrm%7BY%7D%20%5Cmid%20%5Cmathrm%7BX%7D%5D-%5Cmathrm%7Bg%7D%28%5Cmathrm%7BX%7D%29" style="display:inline-block;margin: 0;"/>  是一个常数，因此上式的最后一项为 0 ，证明如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26E%5B%28Y-E%5BY%20%5Cmid%20X%5D%29(E%5BY%20%5Cmid%20X%5D-g(X))%20%5Cmid%20X%5D%20%20%5C%5C%0A%26%3D(E%5BY%20%5Cmid%20X%5D-g(X))%20E%5BY-E%5BY%20%5Cmid%20X%5D%20%5Cmid%20X%5D%20%5C%5C%0A%26%3D(E%5BY%20%5Cmid%20X%5D-g(X))(E%5BY%20%5Cmid%20X%5D-E%5BY%20%5Cmid%20X%5D)%20%5C%5C%0A%26%3D0%0A%5Cend%7Baligned%7D%0A" /></p><p>因此下式成立</p>
<p style=""><img src="https://math.now.sh?from=E%5Cleft%5B%28Y-g(X%29)%5E%7B2%7D%20%5Cmid%20X%5Cright%5D%3D%20E%5Cleft%5B(Y-E%5BY%20%5Cmid%20X%5D)%5E%7B2%7D%20%5Cmid%20X%5Cright%5D%20%0A%2BE%5Cleft%5B(E%5BY%20%5Cmid%20X%5D-g(X))%5E%7B2%7D%20%5Cmid%20X%5Cright%5D%20%5C%5C%0A" /></p><p>其中右手第二项是一个非负数，因此下式成立</p>
<p style=""><img src="https://math.now.sh?from=E%5Cleft%5B%28Y-g(X%29)%5E%7B2%7D%5Cright%5D%20%5Cgeq%20E%5Cleft%5B(Y-E%5BY%20%5Cmid%20X%5D)%5E%7B2%7D%5Cright.%0A" /></p><p>得证。</p>
<p>因此我们必须先已知 <img src="https://math.now.sh?inline=%5B%5Cmathbf%7By%7D%2C%20%5Cmathbf%7Bw%7D%5D" style="display:inline-block;margin: 0;"/> 的联合分布，然后再推导条件分布。</p>
<p><strong>BP</strong> 的一些性质如下：</p>
<ol>
<li><img src="https://math.now.sh?inline=E%28%5Chat%7Bw%7D_%7Bi%7D%29%20%3D%20%20E(w_%7Bi%7D)" style="display:inline-block;margin: 0;"/></li>
<li><img src="https://math.now.sh?inline=Var%28%5Chat%7B%5Cmathbf%7Bw%7D%7D-%20%5Cmathbf%7Bw%7D%20%29%20%3D%20%5Ctext%7B%20average%20conditional%20%7D%20Var(%5Cmathbf%7Bw%20%7C%20y%7D)" style="display:inline-block;margin: 0;"/> 。这个没看懂，感觉怪怪的。</li>
<li>在所有可能的预测值中，<img src="https://math.now.sh?inline=%5Chat%7Bw%7D_%7Bi%7D%20%3D%20%20E%28w_%7Bi%7D%20%7C%20%5Cmathbf%7By%7D%20%29" style="display:inline-block;margin: 0;"/> 最大化了 <img src="https://math.now.sh?inline=%5Chat%7Bw%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=w_%7Bi%7D" style="display:inline-block;margin: 0;"/> 的相关</li>
</ol>
<h1>最佳线性预测</h1>
<p>通常在实践中，我们不知道 <img src="https://math.now.sh?inline=%5B%5Cmathbf%7By%7D%2C%20%5Cmathbf%7Bw%7D%5D" style="display:inline-block;margin: 0;"/> 的联合分布 ，我们就也没有办法计算条件分布。那么此时我们怎么办呢？我们可以将预测值的范围限制为<strong>线性</strong>预测值，这样我们可以极大地简化问题。我们称这种方法为 <strong>最佳线性预测</strong> (Best Linear Prediction, <strong>BLP</strong>)，也就是育种值估计方法中的<strong>选择指数法</strong> (Selection Index) 。</p>
<p>我们先看一般 <strong>最佳线性预测</strong>的一般推导，假设我们的观测值向量为 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，我们需要预测的随机变量是 <img src="https://math.now.sh?inline=w" style="display:inline-block;margin: 0;"/> （注意这里我们采用单个变量），我们采用的线性预测函数为 <img src="https://math.now.sh?inline=%5Chat%7Bw%7D%20%3D%20%5Cmathbf%7Ba'y%7D%20%2B%20b" style="display:inline-block;margin: 0;"/> ，这里 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba'%7D" style="display:inline-block;margin: 0;"/> 是一个向量，<img src="https://math.now.sh?inline=b" style="display:inline-block;margin: 0;"/> 是一个标量。我们的目标是找到一组  <img src="https://math.now.sh?inline=%5Cmathbf%7Ba'%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=b" style="display:inline-block;margin: 0;"/>，使得 <img src="https://math.now.sh?inline=E%28%5Chat%7Bw%7D%20-%20w%29%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 最小。</p>
<p>均值，协方差等设定如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%28w%29%20%26%3D%5Cgamma%2C%20%5C%5C%0AE(%5Cmathbf%7By%7D)%20%26%3D%20%5Cboldsymbol%7B%5Calpha%7D%2C%20%5C%5C%0A%5Coperatorname%7BCov%7D(%5Cmathbf%7By%7D%2C%20w)%20%26%3D%5Cmathbf%7Bc%7D%2C%20%5Ctext%20%7B%20and%20%7D%20%5C%5C%0A%5Coperatorname%7BVar%7D(%5Cmathbf%7By%7D)%20%26%3D%5Cmathbf%7BV%7D%20%0A%5Cend%7Baligned%7D%0A" /></p><p>那么</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%5Cleft%28%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%2Bb-w%5Cright%29%5E%7B2%7D%0A%3D%26E%5Cleft((%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D)%5E%7B2%7D%2Bb%5E%7B2%7D%2Bw%5E%7B2%7D%2B2(%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D)b-2(%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D)w-2bw%5Cright)%5C%5C%0A%3D%26E((%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D)%5E%7B2%7D)%2Bb%5E%7B2%7D%2BE(w%5E%7B2%7D)%2B2E((%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D))b-2E((%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D)w)-2bE(w)%5C%5C%0A%3D%26%20%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%20a%7D%20%2B%20(%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Calpha%7D)%5E2%20%2B%20b%5E%7B2%7D%20%2B%20%5Coperatorname%7BVar%7D(w)%2B%5Cgamma%5E%7B2%7D%2B2%20%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Calpha%7D%20b%20-%202%20%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20(%5Cmathbf%7Bc%7D%2B%20%5Cboldsymbol%7B%5Calpha%7D%20%5Cgamma)%20-2b%20%5Cgamma%5C%5C%0A%0A%3D%26%20%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%20a%7D%20%2B%20%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Calpha%7D%20%5Cboldsymbol%7B%5Calpha%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Ba%7D%20%20%2B%20b%5E%7B2%7D%20%2B%20%5Coperatorname%7BVar%7D(w)%2B%5Cgamma%5E%7B2%7D%2B2%20%20b%20%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Calpha%7D%20-%202%20%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bc%7D-%202%20%5Cgamma%20%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Calpha%7D%20%20-2b%20%5Cgamma%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>分别对   <img src="https://math.now.sh?inline=%5Cmathbf%7Ba'%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=b" style="display:inline-block;margin: 0;"/> 求偏导，使之为 0，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cpartial%20L_%7B2%7D%20%2F%20%5Cpartial%20%5Cmathbf%7Ba%7D%3D%202%5Cmathbf%7BV%7D%20%5Cmathbf%7Ba%7D%2B%202%5Cboldsymbol%7B%5Calpha%20%5Calpha%5E%7B%5Cprime%7D%7D%20%5Cmathbf%7Ba%7D%2B%202b%20%5Cboldsymbol%7B%5Calpha%7D%20-%202%20%5Cmathbf%7Bc%7D%20-%202%20%5Cgamma%20%5Cboldsymbol%7B%5Calpha%7D%20%3D%20%5Cmathbf%7B0%7D%20%5C%5C%0A%26%5Cpartial%20L_%7B2%7D%20%2F%20%5Cpartial%20b%3D2b%2B2%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Calpha%7D%20-%202%20%5Cgamma%3D%200%0A%5Cend%7Baligned%7D%0A" /></p><p>整理得到下面的方程组</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BV%7D%2B%5Cboldsymbol%7B%5Calpha%20%5Calpha%5E%7B%5Cprime%7D%7D%20%26%20%5Cboldsymbol%7B%5Calpha%7D%20%5C%5C%0A%5Cboldsymbol%7B%5Calpha%5E%7B%5Cprime%7D%7D%20%26%201%0A%5Cend%7Barray%7D%5Cright%29%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7Ba%7D%20%5C%5C%0Ab%0A%5Cend%7Barray%7D%5Cright)%3D%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7Bc%7D%2B%5Cboldsymbol%7B%5Calpha%7D%20%5Cgamma%20%5C%5C%0A%5Cgamma%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>根据第二个方程，我们得到 <img src="https://math.now.sh?inline=b%20%3D%20%5Cgamma%20-%20%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Calpha%7D%20%3D%20%5Cgamma%20-%20%20%5Cboldsymbol%7B%5Calpha%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Ba%7D" style="display:inline-block;margin: 0;"/> ，带入到第一个方程得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%28%5Cmathbf%7BV%7D%2B%5Cboldsymbol%7B%5Calpha%20%5Calpha%5E%7B%5Cprime%7D%7D%29%20%5Cmathbf%7Ba%7D%20%2B%20(%5Cgamma%20-%20%5Cboldsymbol%7B%5Calpha%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Ba%7D)%20%5Cboldsymbol%7B%5Calpha%7D%20%20-%20%5Cmathbf%7Bc%7D%20-%20%20%5Cgamma%20%5Cboldsymbol%7B%5Calpha%7D%20%26%3D%20%5Cmathbf%7B0%7D%20%5C%5C%20%0A(%5Cmathbf%7BV%7D%2B%5Cboldsymbol%7B%5Calpha%20%5Calpha%5E%7B%5Cprime%7D%7D)%20%5Cmathbf%7Ba%7D%20-%20%20(%5Cboldsymbol%7B%5Calpha%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Ba%7D)%5Cboldsymbol%7B%5Calpha%7D%20%20-%20%5Cmathbf%7Bc%7D%20%26%3D%20%5Cmathbf%7B0%7D%20%5C%5C%20%0A(%5Cmathbf%7BV%7D%2B%5Cboldsymbol%7B%5Calpha%20%5Calpha%5E%7B%5Cprime%7D%7D)%20%5Cmathbf%7Ba%7D%20-%20%5Cboldsymbol%7B%5Calpha%7D%20(%5Cboldsymbol%7B%5Calpha%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Ba%7D)%20%20-%20%5Cmathbf%7Bc%7D%20%26%3D%20%5Cmathbf%7B0%7D%20%5C%5C%20%0A%5Cmathbf%7BVa%7D%20%26%3D%20%5Cmathbf%7Bc%7D%20%5C%5C%0A%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>因此我们得到解为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Ba%7D%20%3D%20%5Cmathbf%7BV%5E%7B-1%7Dc%7D%2C%20%5Cquad%20b%20%3D%20%20%5Cgamma-%5Cboldsymbol%7B%5Calpha%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7Bc%7D%0A" /></p><p>因此，预测值为</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7Bw%7D%3D%5Cgamma%2B%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%28%5Cmathbf%7By%7D-%5Cboldsymbol%7B%5Calpha%7D%29%0A" /></p><p>从单个元素推广至向量，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%5Chat%7Bw%7D%7D%3D%5Cboldsymbol%7B%5Cgamma%7D%2B%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%28%5Cmathbf%7By%7D-%5Cboldsymbol%7B%5Calpha%7D%29%0A" /></p><p>其中，<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cgamma%7D%20%3D%20E%28%5Cmathbf%7Bw%7D%29" style="display:inline-block;margin: 0;"/>  ， <img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D%20%3D%20Cov%28%5Cmathbf%7By%7D%2C%20%5Cmathbf%7Bw%7D%5E%7B%5Cprime%7D%29" style="display:inline-block;margin: 0;"/> 。</p>
<p>当 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%2C%20w" style="display:inline-block;margin: 0;"/> 的共同分布为多元正态分布时，BLP 就是 <img src="https://math.now.sh?inline=E%28w%20%5Cmid%20y%29" style="display:inline-block;margin: 0;"/> ，即此时 BLP = BP 。</p>
<h2 id="均值及协方差">均值及协方差</h2>
<p>首先我们看期望，BLP是一个无偏估计值，即</p>
<p style=""><img src="https://math.now.sh?from=E%28%5Chat%7Bw%7D%29%3DE(w)%0A" /></p><p>证明：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%28%5Chat%7Bw%7D%29%20%26%3DE%5Cleft%5B%5Cgamma%2B%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cboldsymbol%7B%5Calpha%7D)%5Cright%5D%20%5C%5C%0A%26%3D%5Cgamma%2B%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D(%5Cboldsymbol%7B%5Calpha%7D-%5Cboldsymbol%7B%5Calpha%7D)%20%5C%5C%0A%26%3D%5Cgamma%3DE(w)%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>其协方差矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BVar%7D%28%5Chat%7Bw%7D%29%3D%5Coperatorname%7BVar%7D%5Cleft(%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%5Cright)%3D%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7Bc%7D%3D%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7Bc%7D%0A" /></p><p>其与真实值的协方差矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BCov%7D%28%5Chat%7Bw%7D%2C%20w%29%3D%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Coperatorname%7BCov%7D(%5Cmathbf%7By%7D%2C%20w)%3D%5Cmathbf%7Bc%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7Bc%7D%3D%5Coperatorname%7BVar%7D(%5Chat%7Bw%7D)%0A" /></p><p>误差方差为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7BVar%7D%28%5Chat%7Bw%7D-w%29%26%3D%5Coperatorname%7BVar%7D(w)%2B%5Coperatorname%7BVar%7D(%5Chat%7Bw%7D)-2%5Coperatorname%7BCov%7D(%5Chat%7Bw%7D%2C%20w)%5C%5C%0A%26%3D%5Coperatorname%7BVar%7D(w)%2B%5Coperatorname%7BVar%7D(%5Chat%7Bw%7D)-2%5Coperatorname%7BVar%7D(%5Chat%7Bw%7D)%5C%5C%0A%26%3D%5Coperatorname%7BVar%7D(w)-%5Coperatorname%7BVar%7D(%5Chat%7Bw%7D)%0A%5Cend%7Baligned%7D%0A" /></p><p>下面我们证明 BLP 最大化了 <img src="https://math.now.sh?inline=r_%7B%5Chat%7Bw%7D%20w%7D" style="display:inline-block;margin: 0;"/> ，根据相关系数公式，我们有一般公式</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ar_%7B%5Chat%7Bw%7D%20w%7D%20%26%3D%20%5Cfrac%7BCov%28%5Chat%7Bw%7D%20%2Cw%29%7D%7B%5Cleft(Var(%5Chat%7Bw%7D%20)%20Var(w)%5Cright)%5E%7B0.5%7D%7D%20%5C%5C%0A%26%3D%20%5Cfrac%7BCov(%5Cmathbf%7Ba'y%7D%20%2B%20b%20%2Cw)%7D%7B%5Cleft(Var(%5Cmathbf%7Ba'y%7D%20%2B%20b)%20Var(w)%5Cright)%5E%7B0.5%7D%7D%20%5C%5C%0A%26%3D%20%5Cfrac%7B%5Cmathbf%7Ba'c%7D%7D%7B%5Cleft(%5Cmathbf%7Ba'Va%7D%20%20Var(w)%5Cright)%5E%7B0.5%7D%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>取对数（容易看出  <img src="https://math.now.sh?inline=r_%7B%5Chat%7Bw%7D%20w%7D%20%3E%200" style="display:inline-block;margin: 0;"/> ），得到</p>
<p style=""><img src="https://math.now.sh?from=%5Clog%20r%3D%5Clog%20%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bc%7D-0.5%20%5Clog%20%5Cleft%5B%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7Ba%7D%5Cright%5D-0.5%20%5Clog%20%5Coperatorname%7BVar%7D%28w%29%0A" /></p><p>对 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D" style="display:inline-block;margin: 0;"/> 微分，使之为 0 ，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cpartial%20%5Clog%20r%20%2F%5Cpartial%20%5Cmathbf%7Ba%7D%20%3D%20%5Cfrac%7B%5Cmathbf%7Bc%7D%7D%7B%5Cmathbf%7Ba'c%7D%7D%20-%20%5Cfrac%7B%5Cmathbf%7BVa%7D%7D%7B%5Cmathbf%7Ba'Va%7D%7D%20%3D%20%5Cmathbf%7B0%7D%0A" /></p><p>我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%5Cmathbf%7Bc%7D%7D%7B%5Cmathbf%7Ba'c%7D%7D%20%3D%20%5Cfrac%7B%5Cmathbf%7BVa%7D%7D%7B%5Cmathbf%7Ba'Va%7D%7D%0A" /></p><p>注意到两边的分母均为标量，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BVa%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Bc%7D" style="display:inline-block;margin: 0;"/> 这两个向量平行，即满足下式，其中 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 是一个标量</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BVa%7D%20%3D%20k%20%5Cmathbf%7Bc%7D%0A" /></p><p>因此，我们得到 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%20%3D%20k%20%5Cmathbf%7BV%5E%7B-1%7Dc%7D" style="display:inline-block;margin: 0;"/> ，带入到上式中，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%5Cmathbf%7Bc%7D%7D%7Bk%5Cmathbf%7Bc'V%5E%7B-1%7Dc%7D%7D%20%3D%20%5Cfrac%7B%5Cmathbf%7Bc%7D%7D%7Bk%5Cmathbf%7Bc'V%5E%7B-1%7Dc%7D%7D%0A" /></p><p>因此 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 可以取任意值，不妨设 <img src="https://math.now.sh?inline=k%3D1" style="display:inline-block;margin: 0;"/> ，此时 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%20%3D%20%5Cmathbf%7BV%5E%7B-1%7Dc%7D" style="display:inline-block;margin: 0;"/> ，即为 BLP 估计值，因此我们证明了 BLP  最大化了 <img src="https://math.now.sh?inline=r_%7B%5Chat%7Bw%7D%20w%7D" style="display:inline-block;margin: 0;"/> 。</p>
<h2 id="选择指数法">选择指数法</h2>
<p>下面的内容来自于张沅老师的 《畜禽育种中的线性模型》，选择指数法就是BLP在育种中的应用。</p>
<p>选择指数法需要满足三个条件或者假设：</p>
<ol>
<li>不存在系统环境效应，或者所有系统环境效应均已知</li>
<li>被选择的个体间不存在固定的遗传差异</li>
<li>误差和育种值的方差，协方差矩阵均已知</li>
</ol>
<p>其实前两个条件可以合并为不存在固定效应或者已知固定效应，也就是说此时的模型对应为<strong>随机模型</strong>。</p>
<p>根据定义，选择指数的公式为</p>
<p style=""><img src="https://math.now.sh?from=I%20%3D%20%5Csum%20b_%7Bi%7D%28y_%7Bi%7D%20-%20%5Cmu_%7Bi%7D%29%0A" /></p><p>其中：</p>
<p><img src="https://math.now.sh?inline=I" style="display:inline-block;margin: 0;"/> = 某个体一个性状的选择指数</p>
<p><img src="https://math.now.sh?inline=b_%7Bi%7D" style="display:inline-block;margin: 0;"/> = 与该个体有关的第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 个信息的加权系数（偏回归系数）</p>
<p><img src="https://math.now.sh?inline=y_%7Bi%7D" style="display:inline-block;margin: 0;"/> = 第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 个信息来源的表型值</p>
<p><img src="https://math.now.sh?inline=u_%7Bi%7D" style="display:inline-block;margin: 0;"/> = 与该表型值对应的总体均数</p>
<p>上式可以用矩阵形式表示：</p>
<p style=""><img src="https://math.now.sh?from=I%3D%5Cmathbf%7Bb'd%7D%0A" /></p><p>其中：</p>
<p><img src="https://math.now.sh?inline=%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> = 加权系数向量</p>
<p>$\mathbf{d=y- \boldsymbol{\mu}} $ ，即各信息来源的表型值与各自的群体平均数离差向量</p>
<p>我们确定了选择指数的公式之后，我们需要找一组合适的加权系数，设该个体的真实育种值为 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> ，则代价函数为  <img src="https://math.now.sh?inline=E%28I-A%29%5E%7B2%7D" style="display:inline-block;margin: 0;"/>  ，根据协方差公式，我们有 $ Var(I-A) = E(I-A)^{2} -  (E(I-A))^{2} = E(I-A)^{2}$ ，因此等价于需要一个 <img src="https://math.now.sh?inline=%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> 向量使得误差方差  $ Var(I-A) $ 最小，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7BVar%7D%28I-A%29%20%26%3D%5Coperatorname%7BVar%7D(I)%2B%5Coperatorname%7BVar%7D(A)-2%20%5Coperatorname%7BCov%7D(I%2C%20A)%20%5C%5C%0A%26%3D%5Coperatorname%7BVar%7D%5Cleft(%5Cmathbf%7Bb%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bd%7D%5Cright)%2B%5Csigma_%7BA%7D%5E%7B2%7D-2%20%5Coperatorname%7BCov%7D%5Cleft(%5Cmathbf%7Bb%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bd%7D%2C%20A%5Cright)%20%5C%5C%0A%26%3D%5Cmathbf%7Bb%7D%5E%7B%5Cprime%7D%20%5Coperatorname%7B%5Cmathbf%7BVb%7D%7D%2B%5Csigma_%7BA%7D%5E%7B2%7D-2%20%5Cmathbf%7Bb%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bc%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>其中</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BV%7D%3D%5Coperatorname%7BVar%7D%28%5Cmathbf%7Bd%7D%29%3D%5Coperatorname%7BVar%7D(%5Cmathbf%7By%7D-%5Cboldsymbol%7B%5Cmu%7D)%3D%5Coperatorname%7BVar%7D(%5Cmathbf%7By%7D)%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bc%7D%3D%5Coperatorname%7BCov%7D%28%5Cmathbf%7Bd%7D%2C%20%5Cmathrm%7BA%7D%29%3D%5Coperatorname%7BCov%7D(%5Cmathbf%7By%7D%2C%20%5Cmathrm%7BA%7D)%0A" /></p><p>求上式关于 <img src="https://math.now.sh?inline=%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> 的最小值，我们求偏导数，使之为 <img src="https://math.now.sh?inline=%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> 得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20b%7D%20%5Coperatorname%7BVar%7D%28I-A%29%3D2%20%5Cmathbf%7BVb%7D-2%20%5Cmathbf%7B%20c%7D%3D%5Cmathbf%7B0%7D%0A" /></p><p>我们得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BVb%20%3D%20c%7D" style="display:inline-block;margin: 0;"/> ，因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bb%20%3D%20V%5E%7B-1%7D%20c%7D%0A" /></p><p>如果我们根据单一表型来预测育种值，即此时 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 是一个标量，那么有</p>
<p style=""><img src="https://math.now.sh?from=b%20%3D%20%5Cmathbf%7B%20%20V%5E%7B-1%7D%20c%20%7D%20%3D%20%28Cov(y%29)%5E%7B-1%7D%20Cov(y%2CA)%20%3D%20%5Cfrac%7BCov(y%2CA)%7D%7BCov(y)%7D%0A" /></p><p>根据数量遗传学理论，我们知道两个个体的加性遗传相关等于两个个体的育种值之间的相关，即</p>
<p style=""><img src="https://math.now.sh?from=a_%7BXY%7D%20%3D%20%5Cfrac%7BCov%28A_%7BX%7D%2CA_%7BY%7D%29%7D%7B%5Csigma_%7BX%7D%5Csigma_%7BY%7D%7D%0A" /></p><p>这里由于所有个体属于同一群体，因此我们有  <img src="https://math.now.sh?inline=%5Csigma_%7BX%7D%20%3D%20%5Csigma_%7BY%7D%20%3D%20%5Csigma_%7BA%7D" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=a_%7BXY%7D%20%3D%20%5Cfrac%7BCov%28A_%7BX%7D%2CA_%7BY%7D%29%7D%7B%5Csigma_%7BA%7D%5E%7B2%7D%7D" style="display:inline-block;margin: 0;"/> 。假设我们的目标个体称为 <img src="https://math.now.sh?inline=X" style="display:inline-block;margin: 0;"/> ，因此<img src="https://math.now.sh?inline=%5Cmathbf%7Bc%7D" style="display:inline-block;margin: 0;"/> 向量中的元素 $c_{i} =\operatorname{Cov}(y_{i}, \mathrm{A_{X}})  =\operatorname{Cov}(\mathrm{A_{i}+e_{i}}, \mathrm{A_{X}}) =\operatorname{Cov}(\mathrm{A_{i}}, \mathrm{A_{X}}) = a_{iX} \sigma_{A}^{2}  $  ，即等于相应的加性遗传相关乘以加性遗传方差。设 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D" style="display:inline-block;margin: 0;"/> 为个体与各信息来源的个体间加性遗传相关的向量，因此我们有 <img src="https://math.now.sh?inline=%5Cmathbf%7Bc%20%3D%20a%20%5Csigma_%7BA%7D%5E%7B2%7D%7D" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> 的计算公式可以写为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bb%20%3D%20V%5E%7B-1%7D%20%20a%20%5Csigma_%7BA%7D%5E%7B2%7D%7D%0A" /></p><p>因此，选择指数的基本公式可以写为：</p>
<p style=""><img src="https://math.now.sh?from=I%20%3D%20%5Cmathbf%7Bc'V%5E%7B-1%7D%28y-%5Cboldsymbol%7B%5Cmu%7D%29%7D%20%3D%20%5Csigma_%7BA%7D%5E%7B2%7D%20%5Cmathbf%7Ba'V%5E%7B-1%7D(y-%5Cboldsymbol%7B%5Cmu%7D)%7D%0A" /></p><p>从单个元素推广至向量，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BI%7D%3D%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%28%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D%29%3D%5Cmathbf%7BGZ'%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D(%5Cmathbf%7By%7D-%5Cmathbf%7BX%7D%5Cboldsymbol%7B%5Cbeta%7D)%0A" /></p><p>其中，<img src="https://math.now.sh?inline=%5Cmathbf%7BC%7D%5E%7B%5Cprime%7D%20%3D%20Cov%28%5Cboldsymbol%7B%5Cmu%7D%2C%20%5Cmathbf%7By%7D%5E%7B%5Cprime%7D%29%20%3D%20%5Cmathbf%7BGZ'%7D" style="display:inline-block;margin: 0;"/></p>
<p>选择指数估计的准确性的高低，直接取决于信息来源的种类和数量。而准确度的高低又直接关系到将获得的遗传进展的大小，所以这是一个非常重要的指标。<strong>准确性通常用真实育种值与估计育种值的相关系数来表示</strong>，即：</p>
<p style=""><img src="https://math.now.sh?from=r_%7BAI%7D%20%3D%20%5Cfrac%7BCov%28A%2CI%29%7D%7B%5Csigma_%7BA%7D%20%5Csigma_%7BI%7D%7D%0A" /></p><p>因为 <img src="https://math.now.sh?inline=%5Csigma_%7BI%7D%5E%7B2%7D%3D%5Cmathbf%7Bb%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%20b%7D%20%3D%20%5Cmathbf%7Bb%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bc%7D%2C%5Cquad%20%20%5Coperatorname%7BCov%7D%28A%2C%20I%29%3D%5Cmathbf%7Bb%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bc%7D%3D%5Csigma_%7BI%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，所以</p>
<p style=""><img src="https://math.now.sh?from=r_%7BAI%7D%20%3D%20%5Cfrac%7B%20%5Csigma_%7BI%7D%5E%7B2%7D%7D%7B%5Csigma_%7BA%7D%20%5Csigma_%7BI%7D%7D%20%3D%20%5Cfrac%7B%20%5Csigma_%7BI%7D%7D%7B%5Csigma_%7BA%7D%20%7D%20%3D%20%5Cfrac%7B%5Cmathbf%7B%28b'c%29%7D%5E%7B0.5%7D%7D%7B%5Csigma_%7BA%7D%20%7D%20%3D%20%5Cfrac%7B(%5Cmathbf%7Bb'a%20%7D%5Csigma%5E%7B2%7D_%7BA%7D)%5E%7B0.5%7D%7D%7B%5Csigma_%7BA%7D%20%7D%20%3D%20(%5Cmathbf%7Bb'a%20%7D)%5E%7B0.5%7D%0A" /></p><p>BLP 的一些性质为</p>
<ol>
<li>在所有关于 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的线性组合中，<strong>BLP</strong>  最大化了 <img src="https://math.now.sh?inline=I" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的相关</li>
<li><strong>BLP</strong> 具有不变性，即 <img src="https://math.now.sh?inline=%5Ctext%7BBLP%20of%20%7D%5Cmathbf%7Bm%5E%7B%5Cprime%7Dw%7D%20%3D%20%5Cmathbf%7Bm%5E%7B%5Cprime%7D%5Chat%7Bw%7D%7D" style="display:inline-block;margin: 0;"/></li>
<li>当  <img src="https://math.now.sh?inline=%5B%5Cmathbf%7By%7D%2C%20%5Cmathbf%7Bw%7D%5D" style="display:inline-block;margin: 0;"/> 服从多变量正态分布是，此时的 <strong>BLP</strong>  就是 <strong>BP</strong></li>
</ol>
<h2 id="缺点">缺点</h2>
<p>最主要的缺点就是需要已知 <img src="https://math.now.sh?inline=%5Cmathbf%7B%7D" style="display:inline-block;margin: 0;"/> <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的均值，即 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> ，这在实际情况中基本是不可能实现的。</p>
<h1>参考文献</h1>
<ol>
<li>Henderson，1973，SIRE EVALUATION AND GENETIC  TRENDS</li>
<li>Henderson，《Applications_of_Linear_Models_in_Animal_Breeding》, 1984</li>
<li>张沅，张勤，《畜禽育种中的线性模型》</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>混合线性模型一之广义最小二乘</title>
    <url>/posts/5e674d74/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这是混合线性模型理论系列的第一篇，内容为概述及广义最小二乘（固定效应的估计）。</p>
<span id="more"></span>
<h1>混合线性模型概述</h1>
<h2 id="前言">前言</h2>
<p>统计分析的目的是推断 (<em>inference</em>) 和预测 (<em>prediction</em>)，推断指估计参数的大小（比如确定哪些自变量有作用，哪些自变量没有作用），预测是对未来的观测值进行预测。</p>
<p>假设我们定义我们的观测值向量是一个 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 维的向量 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，一般来说我们将观测值向量视为对真实的或概念上的<strong>总体</strong>的一次<strong>随机抽样</strong>，即向量 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 是一个随机向量，向量 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的每一个元素是随机变量 。但是我们很少知道总体的分布，一般我们可能会假设总体服从多元正态分布。</p>
<h2 id="模型">模型</h2>
<p>混合线性模型表示如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cmathbf%7BZu%7D%2B%5Cmathbf%7Be%7D%0A" /></p><p>其中，</p>
<blockquote>
<p><img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 是一个已知的固定的 <img src="https://math.now.sh?inline=n%20%5Ctimes%20p%20%5Cquad%20%20%28n%20%3E%20p%29" style="display:inline-block;margin: 0;"/> 的矩阵， 其秩为 <img src="https://math.now.sh?inline=r%20%5Cleq%20p" style="display:inline-block;margin: 0;"/> 。<br>
<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 是一个<strong>固定</strong>的由未知参数组成的 <img src="https://math.now.sh?inline=p%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 向量 。<br>
<img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D" style="display:inline-block;margin: 0;"/> 是一个已知的固定的 <img src="https://math.now.sh?inline=n%20%5Ctimes%20q" style="display:inline-block;margin: 0;"/> 矩阵。<br>
<img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=q%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 的<strong>随机</strong>向量。<br>
<img src="https://math.now.sh?inline=%5Cmathbf%7Be%7D" style="display:inline-block;margin: 0;"/> 是由随机误差组成的 <img src="https://math.now.sh?inline=n%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 的随机向量</p>
</blockquote>
<p>注意：这里的 <img src="https://math.now.sh?inline=%5Cmathbf%7By%2C%20u%20%2Ce%7D" style="display:inline-block;margin: 0;"/> 均视为从某个真实的或者概念上的总体的一个<strong>随机抽样</strong>，即均为随机向量。这三者的均值和方差，协方差假设如下。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0AE%28%5Cmathbf%7Bu%7D%29%3D%5Cmathbf%7B0%7D%2C%20E(%5Cmathbf%7Be%7D)%3D%5Cmathbf%7B0%7D%2C%20E(%5Cmathbf%7By%7D)%3D%5Cmathbf%7BX%7D%20%5Cbeta%20%5C%5C%0A%5Coperatorname%7BVar%7D(%5Cmathbf%7Bu%7D)%3D%5Cmathbf%7BG%7D%2C%20%5Coperatorname%7BVar%7D(%5Cmathbf%7Be%7D)%3D%5Cmathbf%7BR%7D%2C%20%5Coperatorname%7BCov%7D%5Cleft(%5Cmathbf%7Bu%7D%2C%20%5Cmathbf%7Be%7D%5E%7B%5Cprime%7D%5Cright)%3D%5Cmathbf%7B0%7D%2C%20%5Coperatorname%7BVar%7D(%5Cmathbf%7By%7D)%3D%5Cmathbf%7BZ%20G%20Z%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7BR%7D%0A%5Cend%7Bgathered%7D%0A" /></p><p>这里的协方差矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%2C%20R%7D" style="display:inline-block;margin: 0;"/> 可能是已知的，也可能是未知的。由于 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7Be%7D" style="display:inline-block;margin: 0;"/> 均无法观测，因此我们一般不知道 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> ，但是我们可以对这两个协方差矩阵做一些假设，从而减少估计的参数数目。我们一般假设 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> 的非对角线元素均为 0，对角线元素均相同，也就是不同样本具有相同的残差并且彼此的残差之间不相干，即假设 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D%20%3D%20%5Csigma_%7Be%7D%5E%7B2%7D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>其中 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 称为<strong>固定效应</strong>，因为其元素均为<strong>固定的不变的常数</strong>，只是我们不知道具体的值；<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cmu%7D" style="display:inline-block;margin: 0;"/> 称为<strong>随机效应</strong>，因为它是从总体得到的一次随机抽样，其元素均为随机变量，我们无法完全控制其大小。</p>
<p>除了随机误差外，完全由固定效应组成的模型称为<strong>固定效应模型</strong>，或<strong>固定模型</strong>；除群体平均数 <img src="https://math.now.sh?inline=%5Cmu" style="display:inline-block;margin: 0;"/> 之外，完全由随机效应组成的模型称为<strong>随机效应模型</strong>，简称为<strong>随机模型</strong>。</p>
<p>其实所有的线性模型都可以表示为<strong>混合线性模型</strong>，固定模型和随机模型均可以视为混合线性模型的一个特例。这样一来我们可以通过这一个模型的通式来解决所有问题（线性问题）。</p>
<p>在混合线性模型中，我们需要估计固定效应 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 和随机效应 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cmu%7D" style="display:inline-block;margin: 0;"/> ，我们将固定效应的估计称为<strong>估计</strong>，将随机效应的估计称为<strong>预测</strong>。</p>
<p>下面我们看如何通过广义最小二乘法来估计固定效应 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 。</p>
<h1>广义最小二乘</h1>
<p>在普通最小二乘中，我们假设 <img src="https://math.now.sh?inline=%5Coperatorname%7BVar%7D%28%5Cmathbf%7By%7D%29%20%3D%20%5Coperatorname%7BVar%7D(%5Cmathbf%7Be%7D)%20%3D%20%5Csigma_%7Be%7D%5E%7B2%7D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ，此时得到的正规方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%5E%7BT%7DX%20%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%20%3D%20%5Cmathbf%7BX%5E%7BT%7Dy%7D" style="display:inline-block;margin: 0;"/> 及满秩情况下的唯一解 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D_%7B%5Cmathrm%7BLS%7D%7D%3D%5Cleft%28%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BX%7D%5Cright%29%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7By%7D" style="display:inline-block;margin: 0;"/> 即为<strong>最佳线性无偏估计值</strong>  (<em>best linear unbiased estimators</em>, BLUE) 。这一部分内容可见 <a href="https://vincere.fun/posts/55264e6f/#">矩阵微分与正规方程组推导</a> 。</p>
<p>但是如果 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的协方差矩阵并不满足普通最小二乘的假设，此时如果我们仍采用普通最小二乘方法，此时得到的参数估计值就不再是 BLUE ，此时我们需要对 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 作相应的线性变换。</p>
<p>我们考虑一般的情况，假设固定模型如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%20%3D%20%5Cboldsymbol%7BX%20%5Cbeta%7D%20%2B%20%5Cmathbf%7Be%7D%0A" /></p><p>假设<img src="https://math.now.sh?inline=E%28%5Cmathbf%7Be%7D%29%20%3D%20%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/>，  <img src="https://math.now.sh?inline=%5Coperatorname%7BVar%7D%28%5Cmathbf%7By%7D%29%20%3D%20%5Coperatorname%7BVar%7D(%5Cmathbf%7Be%7D)%20%3D%20%5Cmathbf%7BV%7D%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> 为一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的相关系数矩阵，这里  <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> 是一个正定矩阵（ 因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 同样是正定矩阵）。根据正定矩阵的性质，一定存在一个非奇异矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D" style="display:inline-block;margin: 0;"/> 使得</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BQQ%5E%7B%5Cprime%7D%3D%20R%5E%7B-1%7D%7D%0A" /></p><p>用  <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D" style="display:inline-block;margin: 0;"/>  对 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 作线性变换，有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7By%7D%5E%7B*%7D%20%26%3D%5Cmathbf%7BQ%20y%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BQ%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cmathbf%7BQ%7D%20%5Cmathbf%7Be%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BX%7D%5E%7B*%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cmathbf%7Be%7D%5E%7B*%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B*%7D%3D%5Cmathbf%7BQ%7D%20%5Cmathbf%7BX%7D%2C%20%5Cquad%20%5Cmathbf%7Be%7D%5E%7B*%7D%3D%5Cmathbf%7BQ%7D%20%5Cmathbf%7Be%7D" style="display:inline-block;margin: 0;"/>  ，则</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BVar%7D%5Cleft%28%5Cmathbf%7By%7D%5E%7B*%7D%5Cright%29%3D%5Coperatorname%7BVar%7D(%5Cmathbf%7BQ%20y%7D)%3D%5Cmathbf%7BQ%7D%20%5Coperatorname%7BVar%7D(%5Cmathbf%7By%7D)%20%5Cmathbf%7BQ%7D%5E%7B%5Cprime%7D%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7BQ%7D%20%5Cmathbf%7BR%7D%20%5Cmathbf%7BQ%7D%5E%7B%5Cprime%7D%0A" /></p><p>因为 <img src="https://math.now.sh?inline=%5Cmathbf%7BQQ%5E%7B%5Cprime%7D%3D%20R%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> ，对该式左乘 <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> ，右乘  <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D%5E%7B'-1%7D" style="display:inline-block;margin: 0;"/> ，得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%7D%5E%7B-1%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BQ%7D%5E%7B%5Cprime-1%7D%3D%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ，即 <img src="https://math.now.sh?inline=%5Cmathbf%7BQ%20R%20Q%7D%5E%7B%5Cprime%7D%3D%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ，于是</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BVar%7D%5Cleft%28%5Cmathbf%7By%7D%5E%7B*%7D%5Cright%29%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D%0A" /></p><p>因此，我们知道线性转换后的模型 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%5E%7B*%7D%3D%5Cmathbf%7BX%7D%5E%7B*%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cmathrm%7Be%7D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 符合普通最小二乘的假设，此时我们得到最小二乘方程组如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D%5E%7B*'%7D%20%5Cmathbf%7BX%7D%5E%7B*%7D%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B*'%7D%20%5Cmathbf%7By%7D%5E%7B*%7D%0A" /></p><p>将 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B*%7D%3D%5Cmathbf%7BQ%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> ， $\mathbf{y}^{*} =\mathbf{Q y} $ 带入，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cmathbf%7BX%7D%5E%7B*'%7D%20%5Cmathbf%7BX%7D%5E%7B*%7D%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX%7D%5E%7B*'%7D%20%5Cmathbf%7By%7D%5E%7B*%7D%20%5C%5C%0A%26%5Cmathbf%7BX'Q'%7D%20%5Cmathbf%7BQX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX'Q'%7D%20%5Cmathbf%7BQy%7D%20%5C%5C%0A%0A%26%5Cmathbf%7BX'R%5E%7B-1%7D%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX'R%5E%7B-1%7D%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%0A%0A%5Cend%7Baligned%7D%0A" /></p><p><img src="https://math.now.sh?inline=%5Cmathbf%7BX'R%5E%7B-1%7D%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX'R%5E%7B-1%7D%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 称为 <strong>广义最小二乘方程组</strong>。 当 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 满秩时，我们得到唯一的广义最小二乘估计值 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%3D%20%28%5Cmathbf%7BX'R%5E%7B-1%7D%7D%20%5Cmathbf%7BX%7D%29%5E%7B-1%7D%20%5Cmathbf%7BX'R%5E%7B-1%7D%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，也就是最佳线性无偏估计值；当  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 不满秩时，我们有无穷个解，某个解可以表示为 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%3D%20%28%5Cmathbf%7BX'R%5E%7B-1%7D%7D%20%5Cmathbf%7BX%7D%29%5E%7B-%7D%20%5Cmathbf%7BX'R%5E%7B-1%7D%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%28%5Cmathbf%7BX'R%5E%7B-%7D%7D%20%5Cmathbf%7BX%7D%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 为任意一个广义逆，此时若  <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bq'%20%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 为可估计函数，则   <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bq'%20%5Chat%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/>  是对   <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bq'%20%5Cbeta%7D" style="display:inline-block;margin: 0;"/>  的最佳线性无偏估计。</p>
<p>对上面的<strong>广义最小二乘方程组</strong>的左右两侧均乘以 <img src="https://math.now.sh?inline=1%2F%5Csigma%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，我们得到该方程组的另一种形式。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX'V%5E%7B-1%7D%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX'V%5E%7B-1%7D%7D%20%5Cmathbf%7By%7D%0A" /></p><p>上面我们推导了固定模型的情况，我们可以轻松推广至一般的混合线性模型，设混合线性模型表达式同上，我们可以将随机效应和随机误差效应视为一体，即令 <img src="https://math.now.sh?inline=%5Cmathbf%7BZu%20%2B%20e%20%3D%20e%5E%7B*%7D%7D" style="display:inline-block;margin: 0;"/> ，此时模型写为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%20%3D%20%5Cboldsymbol%7BX%20%5Cbeta%7D%20%2B%20%5Cmathbf%7Be%7D%5E%7B*%7D%0A" /></p><p>此时，<img src="https://math.now.sh?inline=%5Coperatorname%7BVar%7D%28%5Cmathbf%7By%7D%29%20%3D%20%5Coperatorname%7BVar%7D(%5Cmathbf%7Be%5E%7B*%7D%7D)%20%3D%5Cmathbf%7BZ%20G%20Z%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> ，即此时 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D%20%3D%5Cmathbf%7BZ%20G%20Z%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7BR%7D" style="display:inline-block;margin: 0;"/> ，同样有 <img src="https://math.now.sh?inline=%5Cmathbf%7BX'V%5E%7B-1%7D%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Chat%7B%5Cbeta%7D%7D%3D%5Cmathbf%7BX'V%5E%7B-1%7D%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 方程组成立。</p>
<h2 id="另一种证明">另一种证明</h2>
<p>我们接着延续高斯-马尔可夫定理的思想，从所有的线性无偏估计值中找到一个“最佳的”估计值，这里“最佳”的意思是指估计值具有<strong>最小的</strong>方差。</p>
<p>假设 <img src="https://math.now.sh?inline=%5Cmathbf%7Bk%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 是一个可估计函数，即我们可以找到一个向量  <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D" style="display:inline-block;margin: 0;"/>  使得  <img src="https://math.now.sh?inline=%5Cmathrm%7BE%7D%5Cleft%28%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%3D%5Cmathbf%7Bk%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 。我们知道  <img src="https://math.now.sh?inline=E%5Cleft%28%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%3D%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20%3D%20%5Cmathbf%7Bk%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 需要对所有可能的  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 均成立，那么当且仅当下式成立时 <img src="https://math.now.sh?inline=%5Cmathbf%7Bk%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 是一个可估计函数</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cmathbf%7Bk%7D%5E%7B%5Cprime%7D%0A" /></p><p>同时，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BVar%7D%5Cleft%28%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%29%3D%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D(%5Coperatorname%7BVar%7D(%5Cmathbf%7By%7D))%20%5Cmathbf%7Ba%7D%3D%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%20a%7D%0A" /></p><p>这里我们假设 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D" style="display:inline-block;margin: 0;"/> 矩阵已知。</p>
<p>因此我们是在满足约束条件  <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%3D%5Cmathbf%7Bk%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 的前提下使得 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba'Va%7D" style="display:inline-block;margin: 0;"/> 的对角线元素最小，构建拉格朗日函数如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BL%7D%3D%5Cfrac%7B1%7D%7B2%7D%5Cmathbf%7Btr%28a'Va%29%20%2B%20(a'X-k')%5Cboldsymbol%7B%5Ctheta%7D%7D%0A" /></p><p>求偏导数，使之为 <img src="https://math.now.sh?inline=%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> 得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cpartial%20%5Cmathbf%7BL%7D%20%2F%20%5Cpartial%20%5Cmathbf%7Ba%7D%3D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7Ba%7D%2B%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Ctheta%7D%3D%20%5Cmathbf%7B0%7D%20%5C%5C%0A%26%5Cpartial%20%5Cmathbf%7BL%7D%20%2F%20%5Cpartial%20%5Cboldsymbol%7B%5Ctheta%7D%3D%5Cmathbf%7BX%E2%80%99a-k%7D%20%3D%20%5Cmathbf%7B0%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>将两个式子整理成一个方程组，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7BV%7D%20%26%20%5Cmathbf%7BX%7D%20%5C%5C%0A%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%26%20%5Cmathbf%7B0%7D%0A%5Cend%7Barray%7D%5Cright%29%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7Ba%7D%20%5C%5C%0A%5Cboldsymbol%7B%5Ctheta%7D%0A%5Cend%7Barray%7D%5Cright)%3D%5Cleft(%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7Bk%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>对第一个方程进行变换可得</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BV%7D%20%5Cmathbf%7Ba%7D%2B%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Ctheta%7D%20%26%3D%20%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7Ba%7D%20%20%26%3D%20%5Cmathbf%7B-V%5E%7B-1%7DX%20%5Cboldsymbol%7B%5Ctheta%7D%7D%20%5C%5C%0A%5Cmathbf%7BX'a%7D%20%20%26%3D%20%5Cmathbf%7B-X'V%5E%7B-1%7DX%20%5Cboldsymbol%7B%5Ctheta%7D%7D%20%5C%5C%0A%5Cmathbf%7Bk%7D%20%20%26%3D%20%5Cmathbf%7B-X'V%5E%7B-1%7DX%20%5Cboldsymbol%7B%5Ctheta%7D%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>因此我们得到了一个只关于 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Ctheta%7D" style="display:inline-block;margin: 0;"/> 的方程组</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX'V%5E%7B-1%7DX%20%5Cboldsymbol%7B%5Ctheta%7D%7D%20%3D%20%5Cmathbf%7B-k%7D%0A" /></p><p>我们只需要证明对于任何一个广义逆 <img src="https://math.now.sh?inline=%5Cmathbf%7B%20%28X'V%5E%7B-1%7DX%29%5E%7B-%7D%20%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathbf%7B%28X'V%5E%7B-1%7DX%29%20(X'V%5E%7B-1%7DX)%5E%7B-%7Dk%3Dk%7D" style="display:inline-block;margin: 0;"/> 均成立，则该方程组相容。因为  <img src="https://math.now.sh?inline=%5Cmathbf%7Bk%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 可估计，因此必然存在某个  <img src="https://math.now.sh?inline=%5Cmathbf%7Ba_%7B0%7D%7D" style="display:inline-block;margin: 0;"/> 向量使得  <img src="https://math.now.sh?inline=%5Cmathbf%7Bk%20%3D%20X'a_%7B0%7D%7D" style="display:inline-block;margin: 0;"/> ，因此上式可以写成  <img src="https://math.now.sh?inline=%5Cmathbf%7B%28X'V%5E%7B-1%7DX%29%20(X'V%5E%7B-1%7DX)%5E%7B-%7DX'a_%7B0%7D%3DX'a_%7B0%7D%7D" style="display:inline-block;margin: 0;"/> 。我们设这里的 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%3DV%5E%7B-1%2F2%7DX%7D" style="display:inline-block;margin: 0;"/> ，这里的 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%5E%7B-1%2F2%7D%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%5E%7B1%2F2%7D%7D" style="display:inline-block;margin: 0;"/> 的逆矩阵，易得 <img src="https://math.now.sh?inline=%5Cmathbf%7B%28X'V%5E%7B-1%7DX%29%20(X'V%5E%7B-1%7DX)%5E%7B-%7DX'%7D%20%3D%20%5Cmathbf%7BA'A(A'A)%5E%7B-%7DA'V%5E%7B1%2F2%7D%7D%20%3D%20%5Cmathbf%7BA'V%5E%7B1%2F2%7D%7D%20%3D%20%20%5Cmathbf%7BX'V%5E%7B-1%2F2%7D%20V%5E%7B1%2F2%7D%7D%20%3D%20%5Cmathbf%7BX'%7D" style="display:inline-block;margin: 0;"/> ，因此得证   <img src="https://math.now.sh?inline=%5Cmathbf%7B%28X'V%5E%7B-1%7DX%29%20(X'V%5E%7B-1%7DX)%5E%7B-%7DX'a_%7B0%7D%3DX'a_%7B0%7D%7D" style="display:inline-block;margin: 0;"/>  。</p>
<p>因此  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Ctheta%7D" style="display:inline-block;margin: 0;"/>  的一个解为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B-%28X'V%5E%7B-1%7DX%29%5E%7B-%7Dk%7D%0A" /></p><p>带入到第一个方程 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%7D%20%5Cmathbf%7Ba%7D%2B%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Ctheta%7D%3D%20%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> ，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Ba%7D%20%20%3D%20%5Cmathbf%7BV%5E%7B-1%7DX%20%28X'V%5E%7B-1%7DX%29%5E%7B-%7Dk%7D%0A" /></p><p>我们可以进一步证明无论 <img src="https://math.now.sh?inline=%5Cmathbf%7B%20%28X'V%5E%7B-1%7DX%29%5E%7B-%7D%20%7D" style="display:inline-block;margin: 0;"/> 如何取值，<img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D" style="display:inline-block;margin: 0;"/> 均不变。同样设  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%3DV%5E%7B-1%2F2%7DX%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%20%20%3D%20%5Cmathbf%7BV%5E%7B-1%7DX%20%28X'V%5E%7B-1%7DX%29%5E%7B-%7Dk%7D%20%3D%20%5Cmathbf%7BV%5E%7B-1%7DX%20(X'V%5E%7B-1%7DX)%5E%7B-%7DX'a_%7B0%7D%7D" style="display:inline-block;margin: 0;"/>  ，则 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%20%3D%20V%5E%7B-1%2F2%7D%20A%28A'A%29%5E%7B-%7DA'V%5E%7B1%2F2%7Da_%7B0%7D%7D" style="display:inline-block;margin: 0;"/> 。根据广义逆的性质，无论 <img src="https://math.now.sh?inline=%28%5Cmathbf%7BA%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BA%7D%29%5E%7B-%7D" style="display:inline-block;margin: 0;"/> 取何值， <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5Cleft%28%5Cmathbf%7BA%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BA%7D%5Cright%29%5E%7B-%7D%20%5Cmathbf%7BA%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/>  均保持不变，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D" style="display:inline-block;margin: 0;"/> 保持不变。</p>
<p>此时  <img src="https://math.now.sh?inline=%5Cmathbf%7Bk%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/>  的 BLUE 为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Ba'y%7D%20%3D%20%5Cmathbf%7Bk'%28X'V%5E%7B-1%7DX%29%5E%7B-%7DX'V%5E%7B-1%7Dy%7D%0A" /></p><p>如果我们设</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Cbeta%5E%7B0%7D%7D%20%3D%20%5Cmathbf%7B%28X'V%5E%7B-1%7DX%29%5E%7B-%7DX'V%5E%7B-1%7Dy%7D%0A" /></p><p>即 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%5E%7B0%7D%7D" style="display:inline-block;margin: 0;"/> 是下式的任意一个解，即  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%5E%7B0%7D%7D" style="display:inline-block;margin: 0;"/> 是<strong>广义最小二乘方程组</strong>的一个解，其上标的 0 表示其是某一个解，而不是唯一解。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%28X'V%5E%7B-1%7DX%29%7D%5Cboldsymbol%7B%5Cbeta%5E%7B0%7D%7D%20%3D%20%5Cmathbf%7BX'V%5E%7B-1%7Dy%7D%0A" /></p><p>因此，我们得到   <img src="https://math.now.sh?inline=%5Cmathbf%7Bk%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/>  的 BLUE 值就是  <img src="https://math.now.sh?inline=%5Cmathbf%7Bk%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%5E%7B0%7D%7D" style="display:inline-block;margin: 0;"/>  。</p>
<h2 id="V-1-的计算简化"><img src="https://math.now.sh?inline=V%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 的计算简化</h2>
<p>在广义最小二乘估计时需要计算 <img src="https://math.now.sh?inline=%5Cmathbf%7BV%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> ，当表型值数据量很大时， <img src="https://math.now.sh?inline=%5Cmathbf%7BV%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> 计算困难甚至无法计算。Henderson 在 1959 年给出了  <img src="https://math.now.sh?inline=%5Cmathbf%7BV%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> 的一个计算公式，如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BV%7D%5E%7B-1%7D%3D%5Cmathbf%7BR%7D%5E%7B-1%7D-%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5Cleft%28%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%0A" /></p><p>一般 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 很好计算，如果我们可以轻松计算 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright%29%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 的话 ，那么采用这个公式计算  <img src="https://math.now.sh?inline=%5Cmathbf%7BV%5E%7B-1%7D%7D" style="display:inline-block;margin: 0;"/> 就很有优势。在个体动物模型中貌似没法简单计算  <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright%29%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> ，所以这个计算公式现在好像没啥用了。</p>
<p><strong>证明</strong>：我们只需要证明 <img src="https://math.now.sh?inline=%5Cmathbf%7B%28R%2BZGZ'%29%7D%20%5Cleft(%5Cmathbf%7BR%7D%5E%7B-1%7D-%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5Cleft(%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%2B%5Cmathbf%7BG%7D%5E%7B-1%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BR%7D%5E%7B-1%7D%5Cright)%20%20%3D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> 即可，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cmathbf%7B%5Cleft%28R%2BZ%20G%20Z%5E%7B%5Cprime%7D%5Cright%29%5Cleft%5BR%5E%7B-1%7D-R%5E%7B-1%7D%20Z%5Cleft(Z%5E%7B%5Cprime%7D%20R%5E%7B-1%7D%20Z%2BG%5E%7B-1%7D%5Cright)%5E%7B-1%7D%20Z%5E%7B%5Cprime%7D%20R%5E%7B-1%7D%5Cright%5D%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BI%2BZ%20G%20Z%5E%7B%5Cprime%7D%20R%5E%7B-1%7D-Z%5Cleft(Z%5E%7B%5Cprime%7D%20R%5E%7B-1%7D%20Z%2BG%5E%7B-1%7D%5Cright)%5E%7B-1%7D%20Z%5E%7B%5Cprime%7D%20R%5E%7B-1%7D%7D%20%5C%5C%0A%26%20%5Cquad-%5Cmathbf%7BZ%20G%20Z%5E%7B%5Cprime%7D%20R%5E%7B-1%7D%20Z%5Cleft(Z%5E%7B%5Cprime%7D%20R%5E%7B-1%7D%20Z%2BG%5E%7B-1%7D%5Cright)%5E%7B-1%7D%20Z%5E%7B%5Cprime%7D%20R%5E%7B-1%7D%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BI%2BZ%20G%20Z%5E%7B%5Cprime%7D%20R%5E%7B-1%7D-Z%5Cleft(I%2BG%20Z%5E%7B%5Cprime%7D%20R%5E%7B-1%7D%20Z%5Cright)%5Cleft(Z%5E%7B%5Cprime%7D%20R%5E%7B-1%7D%20Z%2BG%5E%7B-1%7D%5Cright)%5E%7B-1%7D%20Z%5E%7B%5Cprime%7D%20R%5E%7B-1%7D%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BI%2BZ%20G%20Z%5E%7B%5Cprime%7D%20R%5E%7B-1%7D-Z%20G%5Cleft(G%5E%7B-1%7D%2BZ%5E%7B%5Cprime%7D%20R%5E%7B-1%7D%20Z%5Cright)%5Cleft(Z%5E%7B%5Cprime%7D%20R%5E%7B-1%7D%20Z%2BG%5E%7B-1%7D%5Cright)%5E%7B-1%7D%20Z%5E%7B%5Cprime%7D%20R%5E%7B-1%7D%7D%20%5C%5C%0A%26%3D%5Cmathbf%7B%20I%2BZ%20G%20Z%5E%7B%5Cprime%7D%20R%5E%7B-1%7D-Z%20G%20Z%5E%7B%5Cprime%7D%20R%5E%7B-1%7D%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BI%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>得证。</p>
<h2 id="BLUE的方差">BLUE的方差</h2>
<p>假设我们有一个可估计的函数  <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%5E%7B0%7D%7D" style="display:inline-block;margin: 0;"/>  ，那么其方差为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7BVar%7D%5Cleft%28%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D%5E%7Bo%7D%5Cright%29%20%26%3D%5Coperatorname%7BVar%7D%5Cleft%5B%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7By%7D%5Cright%5D%20%5C%5C%0A%26%3D%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BV%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BK%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Cmathbf%7BK%7D%20%5Cquad%5Ctext%20%7B%20%E6%B3%A8%EF%BC%9A%E8%BF%99%E9%87%8C%E5%BA%94%E8%AF%A5%E9%9C%80%E8%A6%81%E5%81%87%E8%AE%BE%20%20%7D%20%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BV%7D%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-%7D%20%5Ctext%7B%E6%98%AF%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8F%8D%E5%B9%BF%E4%B9%89%E9%80%86%E7%9F%A9%E9%98%B5%7D%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>由于   <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%5E%7B0%7D%7D" style="display:inline-block;margin: 0;"/>   可估计，因此一定可以找到一个矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D_%7B0%7D" style="display:inline-block;margin: 0;"/> 使得 <img src="https://math.now.sh?inline=%5Cmathbf%7BK%20%3D%20X'A_%7B0%7D%7D" style="display:inline-block;margin: 0;"/> ，同上易证 $\mathbf{K}^{\prime}\left(\mathbf{X}^{\prime} \mathbf{V}^{-1} \mathbf{X}\right)^{-} \mathbf{K} $ 具有不变性。</p>
<h1>参考文献</h1>
<ol>
<li>Henderson，The Estimation of Environmental and Genetic Trends from Records Subject to Culling, 1959</li>
<li>Henderson，《Applications_of_Linear_Models_in_Animal_Breeding》, 1984</li>
<li>张沅，张勤，《畜禽育种中的线性模型》</li>
</ol>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>批量下载R包</title>
    <url>/posts/c4bb4461/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在一个新服务器上重新安装一堆R包，估计是最让人头疼的事情之一了。</p>
<span id="more"></span>
<h1>第一种方式，复制黏贴 <code>library</code> 文件夹</h1>
<p>如果你在两个服务器中安装的 R 的版本相同，那么最简单的方式就是从旧服务器中R的目录中找到 <code>library</code> 文件夹（比如我的在 <code>*/miniConda/miniconda3/lib/R/library</code> ），然后黏贴到新服务器的相同目录下（记得备份一下新服务器的 <code>library</code> 文件夹 ），如果你够幸运的话就没啥问题了。</p>
<p>但是我旧的R版本是 3.6 ，新的 R 版本是 4.0 ，复制黏贴过去运行R直接报错，这条路就不通了。</p>
<h1>第二种方式，批量安装</h1>
<h2 id="1-查找所有需要安装的-R-包">1. 查找所有需要安装的 R 包</h2>
<p>我采用下面的命令行，在脚本文件夹中便利所有内容，找到所有加载R包的语句</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat * | grep &quot;library(&quot; | sort | uniq</span><br></pre></td></tr></table></figure>
<p>找到一堆 <code>library(*)</code> 的语句后，我是直接复制到 Excel 里，用 excel 的智能填充提取 R 包名称（快捷键为 ctrl+e）, 然后用 f9 提取数组信息提取所有包名，简单处理后得到所有 R 包名称序列，如下。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">all_packages <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;*&quot;</span><span class="punctuation">,</span><span class="string">&quot;*&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h2 id="2-简单区分R包来源并安装">2. 简单区分R包来源并安装</h2>
<p>我们通过 <code>available.packages()</code> 函数提取 CRAN 中所有可用的R包</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ap <span class="operator">&lt;-</span> available.packages<span class="punctuation">(</span><span class="punctuation">)</span> <span class="comment"># cran 中所有可用的包</span></span><br></pre></td></tr></table></figure>
<p>我们先简单地将需要安装的 R 包分为两类，如果在 <code>ap</code> 中则视为 CRAN 中的 R 包，采用 <code>install.packages()</code> 来安装；如果不在 <code>ap</code> 中则视为 Bioconductor 中的 R 包，采用 <code>BiocManager::install()</code> 命令来安装。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">cran_packages <span class="operator">&lt;-</span> all_packages<span class="punctuation">[</span>all_packages <span class="operator">%in%</span> rownames<span class="punctuation">(</span>ap<span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment"># length(cran_packages)</span></span><br><span class="line"></span><br><span class="line">bio_packages <span class="operator">&lt;-</span> all_packages<span class="punctuation">[</span><span class="operator">!</span><span class="punctuation">(</span>all_packages <span class="operator">%in%</span> rownames<span class="punctuation">(</span>ap<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment"># length(bio_packages)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">install.packages<span class="punctuation">(</span>cran_packages<span class="punctuation">)</span> <span class="comment"># 一次性安装所有的 cran 包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="punctuation">(</span><span class="operator">!</span>requireNamespace<span class="punctuation">(</span><span class="string">&quot;BiocManager&quot;</span><span class="punctuation">,</span> quietly <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">    install.packages<span class="punctuation">(</span><span class="string">&quot;BiocManager&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">BiocManager<span class="operator">::</span>install<span class="punctuation">(</span>bio_packages<span class="punctuation">)</span> <span class="comment"># 一次性安装所有的 bioconductor 包</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-确定哪些R包没有安装成功">3. 确定哪些R包没有安装成功</h2>
<p>将所有需要安装的R包，与所有已经安装的R包进行配对，确定哪些R包没有安装成功</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所有已经安装的 R 包</span></span><br><span class="line"></span><br><span class="line">installed_packages <span class="operator">=</span> row.names<span class="punctuation">(</span>installed.packages<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看哪些 R 包还没有安装</span></span><br><span class="line"></span><br><span class="line">no_cran_packages <span class="operator">=</span> cran_packages<span class="punctuation">[</span><span class="operator">!</span><span class="punctuation">(</span>cran_packages <span class="operator">%in%</span> installed_packages<span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line">no_cran_packages <span class="comment"># 2 个 [1] &quot;ggpubr&quot; &quot;car&quot;</span></span><br><span class="line"></span><br><span class="line">no_bio_packages <span class="operator">=</span> bio_packages<span class="punctuation">[</span><span class="operator">!</span><span class="punctuation">(</span>bio_packages <span class="operator">%in%</span> installed_packages<span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line">no_bio_packages <span class="comment"># 0 个</span></span><br><span class="line"></span><br><span class="line">install.packages<span class="punctuation">(</span>no_cran_packages<span class="punctuation">)</span> <span class="comment"># 再来一次</span></span><br><span class="line"></span><br><span class="line">BiocManager<span class="operator">::</span>install<span class="punctuation">(</span>no_bio_packages<span class="punctuation">)</span> <span class="comment"># 再来一次</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-需要特殊安装的-R-包">4. 需要特殊安装的 R 包</h2>
<p>有些 R 包其实是从 GitHub 安装的，或者从别的地方安装，因此需要特殊安装一下。</p>
<p>如果你足够幸运的话，你到这一步应该就把所有的 R 包都安装好了，还有没装好的，估计就是遇到问题了。</p>
<h2 id="5-始终安装失败的包，手动下载安装">5.  始终安装失败的包，手动下载安装</h2>
<p>我有两个  CRAN 中的 R 包一直安装不下来，<code>ggpubr</code> 和 <code>car</code> ， 本来打算手动安装。因为存在附属包的情况，所以手动安装往往需要 “套娃式” 安装。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 手动安装 ggpubr， 事先安装 rstatix</span></span><br><span class="line"><span class="built_in">R</span> CMD INSTALL /mnt/<span class="keyword">data</span>/zhouziwen/lib/R_packages/ggpubr_0.<span class="number">4.0</span>.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动安装  car, 事先安装 pbkrtest lme4</span></span><br><span class="line"><span class="built_in">R</span> CMD INSTALL /mnt/<span class="keyword">data</span>/zhouziwen/lib/R_packages/nloptr_2.<span class="number">0.0</span>.tar.gz</span><br><span class="line"><span class="built_in">R</span> CMD INSTALL /mnt/<span class="keyword">data</span>/zhouziwen/lib/R_packages/lme4_1.<span class="number">1</span><span class="literal">-13</span>.tar.gz</span><br><span class="line"><span class="built_in">R</span> CMD INSTALL /mnt/<span class="keyword">data</span>/zhouziwen/lib/R_packages/pbkrtest_0.<span class="number">5.1</span>.tar.gz</span><br><span class="line"><span class="built_in">R</span> CMD INSTALL /mnt/<span class="keyword">data</span>/zhouziwen/lib/R_packages/car_3.<span class="number">0</span><span class="literal">-12</span>.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>并且，手动安装还是遇到了相同的报错。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CMake Error: The source directory &quot;/tmp/RtmpGALOB5/R.INSTALL62081f90ce01/nloptr/src/nlopt-build&quot; does not exist.</span><br><span class="line">Specify --help for usage, or press the help button on the CMake GUI</span><br></pre></td></tr></table></figure>
<p>此时，真正消耗时间和心情的步骤才来了，然后我就在网上搜索这个报错，没有找到清晰的答案（R 包安装不上的情况貌似一向如此，基本上找不到明白的答案，或者说别人的答案你试了可能还是没用）。</p>
<h2 id="5-1-重装-cmake">5.1 重装 cmake</h2>
<p>然后一番东搞西搞以后，我发现有一个 <code>cmake</code> 软件，从 <a href="https://cmake.org/download/">https://cmake.org/download/</a> 下载 <code>cmake-3.22.2-linux-x86_64.tar.gz </code> ，然后先解压</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zvxf cmake-3.22.2-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压以后，<code>bin</code> 文件夹中就有新的 <code>cmake</code> 软件，将这个 <code>bin</code> 文件夹加入到环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=&quot;*/cmake-3.22.2-linux-x86_64/bin:$PATH&quot;</span><br></pre></td></tr></table></figure>
<p>之前的版本是 2.8 ，现在的版本如下，估计可能就是版本太低了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmake --version</span></span><br><span class="line">cmake version 3.22.2</span><br><span class="line"></span><br><span class="line">CMake suite maintained and supported by Kitware (kitware.com/cmake).</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后正常用 <code>install.packages()</code> 命令来安装 <code>ggpubr</code> 和 <code>car</code> 就正常了。</p>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>R</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>奇异值分解与穆尔-彭罗斯伪逆</title>
    <url>/posts/bc1cea9f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>根据奇异值分解得到穆尔-彭罗斯伪逆的一个表达方式，同时证明不满秩情况下最小二乘问题的穆尔-彭罗斯伪逆的解为最小范数最小二乘解。</p>
<span id="more"></span>
<p>本章节内容主要来自于《Linear Algebra with Applications》的第七章数值线性代数。</p>
<h1>奇异值分解</h1>
<p>简要介绍可见<a href="https://vincere.fun/posts/fc532062/#%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3">PCA分析公式推导</a></p>
<p>简单地说，任何一个矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> ，均可以通过奇异值分解拆分为下式：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%20%3D%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7BT%7D%7D%0A" /></p><h1>穆尔-彭罗斯伪逆</h1>
<p>我们知道矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的一个广义逆只需要满足下式，但是这样的广义逆矩阵不是唯一的，存在明显的缺陷。</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%7D%5E%7B-%7D%20%5Cboldsymbol%7BA%7D%3D%5Cboldsymbol%7BA%7D%0A" /></p><p>如果一个实矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B%2B%7D" style="display:inline-block;margin: 0;"/> 满足下面四个条件 (常称 Moore-Penrose 条件)，则矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5E%7B%2B%7D" style="display:inline-block;margin: 0;"/> 是<strong>唯一</strong>的，称为穆尔-彭罗斯伪逆。</p>
<p>(1) <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%5E%2B%7D%20%5Cboldsymbol%7BA%7D%3D%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/>;<br>
(2) <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%5E%2B%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%5E%2B%7D%3D%5Cboldsymbol%7BA%5E%2B%7D%20%3B" style="display:inline-block;margin: 0;"/><br>
(3) <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%20A%7D%5E%7B%2B%7D" style="display:inline-block;margin: 0;"/> 为实对称矩阵, 即 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%3D%5Cleft%28%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%5Cright%29%5E%7B%5Cmathrm%7BT%7D%7D" style="display:inline-block;margin: 0;"/>;<br>
(4) <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%5E%2B%7D%20%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 为实对称矩阵, 即 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%20%5Cboldsymbol%7BA%7D%3D%5Cleft%28%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%20%5Cboldsymbol%7BA%7D%5Cright%29%5E%7B%5Cmathrm%7BT%7D%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>如果矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的秩为 <img src="https://math.now.sh?inline=r" style="display:inline-block;margin: 0;"/> 的矩阵，我们将其进行奇异值分解，得到 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%3D%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/> ，其中矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵，并且可以拆分为 (注：矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的秩等于非零的奇异值的数目)</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%5CSigma%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7Cl%7D%0A%5Cmathbf%7B%5CSigma%7D_%7B1%7D%20%26%20O%20%5C%5C%0A%5Chline%20O%20%26%20O%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bllll%7Cl%7D%0A%5Csigma_%7B1%7D%20%26%20%26%20%26%20%26%20%5C%5C%0A%26%20%5Csigma_%7B2%7D%20%26%20%26%20%26%200%20%5C%5C%0A%26%20%26%20%5Cddots%20%26%20%26%20%5C%5C%0A%5Chline%20%26%20%26%20O%20%26%20%26%200%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>同时我们定义 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%5E%2B%7D" style="display:inline-block;margin: 0;"/> 是一个 $n \times m $ 的矩阵</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%5CSigma%5E%2B%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7Cc%7D%0A%5Cmathbf%7B%5CSigma%7D_%7B1%7D%5E%7B-1%7D%20%26%20O%20%5C%5C%0A%5Chline%20O%20%26%20O%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7Cc%7D%0A%5Cfrac%7B1%7D%7B%5Csigma_%7B1%7D%7D%20%26%20%5Cddots%20%26%20%26%20O%20%5C%5C%0A%26%20%26%20%5Cfrac%7B1%7D%7B%5Csigma_%7Br%7D%7D%20%26%20%5C%5C%0A%5Chline%20%26%20%26%20O%20%26%20O%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>我们可以证明穆尔-彭罗斯伪逆可以表示为下式</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%5E%7B%2B%7D%7D%3D%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D%0A" /></p><p>易证明该式符合上面的四个条件。</p>
<p><strong>证明</strong>：</p>
<p>首先易得 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D%20%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D%20%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 格式均为下式</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7Cl%7D%0A%5Cmathbf%7BI%7D%20%26%20O%20%5C%5C%0A%5Chline%20O%20%26%20O%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>因此易得 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D%20%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D%20%5Cmathbf%7B%5CSigma%7D%20%3D%20%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D%20%5Cmathbf%7B%5CSigma%7D%20%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D%20%3D%20%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/> ，同时   <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D%20%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D%20%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 均为对称矩阵，因此  <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/> 是  <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 的穆尔-彭罗斯伪逆。</p>
<p>然后我们证明 $ \mathbf{A^{+}}=\mathbf{V \Sigma^{+} U^{\mathrm{T}}}$ 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的 穆尔-彭罗斯伪逆，过程如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%5E%2B%7D%20%5Cboldsymbol%7BA%7D%0A%26%20%3D%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7BT%7D%7D%20%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%20%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7BT%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BU%20%5CSigma%20%5CSigma%5E%7B%2B%7D%20%5CSigma%20V%5E%7BT%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7BT%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BA%7D%20%5C%5C%0A%0A%5C%5C%0A%0A%5Cboldsymbol%7BA%5E%2B%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%5E%2B%7D%0A%26%3D%20%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7BT%7D%7D%20%20%20%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20%5CSigma%20%5CSigma%5E%7B%2B%7D%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7DU%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BA%5E%7B%2B%7D%7D%20%5C%5C%0A%0A%5C%5C%0A%0A%5Cleft%28%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%5Cright%29%0A%26%3D%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7BT%7D%7D%20%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BU%20%5CSigma%20%7D%20%5Cmathbf%7B%20%5CSigma%5E%7B%2B%7D%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%5C%5C%0A%0A%0A%5Cleft(%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%5Cright)%5E%7B%5Cmathrm%7BT%7D%7D%20%0A%26%3D%20(%5Cmathbf%7BU%20%5CSigma%20%7D%20%5Cmathbf%7B%20%5CSigma%5E%7B%2B%7D%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D%20)%5E%7B%5Cmathrm%7BT%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BU%7D%20(%5Cmathbf%7B%20%5CSigma%20%20%5CSigma%5E%7B%2B%7D%20%7D)%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7B%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%20%5C%5C%0A%26%3D%20%5Cmathbf%7BU%7D%20%5Cmathbf%7B%20%5CSigma%20%20%5CSigma%5E%7B%2B%7D%20%7D%20%5Cmathbf%7B%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%20%5C%5C%0A%26%3D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%0A%0A%5C%5C%0A%0A%5Cleft(%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%20%5Cboldsymbol%7BA%7D%5Cright)%20%0A%26%3D%20%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7BT%7D%7D%20%20%20%5C%5C%0A%26%3D%20%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20%5CSigma%20V%5E%7BT%7D%7D%20%20%5C%5C%0A%0A%5Cleft(%5Cboldsymbol%7BA%7D%5E%7B%2B%7D%20%5Cboldsymbol%7BA%7D%5Cright)%5E%7B%5Cmathrm%7BT%7D%7D%20%0A%26%3D%20(%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20%5CSigma%20V%5E%7BT%7D%7D%20)%5E%7B%5Cmathrm%7BT%7D%7D%20%20%5C%5C%0A%26%3D%20%5Cmathbf%7BV%20(%5CSigma%5E%7B%2B%7D%20%5CSigma)%5E%7B%5Cmathrm%7BT%7D%7D%20V%5E%7BT%7D%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20%5CSigma%20V%5E%7BT%7D%7D%20%5C%5C%0A%26%3D%20%5Cboldsymbol%7BA%5E%7B%2B%7D%7D%20%5Cboldsymbol%7BA%7D%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><h1>满秩情况下的最小二乘解</h1>
<p>在正规方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B%5Cmathrm%7BT%7D%7D%20A%7D%20%5Cmathbf%7Bx%7D%20%3D%20%5Cmathbf%7BA%5E%7B%5Cmathrm%7BT%7D%7D%20b%7D" style="display:inline-block;margin: 0;"/> 中，如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 且秩为 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 的满秩矩阵，<img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的奇异值分解为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%3D%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/> ，因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cleft%28%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%5Cright%29%5E%7B-1%7D%0A%26%3D%20(%5Cmathbf%7BV%20%5CSigma%5E%7BT%7D%20U%5E%7BT%7D%7D%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7BT%7D%7D)%5E%7B-1%7D%20%5C%5C%0A%26%3D%20(%5Cmathbf%7BV%20%5CSigma%5E%7BT%7D%20%5CSigma%20V%5E%7BT%7D%7D)%5E%7B-1%7D%20%5C%5C%0A%26%3D%20%5Cmathbf%7BV%20(%5CSigma%5E%7BT%7D%20%5CSigma)%5E%7B-1%7D%20V%5E%7BT%7D%7D%20%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>此时 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 的拆分形式为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%5CSigma%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Br%7D%0A%5Cmathbf%7B%5CSigma%7D_%7B1%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>因此 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%5E%7BT%7D%20%5CSigma%7D%20%3D%20%5Cmathbf%7B%5CSigma%5E%7BT%7D_%7B1%7D%20%5CSigma_%7B1%7D%7D%20%3D%20%5Cmathbf%7B%5CSigma_%7B1%7D%5E%7B2%7D%7D" style="display:inline-block;margin: 0;"/> ，因此我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%5Cright%29%5E%7B-1%7D%20%3D%20%5Cmathbf%7BV%20%5CSigma%5E%7B-2%7D_%7B1%7D%20V%5E%7BT%7D%7D%0A" /></p><p>正规方程组的解为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7Bx%7D%20%0A%0A%26%3D%20%5Cleft%28%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%5Cright%29%5E%7B-1%7D%20%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7Bb%7D%5C%5C%0A%0A%26%3D%20%5Cmathbf%7BV%20%5CSigma%5E%7B-2%7D_%7B1%7D%20V%5E%7BT%7D%7D%20%5Cmathbf%7BV%20%5CSigma%5E%7BT%7D%20U%5E%7BT%7D%7D%20%5Cmathbf%7Bb%7D%20%5C%5C%0A%0A%26%3D%20%5Cmathbf%7BV%20%5CSigma%5E%7B-2%7D_%7B1%7D%20%20%5CSigma%5E%7BT%7D%20U%5E%7BT%7D%7D%20%5Cmathbf%7Bb%7D%20%5C%5C%0A%0A%26%3D%20%5Cmathbf%7BV%20%5CSigma%5E%7B-2%7D_%7B1%7D%20%20%5Cleft%5B%5Cbegin%7Barray%7D%7Br%7D%0A%5Cmathbf%7B%5CSigma%7D_%7B1%7D%20%26%0A%5Cmathbf%7B0%7D%0A%5Cend%7Barray%7D%5Cright%5D%20U%5E%7BT%7D%7D%20%5Cmathbf%7Bb%7D%20%5C%5C%0A%0A%26%3D%20%5Cmathbf%7BV%20%20%20%5Cleft%5B%5Cbegin%7Barray%7D%7Br%7D%0A%5Cmathbf%7B%5CSigma%7D_%7B1%7D%5E%7B-1%7D%20%26%0A%5Cmathbf%7B0%7D%0A%5Cend%7Barray%7D%5Cright%5D%20U%5E%7BT%7D%7D%20%5Cmathbf%7Bb%7D%20%5C%5C%0A%0A%26%3D%20%5Cmathbf%7BV%20%20%20%5CSigma%5E%7B%2B%7D%20U%5E%7BT%7D%20%5Cmathbf%7Bb%7D%7D%20%5C%5C%0A%0A%26%3D%20%5Cmathbf%7BA%5E%7B%2B%7D%20b%7D%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>也就是说，如果 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 满秩，那么最小二乘问题的解为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B%2B%7D%20b%7D" style="display:inline-block;margin: 0;"/> 。</p>
<h1>不满秩情况下的最小范数最小二乘解</h1>
<p>不满秩情况下，最小二乘问题有无穷多个解，我们证明  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B%2B%7D%20b%7D" style="display:inline-block;margin: 0;"/>  不仅是其中的一个解，而且是 L2 范数最小的解，即<strong>最小范数最小二乘解</strong>。</p>
<p>此时设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 且秩为 <img src="https://math.now.sh?inline=r%20%3C%20n" style="display:inline-block;margin: 0;"/> 的不满秩矩阵，<img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的奇异值分解为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%3D%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>令 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=%5Cmathrm%7BR%5E%7Bn%7D%7D" style="display:inline-block;margin: 0;"/> 中的一个向量，并定义</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bc%7D%3D%5Cmathbf%7BU%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7Bb%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cboldsymbol%7Bc%7D_%7B1%7D%20%5C%5C%0A%5Cboldsymbol%7Bc%7D_%7B2%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5Cquad%20%5Ctext%20%7B%20%2C%20%7D%20%5Cquad%20%5Cboldsymbol%7By%7D%3DV%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7Bx%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cboldsymbol%7By%7D_%7B1%7D%20%5C%5C%0A%5Cboldsymbol%7By%7D_%7B2%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>其中  <img src="https://math.now.sh?inline=%5Cmathbf%7Bc%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 均为 <img src="https://math.now.sh?inline=%5Cmathrm%7BR%5E%7Br%7D%7D" style="display:inline-block;margin: 0;"/> 中的一个向量，由于 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/> 是一个正交矩阵，因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5C%7C%5Cboldsymbol%7Bb%7D-%5Cmathbf%7BA%7D%20%5Cboldsymbol%7Bx%7D%5C%7C_%7B2%7D%5E%7B2%7D%0A%0A%26%3D%5C%7C%5Cmathbf%7BU%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%28%5Cboldsymbol%7Bb%7D-%5Cmathbf%7BA%7D%20%5Cboldsymbol%7Bx%7D%29%5C%7C_%7B2%7D%5E%7B2%7D%20%5C%5C%0A%0A%26%3D%5Cleft%5C%7C%5Cmathbf%7BU%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7Bb%7D-%5Cmathbf%7B%5CSigma%7D%5Cleft(%5Cmathbf%7BV%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7Bx%7D%5Cright)%5Cright%5C%7C_%7B2%7D%5E%7B2%7D%5C%5C%0A%26%3D%5C%7C%5Cmathbf%7Bc%7D-%5Cmathbf%7B%5CSigma%20y%7D%5C%7C_%7B2%7D%5E%7B2%7D%5C%5C%0A%26%3D%5Cleft%5C%7C%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7Bc_%7B1%7D%7D%20%5C%5C%0A%5Cmathbf%7Bc_%7B2%7D%7D%0A%5Cend%7Barray%7D%5Cright%5D-%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7B%5CSigma_%7B1%7D%7D%20%26%20%5Cmathbf%7BO%7D%20%5C%5C%0A%5Cmathbf%7BO%7D%20%26%20%5Cmathbf%7BO%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7By_%7B1%7D%7D%20%5C%5C%0A%5Cmathbf%7By_%7B2%7D%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cright%5C%7C_%7B2%7D%5E%7B2%7D%5C%5C%0A%26%3D%5Cleft%5C%7C%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7Bc_%7B1%7D-%5CSigma_%7B1%7D%20y_%7B1%7D%7D%20%5C%5C%0A%5Cmathbf%7Bc_%7B2%7D%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cright%5C%7C_%7B2%7D%5E%7B2%7D%5C%5C%0A%26%3D%5Cleft%5C%7C%5Cmathbf%7Bc_%7B1%7D-%5CSigma_%7B1%7D%20y_%7B1%7D%7D%5Cright%5C%7C_%7B2%7D%5E%7B2%7D%2B%5Cleft%5C%7C%5Cmathbf%7Bc_%7B2%7D%7D%5Cright%5C%7C_%7B2%7D%5E%7B2%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>由于 <img src="https://math.now.sh?inline=%5Cmathbf%7Bc%7D_%7B2%7D" style="display:inline-block;margin: 0;"/> 与 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> (线性) 无关，可得 <img src="https://math.now.sh?inline=%5C%7C%5Cboldsymbol%7Bb%7D-%5Cmathbf%7BA%7D%20%5Cboldsymbol%7Bx%7D%5C%7C_%7B2%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 取得最小值的充要条件为 <img src="https://math.now.sh?inline=%5Cmathbf%7Bc_%7B1%7D-%5CSigma_%7B1%7D%20y_%7B1%7D%20%3D%200%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>因此最小二乘解的充要条件为 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%20%3D%20Vy%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 向量的形式为</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathbf%7B%5CSigma_%7B1%7D%5E%7B-1%7D%20c_%7B1%7D%7D%20%5C%5C%0A%5Cmathbf%7By_%7B2%7D%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>当 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D_%7B2%7D%20%3D%20%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> 时，此时的 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> 为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cboldsymbol%7Bx%7D%20%26%3D%20%5Cmathbf%7BV%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7B%5CSigma_%7B1%7D%5E%7B-1%7D%7D%20%5Cboldsymbol%7Bc%7D_%7B1%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%3D%5Cmathbf%7BV%7D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cmathbf%7B%5CSigma_%7B1%7D%7D%5E%7B-1%7D%20%26%20%5Cmathbf%7BO%7D%20%5C%5C%0A%5Cmathbf%7BO%7D%20%26%20%5Cmathbf%7BO%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cboldsymbol%7Bc%7D_%7B1%7D%20%5C%5C%0A%5Cboldsymbol%7Bc%7D_%7B2%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%3D%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20U%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%5Cboldsymbol%7Bb%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BA%5E%7B%2B%7D%7D%20%5Cboldsymbol%7Bb%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>也就是说证明了   <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B%2B%7D%20b%7D" style="display:inline-block;margin: 0;"/>  是其中的一个解。</p>
<p>如果 <img src="https://math.now.sh?inline=%5Cmathbf%7Bz%7D" style="display:inline-block;margin: 0;"/> 是任何其他的解，则  <img src="https://math.now.sh?inline=%5Cmathbf%7Bz%7D" style="display:inline-block;margin: 0;"/>  的形式必须为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bz%7D%3D%5Cmathbf%7BV%20y%7D%3D%5Cmathbf%7BV%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7B%5CSigma_%7B1%7D%5E%7B-1%7D%20c_%7B1%7D%7D%20%5C%5C%0A%5Cmathbf%7By_%7B2%7D%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D_%7B2%7D%20%5Cneq%20%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/>  由此可得</p>
<p style=""><img src="https://math.now.sh?from=%5C%7C%5Cmathbf%7Bz%7D%5C%7C%5E%7B2%7D%3D%5C%7C%5Cmathbf%7By%7D%5C%7C%5E%7B2%7D%3D%5Cleft%5C%7C%5Cmathbf%7B%5CSigma_%7B1%7D%5E%7B-1%7D%20c_%7B1%7D%7D%5Cright%5C%7C%5E%7B2%7D%2B%5Cleft%5C%7C%5Cmathbf%7By_%7B2%7D%7D%5Cright%5C%7C%5E%7B2%7D%3E%5Cleft%5C%7C%5Cmathbf%7B%5CSigma_%7B1%7D%5E%7B-1%7D%20c_%7B1%7D%7D%5Cright%5C%7C%5E%7B2%7D%3D%5C%7C%5Cmathbf%7Bx%7D%5C%7C%5E%7B2%7D%0A" /></p><p>因此我们证明了   <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B%2B%7D%20b%7D" style="display:inline-block;margin: 0;"/>  是最小范数最小二乘解。</p>
<h2 id="证明-mathbf-A-mathrm-’-A-A-prime-A">证明  <img src="https://math.now.sh?inline=%5Cmathbf%7B%28A%5E%7B%5Cmathrm%7B%E2%80%99%7D%7D%20A%29%5E%7B%2B%7DA%5E%7B%5Cprime%7D%20%3D%20A%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/></h2>
<p>如果我们对正规方程组 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%5E%7B%5Cmathrm%7B'%7D%7D%20A%7D%20%5Cmathbf%7Bx%7D%20%3D%20%5Cmathbf%7BA%5E%7B%5Cmathrm%7B'%7D%7D%20b%7D" style="display:inline-block;margin: 0;"/> 直接求伪逆，得到 $ \mathbf{x = (A^{\mathrm{‘}} A)^{+}A^{’} b}$ ，因此应该存在  <img src="https://math.now.sh?inline=%5Cmathbf%7B%28A%5E%7B%5Cmathrm%7B'%7D%7D%20A%29%5E%7B%2B%7DA%5E%7B'%7D%20%3D%20A%5E%7B%2B%7D%7D" style="display:inline-block;margin: 0;"/>  ，证明这个式子需要用到穆尔-彭罗斯伪逆的一些性质。</p>
<p>首先我们证明 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BA%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BA%7D%5Cright%29%5E%7B%5Cmathbf%7B%2B%7D%7D%3D%5Cmathbf%7BA%5E%2B%7D%5Cleft(%5Cmathbf%7BA%5E%2B%7D%5Cright)%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，根据  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%3D%20%5Cmathbf%7BU%20%5CSigma%20V%5E%7B%5Cprime%7D%7D" style="display:inline-block;margin: 0;"/> ，我们得到  <img src="https://math.now.sh?inline=%5Cmathbf%7BA'A%7D%20%3D%20%5Cmathbf%7BV%20%28%5CSigma%5E%7B'%7D%20%5CSigma%29%20V%5E%7B%E2%80%99%7D%7D" style="display:inline-block;margin: 0;"/> ，易证明该式就是 <img src="https://math.now.sh?inline=%5Cmathbf%7BA'A%7D" style="display:inline-block;margin: 0;"/>  的奇异值分解形式，因此  <img src="https://math.now.sh?inline=%5Cmathbf%7B%28A'A%29%5E%7B%2B%7D%7D%20%3D%20%5Cmathbf%7BV%20(%5CSigma%5E%7B'%7D%20%5CSigma)%5E%7B%2B%7D%20V%5E%7B%5Cprime%7D%7D" style="display:inline-block;margin: 0;"/> , 其中  <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%5E%7B'%7D%7D%20%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 格式为下式</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7Cl%7D%0A%5Cmathbf%7B%5CSigma_%7B1%7D%5E%7B2%7D%7D%20%26%20O%20%5C%5C%0A%5Chline%20O%20%26%20O%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>易得  <img src="https://math.now.sh?inline=%28%5Cmathbf%7B%5CSigma%5E%7B'%7D%7D%20%5Cmathbf%7B%5CSigma%7D%29%5E%7B%2B%7D%20%3D%20%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D%20%5Cmathbf%7B(%5CSigma%5E%7B'%7D)%5E%7B%2B%7D%7D%20%3D%20%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D%20%5Cmathbf%7B(%5CSigma%5E%7B%2B%7D)%5E%7B'%7D%7D" style="display:inline-block;margin: 0;"/>  ，因此我们得证</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%28A'A%29%5E%7B%2B%7D%7D%20%3D%20%5Cmathbf%7BV%20(%5CSigma%5E%7B'%7D%20%5CSigma)%5E%7B%2B%7D%20V%5E%7B%5Cprime%7D%7D%20%20%3D%20%5Cmathbf%7BV%20%5Cmathbf%7B%5CSigma%5E%7B%2B%7D%7D%20%5Cmathbf%7B(%5CSigma%5E%7B%2B%7D)%5E%7B'%7D%7D%20V%5E%7B%5Cprime%7D%7D%20%3D%20%5Cmathbf%7BV%20%5CSigma%5E%7B%2B%7D%20U%5E%7BT%7D%20U%20(%5CSigma%5E%7B%2B%7D)%5E%7B'%7D%20V%5E%7B%5Cprime%7D%7D%20%3D%5Cmathbf%7BA%5E%2B%7D%5Cleft(%5Cmathbf%7BA%5E%2B%7D%5Cright)%5E%7B%5Cprime%7D%0A" /></p><p>因此，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7B%28A%5E%7B%5Cmathrm%7B'%7D%7D%20A%29%5E%7B%2B%7DA%5E%7B'%7D%7D%20%0A%26%20%3D%20%5Cmathbf%7BA%5E%2B%7D%5Cleft(%5Cmathbf%7BA%5E%2B%7D%5Cright)%5E%7B%5Cprime%7D%20%5Cmathbf%7BA%5E%7B'%7D%7D%20%5C%5C%0A%26%20%3D%20%5Cmathbf%7BA%5E%2B%7D%5Cleft(%5Cmathbf%7BAA%5E%2B%7D%5Cright)%5E%7B%5Cprime%7D%20%5C%5C%0A%26%20%3D%20%5Cmathbf%7BA%5E%2B%7D%5Cleft(%5Cmathbf%7BAA%5E%2B%7D%5Cright)%20%5C%5C%0A%26%3D%20%5Cmathbf%7BA%5E%2B%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>得证。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>AB的每一列均为A的列的线性组合</title>
    <url>/posts/54f5dedf/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>线性代数中，线性组合的概念时常见到，这里记录一下推导过程。</p>
<span id="more"></span>
<h1>Ab 为A的列的线性组合。</h1>
<p>假如 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵，<img src="https://math.now.sh?inline=%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=n%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 的向量，易得</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%5Cmathbf%7Bb%7D%20%3D%20%5Cleft%28%5Cbegin%7Barray%7D%7Br%7D%0A%5Cmathbf%7Ba%7D_%7B1%7D%2C%20%26%0A%5Cmathbf%7Ba%7D_%7B2%7D%2C%20%26%0A%5Ccdots%2C%20%26%0A%5Cmathbf%7Ba%7D_%7Bn%7D%0A%5Cend%7Barray%7D%5Cright%29%0A%5Cleft(%5Cbegin%7Barray%7D%7Br%7D%0Ab_%7B1%7D%20%5C%5C%0Ab_%7B2%7D%20%5C%5C%0A%5Cvdots%20%5C%5C%0Ab_%7Bn%7D%0A%5Cend%7Barray%7D%5Cright)%0A%3D%20%5Cmathbf%7Ba%7D_%7B1%7Db_%7B1%7D%20%2B%20%20%5Cmathbf%7Ba%7D_%7B2%7Db_%7B2%7D%20%2B%20%5Ccdots%20%2B%20%20%20%5Cmathbf%7Ba%7D_%7Bn%7Db_%7Bn%7D%0A" /></p><p>因此，得证<img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的列的线性组合。</p>
<h1>AB 的每一列均为A的列的线性组合</h1>
<p>假如 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵，<img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20q" style="display:inline-block;margin: 0;"/> 的矩阵，我们推导出下式。这里第一个等号中，我们将 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 分别按行和列拆分开，第二个等号为分块矩阵的乘积。第三个等号我们继续将每个 <img src="https://math.now.sh?inline=%5Cmathbf%7Bb%7D%5E%7B'%7D_%7Bi%7D" style="display:inline-block;margin: 0;"/> 拆分为元素，第四个等号为矩阵加法的结果。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BA%7D%20%5Cmathbf%7BB%7D%26%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Blll%7D%0A%5Cmathbf%7Ba%7D_%7B1%7D%2C%20%5Cmathbf%7Ba%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cmathbf%7Ba%7D_%7Bn%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A%5Cmathbf%7Bb%7D%5E%7B'%7D_%7B1%7D%20%5C%5C%0A%5Cmathbf%7Bb%7D%5E%7B'%7D_%7B2%7D%20%5C%5C%0A%5Cvdots%20%5C%5C%0A%5Cmathbf%7Bb%7D%5E%7B'%7D_%7Bn%7D%0A%5Cend%7Barray%7D%5Cright%5D%5C%5C%0A%26%5C%5C%0A%26%3D%5Cmathbf%7Ba%7D_%7B1%7D%20%5Cmathbf%7Bb%7D%5E%7B'%7D_%7B1%7D%2B%5Cmathbf%7Ba%7D_%7B2%7D%20%5Cmathbf%7Bb%7D%5E%7B'%7D_%7B2%7D%2B%5Ccdots%2B%5Cmathbf%7Ba%7D_%7Bn%7D%20%5Cmathbf%7Bb%7D%5E%7B'%7D_%7Bn%7D%20%5C%5C%0A%26%5C%5C%0A%26%3D%5Cleft%5B%5Cmathbf%7Ba%7D_%7B1%7D%20b'_%7B11%7D%2C%20%5Cmathbf%7Ba%7D_%7B1%7D%20b'_%7B12%7D%2C%20%5Ccdots%2C%20%5Cmathbf%7Ba%7D_%7B1%7D%20b'_%7B1q%7D%5Cright%5D%2B%5C%5C%0A%26%20%5Cquad%20%5Cleft%5B%5Cmathbf%7Ba%7D_%7B2%7D%20b'_%7B21%7D%2C%20%5Cmathbf%7Ba%7D_%7B2%7D%20b'_%7B22%7D%2C%20%5Ccdots%2C%20%5Cmathbf%7Ba%7D_%7B2%7D%20b'_%7B2q%7D%5Cright%5D%20%2B%5C%5C%0A%26%20%5Cquad%20%5Ccdots%20%5C%5C%0A%26%20%5Cquad%20%5Cleft%5B%5Cmathbf%7Ba%7D_%7Bn%7D%20b'_%7Bn%201%7D%2C%20%5Cmathbf%7Ba%7D_%7Bn%7D%20b'_%7Bn2%7D%2C%20%5Ccdots%2C%20%5Cmathbf%7Ba%7D_%7Bn%7D%20b'_%7Bnq%7D%5Cright%5D%5C%5C%0A%26%5C%5C%0A%26%3D%5B%5Cmathbf%7Ba%7D_%7B1%7D%20b'_%7B11%7D%20%2B%20%5Cmathbf%7Ba%7D_%7B2%7D%20b'_%7B21%7D%2B%5Ccdots%2B%5Cmathbf%7Ba%7D_%7Bn%7D%20b'_%7Bn%201%7D%2C%20%5C%5C%0A%26%20%5Cquad%20%5Cmathbf%7Ba%7D_%7B1%7D%20b'_%7B12%7D%20%2B%20%5Cmathbf%7Ba%7D_%7B2%7D%20b'_%7B22%7D%2B%5Ccdots%2B%5Cmathbf%7Ba%7D_%7Bn%7D%20b'_%7Bn%202%7D%2C%20%5C%5C%0A%26%20%5Cquad%20%5Ccdots%2C%20%5C%5C%0A%26%20%5Cquad%20%5Cmathbf%7Ba%7D_%7B1%7D%20b'_%7B1q%7D%20%2B%20%5Cmathbf%7Ba%7D_%7B2%7D%20b'_%7B2q%7D%2B%5Ccdots%2B%5Cmathbf%7Ba%7D_%7Bn%7D%20b'_%7Bn%20q%7D%5D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们证明了 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 的每一列均为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的列的线性组合。</p>
<p>其实利用上面的” <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5Cmathbf%7Bb%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的列的线性组合“这个性质，我们可以更简洁地证明这一点</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BA%7D%20%5Cmathbf%7BB%7D%26%3D%5Cmathbf%7BA%7D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Blll%7D%0A%5Cmathbf%7Bb%7D_%7B1%7D%2C%20%5Cmathbf%7Bb%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cmathbf%7Bb%7D_%7Bq%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%5C%5C%0A%26%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Blll%7D%0A%5Cmathbf%7BA%7D%5Cmathbf%7Bb%7D_%7B1%7D%2C%20%5Cmathbf%7BA%7D%5Cmathbf%7Bb%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cmathbf%7BA%7D%5Cmathbf%7Bb%7D_%7Bq%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%5C%5C%0A%0A%5Cend%7Baligned%7D%0A" /></p><p>这里，我们同样证明了<img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/>的每一列均为<img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/>的列的线性组合。</p>
<p>举个例子，假设</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Blll%7D%0A2%20%26%202%20%26%203%20%5C%5C%0A1%20%26%200%20%26%201%20%5C%5C%0A3%20%26%202%20%26%204%0A%5Cend%7Barray%7D%5Cright%5D%2C%0A%5Cmathbf%7BB%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A1%20%26%200%20%5C%5C%0A2%20%26%201%20%5C%5C%0A3%20%26%203%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>根据矩阵乘法，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%5Cmathbf%7BB%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A15%20%26%2011%20%5C%5C%0A4%20%26%203%20%5C%5C%0A9%20%26%2014%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>根据我们上面的推导，<img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 每一列可以拆分为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%7B%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A2%20%5C%5C%0A1%20%5C%5C%0A3%0A%5Cend%7Barray%7D%5Cright%5D%201%2B%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A2%20%5C%5C%0A0%20%5C%5C%0A2%0A%5Cend%7Barray%7D%5Cright%5D%202%2B%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A3%20%5C%5C%0A1%20%5C%5C%0A4%0A%5Cend%7Barray%7D%5Cright%5D%203%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A15%20%5C%5C%0A4%20%5C%5C%0A19%0A%5Cend%7Barray%7D%5Cright%5D%7D%20%5C%5C%0A%26%7B%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A2%20%5C%5C%0A1%5C%5C%0A3%0A%5Cend%7Barray%7D%5Cright%5D%200%2B%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A2%20%5C%5C%0A0%20%5C%5C%0A2%0A%5Cend%7Barray%7D%5Cright%5D%201%2B%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A3%20%5C%5C%0A1%20%5C%5C%0A4%0A%5Cend%7Barray%7D%5Cright%5D%203%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A11%20%5C%5C%0A3%20%5C%5C%0A14%0A%5Cend%7Barray%7D%5Cright%5D%7D%0A%5Cend%7Baligned%7D%0A" /></p><h1>AB 的每一行均为B的行的线性组合</h1>
<p>类似上面，假设 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=1%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的行向量，<img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20q" style="display:inline-block;margin: 0;"/> 的矩阵，那么</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%5Cmathbf%7BB%7D%20%3D%20%5Cleft%28%5Cbegin%7Barray%7D%7Br%7D%0Aa_%7B1%7D%2C%20%26%0Aa_%7B2%7D%2C%20%26%0A%5Ccdots%2C%20%26%0Aa_%7Bn%7D%0A%5Cend%7Barray%7D%5Cright%29%0A%5Cleft(%5Cbegin%7Barray%7D%7Br%7D%0A%5Cmathbf%7Bb%7D%5E%7B%5Cprime%7D_%7B1%7D%20%5C%5C%0A%5Cmathbf%7Bb%7D%5E%7B%5Cprime%7D_%7B2%7D%20%5C%5C%0A%5Cvdots%20%5C%5C%0A%5Cmathbf%7Bb%7D%5E%7B%5Cprime%7D_%7Bn%7D%0A%5Cend%7Barray%7D%5Cright)%0A%3Da_%7B1%7D%5Cmathbf%7Bb%7D%5E%7B%5Cprime%7D_%7B1%7D%2B%0Aa_%7B2%7D%5Cmathbf%7Bb%7D%5E%7B%5Cprime%7D_%7B2%7D%20%2B%0A%5Ccdots%20%2B%0Aa_%7Bn%7D%20%5Cmathbf%7Bb%7D%5E%7B%5Cprime%7D_%7Bn%7D%0A%0A" /></p><p>因此，我们证明 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/>的行的线性组合。</p>
<p>假如 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵，<img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20q" style="display:inline-block;margin: 0;"/> 的矩阵，那么</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%5Cmathbf%7BB%7D%20%3D%20%0A%0A%5Cleft%28%5Cbegin%7Barray%7D%7Br%7D%0A%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D_%7B1%7D%20%5C%5C%0A%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D_%7B2%7D%20%5C%5C%0A%5Cvdots%20%5C%5C%0A%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D_%7Bn%7D%0A%5Cend%7Barray%7D%5Cright%29%20%5Cmathbf%7BB%7D%0A%0A%20%3D%20%0A%0A%5Cleft(%5Cbegin%7Barray%7D%7Br%7D%0A%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D_%7B1%7D%20%5Cmathbf%7BB%7D%20%5C%5C%0A%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D_%7B2%7D%20%5Cmathbf%7BB%7D%20%5C%5C%0A%5Cvdots%20%5C%5C%0A%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D_%7Bn%7D%20%5Cmathbf%7BB%7D%0A%5Cend%7Barray%7D%5Cright)%0A" /></p><p>因此得证 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 的每一行均是 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 的行的线性组合。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>18位身份证号的编码规则</title>
    <url>/posts/75bebd59/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>突然有一个疑问，身份证号码是如何编码的？最主要是如何避免身份证号重复的（同一个行政区域内的同年同月同日生的同性别的新生儿）？</p>
<span id="more"></span>
<h1>18位身份证号编码规则</h1>
<p>知乎的一篇博文<a href="https://zhuanlan.zhihu.com/p/21286417">实名认证前传之身份证号码编码规则</a> 感觉已经说得很清楚了，用我自己的身份证号测试了一下，最后一位的校验码的规则应该是对的。</p>
<p>下面的内容均来自这一篇博文。</p>
<blockquote>
<p><strong>一、身份证号码结构</strong></p>
<p>早期‘身份证号码’叫‘社会保障号’，为15位，1999年开始更名为公民身份证号码，即第二代身份证，为18位，且终身不变。</p>
<p>430512198908131367</p>
<p>公民身份号码是特征组合码，由前十七位数字本体码和最后一位数字校验码组成。排列顺序从左至右依次为六位数字地址码，八位数字出生日期码，三位数字顺序码和一位数字校验码。</p>
<p><strong>地址码</strong>： 6位，表示编码对象常住户口所在县(市、旗、区)的行政区划代码。对于新生儿，该地址码为户口登记地行政区划代码。需要没说明的是，随着行政区划的调整，同一个地方进行户口登记的可能存在地址码不一致的情况。行政区划代码按GB/T2260的规定执行。</p>
<p><strong>出生日期码</strong>：8位，表示编码对象出生的年、月、日，年、月、日代码之间不用分隔符，格式为YYYYMMDD，如19880328。按GB/T 7408的规定执行。原15位身份证号码中出生日期码还有对百岁老人特定的标识，其中999、998、997、996分配给百岁老人。</p>
<p><strong>顺序码</strong>： 3位，表示在同一地址码所标识的区域范围内，对同年、同月、同日出生的人编定的顺序号，顺序码的奇数分配给男性，偶数分配给女性。</p>
<p><strong>校验码</strong>： 1位，根据本体码，通过采用ISO 7064:1983,MOD 11-2校验码系统计算出校验码。算法可参考下文。前面有提到数字校验码，我们知道校验码也有X的，实质上为罗马字符X，相当于10.</p>
</blockquote>
<h2 id="校验码算法">校验码算法</h2>
<p>校验码是通过前 17 位数字通过下面这个算法进行计算得到的，也就是说前 17 位数字确定了，第 18 位数字也就确定了。</p>
<p>举个例子，假设本体码为  11010519491231002</p>
<p>第一步：根据下表，将本体码的前17位数字乘以相应的加权因子，求和，按上面的例子，就是 $1 \times 7+1 \times 9+ \cdots +2 \times 2 = 167 $</p>
<table>
<thead>
<tr>
<th>身份证位置序号</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
<th>17</th>
</tr>
</thead>
<tbody>
<tr>
<td>加权因子</td>
<td>7</td>
<td>9</td>
<td>10</td>
<td>5</td>
<td>8</td>
<td>4</td>
<td>2</td>
<td>1</td>
<td>6</td>
<td>3</td>
<td>7</td>
<td>9</td>
<td>10</td>
<td>5</td>
<td>8</td>
<td>4</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>第二步，对上面的和除以11计算余数，这里就是 <img src="https://math.now.sh?inline=167%5C%2511%20%3D%202" style="display:inline-block;margin: 0;"/></p>
<p>第三步，根据余数对照下面，最终得到校验码为  X</p>
<table>
<thead>
<tr>
<th>余数</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td>校验码</td>
<td>1</td>
<td>0</td>
<td>X</td>
<td>9</td>
<td>8</td>
<td>7</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>因此，本例的完整身份证号为 11010519491231002X</p>
<h1>如何避免重复呢？</h1>
<p>我的问题是，同一个县同一天肯定不只是一个人出生（顺序码从 000 到 999 一共是1000个数，也就是一个县同一天能落户的新生儿数目的最大值是 1000 ），同一个县可以用于落户的派出所应该有多个，那么同一天同一性别的多个初生儿同时分别去多个派出所落户，是如何确保他们分配得到的身份证号是唯一的呢？</p>
<p>这个问题我不知道，但是我感觉这应该是数据库的一个操作。我能想到的是，可能在同一个县里如果有人新建记录的时候就锁住数据库，不允许其他人再往数据库里插入记录，这样就可以避免身份证号的重复问题。</p>
<p>然后我咨询了一下小强，他和我说这就是数据库的一个基本特性，如果有多个人同时往数据库里插入了主键相同的一行，那么应该有一个人会插入成功，其他人会显示失败。</p>
<h2 id="数据库事务">数据库事务</h2>
<p>下面的内容主要来自维基百科 <a href="https://www.wikiwand.com/zh-hans/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1">数据库事务</a> 。</p>
<blockquote>
<p><strong>数据库事务</strong>（简称：<strong>事务</strong>）是<a href="https://www.wikiwand.com/zh-hans/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">数据库管理系统</a>执行过程中的一个逻辑单位，由一个有限的<a href="https://www.wikiwand.com/zh-hans/%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a>操作序列构成。</p>
<h2 id="概要">概要</h2>
<p>数据库事务通常包含了一个序列的对数据库的读/写操作。包含有以下两个目的：</p>
<ol>
<li>为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。</li>
<li>当多个<a href="https://www.wikiwand.com/zh-hans/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">应用程序</a>在<a href="https://www.wikiwand.com/zh-hans/%E5%B9%B6%E5%8F%91">并发</a>访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。</li>
</ol>
<p>当事务被提交给了<a href="https://www.wikiwand.com/zh-hans/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">数据库管理系统</a>（DBMS），则<strong>DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要<a href="https://www.wikiwand.com/zh-hans/%E5%9B%9E%E6%BB%9A_(%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86)">回滚</a>，回到事务执行前的状态；同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行</strong>。</p>
<h3 id="例子">例子</h3>
<p>某人要在商店使用<a href="https://www.wikiwand.com/zh-hans/%E9%9B%BB%E5%AD%90%E8%B2%A8%E5%B9%A3">电子货币</a>购买100元的东西，当中至少包括两个操作：</p>
<ol>
<li>该人帐户减少100元</li>
<li>商店帐户增加100元</li>
</ol>
<p><strong>支援交易的资料库管理系统</strong>（<strong>transactional DBMS</strong>）就是要确保以上两个操作（整个“交易”）都能完成，或一起取消；否则就会出现100元平白消失或出现的情况。</p>
<p>但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、<a href="https://www.wikiwand.com/zh-hans/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F">数据库系统</a>／<a href="https://www.wikiwand.com/zh-hans/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>出错，甚至是存储介质出错等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的<a href="https://www.wikiwand.com/zh-hans/%E4%B8%80%E8%87%B4%E6%80%A7">一致性</a>得到保证的状态）。为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志（英语：<a href="https://www.wikiwand.com/en/Transaction_log">Transaction log</a>）以追踪事务中所有影响数据库数据的操作[<a href="https://www.wikiwand.com/zh-hans/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1#citenote1">1]</a>[<a href="https://www.wikiwand.com/zh-hans/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1#citenote2">2]</a>。</p>
</blockquote>
<h2 id="ACID-性质">ACID 性质</h2>
<p>下文内容主要来自于 <a href="https://blog.csdn.net/qq_39521554/article/details/80240841">数据库的ACID（原子性、一致性、隔离性与持久性）</a></p>
<p>数据库管理系统中**事务(transaction)**的四个特性（分析时根据首字母缩写依次解释）：<strong>原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）</strong></p>
<p>详解</p>
<ol>
<li>原子性</li>
</ol>
<blockquote>
<p>原子性是指事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生。</p>
<p>可采用“A向B转账”这个例子来说明解释</p>
<p>在DBMS中，默认情况下一条SQL就是一个单独事务，事务是自动提交的。只有显式的使用start transaction开启一个事务，才能将一个代码块放在事务中执行。</p>
</blockquote>
<p>新增解释，根据 <a href="https://www.zhihu.com/question/30272728/answer/72476703">数据库事务原子性、一致性是怎样实现的？ - 左轻侯的回答 - 知乎</a></p>
<blockquote>
<p>为了实现原子性，需要通过<strong>日志</strong>：将所有对数据的更新操作都写入日志，如果一个事务中的一部分 操作已经成功，但以后的操作，由于断电/系统崩溃/其它的软硬件错误而无法继续，则通过回溯日志，将已经执行成功的操作撤销，从而达到 “全部操作失败&quot; 的目的。最常见的场景是，<strong>数据库系统崩溃后重启，此时数据库处于不一致的状态，必须先执行一个crash recovery的过程：读取日志 进行REDO</strong>（重演将所有已经执行成功但尚末写入到磁盘的操作，保证持久性），再对所有到崩溃 时尚末成功提交的事务进行UNDO (撤销所有执行了一部分但尚末提交的操作，保证原子性)。 crash recovery结束后，数据库恢复到一致性状态，可以继续被使用。</p>
</blockquote>
<ol start="2">
<li>一致性</li>
</ol>
<blockquote>
<p>一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</p>
<p>如A给B转账，不论转账的事务操作是否成功，其两者的存款总额不变（这是业务逻辑的一致性，至于数据库关系约束的完整性就更好理解了）。</p>
<p>保障机制（也从两方面着手）：数据库层面会在一个事务执行之前和之后，数据会符合你设置的约束（唯一约束，外键约束,check约束等)和触发器设置；此外，数据库的内部数据结构（如 B 树索引或双向链表）都必须是正确的。业务的一致性一般由开发人员进行保证，亦可转移至数据库层面。</p>
</blockquote>
<ol start="3">
<li>隔离性</li>
</ol>
<blockquote>
<p>多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。</p>
<p>在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</p>
<p>事务最复杂问题都是由事务隔离性引起的。完全的隔离性是不现实的，完全的隔离性要求数据库同一时间只执行一条事务，这样会严重影响性能。关于隔离性中的事务隔离等级（事务之间影响），参见相应博文</p>
</blockquote>
<p>这里解释的还不够细，当存在并发操作时，原子性并不能保证一致性，因此引入了隔离性。详细回答见  <a href="https://www.zhihu.com/question/30272728/answer/72476703">数据库事务原子性、一致性是怎样实现的？ - 左轻侯的回答 - 知乎</a></p>
<p>下面最核心的话是，<strong>多个事务并发执行后的状态，和它们串行执行后的状态是等价的</strong>。如何实现隔离性很复杂，但是我也不太关心。</p>
<blockquote>
<p>但是，原子性并不能完全保证一致性。在多个事务并行进行的情况下，即使保证了每一个事务的原 子性，仍然可能导致数据不一致的结果。例如，事务1需要将100元转入帐号A: 先读取帐号A的 值，然后在这个值上加上 100 。但是，在这两个操作之间，另一个事务 2 修改了帐号 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的值，为它增 加了100元。那么最后的结果应该是A增加了200元。但事实上，事务1最终完成后，帐号A只增加 了100元，因为事务2的修改结果被事务1覆盖掉了。<br>
为了保证并发情况下的一致性，引入了隔离性，即保证每一个事务能够看到的数据总是一致的，就好象其它并发事务并不存在一样。用术语来说，就是<strong>多个事务并发执行后的状态，和它们串行执行后的状态是等价的</strong>。怎样实现隔离性，已经有很多人回答过了，原则上无非是两种类型的锁:<br>
一种是悲观锁 <img src="https://math.now.sh?inline=%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，即当前事务将所有涉及操作的对象加锁，操作完成后释放给其它对象使用。为了尽 可能提高性能，发明了各种粒度（数据库级/表级/行级…)/各种性质（共享钓/排他锁/共享意向 锁/排他意向锁/共享排他意向锁…) 的锁。为了解决死锁问题，又发明了两阶段锁协议/死锁检测 等一系列的技术。<br>
一种是乐观锁，即不同的事务可以同时看到同一对象 (一般是数据行) 的不同历史版本。如果有两 个事务同时修改了同一数据行，那么在较晩的事务提交时进行冲突检测。实现也有两种，一种是通 过日志UND <img src="https://math.now.sh?inline=%5E%7B%5Ccirc%7D" style="display:inline-block;margin: 0;"/> O的方式来获取数据行的历史版本，一种是简单地在内存中保存同一数据行的多个历 史版本，通过时间濯 <img src="https://math.now.sh?inline=%5E%7B%5Cmathrm%7Ba%7D%7D" style="display:inline-block;margin: 0;"/> 来区分。<br>
锁也是数据库实现中最复杂的部分之一。同样，如果涉及到分布式系统（分布式锁和两阶段提交是 分布式事务的基础)，会比上述场景还要复杂得多。</p>
</blockquote>
<ol start="4">
<li>持久性</li>
</ol>
<blockquote>
<p>这是最好理解的一个特性：持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。（完成的事务是系统永久的部分，对系统的影响是永久性的，该修改即使出现致命的系统故障也将一直保持）</p>
<p><code>write ahead logging</code>：SQL Server中使用了WAL（Write-Ahead Logging）技术来保证事务日志的ACID特性，在数据写入到数据库之前，先写入到日志，再将日志记录变更到存储器中。</p>
</blockquote>
<blockquote>
<p>————————————————<br>
版权声明：本文为CSDN博主「图灵的猫i」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：<a href="https://blog.csdn.net/qq_39521554/article/details/80240841">https://blog.csdn.net/qq_39521554/article/details/80240841</a></p>
</blockquote>
<h2 id="身份证号码重复与隔离性">身份证号码重复与隔离性</h2>
<p>上面的身份证号码避免重复的问题就是用到了隔离性，如果我们把身份证号码设置位主键，那么往数据库中同时插入多个相同主键的行这一并发操作，按照隔离性的性质，和它们<strong>串行执行后的状态是等价的</strong>，也就是说最终应该是<strong>有一个插入操作成功，其他插入操作应该会报错</strong>，从而避免违背一致性，即数据库中出现重复的主键。</p>
<p>所以我的担心是多余的，数据库系统的基本特性本身就可以避免身份证号码重复这个问题的发生。</p>
]]></content>
      <tags>
        <tag>数据分析</tag>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>特征值的乘积与和</title>
    <url>/posts/c98e6ad5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>证明特征值的乘积为行列式，特征值的和为迹。</p>
<span id="more"></span>
<h1>特征值和特征向量</h1>
<p>这一小节的内容主要来自于吴恩达老师的讲义。</p>
<p><img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的特征值和特征向量满足关系：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%20x%3D%5Clambda%20x%2C%20%5Cquad%20x%20%5Cneq%200%0A" /></p><p>我们注意到对于任何特征向量 <img src="https://math.now.sh?inline=x%20%5Cin%20%5Cmathbb%7BC%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> ，和特征值 <img src="https://math.now.sh?inline=t%20%5Cin%20%5Cmathbb%7BC%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%28c%20x%29%3Dc%20%5Cmathbf%7BA%7D%20x%3Dc%20%5Clambda%20x%3D%5Clambda(c%20x)" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=c%20x" style="display:inline-block;margin: 0;"/> 一样是 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的特征向量。因此，当我们提到与特征值 <img src="https://math.now.sh?inline=%5Clambda" style="display:inline-block;margin: 0;"/> 的特征向量 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 时，<strong>我们一般假定特征向量 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 是标准化的</strong>，即 <img src="https://math.now.sh?inline=%5C%7Cx%5C%7C%20%3D%201" style="display:inline-block;margin: 0;"/> 。但是，我们注意到，<img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=-x" style="display:inline-block;margin: 0;"/> 都是特征向量，因此我们无法保证特征向量的符号。</p>
<p>我们可以将上式改写为：</p>
<p style=""><img src="https://math.now.sh?from=%7C%28%5Cmathbf%7BA%7D-%5Clambda%20I%29%7C%3D0%0A" /></p><p>如果我们将上式中的行列式展开，我们得到一个变量为 <img src="https://math.now.sh?inline=%5Clambda" style="display:inline-block;margin: 0;"/> 的 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 次多项式。</p>
<p style=""><img src="https://math.now.sh?from=p%28%5Clambda%29%20%3D%20%7C(%5Cmathbf%7BA%7D-%5Clambda%20I)%7C%0A" /></p><p>这个多项式称为<strong>特征多项式</strong> (<em>characteristic polynomial</em>) ，而 <img src="https://math.now.sh?inline=%7C%28%5Cmathbf%7BA%7D-%5Clambda%20I%29%7C%3D0" style="display:inline-block;margin: 0;"/> 这个方程称为矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的<strong>特征方程</strong>  (<em>characteristic equation</em>) 。特征多项式的根即为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的特征值，如果对重根也计数，那么 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 将有 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个特征值，但是某些特征值可能会是复数，这一点可以通过<strong>代数基本定理</strong>证明。</p>
<p>举个例子，假设  <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%203%20%26%202%20%5C%5C%203%20%26%20-2%20%5Cend%7Barray%7D%20%5Cright%5D" style="display:inline-block;margin: 0;"/> ，那么其特征方程为</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%7C%5Cbegin%7Barray%7D%7Bc%7D%203-%5Clambda%20%26%202%20%5C%5C%203%20%26%20-2-%5Clambda%20%5Cend%7Barray%7D%20%5Cright%7C%20%3D%200%20%5Cquad%20%5Ctext%7B%20%E6%88%96%20%7D%20%5Cquad%20%5Clambda%5E%7B2%7D-%5Clambda%2B12%3D0%0A" /></p><p>那么<img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的特征值为 <img src="https://math.now.sh?inline=%5Clambda_%7B1%7D%20%3D%204" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Clambda_%7B2%7D%20%3D%20-3" style="display:inline-block;margin: 0;"/></p>
<h1>代数基本定理</h1>
<p>维基百科的说明如下</p>
<blockquote>
<p><strong>代数基本定理</strong>说明，任何一个一元复系数<a href="https://www.wikiwand.com/zh-hans/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%96%B9%E7%A8%8B">多项式方程</a>都至少有一个复数<a href="https://www.wikiwand.com/zh-hans/%E6%A0%B9_(%E6%95%B0%E5%AD%A6)">根</a>。也就是说，<a href="https://www.wikiwand.com/zh-hans/%E8%A4%87%E6%95%B8_(%E6%95%B8%E5%AD%B8)">复数</a><a href="https://www.wikiwand.com/zh-hans/%E4%BD%93_(%E6%95%B0%E5%AD%A6)">域</a>是<a href="https://www.wikiwand.com/zh-hans/%E4%BB%A3%E6%95%B0%E5%B0%81%E9%97%AD%E5%9F%9F">代数封闭</a>的。</p>
<p>有时这个定理表述为：任何一个非零的一元n次复系数多项式，都正好有n个复数根（重根视为多个根）。这似乎是一个更强的命题，但实际上是“至少有一个根”的直接结果，因为不断把多项式除以它的线性因子，即可从有一个根推出有n个根。也就是说，<strong>任何一个n次多项式，都可以因式分解为n个复系数一次多项式的乘积</strong>。</p>
</blockquote>
<p>代数基本定理是高斯发现的，高斯总共给出了四个证明，但是我看维基百科后面的证明过程都看不懂。</p>
<p>有一个<a href="https://www.shuxuele.com">数学乐</a>的网址，更简单直观地解释了代数基本定理，感兴趣可以去看一下这里 <a href="https://www.shuxuele.com/algebra/fundamental-theorem-algebra.html">代数基本定理</a> 。</p>
<p>简单地说，就是任何一个一元 <strong>n</strong> 次多项式均有 <strong>n</strong> 个根（包括重根），但是可能是复数。任何一元 <strong>n</strong> 次多项式可以因式分解为下面地形式，其中 <img src="https://math.now.sh?inline=r_1%2Cr_2%2C%5Ccdots%2Cr_n" style="display:inline-block;margin: 0;"/> 为 <strong>n</strong> 个根 ，并且易得 <img src="https://math.now.sh?inline=a" style="display:inline-block;margin: 0;"/> 为多项式第一项 <img src="https://math.now.sh?inline=x%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 的系数。</p>
<p style=""><img src="https://math.now.sh?from=a%28x-r_%7B1%7D%29(x-r_%7B2%7D)%5Ccdots(x-r_%7Bn%7D)%0A" /></p><p>如果多项式有复数根，它所有的复数根必然为共轭对 (<img src="https://math.now.sh?inline=a%2Bb%5Cmathbf%7Bi%7D" style="display:inline-block;margin: 0;"/>  和 <img src="https://math.now.sh?inline=a-b%5Cmathbf%7Bi%7D" style="display:inline-block;margin: 0;"/>)。</p>
<h1>特征值的乘积与和</h1>
<p>这一节内容主要来自于《linear algebra with applications》 的第六章特征值。</p>
<p>若 <img src="https://math.now.sh?inline=p%28%5Clambda%29" style="display:inline-block;margin: 0;"/> 为矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的特征多项式，则</p>
<p style=""><img src="https://math.now.sh?from=p%28%5Clambda%29%3D%5Coperatorname%7Bdet%7D(%5Cmathbf%7BA%7D-%5Clambda%20I)%3D%5Cleft%7C%5Cbegin%7Barray%7D%7Bcccc%7D%0Aa_%7B11%7D-%5Clambda%20%26%20a_%7B12%7D%20%26%20%5Ccdots%20%26%20a_%7B1%20n%7D%20%5C%5C%0Aa_%7B21%7D%20%26%20a_%7B22%7D-%5Clambda%20%26%20%5Ccdots%20%26%20a_%7B2%20n%7D%20%5C%5C%0A%5Cvdots%20%26%20%26%20%26%20%5C%5C%0Aa_%7Bn%201%7D%20%26%20a_%7Bn%202%7D%20%26%20%5Ccdots%20%26%20a_%7Bn%20n%7D-%5Clambda%0A%5Cend%7Barray%7D%5Cright%7C%0A" /></p><p>按照第一列展开，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Bdet%7D%28%5Cmathbf%7BA%7D-%5Clambda%20I%29%3D%5Cleft(a_%7B11%7D-%5Clambda%5Cright)%20%5Coperatorname%7Bdet%7D%5Cleft(%5Cmathbf%7BM%7D_%7B11%7D%5Cright)%2B%5Csum_%7Bi%3D2%7D%5E%7Bn%7D%20a_%7Bi%201%7D(-1)%5E%7Bi%2B1%7D%20%5Coperatorname%7Bdet%7D%5Cleft(%5Cmathbf%7BM%7D_%7Bi%201%7D%5Cright)%0A" /></p><p>我们注意到，子式 <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D_%7B11%7D" style="display:inline-block;margin: 0;"/> 不包含一个对角线元素 (<img src="https://math.now.sh?inline=a_%7B11%7D-%5Clambda" style="display:inline-block;margin: 0;"/>) ，而其他子式 <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D_%7Bi1%7D" style="display:inline-block;margin: 0;"/> (<img src="https://math.now.sh?inline=i%3D2%2C%5Ccdots%2Cn" style="display:inline-block;margin: 0;"/>)  不包含两个对角线元素 <img src="https://math.now.sh?inline=%5Cleft%28a_%7B11%7D-%5Clambda%5Cright%29" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cleft%28a_%7Bii%7D-%5Clambda%5Cright%29" style="display:inline-block;margin: 0;"/> 。</p>
<p>将子式 <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D_%7B11%7D" style="display:inline-block;margin: 0;"/>  采用相同的方法展开，我们得到下式是 <img src="https://math.now.sh?inline=%5Coperatorname%7Bdet%7D%28%5Cmathbf%7BA%7D-%5Clambda%20I%29" style="display:inline-block;margin: 0;"/>  的展开式中<strong>唯一包含超过 <img src="https://math.now.sh?inline=n-2" style="display:inline-block;margin: 0;"/> 个对角线元素</strong>的项（不好直接证明，在草稿上继续展开，就可以看出规律，其他项应该都是包括了<img src="https://math.now.sh?inline=n-2" style="display:inline-block;margin: 0;"/> 个对角线元素 ）。</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%28a_%7B11%7D-%5Clambda%5Cright%29%5Cleft(a_%7B22%7D-%5Clambda%5Cright)%20%5Ccdots%5Cleft(a_%7Bn%20n%7D-%5Clambda%5Cright)%0A" /></p><p>我们把这个式子展开后，易得 <img src="https://math.now.sh?inline=%5Clambda%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 的系数为 <img src="https://math.now.sh?inline=%28-1%29%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> ，因此  <img src="https://math.now.sh?inline=p%28%5Clambda%29" style="display:inline-block;margin: 0;"/>  的首系数为  <img src="https://math.now.sh?inline=%28-1%29%5E%7Bn%7D" style="display:inline-block;margin: 0;"/>  。根据代数基本定理，如果  <img src="https://math.now.sh?inline=%5Clambda_1%2C%5Clambda_2%2C%5Ccdots%2C%5Clambda_n" style="display:inline-block;margin: 0;"/> 为方阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 的特征根，那么  <img src="https://math.now.sh?inline=p%28%5Clambda%29" style="display:inline-block;margin: 0;"/> 可以因式分解为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ap%28%5Clambda%29%20%26%3D(-1)%5E%7Bn%7D%5Cleft(%5Clambda-%5Clambda_%7B1%7D%5Cright)%5Cleft(%5Clambda-%5Clambda_%7B2%7D%5Cright)%20%5Ccdots%5Cleft(%5Clambda-%5Clambda_%7Bn%7D%5Cright)%20%5C%5C%0A%26%3D%5Cleft(%5Clambda_%7B1%7D-%5Clambda%5Cright)%5Cleft(%5Clambda_%7B2%7D-%5Clambda%5Cright)%20%5Ccdots%5Cleft(%5Clambda_%7Bn%7D-%5Clambda%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们得到下式，证明方阵的所有特征值之积为其行列式。</p>
<p style=""><img src="https://math.now.sh?from=p%280%29%20%3D%20%5Clambda_%7B1%7D%20%5Clambda_%7B2%7D%5Ccdots%20%5Clambda_%7Bn%7D%20%3D%20%5Cdet(%5Cmathbf%7BA%7D)%20%0A" /></p><p>由 <img src="https://math.now.sh?inline=%5Cleft%28a_%7B11%7D-%5Clambda%5Cright%29%5Cleft(a_%7B22%7D-%5Clambda%5Cright)%20%5Ccdots%5Cleft(a_%7Bn%20n%7D-%5Clambda%5Cright)" style="display:inline-block;margin: 0;"/> ，我们同样可以看出 <img src="https://math.now.sh?inline=%28-%5Clambda%29%5E%7Bn-1%7D" style="display:inline-block;margin: 0;"/> 的系数为  <img src="https://math.now.sh?inline=%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20a_%7Bii%7D" style="display:inline-block;margin: 0;"/> 。如果对 <img src="https://math.now.sh?inline=p%28%5Clambda%29%3D%5Cleft(%5Clambda_%7B1%7D-%5Clambda%5Cright)%5Cleft(%5Clambda_%7B2%7D-%5Clambda%5Cright)%20%5Ccdots%5Cleft(%5Clambda_%7Bn%7D-%5Clambda%5Cright)" style="display:inline-block;margin: 0;"/> 同样求 <img src="https://math.now.sh?inline=%28-%5Clambda%29%5E%7Bn-1%7D" style="display:inline-block;margin: 0;"/> 的系数，可以得到其为  <img src="https://math.now.sh?inline=%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Clambda_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，因此我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Clambda_%7Bi%7D%20%3D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20a_%7Bii%7D%0A" /></p><p>因此我们证明所有特征值之和为矩阵的迹。</p>
<h1>相似矩阵</h1>
<p>这一节内容主要来自于《linear algebra with applications》 的第六章特征值。</p>
<p>对于矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 和矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> ，若存在一个非奇异矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7BS%7D" style="display:inline-block;margin: 0;"/>，使得  <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D%20%3D%20%5Cmathbf%7BS%5E%7B-1%7DAS%7D" style="display:inline-block;margin: 0;"/> ，那么我们称矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> <strong>相似于</strong>矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/>  。</p>
<p><strong>定理</strong>：令矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 和矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 矩阵，若 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 相似于 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/>，则这两个矩阵有相同的特征多项式，且相应地有相同的特征值。</p>
<p>证明：令 <img src="https://math.now.sh?inline=p_%7BA%7D%28%5Clambda%29" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=p_%7BB%7D%28%5Clambda%29" style="display:inline-block;margin: 0;"/> 分别为 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 的特征多项式。因为 <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D" style="display:inline-block;margin: 0;"/> 相似于 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/>，则存在一个非奇异矩阵  <img src="https://math.now.sh?inline=%5Cmathbf%7BS%7D" style="display:inline-block;margin: 0;"/>，使得  <img src="https://math.now.sh?inline=%5Cmathbf%7BB%7D%20%3D%20%5Cmathbf%7BS%5E%7B-1%7DAS%7D" style="display:inline-block;margin: 0;"/> 。因此</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ap_%7BB%7D%28%5Clambda%29%20%26%3D%5Coperatorname%7Bdet%7D(%5Cmathbf%7BB%7D-%5Clambda%20%5Cmathbf%7BI%7D)%20%5C%5C%0A%26%3D%5Coperatorname%7Bdet%7D%5Cleft(%5Cmathbf%7BS%7D%5E%7B-1%7D%20%5Cmathbf%7BA%7D%20%5Cmathbf%7BS%7D-%5Clambda%20%5Cmathbf%7BI%7D%5Cright)%20%5C%5C%0A%26%3D%5Coperatorname%7Bdet%7D%5Cleft(%5Cmathbf%7BS%7D%5E%7B-1%7D(%5Cmathbf%7BA%7D-%5Clambda%20%5Cmathbf%7BI%7D)%20%5Cmathbf%7BS%7D%5Cright)%20%5C%5C%0A%26%3D%5Coperatorname%7Bdet%7D%5Cleft(%5Cmathbf%7BS%7D%5E%7B-1%7D%5Cright)%20%5Coperatorname%7Bdet%7D(%5Cmathbf%7BA%7D-%5Clambda%20%5Cmathbf%7BI%7D)%20%5Coperatorname%7Bdet%7D(%5Cmathbf%7BS%7D)%20%5C%5C%0A%26%3Dp_%7BA%7D(%5Clambda)%0A%5Cend%7Baligned%7D%0A" /></p><p>一个矩阵的特征值为特征多项式的根。因为两个矩阵有相同的特征多项式，所以它们必有相同的特征值。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归与R代码实现</title>
    <url>/posts/6cb58071/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>线性回归是最基础的统计模型，也应该是应用最广泛的应用模型。线性回归的因变量必须为连续变量；自变量可以为连续变量，也可以为分类变量（转化为哑变量/虚拟变量）</p>
<p>这里是我通过看资料对线性回归的总结。</p>
<span id="more"></span>
<h1>参考资料</h1>
<p><a href="https://www.statlearning.com/">An Introduction to Statistical Learning</a>，下文简称 <strong>ISL</strong></p>
<h1>线性回归的假设</h1>
<h2 id="1-自变量和因变量线性相关">1 自变量和因变量线性相关</h2>
<p>线性相关的意思是，无论自变量多大，自变量每增加一个单位，因变量都会产生固定的变化。</p>
<h2 id="2-多个自变量之间具有可加性">2 多个自变量之间具有可加性</h2>
<p>无论 X1 多大，X2 每增加一个单位，因变量都会产生固定的变化。如果满足这个条件，说明 X1和X2 之间具有可加性。否则说明 X1 和 X2 之间存在<strong>互作</strong>效应。用图表示如下（左图两条线平行说明不存在互作，右图不平行说明存在互作）：</p>
<p><img src="12.png" alt="1"></p>
<h2 id="3-多个自变量之间彼此独立">3 多个自变量之间彼此独立</h2>
<p>多个自变量之间不能存在<strong>相关</strong>关系。相关关系分为两种，一种是简单的两两之间的相关，这个通过相关系数矩阵就能看出来是否存在两个变量之间的明显的相关（看绝对值）；第二种是多重线性相关（Multicollinearity），例如 X1 = a + bX2 + cX3，一个自变量可以用其他的多个自变量来解释，就说明存在多重线性相关。</p>
<h2 id="4-观测值的误差项之间互相独立">4 观测值的误差项之间互相独立</h2>
<p>误差项即实际值 - 预测值。如果观测值之间存在我们没有添加到模型中的其他影响因素，那么误差项之间就可能存在相关关系，比如有些样本搜集自同一个家庭的成员，而我们没有把家庭这个因素加入到模型中。</p>
<h2 id="5-误差项（ε）呈正态分布，期望为0，方差为定值">5 误差项（ε）呈正态分布，期望为0，方差为定值</h2>
<blockquote>
<p>这里其实分为两个假设。第一个假设：误差项服从均值为0的正态分布。第二个假设：误差项的方差为定值（不变）。这两个假设是为了保证回归模型在小样本下能够顺利进行假设检验。正态分布假设仅在小样本的情况下需要，大样本的情况下则不需要，因为有中心极限定理做正态性的支撑。而方差齐性则保证最小二乘法估计出来的统计量具有最小的方差。如果违反了这个假设，置信区间会变宽，这称之为<strong>异方差性（heteroscedasticity）</strong>。当异方差性出现的时候，如果仍采用最小二乘法估计参数，会导致参数的t检验值被高估，可能造成本来不显著的某些参数变为显著，使假设检验失去意义。</p>
<p><a href="https://www.cnblogs.com/HuZihu/p/10142737.html">https://www.cnblogs.com/HuZihu/p/10142737.html</a></p>
</blockquote>
<h2 id="6-自变量和误差项之间互相独立">6 自变量和误差项之间互相独立</h2>
<blockquote>
<p>模型中一个或多个自变量与随机误差项存在相关关系，这称之为<strong>内生性（endogeneity）</strong>。内生性通常由于遗漏变量而导致的，因此是一个普遍存在的问题。内生性会导致模型参数估计不准确。</p>
<p><a href="https://www.cnblogs.com/HuZihu/p/10142737.html">https://www.cnblogs.com/HuZihu/p/10142737.html</a></p>
</blockquote>
<h1>简单线性回归</h1>
<h2 id="β0-β1-参数估计-最小二乘法">β0, β1 参数估计 - 最小二乘法</h2>
<p>最小二乘的思路是，查找使得<strong>误差平方和</strong>或<strong>均方误差</strong>最小的参数。</p>
<p>我们首先知道，<strong>误差 = 实际值 - 预测值</strong>，我们的目的实际是想要所有观察值的总体的误差最小，因为误差有正有负，如果采用误差项直接相加会互相抵消，因为我们采用误差的平方进行相加，得到误差平方和 (<abbr title="residual sum of squares">RSS</abbr>)。</p>
<p><img src="1.png" alt="1"></p>
<p>或者写成</p>
<p><img src="2.png" alt="1"></p>
<p>除以总共的样本数 n，便得到<abbr title="mean square error, MSE"><strong>均方误差</strong></abbr>，使得 RSS/MSE 最小的参数便是最小二乘的最优解。写成公式如下（缺推导过程）：</p>
<p><img src="3.png" alt="1"></p>
<p>画成等高图如下（作图横纵坐标为β0和β1，图中一圈表示相同的RSS，数字即为 RSS 大小），我们可以看到这是向下凹的图形，只有一个点RSS 最小。</p>
<p><img src="4.png" alt="1"></p>
<h3 id="为什么不用残差的绝对值？">为什么不用残差的绝对值？</h3>
<p>我上统计课的时候就有这个问题，就一直有这个疑问，如果因为残差有方向，不能直接求和，那为什么不直接用绝对值呢？这不是更直接的更贴近残差本质的思路吗？</p>
<p>使用残差绝对值作为代价函数，在统计的历史上是存在的，称为<strong>最小一乘法</strong>。查看了很多网页的回答，感觉这个回答比较全 <a href="https://zhuanlan.zhihu.com/p/104391088">为什么是“最小二乘”而不是“最小一乘”？</a></p>
<h4 id="最小一乘法的解不一定唯一">最小一乘法的解不一定唯一</h4>
<p>举个简单的例子，根据下图中的四个点，可以构建出无数条回归直线，只要这些直线同时与 AB, CD 相交即可。</p>
<p><img src="29.png" alt="1"></p>
<h4 id="最小二乘求解方便">最小二乘求解方便</h4>
<p>后来上了吴恩达老师的机器学习课，知道了代价函数的概念，寻找代价函数最小值的最简单的方法就是<strong>求导</strong>。最小二乘法的代价函数就是 RSS/MSE，由于这里采用平方和（二次函数），<strong>求导会直接变成一次函数</strong>。而如果使用残差的绝对值的和，根本无法进行简单的求导，就无法简单地得到最优解的公式（而且绝对值在 x = 0 处不可导）。</p>
<h4 id="最小二乘估计结果与正态分布假设下的最大似然估计结果相同">最小二乘估计结果与正态分布假设下的最大似然估计结果相同</h4>
<p>可以证明，当误差服从正态分布时，最大似然法估计结果和最小二乘相同（注意最小二乘与最大似然是截然不同的两种思想，两种方法。最小二乘没有对观测值的分布做假设）。下方证明参考<a href="https://rayleizhu.github.io/2018/12/16/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%B9%B3%E6%96%B9%E8%AF%AF%E5%B7%AE/">最小二乘法为什么使用平方误差</a> 。</p>
<p>当你用线性回归拟合数据时，其实模型包括了两部分，回归项和残差项：</p>
<p style=""><img src="https://math.now.sh?from=y_%7Bi%7D%3Dw%5E%7BT%7D%20x_%7Bi%7D%2B%5Cepsilon_%7Bi%7D%0A" /></p><p>之后我们用<strong>最大似然方法</strong>来估计参数，假设样本数目为n，似然函数表达式如下 (给定一组参数下得到这些观测值的似然值，等于得到这些残差的似然值)：</p>
<p style=""><img src="https://math.now.sh?from=p%28y%20%5Cmid%20w%2C%20b%29%3D%5Cprod_%7Bi%3D1%7D%5E%7Bn%7D%20p%5Cleft(y_%7Bi%7D%20%5Cmid%20w%2C%20b%5Cright)%3D%5Cprod_%7Bi%3D1%7D%5E%7Bn%7D%20p%5Cleft(%5Cepsilon_%7Bi%7D%3Dy_%7Bi%7D-%5Cleft(w%5E%7BT%7D%20x_%7Bi%7D%2Bb%5Cright)%5Cright)%0A" /></p><p>我们需要找到使得似然函数最大的一组参数。</p>
<p>假设残差独立同分布于正态分布 N(0, σ<sup>2</sup>) ，单个残差的概率密度函数如下：</p>
<p style=""><img src="https://math.now.sh?from=f%28%5Cepsilon_i%20%3D%20y_i%20-%20(w%5ETx_i%20%2B%20b%29)%20%3D%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%5Cpi%7D%20%5Csigma%7D%20exp(-%5Cfrac%7B%5Cepsilon_i%5E2%7D%7B2%5Csigma%20%5E%202%7D)%0A" /></p><p>多个残差服从多元正态分布，联合概率密度函数如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Af%28%5Cvarepsilon%29%20%26%3D%5Cprod_%7Bi%3D1%7D%5E%7Bn%7D%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%7D%20%5Csigma%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B%5Cvarepsilon_%7Bi%7D%5E%7B2%7D%7D%7B2%20%5Csigma%5E%7B2%7D%7D%5Cright)%20%5C%5C%0A%26%3D%5Cleft(%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%7D%5Csigma%7D%5Cright)%5E%7Bn%7D%20%5Cexp%20%5Cleft(-%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cfrac%7B%5Cvarepsilon_%7Bi%7D%5E%7B2%7D%7D%7B2%20%5Csigma%5E%7B2%7D%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>因此这个问题就转换成了求使得**联合概率密度函数<code>f(ε)</code>最大 **的一组参数，这组参数就是最大似然法的估计参数。仔细查看 **联合概率密度函数<code>f(ε)</code> **的式子，不难发现该式最大时，即误差平方和最小。</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Cepsilon_%7Bi%7D%5E%7B2%7D%0A" /></p><p>因此当<strong>残差符合正态分布</strong>时，最小二乘法的参数估计值与最大似然法一致，最小二乘法的参数估计值就是最可能的参数估计值。</p>
<h3 id="为什么不用三次方，平方和？">为什么不用三次方，平方和？</h3>
<p>为什么最小二乘法要用最小误差平方和来拟合（为什么不用立方和，或者开方和）?  首先你要保证误差项永远是正数，因此三次方和其他奇数次方不成立。对于四次项及更高的偶数次项，效果还没有最小二乘好，因为会<strong>放大极端值的影响</strong>。开方更不可能了，因为残差可能是负数，无法求开方。</p>
<h2 id="参数估计准确性">参数估计准确性</h2>
<p>我们使用的模型为</p>
<p><img src="5.png" alt="1"></p>
<p>这里的<strong>残差项包含了所有我们模型中没有考虑到的地方</strong>，比如Y 和 X 的关系不是线性的，还有其他的影响因素，存在测量误差等等。</p>
<p>为了估计参数的估计值与真实值之间的误差，我们需要计算两个参数估计值的标准误，使用下列公式（缺证明）</p>
<p><img src="6.png" alt="1"></p>
<p>这里 σ2 是残差方差，是未知的。残差标准差 σ 可以用 RSE (residual standard error) 来估计（缺证明）。</p>
<p><img src="7.png" alt="1"></p>
<p>知道了标准误，我们可以计算<strong>β0、β1的置信区间</strong>，例如 β1 的 95%的置信区间为：</p>
<p><img src="8.png" alt="1"></p>
<p>如果  β1 的 95%的置信区间 <strong>包含 0</strong>，那说明不能拒绝  β1  = 0 的原假设，我们认为不存在线性相关。</p>
<p>我们也可以通过 t 检验得到 P值。构建 t 统计量如下（自由度 n-2）：</p>
<p><img src="9.png" alt="1"></p>
<p>同理可以检验β0 估计值的P值（零假设：β0 = 0），但实际上截距的显著性没啥大的意义，主要还是看 β1。如果  β1 的 P值小于 0.05，我们认为  β1 ≠ 0。</p>
<h2 id="模型准确性">模型准确性</h2>
<p>上面是得到估计的两个参数的准确性，这里我们想知道，我们构建的简单线性模型与数据的契合程度（<em>which the model fits the data</em>）。</p>
<p>线性模型一般用两个指标， <em>residual standard error</em>(RSE) 和 R<sup>2</sup> 。</p>
<h3 id="RSE">RSE</h3>
<p><img src="7.png" alt="1"></p>
<p>RSE 是<strong>残差的标准误的估计值</strong>，它表示<strong>预测值与真实值的平均偏差量</strong>（这句话需要理解标准误的概念：标准误是样本统计量的标准差，均值为真值，结合标准差的公式，可知标准误就是预测值与真实值的平均偏差量（绝对值），所以一般提供参数估计值的时候，都会写成 参数估计值±<strong>标准误</strong>的形式）。</p>
<p>RSE 是最直接说明模型准确性的统计量，它的缺点是有单位，是一个绝对值，仅仅是RSE你不知道到底是大还是小，所以你还得和因变量的均值啥的进行比较才知道相对大小。</p>
<h3 id="R-sup-2-sup">R<sup>2</sup></h3>
<p>R<sup>2</sup> 指的是因变量方差能够被线性模型解释的比例，始终在0和1之间，是一个相对值，越大越好。公式如下：</p>
<p><img src="10.png" alt="1"></p>
<p>其中<abbr title="total sum of squares">TSS</abbr> 计算如下，表示因变量的总的方差。</p>
<p><img src="11.png" alt="1"></p>
<p>R<sup>2</sup> 比 RSE 更容易解释，因此更常用，但是还是面临一个问题，<strong>R<sup>2</sup> 多大才算结果很好呢？<strong>这可能得根据实际情况来定，在我们一般的实验中，实际上往往还有很多</strong>未测量的影响因素</strong>，所以 RSS 可能比较大，这时可能 R<sup>2</sup> 哪怕比较小可能也说明有用。</p>
<h1>多重线性回归</h1>
<p>简单线性回归只有一个自变量，但在实际情况中，我们往往有多个自变量（即生活中其实几乎不存在简单线性回归的应用场景）。例如，如果我们有三个影响因素，我们如何同时分析这三个影响因素呢？</p>
<p>一种思路是我们分别做上次简单的线性回归，但是这种思路无法令人满意。首先，如果给定一组三个自变量的值，我们无法给出因变量的预测值；其次，每一次简单回归都忽视了其他两个影响因素的作用，这可能会带来严重的误判。更好的解决思路是同时将多个自变量均放到线性回归的模型中。</p>
<p>ISL 书中提到了一个例子，销量和三种媒体预算的回归分析。在简单线性回归下，报纸的作用是显著的，如下图。</p>
<p><img src="13.png" alt="1"></p>
<p>但是，同时考虑三种媒体后，报纸的P值是不显著的。这说明简单线性回归和多重线性回归的结果是不一样的。这种差距的出现的原因是，简单回归得到的<strong>斜率</strong>是不考虑其他因素（TV 和 radio）下得到的，而多重回归得到的<strong>斜率</strong>是<strong>保持 TV 和 radio 固定不变</strong>的基础上计算得到的。</p>
<p><img src="14.png" alt="1"></p>
<p>这种情况说明了什么呢，说明这三个自变量之间并不是互相独立的，通过下面的相关矩阵我们可以看到，radio 和 newspaper 的相关系数为0.35，表示当投资人在 radio advertising 花更多的钱的同时，存在一种趋势在 newspaper advertising 上也花更多的钱。因此，我们对 newspaper 进行简单回归时得到的显著性，<strong>实际不是 newspaper 的作用，而是 radio 因素的作用</strong>。</p>
<p>这样的例子实际上比比皆是。ISL 提了一个离谱的例子来说明这一点。如果我们计算<strong>沙滩冰淇淋销量</strong>对<strong>鲨鱼伤人事件的数量</strong>求回归，我们应该能得到一个正向的关系，类似于上面的 newpaper 的例子。但是这实际是很荒谬的，这两个事件不存在因果关系，<strong>你无法通过禁止销售冰淇淋来减少鲨鱼伤人的事件</strong>。实际上是高温天气促使了人们去海边，从而导致更多的冰淇淋销量和鲨鱼伤人事件。<strong>如果你同时考虑冰淇淋销量和天气，对鲨鱼伤人事件做多重回归，你就会发现冰淇淋销量不再是一个显著的影响因素</strong>。</p>
<h2 id="决定重要的影响因素">决定重要的影响因素</h2>
<p>当我们有多个影响因素时，很有可能所有的影响因素都和因变量是有联系的，但是因变量可能仅仅是由其中的一小部分自变量决定的（相关不等于因果，比如上面的冰淇淋销量的例子）。我们把如何挑选自变量的过程称为 <em>variable selection</em>。</p>
<p>理想情况下，我们可以通过<strong>穷举</strong>所有的模型，每种模型均包含一部分的自变量。通过对比所有模型的表现，我们就可以得到最佳的自变量的集合。例如假如我们手上总共有2个可选的自变量X1 X2，那么总共就有4种可能的模型，（1）不包含任何自变量 ；（2）包含X1 ；（3）包含X2；（4）包含X1和X2。但是我们用什么指标来判断不同模型的优劣呢？<strong>这里有很多的判定模型优劣的统计量，比如<abbr title="Akaike information criterion">AIC</abbr>， <abbr title="Bayesian information criterion">BIC</abbr>  , 校正后R<sup>2</sup> 等。</strong></p>
<h3 id="为什么使用校正后的R-sup-2-sup">为什么使用校正后的R<sup>2</sup></h3>
<p>我们看R<sup>2</sup> 的计算公式，可以看到 TSS 是固定值。如果你增加了变量后（比如原来只包含X1，到包含X1和X2），<strong>残差平方和只会减少</strong>（这就是overfitting的原理，哪怕仅仅是增加了无关变量，也会造成与本次数据的拟合程度“变好”）。这导致增加了变量后，R<sup>2</sup>只会进一步增加。</p>
<p><img src="10.png" alt="1"></p>
<p>校正后的R<sup>2</sup>的公式如下，考虑了自变量个数的影响。可以看到，校正后的R<sup>2</sup> 随着自变量个数的增加而降低，并且始终低于未校正的R<sup>2</sup>。</p>
<p><img src="15.png" alt="1"></p>
<p>ISL 还提到了了使用 RSE 来校正自变量个数的影响。</p>
<p><img src="7.png" alt="1"></p>
<h3 id="三种经典的挑选变量的思路">三种经典的挑选变量的思路</h3>
<ul>
<li><em>Forward selection</em>:  先从<em>null model</em> (没有任何变量的模型)出发，对所有的候选因素（假设 <em>p</em> 个）各做一次简单回归，然后挑选结果中 RSS 最低的变量加入到模型中。然后我们将剩下的 <em>p</em>-1 个候选因素，挨个加入到目前的模型中，再挑选结果中 RSS 最低的变量加入到模型中。一直循环下去，知道达到了某个终止条件。</li>
<li><em>Backward selection</em>:  首先将所有的变量均加入到模型中，然后移除其中 P值最大的变量，我们就得到了一个 <em>p</em>-1个变量的模型。循环往复直到达到终止条件（比如所有剩下的变量的P值均低于某个值）。</li>
<li><em>Mixed selection</em>: 结合了上述的两个方法，我们先从空的模型出发，就像第一种方法的示例，不停地往里加变量，直到最佳。在加变量的过程中，我们观察有没有变量的P值变大并且超出了我们设定的阈值，如果存在这种现象，我们就从模型中移除这个变量（backward）。我们一直重复这种添加变量和删除变量的操作，直到最终实现<strong>所有剩下的变量的P值均很低，所有剔除的变量只要加入到模型中就会有一个很大的P值</strong>。</li>
</ul>
<p>如果变量的个数超过了记录数，那么我们无法用 <em>Backward selection</em> (因为将所有变量均加入到模型中，会发生<a href="https://zh.wikipedia.org/wiki/%E7%BB%B4%E6%95%B0%E7%81%BE%E9%9A%BE">维数灾难</a>)，此时 <em>Forward selection</em> 是可用的。但是<strong><em>Forward selection</em> 是一种贪婪算法</strong>，早期加入的变量可能是多余的，而  <em>Mixed selection</em> 算法修正了这一点。</p>
<h2 id="变量之间是否存在互作">变量之间是否存在互作</h2>
<p>还是采用上面三种媒介的例子，我们已经确定了 newpaper 没有作用， TV  和 radio 对 sales 有作用，那是不是模型就是下面的形式呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Y = β0 + β1*TV + β2*radio + e</span><br></pre></td></tr></table></figure>
<p>我们可以通过这个模型画出一个三维图，图中的平面为预测值。我们可以看到当主要的钱都投向一种媒体时，销量会低于预测值；而如果我们均衡投资这两种媒体，销量会高于预测值（虽然我没有很好的看懂这个三维图）。这说明<strong>TV 和 radio 这两个因素之间存在互作。</strong></p>
<p><img src="16.png" alt="1"></p>
<h2 id="预测的不确定性">预测的不确定性</h2>
<p>一旦我们得到了最终的多重线性回归模型，我们就可以基于一套自变量的值来预测反应变量的值。但是，我们所做的预测至少存在三种不确定性。</p>
<ol>
<li>
<p>我们得到的仅仅是 β0, β1, β2……等参数的估计值。这些参数的估计值与真实值存在差距，这种差距是<strong>可消除误差(<em>reducible error</em>)</strong> 的一种。我们统计计算一个 <em><strong>confidence interval</strong></em> 来决定估计参数得到的预测值与真实参数得到的预测值的差距。</p>
</li>
<li>
<p>第二种不确定性是由于线性模型仅仅是对实际数据的一个近似，这种带来的错误我们称之为<em><strong>model bias</strong></em> 。</p>
</li>
<li>
<p>即使我们知道真实的模型 f(x)（我们知道所有参数的真实值），我们也不能完全精确地预测因变量，因为还存在<strong>随机误差(<em>random error</em>)</strong>，这种属于<strong>不可消除误差(<em>irreducible error</em>)</strong>。真实模型的预测值与真实值之间的差距，用<em><strong>prediction intervals</strong></em> 来评价。<em>prediction intervals</em> 通常比 <em>confidence intervals</em> 更宽， 因为 <em>prediction intervals</em> 不仅包括了可消除误差，也包含了不可预测误差（ <em>prediction intervals</em> 包含了 <em>confidence interval</em> ）。下面这段话解释地更明确一点：</p>
<p><img src="27.png" alt="1"></p>
</li>
</ol>
<h1>线性回归潜在的问题</h1>
<h2 id="1-自变量与因变量之间为非线性关系">1 自变量与因变量之间为非线性关系</h2>
<p>线性回归假设因变量与自变量之间存在直接的线性关系。如果因变量与自变量之间不是线性关系，那么线性回归的准确性会显著降低。</p>
<p>我们一般通过<strong>残差图</strong>来确定非线性关系。如果是简单线性回归，横坐标可以是自变量X，纵坐标是残差e；但是如果是多重线性回归，由于存在多个自变量，横坐标改为因变量的预测值。</p>
<p>下边左图为简单线性回归的残差图，可以看到残差不是均匀地分布在均值为0这条线地上下两侧，说明存在非线性关系。右图通过<strong>多项式回归</strong>，残差图的结果变好了很多，虽然看上去还是有一点非随机分布。</p>
<p><img src="17.png" alt="1"></p>
<h2 id="2-残差项的相关">2 残差项的相关</h2>
<p>线性回归的一个重要的假设是残差项，e<sub>1</sub>,e<sub>2</sub>,e<sub>3</sub>…… e<sub>n</sub> 之间是不相关的。这句话的含义是，如果残差项是不相关的，那么某一个残差项的值不受其他残差项的影响。ISL 原文如下：</p>
<blockquote>
<p>For instance, if the errors are uncorrelated, then the fact that ε<sub>i</sub> is positive provides little or no information about the sign of ε<sub>i+1</sub>.</p>
</blockquote>
<p>预测参数或预测值的<strong>标准误</strong>都是基于残差不相关的假设计算得到的。<strong>如果实际上残差项之间存在相关，那么标准误倾向于被低估</strong>（缺解释），因此置信区间也会比正常情况下更窄，因此 p值会更低，容易出现<strong>假阳性</strong>。</p>
<p>下面这段话举了个例子，但是我没理解。这里假如我们不小心把数据重复了一遍（本来是n条数据，现在是2n条数据），参数估计的置信区间会缩减 √2 。</p>
<p><img src="18.png" alt="1"></p>
<p>**什么时候会出现残差项的相关？**这种情况频繁出现在 <em>time series</em> 数据，也有在不同的时间点去观测得到的数据。在很多情况下，相邻时间观测到的记录之间会有正相关的残差项。为了确定这种情况，我们可以画一个横坐标是时间的残差图，如果残差项之间是不相关的，你就不会观测到明显的模式（残差应该是忽上忽下）；相反，如果残差项之间是正相反的，你可以会发现相邻时间的残差会倾向于有相似的值。</p>
<p>下图就体现了这一点，最上面是没有残差相关的图，越往下残差相关越高，我们可以看到很清晰的模式 - 相邻的点之间倾向于有相似的值。</p>
<p><img src="19.png" alt="1"></p>
<p>除了  <em>time series</em> 数据以外，其他数据也可能出现残差相关。举个例子，假设我们有一个研究通过体重去预测一个人的身高。如果有一些研究个体来自于相同的家庭，或吃相同的饮食，又或者面临某些相同的环境因素，那么残差不相关的假设就可能被打破。</p>
<p>一般来说，<strong>残差不相关</strong>的假设对于线性回归和其他统计方法是非常重要的。<strong>良好的实验设计</strong>对于减少残差不相关的风险至关重要。</p>
<h3 id="为什么会出现残差相关？">为什么会出现残差相关？</h3>
<p>因为<strong>残差是个筐，啥都往里装</strong>。我们的模型中所有没有考虑到的影响因素都会包含在这个残差里。实际上我们的模型不可能包含所有的影响因素，我们也不可能收集到所有影响因素的数据，所以我感觉残差相关是不可能完全避免的，或多或少有一点，只要不是很严重。</p>
<p>所以<strong>实验设计</strong>很重要，你要事先把重要的影响因素考虑到，而且把这些数据收集到。如果没有收集到相应的数据，貌似都无法发现残差相关，比如上面的 <em>time series</em> 数据，如果你没有搜集每个数据的时间信息，你都没法画上面的残差图。你不知道就等于没有了。</p>
<h2 id="3-残差方差不齐性">3 残差方差不齐性</h2>
<p>线性回归的另一个重要的假设是所有残差项均有一个固定的方差。我们计算标准误、置信区间等都依赖于这个假设。</p>
<p>但不幸地是，残差项的方差不是固定的，才是通常的情况。比如，残差方差可能会随着因变量值的提高而提高。我们可以通过残差图来发现这一点，比如下图的左图。<strong>当面临这种情况时，一个可能的解决思路是将反应变量Y 转换为 log(Y)  或 √Y</strong> ，这两个函数对于较大的值都会有一个很好的收缩效应，从而导致方差不齐性的改善。下图的右图就展示了转换后的残差图，我们可以看到方差不齐性的结果大大改善了（残差的宽度都差不多了），但是存在轻微的非线性关系。</p>
<p><img src="20.png" alt="1"></p>
<h2 id="4-Outliers">4 Outliers</h2>
<p><strong>Outliers 的定义是这个点的真实值与预测值偏差很大</strong>。Outliers 出现的原因有很多，比如错误记录。</p>
<p>下图中的红点（观测值为20）就是一个典型的Outlier。左边图中的红线是包含了Outlier的回归线，蓝色虚线是剔除了Outlier的回归线，我们可以看到移除或不移除这个Outlier对参数估计的影响很小。</p>
<p>但是Outliers 还会造成另外的问题。比如，在这个例子中，如果包括Outlier 计算得到的 RSE 为 1.09 ，如果剔除Outlier 得到的 RSE 为 0.77 。因为 RSE 在计算置信区间和 p值时均会用到，这样因为一个点导致RSE剧增会影响到回归方差拟合效果的解释。相似地，加入这个 Outlier， R<sup>2</sup> 从 0.892 降低到 0.805。</p>
<p>我们可以通过残差图来找到Outlier。在本例中我们轻松地找到这个Outlier，但是在实际应用中，我们很难决定到底偏离多少才可以视为一个 Outlier。为了解决这个问题，我们可以画图<em><strong>studentized residuals</strong></em> 图，纵坐标时残差除以它的标准误估计值。如果学生残差超过3，我们一般就认为可能是Outlier。在下图的右图中，我们发现这个Outlier的学生残差超过了6，而其他点均在 -2 与 2 之间。</p>
<p>如果你相信Outlier的出现是由于<strong>数据记录或收集时出错</strong>，那么解决办法就是移除这个观测值。但是你需要担心，Outlier的出现也可能是说明你的<strong>模型不完善</strong>，比如缺了一个影响因子。</p>
<p><img src="21.png" alt="1"></p>
<h2 id="5-High-Leverage-Points">5 High Leverage Points</h2>
<p><em><strong>High Leverage Points</strong></em> 仅指<strong>拥有异常的 x<sub>i</sub> 的观测值</strong>。例如，下图中的观测值 41 就是一个 <em>High Leverage Point</em>。 左图中的红线为包含这个点的回归直线，蓝色虚线是剔除了这个点的回归直线。我们可以看到， <em>High Leverage Point</em> 的影响很大，因此找 <em>High Leverage Point</em> 很重要。</p>
<p>对于简单线性回归， <em>High Leverage Point</em> 很容易找到，我们可以直接从 X-Y 图中直接看出。但是多重线性回归存在多个因变量，有可能一个观测值的<strong>所有的自变量单独看都在合理的范围</strong>，但是<strong>这一组自变量的组合是异常的</strong>。下图中间的图就显示了这一点，这是一个有两个自变量(X1, X2)的回归。很多观测值的两个自变量均落在蓝色虚线框定的椭圆中，但是这个红色的点不在这个范围内，虽然这个点的 X1 和 X2 值单独看都不是异常的值。**因此对于多重回归，如果仅仅看单个自变量是否存在 <em>High Leverage Point</em>，我们可能会漏掉一些 <em>High Leverage Point</em>。 ** 但是对于超过2个变量的多重回归模型，如果能够同时查看多个自变量组合的 <em>High Leverage Point</em>  就是一个问题，因为你没法针对2维以上的变量进行画图。</p>
<p><img src="22.png" alt="1"></p>
<p>为了确定一个观测值的 leverage，我们可以计算一个 <em>leverage statistic</em> 。这个值越大说明 leverage 程度越高。对于一个简单线性回归，公式如下（多重回归的公式未给）：</p>
<p><img src="23.png" alt="1"></p>
<p>这个统计量的值在 1/n 与 1 之间，而且所有的观测值的  <em>leverage statistic</em> 的均值是 (p+1)/n 。所以如果一个观测值的  <em>leverage statistic</em> 远超均值，我们就可以怀疑这是一个  <em>High Leverage Point</em></p>
<p>上图 3.13 中的右图是 学生残差 vs h<sub>i</sub>  的散点图。观测值41 的 h<sub>i</sub> 和 学生残差均特别高，说明**这个点即是   <em>High Leverage Point</em>  ，也是一个 outlier ** 。这种情况是非常危险的组合，会对回归结果造成很大的影响，相比之下观测值20 虽然是一个 outlier, 但是 leverage 很低，最起码对回归方程没什么影响。</p>
<h2 id="6-Collinearity">6  Collinearity</h2>
<p><em>Collinearity</em> 表示<strong>两个或更多个自变量之间具有紧密的相关关系</strong>。<em>Collinearity</em> 可以用下图来表示，左图中的两个变量之间表现出来没有明显的关系，而右图的两个变量之间存在<strong>高度</strong>的相关关系（我不知道这个等高图为什么可以这么解释）。</p>
<p><img src="24.png" alt="1"></p>
<p><em>Collinearity</em> 的影响在于无非区分开多个自变量对因变量的影响程度。比如右图中，RSS最低的（β<sub>Limit</sub> , β<sub>Rating</sub>）有很多个，他们在一个狭长的椭圆当中，这导致了参数估计的不确定性。</p>
<p><em>Collinearity</em> 会降低回归参数估计的准确性，导致斜率估计的标准误增加，因此 P 值会增加，会导致 power（正确地拒绝原假设的概率） 降低。下图就是两次回归得到的回归系数和 P值，我们可以看到由于存在 <em>Collinearity</em> ，导致 limit 因素第二次分析时变得不显著。</p>
<p><img src="25.png" alt="1"></p>
<p>因此<strong>我们需要在进行回归分析前进行 <em>Collinearity</em> 的检测</strong>。一个简单的思路是看<strong>自变量之间的相关矩阵</strong>，看是否存在相关系数很高的情况。但是有可能存在一种情况，就是自变量之间不存在两两之间的强相关，但是存在三个及以上的变量之间的相关（例如 X1 = a + bX2 + cX3）。我们把这种情况称为 <em><strong>multicollinearity</strong></em> 。因此我们不采用自变量的相关矩阵，我们引入了一个新的统计量来检测 <em>Collinearity</em>，就是 <abbr title="variance inflation factor">VIF</abbr> 。定义如下：</p>
<blockquote>
<p>The VIF is  the ratio of the variance of ˆβ<sub>j</sub> when fitting the full model divided by the variance of ˆβ<sub>j</sub> if fit on its own.</p>
</blockquote>
<p>VIF 的最小值为1， 说明完全没有<em>Collinearity</em> ，一般来说自变量之间存在一定的 <em>Collinearity</em> , 一般我们认为 VIF 超过 5 或 10 就说明存在严重的 <em>Collinearity</em> 。对于每个变量的 VIF 计算公式为</p>
<p><img src="26.png" alt="1"></p>
<p>在上面的例子中，对 age, rating  和 limit 这三个变量做 VIF 分析，计算结果分别为 1.01， 160.67 和 160.59 。</p>
<p>如果面临 <em>Collinearity</em>  的问题，有两个简单的思路：<strong>一是删除其中一个变量</strong>，这通常不会导致模型拟合程度的降低，因为变量之间的信息是冗余的；<strong>二是合并共显性的变量为一个变量</strong>。</p>
<h1>R代码实现</h1>
<h2 id="简单线性回归">简单线性回归</h2>
<p>回归分析</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简单回归</span></span><br><span class="line">library<span class="punctuation">(</span>MASS<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>ISLR<span class="punctuation">)</span></span><br><span class="line"><span class="comment">## 采用MASS包的Boston数据集</span></span><br><span class="line">lm.fit <span class="operator">=</span> lm<span class="punctuation">(</span>medv<span class="operator">~</span>lstat<span class="punctuation">,</span> data <span class="operator">=</span> Boston<span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>lm.fit<span class="punctuation">)</span> <span class="comment">#各种回归的信息</span></span><br></pre></td></tr></table></figure>
<p>回归分析结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Call:</span><br><span class="line">lm(formula = medv ~ lstat, data = Boston)</span><br><span class="line"></span><br><span class="line">Residuals:</span><br><span class="line">    Min      1Q  Median      3Q     Max </span><br><span class="line">-15.168  -3.990  -1.318   2.034  24.500 </span><br><span class="line"></span><br><span class="line">Coefficients:</span><br><span class="line">            Estimate Std. Error t value Pr(&gt;|t|)    </span><br><span class="line">(Intercept) 34.55384    0.56263   61.41   &lt;2e-16 ***</span><br><span class="line">lstat       -0.95005    0.03873  -24.53   &lt;2e-16 ***</span><br><span class="line">---</span><br><span class="line">Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1</span><br><span class="line"></span><br><span class="line">Residual standard error: 6.216 on 504 degrees of freedom</span><br><span class="line">Multiple R-squared:  0.5441,	Adjusted R-squared:  0.5432 </span><br><span class="line">F-statistic: 601.6 on 1 and 504 DF,  p-value: &lt; 2.2e-16</span><br></pre></td></tr></table></figure>
<p>只看系数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> coef<span class="punctuation">(</span>lm.fit<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">(</span>Intercept<span class="punctuation">)</span>       lstat </span><br><span class="line"> <span class="number">34.5538409</span>  <span class="operator">-</span><span class="number">0.9500494</span> </span><br></pre></td></tr></table></figure>
<p>查看系数的置信区间（confidence interval ）</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> confint<span class="punctuation">(</span>lm.fit<span class="punctuation">)</span></span><br><span class="line">                <span class="number">2.5</span> <span class="operator">%     97.5 %</span></span><br><span class="line"><span class="punctuation">(</span>Intercept<span class="punctuation">)</span> <span class="number">33.448457</span> <span class="number">35.6592247</span></span><br><span class="line">lstat       <span class="operator">-</span><span class="number">1.026148</span> <span class="operator">-</span><span class="number">0.8739505</span></span><br></pre></td></tr></table></figure>
<p>画 x-y 散点图，并添加回归线</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot<span class="punctuation">(</span>Boston<span class="operator">$</span>lstat<span class="punctuation">,</span> Boston<span class="operator">$</span>medv<span class="punctuation">)</span></span><br><span class="line">abline<span class="punctuation">(</span>lm.fit<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>我们可以查看检查线性回归是否正常的图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">par(mfrow=c(2,2))</span><br><span class="line">plot(lm.fit) # 直接画4副图</span><br></pre></td></tr></table></figure>
<p>绘图如下：上方左图就是正常的残差图，可以查看<strong>非线性</strong>，<strong>残差异方差</strong>等，我们可以看到这里存在非线性关系；上方右图就是QQ图，用于<strong>检验残差是否符合正态分布</strong>；下方左图也是一个残差图，不过就是把纵坐标改成了 <em><strong>standardized residuals</strong></em>（缺公式）；下方右图用于判断 <em>Outlier</em> 和  <em>High Leverage Point</em>  ，横坐标是 leverage， 通常大于 4/n (n 是样本点的数目)，就算 <em>High Leverage Point</em> ； 纵轴是residuals，通常小样本大于2，大样本大于4的算作outliers 。</p>
<p><img src="28.png" alt="1"></p>
<h2 id="多重线性回归">多重线性回归</h2>
<p>看一下数据结构</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> str<span class="punctuation">(</span>Boston<span class="punctuation">)</span></span><br><span class="line"><span class="string">&#x27;data.frame&#x27;</span><span class="operator">:</span>	<span class="number">506</span> obs. of  <span class="number">14</span> variables<span class="operator">:</span></span><br><span class="line"> <span class="operator">$</span> crim   <span class="operator">:</span> num  <span class="number">0.00632</span> <span class="number">0.02731</span> <span class="number">0.02729</span> <span class="number">0.03237</span> <span class="number">0.06905</span> ...</span><br><span class="line"> <span class="operator">$</span> zn     <span class="operator">:</span> num  <span class="number">18</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">12.5</span> <span class="number">12.5</span> <span class="number">12.5</span> <span class="number">12.5</span> ...</span><br><span class="line"> <span class="operator">$</span> indus  <span class="operator">:</span> num  <span class="number">2.31</span> <span class="number">7.07</span> <span class="number">7.07</span> <span class="number">2.18</span> <span class="number">2.18</span> <span class="number">2.18</span> <span class="number">7.87</span> <span class="number">7.87</span> <span class="number">7.87</span> <span class="number">7.87</span> ...</span><br><span class="line"> <span class="operator">$</span> chas   <span class="operator">:</span> int  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> ...</span><br><span class="line"> <span class="operator">$</span> nox    <span class="operator">:</span> num  <span class="number">0.538</span> <span class="number">0.469</span> <span class="number">0.469</span> <span class="number">0.458</span> <span class="number">0.458</span> <span class="number">0.458</span> <span class="number">0.524</span> <span class="number">0.524</span> <span class="number">0.524</span> <span class="number">0.524</span> ...</span><br><span class="line"> <span class="operator">$</span> rm     <span class="operator">:</span> num  <span class="number">6.58</span> <span class="number">6.42</span> <span class="number">7.18</span> <span class="number">7</span> <span class="number">7.15</span> ...</span><br><span class="line"> <span class="operator">$</span> age    <span class="operator">:</span> num  <span class="number">65.2</span> <span class="number">78.9</span> <span class="number">61.1</span> <span class="number">45.8</span> <span class="number">54.2</span> <span class="number">58.7</span> <span class="number">66.6</span> <span class="number">96.1</span> <span class="number">100</span> <span class="number">85.9</span> ...</span><br><span class="line"> <span class="operator">$</span> dis    <span class="operator">:</span> num  <span class="number">4.09</span> <span class="number">4.97</span> <span class="number">4.97</span> <span class="number">6.06</span> <span class="number">6.06</span> ...</span><br><span class="line"> <span class="operator">$</span> rad    <span class="operator">:</span> int  <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> ...</span><br><span class="line"> <span class="operator">$</span> tax    <span class="operator">:</span> num  <span class="number">296</span> <span class="number">242</span> <span class="number">242</span> <span class="number">222</span> <span class="number">222</span> <span class="number">222</span> <span class="number">311</span> <span class="number">311</span> <span class="number">311</span> <span class="number">311</span> ...</span><br><span class="line"> <span class="operator">$</span> ptratio<span class="operator">:</span> num  <span class="number">15.3</span> <span class="number">17.8</span> <span class="number">17.8</span> <span class="number">18.7</span> <span class="number">18.7</span> <span class="number">18.7</span> <span class="number">15.2</span> <span class="number">15.2</span> <span class="number">15.2</span> <span class="number">15.2</span> ...</span><br><span class="line"> <span class="operator">$</span> black  <span class="operator">:</span> num  <span class="number">397</span> <span class="number">397</span> <span class="number">393</span> <span class="number">395</span> <span class="number">397</span> ...</span><br><span class="line"> <span class="operator">$</span> lstat  <span class="operator">:</span> num  <span class="number">4.98</span> <span class="number">9.14</span> <span class="number">4.03</span> <span class="number">2.94</span> <span class="number">5.33</span> ...</span><br><span class="line"> <span class="operator">$</span> medv   <span class="operator">:</span> num  <span class="number">24</span> <span class="number">21.6</span> <span class="number">34.7</span> <span class="number">33.4</span> <span class="number">36.2</span> <span class="number">28.7</span> <span class="number">22.9</span> <span class="number">27.1</span> <span class="number">16.5</span> <span class="number">18.9</span> ...</span><br></pre></td></tr></table></figure>
<p>两个回归因素，lstat 和 age</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> lm.fit<span class="operator">=</span>lm<span class="punctuation">(</span>medv<span class="operator">~</span>lstat<span class="operator">+</span>age<span class="punctuation">,</span>data<span class="operator">=</span>Boston<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> summary<span class="punctuation">(</span>lm.fit<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Call<span class="operator">:</span></span><br><span class="line">lm<span class="punctuation">(</span>formula <span class="operator">=</span> medv <span class="operator">~</span> lstat <span class="operator">+</span> age<span class="punctuation">,</span> data <span class="operator">=</span> Boston<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Residuals<span class="operator">:</span></span><br><span class="line">    Min      <span class="number">1</span>Q  Median      <span class="number">3</span>Q     Max </span><br><span class="line"><span class="operator">-</span><span class="number">15.981</span>  <span class="operator">-</span><span class="number">3.978</span>  <span class="operator">-</span><span class="number">1.283</span>   <span class="number">1.968</span>  <span class="number">23.158</span> </span><br><span class="line"></span><br><span class="line">Coefficients<span class="operator">:</span></span><br><span class="line">            Estimate Std. Error t value Pr<span class="punctuation">(</span><span class="operator">&gt;</span><span class="operator">|</span>t<span class="operator">|</span><span class="punctuation">)</span>    </span><br><span class="line"><span class="punctuation">(</span>Intercept<span class="punctuation">)</span> <span class="number">33.22276</span>    <span class="number">0.73085</span>  <span class="number">45.458</span>  <span class="operator">&lt;</span> <span class="number">2e-16</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">lstat       <span class="operator">-</span><span class="number">1.03207</span>    <span class="number">0.04819</span> <span class="operator">-</span><span class="number">21.416</span>  <span class="operator">&lt;</span> <span class="number">2e-16</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">age          <span class="number">0.03454</span>    <span class="number">0.01223</span>   <span class="number">2.826</span>  <span class="number">0.00491</span> <span class="operator">*</span><span class="operator">*</span> </span><br><span class="line"><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span></span><br><span class="line">Signif. codes<span class="operator">:</span>  <span class="number">0</span> ‘<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.001</span> ‘<span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.01</span> ‘<span class="operator">*</span>’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error<span class="operator">:</span> <span class="number">6.173</span> on <span class="number">503</span> degrees of freedom</span><br><span class="line">Multiple R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.5513</span><span class="punctuation">,</span>	Adjusted R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.5495</span> </span><br><span class="line"><span class="built_in">F</span><span class="operator">-</span>statistic<span class="operator">:</span>   <span class="number">309</span> on <span class="number">2</span> and <span class="number">503</span> DF<span class="punctuation">,</span>  p<span class="operator">-</span>value<span class="operator">:</span> <span class="operator">&lt;</span> <span class="number">2.2e-16</span></span><br></pre></td></tr></table></figure>
<p>Boston 数据集总共有 13 个自变量，我们可以通过这种简写方式，直接使用所有的自变量（前提是除了因变量以外，其他全是自变量）。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> lm.fit<span class="operator">=</span>lm<span class="punctuation">(</span>medv<span class="operator">~</span>.<span class="punctuation">,</span>data<span class="operator">=</span>Boston<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> summary<span class="punctuation">(</span>lm.fit<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Call<span class="operator">:</span></span><br><span class="line">lm<span class="punctuation">(</span>formula <span class="operator">=</span> medv <span class="operator">~</span> .<span class="punctuation">,</span> data <span class="operator">=</span> Boston<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Residuals<span class="operator">:</span></span><br><span class="line">    Min      <span class="number">1</span>Q  Median      <span class="number">3</span>Q     Max </span><br><span class="line"><span class="operator">-</span><span class="number">15.595</span>  <span class="operator">-</span><span class="number">2.730</span>  <span class="operator">-</span><span class="number">0.518</span>   <span class="number">1.777</span>  <span class="number">26.199</span> </span><br><span class="line"></span><br><span class="line">Coefficients<span class="operator">:</span></span><br><span class="line">              Estimate Std. Error t value Pr<span class="punctuation">(</span><span class="operator">&gt;</span><span class="operator">|</span>t<span class="operator">|</span><span class="punctuation">)</span>    </span><br><span class="line"><span class="punctuation">(</span>Intercept<span class="punctuation">)</span>  <span class="number">3.646e+01</span>  <span class="number">5.103e+00</span>   <span class="number">7.144</span> <span class="number">3.28e-12</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">crim        <span class="operator">-</span><span class="number">1.080e-01</span>  <span class="number">3.286e-02</span>  <span class="operator">-</span><span class="number">3.287</span> <span class="number">0.001087</span> <span class="operator">*</span><span class="operator">*</span> </span><br><span class="line">zn           <span class="number">4.642e-02</span>  <span class="number">1.373e-02</span>   <span class="number">3.382</span> <span class="number">0.000778</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">indus        <span class="number">2.056e-02</span>  <span class="number">6.150e-02</span>   <span class="number">0.334</span> <span class="number">0.738288</span>    </span><br><span class="line">chas         <span class="number">2.687e+00</span>  <span class="number">8.616e-01</span>   <span class="number">3.118</span> <span class="number">0.001925</span> <span class="operator">*</span><span class="operator">*</span> </span><br><span class="line">nox         <span class="operator">-</span><span class="number">1.777e+01</span>  <span class="number">3.820e+00</span>  <span class="operator">-</span><span class="number">4.651</span> <span class="number">4.25e-06</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">rm           <span class="number">3.810e+00</span>  <span class="number">4.179e-01</span>   <span class="number">9.116</span>  <span class="operator">&lt;</span> <span class="number">2e-16</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">age          <span class="number">6.922e-04</span>  <span class="number">1.321e-02</span>   <span class="number">0.052</span> <span class="number">0.958229</span>    </span><br><span class="line">dis         <span class="operator">-</span><span class="number">1.476e+00</span>  <span class="number">1.995e-01</span>  <span class="operator">-</span><span class="number">7.398</span> <span class="number">6.01e-13</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">rad          <span class="number">3.060e-01</span>  <span class="number">6.635e-02</span>   <span class="number">4.613</span> <span class="number">5.07e-06</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">tax         <span class="operator">-</span><span class="number">1.233e-02</span>  <span class="number">3.760e-03</span>  <span class="operator">-</span><span class="number">3.280</span> <span class="number">0.001112</span> <span class="operator">*</span><span class="operator">*</span> </span><br><span class="line">ptratio     <span class="operator">-</span><span class="number">9.527e-01</span>  <span class="number">1.308e-01</span>  <span class="operator">-</span><span class="number">7.283</span> <span class="number">1.31e-12</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">black        <span class="number">9.312e-03</span>  <span class="number">2.686e-03</span>   <span class="number">3.467</span> <span class="number">0.000573</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">lstat       <span class="operator">-</span><span class="number">5.248e-01</span>  <span class="number">5.072e-02</span> <span class="operator">-</span><span class="number">10.347</span>  <span class="operator">&lt;</span> <span class="number">2e-16</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span></span><br><span class="line">Signif. codes<span class="operator">:</span>  <span class="number">0</span> ‘<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.001</span> ‘<span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.01</span> ‘<span class="operator">*</span>’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error<span class="operator">:</span> <span class="number">4.745</span> on <span class="number">492</span> degrees of freedom</span><br><span class="line">Multiple R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.7406</span><span class="punctuation">,</span>	Adjusted R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.7338</span> </span><br><span class="line"><span class="built_in">F</span><span class="operator">-</span>statistic<span class="operator">:</span> <span class="number">108.1</span> on <span class="number">13</span> and <span class="number">492</span> DF<span class="punctuation">,</span>  p<span class="operator">-</span>value<span class="operator">:</span> <span class="operator">&lt;</span> <span class="number">2.2e-16</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以通过car包的 vif() 函数计算 各个因子的VIF，这里可以看到 rad 和 tax 这两个因素的 VIF 比较高。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> library<span class="punctuation">(</span>car<span class="punctuation">)</span></span><br><span class="line">载入需要的程辑包：carData</span><br><span class="line">Registered S3 methods overwritten by <span class="string">&#x27;tibble&#x27;</span><span class="operator">:</span></span><br><span class="line">  method     from  </span><br><span class="line">  format.tbl pillar</span><br><span class="line">  print.tbl  pillar</span><br><span class="line">Warning messages<span class="operator">:</span></span><br><span class="line"><span class="number">1</span><span class="operator">:</span> 程辑包‘car’是用R版本<span class="number">4.0</span>.3 来建造的 </span><br><span class="line"><span class="number">2</span><span class="operator">:</span> 程辑包‘carData’是用R版本<span class="number">4.0</span>.3 来建造的 </span><br><span class="line"><span class="operator">&gt;</span> vif<span class="punctuation">(</span>lm.fit<span class="punctuation">)</span></span><br><span class="line">    crim       zn    indus     chas      nox       rm      age      dis      rad      tax </span><br><span class="line"><span class="number">1.792192</span> <span class="number">2.298758</span> <span class="number">3.991596</span> <span class="number">1.073995</span> <span class="number">4.393720</span> <span class="number">1.933744</span> <span class="number">3.100826</span> <span class="number">3.955945</span> <span class="number">7.484496</span> <span class="number">9.008554</span> </span><br><span class="line"> ptratio    black    lstat </span><br><span class="line"><span class="number">1.799084</span> <span class="number">1.348521</span> <span class="number">2.941491</span> </span><br></pre></td></tr></table></figure>
<p>使用除了某一个因子外的其他所有因子的回归（采用 - 号），例如剔除 age 因子。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span>lm.fit1 <span class="operator">=</span> lm<span class="punctuation">(</span>medv∼.<span class="operator">-</span>age<span class="punctuation">,</span>data<span class="operator">=</span>Boston<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span>summary<span class="punctuation">(</span>lm.fit1<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h2 id="互作项">互作项</h2>
<p>回归模型中 ， <code>lstat:black</code> 表示新增一个 <code>lstat</code> 和 <code>black</code> 的互作项。<code>lstat*age</code> 表示同时<code>lstat</code>, <code>age</code> 和他们之间的互作项，是 <code>lstat+age+lstat:age</code> 的简写。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> summary<span class="punctuation">(</span>lm<span class="punctuation">(</span>medv<span class="operator">~</span>lstat<span class="operator">*</span>age<span class="punctuation">,</span>data<span class="operator">=</span>Boston<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Call<span class="operator">:</span></span><br><span class="line">lm<span class="punctuation">(</span>formula <span class="operator">=</span> medv <span class="operator">~</span> lstat <span class="operator">*</span> age<span class="punctuation">,</span> data <span class="operator">=</span> Boston<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Residuals<span class="operator">:</span></span><br><span class="line">    Min      <span class="number">1</span>Q  Median      <span class="number">3</span>Q     Max </span><br><span class="line"><span class="operator">-</span><span class="number">15.806</span>  <span class="operator">-</span><span class="number">4.045</span>  <span class="operator">-</span><span class="number">1.333</span>   <span class="number">2.085</span>  <span class="number">27.552</span> </span><br><span class="line"></span><br><span class="line">Coefficients<span class="operator">:</span></span><br><span class="line">              Estimate Std. Error t value Pr<span class="punctuation">(</span><span class="operator">&gt;</span><span class="operator">|</span>t<span class="operator">|</span><span class="punctuation">)</span>    </span><br><span class="line"><span class="punctuation">(</span>Intercept<span class="punctuation">)</span> <span class="number">36.0885359</span>  <span class="number">1.4698355</span>  <span class="number">24.553</span>  <span class="operator">&lt;</span> <span class="number">2e-16</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">lstat       <span class="operator">-</span><span class="number">1.3921168</span>  <span class="number">0.1674555</span>  <span class="operator">-</span><span class="number">8.313</span> <span class="number">8.78e-16</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">age         <span class="operator">-</span><span class="number">0.0007209</span>  <span class="number">0.0198792</span>  <span class="operator">-</span><span class="number">0.036</span>   <span class="number">0.9711</span>    </span><br><span class="line">lstat<span class="operator">:</span>age    <span class="number">0.0041560</span>  <span class="number">0.0018518</span>   <span class="number">2.244</span>   <span class="number">0.0252</span> <span class="operator">*</span>  </span><br><span class="line"><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span></span><br><span class="line">Signif. codes<span class="operator">:</span>  <span class="number">0</span> ‘<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.001</span> ‘<span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.01</span> ‘<span class="operator">*</span>’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error<span class="operator">:</span> <span class="number">6.149</span> on <span class="number">502</span> degrees of freedom</span><br><span class="line">Multiple R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.5557</span><span class="punctuation">,</span>	Adjusted R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.5531</span> </span><br><span class="line"><span class="built_in">F</span><span class="operator">-</span>statistic<span class="operator">:</span> <span class="number">209.3</span> on <span class="number">3</span> and <span class="number">502</span> DF<span class="punctuation">,</span>  p<span class="operator">-</span>value<span class="operator">:</span> <span class="operator">&lt;</span> <span class="number">2.2e-16</span></span><br></pre></td></tr></table></figure>
<h2 id="自变量的非线性转换">自变量的非线性转换</h2>
<p>我们可以创建一个新的自变量 X<sup>2</sup>，采用 <code>I(X^2)</code> 函数。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> lm.fit2 <span class="operator">=</span> lm<span class="punctuation">(</span>medv<span class="operator">~</span>lstat<span class="operator">+</span>I<span class="punctuation">(</span>lstat<span class="operator">^</span><span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> data <span class="operator">=</span> Boston<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> summary<span class="punctuation">(</span>lm.fit2<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Call<span class="operator">:</span></span><br><span class="line">lm<span class="punctuation">(</span>formula <span class="operator">=</span> medv <span class="operator">~</span> lstat <span class="operator">+</span> I<span class="punctuation">(</span>lstat<span class="operator">^</span><span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> data <span class="operator">=</span> Boston<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Residuals<span class="operator">:</span></span><br><span class="line">     Min       <span class="number">1</span>Q   Median       <span class="number">3</span>Q      Max </span><br><span class="line"><span class="operator">-</span><span class="number">15.2834</span>  <span class="operator">-</span><span class="number">3.8313</span>  <span class="operator">-</span><span class="number">0.5295</span>   <span class="number">2.3095</span>  <span class="number">25.4148</span> </span><br><span class="line"></span><br><span class="line">Coefficients<span class="operator">:</span></span><br><span class="line">             Estimate Std. Error t value Pr<span class="punctuation">(</span><span class="operator">&gt;</span><span class="operator">|</span>t<span class="operator">|</span><span class="punctuation">)</span>    </span><br><span class="line"><span class="punctuation">(</span>Intercept<span class="punctuation">)</span> <span class="number">42.862007</span>   <span class="number">0.872084</span>   <span class="number">49.15</span>   <span class="operator">&lt;</span><span class="number">2e-16</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">lstat       <span class="operator">-</span><span class="number">2.332821</span>   <span class="number">0.123803</span>  <span class="operator">-</span><span class="number">18.84</span>   <span class="operator">&lt;</span><span class="number">2e-16</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">I<span class="punctuation">(</span>lstat<span class="operator">^</span><span class="number">2</span><span class="punctuation">)</span>   <span class="number">0.043547</span>   <span class="number">0.003745</span>   <span class="number">11.63</span>   <span class="operator">&lt;</span><span class="number">2e-16</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span></span><br><span class="line">Signif. codes<span class="operator">:</span>  <span class="number">0</span> ‘<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.001</span> ‘<span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.01</span> ‘<span class="operator">*</span>’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error<span class="operator">:</span> <span class="number">5.524</span> on <span class="number">503</span> degrees of freedom</span><br><span class="line">Multiple R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.6407</span><span class="punctuation">,</span>	Adjusted R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.6393</span> </span><br><span class="line"><span class="built_in">F</span><span class="operator">-</span>statistic<span class="operator">:</span> <span class="number">448.5</span> on <span class="number">2</span> and <span class="number">503</span> DF<span class="punctuation">,</span>  p<span class="operator">-</span>value<span class="operator">:</span> <span class="operator">&lt;</span> <span class="number">2.2e-16</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看到二次项的P值也是显著的，说明模型拟合结果有所改善。我们可以使用 <code>anova()</code> 函数来比对两个模型。</p>
<p>这里 Model 1 表示原来的线性模型，Model 2 表示二次项回归模型。这个  <code>anova()</code> 函数执行了一个比对两个模型的假设检验，零假设是两个模型拟合程度一致，备择假设是更全的模型更好。这里F统计量是135， 相应的 P值也很低，说明二次项模型拟合程度更好。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> lm.fit <span class="operator">=</span> lm<span class="punctuation">(</span>medv<span class="operator">~</span>lstat<span class="punctuation">,</span> data<span class="operator">=</span>Boston<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> anova<span class="punctuation">(</span>lm.fit<span class="punctuation">,</span> lm.fit2<span class="punctuation">)</span></span><br><span class="line">Analysis of Variance Table</span><br><span class="line"></span><br><span class="line">Model <span class="number">1</span><span class="operator">:</span> medv <span class="operator">~</span> lstat</span><br><span class="line">Model <span class="number">2</span><span class="operator">:</span> medv <span class="operator">~</span> lstat <span class="operator">+</span> I<span class="punctuation">(</span>lstat<span class="operator">^</span><span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">  Res.Df   RSS Df Sum of Sq     <span class="built_in">F</span>    Pr<span class="punctuation">(</span><span class="operator">&gt;</span><span class="built_in">F</span><span class="punctuation">)</span>    </span><br><span class="line"><span class="number">1</span>    <span class="number">504</span> <span class="number">19472</span>                                 </span><br><span class="line"><span class="number">2</span>    <span class="number">503</span> <span class="number">15347</span>  <span class="number">1</span>    <span class="number">4125.1</span> <span class="number">135.2</span> <span class="operator">&lt;</span> <span class="number">2.2e-16</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span></span><br><span class="line">Signif. codes<span class="operator">:</span>  <span class="number">0</span> ‘<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.001</span> ‘<span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.01</span> ‘<span class="operator">*</span>’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如果要建立<strong>三次型</strong>方程，我们可以新增一个变量 <code>I(X^3)</code> 。但是，这种写法比较啰嗦。一个更好的写法是使用<code>poly()</code> 函数来创建一个多项式。比如下面就会创建一个自由度为5的二次型拟合</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> lm.fit5 <span class="operator">=</span> lm<span class="punctuation">(</span>medv<span class="operator">~</span>poly<span class="punctuation">(</span>lstat<span class="punctuation">,</span><span class="number">5</span><span class="punctuation">)</span><span class="punctuation">,</span>data<span class="operator">=</span>Boston<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> summary<span class="punctuation">(</span>lm.fit5<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Call<span class="operator">:</span></span><br><span class="line">lm<span class="punctuation">(</span>formula <span class="operator">=</span> medv <span class="operator">~</span> poly<span class="punctuation">(</span>lstat<span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span><span class="punctuation">,</span> data <span class="operator">=</span> Boston<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Residuals<span class="operator">:</span></span><br><span class="line">     Min       <span class="number">1</span>Q   Median       <span class="number">3</span>Q      Max </span><br><span class="line"><span class="operator">-</span><span class="number">13.5433</span>  <span class="operator">-</span><span class="number">3.1039</span>  <span class="operator">-</span><span class="number">0.7052</span>   <span class="number">2.0844</span>  <span class="number">27.1153</span> </span><br><span class="line"></span><br><span class="line">Coefficients<span class="operator">:</span></span><br><span class="line">                 Estimate Std. Error t value Pr<span class="punctuation">(</span><span class="operator">&gt;</span><span class="operator">|</span>t<span class="operator">|</span><span class="punctuation">)</span>    </span><br><span class="line"><span class="punctuation">(</span>Intercept<span class="punctuation">)</span>       <span class="number">22.5328</span>     <span class="number">0.2318</span>  <span class="number">97.197</span>  <span class="operator">&lt;</span> <span class="number">2e-16</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">poly<span class="punctuation">(</span>lstat<span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span><span class="number">1</span> <span class="operator">-</span><span class="number">152.4595</span>     <span class="number">5.2148</span> <span class="operator">-</span><span class="number">29.236</span>  <span class="operator">&lt;</span> <span class="number">2e-16</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">poly<span class="punctuation">(</span>lstat<span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span><span class="number">2</span>   <span class="number">64.2272</span>     <span class="number">5.2148</span>  <span class="number">12.316</span>  <span class="operator">&lt;</span> <span class="number">2e-16</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">poly<span class="punctuation">(</span>lstat<span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span><span class="number">3</span>  <span class="operator">-</span><span class="number">27.0511</span>     <span class="number">5.2148</span>  <span class="operator">-</span><span class="number">5.187</span> <span class="number">3.10e-07</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">poly<span class="punctuation">(</span>lstat<span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span><span class="number">4</span>   <span class="number">25.4517</span>     <span class="number">5.2148</span>   <span class="number">4.881</span> <span class="number">1.42e-06</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">poly<span class="punctuation">(</span>lstat<span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span><span class="number">5</span>  <span class="operator">-</span><span class="number">19.2524</span>     <span class="number">5.2148</span>  <span class="operator">-</span><span class="number">3.692</span> <span class="number">0.000247</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span></span><br><span class="line">Signif. codes<span class="operator">:</span>  <span class="number">0</span> ‘<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.001</span> ‘<span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.01</span> ‘<span class="operator">*</span>’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error<span class="operator">:</span> <span class="number">5.215</span> on <span class="number">500</span> degrees of freedom</span><br><span class="line">Multiple R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.6817</span><span class="punctuation">,</span>	Adjusted R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.6785</span> </span><br><span class="line"><span class="built_in">F</span><span class="operator">-</span>statistic<span class="operator">:</span> <span class="number">214.2</span> on <span class="number">5</span> and <span class="number">500</span> DF<span class="punctuation">,</span>  p<span class="operator">-</span>value<span class="operator">:</span> <span class="operator">&lt;</span> <span class="number">2.2e-16</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里说明如果增加二次项，加到5， 可以增加模型的拟合程度。但是，进一步研究会发现，如果增加超过项数超过5的项，这些超过5的项的p值均不显著。</p>
<p>当然，除了使用二次项以外，我们还可以使用其他转换函数，比如<strong>log函数</strong>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">summary<span class="punctuation">(</span>lm<span class="punctuation">(</span>medv<span class="operator">~</span><span class="built_in">log</span><span class="punctuation">(</span>rm<span class="punctuation">)</span><span class="punctuation">,</span> data<span class="operator">=</span>Boston<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h2 id="分类因子">分类因子</h2>
<p>这里我们用 <code>ISLR</code> 包的 <code>Carseats</code> 数据集。我们想要预测的变量是 <em>Sales</em></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> library<span class="punctuation">(</span>ISLR<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> fix<span class="punctuation">(</span>Carseats<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> str<span class="punctuation">(</span>Carseats<span class="punctuation">)</span></span><br><span class="line"><span class="string">&#x27;data.frame&#x27;</span><span class="operator">:</span>	<span class="number">400</span> obs. of  <span class="number">11</span> variables<span class="operator">:</span></span><br><span class="line"> <span class="operator">$</span> Sales      <span class="operator">:</span> num  <span class="number">9.5</span> <span class="number">11.22</span> <span class="number">10.06</span> <span class="number">7.4</span> <span class="number">4.15</span> ...</span><br><span class="line"> <span class="operator">$</span> CompPrice  <span class="operator">:</span> num  <span class="number">138</span> <span class="number">111</span> <span class="number">113</span> <span class="number">117</span> <span class="number">141</span> <span class="number">124</span> <span class="number">115</span> <span class="number">136</span> <span class="number">132</span> <span class="number">132</span> ...</span><br><span class="line"> <span class="operator">$</span> Income     <span class="operator">:</span> num  <span class="number">73</span> <span class="number">48</span> <span class="number">35</span> <span class="number">100</span> <span class="number">64</span> <span class="number">113</span> <span class="number">105</span> <span class="number">81</span> <span class="number">110</span> <span class="number">113</span> ...</span><br><span class="line"> <span class="operator">$</span> Advertising<span class="operator">:</span> num  <span class="number">11</span> <span class="number">16</span> <span class="number">10</span> <span class="number">4</span> <span class="number">3</span> <span class="number">13</span> <span class="number">0</span> <span class="number">15</span> <span class="number">0</span> <span class="number">0</span> ...</span><br><span class="line"> <span class="operator">$</span> Population <span class="operator">:</span> num  <span class="number">276</span> <span class="number">260</span> <span class="number">269</span> <span class="number">466</span> <span class="number">340</span> <span class="number">501</span> <span class="number">45</span> <span class="number">425</span> <span class="number">108</span> <span class="number">131</span> ...</span><br><span class="line"> <span class="operator">$</span> Price      <span class="operator">:</span> num  <span class="number">120</span> <span class="number">83</span> <span class="number">80</span> <span class="number">97</span> <span class="number">128</span> <span class="number">72</span> <span class="number">108</span> <span class="number">120</span> <span class="number">124</span> <span class="number">124</span> ...</span><br><span class="line"> <span class="operator">$</span> ShelveLoc  <span class="operator">:</span> Factor w<span class="operator">/</span> <span class="number">3</span> levels <span class="string">&quot;Bad&quot;</span><span class="punctuation">,</span><span class="string">&quot;Good&quot;</span><span class="punctuation">,</span><span class="string">&quot;Medium&quot;</span><span class="operator">:</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> ...</span><br><span class="line"> <span class="operator">$</span> Age        <span class="operator">:</span> num  <span class="number">42</span> <span class="number">65</span> <span class="number">59</span> <span class="number">55</span> <span class="number">38</span> <span class="number">78</span> <span class="number">71</span> <span class="number">67</span> <span class="number">76</span> <span class="number">76</span> ...</span><br><span class="line"> <span class="operator">$</span> Education  <span class="operator">:</span> num  <span class="number">17</span> <span class="number">10</span> <span class="number">12</span> <span class="number">14</span> <span class="number">13</span> <span class="number">16</span> <span class="number">15</span> <span class="number">10</span> <span class="number">10</span> <span class="number">17</span> ...</span><br><span class="line"> <span class="operator">$</span> Urban      <span class="operator">:</span> Factor w<span class="operator">/</span> <span class="number">2</span> levels <span class="string">&quot;No&quot;</span><span class="punctuation">,</span><span class="string">&quot;Yes&quot;</span><span class="operator">:</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> ...</span><br><span class="line"> <span class="operator">$</span> US         <span class="operator">:</span> Factor w<span class="operator">/</span> <span class="number">2</span> levels <span class="string">&quot;No&quot;</span><span class="punctuation">,</span><span class="string">&quot;Yes&quot;</span><span class="operator">:</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> ...</span><br></pre></td></tr></table></figure>
<p>这里包含了类似于 <code>ShelveLoc</code> 的分类变量。如果使用分类变量，R会<strong>自动转变为哑变量</strong>。下面我们进行包含了一些互作项的多重回归模型。</p>
<p>这里  <code>ShelveLoc</code>  生成了两个哑变量 ShelveLocGood 和 ShelveLocMedium ，Bad 水平视为基础水平。我们可以看到 Good 和 Medium 水平的斜率都是正数，且均显著，说明 Good 和 Medium 水平的因变量的均值均比 Bad 水平要高。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> lm.fit<span class="operator">=</span>lm<span class="punctuation">(</span>Sales<span class="operator">~</span>.<span class="operator">+</span>Income<span class="operator">:</span>Advertising <span class="operator">+</span>Price<span class="operator">:</span>Age<span class="punctuation">,</span>data<span class="operator">=</span>Carseats<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> summary<span class="punctuation">(</span>lm.fit<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Call<span class="operator">:</span></span><br><span class="line">lm<span class="punctuation">(</span>formula <span class="operator">=</span> Sales <span class="operator">~</span> . <span class="operator">+</span> Income<span class="operator">:</span>Advertising <span class="operator">+</span> Price<span class="operator">:</span>Age<span class="punctuation">,</span> data <span class="operator">=</span> Carseats<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Residuals<span class="operator">:</span></span><br><span class="line">    Min      <span class="number">1</span>Q  Median      <span class="number">3</span>Q     Max </span><br><span class="line"><span class="operator">-</span><span class="number">2.9208</span> <span class="operator">-</span><span class="number">0.7503</span>  <span class="number">0.0177</span>  <span class="number">0.6754</span>  <span class="number">3.3413</span> </span><br><span class="line"></span><br><span class="line">Coefficients<span class="operator">:</span></span><br><span class="line">                     Estimate Std. Error t value Pr<span class="punctuation">(</span><span class="operator">&gt;</span><span class="operator">|</span>t<span class="operator">|</span><span class="punctuation">)</span>    </span><br><span class="line"><span class="punctuation">(</span>Intercept<span class="punctuation">)</span>         <span class="number">6.5755654</span>  <span class="number">1.0087470</span>   <span class="number">6.519</span> <span class="number">2.22e-10</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">CompPrice           <span class="number">0.0929371</span>  <span class="number">0.0041183</span>  <span class="number">22.567</span>  <span class="operator">&lt;</span> <span class="number">2e-16</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">Income              <span class="number">0.0108940</span>  <span class="number">0.0026044</span>   <span class="number">4.183</span> <span class="number">3.57e-05</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">Advertising         <span class="number">0.0702462</span>  <span class="number">0.0226091</span>   <span class="number">3.107</span> <span class="number">0.002030</span> <span class="operator">*</span><span class="operator">*</span> </span><br><span class="line">Population          <span class="number">0.0001592</span>  <span class="number">0.0003679</span>   <span class="number">0.433</span> <span class="number">0.665330</span>    </span><br><span class="line">Price              <span class="operator">-</span><span class="number">0.1008064</span>  <span class="number">0.0074399</span> <span class="operator">-</span><span class="number">13.549</span>  <span class="operator">&lt;</span> <span class="number">2e-16</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">ShelveLocGood       <span class="number">4.8486762</span>  <span class="number">0.1528378</span>  <span class="number">31.724</span>  <span class="operator">&lt;</span> <span class="number">2e-16</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">ShelveLocMedium     <span class="number">1.9532620</span>  <span class="number">0.1257682</span>  <span class="number">15.531</span>  <span class="operator">&lt;</span> <span class="number">2e-16</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">Age                <span class="operator">-</span><span class="number">0.0579466</span>  <span class="number">0.0159506</span>  <span class="operator">-</span><span class="number">3.633</span> <span class="number">0.000318</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">Education          <span class="operator">-</span><span class="number">0.0208525</span>  <span class="number">0.0196131</span>  <span class="operator">-</span><span class="number">1.063</span> <span class="number">0.288361</span>    </span><br><span class="line">UrbanYes            <span class="number">0.1401597</span>  <span class="number">0.1124019</span>   <span class="number">1.247</span> <span class="number">0.213171</span>    </span><br><span class="line">USYes              <span class="operator">-</span><span class="number">0.1575571</span>  <span class="number">0.1489234</span>  <span class="operator">-</span><span class="number">1.058</span> <span class="number">0.290729</span>    </span><br><span class="line">Income<span class="operator">:</span>Advertising  <span class="number">0.0007510</span>  <span class="number">0.0002784</span>   <span class="number">2.698</span> <span class="number">0.007290</span> <span class="operator">*</span><span class="operator">*</span> </span><br><span class="line">Price<span class="operator">:</span>Age           <span class="number">0.0001068</span>  <span class="number">0.0001333</span>   <span class="number">0.801</span> <span class="number">0.423812</span>    </span><br><span class="line"><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span></span><br><span class="line">Signif. codes<span class="operator">:</span>  <span class="number">0</span> ‘<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.001</span> ‘<span class="operator">*</span><span class="operator">*</span>’ <span class="number">0.01</span> ‘<span class="operator">*</span>’ <span class="number">0.05</span> ‘.’ <span class="number">0.1</span> ‘ ’ <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Residual standard error<span class="operator">:</span> <span class="number">1.011</span> on <span class="number">386</span> degrees of freedom</span><br><span class="line">Multiple R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.8761</span><span class="punctuation">,</span>	Adjusted R<span class="operator">-</span>squared<span class="operator">:</span>  <span class="number">0.8719</span> </span><br><span class="line"><span class="built_in">F</span><span class="operator">-</span>statistic<span class="operator">:</span>   <span class="number">210</span> on <span class="number">13</span> and <span class="number">386</span> DF<span class="punctuation">,</span>  p<span class="operator">-</span>value<span class="operator">:</span> <span class="operator">&lt;</span> <span class="number">2.2e-16</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>数据分析</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是线性</title>
    <url>/posts/c2b5c4e7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今天发现，我们一直在说的“线性”二字居然是一个有歧义的概念。</p>
<span id="more"></span>
<h1>概述</h1>
<p>我查了一些资料，目前感觉还是维基百科对这个问题讲得最清楚全面，因此本文主要内容来自于<a href="https://www.wikiwand.com/zh-tw/%E7%B7%9A%E6%80%A7%E9%97%9C%E4%BF%82">维基百科-线性关系</a>。</p>
<blockquote>
<p>在现代学术界中，<strong>线性关系</strong>一词存在2种不同的含义。其一，若某数学函数或数学关系的函数图形呈现为一条直线或线段，那么这种关系就是一种<strong>线性</strong>的关系。其二，在线性代数和数学分析中，如果一种运算同时满足<strong>可加性</strong>和<strong>齐次性</strong>，则称这种运算是线性的。</p>
</blockquote>
<h1>定义</h1>
<blockquote>
<p>如果称一个数学函数 <img src="https://math.now.sh?inline=L%28x%29" style="display:inline-block;margin: 0;"/> 为线性的，可以是指：</p>
<ul>
<li><strong>定义1</strong>： <img src="https://math.now.sh?inline=L%28x%29" style="display:inline-block;margin: 0;"/> 是一个只有一个变量的一阶多项式函数，即可以表示为 <img src="https://math.now.sh?inline=L%28x%29%3Dk%20x%2Bb" style="display:inline-block;margin: 0;"/> 的形式（其中 k,b 为常数），此时的函数图形是一条直线。</li>
<li><strong>定义2</strong>： <img src="https://math.now.sh?inline=L%28x%29" style="display:inline-block;margin: 0;"/> 满足以下两个性质：
<ul>
<li>可加性：<img src="https://math.now.sh?inline=L%28x%2Bt%29%3DL(x)%2BL(t)" style="display:inline-block;margin: 0;"/></li>
<li>齐次性：<img src="https://math.now.sh?inline=L%28m%20x%29%3Dm%20L(x)" style="display:inline-block;margin: 0;"/></li>
</ul>
</li>
</ul>
<p>需要注意这两种定义分别描述的是2种不同的事物。在初等数学中（主要是与方程组与一次函数有关的理论），使用的是定义1。但在高等数学（尤其是纯数学）中所说的线性一般使用的是定义2。如对线性相关和线性变换的定义。但是初等数学中有关【线性】的一些习惯术语也仍然在高等数学中沿用，如<strong>线性回归</strong>。</p>
<p>定义1 的定义动机是把函数图像为直线的数量关系称作线性的关系。从这种几何意义出发，定义1本来不具有对多元函数进行推广的必要，因为形如 <img src="https://math.now.sh?inline=f%5Cleft%28x_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Cldots%2C%20x_%7Bn%7D%5Cright%29%3Dk_%7B1%7D%20*%20x_%7B1%7D%2Bk_%7B2%7D%20*%20x_%7B2%7D%2B%5Cldots%2Bk_%7Bn%7D%20*%20x_%7Bn%7D%2Bb" style="display:inline-block;margin: 0;"/> 的函数的图形根本不是直线，而是平面或<strong>超平面</strong>，因此也就谈不上“线性”了。但是我们还是有这种做法出现。</p>
</blockquote>
<h1>例子</h1>
<blockquote>
<ul>
<li>按照定义1，一次函数描述的都是不同变量间的线性的数量关系，而高次函数描述的都不是线性的数量关系。比如 <img src="https://math.now.sh?inline=y_%7B1%7D%3D3%20x%2C%20%5Cquad%20y_%7B2%7D%3D%5Cfrac%7B1%7D%7B3%7D%20x" style="display:inline-block;margin: 0;"/>  和  <img src="https://math.now.sh?inline=y_%7B3%7D%3D3%20x%2B1" style="display:inline-block;margin: 0;"/>  都属于这种意义下的线性函数，但 <img src="https://math.now.sh?inline=y_%7B4%7D%3Dx%5E%7B2%7D%20%2C%5Cquad%20y_%7B5%7D%3Dx%2Bz%20%2C%5Cquad%20y_%7B6%7D%3Dx%2Bz%2B2" style="display:inline-block;margin: 0;"/>  和  <img src="https://math.now.sh?inline=y_%7B7%7D%3Dx%20z" style="display:inline-block;margin: 0;"/> 则不是。（如果将这种意义下的【线性】概念推广到多元函数，则 <img src="https://math.now.sh?inline=y_6" style="display:inline-block;margin: 0;"/> 也能算。事实上，【多元线性回归】的【线性】指的就是这种线性。）</li>
<li>而按照定义2，若以一元函数为例，则截距为 0 的一次函数 (即正比例函数) 属于线性函数，但截距不为 0 的一次函数则不属于线性函数。又如 <img src="https://math.now.sh?inline=y_%7B1%7D%3D3%20x%2C%5Cquad%20y_%7B2%7D%3D%5Cfrac%7B1%7D%7B3%7D%20x" style="display:inline-block;margin: 0;"/>  和  <img src="https://math.now.sh?inline=y_%7B5%7D%3Dx%2Bz" style="display:inline-block;margin: 0;"/> 都属于这种意义下的线性函数（<img src="https://math.now.sh?inline=y_5" style="display:inline-block;margin: 0;"/> 特征向量的维数为 2 ，即此时 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D%20%3D%20%28x%2Cz%29'" style="display:inline-block;margin: 0;"/> ，此时可以轻易证明其符合可加性和齐次性 ）。但是 <img src="https://math.now.sh?inline=y_%7B3%7D%3D3%20x%2B1%2C%5Cquad%20y_%7B4%7D%3Dx%5E%7B2%7D%2C%5Cquad%20y_%7B6%7D%3Dx%2Bz%2B2" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=y_%7B7%7D%3Dx%20z" style="display:inline-block;margin: 0;"/> 都不是。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>假设检验中的alpha,beta及power</title>
    <url>/posts/5cc421e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在统计的假设检验中，α，β，power ，一型错误，二型错误这几个概念/概率总是容易混淆，或者一下子忘了啥意思，把它们放在一个表里方便查找。</p>
<span id="more"></span>
<h1>假设检验</h1>
<p>假设检验是先对总体参数提出一个假设值，然后利用样本信息判断这一假设是否成立<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[假设检验——这一篇文章就够了](https://zhuanlan.zhihu.com/p/86178674)
">[1]</span></a></sup>。</p>
<p>假设检验的步骤如下<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[假设检验——这一篇文章就够了](https://zhuanlan.zhihu.com/p/86178674)
">[1]</span></a></sup><sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="假设检验的逻辑是是什么？ - GRAYLAMB的回答 - 知乎 https://www.zhihu.com/question/20254932/answer/459073864
">[2]</span></a></sup>。</p>
<ul>
<li>
<p>提出原假设与备择假设</p>
<p>原假设一般时你想要拒绝的假设，备择假设时你想要接受的假设。</p>
</li>
<li>
<p>从所研究总体中出抽取随机一次样本</p>
</li>
<li>
<p>构造检验统计量</p>
</li>
<li>
<p>根据显著性水平确定拒绝域临界值</p>
</li>
<li>
<p>计算检验统计量与临界值进行比较</p>
</li>
</ul>
<h1>假设检验表格</h1>
<p>α，β，power 定义见下表<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://www.wikiwand.com/zh/%E6%AA%A2%E5%AE%9A%E5%8A%9B">[3]</span></a></sup>。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>真实情况</th>
<th>真实情况</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>H0为真</td>
<td>H0为假</td>
</tr>
<tr>
<td><strong>根据研究结果的判断</strong></td>
<td>拒绝 H0</td>
<td>错误判断 (假阳性，一型错误，弃真错误)，发生概率为 α （显著性水平）</td>
<td>正确判断，发生概率 1-β (统计功效)</td>
</tr>
<tr>
<td><strong>根据研究结果的判断</strong></td>
<td>接受 H0</td>
<td>正确判断，发生概率 1-α</td>
<td>错误判断（假阴性，二型错误，存伪错误），发生概率为 β</td>
</tr>
</tbody>
</table>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zhuanlan.zhihu.com/p/86178674">假设检验——这一篇文章就够了</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">假设检验的逻辑是是什么？ - GRAYLAMB的回答 - 知乎 https://www.zhihu.com/question/20254932/answer/459073864<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://www.wikiwand.com/zh/%E6%AA%A2%E5%AE%9A%E5%8A%9B<a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>理论学习</category>
        <category>统计</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>PCA分析公式推导</title>
    <url>/posts/fc532062/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>吴老师的CS229课程里讲到了PCA分析，但是感觉有些地方不清晰，查阅了一些资料，自己整理了一下。</p>
<span id="more"></span> 
<h1>特征值分解与奇异值分解</h1>
<p>首先我们需要了解一些特征值分解与奇异值分解的一些背景知识。</p>
<h2 id="特征值分解">特征值分解</h2>
<h3 id="特征值和特征向量">特征值和特征向量</h3>
<p>矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的特征值和特征向量满足关系：</p>
<p style=""><img src="https://math.now.sh?from=A%20x%3D%5Clambda%20x%2C%20%5Cquad%20x%20%5Cneq%200%0A" /></p><p>我们注意到对于任何特征向量 <img src="https://math.now.sh?inline=x%20%5Cin%20%5Cmathbb%7BC%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> ，和特征值 <img src="https://math.now.sh?inline=t%20%5Cin%20%5Cmathbb%7BC%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=A%28c%20x%29%3Dc%20A%20x%3Dc%20%5Clambda%20x%3D%5Clambda(c%20x)" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=c%20x" style="display:inline-block;margin: 0;"/> 一样是 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的特征向量。因此，当我们提到与特征值 <img src="https://math.now.sh?inline=%5Clambda" style="display:inline-block;margin: 0;"/> 的特征向量 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 时，<strong>我们一般假定特征向量 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 是标准化的</strong>，即 <img src="https://math.now.sh?inline=%5C%7Cx%5C%7C%20%3D%201" style="display:inline-block;margin: 0;"/> 。但是，我们注意到，<img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=-x" style="display:inline-block;margin: 0;"/> 都是特征向量，因此我们无法保证特征向量的符号。</p>
<p>我们可以将上式改写为：</p>
<p style=""><img src="https://math.now.sh?from=%7C%28%5Clambda%20I-A%29%7C%3D0%0A" /></p><p>方阵 <img src="https://math.now.sh?inline=A%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bn%20%5Ctimes%20n%7D" style="display:inline-block;margin: 0;"/> 一定有 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个特征值（可能是复数）。</p>
<p>特征值和特征向量有以下性质：</p>
<ul>
<li>方阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的迹等于所有特征值之和。</li>
</ul>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%20A%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Clambda_%7Bi%7D%0A" /></p><p>证明如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Btr%7D%28A%29%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(Q%20%5CLambda%20Q%5E%7B-1%7D%5Cright)%20%5Cquad%20%5Cbecause%20%5Ctext%20%7B%20%E5%AF%B9%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5%E8%BF%9B%E8%A1%8C%E7%89%B9%E5%BE%81%E5%80%BC%E5%88%86%E8%A7%A3%20%7D%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(Q%5E%7B-1%7D%20Q%20%5CLambda%5Cright)%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D(%5CLambda)%20%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Clambda_%7Bi%7D%0A%5Cend%7Baligned%7D%0A" /></p><ul>
<li>方阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的行列式等于其所有特征值的乘积（缺证明）</li>
</ul>
<p style=""><img src="https://math.now.sh?from=%7CA%7C%3D%5Cprod_%7Bi%3D1%7D%5E%7Bn%7D%20%5Clambda_%7Bi%7D%0A" /></p><ul>
<li>
<p><strong>方阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的秩等于其非零特征值的数目</strong>（缺证明）</p>
</li>
<li>
<p>如果 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 非奇异，那么 <img src="https://math.now.sh?inline=1%2F%5Clambda" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=A%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 的特征值和特征向量。</p>
<p>证明，对 <img src="https://math.now.sh?inline=Ax%20%3D%20%5Clambda%20x" style="display:inline-block;margin: 0;"/> 左右两项均左乘一个 <img src="https://math.now.sh?inline=A%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> ，得到</p>
<p style=""><img src="https://math.now.sh?from=A%5E%7B-1%7DA%20x%20%3D%20A%5E%7B-1%7D%20%5Clambda%20x%20%5C%5C%0A%281%2F%5Clambda%29%20x%20%3D%20A%5E%7B-1%7Dx%0A" /></p></li>
<li>
<p>对角矩阵<img src="https://math.now.sh?inline=D%3D%5Coperatorname%7Bdiag%7D%5Cleft%28d_%7B1%7D%2C%20%5Cldots%20d_%7Bn%7D%5Cright%29" style="display:inline-block;margin: 0;"/>  的特征值就是其对角线元素</p>
<p>证明：因为，<img src="https://math.now.sh?inline=Dx%20%3D%20%5Bd_%7B1%7Dx_%7B1%7D%20%5Cquad%20d_%7B2%7Dx_%7B2%7D%20%5Cquad%20%5Ccdots%20%5Cquad%20d_%7Bn%7Dx_%7Bn%7D%20%5D%5E%7BT%7D" style="display:inline-block;margin: 0;"/>  ，   <img src="https://math.now.sh?inline=d_%7Bi%7Dx%20%3D%20%5Bd_%7Bi%7Dx_%7B1%7D%20%5Cquad%20d_%7Bi%7Dx_%7B2%7D%20%5Cquad%20%5Ccdots%20%5Cquad%20d_%7Bi%7Dx_%7Bn%7D%20%5D%5E%7BT%7D" style="display:inline-block;margin: 0;"/> ，那么我们只需要设 <img src="https://math.now.sh?inline=x_%7Bi%7D" style="display:inline-block;margin: 0;"/> 为任一非零实数，而其他 <img src="https://math.now.sh?inline=x_%7Bj%7D" style="display:inline-block;margin: 0;"/> (<img src="https://math.now.sh?inline=j%20%5Cneq%20i" style="display:inline-block;margin: 0;"/> ) 均为0，那么就满足  <img src="https://math.now.sh?inline=Dx%20%3D%20d_%7Bi%7Dx" style="display:inline-block;margin: 0;"/> ，即对角线元素 <img src="https://math.now.sh?inline=d_%7Bi%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=D" style="display:inline-block;margin: 0;"/> 的特征值。</p>
</li>
</ul>
<p>我们可以将特征方程写为</p>
<p style=""><img src="https://math.now.sh?from=A%20X%3DX%20%5CLambda%0A" /></p><p>其中 <img src="https://math.now.sh?inline=X%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bn%20%5Ctimes%20n%7D" style="display:inline-block;margin: 0;"/> ，每一列表示一个特征向量，而 <img src="https://math.now.sh?inline=%5CLambda" style="display:inline-block;margin: 0;"/> 为对角矩阵，对角线为特征值，即：</p>
<p style=""><img src="https://math.now.sh?from=X%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bn%20%5Ctimes%20n%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0A%5Cmid%20%26%20%5Cmid%20%26%20%26%20%5Cmid%20%5C%5C%0Ax_%7B1%7D%20%26%20x_%7B2%7D%20%26%20%5Ccdots%20%26%20x_%7Bn%7D%20%5C%5C%0A%5Cmid%20%26%20%5Cmid%20%26%20%26%20%5Cmid%0A%5Cend%7Barray%7D%5Cright%5D%2C%20%5CLambda%3D%5Coperatorname%7Bdiag%7D%5Cleft%28%5Clambda_%7B1%7D%2C%20%5Cldots%2C%20%5Clambda_%7Bn%7D%5Cright%29%0A" /></p><p>证明如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7DA%20X%20%26%3DA%5Cleft%5Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Cldots%2C%20x_%7Bn%7D%5Cright%5D%20%5C%5C%26%3D%5Cleft%5B%5Clambda_%7B1%7D%20x_%7B1%7D%2C%20%5Clambda_%7B2%7D%20x_%7B2%7D%2C%20%5Cldots%2C%20%5Clambda_%7Bn%7D%20x_%7Bn%7D%5Cright%5D%20%5C%5C%26%3D%5Cleft%5Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Cldots%2C%20x_%7Bn%7D%5Cright%5D%20%5CLambda%20%5C%5C%26%3DX%20%5CLambda%5Cend%7Baligned%7D%0A" /></p><p>如果 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的特征向量之间<strong>线性无关</strong>，那么 <img src="https://math.now.sh?inline=X" style="display:inline-block;margin: 0;"/> 可逆，因此存在下式</p>
<p style=""><img src="https://math.now.sh?from=A%3DX%20%5CLambda%20X%5E%7B-1%7D%0A" /></p><p>最后，我们的约束条件是 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 有 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/>个 线性无关的特征向量，而不是矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 本身是否满秩，矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 无论是否满秩都有可能有 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个线性无关的特征向量。</p>
<h3 id="对称矩阵的特征值和特征向量">对称矩阵的特征值和特征向量</h3>
<p>对称矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的特征值和特征向量有两个重要的性质，<strong>首先，对称矩阵所有的特征值均是实数；第二，对称矩阵的特征向量彼此正交</strong>（缺证明）。因此，此时的 <img src="https://math.now.sh?inline=X" style="display:inline-block;margin: 0;"/> 矩阵为正交矩阵，此时我们定义特征向量的矩阵为 <img src="https://math.now.sh?inline=U" style="display:inline-block;margin: 0;"/> ，即我们表示对称矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 为下式</p>
<p style=""><img src="https://math.now.sh?from=A%3DQ%20%5CLambda%20Q%5E%7B-1%7D%3DQ%20%5CLambda%20Q%5E%7BT%7D%0A" /></p><p><strong>证明：</strong> <img src="https://math.now.sh?inline=Q%5E%7B-1%7D%3DQ%5E%7BT%7D" style="display:inline-block;margin: 0;"/> (其实就是正交矩阵的基本性质)</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26Q%5E%7BT%7D%20Q%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A-%20q_%7B1%7D%20-%20%5C%5C%0A-%20q_%7B2%7D%20-%20%5C%5C%0A%5Ccdots%20%5C%5C%0A-%20q_%7Bn%7D%20-%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D%0A%7C%20%26%20%7C%20%26%20%5Cvdots%20%26%20%7C%20%5C%5C%0Aq_%7B1%7D%20%26%20q_%7B2%7D%20%26%20%5Cvdots%20%26%20q_%7Bn%7D%20%5C%5C%0A%7C%20%26%20%7C%20%26%20%5Cvdots%20%26%20%7C%0A%5Cend%7Barray%7D%5Cright%5D%5C%5C%0A%26%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0Aq_%7B1%7D%5E%7BT%7D%20q_%7B1%7D%20%26%20q_%7B1%7D%5E%7BT%7D%20q_%7B2%7D%20%26%20%5Ccdots%20%26%20q_%7B1%7D%5E%7BT%7D%20q_%7Bn%7D%20%5C%5C%0Aq_%7B2%7D%5E%7BT%7D%20q_%7B1%7D%20%26%20q_%7B2%7D%5E%7BT%7D%20q_%7B2%7D%20%26%20%5Ccdots%20%26%20q_%7B2%7D%5E%7BT%7D%20q_%7Bn%7D%20%5C%5C%0A%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%5C%5C%0Aq_%7Bn%7D%5E%7BT%7D%20q_%7B1%7D%20%26%20q_%7Bn%7D%5E%7BT%7D%20q_%7B2%7D%20%26%20%5Ccdots%20%26%20q_%7Bn%7D%5E%7BT%7D%20q_%7Bn%7D%0A%5Cend%7Barray%7D%5Cright%5D%5C%5C%0A%5C%5C%0A%26%3DI%20%5Cquad%20%5Cbecause%20%E5%AF%B9%E8%A7%92%E7%BA%BF%E4%B8%BA%E6%A8%A1%E9%95%BF%E5%BA%A6%EF%BC%8C%E9%9D%9E%E5%AF%B9%E8%A7%92%E7%BA%BF%E6%A0%B9%E6%8D%AE%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F%E4%B8%A4%E4%B8%A4%E6%AD%A3%E4%BA%A4%E7%9A%84%E6%80%A7%E8%B4%A8%E5%9D%87%E4%B8%BA0%5C%20%0A%5Cend%7Baligned%7D%0A" /></p><p>此时，我们可以表示二次型为</p>
<p style=""><img src="https://math.now.sh?from=x%5E%7BT%7D%20A%20x%3Dx%5E%7BT%7D%20U%20%5CLambda%20U%5E%7BT%7D%20x%3Dy%5E%7BT%7D%20%5CLambda%20y%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Clambda_%7Bi%7D%20y_%7Bi%7D%5E%7B2%7D%0A" /></p><p>其中  <img src="https://math.now.sh?inline=y%3DU%5E%7BT%7D%20x" style="display:inline-block;margin: 0;"/> 。</p>
<p>因为 $y_{i}^{2} \geq 0 $， 因此，二次型的符号完全由特征值 <img src="https://math.now.sh?inline=%5Clambda_%7Bi%7D" style="display:inline-block;margin: 0;"/> 决定。如果所有的特征值均满足 <img src="https://math.now.sh?inline=%5Clambda_%7Bi%7D%20%3E%200" style="display:inline-block;margin: 0;"/> ，那么这个矩阵便是正定矩阵；如果所有的特征值  <img src="https://math.now.sh?inline=%5Clambda_%7Bi%7D%20%5Cgeq%200" style="display:inline-block;margin: 0;"/> （也就是存在特征值为0），那么这个矩阵就是半正定矩阵。相似地，如果所有的特征值满足 <img src="https://math.now.sh?inline=%5Clambda_%7Bi%7D%3C0" style="display:inline-block;margin: 0;"/> 或 <img src="https://math.now.sh?inline=%5Clambda_%7Bi%7D%20%5Cleq%200" style="display:inline-block;margin: 0;"/> ，此时矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 就是一个负定或半负定矩阵。如果矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 同时有正数和负数的特征值，说明 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 为不定矩阵</p>
<h2 id="奇异值分解">奇异值分解</h2>
<p>下面这段话全部来自于别人的文章<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://zhuanlan.zhihu.com/p/26306568">[3]</span></a></sup></p>
<p>当给定一个大小为 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> ，虽然矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 不一定是方阵，但大小为 <img src="https://math.now.sh?inline=m%20%5Ctimes%20m" style="display:inline-block;margin: 0;"/> 的 <img src="https://math.now.sh?inline=A%20A%5E%7BT%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的 <img src="https://math.now.sh?inline=A%5E%7BT%7D%20A" style="display:inline-block;margin: 0;"/> 却是对称矩阵，可以进行特征值分解。若  <img src="https://math.now.sh?inline=A%20A%5E%7BT%7D%3DP%20%5CLambda_%7B1%7D%20P%5E%7BT%7D" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=A%5E%7BT%7D%20A%3DQ%20%5CLambda_%7B2%7D%20Q%5E%7BT%7D" style="display:inline-block;margin: 0;"/> 则矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/>  的奇异值分解为</p>
<p style=""><img src="https://math.now.sh?from=A%3DP%20%5CSigma%20Q%5E%7BT%7D%0A" /></p><p>满足</p>
<p style=""><img src="https://math.now.sh?from=P%5E%7BT%7D%20%3D%20P%5E%7B-1%7D%5C%5C%0AQ%5E%7BT%7D%20%3D%20Q%5E%7B-1%7D%5C%5C%0A" /></p><p>其中，矩阵 <img src="https://math.now.sh?inline=P%3D%5Cleft%28%5Cvec%7Bp%7D_%7B1%7D%2C%20%5Cvec%7Bp%7D_%7B2%7D%2C%20%5Cldots%2C%20%5Cvec%7Bp%7D_%7Bm%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 的大小为 <img src="https://math.now.sh?inline=m%20%5Ctimes%20m" style="display:inline-block;margin: 0;"/> ，列向量 <img src="https://math.now.sh?inline=%5Cvec%7Bp%7D_%7B1%7D%2C%20%5Cvec%7Bp%7D_%7B2%7D%2C%20%5Cldots%2C%20%5Cvec%7Bp%7D_%7Bm%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=A%20A%5E%7BT%7D" style="display:inline-block;margin: 0;"/> 的特征向量，也 被称为矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的左奇异向量 (left singular vector) ; 矩阵 <img src="https://math.now.sh?inline=Q%3D%5Cleft%28%5Cvec%7Bq%7D_%7B1%7D%2C%20%5Cvec%7Bq%7D_%7B2%7D%2C%20%5Cldots%2C%20%5Cvec%7Bq%7D_%7Bn%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 的大小为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> ， 列向量 <img src="https://math.now.sh?inline=%5Cvec%7Bq%7D_%7B1%7D%2C%20%5Cvec%7Bq%7D_%7B2%7D%2C%20%5Cldots%2C%20%5Cvec%7Bq%7D_%7Bn%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=A%5E%7BT%7D%20A" style="display:inline-block;margin: 0;"/> 的特征向量，也被称为矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的右奇异向量 (right singular vector) ; 矩阵 <img src="https://math.now.sh?inline=%5CLambda_%7B1%7D" style="display:inline-block;margin: 0;"/> 大小为 <img src="https://math.now.sh?inline=m%20%5Ctimes%20m" style="display:inline-block;margin: 0;"/> ，矩阵 <img src="https://math.now.sh?inline=%5CLambda_%7B2%7D" style="display:inline-block;margin: 0;"/> 大小为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> ，两个矩阵对角线上的非零元素相同 (即矩阵 <img src="https://math.now.sh?inline=A%20A%5E%7BT%7D" style="display:inline-block;margin: 0;"/> 和矩阵 <img src="https://math.now.sh?inline=A%5E%7BT%7D%20A" style="display:inline-block;margin: 0;"/> 的非零特征值相同，推导过程见下) ; 矩阵 <img src="https://math.now.sh?inline=%5CSigma" style="display:inline-block;margin: 0;"/> 的大小为 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> ，位 于对角线上的元素被称为奇异值 (singular value)。</p>
<p>接下来，我们来看看矩阵 <img src="https://math.now.sh?inline=%5CSigma" style="display:inline-block;margin: 0;"/> 与矩阵 <img src="https://math.now.sh?inline=A%20A%5E%7BT%7D" style="display:inline-block;margin: 0;"/> 和矩阵 <img src="https://math.now.sh?inline=A%5E%7BT%7D%20A" style="display:inline-block;margin: 0;"/> 的关系。令常数 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 是矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的秩，则 <img src="https://math.now.sh?inline=k%20%5Cleq%20%5Cmin%20%28m%2C%20n%29" style="display:inline-block;margin: 0;"/> ，当 <img src="https://math.now.sh?inline=m%20%5Cneq%20n" style="display:inline-block;margin: 0;"/> 时，很明显，矩阵 <img src="https://math.now.sh?inline=%5CLambda_%7B1%7D" style="display:inline-block;margin: 0;"/> 和矩阵 <img src="https://math.now.sh?inline=%5CLambda_%7B2%7D" style="display:inline-block;margin: 0;"/> 的大小不同，但矩阵 <img src="https://math.now.sh?inline=%5CLambda_%7B1%7D" style="display:inline-block;margin: 0;"/> 和矩阵 <img src="https://math.now.sh?inline=%5CLambda_%7B2%7D" style="display:inline-block;margin: 0;"/> 对 角线上的非零元素却是相同的，若将矩阵 <img src="https://math.now.sh?inline=%5CLambda_%7B1%7D" style="display:inline-block;margin: 0;"/> (或矩阵 <img src="https://math.now.sh?inline=%5CLambda_%7B2%7D" style="display:inline-block;margin: 0;"/> ) 对角线上的非零元素分别为 <img src="https://math.now.sh?inline=%5Clambda_%7B1%7D%2C%20%5Clambda_%7B2%7D%2C%20%5Cldots%2C%20%5Clambda_%7Bk%7D" style="display:inline-block;margin: 0;"/> （因为  <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%5Cleft%28%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%5Cright%29%3D%5Coperatorname%7Brank%7D%5Cleft(%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%5Cright)%3D%5Coperatorname%7Brank%7D(%5Cboldsymbol%7BA%7D)" style="display:inline-block;margin: 0;"/> ），其中，这些特征值也都是非负的（需证明 <img src="https://math.now.sh?inline=AA%5ET" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=A%5ETA" style="display:inline-block;margin: 0;"/> 是半正定的，见下），再令矩阵 <img src="https://math.now.sh?inline=%5C%20Sigma" style="display:inline-block;margin: 0;"/> 对角线上的非零元素分别为 <img src="https://math.now.sh?inline=%5Csigma_%7B1%7D%2C%20%5Csigma_%7B2%7D%2C%20%5Cldots%2C%20%5Csigma_%7Bk%7D" style="display:inline-block;margin: 0;"/> ，则</p>
<p style=""><img src="https://math.now.sh?from=%5Csigma_%7B1%7D%3D%5Csqrt%7B%5Clambda_%7B1%7D%7D%2C%20%5Csigma_%7B2%7D%3D%5Csqrt%7B%5Clambda_%7B2%7D%7D%2C%20%5Cldots%2C%20%5Csigma_%7Bk%7D%3D%5Csqrt%7B%5Clambda_%7Bk%7D%7D%0A" /></p><p>即非零奇异值的平方对应着矩阵 <img src="https://math.now.sh?inline=%5CLambda_%7B1%7D" style="display:inline-block;margin: 0;"/> (或矩阵 <img src="https://math.now.sh?inline=%5CLambda_%7B2%7D" style="display:inline-block;margin: 0;"/> ) 的非零特征值，到这里，我们就不难看出奇异值分解与对称对角化分解（特征分解）的关系了，即我们可以由对称对角化分解得到我们想要的奇异值分解。<br>
为了便于理解，在这里，给定一个大小为 <img src="https://math.now.sh?inline=2%20%5Ctimes%202" style="display:inline-block;margin: 0;"/> 的矩阵 <img src="https://math.now.sh?inline=A%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D4%20%26%204%20%5C%5C%20-3%20%26%203%5Cend%7Barray%7D%5Cright%5D" style="display:inline-block;margin: 0;"/> ，虽然这个矩阵是方阵，但 却不是对称矩阵，我们来看看它的奇异值分解是怎样的。<br>
由 <img src="https://math.now.sh?inline=A%20A%5E%7BT%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D32%20%26%200%20%5C%5C%200%20%26%2018%5Cend%7Barray%7D%5Cright%5D" style="display:inline-block;margin: 0;"/> 进行对称对角化分解，得到特征值为 <img src="https://math.now.sh?inline=%5Clambda_%7B1%7D%3D32%20%EF%BC%8C%20%5Clambda_%7B2%7D%3D18" style="display:inline-block;margin: 0;"/> ，相应地，特征向量 为 <img src="https://math.now.sh?inline=%5Cvec%7Bp%7D_%7B1%7D%3D%281%2C0%29%5E%7BT%7D%20%EF%BC%8C%20%5Cvec%7Bp%7D_%7B2%7D%3D(0%2C1)%5E%7BT%7D" style="display:inline-block;margin: 0;"/>; 由 <img src="https://math.now.sh?inline=A%5E%7BT%7D%20A%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D25%20%26%207%20%5C%5C%207%20%26%2025%5Cend%7Barray%7D%5Cright%5D" style="display:inline-block;margin: 0;"/> 进行对称对角化分解，得到特征值为 <img src="https://math.now.sh?inline=%5Clambda_%7B1%7D%3D32%20%EF%BC%8C%20%5Clambda_%7B2%7D%3D18%20%EF%BC%8C" style="display:inline-block;margin: 0;"/> 相应地，特征向量为 <img src="https://math.now.sh?inline=%5Cvec%7Bq%7D_%7B1%7D%3D%5Cleft%28%5Cfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%2C%20%5Cfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%5Cright%29%5E%7BT%7D%20%EF%BC%8C%20%5Cvec%7Bq%7D_%7B2%7D%3D%5Cleft(-%5Cfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%2C%20%5Cfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%5Cright)%5E%7BT%7D" style="display:inline-block;margin: 0;"/> 。取 <img src="https://math.now.sh?inline=%5CSigma%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D4%20%5Csqrt%7B2%7D%20%26%200%20%5C%5C%200%20%26%203%20%5Csqrt%7B2%7D%5Cend%7Barray%7D%5Cright%5D" style="display:inline-block;margin: 0;"/> ，则矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的奇异值分解为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26A%3DP%20%5CSigma%20Q%5E%7BT%7D%3D%5Cleft%28%5Cvec%7Bp%7D_%7B1%7D%2C%20%5Cvec%7Bp%7D_%7B2%7D%5Cright%29%20%5CSigma%5Cleft(%5Cvec%7Bq%7D_%7B1%7D%2C%20%5Cvec%7Bq%7D_%7B2%7D%5Cright)%5E%7BT%7D%20%5C%5C%0A%26%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A1%20%26%200%20%5C%5C%0A0%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A4%20%5Csqrt%7B2%7D%20%26%200%20%5C%5C%0A0%20%26%203%20%5Csqrt%7B2%7D%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A%5Cfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%20%26%20%5Cfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%20%5C%5C%0A-%5Cfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%20%26%20%5Cfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%0A4%20%26%204%20%5C%5C%0A-3%20%26%203%0A%5Cend%7Barray%7D%5Cright%5D%0A%5Cend%7Baligned%7D%0A" /></p><p>如果 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 是一个<strong>对称方阵</strong>，则 <img src="https://math.now.sh?inline=AA%5ET%3DA%5ETA" style="display:inline-block;margin: 0;"/> ，此时左奇异向量和右奇异向量构成的矩阵也是相等的，即 <img src="https://math.now.sh?inline=P%3DQ" style="display:inline-block;margin: 0;"/> 。更为神奇的是，<strong>对称方阵的奇异值分解与特征分解结果相同</strong>，证明见下。</p>
<h3 id="证明：矩阵-A-A-T-和矩阵-A-T-A-的非零特征值相同">证明：矩阵 <img src="https://math.now.sh?inline=A%20A%5E%7BT%7D" style="display:inline-block;margin: 0;"/> 和矩阵 <img src="https://math.now.sh?inline=A%5E%7BT%7D%20A" style="display:inline-block;margin: 0;"/> 的非零特征值相同</h3>
<p>下面这段话来自网络<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://math.stackexchange.com/questions/1249497/largest-eigenvalues-of-aa-equals-to-aa
">[4]</span></a></sup></p>
<blockquote>
<p>For any <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> and <img src="https://math.now.sh?inline=n%20%5Ctimes%20m" style="display:inline-block;margin: 0;"/> matrices <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> and <img src="https://math.now.sh?inline=B" style="display:inline-block;margin: 0;"/>, the nonzero eigenvalues of <img src="https://math.now.sh?inline=A%20B" style="display:inline-block;margin: 0;"/> and <img src="https://math.now.sh?inline=B%20A" style="display:inline-block;margin: 0;"/> are the same. Namely, if <img src="https://math.now.sh?inline=A%20B%20v%3D%5Clambda%20v" style="display:inline-block;margin: 0;"/> with <img src="https://math.now.sh?inline=%5Clambda%20%5Cneq%200" style="display:inline-block;margin: 0;"/> and <img src="https://math.now.sh?inline=v%20%5Cneq%200" style="display:inline-block;margin: 0;"/>, then <img src="https://math.now.sh?inline=B%20v%20%5Cneq%200" style="display:inline-block;margin: 0;"/> （因为 <img src="https://math.now.sh?inline=A%20B%20v%3D%5Clambda%20v%20%5Cneq%200" style="display:inline-block;margin: 0;"/> ，如果 <img src="https://math.now.sh?inline=B%20v%20%3D%200" style="display:inline-block;margin: 0;"/>，则 <img src="https://math.now.sh?inline=ABv%20%3D%200" style="display:inline-block;margin: 0;"/>，与原条件相悖，因此  <img src="https://math.now.sh?inline=B%20v%20%5Cneq%200" style="display:inline-block;margin: 0;"/>  ）and <img src="https://math.now.sh?inline=B%20A%28B%20v%29%3DB(A%20B%20v)%3D%5Clambda%20B%20v" style="display:inline-block;margin: 0;"/>  ，即 <img src="https://math.now.sh?inline=%5Clambda" style="display:inline-block;margin: 0;"/> 同样为 <img src="https://math.now.sh?inline=BA" style="display:inline-block;margin: 0;"/> 的特征值，因此 <img src="https://math.now.sh?inline=AB" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=BA" style="display:inline-block;margin: 0;"/> 的非零特征值相同。</p>
</blockquote>
<h3 id="证明：矩阵-A-A-T-和矩阵-A-T-A-半正定">证明：矩阵 <img src="https://math.now.sh?inline=A%20A%5E%7BT%7D" style="display:inline-block;margin: 0;"/> 和矩阵 <img src="https://math.now.sh?inline=A%5E%7BT%7D%20A" style="display:inline-block;margin: 0;"/> 半正定</h3>
<p>首先，证明  <img src="https://math.now.sh?inline=A%5E%7BT%7D%20A" style="display:inline-block;margin: 0;"/> 半正定 ，证明如下：</p>
<p style=""><img src="https://math.now.sh?from=x%5E%7BT%7D%5Cleft%28A%5E%7BT%7D%20A%5Cright%29%20x%3D%5Cleft(x%5E%7BT%7D%20A%5E%7BT%7D%5Cright)(A%20x)%3D(A%20x)%5E%7BT%7D(A%20x)%20%5Cgeq%200%0A" /></p><p>同理，可证  <img src="https://math.now.sh?inline=A%20A%5E%7BT%7D" style="display:inline-block;margin: 0;"/> 半正定。</p>
<h3 id="证明：对称方阵的奇异值分解与特征分解结果相同">证明：对称方阵的奇异值分解与特征分解结果相同</h3>
<p>当 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 为对称方阵时，<img src="https://math.now.sh?inline=AA%5ET%3DA%5ETA%20%3D%20A%5E2" style="display:inline-block;margin: 0;"/> 。</p>
<p>假设 <img src="https://math.now.sh?inline=%5Clambda" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=u" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的一个特征值和相应的特征方程，此时存在：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26A%5E%7B2%7D%20u%20%5C%5C%0A%26%3DA%28Au%29%20%5C%5C%0A%26%3DA(%5Clambda%20u)%20%5C%5C%0A%26%3D%5Clambda%20A%20u%20%5C%5C%0A%26%3D%5Clambda%5E2%20u%20%5C%5C%20%0A%5Cend%7Baligned%7D%0A" /></p><p>因此， <img src="https://math.now.sh?inline=%5Clambda%5E2" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=u" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=A%5E2" style="display:inline-block;margin: 0;"/> 的特征值和特征向量。</p>
<p>因此，此时，<img src="https://math.now.sh?inline=P%2C%20Q" style="display:inline-block;margin: 0;"/> 为特征分解的特征向量矩阵，而 <img src="https://math.now.sh?inline=%5CSigma" style="display:inline-block;margin: 0;"/> 为特征值组成的对角矩阵。也就是说，对称方阵的奇异值分解与特征分解结果相同</p>
<h1>PCA 预处理</h1>
<p>在使用PCA分析前，我们需要先进行<strong>特征缩放</strong>。</p>
<blockquote>
<ol>
<li>Let <img src="https://math.now.sh?inline=%5Cmu%3D%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/>.</li>
<li>Replace each <img src="https://math.now.sh?inline=x%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> with <img src="https://math.now.sh?inline=x%5E%7B%28i%29%7D-%5Cmu" style="display:inline-block;margin: 0;"/>.</li>
<li>Let <img src="https://math.now.sh?inline=%5Csigma_%7Bj%7D%5E%7B2%7D%3D%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%7D%5Cleft%28x_%7Bj%7D%5E%7B(i%29%7D%5Cright)%5E%7B2%7D" style="display:inline-block;margin: 0;"/></li>
<li>Replace each <img src="https://math.now.sh?inline=x_%7Bj%7D%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> with <img src="https://math.now.sh?inline=x_%7Bj%7D%5E%7B%28i%29%7D%20%2F%20%5Csigma_%7Bj%7D" style="display:inline-block;margin: 0;"/>.</li>
</ol>
</blockquote>
<p>前两步将均值改为 0，后两步将方差均调整为1，使得不同特征具有相同的取值范围 ( “scale”) 。如果你的特征本身就已经是范围一致，那就不用进行后两步，举个例子，假如你的输入特征是图像像素的灰度，那么你的特征取值都是 <img src="https://math.now.sh?inline=%5C%7B0%2C1%2C%20%5Cldots%2C%20255%5C%7D" style="display:inline-block;margin: 0;"/> ，那么就不需要对范围做处理。</p>
<h1>PCA 直观解释</h1>
<p>吴老师说 PCA 分析结果可以有八九种解释的方式，但是我知道的只有两种。</p>
<p>第一种解释方式是找到一个超平面，使得样本点在这个超平面上尽可能分开，也就是投影点的方差尽可能大。如下图，叉形点是二维空间的样本点，我们想找到某个单位向量 <img src="https://math.now.sh?inline=u" style="display:inline-block;margin: 0;"/> ，使得数据投影到  <img src="https://math.now.sh?inline=u" style="display:inline-block;margin: 0;"/> 方向的点的方差最大化。</p>
<p>第二种解释是我们希望所有的样本到这个超平面的距离足够近（所有样本点到超平面距离的平方和最小），对应着下图的虚线。</p>
<p><img src="1.png" alt=""></p>
<h1>推导第一主成分的方向</h1>
<p>这里就是说，如果我们就像上面图中一样，找一个单位向量 <img src="https://math.now.sh?inline=u" style="display:inline-block;margin: 0;"/> 构成的一条直线方向，使得 数据投影到  <img src="https://math.now.sh?inline=u" style="display:inline-block;margin: 0;"/> 方向的点的方差最大化。这里设样本数为 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> ，特征数为 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/>，我们知道给定一个单位向量 <img src="https://math.now.sh?inline=u" style="display:inline-block;margin: 0;"/> 和某个点 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 投射到 <img src="https://math.now.sh?inline=u" style="display:inline-block;margin: 0;"/> 上投影点的长度为 <img src="https://math.now.sh?inline=x%5E%7BT%7Du" style="display:inline-block;margin: 0;"/> （内积的性质）。我们上面提到了最大化投影点的方差，因此，我们需要最大化下式<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://www.bilibili.com/video/BV1EW411R7g6?p=14
">[5]</span></a></sup>：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cmax%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%28x%5E%7B(i%29%5E%7BT%7D%7D%20u%5Cright)%5E%7B2%7D%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20(u%5E%7BT%7D%20x%5E%7B(i)%7D)%20(x%5E%7B(i)%5E%7BT%7D%7D%20u)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20u%5E%7BT%7D%20x%5E%7B(i)%7D%20x%5E%7B(i)%5E%7BT%7D%7D%20u%20%5C%5C%0A%26%3Du%5E%7BT%7D%5Cleft(%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B(i)%7D%20x%5E%7B(i)%5E%7BT%7D%7D%5Cright)%20u%20%5C%5C%0A%5C%5C%0A%26%20s.t.%20%5Cquad%20%5C%7C%5Cmu%5C%7C_%7B2%7D%20%3D%201%0A%5Cend%7Baligned%7D%0A" /></p><p>这里，一个隐含的性质是，投影的点的均值也为 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B0%7D" style="display:inline-block;margin: 0;"/> ，证明如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%28x%5E%7B(i%29%5E%7BT%7D%7D%20u%5Cright)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft(x%5E%7B(i)%5E%7BT%7D%7D%20%5Cright)%20u%20%5C%5C%0A%26%3D%200u%20%5Cquad%20%5Cbecause%20x%E8%BF%9B%E8%A1%8C%E4%BA%86%E4%B8%AD%E5%BF%83%E5%8C%96%EF%BC%8C%20%E5%9D%87%E5%80%BC%E4%B8%BA%200%5C%5C%0A%26%3D0%0A%5Cend%7Baligned%7D%0A" /></p><p>我们发现这个解为 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 的协方差矩阵 <img src="https://math.now.sh?inline=%5CSigma%3D%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B%28i%29%7D%7Bx%7D%5E%7B(i)%5E%7BT%7D%7D" style="display:inline-block;margin: 0;"/> 的 <strong>主特征值(principal eigenvector)</strong>  （特征值中模最大的特征值称为主特征值，相应的特征向量称为主特征向量）。</p>
<p><strong>证明</strong>：我们可以通过构建拉格朗日乘子式来求解上面的问题：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AL%28u%2C%20%5Clambda%29%20%26%3Du%5E%7BT%7D%20%5CSigma%20u-%5Clambda%5Cleft(u%5E%7BT%7D%20u-1%5Cright)%20%5C%5C%0A%26%3Du%5E%7BT%7D%20%5CSigma%20u-%5Clambda%5Cleft(u%5E%7BT%7D%20I%20u-1%5Cright)%20%5C%5C%0A%5Cnabla_%7Bu%7D%20L%20%26%3D%5Cleft(%5CSigma%2B%5CSigma%5E%7BT%7D%5Cright)%20u-%5Clambda%5Cleft(I%2BI%5E%7BT%7D%5Cright)%20u%20%5Cquad%20%5Cbecause%20%5Cfrac%7B%5Cpartial%5Cleft(%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BX%7D%5Cright)%7D%7B%5Cpartial%20%5Cboldsymbol%7BX%7D%7D%3D%5Cleft(%5Cboldsymbol%7BA%7D%2B%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%5Cright)%20%5Cboldsymbol%7BX%7D%20%5C%5C%0A%26%3D2(%5CSigma%20u-%5Clambda%20u)%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，下式成立，即 <img src="https://math.now.sh?inline=u%0A" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Clambda" style="display:inline-block;margin: 0;"/> 分别为 <img src="https://math.now.sh?inline=%5CSigma" style="display:inline-block;margin: 0;"/> 的特征向量和特征值。</p>
<p style=""><img src="https://math.now.sh?from=%5CSigma%20u%3D%5Clambda%20u%0A" /></p><p>代入原式，得到我们要找的特征向量 <img src="https://math.now.sh?inline=u" style="display:inline-block;margin: 0;"/> 就是<strong>主特征向量</strong>。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Coperatorname%7Bmax%7D%5Cleft%28u%5E%7BT%7D%20%5CSigma%20u%5Cright%29%20%26%20%5C%5C%0A%3D%26%20%5Cmax%20%5Cleft(u%5E%7BT%7D%20%5Clambda%20u%5Cright)%20%5C%5C%0A%3D%26%20%5Cmax%20(%5Clambda)%0A%5Cend%7Baligned%7D%0A" /></p><p>于是，我们得到投影数据最佳的一维子空间，也就是第一主成分。</p>
<p>下面，我们将其一般化，推导 PCA 前 <img src="https://math.now.sh?inline=n'" style="display:inline-block;margin: 0;"/>个主成分 。</p>
<h1>PCA一般推导</h1>
<p>推导过程主要来自于西瓜书和南瓜书<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="《机器学习》- 周志华
">[6]</span></a></sup><sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://www.cnblogs.com/pinard/p/6239403.html">[7]</span></a></sup>。</p>
<h2 id="最小投影距离">最小投影距离</h2>
<p>假设 <img src="https://math.now.sh?inline=%5Cmathrm%7Bm%7D" style="display:inline-block;margin: 0;"/> 个 <img src="https://math.now.sh?inline=%5Cmathrm%7Bn%7D" style="display:inline-block;margin: 0;"/> 维数据 <img src="https://math.now.sh?inline=%5C%7Bx%5E%7B%281%29%7D%2C%20x%5E%7B(2)%7D%2C%20%5Cldots%2C%20x%5E%7B(m)%7D%5C%7D" style="display:inline-block;margin: 0;"/> 都已经进行了中心化，即 <img src="https://math.now.sh?inline=%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B%28i%29%7D%3D0" style="display:inline-block;margin: 0;"/> 。经过投影变换后得到的新坐标系为 <img src="https://math.now.sh?inline=%5Cleft%5C%7Bw_%7B1%7D%2C%20w_%7B2%7D%2C%20%5Cldots%2C%20w_%7Bn%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/>, 其中 <img src="https://math.now.sh?inline=w_%7Bi%7D" style="display:inline-block;margin: 0;"/> 是标准正交基向量 (<img src="https://math.now.sh?inline=n%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 维向量)，即 <img src="https://math.now.sh?inline=%5C%7Cw_%7Bi%7D%5C%7C_%7B2%7D%3D1%2C%20w_%7Bi%7D%5E%7BT%7D%20w_%7Bj%7D%3D0" style="display:inline-block;margin: 0;"/> 。</p>
<p>如果我们将数据从 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 维降到 <img src="https://math.now.sh?inline=n%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 维，即丟弃新坐标系中的部分坐标，则新的坐标系为 <img src="https://math.now.sh?inline=%5Cleft%5C%7Bw_%7B1%7D%2C%20w_%7B2%7D%2C%20%5Cldots%2C%20w_%7Bn%5E%7B%5Cprime%7D%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/>。样本点 <img src="https://math.now.sh?inline=x%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> 在 <img src="https://math.now.sh?inline=n%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 维坐标系中的投影为: <img src="https://math.now.sh?inline=z%5E%7B%28i%29%7D%3D%5Cleft(z_%7B1%7D%5E%7B(i)%7D%2C%20z_%7B2%7D%5E%7B(i)%7D%2C%20%5Cldots%2C%20z_%7Bn%5E%7B%5Cprime%7D%7D%5E%7B(i)%7D%5Cright)%5E%7BT%7D" style="display:inline-block;margin: 0;"/>. 其中， <img src="https://math.now.sh?inline=z_%7Bj%7D%5E%7B%28i%29%7D%3Dw_%7Bj%7D%5E%7BT%7D%20x%5E%7B(i)%7D" style="display:inline-block;margin: 0;"/> 是  <img src="https://math.now.sh?inline=x%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> 在低维坐标系里第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 维的坐标。</p>
<p>如果我们用 <img src="https://math.now.sh?inline=z%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> 来恢复原始数据 <img src="https://math.now.sh?inline=x%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/>, 则得到的恢复数据 <img src="https://math.now.sh?inline=%5Chat%7Bx%7D%5E%7B%28i%29%7D%3D%5Csum_%7Bj%3D1%7D%5E%7Bn%5E%7B%5Cprime%7D%7D%20z_%7Bj%7D%5E%7B(i)%7D%20w_%7Bj%7D%3DW%20z%5E%7B(i)%7D" style="display:inline-block;margin: 0;"/>,  其中， <strong><img src="https://math.now.sh?inline=W" style="display:inline-block;margin: 0;"/> 为标准正交基组成的 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n'" style="display:inline-block;margin: 0;"/> 矩阵</strong>。</p>
<p style=""><img src="https://math.now.sh?from=W%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D%0A%7C%20%26%20%7C%20%26%20%5Cvdots%20%26%20%7C%20%5C%5C%0Aw_%7B1%7D%20%26%20w_%7B2%7D%20%26%20%5Cvdots%20%26%20w_%7Bn'%7D%20%5C%5C%0A%7C%20%26%20%7C%20%26%20%5Cvdots%20%26%20%7C%0A%5Cend%7Barray%7D%5Cright%5D%5C%5C%0A" /></p><p>带入上式，易知，<img src="https://math.now.sh?inline=z%5E%7B%28i%29%7D%3DW%5E%7BT%7D%20x%5E%7B(i)%7D" style="display:inline-block;margin: 0;"/> 。并且存在，<img src="https://math.now.sh?inline=W%5ETW%3DI" style="display:inline-block;margin: 0;"/> ，证明如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26W%5E%7BT%7D%20W%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A-%20w_%7B1%7D%20-%20%5C%5C%0A-%20w_%7B2%7D%20-%20%5C%5C%0A%5Ccdots%20%5C%5C%0A-%20w_%7Bn'%7D%20-%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D%0A%7C%20%26%20%7C%20%26%20%5Cvdots%20%26%20%7C%20%5C%5C%0Aw_%7B1%7D%20%26%20w_%7B2%7D%20%26%20%5Cvdots%20%26%20w_%7Bn'%7D%20%5C%5C%0A%7C%20%26%20%7C%20%26%20%5Cvdots%20%26%20%7C%0A%5Cend%7Barray%7D%5Cright%5D%5C%5C%0A%26%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%0Aw_%7B1%7D%20%5Ccdot%20w_%7B1%7D%20%26%20w_%7B1%7D%20%5Ccdot%20w_%7B2%7D%20%26%20%5Ccdots%20%26%20w_%7B1%7D%20%5Ccdot%20w_%7Bn'%7D%20%5C%5C%0Aw_%7B2%7D%20%5Ccdot%20w_%7B1%7D%20%26%20w_%7B2%7D%20%5Ccdot%20w_%7B2%7D%20%26%20%5Ccdots%20%26%20w_%7B2%7D%20%5Ccdot%20w_%7Bn'%7D%20%5C%5C%0A%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%5C%5C%0Aw_%7Bn'%7D%20%5Ccdot%20w_%7B1%7D%20%26%20w_%7Bn'%7D%5Ccdot%20w_%7B2%7D%20%26%20%5Ccdots%20%26%20w_%7Bn'%7D%20%5Ccdot%20w_%7Bn'%7D%0A%5Cend%7Barray%7D%5Cright%5D%5C%5C%0A%5C%5C%0A%26%3DI%20%5Cquad%20%5Cbecause%20%E5%AF%B9%E8%A7%92%E7%BA%BF%E4%B8%BA%E6%A8%A1%E9%95%BF%E5%BA%A6%EF%BC%8C%E9%9D%9E%E5%AF%B9%E8%A7%92%E7%BA%BF%E6%A0%B9%E6%8D%AE%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F%E4%B8%A4%E4%B8%A4%E6%AD%A3%E4%BA%A4%E7%9A%84%E6%80%A7%E8%B4%A8%E5%9D%87%E4%B8%BA0%5C%20%0A%5Cend%7Baligned%7D%0A" /></p><p>现在我们考虑整个样本集，我们莃望所有的样本到这个超平面的距离足够近，即最小化下式:</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%5C%7C%5Chat%7Bx%7D%5E%7B%28i%29%7D-x%5E%7B(i)%7D%5Cright%5C%7C_%7B2%7D%5E%7B2%7D%0A" /></p><p>将这个式子进行整理，可以得到:</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%5C%7C%5Chat%7Bx%7D%5E%7B%28i%29%7D-x%5E%7B(i)%7D%5Cright%5C%7C_%7B2%7D%5E%7B2%7D%20%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%5C%7CW%20z%5E%7B(i)%7D-x%5E%7B(i)%7D%5Cright%5C%7C_%7B2%7D%5E%7B2%7D%20%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft(%5Cmathbf%7BW%7D%20%5Cboldsymbol%7Bz%7D%5E%7B(i)%7D-%5Cboldsymbol%7Bx%7D%5E%7B(i)%7D%5Cright)%5E%7B%5Cmathrm%7BT%7D%7D%5Cleft(%5Cmathbf%7BW%7D%20%5Cboldsymbol%7Bz%7D%5E%7B(i)%7D-%5Cboldsymbol%7Bx%7D%5E%7B(i)%7D%5Cright)%20%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft(%5Cboldsymbol%7Bz%7D%5E%7B(i)T%7D%20%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BW%7D%20%5Cboldsymbol%7Bz%7D%5E%7B(i)%7D-%5Cboldsymbol%7Bz%7D%5E%7B(i)T%7D%20%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7Bx%7D%5E%7B(i)%7D-%5Cboldsymbol%7Bx%7D%5E%7B(i)T%7D%20%5Cmathbf%7BW%7D%20%5Cboldsymbol%7Bz%7D%5E%7B(i)%7D%2B%5Cboldsymbol%7Bx%7D%5E%7B(i)T%7D%20%5Cboldsymbol%7Bx%7D%5E%7B(i)%7D%5Cright)%20%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft(%5Cboldsymbol%7Bz%7D%5E%7B(i)T%7D%20%5Cboldsymbol%7Bz%7D%5E%7B(i)%7D-2%20%5Cboldsymbol%7Bz%7D%5E%7B(i)T%7D%20%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7Bx%7D%5E%7B(i)%7D%2B%5Cboldsymbol%7Bx%7D%5E%7B(i)T%7D%20%5Cboldsymbol%7Bx%7D%5E%7B(i)%7D%5Cright)%20%5Cquad%20%5Cbecause%20%5Cboldsymbol%7Bz%7D%5E%7B(i)T%7D%20%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7Bx%7D%5E%7B(i)%7D%20%5Ctext%7B%20%E5%92%8C%20%7D%20%5Cboldsymbol%7Bx%7D%5E%7B(i)T%7D%20%5Cmathbf%7BW%7D%20%5Cboldsymbol%7Bz%7D%5E%7B(i)%7D%20%E4%BA%92%E4%B8%BA%E8%BD%AC%E7%BD%AE%E4%B8%94%E4%B8%BA%E6%A0%87%E9%87%8F%EF%BC%8C%E5%9B%A0%E6%AD%A4%E4%BA%8C%E8%80%85%E7%9B%B8%E7%AD%89%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20z%5E%7B(i)%20T%7D%20z%5E%7B(i)%7D-2%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20z%5E%7B(i)%20T%7D%20z%5E%7B(i)%7D%2B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B(i)%20T%7D%20x%5E%7B(i)%7D%20%5C%5C%0A%26%3D-%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20z%5E%7B(i)%20T%7D%20z%5E%7B(i)%7D%2B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B(i)%20T%7D%20x%5E%7B(i)%7D%20%5C%5C%0A%26%3D-%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Coperatorname%7Btr%7D%20%5Cleft(z%5E%7B(i)%7D%20z%5E%7B(i)%20T%7D%5Cright)%2B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B(i)%20T%7D%20x%5E%7B(i)%7D%20%5Cquad%20%5Cbecause%20%5Coperatorname%7Btr%7D%20%5Cleft(z%5E%7B(i)%7D%20z%5E%7B(i)%20T%7D%5Cright)%20%3D%20z%5E%7B(i)%20T%7D%20z%5E%7B(i)%7D%5C%5C%0A%26%3D-%20%5Coperatorname%7Btr%7D%20%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20z%5E%7B(i)%7D%20z%5E%7B(i)%20T%7D%5Cright)%2B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B(i)%20T%7D%20x%5E%7B(i)%7D%20%5C%5C%0A%26%3D-%20%5Coperatorname%7Btr%7D%20%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20W%5E%7BT%7D%20x%5E%7B(i)%7D%20x%5E%7B(i)T%7D%20W%20%20%5Cright)%2B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B(i)%20T%7D%20x%5E%7B(i)%7D%20%5C%5C%0A%26%3D-%5Coperatorname%7Btr%7D%5Cleft(W%5E%7BT%7D%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B(i)%7D%20x%5E%7B(i)%20T%7D%5Cright)%20W%5Cright)%2B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B(i)%20T%7D%20x%5E%7B(i)%7D%20%5C%5C%0A%26%3D-%5Coperatorname%7Btr%7D%5Cleft(W%5E%7BT%7D%20X%5E%7BT%7D%20X%20W%5Cright)%2B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B(i)%20T%7D%20x%5E%7B(i)%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>注意到 <img src="https://math.now.sh?inline=%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B%28i%29%7D%20x%5E%7B(i)%20T%7D" style="display:inline-block;margin: 0;"/> 是数据集的协方差矩阵（从协方差矩阵准取定义看，这个公式少了 <img src="https://math.now.sh?inline=1%2Fm" style="display:inline-block;margin: 0;"/> ，但是对我们这里推导无影响，下同），可以写成<strong>设计矩阵</strong>的格式（行是样本，列是特征，因此 <strong><img src="https://math.now.sh?inline=X" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵</strong>）。而 <img src="https://math.now.sh?inline=%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B%28i%29%20T%7D%20x%5E%7B(i)%7D" style="display:inline-block;margin: 0;"/> 是一个常量。</p>
<p>最小化上式等价于:</p>
<p style=""><img src="https://math.now.sh?from=%5Cunderbrace%7B%5Carg%20%5Cmin%20%7D_%7BW%7D-%5Coperatorname%7Btr%7D%5Cleft%28W%5E%7BT%7D%20X%5E%7BT%7D%20X%20W%5Cright%29%20%5C%5C%20%5Ctext%20%7B%20s.t.%20%7D%20W%5E%7BT%7D%20W%3DI%0A" /></p><p>构建拉格朗日函数如下<sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://math.stackexchange.com/questions/1104376/how-to-set-up-lagrangian-optimization-with-matrix-constrains
">[8]</span></a></sup><sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="《南瓜书》">[9]</span></a></sup> ，这里拉格朗日乘子矩阵  <img src="https://math.now.sh?inline=%5CTheta" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=n'%20%5Ctimes%20n'" style="display:inline-block;margin: 0;"/> 的矩阵，与约束条件维度相同</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AL%28%5Cmathbf%7BW%7D%2C%20%5CTheta%29%20%26%3D-%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%5Cright)%2B%5Cleft%5Clangle%5CTheta%2C%20%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BW%7D-%5Cmathbf%7BI%7D%5Cright%5Crangle%20%5Cquad%20%5Cbecause%20%E8%BF%99%E9%87%8C%E6%98%AF%E4%B8%A4%E4%B8%AA%E7%9F%A9%E9%98%B5%E7%9A%84%E5%86%85%E7%A7%AF%EF%BC%8C%E7%AD%89%E4%BA%8E%E4%B8%A4%E4%B8%AA%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%90%8C%E4%BD%8D%E7%BD%AE%E5%85%83%E7%B4%A0%E4%B9%98%E7%A7%AF%E4%B9%8B%E5%92%8C%EF%BC%8C%E5%8F%AF%E7%94%A8%E8%BF%B9%E5%87%BD%E6%95%B0%E8%A1%A8%E7%A4%BA%5C%5C%0A%26%3D-%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%5Cright)%2B%5Coperatorname%7Btr%7D%5Cleft(%5CTheta%5E%7B%5Cmathrm%7BT%7D%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BW%7D-%5Cmathbf%7BI%7D%5Cright)%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>若此时仅考虑约束 <img src="https://math.now.sh?inline=w_%7Bi%7D%5E%7B%5Cmathrm%7BT%7D%7D%20w_%7Bi%7D%3D1" style="display:inline-block;margin: 0;"/> ，即只考虑 <img src="https://math.now.sh?inline=W%5ETW" style="display:inline-block;margin: 0;"/> 的对角线元素的约束，此时拉格朗日乘子矩阵 <img src="https://math.now.sh?inline=%5CTheta" style="display:inline-block;margin: 0;"/> 为<strong>对角矩阵</strong>，令新的拉格朗日乘子矩阵为 <img src="https://math.now.sh?inline=%5CLambda%3D%5Coperatorname%7Bdiag%7D%5Cleft%28%5Clambda_%7B1%7D%2C%20%5Clambda_%7B2%7D%2C%20%5Cldots%2C%20%5Clambda_%7Bn%5E%7B%5Cprime%7D%7D%5Cright%29" style="display:inline-block;margin: 0;"/> , 此时的拉格朗日函数为</p>
<p style=""><img src="https://math.now.sh?from=L%28%5Cmathbf%7BW%7D%2C%20%5CLambda%29%3D-%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%5Cright)%2B%5Coperatorname%7Btr%7D%5Cleft(%5CLambda%5E%7B%5Cmathrm%7BT%7D%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BW%7D-%5Cmathbf%7BI%7D%5Cright)%5Cright)%0A" /></p><p>对拉格朗日函数关于 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D" style="display:inline-block;margin: 0;"/> 求导可得</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cfrac%7B%5Cpartial%20L%28%5Cmathbf%7BW%7D%2C%20%5CLambda%29%7D%7B%5Cpartial%20%5Cmathbf%7BW%7D%7D%20%26%3D%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Cmathbf%7BW%7D%7D%5Cleft%5B-%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%5Cright)%2B%5Coperatorname%7Btr%7D%5Cleft(%5CLambda%5E%7B%5Cmathrm%7BT%7D%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BW%7D-%5Cmathbf%7BI%7D%5Cright)%5Cright)%5Cright%5D%20%5C%5C%0A%26%3D-%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Cmathbf%7BW%7D%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%5Cright)%2B%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Cmathbf%7BW%7D%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5CLambda%5E%7B%5Cmathrm%7BT%7D%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BW%7D-%5Cmathbf%7BI%7D%5Cright)%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>由矩阵微分公式 <img src="https://math.now.sh?inline=%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Cmathbf%7BX%7D%7D%20%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BB%7D%20%5Cmathbf%7BX%7D%5Cright%29%3D%5Cmathbf%7BB%7D%20%5Cmathbf%7BX%7D%2B%5Cmathbf%7BB%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%2C%20%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Cmathbf%7BX%7D%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BB%20X%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%5Cright)%3D%5Cmathbf%7BX%20B%7D%5E%7B%5Cmathrm%7BT%7D%7D%2B%5Cmathbf%7BX%20B%7D" style="display:inline-block;margin: 0;"/> 可得</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cfrac%7B%5Cpartial%20L%28%5Cmathbf%7BW%7D%2C%20%5CLambda%29%7D%7B%5Cpartial%20%5Cmathbf%7BW%7D%7D%20%26%3D-2%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%2B%5Cmathbf%7BW%7D%20%5CLambda%2B%5Cmathbf%7BW%7D%20%5CLambda%5E%7B%5Cmathrm%7BT%7D%7D%20%5C%5C%0A%26%3D-2%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%2B%5Cmathbf%7BW%7D%5Cleft(%5CLambda%2B%5CLambda%5E%7B%5Cmathrm%7BT%7D%7D%5Cright)%20%5C%5C%0A%26%3D-2%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%2B2%20%5Cmathbf%7BW%7D%20%5CLambda%0A%5Cend%7Baligned%7D%0A" /></p><p>令 <img src="https://math.now.sh?inline=%5Cfrac%7B%5Cpartial%20L%28%5Cmathbf%7BW%7D%2C%20%5CLambda%29%7D%7B%5Cpartial%20%5Cmathbf%7BW%7D%7D%3D0" style="display:inline-block;margin: 0;"/> 可得</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A-2%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%2B2%20%5Cmathbf%7BW%7D%20%5CLambda%20%26%3D%5Cmathbf%7B0%7D%20%5C%5C%0A%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%20%26%3D%5Cmathbf%7BW%7D%20%5CLambda%0A%5Cend%7Baligned%7D%0A" /></p><p>将 <img src="https://math.now.sh?inline=%5Cmathrm%7BW%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5CLambda" style="display:inline-block;margin: 0;"/> 展开可得</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%5Cboldsymbol%7Bw%7D_%7Bi%7D%3D%5Clambda_%7Bi%7D%20%5Cboldsymbol%7Bw%7D_%7Bi%7D%2C%20%5Cquad%20i%3D1%2C2%2C%20%5Cldots%2C%20n%5E%7B%5Cprime%7D%0A" /></p><blockquote>
<p>显然, 此式为矩阵特征值和特征向量的定义式, 其中 <img src="https://math.now.sh?inline=%5Clambda_%7Bi%7D%2C%20w_%7Bi%7D" style="display:inline-block;margin: 0;"/> 分别表示矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的特征值和单位特征向量。由于以上是仅考虑约束 <img src="https://math.now.sh?inline=w_%7Bi%7D%5E%7B%5Cmathrm%7BT%7D%7D%20w_%7Bi%7D%3D1" style="display:inline-block;margin: 0;"/> 所求得的结果, 而 <img src="https://math.now.sh?inline=w_%7Bi%7D" style="display:inline-block;margin: 0;"/> 还需满足约束 <img src="https://math.now.sh?inline=w_%7Bi%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7Bw%7D_%7Bj%7D%3D0%28i%20%5Cneq%20j%29" style="display:inline-block;margin: 0;"/> 。观察 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的定义可知, <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 是一个实对称矩阵, 实对称矩阵的不同特征值所对应的特征向量之间相互正交, <strong>同一 特征值的不同特征向量可以通过施密特正交化使其变得正交</strong>, 所以通过上式求得的 <img src="https://math.now.sh?inline=w_%7Bi%7D" style="display:inline-block;margin: 0;"/> 可以同时满足约束 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D_%7Bi%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7Bw%7D_%7Bi%7D%3D1%2C%20%5Cboldsymbol%7Bw%7D_%7Bi%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7Bw%7D_%7Bj%7D%3D0%28i%20%5Cneq%20j%29" style="display:inline-block;margin: 0;"/> 。根据拉格朗日乘子法的原理可知, 此时求得的结果仅是最优解的必要条件, 而且 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 有 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个相互正交的单位特征向量, 所以还需要从这 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个特征向量里找出 <img src="https://math.now.sh?inline=n%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 个能使得目标函数 达到最优值的特征向量作为最优解。将 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20W%3D%20W%20%5CLambda" style="display:inline-block;margin: 0;"/> 代人目标函数可得<sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="《南瓜书》">[9]</span></a></sup></p>
</blockquote>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmin%20_%7B%5Cmathrm%7BW%7D%7D-%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%5Cright%29%20%26%3D%5Cmax%20_%7B%5Cmathbf%7BW%7D%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%5Cright)%20%5C%5C%0A%26%3D%5Cmax%20_%7B%5Cmathbf%7BW%7D%7D%20%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BW%7D%20%5CLambda%20%5Cright)%20%5C%5C%0A%26%3D%5Cmax%20_%7B%5Cmathbf%7BW%7D%7D%20%5Coperatorname%7Btr%7D%5Cleft(%20%5CLambda%20%5Cright)%20%20%5Cquad%20%5Cbecause%20%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BW%7D%20%3D%20%5Cmathbf%7BI%7D%20%20%5C%5C%0A%26%3D%5Cmax%20_%7B%5Cmathbf%7BW%7D%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%5E%7B%5Cprime%7D%7D%20%5Clambda_%7Bi%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>显然, 此时只需要令 <img src="https://math.now.sh?inline=%5Clambda_%7B1%7D%2C%20%5Clambda_%7B2%7D%2C%20%5Cldots%2C%20%5Clambda_%7Bn%5E%7B%5Cprime%7D%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=w_%7B1%7D%2C%20w_%7B2%7D%2C%20%5Cldots%2C%20w_%7Bn%5E%7B%5Cprime%7D%7D" style="display:inline-block;margin: 0;"/> 分别为矩阵 <img src="https://math.now.sh?inline=%5Cmathrm%7BXX%7D%5E%7B%5Cmathrm%7BT%7D%7D" style="display:inline-block;margin: 0;"/> 的前 <img src="https://math.now.sh?inline=n%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 个最大的特征值和单位特征向量就能使得目标函数达到最优值。</p>
<h2 id="最大投影方差">最大投影方差</h2>
<p>我们知道样本点在超平面上的投影为 <img src="https://math.now.sh?inline=z%5E%7B%28i%29%7D%3DW%5E%7BT%7D%20x%5E%7B(i)%7D" style="display:inline-block;margin: 0;"/> ，首先我们证明投影点的均值同样为 <img src="https://math.now.sh?inline=%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%20%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20z%5E%7B%28i%29%7D%20%5C%5C%0A%3D%26%20%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20W%5E%7BT%7D%20x%5E%7B(i)%7D%20%5C%5C%0A%3D%26%20W%5E%7BT%7D%5Cleft(%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20x%5E%7B%5Cleft(i%5Cright)%7D%5Cright)%20%5C%5C%0A%3D%26%20W%5E%7BT%7D%20%5Cboldsymbol%7B0%7D%20%5C%5C%0A%3D%26%20%5Cboldsymbol%7B0%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，投影点的协方差矩阵为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%20%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20z%5E%7B%28i%29%7D%20z%5E%7B(i)%20T%7D%20%5C%5C%0A%3D%26%20%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20W%5E%7BT%7D%20x%5E%7B(i)%7D%20x%5E%7B(i)%20T%7D%20W%20%5C%5C%0A%3D%26%20%5Cfrac%7B1%7D%7Bm%7D%20W%5E%7BT%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft(%20x%5E%7B(i)%7D%20x%5E%7B(i)%20T%7D%20%5Cright)%20W%20%5C%5C%0A%3D%26%20%5Cfrac%7B1%7D%7Bm%7D%20W%5E%7BT%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft(%20x%5E%7B(i)%7D%20x%5E%7B(i)%20T%7D%20%5Cright)%20W%20%5C%5C%0A%3D%26%20%5Cfrac%7B1%7D%7Bm%7D%20W%5E%7BT%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20W%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>投影点的方差为其协方差矩阵的迹，即为 <img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7Bm%7D%20%5Coperatorname%7Btr%7D%5Cleft%28W%5E%7BT%7D%20X%5E%7BT%7D%20X%20W%5Cright%29" style="display:inline-block;margin: 0;"/></p>
<p>于是，此时我们的优化目标为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cunderbrace%7B%5Carg%20%5Cmax%20%7D_%7BW%7D%20%26%20%5Coperatorname%7Btr%7D%5Cleft%28%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%5Cright%29%20%5C%5C%0A%5Ctext%20%7B%20s.t.%20%7D%20%26%20%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BW%7D%3D%5Cmathbf%7BI%7D%0A%5Cend%7Barray%7D%0A" /></p><p>这和上面的最小投影距离的优化目标一致。</p>
<h1>选择合适的 <img src="https://math.now.sh?inline=n'" style="display:inline-block;margin: 0;"/></h1>
<p>当你对协方差矩阵 <img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7Bm%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 进行奇异值分解或特征值分解后，你可以得到总共 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个特征值。这时你可以指定一个阈值 <img src="https://math.now.sh?inline=%5Cmathrm%7Bt%7D" style="display:inline-block;margin: 0;"/>, 这个阈值 <img src="https://math.now.sh?inline=%5Cmathrm%7Bt%7D" style="display:inline-block;margin: 0;"/> 在 <img src="https://math.now.sh?inline=%280%2C1%29" style="display:inline-block;margin: 0;"/> 之间，表示保留的方差比例，一般惯例可选 0.90，0.95 和 0.99。假如我们的 <img src="https://math.now.sh?inline=%5Cmathrm%7Bn%7D" style="display:inline-block;margin: 0;"/> 个特征值为 <img src="https://math.now.sh?inline=%5Clambda_%7B1%7D%20%5Cgeq%20%5Clambda_%7B2%7D%20%5Cgeq%20%5Cldots%20%5Cgeq%20%5Clambda_%7Bn%7D" style="display:inline-block;margin: 0;"/> ，则n’可以通过下式得到:</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bn%5E%7B%5Cprime%7D%7D%20%5Clambda_%7Bi%7D%7D%7B%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Clambda_%7Bi%7D%7D%20%5Cgeq%20t%0A" /></p><p>吴老师提到过这个公式，很多人的博客也提到了这个公式，但是没有告诉你这个公式怎么来的。这个公式在我看来没有这么一目了然，应该给证明过程的。</p>
<p>我思考了半天，才弄懂原理。这个公式蕴含的一个前提是，协方差矩阵所有特征值之和等于样本点的方差。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7BVar%7D%28x%29%20%26%3D%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%5C%7Cx%5E%7B(i)%7D%5Cright%5C%7C%5E%7B2%7D%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(%5Coperatorname%7BCov%7D(x)%5Cright)%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cfrac%7B1%7D%7Bm%7D%20X%5E%7BT%7D%20X%5Cright)%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(Q%20%5CLambda%20Q%5E%7B-1%7D%5Cright)%20%5Cquad%20%5Cbecause%20%E5%AF%B9%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5%E8%BF%9B%E8%A1%8C%E7%89%B9%E5%BE%81%E5%80%BC%E5%88%86%E8%A7%A3%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(Q%5E%7B-1%7D%20Q%20%5CLambda%5Cright)%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D(%5CLambda)%20%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Clambda_%7Bi%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，当你需要计算方差比例的时候，总方差可以通过对所有特征值求和得到，也可以通过对协方差矩阵对角线所有元素求和得到。</p>
<h1>疑问</h1>
<ol>
<li>
<p>为什么对称矩阵就一定可以进行特征值分解（存在 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个线性无关的特征向量），并且其特征向量是一个正交矩阵？</p>
<p>我现在知道这个性质来自于<a href="https://en.wikipedia.org/wiki/Spectral_theorem">谱定理(Spectral theorem)</a>，吴老师说这可能是线性代数中最重要的一个定理，以后有机会再看吧。</p>
</li>
<li>
<p>为什么用 <img src="https://math.now.sh?inline=z%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> 来恢复原始数据 <img src="https://math.now.sh?inline=x%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> 的公式为  <img src="https://math.now.sh?inline=%5Chat%7Bx%7D%5E%7B%28i%29%7D%3D%5Csum_%7Bj%3D1%7D%5E%7Bn%5E%7B%5Cprime%7D%7D%20z_%7Bj%7D%5E%7B(i)%7D%20w_%7Bj%7D%3DW%20z%5E%7B(i)%7D" style="display:inline-block;margin: 0;"/> ？</p>
<p>这种转换其实就是<strong>基变换</strong>，基变换的内容可以看我的博客<a href="https://vincere.fun/posts/6ea65792/">矩阵乘法的内涵和本质</a>。<img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 的标准基为 <img src="https://math.now.sh?inline=%5C%7Be_1%2C%20e_2%2C%20%5Ccdots%2C%20e_n%5C%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个特征向量  <img src="https://math.now.sh?inline=%5Cleft%5C%7Bw_%7B1%7D%2C%20w_%7B2%7D%2C%20%5Cldots%2C%20w_%7Bn%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> 也是<img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 的一组基（为方便称呼，我下面称呼其为”新基“），从”新基“转换到标准基的转移矩阵就是 <img src="https://math.now.sh?inline=%5Cmathbf%7BW%7D" style="display:inline-block;margin: 0;"/> ，因此如果我们已知某个样本点在”新基“中的坐标为  <img src="https://math.now.sh?inline=z%5E%7B%28i%29%7D" style="display:inline-block;margin: 0;"/> ，其中我们只用前 <img src="https://math.now.sh?inline=n'" style="display:inline-block;margin: 0;"/> 维的信息，等同于我们设 <img src="https://math.now.sh?inline=n'" style="display:inline-block;margin: 0;"/> 维以后的维度的坐标均为 0，因此存在</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7Bx%7D%5E%7B%28i%29%7D%3DW%20z%5E%7B(i)%7D%3D%5Csum_%7Bj%3D1%7D%5E%7Bn%5E%7B%5Cprime%7D%7D%20z_%7Bj%7D%5E%7B(i)%7D%20w_%7Bj%7D%20%2B%20%20%5Csum_%7Bj%3Dn'%2B1%7D%5E%7Bn%7D%200%20%20%5Ctimes%20w_%7Bj%7D%20%3D%5Csum_%7Bj%3D1%7D%5E%7Bn%5E%7B%5Cprime%7D%7D%20z_%7Bj%7D%5E%7B(i)%7D%20w_%7Bj%7D%0A" /></p></li>
<li>
<p>不是很清楚拉格朗日函数的矩阵形式</p>
<p>其实压根就没有什么所谓的矩阵形式的拉格朗日函数，我们采用矩阵的目标是为了方便书写和运算，比如一个线性方程组你直接写出多个等式，你也可以用矩阵表达为 <img src="https://math.now.sh?inline=Ax%3Db" style="display:inline-block;margin: 0;"/> ，二者的内容是一致的。</p>
<p>这里第一次构建拉格朗日乘子式，限制条件是  <img src="https://math.now.sh?inline=W%5E%7BT%7D%20W-I%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/> ，如果我们把它写成多个等式的形式，其实就是 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n%20%3D%20n%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 个等式的约束条件，即可以将 <img src="https://math.now.sh?inline=W%5E%7BT%7D%20W-I%3D%5Cmathbf%7B0%7D" style="display:inline-block;margin: 0;"/>  写为下面这种形式：</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%20w_%7Bik%7Dw_%7Bjk%7D%20-1%20%3D%200%2C%20%5Cquad%20%5Ctext%7B%20if%20%7D%20i%3Dj%20%5C%5C%0A%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%20w_%7Bik%7Dw_%7Bjk%7D%20%3D%200%2C%20%5Cquad%20%5Ctext%7B%20if%20%7D%20i%20%5Cneq%20j%20%5C%5C%0Ai%20%3D%201%2C%5Ccdots%2C%20n%3B%20%5Cquad%20j%20%3D%201%2C%5Ccdots%2C%20n%0A" /></p><p>此时构建的拉格朗日乘子式即为下式，后面的一项就是 <img src="https://math.now.sh?inline=n%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 个等式的约束条件，只是表示为迹的形式。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AL%28%5Cmathbf%7BW%7D%2C%20%5CTheta%29%20%26%3D-%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%5Cright)%2B%5Cleft%5Clangle%5CTheta%2C%20%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BW%7D-%5Cmathbf%7BI%7D%5Cright%5Crangle%20%5Cquad%20%5Cbecause%20%E8%BF%99%E9%87%8C%E6%98%AF%E4%B8%A4%E4%B8%AA%E7%9F%A9%E9%98%B5%E7%9A%84%E5%85%83%E7%B4%A0%E4%B9%98%E7%A7%AF%EF%BC%8C%E7%AD%89%E4%BA%8E%E4%B8%A4%E4%B8%AA%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%90%8C%E4%BD%8D%E7%BD%AE%E5%85%83%E7%B4%A0%E4%B9%98%E7%A7%AF%E4%B9%8B%E5%92%8C%EF%BC%8C%E5%8F%AF%E7%94%A8%E8%BF%B9%E5%87%BD%E6%95%B0%E8%A1%A8%E7%A4%BA%5C%5C%0A%26%3D-%5Coperatorname%7Btr%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BW%7D%5Cright)%2B%5Coperatorname%7Btr%7D%5Cleft(%5CTheta%5E%7B%5Cmathrm%7BT%7D%7D%5Cleft(%5Cmathbf%7BW%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathbf%7BW%7D-%5Cmathbf%7BI%7D%5Cright)%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>但是我认为，这里其实没有  <img src="https://math.now.sh?inline=n%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 个等式的约束条件，因为 <img src="https://math.now.sh?inline=W%5E%7BT%7D%20W-I" style="display:inline-block;margin: 0;"/> 是一个对称矩阵，实际上只有 <img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7B2%7Dn%28n%2B1%29" style="display:inline-block;margin: 0;"/> 个等式约束条件（上三角的元素数目），因此这里应该要需要限制   <img src="https://math.now.sh?inline=%5CTheta" style="display:inline-block;margin: 0;"/>  为一个 <strong>对称</strong>矩阵，从而将约束条件数目降为  <img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7B2%7Dn%28n%2B1%29" style="display:inline-block;margin: 0;"/> 。</p>
<p>第二次构建拉格朗日函数时，我们只考虑 <img src="https://math.now.sh?inline=W%5ETW" style="display:inline-block;margin: 0;"/> 的对角线元素的约束，此时只有 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个约束条件，我们将  <img src="https://math.now.sh?inline=%5CTheta" style="display:inline-block;margin: 0;"/> 改为一个对角矩阵 <img src="https://math.now.sh?inline=%5CLambda" style="display:inline-block;margin: 0;"/> 。</p>
</li>
</ol>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">吴恩达老师CS229课程讲义<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://www.cnblogs.com/pinard/p/6251584.html<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://zhuanlan.zhihu.com/p/26306568<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://math.stackexchange.com/questions/1249497/largest-eigenvalues-of-aa-equals-to-aa<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://www.bilibili.com/video/BV1EW411R7g6?p=14<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">《机器学习》- 周志华<a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://www.cnblogs.com/pinard/p/6239403.html<a href="#fnref:7" rev="footnote"> ↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://math.stackexchange.com/questions/1104376/how-to-set-up-lagrangian-optimization-with-matrix-constrains<a href="#fnref:8" rev="footnote"> ↩</a></span></li><li id="fn:9"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">《南瓜书》<a href="#fnref:9" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>理论学习</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>证明皮尔逊相关系数绝对值小于1</title>
    <url>/posts/e627bd97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>简单记录一下，内容基本来自于<a href="https://brooksj.com/2019/08/09/%E7%9A%AE%E5%B0%94%E9%80%8A%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0%E7%BB%9D%E5%AF%B9%E5%80%BC%E5%B0%8F%E4%BA%8E1%E7%9A%84%E8%AF%81%E6%98%8E/">皮尔逊相关系数绝对值小于1的证明</a></p>
<span id="more"></span>
<h1>皮尔逊相关定义</h1>
<p>总体的相关系数定义为</p>
<p style=""><img src="https://math.now.sh?from=%5Crho_%7BX%2C%20Y%7D%3D%5Cfrac%7B%5Coperatorname%7Bcov%7D%28X%2C%20Y%29%7D%7B%5Csigma_%7BX%7D%20%5Csigma_%7BY%7D%7D%3D%5Cfrac%7BE%5Cleft%5B%5Cleft(X-%5Cmu_%7BX%7D%5Cright)%5Cleft(Y-%5Cmu_%7BY%7D%5Cright)%5Cright%5D%7D%7B%5Csigma_%7BX%7D%20%5Csigma_%7BY%7D%7D%0A" /></p><p>样本的相关系数计算公式为</p>
<p style=""><img src="https://math.now.sh?from=r%3D%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28X_%7Bi%7D-%5Cbar%7BX%7D%5Cright%29%5Cleft(Y_%7Bi%7D-%5Cbar%7BY%7D%5Cright)%7D%7B%5Csqrt%7B%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(X_%7Bi%7D-%5Cbar%7BX%7D%5Cright)%5E%7B2%7D%7D%20%5Csqrt%7B%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(Y_%7Bi%7D-%5Cbar%7BY%7D%5Cright)%5E%7B2%7D%7D%7D%0A" /></p><h1>证明皮尔逊相关绝对值小于1</h1>
<p>如果我们定义 <img src="https://math.now.sh?inline=X_%7Bi%7D-%5Cbar%7BX%7D%3Dx_%7Bi%7D%2C%20Y_%7Bi%7D-%5Cbar%7BY%7D%3Dy_%7Bi%7D" style="display:inline-block;margin: 0;"/> ，由 <img src="https://math.now.sh?inline=x_i" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=y_i" style="display:inline-block;margin: 0;"/> 组成的向量为 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cboldsymbol%7By%7D" style="display:inline-block;margin: 0;"/> ，则样本的相关系数计算公式此时为</p>
<p style=""><img src="https://math.now.sh?from=r%20%3D%20%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20x_%7Bi%7D%20y_%7Bi%7D%7D%7B%5Csqrt%7B%5Cleft%28%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20x_%7Bi%7D%5E%7B2%7D%5Cright%29%7D%5Csqrt%7B%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20y_%7Bi%7D%5E%7B2%7D%5Cright)%7D%7D%0A" /></p><p>根据<a href="https://www.wikiwand.com/zh/%E6%9F%AF%E8%A5%BF-%E6%96%BD%E7%93%A6%E8%8C%A8%E4%B8%8D%E7%AD%89%E5%BC%8F">柯西-施瓦茨不等式</a>，我们有</p>
<p style=""><img src="https://math.now.sh?from=%7C%5Clangle%20%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7By%7D%5Crangle%7C%20%5Cleq%5C%7C%5Cboldsymbol%7Bx%7D%5C%7C%20%5Ccdot%5C%7C%5Cboldsymbol%7By%7D%5C%7C%0A" /></p><p>因此</p>
<p style=""><img src="https://math.now.sh?from=%7C%5Clangle%20%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7By%7D%5Crangle%7C%20%3D%20%5Cleft%7C%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20x_%7Bi%7D%20y_%7Bi%7D%5Cright%7C%20%5Cleq%20%5Csqrt%7B%5Cleft%28%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20x_%7Bi%7D%5E%7B2%7D%5Cright%29%7D%20%5Csqrt%7B%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20y_%7Bi%7D%5E%7B2%7D%5Cright)%7D%20%3D%20%5C%7C%5Cboldsymbol%7Bx%7D%5C%7C%20%5Ccdot%5C%7C%5Cboldsymbol%7By%7D%5C%7C%0A" /></p><p>换句话说，皮尔逊相关系数等于下式</p>
<p style=""><img src="https://math.now.sh?from=r%20%3D%20%5Cfrac%7B%5Clangle%20%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7By%7D%5Crangle%7D%7B%5C%7C%5Cboldsymbol%7Bx%7D%5C%7C%20%5Ccdot%5C%7C%5Cboldsymbol%7By%7D%5C%7C%7D%20%3D%20%5Ccos%28%5Ctheta%29%0A" /></p><p>即可以视为  <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cboldsymbol%7By%7D" style="display:inline-block;margin: 0;"/> 夹角的余弦值。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵乘法的内涵和本质</title>
    <url>/posts/6ea65792/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>理解矩阵乘法的内涵和本质。</p>
<p>下面的内容主要来自于《Linear Algebra with Applications》的第三章 向量空间和第四章 线性变换。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="《Linear Algebra with Applications》 Ninth Edition
">[1]</span></a></sup></p>
<span id="more"></span>
<h1>向量空间</h1>
<h2 id="子空间与张成-空间">子空间与张成(空间)</h2>
<p>我们先看子空间的概念。</p>
<p><strong>定义</strong> 若 <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> 为向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 的非空子集, 且 <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> 满足如下条件：</p>
<ul>
<li>对任意标量 <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/>, 若 <img src="https://math.now.sh?inline=x%20%5Cin%20S" style="display:inline-block;margin: 0;"/>, 则 <img src="https://math.now.sh?inline=%5Calpha%20x%20%5Cin%20S" style="display:inline-block;margin: 0;"/>.</li>
<li>若 <img src="https://math.now.sh?inline=x%20%5Cin%20S" style="display:inline-block;margin: 0;"/> 且 <img src="https://math.now.sh?inline=y%20%5Cin%20S" style="display:inline-block;margin: 0;"/>, 则 <img src="https://math.now.sh?inline=x%2By%20%5Cin%20S" style="display:inline-block;margin: 0;"/>.</li>
</ul>
<p>则 <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> 称为 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 的<strong>子空间</strong> (subspace).</p>
<p>也就是说子空间  <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/>  在标量乘法和向量加法的意义上应该是封闭的。</p>
<p>我们再看向量集合的<strong>张成</strong>的概念，如下：</p>
<p><strong>定义</strong> 令 <img src="https://math.now.sh?inline=v_%7B1%7D%2C%20v_%7B2%7D%2C%20%5Ccdots%2C%20v_%7Bn%7D" style="display:inline-block;margin: 0;"/> 为向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 中的向量. <img src="https://math.now.sh?inline=%5Calpha_%7B1%7D%20v_%7B1%7D%2B%5Calpha_%7B2%7D%20v_%7B2%7D%2B%5Ccdots%2B%5Calpha_%7Bn%7D%20v_%7Bn%7D" style="display:inline-block;margin: 0;"/> (其中 <img src="https://math.now.sh?inline=%5Calpha_%7B1%7D" style="display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=%5Calpha_%7B2%7D%2C%20%5Ccdots%2C%20%5Calpha_%7Bn%7D" style="display:inline-block;margin: 0;"/> 为标量) 称为向量 <img src="https://math.now.sh?inline=v_%7B1%7D%2C%20v_%7B2%7D%2C%20%5Ccdots%2C%20v_%7Bn%7D" style="display:inline-block;margin: 0;"/> 的<strong>线性组合</strong> (linear combination).  向量 <img src="https://math.now.sh?inline=v_%7B1%7D" style="display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=v_%7B2%7D%2C%20%5Ccdots%2C%20v_%7Bn%7D" style="display:inline-block;margin: 0;"/> 的所有线性组合构成的集合称为 <img src="https://math.now.sh?inline=v_%7B1%7D%2C%20%5Ccdots%2C%20v_%7Bn%7D" style="display:inline-block;margin: 0;"/> 的<strong>张成</strong> (span). 向量 <img src="https://math.now.sh?inline=v_%7B1%7D%2C%20%5Ccdots%2C%20v_%7Bn%7D" style="display:inline-block;margin: 0;"/> 的张成记 为 <img src="https://math.now.sh?inline=%5Coperatorname%7BSpan%7D%5Cleft%28v_%7B1%7D%2C%20%5Ccdots%2C%20v_%7Bn%7D%5Cright%29" style="display:inline-block;margin: 0;"/>.</p>
<p>易证明，向量组合的张成是向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/>  的一个子空间。如果张成空间等于向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/>  ，此时我们称向量集合 <img src="https://math.now.sh?inline=v_%7B1%7D" style="display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=v_%7B2%7D%2C%20%5Ccdots%2C%20v_%7Bn%7D" style="display:inline-block;margin: 0;"/>  是  <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 的一个<strong>张集</strong>。</p>
<p>举个例子，**基向量 <img src="https://math.now.sh?inline=e_1%2C%20e_2%2C%20e_3" style="display:inline-block;margin: 0;"/> ** 就是 <img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7B3%7D" style="display:inline-block;margin: 0;"/> 的一个张集， <img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7B3%7D" style="display:inline-block;margin: 0;"/> 中任何一个向量 <img src="https://math.now.sh?inline=%28a%2C%20b%2C%20c%29%5E%7BT%7D" style="display:inline-block;margin: 0;"/> 均可以表示为</p>
<p style=""><img src="https://math.now.sh?from=%28a%2C%20b%2C%20c%29%5E%7BT%7D%20%3D%20a%5Cmathbf%7Be_1%7D%20%2B%20b%5Cmathbf%7Be_2%7D%20%2B%20%20c%5Cmathbf%7Be_3%7D%0A" /></p><p>再举个例子，<img src="https://math.now.sh?inline=%5Cleft%5C%7B%281%2C1%2C1%29%5E%7B%5Cmathrm%7BT%7D%7D%2C(1%2C1%2C0)%5E%7B%5Cmathrm%7BT%7D%7D%2C(1%2C0%2C0)%5E%7B%5Cmathrm%7BT%7D%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/>  是不是 <img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7B3%7D" style="display:inline-block;margin: 0;"/> 的一个张集呢？这个问题等价于，对于<img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7B3%7D" style="display:inline-block;margin: 0;"/> 中任何一个向量 <img src="https://math.now.sh?inline=%28a%2C%20b%2C%20c%29%5E%7BT%7D" style="display:inline-block;margin: 0;"/>  是不是都可以表示为这三个向量的线性组合？即总能找到相应的 <img src="https://math.now.sh?inline=%5Calpha_1%2C%20%5Calpha_2%2C%20%5Calpha_3" style="display:inline-block;margin: 0;"/> ，使得下式成立</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0Aa%20%5C%5C%0Ab%20%5C%5C%0Ac%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Calpha_%7B1%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A1%20%5C%5C%0A1%20%5C%5C%0A1%0A%5Cend%7Barray%7D%5Cright%5D%2B%5Calpha_%7B2%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A1%20%5C%5C%0A1%20%5C%5C%0A0%0A%5Cend%7Barray%7D%5Cright%5D%2B%5Calpha_%7B3%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A1%20%5C%5C%0A0%20%5C%5C%0A0%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>你可以轻松证明，这三个向量是 <img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7B3%7D" style="display:inline-block;margin: 0;"/> 的一个张集。</p>
<h2 id="线性相关和线性无关">线性相关和线性无关</h2>
<p><strong>定义</strong> 如果向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 中的向量 <img src="https://math.now.sh?inline=v_%7B1%7D%2C%20v_%7B2%7D%2C%20%5Ccdots%2C%20v_%7Bn%7D" style="display:inline-block;margin: 0;"/> 满足 <img src="https://math.now.sh?inline=c_%7B1%7D%20v_%7B1%7D%2Bc_%7B2%7D%20v_%7B2%7D%2B%5Ccdots%2Bc_%7Bn%7D%20v_%7Bn%7D%3D0" style="display:inline-block;margin: 0;"/> 就可推出所有标量 <img src="https://math.now.sh?inline=c_%7B1%7D%2C%20%5Ccdots%2C%20c_%7Bn%7D" style="display:inline-block;margin: 0;"/> 必为 0 , 则称它们为<strong>线性无关</strong>的 (linearly independent)，反之则称它们是<strong>线性相关</strong>的。</p>
<p>如果一组向量线性相关，那就说明<strong>至少</strong>有一个向量可以表示为其他向量的线性组合。</p>
<h2 id="基和维数">基和维数</h2>
<p><strong>定义</strong> 当且仅当向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 中的向量 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bv%7D_%7B1%7D%2C%20%5Cboldsymbol%7Bv%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cboldsymbol%7Bv%7D_%7Bn%7D" style="display:inline-block;margin: 0;"/> 满足</p>
<ul>
<li><img src="https://math.now.sh?inline=v_%7B1%7D%2C%20%5Ccdots%2C%20v_%7Bn%7D" style="display:inline-block;margin: 0;"/> 线性无关,</li>
<li><img src="https://math.now.sh?inline=v_%7B1%7D%2C%20%5Ccdots%2C%20v_%7Bn%7D" style="display:inline-block;margin: 0;"/> 张成 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/></li>
</ul>
<p>时, 称它们是向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 的<strong>基</strong> (basis)，如果  <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 的一组基含有 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个向量，那么我们称  <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 的**维数 (dimension)**为 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 。</p>
<p>我们称 <img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 的<strong>标准基</strong>为 <img src="https://math.now.sh?inline=%5C%7Be_1%2C%20e_2%2C%20%5Ccdots%2C%20e_n%5C%7D" style="display:inline-block;margin: 0;"/> ，之所以称这个基为标准基，是因为使用这个基表示向量空间  <img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 最为自然。</p>
<p>举个例子， <img src="https://math.now.sh?inline=e_1%2C%20e_2%2C%20e_3" style="display:inline-block;margin: 0;"/> 就是 <img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7B3%7D" style="display:inline-block;margin: 0;"/> 的<strong>标准基</strong>，但是实际上 <img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7B3%7D" style="display:inline-block;margin: 0;"/> 的基有无穷多种取法，比如上面例子中的 <img src="https://math.now.sh?inline=%5Cleft%5C%7B%281%2C1%2C1%29%5E%7B%5Cmathrm%7BT%7D%7D%2C(1%2C1%2C0)%5E%7B%5Cmathrm%7BT%7D%7D%2C(1%2C0%2C0)%5E%7B%5Cmathrm%7BT%7D%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/>  也是 <img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7B3%7D" style="display:inline-block;margin: 0;"/> 的基。</p>
<p>这里定义基时要求线性无关，是因为只有  <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bv%7D_%7B1%7D%2C%20%5Cboldsymbol%7Bv%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cboldsymbol%7Bv%7D_%7Bn%7D" style="display:inline-block;margin: 0;"/>  线性无关时，张集中的向量数目最小，并且向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 才可以<strong>唯一地</strong>用  <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bv%7D_%7B1%7D%2C%20%5Cboldsymbol%7Bv%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cboldsymbol%7Bv%7D_%7Bn%7D" style="display:inline-block;margin: 0;"/> 的 线性组合来表示。反过来说，如果张集的向量之间存在线性相关，那么对于向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/>的每一个向量，你都可以找到张集的多个线性组合来表示这个向量。</p>
<p><strong>定理</strong> 若 <img src="https://math.now.sh?inline=%5Cleft%5C%7Bv_%7B1%7D%2C%20v_%7B2%7D%2C%20%5Ccdots%2C%20v_%7Bn%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> 为向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 的一个张集, 则 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 中的任何 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> ( <img src="https://math.now.sh?inline=m%3En" style="display:inline-block;margin: 0;"/>) 个向量必线性相关.</p>
<p>证 令 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bu%7D_%7B1%7D%2C%20%5Cboldsymbol%7Bu%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cboldsymbol%7Bu%7D_%7Bm%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 中的 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> 个向量, 其中 <img src="https://math.now.sh?inline=m%3En" style="display:inline-block;margin: 0;"/>. 那么, 由于 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bv%7D_%7B1%7D%2C%20%5Cboldsymbol%7Bv%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cboldsymbol%7Bv_%7Bn%7D%7D" style="display:inline-block;margin: 0;"/> 张成 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/>, 我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7Bu%7D_%7Bi%7D%3Da_%7Bi%201%7D%20%5Cboldsymbol%7Bv%7D_%7B1%7D%2Ba_%7Bi%202%7D%20%5Cboldsymbol%7Bv%7D_%7B2%7D%2B%5Ccdots%2Ba_%7Bi%20n%7D%20%5Cboldsymbol%7Bv%7D_%7Bn%7D%2C%20%5Cquad%20i%3D1%2C2%2C%20%5Ccdots%2C%20m%0A" /></p><p>线性组合 <img src="https://math.now.sh?inline=c_%7B1%7D%20%5Cboldsymbol%7Bu%7D_%7B1%7D%2Bc_%7B2%7D%20%5Cboldsymbol%7Bu%7D_%7B2%7D%2B%5Ccdots%2Bc_%7Bm%7D%20%5Cboldsymbol%7Bu%7D_%7Bm%7D" style="display:inline-block;margin: 0;"/> 可写为</p>
<p style=""><img src="https://math.now.sh?from=c_%7B1%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20a_%7B1%20j%7D%20%5Cboldsymbol%7Bv%7D_%7Bj%7D%2Bc_%7B2%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20a_%7B2%20j%7D%20%5Cboldsymbol%7Bv%7D_%7Bj%7D%2B%5Ccdots%2Bc_%7Bm%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20a_%7Bm%20j%7D%20%5Cboldsymbol%7Bv%7D_%7Bj%7D%0A" /></p><p>重新排列各项, 我们看到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ac_%7B1%7D%20%5Cboldsymbol%7Bu%7D_%7B1%7D%2Bc_%7B2%7D%20%5Cboldsymbol%7Bu%7D_%7B2%7D%2B%5Ccdots%2Bc_%7Bm%7D%20%5Cboldsymbol%7Bu%7D_%7Bm%7D%20%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%5Bc_%7Bi%7D%5Cleft%28%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20a_%7Bi%20j%7D%20%5Cboldsymbol%7Bv%7D_%7Bj%7D%5Cright%29%5Cright%5D%20%5C%5C%0A%26%3D%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20a_%7Bi%20j%7D%20c_%7Bi%7D%5Cright)%20%5Cboldsymbol%7Bv%7D_%7Bj%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>现在我们看下面这个方程组</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20a_%7Bi%20j%7D%20c_%7Bi%7D%3D0%2C%20%5Cquad%20j%3D1%2C2%2C%20%5Ccdots%2C%20n%0A" /></p><p>这个齐次方程组的变量个数 (<img src="https://math.now.sh?inline=c_%7Bi%7D" style="display:inline-block;margin: 0;"/> 个数为 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> ) 多于方程个数 ( <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> ). 因此,  方程组必有非平凡解 <img src="https://math.now.sh?inline=%5Cleft%28%5Chat%7Bc%7D_%7B1%7D%2C%20%5Chat%7Bc%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Chat%7Bc%7D_%7Bm%7D%5Cright%29%5E%7B%5Cmathrm%7BT%7D%7D" style="display:inline-block;margin: 0;"/>. 而将其代入到上式中我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7Bc%7D_%7B1%7D%20%5Cboldsymbol%7Bu%7D_%7B1%7D%2B%5Chat%7Bc%7D_%7B2%7D%20%5Cboldsymbol%7Bu%7D_%7B2%7D%2B%5Ccdots%2B%5Chat%7Bc%7D_%7Bm%7D%20%5Cboldsymbol%7Bu%7D_%7Bm%7D%3D%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%200%20%5Cboldsymbol%7Bv%7D_%7Bj%7D%3D%5Cmathbf%7B0%7D%0A" /></p><p>于是 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bu%7D_%7B1%7D%2C%20%5Cboldsymbol%7Bu%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cboldsymbol%7Bu%7D_%7Bm%7D" style="display:inline-block;margin: 0;"/> 为线性相关的。</p>
<p>根据这个定理，我们可以很容易推导出一个向量空间的维数是固定的，也就是说同一个向量空间的不同基的向量数目相同。另外，对于维数为 <img src="https://math.now.sh?inline=n%20%3E%200" style="display:inline-block;margin: 0;"/> 的向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/>，任意 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个线性无关的向量张成 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 。</p>
<h2 id="基变换">基变换</h2>
<p>很多应用问题可以通过从一个坐标转化为另一坐标系而得到简化。<strong>在一个向量空间中转换坐标系，等同于从一组基转换为另外一组基</strong>。</p>
<p>当我们从一组基转换为另一组基时，可以通过将给定的<strong>坐标向量 (coordinate vector) <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/></strong> （定义为由有序基的基向量的长度组成的向量）  左乘一个**非奇异矩阵 <img src="https://math.now.sh?inline=S" style="display:inline-block;margin: 0;"/> **来实现，即新坐标为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%20%3D%20%5Cmathbf%7BS%7D%5Cmathbf%7Bx%7D%0A" /></p><p>我们以最简单也是最常用的情况为例，假如我们希望用一组不同的基替代  <img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 的标准基，我们设新的基</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%5Cmu_%7B1%7D%7D%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A3%20%5C%5C%0A2%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%2C%20%5Cquad%20%0A%5Cmathbf%7B%5Cmu_%7B2%7D%7D%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A1%20%5C%5C%0A1%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>给定一个向量在新的基中的坐标向量为 <img src="https://math.now.sh?inline=%5Bc_%7B1%7D%2C%20c_%7B2%7D%5D" style="display:inline-block;margin: 0;"/> ，我们可以计算得到其在标准基中的坐标</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ac_1%5Cmathbf%7B%5Cmu_1%7D%20%2B%20c_2%5Cmathbf%7B%5Cmu_2%7D%20%26%3D%20c_1%283%5Cmathbf%7Be_1%7D%2B2%5Cmathbf%7Be_2%7D%29%2Bc_2(1%5Cmathbf%7Be_1%7D%2B1%5Cmathbf%7Be_2%7D)%5C%5C%0A%26%3D(3c_1%2Bc_2)%20%5Cmathbf%7Be_1%7D%20%2B%20(2c_1%2Bc_2)%20%5Cmathbf%7Be_2%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>如果令</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BU%7D%3D%20%28%5Cmathbf%7B%5Cmu_1%2C%20%5Cmu_2%7D%29%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A3%20%26%201%20%5C%5C%0A2%20%26%201%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>上面的坐标转换等同于</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bx%7D%20%3D%20%5Cmathbf%7BU%7D%20%5Cmathbf%7Bc%7D%0A" /></p><p>我们称矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D" style="display:inline-block;margin: 0;"/> 为从基 <img src="https://math.now.sh?inline=%5B%5Cmathbf%7B%5Cmu_%7B1%7D%7D%2C%20%5Cmathbf%7B%5Cmu_%7B2%7D%7D%5D" style="display:inline-block;margin: 0;"/> 转换到基  <img src="https://math.now.sh?inline=%5B%5Cmathbf%7Be_%7B1%7D%7D%2C%20%5Cmathbf%7Be_%7B2%7D%7D%5D" style="display:inline-block;margin: 0;"/> 的<strong>转移矩阵 (transition matrix)</strong> ，其为非奇异矩阵，因此反过来有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7Bc%7D%20%3D%20%5Cmathbf%7BU%7D%5E%7B-1%7D%20%5Cmathbf%7Bx%7D%0A" /></p><p>即矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BU%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 为从基 <img src="https://math.now.sh?inline=%5B%5Cmathbf%7Be_%7B1%7D%7D%2C%20%5Cmathbf%7Be_%7B2%7D%7D%5D" style="display:inline-block;margin: 0;"/> 转换到基  <img src="https://math.now.sh?inline=%5B%5Cmathbf%7B%5Cmu_%7B1%7D%7D%2C%20%5Cmathbf%7B%5Cmu_%7B2%7D%7D%5D" style="display:inline-block;margin: 0;"/>  的<strong>转移矩阵 (transition matrix)</strong> 。</p>
<p>我们可以轻松推广多任意两个基的转换，如果我们设两个基为  <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bv%7D_%7B1%7D%2C%20%5Cboldsymbol%7Bv%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cboldsymbol%7Bv%7D_%7Bn%7D" style="display:inline-block;margin: 0;"/> 和  <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D_%7B1%7D%2C%20%5Cboldsymbol%7Bw%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cboldsymbol%7Bw%7D_%7Bn%7D" style="display:inline-block;margin: 0;"/> ，关键在于如何将 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bv%7D" style="display:inline-block;margin: 0;"/> 中的每一个基向量  <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bv_%7Bi%7D%7D" style="display:inline-block;margin: 0;"/> 表示为  <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D_%7B1%7D%2C%20%5Cboldsymbol%7Bw%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cboldsymbol%7Bw%7D_%7Bn%7D" style="display:inline-block;margin: 0;"/> ，然后我们就可以像上面一样构建转移矩阵。</p>
<h2 id="小结">小结</h2>
<p>这里我们看到一种矩阵乘法的情况，当一个非奇异矩阵乘以一组坐标向量时，其本质是基变换。两组基之间的转换是可逆的，二者的转移矩阵互为逆矩阵。</p>
<h1>线性变换</h1>
<p>在向量空间的学习中, 最重要的一类映射为线性变换.<br>
<strong>定义</strong> 一个将向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 映射到向量空间 <img src="https://math.now.sh?inline=W" style="display:inline-block;margin: 0;"/> 的映射 <img src="https://math.now.sh?inline=L" style="display:inline-block;margin: 0;"/>, 如果对所有 <img src="https://math.now.sh?inline=v_%7B1%7D%2C%20v_%7B2%7D%20%5Cin%20V" style="display:inline-block;margin: 0;"/> 及所有的标量 <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cbeta" style="display:inline-block;margin: 0;"/>,</p>
<p style=""><img src="https://math.now.sh?from=L%5Cleft%28%5Calpha%20v_%7B1%7D%2B%5Cbeta%20v_%7B2%7D%5Cright%29%3D%5Calpha%20L%5Cleft(v_%7B1%7D%5Cright)%2B%5Cbeta%20L%5Cleft(v_%7B2%7D%5Cright)%0A" /></p><p>我们将该线性变换标记为：</p>
<p style=""><img src="https://math.now.sh?from=L%3AV%20%5Crightarrow%20W%0A" /></p><p>我们称线性变换 <img src="https://math.now.sh?inline=L%3AV%20%5Crightarrow%20V" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 上的<strong>线性算子 (linear operator)</strong> （翻译成函数或者映射不行吗，非要整一个新名词，算子）。</p>
<p>事实上，我们可以将每一个线性变换均表示为一个矩阵，存在以下定理：</p>
<p><strong>定理</strong> 若 <img src="https://math.now.sh?inline=L" style="display:inline-block;margin: 0;"/> 为一从 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 到 <img src="https://math.now.sh?inline=%5Cmathbf%7BR%7D%5E%7Bm%7D" style="display:inline-block;margin: 0;"/> 的线性变换, 则存在一个 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/>, 使得对 每一 <img src="https://math.now.sh?inline=x%20%5Cin%20%5Cmathbf%7BR%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/>, 有</p>
<p style=""><img src="https://math.now.sh?from=L%28x%29%3DA%20x%0A" /></p><p>事实上, <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 个列向量为</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7Ba%7D_%7Bj%7D%3DL%5Cleft%28%5Cboldsymbol%7Be%7D_%7Bj%7D%5Cright%29%20%5Cquad%20j%3D1%2C2%2C%20%5Ccdots%2C%20n%0A" /></p><p><strong>证明</strong>：</p>
<p>若</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7Bx%7D%3Dx_%7B1%7D%20%5Cboldsymbol%7Be%7D_%7B1%7D%2Bx_%7B2%7D%20%5Cboldsymbol%7Be%7D_%7B2%7D%2B%5Ccdots%2Bx_%7Bn%7D%20%5Cboldsymbol%7Be%7D_%7Bn%7D%0A" /></p><p>为 <img src="https://math.now.sh?inline=%5Cmathrm%7BR%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 中的任意元素, 则</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AL%28%5Cboldsymbol%7Bx%7D%29%20%26%20%3D%20Ax%20%5C%5C%0A%26%3D%5Cleft(%5Cboldsymbol%7Ba%7D_%7B1%7D%2C%20%5Cboldsymbol%7Ba%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Cboldsymbol%7Ba%7D_%7Bn%7D%5Cright)%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0Ax_%7B1%7D%20%5C%5C%0Ax_%7B2%7D%20%5C%5C%0A%5Cvdots%20%5C%5C%0Ax_%7Bn%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%3Dx_%7B1%7D%20%5Cboldsymbol%7Ba%7D_%7B1%7D%2Bx_%7B2%7D%20%5Cboldsymbol%7Ba%7D_%7B2%7D%2B%5Ccdots%2Bx_%7Bn%7D%20%5Cboldsymbol%7Ba%7D_%7Bn%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>易得 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Ba%7D_%7Bj%7D%3DL%5Cleft%28%5Cboldsymbol%7Be%7D_%7Bj%7D%5Cright%29" style="display:inline-block;margin: 0;"/></p>
<p>因此，我们可以通过这个特性对每一个特定的线性变换 <img src="https://math.now.sh?inline=L" style="display:inline-block;margin: 0;"/> 构建矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 。举个例子，定义线性变换 <img src="https://math.now.sh?inline=L%3A%20%5Cmathbb%7BR%7D%5E%7B3%7D%20%5Crightarrow%20%5Cmathbb%7BR%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 为</p>
<p style=""><img src="https://math.now.sh?from=L%28%5Cboldsymbol%7Bx%7D%29%3D%5Cleft(x_%7B1%7D%2Bx_%7B2%7D%2C%20x_%7B2%7D%2Bx_%7B3%7D%5Cright)%5E%7B%5Cmathrm%7BT%7D%7D%0A" /></p><p>容易验证 <img src="https://math.now.sh?inline=L" style="display:inline-block;margin: 0;"/> 为一线性变换. 我们希望求一个矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/>, 使得对每一 <img src="https://math.now.sh?inline=x%20%5Cin%20%5Cmathbf%7BR%7D%5E%7B2%7D%2C%20L%28x%29%3DA%20x" style="display:inline-block;margin: 0;"/>. 用 做到这一点, 我们必须求 <img src="https://math.now.sh?inline=L%5Cleft%28e_%7B1%7D%5Cright%29%2C%20L%5Cleft(e_%7B2%7D%5Cright)" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=L%5Cleft%28e_%7B3%7D%5Cright%29" style="display:inline-block;margin: 0;"/> :</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26L%5Cleft%28%5Cboldsymbol%7Be%7D_%7B1%7D%5Cright%29%3DL%5Cleft((1%2C0%2C0)%5E%7B%5Cmathrm%7BT%7D%7D%5Cright)%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A1%20%5C%5C%0A0%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26L%5Cleft(%5Cboldsymbol%7Be%7D_%7B2%7D%5Cright)%3DL%5Cleft((0%2C1%2C0)%5E%7B%5Cmathrm%7BT%7D%7D%5Cright)%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A1%20%5C%5C%0A1%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26L%5Cleft(%5Cboldsymbol%7Be%7D_%7B3%7D%5Cright)%3DL%5Cleft((0%2C0%2C1)%5E%7B%5Cmathrm%7BT%7D%7D%5Cright)%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A0%20%5C%5C%0A1%0A%5Cend%7Barray%7D%5Cright%5D%0A%5Cend%7Baligned%7D%0A" /></p><p>选择这些向量作为矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的列向量:</p>
<p style=""><img src="https://math.now.sh?from=A%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Blll%7D%0A1%20%26%201%20%26%200%20%5C%5C%0A0%20%26%201%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>为验证结果, 计算 <img src="https://math.now.sh?inline=A%20x" style="display:inline-block;margin: 0;"/>;</p>
<p style=""><img src="https://math.now.sh?from=A%20x%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Blll%7D%0A1%20%26%201%20%26%200%20%5C%5C%0A0%20%26%201%20%26%201%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0Ax_%7B1%7D%20%5C%5C%0Ax_%7B2%7D%20%5C%5C%0Ax_%7B3%7D%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0Ax_%7B1%7D%2Bx_%7B2%7D%20%5C%5C%0Ax_%7B2%7D%2Bx_%7B3%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>我们注意到在线性转换前后的<strong>坐标轴</strong>往往发生了改变，在这个例子中转换之前的坐标轴为</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7Be%7D_%7B1%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A1%20%5C%5C%0A0%20%5C%5C%0A0%0A%5Cend%7Barray%7D%5Cright%5D%2C%0A%5Cboldsymbol%7Be%7D_%7B2%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A0%20%5C%5C%0A1%20%5C%5C%0A0%0A%5Cend%7Barray%7D%5Cright%5D%2C%0A%5Cboldsymbol%7Be%7D_%7B3%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A0%20%5C%5C%0A0%20%5C%5C%0A1%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p>转换之后的坐标轴为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7Be%7D_%7B1%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A1%20%5C%5C%0A0%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%2C%0A%5Cboldsymbol%7Be%7D_%7B2%7D%20%3D%20%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0A0%20%5C%5C%0A1%20%5C%5C%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><h2 id="小结-2">小结</h2>
<p>矩阵乘法 <img src="https://math.now.sh?inline=Ax" style="display:inline-block;margin: 0;"/> 是一个函数，其本质是一个<strong>线性变换</strong>。如果 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 是一个  <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵，那么就对应着一个 <img src="https://math.now.sh?inline=L%3A%5Cmathbb%7BR%7D%5E%7Bn%7D%20%5Crightarrow%20%5Cmathbb%7BR%7D%5E%7Bm%7D" style="display:inline-block;margin: 0;"/> 的线性变换，在线性变换的过程中向量空间发生了改变。</p>
<h1>总结</h1>
<p>一般的矩阵乘法 <img src="https://math.now.sh?inline=y%20%3D%20Ax" style="display:inline-block;margin: 0;"/> 对应着一个线性变换，一般来说这种线性变换不可逆，也就是一般找不到逆函数。</p>
<p>但是存在一种特殊情况，当 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 是一个<strong>非奇异矩阵</strong>时，此时  <img src="https://math.now.sh?inline=y%20%3D%20Ax" style="display:inline-block;margin: 0;"/>  可以理解为基变换，即在两个坐标系中转换坐标，此时的线性变换可逆。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">《Linear Algebra with Applications》 Ninth Edition<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.matongxue.com/madocs/555/">如何理解矩阵乘法？- 马同学</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>python批量下载url</title>
    <url>/posts/3290d880/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今天需要从网上批量下载文件，如果手动下载需要频繁点击很烦人，尝试用 python 批量下载。</p>
<span id="more"></span>
<h1>问题描述</h1>
<p>我要下载的东西，网址都是很有规律的，就是其中的一个数字发生改变而已。手动一个一个点击很烦，就从网上搜索了一下，目前只找到了一种可行的方案<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://blog.csdn.net/sinat_38682860/article/details/114438555">[1]</span></a></sup>。</p>
<p>很多别的方式我试了不行，但我也不太清楚为什么不行，比如这个 requests 包。</p>
<h1>wget 包</h1>
<p>首先用 pip 安装这个包，之后的脚本如下。</p>
<p>实际下载的密码只有一行 <code>wget.download(url, path)</code> ，只有两个参数，第一个是网址，第二个是存放路径。如果下载网址有规律的话，使用一个 for 循环就能批量下载了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 批量下载 pdf</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> wget</span><br><span class="line"></span><br><span class="line">path = <span class="string">&#x27;D:\Desktop&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">20</span>):</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">10</span>:</span><br><span class="line">        new_i = <span class="string">&quot;0&quot;</span>+<span class="built_in">str</span>(i) <span class="comment"># 如果是单个数字，前面加零</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new_i = <span class="built_in">str</span>(i)</span><br><span class="line">      </span><br><span class="line">    url = <span class="string">f&#x27;https://see.stanford.edu/materials/lsocoee364a/transcripts/ConvexOptimizationI-Lecture<span class="subst">&#123;new_i&#125;</span>.pdf&#x27;</span></span><br><span class="line">    wget.download(url, path)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://blog.csdn.net/sinat_38682860/article/details/114438555<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>正定矩阵都是对称矩阵吗</title>
    <url>/posts/37a2cb0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>正定矩阵的概念来自于二次型，在定义正定矩阵时，就已经明确了<strong>正定矩阵是 Hermitian 矩阵的一种</strong> (对于实数矩阵，就是指对称矩阵)。</p>
<span id="more"></span>
<h1>矩阵的二次型</h1>
<p>下面的内容来自于张贤达老师的《矩阵分析与应用》书中。</p>
<p>任意一个<strong>方阵</strong> <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 的二次型定义为 <img src="https://math.now.sh?inline=x%5E%7B%5Cmathrm%7BH%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D" style="display:inline-block;margin: 0;"/>, 其中 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D" style="display:inline-block;margin: 0;"/> 可以是任意的<strong>非零复向量</strong>。 以实矩阵为例, 考查二次型</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%20%26%3D%5Cleft%5Bx_%7B1%7D%2C%20x_%7B2%7D%2C%20x_%7B3%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D%0A1%20%26%204%20%26%202%20%5C%5C%0A-1%20%26%207%20%26%205%20%5C%5C%0A-1%20%26%206%20%26%203%0A%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bl%7D%0Ax_%7B1%7D%20%5C%5C%0Ax_%7B2%7D%20%5C%5C%0Ax_%7B3%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%3Dx_%7B1%7D%5E%7B2%7D%2B7%20x_%7B2%7D%5E%7B2%7D%2B3%20x_%7B3%7D%5E%7B2%7D%2B3%20x_%7B1%7D%20x_%7B2%7D%2Bx_%7B1%7D%20x_%7B3%7D%2B11%20x_%7B2%7D%20x_%7B3%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>这是变元 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 的二次型函数, 故称 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D" style="display:inline-block;margin: 0;"/> 为矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 的二次型。<br>
推而广之, 若 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%3D%5Cleft%5Bx_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bn%7D%5Cright%5D%5E%7B%5Cmathrm%7BT%7D%7D" style="display:inline-block;margin: 0;"/>, 且 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 的元素为 <img src="https://math.now.sh?inline=a_%7Bi%20j%7D" style="display:inline-block;margin: 0;"/>, 则二次型</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%20%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20x_%7Bi%7D%20x_%7Bj%7D%20a_%7Bi%20j%7D%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20a_%7Bi%20i%7D%20x_%7Bi%7D%5E%7B2%7D%2B%5Csum_%7Bi%3D1%2C%20i%20%5Cneq%20j%7D%5E%7Bn%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20a_%7Bi%20j%7D%20x_%7Bi%7D%20x_%7Bj%7D%20%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20a_%7Bi%20i%7D%20x_%7Bi%7D%5E%7B2%7D%2B%5Csum_%7Bi%3D1%7D%5E%7Bn-1%7D%20%5Csum_%7Bj%3Di%2B1%7D%5E%7Bn%7D%5Cleft%28a_%7Bi%20j%7D%2Ba_%7Bj%20i%7D%5Cright%29%20x_%7Bi%7D%20x_%7Bj%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>根据这一公式, 显然</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cboldsymbol%7BA%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Brrr%7D%0A1%20%26%204%20%26%202%20%5C%5C%0A-1%20%26%207%20%26%205%20%5C%5C%0A-1%20%26%206%20%26%203%0A%5Cend%7Barray%7D%5Cright%5D%2C%20%5Cquad%20%5Cboldsymbol%7BB%7D%3D%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Brrr%7D%0A1%20%26%20-1%20%26%20-1%20%5C%5C%0A4%20%26%207%20%26%206%20%5C%5C%0A2%20%26%205%20%26%203%0A%5Cend%7Barray%7D%5Cright%5D%2C%20%5Cquad%20%5Cboldsymbol%7BC%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Blll%7D%0A1.0%20%26%201.5%20%26%200.5%20%5C%5C%0A1.5%20%26%207.0%20%26%205.5%20%5C%5C%0A0.5%20%26%205.5%20%26%203.0%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%5Cboldsymbol%7BD%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Brrr%7D%0A1%20%26%20114%20%26%2052%20%5C%5C%0A-111%20%26%207%20%26%202%20%5C%5C%0A-51%20%26%209%20%26%203%0A%5Cend%7Barray%7D%5Cright%5D%2C%20%5Cquad%20%5Cboldsymbol%7BF%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Brrr%7D%0A1%20%26%20114%20%26%2052%20%5C%5C%0A-111%20%26%207%20%26%204%20%5C%5C%0A-51%20%26%207%20%26%203%0A%5Cend%7Barray%7D%5Cright%5D%2C%20%5Cquad%20%5Ccdots%0A%5Cend%7Baligned%7D%0A" /></p><p>具有相同的二次型, 即</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%20%26%3D%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BB%7D%20%5Cboldsymbol%7Bx%7D%3D%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BC%7D%20%5Cboldsymbol%7Bx%7D%3D%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BD%7D%20%5Cboldsymbol%7Bx%7D%3D%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BF%7D%20%5Cboldsymbol%7Bx%7D%20%5C%5C%0A%26%3Dx_%7B1%7D%5E%7B2%7D%2B7%20x_%7B2%7D%5E%7B2%7D%2B3%20x_%7B3%7D%5E%7B2%7D%2B3%20x_%7B1%7D%20x_%7B2%7D%2Bx_%7B1%7D%20x_%7B3%7D%2B11%20x_%7B2%7D%20x_%7B3%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>这就是说, 对于任何一个二次型函数</p>
<p style=""><img src="https://math.now.sh?from=f%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bn%7D%5Cright%29%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Calpha_%7Bi%20i%7D%20x_%7Bi%7D%5E%7B2%7D%2B%5Csum_%7Bi%3D1%2C%20i%20%5Cneq%20j%7D%5E%7Bn%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20%5Calpha_%7Bi%20j%7D%20x_%7Bi%7D%20x_%7Bj%7D%0A" /></p><p>而言, 存在许多矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/>, 它们的二次型 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%3Df%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bn%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 相同。但是, 只有<strong>一个唯一的对称矩阵</strong> <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 满足 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%3Df%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bn%7D%5Cright%29" style="display:inline-block;margin: 0;"/>, 其元素为 <img src="https://math.now.sh?inline=a_%7Bi%20j%7D%3Da_%7Bj%20i%7D%3D%5Cfrac%7B1%7D%7B2%7D%5Cleft%28%5Calpha_%7Bi%20j%7D%2B%5Calpha_%7Bj%20i%7D%5Cright%29" style="display:inline-block;margin: 0;"/>, 其 中, <img src="https://math.now.sh?inline=i%3D1%2C%20%5Ccdots%2C%20n%2C%20j%3D1%2C%20%5Ccdots%2C%20n" style="display:inline-block;margin: 0;"/> 。因此, 为了保证定义的唯一性, <strong>在讨论矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 的二次型 时, 有必要假定 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 为实对称矩阵或复共轭对称 (即 Hermitian) 矩阵</strong>。</p>
<p>因此，在二次型的概念中，我们不严格要求矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 为实对称矩阵或复共轭对称 (即 Hermitian) 矩阵，仅仅要求 其为方阵，但是通常我们还是假定其为实对称矩阵或复共轭对称 (即 Hermitian) 矩阵。</p>
<h1>正定矩阵定义</h1>
<p>下面这几段话来自于维基百科<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://www.wikiwand.com/zh/%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5
">[1]</span></a></sup>。</p>
<blockquote>
<p>在线性代数裡，正定矩阵 (英語: positive-definite matrix) 是<strong>埃尔米特矩阵</strong>的一种，有时会简称为正定阵。在线性代数中，正定矩阵的性质類似复数中的正实数。</p>
<p>一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的<strong>实对称矩阵</strong> <img src="https://math.now.sh?inline=M" style="display:inline-block;margin: 0;"/> 是正定的，当且仅当对于所有的非零实系数向量 <img src="https://math.now.sh?inline=z" style="display:inline-block;margin: 0;"/> ，都有 <img src="https://math.now.sh?inline=z%5E%7B%5Cmathrm%7BT%7D%7D%20M%20z%3E0" style="display:inline-block;margin: 0;"/> 。其 中 <img src="https://math.now.sh?inline=z%5E%7B%5Ctop%7D" style="display:inline-block;margin: 0;"/> 表示 <img src="https://math.now.sh?inline=z" style="display:inline-block;margin: 0;"/> 的转置。<br>
对于复数的情况，定义则为: 一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的埃尔米特矩阵(或厄米矩阵) <img src="https://math.now.sh?inline=M" style="display:inline-block;margin: 0;"/> 是正定的当且仅当对于每个非零的禎向量 <img src="https://math.now.sh?inline=Z" style="display:inline-block;margin: 0;"/> ，都有 <img src="https://math.now.sh?inline=z%5E%7B*%7D%20M%20z%3E0" style="display:inline-block;margin: 0;"/> 。其中 <img src="https://math.now.sh?inline=z%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 表示 <img src="https://math.now.sh?inline=Z" style="display:inline-block;margin: 0;"/> 的共轭转置。由于 <img src="https://math.now.sh?inline=M" style="display:inline-block;margin: 0;"/> 是埃尔米特矩阵，经计算可知，对于任意的複向量 <img src="https://math.now.sh?inline=z%20%EF%BC%8C%20z%5E%7B*%7D%20M%20z" style="display:inline-block;margin: 0;"/> 必然是实数，从而可以与比较大小。因此这个定义是自洽的。</p>
</blockquote>
<p>我们可以看到，对于实数矩阵而言，正定矩阵定义时就要求其为<strong>对称矩阵</strong>。</p>
<h1>非埃尔米特矩阵的情况</h1>
<p>下面这段话主要来自于维基百科<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://www.wikiwand.com/zh/%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5
">[1]</span></a></sup>。</p>
<blockquote>
<p>如果一个非对称的实数矩阵<strong>M</strong>满足对所有非零实向量 <em>x</em>，有 <img src="https://math.now.sh?inline=x%5E%7BT%7DMx%20%3E%200" style="display:inline-block;margin: 0;"/> ，当且仅当对称矩阵 <img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7B2%7D%20%28M%20%2B%20M%5E%7BT%7D%29" style="display:inline-block;margin: 0;"/> 是正定矩阵。</p>
<p>对于复系数矩阵，情况可能不太一样。主要看的是怎样扩展 <img src="https://math.now.sh?inline=z%5E%7B*%7D%20%5Cmathbf%7BM%7D%20z%3E0" style="display:inline-block;margin: 0;"/> 这一性质。要使 <img src="https://math.now.sh?inline=z%5E%7B*%7D%20%5Cmathbf%7BM%7D%20z" style="display:inline-block;margin: 0;"/> 总为实数，矩阵 <img src="https://math.now.sh?inline=M" style="display:inline-block;margin: 0;"/> 必须是埃尔米特矩阵。因此，若 <img src="https://math.now.sh?inline=Z%5E%7B*%7D%20M%20Z" style="display:inline-block;margin: 0;"/> 总是正实数， <img src="https://math.now.sh?inline=M" style="display:inline-block;margin: 0;"/> 必然是正定的埃尔米特矩 阵。如果将 <img src="https://math.now.sh?inline=z%5E%7B*%7D%20%5Cmathbf%7BM%7D%20z%3E0" style="display:inline-block;margin: 0;"/> 扩展为 <img src="https://math.now.sh?inline=%5Coperatorname%7BRe%7D%5Cleft%28z%5E%7B*%7D%20%5Cmathbf%7BM%7D%20z%5Cright%29%3E0" style="display:inline-block;margin: 0;"/> ，则等价于 <img src="https://math.now.sh?inline=%5Cleft%28%5Cmathbf%7BM%7D%2B%5Cmathbf%7BM%7D%5E%7B*%7D%5Cright%29%20%2F%202" style="display:inline-block;margin: 0;"/> 为正定阵。</p>
</blockquote>
<p>然后从知乎找到了一个回答<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label=" 正定矩阵一定是对称阵吗？ - 益者三友的回答 - 知乎 https://www.zhihu.com/question/66922790/answer/1463342936">[2]</span></a></sup>。其证明了一个非对称的实数矩阵<img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的二次型等于对称矩阵 <img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7B2%7D%28A%20%2B%20A%5E%7BT%7D%29" style="display:inline-block;margin: 0;"/> 的二次型。</p>
<p>对于任何一个方阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> ，我们都可以将其分解为：</p>
<p style=""><img src="https://math.now.sh?from=A%20%3D%20%5Cfrac%7B1%7D%7B2%7D%28A%20%2B%20A%5E%7BT%7D%29%20%2B%20%5Cfrac%7B1%7D%7B2%7D(A%20-%20A%5E%7BT%7D)%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7B2%7D%28A%20%2B%20A%5E%7BT%7D%29" style="display:inline-block;margin: 0;"/> 是对称矩阵，前面已经提到了。后面 <img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7B2%7D%28A%20-%20A%5E%7BT%7D%29" style="display:inline-block;margin: 0;"/> 为反对称矩阵，下面来证明</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%28A-A%5E%7BT%7D%29_%7Bij%7D%20%26%3D%20A_%7Bij%7D-A%7Bji%7D%5C%5C%0A(A-A%5E%7BT%7D)_%7Bji%7D%20%26%3D%20A_%7Bji%7D-A%7Bij%7D%5C%5C%0A%5Ctherefore%20(A-A%5E%7BT%7D)_%7Bij%7D%20%26%3D%20-%20(A-A%5E%7BT%7D)_%7Bji%7D%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，易得 <img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7B2%7D%28A%20-%20A%5E%7BT%7D%29" style="display:inline-block;margin: 0;"/> 的二次型为 0 。方阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的二次型为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ax%5E%7BT%7DAx%20%26%3D%20x%5E%7BT%7D%28%5Cfrac%7B1%7D%7B2%7D(A%20%2B%20A%5E%7BT%7D%29%20%2B%20%5Cfrac%7B1%7D%7B2%7D(A%20-%20A%5E%7BT%7D))x%20%5C%5C%0A%26%20%3D%20%20x%5E%7BT%7D(%5Cfrac%7B1%7D%7B2%7D(A%20%2B%20A%5E%7BT%7D)%20)x%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，从个人理解来说，由于所有非对称方阵的二次型均可以转化为对称方阵，再加上对称矩阵的诸多优良性质，那就不如直接将正定矩阵定义在对称矩阵的基础上。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://www.wikiwand.com/zh/%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">正定矩阵一定是对称阵吗？ - 益者三友的回答 - 知乎 https://www.zhihu.com/question/66922790/answer/1463342936<a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>证明AB的秩小于等于A的秩</title>
    <url>/posts/6c72beb0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>矩阵秩的性质的证明比较少，看到了一个很好的回答，简单地记录一下。</p>
<p>本文内容基本来自于 <a href="https://yutsumura.com/rank-of-the-product-of-matrices-ab-is-less-than-or-equal-to-the-rank-of-a/">Rank of the Product of Matrices ABAB is Less than or Equal to the Rank of A</a> ，感兴趣的可以自己去看一下。</p>
<span id="more"></span>
<h1>问题</h1>
<p>如果 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵，<img src="https://math.now.sh?inline=B" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20q" style="display:inline-block;margin: 0;"/> 的矩阵，证明下面两个性质：</p>
<p>(a) <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28A%20B%29%20%5Cleq%20%5Coperatorname%7Brank%7D(A)" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28A%20B%29%20%5Cleq%20%5Coperatorname%7Brank%7D(B)" style="display:inline-block;margin: 0;"/></p>
<p>(b) 如果 <img src="https://math.now.sh?inline=B" style="display:inline-block;margin: 0;"/> 非奇异，<img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28A%20B%29%20%3D%20%5Coperatorname%7Brank%7D(A)" style="display:inline-block;margin: 0;"/></p>
<p>解决这个问题前，首先我们要先看看矩阵<strong>列空间</strong>的定义和性质。</p>
<h1>矩阵的列空间</h1>
<p>下面这段话来自于吴恩达老师 CS229 课程的讲义。</p>
<p>一个向量集合的<strong>张成空间 (span)</strong> 定义为这些向量的线性组合，即为：</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Bspan%7D%5Cleft%28%5Cleft%5C%7Bx_%7B1%7D%2C%20%5Cldots%20x_%7Bn%7D%5Cright%5C%7D%5Cright%29%3D%5Cleft%5C%7Bv%3A%20v%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Calpha_%7Bi%7D%20x_%7Bi%7D%2C%20%5Calpha_%7Bi%7D%20%5Cin%20%5Cmathbb%7BR%7D%5Cright%5C%7D%0A" /></p><p>如果 <img src="https://math.now.sh?inline=%5Cleft%5C%7Bx_%7B1%7D%2C%20%5Cldots%2C%20x_%7Bn%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 个线性无关的向量，那么其张成空间就是 <img src="https://math.now.sh?inline=%5Cmathbb%7BR%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>一个向量 <img src="https://math.now.sh?inline=y%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bm%7D" style="display:inline-block;margin: 0;"/> 在 <img src="https://math.now.sh?inline=%5Cleft%5C%7Bx_%7B1%7D%2C%20%5Cldots%2C%20x_%7Bn%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/> 的张成空间的<strong>投影 (projection)</strong> ，定义为在张成空间中与 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 距离最近的一个点 (向量)，写作：</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BProj%7D%5Cleft%28y%20%3B%5Cleft%5C%7Bx_%7B1%7D%2C%20%5Cldots%20x_%7Bn%7D%5Cright%5C%7D%5Cright%29%3D%5Coperatorname%7Bargmin%7D_%7Bv%20%5Cin%20%5Coperatorname%7Bspan%7D%5Cleft(%5Cleft%5C%7Bx_%7B1%7D%2C%20%5Cldots%2C%20x_%7Bn%7D%5Cright%5C%7D%5Cright)%7D%5C%7Cy-v%5C%7C_%7B2%7D%0A" /></p><p>一个矩阵 <img src="https://math.now.sh?inline=A%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bm%20%5Ctimes%20n%7D" style="display:inline-block;margin: 0;"/> 的<strong>列空间 (range, column space)</strong> 是它的列张成的空间，即为 <img src="https://math.now.sh?inline=%5Cmathcal%7BR%7D%28A%29" style="display:inline-block;margin: 0;"/> （好像也有人写作 <img src="https://math.now.sh?inline=C%28A%29" style="display:inline-block;margin: 0;"/>  或 <img src="https://math.now.sh?inline=Col%28A%29" style="display:inline-block;margin: 0;"/> ），即：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathcal%7BR%7D%28A%29%3D%5Cleft%5C%7Bv%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bm%7D%3A%20v%3DA%20x%2C%20x%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bn%7D%5Cright%5C%7D%0A" /></p><p>为什么可以写成 <img src="https://math.now.sh?inline=Ax" style="display:inline-block;margin: 0;"/> 呢，我们可以将 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 写成列向量的形式，得到下式，因此  <img src="https://math.now.sh?inline=Ax" style="display:inline-block;margin: 0;"/> 就是 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的列的张成空间。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AA%20x%20%26%3D%5Cleft%5Ba_%7B1%7D%20a_%7B2%7D%20%5Ccdots%20a_%7Bn%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0Ax_%7B1%7D%20%5C%5C%0A%5Cvdots%20%5C%5C%0Ax_%7Bn%7D%0A%5Cend%7Barray%7D%5Cright%5D%20%5C%5C%0A%26%3Dx_%7B1%7D%20a_%7B1%7D%2Bx_%7B2%7D%20a_%7B2%7D%2B%5Ccdots%2Bx_%7Bn%7D%20a_%7Bn%7D%0A%5Cend%7Baligned%7D%0A" /></p><h2 id="列空间的维度">列空间的维度</h2>
<p>矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的列空间的维度等于矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的秩，即存在</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Bdim%7D%20%5Cmathcal%7BR%7D%28%5Cmathbf%7BA%7D%29%3D%5Coperatorname%7Brank%7D(%5Cmathbf%7BA%7D)%0A" /></p><p>这个很好证明，假设矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 有 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 个线性无关的列，即 <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28%5Cmathbf%7BA%7D%29%20%3D%20k" style="display:inline-block;margin: 0;"/> ，那么矩阵  <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的所有列张成的空间就是其 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 个线性无关的列张成的空间（因为其他列都是这 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 列的线性组合），而  <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 个线性无关的列的张成空间的维度就是 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> ，即  <img src="https://math.now.sh?inline=%5Coperatorname%7Bdim%7D%20%5Cmathcal%7BR%7D%28%5Cmathbf%7BA%7D%29%3D%20k" style="display:inline-block;margin: 0;"/> ，因此得证矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的列空间的维度等于矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的秩。</p>
<h1>证明 AB 的秩小于等于 A</h1>
<p>根据列空间的性质，我们有：</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Brank%7D%28A%20B%29%3D%5Coperatorname%7Bdim%7D(%5Cmathcal%7BR%7D(A%20B))%2C%20%5Cquad%20%5Coperatorname%7Brank%7D(A)%3D%5Coperatorname%7Bdim%7D(%5Cmathcal%7BR%7D(A))%0A" /></p><p>我们知道，如果一个向量空间 <img src="https://math.now.sh?inline=V" style="display:inline-block;margin: 0;"/> 是向量空间 <img src="https://math.now.sh?inline=W" style="display:inline-block;margin: 0;"/> 的子空间，那么必然存在：</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Bdim%7D%28V%29%20%5Cleq%20%5Coperatorname%7Bdim%7D(W)%0A" /></p><p>因此，我们只需要证明 <img src="https://math.now.sh?inline=%5Cmathcal%7BR%7D%28A%20B%29" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathcal%7BR%7D%28A%29" style="display:inline-block;margin: 0;"/> 的子空间即可。</p>
<p>现在假定对于任意一个向量 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%20%5Cin%20%5Cmathcal%7BR%7D%28A%20B%29" style="display:inline-block;margin: 0;"/> ，因此存在一个相应的 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D%20%5Cin%20R%5E%7Bq%7D" style="display:inline-block;margin: 0;"/>，使得  <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%28A%20B%29%20%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> ，以符合列空间的定义。</p>
<p>此时，我们设 <img src="https://math.now.sh?inline=%5Cmathbf%7Bz%7D%3DB%20%5Cmathbf%7Bx%7D%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bn%7D" style="display:inline-block;margin: 0;"/> ，因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%3DA%28B%20%5Cmathbf%7Bx%7D%29%3DA%20%5Cmathbf%7Bz%7D%0A" /></p><p>因此， <img src="https://math.now.sh?inline=%5Cmathcal%7BR%7D%28AB%29" style="display:inline-block;margin: 0;"/> 中的任何一个向量 <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 均同样在  <img src="https://math.now.sh?inline=%5Cmathcal%7BR%7D%28A%29" style="display:inline-block;margin: 0;"/> 中，也就是说， <img src="https://math.now.sh?inline=%5Cmathcal%7BR%7D%28AB%29" style="display:inline-block;margin: 0;"/> 是  <img src="https://math.now.sh?inline=%5Cmathcal%7BR%7D%28A%29" style="display:inline-block;margin: 0;"/> 的一个子空间，因此，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Brank%7D%28A%20B%29%3D%5Coperatorname%7Bdim%7D(%5Cmathcal%7BR%7D(A%20B))%20%5Cleq%20%5Coperatorname%7Bdim%7D(%5Cmathcal%7BR%7D(A))%3D%5Coperatorname%7Brank%7D(A)%0A" /></p><p>得证。</p>
<h1>证明 AB 的秩小于等于 B</h1>
<p>首先，我们知道矩阵的转置与原矩阵的秩相同（矩阵线性无关的列数=线性无关的行数）。因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Brank%7D%28AB%29%20%26%3D%20%5Coperatorname%7Brank%7D(B%5E%7BT%7DA%5E%7BT%7D)%20%5C%5C%0A%26%20%5Cleq%20%5Coperatorname%7Brank%7D(B%5E%7BT%7D)%20%5C%5C%0A%26%20%3D%20%5Coperatorname%7Brank%7D(B)%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>这里第二行采用了上面的结论，AB 的秩小于等于 A。</p>
<p>因此，我们得证 <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28A%20B%29%20%5Cleq%20%5Coperatorname%7Brank%7D(B)" style="display:inline-block;margin: 0;"/> ，联合这两个性质，则有</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Brank%7D%28A%20B%29%20%5Cleq%20%5Cmin%5C%7B%5Coperatorname%7Brank%7D(A)%2C%5Coperatorname%7Brank%7D(B)%5C%7D%0A" /></p><h1>证明如果 B​ 非奇异, AB 的秩等于 A</h1>
<p>我们已知 <img src="https://math.now.sh?inline=%5Coperatorname%7Brank%7D%28A%20B%29%20%5Cleq%20%5Coperatorname%7Brank%7D(A)" style="display:inline-block;margin: 0;"/> ，因此存在：</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Brank%7D%5Cleft%28(A%20B%29%20B%5E%7B-1%7D%5Cright)%20%5Cleq%20%5Coperatorname%7Brank%7D(A%20B)%0A" /></p><p>再采用这个性质，因此我们有：</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Brank%7D%28A%29%3D%5Coperatorname%7Brank%7D%5Cleft((A%20B)%20B%5E%7B-1%7D%5Cright)%20%5Cleq%20%5Coperatorname%7Brank%7D(A%20B)%20%5Cleq%20%5Coperatorname%7Brank%7D(A)%0A" /></p><p>如果一系列不等式的两头相等，那么中间的所有不等式就一定为等式，因此此时，我们有：</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Brank%7D%28A%20B%29%20%3D%20%5Coperatorname%7Brank%7D(A)%0A" /></p><h1>闲话</h1>
<p>从这个帖子的网站主页来看，这个网站貌似就是解决数学问题的，或者证明数学公式的，有时间可以看看，网址见下方。</p>
<p><a href="https://yutsumura.com/">https://yutsumura.com/</a></p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>计算trios的孟德尔错误率</title>
    <url>/posts/7bc46342/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>当系谱中个体-父-母三者均有基因型时，计算该trios的孟德尔错误率。</p>
<span id="more"></span>
<h1>原理简介</h1>
<p>上一篇见 <a href="https://vincere.fun/posts/42752926/">基于芯片数据的亲子鉴定分析代码</a></p>
<p>原理非常简单，就是孟德尔定律，之前只是针对亲子两个个体之间统计孟德尔错误位点，现在这个程序就是计算父母子三者之间不符合孟德尔定理的位点数目和比例，举个例子，如果父母的基因型都是 AA，子代基因型只要不是 AA ，就算一个孟德尔错误位点。</p>
<p>但是想要<strong>快速</strong>统计trios的孟德尔错误位点并不容易，假设父母子在某个位点均不为缺失，那么父母子总共可能的基因型情况有 18 种（不区分两个亲本），其中不符合孟德尔定律的有 8 种情况，那么我们怎么快速统计孟德尔错误位点总数呢？</p>
<p>下表为trios所有基因型情况的统计（这里设 1 和 3 为两种纯和子，2 为杂合子）。</p>
<table>
<thead>
<tr>
<th>亲本1</th>
<th>亲本1</th>
<th>符合孟德尔定律的后代基因型</th>
<th>违背孟德尔定律的后代基因型</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2,3</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>1,2</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>2</td>
<td>1,3</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>1,2,3</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>2,3</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>3</td>
<td>1,2</td>
</tr>
</tbody>
</table>
<p>根据我之前的做法，我是通过亲子对基因型的乘积来判断这个位点是否为孟德尔错误位点，这里我同样沿用了这种做法。</p>
<p>首先将后代/个体的基因型编码改为从 1 2 3 分别改为 5 7 8，亲本基因型编码不变，此时 trios所有基因型情况和 trios 基因型乘积情况见下表。</p>
<table>
<thead>
<tr>
<th>亲本1</th>
<th>亲本2</th>
<th>符合孟德尔定律的后代基因型</th>
<th>违背孟德尔定律的后代基因型</th>
<th>符合孟德尔定律的trios基因型乘积</th>
<th>违背孟德尔定律的trios基因型乘积</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>5</td>
<td>7,8</td>
<td>5</td>
<td>7,8</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>5,7</td>
<td>8</td>
<td>10,14</td>
<td>16</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>7</td>
<td>5,8</td>
<td>21</td>
<td>15,24</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>5,7,8</td>
<td>-</td>
<td>20,28,32</td>
<td>-</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>7,8</td>
<td>5</td>
<td>42,48</td>
<td>30</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>8</td>
<td>5,7</td>
<td>72</td>
<td>45,63</td>
</tr>
</tbody>
</table>
<p>我们发现，此时符合孟德尔定律的 trios 基因型乘积和 违背孟德尔定律的 trios 基因型乘积之间<strong>没有重叠的数字</strong>，然后你就同样可以直接根据<strong>trios 基因型的乘积</strong>来判断该位点是否符合孟德尔定律。此时，8 种违背孟德尔定律的基因型情况对应的基因型乘积为 <img src="https://math.now.sh?inline=%5C%7B7%2C8%2C15%2C16%2C24%2C30%2C45%2C63%5C%7D" style="display:inline-block;margin: 0;"/> 。</p>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么GCTA做PCA分析是对G阵进行特征值分解</title>
    <url>/posts/1e12f93e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在机器学习中，进行PCA分析时都是说对<strong>特征的协方差矩阵</strong> <img src="https://math.now.sh?inline=%5CSigma" style="display:inline-block;margin: 0;"/> 进行特征值分解，得到特征向量 <img src="https://math.now.sh?inline=%5Cleft%5C%7Bw_%7B1%7D%2C%20w_%7B2%7D%2C%20%5Cldots%2C%20w_%7Bn%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/>  后，再利用特征向量与特征的内积，计算样本点的新坐标 <img src="https://math.now.sh?inline=z" style="display:inline-block;margin: 0;"/>（<strong>主成分</strong>）。</p>
<p>但是在我们对基因型数据进行PCA分析时，我们使用的常规软件 (例如plink 和 GCTA)，其算法都是对<strong>G阵</strong>(可以理解为样本的协方差矩阵)进行特征值分解，然后得到的特征向量直接就是主成分。这里主要以 GCTA 文章为例，推导这种做法的合理性。</p>
<p>建议先看上一篇 <a href="https://vincere.fun/posts/fc532062/">PCA分析公式推导</a></p>
<span id="more"></span> 
<h1>GCTA算法<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="GCTA: A Tool for Genome-wide Complex Trait Analysis">[1]</span></a></sup></h1>
<p>这里我稍微改了一些文章中使用的符号，为了与我之前的符号习惯，或者说吴老师的符号习惯一致。</p>
<h2 id="构建G阵">构建G阵</h2>
<p>假设我们使用混合线性模型如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%3D%5Cmathbf%7BK%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cmathbf%7BX%7D%20%5Cmathbf%7Bu%7D%2B%5Cvarepsilon%20%5Ctext%20%7B%20with%20%7D%20%5Coperatorname%7Bvar%7D%28%5Cmathbf%7By%7D%29%3D%5Cmathbf%7BV%7D%3D%5Cmathbf%7BX%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Csigma_%7B%5Cmathrm%7Bu%7D%7D%5E%7B2%7D%2B%5Cmathbf%7BI%7D%20%5Csigma_%7B%5Cvarepsilon%7D%5E%7B2%7D%2C%0A" /></p><p><img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=m%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 的表型向量，<img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 为表型数目。<img src="https://math.now.sh?inline=%5Cmathbf%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 为固定效应，如PCA的主成分;  <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D" style="display:inline-block;margin: 0;"/> 为相应的设计矩阵。<img src="https://math.now.sh?inline=%5Cmu" style="display:inline-block;margin: 0;"/> 为  <img src="https://math.now.sh?inline=n%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 的SNP 效应向量（<img src="https://math.now.sh?inline=n" style="display:inline-block;margin: 0;"/> 为SNP数目，也就是机器学习的特征数目），为随机效应，服从分布 <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D%20%5Csim%20N%5Cleft%280%2C%20%5Cmathbf%7BI%7D%20%5Csigma_%7B%5Cmathrm%7Bu%7D%7D%5E%7B2%7D%5Cright%29" style="display:inline-block;margin: 0;"/> ；<img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 为相应的设计矩阵。</p>
<p>这里着重说一下 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵，其维度为 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> ，也就是说一行表示一个样本，一列是一个SNP（文章里存在一处笔误，对这个矩阵行和列说反了）。这个矩阵的构建分为两步:</p>
<ol>
<li>我们统计每个SNP中指定碱基（文章中指定是<code>reference allele</code>，但这一点无所谓）的数目，作为中间矩阵的元素，此时这个矩阵元素只可能是0,1和 2 ；</li>
<li>我们对上面这个矩阵的每一列（SNP）进行<strong>标准化</strong> ，便得到了   <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵。</li>
</ol>
<p>这里我们假设第一步构建的中间矩阵为  <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D" style="display:inline-block;margin: 0;"/>， 则  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵的元素 <img src="https://math.now.sh?inline=x_%7Bi%20j%7D%3D%5Cleft%28m_%7Bi%20j%7D-2%20p_%7Bj%7D%5Cright%29%2F%5Csqrt%7B2%20p_%7Bj%7D%5Cleft(1-p_%7Bj%7D%5Cright)%7D" style="display:inline-block;margin: 0;"/> ，这里 <img src="https://math.now.sh?inline=p_%7Bj%7D" style="display:inline-block;margin: 0;"/> 为第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 列 SNP 指定碱基的基因频率。也就是说，这里设第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 列 SNP的均值为 <img src="https://math.now.sh?inline=2p_%7Bj%7D" style="display:inline-block;margin: 0;"/> ，其方差为 <img src="https://math.now.sh?inline=2p_%7Bj%7D%281-p_%7Bj%7D%29" style="display:inline-block;margin: 0;"/> ，下面开始证明这两点。</p>
<p>我们设第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 列 SNP中0,1,2三种基因型在样本中出现的频率分别为 <img src="https://math.now.sh?inline=a%2Cb%2Cc" style="display:inline-block;margin: 0;"/> ，因此我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26a%2Bb%2Bc%3D1%20%5C%5C%0A%26%5Cfrac%7B1%7D%7B2%7D%20b%2Bc%3Dp_%7Bj%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>则很容易计算 <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D" style="display:inline-block;margin: 0;"/> 矩阵第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 列的均值</p>
<p style=""><img src="https://math.now.sh?from=E%28M_%7Bj%7D%29%3D0%20%5Ctimes%20a%2B1%20%5Ctimes%20b%2B2%20%5Ctimes%20c%3D2%20p_%7Bj%7D%0A" /></p><p>证明 <img src="https://math.now.sh?inline=%5Cmathbf%7BM%7D" style="display:inline-block;margin: 0;"/> 矩阵第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 列的方差则需要<strong>哈温平衡假设</strong>。当群体处于哈温平衡时，此时存在：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26a%3D%5Cleft%281-p_%7Bj%7D%5Cright%29%5E%7B2%7D%20%5C%5C%0A%26b%3D2%20p_%7Bj%7D%5Cleft(1-p_%7Bj%7D%5Cright)%20%5C%5C%0A%26c%3Dp_%7Bj%7D%5E%7B2%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>第 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 列的方差为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7BVar%7D%5Cleft%28M_%7Bj%7D%5Cright%29%20%26%3DE%5Cleft(M_%7Bj%7D%5E%7B2%7D%5Cright)-%5Cleft(E%5Cleft(M_%7Bj%7D%5Cright)%5Cright)%5E%7B2%7D%20%5C%5C%0A%26%3D%5Cleft(0%20%5Ctimes%20a%2B1%20%5Ctimes%20b%20%2B4%20%5Ctimes%20c%5Cright)-4%20p_%7Bj%7D%5E%7B2%7D%20%5C%5C%0A%26%3D2%20p_%7Bj%7D%2B2%20c-4%20p_%7Bj%7D%5E%7B2%7D%20%5Cquad%20%5Cbecause%20%E5%93%88%E6%B8%A9%E5%B9%B3%E8%A1%A1%E5%81%87%E8%AE%BE%5C%5C%0A%26%3D2%20p_%7Bj%7D%2B2%20p_%7Bj%7D%5E%7B2%7D-4%20p_%7Bi%7D%5E%7B2%7D%20%5C%5C%0A%26%3D2%20p_%7Bj%7D%5Cleft(1-p_%7Bj%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>这里我们得到的  <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵与机器学习中使用的设计矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵一模一样，都是 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵，并且对特征进行了标准。</p>
<p>我们定义<strong>亲缘关系矩阵 (genetic relationship matrix, GRM)</strong>   <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BG%7D%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Cmathbf%7BX%7D%20%5Cmathbf%7BX%7D%5E%7B%5Ctop%7D%0A" /></p><p>我们发现这里定义的 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵 看上去和机器学习中使用的协方差矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 很像，如果我们不管常数项，这里就是矩阵乘积的顺序换了。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7B%5CSigma%7D%3D%5Cfrac%7B1%7D%7Bm%7D%20%5Cmathbf%7BX%7D%5E%7B%5Ctop%7D%20%5Cmathbf%7BX%7D%0A" /></p><p>我们知道协方差矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的矩阵，<strong>其元素  <img src="https://math.now.sh?inline=%5CSigma_%7Bij%7D" style="display:inline-block;margin: 0;"/> 为特征 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 和特征 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 的协方差</strong>；那么这里类似的，  <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵是一个 <img src="https://math.now.sh?inline=m%20%5Ctimes%20m" style="display:inline-block;margin: 0;"/> 的矩阵，<strong>其元素  <img src="https://math.now.sh?inline=G_%7Bij%7D" style="display:inline-block;margin: 0;"/> 便可解释为个体 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 和个体 <img src="https://math.now.sh?inline=j" style="display:inline-block;margin: 0;"/> 的协方差</strong>， <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵可以理解为个体间的协方差矩阵。</p>
<p>同时定义 <img src="https://math.now.sh?inline=%5Csigma_%7Bg%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 为所有SNP 解释的方差，比如 <img src="https://math.now.sh?inline=%5Csigma_%7B%5Cmathrm%7Bg%7D%7D%5E%7B2%7D%3Dn%20%5Csigma_%7B%5Cmathrm%7Bu%7D%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ，此时上面的模型等价于</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7By%7D%3D%5Cmathbf%7BK%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cmathbf%7Bg%7D%2B%5Cvarepsilon%20%5Ctext%20%7B%20with%20%7D%20%5Cmathbf%7BV%7D%3D%5Cmathbf%7BG%7D%20%5Csigma_%7B%5Cmathrm%7Bg%7D%7D%5E%7B2%7D%2B%5Cmathbf%7BI%7D%20%5Csigma_%7B%5Cvarepsilon%7D%5E%7B2%7D%0A" /></p><p>这里 <img src="https://math.now.sh?inline=%5Cmathrm%7Bg%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=m%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 的个体的总的加性效应向量，服从分布 <img src="https://math.now.sh?inline=%5Cmathbf%7Bg%7D%20%5Csim%20N%5Cleft%280%2C%20%5Cmathbf%7BG%7D%20%5Csigma_%7B%5Cmathrm%7Bg%7D%7D%5E%7B2%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 。我们注意到，我们上面说 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵可以理解为个体间的协方差矩阵，那为什么这里个体间的协方差矩阵用的是 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D%20%5Csigma_%7B%5Cmathrm%7Bg%7D%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 呢？个人理解，因为构建 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 矩阵进行了标准化，因此 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵中的方差或协方差相比于个体间真实的方差或协方差的取值范围不一样，因此需要乘以  <img src="https://math.now.sh?inline=%5Csigma_%7Bg%7D%5E%7B2%7D" style="display:inline-block;margin: 0;"/>  来还原。</p>
<h2 id="PCA分析">PCA分析</h2>
<p>PCA 做起来非常简单，就一步，就是对上面的<img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵进行特征值分解，得到的前 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 个特征向量就是我们需要的主成分。</p>
<p>这里我们与一般的PCA分析进行比较，首先我们先看一个简单的性质。当你对矩阵 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 乘以一个常数 <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/> <img src="https://math.now.sh?inline=%28%20%5Calpha%20%3E%200%29" style="display:inline-block;margin: 0;"/> 时，设 <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> 的一组特征值和特征向量分别为 <img src="https://math.now.sh?inline=%5Clambda" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmu" style="display:inline-block;margin: 0;"/>,  则 <img src="https://math.now.sh?inline=%5Calpha%20%5Clambda" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmu" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=%5Calpha%20A" style="display:inline-block;margin: 0;"/> 的特征值和特征向量。证明很简单，见下。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Calpha%20A%20%5Cmu%20%26%3D%20%5Calpha%20%5Clambda%20%5Cmu%20%5Cquad%20%E5%B7%A6%E5%8F%B3%E5%90%84%E4%B9%98%E4%BB%A5%E4%B8%80%E4%B8%AA%20%5Calpha%20%5C%5C%0A%28%5Calpha%20A%29%20%5Cmu%20%26%3D%20(%5Calpha%20%5Clambda)%20%5Cmu%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，这说明大于<img src="https://math.now.sh?inline=0" style="display:inline-block;margin: 0;"/>的常数项不会影响我们提取前<img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/> 个特征向量的结果（特征值绝对大小改变，但是相对大小和排名不变；特征向量不变），因此我们可以忽略 <img src="https://math.now.sh?inline=1%2Fm" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=1%2Fn" style="display:inline-block;margin: 0;"/> 。我们就只需要比较 $ \mathbf{X} \mathbf{X}^{\top}$ 和 $ \mathbf{X}^{\top} \mathbf{X}$ 特征值分解的异同。</p>
<p>我们再回顾一个性质，<strong>矩阵 <img src="https://math.now.sh?inline=A%20A%5E%7BT%7D" style="display:inline-block;margin: 0;"/> 和矩阵 <img src="https://math.now.sh?inline=A%5E%7BT%7D%20A" style="display:inline-block;margin: 0;"/> 的非零特征值相同</strong>，证明如下<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://math.stackexchange.com/questions/1249497/largest-eigenvalues-of-aa-equals-to-aa">[2]</span></a></sup></p>
<blockquote>
<p>For any <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> and <img src="https://math.now.sh?inline=n%20%5Ctimes%20m" style="display:inline-block;margin: 0;"/> matrices <img src="https://math.now.sh?inline=A" style="display:inline-block;margin: 0;"/> and <img src="https://math.now.sh?inline=B" style="display:inline-block;margin: 0;"/>, the nonzero eigenvalues of <img src="https://math.now.sh?inline=A%20B" style="display:inline-block;margin: 0;"/> and <img src="https://math.now.sh?inline=B%20A" style="display:inline-block;margin: 0;"/> are the same. Namely, if <img src="https://math.now.sh?inline=A%20B%20v%3D%5Clambda%20v" style="display:inline-block;margin: 0;"/> with <img src="https://math.now.sh?inline=%5Clambda%20%5Cneq%200" style="display:inline-block;margin: 0;"/> and <img src="https://math.now.sh?inline=v%20%5Cneq%200" style="display:inline-block;margin: 0;"/>, then <img src="https://math.now.sh?inline=B%20v%20%5Cneq%200" style="display:inline-block;margin: 0;"/> （因为 <img src="https://math.now.sh?inline=A%20B%20v%3D%5Clambda%20v%20%5Cneq%200" style="display:inline-block;margin: 0;"/> ，如果 <img src="https://math.now.sh?inline=B%20v%20%3D%200" style="display:inline-block;margin: 0;"/>，则 <img src="https://math.now.sh?inline=ABv%20%3D%200" style="display:inline-block;margin: 0;"/>，与原条件相悖，因此  <img src="https://math.now.sh?inline=B%20v%20%5Cneq%200" style="display:inline-block;margin: 0;"/>  ）and <img src="https://math.now.sh?inline=B%20A%28B%20v%29%3DB(A%20B%20v)%3D%5Clambda%20B%20v" style="display:inline-block;margin: 0;"/>  ，即 <img src="https://math.now.sh?inline=%5Clambda" style="display:inline-block;margin: 0;"/> 同样为 <img src="https://math.now.sh?inline=BA" style="display:inline-block;margin: 0;"/> 的特征值，因此 <img src="https://math.now.sh?inline=AB" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=BA" style="display:inline-block;margin: 0;"/> 的非零特征值相同。</p>
</blockquote>
<p>因此，我们知道 $ \mathbf{X} \mathbf{X}^{\top}$ 和 $ \mathbf{X}^{\top} \mathbf{X}$ 特征值相同，而且根据上面的证明过程，二者的特征向量存在下面的关系。</p>
<p>若 <img src="https://math.now.sh?inline=%28%5Clambda%2C%20%5Cmu%29" style="display:inline-block;margin: 0;"/> 为   $ \mathbf{X}^{\top} \mathbf{X}$ 的一组特征值和特征向量，则 <img src="https://math.now.sh?inline=%28%5Clambda%2C%20X%5Cmu%29" style="display:inline-block;margin: 0;"/> 为  $ \mathbf{X} \mathbf{X}^{\top}$ 的一组特征值和特征向量。也就是我们对 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵和 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 矩阵进行特征值分解，其特征向量的关系为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmu_%7BG%7D%20%3D%20X%20%5Cmu_%7B%5CSigma%7D%0A" /></p><p>其中，<img src="https://math.now.sh?inline=%5Cmu_%7BG%7D" style="display:inline-block;margin: 0;"/>  表示为<img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵的一个特征向量，  <img src="https://math.now.sh?inline=%5Cmu_%20%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 表示为相应的 <img src="https://math.now.sh?inline=%5Cmathbf%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 矩阵的一个特征向量。</p>
<p>而，<img src="https://math.now.sh?inline=X%20%5Cmu_%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 就是<strong>所有样本在这个新坐标轴的坐标组成的向量</strong>（<img src="https://math.now.sh?inline=%5Cmu_%20%7B%5CSigma%7D" style="display:inline-block;margin: 0;"/> 可以理解为新的坐标系的某一个轴）。这就和我们之前提到的先对<strong>特征的协方差矩阵</strong> <img src="https://math.now.sh?inline=%5CSigma" style="display:inline-block;margin: 0;"/> 进行特征值分解，得到特征向量 <img src="https://math.now.sh?inline=%5Cleft%5C%7Bw_%7B1%7D%2C%20w_%7B2%7D%2C%20%5Cldots%2C%20w_%7Bn%7D%5Cright%5C%7D" style="display:inline-block;margin: 0;"/>  后，再利用特征向量与特征的内积，计算样本点的新坐标 <img src="https://math.now.sh?inline=z" style="display:inline-block;margin: 0;"/> ，这个过程是一致的。</p>
<p>因此，这里证明了直接对 <img src="https://math.now.sh?inline=%5Cmathbf%7BG%7D" style="display:inline-block;margin: 0;"/> 矩阵进行特征值分解，其特征向量直接就是主成分，这种做法和常规的PCA分析做法是一致的。</p>
<h1>疑问</h1>
<h2 id="构建G阵的假设有哪些？">构建G阵的假设有哪些？</h2>
<p>第一，构建G阵<strong>最重要的假设就是群体处于哈温平衡状态</strong>。在上面推导每一列SNP的方差时便需要用到哈温平衡的假设，但是这个假设我感觉很难成立。与之有关的另一个问题是使用的等位基因频率。我的理解是我们使用的基因型样本可以视为对总体的一个抽样，我们是用我们手上的样本的等位基因频率去估计总体的等位基因频率，那么只有符合哈温平衡时我们这么做才合理。因此只有符合哈温平衡时，不同的世代的等位基因频率才保持不变，因此对当前世代或当前群体的等位基因频率就可以有效地估计总体的等位基因频率。</p>
<p>第二，标记之间彼此独立，换句话说，不存在连锁不平衡，因为这里我们假设所有SNP的分布为  <img src="https://math.now.sh?inline=%5Cmathbf%7Bu%7D%20%5Csim%20N%5Cleft%280%2C%20%5Cmathbf%7BI%7D%20%5Csigma_%7B%5Cmathrm%7Bu%7D%7D%5E%7B2%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 。</p>
<p>应该没有别的假设了。</p>
<h2 id="当基因型存在缺失时，如何构建的G阵？">当基因型存在缺失时，如何构建的G阵？</h2>
<p>当我们使用 plink 或 GCTA 进行PCA分析时，我们可以直接用下机的基因型数据进行分析，而不需要填充，那么问题来了，此时基因型存在缺失，怎么构建的G阵呢？</p>
<p>GCTA文章指向了 EIGENSTART 软件，然后我就看了这边软件的文章<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Principal components analysis corrects for stratification in genome-wide association studies ">[3]</span></a></sup>，原文见下图。</p>
<p>我个人理解是，</p>
<ol>
<li>
<p>首先计算每一列SNP的等位基因频率 <img src="https://math.now.sh?inline=p_%7Bj%7D" style="display:inline-block;margin: 0;"/> 时剔除缺失位点。</p>
</li>
<li>
<p>然后我们对每一列SNP进行标准化，在标准化过程中直接将 <img src="https://math.now.sh?inline=X" style="display:inline-block;margin: 0;"/> 矩阵中基因型缺失的地方设为 0（按照图中的说法，顺序是先进行中心化，再将缺失位点的值调整为0，最后除以标准差）。</p>
<p style=""><img src="https://math.now.sh?from=x_%7Bi%20j%7D%3D%20%5Cbegin%7Bcases%7D%5Cleft%28m_%7Bi%20j%7D-2%20p_%7Bj%7D%5Cright%29%2F%5Csqrt%7B2%20p_%7Bj%7D%5Cleft(1-p_%7Bj%7D%5Cright)%7D%20%26%20%5Ctext%20%7B%20if%20%7D%20x_%7Bi%20j%7D%20%5Ctext%7B%20%E4%B8%8D%E4%B8%BA%E7%BC%BA%E5%A4%B1%7D%20%20%5C%5C%200%20%26%20%5Ctext%20%7B%20if%20%7D%20x_%7Bi%20j%7D%20%5Ctext%7B%20%E7%BC%BA%E5%A4%B1%7D%5Cend%7Bcases%7D%0A" /></p></li>
</ol>
<p>注意，下图中的  <img src="https://math.now.sh?inline=X" style="display:inline-block;margin: 0;"/> 矩阵是一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20m" style="display:inline-block;margin: 0;"/> 的矩阵，和本文中使用的 <img src="https://math.now.sh?inline=X" style="display:inline-block;margin: 0;"/> 矩阵不是同一个，二者是互为转置的关系。</p>
<p>这种做法就仍然是采用了极大似然估计的思想，当基因型数据存在缺失，这里用最可能出现的值去填补，也就是用群体均值。那么，这种做法和对基因型进行填充再构建G阵的做法，这两种做法那种更好呢？我个人认为是后者，举个例子，假设某个SNP在群体里中的等位基因频率 <img src="https://math.now.sh?inline=p_j%20%3D%200.3" style="display:inline-block;margin: 0;"/> ，那么当这个位点存在缺失时，按上面的做法相当于我们将其基因型填补为 0.6 ，这百分百是一个错误的估计值，因为一个位点的基因型只能是0,1,2。但是，当我们对基因型进行填充时，利用位点间的连锁不平衡或样本间的亲缘关系，我们有很大的几率将其填充为正确的基因型。当然，在基因型缺失率比较低的情况下，这两种做法结果区别不大。</p>
<p><img src="1.png" alt="1"></p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">GCTA: A Tool for Genome-wide Complex Trait Analysis<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://math.stackexchange.com/questions/1249497/largest-eigenvalues-of-aa-equals-to-aa<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Principal components analysis corrects for stratification in genome-wide association studies<a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
  </entry>
  <entry>
    <title>为什么样本方差分母为n-1</title>
    <url>/posts/c8ae5def/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在学习吴恩达老师的机器学习课上，碰到了一个旧知识点：在统计上，样本方差的分母应该是 n-1 ，这样才是对总体方差的无偏估计。在网上查了很多资料，根据自己的理解总结了一下，水平有限，如有不当之处敬请指正。</p>
<span id="more"></span>
<h1>问题</h1>
<p>首先我们要理清楚问题是什么，假设我们拿到了一组数据，样本数为 n，我们认为这些数据服从<strong>独立同分布</strong>的正态分布，我们想知道它们服从的正态分布的均值和方差是多少，或者说想估计它们服从的正态分布的均值和方差。</p>
<h1>最大似然估计</h1>
<p>这种从已有数据推断参数的事情，第一时间我想的就是最大似然估计。首先，一维正态分布的概率密度函数长这样：</p>
<p style=""><img src="https://math.now.sh?from=f%28x%29%3D%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%7D%20%5Csigma%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B(x-%5Cmu)%5E%7B2%7D%7D%7B2%20%5Csigma%5E%7B2%7D%7D%5Cright)%0A" /></p><p>由于不同的样本服从独立同分布，因此所有样本的联合概率密度函数如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Af%28%5Ctextbf%7Bx%7D%7C%CE%BC%2C%5Csigma%5E%7B2%7D%29%20%26%3D%5Cprod_%7Bi%3D1%7D%5E%7Bn%7D%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%7D%20%5Csigma%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B(x-%5Cmu)%5E%7B2%7D%7D%7B2%20%5Csigma%5E%7B2%7D%7D%5Cright)%20%5C%5C%0A%26%3D%5Cleft(%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%7D%5Csigma%7D%5Cright)%5E%7Bn%7D%20%5Cexp%20%5Cleft(-%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cfrac%7B(x-%5Cmu)%5E%7B2%7D%7D%7B2%20%5Csigma%5E%7B2%7D%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们要求出现这组数据或更极端数据出现的似然值<strong>最大</strong>，也就是求使上式的联合概率密度函数最大的一组参数。我们对联合概率密度函数采用对数函数，可以简化运算：</p>
<p style=""><img src="https://math.now.sh?from=%5Cln%20f%5Cleft%28%5Cmathbf%7Bx%7D%20%5Cmid%20%5Cmu%2C%20%5Csigma%5E%7B2%7D%5Cright%29%3D-%5Cfrac%7B1%7D%7B2%20%5Csigma%5E%7B2%7D%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-%5Cmu%5Cright)%5E%7B2%7D-%5Cfrac%7Bn%7D%7B2%7D%20%5Cln%20%5Csigma%5E%7B2%7D-%5Cfrac%7Bn%7D%7B2%7D%20%5Cln%20(2%20%5Cpi)%0A" /></p><p>为了方便查看，这里我们将 σ<sup>2</sup> 替换为 v 。</p>
<p style=""><img src="https://math.now.sh?from=%5Cln%20f%5Cleft%28%5Cmathbf%7Bx%7D%20%5Cmid%20%5Cmu%2C%20v%5Cright%29%3D-%5Cfrac%7B1%7D%7B2%20v%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-%5Cmu%5Cright)%5E%7B2%7D-%5Cfrac%7Bn%7D%7B2%7D%20%5Cln%20v-%5Cfrac%7Bn%7D%7B2%7D%20%5Cln%20(2%20%5Cpi)%0A" /></p><p>这里要求该式的极值，想到了对该式求偏导，计算两个偏导等于 0 时的参数值。首先对参数 μ 求偏导。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20%5Cmu%7D%20%26%3D-%5Cfrac%7B1%7D%7B2%20v%7D%20%5Ccdot%202%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28x_%7Bi%7D-%5Cmu%5Cright%29(-1)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bv%7D%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20X_%7Bi%7D-n%20%5Cmu%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>求该式为 0 ，得到参数 μ 的最大似然值如下，就是样本均值（下标 ML 表示最大似然估计值，下图）</p>
<p style=""><img src="https://math.now.sh?from=%5Cmu_%7BML%7D%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20X_%7Bi%7D%0A" /></p><p>再对参数 v (即σ<sup>2</sup>) 求偏导</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20v%7D%3D%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28x_%7Bi%7D-%5Cmu%5Cright%29%5E%7B2%7D%20v%5E%7B-2%7D-%5Cfrac%7Bn%7D%7B2%7D%20v%5E%7B-1%7D%0A" /></p><p>求该式为 0 ，得到参数 v  (即σ<sup>2</sup>)  的最大似然值如下。</p>
<p style=""><img src="https://math.now.sh?from=%5Csigma%5E%7B2%7D_%7BML%7D%20%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28x_%7Bi%7D-%5Cmu%5Cright%29%5E%7B2%7D%0A" /></p><p>易证，最大似然估计的两个参数值均为无偏估计，证明如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%28%5Cmu_%7BML%7D%29%20%26%3DE%5Cleft(%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20x_%7Bi%7D%5Cright)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20E%5Cleft(x_%7Bi%7D%5Cright)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%20n%20%5Cmu%20%5C%5C%0A%26%3D%5Cmu%20%5C%5C%0AE%5Cleft(%5Csigma%5E%7B2%7D_%7BML%7D%5Cright)%20%26%3DE%5Cleft(%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-u%5Cright)%5E%7B2%7D%5Cright)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20E%5Cleft(x_%7Bi%7D-u%5Cright)%5E%7B2%7D%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%20n%20%5Csigma%5E%7B2%7D%20%5C%5C%0A%26%3D%5Csigma%5E%7B2%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，最大似然估计的方差是无偏的，没有问题。但是注意，<strong>这里得到的方差估计值的公式中含有总体均值 μ</strong>。看我们的问题，我们并不知道总体均值，我们上面得到了总体均值的最大似然估计值就是样本均值，我们能不能直接将总体均值替换为样本均值呢？就是下式：</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Csigma%5E%7B2%7D%7D%20%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28x_%7Bi%7D-%5Cbar%7BX%7D%5Cright%29%5E%7B2%7D%0A" /></p><p>这里我们可以证明这样做得到的估计量会<strong>低于</strong>极大似然估计值，是一个有偏估计量。</p>
<h1>证明分母为n的样本方差会低于极大似然估计值</h1>
<p>我们这里构建一个函数 f(a)</p>
<p style=""><img src="https://math.now.sh?from=f%28a%29%20%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-a%5Cright)%5E%7B2%7D%0A" /></p><p>求导得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Af'%28a%29%20%26%3D%5Cfrac%7B2%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-a%5Cright)(-1)%20%5C%5C%0A%26%3D%5Cfrac%7B2%7D%7Bn%7D%5Cleft(n%20a-%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20x_%7Bi%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>当导数为 0 时，a 等于</p>
<p style=""><img src="https://math.now.sh?from=a%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20x_%7Bi%7D%3D%5Cbar%7BX%7D%0A" /></p><p>易知，当 a 等于样本均值时，该式最小。因此，下式成立</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28X_%7Bi%7D-%5Cbar%7BX%7D%5Cright%29%5E%7B2%7D%20%5Cleq%20%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(X_%7Bi%7D-%5Cmu%5Cright)%5E%7B2%7D%0A" /></p><p>证明分母为n的样本方差会低估总体方差估计值。</p>
<h2 id="第二种证明方法">第二种证明方法</h2>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Csigma%5E%7B2%7D_%7BML%7D%20%26%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28x_%7Bi%7D-u%5Cright%29%5E%7B2%7D%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(%5Cleft(x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright)%2B(%5Cbar%7Bx%7D-u)%5Cright)%5E%7B2%7D%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright)%5E%7B2%7D%2B%5Cfrac%7B2%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright)(%5Cbar%7Bx%7D-u)%2B(%5Cbar%7Bx%7D-u)%5E%7B2%7D%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright)%5E%7B2%7D%2B%5Cfrac%7B2%7D%7Bn%7D(%5Cbar%7Bx%7D-u)%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20x_%7Bi%7D-n%20%5Cbar%7Bx%7D%5Cright)%2B(%5Cbar%7Bx%7D-u)%5E%7B2%7D%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright)%5E%7B2%7D%2B(%5Cbar%7Bx%7D-u)%5E%7B2%7D%20%5C%5C%0A%26%20%5Cgeqslant%20%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright)%5E%7B2%7D%0A%5Cend%7Baligned%7D%0A" /></p><h1>样本方差推导</h1>
<p>具体小多少，可以通过求期望计算一下<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://www.zhihu.com/question/20099757">[1]</span></a></sup></p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%5Cleft%28%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Cleft(X_%7Bi%7D-%5Cbar%7BX%7D%5Cright%29%5E%7B2%7D%20%5Cright)%20%26%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20E%5Cleft(%5Cleft(X_%7Bi%7D-%5Cbar%7BX%7D%5Cright)%5E%7B2%7D%5Cright)%3D%5Cfrac%7B1%7D%7Bn%7D%20E%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(X_%7Bi%7D-%5Cmu%2B%5Cmu-%5Cbar%7BX%7D%5Cright)%5E%7B2%7D%5Cright)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%20E%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(%5Cleft(X_%7Bi%7D-%5Cmu%5Cright)%5E%7B2%7D-2%5Cleft(X_%7Bi%7D-%5Cmu%5Cright)(%5Cbar%7BX%7D-%5Cmu)%2B(%5Cbar%7BX%7D-%5Cmu)%5E%7B2%7D%5Cright)%5Cright)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%20E%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(X_%7Bi%7D-%5Cmu%5Cright)%5E%7B2%7D-2%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(X_%7Bi%7D-%5Cmu%5Cright)(%5Cbar%7BX%7D-%5Cmu)%2Bn(%5Cbar%7BX%7D-%5Cmu)%5E%7B2%7D%5Cright)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%20E%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(X_%7Bi%7D-%5Cmu%5Cright)%5E%7B2%7D-2%20n(%5Cbar%7BX%7D-%5Cmu)(%5Cbar%7BX%7D-%5Cmu)%2Bn(%5Cbar%7BX%7D-%5Cmu)%5E%7B2%7D%5Cright)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%20E%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(X_%7Bi%7D-%5Cmu%5Cright)%5E%7B2%7D-n(%5Cbar%7BX%7D-%5Cmu)%5E%7B2%7D%5Cright)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20E%5Cleft(%5Cleft(X_%7Bi%7D-%5Cmu%5Cright)%5E%7B2%7D%5Cright)-n%20E%5Cleft((%5Cbar%7BX%7D-%5Cmu)%5E%7B2%7D%5Cright)%5Cright)%20%5C%5C%0A%26%3D%5Cfrac%7B1%7D%7Bn%7D(n%20%5Coperatorname%7BVar%7D(X)-n%20%5Coperatorname%7BVar%7D(%5Cbar%7BX%7D))%20%5C%5C%0A%26%3D%5Coperatorname%7BVar%7D(X)-%5Coperatorname%7BVar%7D(%5Cbar%7BX%7D)%0A%5Cend%7Baligned%7D%0A" /></p><p>其中, <img src="https://math.now.sh?inline=%5Coperatorname%7BVar%7D%28%5Cbar%7BX%7D%29" style="display:inline-block;margin: 0;"/> 证明如下。首先方差存在下面的性质</p>
<blockquote>
<p>If <img src="https://math.now.sh?inline=X_%7B1%7D%2C%20%5Cldots%2C%20X_%7Bn%7D" style="display:inline-block;margin: 0;"/> are independent and <img src="https://math.now.sh?inline=a_%7B1%7D%2C%20%5Cldots%2C%20a_%7Bn%7D" style="display:inline-block;margin: 0;"/> are constants, then</p>
</blockquote>
<p style=""><img src="https://math.now.sh?from=%5Cmathbb%7BV%7D%5Cleft%28%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20a_%7Bi%7D%20X_%7Bi%7D%5Cright%29%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20a_%7Bi%7D%5E%7B2%7D%20%5Cmathbb%7BV%7D%5Cleft(X_%7Bi%7D%5Cright)%0A" /></p><p>所以，我们得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%20%5Coperatorname%7BVar%7D%28%5Cbar%7BX%7D%29%20%5C%5C%0A%3D%26%20%5Coperatorname%7Bvar%7D%5Cleft(%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20x_%7Bi%7D%5Cright)%20%5C%5C%0A%3D%26%20%5Cfrac%7B1%7D%7Bn%5E%7B2%7D%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Coperatorname%7Bvar%7D%5Cleft(x_%7Bi%7D%5Cright)%20%5C%5C%0A%3D%26%20%5Cfrac%7B1%7D%7Bn%5E%7B2%7D%7D%20n%20%5Coperatorname%7Bvar%7D(x)%20%5C%5C%0A%3D%26%20%5Cfrac%7B%5Csigma%5E%7B2%7D%7D%7Bn%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>所以，</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%5Cleft%28%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Cleft(X_%7Bi%7D-%5Cbar%7BX%7D%5Cright%29%5E%7B2%7D%20%5Cright)%26%3D%5Coperatorname%7BVar%7D(X)-%5Coperatorname%7BVar%7D(%5Cbar%7BX%7D)%3D%5Csigma%5E%7B2%7D-%5Cfrac%7B%5Csigma%5E%7B2%7D%7D%7Bn%7D%3D%5Cfrac%7Bn-1%7D%7Bn%7D%20%5Csigma%5E%7B2%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，为了避免使用有偏差的估计值，略加转换，我们得到下式：</p>
<p style=""><img src="https://math.now.sh?from=S%5E%7B2%7D%3D%5Cfrac%7B1%7D%7Bn-1%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28X_%7Bi%7D-%5Cbar%7BX%7D%5Cright%29%5E%7B2%7D%0A" /></p><h2 id="第二种证明方法-2">第二种证明方法</h2>
<p>我感觉像上面一样，直接从 <img src="https://math.now.sh?inline=%5Cmathrm%7BE%7D%28%5Csigma%5E%7B2%7D_%7BML%7D%29" style="display:inline-block;margin: 0;"/> 去推公式，结果更直观一点。首先我们需要拆分一下 <img src="https://math.now.sh?inline=%5Csigma%5E%7B2%7D_%7BML%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p style=""><img src="https://math.now.sh?from=%5Csigma%5E%7B2%7D_%7BML%7D%20%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright%29%5E%7B2%7D%2B(%5Cbar%7Bx%7D-u)%5E%7B2%7D%20%5C%5C%0A" /></p><p>同时对左右两侧求期望，得到：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathrm%7BE%7D%28%5Csigma%5E%7B2%7D_%7BML%7D%29%26%3D%5Cmathrm%7BE%7D%5Cleft(%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright)%5E%7B2%7D%2B(%5Cbar%7Bx%7D-u)%5E%7B2%7D%5Cright)%20%5C%5C%0A%26%3D%5Cmathrm%7BE%7D%5Cleft(%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright)%5E%7B2%7D%5Cright)%20%2B%20%5Cmathrm%7BE%7D%5Cleft((%5Cbar%7Bx%7D-u)%5E%7B2%7D%5Cright)%20%5C%5C%0A%26%3D%5Cmathrm%7BE%7D%5Cleft(%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright)%5E%7B2%7D%5Cright)%20%2B%20%5Coperatorname%7BVar%7D(%5Cbar%7BX%7D)%20%5C%5C%0A%26%3D%5Cmathrm%7BE%7D%5Cleft(%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright)%5E%7B2%7D%5Cright)%20%2B%20%5Cfrac%7B%5Csigma%5E%7B2%7D%7D%7Bn%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>左侧 <img src="https://math.now.sh?inline=%5Csigma%5E%7B2%7D_%7BML%7D" style="display:inline-block;margin: 0;"/> 期望为总体方差 <img src="https://math.now.sh?inline=%5Csigma%5E2" style="display:inline-block;margin: 0;"/> （  <img src="https://math.now.sh?inline=%5Cbecause%20%5Cmathrm%7BE%7D%28%5Csigma%5E%7B2%7D_%7BML%7D%29%20%3D%20%5Csigma%5E%7B2%7D" style="display:inline-block;margin: 0;"/> ） ，因此</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Csigma%5E%7B2%7D%20%26%3D%5Cmathrm%7BE%7D%5Cleft%28%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright%29%5E%7B2%7D%5Cright)%20%2B%20%5Cfrac%7B%5Csigma%5E%7B2%7D%7D%7Bn%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>所以</p>
<p style=""><img src="https://math.now.sh?from=E%5Cleft%28%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Cleft(X_%7Bi%7D-%5Cbar%7BX%7D%5Cright%29%5E%7B2%7D%20%5Cright)%3D%5Csigma%5E%7B2%7D-%5Cfrac%7B%5Csigma%5E%7B2%7D%7D%7Bn%7D%3D%5Cfrac%7Bn-1%7D%7Bn%7D%20%5Csigma%5E%7B2%7D%0A" /></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://www.zhihu.com/question/20099757<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>理论学习</category>
        <category>统计</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>python脚本编译及转为exe可执行文件</title>
    <url>/posts/45f5af89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>一般我们执行 python 脚本都是在 python 环境中运行，这里通过将python脚本转化为一个 exe 文件，这样只需要在windows环境下双击 exe 文件就可以运行程序，方便其他人使用。</p>
<span id="more"></span>
<h1>python脚本转为exe方法</h1>
<p>根据某个网上的教程<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="http://zhaoxuhui.top/blog/2017/05/22/Python%E8%84%9A%E6%9C%AC%E8%BD%ACexe%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6.html
">[1]</span></a></sup>，这里使用 PyInstaller 模块实现这个功能。</p>
<h2 id="安装-PyInstaller">安装 PyInstaller</h2>
<p>在 windows 的控制台下，运行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install pyinstaller</span><br></pre></td></tr></table></figure>
<h2 id="python-转为-exe">python 转为 exe</h2>
<p>在 windows 的控制台下，运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyinstaller -F split_plink.py</span><br></pre></td></tr></table></figure>
<p>在当前目录下会生成很多文件夹和文件，其他都不用管，我们需要的就是 <code>dist</code> 目录下的  <code>split_plink.exe</code> 程序文件。</p>
<p>这里如果不使用 <code>-F</code> 选项，那么 <code>dist</code> 目录下除了相应的 <code>exe</code> 文件还会生成很多别的文件，运行 <code>exe</code> 程序时，必须同时包含<code>dist</code> 文件夹下的其他文件，只有  <code>exe</code> 程序 运行不成功。我们使用了  <code>-F</code> 选项 ，就只有一个  <code>exe</code> 程序 ，拷贝程序只要拷贝这个 <code>exe</code> 程序即可，更加方便。</p>
<p>如果不想要控制台窗口，可以采用 <code>-w</code> 选项。</p>
<blockquote>
<p>注意PyInstaller打包的执行文件，只能在和打包机器系统同样的环境下。也就是说，不具备可移植性，若需要在不同系统上运行，就必须针对该平台进行打包<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[python之pyinstaller库将python脚本编译成可执行程序（windows系统）](https://www.cnblogs.com/hls-code/p/15005345.html)">[2]</span></a></sup>。</p>
</blockquote>
<h2 id="更详细的解释">更详细的解释</h2>
<p>可见 <a href="https://www.cnblogs.com/hls-code/p/15005345.html">python之pyinstaller库将python脚本编译成可执行程序（windows系统）</a> <sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[python之pyinstaller库将python脚本编译成可执行程序（windows系统）](https://www.cnblogs.com/hls-code/p/15005345.html)">[2]</span></a></sup></p>
<h1>python 脚本编译</h1>
<p>python 脚本文件经过编译后可以生成 pyc 文件，提高加载速度。</p>
<p>对于单个 python 脚本，可以通过下面的 python 命令编译</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> py_compile</span><br><span class="line">py_compile.<span class="built_in">compile</span>(<span class="string">&#x27;*.py&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>命令行方式为 <code>python -m *.py</code> ，但是这种方式我试了会报错（如果脚本用 <code>sys.argv</code> 传参的话）。</p>
<p>针对一个目录下所有的 python 脚本，可以通过 <code>compileall</code> 模块来批量化编译（目录的绝对路径前面加 ‘r’ ，是为了告诉编译器这是个 <code>raw string</code> ，不要对该字符串转意）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> compileall</span><br><span class="line">compileall.compile_dir(<span class="string">r&#x27;/path&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>注意，编译以后得到 pyc 文件只能在编译时的 python 编译器下运行，否则可能会报错，报错信息类似下面。根据网上的说法，只要运行 pyc 文件采用的 python 编译器版本与编译时用的一样就行，举例而言，就是说你在 3.7 版本的  python 编译器编译得到的 pyc 文件只能在 3.7 版本下运行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RuntimeError: Bad magic number <span class="keyword">in</span> .pyc file</span><br></pre></td></tr></table></figure>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">http://zhaoxuhui.top/blog/2017/05/22/Python%E8%84%9A%E6%9C%AC%E8%BD%ACexe%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6.html<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.cnblogs.com/hls-code/p/15005345.html">python之pyinstaller库将python脚本编译成可执行程序（windows系统）</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么最大似然估计使用概率密度</title>
    <url>/posts/f86994ef/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在看极大似然估计的公式时，一个问题一直盘旋在我的心中，为什么对于连续变量采用概率密度函数呢？</p>
<span id="more"></span> 
<h1>极大似然估计概述</h1>
<p>直接把维基百科的话复制过来如下<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label=" https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1
">[1]</span></a></sup>：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BL%7D%5Cleft%28%5Ctheta%20%5Cmid%20x_%7B1%7D%2C%20%5Cldots%2C%20x_%7Bn%7D%5Cright%29%3Df_%7B%5Ctheta%7D%5Cleft(x_%7B1%7D%2C%20%5Cldots%2C%20x_%7Bn%7D%5Cright)%0A" /></p><p>若 <img src="https://math.now.sh?inline=D" style="display:inline-block;margin: 0;"/> 是离散分布， <img src="https://math.now.sh?inline=f_%7B%5Ctheta%7D" style="display:inline-block;margin: 0;"/> 即是在参数为 <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/> 时观测到这一采样的概率。**若其是连续分布， <img src="https://math.now.sh?inline=f_%7B%5Ctheta%7D" style="display:inline-block;margin: 0;"/> 则为 <img src="https://math.now.sh?inline=X_%7B1%7D%2C%20X_%7B2%7D%2C%20%5Cldots%2C%20X_%7Bn%7D" style="display:inline-block;margin: 0;"/> 联合分布的概率密度函数在观测值处的取值。**一旦我们获得 <img src="https://math.now.sh?inline=X_%7B1%7D%2C%20X_%7B2%7D%2C%20%5Cldots%2C%20X_%7Bn%7D" style="display:inline-block;margin: 0;"/>, 我们就能求得一个关于 <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/> 的估计。最大似然估计会寻找关于 <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/> 的最可能的值 (即, 在所<br>
注意</p>
<ul>
<li>这裡的似然函数是指 <img src="https://math.now.sh?inline=x_%7B1%7D%2C%20x_%7B2%7D%2C%20%5Cldots%2C%20x_%7Bn%7D" style="display:inline-block;margin: 0;"/> 不变时， 关于 <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/> 的一个函数。</li>
<li>最大似然估计不一定存在，也不一定唯一。</li>
</ul>
<h1>问题</h1>
<p>我同时查看了很多知乎上的回答，基本上所有人提到 <img src="https://math.now.sh?inline=X" style="display:inline-block;margin: 0;"/> 为<strong>连续变量</strong>时，则似然函数采用联合概率密度值。就仅仅是这么一笔带过，没有人给我任何解释为什么这里用概率密度。但是，所有人在解释极大似然的含义时，均称极大似然函数在参数为 <img src="https://math.now.sh?inline=%5Ctheta" style="display:inline-block;margin: 0;"/> 时这些样本点出现的概率或可能性。那么我的问题来了，<strong>极大似然为什么用概率密度函数表示这些点出现的概率？</strong></p>
<p>学过概率论都知道，第一，<strong>概率密度不是概率，概率密度函数的积分才是概率</strong>，你怎么指着概率密度说是概率呢？；第二，<strong>连续变量在某一点的概率为0</strong>，所以你说连续变量出现在某一个点的概率高低根本毫无意义啊。</p>
<p>我知道似然函数定义就是这样，但我觉得如果有人只告诉我定义就是这样，这不能让我信服。</p>
<p>我一开始有一个误解，我为了说通似然函数采用概率密度这件事，我将其理解成 P值的概念，即<strong>出现比这个残差相同或更极端情况的概率</strong>。比如正态分布，画出图像如下（图片来自网络，侵删）。我们可以看到出现这个残差或更极端情况的概率，与<strong>该残差的概率密度函数的值的大小成正比</strong>。于是似然函数中直接使用概率密度貌似就可以理解了。但是我慢慢发现，这个理解不对。</p>
<p><img src="1.png" alt="1"></p>
<h1>新的理解</h1>
<p>后面我查看Fisher在1922年发表的论文<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://royalsocietypublishing.org/doi/10.1098/rsta.1922.0009">[2]</span></a></sup>，这好像也是第一次提论最大似然的地方。水平有限，看不太懂，但我还是找到了 Fisher 对于最大似然的阐述：</p>
<p><img src="2.png" alt="1"></p>
<p>我不是很理解第二个公式是怎么得到的，但从第一个公式我们可以清楚地看到，对于连续变量 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> ，<strong>极大似然需要最大化的是在该点的相邻区域的出现概率</strong>。</p>
<p>这里仍然用一元正态分布的图来直观理解一下，需要计算的相邻区域的概率即为下图阴影区域，根据微积分，其计算公式为 <img src="https://math.now.sh?inline=P%20%3D%20f%28x%29dx" style="display:inline-block;margin: 0;"/> ，因此 <img src="https://math.now.sh?inline=P%20%5Cpropto%20f%28x%29" style="display:inline-block;margin: 0;"/> ，因此，<img src="https://math.now.sh?inline=%5Carg%20%5Cmax_%7B%5Ctheta%7D%20P%20%3D%20%5Carg%20%5Cmax_%7B%5Ctheta%7D%20f%28x%29" style="display:inline-block;margin: 0;"/> ，所以似然函数可以直接使用（联合）概率密度函数的值。</p>
<p><img src="3.png" alt="1"></p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://royalsocietypublishing.org/doi/10.1098/rsta.1922.0009<a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>理论学习</category>
        <category>统计</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title>AB=I证明BA=I</title>
    <url>/posts/cdd811e7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>假设 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的方阵，存在 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BAB%3DI%7D" style="display:inline-block;margin: 0;"/> ，证明  <img src="https://math.now.sh?inline=%5Cboldsymbol%7BBA%3DI%7D" style="display:inline-block;margin: 0;"/> ，或者说  <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/> 互为逆矩阵。</p>
<span id="more"></span>
<p>首先我们看逆矩阵定义：</p>
<blockquote>
<p>一个 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 的正方矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/> 满足 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%20A%7D%3D%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BB%7D%3D%5Cboldsymbol%7BI%7D" style="display:inline-block;margin: 0;"/> 时, 就称矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/> 是矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 的逆矩阵, 记为 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="张贤达：《矩阵分析与应用》第二版
">[1]</span></a></sup>。</p>
</blockquote>
<p>也就说根据定义，证明逆矩阵需要证明两边均成立，即  <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%20A%7D%3D%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BB%7D%3D%5Cboldsymbol%7BI%7D" style="display:inline-block;margin: 0;"/> ，这里我们提出的问题就是只要证明一边就行了。</p>
<h1>第一种证明：根据秩的性质</h1>
<p>我们可以根据秩的一个性质来证明<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://math.stackexchange.com/questions/3852/if-ab-i-then-ba-i
">[2]</span></a></sup>，存在</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Brank%7D%28%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BB%7D%29%20%5Cleqslant%20%5Cmin%20%5C%7B%5Coperatorname%7Brank%7D(%5Cboldsymbol%7BA%7D)%2C%20%5Coperatorname%7Brank%7D(%5Cboldsymbol%7BB%7D)%5C%7D%0A" /></p><p>因为 <img src="https://math.now.sh?inline=rank%28%5Cboldsymbol%7BAB%7D%29%20%3D%20rank(%5Cboldsymbol%7BI%7D)%20%3D%20n" style="display:inline-block;margin: 0;"/> ，所以 <img src="https://math.now.sh?inline=rank%28%5Cboldsymbol%7BA%7D%29%20%5Cgeq%20n" style="display:inline-block;margin: 0;"/> ， <img src="https://math.now.sh?inline=rank%28%5Cboldsymbol%7BB%7D%29%20%5Cgeq%20n" style="display:inline-block;margin: 0;"/>  ，由于<img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/> 的秩最大为 n，所以  <img src="https://math.now.sh?inline=rank%28%5Cboldsymbol%7BA%7D%29%20%3D%20rank(%5Cboldsymbol%7BB%7D)%3D%20n" style="display:inline-block;margin: 0;"/> ，二者均为非奇异矩阵。所以</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7BA%5E%7B-1%7DAB%3DA%5E%7B-1%7DI%7D%20%5Cquad%20%5CRightarrow%20%5Cquad%20%5Cboldsymbol%7BB%3DA%5E%7B-1%7D%7D%0A" /></p><p>所以， <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/> 互为逆矩阵。</p>
<h1>第二种证明：根据行列式的性质</h1>
<p style=""><img src="https://math.now.sh?from=det%28%5Cboldsymbol%7BAB%7D%29%3Ddet(%5Cboldsymbol%7BA%7D)det(%5Cboldsymbol%7BB%7D)%3Ddet(%5Cboldsymbol%7BI%7D)%3D1%20%5C%5C%0A%5Ctherefore%20det(%5Cboldsymbol%7BA%7D)%20%5Cneq%200%2C%20%5Cquad%20det(%5Cboldsymbol%7BB%7D)%20%5Cneq%200%0A" /></p><p>因此  <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/>  均为非奇异矩阵，证明二者互逆同上。</p>
<h1>第三种证明：根据齐次方程解的数目</h1>
<p>假设 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BBX%3D0%7D" style="display:inline-block;margin: 0;"/> 是一个齐次方程组，存在<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/product-equals-identity-implies-invertible.html">[3]</span></a></sup></p>
<p style=""><img src="https://math.now.sh?from=B%20X%3D0%20%5CLongrightarrow%20A%28B%20X%29%3DA%200%20%5CLongrightarrow(A%20B)%20X%3D0%20%5CLongrightarrow%20I%20X%3D0%20%5CRightarrow%20X%3D0%0A" /></p><p>因此，<img src="https://math.now.sh?inline=%5Cboldsymbol%7BX%3D0%7D" style="display:inline-block;margin: 0;"/> 是该齐次方程组的<strong>唯一解</strong>，所以 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/> 为非奇异矩阵，证明二者互逆同上。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">张贤达：《矩阵分析与应用》第二版<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://math.stackexchange.com/questions/3852/if-ab-i-then-ba-i<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/product-equals-identity-implies-invertible.html<a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵微分与正规方程组推导</title>
    <url>/posts/55264e6f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在看吴恩达老师CS229课程时，看吴老师推导线性回归的<strong>正规方程组</strong>（<img src="https://math.now.sh?inline=X%5E%7BT%7D%20X%20%5Ctheta%3DX%5E%7BT%7D%20y" style="display:inline-block;margin: 0;"/>）时，感觉不是很系统，而且引入了一个新的概念，<strong>矩阵求导</strong>。这部分内容之前上育种课的时候就感觉云里雾里，这次花了些时间，把这一部分内容搞懂了。</p>
<span id="more"></span> 
<h1>问题描述</h1>
<p>线性回归可以用向量的形式描述为下式（向量表示为加粗的小写字母，默认为竖向量；矩阵表示为加粗的大写字母，下同）</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7By%3DX%5Cbeta%2Be%7D%0A" /></p><p>根据最小二乘法，代价函数定义为 （假设样本数为 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/>，参数数目为 <img src="https://math.now.sh?inline=n%2B1" style="display:inline-block;margin: 0;"/>, 使用向量外积转为向量乘法形式）:</p>
<p style=""><img src="https://math.now.sh?from=J%28%5Cboldsymbol%7B%5Cbeta%7D%29%20%20%3D%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft(h_%7B%5Cbeta%7D%5Cleft(x%5E%7B(i)%7D%5Cright)-y%5E%7B(i)%7D%5Cright)%5E%7B2%7D%20%3D%20%0A%5Cfrac%7B1%7D%7B2%7D%5Cboldsymbol%7B(X%20%5Cbeta-y)%5E%7BT%7D(X%20%5Cbeta-y)%7D%20%5C%5C%0A" /></p><p>我们需要寻找使得代价函数（平方误差和或均方误差）最小的一组常数 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> ，这是一个优化问题（求一个函数的极值：极大值或极小值）。</p>
<p>在高中就学过，一个函数的极值往往是其导数为0的位置，因此我们需要求使得代价函数的导数为0（梯度为 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B0%7D" style="display:inline-block;margin: 0;"/> 向量）的 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 值，而这就牵涉到了矩阵微分或矩阵求导。（实际上，一阶导数为0的点仅仅是一个驻点或称平稳点，一阶导数为0仅仅是全局极小点的<strong>必要不充分</strong>条件。但是最小二乘的代价函数是一个凸函数，因此一阶导为0的点就是全局极小点，这些概念具体可见张贤达老师的《矩阵分析与应用》<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="张贤达《矩阵分析与应用（第二版）》">[1]</span></a></sup>。）</p>
<p>所以，这里需要先了解矩阵微分的一些概念和知识，这一部分内容同样见于张贤达老师的书<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="张贤达《矩阵分析与应用（第二版）》">[1]</span></a></sup>，知乎上也有人进行了一些梳理<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="https://zhuanlan.zhihu.com/p/305171795">[2]</span></a></sup>。</p>
<h1>矩阵微分</h1>
<h2 id="梯度矩阵定义">梯度矩阵定义</h2>
<p>首先，我们将线性代数中的函数依据其输入输出划分为下面这些类型，输入可以为向量或矩阵，输出可以分为标量、向量和矩阵（函数定义就是一个映射关系，线性代数里的函数仅仅是将输入输出换成了向量和矩阵，比如矩阵乘法 <img src="https://math.now.sh?inline=f%28%5Cboldsymbol%7Bx%7D%29%20%3D%20%5Cboldsymbol%7BAx%7D" style="display:inline-block;margin: 0;"/> 就是一个映射/函数）。</p>
<p><img src="1.png" alt="1"></p>
<p>这里只考虑<strong>输入为一个向量的标量函数</strong>（<img src="https://math.now.sh?inline=R%5Em%20%5Crightarrow%20R" style="display:inline-block;margin: 0;"/> ）。</p>
<p>矩阵微分有两种定义方式，一种称为 Jacobian 矩阵，一种称为梯度矩阵，二者的内容均为<strong>偏导数</strong>，仅仅是结果的布局不同，互为转置矩阵。这里只说梯度矩阵，更详细的内容见张贤达老师的书。</p>
<p>实值标量函数 <img src="https://math.now.sh?inline=f%28x%29" style="display:inline-block;margin: 0;"/> 的梯度向量 <img src="https://math.now.sh?inline=%5Cnabla_%7B%5Cboldsymbol%7Bx%7D%7D%20f%28%5Cboldsymbol%7Bx%7D%29" style="display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=m%20%5Ctimes%201" style="display:inline-block;margin: 0;"/> 列向量, 定义为 (输入为一个向量，输出为一个标量)</p>
<p style=""><img src="https://math.now.sh?from=%5Cnabla_%7B%5Cboldsymbol%7Bx%7D%7D%20f%28%5Cboldsymbol%7Bx%7D%29%20%5Cstackrel%7B%5Ctext%20%7B%20def%20%7D%7D%7B%3D%7D%5Cleft%5B%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20x_%7B1%7D%7D%2C%20%5Ccdots%2C%20%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20x_%7Bm%7D%7D%5Cright%5D%5E%7B%5Cmathrm%7BT%7D%7D%3D%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%7D%0A" /></p><h2 id="梯度矩阵性质">梯度矩阵性质</h2>
<h2 id="梯度矩阵计算">梯度矩阵计算</h2>
<p>那么我们如何计算一个梯度函数的梯度向量或梯度矩阵呢？你可以直接通过定义拆分成元素级别来计算，</p>
<p>例如求实值函数 <img src="https://math.now.sh?inline=f%28x%29%3D%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D" style="display:inline-block;margin: 0;"/> 的梯度矩阵。由于 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%3D%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%20%5Csum_%7Bl%3D1%7D%5E%7Bn%7D%20a_%7Bk%20l%7D%20x_%7Bk%7D%20x_%7Bl%7D" style="display:inline-block;margin: 0;"/>, 故可求出梯度向量 <img src="https://math.now.sh?inline=%5Cfrac%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%7D%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%7D" style="display:inline-block;margin: 0;"/> 的第 <img src="https://math.now.sh?inline=i" style="display:inline-block;margin: 0;"/> 个分量为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5B%5Cfrac%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%7D%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%7D%5Cright%5D_%7Bi%7D%3D%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20x_%7Bi%7D%7D%20%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%20%5Csum_%7Bl%3D1%7D%5E%7Bn%7D%20a_%7Bk%20l%7D%20x_%7Bk%7D%20x_%7Bl%7D%3D%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%20x_%7Bk%7D%20a_%7Bk%20i%7D%2B%5Csum_%7Bl%3D1%7D%5E%7Bn%7D%20x_%7Bl%7D%20a_%7Bi%20l%7D%20%3D%20%5Cboldsymbol%7B%28A%5E%7BT%7Dx%7D%29_%7Bi%7D%20%2B%20%5Cboldsymbol%7B(Ax%7D)_%7Bi%7D%0A" /></p><p>立即得梯度向量 <img src="https://math.now.sh?inline=%5Cnabla_%7B%5Cboldsymbol%7BX%7D%7D%20f%28%5Cboldsymbol%7Bx%7D%29%3D%5Cleft(%5Cboldsymbol%7BA%5ET%7D%2B%5Cboldsymbol%7BA%7D%5Cright)%20%5Cboldsymbol%7Bx%7D_%7B%5Ctext%20%7B%E3%80%82%20%7D%7D" style="display:inline-block;margin: 0;"/></p>
<p>但是这样做很麻烦，而已有的函数可能不好拆解成元素级别的式子，也不符合线性代数一向简洁的特点。</p>
<p>我们可以通过一个<strong>矩阵微分</strong>的性质来求解梯度矩阵，下面就简单介绍一下<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="张贤达《矩阵分析与应用（第二版）》">[1]</span></a></sup>。在介绍矩阵微分之前，需要掌握一些<strong>矩阵的迹</strong>的性质</p>
<h3 id="矩阵的迹">矩阵的迹</h3>
<p><strong>定义</strong> $ n \times n$ 矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 的对角元素之和称为 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 的迹 (trace), 记作 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BA%7D%29" style="display:inline-block;margin: 0;"/>, 即有</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BA%7D%29%3Da_%7B11%7D%2B%5Ccdots%2Ba_%7Bn%20n%7D%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20a_%7Bi%20i%7D%0A" /></p><p><strong>非正方矩阵无迹的定义</strong>。</p>
<p>下面是矩阵的迹满足的一些性质。</p>
<p>(1) 若 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/> 均为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 矩阵, 则 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BA%7D%20%5Cpm%20%5Cboldsymbol%7BB%7D%29%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BA%7D)%20%5Cpm%20%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BB%7D)" style="display:inline-block;margin: 0;"/> 。<br>
(2) 若 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/> 均为 <img src="https://math.now.sh?inline=n%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 矩阵, 并且 <img src="https://math.now.sh?inline=c_%7B1%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=c_%7B2%7D" style="display:inline-block;margin: 0;"/> 为常数, 则 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28c_%7B1%7D%20%5Cboldsymbol%7BA%7D%20%5Cpm%20c_%7B2%7D%20%5Cboldsymbol%7BB%7D%5Cright%29%3Dc_%7B1%7D%20%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BA%7D)%20%5Cpm" style="display:inline-block;margin: 0;"/> <img src="https://math.now.sh?inline=c_%7B2%7D%20%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BB%7D%29" style="display:inline-block;margin: 0;"/> 。特别地, 若 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%7D%3D%5Cboldsymbol%7BO%7D" style="display:inline-block;margin: 0;"/>, 则 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%28c%20%5Cboldsymbol%7BA%7D%29%3Dc%20%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BA%7D)" style="display:inline-block;margin: 0;"/> 。<br>
(3) 矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 的转置、复数共轭和复共轭转置的迹分别为 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%5Cright%29%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BA%7D)%2C%20%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7BA%7D%5E%7B*%7D%5Cright)%3D" style="display:inline-block;margin: 0;"/> <img src="https://math.now.sh?inline=%5B%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BA%7D%29%5D%5E%7B*%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BH%7D%7D%5Cright%29%3D%5B%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BA%7D)%5D%5E%7B*%7D%7B%20%7D%5E%7B%5Ccirc%7D" style="display:inline-block;margin: 0;"/><br>
(4) 若 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D%20%5Cin%20%5Cmathbb%7BC%7D%5E%7Bm%20%5Ctimes%20n%7D%2C%20%5Cboldsymbol%7BB%7D%20%5Cin%20%5Cmathbb%7BC%7D%5E%7Bn%20%5Ctimes%20m%7D" style="display:inline-block;margin: 0;"/>, 则 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BA%20B%7D%29%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BB%7D%20%5Cboldsymbol%7BA%7D)" style="display:inline-block;margin: 0;"/> 。</p>
<p>证明，运用矩阵乘法，存在下式</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Btr%7D%28A%20B%29%20%26%3D%5Csum_%7Bi%3D1%7D%5E%7BM%7D%20A%20B_%7Bi%20i%7D%20%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20A_%7Bi%20j%7D%20B_%7Bj%20i%7D%0A%5Cend%7Baligned%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Btr%7D%28B%20A%29%20%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20B%20A_%7Bj%20j%7D%20%5C%5C%0A%26%3D%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%20B_%7Bji%7D%20A_%7Bi%20j%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>观察一下，得知二者相等，得证 <img src="https://math.now.sh?inline=tr%28AB%29%20%3D%20tr(BA)" style="display:inline-block;margin: 0;"/> 。</p>
<p>(5) 若 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 是一个 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 矩阵, 则 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BH%7D%7D%20%5Cboldsymbol%7BA%7D%5Cright%29%3D0%20%5CLongleftrightarrow%20%5Cboldsymbol%7BA%7D%3D%5Cboldsymbol%7BO%7D_%7Bm%20%5Ctimes%20n%7D(" style="display:inline-block;margin: 0;"/> 零矩阵 <img src="https://math.now.sh?inline=%29" style="display:inline-block;margin: 0;"/> 。</p>
<p>证明</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%20%5Coperatorname%7Btr%7D%5Cleft%28A%5E%7BT%7D%20A%5Cright%29%20%5C%5C%0A%3D%26%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20(A%5E%7BT%7D%20A)_%7Bi%20i%7D%20%5C%5C%0A%3D%26%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Csum_%7Bj%3D1%7D%5E%7Bm%7D%20A_%7Bi%20j%7D%5E%7BT%7D%20A_%7Bj%20i%7D%20%5C%5C%0A%3D%26%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bm%7D%20A_%7Bj%20i%7D%5E%7B2%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，<img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%28%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BH%7D%7D%20%5Cboldsymbol%7BA%7D%5Cright%29%3D0%20%5CLongleftrightarrow%20%5Cboldsymbol%7BA%7D%3D%5Cboldsymbol%7BO%7D_%7Bm%20%5Ctimes%20n%7D" style="display:inline-block;margin: 0;"/><br>
(6) <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BH%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%3D%5Coperatorname%7Btr%7D%5Cleft%28%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%20%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BH%7D%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7By%7D%5E%7B%5Cmathrm%7BH%7D%7D%20%5Cboldsymbol%7Bx%7D%3D%5Coperatorname%7Btr%7D%5Cleft%28%5Cboldsymbol%7Bx%7D%20%5Cboldsymbol%7By%7D%5E%7B%5Cmathrm%7BH%7D%7D%5Cright%29" style="display:inline-block;margin: 0;"/>。</p>
<p>证明：这里只证明前半部分，后半部分我直接脑补出来了。</p>
<p style=""><img src="https://math.now.sh?from=x_%7Bn%20%5Ctimes%201%7D%3D%5Cleft%28x_%7Bi%7D%5Cright%29%2C%20%5Cquad%20A_%7Bn%20%5Ctimes%20n%7D%3D%5Cleft%5Ba_%7Bi%20j%7D%5Cright%5D%5C%5C%0A" /></p><p>设</p>
<p style=""><img src="https://math.now.sh?from=B%3Dx%20x%5E%7BT%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D%0Ax_%7B1%7D%5E%7B2%7D%20%26%20x_%7B1%7D%20x_%7B2%7D%20%26%20%5Ccdots%20%26%20x_%7B1%7D%20x_%7Bn%7D%20%5C%5C%0A%5Cvdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Cvdots%20%5C%5C%0Ax_%7Bn%7D%20x_%7B1%7D%20%26%20x_%7Bn%7D%20x_%7B2%7D%20%26%20%5Ccdots%20%26%20x_%7Bn%7D%20x_%7Bn%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Atr%28Axx%5E%7BT%7D%29%0A%26%3D%5Coperatorname%7Btr%7D(A%20B)%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D(A%20B)_%7Bi%20i%7D%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20A_%7Bi%20j%7D%20B_%7Bj%20i%7D%5C%5C%0A%26%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20a_%7Bi%20j%7D%20x_%7Bj%7D%20x_%7Bi%7D%5C%5C%0A%26%3Dx%5E%7BT%7D%20A%20x%0A%5Cend%7Baligned%7D%0A" /></p><p>(7) 迹等于特征值之和, 即 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BA%7D%29%3D%5Clambda_%7B1%7D%2B%5Ccdots%2B%5Clambda_%7Bn%7D" style="display:inline-block;margin: 0;"/> 。<br>
(8) 分块矩阵的迹满足</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cboldsymbol%7BA%7D%20%26%20%5Cboldsymbol%7BB%7D%20%5C%5C%0A%5Cboldsymbol%7BC%7D%20%26%20%5Cboldsymbol%7BD%7D%0A%5Cend%7Barray%7D%5Cright%5D%3D%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BA%7D%29%2B%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BD%7D)%0A" /></p><p>式中, <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D%20%5Cin%20%5Cmathbb%7BC%7D%5E%7Bm%20%5Ctimes%20m%7D%2C%20%5Cboldsymbol%7BB%7D%20%5Cin%20%5Cmathbb%7BC%7D%5E%7Bm%20%5Ctimes%20n%7D%2C%20%5Cboldsymbol%7BC%7D%20%5Cin%20%5Cmathbb%7BC%7D%5E%7Bn%20%5Ctimes%20m%7D%2C%20%5Cboldsymbol%7BD%7D%20%5Cin%20%5Cmathbb%7BC%7D%5E%7Bn%20%5Ctimes%20n%7D" style="display:inline-block;margin: 0;"/> 。<br>
(9) 对于任何正整数 <img src="https://math.now.sh?inline=k" style="display:inline-block;margin: 0;"/>, 有</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%28%5Cboldsymbol%7BA%7D%5E%7Bk%7D%5Cright%29%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Clambda_%7Bi%7D%5E%7Bk%7D%0A" /></p><p>灵活运用迹的等式 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BU%7D%20%5Cboldsymbol%7BV%7D%29%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BV%7D%20%5Cboldsymbol%7BU%7D)" style="display:inline-block;margin: 0;"/>, 可以得到一些常用的重要结果。例如, 矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BH%7D%7D%20%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%20A%7D%5E%7B%5Cmathrm%7BH%7D%7D" style="display:inline-block;margin: 0;"/> 的迹相等, 且有</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%28%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BH%7D%7D%20%5Cboldsymbol%7BA%7D%5Cright%29%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BH%7D%7D%5Cright)%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20a_%7Bi%20j%7D%20a_%7Bi%20j%7D%5E%7B*%7D%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%5Cleft%7Ca_%7Bi%20j%7D%5Cright%7C%5E%7B2%7D%0A" /></p><p>又如, 在迹的等式 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BU%7D%20%5Cboldsymbol%7BV%7D%29%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BV%7D%20%5Cboldsymbol%7BU%7D)" style="display:inline-block;margin: 0;"/> 中, 若分别令 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BU%7D%3D%5Cboldsymbol%7BA%7D%2C%20%5Cboldsymbol%7BV%7D%3D%5Cboldsymbol%7BB%7D%20%5Cboldsymbol%7BC%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=U%3DA%20%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=%5Cboldsymbol%7BV%7D%3D%5Cboldsymbol%7BC%7D" style="display:inline-block;margin: 0;"/>, 则有</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BA%20B%20C%7D%29%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BB%20C%20A%7D)%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BC%20A%20B%7D)%0A" /></p><p>类似地, 若分别令 <img src="https://math.now.sh?inline=U%3DA%2C%20V%3DB%20C%20D%20%3B%20U%3DA%20B%2C%20V%3DC%20D" style="display:inline-block;margin: 0;"/> 及 <img src="https://math.now.sh?inline=U%3DA%20B%20C%2C%20V%3DD" style="display:inline-block;margin: 0;"/>, 又有</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BA%20B%20C%20D%7D%29%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BB%20C%20D%20A%7D)%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BC%20D%20A%20B%7D)%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BD%7D%20%5Cboldsymbol%7BA%20B%20C%7D)%0A" /></p><p>利用上式还易知, 若矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 与 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/> 均为 <img src="https://math.now.sh?inline=m%20%5Ctimes%20m" style="display:inline-block;margin: 0;"/> 矩阵, 且 <img src="https://math.now.sh?inline=B" style="display:inline-block;margin: 0;"/> 非奇异, 则</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Btr%7D%5Cleft%28%5Cboldsymbol%7BB%7D%20%5Cboldsymbol%7BA%20B%7D%5E%7B-1%7D%5Cright%29%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7BB%7D%5E%7B-1%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7BB%7D%5Cright)%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7BA%20B%20B%7D%5E%7B-1%7D%5Cright)%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BA%7D)%0A" /></p><h3 id="一阶矩阵微分">一阶矩阵微分</h3>
<h3 id="一阶实矩阵微分">一阶实矩阵微分</h3>
<p>矩阵微分用符号 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D" style="display:inline-block;margin: 0;"/> 表示, 定义为 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D%3D%5Cleft%5B%5Cmathrm%7Bd%7D%20X_%7Bi%20j%7D%5Cright%5D_%7Bi%3D1%2C%20j%3D1%7D%5E%7Bm%2C%20n%7D" style="display:inline-block;margin: 0;"/> 。<br>
例 考虑标量函数 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BU%7D%29" style="display:inline-block;margin: 0;"/> 的微分, 得</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7Bd%7D%28%5Coperatorname%7Btr%7D%20%5Cboldsymbol%7BU%7D%29%3D%5Cmathrm%7Bd%7D%5Cleft(%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20u_%7Bi%20i%7D%5Cright)%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Cmathrm%7B~d%7D%20u_%7Bi%20i%7D%3D%5Coperatorname%7Btr%7D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BU%7D)%0A" /></p><p>即有 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%28%5Coperatorname%7Btr%7D%20%5Cboldsymbol%7BU%7D%29%3D%5Coperatorname%7Btr%7D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BU%7D)" style="display:inline-block;margin: 0;"/> 。<br>
例 考虑矩阵乘积 <img src="https://math.now.sh?inline=U%20V" style="display:inline-block;margin: 0;"/> 的微分矩阵, 有</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5B%5Cmathrm%7Bd%7D%28%5Cboldsymbol%7BU%7D%20%5Cboldsymbol%7BV%7D%29%5D_%7Bi%20j%7D%20%26%3D%5Cmathrm%7Bd%7D%5Cleft(%5B%5Cboldsymbol%7BU%7D%20%5Cboldsymbol%7BV%7D%5D_%7Bi%20j%7D%5Cright)%3D%5Cmathrm%7Bd%7D%5Cleft(%5Csum_%7Bk%7D%20u_%7Bi%20k%7D%20v_%7Bk%20j%7D%5Cright)%3D%5Csum_%7Bk%7D%20%5Cmathrm%7B~d%7D%5Cleft(u_%7Bi%20k%7D%20v_%7Bk%20j%7D%5Cright)%20%5C%5C%0A%26%3D%5Csum_%7Bk%7D%5Cleft%5B%5Cleft(%5Cmathrm%7B~d%7D%20u_%7Bi%20k%7D%5Cright)%20v_%7Bk%20j%7D%2Bu_%7Bi%20k%7D%20%5Cmathrm%7B~d%7D%20v_%7Bk%20j%7D%5Cright%5D%3D%5Csum_%7Bk%7D%5Cleft(%5Cmathrm%7B~d%7D%20u_%7Bi%20k%7D%5Cright)%20v_%7Bk%20j%7D%2B%5Csum_%7Bk%7D%20u_%7Bi%20k%7D%20%5Cmathrm%7B~d%7D%20v_%7Bk%20j%7D%20%5C%5C%0A%26%3D%5B(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BU%7D)%20%5Cboldsymbol%7BV%7D%5D_%7Bi%20j%7D%2B%5B%5Cboldsymbol%7BU%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BV%7D%5D_%7Bi%20j%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>从而得 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%28%5Cboldsymbol%7BU%7D%20%5Cboldsymbol%7BV%7D%29%3D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BU%7D)%20%5Cboldsymbol%7BV%7D%2B%5Cboldsymbol%7BU%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BV%7D" style="display:inline-block;margin: 0;"/> 。<br>
以上举例表明, 实矩阵微分具有以下两个基本性质:<br>
<strong>转置</strong> 矩阵转置的微分等于矩阵微分的转置, 即有 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%5Cleft%28%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%5Cright%29%3D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D)%5E%7B%5Cmathrm%7BT%7D%7D" style="display:inline-block;margin: 0;"/> 。<br>
<strong>线性</strong> <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%28%5Calpha%20%5Cboldsymbol%7BX%7D%2B%5Cbeta%20%5Cboldsymbol%7BY%7D%29%3D%5Calpha%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D%2B%5Cbeta%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BY%7D" style="display:inline-block;margin: 0;"/> 。<br>
下面汇总了矩阵微分的常用计算公式  。<br>
(1) 常数矩阵的微分矩阵为零矩阵, 即 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BA%7D%3D%5Cboldsymbol%7BO%7D" style="display:inline-block;margin: 0;"/> 。<br>
(2) 常数 <img src="https://math.now.sh?inline=%5Calpha" style="display:inline-block;margin: 0;"/> 与矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BX%7D" style="display:inline-block;margin: 0;"/> 的乘积的微分矩阵 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%28%5Calpha%20%5Cboldsymbol%7BX%7D%29%3D%5Calpha%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D" style="display:inline-block;margin: 0;"/> 。<br>
(3) 矩阵转置的微分矩阵等于原矩阵的微分矩阵的转置, 即 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%5Cleft%28%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%5Cright%29%3D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D)%5E%7B%5Cmathrm%7BT%7D%7D" style="display:inline-block;margin: 0;"/> 。<br>
(4) 两个矩阵函数的和 (差) 的微分矩阵为 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%28%5Cboldsymbol%7BU%7D%20%5Cpm%20%5Cboldsymbol%7BV%7D%29%3D%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BU%7D%20%5Cpm%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BV%7D" style="display:inline-block;margin: 0;"/> 。<br>
(5) 常数矩阵与矩阵乘积的微分矩阵为 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%28%5Cboldsymbol%7BA%20X%7D%20%5Cboldsymbol%7BB%7D%29%3D%5Cboldsymbol%7BA%7D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D)%20%5Cboldsymbol%7BB%7D" style="display:inline-block;margin: 0;"/> 。<br>
(6) 矩阵函数 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BU%7D%3D%5Cboldsymbol%7BF%7D%28%5Cboldsymbol%7BX%7D%29%2C%20%5Cboldsymbol%7BV%7D%3D%5Cboldsymbol%7BG%7D(%5Cboldsymbol%7BX%7D)%2C%20%5Cboldsymbol%7BW%7D%3D%5Cboldsymbol%7BH%7D(%5Cboldsymbol%7BX%7D)" style="display:inline-block;margin: 0;"/> 乘积的微分矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathrm%7Bd%7D%28%5Cboldsymbol%7BU%7D%20%5Cboldsymbol%7BV%7D%29%20%26%3D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BU%7D)%20%5Cboldsymbol%7BV%7D%2B%5Cboldsymbol%7BU%7D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BV%7D)%20%5C%5C%0A%5Cmathrm%7Bd%7D(%5Cboldsymbol%7BU%7D%20%5Cboldsymbol%7BV%7D%20%5Cboldsymbol%7BW%7D)%20%26%3D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BU%7D)%20%5Cboldsymbol%7BV%7D%20%5Cboldsymbol%7BW%7D%2B%5Cboldsymbol%7BU%7D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BV%7D)%20%5Cboldsymbol%7BW%7D%2B%5Cboldsymbol%7BU%7D%20%5Cboldsymbol%7BV%7D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BW%7D)%0A%5Cend%7Baligned%7D%0A" /></p><p>(7) 矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BX%7D" style="display:inline-block;margin: 0;"/> 的迹的矩阵微分 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%28%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BX%7D%29)" style="display:inline-block;margin: 0;"/> 等于矩阵微分 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D" style="display:inline-block;margin: 0;"/> 的迹 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%28%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D%29" style="display:inline-block;margin: 0;"/>, 即</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7Bd%7D%28%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BX%7D%29)%3D%5Coperatorname%7Btr%7D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D)%0A" /></p><p>特别地, 矩阵函数 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BF%7D%28%5Cboldsymbol%7BX%7D%29" style="display:inline-block;margin: 0;"/> 的迹的矩阵微分为 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%28%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BF%7D(%5Cboldsymbol%7BX%7D%29))%3D%5Coperatorname%7Btr%7D(%5Cmathrm%7Bd%7D(%5Cboldsymbol%7BF%7D(%5Cboldsymbol%7BX%7D)))" style="display:inline-block;margin: 0;"/> 。</p>
<h3 id="标量函数的梯度矩阵辨识">标量函数的梯度矩阵辨识</h3>
<p>在多变量函数的微积分中, 称多变量函数 <img src="https://math.now.sh?inline=f%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 在点 <img src="https://math.now.sh?inline=%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 可微分, 若 <img src="https://math.now.sh?inline=f%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 的全改变量可以写作</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5CDelta%20f%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%5Cright%29%20%26%3Df%5Cleft(x_%7B1%7D%2B%5CDelta%20x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%2B%5CDelta%20x_%7Bm%7D%5Cright)-f%5Cleft(x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%5Cright)%20%5C%5C%0A%26%3DA_%7B1%7D%20%5CDelta%20x_%7B1%7D%2B%5Ccdots%2BA_%7Bm%7D%20%5CDelta%20x_%7Bm%7D%2BO%5Cleft(%5CDelta%20x_%7B1%7D%2C%20%5Ccdots%2C%20%5CDelta%20x_%7Bm%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>式中, <img src="https://math.now.sh?inline=A_%7B1%7D%2C%20%5Ccdots%2C%20A_%7Bm%7D" style="display:inline-block;margin: 0;"/> 分别与 <img src="https://math.now.sh?inline=%5CDelta%20x_%7B1%7D%2C%20%5Ccdots%2C%20%5CDelta%20x_%7Bm%7D" style="display:inline-block;margin: 0;"/> 无关, 而 <img src="https://math.now.sh?inline=O%5Cleft%28%5CDelta%20x_%7B1%7D%2C%20%5Ccdots%2C%20%5CDelta%20x_%7Bm%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 表示偏改变量 <img src="https://math.now.sh?inline=%5CDelta%20x_%7B1%7D" style="display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=%5Ccdots%2C%20%5CDelta%20x_%7Bm%7D" style="display:inline-block;margin: 0;"/> 的二阶及高阶项。这时，函数 <img src="https://math.now.sh?inline=f%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 的偏导数 <img src="https://math.now.sh?inline=%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7B1%7D%7D%2C%20%5Ccdots%2C%20%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7Bm%7D%7D" style="display:inline-block;margin: 0;"/> 一定存在,</p>
<p>并且</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7B1%7D%7D%3DA_%7B1%7D%2C%20%5Cquad%20%5Ccdots%20%5Cquad%2C%20%5Cquad%20%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7Bm%7D%7D%3DA_%7Bm%7D%0A" /></p><p>全改变量 <img src="https://math.now.sh?inline=%5CDelta%20f%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 的线性主部</p>
<p style=""><img src="https://math.now.sh?from=A_%7B1%7D%20%5CDelta%20x_%7B1%7D%2B%5Ccdots%2BA_%7Bm%7D%20%5CDelta%20x_%7Bm%7D%3D%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7B1%7D%7D%20%5Cmathrm%7B~d%7D%20x_%7B1%7D%2B%5Ccdots%2B%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7Bm%7D%7D%20%5Cmathrm%7B~d%7D%20x_%7Bm%7D%0A" /></p><p>称为多变量函数 <img src="https://math.now.sh?inline=f%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 的全微分, 记为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7Bd%7D%20f%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%5Cright%29%3D%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7B1%7D%7D%20%5Cmathrm%7B~d%7D%20x_%7B1%7D%2B%5Ccdots%2B%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7Bm%7D%7D%20%5Cmathrm%7B~d%7D%20x_%7Bm%7D%0A" /></p><p><strong>多变量函数 <img src="https://math.now.sh?inline=f%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 在点 <img src="https://math.now.sh?inline=%5Cleft%28x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 可微分的充分条件是: 偏导数 <img src="https://math.now.sh?inline=%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7B1%7D%7D%2C%20%5Ccdots" style="display:inline-block;margin: 0;"/>, <img src="https://math.now.sh?inline=%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7Bm%7D%7D" style="display:inline-block;margin: 0;"/> 均存在, 并且连续。</strong><br>
一阶实矩阵微分为、 矩阵的辨识提供了一种有效的方法。</p>
<h4 id="标量函数-f-boldsymbol-x-的梯度矩阵辩识">标量函数 <img src="https://math.now.sh?inline=f%28%5Cboldsymbol%7Bx%7D%29" style="display:inline-block;margin: 0;"/> 的梯度矩阵辩识</h4>
<p>考虑标量函数 <img src="https://math.now.sh?inline=f%28x%29" style="display:inline-block;margin: 0;"/>, 其变元向量 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%3D%5Cleft%5Bx_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D%5Cright%5D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cin%20%5Cmathbb%7BR%7D%5E%7Bm%7D" style="display:inline-block;margin: 0;"/> 。将变元向量的元素 <img src="https://math.now.sh?inline=x_%7B1%7D%2C%20%5Ccdots%2C%20x_%7Bm%7D" style="display:inline-block;margin: 0;"/> 视为 <img src="https://math.now.sh?inline=m" style="display:inline-block;margin: 0;"/> 个变量, 利用式 (3.2.14), 可以直接引出以向量为变元的标量函数 <img src="https://math.now.sh?inline=f%28%5Cboldsymbol%7Bx%7D%29" style="display:inline-block;margin: 0;"/> 的全微分表达式</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathrm%7Bd%7D%20f%28%5Cboldsymbol%7Bx%7D%29%20%26%3D%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20x_%7B1%7D%7D%20%5Cmathrm%7B~d%7D%20x_%7B1%7D%2B%5Ccdots%2B%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20x_%7Bm%7D%7D%20%5Cmathrm%7B~d%7D%20x_%7Bm%7D%20%5C%5C%0A%26%3D%5Cleft%5B%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20x_%7B1%7D%7D%2C%20%5Ccdots%2C%20%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20x_%7Bm%7D%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%0A%5Cmathrm%7Bd%7D%20x_%7B1%7D%20%5C%5C%0A%5Cvdots%20%5C%5C%0A%5Cmathrm%7Bd%7D%20x_%7Bm%7D%0A%5Cend%7Barray%7D%5Cright%5D%0A%5Cend%7Baligned%7D%0A" /></p><p>或简记为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7Bd%7D%20f%28%5Cboldsymbol%7Bx%7D%29%3D%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D%3D(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D)%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%7D%0A" /></p><p>式中</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Bgathered%7D%0A%5Cfrac%7B%5Cpartial%20f%28%5Cboldsymbol%7Bx%7D%29%7D%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%7D%3D%5Cleft%5B%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20x_%7B1%7D%7D%2C%20%5Ccdots%2C%20%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20x_%7Bm%7D%7D%5Cright%5D%20%5C%5C%0A%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D%3D%5Cleft%5B%5Cmathrm%7Bd%7D%20x_%7B1%7D%2C%20%5Ccdots%2C%20%5Cmathrm%7Bd%7D%20x_%7Bm%7D%5Cright%5D%5E%7B%5Cmathrm%7BT%7D%7D%0A%5Cend%7Bgathered%7D%0A" /></p><p>式 (3.2.16) 称为微分法则的向量形式, 它启示了一个重要的应用: 若令 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D%3D%5Cfrac%7B%5Cpartial%20f%28%5Cboldsymbol%7Bx%7D%29%7D%7B%5Cpartial%20%5Cboldsymbol%7Bx%5ET%7D%7D" style="display:inline-block;margin: 0;"/>, 则一阶微分可以写作迹函数形式 (第二个等号应用标量的迹等于本身)</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7Bd%7D%20f%28%5Cboldsymbol%7Bx%7D%29%3D%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BA%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D)%0A" /></p><p>这表明, 标量函数 <img src="https://math.now.sh?inline=f%28x%29" style="display:inline-block;margin: 0;"/> 的梯度矩阵与微分矩阵之间存在等价关系</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7Bd%7D%20f%28%5Cboldsymbol%7Bx%7D%29%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BA%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D)%20%5CLongleftrightarrow%20%5Cnabla_%7B%5Cboldsymbol%7Bx%7D%7D%20f(%5Cboldsymbol%7Bx%7D)%3D%5Cfrac%7B%5Cpartial%20f(%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%7D%3D%5Cboldsymbol%7BA%5ET%7D%0A" /></p><p>换言之, 若函数 <img src="https://math.now.sh?inline=f%28%5Cboldsymbol%7Bx%7D%29" style="display:inline-block;margin: 0;"/> 的微分可以写作 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%20f%28%5Cboldsymbol%7Bx%7D%29%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BA%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D)" style="display:inline-block;margin: 0;"/>, 则矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 就是函数 <img src="https://math.now.sh?inline=f%28%5Cboldsymbol%7Bx%7D%29" style="display:inline-block;margin: 0;"/> 关于 其变元向量 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D" style="display:inline-block;margin: 0;"/> 的 梯度矩阵的转置。</p>
<p>因此，我们得到了一个计算梯度矩阵的有效方法:</p>
<p>(1) 求实值函数 <img src="https://math.now.sh?inline=f%28%5Cboldsymbol%7BX%7D%29" style="display:inline-block;margin: 0;"/> 相对于变元矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BX%7D" style="display:inline-block;margin: 0;"/> 的矩阵微分 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%20f%28%5Cboldsymbol%7BX%7D%29" style="display:inline-block;margin: 0;"/>, 并将其表示成规范形式 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%20f%28%5Cboldsymbol%7BX%7D%29%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BA%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D)" style="display:inline-block;margin: 0;"/>;<br>
(2) 实值函数 <img src="https://math.now.sh?inline=f%28%5Cboldsymbol%7BX%7D%29" style="display:inline-block;margin: 0;"/> 相对于 <img src="https://math.now.sh?inline=m%20%5Ctimes%20n" style="display:inline-block;margin: 0;"/> 变元矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BX%7D" style="display:inline-block;margin: 0;"/> 的梯度矩阵等于 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%5ET%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>此时，考察二次型函数 <img src="https://math.now.sh?inline=f%28x%29%3Dx%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D" style="display:inline-block;margin: 0;"/>, 其中, <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 是一个正方的常数矩阵。首先将标量函数写成迹函数形式, 然后利用矩阵乘积的微分易得</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathrm%7Bd%7D%20f%28%5Cboldsymbol%7Bx%7D%29%20%26%3D%5Cmathrm%7Bd%7D%5Cleft(%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%5Cright)%5Cright)%3D%5Coperatorname%7Btr%7D%5Cleft%5B(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D)%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%2B%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D%5Cright%5D%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%5Cright)%2B%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D%5Cright)%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(%5B%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%5D%5E%7B%5Cmathrm%7BT%7D%7D%5Cright)%2B%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D%5Cright)%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D%5Cright)%2B%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D%5Cright)%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%5Cleft(%5Cboldsymbol%7BA%7D%2B%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%5Cright)%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7Bx%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>直接得二次型函数 <img src="https://math.now.sh?inline=f%28%5Cboldsymbol%7Bx%7D%29%3D%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D" style="display:inline-block;margin: 0;"/> 关于变元向量 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D" style="display:inline-block;margin: 0;"/> 的梯度向量为</p>
<p style=""><img src="https://math.now.sh?from=%5Cnabla_%7B%5Cboldsymbol%7Bx%7D%7D%5Cleft%28%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%5Cright%29%3D%5Cfrac%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%7D%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%7D%3D%5Cleft%5B%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%5Cleft(%5Cboldsymbol%7BA%7D%2B%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%5Cright)%5Cright%5D%5E%7B%5Cmathrm%7BT%7D%7D%3D%5Cleft(%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%2B%5Cboldsymbol%7BA%7D%5Cright)%20%5Cboldsymbol%7Bx%7D%0A" /></p><p>显然, 若 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 为对称矩阵, 则 <img src="https://math.now.sh?inline=%5Cnabla_%7B%5Cboldsymbol%7Bx%7D%7D%5Cleft%28%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%5Cright%29%3D%5Cfrac%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D%7D%7B%5Cpartial%20%5Cboldsymbol%7Bx%7D%7D%3D2%20%5Cboldsymbol%7BA%7D%20%5Cboldsymbol%7Bx%7D" style="display:inline-block;margin: 0;"/> 。</p>
<h4 id="矩阵的标量函数：迹">矩阵的标量函数：迹</h4>
<p>根据<strong>迹</strong>的性质，我们可以得到：</p>
<p>(1) 标量函数 <img src="https://math.now.sh?inline=f%28%5Cboldsymbol%7BX%7D%29" style="display:inline-block;margin: 0;"/> 总可以写成迹函数的形式, 因为 <img src="https://math.now.sh?inline=f%28%5Cboldsymbol%7BX%7D%29%3D%5Coperatorname%7Btr%7D(f(%5Cboldsymbol%7BX%7D))" style="display:inline-block;margin: 0;"/>;<br>
(2) 无论 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D" style="display:inline-block;margin: 0;"/> 出现在迹函数内的任何位置, 总可以通过迹函数的性质 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5B%5Cboldsymbol%7BA%7D%28%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D%29%20%5Cboldsymbol%7BB%7D%5D%3D" style="display:inline-block;margin: 0;"/> <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%28%5Cboldsymbol%7BB%7D%20%5Cboldsymbol%7BA%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D%29" style="display:inline-block;margin: 0;"/>, 将 <img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D" style="display:inline-block;margin: 0;"/> 写到迹函数变量的最右端, 从而得到迹函数微分矩阵的规范形式。<br>
(3) 对于 <img src="https://math.now.sh?inline=%28%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D%29%5E%7B%5Cmathrm%7BT%7D%7D" style="display:inline-block;margin: 0;"/>, 总可以通过迹函数的性质 <img src="https://math.now.sh?inline=%5Coperatorname%7Btr%7D%5Cleft%5B%5Cboldsymbol%7BA%7D%28%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D%29%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BB%7D%5Cright%5D%3D%5Cboldsymbol%7B%5Coperatorname%7Btr%7D(B%5E%7BT%7DdXA%5ET)%7D%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7BA%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BB%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7BX%7D%5Cright)" style="display:inline-block;margin: 0;"/> , 写成迹函数微分矩阵的规范形式。</p>
<h1>推导正规方程组</h1>
<p>回到我们的问题，这里我们将最小二乘法的损失函数展开，得到</p>
<p style=""><img src="https://math.now.sh?from=J%28%5Cboldsymbol%7B%5Cbeta%7D%29%3D%5Cboldsymbol%7B(X%20%5Cbeta-y)%5E%7B%5Cmathrm%7BT%7D%7D(X%20%5Cbeta-y)%7D%3D%5Cboldsymbol%7B(%5Cbeta%5E%7B%5Cmathrm%7BT%7D%7D%20X%5E%7B%5Cmathrm%7BT%7D%7D%20-y%5E%7B%5Cmathrm%7BT%7D%7D)(X%20%5Cbeta-y)%7D%3D%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D-%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7By%7D-%5Cboldsymbol%7By%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7By%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7By%7D%0A" /></p><p>注意到，<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7By%7D%20%5Ctext%7B%20%E4%B8%8E%20%7D%20%5Cboldsymbol%7By%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 二者互为转置，并且二者均为标量，因此二者相等。损失函数写为</p>
<p style=""><img src="https://math.now.sh?from=J%28%5Cboldsymbol%7B%5Cbeta%7D%29%3D%5Cboldsymbol%7B(X%20%5Cbeta-y)%5E%7B%5Cmathrm%7BT%7D%7D(X%20%5Cbeta-y)%7D%3D%5Cboldsymbol%7B%5Cbeta%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D-2%5Cboldsymbol%7By%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%2B%5Cboldsymbol%7By%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7By%7D%0A" /></p><p>求 <img src="https://math.now.sh?inline=J%28%5Cboldsymbol%7B%5Cbeta%7D%29" style="display:inline-block;margin: 0;"/> 相对于 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的导数, 并令其结果等于零</p>
<p>求梯度向量的过程需要用到上面提到的矩阵微分的性质。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7Bd%7D%20f%28%5Cboldsymbol%7B%5Cbeta%7D%29%3D%5Coperatorname%7Btr%7D(%5Cboldsymbol%7BX%7D%20%5Cmathrm%7Bd%7D%20%5Cboldsymbol%7B%5Cbeta%7D)%20%5CLongleftrightarrow%20%5Cnabla_%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%20f(%5Cboldsymbol%7B%5Cbeta%7D)%3D%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%0A" /></p><p>证明过程如下（这里我们先求解两个子式的微分，注意到这两个子式也是标量，最后一个子式 <img src="https://math.now.sh?inline=%5Cboldsymbol%7By%5ET%20y%7D" style="display:inline-block;margin: 0;"/> 不是关于 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的式子，因此其微分矩阵为 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B0%7D" style="display:inline-block;margin: 0;"/> 矩阵）</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26d%5Cleft%28%5Cboldsymbol%7B%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X%20%5Cbeta%7D%5Cright%29%5C%5C%0A%26%3Dd%5Cleft(%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7B%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X%20%5Cbeta%7D%5Cright)%5Cright)%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(d%5Cleft(%5Cboldsymbol%7B%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X%20%5Cbeta%7D%5Cright)%5Cright)%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(d%5Cboldsymbol%7B%5Cleft(%5Cbeta%5E%7BT%7D%5Cright)%20X%5E%7BT%7D%20X%20%5Cbeta%7D%2B%5Cboldsymbol%7B%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X%20d(%5Cbeta)%7D%5Cright)%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7Bd%5Cleft(%5Cbeta%5E%7BT%7D%5Cright)%20X%5E%7BT%7D%20X%20%5Cbeta%7D%5Cright)%2B%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7B%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X%20d(%5Cbeta)%7D%5Cright)%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7B%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X%20d(%5Cbeta)%7D%5Cright)%2B%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7B%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X%20d(%5Cbeta)%7D%5Cright)%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(2%5Cboldsymbol%7B%20%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X%20d(%5Cbeta)%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%20d%5Cleft%28%5Cboldsymbol%7By%5E%7BT%7D%20X%20%5Cbeta%7D%5Cright%29%20%5C%5C%0A%3D%26%20d%5Cleft(t%20r%5Cleft(%5Cboldsymbol%7By%5E%7BT%7D%20X%20%5Cbeta%7D%5Cright)%5Cright)%20%5C%5C%0A%3D%26%20%5Coperatorname%7Btr%7D%5Cleft(d%5Cleft(%5Cboldsymbol%7By%5E%7BT%7D%20X%20%5Cbeta%7D%5Cright)%5Cright)%20%5C%5C%0A%3D%26%20%5Coperatorname%7Btr%7D%5Cleft(%5Cboldsymbol%7By%5E%7BT%7D%20X%20d(%5Cbeta)%7D%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cboldsymbol%7Bd%20%5Cbeta%7D%20%26%3Dd%5Cleft%28%5Cboldsymbol%7B%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X%20%5Cbeta-2%20y%5E%7BT%7D%20X%20%5Cbeta%2By%5E%7BT%7D%20y%7D%5Cright%29%20%5C%5C%0A%26%3Dd%5Cleft(%5Cboldsymbol%7B%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X%20%5Cbeta%7D%5Cright)-2%20d%20%5Cleft(%5Cboldsymbol%7By%5E%7BT%7D%20X%20%5Cbeta%7D%5Cright)%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(2%20%5Cboldsymbol%7B%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X%20d(%5Cbeta)%7D%5Cright)-2%20tr%5Cleft(%5Cboldsymbol%7By%5E%7BT%7D%20X%20d(%5Cbeta)%7D%5Cright)%20%5C%5C%0A%26%3D%5Coperatorname%7Btr%7D%5Cleft(%5Cleft(%5Cboldsymbol%7B2%20%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X-2%20y%5E%7BT%7D%20X%7D%5Cright)%20d(%5Cboldsymbol%7B%5Cbeta%7D)%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cboldsymbol%7B%5Cnabla_%7B%5Cbeta%7D%20%5Cbeta%7D%20%26%3D%5Cboldsymbol%7B%5Cleft%282%20%5Cbeta%5E%7BT%7D%20X%5E%7BT%7D%20X-2%20y%5E%7BT%7D%20X%5Cright%29%5E%7BT%7D%7D%20%5C%5C%0A%26%3D2%5Cboldsymbol%7B%5Cleft(X%5E%7BT%7D%20X%20%5Cbeta-X%5E%7BT%7D%20y%5Cright)%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>也就是说, 解 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 必然满足</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7By%7D%0A" /></p><p>这就是线性回归的<strong>正规方程组</strong>。</p>
<p>如果 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BX%5E%7B%5Cmathrm%7BT%7D%7D%20X%7D" style="display:inline-block;margin: 0;"/> 非奇异,  该方程有唯一的解</p>
<p style=""><img src="https://math.now.sh?from=%5Cboldsymbol%7B%5Cbeta%7D_%7B%5Cmathrm%7BLS%7D%7D%3D%5Cleft%28%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BX%7D%5Cright%29%5E%7B-1%7D%20%5Cboldsymbol%7BX%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7By%7D%0A" /></p><h1>最小二乘估计值的性质</h1>
<p>这一部分内容来自于《linear models in statistics》<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="《linear models in statistics》
">[3]</span></a></sup></p>
<p>如果 <img src="https://math.now.sh?inline=E%28%5Cmathbf%7By%7D%29%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> ，那么最小二乘估计值 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的无偏估计值。</p>
<p>证明：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AE%28%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29%20%26%3DE%5Cleft%5B%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%5D%20%5C%5C%0A%26%3D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20E(%5Cmathbf%7By%7D)%20%5C%5C%0A%26%3D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%20%5C%5C%0A%26%3D%5Cboldsymbol%7B%5Cbeta%7D%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>如果 <img src="https://math.now.sh?inline=%5Coperatorname%7Bcov%7D%28%5Cmathbf%7By%7D%29%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ，那么最小二乘估计值 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 的协方差矩阵为 <img src="https://math.now.sh?inline=%5Csigma%5E%7B2%7D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-1%7D" style="display:inline-block;margin: 0;"/> 。</p>
<p>证明：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Coperatorname%7Bcov%7D%28%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%29%20%26%3D%5Coperatorname%7Bcov%7D%5Cleft%5B%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5Cright%5D%20%5C%5C%0A%26%3D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Coperatorname%7Bcov%7D(%5Cmathbf%7By%7D)%5Cleft%5B%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%5E%7B%5Cprime%7D%20%5C%5C%0A%26%3D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cleft(%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D%5Cright)%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5C%5C%0A%26%3D%5Csigma%5E%7B2%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5C%5C%0A%26%3D%5Csigma%5E%7B2%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%0A%5Cend%7Baligned%7D%0A" /></p><p><strong>定理</strong>：<strong>(Gauss – Markov Theorem)</strong>，如果同时满足  <img src="https://math.now.sh?inline=E%28%5Cmathbf%7By%7D%29%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/>  ， <img src="https://math.now.sh?inline=%5Coperatorname%7Bcov%7D%28%5Cmathbf%7By%7D%29%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ，那么最小二乘估计值 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7Bj%7D%7D" style="display:inline-block;margin: 0;"/>  , <img src="https://math.now.sh?inline=j%3D0%2C1%2C%20%5Cldots%2C%20k" style="display:inline-block;margin: 0;"/> 在所有的线性无偏估计值中具有<strong>最小的方差</strong>。</p>
<p>证明：</p>
<p>注意这里的“线性”指的是 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7Bj%7D%7D" style="display:inline-block;margin: 0;"/> 是关于  <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的线性变换。假设我们有一个 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的无偏线性估计值为 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BAy%7D" style="display:inline-block;margin: 0;"/>  ，我们想要找到一个矩阵  <img src="https://math.now.sh?inline=%5Cboldsymbol%7BA%7D" style="display:inline-block;margin: 0;"/> 使得  <img src="https://math.now.sh?inline=%5Cboldsymbol%7BAy%7D" style="display:inline-block;margin: 0;"/>  的方差最小。</p>
<p>因为  <img src="https://math.now.sh?inline=%5Cboldsymbol%7BAy%7D" style="display:inline-block;margin: 0;"/> 无偏，我们有 <img src="https://math.now.sh?inline=E%28%5Cmathbf%7BA%20y%7D%29%3D%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 。根据假设 <img src="https://math.now.sh?inline=E%28%5Cmathbf%7By%7D%29%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> ，我们可以将其写为</p>
<p style=""><img src="https://math.now.sh?from=E%28%5Cmathbf%7BA%20y%7D%29%3D%5Cmathbf%7BA%7D%20E(%5Cmathbf%7By%7D)%3D%5Cmathbf%7BA%7D%20%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D%3D%5Cboldsymbol%7B%5Cbeta%7D%0A" /></p><p>该式需要对所有可能的  <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 均成立（这句话我理解了半天， <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 是由未知参数组成的向量，既然是未知的参数，那就是说每个参数可能是任意实数，因此 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/>  可以是欧几里得空间中任意一个点），那么存在</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%7D%20%5Cmathbf%7BX%7D%3D%5Cmathbf%7BI%7D%0A" /></p><p><img src="https://math.now.sh?inline=%5Cboldsymbol%7BAy%7D" style="display:inline-block;margin: 0;"/> 的协方差矩阵为</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Bcov%7D%28%5Cmathbf%7BA%20y%7D%29%3D%5Cmathbf%7BA%7D%5Cleft(%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D%5Cright)%20%5Cmathbf%7BA%7D%5E%7B%5Cprime%7D%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7BA%7D%20%5Cmathbf%7BA%7D%5E%7B%5Cprime%7D%0A" /></p><p><img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D_%7Bj%7D" style="display:inline-block;margin: 0;"/> 的方差为协方差矩阵的对角线元素，因此我们需要挑一个矩阵 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D" style="display:inline-block;margin: 0;"/>, 使得 $ \mathbf{A} \mathbf{A}^{\prime}$ 矩阵的对角线元素最小。为了让其与最小二乘估计值有关系，我们将其写作</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cmathbf%7BA%7D%20%5Cmathbf%7BA%7D%5E%7B%5Cprime%7D%20%26%3D%20%5Cleft%5B%5Cmathbf%7BA%7D-%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%2B%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%5Cleft%5B%5Cmathbf%7BA%7D-%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%2B%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%5E%7B%5Cprime%7D%20%5C%5C%0A%26%3D%20%5Cleft%5B(%5Cmathbf%7BA%7D-%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20)%2B%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%5Cleft%5B(%5Cmathbf%7BA%7D%5E%7B%5Cprime%7D-%20%5Cmathbf%7BX%7D%20%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D)%20%2B%20%20%5Cmathbf%7BX%7D%20%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%5Cright%5D%20%5C%5C%0A%26%3D%5Cleft%5B%5Cmathbf%7BA%7D-%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%5Cleft%5B%5Cmathbf%7BA%7D-%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%5E%7B%5Cprime%7D%20%2B%20%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%26%20%20%5Cbecause%20%5Cmathbf%7BA%7D%20%5Cmathbf%7BX%7D%3D%5Cmathbf%7BI%7D%20%5C%5C%20%0A%5Cend%7Baligned%7D%0A" /></p><p>因为 <img src="https://math.now.sh?inline=%5Cleft%5B%5Cmathbf%7BA%7D-%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%5Cleft%5B%5Cmathbf%7BA%7D-%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cright%5D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 是一个半正定矩阵（<img src="https://math.now.sh?inline=%5Cmathbf%7BAA'%7D" style="display:inline-block;margin: 0;"/> 是一个半正定矩阵 ），根据半正定矩阵的性质，其对角线元素大于等于 0 。因此，只有当我们设 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%7D%3D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> （此时仍满足 <img src="https://math.now.sh?inline=%5Cmathbf%7BA%20X%7D%3D%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ）时，上式的对角线元素才均为 0 ，此时 <img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/>  的最小方差估计值为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BA%20y%7D%3D%5Cleft%28%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%0A" /></p><p>该式正好就是最小二乘估计值。</p>
<p>Gauss – Markov 定理有时也表述为，如果满足  <img src="https://math.now.sh?inline=E%28%5Cmathbf%7By%7D%29%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/>  ， <img src="https://math.now.sh?inline=%5Coperatorname%7Bcov%7D%28%5Cmathbf%7By%7D%29%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ，那么最小二乘估计值 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7Bj%7D%7D" style="display:inline-block;margin: 0;"/>  , <img src="https://math.now.sh?inline=j%3D0%2C1%2C%20%5Cldots%2C%20k" style="display:inline-block;margin: 0;"/> 称为<strong>最佳线性无偏估计值</strong> (<em>best linear unbiased estimators</em>, BLUE)。这里最佳指最小方差，线性指  <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7Bj%7D%7D" style="display:inline-block;margin: 0;"/> 是  <img src="https://math.now.sh?inline=%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> 的线性函数。</p>
<p>Gauss – Markov 定理的最显著特点是<strong>其对任意分布均成立</strong>，这里并不要求满足正态分布。但是如果满足上面的两个假设，那么此时最小二乘估计值可能有偏，或者其真实方差大于估计方差。</p>
<p>Gauss – Markov 定理可以轻松推广到  <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7Bj%7D%7D" style="display:inline-block;margin: 0;"/>  的线性组合。</p>
<p><strong>推论</strong>：如果满足  <img src="https://math.now.sh?inline=E%28%5Cmathbf%7By%7D%29%3D%5Cmathbf%7BX%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/>  ， <img src="https://math.now.sh?inline=%5Coperatorname%7Bcov%7D%28%5Cmathbf%7By%7D%29%3D%5Csigma%5E%7B2%7D%20%5Cmathbf%7BI%7D" style="display:inline-block;margin: 0;"/> ，那么 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Cboldsymbol%7B%5Cbeta%7D" style="display:inline-block;margin: 0;"/> 的最小线性无偏估计值就是 <img src="https://math.now.sh?inline=%5Cmathbf%7Ba%7D%5E%7B%5Cprime%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/>，其中 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 是最小二乘估计值。</p>
<p>最小二乘估计值的最后一个性质是，特征的范围 (<em>scale of x</em>) 不会影响预测结果，存在以下定理。</p>
<p><strong>定理</strong>：如果 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D%3D%5Cleft%281%2C%20x_%7B1%7D%2C%20%5Cldots%2C%20x_%7Bk%7D%5Cright%29%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=%5Cmathbf%7Bz%7D%3D%5Cleft%281%2C%20c_%7B1%7D%20x_%7B1%7D%2C%20%5Cldots%2C%20c_%7Bk%7D%20x_%7Bk%7D%5Cright%29%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> ，那么 <img src="https://math.now.sh?inline=%5Chat%7By%7D%20%3D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bx%7D%3D%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D_%7Bz%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bz%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D_%7Bz%7D%5E%7B%5Cprime%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 关于 <img src="https://math.now.sh?inline=%5Cmathbf%7Bz%7D" style="display:inline-block;margin: 0;"/> 的最小二乘估计参数。</p>
<p>我们可以将 <img src="https://math.now.sh?inline=%5Cmathbf%7Bz%7D" style="display:inline-block;margin: 0;"/> 重写为 <img src="https://math.now.sh?inline=%5Cmathbf%7Bz%7D%3D%5Cmathbf%7BD%7D%20%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BD%7D%3D%5Coperatorname%7Bdiag%7D%5Cleft%281%2C%20c_%7B1%7D%2C%20c_%7B2%7D%2C%20%5Cldots%2C%20c_%7Bk%7D%5Cright%29" style="display:inline-block;margin: 0;"/> 。那么存在 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D%3D%5Cmathbf%7BX%20D%7D" style="display:inline-block;margin: 0;"/> ，我们将其带入到 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D_%7Bz%7D%3D%5Cleft%28%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D" style="display:inline-block;margin: 0;"/> ，得到</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D_%7Bz%7D%20%26%3D%5Cleft%28%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%5C%5C%0A%26%3D%5Cleft%5B(%5Cmathbf%7BX%20D%7D)%5E%7B%5Cprime%7D(%5Cmathbf%7BX%20D%7D)%5Cright%5D%5E%7B-1%7D(%5Cmathbf%7BX%20D%7D)%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%26%3D%5Cleft%5B%5Cmathbf%7BD%7D(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%5Cmathbf%7BX%7D)%5Cmathbf%7BD%7D)%5Cright%5D%5E%7B-1%7D%20%5Cmathbf%7BD%7D%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%26%3D%5Cmathbf%7BD%7D%5E%7B-1%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%20(%5Cmathbf%7BD%7D%5E%7B-1%7D%20%5Cmathbf%7BD%7D)%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%20%5C%5C%0A%26%3D%5Cmathbf%7BD%7D%5E%7B-1%7D%5Cleft(%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BX%7D%5Cright)%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%20%5C%5C%0A%26%3D%5Cmathbf%7BD%7D%5E%7B-1%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D" style="display:inline-block;margin: 0;"/> 为  <img src="https://math.now.sh?inline=y" style="display:inline-block;margin: 0;"/> 关于 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> 的最小二乘估计参数。那么</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D_%7Bz%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bz%7D%3D%5Cleft%28%5Cmathbf%7BD%7D%5E%7B-1%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5Cright%29%5E%7B%5Cprime%7D%20%5Cmathbf%7BD%7D%20%5Cmathbf%7Bx%7D%3D%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bx%7D%0A" /></p><p>得证。</p>
<p>接下来，我们可以将这个定理推广到任何关于 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/>  变量的满秩线性变换中。</p>
<p><strong>推论</strong>：当新变量是关于 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/>  变量的满秩线性变换时，预测值 <img src="https://math.now.sh?inline=%5Chat%7By%7D" style="display:inline-block;margin: 0;"/>  不变</p>
<p>证明：我们可以将 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/>  变量的满秩线性变换表示为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BZ%7D%3D%5Cmathbf%7BX%20K%7D%3D%5Cleft%28%5Cmathbf%7Bj%7D%2C%20%5Cmathbf%7BX%7D_%7B1%7D%5Cright%29%5Cleft(%5Cbegin%7Barray%7D%7Bcc%7D%0A1%20%26%20%5Cmathbf%7B0%7D%5E%7B%5Cprime%7D%20%5C%5C%0A%5Cmathbf%7B0%7D%20%26%20%5Cmathbf%7BK%7D_%7B1%7D%0A%5Cend%7Barray%7D%5Cright)%3D%5Cleft(%5Cmathbf%7Bj%7D%2B%5Cmathbf%7BX%7D_%7B1%7D%20%5Cmathbf%7B0%7D%2C%20%5Cmathbf%7Bj%7D%20%5Cmathbf%7B0%7D%5E%7B%5Cprime%7D%2B%5Cmathbf%7BX%7D_%7B1%7D%20%5Cmathbf%7BK%7D_%7B1%7D%5Cright)%3D%5Cleft(%5Cmathbf%7Bj%7D%2C%20%5Cmathbf%7BX%7D_%7B1%7D%20%5Cmathbf%7BK%7D_%7B1%7D%5Cright)%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 是一个非奇异矩阵（<img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D_%7B1%7D%20%5Cmathbf%7BK%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 的每一列新特征均是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 的列的线性组合），并且</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathbf%7BX%7D_%7B1%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bcccc%7D%0Ax_%7B11%7D%20%26%20x_%7B12%7D%20%26%20%5Cldots%20%26%20x_%7B1%20k%7D%20%5C%5C%0Ax_%7B21%7D%20%26%20x_%7B22%7D%20%26%20%5Cldots%20%26%20x_%7B2%20k%7D%20%5C%5C%0A%5Cvdots%20%26%20%5Cvdots%20%26%20%26%20%5Cvdots%20%5C%5C%0Ax_%7Bn%201%7D%20%26%20x_%7Bn%202%7D%20%26%20%5Cldots%20%26%20x_%7Bn%20k%7D%0A%5Cend%7Barray%7D%5Cright%29%0A" /></p><p>这里我们将 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cmathbf%7BK%7D" style="display:inline-block;margin: 0;"/> 拆分开，这样 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D_%7B1%7D" style="display:inline-block;margin: 0;"/> 只包含 <img src="https://math.now.sh?inline=x" style="display:inline-block;margin: 0;"/> 变量。此时 <img src="https://math.now.sh?inline=%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D_%7Bz%7D" style="display:inline-block;margin: 0;"/> 变成</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D_%7Bz%7D%26%3D%5Cleft%28%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7BZ%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BZ%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7By%7D%20%5C%5C%0A%26%3D%20((%5Cmathbf%7BX%20K%7D)'%5Cmathbf%7BX%20K%7D)%5E%7B-1%7D%20(%5Cmathbf%7BX%20K%7D)'%20%5Cmathbf%7By%7D%5C%5C%0A%26%3D%20(%5Cmathbf%7BK%7D'%20%5Cmathbf%7BX%7D'%20%5Cmathbf%7BX%20K%7D)%5E%7B-1%7D%20%5Cmathbf%7BK%7D'%20%5Cmathbf%7BX%7D'%20%5Cmathbf%7By%7D%5C%5C%0A%26%3D%20%5Cmathbf%7BK%7D%5E%7B-1%7D%20(%5Cmathbf%7BX%7D'%20%5Cmathbf%7BX%7D)%5E%7B-1%7D%20%5Cmathbf%7BK%7D%5E%7B-T%7D%20%5Cmathbf%7BK%7D'%20%5Cmathbf%7BX%7D'%20%5Cmathbf%7By%7D%5C%5C%0A%26%3D%20%5Cmathbf%7BK%7D%5E%7B-1%7D%20(%5Cmathbf%7BX%7D'%20%5Cmathbf%7BX%7D)%5E%7B-1%7D%20%20%5Cmathbf%7BX%7D'%20%5Cmathbf%7By%7D%5C%5C%0A%26%3D%5Cmathbf%7BK%7D%5E%7B-1%7D%20%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D_%7Bx%7D%7D%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>因此，我们有</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7By%7D%3D%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D_%7Bz%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bz%7D%3D%5Chat%7B%5Cboldsymbol%7B%5Cbeta%7D%7D_%7B%5Cmathbf%7Bx%7D%7D%5E%7B%5Cprime%7D%5Cmathbf%7Bx%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%5Cmathbf%7Bz%7D%3D%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> （这里有一点绕，主要在于 <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的一行组成的列向量，不是 <img src="https://math.now.sh?inline=%5Cmathbf%7BX%7D" style="display:inline-block;margin: 0;"/> 的一列，违背了一般的向量符号表示方法，也就是这里  <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/>  是表示某一个观测值的特征组成的列向量。根据 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D%3D%5Cmathbf%7BX%20K%7D" style="display:inline-block;margin: 0;"/> ，有 <img src="https://math.now.sh?inline=%5Cmathbf%7BZ%7D'%3D%5Cmathbf%7BK'%20X'%7D" style="display:inline-block;margin: 0;"/> ，因此  <img src="https://math.now.sh?inline=%5Cmathbf%7Bz%7D%3D%5Cmathbf%7BK%7D%5E%7B%5Cprime%7D%20%5Cmathbf%7Bx%7D" style="display:inline-block;margin: 0;"/> ）。</p>
<p>得证。</p>
<p>除了预测值 <img src="https://math.now.sh?inline=%5Chat%7By%7D" style="display:inline-block;margin: 0;"/>  ，样本方差 <img src="https://math.now.sh?inline=s%5E%7B2%7D" style="display:inline-block;margin: 0;"/> 同样不受特征的范围 (<em>scale of x</em>) 的影响。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">张贤达《矩阵分析与应用（第二版）》<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">https://zhuanlan.zhihu.com/p/305171795<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">《linear models in statistics》<a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>线性代数</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>统计SNP基因型频率及MAF代码实现</title>
    <url>/posts/636ff051/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近准备一些材料时需要计算每个SNP三种分型的基因型频率和MAF，plink 软件只给出 MAF，因此写了一个简单的代码实现它。</p>
<span id="more"></span>
<h1>使用软件</h1>
<ul>
<li>python 3.8 及以上版本，事先安装好 Numpy 模块</li>
</ul>
<h1>背景知识</h1>
<p>假设一个SNP，它有两种碱基 A 和 T，那么就有三种可能的基因型 AA, AT, TT。</p>
<p>假设某个群体样本数目为 100 ，在这个SNP 中有 5 个样本分型失败，有 20 个样本分型为 AA, 有 30 个样本分型为 AT，有45 个样本分型为 TT，计算三种分型的基因型频率如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AP%28AA%29%20%3D%20%5Cfrac%7BAA%7D%7BAA%2BAT%2BTT%7D%20%3D%20%5Cfrac%7B20%7D%7B95%7D%20%3D%200.211%20%5C%5C%0AP(AT)%20%3D%20%5Cfrac%7BAT%7D%7BAA%2BAT%2BTT%7D%20%3D%20%5Cfrac%7B30%7D%7B95%7D%20%3D%200.316%20%5C%5C%0AP(TT)%20%3D%20%5Cfrac%7BTT%7D%7BAA%2BAT%2BTT%7D%20%3D%20%5Cfrac%7B45%7D%7B95%7D%20%3D%200.474%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>注意，分母计算总数时需要剔除分型失败的样本，三种基因型频率相加为1。</p>
<p>现在再看MAF计算方式，MAF 是最小等位基因频率的缩写。因此，我们可以将 P(A) 和 P(T) 都计算出来，看看哪个数值更小，那就是MAF</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AP%28A%29%20%3D%20%5Cfrac%7B2*P(AA)%2BP(AT)%7D%7B2%7D%20%3D%200.368%20%5C%5C%0AP(T)%20%3D%20%5Cfrac%7B2*P(TT)%2BP(AT)%7D%7B2%7D%20%3D%200.632%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>从上面三种基因型频率结果可以看出，A 是较小的等位基因，而 T 是较大的等位基因。判断理由很简单，因为 P(AT) 不影响 P(A) 和 P(T) 的相对大小，只要看 P(AA) 和 P(TT) 哪个更小，哪个就是最小等位基因了。</p>
<h1>输入文件</h1>
<p>使用 plink 软件的 <code>recodeA</code> 命令生成的 raw 文件。这里每个SNP占据一列，值为最小等位基因的数目（0 1 2），缺失值记为 NA。</p>
<h1>输出文件</h1>
<p>输出文件共5列，第一列为SNP名称，第二列为较小等位基因纯和子的基因型频率，第三列为杂合子基因型频率，第四列为另一类纯和子基因型频率，第五列为MAF。</p>
<table>
<thead>
<tr>
<th>seq-rs80960919</th>
<th>0.119152</th>
<th>0.497401</th>
<th>0.383447</th>
<th>0.367853</th>
</tr>
</thead>
<tbody>
<tr>
<td>seq-rs81350349</td>
<td>0.195922</td>
<td>0.530588</td>
<td>0.273491</td>
<td>0.461216</td>
</tr>
<tr>
<td>seq-rs81349911</td>
<td>0.2088</td>
<td>0.5384</td>
<td>0.2528</td>
<td>0.478</td>
</tr>
</tbody>
</table>
<h1>运行代码</h1>
<p>代码文件见：<a href="https://github.com/VincereZhou/code_backup/blob/master/genotype_frequency.py">genotype_frequency.py</a></p>
<p>将输入文件和本程序放在同一文件夹下，运行命令示范如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python genotype_frequency.py A.raw A_frequency.txt</span><br></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<p><code>A.raw</code>: 输入文件名称</p>
<p><code>A_frequency.txt</code>: 结果文件名称</p>
<p>运行结束后，生成以第二个参数为名称的结果文件</p>
<h1>代码说明</h1>
<h2 id="替换分型缺失值">替换分型缺失值</h2>
<p>首先我用 linux 的 sed 命令来精准查找 NA，替换为 3，生成中间文件 temp.raw。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os,sys</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">raw_file_name = sys.argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">f&quot;sed &#x27;s/\&lt;NA\&gt;/3/g&#x27; <span class="subst">&#123;raw_file_name&#125;</span> &gt; temp.raw&quot;</span>) <span class="comment"># 改为精准匹配</span></span><br></pre></td></tr></table></figure>
<h2 id="读取raw文件">读取raw文件</h2>
<p>首先从标题中提取 SNP 名称</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">raw_file = <span class="built_in">open</span>(<span class="string">&quot;temp.raw&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">raw_file_title = raw_file.readline().split() <span class="comment">#剔除标题</span></span><br><span class="line">title_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> raw_file_title[<span class="number">6</span>:]:</span><br><span class="line">    title_list.append(i[:-<span class="number">2</span>]) <span class="comment"># snp 名称列表</span></span><br></pre></td></tr></table></figure>
<p>之后将基因型信息存在到一个二维数组 array1 中，每一行表示一个样本，每一列表示一个SNP</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">raw_list=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> raw_file:</span><br><span class="line">    f = i.split()</span><br><span class="line">    raw_list.append(f[<span class="number">6</span>:])</span><br><span class="line">    </span><br><span class="line">raw_file.close()</span><br><span class="line"></span><br><span class="line">array1 = np.array(raw_list, dtype=np.int8)</span><br></pre></td></tr></table></figure>
<h2 id="统计基因型频率和MAF">统计基因型频率和MAF</h2>
<p>首先统计每列SNP中 2,1, 0 三种分型的数目，各自除以三种分型总数，便得到了三种基因型频率。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计三种基因型数据</span></span><br><span class="line"></span><br><span class="line">p_array = (array1==<span class="number">2</span>).<span class="built_in">sum</span>(axis=<span class="number">0</span>) <span class="comment"># 按列求和, 较小等位基因的纯合子</span></span><br><span class="line">h_array = (array1==<span class="number">1</span>).<span class="built_in">sum</span>(axis=<span class="number">0</span>) <span class="comment"># 按列求和</span></span><br><span class="line">r_array = (array1==<span class="number">0</span>).<span class="built_in">sum</span>(axis=<span class="number">0</span>) <span class="comment"># 按列求和</span></span><br><span class="line"></span><br><span class="line">p_rate = p_array/(p_array+h_array+r_array)</span><br><span class="line">h_rate = h_array/(p_array+h_array+r_array)</span><br><span class="line">r_rate = r_array/(p_array+h_array+r_array)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根据基因型频率，计算MAF</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">maf_rate = (<span class="number">2</span>*p_rate + h_rate)/<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="写入结果文件">写入结果文件</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写入结果文件</span></span><br><span class="line">out_file = <span class="built_in">open</span>(sys.argv[<span class="number">2</span>],<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">snp_num = <span class="built_in">len</span>(title_list)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(snp_num):</span><br><span class="line">    out_file.write(title_list[i]+<span class="string">&quot;\t&quot;</span>+<span class="built_in">str</span>(p_rate[i])+<span class="string">&quot;\t&quot;</span>+<span class="built_in">str</span>(h_rate[i])+<span class="string">&quot;\t&quot;</span>+<span class="built_in">str</span>(r_rate[i])+<span class="string">&quot;\t&quot;</span>+<span class="built_in">str</span>(maf_rate[i])+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">out_file.close()</span><br></pre></td></tr></table></figure>
<p>最后，剔除中间文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.system(<span class="string">&quot;rm temp.raw&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1>小结</h1>
<p>这个代码中计算的MAF 和 Plink 软件计算的 MAF 比对过，是一样的。</p>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>以某列作为主键比对两个文件内容代码实现</title>
    <url>/posts/705b018f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>有的时候，你可能需要比较两个文件的<strong>实质内容</strong>是否一样，或者某一个文件的内容是否均包含在另一个文件，你可以看看本代码。</p>
<span id="more"></span>
<h1>前言</h1>
<p>这两天老得比对各种文件，比对我手上的数据和你手上的数据是否一致，比对上传的数据和计算用的数据是否一致等。但是之前用的一些比对文件的方法又不能很好地满足我的需求，总得手动各种弄，就写了这个小脚本。</p>
<p>我一般用的比对方式有三种，notpad++ 的 Compare 插件，Excel 的  Vlookup 函数 + 排序 + IF， linux 的 diff 命令。但是问题在于第一种和第三种主要用在两个文件行的排序一致的情况，而且也得肉眼去看比对结果。第二种用 Excel 倒是灵活，就是得手动各种弄，偶尔一次可以，经常这样做就废时间了。</p>
<h1>脚本逻辑</h1>
<p>这个脚本要求两个文件的<strong>列数相同</strong>，并且<strong>列的顺序也一样</strong>。两个文件指定以某一列作为主键（数据库的概念，主键不可以出现重复）。</p>
<p>首先比较两个文件的主键，画个韦恩图如下，最左边的部分表示只在第一个文件的主键，也就是只在第一个文件中的行（如果存在，则写入文件 only_in_file1.txt ），最右边同理 。中间重叠的部分就是两个文件共同的主键。</p>
<p><img src="1.png" alt="1"></p>
<p>然后查看两个文件共同的主键部分，比对同一个主键在两个文件的行的内容是否一致，如果不一致，则将这两行内容写入到 diff_rows.txt 。</p>
<p>如果<strong>只在文件1中的行</strong>，<strong>只在文件2中的行</strong>，<strong>共同主键但是行内容不同的行</strong>，这三个<strong>均不存在</strong>，那就说明这<strong>两个文件在内容上完全一致</strong>。</p>
<h1>使用软件</h1>
<ul>
<li>python 3.8 及以上版本</li>
</ul>
<h1>输入文件格式</h1>
<p>文本格式</p>
<h1>输出文件格式</h1>
<p>如果两个文件存在不一致，那么可能出现这三个文件。</p>
<p><code>only_in_file1.txt</code> :  只在第一个文件出现的行</p>
<p><code>only_in_file2.txt</code> :  只在第二个文件出现的行</p>
<p><code>diff_rows.txt</code> : 两个文件主键相同但是行内容不一致的内容。</p>
<p>前两个文件就不用说了，唯一注意的地方是这三个文件文件分隔符用的都是tab，可能和输入文件的分隔符不一样。</p>
<p>第三个文件举个例子，见下方，前两行为一个不一致的地方，第一行为主键<code>YYLNWJ119077114</code>在第一个文件中的内容，第二行则为主键<code>YYLNWJ119077114</code>在第二个文件中的内容，可以看到这两行在最后一列内容不一致，第一个文件为 9，第二个文件为 -999 。第三行为空行，作为分隔。第四行和第五行是第二个不一致的地方。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YYLNWJ119077114	F	7	YYCFJYA1872471220191013	243.76	9</span><br><span class="line">YYLNWJ119077114	F	7	YYCFJYA1872471220191013	243.76	-999</span><br><span class="line"></span><br><span class="line">YYLNWJ119083106	F	8	YYCFJYA1874850920191031	193.26	9</span><br><span class="line">YYLNWJ119083106	F	8	YYCFJYA1874850920191031	193.26	-999</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>运行代码</h1>
<p>代码文件见: <a href="https://github.com/VincereZhou/code_backup/blob/master/compair_two_files.py">compair_two_files.py</a></p>
<p>将两个需要比较的文件和本程序放在一个文件夹内，运行命令示范如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python compair_two_files.py --file1 in_sz_phe --file2 out_sz_phe</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong>：</p>
<p><code>--file1</code>: 第一个输入文件名称，必选</p>
<p><code>--file2</code>: 第二个输入文件名称，必选</p>
<p><code>--key-column</code>:  主键所在的列，可选，默认为 1，即默认第一列为主键。如果数据中无法指定一列作为主键，现在可以指定多列内容作为主键，以逗号分隔。举个例子，假如比对文件为母猪的繁殖数据，此时由于一头母猪有多条数据，你不能将母猪ID作为主键，因为会重复；但是你可以通过母猪ID+胎次来保证一行数据的唯一性，如果母猪ID为第一列，胎次为第4列，则此时这个参数的值为 1,4 。</p>
<p><code>--file-separator</code>:  文件中的分隔符，可选，默认为空白字符。</p>
<h1>代码说明</h1>
<h2 id="输入参数，打印参数">输入参数，打印参数</h2>
<p>略</p>
<h2 id="检验参数">检验参数</h2>
<p>检验两个文件是否存在且非空，两个文件的列数是否相同，主键是否为数字且在列数的范围内。如果存在问题，报错退出</p>
<h2 id="检查文件">检查文件</h2>
<h3 id="第一个文件">第一个文件</h3>
<p>对于每一行判断列数，判断整行内容是否重复，判断主键是否重复，将内容写入到 dict1 中。</p>
<h3 id="第二个文件">第二个文件</h3>
<p>正常检查同第一个文件，判断第二个文件的主键是否在第一个文件中，将共同主键的行内容写入到 dict2 ，将只在第二个文件的行内容写入到 only_in_file2_list 。</p>
<h3 id="提取只在第一个文件中的主键的行">提取只在第一个文件中的主键的行</h3>
<p>上面已经提取了只在第二个文件中的行的内容，这里就提取只在第一个文件的内容，写入 only_in_file1_list</p>
<h3 id="比较共同主键的行">比较共同主键的行</h3>
<p>比较两个文件共同主键的行的内容是否一致</p>
<h2 id="综合判断">综合判断</h2>
<p>结合上述内容，综合判断，如果完全一致则打印退出。如果存在不一致，将不一致的地方写入文件。</p>
<h1>更新</h1>
<h2 id="2021年12月4号">2021年12月4号</h2>
<ol>
<li>
<p>之前数据每行内容拆分时，漏了使用指定的分隔符，改回来了</p>
</li>
<li>
<p><code>--key-column</code> 参数现在可以指定多列。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>基于两个plink文件共同样本共同位点的基因型比对代码实现</title>
    <url>/posts/9ad0a746/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>比对两个plink文件共同样本共同位点的基因型，合并了 <a href="https://vincere.fun/posts/fa9e0b0e/">两个Plink文件样本间基因型比对代码实现</a> 和 <a href="https://vincere.fun/posts/6897c9bb/">两个Plink文件同一SNP基因型比对代码实现</a> 的内容。</p>
<span id="more"></span>
<h1>前言</h1>
<p>整理文档的时候突然想到，既然比对两个plink文件时从共同样本角度和从共同SNP角度比对都需要进行，那为什么不合并成一个脚本呢？</p>
<p>是的，这里需要合并成一个脚本，因此就有了这个脚本。这个脚本是在<a href="https://github.com/VincereZhou/code_backup/blob/master/compair_snps.py">compair_snps.py</a>基础上新增了一些代码得到的，同时从共同样本和共同SNP角度去比较基因型。</p>
<h1>使用软件</h1>
<ul>
<li>python 3.8 及以上版本</li>
<li>plink 软件 v1.90 版本</li>
</ul>
<h1>输入文件格式</h1>
<h2 id="plink-文本文件">plink 文本文件</h2>
<p>格式说明见<a href="https://vincere.fun/posts/506fc784/">根据芯片号拆分plink文件的代码实现</a></p>
<h1>输出文件说明</h1>
<p>两个输出文件名称前面相同，后面分别为 <code>_snp.txt</code> 和 <code>_sample.txt</code> ，分别为从SNP角度和样本角度的比对结果。</p>
<p><code>*_snp.txt</code> :  第一列为SNP名称，第二列为两个plink文件中共同样本中不一致的样本数目，第三列为共同样本总数，第四列为前两列相除得到的不一致率。</p>
<p>示例如下：</p>
<table>
<thead>
<tr>
<th>8_118011832</th>
<th>3508</th>
<th>3529</th>
<th>0.994</th>
</tr>
</thead>
<tbody>
<tr>
<td>5_39432167</td>
<td>3459</td>
<td>3524</td>
<td>0.9816</td>
</tr>
<tr>
<td>14_133523132</td>
<td>3428</td>
<td>3518</td>
<td>0.9744</td>
</tr>
</tbody>
</table>
<p><code>*_sample.txt</code> :  第一列为样本名称，第二列为两个plink文件中该样本的共同位点中不一致的样本数目，第三列为共同位点总数，第四列为前两列相除得到的不一致率。</p>
<table>
<thead>
<tr>
<th>202888800026_R03C02</th>
<th>0</th>
<th>51315</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>202888800026_R03C03</td>
<td>0</td>
<td>51315</td>
<td>0</td>
</tr>
<tr>
<td>202888800026_R03C04</td>
<td>0</td>
<td>51315</td>
<td>0</td>
</tr>
</tbody>
</table>
<h1>运行代码</h1>
<p>代码文件见：<a href="https://github.com/VincereZhou/code_backup/blob/master/compair_two_plinks.py">compair_two_plinks.py</a></p>
<p>将输入文件和本程序放在同一文件夹下，运行命令示范为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python compair_two_plinks.py --plink1 plink1 --plink2 plink2</span><br></pre></td></tr></table></figure>
<p><strong>可用参数说明</strong>：</p>
<p><code>--plink1</code>: 第一个plink文件前缀，必选。</p>
<p><code>--plink2</code>: 第二个plink文件前缀，可选。</p>
<p><code>--exclude-miss</code> : 基因型比对是否先剔除缺失值，可选，只能为yes和no，默认为yes。如果该选项设置为no，比对时不会剔除缺失样本对，如果存在同一个样本，在一个基因型文件中有基因型，另一个基因型文件中则为缺失，该样本同样会被视为不一致位点；如果该选项设置为 yes ，比对时会剔除至少一个样本为缺失的位点，只比对两个样本均不为缺失的位点。</p>
<p><code>--save-temp</code> :  是否保留中间文件，可选，只能为yes和no，默认为 no。</p>
<p><code>--out-prefix</code> : 结果文件前缀，可选，默认为 <code>cmp_two_plinks</code></p>
<h1>代码说明</h1>
<p>由于这个脚本是基于 <a href="https://github.com/VincereZhou/code_backup/blob/master/compair_snps.py">compair_snps.py</a> 的基础修改的，前面的内容基本没变，只看后面修改的地方。</p>
<h2 id="计算不一致率">计算不一致率</h2>
<p>这里新增了从样本角度比对的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#计算不一致率</span></span><br><span class="line">out_sample_list = []</span><br><span class="line">out_snp_list = []</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> args.exclude_miss == <span class="string">&#x27;yes&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(snp_num):</span><br><span class="line">        first_index = <span class="built_in">range</span>(<span class="number">0</span>,common_sample_num)</span><br><span class="line">        second_index = <span class="built_in">range</span>(common_sample_num,total_sample_num)</span><br><span class="line">        v1 = array1[first_index,i]</span><br><span class="line">        v2 = array1[second_index,i]</span><br><span class="line">        non_miss_index = np.where((v1!=<span class="number">3</span>) &amp; (v2!=<span class="number">3</span>))</span><br><span class="line">        total_num = non_miss_index[<span class="number">0</span>].shape[<span class="number">0</span>]</span><br><span class="line">        v1_new = v1[non_miss_index]</span><br><span class="line">        v2_new = v2[non_miss_index]</span><br><span class="line">        no_match_num = np.count_nonzero(v1_new!=v2_new)</span><br><span class="line">        <span class="keyword">if</span> total_num &gt; <span class="number">0</span>:</span><br><span class="line">            no_match_rate = no_match_num/total_num</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            no_match_rate = <span class="number">0</span></span><br><span class="line">        out_snp_list.append([snp_list[i],<span class="string">f&quot;<span class="subst">&#123;no_match_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;total_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;no_match_rate:<span class="number">.4</span>f&#125;</span>&quot;</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(common_sample_list)):</span><br><span class="line">        first_index = i</span><br><span class="line">        second_index = i+common_sample_num</span><br><span class="line">        v1 = array1[first_index,:]</span><br><span class="line">        v2 = array1[second_index,:]</span><br><span class="line">        non_miss_index = np.where((v1!=<span class="number">3</span>) &amp; (v2!=<span class="number">3</span>))</span><br><span class="line">        total_num = non_miss_index[<span class="number">0</span>].shape[<span class="number">0</span>]</span><br><span class="line">        v1_new = v1[non_miss_index]</span><br><span class="line">        v2_new = v2[non_miss_index]</span><br><span class="line">        no_match_num = np.count_nonzero(v1_new!=v2_new)</span><br><span class="line">        <span class="keyword">if</span> total_num &gt; <span class="number">0</span>:</span><br><span class="line">            no_match_rate = no_match_num/total_num</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            no_match_rate = <span class="number">0</span></span><br><span class="line">        out_sample_list.append([common_sample_list[i],<span class="string">f&quot;<span class="subst">&#123;no_match_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;total_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;no_match_rate:<span class="number">.4</span>f&#125;</span>&quot;</span>])</span><br><span class="line">        </span><br><span class="line"><span class="keyword">elif</span> args.exclude_miss == <span class="string">&#x27;no&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(snp_num):</span><br><span class="line">        first_index = <span class="built_in">range</span>(<span class="number">0</span>,common_sample_num)</span><br><span class="line">        second_index = <span class="built_in">range</span>(common_sample_num,total_sample_num)</span><br><span class="line">        v1 = array1[first_index,i]</span><br><span class="line">        v2 = array1[second_index,i]</span><br><span class="line">        total_num = common_sample_num</span><br><span class="line">        no_match_num = np.count_nonzero(v1!=v2)</span><br><span class="line">        no_match_rate = no_match_num/total_num</span><br><span class="line">        out_snp_list.append([snp_list[i],<span class="string">f&quot;<span class="subst">&#123;no_match_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;total_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;no_match_rate:<span class="number">.4</span>f&#125;</span>&quot;</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(common_sample_list)):</span><br><span class="line">        first_index = i</span><br><span class="line">        second_index = i+common_sample_num</span><br><span class="line">        v1 = array1[first_index,:]</span><br><span class="line">        v2 = array1[second_index,:]</span><br><span class="line">        total_num = snp_num</span><br><span class="line">        no_match_num = np.count_nonzero(v1!=v2)</span><br><span class="line">        no_match_rate = no_match_num/total_num</span><br><span class="line">        out_sample_list.append([common_sample_list[i],<span class="string">f&quot;<span class="subst">&#123;no_match_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;total_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;no_match_rate:<span class="number">.4</span>f&#125;</span>&quot;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="将比对结果按从不一致率从大到小">将比对结果按从不一致率从大到小</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sorted_out_snp_list = <span class="built_in">sorted</span>(out_snp_list, key = <span class="keyword">lambda</span> s:<span class="built_in">float</span>(s[<span class="number">3</span>]), reverse = <span class="literal">True</span>) <span class="comment">#不一致率从大到小</span></span><br><span class="line">sorted_out_sample_list = <span class="built_in">sorted</span>(out_sample_list, key = <span class="keyword">lambda</span> s:<span class="built_in">float</span>(s[<span class="number">3</span>]), reverse = <span class="literal">True</span>) <span class="comment">#不一致率从大到小</span></span><br></pre></td></tr></table></figure>
<h2 id="写入结果文件，统计不一致的SNP数目和样本数目。">写入结果文件，统计不一致的SNP数目和样本数目。</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">unconsistent_snp_num = <span class="number">0</span> <span class="comment"># 不一致的SNP数目</span></span><br><span class="line">unconsistent_sample_num = <span class="number">0</span> <span class="comment"># 不一致的样本数目</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sorted_out_snp_list:</span><br><span class="line">    out_snp_file.write(<span class="string">&#x27;\t&#x27;</span>.join(i)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(i[<span class="number">1</span>]) &gt; <span class="number">0</span>:</span><br><span class="line">        unconsistent_snp_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sorted_out_sample_list:</span><br><span class="line">    out_sample_file.write(<span class="string">&#x27;\t&#x27;</span>.join(i)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(i[<span class="number">1</span>]) &gt; <span class="number">0</span>:</span><br><span class="line">        unconsistent_sample_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;unconsistent sample number: <span class="subst">&#123;unconsistent_sample_num&#125;</span>\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;unconsistent  snp   number: <span class="subst">&#123;unconsistent_snp_num&#125;</span>\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1>闲话</h1>
<p>定期整理文档，梳理之前写的代码是有益的。</p>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>生物信息</tag>
      </tags>
  </entry>
  <entry>
    <title>通过比对bim文件查找有问题基因型文件代码实现</title>
    <url>/posts/58fe67f5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>当你用 plink 软件合并同一款芯片的多对plink文件时，出现了下述报错，提示有些位点不是二等位基因型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Error: Variant <span class="string">&#x27;1_242598&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> biallelic.</span><br></pre></td></tr></table></figure>
<p>这时候你就需要找到有问题的plink文件</p>
<span id="more"></span>
<h1>前言</h1>
<p>这种情况比较罕见，正常情况下不会发生，最可能的原因有两个</p>
<ol>
<li>虽然是同一款芯片，但是可能存在更换了注释文件，导致同一个位点分型出来的两个碱基不同。</li>
<li>弄混了 Top 链 和 Forward 链的 plink 文件</li>
</ol>
<h1>使用软件</h1>
<ul>
<li>python 3.8 及以上版本</li>
<li>plink 软件 v1.90 版本</li>
</ul>
<h1>输入文件格式</h1>
<h2 id="plink-文本文件">plink 文本文件</h2>
<p>格式说明见<a href="https://vincere.fun/posts/506fc784/">根据芯片号拆分plink文件的代码实现</a></p>
<h2 id="plink-二进制文件">plink 二进制文件</h2>
<p>通过 plink 软件的 <code>--make-bed</code> 命令生成的二进制基因型文件，具体格式说明见<a href="https://vincere.fun/posts/def937d0/">plink学习笔记</a>。这里我们需要的就是后缀为<code>.bim</code> 的文件，这个文件在map文件的基础上新增了两列，为该SNP的两个碱基。</p>
<p>举个例子，下表为 bim 文件中的内容，第一行中的SNP的第一个碱基为 0 ，说明这个SNP均为一种分型（GG）。</p>
<table>
<thead>
<tr>
<th>1</th>
<th>CNCB10000545</th>
<th>0</th>
<th>119120907</th>
<th>0</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>CNC10012269</td>
<td>0</td>
<td>119133853</td>
<td>A</td>
<td>G</td>
</tr>
<tr>
<td>1</td>
<td>CNC10012270</td>
<td>0</td>
<td>119144804</td>
<td>G</td>
<td>C</td>
</tr>
</tbody>
</table>
<h1>比对多对plink文件代码</h1>
<h2 id="运行代码">运行代码</h2>
<p>代码文件见: <a href="https://github.com/VincereZhou/code_backup/blob/master/cmp_bims.py">cmp_bims.py</a></p>
<p>将所有需要检验的plink文本文件和本程序放在一个文件夹内，运行命令示范如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python cmp_bims.py in_path</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong>：</p>
<p><code>in_path</code> ：需要检验的多对plink文本文件所在的文件夹路径，注意一对<code>ped</code>文件和<code>map</code>文件的前缀必须相同。</p>
<h2 id="代码说明">代码说明</h2>
<h3 id="每对plink文件生成同名二进制文件">每对plink文件生成同名二进制文件</h3>
<p>首先导入需要的模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys,os</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br></pre></td></tr></table></figure>
<p>唯一的一个参数命名为 <code>work_path</code>，即工作路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">work_path = sys.argv[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>创建一个报错提示逻辑值<code>total_error_status</code> ，初始化为 <code>False</code> 。如果值为 <code>True</code> ，表示存在报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total_error_status = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>切换目录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换目录</span></span><br><span class="line">os.chdir(work_path) </span><br></pre></td></tr></table></figure>
<p>每对plink文件生成 <code>bim</code> 文件。这里是遍历输入路径下的所有文件，找到后缀为<code>.ped</code> 的文件，查找是否存在相应前缀的<code>.map</code> 文件，如果不存在则报错；之后使用 plink 软件生成二进制文件，将退出码赋给 <code>exit_code</code> ，如果退出码不为0，说明plink 软件生成二进制文件存在报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每对plink文件生成 bim 文件</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> os.listdir(<span class="string">&quot;.&quot;</span>):</span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(i): <span class="comment">#判断是文件</span></span><br><span class="line">        <span class="keyword">if</span> i[-<span class="number">4</span>:] == <span class="string">&quot;.ped&quot;</span>: <span class="comment">#判断后缀是.ped</span></span><br><span class="line">            prefix = i[:-<span class="number">4</span>]   <span class="comment">#去除.ped</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">f&quot;<span class="subst">&#123;prefix&#125;</span>.map&quot;</span>):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Error: have <span class="subst">&#123;prefix&#125;</span>.ped but not have <span class="subst">&#123;prefix&#125;</span>.map\n&quot;</span>)</span><br><span class="line">                total_error_status = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                exit_code = os.system(<span class="string">f&quot;plink --allow-extra-chr --chr-set 95 --file <span class="subst">&#123;prefix&#125;</span> --out <span class="subst">&#123;prefix&#125;</span> &amp;&gt; /dev/null&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> exit_code != <span class="number">0</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;Error: plink file <span class="subst">&#123;prefix&#125;</span> has problems and can&#x27;t go through plink software, please see <span class="subst">&#123;prefix&#125;</span>.log\n&quot;</span>)</span><br><span class="line">                    total_error_status = <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面一步中，只要存在报错，<code>total_error_status</code> 的值就会改为<code>True</code> 。如果有问题，程序中止。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> total_error_status:</span><br><span class="line">    sys.exit(<span class="number">1</span>) </span><br></pre></td></tr></table></figure>
<h3 id="遍历所有bim文件，查找有问题的plink文件">遍历所有bim文件，查找有问题的plink文件</h3>
<p>这里首先是遍历输入文件的 <code>bim</code> 文件，将第一个<code>bim</code>文件所有SNP的碱基信息存入到<code>dict1</code> 字典中，键为SNP名称，值为该SNP的碱基的集合（包含 “0”）。</p>
<p>然后以第一个<code>bim</code>文件为模块，比对其他<code>bim</code> 文件。如果其他<code>bim</code> 文件的位点不再第一个<code>bim</code> 文件中，或者某个SNP的两个碱基与第一个<code>bim</code>文件不匹配，则打印报错信息，否则就打印<code>***.bim is well</code> ，说明<strong>与第一个<code>bim</code>文件相比较</strong>，这个<code>bim</code>文件没问题。</p>
<p>注意，由于这里第一个<code>bim</code>文件是随机选择的，因此如果恰好第一个<code>bim</code>文件就是有问题的，那么可能出现其他<code>bim</code> 文件均报错的情况。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#遍历所有的bim文件</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> os.listdir(<span class="string">&quot;.&quot;</span>):</span><br><span class="line">    <span class="keyword">if</span> (os.path.isfile(i)) <span class="keyword">and</span> (i[-<span class="number">4</span>:] == <span class="string">&quot;.bim&quot;</span>): <span class="comment">#判断是文件，后缀为bim</span></span><br><span class="line">        <span class="comment"># prefix = i[:-4]   #去除.bim</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span> is first bim&quot;</span>) <span class="comment"># 打印第一个文件</span></span><br><span class="line">            bim_file = <span class="built_in">open</span>(i,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> i2 <span class="keyword">in</span> bim_file:</span><br><span class="line">                f2 = i2.split()</span><br><span class="line">                temp_alleles_set = dict1[f2[<span class="number">1</span>]] <span class="comment"># 该SNP的碱基集合</span></span><br><span class="line">                temp_alleles_set.add(<span class="string">&quot;0&quot;</span>) <span class="comment"># 先添加0</span></span><br><span class="line">                temp_alleles_set.add(f2[-<span class="number">2</span>])</span><br><span class="line">                temp_alleles_set.add(f2[-<span class="number">1</span>])</span><br><span class="line">            bim_file.close()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 以第一个bim为模板，比对其他bim文件。</span></span><br><span class="line">            bim_file = <span class="built_in">open</span>(i,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> i2 <span class="keyword">in</span> bim_file:</span><br><span class="line">                f2 = i2.split()</span><br><span class="line">                <span class="keyword">if</span> f2[<span class="number">1</span>] <span class="keyword">in</span> dict1:</span><br><span class="line">                    temp_alleles_set = dict1[f2[<span class="number">1</span>]].copy() <span class="comment"># 第一个文件该SNP碱基集合的拷贝</span></span><br><span class="line">                    temp_alleles_set.add(f2[-<span class="number">2</span>])</span><br><span class="line">                    temp_alleles_set.add(f2[-<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(temp_alleles_set) &gt; <span class="number">3</span>: <span class="comment"># 如果超过了两个碱基</span></span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">f&quot;Error: SNP <span class="subst">&#123;f2[<span class="number">1</span>]&#125;</span> in <span class="subst">&#123;i&#125;</span> is not consistent with first bim\n&quot;</span>) <span class="comment">#打印错误文件的错误碱基</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;Error: SNP <span class="subst">&#123;f2[<span class="number">1</span>]&#125;</span> in <span class="subst">&#123;i&#125;</span> not in first bim\n&quot;</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span> is well&quot;</span>) <span class="comment">#没有问题则打印没问题</span></span><br><span class="line">            bim_file.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>比对两个bim文件代码</h1>
<h2 id="前言">前言</h2>
<p>假如你在上一步找到有问题的plink文件，你先看看这个plink文件与所谓的正常的plink文件到底是哪些位点的等位基因不一样，你就可以接着运行这个脚本。</p>
<p>或者你总共就只有两对plink文件，合并报错，你也可以直接运行这个脚本。</p>
<h2 id="运行代码-2">运行代码</h2>
<p>代码文件见: <a href="https://github.com/VincereZhou/code_backup/blob/master/cmp_two_bims.py">cmp_two_bims.py</a></p>
<p>将需要检验的bim文件和本程序放在一个文件夹内，运行命令示范如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python cmp_two_bims.py 1.bim 2.bim cmp_two_bims.txt</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong>：</p>
<p><code>1.bim</code>: 第一个<code>bim</code>文件名称</p>
<p><code>2.bim</code>: 第二个<code>bim</code>文件名称</p>
<p><code>cmp_two_bims.txt</code> : 结果文件名称</p>
<p>注意：这里直接用的是<code>bim</code>文件，如果没有生成就先用plink软件生成一下。</p>
<h2 id="输出文件格式">输出文件格式</h2>
<p>输出文件为<strong>不一致</strong>位点的碱基信息，总共5列，第一列为SNP名称，第二列和第三列为该SNP在第一个<code>bim</code>文件的两个碱基，第四列和第五列为该SNP在第二个<code>bim</code>文件的两个碱基。示例如下</p>
<table>
<thead>
<tr>
<th>CNC10012269</th>
<th>A</th>
<th>G</th>
<th>A</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>CNC10012270</td>
<td>G</td>
<td>C</td>
<td>A</td>
<td>T</td>
</tr>
</tbody>
</table>
<h2 id="代码说明-2">代码说明</h2>
<h3 id="读取文件">读取文件</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">bim1 = <span class="built_in">open</span>(sys.argv[<span class="number">1</span>],<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">bim2 = <span class="built_in">open</span>(sys.argv[<span class="number">2</span>],<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">out_file = <span class="built_in">open</span>(sys.argv[<span class="number">3</span>],<span class="string">&#x27;w&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出文件写入标题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">out_file.write(<span class="string">&quot;\t&quot;</span>.join([<span class="string">&quot;snp&quot;</span>,<span class="string">&quot;bim1_A1&quot;</span>,<span class="string">&quot;bim1_A2&quot;</span>,<span class="string">&quot;bim2_A1&quot;</span>,<span class="string">&quot;bim2_A2&quot;</span>])+<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="遍历第一个bim文件">遍历第一个bim文件</h3>
<p>将第一个<code>bim</code>文件SNP的两个碱基信息写入一个字典中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dick = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> bim1:</span><br><span class="line">    f = i.split()</span><br><span class="line">    dick[f[<span class="number">1</span>]] = f[-<span class="number">2</span>:] <span class="comment">#snp名称：倒数第二列</span></span><br></pre></td></tr></table></figure>
<h3 id="遍历第二个bim文件，比对SNP">遍历第二个bim文件，比对SNP</h3>
<p>首先判断第二个<code>bim</code>文件的SNP是否均在第一个<code>bim</code>文件中，如果不是则报错中止程序。</p>
<p>之后检查每个SNP在两个<code>bim</code>文件中的碱基数目是否超过 2 (加上 “0” 超过3) ，超过了就说明有问题，将该SNP数据的信息写入输出文件，不一致位点数 <code>error_base_num </code> 加1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">error_base_num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> bim2:</span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> dick:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error: &#123;&#125; in bim2 not in bim1&quot;</span>.<span class="built_in">format</span>(f[<span class="number">1</span>]))</span><br><span class="line">        sys.exit()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        bim1_alleles_set = <span class="built_in">set</span>(dick[f[<span class="number">1</span>]])</span><br><span class="line">        bim1_alleles_set.add(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">        bim1_alleles_set.add(f[-<span class="number">2</span>])</span><br><span class="line">        bim1_alleles_set.add(f[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(bim1_alleles_set) &gt; <span class="number">3</span>: <span class="comment">#如果包括0，两个bim合并的等位基因数目大于3，就有问题</span></span><br><span class="line">            error_base_num += <span class="number">1</span></span><br><span class="line">            bim1_alleles = <span class="string">&#x27;\t&#x27;</span>.join(dick[f[<span class="number">1</span>]])</span><br><span class="line">            out_file.write(<span class="string">f&quot;<span class="subst">&#123;f[<span class="number">1</span>]&#125;</span>\t<span class="subst">&#123;bim1_alleles&#125;</span>\t<span class="subst">&#123;f[-<span class="number">2</span>]&#125;</span>\t<span class="subst">&#123;f[-<span class="number">1</span>]&#125;</span>\n&quot;</span>)</span><br><span class="line">            <span class="comment"># print(&quot;Error: &#123;&#125; in bim2 file has more than 2 alleles&quot;.format(f[1]))</span></span><br><span class="line">            <span class="comment"># sys.exit()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="打印提示信息">打印提示信息</h3>
<p>如果不一致位点数为0，那么打印祝贺信息；反之提示有几个不一致位点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> error_base_num == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Congradulation: two bim fils is consistent&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;error_base_num&#125;</span> bases has more than 2 alleles&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="关闭文件">关闭文件</h3>
<p>用完记得关闭文件，这是个好习惯</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bim1.close()</span><br><span class="line">bim2.close()</span><br><span class="line">out_file.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>调整plink文件SNP顺序代码实现</title>
    <url>/posts/c9697aaa/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>一般来说 Plink 文件中的SNP顺序并不影响任何操作，如果有必要的话，可以通过下面这个代码以指定SNP顺序调整plink文件。</p>
<span id="more"></span>
<h1>前言</h1>
<p>经过 plink 软件处理的基因型文件，位点会按照物理位置的顺序进行排序，而且性染色体会重命名为常染色体+1 或 常染色体+2。这里我们同样可以利用 plink 软件的这个特性来实现以我们指定的顺序排序SNP的目的。</p>
<h1>使用软件</h1>
<ul>
<li>python 3.8 及以上版本</li>
<li>plink 软件 v1.90 版本</li>
</ul>
<h1>输入输出文件格式</h1>
<h2 id="plink-文件">plink 文件</h2>
<p>格式说明见<a href="https://vincere.fun/posts/506fc784/">根据芯片号拆分plink文件的代码实现</a></p>
<h1>运行代码</h1>
<p>代码文件见：<a href="https://github.com/VincereZhou/code_backup/blob/master/snp_order.py">snp_order.py</a></p>
<p>将所有输入文件和本程序放在同一文件夹下，运行命令示范如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python snp_order.py cn1.map plink_order cn1_2</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong>：</p>
<p><code>cn1.map</code> :  参考map文件，即为预期调整好SNP顺序之后的map 文件</p>
<p><code>plink_order</code> :  输入plink文件前缀</p>
<p><code>cn1_2</code> : 输出plink文件前缀</p>
<p>注意，参考map文件与输入plink文件的map文件的内容一致，仅仅是SNP顺序变动了。最终会将输入的plink文件的SNP顺序调整为参考map文件的SNP顺序。</p>
<h1>代码说明</h1>
<h2 id="输入参数">输入参数</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os,sys</span><br><span class="line"></span><br><span class="line">ref_map_name = sys.argv[<span class="number">1</span>]</span><br><span class="line">in_plink_prefix = sys.argv[<span class="number">2</span>]</span><br><span class="line">out_plink_prefix = sys.argv[<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<h2 id="判断参数和文件内容">判断参数和文件内容</h2>
<p>这里我们先用一个变量 <code>error_status</code> 作为总的判断异常的逻辑值，默认是 <code>False</code> ，如果运行过程中出现问题，则修改为 <code>True</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">error_status = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>写了一个函数，判断文件名是否存在且非空</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断输入文件是否存在且非空</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Judge_file</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(file_path):</span><br><span class="line">        <span class="keyword">if</span> os.path.getsize(file_path):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之后就是对输入输出文件进行判断，判断三个输入文件是否存在；判断输入plink前缀是否等于输出plink前缀。如果有问题，程序中止。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> Judge_file(ref_map_name):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;ref_map_name&#125;</span> not exist or is empty file\n&quot;</span>)</span><br><span class="line">    error_status = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> Judge_file(<span class="string">f&quot;<span class="subst">&#123;in_plink_prefix&#125;</span>.ped&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;in_plink_prefix&#125;</span>.ped not exist or is empty file\n&quot;</span>)</span><br><span class="line">    error_status = <span class="literal">True</span></span><br><span class="line"><span class="keyword">elif</span> <span class="keyword">not</span> Judge_file(<span class="string">f&quot;<span class="subst">&#123;in_plink_prefix&#125;</span>.map&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;in_plink_prefix&#125;</span>.map not exist or is empty file\n&quot;</span>)</span><br><span class="line">    error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> in_plink_prefix == out_plink_prefix:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: second argument is same with third argument\n&quot;</span>)</span><br><span class="line">    error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> error_status:</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之后判断参考map文件和输入plink文件的map文件内容是否有问题，两个map文件的SNP名称是否完全一致。如果有问题，程序中止。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断两个map的SNP名称是否完全一致</span></span><br><span class="line">ref_map_file = <span class="built_in">open</span>(ref_map_name,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">in_map_file = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;in_plink_prefix&#125;</span>.map&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ref_snp_list = []</span><br><span class="line">ref_snp_dick = &#123;&#125;</span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">temp_id_set = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ref_map_file:</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(f) == <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> temp_id_set:</span><br><span class="line">            temp_id_set.add(f[<span class="number">1</span>])</span><br><span class="line">            ref_snp_list.append(f[<span class="number">1</span>])</span><br><span class="line">            ref_snp_dick[f[<span class="number">1</span>]] = <span class="built_in">str</span>(j) <span class="comment"># snp: 序号</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated id <span class="subst">&#123;f[<span class="number">1</span>]&#125;</span> in <span class="subst">&#123;ref_map_name&#125;</span>\n&quot;</span>)</span><br><span class="line">            error_status = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;j&#125;</span> row in <span class="subst">&#123;ref_map_name&#125;</span> has less or more than 4 columns\n&quot;</span>)</span><br><span class="line">        error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">in_snp_list = []</span><br><span class="line">not_in_snp_list = [] <span class="comment"># 不在参考map中的snp</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">temp_id_set = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> in_map_file:</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(f) == <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> temp_id_set:</span><br><span class="line">            temp_id_set.add(f[<span class="number">1</span>])</span><br><span class="line">            in_snp_list.append(f[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> ref_snp_dick:</span><br><span class="line">                not_in_snp_list.append(f[<span class="number">1</span>])</span><br><span class="line">                error_status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated id <span class="subst">&#123;f[<span class="number">1</span>]&#125;</span> in <span class="subst">&#123;in_plink_prefix&#125;</span>.map\n&quot;</span>)</span><br><span class="line">            error_status = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;j&#125;</span> row in <span class="subst">&#123;in_plink_prefix&#125;</span>.map has less or more than 4 columns\n&quot;</span>)</span><br><span class="line">        error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ref_map_file.close()</span><br><span class="line">in_map_file.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> not_in_snp_list:</span><br><span class="line">    temp_str = <span class="string">&quot;, &quot;</span>.join(not_in_snp_list)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: snp in <span class="subst">&#123;in_plink_prefix&#125;</span>.map but not in <span class="subst">&#123;ref_map_name&#125;</span>: <span class="subst">&#123;temp_str&#125;</span>\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">not</span> error_status) <span class="keyword">and</span> (<span class="built_in">len</span>(ref_snp_list) != <span class="built_in">len</span>(in_snp_list)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: snp numbers of <span class="subst">&#123;in_plink_prefix&#125;</span>.map and <span class="subst">&#123;ref_map_name&#125;</span> are not same\n&quot;</span>)</span><br><span class="line">    error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> error_status:</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="SNP顺序重排">SNP顺序重排</h2>
<p>下面这一步是重点，我生成一个临时map文件，其中第二列与输入文件的map文件一致，但是物理位置却是参考map文件的SNP序号（染色体都设为1）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成临时map文件，染色体均设为1，物理位置设置为参考map的序号</span></span><br><span class="line">temp_map_file = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;in_plink_prefix&#125;</span>_temp.map&quot;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> in_snp_list:</span><br><span class="line">    temp_map_file.write(<span class="string">&#x27;1&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+i+<span class="string">&#x27;\t&#x27;</span>+<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+ref_snp_dick[i]+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">temp_map_file.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后再用这个临时map文件去过一遍plink软件，plink 软件就会傻憨憨地按照第四列的”物理位置“进行SNP重新排序，实际就是按照参考map文件的SNP序号排序。说白了，这里就是我骗了一下plink软件，用plink软件自动按物理位置排序的性质，实现了以任何一种给定SNP顺序排序的目的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重排</span></span><br><span class="line">os.system(<span class="string">f&quot;plink --allow-extra-chr --chr-set 95 --ped <span class="subst">&#123;in_plink_prefix&#125;</span>.ped --map <span class="subst">&#123;in_plink_prefix&#125;</span>_temp.map --recode --out <span class="subst">&#123;out_plink_prefix&#125;</span> &gt; /dev/null&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我们使用参考map文件替换结果map文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用参考map替换结果map</span><br><span class="line">os.system(f&quot;cp &#123;ref_map_name&#125; &#123;out_plink_prefix&#125;.map&quot;)</span><br></pre></td></tr></table></figure>
<p>最后删除中间文件，这里就是那个临时map文件，过河拆桥了属于是。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除中间文件</span></span><br><span class="line">os.system(<span class="string">&quot;rm *temp*&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1>闲话</h1>
<p>我写这个脚本时的需求，就是为了将plink软件处理后的基因型数据调整成plink软件处理前的顺序。也就是，就是用了 plink 软件导致SNP顺序改变了，plink 软件是这个问题的源头。然后，我现在又通过给plink 软件提供一个虚假的map文件，用 plink 软件又把SNP顺序调整回来了，也就是现在 plink 软件又成了这个问题的解药。感觉有点哲学的意思，就像金庸先生说的 “毒物旁边往往生长着解药” 。</p>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>提取FASTA文件描述行中含有特定字符记录的python代码实现</title>
    <url>/posts/a96c56b8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这个代码是提取FASTA文件描述行中含有特定字符的记录。</p>
<p>这个脚本代码量很少，但是需要动一下脑子，难点在于序列部分的行数是不固定的。</p>
<span id="more"></span>
<h1>使用软件</h1>
<ul>
<li>python 3.8 及以上版本</li>
</ul>
<h1>输入输出文件格式</h1>
<p>输入文件为一个FASTA文件，示例数据见 <a href="https://github.com/VincereZhou/code_backup/blob/master/tiao_Sus/1_fa.txt">1_fa.txt</a>。输出数据为提取特定记录后生成的FASTA文件，示例结果文件见 <a href="https://github.com/VincereZhou/code_backup/blob/master/tiao_Sus/out_fa.txt">out_fa.txt</a></p>
<p>FASTA 可以存储任何的序列数据，比如参考基因组文件，蛋白质序列，coding DNA sequence (CDS) , 转录序列等。</p>
<p>FASTA 文件的每条记录包含两个部分：一个是描述部分（&gt; 开始，包含序列名称和其他信息），一个是序列数据部分（第二行直至到描述行，<strong>可占据多行</strong>）。</p>
<p>FASTA 文件的灵活性导致它的结构定义很宽泛，结构不严谨，运行程序可能会遭遇未知的错误。</p>
<p>举个例子，示例数据的第一条记录见下，第一行是描述行，第二行和第三行是序列（应该是RNA序列）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop</span><br><span class="line">UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC</span><br><span class="line">UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA</span><br></pre></td></tr></table></figure>
<h1>运行代码</h1>
<p>代码文件见：<a href="https://github.com/VincereZhou/code_backup/blob/master/tiao_Sus/tiao_Sus.py">tiao_Sus.py</a></p>
<p>将输入文件和本程序放在同一文件夹下，运行命令示范如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python tiao_Sus.py 1_fa.txt Sus out_fa.txt</span><br></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<p><code>1_fa.txt</code>: 第一个参数为输入 FASTA 文件名称</p>
<p><code>Sus</code>:  第二个参数为提取的描述部分字段</p>
<p><code>out_fa.txt</code>: 第三个参数为输出文件名称</p>
<h1>代码说明</h1>
<h2 id="输入参数，打开文件">输入参数，打开文件</h2>
<p>导入 sys 模块，输入参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="comment">#挑不规则行数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">in_file = <span class="built_in">open</span>(sys.argv[<span class="number">1</span>],<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">field = sys.argv[<span class="number">2</span>]</span><br><span class="line">out_file = <span class="built_in">open</span>(sys.argv[<span class="number">3</span>],<span class="string">&#x27;w&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="遍历输入文件">遍历输入文件</h2>
<p>先创建一个空字典，然后遍历输入FASTA文件，字典 <code>dick</code> 的键是行索引 (从0开始)，值为该行的内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dick = &#123;&#125;</span><br><span class="line"></span><br><span class="line">j=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> in_file:</span><br><span class="line">    dick[j] = i <span class="comment">#行：内容 从0开始</span></span><br><span class="line">    j+=<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="遍历字典">遍历字典</h2>
<p>这里是<strong>重点</strong>。遍历字典 <code>dick</code> ，这里其实是 <code>j</code> 的递增来实现文件内容的换行；<code>j</code> 每增加1，相当于文件跳到下一行。通过第一个while 循环 (<code>while j &lt; len(dick)</code>) 保证迭代到文件的最后一行。之后就是一个判断，需要同时满足两个条件：<code>&gt;</code> 在这一行中并且需要查找的特定字符也在这一行中。如果满足这个条件，将这一行内容写入到输出文件中，跳到下一行，再通过 while 循环将后面跟着的序列行也写入到输出文件中（这里用 while 循环是解决序列行数不固定的问题）。如果不满足上面的判断，那么直接跳到下一行。</p>
<p>上面说了一堆逻辑，有点啰嗦，其实你看着输入文件和脚本，<strong>在脑子里运行一遍</strong>就清楚了。我写这个脚本的时候，也是在脑子里运行一遍才明确没有问题的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">j=<span class="number">0</span> </span><br><span class="line"><span class="keyword">while</span> j &lt; <span class="built_in">len</span>(dick): <span class="comment">#不是&lt;=</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;&gt;&#x27;</span> <span class="keyword">in</span> dick[j]) <span class="keyword">and</span> (field <span class="keyword">in</span> dick[j]):</span><br><span class="line">        out_file.write(dick[j])</span><br><span class="line">        j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="string">&#x27;&gt;&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> dick[j]):</span><br><span class="line">            out_file.write(dick[j])</span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        j+=<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="关闭文件">关闭文件</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">in_file.close()</span><br><span class="line">out_file.close()</span><br></pre></td></tr></table></figure>
<h1>闲话</h1>
<p>这是几年前给涛哥写的小代码，虽然代码很短，但是确实花了心思。</p>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>规整某类基因型数据R代码与python代码实现</title>
    <url>/posts/2c9b1be7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这个是规整某类格式”不规范“的基因型数据的脚本实现说明，同时采用了 R 和 python 进行实现。</p>
<p>这个需求实现起来说难不难，说易不易，仅是为了将下面我要提到的这类下机的基因型数据转变为常用的plink格式。这里的两个代码可能本身对其他人无法直接使用，但是还是有些借鉴作用。</p>
<span id="more"></span>
<h1>使用软件</h1>
<ul>
<li>python 3.8 及以上版本</li>
<li>plink 软件 v1.90，并且提前加到环境变量中。</li>
</ul>
<h1>输入文件格式</h1>
<h2 id="下机基因型数据">下机基因型数据</h2>
<p>示例数据见 <a href="https://github.com/VincereZhou/code_backup/blob/master/mass_to_plink/rawdata.xlsx">rawdata.xlsx</a> ，是一个 Excel 表，内容见下表。第一列是样本名称，后面每一列表示一个SNP，标题是SNP的名称。也就是说，一行表示一个样本，一列表示一个SNP。如果基因型为两个字符，说明是杂合子，例如GA；如果基因型是一个字符，说明是纯合子，例如T (正常应该记为TT，这里省略了一个字符)；如果单元格内容为空，说明此处基因型缺失。</p>
<table>
<thead>
<tr>
<th>id</th>
<th>seq-rs319899733</th>
<th>seq-rs320947633</th>
<th>seq-rs326926754</th>
<th>seq-rs327695512</th>
</tr>
</thead>
<tbody>
<tr>
<td>24</td>
<td>T</td>
<td>A</td>
<td></td>
<td>CT</td>
</tr>
<tr>
<td>31</td>
<td>T</td>
<td>GA</td>
<td>C</td>
<td>C</td>
</tr>
<tr>
<td>23</td>
<td>CT</td>
<td>GA</td>
<td>C</td>
<td>C</td>
</tr>
<tr>
<td>29</td>
<td>T</td>
<td>GA</td>
<td></td>
<td>T</td>
</tr>
</tbody>
</table>
<h2 id="参考map文件">参考map文件</h2>
<p>包含下机基因型所有SNP的 map 文件，根据这个文件来生成下机基因型数据的map文件，示例数据见 <a href="https://github.com/VincereZhou/code_backup/blob/master/mass_to_plink/raw.map">raw.map</a></p>
<p>map 文件格式说明见<a href="https://vincere.fun/posts/506fc784/">根据芯片号拆分plink文件的代码实现</a></p>
<h1>输出文件格式</h1>
<p>一对 plink 文件，文件格式说明见<a href="https://vincere.fun/posts/506fc784/">根据芯片号拆分plink文件的代码实现</a></p>
<h1>运行代码</h1>
<h2 id="运行R代码">运行R代码</h2>
<p>R 代码文件见：<a href="https://github.com/VincereZhou/code_backup/blob/master/mass_to_plink/mass_to_plink.R">mass_to_plink.R</a></p>
<p>将两个输入文件和本程序放在同一文件夹下，运行命令示范如下。运行结束后，会生成规整后的 plink 文件 <code>new.ped/map</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Rscript mass_to_plink.R rawdata.xlsx raw.map</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong>：</p>
<p><code>rawdata.xlsx</code>: 第一个参数为下机基因型数据</p>
<p><code>raw.map</code>：第二个参数为参考map文件。</p>
<h2 id="运行python代码">运行python代码</h2>
<p>python 代码文件见：<a href="https://github.com/VincereZhou/code_backup/blob/master/mass_to_plink/mass_to_plink.py">mass_to_plink.py</a></p>
<p>将两个输入文件和本程序放在同一文件夹下，运行命令示范如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python mass_to_plink.py rawdata.xlsx raw.map new2</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong>：</p>
<p><code>rawdata.xlsx</code>: 第一个参数为下机基因型数据</p>
<p><code>raw.map</code>：第二个参数为参考map文件。</p>
<p><code>new2</code> : 输出plink文件前缀</p>
<p>运行结束后，生成以第三个参数为前缀的plink 文件。</p>
<h2 id="示例">示例</h2>
<p>示例数据和代码我都放到了一个文件夹内 <a href="https://github.com/VincereZhou/code_backup/blob/master/mass_to_plink">mass_to_plink</a> ，有兴趣可以自己跑一下。</p>
<h1>代码说明</h1>
<p>这两个代码内部我都有比较详细的注释，这里就不再贴代码了。</p>
<p>两个代码的实现思路是一样的，首先要对基因型数据进行规整，缺失要替换为00，纯合子要改为两个字符，生成 compound 格式的 ped  文件（正常的ped文件一个SNP占两列，compound 格式则是一个SNP占一列，一个SNP的两个碱基之间无分隔符）。之后从参考map中提取相应的SNP的行，生成需要的map文件。最后通过 plink 软件将 compound 格式的文件转化为正常的plink格式。</p>
<h1>后续</h1>
<p>R 本身就有 <code>dataframe</code> 这种数据类型，而 python 是需要借助 pandas 模块进行处理。其实我第一次是用 R 实现的，后面又用 python 写了一遍。分别用 R 和 python 跑了一遍以后，我又用之前提到的比对基因型的代码，比较了两个生成的plink文件，基因型完全一致（具体参考 <a href="https://vincere.fun/posts/fa9e0b0e/">两个Plink文件样本间基因型比对代码实现</a> 和 <a href="https://vincere.fun/posts/6897c9bb/">两个Plink文件同一SNP基因型比对代码实现</a>）。</p>
<p>这里也有一个简单的办法，就是通过 sha1sum 或 md5sum 进行文件校验，你会发现两个 ped 文件 或 map 文件都是一样的。但是这种做法并不稳健，如果校验码不一致，不一定说明两个plink文件基因型不一致，还有很多原因导致校验码不同，比如 SNP 顺序不同，性染色体编码不同，杂合子显示顺序不同（如 A G 与 G A）等等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sha1sum</span> new*.ped</span></span><br><span class="line">5150663442126f2f4e5b57e9d2d58118bf1f90f3  new1.ped</span><br><span class="line">5150663442126f2f4e5b57e9d2d58118bf1f90f3  new2.ped</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sha1sum</span> new*.map</span></span><br><span class="line">f899867a1d9f762b7a3d7fb231d5fc13fdc44aa4  new1.map</span><br><span class="line">f899867a1d9f762b7a3d7fb231d5fc13fdc44aa4  new2.map</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>根据芯片号拆分plink文件的代码实现</title>
    <url>/posts/506fc784/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这个代码同样是一个处理基因型数据的<strong>入门级别</strong>的 python 脚本。</p>
<p>目的是根据芯片号，将一对plink文件，提取相应的基因型个体，拆分为一对或多对子文件。</p>
<span id="more"></span>
<h1>使用软件</h1>
<ul>
<li>python 3.8 及以上版本</li>
</ul>
<h1>输入文件格式</h1>
<h2 id="plink-文件">plink 文件</h2>
<p>plink格式的基因型文件包含两个文件：基因型文件（以.ped结尾）和图谱文件（以.map结尾），格式如下：</p>
<p>（1）基因型文件（ped文件）</p>
<p>FAM001 IND001 0 0 1 2 A A G G A C  …</p>
<p>FAM001 IND002 0 0 1  2 A A A G 0 0  …</p>
<p>……</p>
<p>格式说明：前6列分别是：家系编号，个体编号，父亲编号，母亲编号，性别，表型值；性别编码规则：‘1’代表雄性，‘2’代表雌性，其他字符代表性别未知；从第7列开始是基因型（只支持二等位位点），每个位点2列，默认‘0’代表基因型缺失。</p>
<p>（2）图谱文件（MAP文件）</p>
<p>1 rs234567 0 1237793</p>
<p>1 rs224534 0 1237697</p>
<p>1 rs233556  0 1337456</p>
<p>……</p>
<p>格式说明：包含4列：染色体编号，标记名称，标记遗传图谱，标记物理位置；对于性染色体和线粒体的‘染色体’编号规则：总的常染色体对数加一 表示X染色体，Y染色体、假常染色体和线粒体在此基础上依次加一。</p>
<p>更加详细说明见<a href="https://www.cog-genomics.org/plink/1.9/data">官网</a></p>
<h2 id="拆分文件">拆分文件</h2>
<p>一列或两列，无标题，以空格或制表符分隔。</p>
<p>如果是一列，则为一列芯片号，程序会将这一列芯片号的基因型提取出来，生成一对子文件，命名为 <code>split_plink.ped</code> 和 <code>split_plink.map</code></p>
<p>如果是两列，第一列是芯片号，第二列是芯片分类名（例如品种）。此时程序会将不同分类的芯片提取出来，各生成一对plink文件，plink文件前缀即为分类名。</p>
<h1>输出文件格式</h1>
<p>一对或多对 plink 文件。</p>
<h1>运行代码</h1>
<p>代码文件见：<a href="https://github.com/VincereZhou/code_backup/blob/master/split_plink.py">split_plink.py</a></p>
<p>将两个输入文件和本程序放在同一文件夹下，运行命令示范如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python split_plink.py plink_prefix split_plink.txt</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong>：</p>
<p><code>plink_prefix</code> : 第一个参数为总的plink前缀</p>
<p><code>split_plink.txt</code>：第二个参数为拆分文件</p>
<h1>例子</h1>
<p>举个简单的例子，方便理解。</p>
<p>总的plink为 1.ped 1.map。</p>
<p>1.ped 内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">221 30800300 0 0 0 -9 C C T T T T A A C C</span><br><span class="line">222 30800299 0 0 0 -9 T C T T T T G A T C</span><br><span class="line">223 30800298 0 0 0 -9 T C T T T T A A C C</span><br><span class="line">224 30800297 0 0 0 -9 C C T T T T G A T C</span><br><span class="line">225 30800296 0 0 0 -9 T C T T T T A A C C</span><br></pre></td></tr></table></figure>
<p>1.map 内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>	<span class="number">1_242598</span>	<span class="number">0</span>	<span class="number">242598</span></span><br><span class="line"><span class="number">1</span>	<span class="number">1_10673082</span>	<span class="number">16.99376</span>	<span class="number">10673082</span></span><br><span class="line"><span class="number">1</span>	<span class="number">1_10723065</span>	<span class="number">17.17102</span>	<span class="number">10723065</span></span><br><span class="line"><span class="number">1</span>	<span class="number">1_11407894</span>	<span class="number">19.59961</span>	<span class="number">11407894</span></span><br><span class="line"><span class="number">1</span>	<span class="number">1_11426075</span>	<span class="number">19.66408</span>	<span class="number">11426075</span></span><br></pre></td></tr></table></figure>
<p>第一个拆分文件为 split_plink1.py ，内容只有一列，为3个芯片号。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">30800300</span></span><br><span class="line"><span class="number">30800299</span></span><br><span class="line"><span class="number">30800298</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行命令，提取这三个个体的基因型，第一个参数为 1，为总的plink文件前缀；第二个参数为拆分文件名。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python split_plink.py <span class="number">1</span> split_plink1.txt</span><br></pre></td></tr></table></figure>
<p>生成 <code>split_plink.ped</code> 和 <code>split_plink.map</code> ，生成的 <code>split_plink.map</code>文件与<code>1.map</code> 一致，<code> split_plink.ped</code>  文件内容如下，为需要的三个芯片号的基因型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">221</span> <span class="number">30800300</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">9</span> C C T T T T A A C C</span><br><span class="line"><span class="number">222</span> <span class="number">30800299</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">9</span> T C T T T T G A T C</span><br><span class="line"><span class="number">223</span> <span class="number">30800298</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">9</span> T C T T T T A A C C</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第二个拆分文件为 split_plink2.py ，内容为两列，第二列模拟为 3 个物种，分别命名为 DD, LL,  YY</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">30800300</span>	DD</span><br><span class="line"><span class="number">30800299</span>	DD</span><br><span class="line"><span class="number">30800298</span>	LL</span><br><span class="line"><span class="number">30800297</span>	YY</span><br><span class="line"><span class="number">30800296</span>	YY</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行命令，提取这三个个体的基因型，第一个参数为 1，为总的plink文件前缀；第二个参数为拆分文件名。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python split_plink.py <span class="number">1</span> split_plink2.txt</span><br></pre></td></tr></table></figure>
<p>生成了三对 plink 文件，DD.ped/map ，LL.ped/map ,  YY.ped/map ，三个map 文件均与 <code>1.map</code> 一致。三个 ped 文件内容如下：</p>
<p>DD.ped 内容为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">221</span> <span class="number">30800300</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">9</span> C C T T T T A A C C</span><br><span class="line"><span class="number">222</span> <span class="number">30800299</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">9</span> T C T T T T G A T C</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>LL.ped 内容为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">223 30800298 0 0 0 -9 T C T T T T A A C C</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>YY.ped 内容为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">224</span> <span class="number">30800297</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">9</span> C C T T T T G A T C</span><br><span class="line"><span class="number">225</span> <span class="number">30800296</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">9</span> T C T T T T A A C C</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实现了将不同分类拆分为不同plink文件的需求。</p>
<h1>代码说明</h1>
<h2 id="注释说明">注释说明</h2>
<p>首先是两行注释，第一句以<code>#!</code>开头，后面接着的是我在linux系统中安装的python路径。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/mnt/data/zhouziwen/bin/miniConda/miniconda3/bin/python</span></span><br></pre></td></tr></table></figure>
<p>添加这句话的目的是指定解释器，就是说用什么去执行这个脚本。添加这个命令后，在给这个程序添加<strong>执行权限</strong>后（如何添加执行权限见<a href="https://www.runoob.com/linux/linux-comm-chmod.html">linux 的 chmod命令</a> ），可以将这个脚本视为正常的shell脚本执行，例子如下（<strong>需要先修改为你自己的python路径</strong>）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">./pick0.py <span class="built_in">id</span>.txt bigfile.txt out.txt</span><br></pre></td></tr></table></figure>
<p>如果你没看懂，不要紧，这个不重要，你就还是按照上面的<code>运行代码</code>部分写的运行命令去运行即可。</p>
<p>第二行注释是指定字符编码为 <code>utf-8</code>（字符编码的内容可以看看这篇博客，<a href="https://juejin.cn/post/6844903623474806792">字符编码那点事</a>） ，不然写中文注释会报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br></pre></td></tr></table></figure>
<p>后面是我自己写的两行注释，说明代码功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按照一个芯片号文件拆分plink文件</span></span><br><span class="line"><span class="comment"># 如果芯片号文件只有一列，默认输出文件为 split_plink.ped split_plink.map</span></span><br></pre></td></tr></table></figure>
<h2 id="导入模块和参数">导入模块和参数</h2>
<p>这里只导入了三个内置模块。</p>
<p>导入 <code>defaultdict</code> 函数的作用是可以指定字典的值为一种默认的数据类型，比如列表，下面会用到。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os,sys</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br></pre></td></tr></table></figure>
<p>接下来，导入参数并读取文件。这里将第一个参数 (<code>sys.argv[1]</code>) 命名为 <code>plink_prefix</code> ，即 plink 文件前缀。第二个参数为拆分文件，打开文件，命名为 <code>split_file</code> 。打开 <code>ped</code> 文件，命名为 <code>plink_file</code> 。 最后一句将map文件名命名为 <code>map_file_name</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plink_prefix = sys.argv[<span class="number">1</span>] <span class="comment"># plink文件前缀</span></span><br><span class="line">split_file = <span class="built_in">open</span>(sys.argv[<span class="number">2</span>],<span class="string">&#x27;r&#x27;</span>) <span class="comment"># 拆分信息文件，无标题，一列（芯片号）或两列（芯片号-分类名）</span></span><br><span class="line">plink_file = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix&#125;</span>.ped&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">map_file_name = <span class="string">f&quot;<span class="subst">&#123;plink_prefix&#125;</span>.map&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="获取拆分文件列数">获取拆分文件列数</h2>
<p>这里是通过 <code>readline()</code> 读取拆分文件的第一行内容，然后使用 <code>split()</code> 函数对第一行内容按空白字符拆分为列表，最后用 <code>len()</code> 函数求列表元素的个数。通过这种方法，实际获取的是拆分文件第一行的列数，命名为 <code>column_num</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">column_num = <span class="built_in">len</span>(split_file.readline().split())</span><br></pre></td></tr></table></figure>
<p>之后记得通过 <code>seek(0)</code> 函数将指针复原，不然下面对文件进行循环就是从第二行开始了，相当于剔除了第一行。使用了 <code>seek(0)</code> ，下面对文件进行循环，就依然是从第一行开始。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">split_file.seek(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="读取拆分文件内容">读取拆分文件内容</h2>
<p>先创建一个空列表和 一个值默认为列表的字典</p>
<p>注意，使用 <code>defaultdict(list)</code> 必须先从<code>collections</code> 包中导入<code>defaultdict</code> 函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set1 = <span class="built_in">set</span>()</span><br><span class="line">dick = defaultdict(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<p>遍历拆分文件内容，形成 <code>dick</code> 字典的内容。这里分了两种情况，拆分文件为一列和两列的情况，但是内容大同小异。</p>
<p>此处代码对于拆分文件的每一行首先判断列数是否均符合要求（是不是都是一列或两列），存在不符合要求的行，则报错 (<code>sys.exit(1)</code>) ；之后判断不同行之间的芯片号是否出现重复（通过 set1 进行判断），如果重复，则报错；最后将文件内容放入 <code>dick</code> 字典中，字典的键为分类名（如果拆分文件只有一列，则所有芯片号的分类名均设置为 <code>split_plink</code>），值为属于该分类名的所有芯片号组成的列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">j=<span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> column_num == <span class="number">1</span>: <span class="comment"># 只有一列</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> split_file:</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        f = i.split()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(f) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> f[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> set1:</span><br><span class="line">                set1.add(f[<span class="number">0</span>])</span><br><span class="line">                dick[<span class="string">&quot;split_plink&quot;</span>].append(f[<span class="number">0</span>]) <span class="comment"># 品种：芯片号的列表</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated chipid <span class="subst">&#123;f[<span class="number">0</span>]&#125;</span> in <span class="subst">&#123;sys.argv[<span class="number">1</span>]&#125;</span>\n&quot;</span>)</span><br><span class="line">                sys.exit(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error:<span class="subst">&#123;j&#125;</span> row in <span class="subst">&#123;sys.argv[<span class="number">1</span>]&#125;</span> is not 1 columns\n&quot;</span>)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">elif</span> column_num == <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> split_file:</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        f = i.split()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(f) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> f[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> set1:</span><br><span class="line">                set1.add(f[<span class="number">0</span>])</span><br><span class="line">                dick[f[<span class="number">1</span>]].append(f[<span class="number">0</span>]) <span class="comment"># 品种：芯片号的列表</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated chipid <span class="subst">&#123;f[<span class="number">0</span>]&#125;</span> in <span class="subst">&#123;sys.argv[<span class="number">1</span>]&#125;</span>\n&quot;</span>)</span><br><span class="line">                sys.exit(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error:<span class="subst">&#123;j&#125;</span> row in <span class="subst">&#123;sys.argv[<span class="number">1</span>]&#125;</span> is not 2 columns\n&quot;</span>)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: first row in <span class="subst">&#123;sys.argv[<span class="number">1</span>]&#125;</span> is not 1 or 2 columns\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="读取-ped-文件内容">读取 ped 文件内容</h2>
<p>先创建一个空集合和空字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set2=<span class="built_in">set</span>()</span><br><span class="line">dick2 = &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>遍历 ped 文件，只做是否存在重复芯片号的判断，如果存在则报错，程序中止。</p>
<p>生成键为芯片号，值为整行内容的字典 <code>dick2</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> plink_file:</span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> set2:</span><br><span class="line">        set2.add(f[<span class="number">1</span>])</span><br><span class="line">        dick2[f[<span class="number">1</span>]] = i <span class="comment"># 芯片号：芯片信息的行</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated chipid <span class="subst">&#123;f[<span class="number">1</span>]&#125;</span> in <span class="subst">&#123;sys.argv[<span class="number">2</span>]&#125;</span>.ped\n&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="写入结果文件">写入结果文件</h2>
<p>这里我们遍历 dick 的所有键，即遍历所有的分类名。首先这里先将原始的map文件复制为当前的分类名的map文件；之后我们创建<code>out_plink_list</code> 这个列表，作为拆分的<code>ped</code>文件内容的临时存储的地方；然后遍历该分类名下的所有芯片号，将这些芯片号的基因型信息存放在<code>out_plink_list</code> 列表中（这里会判断这些芯片号是否均在 plink 文件中，如果不在则程序报错中）。最后创建以分类号为前缀的 <code>ped</code> 文件，将  <code>out_plink_list</code>  中的全部内容写入其中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dick: <span class="comment"># 所有品种</span></span><br><span class="line">    <span class="comment"># 复制map文件</span></span><br><span class="line">    os.system(<span class="string">f&quot;cp <span class="subst">&#123;map_file_name&#125;</span> <span class="subst">&#123;i&#125;</span>.map&quot;</span>) </span><br><span class="line">    out_plink_list = []</span><br><span class="line">    <span class="keyword">for</span> i2 <span class="keyword">in</span> dick[i]:</span><br><span class="line">        <span class="comment"># 如果芯片号不在plink文件中报错</span></span><br><span class="line">        <span class="keyword">if</span> i2 <span class="keyword">not</span> <span class="keyword">in</span> dick2:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;i2&#125;</span> in <span class="subst">&#123;sys.argv[<span class="number">1</span>]&#125;</span> not in <span class="subst">&#123;sys.argv[<span class="number">2</span>]&#125;</span>\n&quot;</span>)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line">        out_plink_list.append(dick2[i2])</span><br><span class="line">    <span class="comment"># 生成plink 文件</span></span><br><span class="line">    out_plink_file = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span>.ped&quot;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    out_plink_file.writelines(out_plink_list)</span><br><span class="line">    out_plink_file.close()</span><br></pre></td></tr></table></figure>
<p>这里，如果拆分文件只有一列，那么 <code>dick</code> 中只有一种分类号，即<code>split_plink</code> ，因此最终只会生成一对plink文件，即 <code>split_plink.ped/map</code> 。</p>
<h2 id="关闭文件">关闭文件</h2>
<p>所有打开的文件记得关闭，由于写入的文件已经在循环中关闭了，最后只需要关闭读取的两个文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">split_file.close()</span><br><span class="line">plink_file.close()</span><br></pre></td></tr></table></figure>
<h1>小结</h1>
<p>这个脚本其实和上一篇<a href="https://vincere.fun/posts/a3902eec/">根据ID提取文件中相应行的python脚本实现与详细讲解</a> 有异曲同工之处，说白了都是根据某一列从提取需要的特定行，像这种需求用 python 很容易实现，而且可以再加一些判断，可以做到比较稳健。</p>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>根据ID提取文件中相应行的python脚本实现与详细讲解</title>
    <url>/posts/a3902eec/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这个代码是一个处理数据<strong>入门级别</strong>的 python 脚本，我尽可能详细地解释一下，方便小白入门。</p>
<p>这个代码目的是根据提供的ID文件从大文件中提取这些ID的行，生成一个新的文件， 与 Excel 的 <code>vlookup</code> 函数功能相似，优点是自动化。另外Excel 处理大数据会卡，甚至卡死，这时必须要用代码。</p>
<span id="more"></span>
<h1>使用软件</h1>
<ul>
<li>python 3.8 及以上版本</li>
</ul>
<h1>输入文件格式</h1>
<ul>
<li>
<p>ID 文件：第一列必须为需要提取的ID，可以包含其他无关列，以空格或制表符分隔。</p>
</li>
<li>
<p>大文件：用于提取信息的文件，第一列为ID，<strong>ID不能重复</strong>，以空格或制表符分隔。</p>
</li>
</ul>
<h1>输出文件格式</h1>
<p>输出文件为 ID 文件中的 ID 在大文件中的行。</p>
<h1>运行代码</h1>
<p>代码文件见：<a href="https://github.com/VincereZhou/code_backup/blob/master/pick0.py">pick0.py</a></p>
<p>将两个输入文件和本程序放在同一文件夹下，运行命令示范如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python pick0.py <span class="built_in">id</span>.txt bigfile.txt out.txt</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong>：</p>
<p><code>id.txt</code> : 第一个参数为 ID文件名称</p>
<p><code>bigfile.txt</code>：第二个参数为大文件名称</p>
<p><code>out.txt</code>：第三个参数为输出文件名称</p>
<h1>例子</h1>
<p>举个简单的例子。</p>
<p>id 文件为 id.txt ，内容如下</p>
<table>
<thead>
<tr>
<th>YYJXNM518090007</th>
</tr>
</thead>
<tbody>
<tr>
<td>YYJXNM518088704</td>
</tr>
<tr>
<td>YYJXNM518086910</td>
</tr>
</tbody>
</table>
<p>大文件为 big.txt，内容如下</p>
<table>
<thead>
<tr>
<th>YYJXNM518090007</th>
<th>202733730005_R01C02</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>YYJXNM518087902</td>
<td>202733730005_R01C04</td>
<td>1</td>
</tr>
<tr>
<td>YYJXNM518091108</td>
<td>202733730005_R02C01</td>
<td>1</td>
</tr>
<tr>
<td>YYJXNM518089506</td>
<td>202733730005_R02C02</td>
<td>1</td>
</tr>
<tr>
<td>YYJXNM518088704</td>
<td>202733730005_R02C03</td>
<td>1</td>
</tr>
<tr>
<td>YYJXNM518089706</td>
<td>202733730005_R02C04</td>
<td>1</td>
</tr>
<tr>
<td>YYJXNM518087310</td>
<td>202733730005_R03C01</td>
<td>1</td>
</tr>
<tr>
<td>YYJXNM518083704</td>
<td>202733730005_R03C03</td>
<td>1</td>
</tr>
<tr>
<td>YYJXNM518088705</td>
<td>202733730005_R03C04</td>
<td>1</td>
</tr>
<tr>
<td>YYJXNM518086910</td>
<td>202733730005_R04C01</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>执行命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python pick0.py <span class="built_in">id</span>.txt big.txt out.txt</span><br></pre></td></tr></table></figure>
<p>结果文件为 out.txt，内容如下，顺序与ID文件一致。</p>
<table>
<thead>
<tr>
<th>YYJXNM518090007</th>
<th>202733730005_R01C02</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>YYJXNM518088704</td>
<td>202733730005_R02C03</td>
<td>1</td>
</tr>
<tr>
<td>YYJXNM518086910</td>
<td>202733730005_R04C01</td>
<td>1</td>
</tr>
</tbody>
</table>
<h1>代码说明</h1>
<h2 id="注释说明">注释说明</h2>
<p>首先是两行注释，第一句以<code>#!</code>开头，后面接着的是我在linux系统中安装的python路径。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/mnt/data/zhouziwen/bin/miniConda/miniconda3/bin/python</span></span><br></pre></td></tr></table></figure>
<p>添加这句话的目的是指定解释器，就是说用什么去执行这个脚本。添加这个命令后，在给这个程序添加<strong>执行权限</strong>后（如何添加执行权限见<a href="https://www.runoob.com/linux/linux-comm-chmod.html">linux 的 chmod命令</a> ），可以将这个脚本视为正常的shell脚本执行，例子如下（<strong>需要先修改为你自己的python路径</strong>）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">./pick0.py <span class="built_in">id</span>.txt bigfile.txt out.txt</span><br></pre></td></tr></table></figure>
<p>如果你没看懂，不要紧，这个不重要，你就还是按照上面的<code>运行代码</code>部分写的运行命令去运行即可。</p>
<p>第二行注释是指定字符编码为 <code>utf-8</code>（字符编码的内容可以看看这篇博客，<a href="https://juejin.cn/post/6844903623474806792">字符编码那点事</a>） ，不然写中文注释会报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br></pre></td></tr></table></figure>
<h2 id="导入模块">导入模块</h2>
<p>python 的模块就相当于 R中的安装包，这里我们使用一个内置模块<code>sys</code>，目的是可以输入参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys </span><br></pre></td></tr></table></figure>
<h2 id="打开文件">打开文件</h2>
<p>这里我们使用 <code>sys</code> 模块的 <code>sys.argv</code> 导入外部参数，这里 <code>sys.argv[1]</code> 就是第一个参数，<code>sys.argv[2]</code> 就是第二个参数，以此类推。</p>
<p>在 python 中使用 <code>open</code> 函数打开文件，后面跟着 <code>'r'</code> 是读取文件，<code>'w'</code> 则是写入文件（没有则新建，已有该文件会直接覆盖），这两个分别是 <code>read</code> 和 <code>write</code> 的缩写。<code>open</code> 函数更具体的说明见<a href="https://www.runoob.com/python/python-func-open.html">open() 函数-菜鸟教程</a></p>
<p>这里的意思就是说，将输入的第一个参数以只读模式打开，命名为 <code>id</code> ；同样将第二个参数以只读模式打开，命名为 <code>bigfile</code> ；将第三个参数以<strong>写入模型</strong>打开，命名为 <code>outfile</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">id</span> = <span class="built_in">open</span>(sys.argv[<span class="number">1</span>],<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">bigfile = <span class="built_in">open</span>(sys.argv[<span class="number">2</span>],<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">outfile = <span class="built_in">open</span>(sys.argv[<span class="number">3</span>],<span class="string">&#x27;w&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="创建集合和字典">创建集合和字典</h2>
<p>这里我们创建一个空的集合和一个空的字典，分别命名为 set1 和 dick，一行同时创建两个变量用分号隔开。</p>
<p>集合和字典都是 python的可变数据结构，底层都是采用了哈希表。集合是存储单个值，字典是存储键值对，二者的共同特点是<strong>键不能重复</strong>，键出现重复会直接覆盖旧的数据。这一块我一句两句讲不清楚，不知道的可以自行上网看一些python的资料，只需要输入python和数据结构两个关键字，就能找到一堆资料了。</p>
<p>我这里用集合和字典，主要是利用它们查询快的特点（查看某个值是否在集合/字典中）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set1 = <span class="built_in">set</span>();dick=&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历大文件">遍历大文件</h2>
<p>python 可以使用 for 循环对一个文件的所有行进行遍历。不同的层次结构用缩进表示，每次缩进必须为 4 个空格。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> bigfile:</span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> f[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> dick:</span><br><span class="line">        dick[f[<span class="number">0</span>]] = i</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated id <span class="subst">&#123;f[<span class="number">0</span>]&#125;</span> in <span class="subst">&#123;sys.argv[<span class="number">2</span>]&#125;</span>\n&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>下面我们一行一行来看，第一句是 for 循环，遍历所有行，每一行的内容为一个字符串，并且这里命名为<code>i</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> bigfile:</span><br></pre></td></tr></table></figure>
<p>第二句话利用python字符串对象的 <code>split()</code>函数，将每一行的内容按照空白符（空格或制表符）进行分割，分隔结果为一个由各列内容组成的列表，命名为 <code>f</code>。<code>split()</code> 函数的具体解释见<a href="https://www.runoob.com/python/att-string-split.html">split() 函数-菜鸟教程</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = i.split()</span><br></pre></td></tr></table></figure>
<p>下面就是一个 <code>if-else</code> 结构，由于 python 索引是从0开始的，因此 <code>f[0]</code> 表示第一列的内容。</p>
<p>首先判断 <code>f[0]</code> 是否在 <code>dick</code> 字典中，<code>in</code> 表示 f[0] 是否在 dick 中，加 <code>not</code> 表示否定，也就是如果 <code>f[0]</code> 不在 <code>dick</code> 中的话，那么执行 <code>dick[f[0]] = i</code>，即在<code>dick</code> 字典中新增键为 <code>f[0]</code> ，值为 <code>i</code> （<code>i</code> 为整行的内容）的一条记录。如果 <code>f[0]</code> 在 <code>dick</code> 中，此时说明第一列存在重复ID，执行<code>else</code> 部分，<code>else</code> 部分首先用 <code>print</code>函数打印了一条报错信息，内部采用了 python新推出的 <code>f-string</code> ，用于格式化字符串（具体可见<a href="https://cloud.tencent.com/developer/article/1618028">f-string格式化输出</a>），简单地说，就是将<code>&#123;&#125;</code>的部分使用其中变量的内容，<code>f-string</code>不清楚可以先放一放；然后采用 <code>sys.exit(1)</code> 直接退出程序。</p>
<p>我再用人话说一遍目的，这里就是判断大文件的ID是否有重复，只要存在重复那么程序会直接报错终止。不存在重复的话，那么就会往<code>dick</code>字典中新增内容，键为ID，值为整行内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> f[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> dick:</span><br><span class="line">    dick[f[<span class="number">0</span>]] = i</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated id <span class="subst">&#123;f[<span class="number">0</span>]&#125;</span> in <span class="subst">&#123;sys.argv[<span class="number">2</span>]&#125;</span>\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="遍历ID文件，生成结果文件">遍历ID文件，生成结果文件</h2>
<p>这里首先新增了两个数字变量和一个列表。这三个的目的是，<code>not_in_num</code> 是ID文件中的ID不在大文件中的数目，<code>duplicate_id_num</code> 是ID文件中剔除的重复ID的数目，<code>not_in_list</code> 是是ID文件中的ID不在大文件中的ID组成的列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">not_in_num = <span class="number">0</span></span><br><span class="line">duplicate_id_num = <span class="number">0</span></span><br><span class="line">not_in_list = []</span><br></pre></td></tr></table></figure>
<p>遍历ID文件，这里将一下流程，首先会对ID进行去重，然后判断ID是否在dick中，如果在，那么就将这个ID对应的大文件中的行内容写入到输出文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">id</span>:</span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> f[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> set1: <span class="comment">#id文件去重</span></span><br><span class="line">        set1.add(f[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> f[<span class="number">0</span>] <span class="keyword">in</span> dick:</span><br><span class="line">            outfile.write(dick[f[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            not_in_num += <span class="number">1</span></span><br><span class="line">            not_in_list.append(f[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        duplicate_id_num += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如果ID文件中存在重复ID，打印信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> duplicate_id_num &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Warning: <span class="subst">&#123;duplicate_id_num&#125;</span> duplicated id in <span class="subst">&#123;sys.argv[<span class="number">1</span>]&#125;</span>\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>如果存在不在大文件中的ID，生成一个新的文件，<code>pick0_not_in_id.txt</code>，内容就是不在大文件中的ID，即 <code>not_in_list</code> 的内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> not_in_num &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Warning: <span class="subst">&#123;not_in_num&#125;</span> id not in <span class="subst">&#123;sys.argv[<span class="number">2</span>]&#125;</span>\n&quot;</span>)</span><br><span class="line">    not_in_file = <span class="built_in">open</span>(<span class="string">&#x27;pick0_not_in_id.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> not_in_list:</span><br><span class="line">        not_in_file.write(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span>\n&quot;</span>)</span><br><span class="line">    not_in_file.close()</span><br></pre></td></tr></table></figure>
<h2 id="关闭文件">关闭文件</h2>
<p>使用 <code>open</code>函数打开文件后，记得关闭文件，这是一个好习惯。写入的文件（即<code>'w'</code>模式）只有关闭了文件，才会真正写入到硬盘中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">id</span>.close()</span><br><span class="line">bigfile.close()</span><br><span class="line">outfile.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>两个Plink文件同一SNP基因型比对代码实现</title>
    <url>/posts/6897c9bb/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本软件是<a href="https://vincere.fun/posts/fa9e0b0e/">两个Plink文件样本间基因型比对代码实现</a>的另一种比对角度， 前面的思路是在比较两个基因型文件中，同一个样本之间有多少位点不一致，这里是比较同一个SNP有多少样本的分型不一致。在比对同一个群体的两个plink文件时，如果存在不一致，这两种比对角度都是必需的。</p>
<span id="more"></span>
<p>举个例子，比对某个群体基因型文件填充前后的基因型变化，查看样本间不一致率，发现所有样本都有几十个位点不一致，前三行如下：</p>
<table>
<thead>
<tr>
<th>202884940104_R14C04</th>
<th>202884940104_R14C04</th>
<th>15</th>
<th>34653</th>
<th>0.0004</th>
</tr>
</thead>
<tbody>
<tr>
<td>202884940104_R11C01</td>
<td>202884940104_R11C01</td>
<td>17</td>
<td>34665</td>
<td>0.0005</td>
</tr>
<tr>
<td>202888800049_R23C04</td>
<td>202888800049_R23C04</td>
<td>17</td>
<td>34658</td>
<td>0.0005</td>
</tr>
</tbody>
</table>
<p>而通过相同的 SNP 间的不一致率，发现大部分 SNP 在两个基因型文件中完全一致，只有一小部分SNP存在不一致，前三行如下：</p>
<table>
<thead>
<tr>
<th>8_118011832</th>
<th>3508</th>
<th>3529</th>
<th>0.994</th>
</tr>
</thead>
<tbody>
<tr>
<td>5_39432167</td>
<td>3459</td>
<td>3524</td>
<td>0.9816</td>
</tr>
<tr>
<td>14_133523132</td>
<td>3428</td>
<td>3518</td>
<td>0.9744</td>
</tr>
</tbody>
</table>
<h1>前提条件</h1>
<p>两个 plink 文件中的 map 文件的染色体、SNP名称及物理位置必须保持一致，样本名称保持一致（两个plink 文件中同一样本的芯片号相同，可能需要自己手动转plink文件的样本名称）。</p>
<h1>使用软件</h1>
<ul>
<li>python 3.0以上版本，事先安装 numpy 模块。</li>
<li>plink 1.9 , 并将 plink 添加到环境变量中。</li>
</ul>
<h1>输入文件格式</h1>
<ul>
<li>plink 文件 ：前缀相同的一对文件，后缀分别为<code>.ped</code> ，<code>.map</code> 。</li>
</ul>
<h1>输出文件说明</h1>
<p><code>cmp_common_samples.txt</code> :  第一列为SNP名称，第二列为两个plink文件中共同样本中不一致的样本数目，第三列为共同样本总数，第四列为前两列相除得到的不一致率。</p>
<p>示例如下：</p>
<table>
<thead>
<tr>
<th>8_118011832</th>
<th>3508</th>
<th>3529</th>
<th>0.994</th>
</tr>
</thead>
<tbody>
<tr>
<td>5_39432167</td>
<td>3459</td>
<td>3524</td>
<td>0.9816</td>
</tr>
<tr>
<td>14_133523132</td>
<td>3428</td>
<td>3518</td>
<td>0.9744</td>
</tr>
</tbody>
</table>
<h1>运行代码</h1>
<p>代码文件见：<a href="https://github.com/VincereZhou/code_backup/blob/master/compair_snps.py">compair_snps.py</a></p>
<p>将输入文件和本程序放在同一文件夹下，运行命令示范为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python compair_snps.py --plink1 plink1 --plink2 plink2</span><br></pre></td></tr></table></figure>
<p><strong>可用参数说明</strong>：</p>
<p><code>--plink1</code>: 第一个plink文件前缀，必选。</p>
<p><code>--plink2</code>: 第二个plink文件前缀，可选。</p>
<p><code>--exclude-miss</code> : 基因型比对是否先剔除缺失值，可选，只能为yes和no，默认为yes。如果该选项设置为no，比对时不会剔除缺失样本对，如果存在同一个样本，在一个基因型文件中有基因型，另一个基因型文件中则为缺失，该样本同样会被视为不一致位点；如果该选项设置为 yes ，比对时会剔除至少一个样本为缺失的位点，只比对两个样本均不为缺失的位点。</p>
<p><code>--save-temp</code> :  是否保留中间文件，可选，只能为yes和no，默认为 no。</p>
<p><code>--out</code> : 结果文件名称，可选，默认为 <code>cmp_common_samples.txt</code></p>
<h1>代码说明</h1>
<h2 id="检验参数">检验参数</h2>
<p>检验输入的各个参数是否合规</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#检验参数</span></span><br><span class="line">legal_argument_set = <span class="built_in">set</span>([<span class="string">&quot;yes&quot;</span>, <span class="string">&quot;no&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">f&quot;<span class="subst">&#123;args.plink1&#125;</span>.ped&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: not exist <span class="subst">&#123;args.plink1&#125;</span>.ped\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">f&quot;<span class="subst">&#123;args.plink1&#125;</span>.map&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: not exist <span class="subst">&#123;args.plink1&#125;</span>.map\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">f&quot;<span class="subst">&#123;args.plink2&#125;</span>.ped&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: not exist <span class="subst">&#123;args.plink2&#125;</span>.ped\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">f&quot;<span class="subst">&#123;args.plink2&#125;</span>.map&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: not exist <span class="subst">&#123;args.plink2&#125;</span>.map\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.exclude_miss <span class="keyword">not</span> <span class="keyword">in</span> legal_argument_set:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: illegal input, --exclude-miss must be yes or no\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> args.save_temp <span class="keyword">not</span> <span class="keyword">in</span> legal_argument_set:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: illegal input, --save-temp must be yes or no\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="复制基因型文件">复制基因型文件</h2>
<p>这里根据原始plink文件重新生成两套新的plink文件，其中芯片号使用数字代替。</p>
<p>这里会提取<strong>共同位点，共同样本</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plink_prefix1 = args.plink1</span><br><span class="line">plink_prefix2 = args.plink2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制 map</span></span><br><span class="line">os.system(<span class="string">f&quot;cp <span class="subst">&#123;plink_prefix1&#125;</span>.map <span class="subst">&#123;plink_prefix1&#125;</span>_temp.map&quot;</span>)</span><br><span class="line">os.system(<span class="string">f&quot;cp <span class="subst">&#123;plink_prefix2&#125;</span>.map <span class="subst">&#123;plink_prefix2&#125;</span>_temp.map&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新生成plink 文件</span></span><br><span class="line">ped1 = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix1&#125;</span>.ped&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">map1 = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix1&#125;</span>.map&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ped2 = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix2&#125;</span>.ped&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">map2 = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix2&#125;</span>.map&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">re_ped1 = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix1&#125;</span>_temp.ped&quot;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">re_ped2 = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix2&#125;</span>_temp.ped&quot;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">common_snp_file = <span class="built_in">open</span>(<span class="string">f&#x27;<span class="subst">&#123;plink_prefix1&#125;</span>_<span class="subst">&#123;plink_prefix2&#125;</span>_common_snp_temp.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">error_status = <span class="literal">False</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#提取共同位点</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">temp_id_set = <span class="built_in">set</span>()</span><br><span class="line">temp_line_set = <span class="built_in">set</span>()</span><br><span class="line">map1_dick = &#123;&#125;  <span class="comment"># SNP名称：染色体_物理位置</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> map1:</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">len</span>(f) == <span class="number">4</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;\t&#x27;</span>.join(f) <span class="keyword">not</span> <span class="keyword">in</span> temp_line_set:</span><br><span class="line">            temp_line_set.add(<span class="string">&#x27;\t&#x27;</span>.join(f))</span><br><span class="line">            <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> temp_id_set:</span><br><span class="line">                temp_id_set.add(f[<span class="number">1</span>])</span><br><span class="line">                map1_dick[f[<span class="number">1</span>]] = f[<span class="number">0</span>]+<span class="string">&quot;_&quot;</span>+f[<span class="number">3</span>] <span class="comment"># SNP名称：“染色体_物理位置”</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated id <span class="subst">&#123;f[<span class="number">1</span>]&#125;</span> in different rows in <span class="subst">&#123;plink_prefix1&#125;</span>.map\n&quot;</span>) </span><br><span class="line">                error_status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicted row <span class="subst">&#123;j&#125;</span> in <span class="subst">&#123;plink_prefix1&#125;</span>.map\n&quot;</span>)</span><br><span class="line">            error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;j&#125;</span> row in <span class="subst">&#123;plink_prefix1&#125;</span>.map has less or more than 4 coloums\n&quot;</span>)</span><br><span class="line">        error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">temp_id_set = <span class="built_in">set</span>()</span><br><span class="line">temp_line_set = <span class="built_in">set</span>()</span><br><span class="line">common_snp_num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> map2:</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">len</span>(f) == <span class="number">4</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;\t&#x27;</span>.join(f) <span class="keyword">not</span> <span class="keyword">in</span> temp_line_set:</span><br><span class="line">            temp_line_set.add(<span class="string">&#x27;\t&#x27;</span>.join(f))</span><br><span class="line">            <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> temp_id_set:</span><br><span class="line">                temp_id_set.add(f[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">in</span> map1_dick:</span><br><span class="line">                    common_snp_num += <span class="number">1</span></span><br><span class="line">                    common_snp_file.write(f[<span class="number">1</span>]+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated id <span class="subst">&#123;f[<span class="number">1</span>]&#125;</span> in different rows in <span class="subst">&#123;plink_prefix2&#125;</span>.map\n&quot;</span>) </span><br><span class="line">                error_status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicted row <span class="subst">&#123;j&#125;</span> in <span class="subst">&#123;plink_prefix2&#125;</span>.map\n&quot;</span>)</span><br><span class="line">            error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;j&#125;</span> row in <span class="subst">&#123;plink_prefix2&#125;</span>.map has less or more than 4 coloums\n&quot;</span>)</span><br><span class="line">        error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nNumber of common SNPs in two plink files: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(common_snp_num))</span><br><span class="line">   </span><br><span class="line"><span class="comment">#重命名</span></span><br><span class="line"><span class="comment"># newid_dick = &#123;&#125; #chipid/sampleid:newid</span></span><br><span class="line"><span class="comment"># sampleid_dick = &#123;&#125; #newid:chipid/sampleid</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#ped重编码为数字(1-indexed)</span></span><br><span class="line"><span class="comment"># 第一次结果不对</span></span><br><span class="line"><span class="comment"># 我懂了，plink 的 merge 命令会重新排列样本顺序，所以不是按照ped1,ped2的顺序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改程序，严格按照想要的总文件的顺序，重编码芯片号。然后合并时先合并ped2,再合并ped1</span></span><br><span class="line"><span class="comment"># 重编码 ped 文件，第一列家系号替换为0，个体号重编码为数字。因为 merge 命令会按照 家系号 + 个体号进行排序。</span></span><br><span class="line"></span><br><span class="line">ped1_dick = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ped1:</span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> ped1_dick:</span><br><span class="line">        ped1_dick[f[<span class="number">1</span>]] = <span class="string">&#x27;\t&#x27;</span>.join(f[<span class="number">2</span>:])+<span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        error_status = <span class="literal">True</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated chip id <span class="subst">&#123;f[<span class="number">1</span>]&#125;</span> in <span class="subst">&#123;plink_prefix1&#125;</span>.ped\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">sample1_num = <span class="built_in">len</span>(ped1_dick)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of records present in plink1 file: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(sample1_num))</span><br><span class="line"></span><br><span class="line">common_sample_list = []</span><br><span class="line">common_sample_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">j=<span class="number">0</span></span><br><span class="line">temp_id_set = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ped2:</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> temp_id_set:</span><br><span class="line">        temp_id_set.add(f[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">in</span> ped1_dick:</span><br><span class="line">            common_sample_num += <span class="number">1</span></span><br><span class="line">            common_sample_list.append(f[<span class="number">1</span>]) <span class="comment">#两个样本重复样的芯片号</span></span><br><span class="line">            re_ped2.write(<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(j)+<span class="string">&#x27;\t&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>.join(f[<span class="number">2</span>:])+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        error_status = <span class="literal">True</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated chip id <span class="subst">&#123;f[<span class="number">1</span>]&#125;</span> in <span class="subst">&#123;plink_prefix2&#125;</span>.ped\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">sample2_num = j</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of records present in plink2 file: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(sample2_num))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of common samples in two plink file: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(common_sample_num))</span><br><span class="line"></span><br><span class="line"><span class="comment">## re_ped1 重排个体顺序，使得与 re_ped2 一致</span></span><br><span class="line"><span class="comment">## 这里的 j 沿着上面递增，没有初始化 j = 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> common_sample_list:</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">    re_ped1.write(<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(j)+<span class="string">&#x27;\t&#x27;</span>+ped1_dick[i])</span><br><span class="line"></span><br><span class="line">ped1.close()</span><br><span class="line">map1.close()</span><br><span class="line">ped2.close()</span><br><span class="line">map2.close()</span><br><span class="line">re_ped1.close()</span><br><span class="line">re_ped2.close()</span><br><span class="line">common_snp_file.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="合并基因型">合并基因型</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果没有共同个体，程序中止</span></span><br><span class="line"><span class="keyword">if</span> common_sample_num == <span class="number">0</span>: <span class="comment">#如果没有共同个体，报错</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: two plink file has no same samples, check your data again!&quot;</span>)</span><br><span class="line">    error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果读取文件过程中出现错误退出</span></span><br><span class="line"><span class="keyword">if</span> error_status:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Please check your file again!&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># extract merge recodeA</span></span><br><span class="line"><span class="comment"># 合并文件是第二个plink文件的共同样本在上方，第一个plink的共同样本在下方，二者样本的顺序一致。</span></span><br><span class="line"></span><br><span class="line">merge_status = os.system(<span class="string">f&quot;plink --allow-extra-chr --chr-set 95 --file <span class="subst">&#123;plink_prefix2&#125;</span>_temp --merge <span class="subst">&#123;plink_prefix1&#125;</span>_temp --extract <span class="subst">&#123;plink_prefix1&#125;</span>_<span class="subst">&#123;plink_prefix2&#125;</span>_common_snp_temp.txt --recodeA --out <span class="subst">&#123;plink_prefix1&#125;</span>_<span class="subst">&#123;plink_prefix2&#125;</span>_merge_temp &gt; /dev/null&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> merge_status != <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error in merge two plink data\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Maybe some common SNP from Complementary strands, check your data again&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#raw文件处理</span></span><br><span class="line">os.system(<span class="string">f&quot;sed &#x27;s/NA/3/g&#x27; <span class="subst">&#123;plink_prefix1&#125;</span>_<span class="subst">&#123;plink_prefix2&#125;</span>_merge_temp.raw &gt; <span class="subst">&#123;plink_prefix1&#125;</span>_<span class="subst">&#123;plink_prefix2&#125;</span>_merge_temp_sed.raw&quot;</span>)</span><br><span class="line">raw_file = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix1&#125;</span>_<span class="subst">&#123;plink_prefix2&#125;</span>_merge_temp_sed.raw&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">out_file = <span class="built_in">open</span>(args.out,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理标题，得到 SNP 名称</span></span><br><span class="line">snp_list = []</span><br><span class="line">title = raw_file.readline().split() <span class="comment">#剔除标题</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> title[<span class="number">6</span>:]:</span><br><span class="line">    snp_name = i[:-<span class="number">2</span>]</span><br><span class="line">    snp_list.append(snp_name) <span class="comment"># SNP名称的列表</span></span><br><span class="line"></span><br><span class="line">raw_list=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> raw_file:</span><br><span class="line">    f = i.split()</span><br><span class="line">    raw_list.append(f[<span class="number">6</span>:])</span><br><span class="line"></span><br><span class="line">array1 = np.array(raw_list, dtype=np.int8)</span><br><span class="line"></span><br><span class="line">total_sample_num = array1.shape[<span class="number">0</span>]</span><br><span class="line">snp_num = array1.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of records present in merged ped file: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(total_sample_num))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of SNPs in merged plink files: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(snp_num))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (total_sample_num != (<span class="number">2</span>*common_sample_num)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: total samples number of merged plink file is not 2 fold of common samples in two plink files\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="比对同一个SNP的基因型">比对同一个SNP的基因型</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#计算不一致率</span></span><br><span class="line">out_list = []</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> args.exclude_miss == <span class="string">&#x27;yes&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(snp_num):</span><br><span class="line">        first_index = <span class="built_in">range</span>(<span class="number">0</span>,common_sample_num)</span><br><span class="line">        second_index = <span class="built_in">range</span>(common_sample_num,total_sample_num)</span><br><span class="line">        v1 = array1[first_index,i]</span><br><span class="line">        v2 = array1[second_index,i]</span><br><span class="line">        non_miss_index = np.where((v1!=<span class="number">3</span>) &amp; (v2!=<span class="number">3</span>))</span><br><span class="line">        total_num = non_miss_index[<span class="number">0</span>].shape[<span class="number">0</span>]</span><br><span class="line">        v1_new = v1[non_miss_index]</span><br><span class="line">        v2_new = v2[non_miss_index]</span><br><span class="line">        no_match_num = np.count_nonzero(v1_new!=v2_new)</span><br><span class="line">        <span class="keyword">if</span> total_num &gt; <span class="number">0</span>:</span><br><span class="line">            no_match_rate = no_match_num/total_num</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            no_match_rate = <span class="number">0</span></span><br><span class="line">        out_list.append([snp_list[i],<span class="string">f&quot;<span class="subst">&#123;no_match_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;total_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;no_match_rate:<span class="number">.4</span>f&#125;</span>&quot;</span>])</span><br><span class="line"><span class="keyword">elif</span> args.exclude_miss == <span class="string">&#x27;no&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(snp_num):</span><br><span class="line">        first_index = <span class="built_in">range</span>(<span class="number">0</span>,common_sample_num)</span><br><span class="line">        second_index = <span class="built_in">range</span>(common_sample_num,total_sample_num)</span><br><span class="line">        v1 = array1[first_index,i]</span><br><span class="line">        v2 = array1[second_index,i]</span><br><span class="line">        total_num = common_sample_num</span><br><span class="line">        no_match_num = np.count_nonzero(v1!=v2)</span><br><span class="line">        no_match_rate = no_match_num/total_num</span><br><span class="line">        out_list.append([snp_list[i],<span class="string">f&quot;<span class="subst">&#123;no_match_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;total_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;no_match_rate:<span class="number">.4</span>f&#125;</span>&quot;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sorted_out_list = <span class="built_in">sorted</span>(out_list, key = <span class="keyword">lambda</span> s:<span class="built_in">float</span>(s[<span class="number">3</span>]), reverse = <span class="literal">True</span>) <span class="comment">#不一致率从大到小</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sorted_out_list:</span><br><span class="line">    out_file.write(<span class="string">&#x27;\t&#x27;</span>.join(i)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">raw_file.close()</span><br><span class="line">out_file.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="删除中间文件">删除中间文件</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除中间文件</span></span><br><span class="line"><span class="keyword">if</span> args.save_temp == <span class="string">&quot;yes&quot;</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">elif</span> args.save_temp == <span class="string">&quot;no&quot;</span>:</span><br><span class="line">    os.system(<span class="string">f&quot;rm *temp*&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>生物信息</tag>
      </tags>
  </entry>
  <entry>
    <title>两个Plink文件样本间基因型比对代码实现</title>
    <url>/posts/fa9e0b0e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本软件对两个plink文件中的样本的共同的SNP位点进行比对，可以应用于同一群体不同处理之后得到的基因型文件的比对（例如比较不同的填充方式得到的plink文件）。</p>
<p>前提条件为，两个map的染色体、SNP名称及物理位置必须保持一致。</p>
<span id="more"></span>
<h1>使用软件</h1>
<ul>
<li>python 3.0以上版本，事先安装 numpy 模块。</li>
<li>plink 1.9 , 并将 plink 添加到环境变量中。</li>
</ul>
<h1>输入文件格式</h1>
<ul>
<li>plink 文件 ：前缀相同的一对文件，后缀分别为<code>.ped</code> ，<code>.map</code> 。</li>
<li>映射文件： 两列，所有基因型个体的芯片号与个体号，空格或 tab分隔，无标题。</li>
</ul>
<h1>输出文件说明</h1>
<ul>
<li>
<p><code>cmp_two_plinks.txt</code> :  第一列为第一个plink文件某个个体的个体号，第二列为第二个plink文件某个个体的个体号，第三列为两个样本不一致的位点数目，第四列为位点总数，第五列为前两列相除得到的不一致率。</p>
<p>示例如下：</p>
<table>
<thead>
<tr>
<th>202309870171_R01C01</th>
<th>202309870171_R01C01</th>
<th>0</th>
<th>43279</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>202309870171_R01C02</td>
<td>202309870171_R01C02</td>
<td>0</td>
<td>43289</td>
<td>0</td>
</tr>
<tr>
<td>202309870171_R02C01</td>
<td>202309870171_R02C01</td>
<td>0</td>
<td>43268</td>
<td>0</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h1>运行代码</h1>
<p>代码文件见：<a href="https://github.com/VincereZhou/code_backup/blob/master/compair_samples.py">compair_samples.py</a></p>
<p>将输入文件和本程序放在同一文件夹下，运行命令示范为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python compair_samples.py --plink1 plink1 --plink2 plink2</span><br></pre></td></tr></table></figure>
<p><strong>可用参数说明</strong>：</p>
<p><code>--plink1</code>: 第一个plink文件前缀，必选。</p>
<p><code>--plink2</code>: 第二个plink文件前缀，可选。</p>
<p><code>--chipid1</code> : 第一个基因型个体映射文件名，芯片和个体号均不能出现重复，可选。如果提供这个文件，那么基因型样本会使用映射文件的个体号。</p>
<p><code>--chipid2</code> : 第二个基因型个体映射文件名，芯片和个体号均不能出现重复，可选。如果提供这个文件，那么基因型样本会使用映射文件的个体号。</p>
<p><code>--cmp-all</code> : 是否需要所有配对两两遍历，可选，只能为yes和no，默认为no。如果该选项设置为yes，则会对两个plink文件中所有样本之间所有可能的组合进行比较，输出所有配对结果；如果设置为no, 则仅针对两个plink文件的共同样本进行基因型比对，输出两个plink文件的同名的样本间的基因型比对结果。</p>
<p><code>--exclude-miss</code> : 基因型比对是否先剔除缺失值，可选，只能为yes和no，默认为yes。如果该选项设置为no，比对时不会剔除缺失位点，如果存在同一个SNP，一个样本有基因型，一个样本为缺失，该SNP同样会被视为不一致位点；如果该选项设置为 yes ，比对时会剔除至少一个样本为缺失的位点，只比对两个样本均不为缺失的位点。</p>
<p><code>--save-temp</code> :  是否保留中间文件，可选，只能为yes和no，默认为 no。</p>
<p><code>--out</code> : 结果文件名称，可选，默认为 cmp_two_plinks.txt</p>
<h1>流程说明</h1>
<p>先对两个ped文件中的芯片号进行重编码，并获取两个ped文件相同的芯片号信息。之后从两个map中提取相同的SNP位点，使用plink软件提取共同位点并合并两个plink文件，得到012编码的raw文件。最后默认对raw文件中两个plink文件中的共同样本进行基因型比对。</p>
<h1>代码说明</h1>
<h2 id="检验参数">检验参数</h2>
<p>检验输入的各个参数是否合规</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#检验参数</span></span><br><span class="line">legal_argument_set = <span class="built_in">set</span>([<span class="string">&quot;yes&quot;</span>, <span class="string">&quot;no&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_number</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">float</span>(s)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">f&quot;<span class="subst">&#123;args.plink1&#125;</span>.ped&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: not exist <span class="subst">&#123;args.plink1&#125;</span>.ped\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">f&quot;<span class="subst">&#123;args.plink1&#125;</span>.map&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: not exist <span class="subst">&#123;args.plink1&#125;</span>.map\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.chipid1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">f&quot;<span class="subst">&#123;args.chipid1&#125;</span>&quot;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: not exist <span class="subst">&#123;args.chipid1&#125;</span>\n\n&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">f&quot;<span class="subst">&#123;args.plink2&#125;</span>.ped&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: not exist <span class="subst">&#123;args.plink2&#125;</span>.ped\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">f&quot;<span class="subst">&#123;args.plink2&#125;</span>.map&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: not exist <span class="subst">&#123;args.plink2&#125;</span>.map\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.chipid2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">f&quot;<span class="subst">&#123;args.chipid2&#125;</span>&quot;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: not exist <span class="subst">&#123;args.chipid2&#125;</span>\n\n&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.cmp_all <span class="keyword">not</span> <span class="keyword">in</span> legal_argument_set:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: illegal input, --cmp-all must be yes or no\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.exclude_miss <span class="keyword">not</span> <span class="keyword">in</span> legal_argument_set:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: illegal input, --exclude-miss must be yes or no\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.save_temp <span class="keyword">not</span> <span class="keyword">in</span> legal_argument_set:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: illegal input, --save-temp must be yes or no\n\n&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="复制文件">复制文件</h2>
<p>这里根据原始plink文件重新生成两套新的plink文件，其中芯片号使用数字代替。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开始流程</span></span><br><span class="line"></span><br><span class="line">plink_prefix1 = args.plink1</span><br><span class="line">plink_prefix2 = args.plink2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制 map</span></span><br><span class="line">os.system(<span class="string">f&quot;cp <span class="subst">&#123;plink_prefix1&#125;</span>.map <span class="subst">&#123;plink_prefix1&#125;</span>_temp.map&quot;</span>)</span><br><span class="line">os.system(<span class="string">f&quot;cp <span class="subst">&#123;plink_prefix2&#125;</span>.map <span class="subst">&#123;plink_prefix2&#125;</span>_temp.map&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新生成plink 文件</span></span><br><span class="line">ped1 = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix1&#125;</span>.ped&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">map1 = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix1&#125;</span>.map&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ped2 = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix2&#125;</span>.ped&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">map2 = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix2&#125;</span>.map&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">re_ped1 = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix1&#125;</span>_temp.ped&quot;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">re_ped2 = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix2&#125;</span>_temp.ped&quot;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">rename_chipid_file = <span class="built_in">open</span>(<span class="string">&#x27;rename_chipid_temp.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">common_snp_file = <span class="built_in">open</span>(<span class="string">f&#x27;<span class="subst">&#123;plink_prefix1&#125;</span>_<span class="subst">&#123;plink_prefix2&#125;</span>_common_snp_temp.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="提取共同位点">提取共同位点</h2>
<p>读入两个 map 文件，提取共同的 snp 名称。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">error_status = <span class="literal">False</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#提取共同位点</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">temp_id_set = <span class="built_in">set</span>()</span><br><span class="line">temp_line_set = <span class="built_in">set</span>()</span><br><span class="line">map1_dick = &#123;&#125;  <span class="comment"># SNP名称：染色体_物理位置</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> map1:</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">len</span>(f) == <span class="number">4</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;\t&#x27;</span>.join(f) <span class="keyword">not</span> <span class="keyword">in</span> temp_line_set:</span><br><span class="line">            temp_line_set.add(<span class="string">&#x27;\t&#x27;</span>.join(f))</span><br><span class="line">            <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> temp_id_set:</span><br><span class="line">                temp_id_set.add(f[<span class="number">1</span>])</span><br><span class="line">                map1_dick[f[<span class="number">1</span>]] = f[<span class="number">0</span>]+<span class="string">&quot;_&quot;</span>+f[<span class="number">3</span>] <span class="comment"># SNP名称：“染色体_物理位置”</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated id <span class="subst">&#123;f[<span class="number">1</span>]&#125;</span> in different rows in <span class="subst">&#123;plink_prefix1&#125;</span>.map\n&quot;</span>) </span><br><span class="line">                error_status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicted row <span class="subst">&#123;j&#125;</span> in <span class="subst">&#123;plink_prefix1&#125;</span>.map\n&quot;</span>)</span><br><span class="line">            error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;j&#125;</span> row in <span class="subst">&#123;plink_prefix1&#125;</span>.map has less or more than 4 coloums\n&quot;</span>)</span><br><span class="line">        error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">temp_id_set = <span class="built_in">set</span>()</span><br><span class="line">temp_line_set = <span class="built_in">set</span>()</span><br><span class="line">common_snp_num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> map2:</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">len</span>(f) == <span class="number">4</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;\t&#x27;</span>.join(f) <span class="keyword">not</span> <span class="keyword">in</span> temp_line_set:</span><br><span class="line">            temp_line_set.add(<span class="string">&#x27;\t&#x27;</span>.join(f))</span><br><span class="line">            <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> temp_id_set:</span><br><span class="line">                temp_id_set.add(f[<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">in</span> map1_dick:</span><br><span class="line">                    common_snp_num += <span class="number">1</span></span><br><span class="line">                    common_snp_file.write(f[<span class="number">1</span>]+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated id <span class="subst">&#123;f[<span class="number">1</span>]&#125;</span> in different rows in <span class="subst">&#123;plink_prefix2&#125;</span>.map\n&quot;</span>) </span><br><span class="line">                error_status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicted row <span class="subst">&#123;j&#125;</span> in <span class="subst">&#123;plink_prefix2&#125;</span>.map\n&quot;</span>)</span><br><span class="line">            error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;j&#125;</span> row in <span class="subst">&#123;plink_prefix2&#125;</span>.map has less or more than 4 coloums\n&quot;</span>)</span><br><span class="line">        error_status = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nNumber of common SNPs in two plink files: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(common_snp_num))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="ped文件芯片号重编码">ped文件芯片号重编码</h2>
<p>将ped文件中的芯片号改为重编码的数字，如果有映射文件，在此处读取映射文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建一个函数，得到芯片号-个体号的字典(chipid_sampleid_dick 提前创建)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Chipid_Sampleid</span>(<span class="params">chipid_file_name</span>):</span><br><span class="line">    chipid_file = <span class="built_in">open</span>(chipid_file_name,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="keyword">global</span> error_status</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    temp_id_set = <span class="built_in">set</span>()</span><br><span class="line">    temp_id_set2 = <span class="built_in">set</span>()</span><br><span class="line">    temp_line_set = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> chipid_file:</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        f = i.split()</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(f) &gt;= <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;\t&#x27;</span>.join(f) <span class="keyword">not</span> <span class="keyword">in</span> temp_line_set:</span><br><span class="line">                temp_line_set.add(<span class="string">&#x27;\t&#x27;</span>.join(f))</span><br><span class="line">                <span class="keyword">if</span> f[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> temp_id_set:</span><br><span class="line">                    temp_id_set.add(f[<span class="number">0</span>])</span><br><span class="line">                    <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> temp_id_set2:</span><br><span class="line">                        temp_id_set2.add(f[<span class="number">1</span>])</span><br><span class="line">                        chipid_sampleid_dick[f[<span class="number">0</span>]] = f[<span class="number">1</span>] <span class="comment">#芯片号：个体号</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated sample id <span class="subst">&#123;f[<span class="number">1</span>]&#125;</span> in different rows in <span class="subst">&#123;chipid_file_name&#125;</span>\n&quot;</span>) </span><br><span class="line">                        error_status = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;Error: duplicated chip id <span class="subst">&#123;f[<span class="number">0</span>]&#125;</span> in different rows in <span class="subst">&#123;chipid_file_name&#125;</span>\n&quot;</span>) </span><br><span class="line">                    error_status = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Warinning: duplicted row <span class="subst">&#123;j&#125;</span> in <span class="subst">&#123;chipid_file_name&#125;</span>\n&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;j&#125;</span> row in <span class="subst">&#123;chipid_file_name&#125;</span> has less than 2 coloums\n&quot;</span>)</span><br><span class="line">            error_status = <span class="literal">True</span></span><br><span class="line">    chipid_file.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">#重命名</span></span><br><span class="line">newid_dick = &#123;&#125; <span class="comment">#chipid/sampleid:newid</span></span><br><span class="line">sampleid_dick = &#123;&#125; <span class="comment">#newid:chipid/sampleid</span></span><br><span class="line"></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ped重编码为数字(1-indexed)，家系号设定为0。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看是否存在chipid1</span></span><br><span class="line"><span class="keyword">if</span> args.chipid1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    chipid_sampleid_dick = &#123;&#125;</span><br><span class="line">    Chipid_Sampleid(args.chipid1) <span class="comment">#运行函数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ped1:</span><br><span class="line">        f = i.split()</span><br><span class="line">        <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">in</span> chipid_sampleid_dick:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            newid_dick[chipid_sampleid_dick[f[<span class="number">1</span>]]] = j</span><br><span class="line">            sampleid_dick[j] = chipid_sampleid_dick[f[<span class="number">1</span>]]</span><br><span class="line">            rename_chipid_file.write(<span class="string">f&quot;<span class="subst">&#123;chipid_sampleid_dick[f[<span class="number">1</span>]]&#125;</span>\t<span class="subst">&#123;j&#125;</span>\n&quot;</span>)</span><br><span class="line">            f[<span class="number">1</span>] = <span class="built_in">str</span>(j)</span><br><span class="line">            re_ped1.write(<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>.join(f[<span class="number">1</span>:])+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Warning: <span class="subst">&#123;f[<span class="number">1</span>]&#125;</span> in <span class="subst">&#123;args.plink1&#125;</span>.ped not in chpid file&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ped1:</span><br><span class="line">        f = i.split()</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        newid_dick[f[<span class="number">1</span>]] = j</span><br><span class="line">        sampleid_dick[j] = f[<span class="number">1</span>]</span><br><span class="line">        rename_chipid_file.write(<span class="string">f&quot;<span class="subst">&#123;f[<span class="number">1</span>]&#125;</span>\t<span class="subst">&#123;j&#125;</span>\n&quot;</span>)            </span><br><span class="line">        f[<span class="number">1</span>] = <span class="built_in">str</span>(j)</span><br><span class="line">        re_ped1.write(<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>.join(f[<span class="number">1</span>:])+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">sample1_num = j</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of records present in plink1 ped file: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(sample1_num))</span><br><span class="line"></span><br><span class="line">common_sample_list = []</span><br><span class="line">common_sample_num = <span class="number">0</span></span><br><span class="line"><span class="comment">#查看是否存在chipid2</span></span><br><span class="line"><span class="keyword">if</span> args.chipid2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    chipid_sampleid_dick = &#123;&#125;</span><br><span class="line">    Chipid_Sampleid(args.chipid2) <span class="comment">#运行函数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ped2:</span><br><span class="line">        f = i.split()</span><br><span class="line">        <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">in</span> chipid_sampleid_dick:</span><br><span class="line">            j += <span class="number">1</span> <span class="comment">#接着上面递增</span></span><br><span class="line">            sampleid_dick[j] = chipid_sampleid_dick[f[<span class="number">1</span>]]</span><br><span class="line">            <span class="keyword">if</span> chipid_sampleid_dick[f[<span class="number">1</span>]] <span class="keyword">in</span> newid_dick: <span class="comment">#提取相同样本</span></span><br><span class="line">                common_sample_num += <span class="number">1</span></span><br><span class="line">                common_sample_list.append([newid_dick[chipid_sampleid_dick[f[<span class="number">1</span>]]],j]) <span class="comment">#两个重编号  </span></span><br><span class="line">            rename_chipid_file.write(<span class="string">f&quot;<span class="subst">&#123;chipid_sampleid_dick[f[<span class="number">1</span>]]&#125;</span>\t<span class="subst">&#123;j&#125;</span>\n&quot;</span>)</span><br><span class="line">            f[<span class="number">1</span>] = <span class="built_in">str</span>(j)</span><br><span class="line">            re_ped2.write(<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>.join(f[<span class="number">1</span>:])+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Warning: <span class="subst">&#123;f[<span class="number">1</span>]&#125;</span> in <span class="subst">&#123;args.plink2&#125;</span>.ped not in chpid file&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ped2:</span><br><span class="line">        f = i.split()</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        sampleid_dick[j] = f[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">in</span> newid_dick:</span><br><span class="line">                common_sample_num += <span class="number">1</span></span><br><span class="line">                common_sample_list.append([newid_dick[f[<span class="number">1</span>]],j]) <span class="comment">#两个重编号  </span></span><br><span class="line">        rename_chipid_file.write(<span class="string">f&quot;<span class="subst">&#123;f[<span class="number">1</span>]&#125;</span>\t<span class="subst">&#123;j&#125;</span>\n&quot;</span>)            </span><br><span class="line">        f[<span class="number">1</span>] = <span class="built_in">str</span>(j)</span><br><span class="line">        re_ped2.write(<span class="string">&#x27;0&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>.join(f[<span class="number">1</span>:])+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">sample2_num = j - sample1_num</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of records present in plink2 ped file: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(sample2_num))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of common samples in two plink file: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(common_sample_num))</span><br><span class="line">    </span><br><span class="line">ped1.close()</span><br><span class="line">map1.close()</span><br><span class="line">ped2.close()</span><br><span class="line">map2.close()</span><br><span class="line">re_ped1.close()</span><br><span class="line">re_ped2.close()</span><br><span class="line">rename_chipid_file.close()</span><br><span class="line">common_snp_file.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果上面出现错误，报错，中止程序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果输入文件出现错误</span></span><br><span class="line"><span class="keyword">if</span> error_status:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Please check your file again!&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="提取共同位点，合并基因型">提取共同位点，合并基因型</h2>
<p>提取两个plink文件的共同位点，合并基因型，生成 012 编码的 raw 文件。如果合并的过程中出现报错，程序中止，一般这种报错都是由于非二等位基因造成的，即两个plink文件中某个位点的两个碱基不一样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#extract merge recodeA</span></span><br><span class="line"></span><br><span class="line">merge_status = os.system(<span class="string">f&quot;plink --allow-extra-chr --chr-set 95 --file <span class="subst">&#123;plink_prefix1&#125;</span>_temp --merge <span class="subst">&#123;plink_prefix2&#125;</span>_temp --extract <span class="subst">&#123;plink_prefix1&#125;</span>_<span class="subst">&#123;plink_prefix2&#125;</span>_common_snp_temp.txt --recodeA --out <span class="subst">&#123;plink_prefix1&#125;</span>_<span class="subst">&#123;plink_prefix2&#125;</span>_merge_temp &gt; /dev/null&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> merge_status != <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error in merge two plink data\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Maybe some common SNP from Complementary strands,check your data again&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将缺失位点替换为3，将合并基因型读取为二维数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#raw文件处理</span></span><br><span class="line">os.system(<span class="string">f&quot;sed &#x27;s/NA/3/g&#x27; <span class="subst">&#123;plink_prefix1&#125;</span>_<span class="subst">&#123;plink_prefix2&#125;</span>_merge_temp.raw &gt; <span class="subst">&#123;plink_prefix1&#125;</span>_<span class="subst">&#123;plink_prefix2&#125;</span>_merge_temp_sed.raw&quot;</span>)</span><br><span class="line">raw_file = <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;plink_prefix1&#125;</span>_<span class="subst">&#123;plink_prefix2&#125;</span>_merge_temp_sed.raw&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">out_file = <span class="built_in">open</span>(args.out,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gene_list=[]</span><br><span class="line">raw_list=[]</span><br><span class="line">title = raw_file.readline() <span class="comment">#剔除标题</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> raw_file:</span><br><span class="line">    f = i.split()</span><br><span class="line">    gene_list.append(<span class="built_in">int</span>(f[<span class="number">1</span>]))</span><br><span class="line">    raw_list.append(f[<span class="number">6</span>:])</span><br><span class="line"></span><br><span class="line">gene_id_array1 = np.array(gene_list)</span><br><span class="line"></span><br><span class="line">array1 = np.array(raw_list, dtype=np.int8)</span><br><span class="line"></span><br><span class="line">total_sample_num = array1.shape[<span class="number">0</span>]</span><br><span class="line">snp_num = array1.shape[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of records present in merged ped file: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(total_sample_num))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of SNPs in merged plink files: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(snp_num))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="比对两个样本的基因型">比对两个样本的基因型</h2>
<p>创建了两个比对函数（是否剔除缺失值）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建比对函数（是否剔除缺失值）</span></span><br><span class="line"><span class="comment">#这个函数定死了使用 array1 first_index second index</span></span><br><span class="line"><span class="comment">#创建两个函数，这样只要判断一次，而不要每个pair都要判断是否剔除缺失值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Exclude_Miss_Yes</span>():</span><br><span class="line">    <span class="comment">#输出变量设置为全局变量</span></span><br><span class="line">    <span class="keyword">global</span> total_num,no_match_num,no_match_rate</span><br><span class="line">    v1 = array1[first_index,:]</span><br><span class="line">    v2 = array1[second_index,:]</span><br><span class="line">    non_miss_index = np.where((v1!=<span class="number">3</span>) &amp; (v2!=<span class="number">3</span>))</span><br><span class="line">    total_num = non_miss_index[<span class="number">0</span>].shape[<span class="number">0</span>]</span><br><span class="line">    v1_new = v1[non_miss_index]</span><br><span class="line">    v2_new = v2[non_miss_index]</span><br><span class="line">    no_match_num = np.count_nonzero(v1_new!=v2_new)</span><br><span class="line">    no_match_rate = no_match_num/total_num</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Exclude_Miss_No</span>():</span><br><span class="line">    <span class="comment">#输出变量设置为全局变量</span></span><br><span class="line">    <span class="keyword">global</span> total_num,no_match_num,no_match_rate</span><br><span class="line">    v1 = array1[first_index,:]</span><br><span class="line">    v2 = array1[second_index,:]</span><br><span class="line">    total_num = v1.shape[<span class="number">0</span>]</span><br><span class="line">    no_match_num = np.count_nonzero(v1!=v2)</span><br><span class="line">    no_match_rate = no_match_num/total_num</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>计算两个样本的不一致，分两种情况，比较所有配对和只比较同名样本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#计算不一致率</span></span><br><span class="line">out_list = []</span><br><span class="line"><span class="keyword">if</span> args.cmp_all == <span class="string">&#x27;yes&#x27;</span>: <span class="comment">#计算所有pairs</span></span><br><span class="line">    <span class="keyword">if</span> args.exclude_miss == <span class="string">&#x27;yes&#x27;</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(sample1_num):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(sample1_num, total_sample_num):</span><br><span class="line">                first_index = i</span><br><span class="line">                second_index = j</span><br><span class="line">                <span class="comment">#计算去除缺失后的不一致位点数</span></span><br><span class="line">                Exclude_Miss_Yes()</span><br><span class="line">                <span class="comment">#newid = index + 1</span></span><br><span class="line">                out_list.append([sampleid_dick[first_index+<span class="number">1</span>],sampleid_dick[second_index+<span class="number">1</span>],<span class="string">f&quot;<span class="subst">&#123;no_match_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;total_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;no_match_rate:<span class="number">.4</span>f&#125;</span>&quot;</span>])</span><br><span class="line">    <span class="keyword">elif</span> args.exclude_miss == <span class="string">&#x27;no&#x27;</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(sample1_num):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(sample1_num, total_sample_num):</span><br><span class="line">                first_index = i</span><br><span class="line">                second_index = j</span><br><span class="line">                <span class="comment">#计算去除缺失后的不一致位点数</span></span><br><span class="line">                Exclude_Miss_No()</span><br><span class="line">                <span class="comment">#newid = index + 1</span></span><br><span class="line">                out_list.append([sampleid_dick[first_index+<span class="number">1</span>],sampleid_dick[second_index+<span class="number">1</span>],<span class="string">f&quot;<span class="subst">&#123;no_match_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;total_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;no_match_rate:<span class="number">.4</span>f&#125;</span>&quot;</span>])                             </span><br><span class="line"><span class="keyword">elif</span> args.cmp_all == <span class="string">&#x27;no&#x27;</span>: <span class="comment">#只计算个体号相同的pairs</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(common_sample_list) == <span class="number">0</span>: <span class="comment">#如果没有共同个体，报错</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error: two ped file has no same samples, check your data again!&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> args.exclude_miss == <span class="string">&#x27;yes&#x27;</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> common_sample_list:</span><br><span class="line">                <span class="comment">#index = newid - 1</span></span><br><span class="line">                first_index = i[<span class="number">0</span>] - <span class="number">1</span></span><br><span class="line">                second_index = i[<span class="number">1</span>] -<span class="number">1</span> </span><br><span class="line">                <span class="comment">#计算去除缺失后的不一致位点数</span></span><br><span class="line">                Exclude_Miss_Yes()</span><br><span class="line">                out_list.append([sampleid_dick[i[<span class="number">0</span>]],sampleid_dick[i[<span class="number">1</span>]],<span class="string">f&quot;<span class="subst">&#123;no_match_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;total_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;no_match_rate:<span class="number">.4</span>f&#125;</span>&quot;</span>])</span><br><span class="line">        <span class="keyword">elif</span> args.exclude_miss == <span class="string">&#x27;no&#x27;</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> common_sample_list:</span><br><span class="line">                <span class="comment">#index = newid - 1</span></span><br><span class="line">                first_index = i[<span class="number">0</span>] - <span class="number">1</span></span><br><span class="line">                second_index = i[<span class="number">1</span>] -<span class="number">1</span> </span><br><span class="line">                <span class="comment">#计算去除缺失后的不一致位点数</span></span><br><span class="line">                Exclude_Miss_No()</span><br><span class="line">                out_list.append([sampleid_dick[i[<span class="number">0</span>]],sampleid_dick[i[<span class="number">1</span>]],<span class="string">f&quot;<span class="subst">&#123;no_match_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;total_num&#125;</span>&quot;</span>,<span class="string">f&quot;<span class="subst">&#123;no_match_rate:<span class="number">.4</span>f&#125;</span>&quot;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sorted_out_list = <span class="built_in">sorted</span>(out_list, key = <span class="keyword">lambda</span> s:(<span class="built_in">float</span>(s[<span class="number">4</span>]),s[<span class="number">0</span>])) <span class="comment">#不一致率从小到大</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sorted_out_list:</span><br><span class="line">    out_file.write(<span class="string">&#x27;\t&#x27;</span>.join(i)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">raw_file.close()</span><br><span class="line">out_file.close()</span><br></pre></td></tr></table></figure>
<h2 id="删除中间文件">删除中间文件</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> args.save_temp == <span class="string">&quot;yes&quot;</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">elif</span> args.save_temp == <span class="string">&quot;no&quot;</span>:</span><br><span class="line">    os.system(<span class="string">f&quot;rm *temp*&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>生物信息</tag>
      </tags>
  </entry>
  <entry>
    <title>基于芯片数据的亲子鉴定分析代码</title>
    <url>/posts/42752926/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本软件通过利用SNP信息根据孟德尔错误位点比例，对于系谱中均具有基因型的亲子对进行亲子鉴定，判断系谱是否正确。这里的孟德尔错误位点指个体和亲本之间具有相反的纯和子的位点（例如个体的基因型为AA，亲本的基因型为GG），依据孟德尔定律亲子间不应存在这种情况，但由于突变和分型错误等原因，真实的亲子对之间仍存在少量的孟德尔错误位点。当使用的位点数目较多时，通过设定一个合理的阈值可以明确判定系谱中正确的亲子关系和错误的亲子关系。</p>
<span id="more"></span>
<h1>使用软件</h1>
<h1>软件</h1>
<p>python 3.0 以上版本，事先安装 numpy 模块</p>
<h1>输入文件格式</h1>
<ul>
<li>
<p>raw 文件：通过 plink 软件对<strong>原始芯片数据</strong>（未填充）采用 <code>--recodeA</code> 选项生成的文件，后缀为 <code>.raw</code></p>
</li>
<li>
<p>映射文件： 两列，所有基因型个体的芯片号与个体号，空格或 tab分隔，无标题。</p>
</li>
<li>
<p>系谱文件：三列，个体号-父号-母号，空格或 tab分隔，无标题。</p>
</li>
</ul>
<h1>输出文件说明</h1>
<ul>
<li><code>check_pedigree.csv</code>: 五列，个体 - 原系谱中的父本 - 原系谱中的母本 -  父本判定信息 - 母本判定信息（ 三种判定信息，par_nogeno : 亲本没有基因型信息，Match : 亲本符合阈值要求， No-Match : 亲本不符合阈值要求 ）</li>
<li><code>check_paternity_prob.csv</code>: 七列，亲子对类型 - 个体 - 亲本 - 错误位点数 -  匹配的位点总数（剔除缺失位点）- 错误位点概率 - 判定信息</li>
</ul>
<h1>运行代码</h1>
<p>代码文件见：<a href="https://github.com/VincereZhou/code_backup/blob/master/paternity_check_1.0.py">paternity_check_1.0.py</a></p>
<p>将输入文件和本程序放在同一文件夹下，运行命令示范为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python paternity_check_1.0.py --raw test.raw --chipid test_id.txt --pedigree pedigree.txt --check-prob 0.005</span><br></pre></td></tr></table></figure>
<p><strong>可用参数说明：</strong></p>
<p><code>--raw</code> : 基因型文件名，必选。</p>
<p><code>--chipid</code> : 基因型个体映射文件名，必选。</p>
<p><code>--pedigree</code> : 系谱文件名，必选</p>
<p><code>--list</code> : 需要进行亲子鉴定的个体文件名，可选。如果提供该参数，则只对这个文件中的个体进行亲子鉴定；如果不提供该参数，则默认对所有基因型个体进行亲子鉴定。</p>
<p>-<code>-check-prob</code> : 亲子鉴定孟德尔错误率的阈值，可选，默认为0.005</p>
<p>-<code>-miss-snp</code> : SNP位点的基因分型缺失率阈值，可选，默认为0.2</p>
<p>-<code>-maf</code> : SNP 位点的最小等位基因频率阈值，可选，默认为0.01</p>
<p>-<code>-miss-sample</code> : 样本的基因分型缺失率阈值，可选，默认为0.5</p>
<h1>代码说明</h1>
<h2 id="读取文件">读取文件</h2>
<p>这里首先打印了一下 raw 文件中的样本数目，实质采用 linux 命令 <code>wc -l</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打印raw文件行数</span></span><br><span class="line">raw_lines = os.popen(<span class="string">&quot;wc -l &#123;&#125;&quot;</span>.<span class="built_in">format</span>(args.raw)).read().split()[<span class="number">0</span>]</span><br><span class="line">true_raw_lines = <span class="built_in">int</span>(raw_lines) -<span class="number">1</span> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of records in raw file: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(true_raw_lines))</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取文件</span></span><br><span class="line">raw_file = <span class="built_in">open</span>(args.raw,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">chipid_file = <span class="built_in">open</span>(args.chipid,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">pedigree_file = <span class="built_in">open</span>(args.pedigree,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#new_raw = open(&quot;newid.raw&quot;,&#x27;w+&#x27;)</span></span><br><span class="line"></span><br><span class="line">check_prob = <span class="built_in">open</span>(<span class="string">&quot;chek_paternity_prob.txt&quot;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">check_pedigree = <span class="built_in">open</span>(<span class="string">&quot;check_pedigree.txt&quot;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="映射与raw文件处理">映射与raw文件处理</h2>
<p>这里先对映射文件进行处理，过滤条件有两个：</p>
<ol>
<li>每一行的列数必须大于等于2</li>
<li>重复个体号会保留第一个</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set1=<span class="built_in">set</span>();dick=&#123;&#125;</span><br><span class="line">j=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> chipid_file:</span><br><span class="line">    f = i.split()</span><br><span class="line">    j+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(f) &gt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> set1: <span class="comment">#去除重复个体号</span></span><br><span class="line">            set1.add(f[<span class="number">1</span>])</span><br><span class="line">            dick[f[<span class="number">0</span>]] = f[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Warning: &#123;&#125; row in chipid file has less than 2 coloum\n&quot;</span>.<span class="built_in">format</span>(j))</span><br></pre></td></tr></table></figure>
<p>再对 raw 文件进行处理，提取在映射文件中的个体的基因型，生成基因型的二维数组（array1）。这里将缺失值NA替换为3。<code>gene_id_array</code> 是相应的个体号一维数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gene_list=[]</span><br><span class="line">raw_list=[]</span><br><span class="line">raw_file.readline() <span class="comment">#剔除标题</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> raw_file:</span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">in</span> dick:</span><br><span class="line">        gene_list.append(dick[f[<span class="number">1</span>]])</span><br><span class="line">        raw_list.append(<span class="string">&#x27;\t&#x27;</span>.join(f[<span class="number">6</span>:]))</span><br><span class="line">        <span class="comment">#new_raw.write(&#x27;\t&#x27;.join(f[6:])+&#x27;\n&#x27;)</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Warning: &#123;&#125; in raw file not in chpid file or is duplicated samples\n&quot;</span>.<span class="built_in">format</span>(f[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">gene_id_array = np.array(gene_list)</span><br><span class="line"></span><br><span class="line"><span class="comment">#new_raw.seek(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># snp 缺失值过滤，结果文件是 array2</span></span><br><span class="line"><span class="comment">#numpy 0/1 结果会显示为 nan</span></span><br><span class="line">array1 = np.genfromtxt(raw_list, dtype=np.int8, missing_values=<span class="string">&quot;NA&quot;</span>, filling_values=<span class="number">3</span>)</span><br><span class="line"><span class="comment">#array2 = array1.copy()</span></span><br><span class="line"></span><br><span class="line">sample_num = array1.shape[<span class="number">0</span>]</span><br><span class="line">snp_num = array1.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of SNPs in raw file: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(snp_num))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of records present in chipid file: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(sample_num))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="位点和样本质控">位点和样本质控</h2>
<h3 id="位点缺失率">位点缺失率</h3>
<p>这里统计每一列（SNP）中等于3（表示缺失）的比例，剔除缺失率高于阈值的SNP。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bool_array1 = array1==<span class="number">3</span></span><br><span class="line"></span><br><span class="line">total_miss = bool_array1.<span class="built_in">sum</span>()/(bool_array1.shape[<span class="number">0</span>] * bool_array1.shape[<span class="number">1</span>])</span><br><span class="line">toatl_callrate = <span class="number">1</span> - total_miss</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Total genotyping rate is &#123;:.3f&#125;\n&quot;</span>.<span class="built_in">format</span>(toatl_callrate))</span><br><span class="line"></span><br><span class="line">snp_missing_count = bool_array1.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">snp_missing_prob = snp_missing_count/sample_num</span><br><span class="line"></span><br><span class="line">snp_missing_min = snp_missing_prob.<span class="built_in">min</span>()</span><br><span class="line">snp_missing_mean = snp_missing_prob.mean()</span><br><span class="line">snp_missing_max = snp_missing_prob.<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印snp缺失值情况</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;SNP missing\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;  Min missing rate: &#123;:.3f&#125;\n&quot;</span>.<span class="built_in">format</span>(snp_missing_min))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;  AVG missing rate: &#123;:.3f&#125;\n&quot;</span>.<span class="built_in">format</span>(snp_missing_mean))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;  Max missing rate: &#123;:.3f&#125;\n&quot;</span>.<span class="built_in">format</span>(snp_missing_max))</span><br><span class="line"><span class="comment">#np.savetxt(&quot;snp_missing.txt&quot;,snp_missing_prob, fmt=&#x27;%.4f&#x27;)</span></span><br><span class="line"></span><br><span class="line">snp_missing_pick = snp_missing_prob &lt; <span class="built_in">float</span>(args.miss_snp)</span><br><span class="line">array2 = array1[:,snp_missing_pick]</span><br><span class="line">snp_miss_remove = array1.shape[<span class="number">1</span>] - array2.shape[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; snps removed due to missing genotype data\n&quot;</span>.<span class="built_in">format</span>(snp_miss_remove))</span><br><span class="line"><span class="keyword">del</span> array1</span><br><span class="line"><span class="keyword">del</span> bool_array1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="MAF-过滤">MAF 过滤</h3>
<p>统计每个SNP的最小等位基因频率（MAF），剔除低于阈值的位点。</p>
<p>这里的做法是先将缺失值替换为0，统计每一列的和作为分子，分母为该列非缺失样本数的两倍。这么做的原理是 plink 软件 在生成 raw 文件时是按照最小等位基因计数的（raw 文件中的 0 1 2 表示最小等位基因的数目），因此将缺失值替换为0，再求每列的和，便得到最小等位基因的总数，除以所有等位基因总数，便得到了最小等位基因频率。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># maf 过滤,结果文件是 array3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#计算array2每列的缺失值</span></span><br><span class="line">bool_array2 = array2==<span class="number">3</span></span><br><span class="line">snp_missing_count2 = bool_array2.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将array2 中的3替换为0，提取备份为 array2_copy</span></span><br><span class="line">array2_copy = array2.copy()</span><br><span class="line">array2[array2==<span class="number">3</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">maf_sum = array2.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment">#print(&quot;maf_sum[1:5] are &#123;&#125;&quot;.format(maf_sum[1:5]))</span></span><br><span class="line">maf_denominator = <span class="number">2</span>*(sample_num-snp_missing_count2)</span><br><span class="line"><span class="comment">#print(&quot;sample_num are &#123;&#125;&quot;.format(sample_num))</span></span><br><span class="line"><span class="comment">#print(&quot;maf_denominator[1:5] are &#123;&#125;&quot;.format(maf_denominator[1:5]))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">maf_prob = maf_sum/maf_denominator</span><br><span class="line"><span class="comment">#print(&quot;maf_prob[1:5] are &#123;&#125;&quot;.format(maf_prob[1:5]))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#maf_out = np.column_stack((maf_sum,maf_denominator,maf_prob))</span></span><br><span class="line"><span class="comment">#np.savetxt(&quot;maf_all.txt&quot;,maf_out)</span></span><br><span class="line"><span class="comment">#np.savetxt(&quot;maf.txt&quot;,maf_prob, fmt=&#x27;%.4f&#x27;)</span></span><br><span class="line"></span><br><span class="line">maf_min = maf_prob.<span class="built_in">min</span>()</span><br><span class="line">maf_mean = maf_prob.mean()</span><br><span class="line">maf_max = maf_prob.<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印MAF情况</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Minor alleles frequencies\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;  Min alleles frequencies: &#123;:.3f&#125;\n&quot;</span>.<span class="built_in">format</span>(maf_min))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;  AVG alleles frequencies: &#123;:.3f&#125;\n&quot;</span>.<span class="built_in">format</span>(maf_mean))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;  Max alleles frequencies: &#123;:.3f&#125;\n&quot;</span>.<span class="built_in">format</span>(maf_max))</span><br><span class="line"></span><br><span class="line">snp_maf_pick = maf_prob &gt; <span class="built_in">float</span>(args.maf)</span><br><span class="line">array3 = array2_copy[:,snp_maf_pick]</span><br><span class="line"></span><br><span class="line">snp_maf_remove = array2_copy.shape[<span class="number">1</span>] - array3.shape[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; snps removed due to minor allele threshold\n&quot;</span>.<span class="built_in">format</span>(snp_maf_remove))</span><br><span class="line"><span class="keyword">del</span> array2</span><br><span class="line"><span class="keyword">del</span> array2_copy</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="样本缺失率过滤">样本缺失率过滤</h3>
<p>先过滤SNP，再过滤样本，这和 plink 软件的逻辑一致，也符合实际需求。毕竟每个样本都是花了钱的，能不剔除就不剔除。</p>
<p>原理同SNP过滤，只不过列换成了行（每一列表示一个SNP，每一行表示一个样本）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sample_miss 过滤，结果为 array4</span></span><br><span class="line"></span><br><span class="line">sample_num3 = array3.shape[<span class="number">0</span>]</span><br><span class="line">snp_num3 = array3.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">bool_array3 = array3==<span class="number">3</span></span><br><span class="line"></span><br><span class="line">sample_missing_count = bool_array3.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">sample_missing_prob = sample_missing_count/snp_num3</span><br><span class="line"></span><br><span class="line">sample_missing_min = sample_missing_prob.<span class="built_in">min</span>()</span><br><span class="line">sample_missing_mean = sample_missing_prob.mean()</span><br><span class="line">sample_missing_max = sample_missing_prob.<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印sample缺失值情况</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sample missing\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;  Min missing rate: &#123;:.3f&#125;\n&quot;</span>.<span class="built_in">format</span>(sample_missing_min))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;  AVG missing rate: &#123;:.3f&#125;\n&quot;</span>.<span class="built_in">format</span>(sample_missing_mean))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;  Max missing rate: &#123;:.3f&#125;\n&quot;</span>.<span class="built_in">format</span>(sample_missing_max))</span><br><span class="line"></span><br><span class="line"><span class="comment">#np.savetxt(&quot;sample_missing.txt&quot;,sample_missing_prob, fmt=&#x27;%.4f&#x27;)</span></span><br><span class="line"></span><br><span class="line">sample_missing_pick = sample_missing_prob &lt; <span class="built_in">float</span>(args.miss_sample)</span><br><span class="line">array4 = array3[sample_missing_pick,:]</span><br><span class="line"></span><br><span class="line">gene_id_array_new = gene_id_array[sample_missing_pick] <span class="comment">#样本过滤后的基因个体号</span></span><br><span class="line"></span><br><span class="line">sample_miss_remove = array3.shape[<span class="number">0</span>] - array4.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; samples removed due to missing genotype data\n&quot;</span>.<span class="built_in">format</span>(sample_miss_remove))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; samples and &#123;&#125; snps pass QC finally\n&quot;</span>.<span class="built_in">format</span>(array4.shape[<span class="number">0</span>],array4.shape[<span class="number">1</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果剔除了样本，将样本和缺失率写入一个文件中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如果删除了样本，将删除的样本id和缺失率写入一个新文件</span></span><br><span class="line"><span class="keyword">if</span> sample_miss_remove &gt; <span class="number">0</span> :</span><br><span class="line">    filter_sample_file = <span class="built_in">open</span>(<span class="string">&#x27;sample_filted.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    sample_missing_fail = sample_missing_prob &gt;= <span class="built_in">float</span>(args.miss_sample)</span><br><span class="line">    gene_id_fail_array = gene_id_array[sample_missing_fail]</span><br><span class="line">    sample_missing_prob_array = sample_missing_prob[sample_missing_fail]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gene_id_fail_array.shape[<span class="number">0</span>]):</span><br><span class="line">        filter_sample_file.write(<span class="built_in">str</span>(gene_id_fail_array[i])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(<span class="string">&quot;&#123;:.4f&#125;&quot;</span>.<span class="built_in">format</span>(sample_missing_prob_array[i]))+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    filter_sample_file.close()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">del</span> array3</span><br><span class="line"><span class="keyword">del</span> bool_array3</span><br></pre></td></tr></table></figure>
<h2 id="亲子鉴定">亲子鉴定</h2>
<p>首先将基因型数组改为 1 2 3 0 ，对应之前的 0 1 2 3 。改完以后，0 就表示缺失，1 2 3 表示三种基因型。这样改方便之处在于：</p>
<ol>
<li>缺失值是0，0乘任何数还是0。</li>
<li>1,2,3 都是<strong>质数</strong>，这三个数之间任选两个数进行相乘得到的积是唯一的，比如如果乘积为2，那么只能是1和2相乘，3只能是1和3相乘……</li>
</ol>
<p>因此，这样我们在比对两个样本的基因型时，只需要将两个个体的基因型进行<strong>相乘</strong>，如果某个位点乘积为0，表示存在缺失（至少一个个体的基因型为缺失），无法比较；如果某个位点乘积为 3，表示在这个位点上存在孟德尔错误（两个个体为相反纯合子）。这样，我们统计两个个体的缺失位点和孟德尔错误位点非常方便。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#开始进行亲子鉴定</span><br><span class="line">#array4 改为 1 2 3 0(缺失)</span><br><span class="line">#这样两个array 的乘积的array为3的是错误位点，是0的是缺失位点。</span><br><span class="line"></span><br><span class="line">array4 += 1</span><br><span class="line">array4[array4==4] = 0</span><br><span class="line"></span><br><span class="line">snp_num4 = array4.shape[1]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="清洗系谱">清洗系谱</h3>
<p>这里剔除了第一列个体没有基因型的行，因为个体没有基因型就不可能进行亲子鉴定 （如果提过了 --list 选项，那么只会提取需要亲子鉴定的个体的系谱）。</p>
<p>这里得到个体和亲本均有基因型的亲子对列表：<code>offspring_sire_list</code>  和  <code>offspring_dam_list</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#清洗系谱，剔除第一列个体没有基因型的行</span></span><br><span class="line"></span><br><span class="line">offspring_sire_list = []</span><br><span class="line">offspring_dam_list = []</span><br><span class="line">pedigree_list = []</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断 args.list 是否存在</span></span><br><span class="line">id_set = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">if</span> args.<span class="built_in">list</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> pedigree_file:</span><br><span class="line">        f = i.split()</span><br><span class="line">        id_set.add(f[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    list_file = <span class="built_in">open</span>(args.<span class="built_in">list</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> list_file:</span><br><span class="line">        f = i.split()</span><br><span class="line">        id_set.add(f[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">test_records=<span class="number">0</span></span><br><span class="line">sire_pairs=<span class="number">0</span></span><br><span class="line">dam_pairs=<span class="number">0</span></span><br><span class="line">pedigree_file.seek(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> pedigree_file:</span><br><span class="line">    f = i.split()</span><br><span class="line">    <span class="keyword">if</span> (f[<span class="number">0</span>] <span class="keyword">in</span> gene_id_array_new) <span class="keyword">and</span> (f[<span class="number">0</span>] <span class="keyword">in</span> id_set):</span><br><span class="line">        pedigree_list.append(f[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line">        test_records+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> f[<span class="number">1</span>] <span class="keyword">in</span> gene_id_array_new:</span><br><span class="line">            sire_pairs+=<span class="number">1</span></span><br><span class="line">            offspring_sire_list.append([f[<span class="number">0</span>],f[<span class="number">1</span>]])</span><br><span class="line">        <span class="keyword">if</span> f[<span class="number">2</span>] <span class="keyword">in</span> gene_id_array_new:</span><br><span class="line">            dam_pairs+=<span class="number">1</span></span><br><span class="line">            offspring_dam_list.append([f[<span class="number">0</span>],f[<span class="number">2</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="亲子鉴定-2">亲子鉴定</h3>
<p>这里的思路很简单，就是上面提到了，计算两个个体基因型的乘积，统计乘积等于3的位点数目，除以位点总数（剔除缺失个体后），便得到了孟德尔错误率，再与给定的阈值进行比对。如果小于阈值，则认为是正确的亲子对，反之则认为错误。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">check_dick = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#np.savetxt(&quot;gene_id_array_new.txt&quot;,gene_id_array_new, fmt=&quot;%s&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#np.where 结果是一个元组，元组里是一个索引构成的数组，如(array([1, 2]),)</span></span><br><span class="line">conflict_sire_pairs=<span class="number">0</span></span><br><span class="line">conflict_dam_pairs=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> offspring_sire_list:</span><br><span class="line">    first_index = np.where(gene_id_array_new == i[<span class="number">0</span>])</span><br><span class="line">    second_index = np.where(gene_id_array_new == i[<span class="number">1</span>])</span><br><span class="line">    first_array = array4[first_index]</span><br><span class="line">    second_array = array4[second_index]</span><br><span class="line">    product_array = first_array * second_array</span><br><span class="line">    error_snp_nums = (product_array==<span class="number">3</span>).<span class="built_in">sum</span>()</span><br><span class="line">    miss_snp_nums =  (product_array==<span class="number">0</span>).<span class="built_in">sum</span>()</span><br><span class="line">    total_snp_nums = snp_num4 - miss_snp_nums</span><br><span class="line">    error_snp_prob = error_snp_nums/total_snp_nums</span><br><span class="line">    <span class="keyword">if</span> error_snp_prob &lt; <span class="built_in">float</span>(args.check_prob):</span><br><span class="line">        match_status = <span class="string">&quot;Match&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        match_status = <span class="string">&quot;No-Match&quot;</span></span><br><span class="line">        conflict_sire_pairs+=<span class="number">1</span></span><br><span class="line">    check_dick[<span class="built_in">tuple</span>(i)] = match_status</span><br><span class="line">    check_prob.write(<span class="string">&#x27;Offspring-Sire&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+i[<span class="number">0</span>]+<span class="string">&#x27;\t&#x27;</span>+i[<span class="number">1</span>]+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(error_snp_nums)+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(total_snp_nums)+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(error_snp_prob)+<span class="string">&#x27;\t&#x27;</span>+match_status+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> offspring_dam_list:</span><br><span class="line">    first_index = np.where(gene_id_array_new == i[<span class="number">0</span>])</span><br><span class="line">    second_index = np.where(gene_id_array_new == i[<span class="number">1</span>])</span><br><span class="line">    first_array = array4[first_index]</span><br><span class="line">    second_array = array4[second_index]</span><br><span class="line">    product_array = first_array * second_array</span><br><span class="line">    error_snp_nums = (product_array==<span class="number">3</span>).<span class="built_in">sum</span>()</span><br><span class="line">    miss_snp_nums =  (product_array==<span class="number">0</span>).<span class="built_in">sum</span>()</span><br><span class="line">    total_snp_nums = snp_num4 - miss_snp_nums</span><br><span class="line">    error_snp_prob = error_snp_nums/total_snp_nums</span><br><span class="line">    <span class="keyword">if</span> error_snp_prob &lt; <span class="built_in">float</span>(args.check_prob):</span><br><span class="line">        match_status = <span class="string">&quot;Match&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        match_status = <span class="string">&quot;No-Match&quot;</span></span><br><span class="line">        conflict_dam_pairs+=<span class="number">1</span></span><br><span class="line">    check_dick[<span class="built_in">tuple</span>(i)] = match_status</span><br><span class="line">    check_prob.write(<span class="string">&#x27;Offspring-Dam&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+i[<span class="number">0</span>]+<span class="string">&#x27;\t&#x27;</span>+i[<span class="number">1</span>]+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(error_snp_nums)+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(total_snp_nums)+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(<span class="string">&quot;&#123;:.4f&#125;&quot;</span>.<span class="built_in">format</span>(error_snp_prob))+<span class="string">&#x27;\t&#x27;</span>+match_status+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> pedigree_list:</span><br><span class="line">    offspring_sire = (i[<span class="number">0</span>],i[<span class="number">1</span>])</span><br><span class="line">    offspring_dam = (i[<span class="number">0</span>],i[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">if</span> offspring_sire <span class="keyword">in</span> check_dick:</span><br><span class="line">        sire_info = check_dick[offspring_sire]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sire_info = <span class="string">&quot;par_nogeno&quot;</span></span><br><span class="line">    <span class="keyword">if</span> offspring_dam <span class="keyword">in</span> check_dick:</span><br><span class="line">        dam_info = check_dick[offspring_dam]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dam_info = <span class="string">&quot;par_nogeno&quot;</span></span><br><span class="line">    check_pedigree.write(<span class="string">&#x27;\t&#x27;</span>.join(i)+<span class="string">&#x27;\t&#x27;</span>+sire_info+<span class="string">&#x27;\t&#x27;</span>+dam_info+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">raw_file.close()</span><br><span class="line">chipid_file.close()</span><br><span class="line">pedigree_file.close()</span><br><span class="line"><span class="comment">#new_raw.close()</span></span><br><span class="line">check_prob.close()</span><br><span class="line">check_pedigree.close()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Records tested: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(test_records))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;  Pair parent/progeny tested: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(sire_pairs+dam_pairs))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;  Pair with conflicts: &#123;&#125;\n\n&quot;</span>.<span class="built_in">format</span>(conflict_sire_pairs+conflict_dam_pairs))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sire-progeny tested: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(sire_pairs))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sire-progeny with conflicts: &#123;&#125;\n\n&quot;</span>.<span class="built_in">format</span>(conflict_sire_pairs))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Dam-progeny tested: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(dam_pairs))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Dam-progeny with conflicts: &#123;&#125;\n\n&quot;</span>.<span class="built_in">format</span>(conflict_dam_pairs))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;End paternity check\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">end_time = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nFinish time: &#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(end_time)) </span><br></pre></td></tr></table></figure>
<h1>不足</h1>
<ol>
<li>
<p>质控过程缺少了重复样本检验（基因型相同的样本）</p>
</li>
<li>
<p>亲子鉴定阈值需要通过经验给定，如果阈值设定不好，可能无法准确地将正确的亲子对和错误的亲子对分开，可能会造成错误鉴定。</p>
</li>
<li>
<p>后续可以对存在错误的个体查找真实亲本，方法就是对该个体遍历所有的候选亲本。</p>
</li>
<li>
<p>因为实际生产中可能存在采样错误（采的样本/基因型与标记的个体号不一致），因此本流程找到的错误系谱也有可能是由于采样错误导致的（例如这头个体本身系谱可能没错，但是可能采样采错了，不是采的这个个体，那么亲子鉴定肯定显示为错误）。也就是说，亲子鉴定找的错误实际由采样错误+系谱错误两部分组成。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>生物信息</tag>
      </tags>
  </entry>
  <entry>
    <title>Unsupervised Learning</title>
    <url>/posts/da92ff49/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>ISL 真是好书！</p>
<span id="more"></span> 
<h1>资料</h1>
<p><a href="https://www.statlearning.com/">An Introduction to Statistical Learning</a>，下文简称 <strong>ISL</strong></p>
<h1>概述</h1>
<p>无监督学习（<em>unsupervised learning</em> ）指只有特征 X<sub>1</sub>，X<sub>2</sub>, …… ,X<sub>p</sub> ，而没有反应变量的情况。这时候我们就是样本的特征之间的关系，最主要的作用就是对样本进行<strong>分组</strong>。这里主要关注两个无监督学习方法：<strong>主成分分析</strong>（<em>principal components analysis</em>）和 <strong>聚类分析</strong>（<em>clustering</em>）。</p>
<h1>The Challenge of Unsupervised Learning</h1>
<p>无监督学习的挑战在于比较主观，不像监督学习一样有一个真实值在那里，也没有简单的分析目的。无监督学习一般是用在<strong>探索性数据分析</strong>（<em>exploratory data analysis</em>）中。最后，我们也很难评价不同方法结果的优劣，因为无监督学习也不存在普遍承认的类似于交叉验证这样的验证方法。</p>
<p>无监督学习在很多领域都很重要。一个癌症研究者可能会得到100个乳腺癌患者的基因型表达水平数据集，他/她可能会想看一下这些样本能不能划分出子群体，或者这些基因能不能划分出子群体，从而对这个癌症有更好的认知。一个网购平台可能会想将相似的浏览历史和购买历史的顾客划分到一个子群体中，这就是所谓的市场细分，这样方便推送顾客可能会购买的商品广告。一个搜索引擎同样需要将不同的网页进行聚类。上面的这些例子都是通过无监督学习实现的。</p>
<h1>Principle Components Analysis</h1>
<p>当特征很多时，我们无法进行简单地可视化来查看样本之间的关系。如果我们能把原始数据转换成一个二维的数据 (p=2)，并且这两个新的特征能够捕获绝大多数信息，那么就可以根据这两个新的特征画散点图，描述观测值之间的关系。</p>
<p>主成分分析就可以做到这一点，主成分会创建包换尽可能多的变异的新特征，所有的主成分都是旧的p个特征的线性组合。例如，第一主成分表示为下式，第一主成分方差最大。</p>
<p style=""><img src="https://math.now.sh?from=Z_%7B1%7D%3D%5Cphi_%7B11%7D%20X_%7B1%7D%2B%5Cphi_%7B21%7D%20X_%7B2%7D%2B%5Cldots%2B%5Cphi_%7Bp%201%7D%20X_%7Bp%7D%0A" /></p><p>可能的参数需要满足下列条件：</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cphi_%7Bj%201%7D%5E%7B2%7D%3D1%0A" /></p><p>我们将这些参数称为第一主成分的 <em>loading</em> ， 这些 <em>loading</em> 组成了 <em>loading vector</em> 。</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft.%5Cphi_%7B1%7D%3D%5Cbegin%7Barray%7D%7Bcccc%7D%0A%28%5Cphi_%7B11%7D%20%26%20%5Cphi_%7B21%7D%20%26%20%5Cldots%20%26%20%5Cphi_%7Bp%201%7D%0A%5Cend%7Barray%7D%5Cright%29%5E%7BT%7D%0A" /></p><p>假设我们有一个 n × p 的数据集，我们如何计算第一主成分呢？因为我们需要计算方差，因此<strong>我们这里需要先对 X 进行中心化</strong>（使得X每列均值为0）。然后我们计算线性组合如下</p>
<p style=""><img src="https://math.now.sh?from=z_%7Bi%201%7D%3D%5Cphi_%7B11%7D%20x_%7Bi%201%7D%2B%5Cphi_%7B21%7D%20x_%7Bi%202%7D%2B%5Cldots%2B%5Cphi_%7Bp%201%7D%20x_%7Bi%20p%7D%0A" /></p><p>求解下式，即 Z<sub>i1</sub> 的方差需要最大化，这可以用线性代数中的特征值分解计算得到。这里由于所有特征均值为 0， 因此 Z<sub>i1</sub> 均值也为0。</p>
<p style=""><img src="https://math.now.sh?from=%5Cunderset%7B%5Cphi_%7B11%7D%2C%20%5Cldots%2C%20%5Cphi_%7Bp%201%7D%7D%7B%5Coperatorname%7Bmaximize%7D%7D%5Cleft%5C%7B%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cphi_%7Bj%201%7D%20x_%7Bi%20j%7D%5Cright%29%5E%7B2%7D%5Cright%5C%7D%20%5Ctext%20%7B%20subject%20to%20%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cphi_%7Bj%201%7D%5E%7B2%7D%3D1%0A" /></p><p>这里最终计算得到的 z<sub>11</sub>, …… , z<sub>n1</sub> 称为 <em>scores</em> 。</p>
<p>这里有一个对于第一主成分的几何学解释，第一主成分的 <em>loading vector</em> 其实构成了特征空间中的一个方向，再这个方向上数据 <em>vary the most</em> 。如果我们将这 n 个观测值投影到这个方向上，那么投影的值就是第一主成分的 <em>scores</em> ，即 z<sub>11</sub>, …… , z<sub>n1</sub> 。</p>
<p>下图为 p=2 的两个主成分的例子，其中的绿线便为第一组分的方向。</p>
<p><img src="1.png" alt="1"></p>
<p>我们计算得到第一主成分以后，我们就接着找第二主成分。第二主成分同样是p个特征的线性组合，是与第一主成分无关且方差最大的组合。</p>
<p>第二主成分的 scores 格式如下：</p>
<p style=""><img src="https://math.now.sh?from=z_%7Bi%202%7D%3D%5Cphi_%7B12%7D%20x_%7Bi%201%7D%2B%5Cphi_%7B22%7D%20x_%7Bi%202%7D%2B%5Cldots%2B%5Cphi_%7Bp%202%7D%20x_%7Bi%20p%7D%0A" /></p><p>第二主成分与第一主成分无关，等同于要求<strong>二者方向正交</strong>。在上图 6.14 中，由于 p=2，因此与第一主成分正交只有一种可能，因此一旦确定了第一主成分，那么第二主成分也随之确定了。</p>
<p>这里举个例子，数据为美国50个州的犯罪记录，特征包括三种犯罪 (Assault, Murder, Rape) 在 10万人中的逮捕人数，还包括了每个州城市化率 (UrbanPop），因此这里 n=50 ，p=4 。我们在进行PCA分析前，先对数据进行<strong>标准化</strong>（均值为0，标准差为1）。下图为前两个方差组分的结果，这里同时还体现了 <em>loading vectors</em> 的结果（第一主成分和第二主成分的loading 组成的方向），这种图一般称为 <em>biplot</em> 。</p>
<p><img src="2.png" alt="1"></p>
<p><em>loading vectors</em> 的值见下表。从这个表里，我们可以看到第一主成分在 UrbanPop 的权重较小，而第二主成分的主要权重则均在 UrbanPop  上。联立这个表和上面的图示，我们可以看出三种犯罪类型的变量彼此紧密关联，但是城市化率和这这三个变量相关较弱，这说明某一种犯罪较为猖狂的城市其他犯罪可能也比较严重。</p>
<p><img src="3.png" alt="1"></p>
<p>我们同样可以通过上图检验样本之间的差别。根据我们对 <em>loading vectors</em> 的讨论，我们发现第一主成分值很高的城市，比如  California, Nevada 和 Florida 可能有很高的犯罪率，而像North Dakota 这种第一主成分为负数的州可能犯罪率较低。同时 California 的第二主成分也很高，这说明它的城市化率可能较高。</p>
<h2 id="Another-Interpretation-of-Principal-Components">Another Interpretation of Principal Components</h2>
<p>下图为一个 p=3 的两个主成分的例子，我们看到两个 <em>loading vectors</em> 组成了一个平面，把观测值投射到这个平面上，方差最大。</p>
<p><img src="4.png" alt="1"></p>
<p>在前面，我们提到 <em>loading vectors</em>  是特征空间中数据变异最丰富的方向，而 <em>scores</em> 则是数据向 <em>loading vectors</em>  方向上的投射。我们还可以用另外一种方式进行解释：主成分生成了与观测点<strong>距离最近</strong>的低维线性平面。</p>
<p>第一主成分的 <em>loading vector</em> 很特别：它构成的直线是距离这 n 个观测点<strong>最近</strong>的直线。所谓最近指的是欧几里得距离。</p>
<p>我个人感觉<strong>变异最丰富</strong>和<strong>距离最近</strong>是两个性质，变异最丰富并不需要距离最近。例如 p =2 的情况下，变异最丰富其实可以画出无数的平行线，这些平行线都满足变异最丰富。因此上文对于参数的取值有一个限定条件，参数平方和为1，应该是加了这个限制条件才满足了距离最近这个性质。</p>
<p>通过这个解释，我们构建的前M个 <em>score vectors</em> 和 <em>loading vectors</em>  构成了观测值的最佳的 M维的近似值。</p>
<p>这可以写成下式（没看懂）。（假定初始的X是中心化的）</p>
<p style=""><img src="https://math.now.sh?from=x_%7Bi%20j%7D%20%5Capprox%20%5Csum_%7Bm%3D1%7D%5E%7BM%7D%20z_%7Bi%20m%7D%20%5Cphi_%7Bj%20m%7D%0A" /></p><p>这说明如果M较大的话，我们可以用PCA结果计算得到X的近似值。PCA分析 M 的最大值为 min(n-1, p) 。</p>
<h2 id="More-on-PCA">More on PCA</h2>
<h3 id="Scaling-the-Variables">Scaling the Variables</h3>
<p>上面提到过，进行PCA分析前，<strong>必须先对X进行中心化</strong>。另外 X 的方差也会对结果造成影响：</p>
<blockquote>
<p><em>the results obtained when we perform PCA will also depend on whether the variables have been individually scaled (each multiplied by a different constant)</em></p>
</blockquote>
<p>如果你对某个特征，乘以某个常数，这就会造成 <em>scale</em> 的变化，最终造成结果变化。不同的方法对于 <em>scale</em> 的影响不一样，比如线性回归压根不受到 <em>scale</em> 的影响（线性回归中如果对某个自变量乘以一个常数 c，那么最后估计的系数会乘以 1/c，最终的模型不会受到实质性影响）。</p>
<p>上面美国不同的州的犯罪率的例子中，我们事先对特征进行了标准化。原始数据4个特征的方差为 18.97, 87.73, 6945.16 和 209.5。因此，如果直接用原始数据 (<em>unscaled data</em>) 进行PCA分析，那么第一主成分会主要偏向于第3个特征，因为第3个特征的方差最高。事实上，第一主成分的所有权重基本都在第3个特征上。</p>
<p>下图为采用标准化的数据 (左) 和未标准化的数据 (右) 的两次PCA分析比对。我们可以看到对于原始数据，第一主成分基本沿着 Assault 的方向（第3个特征），第二主成分基本验证 UrbanPop 的方向。因此，<strong>是否进行方差标准化，会直接影响PCA结果</strong>。</p>
<p><img src="5.png" alt="1"></p>
<p><strong>如果不同的特征的单位不同，那么我们一般会在PCA分析前进行数据标准化</strong>。<strong>但是在某些情况下，如果所有特征的单位相同，我们可能不希望将所有的特征的方差调整为1</strong>。</p>
<h3 id="Uniqueness-of-the-Principal-Components">Uniqueness of the Principal Components</h3>
<p>不同软件计算的主成分的 <em>loading vector</em> 的数值都是相同，但是符号可能相反。比如(0.5, 0.5) 和 (-0.5, -0.5) ，数值相同，符号相反，但是其实还是在一条直线上。</p>
<h3 id="The-Proportion-of-Variance-Explained">The Proportion of Variance Explained</h3>
<p>做完PCA分析后，我们可能想知道每个主成分解释的方差比例 ( <em>proportion of variance explained</em>(PVE) )。</p>
<p>数据集中总的方差定义如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Coperatorname%7BVar%7D%5Cleft%28X_%7Bj%7D%5Cright%29%3D%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20x_%7Bi%20j%7D%5E%7B2%7D%0A" /></p><p>然后第 m 个主成分解释的方差为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20z_%7Bi%20m%7D%5E%7B2%7D%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cphi_%7Bj%20m%7D%20x_%7Bi%20j%7D%5Cright%29%5E%7B2%7D%0A" /></p><p>因此第m个主成分的PVE为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cphi_%7Bj%20m%7D%20x_%7Bi%20j%7D%5Cright%29%5E%7B2%7D%7D%7B%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20x_%7Bi%20j%7D%5E%7B2%7D%7D%0A" /></p><p>在上面的美国犯罪数据集中，第一个主成分解释了 62% 的方差，第二主成分解释了 24.7% 的方差。二者之和解释了 87% 的方差，而最后两个主成分只有 13% 的方差（总的主成分数目为 min(n-1,p) ）。这说明在这个数据中，只用两个主成分就已经很好地体现总体数据的情况。 每个主成分的PVE 和累计PVE 见下图，其中左图又称为 <em>scree plot</em> 。</p>
<p><img src="6.png" alt="1"></p>
<h3 id="Deciding-How-Many-Principal-Components-to-Use">Deciding How Many Principal Components to Use</h3>
<p>在实际的PCA分析中，我们一般只会用前几个主成分来进行可视化或解释数据，因此我们需要知道需要的主成分数目的<strong>最小值</strong>，才可以较好地把握整个数据集。或者说，我们到底需要几个主成分？</p>
<p>一般我们可以用上图左图（又称为 <em>scree plot</em> ）来决定，通过肉眼来看需要几个主成分，实际上这是一个比较主观的事情，这也是无监督学习的一个特点。</p>
<h3 id="Other-Uses-for-Principal-Components">Other Uses for Principal Components</h3>
<p>我们可以直接用主成分分析的 <em>score vectors</em> 作为新的特征，用于回归问题、分类问题和聚类问题。这种做法的优点是<strong>降低计算量</strong>和<strong>减少噪音的影响</strong>。减少计算量是由于特征数目减少了，而减少噪音的影响是由于<em>signal</em> ( 与 noise 相反) 往往会集中在前几个主成分当中。</p>
<h1>Clustering Methods</h1>
<p>聚类方法就是看能不能把观测值划分成不同的子群体，在同一个子群体内的个体具有相似的特征，而不同的子群体的个体之间则很不相同。这里我们首先要定义<strong>个体之间如何才叫相似或不同</strong>，这需要根据我们对数据集的认知进行特定地考虑。</p>
<p>假设我们有一个 n × p 的数据集，n 个观测值均来自于乳腺癌患者的样本，p 个特征是这些样本的测量值，包括一些临床指标，如肿瘤等级，又或者是基因表达量数据。我们怀疑这n个样本可能存在一定的异质性，比如乳腺癌可能还有一些不为人知的子类型，如何找出这些样本的结构，这就是一个无监督学习的任务。</p>
<p>聚类分析的另一个应用是<strong>市场细分</strong>。</p>
<p>总的来说，我们既可以通过观测值 (Y) 来对观测值进行聚类，也可以通过特征 (X) 进行聚类，二者仅仅是用的数据集不一样，方法相同。下面只考虑基于特征数据集的聚类。</p>
<h2 id="K-Means-Clustering">K-Means Clustering</h2>
<p>K-均值算法是一种将所有观测值划分为 K个不同的<strong>无重叠</strong>的子群体。执行这个算法前，我们需要事先指定子群体的数目K，然后所有的观测值就会被精确划分到某一个子群体中。下图为对 150×2 的数据集聚类的结果</p>
<p><img src="7.png" alt="1"></p>
<p>这里我们标记子群体为 C<sub>1</sub>, …… , C<sub>K</sub> 。一个好的分类是<strong>子群体内方差</strong> (<em>within-cluster variation</em>) 尽可能地小。针对C<sub>K</sub>子群体的子群体内方差标记为 W(C<sub>K</sub>)，适用于衡量这个子群体内的观测值之间的区别。</p>
<p>因此，这种算法需要解决的问题标记如下，即总的子群体内方差最小。</p>
<p style=""><img src="https://math.now.sh?from=%5Cunderset%7BC_%7B1%7D%2C%20%5Cldots%2C%20C_%7BK%7D%7D%7B%5Coperatorname%7Bminimize%7D%7D%5Cleft%5C%7B%5Csum_%7Bk%3D1%7D%5E%7BK%7D%20W%5Cleft%28C_%7Bk%7D%5Cright%29%5Cright%5C%7D%0A" /></p><p>这里我们还需要定义 W(C<sub>K</sub>) ，这个有多种方式，一般定义如下。</p>
<p style=""><img src="https://math.now.sh?from=W%5Cleft%28C_%7Bk%7D%5Cright%29%3D%5Cfrac%7B1%7D%7B%5Cleft%7CC_%7Bk%7D%5Cright%7C%7D%20%5Csum_%7Bi%2C%20i%5E%7B%5Cprime%7D%20%5Cin%20C_%7Bk%7D%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%5Cleft(x_%7Bi%20j%7D-x_%7Bi%5E%7B%5Cprime%7D%20j%7D%5Cright)%5E%7B2%7D%0A" /></p><p>这里 |C<sub>K</sub>| 指第K个子群体的观测值数目。这个公式的含义就是第K个子群体内所有配对的欧几里得距离的平方的均值。</p>
<p>结合上面上面两个式子，我们得到需要解决的问题为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cunderset%7BC_%7B1%7D%2C%20%5Cldots%2C%20C_%7BK%7D%7D%7B%5Coperatorname%7Bminimize%7D%7D%5Cleft%5C%7B%5Csum_%7Bk%3D1%7D%5E%7BK%7D%20%5Cfrac%7B1%7D%7B%5Cleft%7CC_%7Bk%7D%5Cright%7C%7D%20%5Csum_%7Bi%2C%20i%5E%7B%5Cprime%7D%20%5Cin%20C_%7Bk%7D%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%5Cleft%28x_%7Bi%20j%7D-x_%7Bi%5E%7B%5Cprime%7D%20j%7D%5Cright%29%5E%7B2%7D%5Cright%5C%7D%0A" /></p><p>因此，我们需要找到一个算法来解决这个问题。这其实是一个很难的问题，因为有很多潜在的聚类方式。如果我们要遍历所有可能的聚类方式，那么总的计算次数就可能是一个天文数字。幸运地是，我们有一个算法来计算得到一个局部最优解。算法描述如下：</p>
<p><img src="8.png" alt="1"></p>
<p>这个算法确保每一步迭代总的子群体内方差都会降低。为了理解这一点，我们需要理解下面的式子。</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B1%7D%7B%5Cleft%7CC_%7Bk%7D%5Cright%7C%7D%20%5Csum_%7Bi%2C%20i%5E%7B%5Cprime%7D%20%5Cin%20C_%7Bk%7D%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%5Cleft%28x_%7Bi%20j%7D-x_%7Bi%5E%7B%5Cprime%7D%20j%7D%5Cright%29%5E%7B2%7D%3D2%20%5Csum_%7Bi%20%5Cin%20C_%7Bk%7D%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%5Cleft(x_%7Bi%20j%7D-%5Cbar%7Bx%7D_%7Bk%20j%7D%5Cright)%5E%7B2%7D%0A" /></p><p>其中的 X<sub>kj</sub>  bar 是 C<sub>k</sub> 子群体内特征j 的均值，计算公式如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbar%7Bx%7D_%7Bk%20j%7D%3D%5Cfrac%7B1%7D%7B%5Cleft%7CC_%7Bk%7D%5Cright%7C%7D%20%5Csum_%7Bi%20%5Cin%20C_%7Bk%7D%7D%20x_%7Bi%20j%7D%0A" /></p><p>这里ISL 还是没有讲清楚为什么每一步迭代总的子群体内方差都只会降低，最终不再变化，形成一个局部最优解。下图为每一步迭代的图示效果。</p>
<p><img src="9.png" alt="1"></p>
<p>因为 K-均值算法得到的是<strong>局部</strong>最优解，而不是全局最优解，<strong>最终的聚类结果受到了算法第一步随机分类结果的影响</strong>。针对这个原因，我们需要用多个初始随机的配置来进行多次聚类，然后我们挑其中最好的结果（总的子群体内方差最低）。</p>
<p>下图为6次使用不同的初始配置的聚类结果，其中总的子群体内方差为 235.8 的聚类结果是我们最终选的结果。</p>
<p><img src="10.png" alt="1"></p>
<p>从这个图来看，我感觉聚类也只能是做<strong>探索性分析</strong>，受到的影响因素比较多，没法说两个个体没有聚到一类就一定差异很大。</p>
<h2 id="Hierarchical-Clustering">Hierarchical Clustering</h2>
<p>K-均值算法的一个潜在的缺点在于需要事先指定子群体数目K。层次聚类是一种不需要指定K的算法，它的优点是最终会以一个决策树的形式展示聚类结果，称为 <em>dendrogram</em> 。</p>
<h3 id="Interpreting-a-Dendrogram">Interpreting a Dendrogram</h3>
<p>这里我们用一个 45 × 2 的数据集，见下图。这个数据来自于3个子群体，在图上用不同的颜色进行标记了（也就是说，我们知道真实的聚类结果）。</p>
<p><img src="11.png" alt="1"></p>
<p>层次分析结果见下图中的左图。如何去看这个结果呢？从下往上看，决策树的每个叶子表示一个观测值，然后这些叶子会汇聚成一个分支，小分支又能汇聚成更大的分支，以此往复直到决策树的根部。小分支内的个体间的相似性高于大分支。</p>
<p>如何看两个个体的相似性呢？我们需要找到这两个个体第一次合并到成一个分支的节点，查看这个节点在纵坐标的位置，这个值越小说明关系越近。</p>
<p><img src="12.png" alt="1"></p>
<p>我们在解读这张图的时候容易出现一些误区。下图为 9 × 2 的数据集的聚类结果，我们可以认为1和6，5和7很相似，这没有问题，因为它们都在最低的水平。但是，你不能仅仅看着9和2很接近，就认为 9 和 2 很相似，这是错误的，事实上， 9和 2 8 5 7 这四个观测值的距离都差不多，如下图右图所示。</p>
<p>这个误区就是你不能根据横向位置来判断观测值之间的远近，而<strong>只能根据纵向位置判断</strong>。横向位置并不可靠，比如这里 1 和 6 可以互换位置，聚类结果其实没变；又或者 2 所在的左支和 8 5 7 所在的右枝互换位置，这个时候你就看着 9 和 2 的横向距离远了，但是聚类结果没变。</p>
<p><img src="13.png" alt="1"></p>
<p>通过在某个纵坐标上拉一道口子，画一条线，我们可以划分出任意 K 个 cluster ，比如上图10.9 的中间的图和右图分别划分出2个和3个 <em>clusters</em> 。</p>
<p>层次聚类的名称也来自于这一特性，纵坐标的低点划分的 clusters 一定包含在纵坐标的高点划分的 clusters 内，也就是存在嵌套关系。但是有时实际数据可能并不满足这种假设，例如假设我们有个数据集，里面男女各一半，然后又可以分为美国人、日本人和法国人。我们可以想象，如果我们要聚成2类，我们希望按照性别划分；如果要聚成3类，我们希望按照国籍划分。这种情况下，真实的分类并不是嵌套的，因此K=3的聚类并不包含K=2的结果内。因此这种情况下，层次聚类的结果可能会会比 K-均值聚类的效果更差。</p>
<h3 id="The-Hierarchical-Clustering-Algorithm">The Hierarchical Clustering Algorithm</h3>
<p>层次聚类算法很简单，我们首先要定义很来奶两个观测值之间的 <em>dissimilarity</em> 的指标。一帮我们会用欧几里得距离。算法具体描述如下：</p>
<p><img src="14.png" alt="1"></p>
<p>下图为图10.10 聚类的前几步图示。</p>
<p><img src="15.png" alt="1"></p>
<p>这个算法看上去很简单，但是还有一个问题没解决。例如上图右下图，我们如果决定 {5，7}  和 8 的不相似性呢？上面我们只提到了两个点之间的不相似性，我们如何两个 <em>cluster</em> 之间的不相似性呢？我们一半称两个 <em>cluster</em> 之间的不相似性称为 <em>linkage</em> 。下表描述了四种常见的 <em>linkage</em> ，一般我们会用 Average 和 complete 。</p>
<p><img src="16.png" alt="1"></p>
<p>层次聚类的结果受 <em>linkage</em> 的影响很大，见下图</p>
<p><img src="17.png" alt="1"></p>
<h3 id="Choice-of-Dissimilarity-Measure">Choice of Dissimilarity Measure</h3>
<p>一般来说，我们会用欧几里得距离作为 <em>dissimilarity</em> 的衡量指标，但是有时我们可能会想用别的指标。例如，我们可能会用两个观测值特征之间的相关系数作为评价指标，而不是距离。下图展示基于相关系数和欧几里得距离的层次聚类结果，观测值1和3的欧几里得距离很近，但是它们的相关很低；观测值1和2的欧几里得距离很远，但是相关程度很高。</p>
<p><img src="18.png" alt="1"></p>
<p><em>dissimilarity</em> 的衡量指标的选择非常重要，我们需要根据数据类型和目的进行确定。例如一个电商想要根据消费者的消费记录进行聚类。我们的目的是找到消费习惯相同的消费者，然后聚成不同的类，特定投放不同的广告。假设数据集的形式是每一行表示一个消费者，每一列表示一种商品，元素只能是0和1，0表示没买过，1表示买过。这里我们应该用什么衡量 <em>dissimilarity</em> 的指标呢？</p>
<p>如果我们用欧几里得距离，那么哪些买过商品的总数很少的顾客会被聚成一堆，这不是我们想要的结果。但是，如果我们用相关系数，那么有着相似的消费习惯的顾客会被聚成一堆（比如都买过A和B, 但是都没买过C和D的顾客），即便有些顾客的总的商品消费数目更高。因此在这种情况下，更适合使用相关系数。</p>
<p>除了 <em>dissimilarity</em> 的衡量指标，我们还需要考虑聚类前要不要进行<em><strong>scale</strong></em>，将所有特征的标准差均调整为1。为了说明这一点，我们还是用电商的例子，有些商品的购买次数可能会比较频繁，比如袜子；有些商品的购买次数会比较少，比如电脑。高频购买的商品可能在计算 <em>dissimilarity</em> 时比低频购买商品有更高的作用，最终在聚类结果中的作用也更大。如果我们事先将所有特征的标准差均调整为1，那么所有特征对于层次聚类的重要性均相同。最终要不要进行 <em>scale</em> 需要具体情况具体分析，在这个电商的例子中我们可能会选择进行 <em>scale</em> 。</p>
<p>下图是是否进行 <em>scale</em> 效果的图示，这一点对 K-均值聚类也有作用。左图为两种商品8个消费者的消费数目，中间的图为 <em>scale</em> 之后的效果，右图的纵坐标为换成消费金额的效果。</p>
<p><img src="19.png" alt="1"></p>
<h2 id="Practical-Issues-in-Clustering">Practical Issues in Clustering</h2>
<p>实际聚类时需要关注的问题。</p>
<h3 id="Small-Decisions-with-Big-Consequences">Small Decisions with Big Consequences</h3>
<p>聚类之前，我们需要先做一些决定。</p>
<ul>
<li>数据是否需要进行标准化（均值为0，标准差为1）</li>
<li>如果使用层次聚类
<ul>
<li>使用哪一种 <em>dissimilarity</em> 的衡量指标</li>
<li>使用哪一种 <em>linkage</em></li>
<li>我们最终在决策树上什么地方划一道水平线，来获得具体的 clusters</li>
</ul>
</li>
<li>如果使用 K-均值聚类，K值设定为多少</li>
</ul>
<p>这些决定影响很大，但是都是不存在一个唯一的真实答案的，都需要进行主观判断。我们一般可能会测试几次，然后挑一次结果。</p>
<h3 id="Validating-the-Clusters-Obtained">Validating the Clusters Obtained</h3>
<p>当我们聚类后，我们会想知道我们聚类的结果是不是就是真实的结果，还是仅仅是 <em>clustering the noise</em> 。比如，如果我们有一个独立的新的数据，那么这些数据能不能会被用同样的方式进行聚类？现在有一些新方法可以提供一个 p 值，来评价一个cluster 和我们完全随机分组相比的概率，但是目前还没有达到一个统一的共识。</p>
<h3 id="Other-Considerations-in-Clustering">Other Considerations in Clustering</h3>
<p>K-均值聚类和层次聚类都会将所有的观测值划分到某个子群体中。但是数据中可能会存在离群点，这些点不属于任何一个 cluster ，但是由于这两种聚类方法一定要把所有的观测点都放到某个子群体中，因此<strong>离群点会非常影响聚类结果</strong>。（那我能不能先用PCA分析找到离群点，剔除离群点之后再进行聚类呢？）</p>
<p>聚类方法还有一个缺点是不稳健。比如你用 n 个观测值聚类了一次，然后你随机地剔除了一小撮个体，再聚类一次，你可能会得到一个不一样的结果。</p>
<h3 id="A-Tempered-Approach-to-Interpreting-the-Results-of-Clustering">A Tempered Approach to Interpreting the Results of Clustering</h3>
<p>综合上述，你可能挑选不同的指标来做聚类的测试，最终挑选一个你觉得比较好的聚类结果。最后你可能还需要从原数据集中随机挑选一些子集，查看聚类结果的稳健性。最后的最后，你一定要注意解释聚类结果的方式，<strong>你绝对不能认为聚类结果是绝对的真实情况</strong>，你只能把聚类结果当成之后深入研究的起点（最好是用另一个独立的数据集进行进一步研究）。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>数据分析</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Support Vector Machines</title>
    <url>/posts/4de29630/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>ISL 真是好书！</p>
<span id="more"></span> 
<h1>资料</h1>
<p><a href="https://www.statlearning.com/">An Introduction to Statistical Learning</a>，下文简称 <strong>ISL</strong></p>
<h1>Maximal Margin Classifier</h1>
<h2 id="What-Is-a-Hyperplane">What Is a Hyperplane?</h2>
<p>超平面 (<em>hyperplane</em>) 是指在 p 维空间中维度为 p-1 的子空间。例如，对于二维空间，超平面就是一条线；在三维空间，超平面就是一个二维的平面。</p>
<p>超平面的数学定义很简单，但与一个二维空间的超平面，定义如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20X_%7B1%7D%2B%5Cbeta_%7B2%7D%20X_%7B2%7D%3D0%0A" /></p><p>我们可以看到这就是一条直线的表达式。</p>
<p>因此，我们可以推断出 p 维空间的超平面的一般表达式如下：如果一个点满足下列式子，则在超平面上。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20X_%7B1%7D%2B%5Cbeta_%7B2%7D%20X_%7B2%7D%2B%5Cldots%2B%5Cbeta_%7Bp%7D%20X_%7Bp%7D%3D0%0A" /></p><p>如果一个点 X 不在超平面上，即上面的这个式子不为0（大于0 或 小于0），我们称这个点在超平面的一侧。因此，<strong>超平面将这个空间分为了两半</strong>，下图为二维空间超平面划分出的两个空间示意图。</p>
<p><img src="1.png" alt="1"></p>
<h2 id="Classification-Using-a-Separating-Hyperplane">Classification Using a Separating Hyperplane</h2>
<p>假设我们有一个 n×p 的数据集 X，包好 n 条观测值 和 p 个特征。这些观测值只有两个水平，-1 和 1。我们同时还有一个验证集。我们的目的是通过训练集构建一个 classfier，可以正确地对验证集进行分类。这里我们有很多方法可以用，经典地方法有线性判别分析和逻辑回归，决策树方法有分类树、bagging、boosting 。现在我们剔除一个基于 <em>separating hyperplane</em> 概念的新方法。</p>
<p>假设我们可以构建一个超平面，可以完美地区分训练集中不同的观测值，例如下图的左图就显示了3种  <em>separating hyperplane</em>  的例子。</p>
<p><img src="2.png" alt="1"></p>
<p>左图划分的公式如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20x_%7Bi%201%7D%2B%5Cbeta_%7B2%7D%20x_%7Bi%202%7D%2B%5Cldots%2B%5Cbeta_%7Bp%7D%20x_%7Bi%20p%7D%3E0%20%5Ctext%20%7B%20if%20%7D%20y_%7Bi%7D%3D1%20%5Ctext%20%7B%20%2C%20%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20x_%7Bi%201%7D%2B%5Cbeta_%7B2%7D%20x_%7Bi%202%7D%2B%5Cldots%2B%5Cbeta_%7Bp%7D%20x_%7Bi%20p%7D%3C0%20%5Ctext%20%7B%20if%20%7D%20y_%7Bi%7D%3D-1%0A" /></p><p>因此，这里的一个 <em>separating hyperplane</em> 均具有下面的属性：</p>
<p style=""><img src="https://math.now.sh?from=y_%7Bi%7D%5Cleft%28%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20x_%7Bi%201%7D%2B%5Cbeta_%7B2%7D%20x_%7Bi%202%7D%2B%5Cldots%2B%5Cbeta_%7Bp%7D%20x_%7Bi%20p%7D%5Cright%29%3E0%0A" /></p><p>如果我们能构建一个 <em>separating hyperplane</em>，我们就可以用它作为一个 <em>classifier</em> ，直接用在验证集中，效果如上图9.2 右图，预测值取决于上面的式子的符号，大于0则预测为1，小于0则预测为-1。我们同时可以利用上面式子的大小，越大说明预测值越可信。</p>
<p>通过这个例子，我们可以看到，通过 <em>separating hyperplane</em> 这种思想，我们最终构建的是一个<strong>线性决策线</strong>。</p>
<h2 id="The-Maximal-Margin-Classifier">The Maximal Margin Classifier</h2>
<p>一般来说，如果我们可以通过一个超平面来<strong>完美</strong>地划分我们的数据，那么实际上存在无数条这样的可能的超平面。如果需要通过 <em>separating hyperplane</em> 方法来构建一个 classfier ，那么我们需要决定使用哪一个 <em>separating hyperplane</em> 。</p>
<p>一个自然的方法是 <em>the maximal margin classifier</em> ，也称为 <em>optimal separating hyperplane</em> ，即选择与训练集所有的观测点距离最远的 <em>separating hyperplane</em> 。我们可以计算所有观测点到一个给定的 <em>separating hyperplane</em> 的直线距离，所有点的直线距离的最小值称为 <em>margin</em> 。<em>the maximal margin classifier</em> 是 <em>margin</em> 最大的超平面（即所有点的最小直线距离 <em>margin</em> 最大）。虽然这种方法一般很成功，但是当p很大，可能会造成 <em><strong>overfitting</strong></em>。</p>
<p>下图展示了用上图9.2训练集数据计算的最大边际分类器的结果。<em>margin</em> 体现为虚线和实线的直线距离，我们可以看到有3个点与分类器的距离最小，这三个点一般也被称为 <em>support vectors</em> ，因为它们是 p 维空间的向量，而且它们 “support” 我们的最大边际分类器的结果，如果我们把这些点稍微移动了一些位置，那么我们最终的分类器结果也会跟着改变。<strong>其实，最大边际分类器的构建仅取决于这几个点，和其他点毫不相关。</strong></p>
<p><img src="3.png" alt="1"></p>
<h2 id="Construction-of-the-Maximal-Margin-Classifier">Construction of the Maximal Margin Classifier</h2>
<p>简单地说，对于n × p 的训练集，反应变量只有两个水平 -1 和 1，最大边际超平面就是下面问题的解。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cunderset%7B%5Cbeta_%7B0%7D%2C%20%5Cbeta_%7B1%7D%2C%20%5Cldots%2C%20%5Cbeta_%7Bp%7D%2C%20M%7D%7B%5Coperatorname%7Bmaximiize%7D%7D%20M%20%5C%5C%0A%26%5Ctext%20%7B%20subject%20to%20%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%5E%7B2%7D%3D1%2C%20%5C%5C%0A%26y_%7Bi%7D%5Cleft%28%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20x_%7Bi%201%7D%2B%5Cbeta_%7B2%7D%20x_%7Bi%202%7D%2B%5Cldots%2B%5Cbeta_%7Bp%7D%20%20x_%7Bi%20p%7D%5Cright%29%20%5Cgeq%20M%20%5Cquad%20%5Cforall%20i%3D1%2C%20%5Cldots%2C%20n%20.%0A%5Cend%7Baligned%7D%0A" /></p><p>首先假定 M 大于0，那个式子就保证了训练集中所有的观测值均会正确地分类。基于上式第二行的条件，可以推断出，点到超平面的直线距离就是下式。（未证明）</p>
<p style=""><img src="https://math.now.sh?from=y_%7Bi%7D%5Cleft%28%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20x_%7Bi%201%7D%2B%5Cbeta_%7B2%7D%20x_%7Bi%202%7D%2B%5Cldots%2B%5Cbeta_%7Bp%7D%20x_%7Bi%20p%7D%5Cright%29%0A" /></p><p>因此，这个式子确保了所有观测值均被正确分类了，并且与超平面的距离至少为 M，即 M 就是 <em>margin</em> 。然后，我们需要挑出一组 β ，使得 M 的值最大。</p>
<h2 id="The-Non-separable-Case">The Non-separable Case</h2>
<p>上面的方法有一个缺点，有些时候根本不存在  <em>separating hyperplane</em> ，所以也就不存在最大边际超平面。带入上式即为，找不到 M &gt; 0 的解，下图为一个例子。</p>
<p><img src="4.png" alt="1"></p>
<p>我们可以把这个思路扩展一下，改成找到一个能正确分类大多数观测点的超平面，这个方法称为 <em>support vector classifier</em> 。</p>
<h1>Support Vector Classifier</h1>
<p>如上图所示，有些时候我们无法找到一个能把所有观测值正确分开的超平面。事实上，即便真的存在 <em>separating hyperplane</em> ，有时这个超平面构建成的分类器可能也不理想。由于要将所有观测值均要正确分开，因此 <em>separating hyperplane</em> 会对于个体观测值非常敏感。下图为一个例子，右图中仅仅是新增了一个观测值就导致最大边际超平面发生了很大的改变，新的超平面其实并不理想，比如说这个超平面的 <em>margin</em> 非常小。</p>
<p><img src="5.png" alt="1"></p>
<p>由于最大边际超平面对于单个观测值的变化非常敏感，因此非常容易造成过拟合的现象。</p>
<p>因此这种情况下，我们可能更希望想要一个<strong>不是完美分类</strong>的分类器，优点在于更加稳健，不容易受到个别极端值的影响。也就是说，训练集中一小撮的观测值被错误分类是允许的，这是为了让剩下的大部分观测值的预测更加稳定。</p>
<p>上述思想一般就称为 <em>support vector classifier</em> ，有时也称为 <em>soft margin classifier</em> ，效果见下图。左图我们可以看到大部分点在划分的margin 线以外，有几个点在划分的 margin 线以内；右图甚至有几个点直接判别错误（在超平面的另一边），如 11 和 12 。</p>
<p><img src="6.png" alt="1"></p>
<h2 id="Details-of-the-Support-Vector-Classifier">Details of the Support Vector Classifier</h2>
<p><em>support vector classifier</em> 方法的数学式子如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cunderset%7B%5Cbeta_%7B0%7D%2C%20%5Cbeta_%7B1%7D%2C%20%5Cldots%2C%20%5Cbeta_%7Bp%7D%2C%20%5Cepsilon_%7B1%7D%2C%20%5Cldots%2C%20%5Cepsilon_%7Bn%7D%2C%20M%7D%7B%5Coperatorname%7Bmaximize%7D%7D%20M%20%5C%5C%0A%26%5Ctext%20%7B%20subject%20to%20%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%5E%7B2%7D%3D1%2C%20%5C%5C%0A%26y_%7Bi%7D%5Cleft%28%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20x_%7Bi%201%7D%2B%5Cbeta_%7B2%7D%20x_%7Bi%202%7D%2B%5Cldots%2B%5Cbeta_%7Bp%7D%20x_%7Bi%20p%7D%5Cright%29%20%5Cgeq%20M%5Cleft(1-%5Cepsilon_%7Bi%7D%5Cright)%2C%20%5C%5C%0A%26%5Cepsilon_%7Bi%7D%20%5Cgeq%200%2C%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Cepsilon_%7Bi%7D%20%5Cleq%20C%0A%5Cend%7Baligned%7D%0A" /></p><p>这里的 C 是一个调整参数。同上，M 表示 margin ，需要寻找最大值。ε<sub>i</sub> 为松弛变量，使得有些个体可以在错误的margin 甚至是错误的 hyperplane 上；如果 ε<sub>i</sub> 等于0，那么这个观测值就在正确的 margin 一侧；如果 ε<sub>i</sub>  &gt; 0 ，那么这个观测值就在 错误的 margin 一侧；如果 ε<sub>i</sub> &gt; 1 ，那么这个观测值就在错误的 超平面一侧。</p>
<p>这里的 C 限制了 ε<sub>i</sub> 之和，因此这个参数表示我们能允许多少观测值被错误分类。如果 C = 0, 那么这就是最大边际超平面。C 的范围在 0 ~ n 之间，下图为不同 C 值的结果，左上图C值最大，之后不断减少。</p>
<p><img src="7.png" alt="1"></p>
<p>在实际情况中，我们一般用交叉验证来决定 C 值的大小。</p>
<p><em>support vector classifier</em> 有一个特性：<strong>只有在 margin 线上或在错误的margin线一侧的点才会影响 <em>support vector classifier</em> 结果</strong>；对于那些处于正确的 margin 线一侧的点，移动这些点的位置不会影响分类器。</p>
<p>因此在 margin 线上或在错误的margin线一侧的点称为 <em><strong>support vectors</strong></em> 。这和我们说 C 值控制 bias-variance trade-off 也是一致的，当 C 值很大时，存在很多观测值在错误的 margin 线一侧，即<em>support vectors</em> 很多，即构建分类器用到的点很多，所以 variance 较低（由于用到了很多的 <em>support vectors</em> ），但是可能 bias 很高，如上图左上图。当 C 值很小时，构建分类器用到的点较少，因此 variance 较高，但是 bias 较低，如右图右下图，这里其实只有 8 个 <em>support vectors</em> 。</p>
<p>这种分类器几乎不受到离超平面很远的点的影响，这个性质和其他分类方法不太一样，比如前面提到的线性判别方法 (LDA 方法需要计算每个水平所有观测值的均值，以及使用所有观测值计算水平内的方差矩阵) 。与之相反，逻辑回归对于远离决策线的观测值的敏感性很低。</p>
<h1>Support Vector Machines</h1>
<p>我们之前提到过如何将一个线性的分类器转为非线性的分类器。这里 <em>support vector machines</em> 实现了同样的效果。</p>
<h2 id="Classification-with-Non-linear-Decision-Boundaries">Classification with Non-linear Decision Boundaries</h2>
<p>有时我们会面临非线性的决策线，如下图。此时，<em>support vector classifier</em>  结果基本毫无用处。</p>
<p><img src="8.png" alt="1"></p>
<p>类似于线性模型的作法，这里我们也可以加入<strong>多项式</strong>来解决这个问题，比如对 p 个特征都添加二次型。</p>
<p style=""><img src="https://math.now.sh?from=X_%7B1%7D%2C%20X_%7B1%7D%5E%7B2%7D%2C%20X_%7B2%7D%2C%20X_%7B2%7D%5E%7B2%7D%2C%20%5Cldots%2C%20X_%7Bp%7D%2C%20X_%7Bp%7D%5E%7B2%7D%0A" /></p><p>此时的分类器算法变为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%26%5Cunderset%7B%5Cbeta_%7B0%7D%2C%20%5Cbeta_%7B11%7D%2C%20%5Cbeta_%7B12%7D%20%5Cldots%2C%20%5Cbeta_%7Bp%201%7D%2C%20%5Cbeta_%7Bp%202%7D%2C%20%5Cepsilon_%7B1%7D%2C%20%5Cldots%2C%20%5Cepsilon_%7Bn%7D%2C%20M%7D%7B%5Coperatorname%7Bmaximize%7D%7D%20M%20%5C%5C%0A%26%5Ctext%20%7B%20subject%20to%20%7D%20y_%7Bi%7D%5Cleft%28%5Cbeta_%7B0%7D%2B%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%201%7D%20x_%7Bi%20j%7D%2B%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%202%7D%20x_%7Bi%20j%7D%5E%7B2%7D%5Cright%29%20%5Cgeq%20M%5Cleft(1-%5Cepsilon_%7Bi%7D%5Cright)%2C%20%5C%5C%0A%26%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Cepsilon_%7Bi%7D%20%5Cleq%20C%2C%20%5Cquad%20%5Cepsilon_%7Bi%7D%20%5Cgeq%200%2C%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Csum_%7Bk%3D1%7D%5E%7B2%7D%20%5Cbeta_%7Bj%20k%7D%5E%7B2%7D%3D1%0A%5Cend%7Baligned%7D%0A" /></p><p>这里我们可以加入更高的项，或者加入互作效应（X<sub>i</sub>X<sub>j</sub>）等。我们可能会添加了太多的变量，导致计算量失控。<em>support vector machines</em> 方法可以有效管控这一点。</p>
<h2 id="The-Support-Vector-Machine">The Support Vector Machine</h2>
<p>SVM 方法是上面 <em>support vector classifier</em> 方法的拓展，使用 <em>kernels</em> 方法来拓展变量空间。思路见上，但是 <em>kernels</em> 方法是一个有效的实现这个思路的计算方法。ISL 这里没有详细介绍 SVM 的算法。</p>
<p>下面这些论断全没有证明。</p>
<p><em>support vector classifier</em> 求解需要用到内积 (结果为一个标量)， 标量公式如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Clangle%20a%2C%20b%5Crangle%3D%5Csum_%7Bi%3D1%7D%5E%7Br%7D%20a_%7Bi%7D%20b_%7Bi%7D%0A" /></p><p>因此两个观测值x<sub>i</sub> ，x<sub>i’</sub> 的内积为</p>
<p style=""><img src="https://math.now.sh?from=%5Cleft%5Clangle%20x_%7Bi%7D%2C%20x_%7Bi%5E%7B%5Cprime%7D%7D%5Cright%5Crangle%3D%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20x_%7Bi%20j%7D%20x_%7Bi%5E%7B%5Cprime%7D%20j%7D%0A" /></p><p><em>support vector classifier</em> 可以表示为下式。这里有n 个参数 α<sub>i</sub>  ，每个观测值一个参数。为了估计 f(x) ，我们需要计算新点 x 和训练集中所有的点 x<sub>i</sub> 的内积。</p>
<p style=""><img src="https://math.now.sh?from=f%28x%29%3D%5Cbeta_%7B0%7D%2B%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Calpha_%7Bi%7D%5Cleft%5Clangle%20x%2C%20x_%7Bi%7D%5Cright%5Crangle%0A" /></p><p>为了估计参数 α<sub>1</sub>, …… ，α<sub>n</sub> 和 β<sub>0</sub> ，我们需要计算训练集中所有观测值之间可能的配对的内积（需要计算 C<sup>2</sup><sub>n</sub> 次）</p>
<p>实际上，大多数点的 α<sub>i</sub> 都是0，只有 <em>support vector</em> 的 α<sub>i</sub> 不为0 。因此，假定 <em>S</em> 是所有这些 <em>support points</em> 的索引的集合，我们可以将上面的解函数写成</p>
<p style=""><img src="https://math.now.sh?from=f%28x%29%3D%5Cbeta_%7B0%7D%2B%5Csum_%7Bi%20%5Cin%20%5Cmathcal%7BS%7D%7D%20%5Calpha_%7Bi%7D%5Cleft%5Clangle%20x%2C%20x_%7Bi%7D%5Cright%5Crangle%0A" /></p><p>总结一下，<em>support vector classifier</em>  方法中估计参数和求解，都是用了求<strong>内积</strong>的方法。这里我们可以把所有求内积的地方改为一个一般化的形式：</p>
<p style=""><img src="https://math.now.sh?from=K%5Cleft%28x_%7Bi%7D%2C%20x_%7Bi%5E%7B%5Cprime%7D%7D%5Cright%29%2C%0A" /></p><p>这里的 K 指某种函数，一般称为 <em>kernel</em> 。<strong><em>kernel</em> 函数是一个度量两个观测值之间的相似性的指标</strong>。例如，我们可以使用下式，这就是内积的公式，一般也称为 <em>linear kernel</em> ，因为 <em>support vector classifier</em> 方法是线性的。 <em>linear kernel</em>  实际是采用皮尔逊相关的方法来衡量观测值之间的相似性。</p>
<p style=""><img src="https://math.now.sh?from=K%5Cleft%28x_%7Bi%7D%2C%20x_%7Bi%5E%7B%5Cprime%7D%7D%5Cright%29%3D%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20x_%7Bi%20j%7D%20x_%7Bi%5E%7B%5Cprime%7D%20j%7D%0A" /></p><p>我们可以换别的 <em>kernel</em> ，例如下式，这一般称为 <em>polynomial kernel of degree d</em> ，这里 d 是一个正整数。这时候构建的决策线就不再是线性的。</p>
<p style=""><img src="https://math.now.sh?from=K%5Cleft%28x_%7Bi%7D%2C%20x_%7Bi%5E%7B%5Cprime%7D%7D%5Cright%29%3D%5Cleft(1%2B%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20x_%7Bi%20j%7D%20x_%7Bi%5E%7B%5Cprime%7D%20j%7D%5Cright)%5E%7Bd%7D%0A" /></p><p>当采用非线性的 <em>kernel</em> 时，这时便称为 <em>support vector machine</em> 。预测函数如下：</p>
<p style=""><img src="https://math.now.sh?from=f%20%28%20x%20%29%20%3D%20%5Cbeta%20_%20%7B%200%20%7D%20%2B%20%5Csum%20_%20%7B%20i%20%5Cin%20S%20%7D%20%5Calpha%20_%20%7B%20i%20%7D%20K%20(%20x%20%2C%20x%20_%20%7B%20i%20%7D%20)%0A" /></p><p>下图中的左图显示了SVM采用多项式 kernel 的效果。</p>
<p><img src="9.png" alt="1"></p>
<p>多项式 <em>kernel</em> 仅仅是其中的一个例子，另一个可选的 <em>kernel</em> 为 <em>radial kernel</em> ，形式如下。其中的 γ 为一个正数。上图中的右图就是使用了 <em>radial kernel</em> 的效果。</p>
<p style=""><img src="https://math.now.sh?from=K%20%28%20x%20_%20%7B%20i%20%7D%20%2C%20x%20_%20%7B%20i%20%5E%20%7B%20%5Cprime%20%7D%20%7D%20%29%20%3D%20%5Coperatorname%20%7B%20exp%20%7D%20(%20-%20%5Cgamma%20%5Csum%20_%20%7B%20j%20%3D%201%20%7D%20%5E%20%7B%20p%20%7D%20(%20x%20_%20%7B%20i%20j%20%7D%20-%20x%20_%20%7B%20i%20%5E%20%7B%20%5Cprime%20%7D%20j%20%7D%20)%20%5E%20%7B%202%20%7D%20)%20.%0A" /></p><p><em>radial kernel</em> 如何工作的呢？假设我们有一个验证集观测值 x<sup>*</sup> ，这个点与一个训练集的点 x<sub>i</sub>  距离很远，那么经过一个简单的数学推理，我们知道这两个点配对的 <em>radial kernel</em>  非常小，接近于0，因此这个训练集的点对这个验证集的预测几乎没有作用。</p>
<p>使用不同的 kernel 函数，相较于使用旧的特征往特征空间中添加新的特征（比如加入二次项），优势在哪里呢？一个主要的优势就是计算量的优势。</p>
<h2 id="An-Application-to-the-Heart-Disease-Data">An Application to the Heart Disease Data</h2>
<h2 id="ROC-curve">ROC curve</h2>
<p>对于一个二分类的反应变量，预测结果和真实结果比对统计如下：</p>
<p><img src="10.png" alt="1"></p>
<p><abbr title="receiver operating characteristics">ROC</abbr>  曲线是用来展现不同的阈值下两种错误的错误概率的变化。下图就是 ROC 图 ，纵坐标是 <em>sensitivity</em> /power/ 1- Type Ⅱ error，就是零假设被正确拒绝的概率（真实值为1的个体中预测值也为1的概率，结合上表为 <strong>TP/P</strong>）；横坐标为 Type Ⅰ error / <em>1-specificity</em> ，为零假设被错误拒绝的概率，即假阳性概率（真实值为0的个体中预测值为1的概率，计算公式为 <strong>FP/N</strong>）。</p>
<p><strong>ROC 可以比较预测二分类变量的不同方法的预测效果</strong>。ROC 曲线越接近左上侧越好，或者说 ROC 曲线下方的面积越大越好。</p>
<p>这里我们采用13个特征预测个体是否有心脏疾病，总共297个样本，随机挑选207个样本作为训练集，90个样本作为验证集。下图中的左图为采用 LDA 和 support vector classifier 方法的效果，二者差不多，support vector classifier 方法略有优势；右图为与采用 <em>radial kernel</em> 的 SVM 方法的比较，这里随着 γ 的增加，决策线越曲折，ROC 曲线越好。但是看清楚，这里的图是<strong>训练集的效果</strong>，会有误导作用，我们要看验证集的效果。</p>
<p><img src="11.png" alt="1"></p>
<p>下图为验证集的效果，我们左图差不多，右图 γ = 0.1 在训练集上效果最好，但是在验证集上效果最差，再一次证明模型并不是越灵活越好。</p>
<p><img src="12.png" alt="1"></p>
<h1>SVMs with More than Two Classes</h1>
<p>上面的讨论都只是针对二分类的反应变量，那么我们能不能将 SVMs 方法应用到有更多的水平的反应变量上呢？事实上 SVMs 方法基于的 <em>separating hyperplanes</em> 理念本身并不能自动地推导到多个水平的分析。目前也有很多方法将 SVMs 方法拓展到多水平反应变量的分析，最著名的两个就是 <em>one-versus-one</em> 和 <em>one-versus-all</em> 方法。</p>
<h2 id="One-Versus-One-Classification">One-Versus-One Classification</h2>
<p>假设反应变量是 K 个水平，那么我们构建 C<sub>K</sub><sup>2</sup>  次 SVMs ，每一次包含一对水平。预测的时候，我们会计算这 C<sub>K</sub><sup>2</sup> 次的预测值，然后将所有预测结果中出现频率最频繁的水平作为最终的预测值。</p>
<h2 id="One-Versus-All-Classification">One-Versus-All Classification</h2>
<p>这个方法我们拟合 K 次 SVMs，每一次比对其中一个水平（设为1）和剩下的 K-1 个水平（设为-1）。预测时，我们分配所有 SVMs 中下式最大的 SVM 的水平，因为这个式子越大，说明这个观测值属于这个水平的可行程度越高。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbeta%20_%20%7B%200%20k%20%7D%20%2B%20%5Cbeta%20_%20%7B%201%20k%20%7D%20x%20_%20%7B%201%20%7D%20%5E%20%7B%20*%20%7D%20%2B%20%5Cbeta%20_%20%7B%202%20k%20%7D%20x%20_%20%7B%202%20%7D%20%5E%20%7B%20*%20%7D%20%2B%20%5Cldots%20%2B%5Cbeta%20_%20%7B%20p%20k%20%7D%20x%20_%20%7B%20p%20%7D%20%5E%20%7B%20*%20%7D%0A" /></p><h1>Relationship to Logistic Regression</h1>
<p><em>support vector classifier</em> 的拟合条件可以重新写为</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%20%7B%20minimize%20%7D%20_%20%7B%20%5Cbeta%20_%20%7B%200%20%7D%20%2C%20%5Cbeta%20_%20%7B%201%20%7D%20%2C%20%5Cldots%20%2C%20%5Cbeta%20_%20%7B%20p%20%7D%20%7D%20%5C%7B%20%5Csum%20_%20%7B%20i%20%3D%201%20%7D%20%5E%20%7B%20n%20%7D%20%5Coperatorname%20%7B%20max%20%7D%20%5B%200%2C1%20-%20y%20_%20%7B%20i%20%7D%20f%20%28%20x%20_%20%7B%20i%20%7D%20%29%20%5D%20%2B%20%5Clambda%20%5Csum%20_%20%7B%20j%20%3D%201%20%7D%20%5E%20%7B%20p%20%7D%20%5Cbeta%20_%20%7B%20j%20%7D%20%5E%20%7B%202%20%7D%20%5C%7D%0A" /></p><p>其中 λ 是一个非负数，后面的式子就类似于岭回归的惩罚项。总的式子就是 “Loss + Penalty&quot; 的形式。这里的 Loss 项拓展开来如下：</p>
<p style=""><img src="https://math.now.sh?from=L%20%28%20X%20%2C%20y%20%2C%20%5Cbeta%20%29%20%3D%20%5Csum%20_%20%7B%20i%20%3D%201%20%7D%20%5E%20%7B%20n%20%7D%20%5Coperatorname%20%7B%20max%20%7D%20%5B%200%2C1%20-%20y%20_%20%7B%20i%20%7D%20(%20%5Cbeta%20_%20%7B%200%20%7D%20%2B%20%5Cbeta%20_%20%7B%201%20%7D%20x%20_%20%7B%20i%201%20%7D%20%2B%20%5Cldots%20%2B%20%5Cbeta%20_%20%7B%20p%20%7D%20x%20_%20%7B%20i%20p%20%7D%20)%20%5D%0A" /></p><p>这也称为 <em>hinge loss</em> 。如下图所示，SVM 的 Loss 项和逻辑回归相关程度很高。SVM 的 Loss 项还有一个特点，对于处于正确的margin 一侧的点对模型结果没有影响，这体现在下式如果大于1，那么 Loss 项就正好是 0 。但是，逻辑回归不会正好是 0 ，会是一个很小的值，同样见下图。</p>
<p style=""><img src="https://math.now.sh?from=y%20_%20%7B%20i%20%7D%20%28%20%5Cbeta%20_%20%7B%200%20%7D%20%2B%20%5Cbeta%20_%20%7B%201%20%7D%20x%20_%20%7B%20i%201%20%7D%20%2B%20%5Cldots%20%2B%20%5Cbeta%20_%20%7B%20p%20%7D%20x%20_%20%7B%20i%20p%20%7D%20%29%0A" /></p><p><img src="13.png" alt="1"></p>
<p>因此 <em>support vector classifier</em> 和 逻辑回归的结果很相似，当两个水平之间分得较开，<em>support vector classifier</em> 结果更好一点；如果两个水平之间重叠区域较多，那么逻辑回归效果更好。</p>
<p>因此在描述线性关系的过程中，SVM 和逻辑回归等经典方法是高度相关的。那么是否在描述非线性关系时 SVM 采用特殊的 <em>kernels</em> 的做法就是独一无二的呢？答案也是否定的，我们同样可以对逻辑回归或者其他经典的分类方法采用非线性的 <em>kernels</em> 。但是由于历史原因，一般 <em>non-linear kernels</em> 用于SVMs 方法比经典的逻辑回归等方法更加广泛。</p>
<p>SVM 方法的思路同样可以用于回归问题中，称为 <em><strong>support vector regression</strong></em> ，这里的 Loss 项是超过某个常数的<strong>残差绝对值</strong>之和，低于给定常数的残差绝对值则直接忽略。</p>
<h1>R代码</h1>
<p>略</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>数据分析</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Tree Based Methods</title>
    <url>/posts/7532e592/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>ISL 真是好书！</p>
<span id="more"></span> 
<h1>资料</h1>
<p><a href="https://www.statlearning.com/">An Introduction to Statistical Learning</a>，下文简称 <strong>ISL</strong></p>
<h1>概述</h1>
<p>决策树的方法对于 <em>interpretation</em> 很有用，但是它们在预测准确性上效果不是特别好。</p>
<p>决策树可以同时用于回归变量与分类变量的问题。我们先考虑回归问题，</p>
<h2 id="Regression-Trees">Regression Trees</h2>
<h3 id="Predicting-Baseball-Players’Salaries-Using-Regression-Trees">Predicting Baseball Players’Salaries Using Regression Trees</h3>
<p>我们先看一个简单的例子，我们通过回归树来预测足球运动员的收入，这里的特征是 Year (踢球的年限) 和 Hits (上一年度射中球门的数目) 。 我们先移除收入缺失的行，然后对 <em>Salary</em> 变量进行 log 转换（底为 e），使得它的分布更类似于正态分布。</p>
<p>下图表示了一个回归树的结果，它从树的根部出发。第一个分支条件使 Year &lt; 4.5 ，满足这个条件分到了左枝，这里的 5.11 是所有满足 Year &lt; 4.5 的运动员的薪资均值。以此类推。</p>
<p><img src="1.png" alt="1"></p>
<p>这里最终是把所有的运动员分成了3个子群体，如下图所示：</p>
<p><img src="2.png" alt="1"></p>
<p>我们如果用决策树的术语，这里的三个子区域 R<sub>1</sub> , R<sub>2</sub> , R<sub>3</sub> 称为 <em>terminal nodes</em> 或 <em>terminal leaves</em> 。 自变量空间被划分的那个节点称为 <em>internal nodes</em> 。在图 8.1 中，总共有2个  <em>internal nodes</em> ，Years &lt; 4.5 和 Hits &lt; 117.5 。我们把决策树上连接  <em>internal nodes</em> 的片段称为 <em>branches</em> 。</p>
<p>我们一般会这么解释图 8.1 的回归树：Years 是最重要的区分 Salary 性状的因子，年限短的运动员挣的钱少，年限长的运动员挣的钱多；如果一个远动员年限短，那么他上一年进球数对他的薪资几乎没有影响。但是如果一个运动员年限长（&gt;4.5年），那么他上一年进球数会对他的薪资造成影响，上一年进球数越多薪资越高。</p>
<p>这种回归树的图是对 Hits ,Years, Salary 三者之间关系的简化，但是它对于其他回归模型有优势，因为它容易解释，而且有可视化效果。</p>
<h3 id="Prediction-via-Stratification-of-the-Feature-Space">Prediction via Stratification of the Feature Space</h3>
<p>我们现在讨论一下构建一个回归树的过程。简单地讲，总共有两步：</p>
<ol>
<li>我们首先切分 <em>predictor space</em> — 将所有可能的值 X<sub>1</sub> , X<sub>2</sub> ，…… , X<sub>p</sub> 分成 J 个互不重叠的区域， R<sub>1</sub>,  R<sub>2</sub> , ……，R<sub>J</sub> 。</li>
<li>对于落在同一区域的观测值，我们会做相同的预测，即这个区域内所有观测值的<strong>均值</strong>。</li>
</ol>
<p>我们先看第一步，我们要如何去划分区域呢？一般我们会将各个区域划分成高维矩形，或者称为 <em>boxes</em> ，这样解释结果更简单。我们划分的目标是，找到一组 <em>boxes</em> R<sub>1</sub>,  R<sub>2</sub> , ……，R<sub>J</sub> ，使得 RSS 最小，RSS 计算见下式</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bj%3D1%7D%5E%7BJ%7D%20%5Csum_%7Bi%20%5Cin%20R_%7Bj%7D%7D%5Cleft%28y_%7Bi%7D-%5Chat%7By%7D_%7BR_%7Bj%7D%7D%5Cright%29%5E%7B2%7D%0A" /></p><p>下式为 R<sub>j</sub>  中所有观测值的均值。</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7By%7D_%7BR_%7Bj%7D%7D%0A" /></p><p>但是，我们不可能穷尽所有的划分方式，找到这个最佳的划分方法。因此我们采取一种称为 <em>recursive binary splitting</em> 的方法。这是一种 <em>top-down</em> 并且是 <em>greedy</em> 的方法，<em>top-down</em> 指从决策树的一开始的节点一直向下切分，每次生成两条新枝；<em>greedy</em> 指在每一步的切分中，所谓的最好的切分方式的决策都仅针对当前这一步，它不会往前看，面向未来，找会使得将来几步最好的切分。</p>
<p><em>recursive binary splitting</em>  方法的第一步，是选取一个特征 X<sub>j</sub> 和相应的一个断点 s ，然后将个预测因子空间切分为两部分，<strong>从而使得 RSS 减少得最多</strong>。两个子空间如下：</p>
<p style=""><img src="https://math.now.sh?from=R_%7B1%7D%28j%2C%20s%29%3D%5Cleft%5C%7BX%20%5Cmid%20X_%7Bj%7D%3Cs%5Cright%5C%7D%20%5Ctext%20%7B%20and%20%7D%20R_%7B2%7D(j%2C%20s)%3D%5Cleft%5C%7BX%20%5Cmid%20X_%7Bj%7D%20%5Cgeq%20s%5Cright%5C%7D%0A" /></p><p>这就要求需要考虑所有得预测因子  X<sub>1</sub> , X<sub>2</sub> ，…… , X<sub>p</sub>  ，以及每个预测因子上所有可能的断点，然后挑 RSS 最低的组合。RSS 计算方式如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bi%3A%20x_%7Bi%7D%20%5Cin%20R_%7B1%7D%28j%2C%20s%29%7D%5Cleft(y_%7Bi%7D-%5Chat%7By%7D_%7BR_%7B1%7D%7D%5Cright)%5E%7B2%7D%2B%5Csum_%7Bi%3A%20x_%7Bi%7D%20%5Cin%20R_%7B2%7D(j%2C%20s)%7D%5Cleft(y_%7Bi%7D-%5Chat%7By%7D_%7BR_%7B2%7D%7D%5Cright)%5E%7B2%7D%0A" /></p><p>之后我们会重复这一步，，但是这次就不是对整个预测因子空间进行切分，而是对上面的两个子空间的一个进行切分，然后我们就有了3个区域。之后我们会再找一个子空间进行切分，这个过程会一直持续，以至于满足了一个停止条件，例如直到所有区域包含不超过 5 个观测值。</p>
<p>一旦我们创建好了所有子区域，我们就可以通过计算子区域内所有观测值的均值，作为这个子区域的预测值。下图为一个 5个子区域划分的例子。</p>
<p><img src="3.png" alt="1"></p>
<h3 id="Tree-Pruning">Tree Pruning</h3>
<p>上面的划分过程可能会造成 <em>overfitting</em> ，因为划分得到的决策树过于复杂了。一个简单一些的决策树的 variance 更低，解释效果更好，但是 bias 会略有增加。<strong>一个可能的解决办法是每次切分过程 RSS 降低量必须超过某个阈值</strong>。但是这个策略的问题是短视，因为一个看上去没有意义的切分可能会带来后面的一个很好的切分，即在它后面的一个切分可能RSS降低很多。</p>
<p>因此，一个更好的策略是先生成一个非常大的决策树 T<sub>0</sub> ，然后进行删减得到一个 <em>subtree</em> 。我们如何进行删减分支呢？从目标上，我们的目的是选择一个 <em>test error rate</em> 最低的 <em>subtree</em> 。如果给定一个 <em>subtree</em>， 我们可以通过交叉验证来验证 <em>test error</em> 。但是，对于每一个可能的 <em>subtree</em> 如果都进行交叉验证，计算量就太大了。因此，我们需要一种方式事先挑出少数的一些 <em>subtree</em> 备选。</p>
<p>我们可以通过 <em>Cost complexity pruning</em> 或者称为 <em>weakest link pruning</em> 方法来实现这一点。我们通过指定参数 α 来挑出一部分 <em>trees</em> 。</p>
<p>对于每个给定的 α  值，都存在一个 <em>subtree</em> T ⊂T<sub>0</sub> ，使得下式尽可能小。</p>
<p><img src="4.png" alt="1"></p>
<p>这里的 |T| 表示 决策树 T 的 <em>terminal leaf</em> 的数量 , R<sub>m</sub> 是相应于第 m 个  <em>terminal leaf</em>  的子空间。这里就是增加了一个惩罚项，越复杂的 <em>subtree</em> 惩罚越严重，通过调控 α 来控制调控比例。我们可以先通过交叉验证得到一个合适的 α 值，然后根据这个 α 值得到相应的最佳的 <em>subtree</em> 。 这个流程如下图：</p>
<p>首先对所有训练集的个体先得到 T<sub>0</sub> 和 <em>best subtree</em>  与 α 的函数。</p>
<p>然后进行交叉验证结果选择最好的 α 值，最后根据 α 值返回第二步找到相应的 <em>best subtree</em> 。</p>
<p><img src="5.png" alt="1"></p>
<p>效果如下图，我们可以看到交叉验证结果很好地估计了 Test data error ，交叉验证最佳的  <em>terminal leaf</em>  的数目为3， 使用 test data 的结果的最佳数目为9，但是在<em>terminal leaf</em> 为3的地方有一个明显的下降。</p>
<p><img src="6.png" alt="1"></p>
<h2 id="Classification-Trees">Classification Trees</h2>
<p><em>classification trees</em> 和上面的 <em>regression trees</em> 很相似，仅仅是用于预测分类变量，将每个子空间的预测值改为出现概率最大的那个水平。</p>
<p>创建一个分类树的过程和创建回归树的过程类似。我们先用 <em>recursive binary splitting</em> 方法来创建一个分类树，但是这里不能再用 RSS 作为指标了，一般用 <em>classification error rate</em> ，即观测值和预测值（子空间中最大可能的水平）不一致的比例，公式如下：</p>
<p style=""><img src="https://math.now.sh?from=E%3D1-%5Cmax%20_%7Bk%7D%5Cleft%28%5Chat%7Bp%7D_%7Bm%20k%7D%5Cright%29%0A" /></p><p>下式为 训练集第m个子空间中属于k 水平的比例。</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7Bp%7D_%7Bm%20k%7D%0A" /></p><p>这里，E 就是这个子空间内所有观测值中不是最大可能观测值的比例。但是实际证明这个指标在划分决策树时不够敏感，因为实际我们一般会用另外两个指标。</p>
<p>第一个就是 <em>Gini index</em>,  定义为如下式，可以视为 K 个水平的总方差的衡量公式。只看查看这个式子我们不难发现，如果 p<sup>^</sup> <sub>mk</sub>  越接近于0或1，那么这个式子就越小，因此这个式子也可以视为 <em>node purity</em> 的衡量指标 - 值越小说明这个子空间的预测值越纯。</p>
<p style=""><img src="https://math.now.sh?from=G%3D%5Csum_%7Bk%3D1%7D%5E%7BK%7D%20%5Chat%7Bp%7D_%7Bm%20k%7D%5Cleft%281-%5Chat%7Bp%7D_%7Bm%20k%7D%5Cright%29%0A" /></p><p>另外一个指标就是 <em>entropy</em> ， 计算方法如下：</p>
<p style=""><img src="https://math.now.sh?from=D%3D-%5Csum_%7Bk%3D1%7D%5E%7BK%7D%20%5Chat%7Bp%7D_%7Bm%20k%7D%20%5Clog%20%5Chat%7Bp%7D_%7Bm%20k%7D%0A" /></p><p>同样地， 当  p<sup>^</sup> <sub>mk</sub>  越接近于0或1，那么这个式子就越小。实际证明这两个式子效果差不多。</p>
<p>因此创建分类树时，我们一般会用  <em>Gini index</em> 或  <em>entropy</em> 作为划分新枝的衡量标准。当我们在 <em>pruning</em> 分枝时，我们可能会不用这两个指标，而是用一开始的 <em>classfication error rate</em> ，因为最终我们的目标还是预测准确性。</p>
<p>在创建新枝的过程中，属于分类变量的特征也可以用于划分新枝，只用把其中的一些水平划给一个分支，把剩下的所有水平划给另外一个分支即可。下图即为一个分类树结果，比如这里的 Thal:a 就表示左边为 Thal 的第一个水平的观测值，右边为其他水平的观测值。</p>
<p><img src="7.png" alt="1"></p>
<h2 id="Trees-Versus-Linear-Models">Trees Versus Linear Models</h2>
<p>如果反应变量与特征之间存在明显的线性关系，那么线性回归会很合适。但是，如果反应变量与特征之间存在<strong>非线性的复杂关系</strong>，那么决策树会比那些经典方法更合适。下图就是一个很好的例子，这是一个p=2的分类问题，上方的行表示真实的决策线是线性的，不同的颜色表示不同的水平，这里明显可以看出线性模型效果更好；下方的行中真实决策线是非线性的，这里线性模型的方法无法准确预测，而决策树效果很好。</p>
<p><img src="8.png" alt="1"></p>
<h2 id="Advantages-and-Disadvantages-of-Trees">Advantages and Disadvantages of Trees</h2>
<p>决策树的优点如下：</p>
<ul>
<li>结果容易解释</li>
<li>更符合人的做决定的方式</li>
<li>可视化，不言自明</li>
<li>可以直接处理分类变量，而不用像线性模型那样转变为哑变量。</li>
</ul>
<p>缺点如下：</p>
<ul>
<li>预测准确性没有经典方法高</li>
<li>有时不够稳健，换句话说，数据稍有改变，可能最终的决策树就有一个大的改变。</li>
</ul>
<p>但是，通过使用 bagging, random forests, and boosting ，我们可以提高决策树的预测准确性。</p>
<h1>Bagging, Random Forests,  Boosting</h1>
<p>这三种方法都是使用决策树作为 <em>blocks</em>，来创建更加强大的预测模型。</p>
<h2 id="Bagging">Bagging</h2>
<p>自助法是一种强大的思路，可以计算很难计算或无法计算的因子估计值的标准误。这里我们同样可以用自助法的思想，来提高决策树的效果。</p>
<p>上面我们讨论过，决策树具有 <em>high variance</em> 的缺点，这表明如果我们随机将训练集拆分成两部分，然后对每一部分拟合决策树，我们可能会得到两个完全不同的结果。<em>Bootstrap aggregation</em>，或称为 <em>bagging</em> 方法是一种通用的降低统计方法方差的流程，它对决策树非常有用。</p>
<p>假设我们有一个 n 个独立的观测值的数据集 Z<sub>1</sub>,……, Z<sub>n</sub> ，观测值的方差为 σ<sup>2</sup> ，那么观测值均值的方差为 σ<sup>2</sup> / n 。也就是所，对多个数据集求均值可以降低方差。因此一个降低方差，提高预测准确性的方法就是<strong>用多个训练集</strong>单独进行模型拟合，最终对所有模型的预测值求均值。比如我们得到了 B 个单独的拟合模型，最终模型的预测值如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7Bf%7D_%7B%5Ctext%20%7Bavg%20%7D%7D%28x%29%3D%5Cfrac%7B1%7D%7BB%7D%20%5Csum_%7Bb%3D1%7D%5E%7BB%7D%20%5Chat%7Bf%7D%5E%7Bb%7D(x)%0A" /></p><p>但是，这在实际中并不可行，因为我们不可能得到很多个训练集。因此，我们可以使用自助法作为替代方法，从一个训练集中有返回地重复抽样，最终生成B个不同的自助法的训练集。代入上式，得到最终的统计模型。这种方法称为 <em>bagging</em>。</p>
<p><em>Bagging</em> 方法可以显著提高很多回归方法的预测效果，它同样对于决策树也很有用。我们可以用这 B 个自助法训练集来创建 B 个决策树，这些决策树是最深的，没有进行删减。因此这些决策树偏差很小，方差很高。我们通过对这 B 个决策树进行求均值，可以降低方差。</p>
<p>对于反应变量是质量性状的情况，我们可以对这B个决策树的预测结果取 <em>majority vote</em> （占比最高的水平）。</p>
<p>下图中的横坐标为自助法抽样次数，纵坐标为 test error ，这里的黑线就是自助法的结果，黑色虚线是原始结果，我们可以看到自助法没有随着抽样次数的增加出现 <em>overfitting</em> 的问题。实际上，这里 B = 100 就已经够用了。</p>
<p><img src="9.png" alt="1"></p>
<h3 id="自助法究竟是如何用到决策树上？">自助法究竟是如何用到决策树上？</h3>
<p>自助法的思路用到线性回归上，这个流程很容易理解，就是把 B 次估计的系数求均值，就得到了最终使用的模型。推导如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Chat%7Bf%7D_%7B%5Ctext%20%7Bavg%20%7D%7D%28x%29%20%26%3D%20%5Cfrac%7B%5Csum_%7Bk%3D1%7D%5E%7BK%7D%20(a_%7Bk%7Dx%2Bb_%7Bk%7D)%7D%7Bn%7D%20%5C%5C%0A%26%3D%20%5Cfrac%7B(%5Csum_%7Bk%3D1%7D%5E%7BK%7Da_%7Bk%7D)%7D%7Bn%7Dx%20%2B%20%5Cfrac%7B(%5Csum_%7Bk%3D1%7D%5E%7BK%7Db_%7Bk%7D)%7D%7Bn%7D%20%5C%5C%0A%26%3D%20%5Cbar%7Ba%7Dx%2B%5Cbar%7Bb%7D%20%5C%5C%0A%5Cend%7Baligned%7D%0A" /></p><p>但是决策树不是每一次分枝情况都不一样吗？这个最终的模型到底是如何构建的呢？没有说清楚。</p>
<h3 id="Out-of-Bag-Error-Estimation">Out-of-Bag Error Estimation</h3>
<p><em>Bagging</em> 方法有一个直接的估计 test error 的方式，不需要使用交叉验证或者验证集方法。 每个自助集的决策树平均只用了 2/3 的观测值。剩下的没有用到的 1/3 的观测值称为 <em>out-of-bag</em> (OOB) observations。我们可以用当这个观测值为OOB的决策树来预测这个观测值的结果，因此针对某个观测值，我们可以得到差不多 B/3 个预测值。为了获得一个单独的预测值，我们可以对这接近B/3 个预测值求均值，这样每一个观测值都可以得到一个 OOB 预测值，然后我们就可以计算 OOB MSE (反应变量为连续变量) 或者 claffication error (反应变量为分类变量)。实际证明，OOB error 是一个有效地估计 test error 的统计量。如果 K 足够大，那么OOB error 其实就接近于 LOOCV error 。</p>
<h3 id="Variable-Importance-Measures">Variable Importance Measures</h3>
<p>bagging 方法可以增加预测准确性，但是缺点在于<strong>最终的统计模型难以解释</strong>。然而决策树的优势就在于可视化和易于解释。但是 bagging 的结果最终无法显示为一个决策树的可视化结果，也无法显示哪些特征很重要，哪些特征无关紧要。因此，<strong>bagging 方法提高了预测准确性，其代价就是降低了模型解释性</strong>。</p>
<p>但是我们可以通过 RSS 或 Gini index 来或者所有特征的重要性。例如针对一个 bagging regression trees，我们可以获取所有B个决策树中因为基于某个特征的切分造成的 RSS 的下降值，并求均值。如果这个值很大，说明这个特征很重要。下图为特征重要性的可视化，我们把最重要的特征视为100%，然后其他特征与最重要的特征进行比较。</p>
<p><img src="10.png" alt="1"></p>
<h2 id="Random-Forests">Random Forests</h2>
<p>随机森林对于 bagging 方法做了一些调整，实现了 <em>decorrelates the trees</em> （降低多次抽样的决策树之间的相关性）。就像 bagging 方法，随机森林方法同样会用自助法的思想，创建出多个训练集，然后拟合多个决策树。仅仅是在拟合决策树的过程中，随机森林方法不再使用所有 p 个特征，而是随机抽样挑选 m 个特征用于拟合决策树。一般来说，m 一般设定为约等于  √p 。</p>
<p>举个例子，加入在数据集中有一个效果非常强的特征，其他特征只有中等效果。因此，在 bagging 方法创建的众多决策树中，大部分或所有的决策树都会用这个最重要的特征作为第一次切分的特征。因此，所有的决策树看上去都很像。不幸地是，<strong>对高度相关的连续变量求均值无法起到大幅度降低方差的作用</strong>。因此，这到这 bagging 方法降低方差的作用可能不是很大。</p>
<p>随机森林方法通过每次都只用一小部分特征来构建决策树克服了这个问题，例如这个例子中，我们大概有 (p-m)/p  的比例的决策树中没有这个最重要的特征，因此其他的特征可以有机会体现作用。我们可以认为这个过程降低了决策树之间的相关，因此对这些决策树求均值的方差更低，结果更可靠。</p>
<p>因此，bagging 和 随机森林的最大区别在于如何选择 m 的大下。如果随机森林选择 m = p，那么这时就是 bagging 方法。上图8.8中显示，随机森林方法相较于bagging方法，test error 和 OOB error 均更低，说明随机森林方法更佳。</p>
<p>当我们有<strong>数目很多的</strong>并且<strong>彼此存在相关的</strong>特征时，随机森林方法提升效果更好。这里举个例子，假如我们有 349个个体的 4718 个基因的表达量。在这个数据集中，反应变量是一个15个水平的分类变量：要么是正常，要么就是 1-14 种不同类型的癌症。我们随机将数据分为训练集和验证集，然后挑出训练集中方差最大的 500 个基因，我们的目的是用随机森林的方法使用这500个基因预测个体的癌症类型，其中我们采用了三个不同的 m 值。下图为结果显示，其中一次决策树的 test error rate 是 45.7% 。我们可以看到 m = √p 的效果比 bagging （m=p）效果略好。类似于 bagging，随着 B 的增加，随机森林不会出现 overfit 的情况，因此实际情况中，挑选的B值 只要使得 test error 稳定下来即可。</p>
<p><img src="11.png" alt="1"></p>
<h2 id="Boosting">Boosting</h2>
<p><em>Boosting</em> 方法类似于 <em>Bagging</em> 方法，是一种可以应用在多种统计学习模型中的一般方法。这里仅讨论 <em>Boosting</em> 方法在决策树上的应用。</p>
<p><em>Boosting</em> 方法也是创建多个决策树，最终综合所有决策树的结果。但是这里不再使用自助法生成训练集，而是<strong>相继</strong>创建训练集：每一个决策树都会用到上一个决策树的数据。</p>
<p>传统的决策树容易 <em>fitting the data hard</em> ，从而造成 <em>overfitting</em> 。但是 <em>Boosting</em> 方法 <em>learns slowly</em> 。除了第一次创建决策树，之后创建决策树的过程都是使用上一步的<strong>残差</strong>。算法过程如下：</p>
<p><img src="12.png" alt="1"></p>
<p>d 决定每一次决策树的 <em>teminal nodes</em> 的数目；λ 参数用于降低学习速度。一般来说，<em>learn slowly</em> 的统计学习模型效果更好。</p>
<p>对于反应变量是分类变量的流程，ISL 没讲。</p>
<p><em>Boosting</em> 方法有3个参数：</p>
<ul>
<li>The number of trees B.  这里不像 bagging 和 random forests 方法，当 B 很大时，boosting 方法可能会出现 <em>overfitting</em> 现象（虽然过拟合增加的效果很缓慢），所以一般会通过交叉验证选择一个合适的 B 值。</li>
<li>The shrinkage parameter λ. 这是一个很小的正数，控制每一步学习的速度。一般会采用 0.01 或 0.001 。 λ 值越小，B 要求越大。</li>
<li>The number d of splits in each tree. 这控制每一步的决策树的复杂度。一般选择 d=1，因此这样每个决策树只有一次切分。最终的模型是可加的，因为每一步的决策树都只包含了一个特征。</li>
</ul>
<p>下图为 15个水平的癌症基因表达量数据集使用 boosting 的效果。我们可以 d=1 的效果比 d=2 和随机森林的效果都好。一般来说，d=1 效果就可以了，唯一问题在于可能需要增加B的数目，但是在对模型的解释性上很好，因为最终的模型是一个加性模型。</p>
<p><img src="13.png" alt="1"></p>
<h1>R 代码</h1>
<p>略</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>数据分析</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Generalized Additive Models</title>
    <url>/posts/c49e8948/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>ISL 真是好书！</p>
<span id="more"></span> 
<h1>资料</h1>
<p><a href="https://www.statlearning.com/">An Introduction to Statistical Learning</a>，下文简称 <strong>ISL</strong></p>
<h1>概述</h1>
<p>标准的线性回归模型，最大的问题在于线性的假设。实际情况中，这个假设可能不被满足。</p>
<p>这一章节是描述非线性关系的模型。</p>
<h1>Polynomial Regression</h1>
<p>多项式回归模型如下：</p>
<p style=""><img src="https://math.now.sh?from=y_%7Bi%7D%3D%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20x_%7Bi%7D%2B%5Cbeta_%7B2%7D%20x_%7Bi%7D%5E%7B2%7D%2B%5Cbeta_%7B3%7D%20x_%7Bi%7D%5E%7B3%7D%2B%5Cldots%2B%5Cbeta_%7Bd%7D%20x_%7Bi%7D%5E%7Bd%7D%2B%5Cepsilon_%7Bi%7D%0A" /></p><p>一半来说，最高项一般设置为3或4，因为如果项数太高，那么可能会得到非常奇怪的图形。</p>
<p>下图中的左图为项数为4的多项式回归。</p>
<p><img src="1.png" alt="1"></p>
<p>虚线为两个标准误差曲线，或者说置信区间的上下限。这是如何得到的呢？假设我们计算得到某个点 x<sub>0</sub> 的预测值，如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7Bf%7D%5Cleft%28x_%7B0%7D%5Cright%29%3D%5Chat%7B%5Cbeta%7D_%7B0%7D%2B%5Chat%7B%5Cbeta%7D_%7B1%7D%20x_%7B0%7D%2B%5Chat%7B%5Cbeta%7D_%7B2%7D%20x_%7B0%7D%5E%7B2%7D%2B%5Chat%7B%5Cbeta%7D_%7B3%7D%20x_%7B0%7D%5E%7B3%7D%2B%5Chat%7B%5Cbeta%7D_%7B4%7D%20x_%7B0%7D%5E%7B4%7D%20%5Ctext%20%7B%20.%20%7D%0A" /></p><p>那么这个点的预测值的方差等于多少呢？我们通过最小二乘法可以得到所有估计系数的估计方差，我们可以根据这个计算预测值的估计方差，计算方式如下图（ISL 的引用，没说清楚，没有证明）。</p>
<p><img src="2.png" alt="1"></p>
<p>我们可以通过这种方法以<strong>逐点</strong>地方式得到所有点的预测方差（开方即可得到标准误估计值），所有点的预测值 + 两倍的标准误即为上方的误差曲线，所有点的预测值 - 两倍的标准误即为下方的误差曲线（2倍的标准误范围正好是95%的置信区间，实际是1.96，差不多）。</p>
<p>从上面左图可以看出，Wage 这个性状似乎分成了截然分开的两个群体，一部分人的薪资超过了 250,000 美元/年；然后其他人就是低收入群体。因此，Wage 其实可以变成一个二分类的分类变量。这里我们用多项式逻辑回归用于预测薪资大于 250,000 美元/年 的概率。预测结果见上面右图，我们可以看到右侧的置信区间非常大。虽然这里总的样本量很大（n=3000），但是这里其实只有 79个 高收入者，这导致系数估计的方差很高，最终预测结果的置信区间也很大。</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BPr%7D%5Cleft%28y_%7Bi%7D%3E250%20%5Cmid%20x_%7Bi%7D%5Cright%29%3D%5Cfrac%7B%5Cexp%20%5Cleft(%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20x_%7Bi%7D%2B%5Cbeta_%7B2%7D%20x_%7Bi%7D%5E%7B2%7D%2B%5Cldots%2B%5Cbeta_%7Bd%7D%20x_%7Bi%7D%5E%7Bd%7D%5Cright)%7D%7B1%2B%5Cexp%20%5Cleft(%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20x_%7Bi%7D%2B%5Cbeta_%7B2%7D%20x_%7Bi%7D%5E%7B2%7D%2B%5Cldots%2B%5Cbeta_%7Bd%7D%20x_%7Bi%7D%5E%7Bd%7D%5Cright)%7D%0A" /></p><h1>Step Functions</h1>
<p>上面的多项式回归是对整个定义域进行拟合，我们可以用 <em>step functions</em> 来把整个定义域分段，对于每一段进行单独的估计，这就将一个连续自变量转变成了一个 <em>ordered categorical variable</em> 。</p>
<p>更详细地说，我们会在整个定义域创建 K 个断点 (c<sub>1</sub> , c<sub>2</sub> , …… ， c<sub>k</sub>) ，创建 K+1 个新的变量。其中 <code>I()</code> 函数满足条件则为1，不满足条件则为0，因此这 K+1 个新变量中永远只有一个变量的值为1，其他均为0，一般也称为 <strong>哑变量</strong>。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0AC_%7B0%7D%28X%29%20%26%3DI%5Cleft(X%3Cc_%7B1%7D%5Cright)%20%5C%5C%0AC_%7B1%7D(X)%20%26%3DI%5Cleft(c_%7B1%7D%20%5Cleq%20X%3Cc_%7B2%7D%5Cright)%2C%20%5C%5C%0AC_%7B2%7D(X)%20%26%3DI%5Cleft(c_%7B2%7D%20%5Cleq%20X%3Cc_%7B3%7D%5Cright)%2C%20%5C%5C%0A%26%20%5Cvdots%20%5C%5C%0AC_%7BK-1%7D(X)%20%26%3DI%5Cleft(c_%7BK-1%7D%20%5Cleq%20X%3Cc_%7BK%7D%5Cright)%2C%20%5C%5C%0AC_%7BK%7D(X)%20%26%3DI%5Cleft(c_%7BK%7D%20%5Cleq%20X%5Cright)%0A%5Cend%7Baligned%7D%0A" /></p><p>我们可以用后面 k个哑变量作为预测因子，拟合回归模型</p>
<p style=""><img src="https://math.now.sh?from=y_%7Bi%7D%3D%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20C_%7B1%7D%5Cleft%28x_%7Bi%7D%5Cright%29%2B%5Cbeta_%7B2%7D%20C_%7B2%7D%5Cleft(x_%7Bi%7D%5Cright)%2B%5Cldots%2B%5Cbeta_%7BK%7D%20C_%7BK%7D%5Cleft(x_%7Bi%7D%5Cright)%2B%5Cepsilon_%7Bi%7D%0A" /></p><p>对于某个特定的自变量 x，这k个哑变量最多只有一个不为0。比如如果 x &lt; c<sub>1</sub> ，那么所有的预测因子全是0，因此预测值就是 β<sub>0</sub> 。其他 x 值依次类推。</p>
<p>同样，我们可以使用 <em>step functions</em> 进行逻辑回归</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BPr%7D%5Cleft%28y_%7Bi%7D%3E250%20%5Cmid%20x_%7Bi%7D%5Cright%29%3D%5Cfrac%7B%5Cexp%20%5Cleft(%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20C_%7B1%7D%5Cleft(x_%7Bi%7D%5Cright)%2B%5Cldots%2B%5Cbeta_%7BK%7D%20C_%7BK%7D%5Cleft(x_%7Bi%7D%5Cright)%5Cright)%7D%7B1%2B%5Cexp%20%5Cleft(%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20C_%7B1%7D%5Cleft(x_%7Bi%7D%5Cright)%2B%5Cldots%2B%5Cbeta_%7BK%7D%20C_%7BK%7D%5Cleft(x_%7Bi%7D%5Cright)%5Cright)%7D%0A" /></p><p>下图左边是线性回归的 <em>step functions</em> 效果，右边为逻辑回归的效果。</p>
<p><img src="3.png" alt="1"></p>
<p>**不幸的是，除非因变量X本身存在自然断点，<em>step function</em> 效果一般不好。**举例而言，上图左图一开始的区间没有体现出wage 随 age 递增的趋势。</p>
<h1>Basis Functions</h1>
<p>多项式回归与分段回归其实都是 <em>basis function</em> 方法的特例。<em>basis function</em> 的思路是通过一些熟悉的函数/转换应用到自变量 X 上：b<sub>1</sub>(X), b<sub>2</sub>(X), …… ，b<sub>k</sub>(X) 。</p>
<p>因此，我们用下面的模型，替换正常的包含X变量的线性模型：</p>
<p style=""><img src="https://math.now.sh?from=y_%7Bi%7D%3D%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20b_%7B1%7D%5Cleft%28x_%7Bi%7D%5Cright%29%2B%5Cbeta_%7B2%7D%20b_%7B2%7D%5Cleft(x_%7Bi%7D%5Cright)%2B%5Cbeta_%7B3%7D%20b_%7B3%7D%5Cleft(x_%7Bi%7D%5Cright)%2B%5Cldots%2B%5Cbeta_%7BK%7D%20b_%7BK%7D%5Cleft(x_%7Bi%7D%5Cright)%2B%5Cepsilon_%7Bi%7D%0A" /></p><p>这里的 <em>basis function</em> 除了多项式和分段函数外，还有其他选择，比如下面的 <em>regression splines</em> 。</p>
<h1>Regression Splines</h1>
<h2 id="Piecewise-Polynomials">Piecewise Polynomials</h2>
<p>分段多项式回归对不同的自变量X的区段进行拟合。例如一个分段三次项回归的模型如下：</p>
<p style=""><img src="https://math.now.sh?from=y_%7Bi%7D%3D%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20x_%7Bi%7D%2B%5Cbeta_%7B2%7D%20x_%7Bi%7D%5E%7B2%7D%2B%5Cbeta_%7B3%7D%20x_%7Bi%7D%5E%7B3%7D%2B%5Cepsilon_%7Bi%7D%0A" /></p><p>这里不同区段会拟合得到不同的 β<sub>0</sub> 等系数。系数发生改变的点称为 <em>knots</em>。例如只有一个断点 c 的分段多项式回归模型如下：</p>
<p style=""><img src="https://math.now.sh?from=y_%7Bi%7D%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bll%7D%0A%5Cbeta_%7B01%7D%2B%5Cbeta_%7B11%7D%20x_%7Bi%7D%2B%5Cbeta_%7B21%7D%20x_%7Bi%7D%5E%7B2%7D%2B%5Cbeta_%7B31%7D%20x_%7Bi%7D%5E%7B3%7D%2B%5Cepsilon_%7Bi%7D%20%26%20%5Ctext%20%7B%20if%20%7D%20x_%7Bi%7D%3Cc%20%5C%5C%0A%5Cbeta_%7B02%7D%2B%5Cbeta_%7B12%7D%20x_%7Bi%7D%2B%5Cbeta_%7B22%7D%20x_%7Bi%7D%5E%7B2%7D%2B%5Cbeta_%7B32%7D%20x_%7Bi%7D%5E%7B3%7D%2B%5Cepsilon_%7Bi%7D%20%26%20%5Ctext%20%7B%20if%20%7D%20x_%7Bi%7D%20%5Cgeq%20c%0A%5Cend%7Barray%7D%5Cright.%0A" /></p><p>如果 <em>knots</em> 很多，整个模型的 <em>flexibility</em> 会很高，这时候对于每个区段，我们可能不用多项式回归，而是直接用线性回归。例如，上面的 <em>step function</em>s 其实就是这里 自由度为 0 的一个特例。</p>
<p>下图 7.3 中左上角的图就是一个 <em>knot</em> 的分段三次项回归结果，我们看到有一个问题，整个函数不是连续的（两个分段的模型在断点的预测值不同）。由于每个分段的模型有 4 个参数，因此这里我们整个模型有8个参数，自由度为 8 。</p>
<p><img src="4.png" alt="1"></p>
<h2 id="Constrains-and-Splines">Constrains and Splines</h2>
<p>为了避免上面这个问题，我们可以加一个限制条件，就是最终拟合的函数必须是连续的，即两个分段函数在断点的值是相同的。上图 7.3 右上方就是加了这个限制条件的结果，效果更好了，但是总的函数在断点处呈现 v 字型，这看上去不自然。在左下图中又加了两个限制条件，断点两侧两个函数的<strong>一级导数</strong>和<strong>二级导数</strong>是连续的，因此整个函数更加 <em>smooth</em> 。我们每增加一个限制条件，就会减少一个自由度。因此左下方拟合函数的自由度为 5 （3个限制条件，8-3=5），一般也称为 <em><strong>cubic spline</strong></em> 。一般来说，K 个断点的 <em>cubic spline</em> 的总体自由度为 4+K 。</p>
<p>图 7.3 的右下图是 <em>linear spline</em> 的结果，它在断点是连续的。一般来说 <em>degree-d spline</em> 定义为分段的 自由度为d 的 多项式回归（最高项为 d），并且在每个断点追到到 d-1 自由度的导数都是连续的。因此，<em>linear spline</em> 只要求断点是连续的。</p>
<h2 id="The-Spline-Basis-Representation">The Spline Basis Representation</h2>
<p>上面讨论的 <em>regression splines</em> 看上去有点复杂，我们还是可以通过 <em>basis functions</em> 来带入模型，将上面的 <em>cubic splines</em> 表示为</p>
<p style=""><img src="https://math.now.sh?from=y_%7Bi%7D%3D%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20b_%7B1%7D%5Cleft%28x_%7Bi%7D%5Cright%29%2B%5Cbeta_%7B2%7D%20b_%7B2%7D%5Cleft(x_%7Bi%7D%5Cright)%2B%5Ccdots%2B%5Cbeta_%7BK%2B3%7D%20b_%7BK%2B3%7D%5Cleft(x_%7Bi%7D%5Cright)%2B%5Cepsilon_%7Bi%7D%2C%0A" /></p><p>这里可以有多种 <em>basis functions</em> 来描述 <em>cubic splines</em> ，最直接的方法就是从基础的三次型多项式出发 - x, x<sup>2</sup>, x<sup>3</sup>， 然后对于每个 <em>knot</em> 增加一个 <em>truncated power basis function</em> 。</p>
<p><em>truncated power basis function</em> 定义如下：</p>
<p style=""><img src="https://math.now.sh?from=h%28x%2C%20%5Cxi%29%3D(x-%5Cxi)_%7B%2B%7D%5E%7B3%7D%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bcl%7D%0A(x-%5Cxi)%5E%7B3%7D%20%26%20%5Ctext%20%7B%20if%20%7D%20x%3E%5Cxi%20%5C%5C%0A0%20%26%20%5Ctext%20%7B%20otherwise%20%7D%0A%5Cend%7Barray%7D%5Cright.%0A" /></p><p>这里的 ξ 就是 knot 。新增这一项只会导致三级导数不连续（一级导数和二级导数左右两侧都是0，而三级导数左侧是0，右侧是6）</p>
<p>换句话说，对于一个有 K 个 <em>knots</em> 的 <em>cubic spline</em> ，我们的回归模型中除了截距外，还有 K+3 个自变量，分别为</p>
<p style=""><img src="https://math.now.sh?from=X%2CX%5E%7B2%7D%2CX%5E%7B3%7D%2C%20h%5Cleft%28X%2C%20%5Cxi_%7B1%7D%5Cright%29%2C%20h%5Cleft(X%2C%20%5Cxi_%7B2%7D%5Cright)%E2%80%A6%E2%80%A6%20h%5Cleft(X%2C%20%5Cxi_%7Bk%7D%5Cright)%2C%0A" /></p><p>因此，总共需要估计的参数是 K+4 个（加截距），因此总的自由度为 K+4 。</p>
<p>不幸地是，<em>splines</em> 针对外围的预测值（X 值很小或很大）会有很高的 variance 。下图显示了 3 个 <em>knots</em> 的结果，我们可以看到两个边界的置信区间明显更大。</p>
<p>下图中的 <em>natural spline</em> 是含有额外的 <em>boundary constraints</em> （函数要求在 boundary 处是线性的（boundary 指比最小的knot还要小，或比最大的 knot 还要大的区域））的 regression spline 。 <em>natural spline</em> 显示为红线。</p>
<p><img src="5.png" alt="1"></p>
<h2 id="Choosing-the-Number-and-Locations-of-the-Knots">Choosing the Number and Locations of the Knots</h2>
<p>当我们执行 spline 算法时，我们应该在哪里安置 <em>knots</em> 呢？一般来说，变化大的区域安放的 <em>knots</em> 更多，变化小的区域放得少比较合理，但是实际情况一般是，先获取需要安放的 <em>knots</em> 数目，然后按照自变量的百分位点进行选取 <em>knots</em> 。</p>
<p>下图展示了一个例子，使用 <em>natural cubic spline</em> 进行拟合数据，<em>knots</em> 的位置在 age 自变量的 25th, 50th, 75th 分位点。这里总共有4个自由度<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="这里包括两个边界点，其实总共是 5 个 *knots* 。正常的 cubic spline 的自由度为 5+4 =9，但是由于 natural cubic spline 在两个边界处有线性限制，因此自由度为 9-4 = 5。下面怎么从5个自由度视为4个自由度没看懂，原话为：Since this includes a constant, which is absorbed in the intercept,we count it as four degrees of freedom.">[1]</span></a></sup>。</p>
<p><img src="6.png" alt="1"></p>
<p>那么我们需要使用多少个 knots 呢？或者说我们的 spline 中的自由度应该是多少呢？一个选项是变量不同数目的 knots，然后看哪一种生成的拟合曲线最好。一个更客观的方法是使用交叉验证，计算所有test sets 的 test RSS 均值。下图显示为10倍交叉验证的结果，左边为 <em>natural splines</em> ，右图为 <em>cubic splines</em> ，可以看到这两种方法结果差不多。</p>
<p><img src="7.png" alt="1"></p>
<h2 id="Comparison-to-Polynomial-Regression">Comparison to Polynomial Regression</h2>
<p>Regression spines 通常效果比普通的多项式回归更好。因为多项式回归是通过增加最高项的次数来增加模型的复杂性（例如，X<sup>15</sup>），但是 splines 则是通过增加 <em>knots</em> 的数目来实现这一点，一般来说 splines 结果更稳定。下图为自由度同样为15 的 <em>natural cubic spline</em> 和 多项式回归的结果，可以看出多项式回归在边界处的结果比较诡异。</p>
<p><img src="8.png" alt="1"></p>
<h1>Smoothing Splines</h1>
<p>上面提到的 <em>regression splines</em> 是通过创建 <em>knots</em> 的方式，通过 <em>basis functions</em> ，最终可以应用最小二乘回归来计算系数。这里介绍一种不一样的创建曲线的方式。</p>
<p>在对一个数据集拟合成一条平滑曲线的过程中，我们实际想要做的是，找到某个函数，比如说是 g(x)，可以有效地拟合训练集的数据：即 RSS 很小。但是存在一个问题在于，如果对于 g(x) 不加任何限制，我们最终一定可以选择一个 g(x) 函数，使得RSS 等于 0 ，这就会出现 overfitting ，这个函数也会非常地 <em>flexible</em> 。</p>
<p>所以，我们真正想要地函数是，既满足 RSS 很小，同时很<strong>平滑</strong>（<em>smooth</em>）。</p>
<p>那么我们如何确保 g() 函数是平滑的呢？这里有很多方法可以实现这一点。一个自然的方法是找到一个 g() 函数，使得下式最小：</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28y_%7Bi%7D-g%5Cleft(x_%7Bi%7D%5Cright%29%5Cright)%5E%7B2%7D%2B%5Clambda%20%5Cint%20g%5E%7B%5Cprime%20%5Cprime%7D(t)%5E%7B2%7D%20d%20t%0A" /></p><p>这里 λ 是一个非负的调整参数。满足这个条件的 g() 函数一般称为 <em>smoothing spline</em> 。</p>
<p>这个式子其实是 “Loss + Penalty&quot; 的形式，就和 lasso/ 岭回归一样。这里的惩罚项时二阶导数的积分。粗略地说，一个函数的二阶导数衡量了函数的 <em>roughness</em> ：二阶导数越大， g(t) 在接近 t 的波动越大，反之则相反（直线的二阶导数是0，因此认为是 <em>perfectly smooth</em> ）。惩罚项是二阶导数的积分，也就是整个定义域内一阶导数的总的变化大小。如果 g() 函数非常平滑，那么这个惩罚项会很小，反而如果 g() 函数是 <em>jumpy  and variable</em> , 那么 g’(t) 变化会很显著，惩罚项会很大。</p>
<p>当 λ = 0，那么就没有惩罚效应，因此 g() 函数会非常曲折，可以完美解释 training set 中所有的观测值。如果 λ → ∞ ，那么 g() 函数会非常平滑，就是一条直线，实际上这时候 g() 函数就是最小二乘回归直线。</p>
<p>通过这种方法得到的 g(x) 函数有下面的特性：它是分段三项式回归，其中的 knots 式所有的 x 值 (x<sub>1</sub>, ……, x<sub>n</sub>)，而且每个 knot 的一阶导数和二阶导数都是连续的。另外，g(x) 是一个 <em>natural cubic spline</em> ，但是这里的 <em>natural</em> 是一种 <em>shrunken version</em> ，这里通过调整 λ 值来控制 shrinkage 的水平。</p>
<h2 id="Choosing-the-Smoothing-Parameter-λ">Choosing the Smoothing Parameter λ</h2>
<p>由于这里得到的曲线的 knots 是所有的数据点。因此这里不需要考虑挑 <em>knots</em> 的问题，只需要考虑选一个合适的 λ 值。我们很容易想到的方法就是交叉验证。结果证明<strong>留一法</strong>交叉验证（LOOCV）在这里的计算效率很高，就和只拟合一次模型的计算量差不多大，使用公式如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BRSS%7D_%7Bc%20v%7D%28%5Clambda%29%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(y_%7Bi%7D-%5Chat%7Bg%7D_%7B%5Clambda%7D%5E%7B(-i)%7D%5Cleft(x_%7Bi%7D%5Cright)%5Cright)%5E%7B2%7D%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%5B%5Cfrac%7By_%7Bi%7D-%5Chat%7Bg%7D_%7B%5Clambda%7D%5Cleft(x_%7Bi%7D%5Cright)%7D%7B1-%5Cleft%5C%7B%5Cmathbf%7BS%7D_%7B%5Clambda%7D%5Cright%5C%7D_%7Bi%20i%7D%7D%5Cright%5D%5E%7B2%7D%0A" /></p><p>这里其实是用所有数据拟合模型的预测值代替了留一法拟合模型的预测值，因此不再需要拟合 n 次模型。前面也有提到了最小二乘回归的留一法也有一个类似的公式，如下（分母多了 leverage）。这可以用于 <em>regression splines</em> 中。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BCV%7D_%7B%28n%29%7D%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(%5Cfrac%7By_%7Bi%7D-%5Chat%7By%7D_%7Bi%7D%7D%7B1-h_%7Bi%7D%7D%5Cright)%5E%7B2%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=h_%7Bi%7D%3D%5Cfrac%7B1%7D%7Bn%7D%2B%5Cfrac%7B%5Cleft%28x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright%29%5E%7B2%7D%7D%7B%5Csum_%7Bi%5E%7B%5Cprime%7D%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%5E%7B%5Cprime%7D%7D-%5Cbar%7Bx%7D%5Cright)%5E%7B2%7D%7D%0A" /></p><p>下图显示了 <em>smoothing spline</em> 的结果：红线的自由度为16 的结果，蓝线为 LOOCV 挑出的最佳自由度（6.8）的结果。我们可以从预测结果来看，二者相差不大，但是蓝线更平滑，而且效果差不多时我们一般会使用更简单的模型。</p>
<p><img src="9.png" alt="1"></p>
<h1>Local Regression</h1>
<p><strong>局部线性回归</strong>是另外一种拟合非线性关系的方法，这种方法仅仅是目标值 x<sub>0</sub> 附近的点来拟合模型。下图指出了两个点的拟合情况，其中蓝线为生成这些数据的整数函数，橘色线是局部线性回归得到的函数。</p>
<p><img src="10.png" alt="1"></p>
<p>每一个点的拟合过程算法如下。</p>
<p><img src="11.png" alt="1"></p>
<p>在第3步中，不同 x 值的权重 K<sub>i0</sub> 都是不一样的。因此，每一个点的加权最小二乘回归模型都是不一样的，因为用到的点和权重都不一样。局部线性回归有时又称为 <em>memory-based</em> procedure ，因为就像 KNN 算法一样，预测每个点时我们都需要用到全部训练集的数据。</p>
<p>在执行局部线性回归的过程中，我们需要做很多决定，比如如何定义权重函数 K ？是拟合成直线、常数还是二次项回归？还有一个最重要的，如何决定 <em>span</em> s ?  这里 span 的作用就像 smoothing splines 中的 λ 值，它控制着拟合的 <em>flexibility</em> ，这里我们同样可以用交叉验证来决定 s 的大小。下图展示了 s = 0.7 和 0.2 的拟合效果，我们可以看到 s = 0.7 拟合的曲线更加平滑。</p>
<p><img src="12.png" alt="1"></p>
<p>局部线性回归的思路可以推广到别的地方。比如在有多个自变量的数据集中，一个有用的思路是拟合一个多重线性回归模型，其中一些变量是全局的，一些则是局部的。</p>
<h1>Generalized Additive Models</h1>
<p>在前面提到的方法中，我们都是针对一个自变量 X 对 因变量 Y 的预测，可以视为简单线性回归的拓展。这里我们探索多个预测因子的非线性问题，可以视为多重线性回归的拓展。</p>
<p><em>Generalized additive models</em> (GAMs) 扩展了标准的线性模型，可以允许非线性函数，但是仍保留 <em>additivity</em> 。就像线性模型一样，GAMs 既可以用于数量性状的反应变量，也可以用于质量性状的反应变量。</p>
<h2 id="GAMs-for-Regression-Porblems">GAMs for Regression Porblems</h2>
<p>一个标准的多重线性模型如下：</p>
<p style=""><img src="https://math.now.sh?from=y_%7Bi%7D%3D%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20x_%7Bi%201%7D%2B%5Cbeta_%7B2%7D%20x_%7Bi%202%7D%2B%5Ccdots%2B%5Cbeta_%7Bp%7D%20x_%7Bi%20p%7D%2B%5Cepsilon_%7Bi%7D%0A" /></p><p>为了可以允许自变量之间，自变量与因变量之间的非线性关系，我们可以将这里的 β<sub>j</sub>x<sub>ij</sub> 替换为一个非线性函数 <em>f<sub>j</sub></em> (x<sub>ij</sub>) 。即将模型改为：</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0Ay_%7Bi%7D%20%26%3D%5Cbeta_%7B0%7D%2B%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20f_%7Bj%7D%5Cleft%28x_%7Bi%20j%7D%5Cright%29%2B%5Cepsilon_%7Bi%7D%20%5C%5C%0A%26%3D%5Cbeta_%7B0%7D%2Bf_%7B1%7D%5Cleft(x_%7Bi%201%7D%5Cright)%2Bf_%7B2%7D%5Cleft(x_%7Bi%202%7D%5Cright)%2B%5Ccdots%2Bf_%7Bp%7D%5Cleft(x_%7Bi%20p%7D%5Cright)%2B%5Cepsilon_%7Bi%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>这个其中一个 GAM 的例子，这种模型称为一个<strong>加性模型</strong>的原因是因为，我们对每个 X<sub>j</sub> 分别计算一个单独 的 f<sub>j</sub>  值，然后把所有自变量的影响累加到一块。</p>
<p>在上面的部分中，我们讨论了很多拟合一个自变量的方法。GAMs 的优点在于我们可以利用上面这些方法来创建 <em>blocks</em> 来拟合一个加性模型。但是这个过程会非常繁琐。例如，以 <em>natural splines</em> 为例，拟合模型如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Ctext%20%7B%20wage%20%7D%3D%5Cbeta_%7B0%7D%2Bf_%7B1%7D%28%5Ctext%20%7B%20year%20%7D%29%2Bf_%7B2%7D(%5Ctext%20%7B%20age%20%7D)%2Bf_%7B3%7D(%5Ctext%20%7B%20education%20%7D)%2B%5Cepsilon%0A" /></p><p>这里，year 和 age 是连续变量，而 education 是分类变量（总共5个水平）。我们对前两个性状使用 <em>natural splines</em> 方法；我们对第三个变量的每个水平估计为一个单独的常数，即采用哑变量。</p>
<p>下图体现了使用最小二乘方法拟合模型的结果，因为 <em>natural splines</em> 可以用一系列 <em>basis functions</em> 来构建。因此整个模型是基于 <em>spline basis functions</em> 和 <em>dummy variables</em> 的 回归模型。左图表示<strong>如果固定 age 和 education</strong>,  wage 倾向于随着 year 的增加而增加。中间的图表示，<strong>如果固定education 和 year</strong>，wage 会随着age 先增加，后降低。右图表示，<strong>如果固定 year 和 age</strong>, wage 会随着学历的提高而提高。</p>
<p><img src="13.png" alt="1"></p>
<p>下图中 f<sub>1</sub> 和 f<sub>2</sub> 采用了 <em>smoothing splines</em> 方法。这种情况下更加复杂，因为  <em>smoothing splines</em> 方法无法采用最小二乘方法。但是，像 R 中的 gam() 函数可以用  <em>smoothing splines</em>  方法来拟合 GAMs 。方法就是不停预测某个特征的参数时，在先固定其他特征的值的前提下（没太搞懂）。</p>
<p><img src="14.png" alt="1"></p>
<p>这个效果和上面差不多，一般来说使用  <em>natural splines</em>  和   <em>smoothing splines</em> 的 GAMs 结果差距很小。</p>
<p>我们也可以不通用 splines 来创建 GAMs 的 blocks ：我们也可以用 local regression , polynomial regression 等方法来创建 。</p>
<h2 id="Pros-and-Cons-of-GAMs">Pros and Cons of GAMs</h2>
<p>我们这里总结一下 GAM 的优缺点。</p>
<p>优点如下：</p>
<ul>
<li>GAM 允许拟合反应变量与某个特征的非线性关系。</li>
<li>因为模型是加性的，因此我们可以检验每一个特征的效应（固定其他特征的值不变），因此很适合 <em>inference</em> （哪些特征有作用，作用的大小）。（例如多重线性回归，多重线性回归得到的某个特征的斜率的解释是，<strong>在其他特征不变的前提下</strong>每新增一个单位的X，反应变量的变化期望值。）</li>
</ul>
<p>缺点如下：</p>
<ul>
<li>GAMs 的最大缺点在于它只限制为<strong>加性</strong>模型。如果存在很多变量，那么可能会忽视<strong>重要的互作效应</strong>。但是，就是线性回归一样，我们可以手动添加互作效应（X<sub>j</sub> × X<sub>k</sub>）。</li>
</ul>
<p>GAMs 是线性模型和完全非参数模型之间的一个很好的过度方法。</p>
<h2 id="GAMs-for-Classification-Problems">GAMs for Classification Problems</h2>
<p>GAM 也可以用于反应变量为分类变量的情况。这里处于简化，假设 Y 只取 0 和 1 两个值。设定求 Y = 1 的概率。</p>
<p style=""><img src="https://math.now.sh?from=p%28x%29%20%3D%20Pr(Y%3D1%7CX)%0A" /></p><p>我们记得逻辑回归的公式如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Clog%20%5Cleft%28%5Cfrac%7Bp(X%29%7D%7B1-p(X)%7D%5Cright)%3D%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20X_%7B1%7D%2B%5Cbeta_%7B2%7D%20X_%7B2%7D%2B%5Ccdots%2B%5Cbeta_%7Bp%7D%20X_%7Bp%7D%0A" /></p><p>我们可以很自然地把它拓展成允许非线性关系的模型</p>
<p style=""><img src="https://math.now.sh?from=%5Clog%20%5Cleft%28%5Cfrac%7Bp(X%29%7D%7B1-p(X)%7D%5Cright)%3D%5Cbeta_%7B0%7D%2Bf_%7B1%7D%5Cleft(X_%7B1%7D%5Cright)%2Bf_%7B2%7D%5Cleft(X_%7B2%7D%5Cright)%2B%5Ccdots%2Bf_%7Bp%7D%5Cleft(X_%7Bp%7D%5Cright)%0A" /></p><p>这就是逻辑回归的 GAM 格式，它同样有上面提到的回归分析的GAM的优缺点。</p>
<p>还是用上面的 wage 数据集，我们预测薪资超过 $250,000 的概率。GAM 模型如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Clog%20%5Cleft%28%5Cfrac%7Bp(X%29%7D%7B1-p(X)%7D%5Cright)%3D%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20%5Ctimes%20%5Ctext%20%7B%20year%20%7D%2Bf_%7B2%7D(%5Ctext%20%7B%20age%20%7D)%2Bf_%7B3%7D(%5Ctext%20%7B%20education%20%7D)%0A" /></p><p style=""><img src="https://math.now.sh?from=p%28X%29%3D%5Coperatorname%7BPr%7D(%5Ctext%20%7B%20wage%20%7D%3E250%20%5Cmid%20%5Ctext%20%7B%20year%2C%20age%2C%20education%20%7D)%0A" /></p><p>这里 f<sub>2</sub> 采用 <em>smoothing spline</em> 算法，f<sub>3</sub> 采用 step function ，通过创建哑变量实现。结果如下图，右图看上去很奇怪，教育水平&lt; HS 的置信区间特别宽：事实上，这个水平没有值，即没有一个学历低于高中的人的薪水超过  $250,000 。</p>
<p><img src="15.png" alt="1"></p>
<p>因此，我们剔除了学历低于高中的个体的数据，然后重新拟合了模型，我们看到 age 和 education 对于成为高收入者的影响很大，而 year 影响很小。（剔除个体对 education 这个变量的作用这么大？）</p>
<p><img src="16.png" alt="1"></p>
<h1>R 代码</h1>
<p>略<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">这里包括两个边界点，其实总共是 5 个 <em>knots</em> 。正常的 cubic spline 的自由度为 5+4 =9，但是由于 natural cubic spline 在两个边界处有线性限制，因此自由度为 9-4 = 5。下面怎么从5个自由度视为4个自由度没看懂，原话为：Since this includes a constant, which is absorbed in the intercept,we count it as four degrees of freedom.<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div></p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>数据分析</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Bias Variance Trade-Off</title>
    <url>/posts/8a41a048/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>模型创建的思想，很大程度上取决于 <em><strong>Bias-Variance Trade-off</strong></em> 。</p>
<span id="more"></span>
<h1>资料</h1>
<p><a href="https://www.statlearning.com/">An Introduction to Statistical Learning</a>，下文简称 <strong>ISL</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/38853908">https://zhuanlan.zhihu.com/p/38853908</a></p>
<p><a href="http://scott.fortmann-roe.com/docs/BiasVariance.html">http://scott.fortmann-roe.com/docs/BiasVariance.html</a></p>
<h1>Split Test Error</h1>
<p>对于一个特定的 x<sub>0</sub> 值，它的 test MSE 期望值可以拆分为三部分：方差(the variance) , 偏差（bias）平方 ，和随机残差。</p>
<p style=""><img src="https://math.now.sh?from=E%5Cleft%28y_%7B0%7D-%5Chat%7Bf%7D%5Cleft(x_%7B0%7D%5Cright%29%5Cright)%5E%7B2%7D%3D%5Coperatorname%7BVar%7D%5Cleft(%5Chat%7Bf%7D%5Cleft(x_%7B0%7D%5Cright)%5Cright)%2B%5Cleft%5B%5Coperatorname%7BBias%7D%5Cleft(%5Chat%7Bf%7D%5Cleft(x_%7B0%7D%5Cright)%5Cright)%5Cright%5D%5E%7B2%7D%2B%5Coperatorname%7BVar%7D(%5Cepsilon)%0A" /></p><p>test MSE 期望值的意思是，如果我们不停地从很多的训练集中拟合模型，然后每次都计算 x0 的 test MSE 的均值。</p>
<p>上面的公式中，随机残差项是不可减少的，为了最小化 <em>expected test error</em> ，我们需要同时做到 <em>low variance</em> 和 <em>low bias</em> 。</p>
<h1>Variance</h1>
<p>方差指的是如果用了一个不一样的 training set ，拟合出来的模型的变化幅度。因为使用的 training set 不同，拟合出来的模型参数肯定不同，但是理想情况下差距不会很大。</p>
<h1>Bias</h1>
<blockquote>
<p><strong>Bias</strong>是用<strong>所有可能的训练数据集</strong>训练出的<strong>所有模型</strong>的输出的<strong>平均值</strong>与<strong>真实模型</strong>的输出值之间的差异。</p>
</blockquote>
<p>就是说，如果我们不停地拟合模型，所有拟合模型的均值和真实模型的差异。公式如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7Bbias%7D%28%5Cboldsymbol%7Bx%7D%29%3D%5Cbar%7Bf%7D(%5Cboldsymbol%7Bx%7D)-y%0A" /></p><p>举个例子，如果我们用 1000 个 training set 拟合 1000 次线性模型。对这1000次模型的参数求均值，得到一个最终的模型，然后预测 test data 中 x 的预测值，减去真值，这个差值就可以视为 bias。</p>
<p>这1000次拟合的模型参数的方差，就是方差 variance 。</p>
<h1>用图形来解释</h1>
<p><img src="1.png" alt="1"></p>
<p>假设红色的靶心区域是学习算法完美的正确预测值，蓝色点为训练数据集所训练出的模型对样本的预测值，当我们从靶心逐渐往外移动时，预测效果逐渐变差。</p>
<p>bias 就是预测值均值与靶心的举例，variance 就是预测值的离散程度。</p>
<p>上图的个人解释：左上图是理想情况，右上图是过拟合（模型过于复杂，比如采用KNN算法），左下图是欠拟合（比如采用线性模型预测非线性关系），右下图是完全失败的模型（都很差）。</p>
<h1>Variance-Bias Trade-off</h1>
<p>模型越复杂，bias 会越来越小，variance 会越来越大。但是模型过于复杂，可能发生过拟合现象（bias 很小，但是 variance，拟合出来的模型对于其他数据的预测效果很差）。</p>
<p>然后总的 test error 会随着模型复杂度呈现一个 U 字型的变化。这就说明选择一个合适复杂度的模型很重要。</p>
<p><img src="2.png" alt="1"></p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>数据分析</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>线性模型选择与正则化</title>
    <url>/posts/eb9174d6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>ISL 真是好书！</p>
<span id="more"></span> 
<h1>资料</h1>
<p><a href="https://www.statlearning.com/">An Introduction to Statistical Learning</a>，下文简称 <strong>ISL</strong></p>
<h1>概述</h1>
<p>标准的线性模型如下：</p>
<p style=""><img src="https://math.now.sh?from=Y%3D%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20X_%7B1%7D%2B%5Ccdots%2B%5Cbeta_%7Bp%7D%20X_%7Bp%7D%2B%5Cepsilon%0A" /></p><p>线性模型在接近实际问题中依然富有竞争力，通过使用别的拟合过程替换最小二乘法，可以改善线性模型的效果（<em>prediction accuracy</em> 和 <em>model interpretability</em> ）。</p>
<ul>
<li><em>Prediction Accuracy</em> :  假设因变量与自变量之间的真实关系就是几乎线性的，那么使用最小二乘法得到的估计值的 bias 会很低。 如果 n &gt;&gt; p ，也就说观测值数目远大于自变量数目，那么最小二乘估计值的 variance 也会很低。因此，如果满足这两个条件，最小二乘方法表现会很好。然而，如果 n 不是远大于 p， 那么最小二乘拟合结果的 variance 很高，容易造成 overfitting，然后在预测新的样本时结果很差。如果 p &gt; n ，那么根本无法得到一个唯一的最小二乘参数估计值，最小二乘法根本无法使用。如果此时我们人为地降低因变量的个数，那么我们的代价就是在降低了 variance 的同时 提高了 bias。</li>
<li><em>Model Interpretability</em> :  很多情况下，多重回归的一些自变量其实压根和因变量没关系。将这些无关变量添加到模型中会使得模型增加不必要的复杂度。通过移除这些变量 （即将它们的系数估计值设为0），我们可以得到一个更容易解释的模型。但是，使用最小二乘法估计参数是不可能得到正好是0的参数的（可以接近0，但不是0）。</li>
</ul>
<p>ISL 这里提到了三类替代最小二乘的方法</p>
<ul>
<li><em>Subset Selection</em> : 这种方法包括确认我们认为与因变量有关的一组自变量（从总共 p 个自变量中挑子集），然后我们用减少了变量个数的这组自变量预测因变量。</li>
<li><em>Shrinkage</em> :  这个方法同时使用所有的 p 个变量来拟合模型。但是，所有的最小二乘预测值均向0收缩（称为 <em>regularization</em>）。这种方法可以减少 variance ，有一些系数可能会正好估计为0，从而降低了自变量个数，可以实现变量选择。</li>
<li><em>Dimension Reduction</em> : 这个方法包含了将 p 个自变量投射到 (<em>projecting</em>) 一个M维的子空间中，其中 M &lt; p 。</li>
</ul>
<h1>Subset Selection</h1>
<h2 id="Best-Subset-Selection">Best Subset Selection</h2>
<p>为了找到 best subset， 我们需要使用 p 的自变量的所有组合来进行一个个单独的最小二乘拟合。因此我们需要进行p次包含一个变量的模型拟合，进行 p(p-1)/2 次包含两个变量的模型拟合，以此类推（总共 2<sup>p</sup> 次）。然后我们查看所有模型拟合的结果，找出我们认为是最好的模型。</p>
<p>这个过程的算法表述如下：这里我们挑出所有固定因子数目时的最佳组合，然后最后在比较不同因子数目中的最佳模型。</p>
<p><img src="1.png" alt="1"></p>
<p><strong>但是，这里需要注意一点, RSS是会随着变量数目的增加而递减的，无论增加的自变量有没有用。</strong></p>
<p>**因此，如果你使用 RSS 或 R<sup>2</sup> 作为评价指标，最终最好的模型一定是包含了所有自变量的模型。**如下图所示</p>
<p><img src="2.png" alt="1"></p>
<p>这里的问题在于，这里计算得到的 RSS 和 R<sup>2</sup> 实际衡量地是 <strong>training error</strong> ，但是我们要的模型应该是需要 <strong>test error</strong> 最低（training error 倾向于比 test error 更低，trainging error 很低无法保证 test error 很低）。因此在上图中的第三步，我们需要使用交叉验证的预测误差,  C<sub>p</sub>  ,  BIC , adjusted R<sup>2</sup> 来选择后 M<sub>0</sub> ,  M<sub>1</sub> ,  ……， M<sub>p</sub> 。</p>
<p>我们这里提到的思路虽然是用在最小二乘回归中，其他模型也是可以这么做的，比如逻辑回归。不过逻辑回归用的不是 RSS， 而是 <em><strong>deviance</strong></em> 。deviance 等于 -2 times <em>maximized log-likelihood</em> 。值越小，说明拟合程度越好。</p>
<p>虽然 <em>best subset seleciton</em> 方法很简单，逻辑也很清晰，但是它的问题就在于<strong>计算量</strong>太大。如果 p 大于40，这个算法就基本无法实现了。</p>
<h2 id="Stepwise-Selection">Stepwise Selection</h2>
<p>出于计算量的原因， 当 p 很大时，<em>best subset selection</em> 无法实现；除此之外，当 p 很大时这个方法还有其他问题。当 p 很大时，很大概率容易出现过拟合现象（模型仅适用于训练集，对于其他数据不适用，参见维度诅咒）</p>
<p>处于上面的原因，逐步回归是一个很好的备选方法。</p>
<h3 id="Forward-Stepwise-Selection">Forward Stepwise Selection</h3>
<p>向前逐步回归指模型从没有自变量出发，然后每次新增一个自变量，至到所有的自变量都加入到模型中。在实际中，每一步拟合到模型中的变量是 <em>gives the greatest additional improvement</em> 的变量。这个算法具体过程如下：</p>
<p><img src="3.png" alt="1"></p>
<p>这个算法比上面的 best subset 方法计算量小很多。虽然一般来说向前逐步回归效果很好，但是这种方法并不能保证一定能找到所有组合的最优组合。</p>
<p>例如，加入一个p=3的数据集，最好的一个变量的模型包含 X<sub>1</sub>，最好的两个变量的模型包含 X<sub>2</sub> 和 X<sub>3</sub> 。那么向前逐步回归在第二步找最优的二变量模型程序会失败，因为 M<sub>1</sub> 包含 X<sub>1</sub> ，因此 M<sub>2</sub> 必须包括 X<sub>1</sub> 。</p>
<p>这里举了个例子，比对 best subset 方法 和 forward stepwise 方法， 在四变量的时候，best subset 将 rating 替换为了 cards，而 forward stepwise 方法必须要包含 rating 。</p>
<p><img src="4.png" alt="1"></p>
<h3 id="Backward-Stepwise-Selection">Backward Stepwise Selection</h3>
<p>与向前迭代回归相反，向后迭代回归从包含所有的变量开始，然后每次剔除一个最没有用的变量。具体算法见下：</p>
<p><img src="5.png" alt="1"></p>
<p>同样类似于向前迭代，向后迭代同样不保证能够挑出最好的模型。但是向后迭代要求 n &gt; p 。如果 p 很大，只能使用向前迭代。</p>
<h3 id="Hybrid-Approaches">Hybrid Approaches</h3>
<p>我们可以同时杂合使用向前迭代和向后迭代。我们先按照类似于向前迭代回归的方法来添加因子，但是当我们添加了一个新的变量后，这个方法会剔除不能使得这个模型拟合更好的变量（就是走一步，再退一步）。这种方法最接近于 best subset selection ，并且同时利用了向前迭代回归和向后迭代回归的优势。</p>
<p>其实意思就是说，基本用的方法是向前迭代，但是向前迭代是一种贪婪算法，之前的变量会一直保留。但是在不断新增变量的过程中，可能发生一种现象，那就是最开始加入的变量变得不重要了（变量之间的相关性），这个时候剔除不显著的初始变量更为合理。因此这种混合迭代的方法，每新增一个变量，就会看看旧的变量有没有无用变量，有的话就剔除。这种做法更加合理。</p>
<h2 id="Choosing-the-Optimal-Model">Choosing the Optimal Model</h2>
<p><strong>上面的这些方法都会构建很多模型，我们需要一种方法来决定哪个模型是最优的</strong>。就像我们提到的，R<sup>2</sup> 和 RSS 会随着自变量数目的增加而降低，因此不能作为决定自变量数目不同的模型之间比较的指标。这里我们需要能估计 test error 的指标作为评判标准。这里有两种方法：</p>
<ol>
<li>我们可以i通过对 training error 做出调整，间接估计 test error</li>
<li>我们可以通过对 validation set 或使用交叉验证方法，直接估计 test error</li>
</ol>
<p>下面会详细介绍这两种方法</p>
<h3 id="C-sub-p-sub-AIC-BIC-and-Adjusted-R-sup-2-sup">C<sub>p</sub>, AIC, BIC, and Adjusted R<sup>2</sup></h3>
<p>这些参数都是通过调整 training error 来估计  test error ，主要是避免了自变量数目会降低training error 的影响。这里主要考虑四种方法：<strong>C<sub>p</sub>, <abbr title="Akaike information criterion">AIC</abbr>, <abbr title="Bayesian information criterion">BIC</abbr>, and Adjusted R<sup>2</sup></strong> 。下图显示了 best subset selection 方法的四个参数的值的变化。</p>
<p><img src="6.png" alt="1"></p>
<p>对于包含了 d 个因子的最小二乘模型， 使用 C<sub>p</sub> 估计 test MSE 的公式如下（下面是MSE的估计公式）：</p>
<p style=""><img src="https://math.now.sh?from=C_%7Bp%7D%3D%5Cfrac%7B1%7D%7Bn%7D%5Cleft%28%5Cmathrm%7BRSS%7D%2B2%20d%20%5Chat%7B%5Csigma%7D%5E%7B2%7D%5Cright%29%0A" /></p><p style=""><img src="https://math.now.sh?from=%7BEsetimated%7D%20%5Coperatorname%20%7B%20training%20%7D%20%5Coperatorname%20%7Berror%7D%3D%5Cfrac%7B1%7D%7Bn%7D%5Cleft%28%5Cmathrm%7BRSS%7D%5Cright%29%0A" /></p><p>这里 σ_hat<sup>2</sup>  是对因变量预测的残差方差的估计值。</p>
<p style=""><img src="https://math.now.sh?from=%5Ctext%20%7B%20training%20%7D%20%5Coperatorname%7BRSS%7D%0A" /></p><p>我们可以 C<sub>p</sub> 添加了一个惩罚项，如下式，来调整 training error 容易低估 test error 的趋势。而且这个惩罚项会随着自变量数目的增加而增加（含有d），从而趋于弥补 training RSS 随着变量增加而降低的趋势。</p>
<p style=""><img src="https://math.now.sh?from=2%20d%20%5Chat%7B%5Csigma%7D%5E%7B2%7D%0A" /></p><p>由于 σ_hat<sup>2</sup> 是 σ<sup>2</sup> 的无偏估计值，因此  C<sub>p</sub> 是 test MSE 的一个无偏估计值（?）。</p>
<p><strong>AIC</strong> 应用在使用最大似然法来拟合参数的模型中，但是在线性模型中，最大似然法和最小二乘是一回事。在这种情况下，AIC 计算公式如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BAIC%7D%3D%5Cfrac%7B1%7D%7Bn%20%5Chat%7B%5Csigma%7D%5E%7B2%7D%7D%5Cleft%28%5Cmathrm%7BRSS%7D%2B2%20d%20%5Chat%7B%5Csigma%7D%5E%7B2%7D%5Cright%29%0A" /></p><p>我们可以看到 AIC 和  C<sub>p</sub>  是一个比例关系，AIC 乘以  σ_hat<sup>2</sup> 就得到了  C<sub>p</sub> ，因此这两个是等价的，所以在上图中只显示了  C<sub>p</sub> 的结果。</p>
<p>BIC 来源于贝叶斯的观点，但是最终的公式和 AIC/ C<sub>p</sub> 差不多，对于最小二乘模型，公式如下，这里相比较 AIC ，就是把 2 改为了 log(n) （这里其实应该写成 ln(n) , 底为 e,  只要 n &gt; 7, ln(n) 就大于2 ），因此 <strong>BIC 对自变量数目很多的模型的惩罚效应更重</strong>。因此上面的图中 BIC 的最佳变量数目为 4，而 AIC/ C<sub>p</sub>是 6 ，其实在图中我们看到变量数目为4后面的曲线就很平了，变量数为4还是6没啥区别。</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BBIC%7D%3D%5Cfrac%7B1%7D%7Bn%20%5Chat%7B%5Csigma%7D%5E%7B2%7D%7D%5Cleft%28%5Cmathrm%7BRSS%7D%2B%5Clog%20(n%29%20d%20%5Chat%7B%5Csigma%7D%5E%7B2%7D%5Cright)%0A" /></p><p>校正R2 公式如下，也是会对变量数目过多有惩罚效应</p>
<p style=""><img src="https://math.now.sh?from=%5Ctext%20%7B%20Adjusted%20%7D%20R%5E%7B2%7D%3D1-%5Cfrac%7B%5Coperatorname%7BRSS%7D%20%2F%28n-d-1%29%7D%7B%5Coperatorname%7BTSS%7D%20%2F(n-1)%7D%0A" /></p><p>这四种方法均有严谨的理论证明，但是ISL没讲，它们的证明均有一定的前提或<strong>假设</strong>（如 n 非常大）。<strong>虽然校正R<sup>2</sup> 很流行，但是从理论上校正R<sup>2</sup> 的效果不如另外三种方法</strong>。</p>
<h3 id="Validation-and-Cross-Validation">Validation and Cross-Validation</h3>
<p>除了通过校正 training error 间接估计 test error ，我们也可以通过验证集或交叉验证直接估计 test error ，好处就是需要满足的假设更少，而且可以应用在非常广泛的模型选择任务中（不一定是线性模型）。</p>
<p>在过去，由于执行交叉验证需要很大的计算量无法实现，从而导致 AIC ，BIC 等方法更加流行。但是如今随着计算机算力的增加，交叉验证的计算量已经不再是问题了，因此交叉验证成为了模型选择更好的方法。</p>
<p>下图展示了 BIC， validation set errors , CV （k=10）三种方法的结果，我们可以看后面两种方法的最佳变量数目均是6，但是我们看到 变量数是4 还是 6 差不多。validation set errors 是通过随机挑选3/4的个体作为训练集，剩下的个体就作为验证集。</p>
<p><img src="7.png" alt="1"></p>
<p>其实我们可以看到，变量数为 3到11之间的差距很多，如果计算 valiation set errors 时换一种区分参考集和验证集的方式，或者 CV 方法换一个 k 值，那么可能找到的最佳的变量数目会变化。其实，实际我们选模型的方式是 <em><strong>one-standard-error rule</strong></em> ：我们需要同时计算 test MSE 估计值的标准误，然后<strong>挑 test MSE 最低点 的 一倍标准误内的最简单的模型。</strong> 后面的逻辑就是：<strong>如果有很多模型效果差不多好，那么我们应该挑最简单的模型</strong>。 在上面的例子中，我们最终挑选的模型就是 3个变量的模型。</p>
<h1>Shrinkage Methods</h1>
<p>上面提到的那些方法是用来挑选变量的方法。作为另外一种备选方法，我们可以同时将 p 个预测因子均包含在模型中，然后 <em>constrain</em> 或者说是 <em>regularize</em> 系数估计值，或者说是，<em>shrinks</em> the coefficient estimates towards zero。</p>
<p>在这当中，最出名的两个方法就是 <em>ridge  regression</em> 和 <em>lasso</em> 。</p>
<h2 id="Ridge-Regression">Ridge Regression</h2>
<p>一般的线性模型估计参数的标准是，使得RSS最小，公式如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BRSS%7D%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28y_%7Bi%7D-%5Cbeta_%7B0%7D-%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%20x_%7Bi%20j%7D%5Cright%29%5E%7B2%7D%0A" /></p><p>岭回归（Ridge regression）类似于最小二乘，但是它拟合参数用的需要最小化的指标不同，公式如下，其中 λ ≥ 0 ， 称之为 <em>tuning parameter</em> 。每设置一个不同的 λ ，就能得到一套不同的模型参数。因此，<strong>选择一个合适的 λ 是至关重要的</strong>。</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28y_%7Bi%7D-%5Cbeta_%7B0%7D-%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%20x_%7Bi%20j%7D%5Cright%29%5E%7B2%7D%2B%5Clambda%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%5E%7B2%7D%3D%5Cmathrm%7BRSS%7D%2B%5Clambda%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%5E%7B2%7D%0A" /></p><p>其实就是新增了一部分，称为 <em>shrinkage penalty</em> ， 作用是将所有的参数尽量往0压缩。</p>
<p style=""><img src="https://math.now.sh?from=%5Clambda%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%5E%7B2%7D%0A" /></p><p>注意到， <em>shrinkage penalty</em>  仅仅针对 β<sub>1</sub>, …… ， β<sub>p</sub> ， 但是不会针对截距 β<sub>0</sub> ，理由显而易见。</p>
<p>岭回归的效果如下图，左边是估计系数随着 λ 的变化的趋势，可以看到随着 λ 的增加，所有因变量的系数均趋向于 0。</p>
<p><img src="8.png" alt="1"></p>
<p>右图的横坐标改了，分子/分母的计算方式如下：</p>
<p style=""><img src="https://math.now.sh?from=%5C%7C%5Cbeta%5C%7C_%7B2%7D%3D%5Csqrt%7B%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%7B%20%7D%5E%7B2%7D%7D%0A" /></p><p>因此当 λ = 0，岭回就是普通的线性回归，右图横坐标为1；当 λ 趋于 ∞ 时， 右图横坐标趋于0。</p>
<p>标准的线性回归的系数估计值是 <em>scale equivariant</em> ：如果将自变量 X<sub>j</sub> 乘以一个常数 c ，那么这个自变量的系数的估计值就会乘以常数 1/c 。用另外一句话说，无论自变量的值如何缩放，下面这个式子的值永远不变。</p>
<p style=""><img src="https://math.now.sh?from=X_%7Bj%7D%20%5Chat%7B%5Cbeta%7D_%7Bj%7D%0A" /></p><p>但是，与之相反，<strong>岭回归</strong>的系数估计值会随着<strong>自变量系数乘以一个常数</strong>发生<strong>实质性变化</strong>。例如工资这个变量，单位是美元，如果单位换成千美元，那么标准的线性回归的系数估计就会缩小1000倍。这个时候由于岭回归的代价函数中含有系数估计值的平方项，岭回归系数就不会是正好缩小1000倍。换句话说，下式不仅仅取决于 λ 的大小，而且也取决于自变量的缩放比例，甚至还会受到其他自变量缩放比例的影响。</p>
<p style=""><img src="https://math.now.sh?from=X_%7Bj%7D%20%5Chat%7B%5Cbeta%7D_%7Bj%2C%20%5Clambda%7D%5E%7BR%7D%0A" /></p><p>因此，<strong>在进行岭回归前，需要对自变量进行标准化</strong>。公式如下，分母为估计的标准差。这样所有的自变量有相同 的 <em>scale</em>（不知道啥叫 scale） 。经过下面这个公式，所有自变量均拥有值为1的标准差。</p>
<p style=""><img src="https://math.now.sh?from=%5Ctilde%7Bx%7D_%7Bi%20j%7D%3D%5Cfrac%7Bx_%7Bi%20j%7D%7D%7B%5Csqrt%7B%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28x_%7Bi%20j%7D-%5Cbar%7Bx%7D_%7Bj%7D%5Cright%29%5E%7B2%7D%7D%7D%0A" /></p><p>所以上图6.4 的横坐标是  <strong>standardized ridge regression coefficient estimates</strong>, 也就是说自变量已经经过标准化了。</p>
<h3 id="为什么岭回归比最小二乘更好">为什么岭回归比最小二乘更好</h3>
<p>这还是来自于 <em>bias-variance trade-off</em> 。随着 λ 增加，岭回归的 <em>flexibility</em> 会降低，导致 variance 降低，但是 bias 增加。如下图所示，当 λ = 0 时， variance 很高，但是没有bias；最佳的 λ 值接近于30 。</p>
<p><img src="9.png" alt="1"></p>
<p>一般来说，当因变量与 p个自变量之间的真实关系接近线性关系，那么最小二乘估计值拥有很低的 bias ，但是 variance 很高。这意味着只要 training data 发生一个很小的变化，参数估计值就会发生很大的变化。在实际情况中，如果 p 非常大，接近于 n，那么最小二乘估计的参数会是 <em>extremely variable</em> 。 <strong>如果当 p &gt; n， 最小二乘甚至无法给出一个唯一解</strong>。这个时候岭回归依然可以发挥作用，仅仅会增加一点 bias，但是会极大地降低 variance 。因此，<strong>岭回归适用于 p 很大的情况（最小二乘的 variance 很高）</strong>。</p>
<h2 id="The-Lasso">The Lasso</h2>
<p><strong>岭回归的一个明显的缺点是，它最终的模型中会包含所有p个自变量</strong>。虽然它会将所有的系数向0压缩，但是它不会真的把某些系数设置为0，仅仅是接近0。这对于预测没有影响，但是对于模型解释很有影响。</p>
<p>lasso 方法是岭回归的一个替代方法，它克服了上面的这个劣势。lasso 的 代价函数如下：</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28y_%7Bi%7D-%5Cbeta_%7B0%7D-%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%20x_%7Bi%20j%7D%5Cright%29%5E%7B2%7D%2B%5Clambda%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%5Cleft%7C%5Cbeta_%7Bj%7D%5Cright%7C%3D%5Cmathrm%7BRSS%7D%2B%5Clambda%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%5Cleft%7C%5Cbeta_%7Bj%7D%5Cright%7C%0A" /></p><p>我们可以看到， lasso 和 岭回归公式相似，仅仅是把系数估计值平方改为绝对值。同样，类似于岭回归，lasso 也同样将系数估计值 <em>shrinks towards zero</em> 。但是，<strong>lasso 可以使得某些系数估计值正好是0</strong>。因此，类似于 best subset selection 方法， lasso 方法同时可以实现变量选择的目的。我们一般说，<em>the lasso yields <strong>sparse</strong> models</em> ，也就是说模型仅包含部分向量。同样地，选择一个合适的 λ 值对 lasso 方法也很重要。</p>
<p>下图为 lasso 方法的效果，我们可以只要选择不同的λ值，就可以得到不同的因子数目的模型。</p>
<p><img src="10.png" alt="1"></p>
<h3 id="岭回归和-lasso-方法的另一种理解">岭回归和 lasso 方法的另一种理解</h3>
<p>我们认为 lasso 和 岭回归的系数估计过程，可以视为接近下面这两个问题</p>
<p style=""><img src="https://math.now.sh?from=%5Cunderset%7B%5Cbeta%7D%7B%5Coperatorname%7Bminimize%7D%7D%5Cleft%5C%7B%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28y_%7Bi%7D-%5Cbeta_%7B0%7D-%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%20x_%7Bi%20j%7D%5Cright%29%5E%7B2%7D%5Cright%5C%7D%20%5Cquad%20subject%20%5Cquad%20to%20%5Cquad%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%5Cleft%7C%5Cbeta_%7Bj%7D%5Cright%7C%20%5Cleq%20s%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Cunderset%7B%5Cbeta%7D%7B%5Coperatorname%7Bminimize%7D%7D%5Cleft%5C%7B%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28y_%7Bi%7D-%5Cbeta_%7B0%7D-%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%20x_%7Bi%20j%7D%5Cright%29%5E%7B2%7D%5Cright%5C%7D%20%5Cquad%20subject%20%5Cquad%20to%20%5Cquad%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%5E%7B2%7D%20%5Cleq%20s%0A" /></p><p>也就是说，对于任意一个 λ 值，都会有有一个 s 值作为系数估计值绝对值/平方和的最大值，在满足小于 s 的前提下，RSS 最小的系数就是估计的系数。</p>
<p>best subset selection 可以理解为下式，也就是说条件是系数数目要低于 s 。</p>
<p style=""><img src="https://math.now.sh?from=%5Cunderset%7B%5Cbeta%7D%7B%5Coperatorname%7Bminimize%7D%7D%5Cleft%5C%7B%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28y_%7Bi%7D-%5Cbeta_%7B0%7D-%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%20x_%7Bi%20j%7D%5Cright%29%5E%7B2%7D%5Cright%5C%7D%20%5Cquad%20subject%20%5Cquad%20to%20%5Cquad%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20I%5Cleft(%5Cbeta_%7Bj%7D%20%5Cneq%200%5Cright)%20%5Cleq%20s%0A" /></p><p><strong>当 p 很大时，best subset selection 方法不可用，这时候必须用岭回归或者 lasso 方法。</strong></p>
<h3 id="为什么lasso可以实现变量选择？">为什么lasso可以实现变量选择？</h3>
<p>下图为p=2时一个解释说明， 红色的圈为RSS等高线，中间的黑点为最小二乘估计值；蓝色图形为 lasso/ 岭回归限制条件的区域，lasso 是一个菱形，岭回归是一个圆形。如果 s 很大，那么lasso/岭回归的限制条件区域就可能包含最小二乘估计值，那么此时解就等于最小二乘估计值。但是我们图中的限制条件区域并不大，左图为 lasso 结果，估计值为RSS等高线与菱形限制区域外边缘刚刚好接触的那个交点，岭回归同理。由于岭回归的限制区域是一个圆形，没有突出点，因此这个交点很难正好在某个轴上；而 lasso 的四个突出点均在轴上，因此交点很有可能就是轴上的突出点，如图中所示。</p>
<p>在更高的维度上，可能就会有很多的系数估计值都是0。</p>
<p><img src="11.png" alt="1"></p>
<h3 id="比较-lasso-和-岭回归">比较 lasso 和 岭回归</h3>
<p>我们很容易看到 lasso 方法相比于岭回归有很大的优势，产生的模型更容易解释，但是哪种方法的预测准确性更好呢？下图中右图为比较岭回归和lasso的结果，横坐标均为 training data 的 R<sup>2</sup> ，这是一种很好的比较不同的正则方法的方式。我们可以岭回归和 lasso 的 bias 差不多，但是岭回归的 variance 更低。这个图是由于所有的45个自变量都和因变量有关系，所以岭回归效果更好。</p>
<p><img src="12.png" alt="1"></p>
<p>如果我们用的模拟数据，因变量只和45个变量中的2个变量有关系，这时我们可以从下图看到，lasso 预测效果更好。</p>
<p><img src="13.png" alt="1"></p>
<p>这说明**这两种方法之间在预测准确性上没有绝对的优劣之分。**如果因变量实际与大量的预测因子均有关系，那么岭回归效果更好。但是，<strong>与因变量有关的因子数目在实际项目中是一个未知数</strong>，但是我们可以通过交叉验证来决定哪种方法更好。</p>
<h3 id="一个说明岭回归和lasso的简单例子">一个说明岭回归和lasso的简单例子</h3>
<p>为了更好地理解岭回归和 lasso 的特性，我们考虑一个特殊的例子，其中 n = p， 然后 X 是一个单位矩阵。为了进一步简化问题，假设我们正在执行没有截距的回归。根据上面这些假设，最小二乘问题简化为寻找使得下式最小的一组系数</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%5Cleft%28y_%7Bj%7D-%5Cbeta_%7Bj%7D%5Cright%29%5E%7B2%7D%0A" /></p><p>在这个例子中，最小二乘解为</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cbeta%7D_%7Bj%7D%3Dy_%7Bj%7D%0A" /></p><p>在这种情况下，岭回归的解为下式最小的一组系数估计值</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%5Cleft%28y_%7Bj%7D-%5Cbeta_%7Bj%7D%5Cright%29%5E%7B2%7D%2B%5Clambda%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%5E%7B2%7D%0A" /></p><p>lasso 的公式如下</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%5Cleft%28y_%7Bj%7D-%5Cbeta_%7Bj%7D%5Cright%29%5E%7B2%7D%2B%5Clambda%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%5Cleft%7C%5Cbeta_%7Bj%7D%5Cright%7C%0A" /></p><p>岭回归的解为</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cbeta%7D_%7Bj%7D%5E%7BR%7D%3Dy_%7Bj%7D%20%2F%281%2B%5Clambda%29%0A" /></p><p>lasso 的解为</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cbeta%7D_%7Bj%7D%5E%7BL%7D%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bll%7Dy_%7Bj%7D-%5Clambda%20%2F%202%20%26%20%5Ctext%20%7B%20if%20%7D%20y_%7Bj%7D%3E%5Clambda%20%2F%202%20%5C%5C%20y_%7Bj%7D%2B%5Clambda%20%2F%202%20%26%20%5Ctext%20%7B%20if%20%7D%20y_%7Bj%7D%3C-%5Clambda%20%2F%202%20%5C%5C%200%20%26%20%5Ctext%20%7B%20if%20%7D%5Cleft%7Cy_%7Bj%7D%5Cright%7C%20%5Cleq%20%5Clambda%20%2F%202%5Cend%7Barray%7D%5Cright.%0A" /></p><p>下图展示了这种情况。我们可以看到 岭回归和 lasso 的 <em>shrink</em> 策略不一样。在岭回归中，所有的系数的压缩比例都是相同的；与之相反，lasso  将正负 λ/2 之间的系数都直接压缩为0，其他范围的系数压缩比例相同。</p>
<p><img src="14.png" alt="1"></p>
<h3 id="岭回归和-lasso-的贝叶斯解释">岭回归和 lasso 的贝叶斯解释</h3>
<p>我们现在可以用一个 贝叶斯方法的视角来重新审视岭回归和 lasso 。从贝叶斯方法的角度出发，首先我们需要知道回归系数的先验分布，我们称为 <em>p(β)</em>  。 数据的似然性可以写作 f(Y|X, β) 。 先验分布乘以似然值 ，我们就得到了后验分布，形式如下（?）</p>
<p style=""><img src="https://math.now.sh?from=p%28%5Cbeta%20%5Cmid%20X%2C%20Y%29%20%5Cpropto%20f(Y%20%5Cmid%20X%2C%20%5Cbeta)%20p(%5Cbeta%20%5Cmid%20X)%3Df(Y%20%5Cmid%20X%2C%20%5Cbeta)%20p(%5Cbeta)%0A" /></p><p>一般的线性模型如下：</p>
<p style=""><img src="https://math.now.sh?from=Y%3D%5Cbeta_%7B0%7D%2BX_%7B1%7D%20%5Cbeta_%7B1%7D%2B%5Cldots%2BX_%7Bp%7D%20%5Cbeta_%7Bp%7D%2B%5Cepsilon%0A" /></p><p>我们假设残差之间是独立的，而且来自于一个相同的正态分布。还有，我们假设下式成立，其中g() 为一个密度函数，岭回归和 lasso 服从两个特殊的密度分布。</p>
<p style=""><img src="https://math.now.sh?from=p%28%5Cbeta%29%3D%5Cprod_%7Bj%3D1%7D%5E%7Bp%7D%20g%5Cleft(%5Cbeta_%7Bj%7D%5Cright)%0A" /></p><p>我们可以发现岭回归和 lasso 服从两个不同的 g() 函数。</p>
<ul>
<li>如果 g 是一个均值为0，标准差为 λ 函数的正态分布，那么 β 的 <em>posterior mode</em> （基于给定数据的最可能的 β值）就是岭回归的解。换句话说，岭回归的解就是这个时候的后验分布的均值。</li>
<li>如果 g 是 一个 双指数分布 (<em>double-exponential</em>)  (也叫<a href="https://zh.wikipedia.org/wiki/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%88%86%E5%B8%83">拉普拉斯分布</a>) ， 均值为0，<em>scale parameter</em>  是 λ 的函数，那么这时的 <em>posterior mode</em> 就是 lasso 的解。</li>
</ul>
<p>这两种分布如下图所示。</p>
<p><img src="15.png" alt="1"></p>
<h3 id="选择-λ-的值">选择 λ 的值</h3>
<p>岭回归和 lasso 均需要选择一个合适的值。交叉验证提供一个简单的解决办法，通过计算不同的 λ 的 CV errors ，来选择一个 CV errors 最低的 λ 值，如下图所示，左图为不同的λ值计算得到的 CV errors，右图为不同的 λ 值计算得到的岭回归标准化系数。我们通过左图可以看到，最佳的 λ 值的 CV error 降低幅度并不明显，左图的左半边基本都是平的，<strong>这种情况一般我们会直接用最小二乘法</strong>，而不用岭回归/lasso。</p>
<p><img src="16.png" alt="1"></p>
<p>下图为 lasso 的十倍交叉验证与系数估计结果。左图为交叉验证结果；右图为系数估计结果，两根有颜色的线为与因变量有关的因子（<em>signal variables</em>），灰线表示无关变量（<em>noise variables</em>）。这里我们发现最佳的 λ 值比较大，而且最佳 λ 值只保留了两个显著变量，因此证明了交叉验证的结果很好地给出了一个合适的 λ 值，这很有挑战，因为这个例子中有 p=45 个因子，但是只有 n=50 个观测值。作为比较，最小二乘结果（右图横坐标为1）仅仅给一个显著变量分配了一个较大的系数（红线）。</p>
<p><img src="17.png" alt="1"></p>
<h1>Dimension Reduction Methods</h1>
<p>上面提到的两种方法，subset selection 和 shrinkage methods ，都还是使用的原来的预测因子，X<sub>1</sub> , X<sub>2</sub> …… X<sub>p</sub> 。 下面会提到如何 <em>transform the predictors</em> ，然后将转换后的预测因子用于最小二乘模型。我们一般将这些方法称为 <em>dimension reduction methods</em>。</p>
<p>我们假设  Z<sub>1</sub> , Z<sub>2</sub> …… Z<sub>M</sub> 表示 M 个原来 p 个预测因子的线性组合 (<em>linear combinations</em>) ，其中 M &lt; p 。即：</p>
<p style=""><img src="https://math.now.sh?from=Z_%7Bm%7D%3D%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cphi_%7Bj%20m%7D%20X_%7Bj%7D%0A" /></p><p>其中 <em>Φ<sub>jm</sub></em> 为常数。</p>
<p>把上面转换后的预测因子，带入到线性回归模型中，如下</p>
<p style=""><img src="https://math.now.sh?from=y_%7Bi%7D%3D%5Ctheta_%7B0%7D%2B%5Csum_%7Bm%3D1%7D%5E%7BM%7D%20%5Ctheta_%7Bm%7D%20z_%7Bi%20m%7D%2B%5Cepsilon_%7Bi%7D%2C%20%5Cquad%20i%3D1%2C%20%5Cldots%2C%20n%0A" /></p><p>这样就从估计 <em>p+1</em> 个系数降低至估计 <em>M+1</em> 个系数。根据上面的公式进行推导得到</p>
<p style=""><img src="https://math.now.sh?from=%5Csum_%7Bm%3D1%7D%5E%7BM%7D%20%5Ctheta_%7Bm%7D%20z_%7Bi%20m%7D%3D%5Csum_%7Bm%3D1%7D%5E%7BM%7D%20%5Ctheta_%7Bm%7D%20%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cphi_%7Bj%20m%7D%20x_%7Bi%20j%7D%3D%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Csum_%7Bm%3D1%7D%5E%7BM%7D%20%5Ctheta_%7Bm%7D%20%5Cphi_%7Bj%20m%7D%20x_%7Bi%20j%7D%3D%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cbeta_%7Bj%7D%20x_%7Bi%20j%7D%0A" /></p><p>因此，</p>
<p style=""><img src="https://math.now.sh?from=%5Cbeta_%7Bj%7D%3D%5Csum_%7Bm%3D1%7D%5E%7BM%7D%20%5Ctheta_%7Bm%7D%20%5Cphi_%7Bj%20m%7D%0A" /></p><p>通过降维的方法可能会增加系数估计的 bias，但是当相比对 n 而言，p 很大时，通过降维的方法可以显著降低 variance 。</p>
<p>所有的降维方法均分为两步。第一步，获得   Z<sub>1</sub> , Z<sub>2</sub> …… Z<sub>M</sub>  这些新的预测因子；第二步，通过这些 M 个因子来拟合模型。但是如何获取新的预测因子，或者说如何得到这些 <em>Φ<sub>jm</sub></em> 的值，这存在很多方法。这里只考虑两个主要的方法：<em>principal components</em> (主成分)  和 <em>partial least squares</em> 。</p>
<h2 id="Principal-Components-Regression">Principal Components Regression</h2>
<p>主成分分析 (<em>principal components analysis</em>, PCA) 是一个流行的降维方法。这里只讨论 PCA 在回归分析中的作用。第一主成分是指观测值在这个成分上的变异最丰富的成分。例如下图为两个因子的散点图，横坐标为城市的人口数量，纵坐标为某个特定公司的广告费用，这里总共是100个城市的结果。绿色实线表示第一主成分方向 (<em>first principal component direction</em>)，我们可以如果把所有的点均投影到这条线上，投影到第一主成分上得到的点的方差是最大的。如果我们把这些点投射到别的直线上，得到的变异均会更低。</p>
<p><img src="18.png" alt="1"></p>
<p>第一主成分的公式如下，即  <em>Φ<sub>11</sub></em> = 0.839 和  <em>Φ<sub>21</sub></em> = 0.544 。(  <em>Φ<sub>11</sub></em> 等称为 <em>principal component loadings</em> ) （<strong>我不太清楚上面的直线和这个公式之间有什么关系</strong>）</p>
<p style=""><img src="https://math.now.sh?from=Z_%7B1%7D%3D0.839%20%5Ctimes%28%5Cmathrm%7Bpop%7D-%5Coverline%7B%5Cmathrm%7Bpop%7D%7D%29%2B0.544%20%5Ctimes(%5Cmathrm%7Bad%7D-%5Coverline%7B%5Cmathrm%7Bad%7D%7D)%0A" /></p><p>我大致把 Z1 的三维图片画了出来，是一个平面，代码如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;barsurf&quot;</span><span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span><span class="string">&quot;barsurf&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;plotrix&quot;</span><span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span><span class="string">&quot;plotrix&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;scatterplot3d&quot;</span><span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span><span class="string">&quot;scatterplot3d&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;plot3D&quot;</span><span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span><span class="string">&quot;plot3D&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;MBA&quot;</span><span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span><span class="string">&quot;MBA&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">x <span class="operator">&lt;-</span> seq<span class="punctuation">(</span><span class="number">10</span><span class="punctuation">,</span> <span class="number">70</span><span class="punctuation">)</span></span><br><span class="line">y <span class="operator">&lt;-</span> seq<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">35</span><span class="punctuation">)</span></span><br><span class="line">f <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  r <span class="operator">&lt;-</span> 0.839<span class="operator">*</span><span class="punctuation">(</span>x<span class="operator">-</span><span class="number">40</span><span class="punctuation">)</span> <span class="operator">+</span> <span class="number">0.544</span><span class="operator">*</span><span class="punctuation">(</span>y<span class="operator">-</span><span class="number">15</span><span class="punctuation">)</span></span><br><span class="line">  <span class="built_in">return</span><span class="punctuation">(</span>r<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">z <span class="operator">&lt;-</span> outer<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">,</span> f<span class="punctuation">)</span></span><br><span class="line">op <span class="operator">&lt;-</span> par<span class="punctuation">(</span>bg <span class="operator">=</span> <span class="string">&quot;white&quot;</span><span class="punctuation">)</span></span><br><span class="line">nrz <span class="operator">&lt;-</span> nrow<span class="punctuation">(</span>z<span class="punctuation">)</span></span><br><span class="line">ncz <span class="operator">&lt;-</span> ncol<span class="punctuation">(</span>z<span class="punctuation">)</span></span><br><span class="line">jet.colors <span class="operator">&lt;-</span> colorRampPalette<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;gray80&quot;</span><span class="punctuation">,</span> <span class="string">&quot;gray10&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">nbcol <span class="operator">&lt;-</span> 100</span><br><span class="line">color <span class="operator">&lt;-</span> jet.colors<span class="punctuation">(</span>nbcol<span class="punctuation">)</span></span><br><span class="line">zfacet <span class="operator">&lt;-</span> z<span class="punctuation">[</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">+</span> z<span class="punctuation">[</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">,</span> <span class="operator">-</span>ncz<span class="punctuation">]</span> <span class="operator">+</span> z<span class="punctuation">[</span><span class="operator">-</span>nrz<span class="punctuation">,</span> <span class="operator">-</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">+</span> z<span class="punctuation">[</span><span class="operator">-</span>nrz<span class="punctuation">,</span> <span class="operator">-</span>ncz<span class="punctuation">]</span></span><br><span class="line">facetcol <span class="operator">&lt;-</span> cut<span class="punctuation">(</span>zfacet<span class="punctuation">,</span> nbcol<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">persp<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">,</span> z<span class="punctuation">,</span></span><br><span class="line">  theta <span class="operator">=</span> <span class="number">30</span><span class="punctuation">,</span> phi <span class="operator">=</span> <span class="number">30</span><span class="punctuation">,</span></span><br><span class="line">  expand <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">,</span> col <span class="operator">=</span> color<span class="punctuation">[</span>facetcol<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>图片如下：</p>
<p><img src="20.png" alt="1"></p>
<p>在所有的可能的线性组合中（满足条件， <em>Φ<sub>11</sub><sup>2</sup></em> +  <em>Φ<sub>21</sub><sup>2</sup></em> = 1 ），只有上面的这种线性组合可以产生最高的方差（<strong>Var(Z<sub>1</sub>) 最大</strong>）。</p>
<p>这里 pop 和 ad 都是长度为100的向量，那么 Z<sub>1</sub> 也是一个长度为100的向量。例如，对于第 i 个样本，公式如下</p>
<p style=""><img src="https://math.now.sh?from=z_%7Bi%201%7D%3D0.839%20%5Ctimes%5Cleft%28%5Cmathrm%7Bpop%7D_%7Bi%7D-%5Coverline%7B%5Cmathrm%7Bpop%7D%7D%5Cright%29%2B0.544%20%5Ctimes%5Cleft(%5Cmathrm%7Bad%7D_%7Bi%7D-%5Coverline%7B%5Cmathrm%7Bad%7D%7D%5Cright)%0A" /></p><p>这些值 Z<sub>11</sub>, …… , Z<sub>n1</sub> 称为 <em>principal component scores</em> 。</p>
<p>我们对于 PCA 还有另外一种解释：第一主成分定义的直线是和数据<strong>越近越好</strong>。如下图的左图，数据与第一主成分的距离为直线距离，体现为黑色虚线，<strong>直线距离平方和最小的直线为第一主成分直线</strong>（这不就是最小二乘回归嘛）。右图为将左图向右下方旋转，旋转到第一主成分和横坐标方向一致。</p>
<p><img src="19.png" alt="1"></p>
<p>第二主成分 Z<sub>2</sub> 需要和 Z<sub>1</sub> <strong>无关</strong>，如图 6.14 所示（<strong>两条线垂直</strong>）。 第二主成分公式如下：</p>
<p style=""><img src="https://math.now.sh?from=Z_%7B2%7D%3D0.544%20%5Ctimes%28%5Cmathrm%7Bpop%7D-%5Coverline%7B%5Cmathrm%7Bpop%7D%7D%29-0.839%20%5Ctimes(%5Cmathrm%7Bad%7D-%5Coverline%7B%5Cmathrm%7Bad%7D%7D)%0A" /></p><p>因为这里我们只有两个预测因子，因此前两个主成分就包含了全部信息。但是，这里第一主成分包含了最多的信息。图 6.15 右图看出，<em>second principal component scores</em> 几乎为0，表示第二主成分几乎没有什么信息了。</p>
<p>下图为第一主成分与第二主成分与两个性状的相关。</p>
<p><img src="21.png" alt="1"></p>
<p><img src="22.png" alt="1"></p>
<h3 id="The-Principal-Components-Regression-Approach">The Principal Components Regression Approach</h3>
<p>主成分回归 (PCR) 包括创建前 M 个主成分 Z<sub>1</sub> , Z<sub>2</sub> …… Z<sub>M</sub> ，然后用这些主成分作为预测因子加入到回归模型中。这么做的基础是，我们认为<strong>少数的几个主成分，可以体现预测因子的大部分变异</strong>，最终体现在与反应变量的关系上。</p>
<p>下图显示了两次模拟数据中主成分回归中使用的主成分数量的影响。模拟数据中 n=50, p=45，左图中的模拟数据设置所有预测因子都有影响，右图中的模拟数据只有2个预测因子有作用。我们看主成分回归确实有作用。</p>
<p><img src="23.png" alt="1"></p>
<p>但是，同时比对 PCR，岭回归，lasso 三种方法。我们可以看到 PCR 方法相比于另外两种方法并没有优势。</p>
<p><img src="24.png" alt="1"></p>
<p>一般来说，仅在当只有<strong>少数几个</strong>主成分可以捕获自变量的绝大部分变异（同时可以捕获因变量的绝大部分变异）时，PCR 分析效果才比较好。比如图 6.19 的情况，前5个主成分的 bias 就降低至0，这种情况下 PCR 分析更加合适。</p>
<p>我们需要注意地是，虽然 PCR 降低了估计参数的数目，但是它不是<strong>feature selection method</strong> ，主成分回归分析还是用到了所有的 p 个自变量。因此，PCR 分析从原理上更接近于岭回归，而不是 lasso。</p>
<p>在实际的主成分回归分析中，M 的值通常通过 CV 获得。Credit 数据的PCR分析结果如下图，我们可以看到最佳的M = 10，这就相当于没有进行什么降维，因为 p=11。</p>
<p><img src="25.png" alt="1"></p>
<p>当我们进行 PCR 分析时，我们一般建议对预测因子进行 <em>standardizing</em></p>
<p style=""><img src="https://math.now.sh?from=%5Ctilde%7Bx%7D_%7Bi%20j%7D%3D%5Cfrac%7Bx_%7Bi%20j%7D%7D%7B%5Csqrt%7B%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28x_%7Bi%20j%7D-%5Cbar%7Bx%7D_%7Bj%7D%5Cright%29%5E%7B2%7D%7D%7D%0A" /></p><p>如果不进行标准化，那么 <em>high-variance</em> 的变量会在主成分分析中倾向于占据更重要的地位，会对最终的模型结果产生影响。但是，如果所有的变量均采用相同的单位，那么你也可能不选择进行标准化这一步。</p>
<h2 id="Partial-Least-Squares">Partial Least Squares</h2>
<p>PCR 分析中需要确认线性组合Z<sub>1</sub> , Z<sub>2</sub> …… Z<sub>M</sub>  ，来表示这些预测因子 。这个过程我们认为是 <em>unsupervised</em> ，因为这个过程因变量 Y 不会参与，或者说不会 <em>supervise</em> the identification of the principal components 。因此，PCR 分析有一个问题，<strong>可以很好地解释自变量变异的主成分不见得可以很好地预测因变量</strong>。</p>
<p>我们这里推出，<abbr title="Partial least squares regression, PLS">偏最小二乘回归</abbr> , 一种替代 PCR 分析的 监督方法。PLS 方法创建新变量的过程时会利用因变量 Y 的值。粗略地说，PLS 方法倾向于找到同时可以解释自变量和因变量的新变量。</p>
<p>PLS 首先将 p 个自变量和因变量进行标准化。然后PLS 的第一主成分的 <em>Φ<sub>j1</sub></em>  设置为 Y ~ X<sub>j</sub> 的简单线性回归的系数（公式如下）。因此，第一主成分的主要权重给了与因变量高度相关的变量。</p>
<p style=""><img src="https://math.now.sh?from=Z_%7B1%7D%3D%5Csum_%7Bj%3D1%7D%5E%7Bp%7D%20%5Cphi_%7Bj%201%7D%20X_%7Bj%7D%0A" /></p><p>下图显示了 p=2 的 PLS 与 PCR 的第一主成分的直线，绿色实线为 PLS 的第一主成分，虚线为 PCR 的第一主成分。PLS 的方向添加了 pop 的权重，降低了ad 的权重，表明 pop 与因变量的关系更强。</p>
<p><img src="26.png" alt="1"></p>
<p>PLS 在 <em>chemometrics</em> (化学计量学) 上很流行。实际上，PLS 的效果不见得比 岭回归或 PCR 方法更好。虽然 PLS 可以减少 bias ，但是它可能会增加 variance ，</p>
<h1>Considerations in High Dimensions</h1>
<h2 id="High-Dimensional-Data">High-Dimensional Data</h2>
<p><strong>大部分传统的统计方法都是适用于 <em>low_dimensional</em> 的情况，即 n &gt;&gt; p 。</strong> 因为以前的计算任务都是这种情况的，因此发展起来的统计方法也是仅适用于这种情况的。</p>
<p>在过去的20年中，新技术改变了数据收集的方式，因此 p 非常大的情况也就出现了，但是由于收集数据是有成本的，因此 n 一般是有限的。ISL 书中举了两个例子</p>
<ol>
<li>我们可能会通过50万个 SNP 来预测血压性状，这里 n ≈ 200，p ≈ 500,000</li>
<li>一个市场调研公司对客户的上网购物模式感兴趣，可能会把用户在搜索引擎上的所有搜索过的词汇当作特征 (features) 。对于某个特定用户，任何一个 <em>search term</em>  会被标记为 present (0)  和 absent (1) ，会创建一个非常大的二变量的 feature vector 。这里 n ≈ 1000，但是 p 非常大。</li>
</ol>
<p><em><strong>p&gt;n</strong></em> (或 p≈n )的数据集一般称为 <em>high-dimensional</em> 。传统方法并不适合用于分析这些数据，例如最小二乘线性回归，原因来自于 bias-variance trade-off 和 overfitting 。</p>
<h2 id="What-Goes-Wrong-in-High-Dimensions">What Goes Wrong in High Dimensions?</h2>
<p>这里我们用最小二乘回归举例。当 p  和 n 一样大时，最小二乘回归无法实现。理由很简单，无论因变量与自变量的真实关系如何，最小二乘法的结果都会<strong>完美拟合</strong>训练集，以至于残差均为0。</p>
<p>下图为 p=1 的两种情况，左边 n =20，右边 n=2，可以看到右边完美拟合了这两个点（无论这两个点是什么情况）。这就是 <strong>overfitting</strong> ，如果在 test data 里这个拟合结果就会很差。</p>
<p><img src="27.png" alt="1"></p>
<p>下图进一步说明了p很大时最小二乘分析的风险，其中 n = 20，  p 从 1-20 之间变化，所有的自变量均和因变量完全没有关系。如图，随着变量数目的增加，R<sup>2</sup> 逐渐趋于1，而 Training MSE 趋于0。由于所有的自变量都是噪音变量，随着自变量的提高， Test MSE 也是逐渐提高的。</p>
<p>如果分析人员很粗心，只看 training data 的情况，那么很容易得到包含所有变量的模型最好的结论。如果 p 很大，C<sub>p</sub> , AIC , BIC 方法也不合适，因为估计的残差方差是有问题的，这里就是0。校正R<sup>2</sup> 也有问题，由于 RSS 是0，校正R<sup>2</sup>  就会是1。</p>
<p><img src="28.png" alt="1"></p>
<h2 id="Regression-in-High-Dimensions">Regression in High Dimensions</h2>
<p>在 ISL 书中其实提到了很多应用于 p 很大 时的回归方法，例如 forward stepwise selection， 岭回归， lasso， 主成分回归。这些都可以用，都可以避免 overfitting 。</p>
<p>下图说明了 lasso 的表型。这里 p =20, 50, 2000 ，其中只有20个自变量是有效的， n=100 。然后通过一个无关的 test set 来评估效果。下面三个图，横坐标用的是自由度（系数个数，包括截距），不用 λ , 便于理解；纵坐标为 test MSE。</p>
<p>从下图我们可以得到三点：</p>
<ol>
<li>lasso 有作用</li>
<li>合适的λ值很重要</li>
<li>随着 p 的增加， test error 倾向于增加，除非新增的因子和反应变量真的有关系。</li>
</ol>
<p>第三点实际上是高维数据分析的一个重要的原则，称之为<abbr title="curse of dimensionality">维度陷阱</abbr> 。<strong>我们可能会本能地认为随着自变量数目的增加，模型拟合的效果会越好。</strong> 但是，比对下图地最左图与最右图结果，我们发现情况相反，p=2000的 test error 几乎是 p=20 的两倍。</p>
<p><img src="29.png" alt="1"></p>
<p>一般来说，<strong>新增 signal features 会增加模型拟合效果；但是新增 noise features 会降低模型拟合效果</strong>。因为新增 noise features 会增加维度，使得 overfitting 的风险剧增。</p>
<p>因此，可以收集成千上万 features 的新技术是一把双刃剑：如果这些 features 都和关心的问题有关，那么就可以改善模型；但是如果这些 features 是噪音变量，那么把这些 features 加入到模型中就可能带来负优化。</p>
<h2 id="Intercepting-Results-in-High-Dimensions">Intercepting Results in High Dimensions</h2>
<p>当我们对 high-dimensional setting 执行岭回归，lasso 等分析时，<strong>在解释结果时需要小心</strong>。在前面，我们提到了 <em>multicollinearity</em> ，意思是自变量之间的相关关系。在高维数据中， <em>multicollinearity</em> 的问题更加极端：所有的自变量都可以写成其他自变量的线性组合。这意味着，我们永远不知道哪些变量是真的与因变量有关，哪些仅仅是由于与signal features 相关导致与因变量相关。</p>
<p>例如，假设我们想要通过 50万个SNP来预测血压，forward stepwise selection 方法选择了 17个 SNP 加入到预测模型中。我们可能很容易错误地推断出这17个 SNP 预测血压地效果比其他 SNP 更有效。实际上，可能你可以选出很多个 17 SNPs sets，预测效果都和你选的模型一样。如果我们采用一个不同的 training data，我们可能会得到一个完全不同的 SNP 集合，这并不是说我们之前得到的模型是错的或无效的，事实上可能之前的模型非常有效，仅仅是我们不要过分解读我们获得的结果，要认识到我们仅仅是得到了 <em>one of many possible models</em> for predicting blood pressure , 而且需要后期更多数据的验证。</p>
<p>另外，在评价高维数据的模拟拟合效果的时候，需要注意之前的所有的训练集的统计量已经全部失效了。因此，很重要地是，我们需要采用 test set 的结果，或 cross-validation errors。</p>
<h1>R代码</h1>
<h2 id="Subset-Selection-Methods">Subset Selection Methods</h2>
<h3 id="Best-Subset-Selection-2">Best Subset Selection</h3>
<p>查看数据，清除缺失值</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> library<span class="punctuation">(</span>ISLR<span class="punctuation">)</span></span><br><span class="line">Warning message<span class="operator">:</span></span><br><span class="line">程辑包‘ISLR’是用R版本<span class="number">4.0</span>.5 来建造的 </span><br><span class="line"><span class="operator">&gt;</span> fix<span class="punctuation">(</span>Hitters<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">names</span><span class="punctuation">(</span>Hitters<span class="punctuation">)</span></span><br><span class="line"> <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;AtBat&quot;</span>     <span class="string">&quot;Hits&quot;</span>      <span class="string">&quot;HmRun&quot;</span>     <span class="string">&quot;Runs&quot;</span>      <span class="string">&quot;RBI&quot;</span>       <span class="string">&quot;Walks&quot;</span>     <span class="string">&quot;Years&quot;</span>    </span><br><span class="line"> <span class="punctuation">[</span><span class="number">8</span><span class="punctuation">]</span> <span class="string">&quot;CAtBat&quot;</span>    <span class="string">&quot;CHits&quot;</span>     <span class="string">&quot;CHmRun&quot;</span>    <span class="string">&quot;CRuns&quot;</span>     <span class="string">&quot;CRBI&quot;</span>      <span class="string">&quot;CWalks&quot;</span>    <span class="string">&quot;League&quot;</span>   </span><br><span class="line"><span class="punctuation">[</span><span class="number">15</span><span class="punctuation">]</span> <span class="string">&quot;Division&quot;</span>  <span class="string">&quot;PutOuts&quot;</span>   <span class="string">&quot;Assists&quot;</span>   <span class="string">&quot;Errors&quot;</span>    <span class="string">&quot;Salary&quot;</span>    <span class="string">&quot;NewLeague&quot;</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">dim</span><span class="punctuation">(</span>Hitters<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">322</span>  <span class="number">20</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">sum</span><span class="punctuation">(</span><span class="built_in">is.na</span><span class="punctuation">(</span>Hitters<span class="operator">$</span>Salary<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">59</span></span><br><span class="line"><span class="operator">&gt;</span> Hitters <span class="operator">=</span> na.omit<span class="punctuation">(</span>Hitters<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">dim</span><span class="punctuation">(</span>Hitters<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">263</span>  <span class="number">20</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">sum</span><span class="punctuation">(</span><span class="built_in">is.na</span><span class="punctuation">(</span>Hitters<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>leaps 包 的 regsubsets() 函数可以执行 best subset selction，每个因子数目下，最好的模型通过 RSS 确定（regsubsets()  默认的最大因子数目为8，可以通过nvmax 设定）。最终结果可以通过 summary() 查看</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> library<span class="punctuation">(</span>leaps<span class="punctuation">)</span></span><br><span class="line">Warning message<span class="operator">:</span></span><br><span class="line">程辑包‘leaps’是用R版本<span class="number">4.0</span>.5 来建造的 </span><br><span class="line"><span class="operator">&gt;</span> regfit.full <span class="operator">=</span> regsubsets<span class="punctuation">(</span>Salary <span class="operator">~</span> .<span class="punctuation">,</span> Hitters<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 默认最大8个因子</span></span><br><span class="line"><span class="operator">&gt;</span> summary<span class="punctuation">(</span>regfit.full<span class="punctuation">)</span></span><br><span class="line">Subset selection object</span><br><span class="line">Call<span class="operator">:</span> regsubsets.formula<span class="punctuation">(</span>Salary <span class="operator">~</span> .<span class="punctuation">,</span> Hitters<span class="punctuation">)</span></span><br><span class="line"><span class="number">19</span> Variables  <span class="punctuation">(</span>and intercept<span class="punctuation">)</span></span><br><span class="line">           Forced <span class="keyword">in</span> Forced out</span><br><span class="line">AtBat          <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">Hits           <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">HmRun          <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">Runs           <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">RBI            <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">Walks          <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">Years          <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">CAtBat         <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">CHits          <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">CHmRun         <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">CRuns          <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">CRBI           <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">CWalks         <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">LeagueN        <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">DivisionW      <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">PutOuts        <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">Assists        <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">Errors         <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line">NewLeagueN     <span class="literal">FALSE</span>      <span class="literal">FALSE</span></span><br><span class="line"><span class="number">1</span> subsets of each size up to <span class="number">8</span></span><br><span class="line">Selection Algorithm<span class="operator">:</span> exhaustive</span><br><span class="line">         AtBat Hits HmRun Runs RBI Walks Years CAtBat CHits CHmRun CRuns CRBI CWalks</span><br><span class="line"><span class="number">1</span>  <span class="punctuation">(</span> <span class="number">1</span> <span class="punctuation">)</span> <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>  <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>  <span class="string">&quot; &quot;</span> <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   </span><br><span class="line"><span class="number">2</span>  <span class="punctuation">(</span> <span class="number">1</span> <span class="punctuation">)</span> <span class="string">&quot; &quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>  <span class="string">&quot; &quot;</span> <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   </span><br><span class="line"><span class="number">3</span>  <span class="punctuation">(</span> <span class="number">1</span> <span class="punctuation">)</span> <span class="string">&quot; &quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>  <span class="string">&quot; &quot;</span> <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   </span><br><span class="line"><span class="number">4</span>  <span class="punctuation">(</span> <span class="number">1</span> <span class="punctuation">)</span> <span class="string">&quot; &quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>  <span class="string">&quot; &quot;</span> <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   </span><br><span class="line"><span class="number">5</span>  <span class="punctuation">(</span> <span class="number">1</span> <span class="punctuation">)</span> <span class="string">&quot;*&quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>  <span class="string">&quot; &quot;</span> <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   </span><br><span class="line"><span class="number">6</span>  <span class="punctuation">(</span> <span class="number">1</span> <span class="punctuation">)</span> <span class="string">&quot;*&quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>  <span class="string">&quot; &quot;</span> <span class="string">&quot;*&quot;</span>   <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   </span><br><span class="line"><span class="number">7</span>  <span class="punctuation">(</span> <span class="number">1</span> <span class="punctuation">)</span> <span class="string">&quot; &quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>  <span class="string">&quot; &quot;</span> <span class="string">&quot;*&quot;</span>   <span class="string">&quot; &quot;</span>   <span class="string">&quot;*&quot;</span>    <span class="string">&quot;*&quot;</span>   <span class="string">&quot;*&quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>  <span class="string">&quot; &quot;</span>   </span><br><span class="line"><span class="number">8</span>  <span class="punctuation">(</span> <span class="number">1</span> <span class="punctuation">)</span> <span class="string">&quot;*&quot;</span>   <span class="string">&quot;*&quot;</span>  <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>  <span class="string">&quot; &quot;</span> <span class="string">&quot;*&quot;</span>   <span class="string">&quot; &quot;</span>   <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>   <span class="string">&quot;*&quot;</span>    <span class="string">&quot;*&quot;</span>   <span class="string">&quot; &quot;</span>  <span class="string">&quot;*&quot;</span>   </span><br><span class="line">         LeagueN DivisionW PutOuts Assists Errors NewLeagueN</span><br><span class="line"><span class="number">1</span>  <span class="punctuation">(</span> <span class="number">1</span> <span class="punctuation">)</span> <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>       <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>       </span><br><span class="line"><span class="number">2</span>  <span class="punctuation">(</span> <span class="number">1</span> <span class="punctuation">)</span> <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>       <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>       </span><br><span class="line"><span class="number">3</span>  <span class="punctuation">(</span> <span class="number">1</span> <span class="punctuation">)</span> <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>       <span class="string">&quot;*&quot;</span>     <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>       </span><br><span class="line"><span class="number">4</span>  <span class="punctuation">(</span> <span class="number">1</span> <span class="punctuation">)</span> <span class="string">&quot; &quot;</span>     <span class="string">&quot;*&quot;</span>       <span class="string">&quot;*&quot;</span>     <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>       </span><br><span class="line"><span class="number">5</span>  <span class="punctuation">(</span> <span class="number">1</span> <span class="punctuation">)</span> <span class="string">&quot; &quot;</span>     <span class="string">&quot;*&quot;</span>       <span class="string">&quot;*&quot;</span>     <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>       </span><br><span class="line"><span class="number">6</span>  <span class="punctuation">(</span> <span class="number">1</span> <span class="punctuation">)</span> <span class="string">&quot; &quot;</span>     <span class="string">&quot;*&quot;</span>       <span class="string">&quot;*&quot;</span>     <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>       </span><br><span class="line"><span class="number">7</span>  <span class="punctuation">(</span> <span class="number">1</span> <span class="punctuation">)</span> <span class="string">&quot; &quot;</span>     <span class="string">&quot;*&quot;</span>       <span class="string">&quot;*&quot;</span>     <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>       </span><br><span class="line"><span class="number">8</span>  <span class="punctuation">(</span> <span class="number">1</span> <span class="punctuation">)</span> <span class="string">&quot; &quot;</span>     <span class="string">&quot;*&quot;</span>       <span class="string">&quot;*&quot;</span>     <span class="string">&quot; &quot;</span>     <span class="string">&quot; &quot;</span>    <span class="string">&quot; &quot;</span>       </span><br><span class="line"><span class="operator">&gt;</span> <span class="comment"># 给定最大因子数</span></span><br><span class="line"><span class="operator">&gt;</span> regfit.full <span class="operator">=</span> regsubsets<span class="punctuation">(</span>Salary <span class="operator">~</span>.<span class="punctuation">,</span> data<span class="operator">=</span>Hitters<span class="punctuation">,</span> nvmax<span class="operator">=</span><span class="number">19</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> reg.summary <span class="operator">=</span> summary<span class="punctuation">(</span>regfit.full<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>summary() 也可以返回 R<sup>2</sup>  ,  校正R<sup>2</sup>  ，C<sub>p</sub> 等结果，我们可以根据这些统计量挑选最终的模型。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="built_in">names</span><span class="punctuation">(</span>reg.summary<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;which&quot;</span>  <span class="string">&quot;rsq&quot;</span>    <span class="string">&quot;rss&quot;</span>    <span class="string">&quot;adjr2&quot;</span>  <span class="string">&quot;cp&quot;</span>     <span class="string">&quot;bic&quot;</span>    <span class="string">&quot;outmat&quot;</span> <span class="string">&quot;obj&quot;</span>   </span><br><span class="line"><span class="operator">&gt;</span> <span class="comment">#查看 R2 结果</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment">#可以看到随着因子数量增加，R2无脑增加</span></span><br><span class="line"><span class="operator">&gt;</span> reg.summary<span class="operator">$</span>rsq</span><br><span class="line"> <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">0.3214501</span> <span class="number">0.4252237</span> <span class="number">0.4514294</span> <span class="number">0.4754067</span> <span class="number">0.4908036</span> <span class="number">0.5087146</span> <span class="number">0.5141227</span> <span class="number">0.5285569</span> <span class="number">0.5346124</span> <span class="number">0.5404950</span> <span class="number">0.5426153</span> <span class="number">0.5436302</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">13</span><span class="punctuation">]</span> <span class="number">0.5444570</span> <span class="number">0.5452164</span> <span class="number">0.5454692</span> <span class="number">0.5457656</span> <span class="number">0.5459518</span> <span class="number">0.5460945</span> <span class="number">0.5461159</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将所有统计量画在一张图上</span></span><br><span class="line">par<span class="punctuation">(</span>mfrow<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">19</span><span class="punctuation">,</span>reg.summary<span class="operator">$</span>rss<span class="punctuation">,</span> xlab <span class="operator">=</span> <span class="string">&quot;NUmber of Variables&quot;</span><span class="punctuation">,</span>ylab <span class="operator">=</span> <span class="string">&quot;RSS&quot;</span><span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;l&quot;</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">19</span><span class="punctuation">,</span>reg.summary<span class="operator">$</span>adjr2<span class="punctuation">,</span> xlab <span class="operator">=</span> <span class="string">&quot;NUmber of Variables&quot;</span><span class="punctuation">,</span>ylab <span class="operator">=</span> <span class="string">&quot;Adjusted RSq&quot;</span><span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;l&quot;</span><span class="punctuation">)</span></span><br><span class="line">which.max<span class="punctuation">(</span>reg.summary<span class="operator">$</span>adjr2<span class="punctuation">)</span></span><br><span class="line">points<span class="punctuation">(</span><span class="number">11</span><span class="punctuation">,</span>reg.summary<span class="operator">$</span>adjr2<span class="punctuation">[</span><span class="number">11</span><span class="punctuation">]</span><span class="punctuation">,</span> col<span class="operator">=</span><span class="string">&quot;red&quot;</span><span class="punctuation">,</span> cex<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span>pch<span class="operator">=</span><span class="number">20</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">19</span><span class="punctuation">,</span>reg.summary<span class="operator">$</span>cp<span class="punctuation">,</span> xlab <span class="operator">=</span> <span class="string">&quot;NUmber of Variables&quot;</span><span class="punctuation">,</span>ylab <span class="operator">=</span> <span class="string">&quot;Cp&quot;</span><span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;l&quot;</span><span class="punctuation">)</span></span><br><span class="line">points<span class="punctuation">(</span>which.min<span class="punctuation">(</span>reg.summary<span class="operator">$</span>cp<span class="punctuation">)</span><span class="punctuation">,</span> reg.summary<span class="operator">$</span>cp<span class="punctuation">[</span>which.min<span class="punctuation">(</span>reg.summary<span class="operator">$</span>cp<span class="punctuation">)</span><span class="punctuation">]</span><span class="punctuation">,</span> col<span class="operator">=</span><span class="string">&quot;red&quot;</span><span class="punctuation">,</span> cex<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span> pch<span class="operator">=</span><span class="number">20</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">19</span><span class="punctuation">,</span>reg.summary<span class="operator">$</span>bic<span class="punctuation">,</span> xlab <span class="operator">=</span> <span class="string">&quot;NUmber of Variables&quot;</span><span class="punctuation">,</span>ylab <span class="operator">=</span> <span class="string">&quot;BIC&quot;</span><span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;l&quot;</span><span class="punctuation">)</span></span><br><span class="line">points<span class="punctuation">(</span>which.min<span class="punctuation">(</span>reg.summary<span class="operator">$</span>bic<span class="punctuation">)</span><span class="punctuation">,</span> reg.summary<span class="operator">$</span>bic<span class="punctuation">[</span>which.min<span class="punctuation">(</span>reg.summary<span class="operator">$</span>bic<span class="punctuation">)</span><span class="punctuation">]</span><span class="punctuation">,</span> col<span class="operator">=</span><span class="string">&quot;red&quot;</span><span class="punctuation">,</span> cex<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span> pch<span class="operator">=</span><span class="number">20</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>手动画图结果如下：</p>
<p><img src="30.png" alt="1"></p>
<p>regsubsets() 函数本身有一个内建函数 plot() ，也可以画图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># regsubsets() 内建函数</span><br><span class="line">plot(regfit.full, scale=&quot;r2&quot;)</span><br><span class="line">plot(regfit.full, scale=&quot;adjr2&quot;)</span><br><span class="line">plot(regfit.full, scale=&quot;Cp&quot;)</span><br><span class="line">plot(regfit.full, scale=&quot;bic&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是画出的图看不懂</p>
<p><img src="31.png" alt="1"></p>
<h3 id="Forward-and-Backward-Stepwise-Selection">Forward and Backward Stepwise Selection</h3>
<p>我们也可以用 regsubsets() 执行这两种算法，只要新增一个参数 method</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 向前/后</span></span><br><span class="line">regfit.fwd <span class="operator">=</span> regsubsets<span class="punctuation">(</span>Salary<span class="operator">~</span>.<span class="punctuation">,</span> data<span class="operator">=</span>Hitters<span class="punctuation">,</span> nvmax<span class="operator">=</span><span class="number">19</span><span class="punctuation">,</span> method<span class="operator">=</span><span class="string">&#x27;forward&#x27;</span><span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>regfit.fwd<span class="punctuation">)</span></span><br><span class="line">regfit.bwd <span class="operator">=</span> regsubsets<span class="punctuation">(</span>Salary<span class="operator">~</span>.<span class="punctuation">,</span> data<span class="operator">=</span>Hitters<span class="punctuation">,</span> nvmax<span class="operator">=</span><span class="number">19</span><span class="punctuation">,</span> method<span class="operator">=</span><span class="string">&#x27;backward&#x27;</span><span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>regfit.bwd<span class="punctuation">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Choosing-Among-Models-Using-the-Validation-Set-Approach-and-Cross-Validation">Choosing Among Models Using the Validation Set Approach and Cross-Validation</h3>
<p>上面是通过 C<sub>p</sub> , BIC, adjusted R<sup>2</sup> 这三个统计量来选择模型，这里是用验证集或交叉验证来实现。</p>
<p>这两种方法的思路都是，<strong>先找到最佳因子数目</strong>，然后用全部数据和 best subset 方法，找最佳因子数目下的模型。</p>
<p>为了适用验证集检验的方式，我们首先要把总数据拆分成训练集和验证集。首先根据训练集找到每个因子数量下的最好模型，再用不同因子数量的模型预测 test data， 计算 test MSE，找 test MSE 最小的因子数量。<strong>最后需要用全部数据使用 best subset 重新估计最佳因子数目的模型</strong>，因为用的数据越多，估计的参数越准，前面训练集估计参数只用了一部分数据（有可能最后一次找到的因子和前面训练集的因子不一样）。</p>
<p>10倍交叉验证的方法：首先随机分成10分，每一次随机挑出一份作为验证集，另外九份作为训练集。每一次计算出所有因子水平的 test MSE，最终结果是一个 10×19 的矩阵，其中元素 (i, j) 是第i 个 fold 的 j 个因子水平下最好模型的 test MSE。计算每一列的均值，查找最小值，即为最好的因子数目。最后需要用全部数据使用 best subset 重新估计最佳因子数目的模型，比如这里交叉验证得到的最佳因子数目为 11， 然后得到最终模型的代码如下：</p>
<p><img src="32.png" alt="1"></p>
<h2 id="Ridge-Regression-and-the-Lasso">Ridge Regression and the Lasso</h2>
<p>这里我们用 glmnet 包来实现岭回归和 lasso 算法。</p>
<p>model.matrix() 创建因子矩阵特别好用，会自动将分类变量转化为哑变量。glmnet() 只接受哑变量和连续变量。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成因子与因变量</span></span><br><span class="line"></span><br><span class="line">x <span class="operator">=</span> model.matrix<span class="punctuation">(</span>Salary<span class="operator">~</span>.<span class="punctuation">,</span> Hitters<span class="punctuation">)</span><span class="punctuation">[</span><span class="punctuation">,</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">y <span class="operator">=</span> Hitters<span class="operator">$</span>Salary</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Ridge-Regression-2">Ridge Regression</h3>
<p>glmnet() 有一个 alpha 参数可以指定模型，如果 alpha=0 ，那么就是岭回归；如果 alpha=1，那么就是 lasso。</p>
<p>我们先看岭回归</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 岭回归</span></span><br><span class="line">library<span class="punctuation">(</span>glmnet<span class="punctuation">)</span></span><br><span class="line">grid <span class="operator">=</span> <span class="number">10</span><span class="operator">^</span>seq<span class="punctuation">(</span><span class="number">10</span><span class="punctuation">,</span><span class="operator">-</span><span class="number">2</span><span class="punctuation">,</span><span class="built_in">length</span><span class="operator">=</span><span class="number">100</span><span class="punctuation">)</span></span><br><span class="line">ridge.mod <span class="operator">=</span> glmnet<span class="punctuation">(</span>x<span class="punctuation">,</span>y<span class="punctuation">,</span>alpha<span class="operator">=</span><span class="number">0</span><span class="punctuation">,</span>lambda<span class="operator">=</span>grid<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>glmnet() 函数一般会指定选择 λ 值的范围。这里是想指定λ的范围为 10<sup>10</sup> 到 10<sup>-2</sup> ，覆盖了从只包含截距到普通的最小二乘回归的所有范围。glmnet() 默认会对所有变量进行标准化，如果想要关闭这一点，可以使用 standardize=FALSE 。</p>
<p>每一个λ值都会有相应的岭回归系数，可以通过coef() 查看，这里是20×100的矩阵，20 是因子数（包括截距），100 是 λ 值的数目。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="built_in">dim</span><span class="punctuation">(</span>coef<span class="punctuation">(</span>ridge.mod<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span>  <span class="number">20</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>查看某一个λ值的结果</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> ridge.mod<span class="operator">$</span>lambda<span class="punctuation">[</span><span class="number">50</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">11497.57</span></span><br><span class="line"><span class="operator">&gt;</span> coef<span class="punctuation">(</span>ridge.mod<span class="punctuation">)</span><span class="punctuation">[</span><span class="punctuation">,</span><span class="number">50</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">(</span>Intercept<span class="punctuation">)</span>         AtBat          Hits         HmRun          Runs           RBI </span><br><span class="line"><span class="number">407.356050200</span>   <span class="number">0.036957182</span>   <span class="number">0.138180344</span>   <span class="number">0.524629976</span>   <span class="number">0.230701523</span>   <span class="number">0.239841459</span> </span><br><span class="line">        Walks         Years        CAtBat         CHits        CHmRun         CRuns </span><br><span class="line">  <span class="number">0.289618741</span>   <span class="number">1.107702929</span>   <span class="number">0.003131815</span>   <span class="number">0.011653637</span>   <span class="number">0.087545670</span>   <span class="number">0.023379882</span> </span><br><span class="line">         CRBI        CWalks       LeagueN     DivisionW       PutOuts       Assists </span><br><span class="line">  <span class="number">0.024138320</span>   <span class="number">0.025015421</span>   <span class="number">0.085028114</span>  <span class="operator">-</span><span class="number">6.215440973</span>   <span class="number">0.016482577</span>   <span class="number">0.002612988</span> </span><br><span class="line">       Errors    NewLeagueN </span><br><span class="line"> <span class="operator">-</span><span class="number">0.020502690</span>   <span class="number">0.301433531</span> </span><br><span class="line"><span class="operator">&gt;</span> <span class="comment">#计算岭回归的惩罚项</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">sqrt</span><span class="punctuation">(</span><span class="built_in">sum</span><span class="punctuation">(</span>coef<span class="punctuation">(</span>ridge.mod<span class="punctuation">)</span><span class="punctuation">[</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">,</span><span class="number">50</span><span class="punctuation">]</span><span class="operator">^</span><span class="number">2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">6.360612</span></span><br></pre></td></tr></table></figure>
<p>我们可以用交叉验证的方式来选择 λ 值，我们可以用 cv.glmnet() 函数，这个函数默认采取十倍的交叉验证，可以通过 nfolds 参数修改。这里我们通过 set.seed() 函数使我们的结果可重复，因为 CV 中参验群体的划分是随机的。通过交叉验证找到了最佳的的 λ 值后，我们需要使用全部数据，使用最佳的λ值来估计模型系数。</p>
<p>代码略</p>
<h3 id="The-Lasso-2">The Lasso</h3>
<p>lassso 算法，只要改成 alpha = 1 即可。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>数据分析</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>重复抽样方法</title>
    <url>/posts/c54c0f20/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>ISL 真是好书！</p>
<span id="more"></span> 
<h1>资料</h1>
<p><a href="https://www.statlearning.com/">An Introduction to Statistical Learning</a>，下文简称 <strong>ISL</strong></p>
<h1>概述</h1>
<p>重复抽样方法 (<em>Resampling methods</em>) 是统计中的一个常用工具。通过对一个训练集不断地提取子集，然后用同一个模型进行拟合，来获取这个模型的更多的信息，比如 <em>variance</em> 。</p>
<p>重复抽样方法最常用的是 <strong>交叉验证</strong>(<em>cross-validation</em>) 和 <strong>自助法</strong>(<em>bootstrap</em>) 。这两种方法都很重要，比如交叉验证方法可以用来估计模型的 <em>test error</em> ，从而用来评价模型/方法的表现。这种评估模型表现的过程称为 <em>model assessment</em> ，而选择一个模型的自由度（<em>level of flexibility</em>）称为 <em>model selection</em> 。自助法一般用于评估参数估计的准确性。</p>
<h1>交叉验证</h1>
<p>在 ISL 前面的章节里提过了 <em>test error rate</em> 和 <em>trainging error rate</em> 。一般我们评价模型的好坏会用 <em>test error rate</em> ，但是这就要求除了有<em>training data set</em> 外，还需要有 <em>test data set</em> 。但是实际情况里，我们可能会没有一个比较大的 <em>test data</em> 来估计 <em>test error rate</em> ，也就是说我们只有一个群体的数据。通过交叉验证方法，我们可以人为的从训练集中提取一个子集来计算 <em>test error rate</em> 。</p>
<h2 id="The-Validation-Set-Approach">The Validation Set Approach</h2>
<p>这个方法的思路就是将所有观测值分为两部分，训练集和验证集。训练集用于拟合模拟，然后将得到的模型用于验证集，计算 <em>test error rate</em> ，数量性状一般就是计算 <strong>均方误差(MSE)</strong>。</p>
<p>在 ISL 的书中提到了一个例子，在 Auto 数据集中，mpg 和 horsepower 之间存在非线性关系，然后用 horsepower 和 horsepower<sup>2</sup> 的模型效果更好。<strong>我们很容易想到如果继续添加立方项或者更多的项，效果会不会更好？</strong> 这在前面的例子中是通过查看立方项和更高的项的 P 值来确定的，但是我们也可以用交叉验证来回答。我们可以随机将 392 个观测值随机分为两个集合，一半作为训练集，一半作为验证集；对于相同的训练集，采用不同的模型进行拟合，然后用于同样的验证集计算MSE。效果如下，左边为一次结果，右边为重复十次结果。十次重复结果各不相同，均方误差最小值的项均不相同，我们只能说简单线性回归不是最优解，然后高于2项的回归即便有提升，提升幅度一般也比较小。</p>
<p><img src="1.png" alt="1"></p>
<p><strong>The validation set approach</strong> 这种方法思路非常简单，易于使用，但是又两个潜在的缺点：</p>
<ol>
<li>就像上面右图的结果，多次抽样的结果差异较大，取决于你把哪些个体放在训练集，把哪些个体放在验证集。</li>
<li>这个方法，仅仅只使用了一部分个体（划定为训练集的个体）用于拟合模型。一般来说，样本量越少，样本拟合效果越差，因此这里计算得到的 test error rate 比实际情况要高。</li>
</ol>
<h2 id="Leave-One-Out-Cross-Validation">Leave-One-Out Cross-Validation</h2>
<p><em>Leave-One-Out Cross-Validation</em> (LOOCV) 接近于上面的 <em>validation set approach</em> ，但是这种方法尝试来弥补上面这种方法的缺点。</p>
<p>LOOCV 也是把观测值分为两个群体，但区别在于它只将一个个体划定给验证集，将其他的 n-1 个个体划定给训练集，用于拟合模型，然后预测留出来的一个个体的，计算MSE。由于只有一个个体, MSE 的公式变为</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BMSE%7D_%7B1%7D%3D%5Cleft%28y_%7B1%7D-%5Chat%7By%7D_%7B1%7D%5Cright%29%5E%7B2%7D%0A" /></p><p>虽然MSE<sub>1</sub> 是无偏的，但是它是一个很糟糕的估计值，因为变异太大。</p>
<p>我们可以重复这个过程，让所有个体都做一次验证个体，也就是总共重复n次。图示如下：</p>
<p><img src="2.png" alt="1"></p>
<p>然后我们计算这n次的平均MSE</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BCV%7D_%7B%28n%29%7D%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Cmathrm%7BMSE%7D_%7Bi%7D%0A" /></p><p>LOOCV 方法相比于上面的 validation set 方法又很多优势。首先，LOOCV 方法有更小的 bias，因为 LOOCV 方法用了接近所有个体来拟合模型，而 validation set 只用了一半。因此，LOOCV 方法不会高估 <em>test error rate</em> 。其次，validation set 随机划分群体使得多次重复结果的差异较大，而多次重复 LOOCV 也只会产生一个相同的结果，LOOCV 方法根本没有训练集和验证集划分的随意性问题。</p>
<p>我们对 Auto 数据集采用 LOOCV 方法进行计算，结果如下图左图（右图为9次单独的 10-fold CV结果，每次均随机地将群体分成10份。从这里可以看出 10-fold CV 多次结果之间的差异较小）</p>
<p><img src="3.png" alt="1"></p>
<p>LOOCV 的计算量比较大，毕竟需要计算 n 次。如果 n 比较大，那么 可能会非常耗时。<strong>在最小二乘的线性回归或二项式回归分析中</strong>，存在一个简化可以使得 LOOCV 的计算量与单次模型拟合差不多，公式如下。这个式子看上去类似于普通的 MSE 的计算公式，除了分母部分增加了 一个 (1-h<sub>i</sub>)</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BCV%7D_%7B%28n%29%7D%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft(%5Cfrac%7By_%7Bi%7D-%5Chat%7By%7D_%7Bi%7D%7D%7B1-h_%7Bi%7D%7D%5Cright)%5E%7B2%7D%0A" /></p><p>这里预测值 y_hat 是采用原始的最小二乘拟合的结果， <em>h<sub>i</sub></em>  是 leverage ，值在1/n 与 1 之间，表示一个观测值对模型拟合的影响程度。因此，对于 high-leverage 的点，1-  <em>h<sub>i</sub></em>  越低，这里相当于放大了残差。</p>
<p style=""><img src="https://math.now.sh?from=h_%7Bi%7D%3D%5Cfrac%7B1%7D%7Bn%7D%2B%5Cfrac%7B%5Cleft%28x_%7Bi%7D-%5Cbar%7Bx%7D%5Cright%29%5E%7B2%7D%7D%7B%5Csum_%7Bi%5E%7B%5Cprime%7D%3D1%7D%5E%7Bn%7D%5Cleft(x_%7Bi%5E%7B%5Cprime%7D%7D-%5Cbar%7Bx%7D%5Cright)%5E%7B2%7D%7D%0A" /></p><p>LOOCV 是一个一般方法，可以用于各种各样的模型，比如用于逻辑回归或LDA分析。</p>
<h2 id="k-fold-Cross-Validation">k-fold Cross-Validation</h2>
<p>LOOCV 方法的一个备选方法是 k-fold CV 方法。这种方法将所有个体随机分成相同大小的 k groups ，或者说是 k folds。将第一个 fold 视为验证集，然后用其他folds拟合模型，计算得到 MSE<sub>1</sub>。这个过程重复 k 次，每次均拿出一个fold 视为验证集，其他视为训练集，得到多个 MSE。</p>
<p>然后通过下面这个式子计算平均MSE</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BCV%7D_%7B%28k%29%7D%3D%5Cfrac%7B1%7D%7Bk%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bk%7D%20%5Cmathrm%7BMSE%7D_%7Bi%7D%0A" /></p><p>下图便反映了这个过程</p>
<p><img src="4.png" alt="1"></p>
<p>我们很容易看到，LOOCV 方法是 k-fold CV 方法的一个特例，即 k = n。在实际中，一般k会设为5或10，那么k设为5/10 相比于 设为n 的优势在哪里呢？首先最明显的就是<strong>计算量</strong>，因为 LOOCV 需要拟合模型 n 次（通过最小二乘法估计的线性模型除外），而 k-fold CV 只需要拟合 5次或10次。</p>
<p>但我们使用真实数据时，由于我们不知道真实的 test MSE ，因此我们很难决定CV估计的准确性。但是，如果我们使用模拟数据，我们计算得到真实的 test MSE，因此可以评价CV结果。下图中，我们画出了CV得到的 test error rate 估计值 和 真实的 test error rate，这里蓝线是真实值，黑色虚线是LOOCV估计值，红色线是 10-fold CV 估计值。我们可以看到 10-fold CV 和 LOOCV 结果差不多。</p>
<p><img src="5.png" alt="1"></p>
<p>但我执行交叉验证时，我们的目的可能是看一个统计模型应用在一个与训练集独立的数据中的效果，也就是说， 我们感兴趣地是 test MSE 的 估计值。但是有时候，我们仅仅是对 <em>estimated test MSE</em> 曲线的最小值，比如比较一系列统计方法/模型的优劣，一种模型但是使用不同水平的 <em>flexibility</em> 的比较，为了得到最佳的模型，或者最佳的 <em>flexibility</em> 。这种情况下，test MSE 的最小值的位置是最重要的，但是实际test MSE的大小不重要。根据上面的图(5.6)，我们可以看到 CV 的MSE估计值可能是低估的，但是通过CV曲线来查找最佳的 <em>flexibility</em> 水平基本和真实情况差不多。</p>
<h2 id="Bias-Variance-Trade-Off-for-k-fold-CV">Bias-Variance Trade-Off for k-fold CV</h2>
<p>前面起到 k-fold CV 相比于 LOOCV 的优点是减少计算量，其实 k-fold CV 相比于 LOOCV 还有一个优点，就是 <strong><em>test error rate</em> 估计更准确</strong>。这和 bias-variance trade-off 有关。</p>
<p>前面提到过 validation set 方法估计得到的 test error rate 会比真实值高，因为只用了一半数据来拟合模型。通过这个逻辑，LOOCV 方法会给出一个接近无偏的 test error ，因为几乎用了全部的数据来拟合模型。然后 k-fold CV 方法的 bias 会介于这二者之间。</p>
<p>但是我们知道，bias 并不是我们关心的估计过程的唯一指标，我们还关心 variance ，结果表明 LOOCV 比 k-fold CV 有更高的 variance 。为什么是这样呢？当我们执行 LOOCV 方法时，我们拟合的n个模型，几乎都是使用相同的数据；因此，这些模型的拟合结果之间具有高度的相关性。但是当我们执行 k-fold CV 时，k 个拟合的模型之间相关较弱，因为训练集数据之间的重合程度较小。因为很多高度相关的数量性状的均值比相关程度较低的数量性状均值的 variance 更小，因此 LOOCV 方法得到的 test error 估计值通常比 k-fold CV 方法有更高的 variance。</p>
<p>总结一下，综合考虑 bias 和 variance ，我们容易得到 k=5 或 k=10 的 k-fold CV 得到的 test error estimates 最佳，既不会有很高的 bias ，也不会有很高的 variance。</p>
<h2 id="Cross-Validation-on-Classification-problems">Cross-Validation on Classification problems</h2>
<p>上面提高的交叉验证的使用均是基于<strong>数量性状</strong>，因此都是用 MSE 来衡量 test error 。但是交叉验证同样可以用于质量性状的分析上，其实大同小异，只是用 test error rate 替换 MSE 来衡量 test error。例如， LOOCV 的公式如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cmathrm%7BCV%7D_%7B%28n%29%7D%3D%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20%5Cmathrm%7BErr%7D_%7Bi%7D%0A" /></p><p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BErr%7D_%7Bi%7D%3DI%5Cleft%28y_%7Bi%7D%20%5Cneq%20%5Chat%7By%7D_%7Bi%7D%5Cright%29%0A" /></p><p>下图为一个模拟数据的逻辑回归结果，p=2，通过多项式回归不断增加自由度。</p>
<p><img src="6.png" alt="1"></p>
<p>但是在真实的数据中，真实的决策线和 test error rate 均是未知的。因此我们需要决定上面的四种逻辑回归哪一种比较好。我们可以通过交叉验证来实现这一点。下图的左图显示了十倍交叉验证的结果（黑线），真实的 test error 是棕线，十倍交叉验证的结果很好的预测了真实结果（略低估了真实结果）。右图显示了KNN的结果，我们可以随着 flexibility 的增加，traing error rate 迅速下降，而 test error rate 呈U字型变化，这再次说明了不能用 training error rate 来说明模型的好坏。</p>
<p><img src="7.png" alt="1"></p>
<h1>自助法</h1>
<p>自助法可以衡量一个给定估计值或方法的不确定性。作为一个简单的例子，自助法可以用来估计线性回归拟合参数的标准误，这并不是很实用，因为R在做回归分析的时候会自动给出标准误。但是像一些复杂的统计方法，或者软件不能自动给出的不确定性，自助法就有用了。</p>
<p>如果我们使用模拟数据，计算一个参数估计的标准误，可以直接通过多次抽样直接计算多次参数估计的标准差即可。但是实际情况里，我们没法这么做，自助法则是通过一个数据集，生成多个数据集（比如1000个），然后计算所有生成的数据集中估计参数的标准差，做为估计参数标准误的估计值。</p>
<p>生成数据集的过程如下，加入原始数据是3条数据，生成的数据集也都是3条数据，生成的数据集的每条数据都是<strong>可重复地</strong>从原始数据集中进行随机抽样的结果。</p>
<p><img src="8.png" alt="1"></p>
<p>自助法效果如下，左图为多次创建数据集的结果，中图为使用一个数据集采用自助法的结果，右图为二者比较，我们可以看到自助法与真实结果很接近。</p>
<p><img src="9.png" alt="1"></p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>数据分析</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑回归及其他分类变量分析方法</title>
    <url>/posts/749a327e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>ISL 真是好书！</p>
<span id="more"></span> 
<h1>资料</h1>
<p><a href="https://www.statlearning.com/">An Introduction to Statistical Learning</a>，下文简称 <strong>ISL</strong></p>
<h1>概述</h1>
<p><strong>线性回归的因变量都是连续变量</strong>（例如人的身高），但是生活中我们也有很多因变量是分类变量的情况。比如：</p>
<ol>
<li>一位来到急诊室的病人，具有很多的临床症状，这些症状可能是由三种疾病导致的，那么到底这个病人是患上了什么疾病呢？</li>
<li>邮箱区分哪些邮件是垃圾邮件，哪些邮件不是垃圾邮件</li>
<li>全基因组关联分析：确定哪些基因突变与疾病有关联</li>
</ol>
<p>在 ISL 书中，分析的例子是基于一个人的年收入和每月信用卡余额来预测这个人是否会拖欠信用卡付款。数据如下图所示</p>
<p><img src="1.png" alt="1"></p>
<h1>为什么不用线性回归？</h1>
<p>假设我们想要基于一个急诊室的病人的症状来预测他/她患了什么病。在这个简化的例子中，假设我们有三个可能的疾病：stroke, drug overdose, epileptic seizure 。 我们可以将这些重编码为数字，如下：</p>
<p><img src="2.png" alt="1"></p>
<p>如果这里我们用最小二乘的方式来预测 Y，并且我们认为这三者之间的差异是相同的。<strong>实际上我们这么重编码数字是没有道理的</strong>。比如，有些人还可能用另外一种编码方式：</p>
<p><img src="3.png" alt="1"></p>
<p><strong>如果换了一种重编码方式，那么这三者之间的关系就完全变了。</strong></p>
<p>如果反应变量的值是有序的，例如 <em>mild</em>, <em>moderate</em>, <em>severe</em> ，这样我们把这几个变量编码为1,2,3 还有一点道理。但是这么做还不是一种自然的方式。</p>
<p>对于一个<strong>二变量</strong>的分类性状，情况就好一点。比如如果病人的病症只有两种情况：stroke 和 drug overdose 。 我们可以将这两个变量转换为哑变量。</p>
<p><img src="4.png" alt="1"></p>
<p>我们可以对这个二变量进行线性回归，如果预测值大于0.5， 我们认为是 drug overdose；反之我们认为 stroke 。在这种情况，<strong>即使颠倒了重编码方法，预测结果还是一样的</strong>。这种情况下，线性回归是有意义的，我们得到的预测值可以理解为 <em>drug overdose</em> 的<strong>可能性</strong>，但是<strong>线性回归的预测值可能会超出 [0,1] 区间</strong>，使得这个结果难以解释。</p>
<h1>衡量分类变量模型的准确性</h1>
<p><em><strong>training error rate</strong></em> :  公式如下，其中 <code>I()</code> 为哑变量，如果预测值和真实值不同则为1，相同则为0。这个式子其实就是计算 traing data 有多少比例的预测值预测错了。</p>
<p style=""><img src="https://math.now.sh?from=%5Cfrac%7B1%7D%7Bn%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%20I%5Cleft%28y_%7Bi%7D%20%5Cneq%20%5Chat%7By%7D_%7Bi%7D%5Cright%29%0A" /></p><p>但是，实际上我们更关心的是 <em>test data</em> 的结果，同样的我们计算 <em><strong>test error rate</strong></em> 。一个好的模型，我们得到的  <em><strong>test error rate</strong></em> 应该是很低的。</p>
<h1>逻辑回归</h1>
<p>逻辑回归（logistic 回归）采用的因变量是<strong>某一个水平的概率</strong>。</p>
<p>线性回归与逻辑回归比对的结果如下：</p>
<p><img src="5.png" alt="1"></p>
<p>对于 ISL 的 Default 数据集（信用卡是否违约）， 逻辑回归会预测违约的概率。例如，基于 balance 因子的预测可以写成</p>
<p><img src="6.png" alt="1"></p>
<p>简写为 p(balance)，如果这个值大于0.5，我们可能预测会违约（这个阈值也可以调整）。</p>
<h2 id="逻辑回归模型">逻辑回归模型</h2>
<p>常规的线性模型如下：</p>
<p><img src="7.png" alt="1"></p>
<p>线性模型的问题在于预测值会超出[0,1]区间，这是不合理的。为了避免预测值超出[0,1]区间，我们设定逻辑回归的预测函数为：</p>
<p><img src="8.png" alt="1"></p>
<p>个人理解：β0+β1X 就是原来的线性模型的预测函数，范围是负无穷到正无穷。因此，e<sup>β0+β1X</sup> 的范围就是 (0,+∞] 。整个 p(X) 在这个范围内是递增函数（由求导得到，易知导数永远大于0），整个p(x) 的两个极值在自变量的两个端点取得，范围为 (0,1)</p>
<p>为了求解这个预测函数，我们需要用到<strong>最大似然法</strong>。</p>
<p>对上面的函数进行变换，我们得到下面这个式子。这个式子 p(x)/[1-p(x)] 称为 <em>odds</em> ，这个式子的值的范围为 (0, ∞)</p>
<p><img src="9.png" alt="1"></p>
<p>如果我们对左右两边取对数，我们可以得到下面这个式子：下式中左侧称之为 <em>log-odds</em> 或者 <em>logit</em> 。我们可以看到 <em>logit</em> 是符合线性模型的。</p>
<p><img src="10.png" alt="1"></p>
<p>我们这里估计得到的 β1 的值虽然和 p(x) 不是线性相关，但是<strong>如果β1 是正数，说明增加 X 的值，会提高 p(x)</strong>。</p>
<h2 id="估计回归系数">估计回归系数</h2>
<p>逻辑回归中的 β0 和 β1 是未知的，必须通过已有的 training data 来进行估计。在线性模型中，我们采用最小二乘法来估计线性回归的系数。虽然这里我们也可以用最小二乘来拟合模型，当我们偏向采用更一般的方式 - <strong>最大似然法</strong>。最大似然法用于拟合逻辑回归的基本思路是：<strong>我们想寻找一组 β0 β1 的值，使得每个个体p(x) 的预测值和观测值尽可能的接近</strong>。在这个例子中，也就是对于存在违约的个体的预测值要接近1，对于不存在违约的个体的预测值要接近于0。</p>
<p>我们可以把上面这个思路用一个 <abbr title="likelihood function">似然函数</abbr> 来表示，如下图所示：</p>
<p><img src="11.png" alt="1"></p>
<p>使得这个似然函数<strong>最大</strong>的一组 β0 和 β1 的值就是我们选中的估计值。</p>
<p>在ISL书中，最大似然法是一种估计<strong>非线性模型</strong>参数的一种普遍的方法。<strong>在线性模型中，最小二乘法实际是最大似然法的一个特例</strong>（理由呢？）。</p>
<p>回到信用卡的例子，如果我们采用逻辑回归，结果如下图。我们可以看到 β1 的估计值为正数，说明 随着 balance 的增加，违约的概率在增加。</p>
<p><img src="12.png" alt="1"></p>
<h2 id="预测">预测</h2>
<p>一旦我们得到了系数的估计值，我们就可以带入逻辑回归的公式进行预测。例如，加入我们要预测 balance 为 1000 时的违约概率：</p>
<p><img src="13.png" alt="1"></p>
<p>如果自变量是分类变量也是可以的，不过需要先转变为<strong>哑变量</strong>。比如下面是“是否是学生” 的分析结果，我们可以看到学生违约的风险高于非学生群体。</p>
<p><img src="16.png" alt=""></p>
<p>预测值如下</p>
<p><img src="17.png" alt="1"></p>
<h2 id="多重逻辑回归">多重逻辑回归</h2>
<p>如果我们多个自变量，我们可以将逻辑函数扩展如下：</p>
<p><img src="14.png" alt="1"></p>
<p><img src="15.png" alt="1"></p>
<p>之后我们还是采用最大似然法来估计这些系数。</p>
<p>比如，我们用三个自变量去预测信用卡违约，结果如下，我们可以看到 balance 和 student[Yes] 的 P 值都很小，说明这这两个自变量都是显著的。但是<strong>stdent[Yes] 的系数是负数</strong>，说明学生违约的概率更小，这和上面的简单逻辑回归的结论相反。</p>
<p><img src="18.png" alt="1"></p>
<p>下图就说明了这个矛盾的结论：左图说明了，如果固定了 Balance 因子，既在相同的 Balance 水平下，学生的违约风险更低；右图中是不管Balance 和 income 水平，计算所有的学生和非学生的结果，可以看到学生的违约风险更高。这对于信用卡发放的决策者而言这是一个重要的区别，<strong>如果不知道balance信息，学生的违约风险比非学生更高； 但是如果在相同的balance水平下，学生比非学术的违约风险要低。</strong></p>
<p><img src="19.png" alt="1"></p>
<p>发生这种矛盾的原因还是<strong>自变量之间的相关</strong>，这种现象称之为 <em>confounding</em> 。是否是学生 与  balance 绝对是存在相关关系的，或者说学生的balance 的 分布 和 非学生的 balance 分布是不一样的。</p>
<p>我这里可以通过画图来看一下，代码和图片结果如下。我们可以看到学生和非学生的 balance 的分布基本还是类似于正态分布，但是学生的均值更高，而且右侧的尾巴更肥。我们可以通过这个图简单地总结一下，就是学生群体balance的值倾向于比非学生群体更高。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span></span><br><span class="line">ggplot<span class="punctuation">(</span>Default<span class="punctuation">,</span> aes<span class="punctuation">(</span>x<span class="operator">=</span>balance<span class="punctuation">,</span> fill<span class="operator">=</span>student<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span> geom_histogram<span class="punctuation">(</span>position <span class="operator">=</span> <span class="string">&#x27;identity&#x27;</span><span class="punctuation">,</span> alpha <span class="operator">=</span> <span class="number">0.4</span><span class="punctuation">,</span> bins<span class="operator">=</span><span class="number">60</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p><img src="20.png" alt="1"></p>
<h2 id="大于2个水平的因变量">大于2个水平的因变量</h2>
<p>如果有多个水平的话，一般就不用逻辑回归了。我们会用 <abbr title="discriminant analysis"><strong>判别分析</strong></abbr>  方法。</p>
<h1><abbr title="Linear Discriminant Analysis, LDA">线性判别分析</abbr></h1>
<p>对于大于2个水平（K&gt;2）的因变量，我们假定我们获取因变量的<strong>先验分布</strong>（即一个随机挑选的观察值来自于其中某个水平的概率），记为下面的符号。</p>
<p style=""><img src="https://math.now.sh?from=%5Cpi_%7Bk%7D%0A" /></p><p>另外一个式子就是基于某个因变量水平的自变量分布，见下式。如果这个值很高，说明当Y=k时，X=x 的概率很大。</p>
<p style=""><img src="https://math.now.sh?from=f_%7Bk%7D%28x%29%20%5Cequiv%20%5Coperatorname%7BPr%7D(X%3Dx%20%5Cmid%20Y%3Dk)%0A" /></p><p>我们通过<strong>贝叶斯定理</strong>，就可以得到基于某个X的Y的条件概率，即<strong>后验概率</strong>，我们用 <em><strong>p<sub>k</sub>(x)</strong></em>  来表示</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BPr%7D%28Y%3Dk%20%5Cmid%20X%3Dx%29%3D%5Cfrac%7B%5Cpi_%7Bk%7D%20f_%7Bk%7D(x)%7D%7B%5Csum_%7Bl%3D1%7D%5E%7BK%7D%20%5Cpi_%7Bl%7D%20f_%7Bl%7D(x)%7D%0A" /></p><p>在这个公式里，因变量的先验分布比较容易获得，我们先对总体进行随机抽样，之后算一下每个水平的比例即可。但是 f<sub>k</sub>(x) 就不是很容易获得。<strong>如果我们可以估计  f<sub>k</sub>(x)</strong> ，我们就可以计算不同因变量水平的<strong>后验概率</strong>，我们认为后验概率最大的水平就是预测值。</p>
<h2 id="p-1的线性判别分析">p=1的线性判别分析</h2>
<p>如果只有一个自变量，我们需要首先估计  f<sub>k</sub>(x) ，我们需要先做一些假设。</p>
<p>我们假设  <strong>f<sub>k</sub>(x) 是符合正态分布的</strong> （假设1），在一个自变量的情况下，即符合下面这个式子：</p>
<p style=""><img src="https://math.now.sh?from=f_%7Bk%7D%28x%29%3D%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%7D%20%5Csigma_%7Bk%7D%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B1%7D%7B2%20%5Csigma_%7Bk%7D%5E%7B2%7D%7D%5Cleft(x-%5Cmu_%7Bk%7D%5Cright)%5E%7B2%7D%5Cright)%0A" /></p><p>其中 u<sub>k</sub> 和 σ<sup>2</sup><sub>k</sub>  分别为第K个水平的均值和方差。我们进一步假设<strong>所有的水平的方差均相同</strong>（假设2），即如下式，可以简化为 σ<sup>2</sup> 。</p>
<p style=""><img src="https://math.now.sh?from=%5Csigma_%7B1%7D%5E%7B2%7D%3D%5Cldots%3D%5Csigma_%7BK%7D%5E%7B2%7D%0A" /></p><p>将这个式子带入到上面计算  <em><strong>p<sub>k</sub>(x)</strong></em> 的式子中，得到</p>
<p style=""><img src="https://math.now.sh?from=p_%7Bk%7D%28x%29%3D%5Cfrac%7B%5Cpi_%7Bk%7D%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%7D%20%5Csigma%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B1%7D%7B2%20%5Csigma%5E%7B2%7D%7D%5Cleft(x-%5Cmu_%7Bk%7D%5Cright)%5E%7B2%7D%5Cright)%7D%7B%5Csum_%7Bl%3D1%7D%5E%7BK%7D%20%5Cpi_%7Bl%7D%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%7D%20%5Csigma%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B1%7D%7B2%20%5Csigma%5E%7B2%7D%7D%5Cleft(x-%5Cmu_%7Bl%7D%5Cright)%5E%7B2%7D%5Cright)%7D%0A" /></p><p>计算所有水平的后验概率，选择<strong>后验概率最大</strong>的水平。我们可以看到对所有的水平，分母部分都是一样的，因此我们只需要关注分子部分，只要找对分子最大的水平。对分子部分采用 log 函数，剔除常数部分，我们得到下面这个式子。这个式子值最大的水平，就是后验概率最大的水平</p>
<p style=""><img src="https://math.now.sh?from=%5Cdelta_%7Bk%7D%28x%29%3Dx%20%5Ccdot%20%5Cfrac%7B%5Cmu_%7Bk%7D%7D%7B%5Csigma%5E%7B2%7D%7D-%5Cfrac%7B%5Cmu_%7Bk%7D%5E%7B2%7D%7D%7B2%20%5Csigma%5E%7B2%7D%7D%2B%5Clog%20%5Cleft(%5Cpi_%7Bk%7D%5Cright)%0A" /></p><p>假设 K=2，并且 π<sub>1</sub> = π<sub>2</sub> 。那么如果满足下面这个式子，则最终分配为水平1；否则则为水平2</p>
<p style=""><img src="https://math.now.sh?from=2%20x%5Cleft%28%5Cmu_%7B1%7D-%5Cmu_%7B2%7D%5Cright%29%3E%5Cmu_%7B1%7D%5E%7B2%7D-%5Cmu_%7B2%7D%5E%7B2%7D%0A" /></p><p>在这种情况下，<abbr title="Bayes decision boundary">贝叶斯决策线</abbr> 为</p>
<p style=""><img src="https://math.now.sh?from=x%3D%5Cfrac%7B%5Cmu_%7B1%7D%5E%7B2%7D-%5Cmu_%7B2%7D%5E%7B2%7D%7D%7B2%5Cleft%28%5Cmu_%7B1%7D-%5Cmu_%7B2%7D%5Cright%29%7D%3D%5Cfrac%7B%5Cmu_%7B1%7D%2B%5Cmu_%7B2%7D%7D%7B2%7D%20%5Ctext%20%7B%20.%20%7D%0A" /></p><p>但是在实际中， π<sub>k</sub> , μ<sub>k</sub> ， σ<sup>2</sup>  这些参数都是未知的，我们需要先估计这些常数，再估计 <em>p<sub>k</sub>(x)</em></p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Chat%7B%5Cmu%7D_%7Bk%7D%20%26%3D%5Cfrac%7B1%7D%7Bn_%7Bk%7D%7D%20%5Csum_%7Bi%3A%20y_%7Bi%7D%3Dk%7D%20x_%7Bi%7D%20%5C%5C%0A%5Chat%7B%5Csigma%7D%5E%7B2%7D%20%26%3D%5Cfrac%7B1%7D%7Bn-K%7D%20%5Csum_%7Bk%3D1%7D%5E%7BK%7D%20%5Csum_%7Bi%3A%20y_%7Bi%7D%3Dk%7D%5Cleft%28x_%7Bi%7D-%5Chat%7B%5Cmu%7D_%7Bk%7D%5Cright%29%5E%7B2%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>这里 n 是所有的观测值数目，n<sub>k</sub> 是观测值为水平k 时的数目。至于 π<sub>k</sub> ，有先验就用，没有就从 training data 计算一下</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cpi%7D_%7Bk%7D%3Dn_%7Bk%7D%20%2F%20n%0A" /></p><p>将上面的参数估计值带入下式，计算得到值最大的水平</p>
<p style=""><img src="https://math.now.sh?from=%5Chat%7B%5Cdelta%7D_%7Bk%7D%28x%29%3Dx%20%5Ccdot%20%5Cfrac%7B%5Chat%7B%5Cmu%7D_%7Bk%7D%7D%7B%5Chat%7B%5Csigma%7D%5E%7B2%7D%7D-%5Cfrac%7B%5Chat%7B%5Cmu%7D_%7Bk%7D%5E%7B2%7D%7D%7B2%20%5Chat%7B%5Csigma%7D%5E%7B2%7D%7D%2B%5Clog%20%5Cleft(%5Chat%7B%5Cpi%7D_%7Bk%7D%5Cright)%0A" /></p><p>为什么判别分析称为<strong>线性</strong>判别分析呢？因为 <em>discriminant functions</em> δ<sub>k</sub>(x) 是 x 的线性函数。</p>
<h2 id="p-1的线性判别分析-2">p&gt;1的线性判别分析</h2>
<p>我们现在看多个自变量的情况，并且这些自变量服从<strong>多元正态分布</strong>（每个变量均服从一维正态分布）， 下图为两个变量时服从多元正态分布的概率密度图。</p>
<p><img src="21.png" alt="1"></p>
<p>为了表示 p维的随机变量X 服从多元正态分布，我们写作</p>
<p style=""><img src="https://math.now.sh?from=X%20%5Csim%20N%28%5Cmu%2C%20%5Cboldsymbol%7B%5CSigma%7D%29%0A" /></p><p>其中，<em>μ</em> 为均值，是一个p维的向量。</p>
<p style=""><img src="https://math.now.sh?from=E%28X%29%3D%5Cmu%0A" /></p><p>方差分布为 Σ , 为 <em>p × p</em> 的矩阵。</p>
<p>最后，多元正态分布定义为</p>
<p style=""><img src="https://math.now.sh?from=f%28x%29%3D%5Cfrac%7B1%7D%7B(2%20%5Cpi)%5E%7Bp%20%2F%202%7D%7C%5CSigma%7C%5E%7B1%20%2F%202%7D%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B1%7D%7B2%7D(x-%5Cmu)%5E%7BT%7D%20%5Cmathbf%7B%5CSigma%7D%5E%7B-1%7D(x-%5Cmu)%5Cright)%0A" /></p><p>类似于p=1的判别分析，这里假定因变量所有水平的观测值均服从<strong>方差相同的</strong>多元正态分布。</p>
<p>p&gt;1的判别函数如下</p>
<p style=""><img src="https://math.now.sh?from=%5Cdelta_%7Bk%7D%28x%29%3Dx%5E%7BT%7D%20%5Cboldsymbol%7B%5CSigma%7D%5E%7B-1%7D%20%5Cmu_%7Bk%7D-%5Cfrac%7B1%7D%7B2%7D%20%5Cmu_%7Bk%7D%5E%7BT%7D%20%5Cboldsymbol%7B%5CSigma%7D%5E%7B-1%7D%20%5Cmu_%7Bk%7D%2B%5Clog%20%5Cpi_%7Bk%7D%0A" /></p><p>以下图为例，作图是三种水平所有观测值结果，圆圈为95%的概率的范围，虚线为画出的贝叶斯决策线；右图为各随机抽取了20个样本的结果，实线为抽样结果的贝叶斯决策线。</p>
<p>个人理解：这张图给了我一个提示，<strong>分类变量的每个水平必须是能几乎截然分开的</strong>，才能进行分析。不然对于判别分析，无法画出决策线。所以我感觉进行分析前有必要先进行一下可视化，看一下分类变量的各个水平的设置是否合理，有没有两个水平实际是差不多同一个水平的情况。</p>
<p><img src="22.png" alt="1"></p>
<p>这里我们同样需要估计这些参数，类似于p=1的情况</p>
<p>从判别函数的形式看，判别函数依然是 X 的线性转换，这就是线性判别分析中线性的由来。</p>
<p>如果对信用卡违约的数据进行判别分析，因变量是<strong>是否违约</strong>，自变量是 <em>credit card balance</em> 和 <em>student status</em> ，通过对 10,000 个 traing samples 进行建模，我们得到的 <em>training error rate</em> 的结果是 2.75% 。这个结果看上去很好，但是有两个注意事项：</p>
<ol>
<li>首先，<em>training error rate</em>  通常会低于 <em>test error rate</em>，也就是说 test data 的结果通常会更差一点，这是因为我们是根据 <em>training data</em> 来拟合的模型参数。如果参数 p 除以 样本 n 的比例越高，我们可能越可能遇到<strong>过拟合</strong>问题。</li>
<li>其次，由于 <em>training data</em> 中只有3.33%的个体违约，因此一个最简单的 <em>classifier</em> 可以将所有个体都预测为不会违约，无论这个人的 credit card balance 和 student status 是什么情况，这个 <em>classifier</em> 的 <em>trainging error rate</em> 就是 3.33%。这种情况下仅仅比上面的 2.75% 略高。</li>
</ol>
<p>在实际情况中，一个二分类的 <em>classifier</em> 会产生两种错误：它可能将一个不违约的个体判定为违约，或者将违约的个体判定为不违约。这两种错误发生的原因，通常是需要关注的地方。我们一般会通过 <em><strong>confusion matrix</strong></em> 来查看一下，我们可以看到在真实为NO的个体中（9667），总共有23个个体是错误预测的，这看上去错误概率很低。但是，在总共333个违约个体中，总共有252（75.7%）的个体被错误预测为No。因此，<strong>虽然总的 <em>training error rate</em>  很低，但是针对违约的个体的<em>error rate</em> 很高</strong>。由于信用卡公司做预测的目的是为了确定高风险可能违约的用户，这种预测情况肯定是无法接受的。</p>
<p><img src="23.png" alt="1"></p>
<h3 id="sensitivity-和-specificity">sensitivity 和 specificity</h3>
<p>有两个概念可以说明一个 <em>classifier</em> 的表现， <em><strong>sensitivity</strong></em> 和 <em><strong>specificity</strong></em> 。在这个例子中，<em>sensitivity</em> 就是违约者被正确预测的概率，这里是24.3%；<em>specificity</em> 就是非违约者被正确预测的概率，这里是 99.8%。</p>
<p>为什么判别分析在违约个体的表现如此糟糕呢？或者说，为什么 <em>sensitivity</em> 如此低？如我们所见，判别分析会采用贝叶斯方法，会含有最低的 <em>total error rate</em> ，也就是说会产生最少的总的错误分类的数目，无论这些错误分类原本来自于哪个分类。但是基于信用卡公司的角度，肯定是希望尽量避免将会违约的个体判定为不会违约的错误，相比之下，将不会违约的个体判定为违约问题则没有那么严重。因此我们需要需改这个方法，来新建一个 <em>classifier</em> 来更好地符合信用卡公司的需求。</p>
<p>判别分析会将个体判定为<strong>后验概率最大</strong>的分类。在只有两种分类的情况下，一个观测值会判定为违约的公式如下（后验概率大于0.5）</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BPr%7D%28%5Ctext%20%7B%20default%20%7D%3D%5Coperatorname%7BYes%7D%20%5Cmid%20X%3Dx%29%3E0.5%0A" /></p><p>这里默认阈值就是0.5，但是，如果我们特别关心将违约个体预测为非违约的情况，那么我们就可以降低这个阈值。例如如果后验概率超过0.2，我们就判定为违约，公式如下</p>
<p style=""><img src="https://math.now.sh?from=%5Coperatorname%7BPr%7D%28%5Ctext%20%7B%20default%20%7D%3D%5Coperatorname%7BYes%7D%20%5Cmid%20X%3Dx%29%3E0.2%0A" /></p><p>修改阈值后，预测结果如下，我们可以看到相比于上面的结果，违约个体预测错误下降，但是非违约个体的预测错误上升。总的预测错误轻微上升至3.73%。</p>
<p><img src="24.png" alt="1"></p>
<p>下图说明了修改违约后验概率阈值的 trade-off 结果。如果阈值设定为0.5，那么总的错误概率是最低的，如下图的黑线，但是违约个体的错误概率却是最高的，如蓝色虚线所示。</p>
<p><img src="25.png" alt="1"></p>
<p><abbr title="receiver operating characteristics">ROC</abbr>  曲线是用来展现不同的阈值下两种错误的错误概率的变化。下图就是 ROC 图 ，纵坐标是 <em>sensitivity</em> ，就是违约者被正确预测的概率；横坐标为 <em>1-specificity</em> ，为非违约者被错误预测的概率。这幅图不显示阈值。</p>
<p><img src="26.png" alt="1"></p>
<h3 id="一型错误和二型错误">一型错误和二型错误</h3>
<p>我们把上面的表格进行一般化，用 - 或 Null 表示零假设（本例为不违约），+ 或 Non-null 表示备择假设（本例为违约）。</p>
<p><img src="27.png" alt="1"></p>
<p>根据上面的表格，我们得到一些重要的统计量。</p>
<p><img src="28.png" alt="1"></p>
<h1><abbr title="Quadratic Discriminant Analysis,  QDA">二次判别分析</abbr></h1>
<p>线性判别分析假设所有水平的观测值均假设服从一个<strong>方差矩阵</strong>相同的<strong>多元正态分布</strong>。二次判别分析则假设所有水平的观测值均服从一个正态分布，但是不像线性判别分析，二次判别分析假设<strong>所有水平的方差矩阵各不相同</strong>。即对第k个水平的观测值的分布为：</p>
<p style=""><img src="https://math.now.sh?from=X%20%5Csim%20N%5Cleft%28%5Cmu_%7Bk%7D%2C%20%5CSigma_%7Bk%7D%5Cright%29%0A" /></p><p>在这个假设下，判别函数如下。这个函数是 x 的二次函数，这就是二次判别分析名字的来源。</p>
<p style=""><img src="https://math.now.sh?from=%5Cbegin%7Baligned%7D%0A%5Cdelta_%7Bk%7D%28x%29%20%26%3D-%5Cfrac%7B1%7D%7B2%7D%5Cleft(x-%5Cmu_%7Bk%7D%5Cright)%5E%7BT%7D%20%5CSigma_%7Bk%7D%5E%7B-1%7D%5Cleft(x-%5Cmu_%7Bk%7D%5Cright)-%5Cfrac%7B1%7D%7B2%7D%20%5Clog%20%5Cleft%7C%5CSigma_%7Bk%7D%5Cright%7C%2B%5Clog%20%5Cpi_%7Bk%7D%20%5C%5C%0A%26%3D-%5Cfrac%7B1%7D%7B2%7D%20x%5E%7BT%7D%20%5CSigma_%7Bk%7D%5E%7B-1%7D%20x%2Bx%5E%7BT%7D%20%5CSigma_%7Bk%7D%5E%7B-1%7D%20%5Cmu_%7Bk%7D-%5Cfrac%7B1%7D%7B2%7D%20%5Cmu_%7Bk%7D%5E%7BT%7D%20%5CSigma_%7Bk%7D%5E%7B-1%7D%20%5Cmu_%7Bk%7D-%5Cfrac%7B1%7D%7B2%7D%20%5Clog%20%5Cleft%7C%5CSigma_%7Bk%7D%5Cright%7C%2B%5Clog%20%5Cpi_%7Bk%7D%0A%5Cend%7Baligned%7D%0A" /></p><p>我们应该在什么情况下采用线性判别分析，什么情况下采用二次判别分析呢？这个答案在 <code>bias-variance trade-off</code> 中。二次判别分析需要估计的参数比线性判别分析多得多，如果我们有 p 个预测因子，那么估计线性分析的方差矩阵需要 <em>p(p+1)/2</em> 个参数；而二次判别分析需要对每个水平均要估计一个单独的方差矩阵，则总共需要 <em>Kp(p+1)/2</em> 个参数。因此二次判别分析更灵活，bias 比较低，但 variance 比较高。<strong>一般来说，当样本数量比较少时，推荐使用线性判别分析来降低 variance；如果样本数量非常大或者严重偏理所有水平同方差的假设，更推荐使用二次判别分析。</strong></p>
<p>下图说明了线性判别分析和二次判别分析在两种情况下的表现。</p>
<p><img src="29.png" alt="1"></p>
<h1>不同方法的比较</h1>
<p>逻辑回归和线性判别分析虽然思路不同，但却是紧密相关的。在线性判别分析的框架里，<em>log odds</em> 计算公式可简化如下（就是两个判别函数相减）：</p>
<p style=""><img src="https://math.now.sh?from=%5Clog%20%5Cleft%28%5Cfrac%7Bp_%7B1%7D(x%29%7D%7B1-p_%7B1%7D(x)%7D%5Cright)%3D%5Clog%20%5Cleft(%5Cfrac%7Bp_%7B1%7D(x)%7D%7Bp_%7B2%7D(x)%7D%5Cright)%3Dc_%7B0%7D%2Bc_%7B1%7D%20x%0A" /></p><p>根据逻辑回归公式，<em>log odd</em> 可写为：</p>
<p style=""><img src="https://math.now.sh?from=%5Clog%20%5Cleft%28%5Cfrac%7Bp_%7B1%7D%7D%7B1-p_%7B1%7D%7D%5Cright%29%3D%5Cbeta_%7B0%7D%2B%5Cbeta_%7B1%7D%20x%0A" /></p><p>这两种方法得到的 <em>log odd</em> 都是 x 的线性函数，因此这两种方法的决策边界均为直线。这两种方法唯一的区别在于 β0 和 β1 是通过最大似然得到的，而 c<sub>0</sub>  和 c<sub>1</sub> 是通过估计正态分布的均值和方差得到的。</p>
<p>由于这两种方法仅仅是拟合参数的过程有区别，因此这两种方法的结果往往是非常相似的，但偶尔可能情况不一样。线性判别分析由于存在<strong>同方差正态分布</strong>的假设，因此<strong>如果数据符合这个假设，那么结果可能比较好。相反，如果数据不符合这个假设，那么逻辑回归的结果会更好。</strong></p>
<p>而 KNN 方法但预测 X = x 的值时，会提取x附近的多个观测值，然后分配X为大多数观测值的结果。因此 KNN 方法是一种完全的非参数方法，没有对决策界限的任何假设。因此，如果只有当决策线是高度非线性的情况下，KNN 方法才可能由于线性判别方法和逻辑回归方法。另一方面，KNN 方面没有告诉我们哪些预测是重要的，哪些是不重要的。</p>
<p>最后，二次判别分析是 KNN 方法 和 LDA/逻辑回归方法 之间的折中方法，它的决策线是二次函数。</p>
<p>为了说明这四种方法的表型，ISL 书中模拟了六种情况，在前三种情况下，真实的决策线就是线性的，另外三种情况则是非线性的。对于每种情况下，均随机生成 100 个训练集，我们在每个训练集中拟合模型，然后计算一个很大的 <em>test data</em> 数据集的 <em>test error rate</em> 。</p>
<p>真实决策线是直线的三种情况画图如下：</p>
<p><img src="30.png" alt="1"></p>
<p>真实决策线不是直线的三种情况画图如下：</p>
<p><img src="31.png" alt="1"></p>
<p>其中，KNN 方法做了两次，一次 K = 1，一次 K 值通过 <em>cross validation</em> 获得。在所有的情况中，p 均等于2。</p>
<p>我们可以看到，如果真实的预测线是线性的，那么 LDA和逻辑回归方法较好；如果是非线性的，那么 QDA 方法更好。最后，对于非常复杂的预测线，那么非参方法，例如KNN方法更好，但是需要慎重选择平滑度。</p>
<p>最后，在线性回归中，我们可以通过对预测因子进行转换，来实现对非线性关系的模拟。我们同样可以在分类变量的分析中采用相同的操作，例如采用 X<sup>2</sup> , X<sup>3</sup>  等加入到逻辑回归 和 LDA分析中，这样可以实现类似与 QDA 的效果。</p>
<h1>R代码</h1>
<p>ISl 使用的数据是股票数据，Smarket data ，来自于 ISLR 包。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>ISLR<span class="punctuation">)</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>Smarket<span class="punctuation">)</span></span><br><span class="line"><span class="built_in">dim</span><span class="punctuation">(</span>Smarket<span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>Smarket<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<p>使用 cor() 函数可以计算所有数据集的相关矩阵，所有变量必须为连续变量。</p>
<p>我们可以看到这里只有 Year 和 Volume 这两个变量之间存在实质相关。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> cor<span class="punctuation">(</span>Smarket<span class="punctuation">)</span></span><br><span class="line">Error <span class="keyword">in</span> cor<span class="punctuation">(</span>Smarket<span class="punctuation">)</span> <span class="operator">:</span> <span class="string">&#x27;x&#x27;</span>必需为数值</span><br><span class="line"><span class="operator">&gt;</span> cor<span class="punctuation">(</span>Smarket<span class="punctuation">[</span><span class="punctuation">,</span><span class="operator">-</span><span class="number">9</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">             Year         Lag1         Lag2         Lag3         Lag4         Lag5      Volume</span><br><span class="line">Year   <span class="number">1.00000000</span>  <span class="number">0.029699649</span>  <span class="number">0.030596422</span>  <span class="number">0.033194581</span>  <span class="number">0.035688718</span>  <span class="number">0.029787995</span>  <span class="number">0.53900647</span></span><br><span class="line">Lag1   <span class="number">0.02969965</span>  <span class="number">1.000000000</span> <span class="operator">-</span><span class="number">0.026294328</span> <span class="operator">-</span><span class="number">0.010803402</span> <span class="operator">-</span><span class="number">0.002985911</span> <span class="operator">-</span><span class="number">0.005674606</span>  <span class="number">0.04090991</span></span><br><span class="line">Lag2   <span class="number">0.03059642</span> <span class="operator">-</span><span class="number">0.026294328</span>  <span class="number">1.000000000</span> <span class="operator">-</span><span class="number">0.025896670</span> <span class="operator">-</span><span class="number">0.010853533</span> <span class="operator">-</span><span class="number">0.003557949</span> <span class="operator">-</span><span class="number">0.04338321</span></span><br><span class="line">Lag3   <span class="number">0.03319458</span> <span class="operator">-</span><span class="number">0.010803402</span> <span class="operator">-</span><span class="number">0.025896670</span>  <span class="number">1.000000000</span> <span class="operator">-</span><span class="number">0.024051036</span> <span class="operator">-</span><span class="number">0.018808338</span> <span class="operator">-</span><span class="number">0.04182369</span></span><br><span class="line">Lag4   <span class="number">0.03568872</span> <span class="operator">-</span><span class="number">0.002985911</span> <span class="operator">-</span><span class="number">0.010853533</span> <span class="operator">-</span><span class="number">0.024051036</span>  <span class="number">1.000000000</span> <span class="operator">-</span><span class="number">0.027083641</span> <span class="operator">-</span><span class="number">0.04841425</span></span><br><span class="line">Lag5   <span class="number">0.02978799</span> <span class="operator">-</span><span class="number">0.005674606</span> <span class="operator">-</span><span class="number">0.003557949</span> <span class="operator">-</span><span class="number">0.018808338</span> <span class="operator">-</span><span class="number">0.027083641</span>  <span class="number">1.000000000</span> <span class="operator">-</span><span class="number">0.02200231</span></span><br><span class="line">Volume <span class="number">0.53900647</span>  <span class="number">0.040909908</span> <span class="operator">-</span><span class="number">0.043383215</span> <span class="operator">-</span><span class="number">0.041823686</span> <span class="operator">-</span><span class="number">0.048414246</span> <span class="operator">-</span><span class="number">0.022002315</span>  <span class="number">1.00000000</span></span><br><span class="line">Today  <span class="number">0.03009523</span> <span class="operator">-</span><span class="number">0.026155045</span> <span class="operator">-</span><span class="number">0.010250033</span> <span class="operator">-</span><span class="number">0.002447647</span> <span class="operator">-</span><span class="number">0.006899527</span> <span class="operator">-</span><span class="number">0.034860083</span>  <span class="number">0.01459182</span></span><br><span class="line">              Today</span><br><span class="line">Year    <span class="number">0.030095229</span></span><br><span class="line">Lag1   <span class="operator">-</span><span class="number">0.026155045</span></span><br><span class="line">Lag2   <span class="operator">-</span><span class="number">0.010250033</span></span><br><span class="line">Lag3   <span class="operator">-</span><span class="number">0.002447647</span></span><br><span class="line">Lag4   <span class="operator">-</span><span class="number">0.006899527</span></span><br><span class="line">Lag5   <span class="operator">-</span><span class="number">0.034860083</span></span><br><span class="line">Volume  <span class="number">0.014591823</span></span><br><span class="line">Today   <span class="number">1.000000000</span></span><br></pre></td></tr></table></figure>
<h2 id="逻辑回归">逻辑回归</h2>
<p><code>glm()</code> 函数使用广义线性模型，包括一系列模型，其中就有逻辑回归。这里我们通过指定 <code>family = binomial</code> 来指定使用逻辑回归。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> glm.fit <span class="operator">=</span> glm<span class="punctuation">(</span>Direction <span class="operator">~</span> Lag1<span class="operator">+</span>Lag2<span class="operator">+</span>Lag3<span class="operator">+</span>Lag4<span class="operator">+</span>Lag5<span class="operator">+</span>Volume<span class="punctuation">,</span> data<span class="operator">=</span>Smarket<span class="punctuation">,</span> family<span class="operator">=</span>binomial<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> summary<span class="punctuation">(</span>glm.fit<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Call<span class="operator">:</span></span><br><span class="line">glm<span class="punctuation">(</span>formula <span class="operator">=</span> Direction <span class="operator">~</span> Lag1 <span class="operator">+</span> Lag2 <span class="operator">+</span> Lag3 <span class="operator">+</span> Lag4 <span class="operator">+</span> Lag5 <span class="operator">+</span> </span><br><span class="line">    Volume<span class="punctuation">,</span> family <span class="operator">=</span> binomial<span class="punctuation">,</span> data <span class="operator">=</span> Smarket<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Deviance Residuals<span class="operator">:</span> </span><br><span class="line">   Min      <span class="number">1</span>Q  Median      <span class="number">3</span>Q     Max  </span><br><span class="line"><span class="operator">-</span><span class="number">1.446</span>  <span class="operator">-</span><span class="number">1.203</span>   <span class="number">1.065</span>   <span class="number">1.145</span>   <span class="number">1.326</span>  </span><br><span class="line"></span><br><span class="line">Coefficients<span class="operator">:</span></span><br><span class="line">             Estimate Std. Error z value Pr<span class="punctuation">(</span><span class="operator">&gt;</span><span class="operator">|</span>z<span class="operator">|</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">(</span>Intercept<span class="punctuation">)</span> <span class="operator">-</span><span class="number">0.126000</span>   <span class="number">0.240736</span>  <span class="operator">-</span><span class="number">0.523</span>    <span class="number">0.601</span></span><br><span class="line">Lag1        <span class="operator">-</span><span class="number">0.073074</span>   <span class="number">0.050167</span>  <span class="operator">-</span><span class="number">1.457</span>    <span class="number">0.145</span></span><br><span class="line">Lag2        <span class="operator">-</span><span class="number">0.042301</span>   <span class="number">0.050086</span>  <span class="operator">-</span><span class="number">0.845</span>    <span class="number">0.398</span></span><br><span class="line">Lag3         <span class="number">0.011085</span>   <span class="number">0.049939</span>   <span class="number">0.222</span>    <span class="number">0.824</span></span><br><span class="line">Lag4         <span class="number">0.009359</span>   <span class="number">0.049974</span>   <span class="number">0.187</span>    <span class="number">0.851</span></span><br><span class="line">Lag5         <span class="number">0.010313</span>   <span class="number">0.049511</span>   <span class="number">0.208</span>    <span class="number">0.835</span></span><br><span class="line">Volume       <span class="number">0.135441</span>   <span class="number">0.158360</span>   <span class="number">0.855</span>    <span class="number">0.392</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">(</span>Dispersion parameter <span class="keyword">for</span> binomial family taken to be <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">    Null deviance<span class="operator">:</span> <span class="number">1731.2</span>  on <span class="number">1249</span>  degrees of freedom</span><br><span class="line">Residual deviance<span class="operator">:</span> <span class="number">1727.6</span>  on <span class="number">1243</span>  degrees of freedom</span><br><span class="line">AIC<span class="operator">:</span> <span class="number">1741.6</span></span><br><span class="line"></span><br><span class="line">Number of Fisher Scoring iterations<span class="operator">:</span> <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看系数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> coef<span class="punctuation">(</span>glm.fit<span class="punctuation">)</span></span><br><span class="line"> <span class="punctuation">(</span>Intercept<span class="punctuation">)</span>         Lag1         Lag2         Lag3         Lag4         Lag5       Volume </span><br><span class="line"><span class="operator">-</span><span class="number">0.126000257</span> <span class="operator">-</span><span class="number">0.073073746</span> <span class="operator">-</span><span class="number">0.042301344</span>  <span class="number">0.011085108</span>  <span class="number">0.009358938</span>  <span class="number">0.010313068</span>  <span class="number">0.135440659</span></span><br><span class="line"><span class="operator">&gt;</span> summary<span class="punctuation">(</span>glm.fit<span class="punctuation">)</span><span class="operator">$</span>coef</span><br><span class="line">                Estimate Std. Error    z value  Pr<span class="punctuation">(</span><span class="operator">&gt;</span><span class="operator">|</span>z<span class="operator">|</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">(</span>Intercept<span class="punctuation">)</span> <span class="operator">-</span><span class="number">0.126000257</span> <span class="number">0.24073574</span> <span class="operator">-</span><span class="number">0.5233966</span> <span class="number">0.6006983</span></span><br><span class="line">Lag1        <span class="operator">-</span><span class="number">0.073073746</span> <span class="number">0.05016739</span> <span class="operator">-</span><span class="number">1.4565986</span> <span class="number">0.1452272</span></span><br><span class="line">Lag2        <span class="operator">-</span><span class="number">0.042301344</span> <span class="number">0.05008605</span> <span class="operator">-</span><span class="number">0.8445733</span> <span class="number">0.3983491</span></span><br><span class="line">Lag3         <span class="number">0.011085108</span> <span class="number">0.04993854</span>  <span class="number">0.2219750</span> <span class="number">0.8243333</span></span><br><span class="line">Lag4         <span class="number">0.009358938</span> <span class="number">0.04997413</span>  <span class="number">0.1872757</span> <span class="number">0.8514445</span></span><br><span class="line">Lag5         <span class="number">0.010313068</span> <span class="number">0.04951146</span>  <span class="number">0.2082966</span> <span class="number">0.8349974</span></span><br><span class="line">Volume       <span class="number">0.135440659</span> <span class="number">0.15835970</span>  <span class="number">0.8552723</span> <span class="number">0.3924004</span></span><br></pre></td></tr></table></figure>
<h2 id="线性判别分析">线性判别分析</h2>
<p>我们可以用 MASS 包的 lda() 函数进行LDA分析。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> library<span class="punctuation">(</span>MASS<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> lda.fit <span class="operator">=</span> lda<span class="punctuation">(</span>Direction <span class="operator">~</span> Lag1 <span class="operator">+</span> Lag2<span class="punctuation">,</span> data<span class="operator">=</span>Smarket<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> lda.fit</span><br><span class="line">Call<span class="operator">:</span></span><br><span class="line">lda<span class="punctuation">(</span>Direction <span class="operator">~</span> Lag1 <span class="operator">+</span> Lag2<span class="punctuation">,</span> data <span class="operator">=</span> Smarket<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">Prior probabilities of groups<span class="operator">:</span></span><br><span class="line">  Down     Up </span><br><span class="line"><span class="number">0.4816</span> <span class="number">0.5184</span> </span><br><span class="line"></span><br><span class="line">Group means<span class="operator">:</span></span><br><span class="line">            Lag1        Lag2</span><br><span class="line">Down  <span class="number">0.05068605</span>  <span class="number">0.03229734</span></span><br><span class="line">Up   <span class="operator">-</span><span class="number">0.03969136</span> <span class="operator">-</span><span class="number">0.02244444</span></span><br><span class="line"></span><br><span class="line">Coefficients of linear discriminants<span class="operator">:</span></span><br><span class="line">            LD1</span><br><span class="line">Lag1 <span class="operator">-</span><span class="number">0.7567605</span></span><br><span class="line">Lag2 <span class="operator">-</span><span class="number">0.4707872</span></span><br></pre></td></tr></table></figure>
<p>这里提供了先验概率的估计值，每个水平均值的估计值。最后的 <em>Coefficients of linear discriminants</em> 提供了两个因子的线性组合，用于形成决策线。在本例中，就是下式</p>
<p style=""><img src="https://math.now.sh?from=-0.642%20%5Ctimes%20%5Coperatorname%7BLag%7D%201-0.514%20%5Ctimes%20%5Ctext%20%7B%20Lag%20%7D%202%0A" /></p><p>如果这个式子很大，那么就会预测为 Up，否则就预测为 down 。</p>
<h2 id="二次判别分析">二次判别分析</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; library(MASS)</span><br><span class="line">&gt; qda.fit = qda(Direction ~ Lag1 + Lag2, data=Smarket)</span><br><span class="line">&gt; qda.fit</span><br><span class="line">Call:</span><br><span class="line">qda(Direction ~ Lag1 + Lag2, data = Smarket)</span><br><span class="line"></span><br><span class="line">Prior probabilities of groups:</span><br><span class="line">  Down     Up </span><br><span class="line">0.4816 0.5184 </span><br><span class="line"></span><br><span class="line">Group means:</span><br><span class="line">            Lag1        Lag2</span><br><span class="line">Down  0.05068605  0.03229734</span><br><span class="line">Up   -0.03969136 -0.02244444</span><br></pre></td></tr></table></figure>
<p>这里没有提供系数。</p>
]]></content>
      <categories>
        <category>理论学习</category>
        <category>线性模型</category>
      </categories>
      <tags>
        <tag>理论学习</tag>
        <tag>数据分析</tag>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第八卷杂说-诡信</title>
    <url>/posts/e52a7502/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>【议曰：“ 代有诡诈反为忠信者也。” 抑亦通变，适时所为、见机而作而不俟终日者。】</p>
<p>孔子曰：“ 君子贞而不谅。” 又曰：“ 近逝于义，言可复也。” 由是观之，唯义所在，不在信也。【议曰：微哉！微哉！天下之事也，不有所废则无以兴。若忠于斯，必不诚于彼，自然之理矣。由是观之，则我之所谓忠，则彼之所谓诈也。然则忠之与诈，将何所取定哉？抑我闻之：夫臣主有大义，上下有定分，此百代不易之道也。故欲行忠，观臣主之义定；欲行信，顾上下之分明。苟分义不愆于躬，虽谲而不正可也。】何以明之？</p>
<p>叶公问孔子曰：“ 吾党有直躬者，其父攘羊而其子证之。” 孔子曰：“ 吾党之直者异于是，父为子隐，子为父隐，直在其中矣。”</p>
<p>楚子围宋，宋求救于晋。晋侯使解扬如宋，使无降楚，曰：“ 晋师悉起，将至矣。” 郑人囚而献诸楚，楚子厚赂之，使反其言。许之。登诸楼车，使呼宋人而告之，遂致其君命。楚子将杀之，使与之言曰：“ 尔既许不谷而反之，何故？非我无信，尔其弃之，速即尔刑！” 对曰：“ 臣闻之，君能制命为义，臣能承命为信。信载义而行之有利，谋不失利，以卫社稷，民之主也。义无二信，信无二命。君之赂臣，不知命也。受命以出，有死无殒，又何赂乎？臣之许君，以成命也。死而成命，臣之禄也！寡君有信臣，下臣获考，死又何求！” 楚之舍之以归。</p>
<p>【韩子曰：“ 楚有直躬者，其父窃羊而讦之，令尹曰：” 必杀之！“ 以为直于君而曲于父，执其子而罪之。由是观之，夫君之直臣，父之暴子也。鲁人从君战，三战三北，仲尼问其故，对曰：” 吾有老父，死莫之养也。“ 仲尼以为孝，誉而用之。以是观之，夫父之孝子，君之北人也。故令尹诛而楚奸不止，闻仲尼赏之，鲁人易降。此上下之利，若是其异也，而人主兼誉匹夫之行，而求致社稷之福，必不几矣。】</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第八卷杂说-钓情</title>
    <url>/posts/ed6fb8cc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>孔子曰：“ 未见颜色而言曰瞽”，又曰：“ 未信则以为谤己。” 孙卿曰：“ 语而当，智也，默而当，智也。” 尸子曰：“ 听言，耳目不惧，视听不深，则善言不往焉。” 是知将语者，必先钓于人情，自古然矣。</p>
<p>韩子曰：“ 夫说之难也，在知所说之心可以吾说当之。说之以厚利，则见下节而遇 卑贱，必弃远矣【所说实为厚利则阴用其言而显弃其身，此不可不知也】。说之以名高，则见无心而远事情，必不收矣【所谓实为名高而阳收其身而实疏之。此不可不知也】。事以密成，语以泄败，未必其身泄之也，而说及其所匿之事，如是者身危【周泽未渥也，而语极知，说行而有功则德亡，说不行而有败则见疑，如是者身危】。贵人有过端，而说者明言善议以推其恶者身危。贵人或得计而欲自己为功，说者与知焉则身危。强之以其所不为，止之以其所不能已者身危。“ 又曰：” 与之论大人，则以为间己，与之论细人，则以为鬻权。论其所爱，则以为借资，论其所憎，则以为尝已。顺事陈意则曰怯懦而不尽，虑事广肆，则曰草野而居侮，此不可不知也……彼自智其计，则勿以其失当之，自勇其断，则勿以其敌怒之。“ 【凡说须旷日弥久，周泽而不凝，交争而不罪，乃明计利害，以致其功。直指是非，以饰其身。以此相持，此说之成也。】</p>
<p>荀悦曰：” 夫臣下所以难言者，何也？言出乎身则咎悔及之矣。“ 故曰：举过揭非，则有干忤之咎，劝励教诲，则有侠上之议。言而当，则耻其胜己也，言而不当，则贱其愚也。先己而同，则恶其夺己明也，后己而同，则以为从顺也。违下从上，则以为谄谀也，违上从下，则以为雷同也。言而浅露，则简而薄之，深妙弘远，则不知而非之。特见独智，则众恶其盖己也，虽是而不见称，与众同智，则以为附随也，虽得之不以为功。谦让不争，则以为易容，言而不尽，则以为怀隐，进说竭情，则以为不知量。言而不效，则受其怨责，言而事效，则以为固当。利于上不利于下，或便于左则不便于右，或合于前而忤于后，此下情所以常不通。仲尼发愤，称”予欲无言“者，盖为语之难也。何以明其难也？</p>
<p>昔宋有富人，天雨坏墙，其子曰：” 不筑，且有盗。“ 其邻人亦云。暮而果大亡，其家智其子而疑邻人之父。郑武公欲伐胡，乃以其子妻之，因问群臣：” 吾欲用兵，谁可伐者？“ 关其思曰：” 胡可伐。“ 乃戮关其思，曰：” 胡，兄弟之国也，子言伐之，何也？“ 胡君闻之，以为郑为亲己而不备郑，郑人袭胡，取之。此二说者，其智皆当矣，然而甚者为戮，薄者见疑，非智之难也，处智则难。</p>
<p>卫人迎新妇，妇上车，问：” 骖马，谁马也？“ 御者：” 借之。“ 新妇谓仆曰：” 拊骖，无苦服。“ 车至门，拔教：” 逆母，灭橹，将失火。“ 入室，见臼，曰：” 徙牖下，妨往来者。“ 主人大笑之。此三言，皆要言也，然而不免为笑者，早晚之时失矣。此说之难也。</p>
<p>说者知其难也，故语必有钓，以取人情。何以明之？</p>
<p>昔齐王后死，欲置后而未定，使群臣议。薛公田婴欲中王之意，因献其珥而美其一，旦日因问美珥所在，因劝立以为后，齐王大悦，遂重薛公。此情可以物钓也。</p>
<p>申不害始合于韩王，然未知王之所欲也，恐言而未必中于王也。王问申子曰：“吾谁与而可？” 对曰：“ 此安危之要，国家之大事也，臣请深惟而苦思之。” 乃微请赵卓、韩冕曰：“ 子，皆国之辩士也，夫为人臣者，言何必同？尽忠而已矣。” 二人各进议于王以事。申子微视王之所悦，以言于王，王大悦之。此情可以言钓也。</p>
<p>吴伐越，越栖于会稽，勾践喟然叹曰：“吾终此乎？” 大夫种曰：“汤系夏台，文王囚姜里，重耳奔翟，齐小白奔莒，其卒霸王。由是观之，何遽不为福乎？” 勾践既得免，务报吴。大夫种曰：“ 吾观吴王政骄矣，请尝之。” 乃贷粟以卜其事。子胥谏勿与，王遂与之。子胥曰：“ 王不听谏，后三年，吴其墟矣！” 太宰嚭闻之，馋曰：“ 伍员貌忠而实忍人。” 吴杀子胥，此情可以事钓也。</p>
<p>客以淳于髡见梁惠王，惠王屏左右，再见之，终无言，王怪之，让客。客谓淳于髡，髡曰：“ 吾前见王，王志在驰逐，后复见王，王志在音色，是以默然。” 客具以报王，王大骇曰：“ 淳于先生，诚圣人也。前有善献马者，寡人未及试，会生来。后有献讴者，未及试，又会生至。寡人虽屏人，然私心在彼。” 此情可以志钓也。</p>
<p>智伯从韩魏之君伐赵，韩魏用赵臣张孟谈之计，阴谋叛智伯。张孟谈因朝智伯，遇智果于辕门之外。智果入见智伯，曰：“ 二主殆将有变，臣遇张孟谈，察其志矜而行高，见二君色动而变，必背君矣。” 智伯不从，智果出，遂更其姓曰辅氏。张孟谈见赵襄子曰：“ 臣遇智果于辕门之外，其视有疑臣之心。入见智伯而更其族，今暮不击，必后之矣。” 襄子曰：“诺！” 因与韩魏杀守堤之吏，决水灌智伯军，此情可以视钓也。</p>
<p>殷浩仕晋，有盛名，时人观其出处，以卜江左兴亡，此情可以贤钓也。【 《吕氏春秋》曰：“ 夫国之将亡，有道者先去。”】</p>
<p>【《易》曰：“将叛者，其辞惭，中心疑者，其辞枝。吉人之辞寡，躁人之辞多。诬善之人，其辞游，失其守者，其辞屈。” 】</p>
<p>由是观之，夫人情必见于物。【昔者晋公好色，骊姬乘色以壅之。吴王好广地，太宰陈伐以壅之。桓公好味，易牙蒸子以壅之。沉冥无端，甚可畏也。故知人主之好恶，不可见于外。所好恶见于外，则臣妾乘其所好恶以行壅制焉。故曰：人君无意见则为下饵。此之谓也。】能知此者，可以纳说于人主矣。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第三卷权变-正论</title>
    <url>/posts/6a24346d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>【议曰：“反经”、“是非”、“适变” 三篇，虽博辩利害，然其弊流遁漫，羡无所归。故作“正论”以质之。】</p>
<p>孔子曰：“六艺于治一也。《礼》以节人，《乐》以发和，《书》以导事，《诗》以达意，《易》以神化，《春秋》以义。”</p>
<p>【班固曰：“ 乐者，圣人之所以乐也，而可以善人心，其感人也深。故先王著其教焉。夫人又血气心知之性，而无衰乐喜怒之常。应感而动，然后心术形焉。故纤微憔悴之音作，而民思忧；阐谐慢易之音作，而民康乐；粗厉猛奋之音作，而民刚毅；廉直正诚之音作，而民肃静；宽裕顺和之音作，而民慈爱；流僻邪散之音作，而民淫乱。先王耻其乱也，故制《雅》、《颂》之声。本之情性，稽之度数，制之礼义，合生气之和，导五常之行，使之阳而不散，阴而不集，刚气不怒，柔气不摄，四畅交于中，而发作于外。足以感人之善心，而不使邪气得接焉。是先王立乐之方也。”</p>
<p>班固曰：“人涵天地阴阳之气，有喜怒哀乐之情，天禀其性而不节也，圣人能为之节而不能绝也。故像天地而制礼乐，所以通神明，立人伦，正情性，节万事也。……。故孔子曰：‘ 安于治人，莫善于礼；风易俗，莫善于乐。揖让而治天下者，礼乐之谓也。’ ”】</p>
<p>【司马谈曰：“ 儒者，博而寡要，劳而少功，是以其事难尽从，然其 叙君臣父子之礼，列夫妇长幼之别，不可易也。夫儒者，以‘六艺’为法，经传以千万，累世不能通其学，当年不能究其礼，故曰‘ 博而寡要，劳而少功 ’ 。若夫列君臣父子之礼，叙夫妇长幼之别，虽百家勿能易也。”</p>
<p>司马谈曰：“ 阴阳之术，大详而众忌讳，使人拘而多畏，然其叙四时之大顺，不可失也。夫阴阳四时，八位十二度，二十四节，各有教令。曰顺之者昌，逆之者亡，未必然也。故曰使人拘而多忌。夫春生夏长，秋收冬藏，此天下之大经，弗顺则无以为天下纪纲。故曰叙四时之大顺，不可失也。”</p>
<p>司马谈曰：“ 法家严而少恩；然正君臣上下之分，不可改也。夫法家不别亲疏，不殊贵贱，一断于法，则亲亲尊尊之恩绝矣。可使行一时之计，而不可长用也。故‘ 严而少恩 ’。至于尊主卑臣，明职分不相逾越，虽百家不能改也。”</p>
<p>司马谈曰：“ 墨家俭而难遵，是以其事不可偏循。然其强本节用，不可废也。】</p>
</blockquote>
<blockquote>
<p>数子之言，当世得失，皆悉究矣。然多谬通方之训，好申一隅之说。贵清净者，以席上为腐论；束名实者，以柱下为诞辞。或推前王之风，可行于当年，有引救弊之规，宜流于长世。稽之笃论，将为弊矣。由此言之，故知有法无法，因时为业，时止则止，时行则行，动不失其时，其道光明。非至精者，孰能通于变哉？</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第三章权变-适变</title>
    <url>/posts/1e7152bf/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>昔先王当时而立法度，临务而制事，法宜其时则理，事适其务故有功。今时移而法不变，务易而事以古，是则法与时诡，而事与务易，是以法立而时益乱，务无而事益废。此圣人之理国也，不法古，不修今，当时而立功，在难而能免。</p>
<p>【秦孝公用卫鞅。鞅欲变法，孝公恐天下议己，疑之。卫鞅曰：“疑行无名，疑事无功。夫有高人之行者，固见非于世；有独智之虑者，必见教于人。愚者暗于成事，智者见于未萌。人不可与虑始，而可与乐成。论至德者，不和于俗；成大功者，不谋于众。是以圣人苟可以强国，不法其故；苟可以利人，不循其礼。” 孝公曰：“ 善。” 甘龙曰：“ 不然。圣人不易人而教，智者不变法而治。因人而教，不劳而功成。缘法而理，吏习而人安。” 卫鞅曰：“ 龙之所言，世俗之言。常人安于习俗，学者溺于所闻。以此两者居官守法可也，非所以与论于法之外也。三代不同礼而王；五霸不同法而霸。智者作法，愚者制焉。贤者更礼，不肖者拘焉。” 杜贽曰：“ 利不百，不变法；功不十，不易器。法古无过，修礼无邪。” 卫鞅又曰：“ 治代不一道，便国不法故。故汤武不循古而王，夏殷不易礼而亡。反古者不可非，而循礼者不足多。” 孝公曰：“ 善。” 遂变法也。】</p>
<p>由是言之，故知若人者，各因其时而建功立德焉。【孟子曰：“ 虽有磁基，不如遇时；虽有智慧，不如逢代。” 范蠡曰：“ 时不至，不可强生；事不究，不可强成。” 《语》 曰：“ 圣人修备以待时也。” 】</p>
<p>何以知其然耶？桓子曰：“ 三皇以道治，五帝用德化，三王由仁义，五伯用权智。” 【说曰：无制令刑罚谓之皇，有制令，无刑罚谓之义；赏善诛恶，朝诸侯，朝事，谓之王；兴兵众，立约盟，以信义矫代谓之伯。文子曰：“ 帝者，贵其德也；王者，尚其义也；霸者，迫其理也。道狭然后任智，德薄然后任刑，明浅然后任察。议曰：夫建国立功，其政不同也如此。】</p>
<p>五帝以上久远，经传无事，唯王霸二盛之类，以定古今之理焉。【秦汉居帝王之位，所行者霸事也。故以为德之次。】</p>
<p>夫王道之治，先除人害，而足其衣食。</p>
<p>【论曰：” 五亩之宅，树之以桑，匹妇蚕之，年五十者，可以衣帛矣。百亩之田，数口之家，耕稼修理，可以无饥矣。鸡豚狗彘之畜，不失其时，老者可以食肉矣。夫上无贪欲之求，下无奢淫之人，藉税省少而徭役不繁，其仕者，食禄而已，不与人争利焉。是以产业均而贫富不能相悬也。“ 】</p>
<p>然后教以礼仪。</p>
<p>【故明王审己正统，慎乃其位。宫室舆服不逾礼制，九女正序于内，三公分职于外。制井田以齐之，设诸侯以牧之，使饶不溢侈，少不匮乏，然后申以辟雍之化，示以揖让之容，是以和气四塞，祸乱不生，此圣王之教也。】</p>
<p>而威以刑诛，使知好恶去就。</p>
<p>是故大化四凑，天下安乐，此王者之术。</p>
<p>【王者，父天母地，调和阴阳，顺四时而理五行，养黎元而育群生，故王之为言往也。盖言其惠泽，优游善养润天下，天下归往之，故曰王也。】</p>
<p>霸功之大者，尊君卑臣，权统由一，政不二门，赏罚必信，法令著明，百官修理，威令必行。</p>
<p>【夫霸君亦为人除难兴利以富国强兵，或承衰乱之后，或兴兵征伐。皆未得，遵法度，申文理，度代而制，因时施宜，以从便善之计，而务在于立功也。】此霸者之术。</p>
<p>【王道纯而任德，霸道驳而任法。此优劣之差也。】</p>
<p>《道德经》曰：” 我无为而人自化。“ 《文子》曰：” 所谓无为者，非谓引之不来，推之不往，谓其循理而举事，因资而立功，推自然之势也。“ 【故曰：” 智而好问者圣；勇而好问者胜。乘众人之智，即无不任也；用众人之力，即无不胜也。故圣人举事，未尝不因其资而用也。】 故曰：汤武，圣主也，而不能与越人乘舲舟，泛江湖。伊尹，贤相也，而不能与胡人骑原马，服**。孔、墨，博通也，而不能与山居者入榛薄，出险阻。</p>
<p>由是观之，人智于物，浅矣，而欲以昭海内，存万物，不因道理之数，而专己之能，则其穷不远。故智不足以为理，勇不足以为强，明矣。然而君人者，在庙堂之上而知四海之外者，因物以识物，因人以知人也。</p>
<p>【《吕氏春秋》曰：“ 是天无形而万物以成，大圣无事而千官尽能，此谓不教之教，无言之昭业。” 】</p>
<p>夫冬日之阳，夏日之阴，万物归之，而莫之使。至精之感，弗召自来。待目而昭见，待言而使令，其于理难矣。</p>
<p>【《文子》曰：“ 三月婴儿，未知利害，而慈母之忧喻焉者，情也。” 故曰：“ 言之用者小，不言之用者大。又曰：不言而信，不施而仁，不怒而威，是以天心动化者也。施而仁，言而信，怒而威，是以精诚为之者也。施而不仁，言而不信，怒而不威，是以外貌为之也。】</p>
<p>【庄子曰：” 天地有大美而不言，四时有明法而不议，万物有成理而不说。圣人无为，大圣不作，观于天地之谓也。】</p>
<p>不言之令，不视之见，圣人所以为师。此黄老之术也。</p>
<p>六经之理，贵于未乱；兵家之胜，贵于未战。</p>
<p>此孔氏之术也。【议曰：孔氏之训，务德行义，盖王道也。】</p>
<p>墨子曰：“ 古之人未知为宫室，就陵阜而居，穴而处，故圣王作为宫室。为宫室之法，高足以避润湿，边足以圉风寒。宫墙之高，足以别男女之礼。谨此则止，不以为观乐也。故天下之人，财用可得而足也。当今之王为宫室则与此异矣。必厚敛于百姓以为宫室，台榭曲直之望，青黄刻镂之饰，为宫室若此，故左右皆法而象之。是以财不足以待凶饥，振孤寡，故国贫而难理也。为宫室不可不节。【议曰：此节宫室者。】</p>
<p>古之人未知为衣服，时衣皮带茭，冬则不轻而暖，夏则不轻而清。圣王以为不中人之情，故圣人作，诲妇人，以为人衣。为衣服之法，冬则练帛，足以为轻暖，夏则絺绤，足以为轻清，谨此则止，非为荣耳目，观于人也。是以其人用俭约而易治，其君用财节而易赡也。当今之王，其为衣服，则与此异矣。必厚敛于百姓，以为文彩靡曼之衣，铸金以为钩，珠玉以为佩。由此观之，其为衣服，非为身体，皆为观好耶。是以其人淫僻而难治，其君奢侈而难谏。夫以奢侈之君，御淫僻之人，欲国无乱，不可得也。为衣服不可不节。”【 议曰：此节衣服也。】</p>
<p>此墨翟之术也。【议曰：墨家之议，去奢节用，盖强本道。】</p>
<p>商子曰：“ 法令者，人之命也，为治之本。【慎子曰：” 君人者，舍法而以身治，则受赏者虽当，望多无穷；受罚者虽当，望轻无已。君舍法而以心裁轻重，怨之所由生也。是以分马者之用策，分田者之用钩，非以钩策为过人之智也，所以去私塞怨也。故曰：夫君任法而不躬为，则怨不生而上下和也。“ 】 一兔走，百人逐之，非以兔可分为百，由名分之未定也。卖兔满市，盗不敢取者，由名分已定也。故名分未定，虽尧舜禹汤，且皆加务而逐之。名分之定，则贫盗不敢取。故尧舜圣人之为法令也，置官也，置吏也，所以定分也。名分定则大诈贞信，巨盗原悫，而各自治也。” 【《尹文子》曰：“ 名定则物不竞，分明则私不行。物不竞，非无心，由名定，故无所措其心；私不行，非无欲，由分明，故无所措其欲。然则心欲人人有之，而得同于无心无欲者，在制之有道故也。” 】</p>
<p>申子曰：“ 君如身，臣如手，君设其本，臣操其末。为人君者，操契以责其名。名者，天地之网，圣人之符。张天地之网，用圣人之符，则万物无所逃矣。”</p>
<p>此商鞅、申、韩之术也。</p>
<p>【恒范曰：“ 夫商鞅申韩之徒，贵尚谲诈，务行苛刻。废礼义之教，任刑名之教，不师古，始败俗伤化。此则伊尹、周公之罪人也。然其尊君卑臣，富国强兵，守法持术，有可取焉。逮至汉兴，有宁成，郅都之辈，仿商、韩之治，专以杀伐残暴为能，顺人主之意，希旨之行，要时趋利，敢行败祸，此又商、韩之罪人也。然其抑强族，抚孤弱，清己禁奸，背私立公，亦有取焉。至于晚代之所谓能者，乃犯公家之法，赴私门之势，废百姓之务，趋人间之事，决烦理务，临时苛辩，使官无谴负之累，不省下人之冤，复是申、韩、宁、郅之罪人也。”】</p>
<p>由是观之，故知治天下者，有王霸焉，有黄老焉，有孔墨焉，有申商焉，此所以异也，虽经纬殊制，救弊不同，然康济群生，皆有以矣。今议者或引长代之法，诘救弊之言【议曰：救弊为夏人尚忠，殷人尚敬，周人尚文者】；或引帝王之风，讥霸者之政，不论时变，而务以饰说。故是非之论，纷然作矣。言伪而辩，顺非而泽，此罪人也。故君子禁之。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第三卷权变-反经</title>
    <url>/posts/7d0687a0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>《韩诗外传》曰：“夫士有五反，有势尊贵不以爱人行义理，而反以暴傲。” ——【 反贵也。古语曰：” 富能富人者，欲贫不可得；贵能贵人者，欲贱不可得；达能达人者，欲穷不可得。“ 梅福曰：“ 存人所以自立也；壅人所以自塞也。” 】</p>
<p>家富厚不以振穷救不足，而反以侈靡无度。 —— 【反富也。】</p>
<p>资勇悍不以卫上攻战，而反以侵凌私斗。 —— 【反勇也。凡将帅轻去就者，不可使镇边，使仁德守之则安矣。】</p>
<p>心智慧不以端计教，而反以事奸饰非。 —— 【反智慧也。《说苑》曰：“ 君子之权谋正，小人之权谋邪。” 】</p>
<p>貌美好不以统朝莅人，而反以盅女从欲。 —— 【反貌也。】</p>
<p>此五者，所谓士失其美质。</p>
</blockquote>
<blockquote>
<p>太公曰：“明罚使人畏慑，人畏慑则变故出。 —— 【反明罚也。】 明察使人扰，人扰则人徙，人徙则不安其处，易以成变。” —— 【反明察也。】 太公曰：“ 明赏则不足，不足则怨长。明王理人，不知所好，而知所恶；不知所归，而知所去。使人各安其所生，而天下静矣。”</p>
<p>晋刘颂曰：“ 凡监司欲举大而略小，何则？ 夫细过微阙，谬忘之失，此人情所必有，所固不许在不犯之地，而悉纠以法，则朝野无立人。此所谓以治而乱也。”</p>
<p>韩子曰：“儒者以文乱法，侠者以武犯禁。“</p>
<p>慎子曰：” 忠未足以救乱代而适足以重非。** 。然则孝子不生慈父之义【六亲不和有孝慈】，而忠臣不生于圣君之下【国家昏乱有忠臣】。故明主之使其臣也，忠不得过职，而职不得过官。 —— 【反忠也]</p>
</blockquote>
<p>这段话我的理解，如果不是因为国家昏乱，则个人的忠名不显。而个人的忠名越显，反而越彰显出国家昏乱（如果只是敢于进言而无助于事），因此“适足以重非”。</p>
<blockquote>
<p>跖之徒问于跖曰：“盗亦有道乎？” 跖曰：” 何适而无有道耶？夫妄意室中之藏，圣也。入先，勇也。出后，义也。知可否，智也。分均，仁也。五者不备而能成大盗者，天下未之有也。“</p>
</blockquote>
<blockquote>
<p>由是观之，善人不得圣人之道不立，盗跖不得圣人之道不行。天下之善人少而不善人多，则圣人之利天下也少而害天下也多矣。 —— 【反仁义也。】</p>
</blockquote>
<blockquote>
<p>汉武时，河间献王来朝，造次必于仁义。武帝色然难之，谓曰：” 汤以七十里，文王以百里，王其勉之！” 王知其意，归即纵酒。</p>
<p>由是言之，夫仁义兼济，必有分乃可。故尸子曰：“ 君臣父子，上下长幼，贵贱亲疏，皆得其分理。爱得分曰仁。施得分曰义。虑得分曰智。动得分曰适。言得分曰信。皆得其分而后为成人。”</p>
<p>由是言之，跖徒之仁义非其分矣。</p>
</blockquote>
<blockquote>
<p>由是言之，夫仁义礼乐、名法刑赏、忠孝贤智之道，文武明察之端，无隐于人，而常存于代，非自昭于尧汤之时，非故逃于桀纣之朝。用得其道则天下理，用失其道则天下乱。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第二卷德行-德表</title>
    <url>/posts/9c3a31d9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>孔子曰：“性相近也，习相远也。” 言嗜欲之本同，而迁染之途异也。夫刻意则行不肆，牵物则其志流。是以圣人导人理性，裁抑流宕，慎其所与，节其所偏。故《传》曰：“ 审好恶，理情性，则王道毕矣。” 治性之道，必审己之所有余，而强其所不足。盖聪明流通者，戒于太察；寡言少见者，戒于壅蔽；勇猛刚强者，戒于太暴；仁爱温良者，戒于无断；湛静安舒者，戒于后时；广心浩大者，戒于遗忘。</p>
</blockquote>
<blockquote>
<p>此拘亢之材，非中庸之德也。</p>
</blockquote>
<blockquote>
<p>文子曰：“ 凡人之道，心欲小，志欲大，智欲圆，行欲方，能欲多，事欲少。” 所谓“心小”者，虑患未生，戒祸慎微，不敢纵其欲也；“ 志大” 者，兼包万国，一齐殊俗，是非辐辏，中之为毂也；“智圆” 者，终始无端，方流四远，深泉而不竭也；“行方”者，直立而不挠，素白而不污，穷不易操，达不肆志也；“能多” 者，文武具备，动静中仪也；“事少” 者，执约以治广，处静以待躁也。</p>
<p>夫天道极即反，盈即损。故聪明广智，守以愚；多闻博辩，守以俭；武力毅勇，守以畏；富贵广大，守以狭；德施天下，守以让。此五者，先王所以守天下也。</p>
<p>《传》曰：“无始乱，无怙富，无恃宠，无违同，无傲礼，无骄能，无复怒，无谋非德，无犯非义。“  此九言，古人所以立身也。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>说文解字第四册笔记</title>
    <url>/posts/da100df3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《说文解字》节选</p>
<span id="more"></span>
<p><strong>羁</strong>：<br>
羁，马络头也。<br>
原义是马络头。进而延申指用笼头系住马头。<br>
由络马头延申为束缚。例如“放荡不羁”。</p>
<p><strong>益</strong>：<br>
益，饶也。<br>
甲骨文从皿，“皿”上有很多“水”，会水太多而流出盆外之意。</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>说文解字</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>说文解字第三册笔记</title>
    <url>/posts/259f533d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《说文解字》节选</p>
<span id="more"></span>
<p><strong>逮</strong>：<br>
逮，及也。<br>
金文似右手揪住一条尾巴的样子。</p>
<p><strong>族</strong>：<br>
族，矢锋也。束之族族也。<br>
族，原义是箭头。</p>
<p><strong>感</strong>：<br>
感，动人心也。<br>
感的原义是人心受到外界影响而触动。</p>
<p><strong>意</strong>：<br>
意，志也。从心察言而知意也。<br>
意，意向。用心去考察别人的言语就知道他的意向。</p>
<p><strong>期</strong>：<br>
期，会也。<br>
期，约会。</p>
<p><strong>拜</strong>：<br>
拜，手至地也。<br>
拜，两手至地。<br>
甲骨文似双手捧禾麦奉献给神祖之行，会向神祖拜祭祈祷之意。</p>
<p>​</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>说文解字</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第二卷德行-臣行</title>
    <url>/posts/6feddce9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>夫人臣萌芽未动，形兆未见，昭然独见存亡之机，得失之要，豫禁乎未然之前，使主超然立乎显荣之处，如此者，圣臣也。</p>
<p>虚心尽意，日进善道，勉主以礼义，谕主以长策，将顺其美，匡救其恶，如此者，大臣也。</p>
<p>夙兴夜寐，进贤不懈，数称往古之行事，以厉主意，如此者，忠臣也。</p>
<p>明察成败，早防而救之，塞其间，绝其源，转祸以为福，君终己无忧，如此者，智臣也。</p>
<p>依文奉法，任官职事，不受馈赠，食饮节俭，如此者，贞臣也。</p>
<p>国家昏乱，所为不谀，敢犯主之严颜，而言主之过失，如此者，直臣也。</p>
<p>是谓六正。</p>
</blockquote>
<blockquote>
<p>安官贪禄，不务公事，与世沉浮，左右观望，如此者，具臣也。</p>
<p>主所言皆曰“善”，主所为皆曰“可”，隐而求主之所好而进之，以快主之耳目。偷合苟容，与主为乐，不顾后害，如此者，谀臣也。</p>
<p>中实险诐，外貌小谨，巧言令色，又心疾贤。所欲进则明其美，隐其恶；所欲退则彰其过，匿其美，使主赏罚不当，号令不行，如此者，奸臣也。</p>
<p>智足以饰非，辩足以行说，内离骨肉之亲，外妒乱于朝廷，如此者，馋臣也。</p>
<p>专权擅势，以轻为重；私门成党，以富其家；擅矫主命，以自显贵，如此者，贼臣也。</p>
<p>谄主以佞邪，坠主于不义，朋党比周，以蔽主明，使白黑无别，是非无闻；使主恶布于境内，闻于四邻，如此者，亡国之臣也。</p>
<p>是谓六邪。</p>
</blockquote>
<blockquote>
<p>议曰：夫圣人德全，器无不备。中庸已降，才则好偏。故曰：柴也愚，参也鲁，师也辟，由也喭。由此观之，全德者鲜矣！全德既鲜，则资矫情而力善矣！然世恶矫伪，而人贤任真。使其真贪愚而亦任之，可为贤乎？对曰：吁！何为其然？夫肖貌天地，负阴抱阳，虽清浊贤愚，其性则异，而趋走嗜欲，所规则同。故靡颜腻理，人所悦也；乘坚驱良，人所爱也；哭心贞节，人所难也；徇公灭私，人所苦也。不以礼教节之，则荡而不制，安肯攻苦食淡，贞洁公方，临财廉而取与义乎？故《礼》曰：”欲不可纵，志不可满。“ 古语云：” 廉士非不爱财，取之有道。“ 诗云：” 如切如蹉，如琢如磨。“ 皆矫伪之谓也。 若肆其愚态，随其鄙情，名曰任真而贤之，此先王之罪之也。故吾以为矫伪者，礼义之端；任真者，贪鄙之主。夫强仁者，庸可诬乎？</p>
</blockquote>
<blockquote>
<p>或曰：”长平之事，白起坑赵卒四十万，可为奇将乎？“</p>
<p>何晏曰：”白起之降赵卒，诈而坑其四十万，其徒酷暴之谓乎？ 后亦难以重得其志矣！ 向使众人预知降之必死，则张虚拳，犹可畏也。况于四十万披坚执锐哉？天下见降秦之将头颅依山，归秦之众骸积成丘，则后日之战，死当死耳，何众肯服，何城肯下乎？是为虽能裁四十万之命，而适足以强天下之战。欲以一期之功，而乃更坚诸侯之守。故兵进而自伐其势，军胜而还丧其计，何者？设使赵众复合，马服更生，则后日之战，必非前日之对也，况今皆使天下为后日乎！其所以终不敢复加兵于邯郸者，非但忧平原之补缝，患诸侯之救至也，徒讳之而不言耳。且长平之事，秦人十五以上，皆荷戟而向赵矣。夫以秦之强，而十五以上，死伤过半，此为破赵之功小，伤秦之败大也。又何称奇哉？“</p>
<p>议曰：黄石公称柔者能制刚，弱者能制强。柔者德也，刚者贼也。柔者人之所助，刚者怨之所居。是故纣之百克而卒无后，项羽兵强，终失天下。故随何曰：” 使楚胜，则诸侯自危惧而相救。夫楚之强，适足以致天下兵耳。“ 由是观之，若天下已定，借一战之胜，诈之可也。若海内纷纷，雌雄未决而失信于天下，败亡之道也。当亡国之时，诸侯尚强，而白起乃坑赵降卒，使诸侯畏之而合纵。诸侯合纵，非秦之利，为战胜而反败。何晏之论当矣。</p>
</blockquote>
<p>有意思！长平之战或胜于军事，但输于政治。</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>说文解字第二册笔记</title>
    <url>/posts/c3d58b1a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《说文解字》节选</p>
<span id="more"></span>
<p><strong>绝</strong>：<br>
绝，断丝也。<br>
绝，用刀断丝为二。</p>
<p><strong>怕</strong>：<br>
怕，无为也。</p>
<p><strong>守</strong>：<br>
守，守官也。<br>
“守”，金文是屋子里的一只手，由手在屋内掌管职责之意。<br>
原义是掌管职守。</p>
<p><strong>安</strong>：<br>
安，静也。<br>
女子坐在房中，会平安、安适之意。</p>
<p><strong>家</strong>：<br>
家，居也。<br>
“屋里有豕”为“家”。</p>
<p><strong>圣</strong>：<br>
圣，通也。<br>
圣，双耳畅通。<br>
甲骨文从耳，从口。<br>
原义是通达，延申指聪明、才智超群。在很早的时候人们传播知识、交流经验主要通过口耳相传，于是，只有善于聆听的人才能得到这么多的知识，故“圣”延申指博学多闻的人。</p>
<p><strong>拯</strong>：<br>
抍，上举也。<br>
原义是向上举，延申为援助、救济。</p>
<p><strong>报</strong>：<br>
报，当罪人也。<br>
报，判决罪人。甲骨文和金文左边是一个刑具，右边是一只手抓住一个人给其加上刑具的样子，会给人治罪之意。<br>
“报”的原义是按律判决罪人。例如《韩非子》：“报而罪之。” 意思是判决而治他的罪。判决罪人需要告知上级审批，故延申指告诉、告知。例如“通报”、“报警”。也引申为报答，例如”投桃报李“。<br>
好的回报是报答，但恶的回报就是报复了，所以”报“又指报复。例如”报仇雪耻“。也引申指由某种行为得到的结果。例如”善有善报“。</p>
<p><strong>莠</strong>：<br>
莠，禾粟下生莠。<br>
莠，是在禾粟之间生长的似禾非禾的东西叫“莠”。<br>
“莠”的原义是一种田间生长的外形似禾苗的杂草，其穗上似狗尾巴的毛，也叫狗尾巴草。例如《诗经》：“惟莠骄骄。” 意思是只有莠草长得十分茂盛。莠会妨碍禾苗生长，故延申成恶草的通称。也引申为坏、恶。例如“良莠不齐”。</p>
<p><strong>英</strong>：<br>
英，草荣而不实者。<br>
英，草只开花却不结实。<br>
“英”的原义是花。如《桃花源记》：“芳草鲜美，落英缤纷。”<br>
花是美好的，延申成美好、杰出、优异。</p>
<p><strong>萌</strong>：<br>
萌，草芽也。<br>
“萌”的原义是草木的芽。延申指发芽；又引喻事情刚刚显露的发展趋势或者情况、开端。例如《韩非子》：“圣人见微以知萌，见端以知末。” 又指开始发生。例如“萌动”。</p>
<p><strong>大</strong>：<br>
大，天大，地大，人亦大。故大象人形。<br>
“大”是象形字。甲骨文、金文、小篆的形状全部似一个正面站立、张开双手双脚的人的形象。<br>
“大”的原义是人。人为“万物之灵”，上古以人为大，故延申为“大小”之“大”。也引申表示重要、重大。</p>
<p><strong>太</strong>：<br>
“太”是象形字。甲骨文中的“太”字就是“大”形，似正面站立的人形。金文下面增加了一个曲笔，以与“大”相区别。隶变以后楷书写成“太”。<br>
“太”是在“大”的基础上再加了一点而形成的，故延申成过于。如杜甫《新婚别》：“暮婚晨告别，无乃太匆忙！” 延申为最、极。进而延申指身份最高或者辈分更高的。例如”太公“、”太后“。</p>
<p><strong>天</strong>：<br>
天，颠也。至高无上，从一大<br>
天，头顶。<br>
”天“的原义是人的头顶；两眉之间，称为”天庭“。人至高无上的部分为”天“（头），自然界至高无上的部分也为“天”。</p>
<p><strong>夫</strong>：<br>
夫，丈夫也。从大，一以象簪也。周制以八寸为尺、十尺为丈。人长八尺，故曰丈夫。<br>
夫，成年男子。从大，一用以似成年男子头发上的簪子之形。</p>
<p><strong>君</strong>：<br>
君，尊也。从尹，发号，故从口。</p>
<p><strong>混</strong>：<br>
混，丰流也。从水昆声。<br>
混，盛大的水流。<br>
“混”的原义是水势盛大。水大则泥多，容易浑浊，故延申指浑浊，水多泥、多杂质而不清澈。进而延申指糊涂、不懂事。</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>说文解字</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-政体</title>
    <url>/posts/a3353214/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>【议曰：夫政理，得人则心，失人则毁。故首简才，次论政体也。】</p>
</blockquote>
<blockquote>
<p>措国于不倾之地，有德也。</p>
</blockquote>
<blockquote>
<p>积於不涸之仓，务五谷也。</p>
</blockquote>
<blockquote>
<p>下令于流水之原，以顺人心也。</p>
<p>尉缭子曰：“令，所以一众心也。不审所出，则数变，数变则令虽出，众不信也。出令之法虽有小过，无更，则众不二听，即令行矣。”</p>
</blockquote>
<blockquote>
<p>使士于不诤之官，使人各为其所长也</p>
<p>孙卿曰：“相高下，序五谷，君子不如农人；通财货，辩贵贱，君子不如贾人；设规矩，便备用，君子不如工人。若夫论德而定次，量能而授官，言必当理，事必当务，然后君子之所长。”</p>
<p>文子曰：“力胜其任即举之，不重也；能务其事则为之，不难也。”</p>
</blockquote>
<p>这里的“诤” 解释为不争夺权势，个人感觉根据下文说不通，解释为不让人争论更好，即举官应该做到让人无法非议。</p>
<blockquote>
<p>明必死之路，严刑罚也。</p>
<p>议曰：孔子曰：“上失其道而杀其下，非礼也。” 故三军大败，不斩；狱*不治，不可刑。何也？上教之不行，罪不在人故也。夫慢令致诛，贼也；征敛无时，暴也；不诫责成，虐也。政无此三者，然后刑，即可也。陈道德以先服之，犹不可，则尚贤以劝之，又不可，则废。不能以惮之，而犹有邪人不从化者，然后待之以刑矣。“</p>
</blockquote>
<blockquote>
<p>开必得之门，信庆赏也。</p>
</blockquote>
<blockquote>
<p>不为不可成，量人力也。</p>
<p>文子曰：”夫债少易偿也，职寡易守也，任轻易劝也。上操约少之分，下效易为之功，是以为君为臣久而不相厌也。末世之法，高为量而罪不及，重为任而罚不胜，危为难而诛不敢。人困于三责，即饰智以诈上，虽峻法严刑，不能禁其奸也。“</p>
</blockquote>
<blockquote>
<p>不求不可得，不强人以其所恶也。</p>
<p>故其称曰：”政“者，政之所行，在顺人心，政之所废，在逆人心。夫人恶忧劳，我逸乐之；人恶贫贱，我富贵之；人恶危坠，我存安之；人恶绝灭，我生育之。能逸乐之，则人为之忧劳；能富贵之，则人为之贫贱；能存安之，则人为之危坠；能生育之，则人为之绝灭。故从其四欲，则远者自亲，行其四恶，则近者亦叛。</p>
</blockquote>
<blockquote>
<p>不处不可久，不偷取一世宜也。</p>
</blockquote>
<blockquote>
<p>知时者，可立以为长。</p>
<p>范蠡曰：” 时不至不可强生，事不容不可强成。“ 管子曰：” 圣人能辅时，不能违时。“ 《语》曰：”圣人修备以待时也。“</p>
</blockquote>
<blockquote>
<p>审于时，察于用，而能备官者，可奉以为君。</p>
<p>管仲曰：” 大位不仁，不可授以国柄；见贤不让，不可与尊位；罚避亲戚，不可使主兵；不好本事，不可与都邑。“ 又曰：” 使贤者食于能，则上尊崇；斗士食于功，则卒轻死。使二者设于国，则天下理。“</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-论士</title>
    <url>/posts/b8f1ee07/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>《书》曰：“能自得师者王。” 何以明之？齐宣王见颜触曰：“触前。” 触亦曰：“王前。” 宣王作色曰：“王者贵乎？士者贵乎” ……</p>
<p>宣王左右曰：“大王据千乘之地，而建千石之钟，东西南北，莫敢不服。今夫士之高者，乃称匹夫，徒步而处于农亩，下则鄙野、监门、闾里。士之贱也，亦甚矣。” 触曰：“古大禹之时，诸侯万国。舜起农亩而为天子。及汤之时，诸侯三千。当今之世，南面称寡人则，乃四世。由此观之，非得失之策与？稍稍诛灭，灭亡无族之时，欲为监门、闾里，安可得哉？《易传》不云乎：‘居上位，未得其实。’ 故无其实而喜居名者削；无其德而望其福者约；无其功而受其禄者辱，祸必掘。故曰：‘ 矜功不立，虚愿不至。’ 至皆夸其名华而无其实德也。是以尧有九佐，舜有十友，禹有五丞，汤有三辅，自古及今，而能虚成名于天下者，无有。是以君王无羞亟问，不愧下学，而成其道。老子曰：‘ 虽贵，必以贱为本；虽高，必以下为基。’ 是以侯王称孤、寡人、不谷。夫孤寡者，困贱、下位者也，而侯王以是谓，岂非下人而尊贵士与？夫尧传舜，舜传禹，周成王传周公旦，而世世称名，实以明乎士之贵也。“</p>
<p>谚曰：”浴不必江海，要之去垢；马不必骐骥，要之善走；士不必贤也，要之知道；女不必贵种，要之贞好。“ 何以明之？淳于髡谓齐宣王曰：”古者好马，王亦好马；古者好味，王亦好味；古者好色，王亦好色；古者好士，王独不好。“ 王曰：” 国无士耳。有则寡人亦悦之。“ 髡曰：” 古有骅骝，今之无有，王选于众，王好马矣；古有豹像之胎，今之无有，王选于众，王好味矣；古有毛嫱、西施，今之无有，王选于众，王好色矣；王必待尧舜禹汤之士，而后好之，则尧舜禹汤之士，亦不好王矣。“</p>
<p>《淮南》曰：”待腰袅、飞兔而后驾，则世莫乘车矣；待西施、洛浦而后妃，则终身不家矣。然不待古之英隽而自足者，因其所有而遂用之也。“</p>
<p>郭隗说燕昭王曰：” 帝者与师处，王者与友处，霸者与臣处，亡国与厮役处。诎指而事之，北面受学，则百己者至；先趋而后息，先问而后默，则什己者至；人趋己趋，则若己者至；凭几据杖，眄视指使，则厮役之人至；恣睢奋击，呴藉叱咄，则徒隶之人至矣。“此乃古之服道致士者也。</p>
<p>黄石公曰：”礼者，士之所归；赏者，士之所死。招其所归，示其所死，则所求者至矣。“</p>
</blockquote>
<blockquote>
<p>【议曰：世之善恶，难得而知，苟非其人，莫见其际，何者？夫文章为武人所嗤，未必鄙也；为扬、马所嗤，此真鄙也。夫人臣为桀、纣所毁，未必为愚也；必若尧舜所毁，此真愚也。世之毁誉不足信也。故曰：不夜出，安知有夜行人？太公曰：“ 智与众同，非人师也；伎与众同，非国工。” 老子曰：“下士闻道，大笑之，不笑不足以为道。” 故曰：凡人所贱，圣人所贵。信矣哉！】</p>
</blockquote>
<blockquote>
<p>《语》曰：”知人未易，人未易知。“</p>
</blockquote>
<blockquote>
<p>《语》曰：”夫有国之主，不可谓举国无深谋之臣，合朝无智策之士，在听察所考精与不精，审与不审耳。“ …… 天下之国，莫不皆有忠臣谋士也。</p>
<p>议曰：天下无灾害，虽有贤德，无所施材。老子曰：”大道废，有仁义；国家混乱，有忠诚。《淮南子》曰：”未有其功而知其贤者，唯尧之知舜也；功成事立而知其贤者，市人之知舜也。“ …… 故曰：“贤、不肖者，才也；遇与不遇者，时也。” 诚哉，是言也。</p>
</blockquote>
<blockquote>
<p>黄石公曰：”罗其英雄，则敌国穷。夫英雄者，国家之干；士民者，国家之半。得其干，收其半，则政行而无怨。知人者哲，唯帝难之。“ 慎哉！</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-察相</title>
    <url>/posts/3e46a22e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这里的“相”除了长相，骨骼等，还指的是人的形态、举止。</p>
<span id="more"></span>
<blockquote>
<p>富贵在于骨法，忧喜在于容色，成败在于决断。由此参之，万不失一。</p>
</blockquote>
<blockquote>
<p>言性灵者存乎容止。斯其大体。</p>
</blockquote>
<blockquote>
<p>夫人有六贱：<br>
头小身大，为一贱 【又曰：额角陷缺，天中洼下，亦为一贱。】<br>
目无光泽，为二贱【又曰：胸背俱薄，亦为二贱。《经》曰：陷胸薄尻及猴目，皆穷相也】。<br>
举动不使，为三贱【又曰：声音雌散，亦为三贱。夫人不笑似笑，不嗔似嗔，不喜似喜，不畏似畏，不醉似醉，常如宿醒，不愁似愁，常如忧戚，容貌缺乏，如经痫病，神色凄怆，常如有失，举止张皇，恒如趋急，言语涩缩，若有隐藏，体貌低催，如遭凌辱，此并神不足者也。神不足者，多牢狱厄。有官隐藏而失，有位贬逐而黜者也。<br>
鼻不成就，准向前低，为四贱<br>
脚长腰短，为五贱<br>
文策不成，唇细横长，为六贱。【又曰：多言少信，亦为六贱。<br>
此贵贱存乎骨骼者也。</p>
</blockquote>
<p>译文解释：相面要从身体结构的整体上把握，绝不能只见树木、不见森林。大凡人的姿容，都以“整”为贵。这个“整”指的并不是整齐划一，而是人体的各个部位都要匀称、均衡，从而构成一个和谐有机的整体。比如个子矮的人不能太胖；个子高的人不能太瘦，不然就像一根茅草或电线杆。背部应该浑圆而厚实，腹部应该突出而平坦，手部应该温润而柔软，脚应该丰厚而饱满，足心应该虚能藏蛋 – 这也是所谓的“整”。</p>
<blockquote>
<p>昔姑布之卿谓子贡曰：“郑东门有一人，其长九尺六寸，河目而龙颜，其头似尧，其颈似皋陶，其肩似子产，然自腰以下不及禹三寸，垒然若丧家之犬。”</p>
</blockquote>
<p>译文：郑国东门的这个人虽然有尧一样的头颅，皋陶一样的脖颈，子产一样的肩膀，然而由于腿太短，所以像一只丧家之犬。这就是因为此人的相貌违反了“整”的原则。</p>
<blockquote>
<p>夫命之与相，犹声之与响也。声动乎几响，穷乎应，必然之理也。虽云以言信行，失之宰予，以貌度性，失之子羽。然《传》称：“无忧而戚，忧必及之；无庆而乐，乐必还之。” 此心有先动而神有先知，则色有先见。故扁鹊见桓公，知其将亡；申叔见巫臣，知其窃妻。或跃马膳珍，或飞而食肉，或早隶晚侯，或初刑末王。铜岩无饱生，玉馔终乎饿死。则彼度表扪骨，指色摘理，不可诬也。故列云尔。</p>
</blockquote>
<p>这一篇我原来当作糟粕，现在想想也很有道理的。长相、身高等确实是天生，但是形态、举止等是可以后天改变的，是可以教化的。按峰老师的说法，以貌取人仍然是最简单最直接的方法。人的内心的情志一定会通过外貌和举止来体现出来，而且更多的时候我们也只能通过人的外貌、形态和举止对其它人做出一个判断。</p>
<p>比如目光无泽、举动不使（译文，行为举止看着力不从心）就说明这个人意志薄弱（神不足）。就像这种情况，就完全是可以通过增强意志、锻炼身体等方式进行改变的。</p>
<p>其实这篇对我的意义在于，一是说明了以貌取人虽然不见得对，但是仍然是有道理的；二是要认识到自身形态举止的缺点，进行针对性的改造，以最大实现“整体”的和谐。</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-知人</title>
    <url>/posts/2dee69f0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>臣闻主将之法，务览英雄之心。然人未易知，知人未易。 汉光武聪听之主也，谬于庞萌；曹孟德知人之哲也，弊于张邈。何则？夫物类者，世之惑乱也。故曰：狙者类智而非智也，愚者类君子而非君子也，戆者类勇而非勇也。亡国之主似智；亡国之臣似忠；幽莠之幼似禾；骊牛之黄似虎；白骨疑象；碔砆类玉。此皆似是而非也。</p>
<p>《人物志》曰：”轻诺似烈而寡信；多易似能而无效；进锐似精而去速；诃者似察而事烦；许施似惠而无终；面从似忠而退违。此似是而非者也。亦有似非而是者：大权似奸而有功；大智似愚而内明；博爱似虚而实厚；正言似讦而情忠。非天下之至精，孰能得其实也？“</p>
</blockquote>
<blockquote>
<p>孔子曰：”凡人心险于山川，难知于天。天犹有春夏秋冬旦暮之期，人者厚貌深情，故有貌愿而益，有长若不肖，有顺怀而达，有坚而缦，有缓而钅干。“ 太公曰：”士有严而不肖者，有温良而为盗者，有外貌恭敬中心欺慢者，有精精而无情者，有威威而无成者，有如敢断而不能断者，有恍恍惚惚而反忠实者，有倭倭拖拖而有效者，有貌勇狠而内怯者，有梦梦而反易人者。无使不至，无使不遂，天下所贱，圣人所贵，凡人莫知，惟有大明，乃见其际。“ 此士之外貌不与中情相应者也。</p>
</blockquote>
<blockquote>
<p>知士者而有水焉。微察问之，以观其辞；穷之以辞，以观其变，与之间谋，以观其诚；明白显问，以观其德；远使以财，以观其廉；试之以色，以观其贞；告之以难，以观其勇；<strong>醉之以酒，以观其态</strong>。</p>
</blockquote>
<blockquote>
<p>《庄子》曰：”远使之而观其忠；近使之而观其敬；<strong>烦使之而观其能</strong>；<strong>卒然问焉而观其智</strong>；急与之期而观其信；杂之以处而观其色。</p>
</blockquote>
<p>简单地说，就是需要通过实践来验证一个人的才能和品格。</p>
<blockquote>
<p>桓范曰：“夫务名者不能出己之后，是故性同而材倾则相援而相赖也，性同而势均则相竞而相害也。” 此为同体之变，不可不察也。</p>
</blockquote>
<blockquote>
<p>夫圣贤所美，莫美乎聪明。聪明之所贵，莫贵乎知人。知人识智，则众材得其序，而庶绩之业兴矣。…… 察其所安，观其所由，以知居止之行。率此道也，人焉庾哉，人焉庾哉？</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>说文解字第一册笔记</title>
    <url>/posts/27938e11/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>果然是书非借不能读也。说文解字这一套书买来就没怎么看过了。哈哈哈，类似了买了健身卡就感觉自己锻炼了一样。</p>
<span id="more"></span>
<p><strong>才</strong>：<br>
才，草木之初也。<br>
象形字，上面一横表示土地，植物嫩芽刚刚出土而枝叶尚未出土的样子。<br>
原义是草木初生。延申为木料或木料的质性，人或物的质性。</p>
<p><strong>奉</strong>：<br>
奉，承也。<br>
金文似用双手捧着禾麦奉献给神祖之行，会向神祖拜祭祷告、祈求丰收之意。</p>
<p><strong>与</strong>：<br>
与，赐予也。一勺为与。<br>
一双手把器物交给一双手的意思。<br>
原义是赐给、给予。授人以物，除了是对对方的肯定之外，甚至还可能想跟对方结交，所以延申出赞许、嘉奖、交往、结交之意。</p>
<p><strong>本</strong>：<br>
本，木下曰本<br>
根本，根本，本就是根。</p>
<p><strong>考</strong>：<br>
考，老也。<br>
甲骨文为老人扶杖之形。</p>
<p><strong>北</strong>：<br>
北，乖也。从二人相背。<br>
两个人背靠背，是”背“的本字。<br>
打了败仗逃跑时总是以背对敌，”北“由此延申指败、败逃。例如败北。<br>
古代君主面朝南坐，臣子面君时则面朝北，所以对人称臣为”北面“</p>
<p><strong>卑</strong>：<br>
卑，贱也。<strong>执事</strong>也。<br>
金文似左手持一粗糙的酒器之形，会执事供役使之意。后延申为地位低微</p>
<p><strong>夭</strong>：</p>
<p>​	夭，屈也。</p>
<p>​	甲骨文字形似一个人弯曲双臂摆动的样子。</p>
<p>夭的原义是屈。但是屈过头了，就会折断。由此引申为折、短命，如“夭折”。</p>
<p>夭的字形，好似在跳舞的样子，所以也形容女子美丽姣好，也表示花开茂盛。</p>
<p><strong>州</strong>：<br>
州,水中可居曰州，周绕其旁，从重川。昔尧遭洪水，民居水中高土，或者曰九州。</p>
<pre><code>州，水中陆地。后来大禹将其领域划分为九州，之后九州就泛指天下。
</code></pre>
<p><strong>乡</strong>：<br>
甲骨文似两个人对着盛有食物的器皿，会两人相对而食之意。<br>
原义是两人相对而食。延申泛指用酒食款待别人。</p>
<p><strong>习</strong>：<br>
习，数飞也。<br>
甲骨文为鸟儿在日光下练习飞翔之意。<br>
后引申为反复练习、钻研。</p>
<p><strong>承</strong>：<br>
承，奉也，受也。<br>
甲骨文似一个屈膝的人作授物之形，下有一双手做出接受的样子。<br>
原义是<strong>捧</strong>，也延申为继承，如“汉承秦制”。<br>
承还可以表示顺从、侍奉。如“承欢膝下”。</p>
<p><strong>民</strong>：<br>
民，众萌也。<br>
众人懵懂无知的样子。<br>
金文似以锐物刺左目之形。古时候，俘获敌人则刺瞎其左眼用为奴。所以“民”的原义是奴隶。</p>
<p><strong>卒</strong>：<br>
卒，隶人给事者衣为卒。<br>
原指带有标记的衣服（叉号），也特指穿这种衣服供役使的隶役。也特指士兵。</p>
<p><strong>真</strong>：<br>
甲骨文为人从鼎中取食美味之意。<br>
原义指美食，由美食的原质原味延申为本质、本性。</p>
<p><strong>协</strong>：<br>
协，众之同和也。<br>
甲骨文似三耒并耕之形，会合力耕种之意。</p>
<p><strong>企</strong>：<br>
企，举踵也。<br>
踮起脚尖的意思。如“企盼”，“企鹅”，“企及”</p>
<p><strong>位</strong>：<br>
位，列中庭之左右谓之位。<br>
位，排列在朝廷中的左右位置叫做位。原义是朝廷中群臣排班所处的序列、地方。延申指所处的官职、级别。还特指封建君主的统治地位。“即位” 就是指登上帝位，“在位”就是居于帝王之位。<br>
位也延申指人在某一社会领域中所处的位置或者等级。例如“岗位”、”学位“<br>
位还指抽象的名分、地位。</p>
<p><strong>仔</strong>：<br>
原义是人背子，甲骨文是人背小孩的样子。</p>
<p><strong>保</strong>：<br>
保，养也<br>
甲骨文士大人手臂向后抱一小儿。</p>
<p><strong>儿</strong>；<br>
儿，孺子也。<br>
甲骨文是一个向左站着的大头娃娃，头顶中间是开口的，表示婴儿脑囟骨还没有长在一起。<br>
【原来婴儿出生后颅骨之间结合不紧密，存有空隙，长见识了。】</p>
<p><strong>先</strong>：<br>
先，前进也。<br>
甲骨文像是一个走路的样子。“先”的原义是在前引导，走在前面。</p>
<p><strong>公</strong>：<br>
公，平分也。<br>
甲骨文是平分器皿中的东西之意。<br>
原义是无私，延申为公正。</p>
<p><strong>周</strong>：<br>
周，密也。<br>
“周”是象形字。甲骨文似在玉片上雕刻出纹饰，四点则象征雕刻的图画和花纹有疏密。</p>
<p><strong>友</strong>：<br>
友，同志为友。<br>
甲骨文和金文都是方向相同的两只右手靠在一起的样子，会志同道合地做一件事情之意。</p>
<p><strong>冤</strong>：<br>
冤，屈也。<br>
兔子在覆罩之下不能跑。</p>
<p><strong>危</strong>：<br>
危，在高而惧也。<br>
人站在高处有危险而感到害怕之意。</p>
<p><strong>孝</strong>：<br>
孝，善事父母者<br>
甲骨文似长者长头发的老人，金文似孩子背着老人的样子。</p>
<p><strong>奴</strong>：<br>
“奴”是会意字。金文字形左为“女”，右下为“又”（手）向她抓去，会抓住了人之意。</p>
<p><strong>驳</strong>：<br>
驳，马色不纯。<br>
甲骨文为马身上有交错的花纹之意。<br>
原指马的毛色不纯，延申成混杂、杂乱、庞杂。</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>说文解字</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-量才</title>
    <url>/posts/c7a98fc8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>孙武曰：“主孰有道？”</p>
<p>昔汉王见围荥阳，谓陈平曰：“天下纷纷，何时定乎？“ 平曰：”项王为人恭敬爱人，士之廉节好礼者多归之。至于行功赏爵邑，重之，士亦以此不附。今大王慢人少礼，士之愚钝嗜利无耻者亦多归汉。诚宜各去两短，集其两长，天下指麾即定矣。“</p>
<p>魏太祖谓郭嘉曰：”袁本初地广兵强，吾欲讨之，力不能敌，何如？“ 嘉对曰：”刘，项之不敌，公所知也，汉祖惟智胜。项羽虽强，终为所擒。嘉窃料之，绍有十败，公有十胜，虽兵强，无能为也。绍繁礼多仪，公体任自然。此道胜一也。绍虽兵强，绍以逆动，公奉顺以率天下，此义胜二也。汉末政失于宽，绍以宽济，故不摄；公纠之以猛，而上下，而上下知制，此治胜三也。绍外宽内忌，用人而旋疑之，所任唯亲戚子弟耳；公外简易而内机明，用人无疑，唯才能所宜，不问远近，此度胜四也。绍多计少决，失在事后；公策得辄行，应变无穷，此谋胜五也。绍因累世之资，高议揖让，以收名誉，士之好言饰外者多归之；公至心待人，推诚而行之，不为虚美，以俭率下，与有功者无所吝，士之忠正远见而有实者皆愿为用，此德胜六也。绍见人饥寒，恤念之情形于颜色，其所不见，虑或不及，所谓妇人之仁耳；公于目前小事，时有所忽，至于大事，于四海相接，恩之所加，皆过其望，虽所不见，虑之所周，无不济也，此仁胜七也。绍大臣争权，谗言惑乱；公御下以道，浸润而行，此明胜八也。绍是非不可知；公所是进之以礼，所不是正之以法，以文胜九也。绍好为虚势，不知兵要；公以少克众，用兵如神，军人恃之，敌人畏之，此武胜十也。“ 曹公曰：”吾知之，绍为人志大而智小，色厉而胆薄，忌刻而少威，兵多而分画不明，将骄而政令不一，土地虽广，粮食虽丰，适所以谓吾奉也。“ 杨阜曰：”袁公宽而不断，好谋而少决。不断而无威，少决则后事。今虽强，终为所擒。曹公有雄才远略，决机无疑，法一兵精，必能济大事也。“</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-品目</title>
    <url>/posts/a8d66a27/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>夫天下重器，王者大统，莫不劳聪明于品材，或安逸于任使。故孔子曰：“人有五仪：有庸人，有士人，有君子，有圣，有贤。审此五者，则治道毕矣。”</p>
<p>所谓庸人者，心不存慎终之规，口不吐训格之言，不择贤以托身，不力行以自定，见小暗大而不知所务，从物如流而不知所执。此则庸人也。</p>
<p>所谓士人者，心有所定，计有所守。虽不能尽道术之术，必有率也；虽不能遍百善之美，必有处也。是故智不务多，务审其所知；言不务多，务审其所谓【所谓，言之要也】；行不务多，务审其所由。智既知之，言既得之【得其要也】，行既由之，则若性命形骸之不可易也。富贵不足以益，贫贱不足以损，此则士人也。</p>
<p>所谓君子者，言必忠信而心不忌【忌，怨害也】，仁义在身而色不伐，思虑通明而辞不专，笃行信道，自强不息，油然若将可越而终不及者。此君子也。【孙卿曰：“夫君子能为可贵，不能使人必贵己；能为可信，不能使人必信己；能为可用，不能使人必用己。故君子耻不修，不耻见污；耻不信，不耻不见信；耻不能，不耻不见用。不诱于誉，不怨于诽，率道而行，端然正己，谓之君子也。”】</p>
<p>所谓贤者，德不逾闲【闲，法也】，行中规绳，言足法于天下而不伤于其身【言满天下，无口过也】，道足化于百姓而不伤于本【本亦身也】，富则天下无菀财【菀：积】，施则天下无病贫。此谓贤者也。</p>
<p>所谓圣者，德合天地，变通无方，究万物之终始，协庶品之自然，敷其大道而遂成情性，明立日月，化行若神，下民不知其德，睹者不识其邻。此圣者也。</p>
</blockquote>
<blockquote>
<p>清节之流，不能弘恕，好尚讥诃，分别是非，是谓臧否。子夏之徒是也。法家之流，不能创思图远，而能受一官之任，错意施巧，是为伎俩。张敞、赵广汉是也。术家之流，不能创制垂则，而能遭变用权。权智有余，公正不足，是谓智意。陈平、韩安国是也。能文著述，是谓文章，司马迁、班固是也。能传圣人之业，而不能干事施政，是谓儒学。毛公、贯公是也。辩不入道，而应对给资，是谓口辩。乐毅、曹丘生是也。胆力绝众，才略过人，是谓骁雄。白起、韩信是也。</p>
</blockquote>
<blockquote>
<p>《家语》曰：“昔者明王必尽知天下良士之名，既知其名，又知其实，然后用天下之爵以尊之，则天下理也。”此之谓矣。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-任长</title>
    <url>/posts/4553ed87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>臣闻料才核能，治世之要。自非圣人，谁能兼兹百行，备贯众理乎？故舜合群司，随才授位；汉述功臣，三杰异称。况非此俦，而可备责耶？</p>
</blockquote>
<blockquote>
<p>夫刚略之人，不能理微，故其论大体则弘略而高远，历纤理微则宕往而疏越；亢厉之人，不能回挠，其论法直则括据而公正，说变通则否戾而不入；宽恕之人，不能速捷，论仁义则弘详而长雅，趋时务则迟缓而不及；好奇之人，横逸而求异，造诡谲则倜傥而瑰壮，案清道则诡常而恢迂。</p>
<p>又曰：王化之政，宜于统大，以之理小则迂；策术之政，宜于理难，以之理平则无奇；矫亢之政，宜于治侈，以之治弊则残；公刻之政，宜于纠奸，以之治边则失其众；威猛之政，宜于讨乱，以之治善则暴；伎俩之政，宜于治富，以之治贫则民劳而下困。此已上皆偏材也。</p>
</blockquote>
<blockquote>
<p>魏武诏曰：“进取之士，未必能有行。有行之士，未必能进取。陈平岂笃行，苏秦岂守信耶？而陈平定汉业，苏秦济弱燕者，任其长也。”</p>
<p>由此观之，使韩信下帏，仲舒当戎，于公驰说，陆贾听讼，必无曩时之勋，而显今日之名也。故“任长”之道，不可不察。</p>
</blockquote>
<blockquote>
<p>议曰：魏恒范云：“帝王用人，度世授才。争夺之时，书策为先。分定之后，忠义为首。故晋文行舅犯之计而赏雍季之言，高祖用陈平之智而托后于周勃。” 古语云：“守文之代，德高者位尊；仓促之时，功多者赏厚。”  诸葛亮曰：“老子长于养性，不可以临危难；商鞅长于理法，不可以从教化。苏张长于驰辞，不可以结盟誓；白起长于攻取，不可以广众；子胥长于图敌，不可以谋身；尾生长于守信，不可以应变；王嘉长于遇明君，不可以事暗主；许子将长于明臧否，不可以养人物。”  此任长之术也。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-原序</title>
    <url>/posts/48e2ba4b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>匠臣舆者，忧人不贵；做箭者，恐人不伤。彼其有爱憎哉？实技业驱之然耳。是知当代之士、驰骛之曹，书读纵横，则思诸侯之变；艺长奇正，则念风尘之会。此亦向时之论，必然之理矣。故先师孔子深探其本、忧其末，遂作《春秋》，大乎工道；制《孝经》，美乎德行。防萌杜渐，预有所抑。</p>
<p>斯圣人制作之本意也。</p>
<p>然作法于理，其弊必乱。若至于乱，将焉救之？是以御世理人，罕闻沿袭。三代不同礼，五霸不同法。非其相反，盖以救弊也。是故国容一致，而忠文之道必殊；圣哲同风，而皇王之名或异。岂非随时投教沿乎此，因物成务牵乎彼？沿乎此者，醇薄继于所遭；牵乎彼者，王霸存于所遇。故古之理者，其政有三：王者之政化之；霸者之政威之；强国之政胁之。各有所施，不可易也。管子曰：“圣人能辅时不能违时。智者善谋，不如当时。”邹之曰：“政教文质，所以匡救也。当时则用之，过则舍之。”由此观之，当霸者之朝而行王者之化，则悖矣。当强国之世而行霸者之威，则乖矣。若时逢狙诈，正道陵夷，欲宪章先王，广陈德化，是犹待越客以拯溺，白大人以救火（等待水性好的人来救溺水者，请求尊贵的人来救火）。善则善矣，岂所谓通于时变欤？</p>
<p>夫霸者， 驳道也，盖白黑杂合，不纯用德焉。期于所成，不问所以；论于大体，不守小节。虽称仁引义不及三王，扶颠定倾，其归一揆。恐儒者溺于所闻，不知王霸殊略，故叙以长短术，以经论通变者，并立题目总六十有三篇，合为十卷，名曰《反经》。大旨在乎宁固根蒂，革易时弊，兴亡治乱。</p>
<p>具载诸篇，为沿袭之远图，作经济之至道，非欲矫世夸欲，希声慕名。辄露见闻，逗机来哲。凡厥有位，幸望详焉。</p>
</blockquote>
<p>《反经》是我最喜欢的古文书，这篇序就很先声夺人，不明觉厉。拜服老祖宗的智慧！</p>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>反经-第一卷大政-大体</title>
    <url>/posts/112d874c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>《反经》节选</p>
<span id="more"></span>
<blockquote>
<p>臣闻老子曰：“以正理国，以奇用兵，以无事取天下。”荀卿曰：“人主者，以官人为能者也；匹夫者，以自能为能也。”</p>
</blockquote>
<blockquote>
<p>《人物志》曰：“夫一官之任，以一味协五味；一国之政，以无味协五味。故臣以自任为能；君以能用人为能。臣以能言为能；君以能听为能。臣以能行为能；君以能赏罚为能。所以不同，故能君众能也。”</p>
</blockquote>
<blockquote>
<p>故曰，知人者，王道也；知事者，臣道也；无形者，物之君也；无端者，事之本也。鼓不预五音，而为五音主；有道者，不为五官之事，而为理事之主。君守其道，官知其事，有自来矣。</p>
<p>先王知其如此也，故用非其有如己有之，通乎君道者也。</p>
</blockquote>
<blockquote>
<p>议曰：《淮南子》云：“巧匠为宫室，为圆必以规，为方必以矩，为平直必以准绳。功已就矣，而不知规矩准绳，而赏巧匠。宫室已成，不知巧匠，而皆曰某君某王之宫室也。”</p>
<p>孙卿曰：“夫人主故欲得善射中微，则莫若使羿；欲得善御致远，则莫若使王良；欲得调一天下，则莫若聪明君子矣。其用智甚简，其为事不劳，而功名甚大。”此能用其非其有如已有者也。</p>
</blockquote>
<blockquote>
<p>人主不通主道者则不然。自为之则不能任贤，不能任贤，则贤者恶之，此功名之所以伤，国家之所以危。</p>
</blockquote>
<blockquote>
<p>议曰：“《申之》云：君知其道也，臣知其事也。十言十当，百言百当者，人臣之事也，非人君之道也。”《尸子》云：“人臣者，以进贤为功也；君者，以用贤为功也。”</p>
</blockquote>
<blockquote>
<p>汤武一日而尽有夏商之财，以其地封，而天下莫敢不悦服；以其财赏，而天下皆竞劝，通乎用非其有也。</p>
</blockquote>
<blockquote>
<p>议曰：孙卿曰：“修礼者王，为政者强，取人者安，聚敛者亡。故王者富人；霸者富士；仅存之国富大夫；亡国者富筐箧、实府库。是谓上溢下漏。” 又曰：“天子不言多少，诸侯不言利害，大夫不言得失。”</p>
</blockquote>
<blockquote>
<p>魏文侯御廪灾，素服避正殿，群臣皆哭。公子成夫趋入贺曰：“臣闻天子藏于四海；诸侯藏于境内。非其所藏，必有火灾，必有人患。幸无人患，不亦善乎。”  孔子曰：“百姓足，君孰与不足？” 由此言之，夫圣王以其地封，以其财赏，不与人争利，乃能通于主道，是用非其有者也。</p>
</blockquote>
<blockquote>
<p>故称，设官分职，君之体也；委任责成，君之体也；好谋无倦，君之体也；宽以得众，君之体也；含垢藏疾，君之体也。君有君人之体，其臣畏而爱之，此帝王所以成业也。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂学旁收</category>
        <category>反经</category>
      </categories>
      <tags>
        <tag>杂学旁收</tag>
      </tags>
  </entry>
  <entry>
    <title>序 - 构建个人博客的原因和过程</title>
    <url>/posts/7ce416b6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>第一篇博客，扯了一些闲天。</p>
<span id="more"></span>
<h1>为什么开通个人博客？</h1>
<p>我在B站关注了一位up主，名字叫codesheep（程序羊），他是华科出来的硕士（自称”资质平平“，感觉自己都不用活了）。自称看了他的视频，才产生了构建个人博客的想法。我看他宣传开通个人博客的视频，应该是在去葫芦岛旅游前（2019年7月27号）。按照大佬的说法，开通个人博客，有百利而无一害，比如避免自己重复掉坑、能够吸引一点关注、可能对其他人有帮助、结交同性朋友等。我想了想，感觉说得都很对，我没办法反驳，心里就种下了种子。等从葫芦岛回来，有空余时间的时候就可以动手做了。<br>
本科毕业的时候，我从一件事情上吸取到了一个教训。那时候我发现我有很多买回来的书，就一直放着，很多都没看，就一直放着，直到毕业。最后，我感觉实在有点累赘，就或卖或送打发了。这些买回来的书，如果一开始没去看，可能我永远都不会去翻他。其他事情应该也是一样的吧。对于想做的事，一开始不着手去做的话，这辈子都不会做了吧。毕竟，一辈子其实想想也没有多长。</p>
<h1>开通个人博客的过程</h1>
<p>当时好像程序羊还没有发布详细的构建个人博客的视频，我就从知网找了个教程，看着比较详细，那上面第一步就说要有个域名。然后，我就去了阿里云上去查找注册域名，本来想注册自己的名字 <a href="https://www.zhouzw.com">zhouzw</a>，没想到已经被注册了。然后我就不知道用啥英文了，毕竟我没有正儿八经起过英文名。我就找到了我的词汇课的课件，第一个词根是-vict（胜利的意思），一查也被注册了。后面对这个词根的注解上说，来自于希腊语vincere，就用了这个不是英文单词的词。之后我发现阿里云上域名都是按年买的，我感觉这是不是坑我（我刚开始以为应该是注册了就是终生的）。谷歌了一下，才发现域名都是按年买的，逾期不付费会回收，尴尬。为什么选.fun这个后缀呢，当然是希望自己开开心心（假的，因为便宜，我一次性买了10年才花了179，<a href="http://xn--6iq8fuf485iowl.com">相比于什么.com</a>,.cn这种正规后缀，真的是好便宜！)<br>
然后按照知乎的流程去走（其实什么软件、命令都不懂），从4点到了将近7点（我一般5点多去吃饭），并没有弄通。整个人就有点不太好，虽然其实也没搞多长时间。后来又是看了程序羊的视频，才算是最终构建好了。  搭建好了个人博客，当时发了个微信。然后到现在又过了一个多礼拜，这期间主要是其它事和学习shell编程啥的。我总是想先把手头的东西弄完或学完，再弄别的事。然后就一直到了今天。</p>
<h1>用个人博客做什么</h1>
<p>现在初步打算把自己一年多的学习的东西，总结提取重点，发到这个个人博客上来。当然都是一些很基础的东西。参考别人的博客，我对我这个博客的设定为总结，总结自己学习的东西，总结自己遇到的坑，总结一些实践经验（如果有的话），偶尔总结一下自己矫情的感想。</p>
]]></content>
  </entry>
</search>
